{"id": "dtcGzX", "name": "Colorful Rectangular Pillars", "author": "gelami", "description": "Fast traversal of a grid of rounded pillars / rectangular prisms\nFeatures anti-aliasing using TAA (or FXAA, see Common)", "tags": ["3d", "raytracing", "grid", "box", "aa", "fxaa", "taa"], "likes": 14, "viewed": 340, "published": 3, "date": "1682886690", "time_retrieved": "2024-07-30T17:58:17.147577", "image_code": "\n// Colorful Pillars - gelami\n// https://www.shadertoy.com/view/dtcGzX\n\n/*\n * Fast traversal of a grid of rounded pillars / rectangular prisms\n * Features anti-aliasing using TAA (or FXAA, see Common)\n *\n * Mouse drag to look around\n * Defines in Common\n * \n * Have a few ideas to improve upon this, was thinking about doing an implicit\n * quadtree structure to speed up the traversal without storing anything in a buffer\n * \n * By have a value for each level of detail and multiply with the levels above it,\n * You could ensure the value in the LoD would not exceed values the below it\n *\n * You could also do interval arithmetic, to be able to use all sorts of functions\n * Also if you store 6 levels in the Cubemap buffer,\n * you could do a cascaded heightmap/clipmap setup, where each cubemap face is an LoD\n * \n * Traversal method is based from\n * Gaussian Weights and Fake AO - reinder\n * https://www.shadertoy.com/view/Wtj3Wc\n * \n * TAA from my old shader\n * Temporal AA Study - gelami\n * https://www.shadertoy.com/view/DsfGWX\n *\n * FXAA implementation from\n * https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n * https://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n * \n *\n *\n */\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    ivec2 fp = ivec2(fragCoord);\n    \n    #if AA == 1\n    vec3 col = FXAA(iChannel0, uv, iResolution.xy).rgb;\n    #elif AA == 2\n    vec3 col = texture(iChannel1, uv).rgb;\n    #else\n    vec3 col = texture(iChannel0, uv).rgb;\n    #endif\n        \n    //col = col / (1.0 - col);\n    col = mix(col, smoothstep(vec3(0), vec3(1), col), 0.8);\n    \n    //col = ACESFilm(col);\n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define ROUNDED\n#define RADIUS 0.06\n#define MOTION\n\n// 0 = No AA\n// 1 = FXAA\n// 2 = TAA\n#define AA 2\n\n//#define NO_MOUSE\n\n#define MIN_HEIGHT 0.01\n#define MAX_HEIGHT 8.0\n\n#define STEPS 512\n#define MAX_DIST 1000.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nstruct HitInfo\n{\n    float t;\n    vec3 normal;\n    vec2 tp;\n};\n\n// Rounded box ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 pos, in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n    \n    // Faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return 0.0;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    float t = MAX_DIST;\n    \n    // Corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b*b - c;\n        if( h>0.0 ) t = - b -sqrt(h);\n    }\n    \n    vec3 a = dd.yzx + dd.zxy;\n    vec3 b = od.yzx + od.zxy;\n    vec3 c = oo.yzx + oo.zxy - ra2;\n    vec3 h = b*b - a*c;\n    \n    // Edge X\n    if( h.x>0.0 )\n    {\n        float ht = (-b.x - sqrt(h.x)) / a.x;\n        if( ht>0.0 && ht<t && abs(ro.x+rd.x*ht)<size.x ) t = ht;\n    }\n    \n    // Edge Y\n    if( h.y>0.0 )\n    {\n        float ht = (-b.y - sqrt(h.y)) / a.y;\n        if( ht>0.0 && ht<t && abs(ro.y+rd.y*ht)<size.y ) t = ht;\n    }\n    \n    // Edge Z\n    if( h.z>0.0 )\n    {\n        float ht = (-b.z - sqrt(h.z)) / a.z;\n        if( ht>0.0 && ht<t && abs(ro.z+rd.z*ht)<size.z ) t = ht;\n    }\n    \n    return t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) {\n    return dot(col, vec3(0.2126729, 0.7151522, 0.0721750));\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n  vec4 a = vec4(1,1,0,0);\n  while (s.x > 0. && s.y > 0.)\n  {\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(vec2(s),coprimes);\n    s = floor(s/coprimes);\n  }\n  return a.zw;\n}\n\n// FXAA implementation from\n// https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n// https://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n#define SPAN_MAX   (8.0)\n#define REDUCE_MIN (1.0/128.0)\n#define REDUCE_MUL (1.0/32.0)\n\nvec4 FXAA(sampler2D tex, vec2 uv, vec2 size)\n{\n    vec2 px = 1.0 / size;\n    vec3 col   = texture(tex, uv).rgb;\n    vec3 col00 = texture(tex, uv + vec2(-0.5) * px).rgb;\n    vec3 col11 = texture(tex, uv + vec2( 0.5) * px).rgb;\n    vec3 col10 = texture(tex, uv + vec2(0.5, -0.5) * px).rgb;\n    vec3 col01 = texture(tex, uv + vec2(-0.5, 0.5) * px).rgb;\n    \n    float lum = luminance(col);\n    float lum00 = luminance(col00);\n    float lum11 = luminance(col11);\n    float lum10 = luminance(col10);\n    float lum01 = luminance(col01);\n    \n    vec2 dir = vec2((lum01 + lum11) - (lum00 + lum10),\n                    (lum00 + lum01) - (lum10 + lum11));\n    \n    float dirReduce = max((lum00 + lum10 + lum01 + lum11) * REDUCE_MUL, REDUCE_MIN);\n    \n    float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = clamp(dir * rcpDir, -SPAN_MAX, SPAN_MAX) * px;\n    \n    vec4 A = 0.5 * (\n        texture(tex, uv - dir * (1.0/6.0)) +\n        texture(tex, uv + dir * (1.0/6.0)));\n    \n    vec4 B = A * 0.5 + 0.25 * (\n        texture(tex, uv - dir * 0.5) +\n        texture(tex, uv + dir * 0.5));\n    \n    float lumMin = min(lum, min(min(lum00, lum10), min(lum01, lum11)));\n    float lumMax = max(lum, max(max(lum00, lum10), max(lum01, lum11)));\n    \n    float lumB = luminance(B.rgb);\n\t\n    return ((lumB < lumMin) || (lumB > lumMax)) ? A : B;\n}\n\n// Taken from https://www.shadertoy.com/view/MtVGWz\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += texture(tex, vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += texture(tex, vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += texture(tex, vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += texture(tex, vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\nvec2 getJitter(vec2 pos, int frame)\n{\n    pos = floor(pos);\n    return halton(vec2(frame%8+1)) - .5;\n}\n\nvec3 getLookAtPos(float time)\n{\n    return vec3(time * 1.0, 6, time * 8.0);\n}\n\nfloat getPillarMotion(vec2 p, float time)\n{\n    return sin((time * 0.4 + hash12(p * 23.23)) * TAU)*0.1;\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "\nfloat map(vec2 p)\n{\n    float h = texture(iChannel0, 0.25 * p / iChannelResolution[0].xy).r;\n    h = smoothstep(0.3, 0.85, h)*0.8+0.1;\n    float h2 = texture(iChannel0, 0.1 * p / iChannelResolution[0].xy).r;\n    h2 = smoothstep(0.3, 0.85, h2);\n    //h *= 0.3+0.7*h2;\n    \n    #ifdef MOTION\n    h += getPillarMotion(p, iTime);\n    #endif\n    \n    //float h = hash12(p * 0.033);\n    return clamp(h * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sp = ivec2(fragCoord);\n    \n    vec3 ro = vec3(0, 0, 16);\n    vec3 lo = getLookAtPos(iTime);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = -PI * .7 + iTime * .3;\n    float ay = PI * 0.16;\n    \n    #ifndef NO_MOUSE\n    if (iMouse.z > 0.0 && iMouse.x > 4.0)\n        ax = -m.x * TAU;\n    \n    if (iMouse.z > 0.0 && iMouse.y > 4.0)\n        ay = -m.y * PI + PI * 0.5;\n    #endif\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    float h = map(floor(ro.xz));\n    if (ro.y < h)\n    {\n        ro.y = h + 0.05;\n    }\n    \n    if (sp.y != 0) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    if (sp.x == 0)\n        fragColor = vec4(ro, 1);\n    else if (sp.x == 1)\n        fragColor = texelFetch(iChannel1, ivec2(0, 0), 0);\n    else\n        fragColor = vec4(0, 0, 0, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-04-29 21:51:26\n\n\n\nfloat map(vec2 p)\n{\n    float h = texture(iChannel0, 0.25 * p / iChannelResolution[0].xy).r;\n    h = smoothstep(0.3, 0.85, h)*0.8+0.1;\n    float h2 = texture(iChannel0, 0.1 * p / iChannelResolution[0].xy).r;\n    h2 = smoothstep(0.3, 0.85, h2);\n    //h *= 0.3+0.7*h2;\n    \n    #ifdef MOTION\n    h += getPillarMotion(p, iTime);\n    #endif\n    \n    //float h = hash12(p * 0.033);\n    return clamp(h * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\nbool trace(vec3 ro, vec3 rd, out float t, out vec3 normal, out vec2 tp)\n{\n    if ((ro.y > MAX_HEIGHT && rd.y > 0.0) || (ro.y < MIN_HEIGHT && rd.y > 0.0))\n        return false;\n    \n    tp = floor(ro.xz);\n    \n    //if (ro.y < map(tp))\n    //    return false;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(rd);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = (ro - vec3(0.5, 0, 0.5)) * ird;\n    \n    t = MAX_DIST;\n    normal = vec3(-1);\n    \n    // Traversal method based from\n    // https://www.shadertoy.com/view/Wtj3Wc\n    int i = 0;\n    for (; i < STEPS; i++)\n    {\n        float d = map(tp) * 0.5;\n        \n        vec3 p = vec3(tp.x, d, tp.y);\n        vec3 s = vec3(0.5, d, 0.5);\n        vec3 n = iro - p * ird;\n        vec3 k = ard * s;\n        \n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        \n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 pos = ro + rd * tN;\n        \n        if (pos.y > MAX_HEIGHT && rd.y > 0.0)\n            return false;\n        \n        if (tN < tF && tN >= 0.0)\n        {\n            #ifndef ROUNDED\n            t = tN;\n            normal = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n            return true;\n            \n            #else\n            \n            const float rad = RADIUS;\n            \n            if (d < MIN_HEIGHT + rad)\n            {\n                t = tN;\n                normal = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n                return true;\n            }\n            \n            vec3 o = p + vec3(0.5, 0, 0.5);\n            vec3 rp = ro - o;\n            float rt = roundedboxIntersect(pos - o, rp, rd, s-rad, rad);\n            if (rt != MAX_DIST)\n            {\n                t = rt == 0.0 ? tN : rt;\n                vec3 pos = rp + rd * t;\n                normal = normalize(roundedboxNormal(pos, s-rad, rad));\n                return true;\n            }\n            #endif\n        }\n        \n        tp += step(t2.xz, t2.zx) * srd.xz;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if AA == 2\n    vec2 o = getJitter(fragCoord, iFrame);\n    #else\n    vec2 o = vec2(0);\n    #endif\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 ndc = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = texelFetch(iChannel1, ivec2(0, 0), 0).rgb;\n    vec3 lo = getLookAtPos(iTime);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, 2));\n\n    vec3 col = vec3(0);\n    \n    float t;\n    vec3 normal;\n    vec2 tp;\n    bool hit = trace(ro, rd, t, normal, tp);\n    \n    vec3 pos = ro + rd * t;\n    \n    vec3 ref = reflect(rd, normal);\n    \n    float rt;\n    vec3 rnormal;\n    vec2 rtp;\n    bool rhit = trace(pos + normal * EPS, ref, rt, rnormal, rtp);\n    \n    float r0 = 0.08;\n    float fresnel = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, normal), 5.0);\n    \n    vec3 rcol = palette(hash12(rtp));\n    rcol *= dot(abs(rnormal), vec3(0.8, 1, 0.9));\n    \n    if (!rhit)\n        rcol = palette(abs(ref.y * 0.5));\n    \n    col = palette(hash12(tp));\n    col *= dot(abs(normal), vec3(0.8, 1, 0.9));\n    \n    col = mix(col, rcol, fresnel);\n    \n    vec3 lcol = vec3(1, 0.8, 0.6) * 1.5;\n    vec3 ldir = normalize(vec3(-1, 1.5, 0.8));\n    //vec3 ldir = normalize(vec3(1, 3, 0.8));\n    \n    float lt;\n    vec3 lnormal;\n    vec2 ltp;\n    bool lhit = trace(pos + (normal + ldir) * EPS, ldir, lt, lnormal, ltp);\n    \n    float diff = max(dot(normal, ldir), 0.0);\n    \n    col *= vec3(diff * float(!lhit) * 0.75 + 0.25) * lcol;\n    col *= 0.2+0.8*smoothstep(0.0, MAX_HEIGHT*0.5, pos.y);\n    \n    float a = 0.3;\n    float b = 0.6;\n    \n    float fog = (a / b) * exp(-ro.y * b) * (1.0 - exp(-t * rd.y * b)) / rd.y;\n    //vec3 fog = 1.0 - exp(-t * (1.0-vec3(0.9, 0.8, 0.5)) * .01);\n    \n    vec3 fogCol = palette(0.5);\n    fogCol = mix(fogCol, palette(abs(-rd.y * 0.5)), 0.8)*0.8+0.2;\n    col = mix(col, fogCol, saturate(fog));\n    \n    if (!hit)\n    {\n        col = palette(abs(rd.y * 0.5));\n        t = MAX_DIST;\n    }\n    //col = normal*0.5+0.5;\n    \n    col = max(col, vec3(0));\n    \n    col = col / (1. + col);\n    fragColor = vec4(col, t);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// TAA implementation from\n// Temporal AA Study - gelami\n// https://www.shadertoy.com/view/DsfGWX\n\n#if 0\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n\n#else\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n#endif\n\nvec3 RGBtoYCoCg(vec3 c)\n{\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\n// From https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 center, in vec3 halfSize)\n{\n// Clip towards AABB center\n#if 0\n    vec3 o = cOld - center;\n    vec3 v = o / halfSize;\n    vec3 a = abs(v);\n    float t = max(a.x, max(a.y, a.z));\n    \n    if (t > 1.)\n        return cNew + o / t;\n    else\n        return cOld;\n#else\n    vec3 r = cOld - cNew;\n    vec3 m = (center + halfSize) - cNew;\n    vec3 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n\n\treturn cNew + r;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 sp = ivec2(fragCoord);\n    \n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 o = getJitter(fragCoord, iFrame);\n\n    vec4 curr = texture(iChannel0, (fragCoord - o) / iResolution.xy);\n\n    vec3 new = RGBtoYCoCg(curr.rgb);\n    \n    vec3 ro = texelFetch(iChannel2, ivec2(0, 0), 0).rgb;\n    vec3 pro = texelFetch(iChannel2, ivec2(1, 0), 0).rgb;\n    \n    vec3 lo = getLookAtPos(iTime);\n    vec3 plo = getLookAtPos(iTime - iTimeDelta);\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    mat3 pmat = getCameraMatrix(pro, plo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, 2));\n\n    vec3 p = ro + rd * curr.a;\n    \n    #ifdef MOTION\n    float h0 = getPillarMotion(floor(p.xz), iTime);\n    float h1 = getPillarMotion(floor(p.xz), iTime - iTimeDelta);\n    \n    p.y += (h1 - h0);\n    #endif\n    \n    vec3 cp = (p - pro) * pmat;\n    vec2 np = 2. * cp.xy / cp.z;\n    vec2 puv = np * vec2(iResolution.y / iResolution.x, 1) * .5 + .5;\n    \n    //vec4 hist = texture(iChannel1, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel1, iResolution.xy, puv);\n    \n    vec3 old = RGBtoYCoCg(hist.rgb);\n    \n    vec3 avg = new;\n    vec3 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec3 tex = RGBtoYCoCg(texelFetch(iChannel0, sp + off[i], 0).rgb);\n    \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec3 sig = sqrt(max(var - avg * avg, vec3(0)));\n    \n    const float g = 0.5;\n    vec3 cmin = avg - sig * g;\n    vec3 cmax = avg + sig * g;\n    \n    vec3 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    \n    vec3 col = iFrame != 0 ? mix(clip, new, a) : new;\n    \n    fragColor = vec4(YCoCgToRGB(col), curr.a);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1246, 1246, 1303, 1303, 1872]], "test": "untested"}
{"id": "DsfGWX", "name": "Temporal AA Study", "author": "gelami", "description": "Old shader I made to learn about TAA\nImplements temporal reprojection and variance clipping\n\nMouse drag to move\nDefines in Common", "tags": ["3d", "taa"], "likes": 24, "viewed": 697, "published": 3, "date": "1682886426", "time_retrieved": "2024-07-30T17:58:18.082078", "image_code": "\n// Temporal AA Study by gelami\n// https://www.shadertoy.com/view/DsfGWX\n\n/*\n * Old shader I made to learn about TAA\n * Implements temporal reprojection and variance clipping\n *\n * Mouse drag to move\n * Defines in Common\n * \n * Resources:\n * Marco Salvi - Temporal Supersampling (Variance Clipping)\n *  - https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf\n * A Survey of Temporal Antialiasing Techniques\n *  - http://behindthepixels.io/assets/files/TemporalAA.pdf\n * Temporal AA and the quest for the Holy Trail\n *  - https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n * High Quality Temporal Supersampling\n *  - https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf\n * Temporal Reprojection Anti-Aliasing in INSIDE\n *  - https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in\n *  - https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\n *\n * Shaders:\n * Enscape Cube - ThomasSchander (TAA Implementation)\n *  - https://www.shadertoy.com/view/4dSBDt\n * Temporal AA + Variance Clipping - Vil\n *  - https://www.shadertoy.com/view/MscSD7\n * Temporal Reprojection - Raxvan\n *  - https://www.shadertoy.com/view/ldtGWl\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef SHOW_COMPARISON\n    if (fragCoord.x - iResolution.x / 2. < 0.)\n        fragColor.rgb = linearTosRGB(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb);\n    else\n#endif\n        fragColor.rgb = linearTosRGB(texelFetch(iChannel1, ivec2(fragCoord), 0).rgb);\n    \n    vec2 s = vec2(240, 160);\n    float sc = 4.0;\n    if (fragCoord.x < s.x && fragCoord.y < s.y)\n    {\n        vec2 p = ((fragCoord - s * .5) / s.y) * s.x / sc;\n        vec2 s = p + iResolution.xy * .5;\n        \n    #ifdef SHOW_COMPARISON\n        if (p.x < 0.)\n            fragColor.rgb = linearTosRGB(texelFetch(iChannel0, ivec2(s), 0).rgb);\n        else\n    #endif\n            fragColor.rgb = linearTosRGB(texelFetch(iChannel1, ivec2(s), 0).rgb);\n        \n    #ifdef SHOW_COMPARISON\n        if (int(floor(p.x)) == 0)\n            fragColor.rgb = vec3(1, 0, 0);\n    #endif\n    }\n    \n#ifdef SHOW_COMPARISON\n    if (int(floor(fragCoord.x - iResolution.x / 2.)) == 0)\n        fragColor.rgb = vec3(1, 0.1, 0.1);\n#endif\n    fragColor.a = 1.0;\n    fragColor.rgb += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Defines\n\n#define CAMERA_MOVEMENT\n//#define OBJECT_MOVEMENT\n\n#define CHECKERS\n//#define FILTERED_CHECKERS\n\n// TAA Settings\n#define ENABLE_TAA\n\n#define JITTER\n#define UNJITTER\n\n#define TEMPORAL_REPROJECT\n//#define REJECT_DISOCCLUSION\n\n#define VARIANCE_CLIPPING\n\n//#define SHOW_DISOCCLUSION\n//#define SHOW_MOTION\n\n#define SHOW_COMPARISON\n\n////////////////\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nvec4 getTextureSmooth(sampler2D tex, vec2 size, vec2 p)\n{\n    p = p * size + .5;\n    \n    vec2 i = floor(p);\n    vec2 f = p - i;\n    \n    // Smoothstep\n    //f = f * f * (3. - 2. * f);\n    \n    // Smootherstep\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    // Smootheststep\n    f = f*f*f*f * (f * (f * (f * -20. + 70.) - 84.) + 35.);\n    \n    // Fast Smootheststep\n    //f = max(min((f - .2) / .6, 1.), 0.);\n    //f = f * f * (3. - 2. * f);\n    \n    p = i + f;\n    \n    p = (p - .5) / size;\n    return texture(tex, p);\n}\n\n// Taken from https://www.shadertoy.com/view/MtVGWz\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += texture(tex, vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += texture(tex, vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += texture(tex, vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += texture(tex, vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\n// Adapted from https://vec3.ca/bicubic-filtering-in-fewer-taps/\nvec4 SampleTextureBSpline(sampler2D tex, vec2 size, vec2 uv)\n{\n    vec2 sp = uv * size;\n    vec2 fc = floor(sp - 0.5) + 0.5;\n    \n    vec2 f = sp - fc;\n    vec2 f2 = f * f;\n    vec2 f3 = f2 * f;\n    \n    vec2 w0 = f2 - 0.5 * (f3 + f);\n    vec2 w1 = 1.5 * f3 - 2.5 * f2 + 1.0;\n    vec2 w3 = 0.5 * (f3 - f2);\n    vec2 w2 = 1.0 - w0 - w1 - w3;\n    \n    vec2 s0 = w0 + w1;\n    vec2 s1 = w2 + w3;\n    \n    vec2 f0 = w1 / (w0 + w1);\n    vec2 f1 = w3 / (w2 + w3);\n    \n    vec2 t0 = fc - 1.0 + f0;\n    vec2 t1 = fc + 1.0 + f1;\n    \n    t0 /= size;\n    t1 /= size;\n    \n    return texture(tex, vec2(t0.x, t0.y)) * s0.x * s0.y +\n           texture(tex, vec2(t1.x, t0.y)) * s1.x * s0.y +\n           texture(tex, vec2(t0.x, t1.y)) * s0.x * s1.y +\n           texture(tex, vec2(t1.x, t1.y)) * s1.x * s1.y;\n}\n\n// https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat IGN(vec2 p, int frame)\n{\n    frame = frame % 64; // need to periodically reset frame to avoid numerical issues\n    float x = p.x + 5.588238 * float(frame);\n    float y = p.y + 5.588238 * float(frame);\n    return fract(52.9829189 * fract(0.06711056 * x + 0.00583715 * y));\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n  vec4 a = vec4(1,1,0,0);\n  while (s.x > 0. && s.y > 0.)\n  {\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(vec2(s),coprimes);\n    s = floor(s/coprimes);\n  }\n  return a.zw;\n}\n\n\nvoid getCameraPosition(out vec3 ro, out vec3 lo, float time )\n{\n\n}\n\nvec2 getJitter(sampler2D ch, vec2 pos, int frame)\n{\n#ifdef JITTER\n    pos = floor(pos);\n    return halton(vec2(frame%8+1)) - .5;\n    //return vec2(IGN(pos, frame), IGN(pos, frame+33));\n    //return texelFetch(ch, (ivec2(pos) + ivec2(13, 27) * frame) % ivec2(1024), 0).xy;\n#else\n    return vec2(0);\n#endif\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec2 saturate(vec2 x)\n{\n    return clamp(x, vec2(0), vec2(0));\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nvec2 sqr(vec2 x)\n{\n    return x*x;\n}\n\nvec3 sqr(vec3 x)\n{\n    return x*x;\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n", "buffer_a_code": "\n// Camera\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sp = ivec2(fragCoord);\n\n    vec3 ro = vec3(0, 0, 3.75);\n    vec3 lo = vec3(0, 1, 0);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    bool mdx = iMouse.z < 0. || iMouse.x == 0.;\n    bool mdy = iMouse.z < 0. || iMouse.y == 0.;\n    \n    float ax = 0.+PI, ay = 0.;\n    \n    if (!mdx)\n        ax = -m.x * TAU;\n    else\n#ifdef CAMERA_MOVEMENT\n        ax = -0.75 * PI - iTime * 0.1 * TAU;\n#else\n        ax = -0.75 * PI;\n#endif\n    if (!mdy)\n        ay = m.y * PI * .5;\n    else\n        ay = 0.2 * PI;\n        \n    ro -= lo;\n    //ro *= mdy ? 1. : mix(.25, 1., m.y);\n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    if (sp.y != 0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    if (sp.x == 0)\n        fragColor = vec4(ro, 1);\n    else if (sp.x == 1)\n        fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Scene rendering\n\nfloat checkers(vec2 p)\n{\n    vec2 id = floor(p);\n    return mod(id.x + id.y, 2.);\n}\n\n// From iq https://www.shadertoy.com/view/XlcSz2\nfloat checkersFiltered( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n\nfloat gyroid(vec3 p)\n{\n    return dot(sin(p), cos(p.yzx));\n}\n\nfloat map(vec3 p)\n{\n    float d = MAX_DIST;\n    d = abs(p.y-.01) - .01;\n    vec3 q = p - vec3(0, 1, 0);\n    vec3 o = vec3(0);\n#ifdef OBJECT_MOVEMENT\n    q -= vec3(0, sin(iTime*.5)*.5, 0);\n    o += vec3(.5) * iTime;\n#endif\n    vec2 s = vec2(4);\n    q.xz = mod(q.xz + s*0.5, s) - s*0.5;\n    \n    float g = (abs(gyroid(q * TAU + o)) - 0.3) / (TAU * 2.);\n    \n    d = smin(d, smax(g, (length(q) - 1.), .01), .5);\n\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 e = vec2(0, EPS);\n    return normalize(\n        vec3(\n            map(p + e.yxx),\n            map(p + e.xyx),\n            map(p + e.xxy)) - map(p)\n        );\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        float d = map(ro + rd * t);\n        \n        t += d;\n    \n        if (abs(d) < EPS || t > MAX_DIST)\n            return t;    \n    }\n    return t;\n}\n\nvec2 texCoords(vec3 p)\n{\n    return p.xz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 o = getJitter(iChannel1, fragCoord, iFrame);\n    \n    #ifdef SHOW_COMPARISON\n    if (uv.x < 0.5)\n        o = vec2(0);\n    #endif\n    \n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = texelFetch(iChannel3, ivec2(0, 0), 0).rgb;\n    vec3 lo = vec3(0, 1, 0);\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    \n    float t = trace(ro, rd);\n    \n    vec3 p = ro + rd * t;\n    \n    vec3 n = normal(p);\n    \n    vec3 col = vec3((n*.5+.5));\n    //col = palette(pow(dot(-rd, n), 1.))*.8+.2;\n    \n#ifdef CHECKERS\n    float sc = 2.5;\n    \n    // From iq https://www.shadertoy.com/view/XlcSz2\n#ifdef FILTERED_CHECKERS\n    vec2 dx_pv = (2. * (fragCoord + o + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 dy_pv = (2. * (fragCoord + o + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n    \n    vec3 ddx_rd = normalize(cmat * vec3(dx_pv, 2));\n    vec3 ddy_rd = normalize(cmat * vec3(dy_pv, 2));\n    // compute ray differentials\n\tvec3 ddx_pos = ro - ddx_rd*dot(ro-p,n)/dot(ddx_rd,n);\n\tvec3 ddy_pos = ro - ddy_rd*dot(ro-p,n)/dot(ddy_rd,n);\n    \n\t// calc texture sampling footprint\t\t\n\tvec2 uv  = texCoords(     p*sc );\n\tvec2 ddx_uv = texCoords( ddx_pos*sc ) - uv;\n\tvec2 ddy_uv = texCoords( ddy_pos*sc ) - uv;\n    \n    float c = checkersFiltered(uv, ddx_uv, ddy_uv);\n#else\n    float c = checkers(p.xz * sc);\n#endif\n    vec3 ch = mix(vec3(.05), vec3(1), c);\n\n    col *= ch;\n#else\n    //col *= sRGBToLinear(texture(iChannel2, p.xz).rgb);\n#endif\n    \n    t = clamp(t, EPS, MAX_DIST);\n    \n    if (t >= MAX_DIST)\n        col = vec3(0.1);\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    fragColor = vec4(col, t);\n}", "buffer_b_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// TAA\n\n#if 0\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n\n#else\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n#endif\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co / 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg / 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\n    float t = ycocg.r - ycocg.b / 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g / 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\nvec3 RGBtoYCoCg(vec3 c)\n{\n    //return rgb2ycocg(c);\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\n    //return ycocg2rgb(c);\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\n#if 0\n// Based on https://www.shadertoy.com/view/MscSD7\n// https://github.com/GameTechDev/TAA/blob/main/MiniEngine/Core/Shaders/TAAResolve.hlsl\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 center, in vec3 halfSize)\n{\n    vec3 dir = (cNew - cOld);\n    \n    vec3 near = (center - cOld) - sign(dir) * halfSize;\n    vec3 tAll = near / dir;\n    tAll = mix(tAll, vec3(1e5), step(tAll, vec3(0)));\n    float t = min(min(tAll.x, tAll.y), tAll.z);\n    \n    if (t >= 1e5)\n        return cOld;\n    \n    t = saturate(t);\n    return cOld + dir * t;\n}\n#else\n// From https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 center, in vec3 halfSize)\n{\n// Clip towards AABB center\n#if 0\n    vec3 o = cOld - center;\n    vec3 v = o / halfSize;\n    vec3 a = abs(v);\n    float t = max(a.x, max(a.y, a.z));\n    \n    if (t > 1.)\n        return cNew + o / t;\n    else\n        return cOld;\n#else\n    vec3 r = cOld - cNew;\n    vec3 m = (center + halfSize) - cNew;\n    vec3 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n\n\treturn cNew + r;\n#endif\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 sp = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 o = getJitter(iChannel2, fragCoord, iFrame);\n\n#ifdef UNJITTER\n    vec4 curr = texture(iChannel0, (fragCoord - o) / iResolution.xy);\n#else\n    vec4 curr = texture(iChannel0, fragCoord / iResolution.xy);\n#endif\n\n    vec3 new = RGBtoYCoCg(curr.rgb);\n\n#ifdef TEMPORAL_REPROJECT\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = texelFetch(iChannel3, ivec2(0, 0), 0).rgb;\n    vec3 pro = texelFetch(iChannel3, ivec2(1, 0), 0).rgb;\n    \n    vec3 lo = vec3(0, 1, 0);\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    mat3 pmat = getCameraMatrix(pro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    \n    vec3 p = ro + rd * curr.a;\n    \n    vec3 cp = (p - pro) * pmat;\n    vec2 np = 2. * cp.xy / cp.z;\n    vec2 puv = np * vec2(iResolution.y / iResolution.x, 1) * .5 + .5;\n    \n    vec2 o2 = getJitter(iChannel2, puv * iResolution.xy, iFrame) / iResolution.xy;\n    \n    vec3 prd = normalize(pmat * vec3(np, 2));\n    \n    //vec4 hist = texture(iChannel1, puv);\n    //vec4 hist = getTextureSmooth(iChannel1, iResolution.xy, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel1, iResolution.xy, puv);\n    \n    vec3 pp = pro + prd * hist.a;\n    \n#ifdef REJECT_DISOCCLUSION\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1.)\n        a = 1.;\n    if (distance(p, pp) > 0.1*curr.a)\n        a = 1.;\n#endif\n\n    vec3 old = RGBtoYCoCg(hist.rgb);\n#else\n    vec3 old = RGBtoYCoCg(texelFetch(iChannel1, sp, 0).rgb);\n#endif\n\n#ifdef VARIANCE_CLIPPING\n    vec3 avg = new;\n    vec3 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec3 tex = RGBtoYCoCg(texelFetch(iChannel0, sp + off[i], 0).rgb);\n    \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec3 sig = sqrt(max(var - avg * avg, vec3(0)));\n    \n    const float g = 1.;\n    vec3 cmin = avg - sig * g;\n    vec3 cmax = avg + sig * g;\n    \n    #if 0\n    vec3 clip = clamp(old, cmin, cmax);\n    #else\n    vec3 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    #endif\n    \n    old = mix(old, clip, 1.);\n#endif\n    \n    vec3 col = iFrame != 0 ? mix(old, new, a) : new;\n#ifdef ENABLE_TAA\n    fragColor = vec4(YCoCgToRGB(col), curr.a);\n#else\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, curr.a);\n#endif\n\n#ifdef SHOW_DISOCCLUSION\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1. ||\n        distance(p, pp) > 0.1*curr.a)\n    {\n        fragColor = vec4(1, 0, 0, curr.a);\n    }\n#endif\n\n#ifdef SHOW_MOTION\n    fragColor = vec4((uv - puv) * 10., 0, curr.a);\n#endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsfGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtt3zf", "name": "Color Stud - Bezold Eff PXIII-1", "author": "Slals", "description": "Bezold effect showing how contrasted color change the appearance of clearer colors (here the red)", "tags": ["interactionofcolor"], "likes": 2, "viewed": 98, "published": 3, "date": "1682884578", "time_retrieved": "2024-07-30T17:58:18.833071", "image_code": "// bricks implementation taken from https://thebookofshaders.com/09/\n// by Patricio Gonzalez Vivo\nvec2 grid(vec2 uv) {\n    uv *= 20.0;\n    \n    uv.x += step(1.0, mod(uv.y, 2.0)) * 0.5;\n    \n    return fract(uv);\n}\nfloat brickSDF(vec2 uv, vec2 s, float f) {\n    s = vec2(0.5) - s * 0.5;\n    vec2 uv2 = smoothstep(s, s + vec2(0.150001 - (0.1 * f)), uv);\n    uv2 *= smoothstep(s, s + vec2(0.150001 - (0.1 * f)), vec2(1.0) - uv);\n    return uv2.x * uv2.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float MY = iMouse.y / iResolution.y;\n    \n    float strokeColor = step(max(0.0, 0.5 - (1.0 - MY)), uv.y - 0.5);\n\n    vec2 g = grid(uv);\n    \n    vec3 red = vec3(1.0, 0.11, 0.133);\n    vec3 color = red * brickSDF(g, vec2(0.9), strokeColor);\n    \n    color = color.r == 0.0 ? vec3(strokeColor) : color;\n    \n    color = (uv.x <= 0.2 || uv.x >= 0.8) || (uv.y >= 0.5 && uv.y <= 0.55) ? vec3(1.0) : color;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtt3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 118, 118, 213], [214, 214, 256, 256, 453], [455, 455, 512, 562, 1072]], "test": "untested"}
{"id": "llSXRz", "name": "discard effect", "author": "rcread", "description": "discard effect", "tags": ["2d"], "likes": 3, "viewed": 122, "published": 3, "date": "1682883274", "time_retrieved": "2024-07-30T17:58:19.843369", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n    float t=iTime;\n    vec2 d = 1. + .5 * vec2( sin(t), cos(t) );\n    i = i / .3 / iResolution.xy - .7;\n    if ( t>.1 ) {\n    \tt = smoothstep(.5,1.,length( i-d ));\n    \tif ( t > .65*d.x ) discard;\n    }\n\to = vec4(cos(d),sin(d)) / length( i );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSXRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[127, 127, 168, 168, 413]], "test": "untested"}
{"id": "ctt3zf", "name": "kaledoscope", "author": "FabriceNeyret2", "description": "click to see the mirror-less scene.", "tags": ["2d", "kaleidoscope", "symmetry", "tuto", "short"], "likes": 23, "viewed": 281, "published": 3, "date": "1682877610", "time_retrieved": "2024-07-30T17:58:20.725012", "image_code": "#define H(s)  fract(1e4*sin(i*vec4(R-17.,R+17.)-s))  // 4 random numbers, seed s\n#define S(v)  O += smoothstep(2./R.y,0.,v)           // AA draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, A,\n          U = ( u+u - R ) / R.y;                     // normalized coordinates\n    vec4  H,h; \n          \n    if (iMouse.z<=0.)                                // 6-rot symmetry + miror\n      U = length(U) * cos( abs( mod( atan(U.y,U.x), 1.05) - .525 ) - .525  + vec2(0,11) );\n    O *= 0.;\n    \n    for( float d, i=0.; i++ < 40.; )                 // loop on objects\n      H = H(17.7) + .2,                              // compute location:\n      A =   ( iTime/3. + 6.28*H.y )                  //   random angle\n          * ( H.zw *2. - 1. ),                       //   random speed\n      h =  H(3.1),\n      d = length( H.x*vec2(cos(A.x),sin(A.y)) - U )  // circle at random dist + radius\n          - .2*h.x,\n      S(abs(d)),                                     // draw\n        h.y<.3 ? S(abs(d-.02))                       // sometime add echo\n      : h.y<.6 ? S(d) *.1 : O;                       // sometime fill\n      \n    O = sqrt(O);                                     // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctt3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 184, 184, 1203]], "test": "untested"}
{"id": "DttGzf", "name": "Electron 2 ", "author": "FabriceNeyret2", "description": "Electron tangle, spinning", "tags": ["belttrickspin12"], "likes": 13, "viewed": 212, "published": 3, "date": "1682874561", "time_retrieved": "2024-07-30T17:58:21.591695", "image_code": "// Variant (reach rest configuration) of https://shadertoy.com/view/cld3zX\n// variant2 (uncomment line32) of https://www.shadertoy.com/view/DstXRs\n// 3-knotted axis variant of https://shadertoy.com/view/DdcXRj\n\n#define N true                                                             // display the triangle normal ( green )\n#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))                         // 2D rotation \n#define rot3(P,A,a)  ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )  // 3D rot around an arbitrary axis\n  \n#define L(q) length(q.xy - vec2(1.2,-1.5*sin(clamp(q.z,-1.57,1.57))) ) -.2 // 3-knot cylinders SDF\n//#define L(q) length(q.xy - vec2(1,0)) -.2                                // 3 no-knot cylinders SDF\n#define d(q)  ( min(                                                       \\\n                  min( r= L((q).yzx), N ? g= max(length(q)-1.5,length(q-dot(q,vec3(1./3.))))-.1 : 1e2 ), \\\n                  min( w= L((q).zxy),                                      \\\n                       b= L((q).xyz)                                       \\\n              )    ) )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., w=0.,r=w,b=w,g=w;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),                          // ray direction\n          p = vec3(0,0,90), q,a,                                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n                            : vec3(-.8,0,0); // vec3(0,1.,0) // vec3(.5,-.5,0)\n        p.yz *= rot(-M.y),                                                 // camera rotations\n        p.xz *= rot(-M.x), \n        D.yz *= rot(-M.y),\n        D.xz *= rot(-M.x); \n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )                        // march scene  \n        q = p,\n#if 1                                                                      // set 0 for no antitwister\n # if 1  // anti-deform with antitwister(0) so as to obtain the \"rest configuration\" at t=4.5\n        a = vec3(sin(0.),0,cos(0.)),                              \n        a = rot3( a, vec3(.71,0,-.71), -3.14/2. ),                           \n        q = rot3( q,a, -3.14 *smoothstep(.05, .6, 1./length(p)) ),\n #endif\n        a = vec3(sin(iTime),0,cos(iTime)),\n        a = rot3( a, vec3(.71,0,-.71), 3.14/2. ),                          // variant\n        q = rot3( q,a, \n               // 3.14 *smoothstep(8., 0., length(p)) ),                   // the magic is there\n                  3.14 *smoothstep(.05, .6, 1./length(p)) ),\n               // 3.14 ),                                                  // test: rot with no antitwister\n#endif\n        q = rot3( q,vec3(.71,0,-.71), .6 ),                                //  make triangle vertical             \n     // q = rot3( q,vec3(.71,0,-.71), .955 ), // acos(1/sqrt(3))                                       \n     // J = inverse( mat3( D(p+e) -q, D(p+e.yxy) -q, D(p+e.yyx) -q ) / e.x ), // Jacobian\n        t = d(q),                                                          \n        p += .2*t*D;                                                       // step forward = dist to obj      \n\n    O *= O*O*2.;                                                           // color scheme\n    O *= vec4( t==r, t==g, t==b, 1)*vec4(2,1,2,1) + float(t==w);\n    if (O.a < 0.) O += .9;                                                 // white background\n} \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dld3zX", "name": "Color Stud - Z dim PXI-3b", "author": "Slals", "description": "Transparence and space illusion :\n\nDepending on the strongness of yellow mix with the vertical bar (y axis), the horizontal bars appears to be under the vertical bar or above.", "tags": ["interactionofcolor"], "likes": 2, "viewed": 157, "published": 3, "date": "1682866257", "time_retrieved": "2024-07-30T17:58:22.664825", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nfloat rectSDF(vec2 uv, vec2 s) {\n    return max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\nfloat fill(float x) {\n    return step(x, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 M = iMouse.xy / iResolution.xy;\n    \n    float fx = fract(uv.x * 12.0);\n    \n    float vRect = fill(rectSDF(vec2(fx, uv.y), vec2(0.8, 1.0)));\n    float hRect = fill(rectSDF(uv - vec2(0.0, M.y), vec2(2.0, 0.05)));\n\n    vec3 color = vec3(1.0);\n    float fix = floor(fx);\n    \n    // hue from https://www.shadertoy.com/view/ll2cDc\n    vec3 vRectColor = cos( 3.0 * uv.x + vec3(0, 23, 21)) - 0.02;\n    vec3 hRectColor = vec3(1.0, 0.855, 0.0);\n    \n    color = vRect * vRectColor;\n    color = hRect == 1.0 ? hRectColor : color;\n    color = hRect * vRect == 1.0 ? vRectColor : color;\n    color = mix(color, hRectColor, hRect * M.y * 1.1);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dld3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 98, 98, 150], [151, 151, 172, 172, 199], [201, 201, 258, 308, 1102]], "test": "untested"}
{"id": "cld3zX", "name": "Electron - by Fabrice Neyret", "author": "MotionMountain", "description": "Wonderful work by Fabrice Neyret, fork of his https://www.shadertoy.com/view/DstXRs\nOnly comments makerd \"CS:\" are mine. Tried to understand the code.\nIt is embedded in the web page https://www.motionmountain.net/research.html#et", "tags": ["belttrickspin12"], "likes": 5, "viewed": 2687, "published": 3, "date": "1682865412", "time_retrieved": "2024-07-30T17:58:23.633236", "image_code": "// 3-knotted axis variant of https://shadertoy.com/view/DdcXRj by Fabrice Neyret\n// Fork of https://www.shadertoy.com/view/DstXRs by Fabrice Neyret\n\n// CS sees the following shortcoming that he wants to be correctd:\n//\n//       (1) The rotating \"triangle\" is not rotated as desired. There should be an instant in time where the structure looks simpler.\n//       There should be a time where the structure looks like https://www.shadertoy.com/view/DtGGDz at time 10.80\n//       (but that shadertoy file has other shortcomings ...)\n//\n//       Changes should be commented and put in a separate shadertoy file that is made public. Accounts at shadertoy are free.\n//\n//       The result will be made public on https://www.motionmountain.net/research.html#et and on the top of that same page.\n//\n//       There will be more such jobs in future - at least a dozen.\n\n#define N true                                                             // display the triangle normal ( green )\n#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))                         // 2D rotation \n#define rot3(P,A,a)  ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )  // 3D rot around an arbitrary axis\n  \n#define L(q) length(q.xy - vec2(1.2,-1.5*sin(clamp(q.z,-1.57,1.57))) ) -.2 // 3-knot cylinders SDF\n//#define L(q) length(q.xy - vec2(1,0)) -.2                                // 3 no-knot cylinders SDF\n#define d(q)  ( min(                                                       \\\n                  min( r= L((q).yzx), N ? g= max(length(q)-1.5,length(q-dot(q,vec3(1./3.))))-.1 : 1e2 ), \\\n                  min( w= L((q).zxy),                                      \\\n                       b= L((q).xyz)                                       \\\n              )    ) )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., w=0., r=w,b=w,g=w;                      // CS: t=9., w=0. is original, no changes for different numbers\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),                          // ray direction - CS: size of triangle\n          p = vec3(0,0,90), q,a,                                           // marching point along ray - CS: observer position\n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n                            : vec3(-.8,0,0); // vec3(0,1.,0) // vec3(.5,-.5,0)   // CS: original was -.8,0,0 perp view with -12,0,0\n        p.yz *= rot(-M.y),                                                 // camera rotations - CS: and orientation\n        p.xz *= rot(-M.x), \n        D.yz *= rot(-M.y),\n        D.xz *= rot(-M.x); \n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )                        // march scene - CS: original is O-=.005, makes shading\n        q = p,\n#if 1                                                                      // set 0 for no antitwister - CS: 1 makes things rotate\n\n        a = vec3(sin(iTime),0,cos(iTime)),                                 // CS: original is  vec3(sin(iTime),0,cos(iTime))\n                                                                           // CS: adding phase has no effect\n        \n        a = rot3( a, vec3(-.71,0,.71), 3.14/2. ),                          // variant - CS: comment out to get different rotation axis\n                                                                           // CS: original is rot3( a, vec3(.71,0,-.71), 3.14/2. )\n                                                                           // CS: sign of vec3 yields different rotation direction\n                                                                           // different sin & cos make green axis tumble\n                                                                           \n        q = rot3( p,a, \n               // 3.14 *smoothstep(8., 0., length(p)) ),                   // the magic is there\n                 3.14 *smoothstep(.05, .6, 1./length(p)) ),                // CS: (.05, .6. 1./length(p)) is original ; 2./ changes surr.\n                //3.14 ),                                                  // test: rot with no antitwister\n#endif\n\n        q = rot3( q,vec3(.71,0,-.71), .6 ),                                // make triangle vertical - CS: other sin & cos have no effect           \n     // q = rot3( q,vec3(.71,0,-.71), .955 ), // acos(1/sqrt(3))                                      \n     // J = inverse( mat3( D(p+e) -q, D(p+e.yxy) -q, D(p+e.yyx) -q ) / e.x ), // Jacobian\n        t = d(q),                                                          \n        p += .2*t*D;                                                       // step forward = dist to obj - CS: number changes blackness\n\n    O *= O*O*2.;                                                           // color scheme - CS: white is more white with *6.\n    O *= vec4( t==r, t==g, t==b, 1)*vec4(2,1,2,1) + float(t==w);\n    if (O.a < 0.) O += .9;                                                 // white background - CS: also works in grey with .+= .777\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cld3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "clcGzf", "name": "Enchanting Red Square (271 ch)", "author": "fenix", "description": "Reproduction/golf attempt of https://twitter.com/remistura/status/1652164132253192193\n\nA spirograph-like rosette/flower emerges from simple transformations applied to a square.", "tags": ["square", "codegolf", "reproduction"], "likes": 8, "viewed": 218, "published": 3, "date": "1682810551", "time_retrieved": "2024-07-30T17:58:24.583695", "image_code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// I saw this tweet and it seemed like a fun Saturday golfing excercise:\n//\n//    https://twitter.com/remistura/status/1652164132253192193\n\nM + .1) * vec4(1, 0, 0, 0); }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M * .99);\n    \n    mat2 m = mat2(sin(iTime - vec4(0, 11, 33, 0)));\n\n    O += smoothstep(3. / R.y, 0.,\n        abs(length(max(u = abs(((u - .5 * R) / R.y * m + vec2(0, .22)) * m) - .2, 0.)) +\n            min(max(u.x, u.y),0.))\n         ) * .2;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M void mainImage( out vec4 O, vec2 u ) { vec2 R = iResolution.xy; O = (texture(iChannel0, u / R)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcGzf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "cl3GRX", "name": "Color Stud - After Image PVIII-2", "author": "Slals", "description": "Focus your eyes on the middle circle. In the transition you will see blue patterns in the white square. This is due to eyes cone fatigue substracting yellow color (red + green) from white, resulting in blue.", "tags": ["interactionofcolor"], "likes": 0, "viewed": 178, "published": 3, "date": "1682798931", "time_retrieved": "2024-07-30T17:58:25.656826", "image_code": "#define PI 3.14159265359\n#define TAU 6.2831853071\n#define REMANENCE_SECONDS 60.0\n\nfloat circleSDF(vec2 uv, float r) {\n    return length(uv - 0.5) * r;\n}\nfloat rectSDF(vec2 uv, vec2 s) {\n    uv = uv * 2.0 - 1.0;\n    return max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\n\nfloat fillAA(float x, float s) {\n    return smoothstep(x - 0.002, x + 0.002, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.43; // why this appears to be the center?\n\n    vec3 color = vec3(0.0);\n    \n    float r = iResolution.x / iResolution.y;\n    vec2 center = vec2(r * 0.5, 0.5);\n \n    vec3 observedColor = vec3(1.0, 0.851, 0.024);\n    \n    float alpha = 1.0;\n    \n    float t = mod(iTime, REMANENCE_SECONDS);\n    if (t > REMANENCE_SECONDS * 0.5) { // remanence\n        observedColor = vec3(1.0);\n    }\n    \n    vec2 loaderOffset = vec2(0.2649, 0.3 + (mod(iTime, REMANENCE_SECONDS * 0.5) / REMANENCE_SECONDS) * 2.0);\n    float loaderLeft = rectSDF(uv2 + loaderOffset, vec2(0.02, 2.0));\n    \n    float circle = circleSDF(fract(uv * 3.0), 0.39);\n  \n    float square = fillAA(rectSDF(uv, vec2(1.0)), 1.0);\n    color = mix(color, vec3(1.0), square);\n    color = mix(color, observedColor, fillAA(circle, 0.2)) * color;\n    color = mix(color, observedColor, smoothstep(loaderLeft, loaderLeft + 0.5, 1.0));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3GRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 117, 117, 152], [153, 153, 185, 185, 262], [264, 264, 296, 296, 346], [348, 348, 405, 455, 1515]], "test": "untested"}
{"id": "Dl33zX", "name": "Wobbly Toroids", "author": "drliquidglitch", "description": "from evvvvil's raymarching boilerplate", "tags": ["basic", "tutorial", "boilerplate", "workshop"], "likes": 2, "viewed": 163, "published": 3, "date": "1682796204", "time_retrieved": "2024-07-30T17:58:26.559413", "image_code": "//GLOBAL VARIABLES\nfloat time;\n//PRIMITIVE FUNCTIONS\nfloat plane(vec3 p,vec3 r){p=min(p,r);return p.y;}\nfloat sphere(vec3 p,float r){return length(p)-r;}\nfloat torus(vec3 p,vec2 t ){\n    p.z += cos(p.y*.01*sin(iTime));\n    p.y += sin(p.x*.5*cos(iTime));\n    vec2 q=vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n//MAP / SCENE FUNCTION\nfloat map(vec3 p)\n{ \n  float mainBox=plane(p,vec3(1));\n  float leftSphere=sphere(p+vec3(0,0,3),1.);\n  float scene=max(mainBox,leftSphere);\n\n  for (float i=0.; i< 14.; i++){\n  \n      float rightTorus=torus(p-vec3(2.*sin(i),i-7.,i),vec2(i,0.5));\n      scene=min(scene,rightTorus);\n\n  }\n  return scene;\n}\n//RAY CAST / TRACE LOOP FUNCTION\nfloat raycast( vec3 ro, vec3 rd )\n{\n  float dist,res=0.;\n  for(int i=0;i<128;i++){ \n    dist=map(ro+rd*res); \n    if(dist<.0001||res>120.) break;\n    res+=dist;\n  }\n  if(res>120.) res=0.;\n  return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //UV.y from -.5 to .5 and UV.x from -.88 to .88 (aspect ratio broooh)\n  time=mod(iTime,62.82); //Modulo time to avoid sin glitch noise due to floating point precision\n  // CAMERA  \n  vec3 rayOrigin=vec3(cos(time*.2)+4.,5,sin(time*.2)+14.);\n  vec3 cameraForward=normalize(vec3(0)-rayOrigin);\n  vec3 cameraLeft=normalize(cross(cameraForward,vec3(0,1,0)));\n  vec3 cameraUp=normalize(cross(cameraLeft,cameraForward));\n  vec3 rayDirection=mat3(cameraLeft,cameraUp,cameraForward)*normalize(vec3(uv,.5)); \n  // LIGHT DIRECTION & BACKGROUND SETUP   \n  vec3 lightDirection=normalize(vec3(-.1,.4,-.3));  \n  vec3 backgroundColor=vec3(.5*uv.y,.25*sin(iTime),.1*cos(iTime))-length(uv)*.1;\n  vec3 color=backgroundColor;\n  // TRACE AND GET RESULT FOR THIS PIXEL\n  float result=raycast(rayOrigin,rayDirection);\n  // IF WE HIT SOMETHING THEN DO SOME LIGHTING  \n  if(result>0.){ \n    vec3 hitPos=rayOrigin+rayDirection*result; // GET POSITION OF WHERE WE HIT\n    vec2 e=vec2(.00035,-.00035); // e=ESPILON = OFFSET NUMBER FOR NORMALS CALCULATION\n    vec3 normals=normalize(e.xyy*map(hitPos+e.xyy)+e.yyx*map(hitPos+e.yyx)+e.yxy*map(hitPos+e.yxy)+e.xxx*map(hitPos+e.xxx)); //CALCULATE NORMALS FOR WHERE WE HIT\n    vec3 albedo=vec3(.0,.2,.4); // SETUP BASE COLOUR\n    float diffuse=max(0.,dot(normals,lightDirection)); // SIMPLE DIFFUSE LIGHTING\n    float fresnel=pow(1.+dot(normals,rayDirection),4.); // FRESNEL = BACKGROUND REFLECTIONS ADDED TO EDGES OF GEOMETRY TO COMPOSITE IT BETTER IN THE SCENE\n    float specular=pow(max(dot(reflect(-lightDirection,normals),-rayDirection),0.),30.);// SPECULAR LIGHTING = Bright highlights, the shiny white flashy bit especially visible on metallic objects\n    float ao=clamp(map(hitPos+normals*.05)/.05,0.,1.); // AO = AMBIENT OCCLUSION = Small shadows where geometries touch due to ambient lighting\n    float sss=smoothstep(0.,1.,map(hitPos+lightDirection*.4)/.4);// SSS = Sub surface scattering = Light penetrating through edges of a translucent object, especially visible on candle wax or skin. Can be used as backlight too.\n    color=mix(specular+albedo*(ao+.2)*(diffuse+sss*.1),backgroundColor,fresnel); // Final lighting result made of all the above and then mixed with fresnel\n    color=mix(backgroundColor,color,exp(-.002*result*result*result)); // Add fog right at the end\n  }\n  fragColor = vec4(pow(color,vec3(sin(iTime))),1);// RETURN FINAL COLOR WITH GAMMA CORRECTION (pow(color,vec3(.4545)))\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl33zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 53, 80, 80, 103], [104, 104, 133, 133, 153], [154, 154, 182, 182, 320], [321, 344, 363, 363, 645], [646, 679, 714, 714, 882], [883, 883, 940, 940, 3447]], "test": "untested"}
{"id": "dtd3z2", "name": "Color Stud - After Image PVIII-1", "author": "Slals", "description": "Focus your eyes on the middle circle. You will see the white circle with some green.\n\nThis is caused by eyes cones fatigue by looking at the red color, by seeing the white your eyes substracts the red color from the white, making it greenish.", "tags": ["interactionofcolor"], "likes": 0, "viewed": 115, "published": 3, "date": "1682785717", "time_retrieved": "2024-07-30T17:58:27.306415", "image_code": "#define PI 3.14159265359\n#define TAU 6.2831853071\n#define REMANENCE_SECONDS 60.0\n\nfloat circleSDF(vec2 uv, vec2 c, float r) {\n    return length(uv - c) * r;\n}\n\nfloat fillAA(float x, float s) {\n    return smoothstep(x - 0.002, x + 0.002, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.0);\n    \n    float r = iResolution.x / iResolution.y;\n    vec2 center = vec2(r * 0.5, 0.5);\n    \n    vec2 workingEyesOffset = vec2(0.0, 0.0);\n    vec2 remanenceOffset = vec2(0.50, 0.0);\n    \n    vec3 red = vec3(0.89, 0.137, 0.227), white = vec3(1.0);\n    vec3 observedColor = red;\n    \n    if (mod(iTime, REMANENCE_SECONDS) > REMANENCE_SECONDS * 0.5) { // remanence\n        observedColor = white;\n        \n        // transition\n        float t = fract(iTime);\n        workingEyesOffset.x = 0.5;\n        remanenceOffset.x = 0.0;\n    } else { // working eyes cones\n        observedColor = red;\n    }\n    \n    float circleA = fillAA(circleSDF((uv + workingEyesOffset) * vec2(r, 1.0), center, 0.5), 0.16);\n    float circleB = fillAA(circleSDF((uv - remanenceOffset) * vec2(r, 1.0), center, 0.5), 0.16);\n\n    float unit = min(iResolution.x, iResolution.y) * 0.5;\n    vec2 bounds = vec2(0.43 * unit, 0.55 * unit) * 1.2;\n    vec2 dir = (iResolution.xy / 2.0) - fragCoord;\n    float rot = (1.0 - iTime / REMANENCE_SECONDS * 2.0) * TAU;\n    float clockA = mod(atan(dir.x, dir.y) + radians(180.0) + rot, TAU);\n    clockA *= float(clockA <= TAU);\n    float intsy = clockA / TAU;\n\n    float clock = dot(step(length(dir), bounds), vec2(0.0, 1.0));\n    \n    color += circleA * red;\n    color += circleB * white;\n    color = mix(color, observedColor, fillAA(clock, 0.1) * intsy);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtd3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 125, 125, 158], [160, 160, 192, 192, 242], [244, 244, 301, 351, 1841]], "test": "untested"}
{"id": "dtd3R2", "name": "Color Study - Plate VII-5b", "author": "Slals", "description": "The horizontal brownish bars remains the same across different backgrounds, we can clearly see how the background influence our perception of the 2 bar colors.", "tags": ["interactionofcolor"], "likes": 4, "viewed": 137, "published": 3, "date": "1682778337", "time_retrieved": "2024-07-30T17:58:28.146170", "image_code": "float rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float s) {\n    return step(x, s);\n}\n\nvec2 rot(vec2 uv, float a) {\n    uv = mat2(cos(a), -sin(a), sin(a), cos(a)) * (uv - 0.5);\n    return uv + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 colorA = vec3(0.757, 0.106, 0.263);\n    vec3 colorB = vec3(0.988, 0.929, 0.808);\n    vec3 colorStudA = vec3(0.741, 0.498, 0.259);\n    vec3 colorStudB = vec3(0.91, 0.831, 0.553);\n    \n    vec3 color = vec3(0.0);\n    \n    bool isRightSide = step(0.5, uv.x) == 1.0;\n    \n    vec2 s = vec2(0.08, 1.0);\n    \n    float sideOffset = 0.25;\n    \n    float MX = iMouse.x / iResolution.x, MY = iMouse.y / iResolution.y;\n    \n    if (step(0.2, uv.y) == 0.0) {\n        // Comp B\n        color = isRightSide ? colorStudA : colorStudB;\n    } else if (step(0.4, uv.y) == 0.0) {\n        // Comp A\n        color = isRightSide ? colorA : colorB;\n    } else {\n        // Main study\n        float vertOffset = 0.2;\n        \n        float studBarLeft = rectSDF(rot(uv + vec2(sideOffset, -vertOffset), radians(-45.0 - min(MY * 55.0, 45.0))), s);\n        float studBarRight = rectSDF(rot(uv - vec2(sideOffset, vertOffset), radians(-45.0 - min(MY * 55.0, 45.0))), s);\n        \n        color = isRightSide ? colorB : colorA;\n        \n        float bL = smoothstep(studBarLeft - 0.01, studBarLeft + 0.01, 0.5);\n        float bR = smoothstep(studBarRight - 0.01, studBarRight + 0.01, 0.5);\n        color = mix(color, colorStudA, bL);\n        color = mix(color, colorStudB, bR);\n    }\n    \n    float movVertOffset = 0.5 - MY * 0.85;\n        \n    float movStudBarLeft = fill(rectSDF(rot(uv + vec2(sideOffset, movVertOffset), radians(90.0)), s), 0.5);\n    float movStudBarRight = fill(rectSDF(rot(uv - vec2(sideOffset, -movVertOffset), radians(90.0)), s), 0.5);\n    \n    color = movStudBarLeft == 1.0 ? colorStudA : color;\n    color = movStudBarRight == 1.0 ? colorStudB : color;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtd3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [111, 111, 141, 141, 166], [168, 168, 196, 196, 280], [282, 282, 339, 389, 2152]], "test": "untested"}
{"id": "mld3zj", "name": "Year of Truchets #015", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nNothing too special - just playing with my refraction loop - thanks @blackle (and @Shane/@iq)", "tags": ["hexagon", "truchet", "tiles"], "likes": 14, "viewed": 222, "published": 3, "date": "1682777388", "time_retrieved": "2024-07-30T17:58:29.188383", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #015\n    04/29/2023  @byt3_m3chanic\n    (it's gonna be may)\n*/\n\n// AA = 1 = OFF else 2 > depending on GPU\n#define ZERO (min(iFrame,0))\n#define AA 1\n\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    100.\n\n\nconst vec2  s = vec2(1, 1.7320508);\n// pre-cal for speed \nconst float radi = .28867514;\nconst float harc = .57735027;\nconst float scale = .4;\n\nvec3 hp=vec3(0),hit=vec3(0);\nvec2 gid=vec2(0),sid=vec2(0);\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\n//@iq extrude functions \nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n//@Shane hex/grid functions\nfloat hex(in vec2 p) {\n    p = abs(p);\n    return max(dot(p, s*.5), p.x);\n}\n\nvec4 getGrid(vec2 p) {\n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n}\n\nvec3 map(vec3 pos) {\n    vec3 res = vec3(1e5,0,0);\n    \n    vec2 uv = pos.xy+(vec2(-.1,.2)*T);\n\n    vec4 h = getGrid(uv*scale);\n    vec2 p = h.xy;\n\n    float f = hex(p)-.465;\n    float rnd = hash21(h.zw + vec2(.09, .04));\n    float rnd2 = hash21(h.zw + vec2(.37, 7.83)); \n    \n    rnd = floor(rnd*144.);\n    p.xy*=rot(rnd*PI/3.);\n\n    vec3 d, py;\n    vec2 p0, p1, p2;\n    float m = 1.;\n    \n    if(rnd2<.25) {\n        p0 = p - vec2(0, -harc);\n        p1 = p - vec2(0, harc);\n        p2 = p;\n        \n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = abs(p2.y);\n        \n        py.x = pos.z;\n        py.y = pos.z;\n        py.z = (pos.z-.11)-.11*cos(p0.x*PI2);\n        m = 3.;\n    }\n    else if(rnd2<.75) {\n        p0 = p;\n        p1 = rot(1.04719755)*p;\n        p2 = rot(2.09439510)*p;\n    \n        d.x = abs(p0.y);\n        d.y = abs(p1.y);\n        d.z = abs(p2.y);\n \n        py.x = (pos.z-.22)-.22*cos(p0.x*PI2);\n        py.y = (pos.z-.11)-.11*cos(p1.x*PI2);\n        py.z = pos.z;\n        m = 2.;\n    }\n    else {\n        p0 = p - vec2(-.5, -radi);\n        p1 = p - vec2(.5, -radi);\n        p2 = p - vec2(0, harc);\n        \n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = length(p2) - radi;\n        \n        py = vec3(pos.z);\n    }\n  \n    const float ht = .03;\n    d=abs(abs(abs(d)-.1)-.05)-.025;\n    \n    float hx= opx(f,pos.z+.75,.025)-.01; \n    if(hx<res.x) {\n        res =vec3(hx,5.,5.);\n        hp = vec3(p,pos.z);\n        gid=h.zw;\n    }\n    \n    float d1 = opx(d.x,py.x,ht)-.01;\n    if(d1<res.x) {\n        res =vec3(d1,m,1.);\n        hp = vec3(p0,pos.z);\n        gid=h.zw;\n    }\n\n    float d2 = opx(d.y,py.y,ht)-.01;\n    if(d2<res.x) {\n        res =vec3(d2,m,2.);\n        hp = vec3(p1,pos.z);\n        gid=h.zw;\n    }\n    \n    float d3 = opx(d.z,py.z,ht)-.01;\n    if(d3<res.x) {\n        res =vec3(d3,m,3.);\n        hp = vec3(p2,pos.z);\n        gid=h.zw;\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n//@iq https://iquilezles.org/articles/palettes/\nvec3 hue(float t){ \n    t+=T*.05;\n    return .3+.3*cos(PI2*t*(vec3(1.,.99,.95)+vec3(0.925,0.631,0.212))); \n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    \n    vec3 lpos = vec3(4,-5,7);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),.0,.9);\n    \n    float py = abs(p.y)-5.;\n    float hs = (m==5.) ? .13 : .15;\n    \n    vec3 h = hue(py*hs);\n\n    return h*diff;\n}\n\nvec3 render(in vec2 uv, in vec2 F ) {\n\n    vec3 C=vec3(.0);\n\n    vec3 ro = vec3(0,0,4.75),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? -.1 : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ?  .0 :  (M.x/R.x * .125 - .0625) * PI;\n\n    mat2 rx = rot(x),ry = rot(y);\n    ro.yz *= rx,ro.xz *= ry;\n    rd.yz *= rx,rd.xz *= ry;\n    \n    vec3  p = ro + rd * .1;\n    \n    float atten = 1.,k = 1.,v = 1.,b = 3.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<100;i++)\n    {\n        vec3 ray = map(p);\n        vec3 n=vec3(0);\n\n        float d = ray.x*.8;\n        float m = ray.y;\n        float q = ray.z;\n        sid=gid;\n        hit=hp;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n\n            C+=shade(p,rd,d,m,n)*atten;\n         \n            if(m==5.||b<1.)break;\n            b--;\n            atten *= .675;\n            p += rd*.0025;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,v > 0. ? .75 : 1.1);\n            v *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            \n            rd = rf;\n            p += -n*.0025;\n        }  \n        if(distance(p,rd)>50.) { break; }\n    }\n    // Output to screen\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n        vec3 color = render(uv,F);     \n        color = 1.35*color/(1.0+color);\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    \n    C = pow(C, vec3(0.4545) );\n    O = vec4(C,1.);\n}\n//end\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mld3zj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[633, 633, 652, 652, 697], [698, 698, 719, 719, 779], [781, 806, 852, 852, 945], [947, 975, 997, 997, 1050], [1052, 1052, 1074, 1074, 1265], [1267, 1267, 1287, 1287, 3214], [3216, 3285, 3330, 3330, 3553], [3555, 3603, 3621, 3621, 3711], [3713, 3713, 3774, 3774, 4027], [4029, 4029, 4066, 4066, 5316]], "test": "untested"}
{"id": "ctt3z2", "name": "SESSIONS 2023 jam entry", "author": "kostik1337", "description": "My entry for SESSIONS 2023", "tags": ["tunnel", "jam", "sessions"], "likes": 10, "viewed": 235, "published": 3, "date": "1682760255", "time_retrieved": "2024-07-30T17:58:30.025146", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define INF 1e10\n#define time iTime\n#define rep(p,s) (mod(p,s)-s/2.)\n#define rep2(p,s) (abs(rep(p,2.*s))-s/2.)\n#define PI 3.14159265\n\nfloat hash(float x) {return fract(sin(x)*3458.2551);}\nfloat hash(vec3 x) {return hash(dot(x, vec3(34.67546,65.34135,23.4567457)));}\n\nfloat ffti(float t) {return 0.;}\nfloat ffts(float t) {return 0.;}\nvec4 back(vec2 uv) {return texture(iChannel0, uv);}\n\nvec2 polar(vec2 p, float n) {\n  p = vec2(length(p), atan(p.y,p.x));\n  p.y = rep2(p.y, 2.*PI/n);\n  return p.x*vec2(cos(p.y),sin(p.y));\n}\n\nmat2 mr(float t) {float c=cos(t),s=sin(t); return mat2(c,s,-s,c);}\n\nfloat box(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nvec3 ct(vec3 p) {\n  if(p.x<p.y)p.xy=p.yx;\n  if(p.y<p.z)p.yz=p.zy;\n  if(p.x<p.y)p.xy=p.yx;\n  return p;\n}\n\nfloat maxx(vec3 p) {return max(p.x, max(p.y,p.z));}\n\nvec3 glow=vec3(0.);\n\nfloat map(vec3 p, float t) {\n  p.z += .6*t + .6*ffti(.1);\n  vec3 op=p;\n  float m=INF;\n  \n  p.xy=polar(p.xy, 7.);\n  float bound = p.x-.2;\n  \n  vec3 s = vec3(1.2);\n  for(float i=0.;i<3.;++i) {\n    p.x += (.1*time + .3*op.z) * exp2(-i);\n    p = rep2(p, s);\n    \n    s *= .65;\n    s.xy *= mr(.17);\n    s = s.zxy;\n    if(i==1.) p.xy *= mr(PI/4.);\n    \n    p = ct(abs(p));\n    float boxs=maxx(s)/(i==0.?10.:100.);\n    float m1=box(p, vec3(boxs, boxs, INF).zxy);\n    float gpow=pow(sin(length(10.*op.xy)+op.z+5.*t)*.5+.5, 4.);\n    vec3 gcol=vec3(1.4,1.,1.);\n    gcol.xz *= mr(.4*op.z);\n    gcol=abs(gcol);\n    glow += gpow * .001*gcol / (m1+mix(.03,.05, hash(p+time)));\n    m = min(m, m1);\n  }\n  m= max(m,-bound);\n  \n  return m;\n}\n\nvec3 norm(vec3 p) {\n  vec2 E=vec2(.001,.0);\n  return normalize(vec3(\n    map(p+E.xyy,time),map(p+E.yxy,time),map(p+E.yyx,time)\n  )-map(p,time));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 c=vec3(0.);  \n  vec3 O=vec3(0.,0.,-1.), D = vec3(uv,1.);\n  D.z = (1.+.6*length(D.xy));\n  D = normalize(D);\n  D.xz *=mr(.15*sin(.2*time));\n  D.yz *=mr(.15*sin(.22*time));\n  float d = 0.;\n  bool hit = false;\n  for(float i=0.;i<64.;++i) {\n    vec3 p=O+D*d;\n    float m=map(p,time + .1*hash(vec3(uv, time)));\n    d += m;\n    if(m<.001*d) {\n      hit = true;\n      break;\n    }\n  }\n  c += min(vec3(1.),glow)* exp(-d*.1);\n  \n  uv = fragCoord/iResolution.xy;\n  if(hit) {\n    vec3 p=O+D*d;\n    vec3 n=norm(p);\n    float e=.03;\n    vec2 off=n.xy*.4;\n    vec3 prev=vec3(\n      back(uv+off*(1.+e)).r,\n      back(uv+off).g,\n      back(uv+off*(1.-e)).b\n    );\n    c += prev.rgb * mix(.5,1.,min(1.,8.*ffts(.12)));\n  } else {\n    c = mix(c, back(uv).rgb, .8);\n  }\n\n\tfragColor = vec4(c, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctt3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "cltGR2", "name": "fork color study VI-1.1", "author": "elenzil", "description": "reworking it with a 'scene' and smoothstep.\n\ntop: AA\nbot: no AA", "tags": ["colorinteraction"], "likes": 9, "viewed": 151, "published": 3, "date": "1682746891", "time_retrieved": "2024-07-30T17:58:30.863904", "image_code": "\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\n// return the distance to the nearest thing in the scene\nfloat sdScene(vec2 p) {\n    float d = 1e9;\n    \n    float circleWidth = 0.13;\n    \n    float sep = mix(0.6, 0.0, smoothstep(0.1, 0.9 * iResolution.x, iMouse.x));\n    vec2  off = vec2(sep * (p.x < 0.0 ? 1.0 : -1.0), 0.0);\n    \n    // four circles, offset by separation.\n    for (float n = 0.0; n < 4.0; ++n) {\n        d = min(d, abs(sdCircle(p + off, 1.0 - circleWidth * 2.0 * n)) - circleWidth / 2.0 );\n    }\n    \n    // erase a column in the middle.\n    if (sep > 0.0) {\n        d = max(d, -(abs(p.x) - sep));\n    }\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixelate to exaggerate aliasing\n    float pixelateAmount = iMouse.z > 1.0 ? 8.0 : 1.0;\n    vec2  pixelatesFragCoord = round(fragCoord / pixelateAmount) * pixelateAmount;\n    \n    // uv with (0,0) at the center of screen\n    float zoom = 0.54;\n    vec2  uv   = (pixelatesFragCoord * 2.0 - iResolution.xy)/iResolution.y / zoom;\n    \n    // smoothing epsilon\n    // 4 pixels above, 0 pixels below.\n    float eps = uv.y < 0.0 ? 0.0 : pixelateAmount * 4.0 / iResolution.y;\n    \n    vec3  c1  = vec3(0.506, 0.478, 0.506);\n    vec3  c2  = vec3(0.929, 0.725, 0.573);\n    vec3  c3  = vec3(0.69 , 0.584, 0.518);\n    vec3  c   = c1;\n    \n    // the distance to the scene\n    float d   = sdScene(uv);\n    \n    c = mix(c, c2, smoothstep(eps, -eps, -uv.x));\n    c = mix(c, c3, smoothstep(eps, -eps, d));\n    \n    // visualize the distance to the scene\n    if (iMouse.z > 1.0 && d > 0.0 && iMouse.y > iResolution.y / 2.0) {\n        c += cos(d * 30.0) * 0.1;\n    }\n    \n    // white line\n    if (round(fragCoord.y) == round(iResolution.y / 2.0)) {\n        c = mix(c, vec3(1.0), 0.5);\n    }\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 72], [74, 131, 154, 154, 664], [666, 666, 723, 762, 1841]], "test": "untested"}
{"id": "Dtt3zj", "name": "Rainbow gem pattern (music)", "author": "jarble", "description": "Another shiny fractal thing.", "tags": ["fractal", "mosaic", "gem"], "likes": 6, "viewed": 204, "published": 3, "date": "1682739349", "time_retrieved": "2024-07-30T17:58:32.025797", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.x/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    vec2 uv1 = uv;\n    uv.x = mod(uv.x,.5)+.25;\n    uv.y = mod(uv.y,1.)+1.;\n    for(int k = 0; k < 9; k++){\n        //k += int(uv.y>uv.x);\n        uv =\n            abs(-.5-uv-t2*sign(uv.y-uv.x))/1.5+1.\n            //abs(-.5*sign(uv.x-.5)-uv-t2*sign(uv.y-uv.x))/1.5+1.\n        ;\n        b =\n            uv.y>uv.x\n            //uv.y<uv.x&&col.x>0.\n        ;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv+.5).yx\n        ;\n        uv =\n            t2+triangle_wave(uv.yx).yx\n        ;\n        \n        //uv = -(fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n        \n        vec2 uv_1 =\n            uv\n            //triangle_wave(uv.yx+iTime)+t2\n        ;\n        \n        col.x =\n            abs((uv_1.x)-col.x)\n            //abs(sign(uv.x)-col.x)/2.\n        ;\n        \n        //awesome kaleidoscope effect!\n        //if(t2.y>t2.x) {t2 = t2.yx; uv=uv.yx-iTime/8.;}\n        \n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n            //abs(col.yzx-float(uv.y>uv.x)/2.)\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a += floor(-a)/b*8.;\n    return\n        mod(floor(a),b)\n        //floor(mod(mod(floor(a),b+floor(a/b)*2.),b))\n        //mod(floor(a+floor(b/2.)),b)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      8.,\n  s2 = 4.,\n  t = time,\n  m1 =\n      0.\n  ;\n  \n  //change this number to get more interesting rhythms\n  float m4 =\n      2.\n      //2.*pow(2.,mod(floor(t/16.),2.))\n  ;\n  \n  for(int i = 0; i < 3; i++){\n      \n      //t += (fmod(time*pow(2.,fmod(t,3.)),2.));\n      t *= 1.+fmod(t/m4,2.);\n      t +=\n          floor(t/m4)\n          //floor(t/8.)+floor(t/4.)+floor(t/2.)\n      ;\n      //t += abs(mod((t*2.),2.)-mod((t*2.),3.));\n      m1 =\n      fmod(t*m4,s2);\n      //t += abs(mod((t),2.)-mod((t),3.));\n      \n      t = t/(1.+fmod(m1+floor(t*m4)+floor(t/m4),2.));\n  }\n  t *= s1/2.;\n  float\n  m3 =\n      fmod(t,s1/2.)\n  ;\n\n  float m2 =\n      1. + floor(fmod(t,s1/2.));\n  ;\n  float a=\n      pow((sqrt(fract(-t))),2.)*8.\n  ;\n  float nb = time*pow(2.,(m3+m2-m1)/5.+7.)*2.;\n  return\n      //instruments\n      abs(.5-abs(vec2(sin(nb),cos(nb))*a))*2.\n      \n      //sitar\n      //log(abs(a/8.-abs(.5-vec2(fract(nb/2.),fract(nb/2.)))*a))\n      \n      //abs(1.-2.*abs(.5-abs(vec2(sin(nb),cos(nb)))))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtt3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1552]], "test": "untested"}
{"id": "cldGzj", "name": "fan-bulma", "author": "jorge2017a2", "description": "fan-bulma", "tags": ["fanbulma"], "likes": 13, "viewed": 179, "published": 3, "date": "1682737246", "time_retrieved": "2024-07-30T17:58:33.038091", "image_code": "//por Jorge F.P.----jorge2017a2\n//28-abril-2023\n//----Fan Bulma....faltan detalles,,, y el pelo es dificil\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(1.0),b,d)\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 CejaDer(vec2 uv,vec3  col) \n{\nfloat d1,d2,d3,d4,df;\nvec2 p1,p2,p3,p4,p5;\nfloat r1,r2,r3,r4,r5;\nfloat a1,a2,a3;\nfloat b1,b2,b3;\n    p1 = vec2(3.69, 3.2); r1 = 0.25;\n    p2 = vec2(3.77, 3.13); r2 = 0.3;\n    p3 = vec2(3.37, 3.02); r3 = 0.25;\n    d1 = sdCircle(uv- p1, r1);\n    d2 = sdCircle(uv- p2, r2);\n    d3 = sdCircle(uv- p3, r3);\n    df = differenceSDF(d1, d2);\n    df = differenceSDF(df, d3);\n    col = DrawFigBorde(vec3(70.0/ 255.0, 151.0/ 255.0, 205.0/ 255.0), col, df);\n    return  col;\n}\n\nvec3 Cejaizq(vec2 uv,vec3 col ) \n{\nfloat d1,d2,d3,d4,df;\nvec2 p1,p2,p3,p4,p5;\nfloat r1,r2,r3,r4,r5;\nfloat a1,a2,a3; \nfloat b1,b2,b3;\n////------ceja izq;\n//inter , dif;\np1 = vec2(2.77, 3.14);  r1 = 0.25;\np2 = vec2(2.75, 3.1);  r2 = 0.25;\np3 = vec2(3.1, 2.99);  r3 = 0.25;\n    d1 = sdCircle(uv- p1, r1);\n    d2 = sdCircle(uv- p2, r2);\n    d3 = sdCircle(uv- p3, r3);\n    df = differenceSDF(d1, d2);\n    df = differenceSDF(df, d3);\n    col = DrawFigBorde(vec3(70.0 / 255.0, 151.0 / 255.0, 205.0 / 255.0), col, df);\n    return col;\n}\n\nvec3 OrejaDer(vec2 uv ,vec3 col)\n{\nfloat d1,d2,d3,d4,df;\nvec2 p1,p2,p3,p4,p5;\nfloat r1,r2,r3,r4,r5;\nfloat a1,a2,a3; \nfloat b1,b2,b3;\n////oreja der;\np1 = vec2(4.32, 2.6);  r1 = 0.25;\np2 = vec2(4.39, 2.78);  r2 = 0.15;\np3 = vec2(4.21, 2.54);  r3 = 0.25;\n    d1 = sdCircle(uv- p1, r1);\n    d2 = sdCircle(uv- p2, r2);\n    d3 = sdCircle(uv- p3, r3);\n    df = unionSDF(d1, d2);\n    df = unionSDF(df, d3);\n    col = DrawFigBorde(vec3(249.0 / 255.0, 210.0/255., 203.0/255.0), col, df);\n    return col;\n}\n\nvec3 OjoIzq(vec2 uv,vec3 col)\n{\nfloat d1,d2,d3,d4,d5,d6,df;\nvec2 p1,p2,p3,p4,p5, p6;\nfloat r1,r2,r3,r4,r5,r6;\nfloat a1,a2,a3,a4,a5; \nfloat b1,b2,b3,b4,b5;\n    ////-----ojo izquierdo;\n//interseccion;\np1 = vec2(2.925, 2.74);  a1 = 0.185;  b1 = 0.32;\np2 = vec2(2.865, 2.69);  a2 = 0.185;  b2 = 0.37;\np3 = vec2(2.94, 2.12);  r3 = 0.5; //diferencia;\n    ////ojo base\n    d1 = sdEllipse(uv- p1, vec2(a1, b1));\n    d2 = sdEllipse(uv- p2, vec2(a2, b2));\n    d3 = sdCircle(uv- p3, r3);\n    //cornea\n    p4 = vec2(2.96, 2.74);  a4 = 0.11;  b4 = 0.22;\n    d4 = sdEllipse(uv- p4, vec2(a4, b4));\n    //pupila\n    p5 = vec2(2.97, 2.82);  a5 = 0.06; b5 = 0.12;\n    d5 = sdEllipse(uv- p5, vec2(a5, b5));\n    //pupila luz\n    p6 = vec2(2.94, 2.89);  r6 = 0.05;\n    d6 = sdCircle(uv- p6, r6);\n    df = intersectSDF(d1, d2);\n    df = differenceSDF(df, d3);\n    d4 = intersectSDF(df, d4); ////cornea\n    \n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, df);\n    col = DrawFigBorde(vec3(33.0 / 255.0, 141.0 / 255.0, 192.0 / 255.0), col, d4);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d5);\n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, d6);\n    return  col;\n}\n\nvec3 ojoDer(vec2 uv, vec3 col)\n{\nfloat d1,d2,d3,d4,d5,d6,df;\nvec2 p1,p2,p3,p4,p5, p6;\nfloat r1,r2,r3,r4,r5,r6;\nfloat a1,a2,a3,a4,a5; \nfloat b1,b2,b3,b4,b5;\n\n//----ojo derecho  bulma;\n//Union;\np1 = vec2(3.715, 2.77);  a1 = 0.185;  b1 = 0.32;\np2 = vec2(3.715, 2.75);  a2 = 0.185;  b2 = 0.37;\n//diferencia;\np3 = vec2(3.71, 2.17);  r3 = 0.5;\n    d1 = sdEllipse(uv- p1, vec2(a1, b1));\n    d2 = sdEllipse(uv- p2, vec2(a2, b2));\n    d3 = sdCircle(uv- p3, r3);\n    //der;\n    p4 = vec2(3.625, 2.805);  a4 = 0.135;  b4 = 0.195;\n    d4 = sdEllipse(uv- p4, vec2(a4, b4));\n    //pupila;\n    p5 = vec2(3.62, 2.87);  a5 = 0.06; b5 = 0.12;\n    d5 = sdEllipse(uv- p5, vec2(a5, b5));\n    //pupila luz;\n    p6 = vec2(3.61, 2.92);  r6 = 0.05;\n    d6 = sdCircle(uv- p6, r6);\n    //df = intersectSDF(d1, d2);\n    df = unionSDF(d1, d2);\n    df = differenceSDF(df, d3);\n    d4 = intersectSDF(df, d4); ////cornea;\n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, df);\n    col = DrawFigBorde(vec3(33.0 / 255.0, 141.0 / 255.0, 192.0 / 255.0), col, d4);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d5);\n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, d6);\n\n    return  col;\n}\n\nvec3 PestanasIzq(vec2 uv,vec3 col)\n{\nvec2 lA1,lA2;\nvec2 lB1,lB2;\nvec2 lC1,lC2 ;\nfloat d1, d2,d3;\n    lA1 = vec2(2.65, 2.89);  lA2 = vec2(2.75, 2.86);\n    lB1 = vec2(2.67, 2.79);  lB2 = vec2(2.77, 2.76);\n    lC1 = vec2(2.68, 2.62);  lC2 = vec2(2.78, 2.64);\n    d1 = sdSegment(uv, lA1, lA2);\n    d2 = sdSegment(uv, lB1, lB2);\n    d3 = sdSegment(uv, lC1, lC2);\n    \n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d1);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d2);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d3);\n    return col;\n}\n\nvec3 PestanasDer(vec2 uv,vec3 col)\n{\nvec2 lA1,lA2;\nvec2 lB1,lB2;\nvec2 lC1,lC2 ;\nfloat d1, d2,d3;\n    lA1 = vec2(3.85, 2.94);  lA2 = vec2(3.95, 3.01);\n    lB1 = vec2(3.88, 2.89);  lB2 = vec2(3.98, 2.92);\n    lC1 = vec2(3.88, 2.81);  lC2 = vec2(3.98, 2.83);\n    d1 = sdSegment(uv, lA1, lA2);\n    d2 = sdSegment(uv, lB1, lB2);\n    d3 = sdSegment(uv, lC1, lC2);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d1);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d2);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d3);\n    return col;\n}\n\nvec3 nariz(vec2 uv ,vec3 col)\n{\nvec2 lA1,lA2;\nvec2 lB1,lB2;\nvec2 lC1,lC2 ;\nfloat d1, d2,d3;\n    \n    lA1 = vec2(3.06, 2.48);  lA2 = vec2(3.16, 2.46);\n    lB1 = vec2(3.06, 2.48);  lB2 = vec2(3.16, 2.41);\n    lC1 = vec2(3.11, 2.48);  lC2 = vec2(3.21, 2.61);\n    d1 = sdSegment(uv, lA1, lA2);\n    d2 = sdSegment(uv, lB1, lB2);\n    d3 = sdSegment(uv, lC1, lC2);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d1);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d2);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d3);\n    return col;\n}\n\nvec3  Pelo(vec2 uv,vec3 col )\n{\nfloat d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,df;\nvec2 p1,p2,p3,p4,p5, p6,p7,p8,p9,p10;\nfloat r1,r2,r3,r4,r5,r6,r7,r8,r9,r10;\nfloat a1,a2,a3,a4,a5; \nfloat b1,b2,b3,b4,b5;\n\np1 = vec2(3.51, 3.26);  r1 = 1.3;\np2 = vec2(3.57, 3.12);  r2 = 0.6;\np3 = vec2(3.24, 2.73);  r3 = 0.75;\np4 = vec2(3.42, 2.72);  r4 = 0.85;\np5 = vec2(2.71, 2.83);  r5 = 0.3;\n\n////union p1 y p2;\n//diferencia con p3 y otra diferencia con lo demas;\np6 = vec2(3.29, 4.22);  r6 = 0.4;\np7 = vec2(4.01, 4.18);  r7 = 0.35;\np8 = vec2(3.66, 4.52);  r8 = 0.35;\n    d1 = sdCircle(uv- p1, r1);\n    d2 = sdCircle(uv- p2, r2);\n    d3 = sdCircle(uv- p3, r3);\n    d4 = sdCircle(uv- p4, r4);\n    d5 = sdCircle(uv- p5, r5);\n    d6 = sdCircle(uv- p6, r6);\n    d7 = sdCircle(uv- p7, r7);\n    d8 = sdCircle(uv- p8, r8);\n    df = differenceSDF(d1, d2);\n    df = differenceSDF(df, d3);\n    df = differenceSDF(df, d4);\n    df = unionSDF(df, d5);\n    d6 = unionSDF(d6, d7);\n    d6 = differenceSDF(d8, d6);\n    df = differenceSDF(df, d6);\n    col = DrawFigBorde(vec3(70.0 / 255.0, 151.0 / 255.0, 205.0 / 255.0), col, df);\n    \n    return col;\n}\n\n\nvec3 OrejaIzq(vec2 uv,vec3 col)\n{\nfloat d1,d2,d3,d4,d5,d6,df;\nvec2 p1,p2,p3,p4,p5, p6;\nfloat r1,r2,r3,r4,r5,r6;\nfloat a1,a2,a3,a4,a5; \nfloat b1,b2,b3,b4,b5;\n\np1 = vec2(0.72, 3.37);  r1 = 0.25;\np2 = vec2(0.88, 3.32);  r2 = 0.25;\np3 = vec2(0.72, 3.65);  r3 = 0.2;\np4 = vec2(0.475, 3.885);  r4 = 0.175;\np5 = vec2(0.64, 3.93);  r5 = 0.2;\n    d1 = sdCircle(uv- p1, r1);\n    d2 = sdCircle(uv- p2, r2);\n    d3 = sdCircle(uv- p3, r3);\n    d4 = sdCircle(uv- p4, r4);\n    d5 = sdCircle(uv- p5, r5);\n    df = unionSDF(d1, d2);\n    df = unionSDF(df, d3);\n    df = unionSDF(df, d4);\n    df = unionSDF(df, d5);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, df);\n    return col;\n}\n\n\nvec3 Boca(vec2 uv,vec3 col)\n{\nfloat d1,d2,d3,d4,d5,d6,df;\nvec2 p1,p2,p3,p4,p5, p6;\nfloat r1,r2,r3,r4,r5,r6;\nfloat a1,a2,a3,a4,a5; \nfloat b1,b2,b3,b4,b5;\n////-----boca diferenica;\np1 = vec2(3.23, 2.8);  r1 = 0.5;\np2 = vec2(3.345, 2.34);  a1 = 0.185;  b1 = 0.32;\np3 = vec2(3.4, 2.23);  r3 = 0.2;\n    d1 = sdCircle(uv- p1, r1);\n    d2 = sdEllipse(uv- p2, vec2(a1, b1));\n    d3 = sdCircle(uv- p3, r3);\n    df = differenceSDF(d2, d1);\n    d3 = intersectSDF(df, d3);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, df);\n    col = DrawFigBorde(vec3(210.0/255.0, 136.0/255., 110.0/255.), col, d3);\n    return col;\n}\n\nvec3 Cabeza(vec2 uv,vec3 col)\n{\nfloat d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16,df;\nvec2 p1,p2,p3,p4,p5, p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16;\nfloat r1,r2,r3,r4,r5,r6,r7,r8,r9,r10;\nfloat a1,a2,a3,a4,a5,a6,a7,a8,a9,a10; \nfloat b1,b2,b3,b4,b5,b6,b7,b8,b9,b10;\nvec2 p17,p18;\n\nfloat a11,a12,a13,a14,a15,a16,a17;\nfloat b11,b12,b13,b14,b15,b16,b17;\n\np1 = vec2(3.45, 2.69);  r1 = 0.8;\np2 = vec2(3.23, 2.44);  r2 = 0.55;\np3 = vec2(3.54, 2.44);  r3 = 0.6;\np4 = vec2(3.43, 2.21);  r4 = 0.45;\np5 = vec2(3.43, 3.04);  r5 = 0.85;\np6 = vec2(3.39, 2.34);  a6 = 0.36;  b6 = 0.57;\n////diferencia rostro;\np7 = vec2(3.705, 1.715);  a7 = 0.335;  b7 = 0.645;\n    d1 = sdCircle(uv- p1, r1);\n    d2 = sdCircle(uv- p2, r2);\n    d3 = sdCircle(uv- p3, r3);\n    d4 = sdCircle(uv- p4, r4);\n    d5 = sdCircle(uv- p5, r5);\n    d6 = sdEllipse(uv- p6, vec2(a6, b6));\n    d7 = sdEllipse(uv- p7, vec2(a7, b7));\n    df = unionSDF(d1, d2);\n    df = unionSDF(df, d3);\n    df = unionSDF(df, d4);\n    df = unionSDF(df, d5);\n    df = unionSDF(df, d6);\n    col = Pelo(uv, col);\n    col = OrejaDer(uv, col);\n    col = DrawFigBorde(vec3(249.0/255.0, 210.0/ 255., 203.0/255.0), col, d7);\n    col = DrawFigBorde(vec3(249.0/255.0, 210.0/ 255., 203.0 /255.0), col, df);\n    col = OjoIzq(uv, col);\n    col = ojoDer(uv, col);\n    col = Boca(uv, col);\n    col = CejaDer(uv, col);\n    col = Cejaizq(uv, col);\n    col = PestanasIzq(uv, col);\n    col = PestanasDer(uv, col);\n    col = nariz(uv, col);\n    ////----diferencia de pelo y union con total;\n    p9 = vec2(3.5, 2.78);  r9 = 1.1;\n    p10 = vec2(3.85, 2.27);  r10 = 1.45;\n    //parte del pelo posterior;\n    d9 = sdCircle(uv- p9, r9);\n    d10 = sdCircle(uv- p10, r10);\n    d9 = differenceSDF(d9, d10);\n    col = DrawFigBorde(vec3(70.0/255.0, 151.0/255.0, 205.0/ 255.0), col, d9);\n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5); uv*=4.5;\n   vec3 col =vec3(1.0); \n    uv.x=abs(uv.x)-0.5;\n    col= Cabeza(uv,col);\n    float t=iTime*3.0;\n    vec2 uv1= rotatev2(uv, t);\n    vec2 uv2= rotatev2(uv, -t);\n    col= Cabeza(uv1,col);\n    col= Cabeza(uv2,col);\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 332, 332, 458], [459, 459, 540, 540, 668], [670, 670, 717, 717, 744], [745, 745, 788, 788, 815], [816, 816, 864, 864, 892], [894, 894, 929, 929, 952], [954, 954, 1006, 1006, 1113], [1115, 1115, 1149, 1149, 1240], [1242, 1242, 1276, 1276, 1741], [1743, 1743, 1777, 1777, 2271], [2273, 2273, 2307, 2307, 2768], [2770, 2770, 2801, 2801, 3918], [3920, 3920, 3952, 3952, 5074], [5076, 5076, 5112, 5112, 5618], [5620, 5620, 5656, 5656, 6157], [6159, 6159, 6190, 6190, 6696], [6698, 6698, 6729, 6729, 7808], [7811, 7811, 7844, 7844, 8479], [8482, 8482, 8511, 8511, 9090], [9092, 9092, 9123, 9123, 10910], [10912, 10912, 10969, 10969, 11338]], "test": "untested"}
{"id": "Dld3zS", "name": "Color Study - Plate VI-1", "author": "Slals", "description": "3 colors seems to disappear ;\n\nThe circular forms appears to have the color of the opposite background while those are in identical colors", "tags": ["colorinteraction"], "likes": 2, "viewed": 167, "published": 3, "date": "1682721149", "time_retrieved": "2024-07-30T17:58:34.065344", "image_code": "#define M(C, s) color = mix(color, C, clamp(s, 0., 1.)\n\nfloat circleSDF(vec2 st, vec2 center) {\n    return length(st - center) * 2.0;\n}\n\nfloat fill(float x, float size) {\n    float pw = 1.0 / iResolution.x;\n    return smoothstep(-pw, pw, size - x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = step(0.5, uv.x) == 0.0 ? vec3(0.506, 0.478, 0.506) : vec3(0.929, 0.725, 0.573);\n    \n    vec3 circleColor = vec3(0.69, 0.584, 0.518);\n    \n    float MX = iMouse.x / iResolution.x;\n    \n    float r = iResolution.x / iResolution.y;\n    \n    vec2 offset = vec2(0.17 - MX / 6.0, 0.0);\n    float circleLeft = circleSDF(uv * vec2(r, 1.0) + offset, vec2(r * 0.5, 0.5)) * step(uv.x, 0.4 + MX / 10.0);\n    float circleRight = circleSDF(uv * vec2(r, 1.0) - offset, vec2(r * 0.5, 0.5)) * step(0.6 - MX / 10.0, uv.x);\n    \n    float f = 7.0;\n    float nb = 4.0;\n    float s = 0.5;\n    \n    color = M(circleColor, 1.0 - fill(fract(min(circleLeft * f, nb)), s)));\n    color = M(circleColor, 1.0 - fill(fract(min(circleRight * f, nb)), s)));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dld3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 95, 95, 135], [137, 137, 170, 170, 250]], "test": "untested"}
{"id": "mtc3R2", "name": "RGB Ascend - 149 chars", "author": "GregRostami", "description": "A fork of testaccountplsignore's \"inverted sphere structure\" shader:\n[url[https://www.shadertoy.com/view/DttGR8[/url]\nCan you make it shorter?", "tags": ["raymarching", "short", "elevator", "golf"], "likes": 7, "viewed": 258, "published": 3, "date": "1682713490", "time_retrieved": "2024-07-30T17:58:34.910086", "image_code": "// This is a fork of testaccountplsignore's \"inverted sphere structure\" shader:\n// https://www.shadertoy.com/view/DttGR8\n\n// 149 chars - Fabrice RUTHLESSLY killed 3 chars!\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec4 f = o*0.;\n    for (f.y = .1*iTime; f.a++ < 1e2;)\n         f += vec4(u/iResolution.y-.4, 1, 0)/4. * (.7 - length(o=fract(f+f+.5)-.5));\n    o /= f.z; \n}\n\n\n// 152 chars - Original shader by Greg Rostami\n/*\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o *= 0.;\n    vec4 f;\n    for (o.y=.2*iTime; o.a++ < 1e2;)\n        o += .5*vec4(u/iResolution.y-.4, 1, 0) * (.7-length(f=fract(o+.5)-.5));\n    o = 2.*f/o.z;\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtc3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 172, 208, 208, 368]], "test": "untested"}
{"id": "ml3GR2", "name": "depth of field study 3 + refract", "author": "morisil", "description": "Testing something out", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 6, "viewed": 233, "published": 3, "date": "1682709076", "time_retrieved": "2024-07-30T17:58:35.732885", "image_code": "// Copyright Kazimierz Pogoda, 2023 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\nconst float SHAPE_SIZE = .5;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 20.;\nconst float INITIAL_LUMA = .5;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sphere(in vec2 st, in float size) {\n    float dist = length(st) / size;\n    float value = sqrt(4. - dist * dist * 4.);\n    value = clamp(value, 0., 100.);\n    return value;// *\n     //* smoothstep(SIZE + EDGE_BLUR, SIZE - EDGE_BLUR, dist);\n}\n\nfloat getRefraction(in vec2 st, in float modScale, in float radius) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    return sphere(modSt, radius);\n}\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .14) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .5 + sin(iTime * .5) * .3;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .12), cos(iTime * .13));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getRefraction(center, modScale, .5 + sin(i * 16.3 + iTime * .834) * .4) * 1.5 * sin(iTime * .13);\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .8;\n        blur *= .63;\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3GR2.jpg", "access": "api", "license": "proprietary-license", "functions": [[826, 826, 854, 854, 940], [942, 942, 983, 983, 1189], [1191, 1191, 1260, 1260, 1358], [1360, 1360, 1431, 1431, 1667], [1669, 1669, 1724, 1724, 2826]], "test": "untested"}
{"id": "Dl33R2", "name": "Ball Roller", "author": "dr2", "description": "Balls rolling...", "tags": ["mechanics", "ball", "track"], "likes": 24, "viewed": 301, "published": 3, "date": "1682676966", "time_retrieved": "2024-07-30T17:58:36.483878", "image_code": "// \"Ball Roller\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nconst int nBall = 5;\nvec3 bPos[nBall], qHit, ltDir;\nvec2 aTurnCs;\nfloat dstFar, tCur, tRad, bRad;\nint idObj;\nconst int idTrk = 1, idSup = 2, idBas = 3, idBall = 4;\nconst float pi = 3.1415927;\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dc, r, rm, rs, a, hMax, ts, tw;\n  dMin = dstFar;\n  hMax = 3.;\n  tw = 0.02;\n  ts = bRad + tw + 0.01;\n  p.y -= tRad - hMax + 2.;\n  q = p;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (float (2 * nBall) * a) + 0.5) / float (2 * nBall));\n  rm = length (q.xy) - tRad;\n  rs = 0.2 * tRad - r;\n  d = abs (length (vec2 (rm, q.z)) - ts) - tw;\n  d = max (max (max (d, - rm), rs), tRad - hMax + q.y);\n  DMINQ (idTrk);\n  d = max (max (max (length (vec2 (abs (q.x + 0.65 * tRad) - 0.25 * tRad, q.z)) - 0.15,\n     0.3 - rm), - q.y - tRad - 0.4), q.y);\n  DMINQ (idSup);\n  q = p;\n  q.xz = Rot2Cs (q.xz, aTurnCs);\n  rm = length (q.xy) - tRad;\n  dc = length (vec2 (rm, q.z)) - ts;\n  d = max (max (max (abs (dc) - tw, - rm), 0.025 - rs), q.y);\n  DMINQ (idTrk);\n  q.y -= - tRad - 0.25;\n  d = max (max (r - 0.15 * tRad, abs (q.y) - 0.18), - dc);\n  DMINQ (idSup);\n  q.y -= - 0.15;\n  d = PrCylDf (q.xzy, tRad + 0.5, 0.05);\n  DMINQ (idBas);\n  for (int n = 0; n < nBall; n ++) {\n    q = p - bPos[n];\n    d = PrSphDf (q, bRad);\n    DMINQ (idBall + n);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nfloat BAng (float s)\n{\n  return 0.36 * pi * sin (0.5 * tCur + 2. * s);\n}\n\nvec4 BCol ()\n{\n  vec3 q, col;\n  float s;\n  col = vec3 (0.7, 0.6, 0.1);\n  s = pi * float (idObj - idBall) / float (nBall);\n  q = qHit;\n  q.xz = Rot2D (qHit.xz, s + 0.5 * pi);\n  q.xy = Rot2D (q.xy, BAng (s) * tRad / bRad);\n  if (abs (q.z) < 0.03) col = vec3 (1., 1., 0.3);\n  else col = (q.z * (mod (pi + atan (q.x, q.y), 2. * pi) - pi) > 0.) ? vec3 (0., 1., 1.) :\n     vec3 (1., 0., 1.);\n  return vec4 (col, 0.2);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL, a, aMin, s, sMin;\n  tRad = 5.;\n  bRad = 0.25;\n  aMin = 99.;\n  for (int n = 0; n < nBall; n ++) {\n    s = pi * float (n) / float (nBall);\n    a = BAng (s);\n    if (abs (a) < aMin) {\n      aMin = abs (a);\n      sMin = s;\n    }\n    bPos[n] = vec3 (0., - tRad * sin (a + vec2 (0.5 * pi, 0.)));\n    bPos[n].xz = Rot2D (bPos[n].xz, - s);\n  }\n  aTurnCs = sin (sMin + 0.5 * pi + vec2 (0.5 * pi, 0.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == idTrk) {\n      col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.9 + 0.1 * cos (128. * atan (qHit.x, qHit.y)));\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.7, 0.5, 0.2, 0.1) * (0.9 + 0.1 * sin (2. * pi * fract (8. * qHit.y)));\n    } else if (idObj == idBas) {\n      col4 = vec4 (0.5, 0.6, 0.5, 0.1) * (0.97 + 0.03 * sin (32. * float (nBall) *\n         atan (qHit.z, qHit.x)));\n    } else if (idObj >= idBall) {\n      col4 = BCol ();\n      nDotL *= nDotL;\n    }\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  zmFac = 4.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 2. * abs (az);\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, 0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -24.);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl33R2.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[661, 661, 683, 683, 1824], [1826, 1826, 1859, 1859, 2043], [2045, 2045, 2066, 2066, 2321], [2323, 2323, 2360, 2360, 2589], [2591, 2591, 2613, 2613, 2663], [2665, 2665, 2679, 2679, 3078], [3080, 3080, 3115, 3115, 4423], [4425, 4425, 4481, 4481, 5595], [5597, 5597, 5630, 5630, 5657], [5659, 5659, 5701, 5701, 5752], [5754, 5754, 5790, 5790, 5996], [5998, 5998, 6028, 6028, 6141], [6143, 6143, 6174, 6174, 6238]], "test": "untested"}
{"id": "ctd3RS", "name": "sdEllipse-bimbo", "author": "jorge2017a2", "description": "sdEllipse-bimbo", "tags": ["sdellipsebimbo"], "likes": 11, "viewed": 179, "published": 3, "date": "1682629275", "time_retrieved": "2024-07-30T17:58:37.406412", "image_code": "//--------Por Jorge.F.P.----jorge2017a1\n//----27-abril-2023-\n//sdEllipse-bimbo\n//-----No optimo codigo :)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(1.0),b,d)\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nvec3 OrejaDer(vec2 uv ,vec3 col )\n{\nfloat d1 ,d2,d3,d4,d5 ;\nfloat df;\n\nvec2 p1 ,p2,p3,p4,p5,p6,p7;\nfloat r1,r2, r3, r4, r5 ;\n\np1 = vec2(2.57, 3.48); r1 = 0.25;\np2 = vec2(2.35, 3.31); r2 = 0.25;\np3 = vec2(2.56, 3.7); r3 = 0.2;\np4 = vec2(2.795, 3.895); r4 = 0.125;\np5 = vec2(2.65, 3.86); r5 = 0.2;\n\nd1 = sdCircle(uv- p1, r1);\nd2 = sdCircle(uv- p2, r2);\nd3 = sdCircle(uv- p3, r3);\nd4 = sdCircle(uv- p4, r4);\nd5 = sdCircle(uv- p5, r5);\ndf = unionSDF(d1, d2);\ndf = unionSDF(df, d3);\ndf = unionSDF(df, d4);\ndf = unionSDF(df, d5);\ncol = DrawFigBorde(vec3(0., 0., 0.), col, df);\nreturn col;\n\n}\n\n\nvec3  Boca(vec2 uv,vec3 colOut)\n{\nfloat d1 ,d2,d3,d4;\nfloat df;\nvec2 p1 ,p2,p3,p4;\nfloat a1 ,b1 , a2 ,b2,a3,b3,a4,b4;\nvec3 col;\ncol=colOut;\n\np1 = vec2(1.66, 2.255); a1 = 0.76; b1 = 0.445;\np2 = vec2(1.665, 2.37); a2 = 0.785; b2 = 0.47;\n\nd1 = sdEllipse(uv- p1, vec2(a1, b1));\nd2 = sdEllipse(uv- p2, vec2(a2, b2));\ndf = differenceSDF(d1, d2);\n    col = DrawFigBorde(vec3(0., 0., 0.), col, df);\nreturn col;\n\n}\n\n\nvec3 OrejaIzq(vec2 uv,vec3 col )\n{\nfloat d1 ,d2,d3,d4,d5;\nfloat df;\n\nvec2 p1 ,p2,p3,p4,p5,p6,p7;\nfloat r1,r2, r3, r4, r5 ;\n\np1 = vec2(0.72, 3.37); r1 = 0.25;\np2 = vec2(0.88, 3.32); r2 = 0.25;\np3 = vec2(0.72, 3.65); r3 = 0.2;\np4 = vec2(0.475, 3.885); r4 = 0.175;\np5 = vec2(0.64, 3.93); r5 = 0.2;\nd1 = sdCircle(uv- p1, r1);\nd2 = sdCircle(uv- p2, r2);\nd3 = sdCircle(uv- p3, r3);\nd4 = sdCircle(uv- p4, r4);\nd5 = sdCircle(uv- p5, r5);\ndf = unionSDF(d1, d2);\ndf = unionSDF(df, d3);\ndf = unionSDF(df, d4);\ndf = unionSDF(df, d5);\ncol = DrawFigBorde(vec3(0., 0., 0.), col, df);\nreturn col;\n}\n\nvec3 LineaNariz(vec2 p, vec3 colOut)\n{\n    float  d1=sdBox(p-vec2(1.7,1.9), vec2(0.025,0.1) );\n    vec3 col = DrawFigBorde(vec3(0., 0., 0.), colOut, d1);\n    return col;\n}\n\nvec3 Cabeza(vec2 uv,vec3 col) \n{\nfloat d1 ,d2,d3,d4,d5 ,d6 ,d7 ,d8_,d9 ,d10;\nfloat d11,d12,d13,d14,d15,d16;\nfloat df;\n\nvec2 p1 ,p2,p3,p4,p5,p6,p7;\nvec2 p8 ,p9 ,p10, p11,p12, p13;\nvec2 p14, p15, p16 ,p17 , p18 ;\n\nfloat r1,r2, r3, r4, r5 ;\n\nfloat a1 ,b1 , a2 ,b2,a3,b3,a4,b4;\nfloat a5,b5,a6 ,b6,a7,b7,a8 ,b8;\n\nfloat a9,b9,a10,b10,a11,b11,a12,b12;\nfloat a13,b13,a14,b14,a15,b15, a16,b16;\nfloat a17 ,b17;\n\np1 = vec2(1.635, 2.215); a1 = 0.935;b1 = 0.445;\np2 = vec2(1.665, 2.125); a2 = 0.535; b2 = 0.445;\np3 = vec2(1.395, 2.735); a3 = 0.385; b3 = 0.395;\np4 = vec2(2.055, 2.735); a4 = 0.335; b4 = 0.395;\np5 = vec2(1.665, 2.585); a5 = 0.685; b5 = 0.395;\np6 = vec2(1.375, 2.685); a6 = 0.315; b6 = 0.385;\np7 = vec2(2.05, 2.695); a7 = 0.3; b7 = 0.385;\n//cornea izq\np8 = vec2(1.41, 2.83); a8 = 0.16; b8 = 0.22;\n//cornea der\np9 = vec2(2.025, 2.845); a9 = 0.135; b9 = 0.195;\n\n//nariz puntos\np10 = vec2(1.705, 2.175); a10 = 0.235; b10 = 0.145;\np11 = vec2(1.71, 2.185); a11 = 0.11; b11 = 0.045;\n\n/////base negro rostro //antes de blanco\np12 = vec2(1.64, 2.185); a12 = 1.06; b12 = 0.445;\np13 = vec2(1.635, 2.065); a13 = 0.585; b13 = 0.445;\n\n\n////------base2 negro rostro\n////union 3 puntos\np14 = vec2(1.635, 2.83); a14 = 1.035; b14 = 0.72;\np15 = vec2(1.62, 3.18); a15 = 0.71; b15 = 0.47;\np16 = vec2(1.025, 2.73); a16 = 0.435; b16 = 0.47;\n\nd1 = sdEllipse(uv- p1, vec2(a1, b1));\nd2 = sdEllipse(uv- p2, vec2(a2, b2));\nd3 = sdEllipse(uv- p3, vec2(a3, b3));\nd4 = sdEllipse(uv- p4, vec2(a4, b4));\n////frente ojo\nd5 = sdEllipse(uv-p5, vec2(a5, b5));\n////ojos otro color\nd6 = sdEllipse(uv- p6, vec2(a6, b6));\nd7 = sdEllipse(uv- p7, vec2(a7, b7));\nd8_ = sdEllipse(uv- p8, vec2(a8, b8));\nd9 = sdEllipse(uv- p9, vec2(a9, b9));\n//nariz\nd10 = sdEllipse(uv- p10, vec2(a10, b10));\nd11 = sdEllipse(uv- p11, vec2(a11, b11));\nd12 = sdEllipse(uv- p12, vec2(a12, b12));\nd13 = sdEllipse(uv- p13, vec2(a13, b13));\n//base rostro sup\nd14 = sdEllipse(uv- p14, vec2(a14, b14));\nd15 = sdEllipse(uv- p15, vec2(a15, b15));\nd16 = sdEllipse(uv- p16, vec2(a16, b16));\ndf = d1;\ndf = unionSDF(df, d2);\ndf = unionSDF(df, d3);\ndf = unionSDF(df, d4);\ndf = unionSDF(df, d5);\n\n//base rostro\ncol = DrawFigBorde(vec3(0.), col, d12);\ncol = DrawFigBorde(vec3(0.), col, d13);\n//base rostro sup\ncol = DrawFigBorde(vec3(0.), col, d14);\ncol = DrawFigBorde(vec3(0.), col, d15);\ncol = DrawFigBorde(vec3(0.), col, d16);\n//boca-blanco\ncol = DrawFigBorde(vec3(1.), col, df);\n//ojo base\ncol = DrawFigBorde(vec3(1.), col, d6);\ncol = DrawFigBorde(vec3(1.), col, d7);\n////cornea\ncol = DrawFigBorde(vec3(0.), col, d8_);\ncol = DrawFigBorde(vec3(0.), col, d9);\n//nariz\ncol = DrawFigBorde(vec3(0.), col, d10);\ncol = DrawFigBorde(vec3(1.), col, d11);\n\ncol = OrejaIzq(uv, col);\ncol = OrejaDer(uv, col);\ncol = Boca(uv, col);\ncol=LineaNariz(uv,col);\nreturn col;\n\n}\n\n// zoom --- Mini Droste Zoom...https://www.shadertoy.com/view/Ml33R7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    vec2 uv0=uv*2.0-vec2(0.0,-1.0);\n    uv*=8.0;\n    \n    vec2 z=uv;float t=iTime;\n     z = vec2(log(length(z)),atan(z.y,z.x));\n     z = exp(z.x-mod(t*0.8,10.0)) * vec2( cos(z.y), sin(z.y));\n     \n    vec2 c = abs(z);\n    uv=.5+z*exp2(ceil(-log2(max(c.y,c.x))-0.015));\n    \n    vec3 col =0.5 + 0.5*cos(t+uv.xyx+vec3(0,2,4));\n    \n    col= Cabeza(uv-vec2(-1.5,-1.0),col);\n    if( sin(t*2.0)>0.0)\n    col= Cabeza(uv0-vec2(-1.5,-1.0),col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//---2D primitives---IQ\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctd3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 331, 331, 457], [458, 458, 539, 539, 667], [669, 669, 716, 716, 743], [744, 744, 787, 787, 814], [815, 815, 863, 863, 891], [894, 894, 929, 929, 952], [954, 954, 991, 991, 1065], [1068, 1068, 1103, 1103, 1653], [1656, 1656, 1689, 1689, 2061], [2064, 2064, 2098, 2098, 2646], [2648, 2648, 2686, 2686, 2819], [2821, 2821, 2853, 2853, 5604], [5676, 5676, 5733, 5733, 6348]], "test": "untested"}
{"id": "dlcGzB", "name": "psycho-delic mind fault", "author": "timmaffett", "description": "perverted \"different noise\" - use mouse to take over rotate/zoom and explore the nervous breakdown ;)", "tags": ["voronoi"], "likes": 5, "viewed": 193, "published": 3, "date": "1682621479", "time_retrieved": "2024-07-30T17:58:38.363851", "image_code": "// Fork of \"different noise\" by WhiteWalrus518. https://shadertoy.com/view/mt2SDy\n// 2023-04-27 18:38:06\n\n#define res iResolution\n#define t iTime\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.5*sin(iTime/8.0),0.2+.3*cos((iTime/2.))) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n    \nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat r(float a){\n    return random2(vec2(a, 3.14159)).x;\n}\n\nvec2 randcis(vec2 seed, float time){\n    vec2 ra = random2(seed);\n    vec2 rb = random2(ra + seed);\n    vec2 rc = random2(rb + seed);\n    return vec2(ra.x * sin(pi * (rb.x * time + rc.x)),\n                ra.y * cos(pi * (rb.y * time + rc.y)));\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/res.y;\n    \n \n    \n    vec2 st = uv - vec2(res.x/res.y, 1.0) * 0.5;\n    \n    st = mouseRotZoom(st);\n\n  \n    st *= 25.0;\n    \n    \n\n    vec2 cor = floor(st);\n    \n    float minda =  999.0;\n    float mindb = 1000.0;\n    float mindc = 1001.0;\n    for(int x = -2; x < 3;x++){\n        for(int y = -2; y < 3; y++){\n            vec2 test = cor + vec2(float(x), float(y));\n            vec2 centre = test + random2(test) + randcis(test, t);\n            float dist = length(centre - st);\n            if(dist < minda){\n                mindc = mindb;\n                mindb = minda;\n                minda = dist;\n            }else{\n                if(dist < mindb){\n                    mindc = mindb;\n                    mindb = dist;\n                }\n                else{\n                    if(dist < mindc){\n                        mindc = dist;\n                    }\n                }\n            }\n        }\n    }\n    \n    \n    // Time varying pixel color\n    //vec3 col = vec3(1.0);\n    vec3 col = hsb2rgb( vec3(max(minda,mindb)*uv.x/st.y, mindb*0.8, 0.9) );\n    \n    if(mindc - mindb < (20.0 * (1.0 + sin(t * pi * 0.3)) - length(st))* 0.01 ){\n        //col = vec3(0.0);\n        col = hsb2rgb( vec3(minda*st.y*uv.x*0.3/*/uv.x*/, mindc*0.8, 0.9) );\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 236, 236, 285], [287, 287, 315, 354, 557], [563, 563, 590, 590, 825], [828, 828, 852, 852, 945], [947, 947, 964, 964, 1006], [1008, 1008, 1044, 1044, 1263], [1265, 1265, 1322, 1370, 2677]], "test": "untested"}
{"id": "dt3GzB", "name": "Smokey Disco Godrays", "author": "timmaffett", "description": "Disco Godrays\" by @kishimisu (2023) - https://www.shadertoy.com/view/Dt33RS\nchanged texture and sampling to get 'smoke rings fill the air' effect..", "tags": ["raymarching", "ray", "rays", "fog", "rotation", "god", "neon", "short", "density", "golf"], "likes": 6, "viewed": 332, "published": 3, "date": "1682618483", "time_retrieved": "2024-07-30T17:58:39.309323", "image_code": "// Fork of \"Disco Godrays [483 chars]\" by kishimisu. https://shadertoy.com/view/Dt33RS\n// 2023-04-27 17:51:23\n\n/* \"Disco Godrays\" by @kishimisu (2023) - https://www.shadertoy.com/view/Dt33RS\n\n   These are \"fake\" godrays made without tracing any additional ray.\n   The maximum raymarching step size is set to 0.1 in order to sample the scene\n   frequently (very inneficient) and some blue noise is added to reduce artefacts.\n*/\n#define iTime (iTime*0.75)\n\n#define r(p) mat2(cos(round((atan(p.y,p.x)+k)/f)*f-k + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n\n\n    float f = .2856, d = f, k = iTime*f, t;\n    vec4  p, a = O *= t = 0.;\n    vec2 R = iResolution.xy;\n    vec2 textSamp =  F/1024.+fract(k/20.);\n    vec4 sv = normalize(vec4((F+F-R)/R.y, 1, 0));\n    \n    for (float i=0.;i<6e1;i++) {\n        if(d <= .01) break;\n        p.z -= 2.;\n        p.zx *= r(p.xz);\n        p.yx *= r(p.xy);\n        \n        a += smoothstep(.02, .0, length(p.yz) - .05) *\n             smoothstep( 1., .0, length(p)    -  1.) *\n             (1. + cos(k+k + t+t + vec4(0,1,2,0)));\n             \n        t += d = min(max(length(p) - 1., .05 - length(p.yz)),\n                 .1 + texture(iChannel0, textSamp).r*.026);\n        p = t*sv;\n    }\n                 \n    O = .5*mix(O+.3, a, exp(-t*.1));\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3GzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[529, 529, 565, 565, 1286]], "test": "untested"}
{"id": "mtc3RB", "name": "Simple Rain Ripple", "author": "i11212", "description": "Free to use", "tags": ["ex"], "likes": 5, "viewed": 302, "published": 3, "date": "1682617269", "time_retrieved": "2024-07-30T17:58:40.054331", "image_code": "/*\nMade By I11212\nTwitter: https://twitter.com/i11212_?t=us2GzKso5JLrTiwYIxuueg&s=09\nYoutube: https://youtube.com/channel/UCg21GlDi4TtGe-9CNpSlR9A\n*/\n\n#define saturate(x) clamp(x,0.0,1.0)\n#define rot(x) mat2(cos(x), sin(x), -sin(x), cos(x))\n\nhighp float hash(\n\thighp vec2 x){\nreturn fract(sin(\n\tdot(x,vec2(11,57)))*4567.0+iTime);\n\t}\n\nhighp float ripple(\n\thighp vec2 x,\n\thighp float k){\nhighp float r = hash(floor(x)),\nd = length(fract(x)-0.5);\n\nreturn smoothstep(0.05,0.025,distance(d, r*k))*\n\tsmoothstep(0.5,0.475,d)*((1.0-r)*k);\n\t}\n\nhighp float ripple(\n\thighp vec2 x){\nhighp float result = 0.0;\nfor(int i = 0; i<3; i++){\nx -= 6.0, x *= rot(0.3333),\nresult += ripple(x+iTime*0.5,float(i)/3.0+1.0);\n\t}\nreturn result;\n\t}\n\nhighp vec3 norm(\n\thighp vec2 x) {\nhighp float\n\nm = 0.01,\nr = ripple(x-vec2(m,0)),\ng = ripple(x-vec2(0,m)),\nb = ripple(x);\n\nr = r-b,\ng = g-b;\nb = 1.0-(r+g);\n\nreturn (vec3(r+0.5,g+0.5,b*m+1.0));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - iResolution.xy*0.5) / (\n\t\tiResolution.x, iResolution.y);\n\n\tvec3 n = norm(uv*6.0);\n    \n    if(uv.x>sin(iTime)){\n    uv = reflect(vec3(uv,1),\n    normalize(n*2.0-1.0)*0.125).xy;\n    n = texture(iChannel0, uv).rgb;\n    }\n    \n\tfragColor = vec4(n,1);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtc3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[918, 918, 973, 973, 1247]], "test": "untested"}
{"id": "Dt33RS", "name": "Disco Godrays [411 chars]", "author": "kishimisu", "description": "I spent quite some time going from 800+ down to 483 chars!", "tags": ["raymarching", "ray", "rays", "fog", "rotation", "god", "neon", "short", "density", "golf"], "likes": 54, "viewed": 1930, "published": 3, "date": "1682583348", "time_retrieved": "2024-07-30T17:58:40.934976", "image_code": "/* \"Disco Godrays\" by @kishimisu (2023) - https://www.shadertoy.com/view/Dt33RS\n   [68 chars shorter thanks to the amazing shadertoy community!]\n   \n   These are \"fake\" godrays made without tracing any additional ray.\n   The maximum raymarching step size is set to 0.1 in order to sample the scene\n   frequently (very inneficient) and some blue noise is added to reduce artefacts.\n*/\n\n#define M(p) p *= mat2(cos(round((atan(p.x,p.y)+k)/.3)*.3-k + vec4(0,33,11,0)));//\n#define S cos( k - t + vec4(0,.5,1,0)) * smoothstep( 1., 0.//\n#define L length(p\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float i = .0, t = i, d=.3, k = iTime*d, l;\n    for ( O *= i; \n          i++ < 60. && d > .01;\n          t -= d = min(max(l,-d), .1 + texture(iChannel0, F/1024.).r*.06) )\n    {\n        vec3 R = iResolution,\n        p = R-vec3(F+F,R.y);\n        p = t/L)*p-2./R;\n        M(p.zx) M(p.yx)\n        O +=  S, (d = L.yz) -.05) / .02) \n            * S,  l = L)    - 1.       ) + .002;\n    }\n    O *= exp(t*.1);   \n}\n\n/* Original version [483 chars]\n\n#define r(p) mat2(cos(round((atan(p.y,p.x)+k)/f)*f-k + vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float i = 0., f = .2856, d = f, k = iTime*f, t;\n    vec4  p, a = O *= t = i;\n          \n    for (vec2 R = iResolution.xy; i++ < 6e1 && d > .01;\n        p = t*normalize(vec4((F+F-R)/R.y, 1, 0))) {\n        p.z -= 2.;\n        p.zx *= r(p.xz);\n        p.yx *= r(p.xy);\n        \n        a += smoothstep(.02, .0, length(p.yz) - .05) *\n             smoothstep( 1., .0, length(p)    -  1.) *\n             (1. + cos(k+k + t+t + vec4(0,1,2,0)));\n             \n        t += d = min(max(length(p) - 1., .05 - length(p.yz)),\n                 .1 + texture(iChannel0, F/1024.).r*.06);\n    }\n                 \n    O = .5*mix(O+.3, a, exp(-t*.1));\n}*/", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt33RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtd3W7", "name": "try to look a chicken in the eye", "author": "veravandeseyp", "description": "It's a spiral idk what is happening but i think it looks nice, based on this one https://www.shadertoy.com/view/WtjSWt", "tags": ["help"], "likes": 3, "viewed": 145, "published": 3, "date": "1682566457", "time_retrieved": "2024-07-30T17:58:41.679985", "image_code": "\nfloat spiralWave(vec2 p, float ratio, float rate, float scale) {\n    \n    float r = length(p);\n    float theta = atan(p.x,p.y);\n   \n    float logspiral = log(r)/ratio + atan(theta);\n    return sin(rate*iTime - scale*logspiral);\n}\n\n\nfloat spiralToEllipse(vec2 p, float ratio, float rate, float scale, float transitionRadius) {\n    \n    float r = length(p);\n    float theta = atan(p.x,p.y);\n    float mini = min( (r - transitionRadius*1.7), 0.1);\n   \n    float logspiral = log(r)/ratio/ mini + atan(theta);\n    float spiralValue = tan(rate*iTime - scale*logspiral);\n    \n    if (r > transitionRadius) {\n       // float ellipseValue = sin(rate*iTime - scale*r);\n        float ellipseValue = -10.;\n        float t = smoothstep(transitionRadius, transitionRadius + 0.1, r);\n        return mix(spiralValue, ellipseValue, t);\n        return -10.0;\n    } else {\n        return spiralValue;\n    }\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\t\n   float goldenRatio = 0.618;\n    //float goldenRatio  = 0.3;   \n      float tt = time/50000.0;\n      \n    float red = 0.5 + 0.5 * spiralToEllipse(p, goldenRatio, sin(2.5 - tt), 4.98, 0.35);\n    \n    //float green = 0.5 + 0.5 * spiralToEllipse(p,goldenRatio, 2.5 + tan(tt + tan(tt/30.)*1.2) *2.5 , 4.98, 0.35);\n    float green =  spiralToEllipse(p,goldenRatio, 2.5 + tan(tt) *2.5, 4.98, 0.35);\n    float blue = 0.5 + 0.5 * spiralToEllipse(p, goldenRatio, sin(2.5 + tt), 4.98, 0.35);\n    \n    float gray =0.5 + 0.5 * spiralToEllipse(p,goldenRatio, 4.0, 4.98, 0.41 );\n    \n    vec3 color = vec3(red,  0, blue );\n    // vec3 color = vec3( gray );\n \tfragColor  = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtd3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 65, 65, 230], [233, 233, 326, 326, 895], [898, 898, 955, 955, 1719]], "test": "untested"}
{"id": "Dlt3D7", "name": "Procedural Water Texture", "author": "ThePlaneGuy45", "description": "wtre\n\nwas messing around with noise functions and found this :P", "tags": ["water"], "likes": 13, "viewed": 463, "published": 3, "date": "1682547986", "time_retrieved": "2024-07-30T17:58:42.532705", "image_code": "float getHeight(vec2 fragCoord) {\n\n    return dot(texture(iChannel0, mod(fragCoord/iResolution.xy, 1.0)).rgb, vec3(.2126, .7152, .0722));\n\n}\n\nvec4 normal(vec2 fragCoord) {\n\n    float current = getHeight(fragCoord);\n    float x = (getHeight(fragCoord + vec2(1.0, 0.0)) - current) * BUMPSTRENGTH;\n    float y = (getHeight(fragCoord + vec2(0.0, 1.0)) - current) * BUMPSTRENGTH;\n    return vec4(normalize(vec3(x, y, 1.0)), current);\n\n}\n\nvec3 tint(vec3 color) {\n\n    return mix(vec3(0.1, 0.3, 0.5), color, 75.0 / (DEPTH + 75.0));\n\n}\n\nvec3 shade(vec2 fragCoord) {\n\n    vec4 norm = normal(fragCoord);\n    \n    #ifdef LIGHT\n    \n    vec3 lightNorm = normalize(vec3(0.1, -0.1, 1.0));\n    \n    float diff = dot(norm.xyz, lightNorm);\n    \n    vec2 refracNorm = (refract(vec3(0.0, 0.0, -1.0), norm.xyz, 0.35) * DEPTH).xy + fragCoord.xy;\n    vec2 coord = refracNorm / iResolution.xy;\n    \n    #ifdef SPEC\n    \n    float specang = acos(diff);\n    float specexp = specang / (1.0-SPECULAR);\n    float spec = exp(-specexp * specexp) * SPECULAR;\n    \n    #else\n    \n    float spec = 0.0;\n    \n    #endif /* SPEC */\n    \n    return (tint(texture(iChannel1, coord).rgb) + vec3(spec)) * LIGHTSTRENGTH;\n\n    #else\n    \n    return norm.xyz;\n    \n    #endif /* LIGHT */\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(shade(fragCoord),1.0);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvec3 random (in vec2 st) {\n    vec3 r;\n    r.x = fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n    r.y = fract(sin(dot(st.xy + vec2(st.x), vec2(12.9898,78.233))) * 43758.5453123);\n    r.z = fract(sin(dot(st.xy + vec2(st.y), vec2(12.9898,78.233))) * 43758.5453123);\n    return r;\n}\n\nvec3 noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec3 a = random(i);\n    vec3 b = random(i + vec2(1.0, 0.0));\n    vec3 c = random(i + vec2(0.0, 1.0));\n    vec3 d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec3 fbm (in vec2 st) {\n    vec3 value = vec3(0.0);\n    float amplitude = 0.5;\n    float frequency = 0.0;\n    for (int i = 0; i < 6; i++) {\n        value += amplitude * noise(st);\n        st = st * rot2(0.5) * 2.0 + vec2(100.0, 0.0);\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= SCALE;\n    \n    vec2 p = vec2(fbm(uv + iTime * ROUGHNESS).r, fbm(uv - iTime * ROUGHNESS).r);\n    \n    fragColor = vec4(fbm(uv + p), 1.0);\n    \n}", "buffer_a_inputs": [], "common_code": "#define ROUGHNESS 0.25\n#define DEPTH 100.0\n\n#define LIGHT\n#define SPEC\n\n#define BUMPSTRENGTH 1000.0 * ROUGHNESS\n#define LIGHTSTRENGTH 1.0\n#define SPECULAR 0.92\n\n#define SCALE 2.0", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlt3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 140], [142, 142, 171, 171, 431], [433, 433, 456, 456, 527], [529, 529, 557, 557, 1248], [1250, 1250, 1307, 1307, 1353]], "test": "untested"}
{"id": "mtt3D4", "name": "PBR Pathtracer", "author": "ThePlaneGuy45", "description": "Added better material support, improved random normal function, etc\n(5/5/23) added anisotropy\n\nhttps://www.youtube.com/watch?v=Qz0KTGYJtUk\nhttps://www.shadertoy.com/view/XlXcW4\ncosine distro by reinder", "tags": ["raytracing", "textures", "pathtracing"], "likes": 4, "viewed": 226, "published": 3, "date": "1682546627", "time_retrieved": "2024-07-30T17:58:43.711554", "image_code": "// Shader settings in Common\n// Scene editor in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nPathtracer by TPG45\n\nfeel free to use as a base for other projects, just give credit\nalso feel free to expand on this, just give credit for the base pathtracer\n\nIncludes:\n- lighting, diffuse + specular + anisotropic\n- refraction\n- textures & cubemaps\n- DOF & blur\n- Multipass sampling\n- Normal maps\n*/\n\n// Shader Settings\n#define FOCAL_LENGTH 500.0\n#define CAM_DISTANCE 500.0\n#define MAX_BOUNCES 10\n#define SAMPLES 10\n#define DOF_AMOUNT 0.0\n#define BLUR_AMOUNT 2.0\n\n\n// Other random definitions\n#define T true\n#define F false\n#define PHI 1.61803398874989484820459\n\nstruct Material {\n\n    vec3 color;\n    bool useTexture;\n    bool useNormals;\n    int texID;\n    float texScale;\n    float bumpStrength;\n    \n    vec3 emission;\n    float emissionStrength;\n    \n    float sheen;\n    float roughness;\n    \n    float metallic;\n    float aniso;\n    \n    float transparency;\n    float ior;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Triangle {\n\n    Material material;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec2 auv;\n    vec2 buv;\n    vec2 cuv;\n\n};\n\nstruct Plane {\n\n    Material material;\n    vec3 normal;\n    float height;\n    float scale;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n    int refrac;\n    int objID;\n    int hitID;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n// Extra trig + hyperbolic functions by me, if you want to use please credit.\nfloat cot(float x){return cos(x)/sin(x);}vec2 cot(vec2 x){return cos(x)/sin(x);}vec3 cot(vec3 x){return cos(x)/sin(x);}vec4 cot(vec4 x){return cos(x)/sin(x);}float sec(float x){return 1./cos(x);}vec2 sec(vec2 x){return 1./cos(x);}vec3 sec(vec3 x){return 1./cos(x);}vec4 sec(vec4 x){return 1./cos(x);}float csc(float x){return 1./sin(x);}vec2 csc(vec2 x){return 1./sin(x);}vec3 csc(vec3 x){return 1./sin(x);}vec4 csc(vec4 x){return 1./sin(x);}float coth(float x){float a=exp(x);float b=exp(-x);return(a+b)/(a-b);}vec2 coth(vec2 x){vec2 a=exp(x);vec2 b=exp(-x);return(a+b)/(a-b);}vec3 coth(vec3 x){vec3 a=exp(x);vec3 b=exp(-x);return(a+b)/(a-b);}vec4 coth(vec4 x){vec4 a=exp(x);vec4 b=exp(-x);return(a+b)/(a-b);}float sech(float x){return 2./(exp(x)+exp(-x));}vec2 sech(vec2 x){return 2./(exp(x)+exp(-x));}vec3 sech(vec3 x){return 2./(exp(x)+exp(-x));}vec4 sech(vec4 x){return 2./(exp(x)+exp(-x));}float csch(float x){return 2./(exp(x)-exp(-x));}vec2 csch(vec2 x){return 2./(exp(x)-exp(-x));}vec3 csch(vec3 x){return 2./(exp(x)-exp(-x));}vec4 csch(vec4 x){return 2./(exp(x)-exp(-x));}\n\nuint raySphere(in Sphere sph, inout Record rec) {\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    rec.objID++;\n    if (disc > 0.0) {\n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        if(dstNear < rec.dist) {\n            if(dstNear > 0.0) {\n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.offset = (rec.intersect - sph.center - sph.radius) / sph.radius - 0.5;\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                rec.hitID = rec.objID;\n                return uint(0x1);\n            }\n        }\n        return uint(0x0);\n    }\n}\nuint rayTri(in Triangle tri, inout Record rec) {\n    vec3 ab = tri.b - tri.a;\n    vec3 ac = tri.c - tri.a;\n    vec3 bc = tri.c - tri.b;\n    vec3 normal = ab.yzx * ac.zxy - ab.zxy * ac.yzx;\n    vec3 ao = rec.ray.origin - tri.a;\n    vec3 dao = cross(ao, rec.ray.normal);    \n    float det = 1.0 / (-dot(rec.ray.normal, normal));    \n    float dist = dot(ao, normal) * det;\n    float u = dot(ac, dao) * det;\n    float v = -dot(ab, dao) * det;\n    float w = 1.0 - u - v;    \n    bool hit = det >= 1e-6 && dist >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;    \n    rec.objID++;\n    if(hit && dist < rec.dist) {    \n        rec.intersect = (rec.ray.normal * dist) + rec.ray.origin;\n        rec.normal = normalize(normal);\n        rec.dist = dist;\n        rec.material = tri.material;\n        rec.hit = true;\n        rec.offset = vec3(u, v, w);\n        \n        float xba = tri.buv.x - tri.auv.x;\n        float xcb = tri.cuv.x - tri.buv.x;\n        float yba = tri.buv.y - tri.auv.y;\n        float ycb = tri.cuv.y - tri.buv.y;\n        rec.tangent = normalize(ycb * ab - yba * bc);\n        rec.bitangent = normalize(-xcb * ab + xba * bc);\n        rec.hitID = rec.objID;\n        \n        return uint(0x1);\n    }\n    return uint(0x0);\n}\nuint rayPlane(in Plane plane, inout Record rec) {\n\n    rec.objID++;\n    float dist = -(dot(rec.ray.origin, plane.normal) - plane.height) / dot(rec.ray.normal, plane.normal);\n    \n    if(dist >= 0.0) {\n    \n        if(dist < rec.dist) {\n        \n            rec.intersect = (rec.ray.normal * dist) + rec.ray.origin;\n            rec.normal = plane.normal;\n            rec.dist = dist;\n            rec.material = plane.material;\n            rec.hit = true;\n            rec.offset = rec.intersect.xyz * plane.scale;\n            \n            rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n            if(rec.normal.x + rec.normal.z == 0.0) {\n            \n                rec.tangent = vec3(1.0, 0.0, 0.0);\n            \n            }\n            rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n            rec.hitID = rec.objID;\n            \n            return uint(0x1);\n        \n        }\n    \n    }\n    \n    return uint(0x0);\n\n}\nvec3 random(inout uvec3 state) {\n\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    \n    return vec3(state)*(1.0/float(0xffffffffU));\n\n}\nvec3 randomNormal(vec3 n, inout uvec3 state) {\n\n    vec2 rv2 = random(state).xy;\n\n    vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n\n}", "buffer_a_code": "/*\n\nMaterial Guide:\n    \n    Material(\n        vec3 color, // Albedo color if you aren't using textures\n        bool useTexture, // Whether you are using a texture or not\n        bool useNormals, // Whether you are using a normal map or not\n        int texID, // Which channel to get the texture from (1 - 3)\n        float texScale, // Scale of the texture\n        float bumpStrength, // Strength of the normal map\n        \n        vec3 emission, // Emission color\n        float emissionStrength, // Strength of Emission\n        \n        float sheen, // Reflectiveness\n        float roughness, // Roughness of reflection\n        float metallic, // Metallicness\n        float aniso, // Anisotropic strength\n        \n        float transparency, // Transparancey\n        float ior, // Index of Refraction\n    )\n\n*/\n\n// Scene Editor ////////////////////////\nvoid distances( inout Record rec ) {\n    raySphere( Sphere( Material(vec3(0.3, 0.0, 1.0), F, F, 0, 1.0, 1.0, /**/ vec3(0.0), 0.0, 1.0, 0.3 , 1.0, 0.0, 0.0, 0.0 /**/), vec3(0.0, 100.0, 300.0), 100.0 ), rec );\n    raySphere( Sphere( Material(vec3(0.0, 0.0, 0.0), T, T, 3, 0.25, 10.0, /**/ vec3(0.0), 0.0, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0 /**/), vec3(0.0, 100.0, -300.0), 100.0 ), rec );\n    raySphere( Sphere( Material(vec3(1.0, 0.5, 0.5), F, T, 2, 1.0, 2.5, /**/ vec3(0.0), 0.0, 0.1, 0.0, 0.0, 0.0, 0.8, 1.2 /**/), vec3(300.0, 100.0, 0.0), 100.0 ), rec );\n    raySphere( Sphere( Material(vec3(0.9, 0.4, 0.9), F, F, 0, 0.0, 00.0, /**/ vec3(1.0, 0.7, 0.0), 2.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0 /**/), vec3(-300.0, 100.0, 0.0), 100.0 ), rec );\n    \n    rayTri( Triangle( Material(vec3(0.5, 0.5, 0.5), T, T, 1, 1.0, 10.0, /**/ vec3(0.0), 0.0, 0.3, 0.0, 0.0, 0.0, 0.0, 0.0 /**/), vec3(0.0, 100.0, 300.0), vec3(300.0, 100.0, 0.0), vec3(0.0, 100.0, -300.0), vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0) ), rec );\n    \n    raySphere( Sphere( Material(vec3(1.0), F, F, 0, 0.0, 0.0, /**/ vec3(0.0), 0.0, 1.0, 0.2, 1.0, 0.25, 0.0, 0.0 /**/), vec3(0.0, -100000.0, 0.0 ), 100000.0 ), rec );\n}\n////////////////////////////////////////\n\nvoid initRay( in vec2 fragCoord, inout Ray ray, uvec3 state ) {\n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    ray.origin = vec3(0.0, 0.0, -FOCAL_LENGTH) + vec3(random(state).xy * DOF_AMOUNT, 0.0);\n    ray.normal = normalize(vec3(fragCoord + random(state).x * BLUR_AMOUNT, 0.0) - ray.origin);\n    ray.origin.z -= CAM_DISTANCE;\n    mat2 rot = rot2(8.0 * mouse.y);\n    ray.origin.yz *= rot; ray.normal.yz *= rot;\n    rot = rot2(8.0 * mouse.x);\n    ray.origin.xz *= rot; ray.normal.xz *= rot;\n}\n\nvoid initRecord(inout Record rec, in Ray ray) {\n\n    rec.ray = ray;\n    rec.hit = false;\n    rec.dist = 100000.0;\n    rec.objID = 0;\n\n}\n\nvec4 triPlanar(sampler2D tex, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    vec3 blend = normalize(max(abs(normal), 0.000001));\n    float sum = blend.x + blend.y + blend.z;\n    blend /= sum;\n    vec4 x = texture(tex, offset.yz * scale + imgOffset);\n    vec4 y = texture(tex, offset.xz * scale + imgOffset);\n    vec4 z = texture(tex, offset.xy * scale + imgOffset);\n    return x * blend.x + y * blend.y + z * blend.z;\n\n}\n\nvec4 sampleTex(int id, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    switch(id){\n    case 1:\n        return triPlanar(iChannel1, offset, normal, scale, imgOffset);\n    case 2:\n        return triPlanar(iChannel2, offset, normal, scale, imgOffset);\n    case 3:\n        return triPlanar(iChannel3, offset, normal, scale, imgOffset);\n    }\n    return vec4(0.0);\n\n}\n\nfloat getHeight(vec4 tex) {\n\n    return dot(tex.rgb, vec3(.2126, .7152, .0722));\n\n}\n\nvec3 normal(int id, vec3 offset, vec3 normal, float scale, vec2 res, float strength) {\n\n    float current = getHeight(sampleTex(id, offset, normal, scale, vec2(0.0)));\n    float x = (getHeight(sampleTex(id, offset, normal, scale, vec2(1.0 / res.x, 0.0))) - current) * strength;\n    float y = (getHeight(sampleTex(id, offset, normal, scale, vec2(0.0, 1.0 / res.y))) - current) * strength;\n    return normalize(vec3(x, y, 1.0));\n\n}\n\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nvec3 Trace( in vec2 fragCoord, in uvec3 state ) {\n\n    vec3 final = vec3(0.0);\n\n    for( int i = 0; i < SAMPLES; i++ ) {\n\n        Ray ray;\n        Record rec;\n        initRay( fragCoord, ray, state );\n        initRecord( rec, ray );\n        rec.refrac = -1;\n    \n        vec3 color = vec3(0.0);\n        vec3 increment = vec3(1.0);\n    \n        for( int j = 0; j < MAX_BOUNCES; j++ ) {\n    \n            distances( rec );\n    \n            if( rec.hit ) {\n            \n                vec3 matColor;\n                vec3 nMap;\n            \n                if(rec.material.useTexture) {\n                    \n                    matColor = sampleTex(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, vec2(0.0)).rgb;\n                \n                } else {\n                \n                    matColor = rec.material.color;\n                \n                }\n                \n                if(rec.material.useNormals) {\n                \n                    nMap = normal(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, iChannelResolution[3].xy, rec.material.bumpStrength);\n                    rec.normal = worldSpace(nMap, rec.tangent, rec.bitangent, rec.normal);\n                \n                }\n                \n                vec3 aniso = normalize(vec3(0.0, sign(random(state).x * 2.0 - 1.0) * rec.material.aniso, 1.0));\n                \n                rec.normal = worldSpace(aniso, rec.tangent, rec.bitangent, rec.normal);\n                \n                float det = (1.0/(rec.material.roughness+1.0));\n                \n                float spec = float(rec.material.sheen > random(state).x) * det;\n                \n                vec3 diffuseCol = matColor * (1.0 - rec.material.metallic);\n                vec3 specCol = mix(vec3(1.0), matColor, rec.material.metallic * 0.5);\n                \n                rec.ray.origin = rec.intersect;\n                if(rec.material.transparency * det > random(state).x || rec.refrac == rec.hitID) {\n                \n                    rec.ray.normal = refract(rec.ray.normal, rec.normal, clamp(rec.refrac > 0 ? rec.material.ior : 1.0 / rec.material.ior, 0.0, 1.0));\n                    \n                    if(rec.refrac > -1) {\n                    \n                        rec.refrac = -1;\n                    \n                    } else {\n                    \n                        rec.refrac = rec.hitID;\n                    \n                    }\n                \n                } else {\n                \n                    vec3 diffuseNorm = randomNormal(rec.normal, state);\n                    vec3 reflectNorm = reflect(rec.ray.normal, rec.normal);\n                    rec.ray.normal = normalize(mix(diffuseNorm, reflectNorm, spec));\n                    \n                }\n                initRecord(rec, rec.ray);\n        \n                color += (rec.material.emission * rec.material.emissionStrength) * increment;\n                increment *= mix(diffuseCol, specCol, spec);\n    \n            } else {\n    \n                color += texture(iChannel0, rec.ray.normal).xyz * increment;\n                break;\n    \n            }\n        }\n    \n        final += color;\n        \n    }\n    \n    final /= float(SAMPLES);\n    \n    return final;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float ratio = 720.0/iResolution.y;\n    vec2 coord = ratio * fragCoord;\n\n    vec3 det = vec3(coord, iFrame);\n\n    uvec3 state = floatBitsToUint(det);\n    \n    fragColor = vec4(Trace( coord - ratio * iResolution.xy / 2.0, state ), 1.0);\n    \n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = texture(iChannel0, rayDir);\n}", "cube_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Save State Buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if(iMouse.z > 0.0) {\n    \n        fragColor = vec4(float(iFrame));\n        \n    }\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n\n    float frame = float(iFrame + 1) - texture(iChannel1, vec2(0.6, 0.5)).x;\n    \n    vec4 current = texture(iChannel2, uv);\n    \n    if(iMouse.z > 0.0) {\n    \n        fragColor = current;\n    \n    } else {\n    \n        fragColor = mix(fragColor, current, 1.0 / frame);\n    \n    }\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtt3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 197]], "test": "untested"}
{"id": "dtc3DM", "name": "illusion 11d2", "author": "FabriceNeyret2", "description": "motion without movment. no strips, just plain time sine.\nvariant of https://shadertoy.com/view/dtc3WM\nso no wave at all is necessary !", "tags": ["illusion", "perception"], "likes": 20, "viewed": 299, "published": 3, "date": "1682520868", "time_retrieved": "2024-07-30T17:58:44.516401", "image_code": "// variant of https://shadertoy.com/view/dtc3WM\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // float h = 450.; // R.y;\n    vec2 R = iResolution.xy,\n         U = 5.*( 2.*u - R ) / R.y,                                    // global normalize coords\n         I = floor(U)+.5,                                              // disc Id\n         F = fract(U)-.5,                                              // local disc coords\n         H = fract(1e4*sin(I*mat2(R-17.,R+71.)));                      // 2 random values \n         \n    float p = 15./R.y, l = length(F), L = length(U), i = length(I);\n    O = vec4( mix( .5,                                                 // bg color\n                   .5+.5* sin( // 3.*l // i*atan(U.y,U.x)              // wavelength\n                               - 20.*iTime* sign(H.x-.5)  - 6.28*H.y   // random dir and phase\n                               - ( l > .4 - 2.*p* abs(dot(U,F))/L/l ?  sign(L-i): 0.) ), // margin phase\n                   smoothstep(0.,-p, l-.4) ) );                        // draw disk\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtc3DM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 88, 116, 1040]], "test": "untested"}
{"id": "dt3GDM", "name": "illusion 11e", "author": "FabriceNeyret2", "description": "motion without movment: no center change: motion is now shake.\nvariant of https://shadertoy.com/view/dtc3WM\nvariant of https://shadertoy.com/view/ml3GWN\nvariant of https://shadertoy.com/view/mtc3D4\nvariant of https://shadertoy.com/view/ct33WN", "tags": ["illusion", "perception"], "likes": 6, "viewed": 206, "published": 3, "date": "1682516388", "time_retrieved": "2024-07-30T17:58:45.260412", "image_code": "// variant of https://shadertoy.com/view/dtc3WM\n// variant of https://shadertoy.com/view/ml3GWN\n// variant of https://shadertoy.com/view/mtc3D4\n// variant of https://shadertoy.com/view/ct33WN\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // float h = 450.; // R.y;\n    vec2 R = iResolution.xy,\n         U = 5.*( 2.*u - R ) / R.y,                                    // global normalize coords\n         I = floor(U)+.5,                                              // disc Id\n         F = fract(U)-.5,                                              // local disc coords\n         H = fract(1e4*sin(I*mat2(R-17.,R+71.)));                      // 2 random values \n         \n    float p = 15./R.y, l = length(F), L = length(U), i = length(I);\n    O = mix( vec4(0,.5,0,1),                                            // bg color\n             vec4(.5+.5* sin( l > .4 - 2.*p* abs(dot(U,F))/L/l ?  3.*l - sign(L-i)-  - 6.28*H.y -20.*iTime* sign(H.x-.5)  : 0. )), // margin phase\n             smoothstep(0.,-p, l-.4) );                                // draw disk\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3GDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 231, 259, 1046]], "test": "untested"}
{"id": "dtc3WM", "name": "illusion 11d", "author": "FabriceNeyret2", "description": "motion without movment. radial strips.\nvariant of https://shadertoy.com/view/ml3GWN\nvariant of https://shadertoy.com/view/mtc3D4\nvariant of https://shadertoy.com/view/ct33WN\nwow, the effect is independant of wave dir !", "tags": ["illusion", "perception"], "likes": 9, "viewed": 208, "published": 3, "date": "1682515671", "time_retrieved": "2024-07-30T17:58:46.110140", "image_code": "// variant of https://shadertoy.com/view/ml3GWN\n// variant of https://shadertoy.com/view/mtc3D4\n// variant of https://shadertoy.com/view/ct33WN\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // float h = 450.; // R.y;\n    vec2 R = iResolution.xy,\n         U = 5.*( 2.*u - R ) / R.y,                                    // global normalize coords\n         I = floor(U)+.5,                                              // disc Id\n         F = fract(U)-.5,                                              // local disc coords\n         H = fract(1e4*sin(I*mat2(R-17.,R+71.)));                      // 2 random values \n         \n    float p = 15./R.y, l = length(F), L = length(U), i = length(I);\n    O = vec4( mix( .5,                                                 // bg color\n                   .5+.5* sin( 3.*l // i*atan(U.y,U.x)                 // wavelength\n                               - 20.*iTime* sign(H.x-.5)  - 6.28*H.y   // random dir and phase\n                               - ( l > .4 - 2.*p* abs(dot(U,F))/L/l ?  sign(L-i): 0.) ), // margin phase\n                   smoothstep(0.,-p, l-.4) ) );                        // draw disk\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtc3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 183, 211, 1135]], "test": "untested"}
{"id": "cl33D7", "name": "Fork Psychedeli becanchi 941", "author": "becanchi", "description": "Turn your webcam into a music visualizer and get your groove on :)", "tags": ["music", "webcam", "microphone", "vizualizer"], "likes": 4, "viewed": 571, "published": 3, "date": "1682508108", "time_retrieved": "2024-07-30T17:58:46.913990", "image_code": "/////////////////////////////////////////////////////////////////////////////////\n// Modified from relampago2048's \"Fractal Audio 01\"\n// https://www.shadertoy.com/view/llB3W1\n/////////////////////////////////////////////////////////////////////////////////\n\nconst int iters = 150;\n\nint fractal(vec2 p, vec2 point) {\n\tvec2 so = (-1.0 + 2.0 * point) * 0.3;\n\tvec2 seed = vec2(0.098386255 + so.x, 0.6387662 + so.y);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t\n\t\tif (length(p) > 2.0) {\n\t\t\treturn i;\n\t\t}\n\t\tvec2 r = p;\n\t\tp = vec2(p.x * p.x - p.y * p.y, 2.0* p.x * p.y);\n\t\tp = vec2(p.x * r.x - p.y * r.y + seed.x, r.x * p.y + p.x * r.y + seed.y);\n\t}\n\t\n\treturn 0;\t\n}\n\nvec3 color(int i) {\n\tfloat f = float(i)/float(iters) * 2.0;\n\tf=f*f*2.;\n\treturn vec3((sin(f*2.0)), (sin(f*3.0)), abs(sin(f*7.0)));\n}\n\n\nfloat sampleMusicA() {\n\treturn 0.6 * (\n\t\ttexture( iChannel1, vec2( 0.15, 0.25 ) ).x + \n\t\ttexture( iChannel1, vec2( 0.30, 0.25 ) ).x);\n}\n\nmat2 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nvec4 fractalImg(vec2 uv, vec2 fragCoord) {\n    vec2 mouse = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n    \n    vec2 position = 3. * (-0.5 + fragCoord.xy / iResolution.xy ) + vec2(0.2 * abs(cos(iTime * 0.21313)) * sin(sin(iTime)+cos(iTime)*.242), 0.1 * abs(cos(iTime * 0.1323)));\n\tposition.x *= iResolution.x/iResolution.y;\n    position *= rotateX(mod(iTime * .54, 6.3) + abs(.2 * sin(iTime / 5.3)));\n    \n    vec2 iFC = vec2(iResolution.x-fragCoord.x,iResolution.y-fragCoord.y);    \n    vec2 pos2 = 2. * (-0.5 + iFC.xy / iResolution.xy);\n    pos2.x*=iResolution.x/iResolution.y;\n    pos2 *= rotateX(mod(iTime * -.4235, 6.3) + abs(.2 * sin(iTime / 5.3)));\n\n    vec4 t3 = texture(iChannel0, vec2(length(position)/14.0,0.1) );\n    float pulse = .2+sampleMusicA()*1.8;\n\n    vec3 invFract = color(fractal(pos2,vec2(0.55+sin(iTime/18.+0.5)/2.0,pulse*.9)));\n    \n    vec3 fract4 = color(fractal(position/1.6,vec2(0.6+cos(iTime/20.+0.5)/2.0,pulse*.8)));\n\n    vec3 c = color(fractal(position,vec2(10.1+sin(iTime/3.)/12.0,pulse)));\n    \n    t3=abs(vec4(0.5,0.1,0.5,1.)-t3)*.8;\n    \n    vec4 fract01 =  vec4( c , 1.0 );\n    vec4 salida;\n    salida = fract01 / t3 + fract01 * t3 + vec4(invFract,0.6) + vec4(fract4,0.25);\n\treturn mix(salida * 2.,texture(iChannel1, fragCoord.xy / iResolution.xy), 0.3);\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Modified from t3hk0d3's \"webcam roberts\"\n// https://www.shadertoy.com/view/MssGRB\n/////////////////////////////////////////////////////////////////////////////////\n\n\nconst float sensitivity = 1.0 / 100.0;\n\nfloat bw(vec2 coords) {\n\tvec4 lm = texture(iChannel0, coords) * vec4(0.21, 0.71, 0.07, 1);\n\t\n\treturn lm.r+lm.g+lm.b;\t\n}\n\nfloat outline(vec2 uv)\n{\n \tvec2 of = vec2(sensitivity * pow(sampleMusicA(), 2.), 0);\n\t\n\treturn sqrt(\n\t\tpow(abs(bw(uv) - bw(uv+of.xx)), 2.0) +\n\t\tpow(abs(bw(uv + of.xy) - bw(uv + of.yx)), 2.0)\n\t);   \n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Modified from  unycone's \"Camera Distortion 01\"\n// https://www.shadertoy.com/view/XlXfRs\n/////////////////////////////////////////////////////////////////////////////////\n\nvec2 distort(vec2 uv)\n{\n    bool autoScale = true;\n    float strength = sampleMusicA() * sign(sin(iTime / 5.)) * 0.25;\n    float zoom = (autoScale ? abs(strength) + 1.0 : 1.0);\n    \n\n    \n    vec2 p = (uv - 0.5) * 2.0; // map [0, 1] to [-1, 1]\n    float theta = atan(p.y, p.x);\n    float rd = length(p);\n    float ru = rd * (1.0 + strength * rd * rd) / zoom;\n    return vec2(cos(theta), sin(theta)) * ru / 2.0 + 0.5; \n}\n\n\n/////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = 1.0 - uv.x;\n    \n    vec4 imgColor = texture(iChannel0, uv);\n\n\n\tuv = distort(uv); // Comment this line out to remove distortion\n\t\n\tfloat bwColor = outline(uv) * 2.;\n    bwColor = min(round(bwColor * 8.), 2.) * bwColor;\n    \n\t\n\t\n\tfragColor = imgColor + bwColor * (fractalImg(uv, fragCoord) + fractalImg(-uv, fragCoord));\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl33D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 315, 315, 653], [655, 655, 674, 674, 786], [789, 789, 811, 811, 924], [926, 926, 951, 951, 1053], [1055, 1055, 1097, 1097, 2357], [2650, 2650, 2673, 2673, 2769], [2771, 2771, 2795, 2795, 2970], [3229, 3229, 3252, 3252, 3648], [3651, 3733, 3790, 3790, 4168]], "test": "untested"}
{"id": "cl3GW7", "name": "Electric Current Mask ", "author": "Ridah", "description": "I didn't find it in shadertoy, then tried to imitate and made one.  ( i just copy the function from unity )", "tags": ["electric", "current"], "likes": 2, "viewed": 167, "published": 3, "date": "1682500639", "time_retrieved": "2024-07-30T17:58:47.936257", "image_code": "float SimpleNoise_RandomValue_float (vec2 uv)\n{\n    float angle = dot(uv, vec2(12.9898, 78.233));\n    #if defined(SHADER_API_MOBILE) && (defined(SHADER_API_GLES) || defined(SHADER_API_GLES3) || defined(SHADER_API_VULKAN))\n        // 'sin()' has bad precision on Mali GPUs for inputs > 10000\n        angle = fmod(angle, TWO_PI); // Avoid large inputs to sin()\n    #endif\n    return fract(sin(angle)*43758.5453);\n}\nfloat SimpleNnoise_Interpolate_float (float a, float b, float t)\n{\n    return (1.0-t)*a + (t*b);\n}\nfloat SimpleNoise_ValueNoise_float (vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    f = f * f * (3.0 - 2.0 * f);\n\n    uv = abs(fract(uv) - 0.5);\n    vec2 c0 = i + vec2(0.0, 0.0);\n    vec2 c1 = i + vec2(1.0, 0.0);\n    vec2 c2 = i + vec2(0.0, 1.0);\n    vec2 c3 = i + vec2(1.0, 1.0);\n    float r0 = SimpleNoise_RandomValue_float(c0);\n    float r1 = SimpleNoise_RandomValue_float(c1);\n    float r2 = SimpleNoise_RandomValue_float(c2);\n    float r3 = SimpleNoise_RandomValue_float(c3);\n\n    float bottomOfGrid = SimpleNnoise_Interpolate_float(r0, r1, f.x);\n    float topOfGrid = SimpleNnoise_Interpolate_float(r2, r3, f.x);\n    float t = SimpleNnoise_Interpolate_float(bottomOfGrid, topOfGrid, f.y);\n    return t;\n}\nvoid SimpleNoise_float(vec2 UV, float Scale, out float Out)\n{\n    float t = 0.0;\n\n    float freq = pow(2.0, float(0));\n    float amp = pow(0.5, float(3-0));\n    t += SimpleNoise_ValueNoise_float(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(1));\n    amp = pow(0.5, float(3-1));\n    t += SimpleNoise_ValueNoise_float(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(2));\n    amp = pow(0.5, float(3-2));\n    t += SimpleNoise_ValueNoise_float(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    Out = t;\n}\nvoid Remap(vec4 In, vec2 InMinMax, vec2 OutMinMax, out vec4 Out)\n{\n    Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);\n}\nvoid Rectangle(vec2 UV, float Width, float Height, out float Out)\n{\n    vec2 d = abs(UV * 2. - 1.) - vec2(Width, Height);\n    d = 1. - d / fwidth(d);\n    Out = clamp(min(d.x, d.y),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //offset\n    float up = 0., down =0.;\n    SimpleNoise_float(uv+vec2(-0.5*iTime,iTime),10.,down);\n    SimpleNoise_float(uv+vec2(0.5*iTime,-1.*iTime),12.,up);\n    float noise = pow(up+down,2.);\n    Remap(vec4(noise),vec2(0.,1.),vec2(-10.,10.),fragColor);\n    Rectangle(fragColor.xy,1.,0.,noise);\n    fragColor = vec4(noise);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3GW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 412], [413, 413, 479, 479, 511], [512, 512, 558, 558, 1237], [1238, 1238, 1299, 1299, 1787], [1788, 1788, 1854, 1854, 1957], [1958, 1958, 2025, 2025, 2147], [2149, 2149, 2206, 2206, 2581]], "test": "untested"}
{"id": "DtcGDM", "name": "infinite 2d ", "author": "FabriceNeyret2", "description": "inspiration: https://twitter.com/beesandbombs/status/1650831768868605952\n\nany idea how to better deal with the discontinuity at loop/cross ? \n( #[ min(2.,fwidth) is uggly and doesn't 100% fix ).", "tags": ["2d", "short", "golf", "reproduction"], "likes": 40, "viewed": 622, "published": 3, "date": "1682498755", "time_retrieved": "2024-07-30T17:58:48.771025", "image_code": "// variant of https://shadertoy.com/view/cl3GDM\n// variant of https://shadertoy.com/view/clc3WM\n// variant of https://shadertoy.com/view/cl33WM\n\n  #define S(v,s) clamp( v+ cos(s)/abs(sin(s)*min(2.,fwidth(s))), 0., 1. ) // draw AA strips\n//#define S(v,s) clamp( v+ cos(s)/fwidth(cos(s)), 0., 1. ) // fwidth(high freq) suffers too much\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,                  // normalized coordinates\n          T = ( U + vec2(-U.y,U) ) *.707,         // 45-tilted ( for cross )\n          V = abs( T ),                           // + symmetry \n          A = abs( U ); A.x -= .707;              // symmetries ( for loops )\n    float l = length(A), x = A.x/l,\n          s = x > -.7 ? sign(U.x)*(.5-l)            : V.y < .2 ? T.y :  T.x, // local parameterization\n          t = x > -.7 ? atan(U.y,abs(U.x)-.707)/1.7 : V.y < .2 ? T.x : -T.y;\n          \n    O =  1. - clamp(R.yyyy/3. \n               * (.2 - abs( x > -.7               // .2- : thickness\n                            ? l - .5              // loops SDF\n                            : min(V.x,V.y)        // cross SDF\n                        ) ) ,0.,1.)\n               *  S(  , 275.*s )                  // AA strips along v loc param\n               *  S(1.,  50.*t - 25.*round(43.77*s)/43.77*mod(iTime,11.) );  // AA strips along u loc param\n            // *  S( 50.*t - 10.*s - 5.*iTime );  // AA strips along u loc param\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcGDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cl3GDM", "name": "infinite 2c ", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "short", "golf"], "likes": 15, "viewed": 244, "published": 3, "date": "1682497762", "time_retrieved": "2024-07-30T17:58:49.806257", "image_code": "// variant of https://shadertoy.com/view/clc3WM\n// variant of https://shadertoy.com/view/cl33WM\n\n#define S(s) clamp( .5+ .5*s/fwidth(s), 0., 1. ) // draw AA strips\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,                // normalized coordinates\n          T = ( U + vec2(-U.y,U) ) *.707,       // 45-tilted ( for cross )\n          V = abs( T ),                         // + symmetry \n          A = abs( U ); A.x -= .707;            // symmetries ( for loops )\n    float l = length(A), x = A.x/l,\n          s = x > -.7 ? l-.5 : V.y < .2 ? T.y : T.x, // local parameterization\n          t = x > -.7 ? atan(U.y,abs(U.x)-.707)/1.7 :  V.y < .2 ? T.x : -T.y;\n          \n    O =  clamp(R.yyyy/3. \n               * (.2 - abs( x > -.7             // .2- : thickness\n                            ? l - .5            // loops SDF\n                            : min(V.x,V.y)      // cross SDF\n                        ) ) ,0.,1.)\n               *  S(cos(140.*s))                // AA strips along v loc param\n               *  S(cos( 50.*t - 5.*iTime));    // AA strips along u loc param\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3GDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 203, 203, 1138]], "test": "untested"}
{"id": "clc3WM", "name": "infinite 2b ", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "2tweets", "short", "golf"], "likes": 9, "viewed": 242, "published": 3, "date": "1682496585", "time_retrieved": "2024-07-30T17:58:50.576199", "image_code": "// variant of https://shadertoy.com/view/cl33WM\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,                // normalized coordinates\n          V = abs( U + vec2(-U.y,U) )*.707,     // 45-tilted + symmetry ( for cross )\n          A = abs( U ); A.x -= .707;            // symmetries ( for loops )\n    float l = length(A), x = A.x/l,\n          s = cos(140.*( x > -.7 ? l-.5 : V.y < .2 ? V.y : V.x )); // for strips\n          \n    O =  clamp(R.yyyy/3. \n               * (.2 - abs( x > -.7             // .2- : thickness\n                            ? l - .5            // loops SDF\n                            : min(V.x,V.y)      // cross SDF\n                        ) ) ,0.,1.)\n                  *  ( .5+ .5*s/fwidth(s));     // AA strips\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clc3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 797]], "test": "untested"}
{"id": "cl33WM", "name": "infinite 2 ( 183 chars )", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "2tweets", "short", "golf"], "likes": 8, "viewed": 200, "published": 3, "date": "1682495563", "time_retrieved": "2024-07-30T17:58:51.332177", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,                // normalized coordinates\n          V = abs( U + vec2(-U.y,U) )*.707,     // 45-tilted + symmetry ( for cross )\n          A = abs( U ); A.x -= .707;            // symmetries ( for loops )\n    \n    O =  R.yyyy/3.* (abs( A.x/length(A) > -.7\n                            ? length(A) - .5    // loops SDF\n                            : min(V.x,V.y)      // cross SDF\n                        ) -.2 );                // thickness\n}\n\n\n/**\n\n// --- 216 chars\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float s = .707, a;\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y,\n          V = abs( U + vec2(-U.y,U) )*s,\n          A = abs(U); A.x -= s;\n    \n    a = atan(A.y,A.x);\n    O = vec4( smoothstep( 0., 3./R.y, abs( cos(a) > -s ? length(A)-.5 : min(V.x,V.y) ) -.2 ) );\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl33WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 542]], "test": "untested"}
{"id": "mtt3WH", "name": "Graflex", "author": "hubbe", "description": "Graflex lightsaber model.", "tags": ["raymarching", "lightsaber"], "likes": 0, "viewed": 138, "published": 3, "date": "1682480316", "time_retrieved": "2024-07-30T17:58:52.457170", "image_code": "#define R 0.08\n#define CUTR (R/8.0)\n\nconst float pi = 3.1415926535;\nconst float PI = 3.1415926535;\n\n\nmat3 rotz(float f) {\n    return mat3(cos(f), sin(f), 0,\n                -sin(f), cos(f), 0,\n                0,0,1);\n}\nmat3 roty(float f) {\n    return mat3(cos(f), 0, sin(f),\n    0, 1, 0,\n                -sin(f), 0, cos(f));\n}\nmat3 rotx(float f) {\n    return mat3(1,0,0,\n                0, cos(f), sin(f),\n                0, -sin(f), cos(f));\n}\n\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec3 c) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, -h, h );\n  return length( p ) - r;\n}\n\nvec4 opElongate( in vec3 p, in vec3 h) {\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\nfloat Clamp(vec3 p) {\n  p= vec3(p.x + 0.03, -p.z, p.y);\n  float dist = 100000.0;\n  // clamp\n  dist = min(dist, sdCappedCylinder(p.yxz, 0.040, 0.051));\n  dist = min(dist, sdBox(p.xyz + vec3(0.0, -0.038, 0.0), vec3(0.051, 0.020, 0.015)));\n  return dist;\n}\n\nfloat RedPill(vec3 p) {\n  p -= vec3(0.143,0,0);\n  if (p.y > 0.0) {\n    p.x-=0.030;\n    p.y = abs(p.y);\n  }\n  float dist = 1000000.0;\n//  dist = min(dist, sdCappedCylinder(p, 0.011, 0.051));\n  dist = min(dist, \n    max(sdSphere(p, 0.053),\n        sdCappedCylinder(p, 0.011, 0.08)));\n  return dist;\n}\n\nfloat Button(vec3 p) {\n  float dist = 1000000.0;\n  dist = min(dist, RedPill(p));\n  p -= vec3(0.143,0,0);\n  if (p.y > 0.0) {\n    p.x-=0.030;\n    p.y = abs(p.y);\n  }\n  dist = min(dist, sdCappedCylinder(p, 0.018, 0.050));\n//  dist = min(dist, sdCappedCylinder(p, 0.011, 0.051));\n  return dist;\n}\n\n// May need to find a better way to model this.\nfloat Cut(vec3 p) {\n  p.x -= 0.350;\n//  p.y -= 0.008;\n  p *= rotz(-0.60);\n  p.x += sin(p.y*50.0)/55.0;\n  return sdBox(p, vec3(0.1, 0.2, 0.1)) * 0.8;\n}\n\nfloat Slots(vec3 p) {\n  float dist = sdBox(p + vec3(-0.259,0.0,0.0), vec3(0.004, 0.1, 0.005));\n  dist = min(dist, sdBox(p + vec3(-0.227,0.0,0.0), vec3(0.020, 0.1, 0.010)));\n  return dist;\n}\n\nfloat Slots2(vec3 p) {\n  p.z = -abs(p.z);\n//  float dist = 100000.0;\n  float dist = sdBox(p + vec3(-0.179,0.055,0.01), vec3(0.010, 0.03, 0.005));\n  p *= rotx(0.95);\n  dist = min(dist, sdCappedCylinder(p+vec3(-0.175,0.040,0), 0.014, 0.02));\n//  dist = min(dist, sdBox(p + vec3(-0.227,0.0,0.0), vec3(0.020, 0.1, 0.010)));\n  return dist;\n}\n\nfloat Pins(vec3 p) {\n  p.z = -abs(p.z);\n  p *= rotx(0.95);\n  p += vec3(-0.175,0.015,0);\n  p.x = abs(p.x);\n  p.x -= 0.005;\n  return sdVerticalCapsule(p.yxz, 0.018, 0.002);\n//  return sdCappedCylinder(p, 0.002, 0.02);\n}\n\nfloat Cylinder(vec3 p) {\n float dist = sdCappedCylinder(p.yxz, 0.038, 0.270);\n  dist = max(dist, -sdCappedCylinder(p.yxz + vec3(0,-0.470,0), 0.036, 0.270));\n  dist = max(dist, -Cut(p));\n  dist = max(dist, -Slots(p));\n  dist = max(dist, -Slots2(p));\n  return dist;\n}\n\nfloat sdCircle(vec2 xy, float r) {\n  return length(xy) - r;\n}\nfloat sdRect(vec2 p, vec2 b) {\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat earsFront(vec2 xy) {\n  xy.x = -abs(xy.x);\n  float dist = sdCircle(xy, 0.027);\n  dist = max(dist, -sdCircle(xy, 0.0265));\n  dist = max(dist, -sdRect(xy + vec2(0.0, -0.030), vec2(0.005, 0.010)));\n  dist = min(dist, sdRect(xy + vec2(0.005, -0.056), vec2(0.0005, 0.030)));\n  return dist;\n}\n\nfloat earsSide(vec2 xy) {\n  xy.x = -abs(xy.x);\n  float dist = sdRect(xy + vec2(0, -0.050), vec2(0.012, 0.030));\n  dist = min(dist, sdRect(xy, vec2(0.016, 0.030)));\n  dist = min(dist, max(\n    sdCircle(xy + vec2(0,-0.069), 0.016),\n    -sdRect(xy + vec2(0.011*2.0, -0.060), vec2(0.011, 0.030))));\n  return dist;\n}\n\nfloat bunnyEars(vec3 p) {\n  p.x -= 0.227;\n  return max(\n      opExtrussion( p.zyx, earsFront(p.zy), 0.1 ),\n      opExtrussion( p, earsSide(p.xy), 0.1 ));\n}\n\nfloat grips(vec3 p) {\n    // 6-symmetry\n    float angle = atan(p.z, p.y);\n    float section = round(angle * 3.0 / pi);\n    float angle2 = section * pi / 3.0;\n    vec3 p2 = p * rotx(angle2);\n\n    // T-track\n    float dist = sdBox(p2.xyz + vec3(0.270-0.092,-0.038,0.0), vec3(0.092, 0.004, 0.013));\n    dist = min(dist, sdBox(p2.xyz + vec3(0.270-0.092,-0.038,0.0), vec3(0.091, 0.012, 0.002)) - 0.001);\n    return dist;\n}\n\nvec3 dorot(vec3 p) {\n   p = p  * roty(-0.4) * rotx(pi/5.0);\n//    p = p  * roty(-0.4) * rotx(pi/7.0);\n//    p = p * roty(-0.05);\n   p *= rotz(iTime*0.1) * rotx(-iTime*0.0123) * roty(iTime*0.09781623);\n    return p;\n} \n\n// bounding box\nfloat bb(vec3 p) {\n  p.y-=0.01;\n  return sdVerticalCapsule(p, 0.25, 0.08);\n}\n\n// Return actual distance, step\nfloat map(vec3 p) {\n    p = dorot(p);\n    \n    \n    float dist = bb(p);\n    if (dist > 0.1) return dist;\n    \n    dist = 100000.0;    \n    dist = min(dist, Cylinder(p));\n    dist = min(dist, Clamp(p));\n    dist = min(dist, Button(p));\n    dist = min(dist, grips(p));\n    dist = min(dist, bunnyEars(p));\n    dist = min(dist, Pins(p));\n\n    return dist;\n}\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nstruct Material {\n  vec3 color;\n  float metallic;\n  float roughness;\n};\n\nMaterial getMaterial(vec3 hp, vec3 ray_dir) {\n    float dist = map(hp);\n    vec3 hpr = dorot(hp);\n\n    if (grips(hpr) == dist) {\n       return Material(vec3(0.01,0.01,0.01), 0.0, 0.4);\n    }\n    \n    if (Pins(hpr) == dist) {\n        return Material(vec3(1.00, 0.71, 0.29), 1.0, 0.2);\n    }\n    \n    if (length(hpr.zy) < 0.036 && abs(hpr.x) < 0.201) {\n      return Material(vec3(0.01,0.01,0.01), 0.2, 0.2);     \n    }\n    \n    if (RedPill(hpr) == dist) {\n      return Material(vec3(0.6,0.1,0.1), 0.5, 0.2);\n    }\n    \n    if (hpr.z < -0.055 && abs(hpr.y) < 0.011) {\n      if (mod(hpr.x+0.2, 0.006) < 0.002) {\n        return Material(vec3(0.3, 0.9, 0.3), 0.0, 0.4);\n      } else {\n        return Material(vec3(1.00, 0.71, 0.29), 1.0, 0.2);\n      }\n    }\n    \n//    return Material(vec3(0.3), 0.9, 0.1);\t\n      vec2 tpos = vec2(dot(hpr, vec3(13.1,1,0.5)), dot(hpr, vec3(7.033,0.1,2.2)));\n    vec3 c = texture(iChannel0, tpos).xyz;\n    return Material(vec3(0.3), 1.0-c.g, c.r*0.8 + 0.1);\n}\n\n\n\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        float tmp = map(position);\n\t    float distance_to_closest_object = tmp;\n        float step_size = hit ? tmp : tmp;\n\n        if (distance_to_closest_object < 0.0005) {\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += step_size;\n    }\n \n    return travel_distance;\n}\n\n\nvec3 norm(vec3 pos) {\n    float d = 0.0001;\n    float dist = map(pos);\n    return normalize(vec3(map(pos + vec3(d,0,0)) - dist,\n                          map(pos + vec3(0,d,0)) - dist,\n                          map(pos + vec3(0,0,d)) - dist));\n}\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.001;\n    \n    for (int i = 0; i < 100; i++) {\n        float h = map(origin + direction * t);\n        if (h < 0.0002) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\nvoid planet(out vec4 O,vec2 I)\n{\n    vec4 bg = texture(iChannel2, I / iResolution.xy);\n//    O = bg;    return ;\n    vec2 P =(( I / iResolution.x)/0.8+vec2(-0.9, 0.5)) / 1.0;\n    vec3 RR = vec3(P,sqrt(max(1.-dot(P,P),0.)));\n\tO = mix(\n        texture(iChannel1, .001*iTime+.3*RR.xy/sqrt(RR.z))*max(RR.x*.3+RR.y*.9+RR.z*.1+.5,.1),\n            vec4(.6,.4,.3,1)/dot(P,P*.5),pow(1.-RR.z,2.));\n    if (RR.z == 0.0)\n      O = mix(O, bg, min(1.0, max(0.0, pow((dot(P,P)-1.0),0.2))));\n}\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -3.0);\n    vec3 light_position = vec3(1.1, 1.1, 1.1);\n\n    // Animate\n  // camera_position.z += iTime/2.0 + iTime * iTime / 200.0;\n // camera_position.x += iTime/2.0;\n\n   light_position += camera_position;\n //   camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 4.0;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance > 50.0) {\n        planet(fragColor, fragCoord);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n    \n    \n\n      Material mat = getMaterial(hit_position, ray_direction);\n      \n        vec3 v = normalize(-ray_direction);\n        vec3 n = norm(hit_position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7)); // light direction??\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(ray_direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = mat.color * 0.5;\n     \n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        float linearRoughness = mat.roughness * mat.roughness;\n        vec3 diffuseColor = (1.0 - mat.metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - mat.metallic) + baseColor.rgb * mat.metallic;\n\n        float attenuation = shadow(hit_position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        vec3 color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        float indirectHit = ray(hit_position + r * 0.001, r);\n        vec3 indirectSpecular = vec3(1.8, 0.5, 0.5) + r.y * 3.72;\n        vec3 indirectHitPosition = hit_position + r * indirectHit;\n        if (indirectHit < 1.0) {\n           Material indirectMaterial = getMaterial(indirectHitPosition, r);\n           indirectSpecular = indirectMaterial.color;\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(mat.roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n\n      \n      \n      \n//      fragColor = vec4(mat.color, 1.0);\n//      vec3 light_dir = normalize(light_position - hit_position);\n//      vec3 normal = norm(hit_position);    \n//      vec3 reflection = reflect(ray_direction, normal);\n//      float l2 = max(dot(reflection, light_dir), 0.0);\n//      float spec = pow(l2, 4.0) * 0.3;\n    \n      fragColor = pow(vec4(color, 1.0), vec4(1.0/2.2));\n}\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtt3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 121, 121, 218], [219, 219, 239, 239, 326], [327, 327, 347, 347, 444], [447, 447, 506, 506, 602], [604, 604, 637, 663, 694], [695, 695, 726, 726, 813], [815, 815, 849, 849, 873], [875, 875, 910, 910, 944], [946, 946, 997, 997, 1104], [1106, 1106, 1169, 1169, 1286], [1288, 1288, 1341, 1341, 1399], [1401, 1401, 1441, 1441, 1638], [1641, 1641, 1662, 1662, 1894], [1896, 1896, 1919, 1919, 2194], [2196, 2196, 2218, 2218, 2488], [2490, 2538, 2557, 2557, 2688], [2690, 2690, 2711, 2711, 2879], [2881, 2881, 2903, 2903, 3217], [3219, 3219, 3239, 3239, 3436], [3438, 3438, 3462, 3462, 3703], [3705, 3705, 3739, 3739, 3766], [3767, 3767, 3797, 3797, 3875], [3877, 3877, 3903, 3903, 4168], [4170, 4170, 4195, 4195, 4481], [4483, 4483, 4508, 4508, 4638], [4640, 4640, 4661, 4679, 5057], [5059, 5059, 5079, 5079, 5275], [5278, 5294, 5312, 5312, 5370], [5372, 5404, 5423, 5423, 5757], [5931, 5931, 5952, 5952, 6000], [6002, 6002, 6063, 6148, 6345], [6347, 6347, 6420, 6512, 6712], [6714, 6714, 6756, 6836, 6890], [6892, 6892, 6941, 6941, 6989], [6991, 6991, 7064, 7121, 7334], [7336, 7336, 7356, 7356, 7379], [7565, 7565, 7615, 7699, 8057], [8059, 8059, 8114, 8171, 8431], [8506, 8506, 8551, 8551, 9491], [9496, 9596, 9634, 9671, 10438], [10441, 10441, 10462, 10462, 10686], [10688, 10688, 10737, 10737, 11028], [11031, 11031, 11063, 11063, 11508], [11551, 11551, 11608, 11608, 15081]], "test": "untested"}
{"id": "DtdGW4", "name": "Pixel Art Spacecraft", "author": "ThePlaneGuy45", "description": "was working on fake emissive objects and thought this would be a cool idea\n\n- SDFs & get normal function are all from iq (I'm not smart enough)\n- basically everything else by me", "tags": ["space", "raymarcher", "spaceship"], "likes": 5, "viewed": 240, "published": 3, "date": "1682467661", "time_retrieved": "2024-07-30T17:58:53.483426", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = 360.0 / iResolution.y;\n    float ratio2 = iResolution.y / 720.0;\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = sampleTex(iChannel0, vec2(640.0, 360.0) * ratio2, uv * ratio);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define AMBIENT 0.2\n\n#define LIGHT vec3(0.0, 200.0, 400.0)\n\n#define blurQUAL 8.0\n#define blurDIR 32.0\n#define blurSIZE 64.0\n\nstruct Material {\n\n    vec3 color;\n    float emission;\n    float sheen;\n    float roughness;\n    float metallic;\n\n};\n\nstruct Info {\n\n    Material mat;\n    vec3 p;\n    float d;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Normal {\n\n    vec3 n;\n    vec3 b;\n    vec3 t;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nfloat sphere(vec3 center, float radius, vec3 pos) {\n\n    return distance(pos, center) - radius;\n\n}\n\nfloat box(vec3 center, vec3 dim, float radius, vec3 pos) {\n\n    vec3 q = abs(pos - center) - dim;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - radius;\n\n}\n\nfloat cylinder(vec3 a, vec3 b, float radius, vec3 pos) {\n\n  vec3  ba = b - a;\n  vec3  pa = pos - a;\n  float baba = dot(ba, ba);\n  float paba = dot(pa, ba);\n  float x = length(pa * baba - ba * paba) - radius * baba;\n  float y = abs(paba - baba * 0.5) - baba * 0.5;\n  float x2 = x * x;\n  float y2 = y * y * baba;\n  float d = max(x, y) < 0.0 ? -min(x2, y2) : (x > 0.0 ? x2 : 0.0) + (y > 0.0 ? y2 : 0.0);\n  return sign(d)*sqrt(abs(d))/baba;\n  \n}\n\nfloat cone(vec3 a, vec3 b, float r1, float r2, vec3 p) {\n\n  vec3  ba = b - a;\n  float l2 = dot(ba, ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr * rr;\n  float il2 = 1.0 / l2;\n  vec3 pa = p - a;\n  float y = dot(pa, ba);\n  float z = y - l2;\n  vec3 temp = pa * l2 - ba * y;\n  float x2 = dot(temp, temp);\n  float y2 = y * y * l2;\n  float z2 = z * z * l2;\n  float k = sign(rr) * rr * rr * x2;\n  if(sign(z) * a2 * z2 > k) { return  sqrt(x2 + z2) * il2 - r2; }\n  if(sign(y) * a2 * y2 < k) { return  sqrt(x2 + y2) * il2 - r1; }\n  return (sqrt(x2 * a2 * il2) + y * rr) * il2 - r1;\n  \n}\n\nvoid object(in Material mat, in float dist, inout Info i) {\n\n    if(dist < i.d) {\n    \n        i.mat = mat;\n        i.d = dist;\n    \n    }\n\n}\n\nfloat add(float d1, float d2, float k) {\n\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n    \n}\n\nfloat sub(float d1, float d2, float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n\n}\n\nfloat and(float d1, float d2, float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n    \n}\nvec3 random(inout uvec3 state) {\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    return vec3(state)*(1.0/float(0xffffffffU));\n}\n\nvec4 sampleTex(sampler2D tex, vec2 resolution, vec2 uv) {\n\n    vec2 suv = round(uv * resolution) / resolution;\n    return texture(tex, suv);\n\n}", "buffer_a_code": "void map(inout Info i) {\n\n    vec3 p = i.p;\n    \n    object( Material( vec3(0.45, 0.25, 0.15) * (texture(iChannel1, vec2(i.p.x, i.p.y) * 0.00005).r * 0.2 + 0.8), 0.0, 0.0, 0.9, 0.0 ), (\n        sphere(vec3(3000.0, -200.0, 7000.0), 5000.0, i.p)\n    ), i);\n    \n    \n\n    // Spacecraft Body\n    object( Material( vec3(1.0), 0.0, 0.75, 0.9, 0.0 ), add(\n        add(\n            cylinder(vec3(0.0, 0.0, -250.0), vec3(0.0, 0.0, 400.0), 100.0, i.p),\n            add(\n                cone(vec3(0.0, -10.0, 450.0), vec3(0.0, 0.0, 400.0), 75.0, 100.0, i.p),\n                cone(vec3(0.0, -10.0, 500.0), vec3(0.0, 0.0, 400.0), 50.0, 75.0, i.p),\n                20.0\n            ),\n            0.0\n        ),\n        and(\n            box(vec3(0.0, 0.0, -250.0), vec3(150.0, 1.0, 50.0), 100.0, i.p),\n            box(vec3(0.0, 0.0, -200.0), vec3(300.0, 300.0, 100.0), 0.0, i.p),\n            40.0\n        ),\n        100.0\n    ), i);\n    \n    // Spacecraft Wings\n    p = i.p;\n    p.xy *= rot2(0.78539816339);\n    \n    object( Material( vec3(0.8), 0.0, 0.75, 0.4, 0.0 ), add(\n    \n        box(vec3(0.0, 0.0, 300.0), vec3(0.0, 300.0, 35.0), 10.0, vec3(p.x, p.y, (p.z - 300.0) * 1.0 / (2.0 - abs(p.y * 0.004)) + 300.0)),\n        box(vec3(0.0, 0.0, 300.0), vec3(300.0, 0.0, 35.0), 10.0, vec3(p.x, p.y, (p.z - 300.0) * 1.0 / (2.0 - abs(p.x * 0.004)) + 300.0)),\n        0.0\n    \n    ), i);\n    \n    // Spacecraft Windshield\n    object( Material( vec3(0.1, 0.1, 0.2), 0.0, 0.2, 0.0, 0.0 ), and(\n        sphere(vec3(0.0, -10.0, 425.0), 100.0, i.p),\n        box(vec3(0.0, 65.0, 500.0), vec3(40.0, 10.0, 50.0), 0.0, i.p),\n        0.0\n    ), i);\n    \n    // Spacecraft Engines\n    vec3 ion = mix(vec3(0.0, 0.3, 1.0), vec3(0.0, 0.75, 1.0), (sin(2.0 * (5.0 * iTime + i.p.x * 0.05)) + sin(3.14159265 * (6.0 * iTime + i.p.x * 0.05))) / 10.0 + 0.7);\n    \n    object( Material( vec3(0.2, 0.25, 0.3), 0.0, 0.2, 0.93, 0.0 ), sub(\n        cylinder(vec3(0.0, 0.0, -330.0), vec3(0.0, 0.0, -370.0), 60.0, i.p),\n        cylinder(vec3(0.0, 0.0, -250.0), vec3(0.0, 0.0, -370.0), 80.0, i.p),\n        10.0\n    ), i);\n    \n    object( Material( vec3(0.2, 0.25, 0.3), 0.0, 0.2, 0.93, 0.0 ), sub(\n        cylinder(vec3(150.0, 0.0, -330.0), vec3(150.0, 0.0, -350.0), 40.0, i.p),\n        cylinder(vec3(150.0, 0.0, -250.0), vec3(150.0, 0.0, -350.0), 60.0, i.p),\n        10.0\n    ), i);\n    object( Material( vec3(0.2, 0.25, 0.3), 0.0, 0.2, 0.93, 0.0 ), sub(\n        cylinder(vec3(-150.0, 0.0, -330.0), vec3(-150.0, 0.0, -350.0), 40.0, i.p),\n        cylinder(vec3(-150.0, 0.0, -250.0), vec3(-150.0, 0.0, -350.0), 60.0, i.p),\n        10.0\n    ), i);\n    object( Material( ion, 2.0, 0.2, 0.93, 0.0 ), (\n        cylinder(vec3(0.0, 0.0, -330.0), vec3(0.0, 0.0, -360.0), 60.0, i.p)\n    ), i);\n    object( Material( ion, 2.0, 0.2, 0.93, 0.0 ), (\n        cylinder(vec3(150.0, 0.0, -330.0), vec3(150.0, 0.0, -340.0), 40.0, i.p)\n    ), i);\n    object( Material( ion, 2.0, 0.2, 0.93, 0.0 ), (\n        cylinder(vec3(-150.0, 0.0, -330.0), vec3(-150.0, 0.0, -340.0), 40.0, i.p)\n    ), i);\n\n}\n\nNormal initNormal(vec3 n) {\n\n    vec3 t = normalize(vec3(n.z, 0.0, -n.x));\n    if(n.x + n.z == 0.0) {\n            \n        t = vec3(1.0, 0.0, 0.0);\n            \n    }\n    vec3 b = normalize(cross(n, t));\n    return Normal(n, b, t);\n\n}\n\nNormal calcNormal(vec3 position) {\n\n    vec3 n = vec3(0.0);\n    for( int i = 0; i < 4; i++ ) {\n    \n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        Info p;\n        p.p = position + 0.0005 * e;\n        p.d = 100000.0;\n        map(p);\n        n += e * p.d;\n        \n    }\n    n = normalize(n);\n    return initNormal(n);\n\n}\n\nvec3 worldSpace(vec3 map, Normal n) {\n\n    mat3x3 tbn = mat3x3(n.t.x, n.b.x, n.n.x, n.t.y, n.b.y, n.n.y, n.t.z, n.b.z, n.n.z);\n    return normalize(map * tbn);\n\n}\n\nInfo march(Ray ray, bool celshade) {\n\n    Info i;\n    i.p = ray.origin;\n    float md = 100000.0;\n    for(int j = 0; j < 50; j++) {\n    \n        i.d = 100000.0;\n        map(i);\n        i.p += i.d * ray.normal;\n        if(i.d <= 1.0) {break;}\n        if(i.d < md) {md = i.d;}\n    \n    }\n    if(i.d <= 1.0) {\n    \n        return i;\n        \n    }\n    i.d = 100000.0;\n    vec4 tex = texture(iChannel0, ray.normal);\n    i.mat = Material(tex.rgb, tex.w, 0.0, 0.0, 0.0);\n    if(md < 10.0 && celshade) { i.mat.color = vec3(0.75); }\n    i.p = vec3(0.0);\n    return i;\n\n}\n\nvoid initRay(inout Ray ray, in vec2 fragCoord) {\n\n    ray.origin = vec3(0.0, 0.0, -1500.0);\n    ray.normal = normalize(vec3(fragCoord, 250.0));\n    mat2 rot = rot2(6.0 * (iMouse.y/iResolution.y-0.5));\n    ray.origin.yz *= rot;\n    ray.normal.yz *= rot;\n    rot = rot2(6.0 * (iMouse.x/iResolution.x-0.5));\n    ray.origin.xz *= rot;\n    ray.normal.xz *= rot;\n\n}\n\nvec4 Trace(in vec2 fragCoord) {\n\n    Ray ray;\n    initRay(ray, fragCoord);\n    Info i = march(ray, true);\n    if(i.d <= 5.0) {\n        Normal planeInfo = calcNormal(i.p);\n        vec3 normal = planeInfo.n;\n        vec3 lightNormal = worldSpace(normalize(vec3(-1.0, 1.0, -1.0)), initNormal(ray.normal));\n        float lightDist = distance(LIGHT, i.p);\n        float shade = clamp(dot(normal, lightNormal), 0.0, 1.0);\n        float specang = acos(shade);\n        float specexp = specang / (1.0-i.mat.sheen);\n        float spec = 1.0 / (i.mat.emission + 1.0) * exp(-specexp * specexp) * i.mat.sheen;\n        vec3 color = mix(i.mat.color * AMBIENT, i.mat.color, shade) + spec;\n        if(i.mat.roughness < 1.0) {\n            ray.origin = i.p + 2.0 * normal;\n            ray.normal = reflect(ray.normal, normal);\n        \n            Info r = march(ray, false);\n        \n            vec3 reflectedColor = mix(r.mat.color, dot(r.mat.color, vec3(.2126, .7152, .0722)) * i.mat.color, i.mat.metallic);\n            \n            color = mix(color, reflectedColor, 1.0 - i.mat.roughness);\n        }\n        return vec4(mix(color, i.mat.color, i.mat.emission), i.mat.emission);\n    }\n    return vec4(i.mat.color, i.mat.emission);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x <= 640.0 && fragCoord.y <= 360.0) {\n        fragColor = Trace((fragCoord - vec2(320.0, 180.0)));\n    } else {\n        fragColor = vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if(fragCoord.x <= 640.0 && fragCoord.y <= 360.0) {\n        float br = 9.0 / 16.0;\n        vec2 uv = fragCoord/iResolution.xy;\n    \n        vec2 rad = (blurSIZE / vec2(640.0, 360.0)) * br;\n        vec3 color = sampleTex(iChannel0, vec2(640.0, 360.0), uv).rgb;\n    \n        for( float i = 0.0; i < 6.283185307179586; i += 6.283185307179586/blurDIR ) {\n    \n            for( float j = 1.0/blurQUAL; j <= 1.0; j += 1.0/blurQUAL ) {\n        \n                vec4 add = sampleTex(iChannel0, vec2(640.0, 360.0), uv + vec2( cos(i), sin(i) ) * rad * j);\n            \n                if(dot(abs(add.rgb), add.rgb) > 0.0 && add.w > 0.0) {\n        \n                    color += add.rgb * (1.0 - exp(-(2.0 * tanh(add.w / 2.0))));\n                    \n                }\n            \n            }\n        \n        }\n    \n        color /= blurQUAL * blurDIR + blurSIZE;\n    \n        fragColor = vec4(color.rgb + texture(iChannel0, uv).rgb, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    uvec3 state = floatBitsToUint(vec3(-rayDir.x, rayDir.yz));\n    vec3 rand = random(state);\n    float det = float(clamp(dot(rand, rand), 0.0, 1.0) < 0.01);\n    fragColor = vec4(1.0, 1.0, 1.0, 100.0) * det;\n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdGW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 263]], "test": "untested"}
{"id": "dtdGW4", "name": "HDR Color Grading", "author": "PKovachev", "description": "Some stuff I was tinkering with in ENBSeries. Quite a bit of color space jumping.\n\nInspired by the talks of Alex Fry, Paul Malin and SandvichDISH's post on the ENB Forums.", "tags": ["color", "imageprocessing", "contrast", "saturation", "hdr", "tonemapping", "tint", "temperature", "vibrance"], "likes": 2, "viewed": 306, "published": 3, "date": "1682466332", "time_retrieved": "2024-07-30T17:58:54.233421", "image_code": "/*\nBSD 2-Clause License\n\nCopyright (c) 2023, Pavel Kovachev\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* PARAMETERS - I HAVE A LAPTOP WITH A 70% sRGB PANEL SO I CAN'T PROMISE THIS LOOKS ANY GOOD */\nconst float EExposure   = 0.2;                      /* F-Stops */\nconst float EMidGray    = 0.18;\nconst float EContrast   = 1.2;\nconst float ESaturation = 1.2;\nconst float EVibrance   = 0.2;\nconst int   ETemp       = 7700;                     /* COLOR TEMPERATURE IN DEGREES KELVIN, 6600 = WHITE */\nconst vec3  ETint       = vec3(0.9, 0.95, 0.9);     /* sRGB COLOR NORMALIZED TO 0-1 RANGE */\nconst float EDesat      = 1.0;                      /* FACTOR OF HIGHLIGHT DESATURATION */\nconst float ECurve      = 0.2;                      /* TONEMAPPER CURVE */\nconst float EShift      = 0.0;                      /* FACTOR OF HUE SHIFT DURING TONEMAPPING */\n\n/* LUMINANCE WEIGHTS */\n#define L709  vec3(0.2126, 0.7152, 0.0722)\n#define L2020 vec3(0.2627, 0.678,  0.0593)\n\n/* PRECOMPUTED LOGC4 PARAMETERS */\n#define LOGC_A    2231.8263090676883\n#define LOGC_B    0.9071358748778103\n#define LOGC_C    0.09286412512218964\n#define LOGC_S    0.1135972086105891\n#define LOGC_T    -0.01805699611991131\n\n/* PRECOMPUTED PQ PARAMETERS */\n#define PQ_C1   0.8359375\n#define PQ_C2   18.8515625\n#define PQ_C3   18.6875\n#define PQ_M1   0.159301758125\n#define PQ_M2   78.84375\n#define PQ_MAX  100.00\n\n\n/* R709 <-> R2020 MATRICES */\n/* https://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.2087-0-201510-I!!PDF-E.pdf */\nconst mat3 m_r709_r2020 = mat3(\n    +0.6274,    +0.3293,    +0.0433,\n    +0.0691,    +0.9195,    +0.0114,\n    +0.0164,    +0.0880,    +0.8956);\n/* https://www.itu.int/dms_pub/itu-r/opb/rep/R-REP-BT.2407-2017-PDF-E.pdf */\nconst mat3 m_r2020_r709 = mat3(\n    +1.6605,    -0.5876,    -0.0728,\n    -0.1246,    +1.1329,    -0.0083,\n    -0.0182,    -0.1006,    +1.1187);\n\n/* R2020 <-> LMS MATRICES */\n/* https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf */\nconst mat3 m_r2020_lms = mat3(\n    +0.412109375,               +0.52392578125,            +0.06396484375,\n    +0.166748046875,            +0.720458984375,           +0.11279296875,\n    +0.024169921875,            +0.075439453125,           +0.900390625);\nconst mat3 m_lms_r2020 = mat3(\n    +3.4366066943330784267,     -2.5064521186562698975,    +0.069845424323191470954,\n    -0.79132955559892875305,    +1.9836004517922907339,    -0.19227089619336198096,\n    -0.025949899690592673413,   -0.098913714711726441685,  +1.1248636144023191151);\n\n/* LMS <-> ICTCP MATRICES */\nconst mat3 m_lms_ictcp = mat3(\n    +0.5,                       +0.5,                      +0.0,\n    +1.61376953125,             -3.323486328125,           +1.709716796875,\n    +4.378173828125,            -4.24560546875,            -0.132568359375);\n    \nconst mat3 m_ictcp_lms = mat3(\n    +1.0,                       +0.0086090370379327566,    +0.11102962500302595655,\n    +1.0,                       -0.0086090370379327566,    -0.11102962500302595655,\n    +1.0,                       +0.560031335710679118,     -0.32062717498731885184);\n \n\n/* COMMON FUNCTIONS */\nfloat min3(vec3 x)\n{\n\treturn min(x.x, min(x.y, x.z));\n}\nfloat max3(vec3 x)\n{\n\treturn max(x.x, max(x.y, x.z));\n}\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec2 saturate(vec2 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec4 saturate(vec4 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 con(vec3 x, float g, float c)\n{\n    return (x - g) * c + g;\n}\n\n/* https://github.com/CeeJayDK/SweetFX/blob/master/Shaders/Vibrance.fx */\nfloat vibrance(vec3 x, float v)\n{\n    float lo, hi, s;\n\n    lo = min3(x);\n    hi = max3(x);\n    s = hi - lo;\n    return 1.0 + (v * (1.0 - (sign(v) * s)));\n}\n\n/* COLOR SPACE CONVERSION */\nfloat lin_sRGB(float x)\n{\n    return x <= 0.0031308 ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055; \n}\nfloat sRGB_lin(float x)\n{\n\treturn x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 lin_sRGB3(vec3 x)\n{\n    x.r = lin_sRGB(x.r);\n    x.g = lin_sRGB(x.g);\n    x.b = lin_sRGB(x.b);\n    \n    return x;\n}\nvec3 sRGB_lin3(vec3 x)\n{\n    x.r = sRGB_lin(x.r);\n    x.g = sRGB_lin(x.g);\n    x.b = sRGB_lin(x.b);\n    \n    return x;\n}\n\n/* https://www.arri.com/resource/blob/278790/bea879ac0d041a925bed27a096ab3ec2/2022-05-arri-logc4-specification-data.pdf */\nfloat lin_LogC(float x)\n{\n    /* SKIPPING CONDITION CHECK SINCE SCENE COLOR IS ASSUMED POSITIVE */\n    return (log2(LOGC_A * x + 64.0) - 6.0) / 14.0 * LOGC_B + LOGC_C;\n}\n\nfloat LogC_lin(float x)\n{\n    return x < 0.0 ? x * LOGC_S + LOGC_T : (exp2(14.0 * (x - LOGC_C) / LOGC_B + 6.0) - 64.0) / LOGC_A;\n\n}\n\n/* IT'S LOGC4 BUT I'M BAD AT NAMING THINGS */\nvec3 lin_LogC3(vec3 x)\n{\n    x.r = lin_LogC(x.r);\n    x.g = lin_LogC(x.g);\n    x.b = lin_LogC(x.b);\n    \n    return x;\n}\nvec3 LogC_lin3(vec3 x)\n{\n    x.r = LogC_lin(x.r);\n    x.g = LogC_lin(x.g);\n    x.b = LogC_lin(x.b);\n    \n    return x;\n}\n\nfloat lin_PQ(float x)\n{\n    float p;\n\n    p = pow(x / PQ_MAX, PQ_M1);\n\n    return pow((PQ_C1 + PQ_C2 * p) / (1.0 + PQ_C3 * p), PQ_M2);\n}\n\nfloat PQ_lin(float x)\n{\n    float p;\n\n    p = pow(x, 1.0 / PQ_M2);\n\n    return pow(max(p - PQ_C1, 0.0) / (PQ_C2 - PQ_C3 * p), 1.0 / PQ_M1) * PQ_MAX;\n}\n\nvec3 lin_PQ3(vec3 x)\n{\n    x.r = lin_PQ(x.r);\n    x.g = lin_PQ(x.g);\n    x.b = lin_PQ(x.b);\n    \n    return x;\n}\n\nvec3 PQ_lin3(vec3 x)\n{\n    x.r = PQ_lin(x.r);\n    x.g = PQ_lin(x.g);\n    x.b = PQ_lin(x.b);\n    \n    return x;\n}\n\nvec3 r709_r2020(vec3 x)\n{\n    return x * m_r709_r2020;\n}\nvec3 r2020_r709(vec3 x)\n{\n    return x * m_r2020_r709;\n}\nvec3 r2020_lms(vec3 x)\n{\n    return x * m_r2020_lms;\n}\nvec3 lms_r2020(vec3 x)\n{\n    return x * m_lms_r2020;\n}\nvec3 lms_ictcp(vec3 x)\n{\n    return x * m_lms_ictcp;\n}\nvec3 ictcp_lms(vec3 x)\n{\n    return x * m_ictcp_lms;\n}\n\nvec3 r2020_ictcp(vec3 x)\n{\n    x = r2020_lms(x);\n    x = lin_PQ3(x);\n    x = lms_ictcp(x);\n\n    return x;\n}\nvec3 ictcp_r2020(vec3 x)\n{\n    x = ictcp_lms(x);\n    x = PQ_lin3(x);\n    x = lms_r2020(x);\n\n    return x;\n}\n\n/* https://tannerhelland.com/2012/09/18/convert-temperature-rgb-algorithm-code.html */\nvec3 k_rgb(int x)\n{\n    vec3 r0;\n    float t;\n\n    t = float(x) * 0.01;\n\n    if (t <= 66.0)\n    {\n        r0.r = 1.0;\n        r0.g = saturate(0.3900815787690196 * log(t) - 0.6318414437886275);\n    }\n    else\n    {\n        r0.r = saturate(1.292936186062745 * pow(t - 60.0, -0.1332047592));\n        r0.g = saturate(1.129890860895294 * pow(t - 60.0, -0.0755148492));\n    }\n    if (t >= 66.0)\n        r0.b = 1.0;\n    else\n    {\n        if (t <= 19.0)\n            r0.b = 0.0;\n        else\n            saturate(r0.b = 0.543206789110196 * log(t - 10.0) - 1.19625408914);\n    }\n    return r0;\n}\n\n/* TONEMAPPING FROM https://www.shadertoy.com/view/llSyRD WITH A FEW TWEAKS */\nfloat squish(float x)\n{\n\treturn 1.0 - exp(-x);\n}\nfloat tonemap(float x, float t)\n{\n\treturn (x < t) ? x : t + squish((x - t) / (1.0 - t)) * (1.0 - t);\n}\nvec3 tonemap3(vec3 x, float t)\n{\n\tx.r = tonemap(x.r, t);\n\tx.g = tonemap(x.g, t);\n\tx.b = tonemap(x.b, t);\n\treturn x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 r0, r1, r2;\n    vec3 t0, t1, t2;\n    vec2 uv;\n    float l0, l1;\n    \n    uv = fragCoord/iResolution.xy;\n    \n    r0 = texture(iChannel0, uv).rgb;\n    r0 = sRGB_lin3(r0);\n    r0 = r709_r2020(r0);\n    r0 *= 1.0 + r0;   /* PSEUDO HDR SINCE IDK HOW TO LOAD AN HDR IMAGE, DON'T COPY PASTE THIS */\n    r0 *= exp2(EExposure);\n    \n    t0 = k_rgb(ETemp);\n    t0 = sRGB_lin3(t0);\n    t0 = r709_r2020(t0);\n    \n    t1 = ETint;\n    t1 = sRGB_lin3(t1);\n    t1 = r709_r2020(t1);\n    \n    /* HACKY BUT CHEAP WAY TO PRESERVE LUMINANCE WITHOUT JUMPING MORE COLOR SPACES */\n    r0 *= t0 / ((t0.r + t0.g + t0.b) * 0.3333333333333333);\n    r0 *= t1 / ((t1.r + t1.g + t1.b) * 0.3333333333333333);\n    \n    r0 = lin_LogC3(r0);\n    r0 = con(r0, EMidGray, EContrast);\n    r0 = LogC_lin3(r0);\n    \n    r1 = r2020_ictcp(r0);\n    r1.yz *= ESaturation;\n    r1.yz *= vibrance(r0, EVibrance);\n    r2 = ictcp_r2020(r1);    /* EARLY EXIT FOR PER-CHANNEL TONEMAPPING LATER */\n    r1.yz *= 1.0 - (1.0 - exp2(dot(r0, L2020) * -EDesat));\n    r0 = ictcp_r2020(r1);\n\n    l0 = max3(r0);\n    l1 = tonemap(l0, ECurve);\n    r0 *= l1 / l0;\n    r0 = mix(r0, tonemap3(r2, ECurve), EShift);\n    \n    r0 = saturate(r2020_r709(r0));\n    r0 = lin_sRGB3(r0);\n    fragColor = vec4(r0, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdGW4.jpg", "access": "api", "license": "bsd-simplified", "functions": [[4292, 4315, 4335, 4335, 4370], [4371, 4371, 4391, 4391, 4426], [4427, 4427, 4452, 4452, 4485], [4486, 4486, 4509, 4509, 4542], [4543, 4543, 4566, 4566, 4599], [4600, 4600, 4623, 4623, 4656], [4658, 4658, 4694, 4694, 4724], [4726, 4800, 4833, 4833, 4956], [4958, 4987, 5012, 5012, 5090], [5091, 5091, 5116, 5116, 5184], [5186, 5186, 5210, 5210, 5306], [5307, 5307, 5331, 5331, 5427], [5429, 5552, 5577, 5650, 5721], [5723, 5723, 5748, 5748, 5854], [5856, 5902, 5926, 5926, 6022], [6023, 6023, 6047, 6047, 6143], [6145, 6145, 6168, 6168, 6281], [6283, 6283, 6306, 6306, 6433], [6435, 6435, 6457, 6457, 6547], [6549, 6549, 6571, 6571, 6661], [6663, 6663, 6688, 6688, 6719], [6720, 6720, 6745, 6745, 6776], [6777, 6777, 6801, 6801, 6831], [6832, 6832, 6856, 6856, 6886], [6887, 6887, 6911, 6911, 6941], [6942, 6942, 6966, 6966, 6996], [6998, 6998, 7024, 7024, 7105], [7106, 7106, 7132, 7132, 7213], [7215, 7302, 7321, 7321, 7888], [7890, 7969, 7992, 7992, 8017], [8018, 8018, 8051, 8051, 8120], [8121, 8121, 8153, 8153, 8238], [8240, 8240, 8295, 8295, 9547]], "test": "untested"}
{"id": "DtdGDN", "name": "Color Study - Plate VI-1b", "author": "Slals", "description": "Reversed grounds :\n\n2 blocks, 2 studies with different color, redish and blueish.", "tags": ["interactionofcolor"], "likes": 0, "viewed": 121, "published": 3, "date": "1682459307", "time_retrieved": "2024-07-30T17:58:55.093122", "image_code": "float rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return step(x, size);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 S = vec2(0.4, 0.4369);\n    \n    float hOffset = 0.2;\n    float vOffset = 0.22;\n    \n    float rectALeft = rectSDF(uv - vec2(-hOffset, vOffset), S);\n    float rectARight = rectSDF(uv - vec2(hOffset, vOffset), S);\n    float rectBLeft = rectSDF(uv - vec2(-hOffset, -vOffset), S);\n    float rectBRight = rectSDF(uv - vec2(hOffset, -vOffset), S);\n    \n    float MX = iMouse.x / iResolution.x;\n    \n    float extandableRectA = rectSDF(uv - vec2(-hOffset + MX * 0.3, vOffset), S + vec2(MX * 2.0, 0.0));\n    float extandableRectB = rectSDF(uv - vec2(-hOffset + MX * 0.3, -vOffset), S + vec2(MX * 2.0, 0.0));\n    \n    vec3 leftAColor = vec3(0.973, 0.737, 0.776);\n    vec3 rightAColor = vec3(0.945, 0.467, 0.525);\n    vec3 leftBColor = vec3(0.647, 0.851, 0.945);\n    vec3 rightBColor = vec3(0.431, 0.729, 0.871);\n    \n    vec3 middleAColor = vec3(0.969, 0.6, 0.663);\n    vec3 middleBColor = vec3(0.584, 0.82, 0.929);\n    \n    vec3 color = vec3(\n        fill(rectALeft, 1.0) * leftAColor\n        + fill(rectARight, 1.0) * rightAColor\n        + fill(rectBLeft, 1.0) * leftBColor\n        + fill(rectBRight, 1.0) * rightBColor\n    );\n    \n    float s = 0.3;\n    float midALeft = fill(extandableRectA, s);\n    float midARight = fill(rectARight, s);\n    float midBLeft = fill(extandableRectB, s);\n    float midBRight = fill(rectBRight, s);\n    \n    color = (midALeft == 1.0 || midARight == 1.0) ? middleAColor : color;\n    color = (midBLeft == 1.0 || midBRight == 1.0) ? middleBColor : color;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdGDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [111, 111, 144, 144, 172], [174, 174, 231, 281, 1845]], "test": "untested"}
{"id": "ml3GWN", "name": "illusion 11c", "author": "FabriceNeyret2", "description": "motion without movment. orthogonal strips.\nvariant of https://shadertoy.com/view/mtc3D4\nvariant of https://shadertoy.com/view/ct33WN\nreplacing #17:sign with +1 to see inflate/deplate only show effect in fullscreen.", "tags": ["illusion", "perception"], "likes": 21, "viewed": 266, "published": 3, "date": "1682427394", "time_retrieved": "2024-07-30T17:58:56.992045", "image_code": "// variant of https://shadertoy.com/view/mtc3D4\n// variant of https://shadertoy.com/view/ct33WN\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // float h = 450.; // R.y;\n    vec2 R = iResolution.xy,\n         U = 5.*( 2.*u - R ) / R.y,                                    // global normalize coords\n         I = floor(U)+.5,                                              // disc Id\n         F = fract(U)-.5,                                              // local disc coords\n         H = fract(1e4*sin(I*mat2(R-17.,R+71.)));                      // 2 random values \n         \n    float p = 15./R.y, l = length(F), L = length(U), i = length(I);\n    O = vec4( mix( .5,                                                 // bg color\n                   .5+.5* sin( 3.*i*atan(U.y,U.x)                      // wavelength\n                               - 20.*iTime* sign(H.x-.5)  - 6.28*H.y   // random dir and phase\n                               - ( l > .4 - 2.*p* abs(dot(U,F))/L/l ?  sign(L-i): 0.) ), // margin phase\n                   smoothstep(0.,-p, l-.4) ) );                        // draw disk\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3GWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 135, 163, 1087]], "test": "untested"}
{"id": "mtc3D4", "name": "illusion 11b", "author": "FabriceNeyret2", "description": "motion without movment.  tangential strips.\nvariant of https://shadertoy.com/view/ct33WN\nreplacing #16:sign with +1 to see inflate/deplate only show effect in fullscreen.", "tags": ["illusion", "perception"], "likes": 15, "viewed": 190, "published": 3, "date": "1682427330", "time_retrieved": "2024-07-30T17:58:57.975416", "image_code": "// variant of https://shadertoy.com/view/ct33WN\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // float h = 450.; // R.y;\n    vec2 R = iResolution.xy,\n         U = 5.*( 2.*u - R ) / R.y,                                    // global normalize coords\n         I = floor(U)+.5,                                              // disc Id\n         F = fract(U)-.5,                                              // local disc coords\n         H = fract(1e4*sin(I*mat2(R-17.,R+71.)));                      // 2 random values \n         \n    float p = 15./R.y, l = length(F), L = length(U);\n    O = vec4( mix( .5,                                                 // bg color\n                   .5+.5* sin( 3.*L                                    // wavelength\n                               - 20.*iTime* sign(H.x-.5)  - 6.28*H.y   // random dir and phase\n                               - ( l > .4 - 2.*p* abs(dot(U,F))/L/l ?  sign(L-length(I)): 0.) ), // margin phase\n                   smoothstep(0.,-p, l-.4) ) );                        // draw disk\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtc3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 115, 1032]], "test": "untested"}
{"id": "dl3GW4", "name": "XOX ", "author": "cisemsu", "description": "XOX GAMES, WINNER X", "tags": ["circle", "x", "xox"], "likes": 0, "viewed": 152, "published": 3, "date": "1682420574", "time_retrieved": "2024-07-30T17:58:58.839106", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C ){    \n\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n  \n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n     \n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cro(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cro(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cro(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\nvoid circle(out vec4 fragColor, in vec2 fragCoord,vec2 uv, vec2 center, float radius, vec3 color){\n\n float d_ = length (center - uv);\n     if (d_ <= radius){\n        fragColor = vec4 (color,1.0);\n    }\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    fragColor = vec4 (0.0,0.0,0.0,1.0); //background color\n        \n    // for O \n    \n    vec2 uv = fragCoord.xy;\n    vec2 center = vec2(133.35,225.);\n    vec2 center2 = vec2(134.,224.5);\n    vec2 center3 = vec2(133.35,72.);\n    vec2 center4 = vec2(134.,71.5);\n    vec2 center5 = vec2(408,72.);\n    vec2 center6 = vec2(407.5,71.5);\n    vec2 center7 = vec2(665,224.);\n    vec2 center8 = vec2(664.5,223.5);\n    vec2 center9 = vec2(665,374.);\n    vec2 center10 = vec2(664.5,373.5);\n    float radius = 0.13 * iResolution.y;\n    float radius2 = 0.115 * iResolution.y;\n    vec3 black = vec3(0.0,0.0,0.0);\n    vec3 white=vec3(1.0,1.0,1.0);\n   \n   \n    circle(fragColor, fragCoord, uv, center,radius,white);\n    circle(fragColor, fragCoord, uv, center2,radius2,black);\n    circle(fragColor, fragCoord, uv, center3,radius,white);\n    circle(fragColor, fragCoord, uv, center4,radius2,black);\n    circle(fragColor, fragCoord, uv, center5,radius,white);\n    circle(fragColor, fragCoord, uv, center6,radius2,black);\n    circle(fragColor, fragCoord, uv, center7,radius,white);\n    circle(fragColor, fragCoord, uv, center8,radius2,black);\n    circle(fragColor, fragCoord, uv, center9,radius,white);\n    circle(fragColor, fragCoord, uv, center10,radius2,black);\n\n    \n    //for background line\n    \n    // first line y\n    vec2 fLine_y1 = vec2(266.7, 0);\n    vec2 fLine_y2 = vec2(266.7, 50);\n    vec2 fLine_y3 = vec2(266.7, 450);\n    \n    float firstLine_y = sdBezier(fragCoord, fLine_y1, fLine_y2, fLine_y3);\n    if (abs(firstLine_y)<=2.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n        \n    // second line y\n    vec2 sLine_y1 = vec2(533.4, 0);\n    vec2 sLine_y2 = vec2(533.4, 50);\n    vec2 sLine_y3 = vec2(533.4, 450);\n    \n    float secondLine_y = sdBezier(fragCoord, sLine_y1, sLine_y2, sLine_y3);\n    if (abs(secondLine_y)<=2.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n        \n    //first line x\n    vec2 fLine_x1 = vec2(0, 150);\n    vec2 fLine_x2 = vec2(400, 150);\n    vec2 fLine_x3 = vec2(900, 150);\n    \n    float firstLine_x = sdBezier(fragCoord, fLine_x1, fLine_x2, fLine_x3);\n    if (abs(firstLine_x)<=2.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n        \n    //second line x\n    vec2 sLine_x1= vec2(0, 300);\n    vec2 sLine_x2 = vec2(400, 300);\n    vec2 sLine_x3 = vec2(900, 300);\n    \n    float secondLine_x = sdBezier(fragCoord, sLine_x1, sLine_x2, sLine_x3);\n    if (abs(secondLine_x)<=2.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n\n    //for X_1\n    \n    vec2 x1_1 = vec2(81,420);\n    vec2 x1_2 = vec2(125, 380);\n    vec2 x1_3 = vec2(200, 320);\n    \n    vec2 x1_4 = vec2(200,420);\n    vec2 x1_5 = vec2(145, 380);\n    vec2 x1_6 = vec2(81, 320);\n    \n    float x_1a = sdBezier(fragCoord, x1_1, x1_2, x1_3);\n    if (abs(x_1a)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n    float x_1b = sdBezier(fragCoord, x1_4, x1_5, x1_6);\n    if (abs(x_1b)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n    \n    //for X_2\n    \n    vec2 x2_1 = vec2(347.7,420);\n    vec2 x2_2 = vec2(401, 380);\n    vec2 x2_3 = vec2(466.7, 320);\n    \n    vec2 x2_4 = vec2(466.7,420);\n    vec2 x2_5 = vec2(415, 380);\n    vec2 x2_6 = vec2(347.7, 320);\n    \n    float x_2a = sdBezier(fragCoord, x2_1, x2_2, x2_3);\n    if (abs(x_2a)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n    float x_2b = sdBezier(fragCoord, x2_4, x2_5, x2_6);\n    if (abs(x_2b)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n    \n    //for X_3\n    \n    vec2 x3_1 = vec2(347.7,270);\n    vec2 x3_2 = vec2(400,230);\n    vec2 x3_3 = vec2(466.7,170);\n    \n    vec2 x3_4 = vec2(466.7,270);\n    vec2 x3_5 = vec2(415,230);\n    vec2 x3_6 = vec2(347.7,170);\n    \n    float x_3a = sdBezier(fragCoord, x3_1, x3_2, x3_3);\n    if (abs(x_3a)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n    float x_3b = sdBezier(fragCoord, x3_4, x3_5, x3_6);\n    if (abs(x_3b)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n        \n   \n    //for X_4\n    \n    vec2 x4_1 = vec2(614.4,120);\n    vec2 x4_2 = vec2(638,100);\n    vec2 x4_3 = vec2(733.4,20);\n    \n    vec2 x4_4 = vec2(733.4,120);\n    vec2 x4_5 = vec2(710,100);\n    vec2 x4_6 = vec2(614.4,20);\n    \n    float x_4a = sdBezier(fragCoord, x4_1, x4_2, x4_3);\n    if (abs(x_4a)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n    float x_4b = sdBezier(fragCoord, x4_4, x4_5, x4_6);\n    if (abs(x_4b)<=4.0)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n    \n  \n    //red line for winner\n    vec2 p27 = vec2(0, 449);\n    vec2 p28 = vec2(400, 225);\n    vec2 p29 = vec2(800, 0);\n     \n    float redLine = sdBezier(fragCoord, p27, p28, p29);\n    if (abs(redLine)<=7.0)\n        fragColor = vec4 (1.0,0.0,0.0,1.0);\n    \n     \n  \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3GW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 80, 80, 108], [110, 110, 173, 173, 1593], [1594, 1594, 1692, 1692, 1798], [1799, 1799, 1855, 1855, 6489]], "test": "untested"}
{"id": "ct33WN", "name": "illusion 11", "author": "FabriceNeyret2", "description": "investigating the hearth of the effect in https://www.shadertoy.com/view/tdyfRR and https://twitter.com/jagarikin/status/1331409504953540613\ntop to bottom: orthogonal, no, tangential strip\n same effect !\ntry replace #4:sign with +1 or -1  inflate/deflat", "tags": ["illusion", "perception"], "likes": 23, "viewed": 358, "published": 3, "date": "1682414018", "time_retrieved": "2024-07-30T17:58:59.626002", "image_code": "  #define f(x)  .5+.5*sin(x)\n//#define f(x)  step(.5,fract((x)/6.))\n\n#define F(y,x,v)  vec4( f( (y)/75. - (abs(x) > 55. ? sign(x):0.) - v*iTime ) )\n                          // ./75 = *3./R.y in icon size \n\n#define band(x,v) O = abs(x) < 60.                   \\\n                        ? abs(U.y) < R.y/3.          \\\n                          ?   F( 0.  , x,v)          \\\n                          : U.y > 0.                 \\\n                            ? F( U.y , x,v)          \\\n                            : F(   x , x,v) : O \n                     \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.*u - R;\n    \n    O = vec4(.5);\n    band(U.x+400., 40.);\n    band(U.x+100., 20.);\n    band(U.x-100.,-20.);\n    band(U.x-400.,-10.);\n // O = ( .6 + .6 * cos( 6.3*O.x  + vec4(0,23,21,0)  ) );  // uncomment to see in chrominance rather than luminance\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct33WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[553, 553, 591, 591, 884]], "test": "untested"}
{"id": "Dtc3W4", "name": "Blue and gold rug", "author": "jarble", "description": "A blue and gold rug pattern.", "tags": ["fractal", "flower", "mosaic", "carpet", "rug"], "likes": 5, "viewed": 208, "published": 3, "date": "1682404095", "time_retrieved": "2024-07-30T17:59:00.557512", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    //uv = mod(uv,1.);\n    vec2 uv1 = uv;\n    for(int k = 0; k < 15; k++){\n        uv =\n            abs(.5-uv+t2*sign(uv.y-uv.x))/1.5+1.\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv+.5*sign(uv.x-uv.y)).yx\n        ;\n        uv =\n            t2-triangle_wave(-uv.yx).yx\n        ;\n        col.x =\n            max(sign(uv.x),col.x)\n            //abs(sign(uv.x)-col.x)/2.\n        ;\n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return mod(floor(-a),b);\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.,\n  s2 = 8.,\n  t = time,\n  m1 =\n      0.\n  ;\n  for(int i = 0; i < 3; i++){\n      \n      t += floor(t/2.);\n      m1 =\n      fmod(t*2.,s2);\n      \n      t = t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  }\n  float\n  m4 =\n      fmod(t*s1,s1)\n  ,\n  m3 =\n      fmod((t+m4)*s1,s1)\n  ;\n  t *=\n      s1*s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1/2.);\n  ;\n  float a=\n      pow((1.-sqrt(fract(t/s1)/5.))/5.,2.)\n  ;\n  float nb = pow(2.,(m3+m2-m1)/5.+8.);\n  return\n      vec2(fract(time*nb*.998+m2/2.)*a,fract(time*nb+m2/2.)*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtc3W4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1051]], "test": "untested"}
{"id": "mttGWH", "name": "Color Study - Plate V-2b", "author": "Slals", "description": "Gradation intensity :\n\nThe alternate gradient in gray scale shows a dematerialized appearance in the center", "tags": ["interactionofcolor"], "likes": 3, "viewed": 162, "published": 3, "date": "1682376211", "time_retrieved": "2024-07-30T17:59:01.565816", "image_code": "float rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - step(size, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= 1.0 - iMouse.x / iResolution.x;\n    \n    float N = 6.0;\n    \n    fragColor = vec4(int(uv.y * 36.0) % 2 < 1 ? uv.x : 1.0 - uv.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [111, 111, 144, 144, 178], [180, 180, 237, 287, 475]], "test": "untested"}
{"id": "dttGWr", "name": "dot video", "author": "FabriceNeyret2", "description": "in each 8x8 tiles, show the center of mass of red.\nclick for color.\n", "tags": ["moment", "gpmipmap"], "likes": 13, "viewed": 282, "published": 3, "date": "1682369856", "time_retrieved": "2024-07-30T17:59:02.450451", "image_code": "// === center of mass of red in 8x8 tiles ============\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         F = fract(u/8.)*2. - 1.;                 // tile centered coords\n         \n    O = texelFetch(iChannel0, ivec2(u/R*S)/8, 3); // get location coordinates\n // O = textureLod(iChannel0, u/R*S/R, 3.);       // interpolated version\n    O.x += 1e-5;                                  // avoid div0\n    O = vec4( smoothstep(.2,-.2,length(F-2.*O.yz/O.x)-.5 ) ); // display disk\n  //if ( fract(iTime/4.)<.5)          // 2.* to amplify displacement\n    if ( iMouse.z > 0. )\n        O *= texture(iChannel1,u/R*S/R);                      // display color\n      \n         \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === store video ==============\n// NB: report video size in Common\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === prepare MIPmap for center of mass of red in 8x8 tiles ====\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float v = T(u).r;\n    vec2  F = fract(u/8.)*2. - 1.;\n    O.rgb = vec3( v, F * v );\n    \n // O = T(u).r * vec4(1, mod(u/4.,2.) - 1., 0 );  // golfed version\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//vec2 S = vec2(512,396); // Britney size.\n  vec2 S = vec2(640,360); // JC.VD size.  \n  \n#define T(u) texelFetch(iChannel0, ivec2(u), 0)", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 94, 94, 693]], "test": "untested"}
{"id": "cldGD8", "name": "Circle arc equal split", "author": "branc116", "description": "Circle, with equal parts. This is sort of a puzzle where you have to find a way to divide a circle into equal parts ( parts of equal shape % rotation and translation. ) AND at least one part musn't touch the center of a circle ( so no pizza slicing... ) ", "tags": ["circle", "puzzle", "equalsplit"], "likes": 3, "viewed": 203, "published": 3, "date": "1682365968", "time_retrieved": "2024-07-30T17:59:03.276243", "image_code": "//branc116\n#define pi 3.1415926535\n#define AA 0\n\nmat3x4 clamp34(mat3x4 m34, float f, float t) {\n    return mat3x4(clamp(m34[0], f, t), clamp(m34[1], f, t), clamp(m34[2], f, t));\n}\n\nvec2 trans_rot(vec2 x, vec2 trans, float rot) {\n    return (x * mat2(cos(rot), sin(rot), sin(-rot), cos(rot))) + trans;\n}\n\nvec2 rot(vec2 x, float rot) {\n    return x * mat2(cos(rot), sin(rot), sin(-rot), cos(rot));\n}\n\nfloat smooth_in(float from, float to, float x, float eps) {\n    return smoothstep(from - eps, from + eps, x) - smoothstep(to - eps, to + eps, x);  \n}\n\nvec3 smooth_eq(float value, float x, float eps) {\n    float l = smoothstep(value - eps, value, x);\n    float u = smoothstep(value, value + eps, x);\n    return vec3(l - u, l, u);\n}\n\nvec2 circ(vec2 x) {\n    vec3 edge = smooth_eq(1., length(x), 2./iResolution.y);\n    float inside = 1. - edge.y;\n    return vec2(edge.x, inside);\n}\n\nvec2 cone(vec2 x, float from_rad, float to_rad) {\n    float angle = atan(x.y, x.x);\n    float is_in = smooth_in(min(from_rad, to_rad), max(from_rad, to_rad), angle, 2./iResolution.y);\n    return vec2(is_in, is_in);\n}\n\nvec3 circ_arc(vec2 x, float segment, float size) {\n    float size_angle = size*2.*pi;\n    float start_angle = size_angle * segment;\n    vec2 ci = circ(x);\n    vec2 co = cone(x, start_angle, start_angle + size_angle);\n    return vec3(ci.x * co.x, ci.y, co.y);\n}\n\nvec3 middle_segment(vec2 x) {\n    vec2 middle_arc = trans_rot(x, vec2(-1. - cos(2.5*pi/3.), -sin(2.5*pi/3.)), 0.);\n    return circ_arc((middle_arc + vec2(0., 1.0)), .5, 1./6.);\n}\n\nvec3 map(vec2 frag) {\n    float zoom = 2. + sin(iTime);\n    vec2 uv = frag/iResolution.yy*zoom - zoom/2.*vec2(iResolution.x/iResolution.y, 1.0);\n    uv = rot(uv, -iTime);\n\n    vec3 col = vec3(0.);\n    col.r += circ(uv).x;\n    mat3x4 count = mat3x4(0.0);\n    for (int i = 0; i < 6; ++i) {\n        vec3 a = circ_arc(trans_rot(uv, vec2(-1.0, 0.0), float(i)*pi/3.), 2., 1./6.);\n        vec3 b = middle_segment(rot(uv, float(i)*pi/3.));\n        col.b += a.x;\n        col.b += b.x;\n        //don't question this 3 lines!\n        count[i/2][(i*2)%4] += a.y - b.y;\n        count[i/2][(i*2)%4 + 1] += (-2. + b.y + a.y + a.z);\n        count[(i + 1)/2%3][(3 + i*2)%4] -= a.y;\n    }\n    bool inn = length(uv) < 1.0;\n    count = clamp34(count, 0., 1.);\n    for (int i = 0; i < 12; ++i) {\n        col += inn ? vec3(\n            count[i/4][i%4]/float(((1 + 1*i) % 6) + 1),\n            count[i/4][i%4]/float(((2 + 3*i) % 12) + 1),\n            count[i/4][i%4]/float(((6 + 5*i) % 12) + 1)) : vec3(0.); \n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 col = vec3(0.);\n    float aa_diff = 2./(float(AA)*2.0 + 1.);\n    int aa_count = (AA*2+1)*(AA*2+1);\n    for (int x = -AA; x <= AA; ++x) {\n        for (int y = -AA; y <= AA; ++y) {\n            col += map(fragCoord + (vec2(x, y)*aa_diff));\n        }\n    }\n    fragColor = vec4(col/float(aa_count), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldGD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 100, 100, 184], [186, 186, 233, 233, 307], [309, 309, 338, 338, 402], [404, 404, 463, 463, 553], [555, 555, 604, 604, 734], [736, 736, 755, 755, 882], [884, 884, 933, 933, 1100], [1102, 1102, 1152, 1152, 1362], [1364, 1364, 1393, 1393, 1542], [1544, 1544, 1565, 1565, 2552]], "test": "untested"}
{"id": "Dtd3WH", "name": "Abstract Liquid w/rotate/zoom", "author": "timmaffett", "description": "i think a little more interesting with rotate/zoom exploration -tmm\nMelting Chromatic Liquid Smoke Effect", "tags": ["water"], "likes": 13, "viewed": 409, "published": 3, "date": "1682359447", "time_retrieved": "2024-07-30T17:59:04.059149", "image_code": "// Fork of \"Abstract Liquid\" by SentientCymatic. https://shadertoy.com/view/ctd3z4\n// 2023-04-24 18:02:54\n\nvec2 hash2( float n ){return fract(sin(vec2(n,n+1.0))*vec2(432.14159,528.14159));}\n\nconst vec2 randConst = vec2(432., 528.);\nconst float randMultiplier = 3.14159;\nfloat rand(const vec2 co) {\n    return fract(sin(co.x * randConst.x + co.y * randConst.y) * randMultiplier);}\n\nfloat custom_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.1, 1.0);\n    return t * t * (3.0 - 2.0 * t);}\n\nfloat noise(in vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 n = p + vec2(2.5, -2.5);\n    float a = mix(rand(n), rand(n + vec2(1.0, 0.0)), f.x);\n    float b = mix(rand(n + vec2(0.0, 1.0)), rand(n + vec2(1.0, 1.0)), f.x);\n    return mix(a, b, f.y);}\n\nvec2 turbulence(vec2 p, float t, float scale){\n    float sum = 0.1;\n    float freq = scale;\n    float smoothness;\n    vec2 noise_coord;\n    for (int i = 0; i < 5; i++){\n        smoothness = custom_smoothstep(0.0, 10.0, float(i));\n        noise_coord = vec2(p + t * 0.25) + vec2(cos(float(i) * 0.6), sin(float(i) * 0.6)) * smoothness;\n        sum += abs(noise(noise_coord)) / freq;\n        freq *= 0.25;}\n    return vec2(sum, sum) * 0.1;}\n\nmat2 mtx = mat2( 0.87,  0.50, -0.50,  0.87 );\n\nfloat fbm( vec2 p ){\n    float f = 0.03;\n    f += 0.980000*noise( p ); p = mtx*p*3.0;\n    f += 0.210000*noise( p ); p = mtx*p*2.0;\n    f += 0.070000*noise( p ); p = mtx*p*2.0;\n    f += 0.060000*noise( p ); p = mtx*p*2.0;\n    f += 0.030000*noise( p ); p = mtx*p*1.0;\n    f += 0.010000*noise( p );\n    p = mtx*p*2.0;\n    f += 0.004000*noise( p );\n    p = mtx*p*2.0;\n    f += 0.002000*noise( p );\n    return f/0.90000;}\n\nfloat pattern(in vec2 p, in float t, in vec2 uv, out vec2 q, out vec2 r, out vec2 g) {\n    float s = dot(uv + 0.5, uv + 0.5);\n    float iMelty = 50.0, iFlowing = 10.0;\n    float l = custom_smoothstep(0., iMelty, sin(t * iFlowing));\n    q = mix(vec2(fbm(p + vec2(t * 1. + sin(t), t * 0.2 + cos(t))),\n                 fbm(p + vec2(t * 0.5 + sin(t + 0.7), t * 0.3 + cos(t + 1.3)))),\n            vec2(fbm(p), fbm(p + vec2(10.49, 1.37))),\n            l);\n    r = mix(vec2(fbm(p + 3.14159 * q + vec2(t * 0.2 + sin(t * 0.5), t * 0.2 + cos(t * 0.7)) + vec2(1.73, 9.6)),\n                 fbm(p + 2. * q + vec2(t * 0.5 + sin(t * 0.3), t * 0.4 + cos(t * 0.9)) + vec2(8.5, 4.8))),\n            vec2(fbm(p + 5. * q + vec2(t) + vec2(33.33, 66.66)), fbm(p + 4. * q + vec2(t) + vec2(8.3, 2.8))),\n            l);\n    g = mix(vec2(fbm(p + 2. * r + vec2(t * 0.5 + sin(t * 0.2), t * 0.3 + cos(t * 0.8)) + vec2(2, 6)),\n                 fbm(p + 1.5 * r + vec2(t * 0.76 + sin(t * 0.4), t * 0.6 + cos(t * 0.6)) + vec2(5, 3))),\n            vec2(fbm(p + 2.5 * r + vec2(t * 5.0) + vec2(2, 6)), fbm(p + 2. * r + vec2(t * 11.0) + vec2(5, 3))),\n            l);\n    vec2 v = turbulence(p * 0.1, t * 0.1, 20.);\n    vec2 m = vec2(fbm(p * 0.5 + vec2(t * 0.9, t * 0.9) + v * 0.5),\n                  fbm(p * 0.5 + vec2(t * 0.9, t * 0.9) + v * 0.5));\n    return mix(fbm(p + 3. * g + vec2(-t * 0.7 + sin(t * 0.5), -t * 0.5 + cos(t * 0.3)) + v * 2. + m * 0.3),\n               fbm(p + 5. * g + vec2(-t * 7.) + v * 3.),\n               l);}\n\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float iSmoke = 0.01;\n    float iSpeed = 0.25;\n    \n    // center for rotate and zoom\n    fragCoord -= iResolution.xy/2.0;\n    fragCoord = mouseRotZoom(fragCoord);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    \n    vec2 q, r, g;\n    float noise = pattern(fragCoord * vec2(iSmoke), iTime * iSpeed, uv, q, r, g);\n    vec3 col = mix(vec3(0.2, 0.4, 0.2), vec3(0.0, 0.25, 0.5), custom_smoothstep(0.1, 1.0, noise));\n    col = mix(col, vec3(0.4, 0.2, 0.2), dot(q, q) * 1.5);\n    col = mix(col, vec3(0.2, 0.4, 0.0), 0.25 * g.y * g.y);\n    col = mix(col, vec3(0.4, 0.2, 0.2), custom_smoothstep(0.2, 0.5, 1.0 * r.g * r.g));\n    col = mix(col, vec3(0.2, 0.4, 0.6), 0.5 * g.x);\n    float timeScale = .25;\n    float xDrift = sin(uv.x * 3.14159 + iTime * timeScale);\n    float yDrift = cos(uv.y * 3.14159 + iTime * timeScale);\n    vec3 drift = vec3(xDrift, yDrift, -xDrift - yDrift) * .1;\n    col += drift;\n    col = mix(col, vec3(1), custom_smoothstep(0., 1000., noise) * custom_smoothstep(0., 1000., noise));\n    col *= noise * 2.;\n    fragColor = vec4(col, 1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtd3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 129, 129, 189], [270, 270, 297, 297, 379], [381, 381, 441, 441, 540], [542, 542, 565, 565, 841], [843, 843, 889, 889, 1280], [1329, 1329, 1349, 1349, 1745], [1747, 1747, 1833, 1833, 3244], [3317, 3317, 3336, 3336, 3385], [3387, 3387, 3415, 3454, 3619], [3621, 3621, 3675, 3675, 4736]], "test": "untested"}
{"id": "Dtt3WH", "name": "plasma 2 w/ mouse rotate/zoom", "author": "timmaffett", "description": "adding mouse play to original - tmm\nu like warp?", "tags": ["2d"], "likes": 2, "viewed": 194, "published": 3, "date": "1682357662", "time_retrieved": "2024-07-30T17:59:04.939795", "image_code": "// Fork of \"plasma 2\" by 104. https://shadertoy.com/view/ml33W8\n// 2023-04-24 17:32:50\n\nconst float gStep = .15;\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec2 uvo = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n\n    \n    uv *= 8.;\n    uv += sin((vec2(uv.y, -uv.x)+iTime*.5)*4.)*.2;\n    uv += 14.+iTime;\n    \n    vec2 id = floor(uv);\n    o = vec4(0);\n    \n    for (float i = 0.;i<1.;i+=gStep)\n    {\n        uv += sin((vec2(uv.y,uv.x) + iTime*.4));\n        \n        id = floor(uv);\n        vec2 p =  uv-id;\n        vec4 h = hash42(id);\n        \n        float d = .707-length((p-.5));\n        float d2 = step(mix(.15,.45,h.x), d);\n        \n        o = vec4(o.r + d2);\n        o = abs(o-.4) * h;\n    }\n    o *= 1.-dot(uvo,2.*uvo);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtt3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 134, 134, 282], [313, 313, 332, 332, 381], [383, 383, 432, 432, 1251]], "test": "untested"}
{"id": "DldGWH", "name": "Rot/Zoom Texture -  bigysmth 306", "author": "timmaffett", "description": "Adding mouse rotate/zoom and time exploring to https://shadertoy.com/view/mt33DH\nThis shader shows how to avoid the ugly artifacts of bilinear texture filtering. You can find more information here [url]https://iquilezles.org/articles/texture[/url]", "tags": ["2d", "texture", "filtering", "cubic", "bilinear"], "likes": 2, "viewed": 171, "published": 3, "date": "1682356627", "time_retrieved": "2024-07-30T17:59:05.857342", "image_code": "// Fork of \"Fork Texture -  biggysmith 306\" by biggysmith. https://shadertoy.com/view/mt33DH\n// 2023-04-24 17:07:18\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is the implementation for my article \"improved texture interpolation\"\n// \n// https://iquilezles.org/articles/texture\n//\n// It shows how to get some smooth texture interpolation without resorting to the regular\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \n// 4 the hardware uses for bilinear interpolation.\n//\n// With this techinque here, you can get smooth interpolation while still using only\n// 1 bilinear fetche, by tricking the hardware. The idea is to get the fractional part\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\n// perfect for this task.\n\n\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.x;\n    //vec2 uv = p*0.1;\t\n\t\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= 0.01;\n    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    \n    //---------------------------------------------\t\n\t// regular texture map filtering\n    //---------------------------------------------\t\n\tvec3 colA = texture( iChannel0, uv/fract(iTime/100.0) ).xyz;\n\n    //---------------------------------------------\t\n\t// my own filtering \n    //---------------------------------------------\t\n\tfloat textureResolution = iChannelResolution[0].x;\n\tuv = uv*textureResolution + 0.5;\n    \n    \n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(10.0*mouse.y));\n\n    \n\tvec2 iuv = floor( uv/fract(iTime/100.0) );\n\tvec2 fuv = fract( uv/sin(iTime/10.0) );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // InigoQuilez original function>>  fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)/textureResolution;\n\tvec3 colB = texture( iChannel0, uv ).xyz;\n    \n    vec2 uv2 = iuv +  fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);\n    uv2 = (uv2 - 0.5)/textureResolution;\n    colA = texture( iChannel0, uv2 ).xyz;\n\t\n    //---------------------------------------------\t\n    // final color\n    //---------------------------------------------\t\n\tfloat f = sin(3.1415927*p.x + 0.7*iTime);\n\tvec3 col = (f>=0.0) ? colA : colB;\n\t//vec3 col = colB; //(false) ? colA : colB;\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldGWH.jpg", "access": "api", "license": "mit", "functions": [[2025, 2025, 2044, 2044, 2093], [2095, 2095, 2152, 2152, 3670]], "test": "untested"}
{"id": "DttGW8", "name": "two tweet trixels", "author": "flockaroo", "description": "trigonal multiscale subdivide in 2 tweets...", "tags": ["multiscale", "subdivision", "npr", "trixels", "golf", "subdivide", "codegolfing", "tinycode"], "likes": 22, "viewed": 419, "published": 3, "date": "1682352153", "time_retrieved": "2024-07-30T17:59:06.657203", "image_code": "// created by florian berger (flockaroo) - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multiscale trixels in 2 tweets of code (560 chars)\n\n// original version (560 chars)\n\n/*#define R(x) mat2(cos(x-vec4(0,33,11,0)))\n#define C(x) texture(iChannel0,(x)/r+.5)\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 q,r=iResolution.xy,u,v,w,c,f,x=vec2(1,0);\n    float z,s=r.y/2e2;\n    mat2 m=R(iTime*.1)*mat2(1,0,.5,.9)*s;\n    \n    vec4 G,H;\n    for(;s<r.y;s*=2.,m*=2.) {\n        q=inverse(m)*(C-r*.5); f=fract(q);\n        u=m*(q-f); v=u+m*x; w=u+m*x.yx;\n        if((z=1.-f.x-f.y)<0.) { u=w; w=u+m*x.xx; }\n        G=C(c=(u+v+w)/3.);\n        if( dot(max(max(abs(C(v+w-c)-G),abs(C(w+u-c)-G)),abs(C(u+v-c)-G)),x.xxxy)>.17 ) break;\n    }\n    O=G-.27*exp2(-f.x*20.)*(H=vec4(1.13,1,.87,1))\n           -.23*exp2(-f.y*30.)*H.zxyw;\n    if(z<0.) O-=.2*exp2(z*60.)*H.yzxw;\n}*/\n\n// much smaller now thx to fabrice!! (509 chars)\n\n#define C(x) texture(iChannel0, (x)/r +.5 )\n\nvoid mainImage( out vec4 O, vec2 C )\n{\n    vec2  q, u=C-C,v=u,w=u,c,f, r = iResolution.xy;\n    float z, s = 0.; \n    vec4  H = vec4(1.13,1,.87,0); \n    \n    for( mat2 m =  mat2(cos(iTime*.1-vec4(0,33,1,34)))*r.y/2e2\n       ; O = C( c = (u+v+w)/3. ),\n         dot(max(max(abs( C(v+w-c) - O ),\n                     abs( C(w+u-c) - O )),\n                     abs( C(u+v-c) - O )),\n             H.yyyw) < .17 && ++s < 9.\n       ; m+=m)\n        q = inverse(m) * ( C - r*.5 ),\n        f = fract(q),\n        u = m*(q-f), v = u + m[0], w = u + m[1],\n        z = 1.-f.x-f.y,\n        z < 0. ?  u = w, w += m*H.yy : w;\n\n    \n    O -=   .27/ exp(f.x*14.)*H\n         + .23/ exp(f.y*21.)*H.zxyw\n         +  .2* exp( z<0.? z*42.: -s )*H.yzxw;\n     //  +  .2/ exp(  z*42.)*H.yzxw * step(-z,0.);  // also quite interesting - visually some tiles sunken some raised\n\n}\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttGW8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1007, 1007, 1045, 1045, 1856]], "test": "untested"}
{"id": "mt33DH", "name": "Fork Texture -  biggysmith 306", "author": "biggysmith", "description": "This shader shows how to avoid the ugly artifacts of bilinear texture filtering. You can find more information here [url]https://iquilezles.org/articles/texture[/url]", "tags": ["2d", "texture", "filtering", "cubic", "bilinear"], "likes": 2, "viewed": 142, "published": 3, "date": "1682343437", "time_retrieved": "2024-07-30T17:59:07.443102", "image_code": "// The MIT License\n// Copyright  2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is the implementation for my article \"improved texture interpolation\"\n// \n// https://iquilezles.org/articles/texture\n//\n// It shows how to get some smooth texture interpolation without resorting to the regular\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \n// 4 the hardware uses for bilinear interpolation.\n//\n// With this techinque here, you can get smooth interpolation while still using only\n// 1 bilinear fetche, by tricking the hardware. The idea is to get the fractional part\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\n// perfect for this task.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.x;\n    vec2 uv = p*0.1;\t\n\t\n    //---------------------------------------------\t\n\t// regular texture map filtering\n    //---------------------------------------------\t\n\tvec3 colA = texture( iChannel0, uv ).xyz;\n\n    //---------------------------------------------\t\n\t// my own filtering \n    //---------------------------------------------\t\n\tfloat textureResolution = iChannelResolution[0].x;\n\tuv = uv*textureResolution + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)/textureResolution;\n\tvec3 colB = texture( iChannel0, uv ).xyz;\n    \n    vec2 uv2 = iuv +  fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);\n    uv2 = (uv2 - 0.5)/textureResolution;\n    colA = texture( iChannel0, uv2 ).xyz;\n\t\n    //---------------------------------------------\t\n    // final color\n    //---------------------------------------------\t\n\tfloat f = sin(3.1415927*p.x + 0.7*iTime);\n\tvec3 col = (f>=0.0) ? colA : colB;\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt33DH.jpg", "access": "api", "license": "mit", "functions": [[1880, 1880, 1937, 1937, 3042]], "test": "untested"}
{"id": "dt3GWH", "name": "clamp sample", "author": "zyc", "description": "clamp sample", "tags": ["clamp"], "likes": 4, "viewed": 184, "published": 3, "date": "1682330847", "time_retrieved": "2024-07-30T17:59:08.229000", "image_code": "#define CLAMP_FROM_RIGHT 0\n#define CLAMP_FROM_LEFT 1\n#define CLAMP_FROM_CENTER 2\n\nconst int clampDir = CLAMP_FROM_CENTER;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float progress = fract(iTime*0.5);\n\n\n    // Output to screen\n    if (clampDir == CLAMP_FROM_RIGHT) {\n        uv.x = clamp(uv.x, 1.0 - progress, 1.0);\n    } else if (clampDir == CLAMP_FROM_LEFT) {\n        uv.x = clamp(uv.x, 0.0, progress);\n    } else if (clampDir == CLAMP_FROM_CENTER) {\n        float p = (1.0 - progress) / 2.0;\n        uv.x = clamp(uv.x, p, 1.0 - p);\n    }\n   \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3GWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 180, 230, 700]], "test": "untested"}
{"id": "mt33D8", "name": "Hilbert Walk 3D", "author": "dr2", "description": "Motion along a 3D Hilbert path (mouseable)", "tags": ["hilbert", "graycode", "peano"], "likes": 29, "viewed": 429, "published": 3, "date": "1682330489", "time_retrieved": "2024-07-30T17:59:09.222344", "image_code": "// \"Hilbert Walk 3D\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 6 in \"Hilbert\" series\n    \"Hilbert Square\"                   (MsGyDK)\n    \"Hilbert 3D\"                       (lltfRj)\n    \"Hilbert's Path\"                   (tl2fWG)\n    \"Hilbertian Saltation\"             (NtVfDh)\n    \"Looping Hilbertian Saltation\"     (DdXGWn)\n*/\n\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r);\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nconst int nBall = 100;\nconst int nDim = 3;\nconst int nBit = 4;\n\nstruct Hvec {\n  int u[nDim];\n};\n\nvec3 ltDir, qHit, qDir;\nfloat dstFar, tCur, segLen;\nint idObj, pathLen, qSeq;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n/*\n  Skilling's Gray-code Hilbert curve algorithm\n \n  Ref: Skilling, J., \"Programming the Hilbert Curve\", AIP Conf. Proc. 707, 381 (2004).\n \n  Source: http://www.inference.org.uk/bayesys/test/hilbert.c\n \n  Simplified by mla (flX3W8) including partial restriction to 3D case.\n \n  Alternative (simpler, and closer to original) adaptation used here.\n \n  Original copyright:\n\n     Filename:  hilbert.c\n     Version:   2 Dec 2003\n   \n     Copyright (c) 1996-2003 Maximum Entropy Data Consultants Ltd,\n     114c Milton Road, Cambridge CB4 1XE, England\n  \n     This library is free software; you can redistribute it and/or\n     modify it under the terms of the GNU Lesser General Public\n     License as published by the Free Software Foundation; either\n     version 2.1 of the License, or (at your option) any later version.\n     \n  Original function headers at end\n*/\n\nHvec AxesToTranspose (Hvec h)\n{\n  int t, q;\n  q = 1 << nBit;\n  for (int k = 0; k < nBit - 1; k ++) {\n    q >>= 1;\n    if ((h.u[0] & q) != 0) h.u[0] ^= q - 1;\n    for (int j = 1; j < nDim; j ++) {\n      t = q - 1;\n      if ((h.u[j] & q) == 0) {\n        t &= h.u[0] ^ h.u[j];\n        h.u[j] ^= t;\n      }\n      h.u[0] ^= t;\n    }\n  }\n  for (int j = 1; j < nDim; j ++) h.u[j] ^= h.u[j - 1];\n  t = h.u[nDim - 1];\n  for (int k = 1; k < nBit; k <<= 1) h.u[nDim - 1] ^= h.u[nDim - 1] >> k;\n  t ^= h.u[nDim - 1];\n  for (int j = nDim - 2; j >= 0; j --) h.u[j] ^= t;\n  return h;\n}\n\nHvec TransposeToAxes (Hvec h)\n{\n  int t, q;\n  t = h.u[nDim - 1] >> 1;\n  for (int j = nDim - 1; j > 0; j --) h.u[j] ^= h.u[j - 1];\n  h.u[0] ^= t;\n  q = 1;\n  for (int k = 0; k < nBit - 1; k ++) {\n    q <<= 1;\n    for (int j = nDim - 1; j > 0; j --) {\n      t = q - 1;\n      if ((h.u[j] & q) == 0) {\n        t &= h.u[0] ^ h.u[j];\n        h.u[j] ^= t;\n      }\n      h.u[0] ^= t;\n    }\n    if ((h.u[0] & q) != 0) h.u[0] ^= q - 1;\n  }\n  return h;\n}\n\nHvec LineToTranspose (int n) \n{\n  Hvec h;\n  int p, t;\n  p = 1 << (nBit - 1);\n  t = 1 << (nDim * nBit - 1);\n  for (int j = 0; j < nDim; j ++) h.u[j] = 0;\n  for (int k = 0; k < nBit; k ++) {\n    for (int j = 0; j < nDim; j ++) {\n      if ((n & t) != 0) h.u[j] |= p;\n      t >>= 1;\n    }\n    p >>= 1;\n  }\n  return h;\n}\n\nint TransposeToLine (Hvec h)\n{\n  int p, n, t;\n  p = 1 << (nBit - 1);\n  t = 1 << (nDim * nBit - 1);\n  n = 0;\n  for (int k = 0; k < nBit; k ++) {\n    for (int j = 0; j < nDim; j ++) {\n      if ((h.u[j] & p) != 0) n |= t;\n      t >>= 1;\n    }\n    p >>= 1;\n  }\n  return n;\n}\n\nvec3 LineToAxes3 (int n)\n{\n  Hvec h;\n  vec3 u;\n  h = TransposeToAxes (LineToTranspose (n));\n  for (int j = 0; j < nDim; j ++) u[j] = float (h.u[j]);\n  return u;\n}\n\nint AxesToLine3 (vec3 u)\n{\n  Hvec h;\n  for (int j = 0; j < nDim; j ++) h.u[j] = int (u[j]);\n  return TransposeToLine (AxesToTranspose (h));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, c, cP, cN;\n  float dMin, d, r;\n  int iSeg;\n  dMin = dstFar / 2.;\n  d = PrBoxDf (p, vec3 (1.));\n  if (d < 0.05) {\n    q = (p + 1.) / 2.;\n    r = 0.005;\n    c = floor (clamp (q, 0.5 * segLen, 1. - 0.5 * segLen) / segLen);\n    iSeg = AxesToLine3 (c);\n    if (iSeg > 0) {\n      cP = LineToAxes3 (iSeg - 1);\n      d = PrEECapsDf (q, (cP + 0.5) * segLen, (c + 0.5) * segLen, r);\n      if (d < dMin) {\n        qDir = c - cP;\n        qSeq = iSeg;\n      }\n      DMINQ (1);\n    } else cP = c;\n    if (iSeg < pathLen) {\n      cN = LineToAxes3 (iSeg + 1);\n      d = PrEECapsDf (q, (c + 0.5) * segLen, (cN + 0.5) * segLen, r);\n      if (d < dMin) {\n        qDir = cN - c;\n        qSeq = iSeg + 1;\n      }\n      DMINQ (1);\n    } else cN = c;\n    if (length (cN + cP - 2. * c) > 0.) {\n      d = PrSphDf (q - (c + 0.5) * segLen, 1.4 * r);\n      if (d < dMin) qSeq = iSeg;\n      DMINQ (2);\n    }\n    dMin *= 2.;\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp, vn;\n  float dMin, dn, df;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  dMin = dstFar;\n  if (df > 0. && dn < df) dMin = dn;\n  return dMin;\n}\n\nvec3 BallPos (int k)\n{\n  vec3 p;\n  float tc;\n  int n, nn;\n  tc = 2. * tCur + float (k) * float (pathLen) / float (nBall);;\n  n = int (mod (tc, float (pathLen)));\n  nn = (n < pathLen) ? n + 1 : pathLen;\n  return (mix (LineToAxes3 (n), LineToAxes3 (nn), smoothstep (0.02, 0.98, fract (tc))) +\n     0.5) * segLen * 2. - 1.;\n}\n\nvec4 BallHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 u, vn;\n  float dMin, d, b, w;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    u = ro - BallPos (k);\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vn = (u + d * rd) / rad;\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n} \n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 db4;\n  vec3 col, vn;\n  float dstObj, nDotL, s;\n  col = vec3 (0.9, 0.9, 1.) * (0.7 + 0.2 * rd.y);\n  if (BlkHit (ro, rd, vec3 (1.)) < dstFar) {\n    segLen = 1. / float (1 << nBit);\n    pathLen = (1 << nDim * nBit) - 1;\n    db4 = BallHit (ro, rd, 0.025);\n    dstObj = ObjRay (ro, rd);\n    if (min (dstObj, db4.x) < dstFar) {\n      if (db4.x < dstObj) dstObj = db4.x;\n      ro += dstObj * rd;\n      if (dstObj == db4.x) {\n        vn = db4.yzw;\n        col = vec3 (1.);\n      } else {\n        vn = ObjNf (ro);\n        col = HsvToRgb (vec3 (mod (- float (qSeq) + 10. * tCur, float (pathLen)) /\n           float (pathLen), 0.7, 1.));\n        if (idObj == 1) {\n          qHit *= normalize (qDir);\n          s = (abs (qDir.x) > max (abs (qDir.y), abs (qDir.z))) ? qHit.x :\n             ((abs (qDir.y) > abs (qDir.z)) ? qHit.y : qHit.z);\n          col *= 0.6 + 0.4 * step (0.5, fract (8. * s / segLen - 2. * tCur));\n        }\n      }\n      nDotL = max (dot (vn, ltDir), 0.);\n      col = col * (0.3 + 0.7 * nDotL * nDotL) +\n         0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  zmFac = 3.8;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 4. * abs (az);\n  } else {\n    az += 0.02 * pi * tCur;\n    el -= 0.05 * pi * sin (0.03 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.5);\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (0); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrEVCapsDf (vec3 p, vec4 u, float r)\n{\n  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;\n}\n\nfloat PrEECapsDf (vec3 p, vec3 v1, vec3 v2, float r)\n{\n  return PrEVCapsDf (p - v1, vec4 (normalize (v2 - v1), length (v2 - v1)), r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\n// Original function headers:\n\n//=============================================================================\n//              Hilbert-curve (a space-filling Peano curve) library\n//=============================================================================\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: LineToAxes\n//            AxesToLine\n//\n// Purpose:   Serial Hilbert length  <---->   multidimensional Axes position.\n//\n//   Space  = n-dimensional hypercube of side R = 2^b\n//            Number of cells = N = R^n = 2^(n*b)\n//\n//   Line   = serial number of cell along Hilbert curve through hypercube\n//          = extended integer of n*b bits ranging from 0 to N-1,\n//            stored as vector of n unsigned b-bit integers with [0] high.\n//\n//   Axes   = Geometrical position of cell\n//          = n b-bit integers representing coordinates.\n//\n// Notes: (1) Unit change in Line yields single unit change in Axes position:\n//            the Hilbert curve is maximally local.\n//        (2) CPU proportional to total number of bits, = b * n.\n//\n// History:   John Skilling  20 Apr 2001, 11 Jan 2003, 3 Sep 2003\n//-----------------------------------------------------------------------------\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: LineToTranspose\n//            TransposeToLine\n//\n// Purpose:   Recover Hilbert integer by bit-transposition\n//\n// History:   John Skilling  20 Apr 2001, 3 Sep 2003, 14 Oct 2003\n//-----------------------------------------------------------------------------\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Functions: TransposeToAxes\n//            AxesToTranspose\n//\n// Purpose:   Transform between Hilbert transpose and geometrical axes\n//\n// History:   John Skilling  20 Apr 2001, 3 Sep 2003, 14 Oct 2003\n//-----------------------------------------------------------------------------\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt33D8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1896, 1896, 1927, 1927, 2466], [2468, 2468, 2499, 2499, 2910], [2912, 2912, 2943, 2943, 3227], [3229, 3229, 3259, 3259, 3499], [3501, 3501, 3527, 3527, 3663], [3665, 3665, 3691, 3691, 3806], [3808, 3808, 3830, 3830, 4771], [4773, 4773, 4806, 4806, 4990], [4992, 4992, 5013, 5013, 5270], [5272, 5272, 5314, 5314, 5626], [5628, 5628, 5650, 5650, 5950], [5952, 5952, 5996, 5996, 6354], [6357, 6357, 6392, 6392, 7521], [7523, 7523, 7579, 7579, 8644], [8646, 8646, 8668, 8668, 8706], [8708, 8708, 8730, 8730, 8768], [8770, 8770, 8802, 8802, 8886], [8888, 8888, 8921, 8921, 8948], [8950, 8950, 8994, 8994, 9063], [9065, 9065, 9119, 9119, 9200], [9202, 9202, 9238, 9238, 9444], [9446, 9446, 9476, 9476, 9589], [9591, 9591, 9615, 9615, 9737]], "test": "untested"}
{"id": "dtcGW8", "name": "Simple Numeral Clock ", "author": "cisemsu", "description": "Since I'm a beginner, I made a clock with simple shapes. Colors are important to me because GALATASARAY.", "tags": ["clock", "circle", "square"], "likes": 0, "viewed": 123, "published": 3, "date": "1682321734", "time_retrieved": "2024-07-30T17:59:10.233641", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy;\n    vec2 center = iResolution.xy * 0.5;\n    float angle = (iTime * 0.20);\n    float radius = 0.45 * iResolution.y;\n    float radius2 = 0.05 * iResolution.y;\n    vec2 extent = vec2 (-cos(angle), sin(angle));\n    \n   \n    vec2 center2 = iResolution.xy * 0.5;\n    \n    vec3 red = vec3(1.0,0.0,0.0);\n    vec3 yellow=vec3(1.0,1.0,0.0);\n    vec2 velocity = vec2(1.0f, 1.0f);\n    float time = mod(iTime * 1.0 / 1.0, 2.0);\n    fragColor = vec4 (1.0,1.0,1.0,1.0);\n    \n    float d = length (center - uv);\n    float d2 = length (center2 - uv);\n    if (d2 <=radius2)\n        fragColor = vec4(red,1.0);\n    else if (d <= radius){\n        fragColor = vec4 (yellow,1.0);\n    }\n\n  vec2 v = vec2(-extent.y,extent.x);\n  vec2 _uv;\n  _uv.x = dot(uv - center, extent);\n  _uv.y = dot(uv - center, v);\n  if (_uv.x >= 0.0 && _uv.y >= 0.0 && _uv.x <= radius && _uv.y <= 4.0)\n        fragColor = vec4 (0.0,0.0,0.0,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 982]], "test": "untested"}
{"id": "ml3GW8", "name": "2D Red Ball", "author": "cisemsu", "description": "This is my first work!", "tags": ["circle", "bal"], "likes": 0, "viewed": 109, "published": 3, "date": "1682321109", "time_retrieved": "2024-07-30T17:59:11.228980", "image_code": "vec3 circle(vec2 uv, vec2 pos, float rad)\n{\n    float d = length (pos - uv) - rad;\n    if (d <= rad)\n        return vec3(1.0,0.0,0.0);\n    else\n        return vec3(1.0,1.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy;\n    vec2 center = iResolution.xy * 0.0;\n\n    float radius = 0.05 * iResolution.y;\n    vec2 velocity = vec2(1.0f, 1.0f);\n    float m = mod(iTime * 250.0 / 500.0, 2.0);\n    if (m < 1.0)\n    {\n        center = vec2(0.0);\n        center += velocity * mod(iTime * 250.0, 500.0);\n    }\n    else\n    {\n        center = iResolution.xy;\n        center -= velocity * mod(iTime * 250.0, 500.0);\n    }\n\n    fragColor = vec4(circle(uv,center,radius), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3GW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 179], [181, 181, 237, 237, 711]], "test": "untested"}
{"id": "cl33DH", "name": "Red and green glass", "author": "jarble", "description": "A shiny fractal pattern.", "tags": ["fractal", "glass"], "likes": 5, "viewed": 203, "published": 3, "date": "1682319858", "time_retrieved": "2024-07-30T17:59:12.117604", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        //if(uv.y>0.) uv.x += .5;\n        //else uv.y += .5;\n        \n        uv =\n            abs(.5+uv.yx+t2.yx)/1.5\n        ;\n        //uv += sign(uv-uv.yx)/2.+.5;\n        if(uv.y>uv.x) uv = uv.yx;\n        //else k += 1;\n\n        t2 =\n            -triangle_wave(uv.yx-.5)\n        ;\n        //if(t2.y>t2.x) t2 = t2.yx;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        \n        {t2 = t2.yx; uv=uv.yx;}\n\n        \n        col =\n            abs(vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.)))\n        ;\n        //uv /= 1.+mod(uv.y,2.);\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float x,float y){\n    return mod(floor(x),y);\n}\n\nvec2 mainSound(int samp, float t){\n  float s1 =\n      8.,\n  m1 =\n      0.,\n  d1 = 1.;\n  ;\n  t /= 8.;\n  for(int i = 0; i < 4; i++){\n      m1 =\n      fmod(t*d1+m1,s1+m1);\n      float d2 = (1.+fmod(m1*t,2.));\n      d1 /= d2;\n      t /= d2;\n  }\n  t /= d1;\n  t /=\n      1.+fmod((t*s1*4.+floor(t*s1*4.)),2.)\n  ;\n  float m3 =\n      fmod((t+floor(t*16.*2.+s1))/(m1+.5),s1)\n  ;\n  t *=\n      1.+fmod(((t*s1)+floor(t*s1/2.+s1)),2.)\n  ;\n\n  float a= 64.*((1.-sqrt(fract(t*s1))))*.2,\n\n  nb = pow(2.,(m3)/5.+7.5)*4.;\n\n  return abs(.5-vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a));\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl33DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1087]], "test": "untested"}
{"id": "ct3GWH", "name": "The AI will hypnotically seduce", "author": "maxwellcoffee", "description": "created with AI", "tags": ["psychedelic"], "likes": 1, "viewed": 144, "published": 3, "date": "1682305709", "time_retrieved": "2024-07-30T17:59:12.959353", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float radius = length(uv);\n    \n    // Add time-based animation\n    float time = iTime * 0.5;\n    \n    // Create a symbol pattern with animation\n    float symbol = sin(uv.x * 10.0 + time) * sin(uv.y * 10.0 + time) + cos(radius * 40.0 + time);\n    \n    // Add vivid colors to the symbol\n    vec3 color = vec3(\n        sin(symbol * 3.1415 + time),\n        cos(symbol * 1.618 + time),\n        sin(symbol * 2.236 + time)\n    );\n    \n    // Create a circular mask to isolate the symbol\n    float mask = smoothstep(0.1, 0.11, radius);\n    color *= mask;\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3GWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 717]], "test": "untested"}
{"id": "mlXGW2", "name": "Checkerboard Box", "author": "Zyphery", "description": "Checkerboard box pattern, usually used for selection patterns in art programs", "tags": ["checkerboard", "square", "box", "pattern"], "likes": 4, "viewed": 181, "published": 3, "date": "1682299501", "time_retrieved": "2024-07-30T17:59:13.870916", "image_code": "const float boxSize = 16.0;\nconst float boxSpeed = 4.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float stp = 1.0 / iResolution.y;\n    const float left = 0.1, right = 0.9, bottom = 0.9, top = 0.1;\n    \n    float rect_lr = (step(left, uv.x) * step(uv.x, right));\n    float rect_lr_i = 1.0 - (step(left, uv.x - stp) * step(uv.x + stp, right));\n    float rect_tb = (step(top, uv.y) * step(uv.y, bottom));\n    float rect_tb_i = 1.0 - (step(top, uv.y - stp) * step(uv.y + stp, bottom));\n\n    \n\n    \n    float checkerboard = 0.0;\n    \n    if(rect_lr * rect_lr_i * rect_tb == 1.0)\n    {\n        checkerboard += fract((floor(iTime * boxSpeed + uv.y * boxSize)) * 0.5) * 2.0;\n    }\n    \n    if(rect_tb * rect_tb_i * rect_lr * (1.0 - rect_lr_i) == 1.0)\n    {\n        checkerboard += fract((floor(iTime * boxSpeed + uv.x * boxSize)) * 0.5) * 2.0;\n    }\n    \n    \n    fragColor.rgb = vec3(checkerboard);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 114, 114, 1005]], "test": "untested"}
{"id": "Dl3GD8", "name": "AI Voronoi", "author": "Dirk", "description": "This was built by chat gpt-4", "tags": ["voronoi", "ai"], "likes": 0, "viewed": 185, "published": 3, "date": "1682298280", "time_retrieved": "2024-07-30T17:59:14.652825", "image_code": "float hash(float n) { return fract(sin(n) * 43758.5453123); }\n\nvec2 hash2(vec2 p) {\n    vec2 SCALE = vec2(37.0, 71.0);\n    vec2 ROTATE = vec2(121.0, 157.0);\n    vec2 OFFSET = vec2(17.0, 43.0);\n\n    float s1 = dot(p, SCALE);\n    float s2 = dot(p, ROTATE);\n\n    return fract(vec2(sin(s1), sin(s2)) * 1399763.5453123) * 2.0 - 1.0;\n}\n\nvec3 hash3(vec3 p) {\n    vec3 SCALE = vec3(127.1, 311.7, 419.2);\n    vec3 ROTATE = vec3(269.5, 183.3, 246.1);\n    vec3 OFFSET = vec3(113.5, 271.9, 124.6);\n    \n    vec3 s = vec3(dot(p, SCALE), dot(p, ROTATE), dot(p, OFFSET));\n    return fract(sin(s) * 143758.5453) * 2.0 - 1.0;\n}\n\nfloat voronoi(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec3 res = vec3(8.0);\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 b = vec2(i, j);\n            vec2 r = vec2(b) - f + hash2(p + b) * 0.35;\n            float d = dot(r, r);\n            int index = int(hash(dot(p + b, vec2(37, 41))));\n            if (d < res[index]) {\n                res[index] = d;\n            }\n        }\n    }\n    return sqrt(res.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float v = voronoi(uv * 2.0);\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "\n\n    //ENGINE\n    \n    \n    #define  loop mainImage\n    \n    #define  e   v4(0.,0.001,0.025,0.05)\n    #define  PI  3.1415926\n    \n    #define  iR  iResolution.xy\n    #define  iM  iMouse\n    #define  iT  iTime\n    \n    #define  v2  vec2\n    #define  v3  vec3\n    #define  v4  vec4\n    #define  i2  ivec2\n    #define  i3  ivec3\n    #define  i4  ivec4\n    #define  m2  mat2\n    #define  m3  mat3\n    #define  m4  mat4\n    \n    #define A abs\n    #define B break\n    #define C clamp\n    #define D dot\n    #define F float\n    #define FL floor\n    #define I int\n    #define K fract\n    #define L length\n    #define M max\n    #define N normalize\n    #define P pow\n    #define Q mix\n    #define R return\n    #define S smoothstep\n    #define V void\n    #define W min\n    #define X cross", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3GD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 61], [63, 63, 83, 83, 329], [331, 331, 351, 351, 610], [612, 612, 635, 635, 1088], [1090, 1090, 1145, 1145, 1285]], "test": "untested"}
{"id": "mtd3Wr", "name": "PBR Path tracer attempt 2", "author": "pathtracerenthusiast", "description": "PBR PT", "tags": ["pathtracer"], "likes": 0, "viewed": 88, "published": 3, "date": "1682281410", "time_retrieved": "2024-07-30T17:59:15.690052", "image_code": "#define exposure .8\n\nvoid mainImage( out vec4 o, vec2 i ) {\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    o.xyz *= exposure;\n    \n    o.xyz = ACESFilm(o.xyz);\n    o.xyz = linearToSRGB(o.xyz);\n    //initR(i,float(iFrame));\n    //for(int i = 0;i<40;i++) rand();\n    //o = vec4(rand());\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FOV 60.\n#define shutAp .05\n#define blurAmt .001\n#define fcsDist 3.\nconst vec3 rightVec = vec3(1.,0.,0.),\nupVec = vec3(0.,1.,0.),\noutVec = vec3(0.,0.,1.);\n\n#define skyBrightness .75\n\n#define numLvls 8\n#define spp 8.\n\nconst float dv = 1./tan(d2r(FOV)*.5);\n\nHit worldInt(vec3 ro,vec3 rd,World objs) {\n    Hit h;\n    h.len = -1.;\n    h.type = -1;\n    \n    int id;\n    \n    Sphere sphs[c_w_sphs] = objs.sphs;\n    for(int i = 0; i < c_w_sphs; i++){\n        bool ff;\n        float d = sphInt(ro,rd,sphs[i],ff);\n        if(d>=c_Small&&(d<h.len||h.len<0.)) {\n        h.ff=ff;h.len=d;h.mat=sphs[i].m;\n        h.type=0;id=i;}\n    }\n    \n    if(h.type==0) {Sphere obj = sphs[id];h.nor = normalize((ro+rd*h.len)-obj.pos);}\n    \n    //if(!h.ff) h.nor *= -1.;\n    \n    return h;\n}\n\nvec3 getSky(vec3 rd,float t) {\n    return skyBrightness*SRGBToLinear(texture(iChannel1,rd).xyz);\n    //return vec3(.3,.625,.95);\n}\n\nvec3 scatter(out vec3 ro, inout vec3 rd, MatPBR m,vec3 p,in vec3 n){\n    ro = p;\n    float r = m.roughness, met = m.metalness;\n    \n    vec3 N = HSampleGGX(n,r);\n    \n    rd = reflect(rd,N);\n    \n    #if 0\n    vec3 F0 = mix(vec3(.04),m.albedo,met);\n    vec3 F = fresnelSchlick(md(N,-rd),F0);\n    return mix(m.albedo,,F);\n    #else\n    return m.albedo;\n    #endif\n}\n\nSphere new(vec3 p,float rad,vec3 alb,float rog,vec3 ems,float met) {\n    return Sphere(p,rad,MatPBR(alb,ems,rog,met));\n}\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n    o = texelFetch(iChannel0,ivec2(i),0);\n    float framespp = float(iFrame)*spp;\n    \n    vec3 ttcol = vec3(0.);\n    \n    for(float j = 0.; j < spp; j++) {\n        initR(i,framespp + j);\n        \n        vec2 pixT = (-iR+ 2.*(i + rand2())) / iR.y;\n        vec3 er = normalize(vec3(pixT,dv));\n        \n        float ctime = iTime - rand()*shutAp;\n        \n        // Objects\n        \n        Sphere sphs[c_w_sphs] = Sphere[c_w_sphs](\n        new(vec3(0.,0.,3.5),1.,vec3(1.,.8,.5),.8,vec3(0.),1.),\n        new(vec3(0.,-101.,0.),100.,vec3(1.),.3,vec3(0.),0.),\n        new(vec3(0.,2.5,3.),.75,vec3(.5),.75,vec3(1.),0.)\n        );\n        \n        // Automatic code continues\n        World W;\n        W.sphs = sphs;\n        \n        vec3 rd = er.x*rightVec+ er.y*upVec + er.z*outVec;\n        vec3 ro = vec3(0.);\n        \n        vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n        vec3 gd = normalize(er*fcsDist - go);\n        rd = normalize(rd + gd.x*rightVec + gd.y*upVec);\n        ro += go.x*rightVec + go.y*upVec;\n        \n        vec3 col = vec3(0.), mask = vec3(1.), oldNor = rd;\n        \n        for(int k = 0; k < numLvls; k++){\n            // Intersection\n            Hit inter = worldInt(ro,rd,W);\n            \n            // Sky\n            if(inter.len == -1.) {col+=getSky(rd,ctime)*mask;break;}\n            \n            // Data Retrieval\n            MatPBR mat = inter.mat;\n            vec3 p = inter.len*rd+ro;\n            \n            // Coloring, masking, and scattering\n            col += mat.ems*mask;\n            mask *= scatter(ro,rd,mat,p,inter.nor);\n        }\n        \n        ttcol += col;\n    }\n    \n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define c_w_sphs 3\n\n\n#define iR iResolution.xy\n#define c_PI 3.1415926523\n#define c_Inf 3.4028235e38\n#define c_Small .0001\n\n#define md(a,b) max(0.,dot(a,b))\nconst float c_piover180 = c_PI/180.;\n#define d2r(a) a*c_piover180\n\n//Thanks Dave_Hoskins\nfloat _seed = 0.;\n/*\nfloat rand(){\n    float v = fract(_seed*.1031);\n    v *= v + 33.33;\n    v *= v + v*18.23;\n    //v += 34.35;\n    _seed = v;\n    return fract(v);\n}\n\nvec2 rand2(){\n    vec3 p = fract(_seed*vec3(.1031,.103,.0973));\n    p += dot(p,p.yzx+33.33);\n    vec2 a = (p.xx+p.yz)*p.zy;\n    _seed = a.x+a.y-a.x*a.y+a.x*a.x+a.y*a.y;\n    return fract(a);\n}*/\n/*\nfloat rand() {\n    _seed = (_seed * 27.19 + 27.49) * _seed + 93.73;\n    _seed /= abs(_seed-234.56);\n    //_seed *= (1.+fract(_seed))*abs(90.78-_seed);\n    float a = _seed;\n    //_seed -= 45.54;\n    return fract(a);\n}*/\nfloat rand(){\n    float p = fract(_seed * .1031);\n    p *= p + 23.43;\n    p *= p + p;\n    _seed = p;\n    return fract(p);\n}\n\nvec2 rand2(){\n    return vec2(rand(),rand());\n}\n/*\nvoid initR(vec2 p,float t) {\n    vec3 p3 = vec3(p.y,t,p.x);\n    p3 = fract(p3*.1031);\n    p3 += dot(p3*2.*fract(p3),p3.zyx+32.31);\n    _seed = fract((p3.x+p3.y)*p3.z);\n}*/\nvoid initR(vec2 p,float t){\n    vec3 p3 = vec3(p,t);\n\tp3  = fract(p3 * .1214);\n    p3 += dot(p3, p3.zyx + 41.62);\n    _seed = fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*c_PI;\n    float z = rand()*2.-1.;\n    float r = sqrt(1.-z*z);\n    float x = r*cos(phi), y = r*sin(phi);\n\treturn vec3(x,y,z);\n}\n\nvec3 hemi(vec3 h){\n    vec3 v = uniformVec();\n    return normalize(v-2.*h*md(v,h));\n}\n\n\nstruct MatPBR {\n    vec3 albedo,\n    ems;\n    float roughness,\n    metalness;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rad;\n    MatPBR m;\n};\n\nstruct Hit {\n    float len;\n    vec3 nor;\n    bool ff;\n    MatPBR mat;\n    int type;\n};\n\nstruct World {\n    Sphere sphs[c_w_sphs];\n};\n\n\n\nvec3 LessThan(vec3 f, float val) {\n    return vec3(\n        (f.x < val) ? 1. : 0.,\n        (f.y < val) ? 1. : 0.,\n        (f.z < val) ? 1. : 0.);\n}\n \nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - .055,\n        rgb * 12.92,\n        LessThan(rgb, .0031308)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(((rgb + .055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        LessThan(rgb, 0.04045)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0., 1.);\n}\n\nfloat sphInt(in vec3 ro,vec3 rd,Sphere sph,out bool ff){\n    ro -= sph.pos;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sph.rad*sph.rad;\n    float h = b*b - c;\n    if( h<0. ) return -1.;\n    h = sqrt( h );\n    if(length(ro)<=sph.rad){\n        ff = false;\n        return -b+h;\n    }else{\n        ff = true;\n        return -b-h;\n    }\n}\n\nvec3 orient(vec3 S,vec3 N){\n    vec3 up = abs(N.z) < .999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\n    vec3 tangent = normalize(cross(up,N));\n    vec3 bitangent = cross(N,tangent);\n    return tangent*S.x + bitangent*S.y + N*S.z;\n}\n\n// Generated bu ChatGPT\nvec3 HSampleGGX(vec3 n,float r){\n    float a2 = r*r;\n    float phi = 2.*c_PI*rand();\n    float ry = rand();\n    float cosTheta = sqrt((1.-ry)/(1.+(a2*a2-1.)*ry));\n    float sinTheta = sqrt(1.-cosTheta*cosTheta);\n    \n    vec3 h = vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n    return orient(h,n);\n}\n\n\nfloat distributionGGX(vec3 N, vec3 H, float r) {\n    float a2 = r*r*r*r;\n    float NdotH  = md(N,H);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float denom = (NdotH2*(a2-1.) + 1.);\n    denom *= c_PI*denom;\n\t\n    return a2/denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float r0) {\n    float r1 = r0 + 1.;\n    float k = r1*r1 / 8.;\n\n    float denom = NdotV*(1. - k) + k;\n\t\n    return NdotV / denom;\n}\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float r){\n    float NdotV = md(N,V);\n    float NdotL = md(N,L);\n    float ggx2  = geometrySchlickGGX(NdotV,r);\n    float ggx1  = geometrySchlickGGX(NdotL,r);\n\t\n    return ggx1*ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1. - F0)*pow(clamp(1.- cosTheta,0.,1.),5.);\n}  \n\n\nvec3 cosineWeighted(vec3 N) {\n    float u1 = rand(), u2 = rand();\n    float r = sqrt(u1),\n    theta = 2.*c_PI*u2;\n    \n    float x = r*cos(theta), y = r*sin(theta),\n    z = sqrt(max(0.,1.-x*x-y*y));\n    \n    return orient(vec3(x,y,z),N);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtd3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 59, 59, 304]], "test": "untested"}
{"id": "dlt3Wr", "name": "Rorschach Of Sound", "author": "QuantumSuper", "description": "An auto-VJ based on a spectrogram in polar coordinates. Utilizing compression for colors & lighting.\n\n - use with audio in iChannel0 of Buffer A -", "tags": ["2d", "music", "buffer", "spectrogram"], "likes": 7, "viewed": 346, "published": 3, "date": "1682276485", "time_retrieved": "2024-07-30T17:59:16.772159", "image_code": "// Rorschach Of Sound 0.51.230426 by QuantumSuper\n// auto-vj which doubles as a spectrogram visualizer\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define zoom (400./iResolution.x)\n#define PI 3.14159265359 \n\nfloat compressDat(vec2 pos, vec2 stepSize, float steps){ //reads & sums up iChannel1.r/b from pos until pos+stepSize*steps in .y domain\n    float maxVal,curVal = 0.;\n    \n    for (float n=0.; n<steps; n++){\n        maxVal = getDat( iChannel1, pos+stepSize*n).b;\n        curVal += (maxVal>.0)? clamp( getDat( iChannel1, pos+stepSize*n).r/maxVal, .0, 1.) : getDat( iChannel1, pos+stepSize*n).r; //normalize over maximum estimation\n    }\n    \n    return curVal/steps; //normalize over steps\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // Prepare view\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x,iResolution.y); //long edge -1 to 1\n    uv *= max(iResolution.x,iResolution.y)/sqrt(iResolution.x*iResolution.x+iResolution.y*iResolution.y) * zoom; // stretch to fill screen & zoom\n    uv = vec2(uv.y,-abs(uv.x)); //symmetry & domain flip\n    \n    \n    // Polar coordinates\n    float r = mod(float(iFrame)/iResolution.x-length(uv),1.);\n    float rho =  (atan(uv.y,uv.x)/PI+1.);\n    \n    \n    // Compression (assume sound texture with 44.1kHz in 512 texels)\n    float tc = mod(float(iFrame)+.001,iResolution.x); //latest texture position\n    vec4 fft = vec4(\n        compressDat( vec2(tc, 1), vec2(0,  1), 2.), //bass, 0-517Hz, reduced to 86-258Hz\n        compressDat( vec2(tc, 6), vec2(0,  1), 2.)+ //speech I, 517-689Hz\n        compressDat( vec2(tc, 8), vec2(0,  2), 3.)+ //speech II, 689-1206Hz\n        compressDat( vec2(tc,14), vec2(0,  4), 3.), //speech III, 1206-2067Hz\n        compressDat( vec2(tc,24), vec2(0, 10), 8.), //presence, 2067-8183Hz, tenth sample\n        compressDat( vec2(tc,95), vec2(0,100), 5.)); //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y/=3.; //finalize normalization\n    \n    \n    // View manipulation\n    float wave = getDat( iChannel1, vec2(mod(float(iFrame)+.001,iResolution.x) ,rho*iResolution.y)).g;\n    if (wave == .0) wave = dot( fft, cos(2.*PI*(iTime*vec4(86,517,2067,8183)+rho)))/8. + .5; //catch if no waveform found, synthesize crude approximation        \n    r = .94*r + .06*length(uv) * wave; //wobble by waveform\n    rho = (pow(10.,rho)-1.)/9.; //exponential frequency scale of pow10 to increase visibility of lower frequencies\n  \n\n    // Compression manipulation\n    fft.yzw = 2.*fft.yzw-fft.zwy-fft.wyz; //get differences\n    fft.yzw /= max(abs(fft.y),max(abs(fft.z),max(abs(fft.w),.001))); //normalize\n    \n    fft.x = pow(fft.x,6.); //weaken weaker bass (exaggerate movement)\n    \n    \n    // Draw image\n    float amp = getDat( iChannel1, vec2( r, rho) * iResolution.xy).r;\n    amp *= amp*amp*amp; //increase contrast\n    \n    float d = 10.*length(uv/zoom)+1.5; d *= d; //offset distance factor\n    vec3 col = amp * 10./d * (1.-cos(fft.zwy*PI)); //vignette & color\n    \n    d *= d;\n    col = vec3(10.+20.*fft.x)/d * (.8+.2*col) + col*(1.-1./d); //center light\n    \n    col *= abs(cos(.06666*iTime+vec3(0,.7854,1.571))); //color shift \n    col = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4( col, 1.); //output\n    \n    \n    // Utility\n    //fragColor = vec4(getDat( iChannel1, fragCoord).rrr,1); //audio spectrum over time\n    //fragColor = vec4(getDat( iChannel1, fragCoord).ggg,1); //wave form over time\n    //fragColor = vec4(getDat( iChannel1, fragCoord).bbb,1); //average amplitude over time\n    //fragColor = vec4(step(.0,(fragCoord.y/iResolution.y-.9)),vec2(dot(step(.0,fft-abs(floor(fragCoord.x/iResolution.x*4.-vec4(0,1,2,3)))-fragCoord.y/iResolution.y/.9),vec4(1))),1); //final compression data\n    //fragColor = vec4(vec3(step(abs(wave-fragCoord.x/iResolution.x)-.01,.0)),1); //polar waveform\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON (0.0) of Rorschach Of Sound by QuantumSuper\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define getDat(buf,addr) texelFetch( buf, ivec2(addr), 0)", "buffer_a_code": "// BUFFER A (0.3) of Rorschach Of Sound by QuantumSuper\n// audio spectrum over time\n// red: amplitude by brightness of frequency by y-axis at time by x-axis\n// green: waveform by brightness of frequency by y-axis at time by x-axis\n// blue: average amplitude by brightness of frequency by y-axis at time by x-axis\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define TRACKDURATIONINFRAMES 3600.\n\nfloat estMax(float p){ //estimate changing maximum over time of sound texel by weighted amplitude tracking\n    float curVal = clamp( getDat( iChannel0, vec2( p/iResolution.y*512., 0)).x, .0, 1.); //current amplitude\n    float maxVal = clamp( getDat( iChannel1, vec2( (mod(float(iFrame-1)+.001,iResolution.x)), p)).z, .0, 1.); //latest max amp\n    \n    if (curVal >= maxVal) maxVal = 0.; //check for new max    \n    \n    if (maxVal != 0.) //avoid uninitialized state & deprecated maxVal\n        curVal *=    1./TRACKDURATIONINFRAMES,\n        maxVal *= 1.-1./TRACKDURATIONINFRAMES;\n  \n    return maxVal+curVal; //returns value between 0 and 1\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    fragColor = (mod(fragCoord.x-float(iFrame)+.001,iResolution.x)<1.)? vec4( \n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 0)).x, //amplitudes\n        getDat( iChannel0, vec2( fragCoord.y/iResolution.y*512., 1)).x, //waveform\n        estMax( fragCoord.y), //average amplitude\n        1)\n        : getDat( iChannel1, fragCoord); //carry over \"long-term\" memory    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33124, "src": "https://soundcloud.com/dvskrecords/rec003wav", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// BUFFER B (0.0) of Rorschach Of Sound by QuantumSuper\n// workaround to avoid self-sampling of Buffer A\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = getDat( iChannel1, fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlt3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 272, 351, 705], [707, 707, 762, 783, 3822]], "test": "untested"}
{"id": "mtdGWn", "name": "droste effect with arrows", "author": "yasuo", "description": "This shader uses the 'droste' logic from the following code by roywig.\nhttps://www.shadertoy.com/view/Ml33R7\n", "tags": ["graphicdesign", "cineshader"], "likes": 29, "viewed": 1827, "published": 3, "date": "1682264778", "time_retrieved": "2024-07-30T17:59:17.805396", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(3.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// principal value of logarithm of z\n// https://gist.github.com/ikr7/d31b0ead87c73e6378e6911e85661b93\nvec2 clog (vec2 z) {\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\n// The following code will return the Droste Zoom UV.\n// by roywig https://www.shadertoy.com/view/Ml33R7\nvec2 drosteUV(vec2 p){\n    float speed = 0.5;\n    float animate = mod(iTime*speed,2.07);\n    float rate = sin(iTime*0.5);\n    p = clog(p)*mat2(1,.11,rate*0.5,1);\n    //p = clog(p);\n    p = exp(p.x-animate) * vec2( cos(p.y), sin(p.y));\n    vec2 c = abs(p);\n    vec2 duv = .5+p*exp2(ceil(-log2(max(c.y,c.x))-2.));\n    return duv;\n}\n\nfloat arrowBase(vec2 p){\n    vec2 prevP = p;\n    p.y-=0.3;\n    float d = Tri(p,vec2(0.35));\n    p = prevP;\n    p-=vec2(0.,0.1);\n    float d2 = Tri(p,vec2(0.3));\n    d = max(-d2,d);\n    p = prevP;\n    p.y+= 0.1;\n    d2 = B(p,vec2(0.07,0.2));\n    float a = radians(-45.);\n    p.x = abs(p.x);\n    p.y+=0.2;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat arrow(vec2 p, float speed){\n    p.y-= 0.5;\n    p.y-=iTime*(0.5+(speed*0.5));\n    p.y = mod(p.y,1.)-0.5;\n    vec2 prevP = p;\n    float d = abs(arrowBase(p))-0.01;\n    \n    p.y+= 0.04;\n    float d2 = B(p,vec2(0.03,0.2));\n    float a = radians(-45.);\n    p.x = abs(p.x);\n    p.y+=0.2;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    p = prevP;\n    a = radians(45.);\n    p.x = abs(p.x);\n    p.y-=0.1;\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,abs(d2)-0.01);\n    \n    p = prevP;\n    p.y-=0.21;\n    d2 = Tri(p,vec2(0.2));\n    p = prevP;\n    p-=vec2(0.,0.18);\n    \n    d2= max(-Tri(p,vec2(0.2)),d2);\n    \n    d = min(d,d2);    \n    \n    \n    return d;\n}\n\nfloat bg(vec2 p){\n    vec2 prevP = p;\n    p = mod(p,0.1)-0.05;\n    float d = length(p)-0.002;\n    \n    return d;\n}\n\nfloat otherGraphicItems(vec2 p){\n    vec2 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x-=0.45;\n    float d = B(p,vec2(0.002,0.3));\n    p.x+=0.02;\n    p.y+=iTime*0.2;\n    p.y=mod(p.y,0.05)-0.025;\n    float d2 = B(p,vec2(0.02,0.002));\n    d2 = max((abs(prevP.y)-0.3),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.42;\n    p.y = abs(p.y)-0.3;\n    d2 = B(p,vec2(0.03,0.003));\n    d = min(d,d2);\n    \n    p = prevP;\n    p = abs(p)-0.3;\n    p*=Rot(radians(iTime*100.-45.));\n    d2 = B(p,vec2(0.04,0.003));\n    d = min(d,d2);\n    \n    p = prevP;\n\n    p.y+=sin(-iTime)*0.25;\n    p.x = abs(p.x)-0.39;\n    d2 = B(p,vec2(0.005,0.02));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat drawGraphics(vec2 p){\n    vec2 prevP = p;\n    p*=4.; // `4.` will be the best fit.\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    vec2 prevGr = gr;\n    \n    float n = random(id);\n    \n    float d = bg(gr);\n    \n    gr = prevGr;\n    if(n<0.3){\n        gr*=Rot(radians(90.));\n    } else if(n>=0.3 && n<0.6){\n        gr*=Rot(radians(180.));\n    } else if(n>=0.6 && n<0.9){\n        gr*=Rot(radians(270.));\n    }\n    \n    float d2 = otherGraphicItems(gr);\n    d = min(d,d2);\n    \n    d2 = max(B(prevGr,vec2(0.45)),arrow(gr,n));\n    d = min(d,d2);\n    \n    gr = prevGr;\n    d2 = abs(B(gr,vec2(0.45)))-0.01;\n    d2 = max(-(abs(gr.x)-0.35),d2);\n    d2 = max(-(abs(gr.y)-0.35),d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    vec2 duv = drosteUV(p);\n    \n    vec3 col = vec3(0.);\n    \n    p = duv;\n    float d =drawGraphics(p);\n    \n    col = mix(col,vec3(1.),S(d,0.));\n    p = prevP;\n    col*=length(p); // The Antialiasing of the small scale of the graphics looks not great. Added the fog effect to fade them out.\n    \n    // debug\n    //p = duv;\n    //vec2 gr = fract(p*4.)-0.5;\n    //col.rg+=gr;\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 444, 467, 467, 540], [542, 644, 664, 664, 712], [714, 819, 841, 841, 1148], [1150, 1150, 1174, 1174, 1538], [1540, 1540, 1573, 1573, 2215], [2217, 2217, 2234, 2234, 2331], [2333, 2333, 2365, 2365, 3022], [3024, 3024, 3051, 3051, 3751], [3753, 3753, 3810, 3810, 4305]], "test": "untested"}
{"id": "Dtd3Wr", "name": "Pixel Art Postprocessing Shader", "author": "ThePlaneGuy45", "description": "pixels go brr", "tags": ["postprocessing", "normalmap", "pixelart"], "likes": 15, "viewed": 382, "published": 3, "date": "1682260157", "time_retrieved": "2024-07-30T17:59:18.821679", "image_code": "// Pixel Art Shader\n// Feel free to use, just give credit as always\n// - TPG45\n\n#define COLOR_STEP 6.0\n#define PIXEL_SIZE 4.0\n\nvec4 colorize(in vec4 color) {\n\n    // Pixel art coloring\n    vec3 nCol = normalize(color.rgb);\n    float nLen = length(color.rgb);\n    return vec4(nCol * round(nLen * COLOR_STEP) / COLOR_STEP, color.w);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel Sizing\n    float ratio = iResolution.y/720.0;\n    vec2 pixel = round(fragCoord / (PIXEL_SIZE * ratio)) * PIXEL_SIZE * ratio;\n    vec2 uv = pixel/iResolution.xy;\n    fragColor = colorize(texture(iChannel0, uv));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "uint raySphere(in Sphere sph, inout Record rec) {\n\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    \n    if (disc > 0.0) {\n    \n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        \n        if(dstNear < rec.dist) {\n        \n            if(dstNear > 0.0) {\n        \n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.offset = (rec.intersect - sph.center - sph.radius) / sph.radius - 0.5;\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                \n                return uint(0x1);\n        \n            }\n        \n        }\n        \n        return uint(0x0);\n    \n    }\n\n}\n\nvoid distances(inout Record rec) {\n\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 0, 10.0, 0.42, 0.75), vec3(200.0, 0.0, 0.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 1, 40.0, 0.42, 0.40), vec3(0.0, 0.0, 200.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 2, 10.0, 0.42, 0.80), vec3(-200.0, 0.0, 0.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 3, 10.0, 0.42, 0.60), vec3(0.0, 0.0, -200.0), 100.0), rec);\n\n}\n\nvoid initRay(inout Ray ray, in vec2 fragCoord) {\n\n    ray.origin = vec3(fragCoord, -500.0);\n    ray.normal = vec3(0.0, 0.0, 1.0);\n    mat2 rot = rot2(-0.392699081699);\n    ray.origin.yz *= rot;\n    ray.normal.yz *= rot;\n\n}\n\nvoid initRecord(inout Record rec, in Ray ray) {\n\n    rec.ray = ray;\n    rec.hit = false;\n    rec.dist = 100000.0;\n\n}\n\nvec4 triPlanar(sampler2D tex, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    vec3 blend = normalize(max(abs(normal), 0.000001));\n    float sum = blend.x + blend.y + blend.z;\n    blend /= sum;\n    vec4 x = texture(tex, offset.yz * scale + imgOffset);\n    vec4 y = texture(tex, offset.xz * scale + imgOffset);\n    vec4 z = texture(tex, offset.xy * scale + imgOffset);\n    return x * blend.x + y * blend.y + z * blend.z;\n\n}\n\nvec4 texturize(int id, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    switch(id) {\n    case 0:\n        return triPlanar(iChannel0, offset, normal, scale, imgOffset);\n    case 1:\n        return triPlanar(iChannel1, offset, normal, scale, imgOffset);\n    case 2:\n        return triPlanar(iChannel2, offset, normal, scale, imgOffset);\n    case 3:\n        return triPlanar(iChannel3, offset, normal, scale, imgOffset);\n    }\n    return vec4(0.0);\n\n}\n\nfloat getHeight(vec4 tex) {\n\n    return dot(tex.rgb, vec3(.2126, .7152, .0722));\n\n}\n\nvec3 normal(int id, vec3 offset, vec3 normal, float scale, vec2 res, float strength) {\n\n    float current = getHeight(texturize(id, offset, normal, scale, vec2(0.0)));\n    float x = (getHeight(texturize(id, offset, normal, scale, vec2(1.0 / res.x, 0.0))) - current) * strength;\n    float y = (getHeight(texturize(id, offset, normal, scale, vec2(0.0, 1.0 / res.y))) - current) * strength;\n    return normalize(vec3(x, y, 1.0));\n\n}\n\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nvec4 Trace(in vec2 fragCoord, vec3 iChannelResolution[4], float iTime) {\n\n    Ray ray;\n    Record rec;\n    initRay(ray, fragCoord);\n    initRecord(rec, ray);\n    distances(rec);\n    if(rec.hit) {\n        vec3 matColor;\n        vec3 nMap;\n        if(rec.material.useTexture) {\n            matColor = texturize(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, vec2(0.0)).xyz;\n            nMap = normal(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, iChannelResolution[3].xy, rec.material.bumpStrength);\n            rec.normal = worldSpace(nMap, rec.tangent, rec.bitangent, rec.normal);\n        } else {\n            matColor = rec.material.color;\n        }\n        vec2 mPos = iMouse.xy - iResolution.xy/2.0;\n        vec3 lightNormal = normalize((vec3(mPos.x, 400.0, mPos.y)) - rec.intersect);\n        float shade = clamp(dot(lightNormal, rec.normal), 0.0, 1.0);\n        float specang = acos(shade);\n        float specexp = specang / (1.0-rec.material.specular);\n        float spec = exp(-specexp * specexp) * rec.material.specular;\n        vec3 result = matColor * mix(vec3(0.2), vec3(1.0), shade) + vec3(spec);\n        return vec4(result, 1.0);\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / 720.0;\n    fragColor = Trace((fragCoord-(iResolution.xy)/2.0)/ratio, iChannelResolution, iTime);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BUMPSTRENGTH 10.0\n\nstruct Material {\n\n    vec3 color;\n    bool useTexture;\n    int texID;\n    float bumpStrength;\n    float texScale;\n    float specular;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtd3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 157, 184, 333], [335, 335, 392, 412, 618]], "test": "untested"}
{"id": "DsKXDy", "name": "Year of Truchets #014", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nIf slow - turn AA off ", "tags": ["raymarching", "hexagon", "truchet", "tiles"], "likes": 33, "viewed": 379, "published": 3, "date": "1682238922", "time_retrieved": "2024-07-30T17:59:19.762164", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #014\n    04/22/2023  @byt3_m3chanic\n    \n    Taking 2D concepts from @Shane into 3D with some simple extrudes and a few exta vec3's\n\n*/\n\n\n// AA Setting 2 = on / 1 = off\n#define AA 2\n// AA Setting\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n#define SQ3         1.732\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    60.\n\nconst vec2  s = vec2(1, 1.7320508);\n// pre-cal for speed \nconst float radi = .28867514;\nconst float harc = .57735027;\nconst float scale = .415;\n\nvec3 hp,hit;\nvec2 gid, sid;\nfloat time;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\n//@iq extrude functions \nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n//@Shane grid functions\nvec4 getGrid(vec2 p) {\n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n}\n\nvec3 map(vec3 pos) {\n    vec3 res = vec3(1e5,0,0);\n\n    vec2 uv = pos.xz;\n    \n    vec4 h = getGrid(uv*scale);\n    vec2 p = h.xy;\n\n    float rnd = hash21(h.zw + vec2(.09, .04));\n    float rnd2 = hash21(h.zw + vec2(.37, 7.83)); \n    \n    rnd = floor(rnd*144.);\n    p.xy*=rot(rnd*PI/3.);\n\n    vec3 d, py;\n    vec2 p0, p1, p2;\n    float m = 1.;\n    \n    if(rnd2<.25) {\n        p0 = p - vec2(0, -harc);\n        p1 = p - vec2(0, harc);\n        p2 = p;\n        \n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = abs(p2.y);\n        \n        py.x = pos.y;\n        py.y = pos.y;\n        py.z = (pos.y-.15)-.15*cos(p0.x*PI2);\n        m = 3.;\n    }\n    else if(rnd2<.5) {\n        p0 = p;\n        p1 = rot(1.04719755)*p;\n        p2 = rot(2.09439510)*p;\n    \n        d.x = abs(p0.y);\n        d.y = abs(p1.y);\n        d.z = abs(p2.y);\n \n        py.x = (pos.y-.15)-.15*cos(p0.x*PI2);\n        py.y = (pos.y-.3)-.3*cos(p1.x*PI2);\n        py.z = pos.y;\n        m = 2.;\n    }\n    else {\n        p0 = p - vec2(-.5, -radi);\n        p1 = p - vec2(.5, -radi);\n        p2 = p - vec2(0, harc);\n        \n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = length(p2) - radi;\n        \n        py = vec3(pos.y);\n    }\n  \n    const float ht = .075;\n    float tk = .055+.045*sin(pos.z*.25);\n    tk += .055+.045*sin(pos.x*.35);\n    d=abs(d)-tk;\n    \n    float d1 = opx(d.x,py.x,ht)-.01;\n    if(d1<res.x) {\n        res =vec3(d1,m,1.);\n        hp = vec3(p0.x,pos.y,p0.y);\n    }\n\n    float d2 = opx(d.y,py.y,ht)-.01;\n    if(d2<res.x) {\n        res =vec3(d2,m,2.);\n        hp = vec3(p1.x,pos.y,p1.y);\n    }\n    \n    float d3 = opx(d.z,py.z,ht)-.01;\n    if(d3<res.x) {\n        res =vec3(d3,m,3.);\n        hp = vec3(p2.x,pos.y,p2.y);\n    }\n\n    float f = pos.y+ht;\n    if(f<res.x) {\n        res =vec3(f,20.,0.);\n        hp = pos;\n    }\n\n    return res;\n}\n\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec3 marcher(vec3 ro, vec3 rd, inout vec3 p) {\n    float d=0.,m=0.,z=0.;\n    for(int i=0;i<100;i++){\n        vec3 t = map(p);\n        d += i<32? t.x*.75:t.x;\n        m  = t.y;\n        z  = t.z;\n        p = ro + rd * d;\n        if(abs(t.x)<d*MIN_DIST||d>75.) break;\n    } \n    return vec3(d,m,z);\n}\n\nvec3 renderFull( vec2 uv )\n{\n\n    vec3 ro = vec3(11,0,8);\n    vec3 rd = normalize(vec3(uv, -1.));\n    \n    // mouse //\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*2.-1.)*PI;\n    mat2 rx = rot(-.62-x), ry = rot(-.78-y+T*.04);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n\n    vec3 ray = marcher(ro,rd,p);\n    float d = ray.x, m = ray.y, z = ray.z;\n    \n    // save globals\n    gid = sid; hit = hp;\n    \n    if(d<MAX_DIST) {\n  \n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(.5,5,-13.5);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.;\n        for( float t = .01; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 25.*h/t);\n            t += h;\n            if( shdw < MIN_DIST || t > 25. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.35);\n\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),.1),24.);\n\n        vec3 h = vec3(.4);\n        \n        if(m==1.) {\n            vec2 arc = hit.xz;\n            float angle = atan(arc.x, arc.y);\n            float d = length(arc);\n\n            float width = .15;\n            float x = (width*angle/.28867514);\n            float y = (d-(.5-width))/(4.*width);\n\n            vec2 vv = vec2(x,y);\n            vec2 f = fract(vv)-.5;\n            h = texture(iChannel0,vv).rgb*vec3(.93,.62,.25);\n         \n        }\n\n        if(m==2.) {\n            vec2 vv = vec2(hit.xz);\n            vec2 f = (vv)-.5;\n            h = texture(iChannel0,vv).rgb*vec3(.93,.62,.25);\n        }\n\n        if(m==3.) {\n            vec2 f = vec2(0),vv = vec2(0);\n\n            if(z!=3.){\n                vec2 arc = hit.xz;\n                float angle = atan(arc.x, arc.y);\n                float d = length(arc);\n\n                float width = .15;\n                float x = (width*angle/.28867514);\n                float y = (d-(.5-width))/(4.*width);\n\n                vv = vec2(x,y);\n                f = fract(vv)-.5;\n            } else {\n                vv = vec2(hit.xz);\n                f = fract(vv)-.5;\n            }\n\n            h = texture(iChannel0,vv).rgb*vec3(.93,.62,.25);\n        }\n\n        \n        if(m==20.) {\n            h = texture(iChannel1,hit.xz*.25).rgb*.35;\n        }\n        \n        C = h * diff + spec;\n\n    }\n\n    vec3 sky = mix(vec3(.62,.37,.21),vec3(.36,.69,.94),clamp((uv.y-.25)*2.5,0.,1.));\n    C = mix(C,sky, 1.-exp(-.0001*d*d*d));\n    return C;\n}\n\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\nvoid mainImage(out vec4 O, in vec2 F) { \n\n    vec3 col = vec3(.00); \n\n    float mTime = iTime;\n    time = mTime;    \n    \n    vec2 o = vec2(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    // set AA above renderFull\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(F.xy * vec2(147,131), vec2(PI * 2.))));\n    \ttime = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\n    \tvec2 p = (-R.xy + 2. * (F + o)) / R.x;\n    \tcol += renderFull(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n\n    col = pow( col, vec3(0.4545) );\n\n    O = vec4(col, 0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKXDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[704, 704, 722, 722, 765], [767, 767, 788, 788, 848], [850, 875, 921, 921, 1014], [1016, 1040, 1062, 1062, 1253], [1255, 1255, 1275, 1275, 3130], [3133, 3133, 3163, 3163, 3356], [3358, 3358, 3404, 3404, 3655], [3657, 3657, 3685, 3685, 6252], [6255, 6255, 6275, 6275, 6299]], "test": "untested"}
{"id": "cltGWn", "name": "Zellij pattern 8 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "zellige"], "likes": 2, "viewed": 258, "published": 3, "date": "1682234501", "time_retrieved": "2024-07-30T17:59:20.846266", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //fract(a+fract(a*2.+.5))\n        //fract(a+fract(a*2.+.5)/2.)\n        //fract(a+fract(a*2.)/2.)\n        //fract(a-fract(a*4.)/2.)\n        //fract(a+fract(a))\n        //fract(a+fract(a/4.))\n        //abs(fract(a)+fract(a/16.)/16.)/(1.+1./16.)\n        //mod(a*sign(1.-2.*mod(floor(a/2.),2.)),4.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.,0.5)\n        //vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\n\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv = mod(uv,1.);\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv-t2*sign(uv.y-uv.x))/1.5\n            //abs(.5*sign(t2.y-t2.x)-uv-t2*sign(uv.y-uv.x))/1.5\n        ;\n        \n        //WOW!\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n        \n        b =\n            uv.y<uv.x\n            //uv.y<uv.x && t2.y<t2.x\n        ;\n        //uv += binary_digit(k,2)/2.;\n        if(b)\n            uv = uv.yx\n            //uv.x -= .5\n            //uv.y += .5\n        ;\n        t2 =\n            triangle_wave(uv-.5*sign(uv.x-uv.y)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        col.x =\n            max(sign(uv.x),col.x)\n            //max(sign(uv.x),1.-col.x)\n            //abs(sign(uv.x)-col.x)/2.\n        ;\n        //col = vec3(col.zx,abs(uv.x*sign(t2.x-t2.y)-uv.y));\n        \n        //awesome kaleidoscope effect!\n        //if(t2.y>t2.x) {t2 = t2.yx; uv=uv.yx-iTime/8.;}\n        \n        //if(t2.x>t2.y)\n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n        //if(uv.x<uv.y) uv.x += .5;\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod2(float a, float b){\n    return b*mod(floor(a),b);\n}\n\nfloat sqmod(float a, float b){\n    float m1 = mod(floor(a),b);\n    return floor(m1*m1/b);\n}\n\nfloat mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+mod(a/2.,3.)*2.-mod(a/2.,5.)*2.,b)\n        //floor(mod(floor(a+floor(a)/8.),b))\n    ;\n}\n\n\nfloat fmod(float a, float b){\n    //a += (mod(floor(a)/2.,5.)-mod(floor(a)/2.,3.))*2.;\n    \n    //a += mod(-a/2.,2.)*mod(b/2.,2.);\n    //a -= fmod2(a/6.,6.);\n    //a += fmod2(a*b/8.,8.)/8.;\n    \n    //a += floor(a/2.);\n\n    /*\n    for(int i = 0; i < 3; i++){\n        a += floor(a/4.);\n    }\n    */\n    //a = a/2. + floor(a/b)/b*8.;\n    /*\n    for(float a2 = 64.*2.; a2 < 128.*2.; a2 *= 2.){\n        a += mod(floor(a/a2),2.)+mod(floor(a/a2/2.),3.)+mod(floor(a/a2/4.),4.);\n        a /= 1. + mod(floor(a),2.);\n    }\n    */\n    //a -= floor(a*pow(2.,b)/2./128.);\n    //a += pow(2.,mod(floor(a/8.),8.));\n    //a = (a/2. + pow(2.,mod(floor(a/2.),3.)))/2.;\n    return\n        mod1(floor(a),b)\n        //mod(floor(a/2.)+2.,b)\n        //mod(floor(mod(floor(a/8.)+floor(a/4.),b)),4.)\n        //floor(abs(mod(floor(a),b*b))/b)\n        //mod(floor(a/pow(2.,mod(floor(a/b),2.))),b)\n        //mod(floor(floor(floor(a)*b)/4.),b)\n        //abs(b-mod(floor(a/b),b*2.))\n        //floor(mod(floor(a),b)*mod(floor(a+b),b*2.)/b)\n        \n        //mod(mod(floor(a)*floor(a)+floor(a)*2.,(b)*2.+floor(a)*b),b)\n        //mod(mod(floor(-a/4.),b*2.),8.)\n        //mod(mod(floor(a),floor(a/b)+b),b)\n        //mod(mod(floor(a/2.+4.),floor(a/8.+4.)),b)\n        //floor(mod(floor(a),b)-mod(floor(a),b/2.))\n        //mod(floor(a+mod(floor(a/8.*b),b)),b)\n        //min(mod(floor(a*b/4.),b),mod(floor(a/b*2.),b))\n        //mod(floor(a+floor(pow((1.5),b))),b)\n        //mod(mod(floor(a),b)*(mod(floor(a/b),b)),b)\n        //mod(floor(a/pow(floor(1.+mod(a/2.,2.)),mod(floor(a/4.),2.))),b)\n        //mod(mod(floor(a),b)*(mod(floor(a/b),b)),b)\n        //floor(sqrt(mod(floor(a*2./b)*floor(a*8./b/b),b*b)))\n        //mod(floor(a*sign(1.-2.*mod(floor(a/8.),2.))),b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    return (1.+fmod(time/2.,2.))*(1.+fmod(time/3.,2.))*(1.+fmod(time/5.,2.))*(1.+fmod(time/7.,2.));\n}\n\nfloat fract1(float a){\n    return\n        //sqrt(fract(a))\n        //fract(a)*fract(a)\n        abs(fract(a)+.25)/1.25\n        //fract(a/(1.+fmod(a*8.,2.))/2.)\n        //fract(a+fract(a*2.)/2.)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.*pow(2.,fmod(1.+time/2./8.,2.)),\n  s2 = 8.,\n  m0 = pow(2.,fmod(time/s1,2.)),\n  t = time/m0/2.,\n  m1 = fmod(t,s1);\n  t =\n      s1*pow(2.,fmod(t*4.+m1,2.))*t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.))\n      //s1*pow(2.,fmod(t*4.,2.))*t/(1.+fmod(floor(t),2.))\n  ;\n  \n  /*\n  for(int i = 0; i < 3; i++){\n      t += mod(floor(t),2.)/2.;\n  }\n  */\n  //t += floor(t/m0/2.);\n  float\n  m3 =\n      floor(fmod(time*m0*s1,s1)/2.)\n      //floor(fmod(time*m0*s1,s1)/(2.+m0))\n  ;\n  float m2 =\n      1. + fmod(t,s1/2.);\n  ;\n  float a=\n      128.*pow((1.-sqrt(fract1(t)/2.))/2.,2.)\n      //pow(2.,2.-log(fract(t)))\n  ;\n  float nb =\n      time*pow(2.,(m3+m2-m1)/5.+8.)\n      //pow(2.,mod(floor(t/8.),1.+m3+m2+m1)/5.+8.)\n  ;\n  return\n      abs(.5-1.*vec2(fract1(nb*.998),fract1(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 410], [412, 412, 439, 439, 624], [627, 627, 660, 660, 694], [696, 696, 753, 753, 2175]], "test": "untested"}
{"id": "DttGWn", "name": "highlight points", "author": "liuming", "description": "highlight points while mouse is moving", "tags": ["mouse", "circle", "points", "highlight"], "likes": 2, "viewed": 104, "published": 3, "date": "1682233466", "time_retrieved": "2024-07-30T17:59:21.853573", "image_code": "// draw circle matrix\n\nconst float num = 30.0;\nconst vec4 circleColor = vec4(0.5, 0.4, 0.8, 1.0);\nconst vec4 hlColor = vec4(1.0, 0.2, 0.2, 1.0);\nconst vec4 scanColor = vec4(1.0, 0.6, 0.7, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;  // transform to center & scale aspect\n    vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n\n    // grid pos\n    vec2 pos = floor(uv * num);\n\n    // circle\n    vec2 center = (pos + 0.5) / num;\n    float r = 1.0 / num / 2.0 / 2.0; \n    r *= mix(.9, 1.2, sin(iTime));\n\n    // AA\n    float d = r - length(uv - center);\n    float anti = fwidth(d);\n    float alpha = smoothstep(-anti, anti, d);\n    fragColor = circleColor * alpha;\n    \n    // scan wave\n    float r_scan[] = float[](.1,.3,.5,.7,.9);\n    float d_scanAll = -1.0;\n    float gap = .1;\n    for(int i = 0;i<r_scan.length();i++){\n        float d_scanOuter = (r_scan[i] + gap - length(uv));\n        d_scanOuter += fract(iTime) * gap * 2.0; // cycle\n        float d_scan = min(d,min(d_scanOuter,-d_scanOuter + gap));\n        d_scanAll = max(d_scanAll,d_scan);\n    }\n    if(d_scanAll >= .0){\n        fragColor = scanColor * alpha;\n    }\n    \n    // mouse highlight\n    float hl_r = 0.2;\n    float d_mouse = hl_r - length(uv - mouse);\n    float dis_hl = min(d,d_mouse);\n    if(dis_hl >= .0){\n        fragColor = hlColor * alpha;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mlc3Wr", "name": "Ivy Fractal", "author": "jerhadf", "description": "Visualization of ivy growing, made with ChatGPT", "tags": ["fractal", "ai", "ivy"], "likes": 4, "viewed": 220, "published": 3, "date": "1682217576", "time_retrieved": "2024-07-30T17:59:22.752170", "image_code": "// Author: paperu, modified by ChatGPT\n// Title: Ivy Fractal Visualization\n\nfloat t;\n#define T 6.283185307\n#define P T*.5\n\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n#define orientedVec2(a) vec2(cos((a)),sin((a)))\n\nfloat petalDcp(in vec2 uv, in float w)\n{\n    uv.x = abs(uv.x) + .25 + .25*w;\n    return length(uv) - .5;\n}\n\nfloat petal(in vec3 p, in float m)\n{\n    float tt = mod(t, P);\n\n    float ouv = m - .015;\n    float w = m;\n    float a = m;\n    const float b = .5;\n    p.y -= .45;\n    p.z -= b*1.;\n    p.zy *= rot(ouv*2.);\n    float pDcp = petalDcp(p.xy, w);\n    p.x = abs(p.x);\n    p.xz *= rot(-.25);\n    float c1 = length(p.yz) - b;\n    return max(max(pDcp, abs(c1) - .01), p.z);\n}\n\nvec2 repRot(in vec2 p, in float aIt)\n{\n    return p*rot(-(T/aIt)*floor((atan(p.x, p.y)/T + .5)*aIt) - P - T/(aIt*2.));\n}\n\nfloat flower(in vec3 p, in float aIt, in float m)\n{\n    p.xy = repRot(p.xy, aIt);\n    return petal(p, m);\n}\n\nint m;\nfloat df(in vec3 pp) {\n    pp.y = -pp.y;\n    pp.xz *= rot(1.016), pp.xy *= rot(-0.640);\n\n    float dd = 10e9, ee = 10e9;\n    vec3 p = pp;\n\n    const float fsz = .25;\n    const vec2 n = orientedVec2(P*.125);\n\n    bool b = false;\n    for(float g = 0.; g < 3.; g++)\n    {\n        p = (b = !b) ? p.xzy : p.zxy;\n        float r = length(p.xy);\n        vec3 pp = vec3(log(r) - t*(.1+((g+1.)*.051)), atan(p.x, p.y), p.z/r);\n        float e = dot(pp.xy, n), f = dot(pp.xy, vec2(n.y,-n.x));\n        {float k = 1.2021; e = mod(e, k) - k*.5;}\n        float l = .65; f += 1.3; float i = mod(floor(f/l) + g, 3.); f = mod(f, l) - l*.5;\n        float d = (length(vec2(e, pp.z)) - 0.015/r)*r;\n        bool j = i == 0.;\n        dd = opSmoothUnion(dd, d, .1);\n       \n        float ff = flower(vec3(e, f, pp.z + .06)/fsz, smoothstep(-1., 1., r*r)*(j ? 5. : 2.), smoothstep(1., -0., r*r))*fsz*r;\n        ee = min(ee, ff);\n        if(ee == ff) m = j ? 1 : 0;\n    }\n\n    float ff = min(dd, ee);\n    if(ff == dd) m = 0;\n    return ff*.8;\n}\n\n#define MAX_D 30.\n#define MIN_D 0.\n#define LIM .0002\n#define MAX_IT 500\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,LIM); return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d); }\n\nstruct rmRes { vec3 p; int i; bool h; };\nrmRes rm(in vec3 c, in vec3 r)\n{\n    rmRes s = rmRes(c + r*MIN_D, 0, false);\n    float d;\n    for(s.i = 0; s.i < MAX_IT; s.i++) {\n        d = df(s.p);\n        if(d < LIM) { s.h = true; break; }\n        if(distance(c,s.p) > MAX_D) break;\n        s.p += d*r;\n    }\n    return s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = (fragCoord.xy - iResolution.xy*.5)/iResolution.x;\n    t = iTime;\n    \n    vec3 c = vec3(0.,0.,-10.), r = normalize(vec3(st,1.));\n\n    rmRes res = rm(c,r);\n    \n    // sky psychedelic background \n    vec3 sky = mix(vec3(0.1, 0.0, 0.2), vec3(0.0, 0.1, 0.3), (sin(st.y * 3.0 + iTime * 0.5) + 1.0) * 0.5);\n    vec3 color = sky;\n    \n    if(res.h)\n    {\n        vec3 n = normal(res.p);\n        const vec3 ld = normalize(vec3(0.,1.,-.1));\n        float d = max(0., dot(n, ld));\n        float s = pow(max(0., dot(r, reflect(ld, n))), 1.);\n        // colors for ivy dissapation \n        color = mix(vec3(0.0, 0.6, 0.0) * (1.0 - smoothstep(0.7, 1.0, res.p.y)) * (1.0 + sin(iTime * 2.0 + res.p.y * 10.0) * 0.5), vec3(0.0, 1.0, 0.0) * (1.0 + cos(iTime * 1.5 + res.p.y * 5.0) * 0.5), d);\n        color *= m == 1 ? vec3(0.905,0.170,0.292) :vec3(0.885,0.882,0.945);\n        color = mix(color, sky, smoothstep(20., 25., distance(res.p, c)));\n        color = mix(color, sky, smoothstep(0.5, 3., dot(st,st)*10.));\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlc3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 145, 145, 190], [192, 192, 244, 244, 343], [394, 394, 434, 434, 500], [502, 502, 538, 538, 868], [870, 870, 908, 908, 990], [992, 992, 1043, 1043, 1099], [1108, 1108, 1130, 1130, 2125], [2199, 2199, 2223, 2223, 2336], [2379, 2379, 2411, 2411, 2657], [2659, 2659, 2714, 2714, 3768]], "test": "untested"}
{"id": "dlc3Wr", "name": "Flower mosaic 2", "author": "jarble", "description": "A flower mosaic pattern.", "tags": ["fractal", "flower", "mosaic", "carpet", "rug"], "likes": 2, "viewed": 173, "published": 3, "date": "1682217555", "time_retrieved": "2024-07-30T17:59:23.571978", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .25;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv = mod(uv,1.);\n    vec2 uv1 = uv;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv+t2*sign(uv.y-uv.x))/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv-.5*sign(uv.x-uv.y)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        col.x =\n            max(sign(-uv.x),col.x)\n            //abs(sign(uv.x)-col.x)/2.\n        ;\n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a += floor(a)/b*8.;\n    return mod(floor(a),b);\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.,\n  s2 = 8.,\n  t = time,\n  m1 =\n      fmod(t/2.,s2)\n  ;\n  for(int i = 0; i < 3; i++){\n      t += floor(t/8.);\n      t = t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  }\n  float\n  m4 =\n      fmod(t*s1,s1)\n  ,\n  m3 =\n      fmod((t+m4)*s1,s1)\n  ;\n  t *=\n      s1*s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1/2.);\n  ;\n  float a=\n      64.*pow((1.-sqrt(fract(t/s1)/5.))/2.,2.)\n  ;\n  float nb = time*pow(2.,(m3+m2-m1)/5.+8.);\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlc3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1032]], "test": "untested"}
{"id": "mtc3Wr", "name": "Sinusoidal Wave Noise", "author": "Tech_", "description": "A type of noise based on sinusoidal interpolation. Also ensures an \"up-and-down\" curve motion.", "tags": ["noise"], "likes": 0, "viewed": 141, "published": 3, "date": "1682215304", "time_retrieved": "2024-07-30T17:59:24.515455", "image_code": "#define rcp(x) (1.0 / (x))\n#define mod2(x) mod(x, 2.0)\n\nconst float PI     = 3.14159265359;\nconst float INV_PI = rcp(PI);\n\nfloat Hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat RandCos(float x)\n{\n    float gridID = floor(x / PI);\n\n    return mix(\n        Hash11( gridID        * 4e1) - mod2(gridID      ),\n        Hash11((gridID + 1.0) * 4e1) - mod2(gridID + 1.0),\n        0.5 - 0.5 * cos(PI * fract(x * INV_PI))\n    );\n}\n\nfloat RandSin(float x)\n{\n    return RandCos(x - PI * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = fragCoord / iResolution.xy;\n    float x  = uv.x * 1.0e2;\n    \n    vec3 color;\n\n    if (uv.y < 0.5) color += RandCos(x);\n    else            color += cos(x);\n    \n    fragColor = vec4(color * 0.5 + 0.5, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtc3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 146, 146, 231], [233, 233, 257, 257, 483], [485, 485, 509, 509, 545], [547, 547, 604, 604, 829]], "test": "untested"}
{"id": "mt33Wn", "name": "Magic Keyboard", "author": "Rex109", "description": "Wow, so magic...", "tags": ["raymarching", "magic", "keyboard", "push", "buttons"], "likes": 4, "viewed": 99, "published": 3, "date": "1682211821", "time_retrieved": "2024-07-30T17:59:25.422031", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdButton(vec3 p)\n{\n    float base = sdBox(p, vec3(.5));\n    \n    vec3 cp1 = p - vec3(.0,.0,1.3);\n    cp1.yz *= Rot(PI/5.);\n    float cutout1 = sdBox(cp1, vec3(.5,1.0,1.0));\n    \n    vec3 cp2 = p - vec3(-1.35,.0,.0);\n    cp2.xy *= Rot(PI/10.);\n    float cutout2 = sdBox(cp2, vec3(1.0));\n    \n    vec3 cp3 = p - vec3(1.35,.0,.0);\n    cp3.xy *= Rot(-PI/10.);\n    float cutout3 = sdBox(cp3, vec3(1.0));\n    \n    vec3 cp4 = p - vec3(.0,2.0,.0);\n    cp4.xy *= Rot(PI/2.);\n    cp4.yz *= Rot(PI/2.);\n    float cutout4 = sdCylinder(cp4, 1.0, 2.);\n    \n    return max(max(max(max(base, -cutout1), -cutout2), -cutout3), -cutout4) * .5;\n}\n\nfloat Hash21(vec2 p)\n{\n    p = fract(p*vec2(422.53, 321.13));\n    p += dot(p, p+2003.123);\n    return fract(p.x*p.y);\n}\n\nfloat GetDist(vec3 p) {\n    p.x += T;\n    p.z -= T;\n    \n    vec3 P = p;\n    vec2 id = floor(P.xz);\n    P.xz = fract(p.xz)-.5;\n    \n    float n = Hash21(id)*.5+.5;\n    \n    if(n > .5) P.y += (cos((T+n*5.)*5.0)*.5+.5)*.35;\n    \n    float d = sdButton(P);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = vec2(0.47,0.3);\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0,0), 1.);\n    vec3 col = vec3(0.188,0.173,0.153);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        col *= vec3(0.620,0.553,0.439);\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt33Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 166, 166, 228], [230, 230, 259, 259, 340], [342, 342, 388, 388, 495], [496, 496, 520, 520, 1128], [1130, 1130, 1152, 1152, 1249], [1251, 1251, 1274, 1274, 1525], [1527, 1527, 1561, 1561, 1772], [1774, 1774, 1798, 1798, 1952], [1954, 1954, 2004, 2004, 2189], [2191, 2191, 2248, 2248, 2892]], "test": "untested"}
{"id": "mt3GWr", "name": "KalleidoEllo BMove", "author": "elloskelling", "description": "Kaleidoscope fractal tunnel. Use mouse to look around.", "tags": ["fractal"], "likes": 0, "viewed": 209, "published": 3, "date": "1682208656", "time_retrieved": "2024-07-30T17:59:26.229871", "image_code": "// from https://www.shadertoy.com/view/XtcXWM\n\n#define BEATMOVE 1\n\nfloat time() { return iTime; }\nvec2 resolution() { return iResolution.xy; }\n\nfloat hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\nfloat de(vec3 p) {\n\tvec3 op = p;\n\tp = fract(p + 0.5) - 0.5;\n\tp.xz *= rotate(3.14159);\n\tconst int it = 7;\n\tfor(int i = 0; i < it; i++) {\n\t\tp = abs(p);\n\t\tp.xz *= rotate(-0.1 + 0.1*sin(time()));\n\t\tp.xy *= rotate(0.3);\n\t\tp.yz *= rotate(0.0 + 0.2*cos(0.45*time()));\n\t\tp = 2.0*p - 1.0;\n\t}\n    \n    float c = length(op.xz - vec2(0, 0.1*time())) - 0.08;\n\t\n\treturn max(-c, (length(max(abs(p) - 1.3 + texture(iChannel0, vec2(0)).r, 0.0)))*exp2(-float(it)));\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001*t || t >= mx) break;\n\t\tt += d;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005;\n\tfor(int i= 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d);\n\t\ts += s/(float(i) + 1.0);\n\t}\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(1);\n\t\n\tfloat t = trace(ro, rd, 10.0);\n    if(t < 10.0) {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n        vec3 ref = normalize(reflect(rd, nor));\n\n        float occ = ao(pos, nor);\n        float dom = smoothstep(0.0, 0.3, trace(pos + nor*0.001, ref, 0.3));\n\n        col = 0.1*vec3(occ);\n        col += clamp(1.0 + dot(rd, nor), 0.0, 1.0)*mix(vec3(1), vec3(1.0, 0.3, 0.3), 1.0 - dom);\n\t\tcol *= vec3(7.0*abs(cos(20.0*pos.x)), 2.3*abs(sin(10.0*pos.z)), 3.0 + t);\t\n    }\n    \n    col = mix(col, vec3(10), 1.0 - exp(-0.16*t));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (-resolution() + 2.0*fragCoord.xy)/resolution().y;\n  \n\tfloat atime = 0.1*time();\n\tvec3 ro = vec3(0.0, 0.0, atime);    \n    vec3 la = vec3(vec2(0), atime + 1.0);\n    \n\tvec3 ww = normalize(la-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n    mat3 ca = mat3(uu, vv, ww);\n\tvec3 rd = normalize(ca*vec3(uv, 1.97));\n\t\n\tvec3 col = render(ro, rd);\n\t\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\tfragColor = vec4(col*0.9, 1);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3GWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 81, 81, 97], [98, 98, 117, 117, 142], [144, 144, 165, 165, 204], [206, 206, 228, 228, 297], [299, 299, 317, 317, 748], [750, 750, 791, 791, 928], [930, 930, 951, 951, 1121], [1315, 1315, 1346, 1346, 1921], [1923, 1923, 1980, 1980, 2474]], "test": "untested"}
{"id": "mlc3Dn", "name": "BathroomFloor BMove", "author": "elloskelling", "description": "Overlapping grids of squares, spinning at different rates", "tags": ["sound", "beat"], "likes": 0, "viewed": 148, "published": 3, "date": "1682208490", "time_retrieved": "2024-07-30T17:59:26.992831", "image_code": "float square(vec2 p, float size)\n{\n    p /= size;\n    vec2 q = mod(p, vec2(1.0));\n    if (q.x < 0.5 && q.y < 0.5) {\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float size = 0.1;\n    float size2 = 0.11;\n    \n    float RV = 1.0;  // radians per second\n    float RV2 = 1.0+0.1*sin(iTime*0.05); // radians per second for second grid\n    \n    float beatThreshold = 0.5;\n    float pulseAmount = 1.75;\n    float pulseTime = 0.1;\n    float pulseWidth = 0.1;\n    float angle = iTime * RV;\n    float angle2 = iTime * RV2;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    mat2 rot2 = mat2(cos(angle2), -sin(angle2), sin(angle2), cos(angle2));\n    vec3 color = vec3(0.0);\n    vec2 q = vec2(p.x, p.y);\n    vec2 q2 = vec2(p.x+0.1*cos(iTime*0.1), p.y+0.1*sin(iTime*0.1));\n    \n    q = rot * q;\n    q2 = rot2 * q2;\n    q = mod(q, vec2(size, size));\n    q2 = mod(q2, vec2(size2, size2));\n\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\n    float beat = 0.25*freqs[0]*freqs[0]\n                +0.25*freqs[1]*freqs[1]\n                +0.25*freqs[2]*freqs[2]\n                +0.25*freqs[3]*freqs[3];\n    beat = sqrt(beat);\n    \n    float highs = sqrt(0.5*(freqs[4]*freqs[4]+freqs[5]*freqs[5]));\n    \n    size *= mix(1.2, pulseAmount, beat);\n    size2 *= mix(1.1, pulseAmount, highs);\n\n    if (square(q, size) > 0.5) {\n        color = vec3(0.6, 0.6, 0.6);\n    }\n    \n    if (square(q2, size2) > 0.5) {\n        if (square(q, size) > 0.5) {\n            color = vec3(1.0);\n        } else {\n            color = vec3(0.6, 0.6, 0.6);\n        }\n    }\n    fragColor = vec4(color+beat/2.5, 1.0);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlc3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 159], [161, 161, 216, 216, 2028]], "test": "untested"}
{"id": "ddVSDd", "name": "Year of Truchets #013", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nThanks @Shane - as this is mostly his skills here!", "tags": ["2d", "animation", "hexagon", "truchet", "tiles"], "likes": 24, "viewed": 263, "published": 3, "date": "1682173622", "time_retrieved": "2024-07-30T17:59:27.995152", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #013\n    04/22/2023  @byt3_m3chanic \n    \n    Getting some schooling after my first woven truchet from @Shane\n    who has some amazing examples and shaders. \n    \n    https://www.shadertoy.com/view/MtlBDs\n    \n    https://www.shadertoy.com/view/3dSBzt\n    \n    https://www.shadertoy.com/view/NlKfzV\n    \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n\n#define PI         3.14159265\n#define PI2        6.28318530\n#define SQ3        1.732\n\nconst vec2 s = vec2(1, 1.7320508);\n\nconst float scale = 5.;\nconst float radi = .28867514;\nconst float harc = .57735027;\nconst float narc = .95494262;\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(27.609, 57.583)))*43758.5453); }\nvec3 hue(float t) { return .45+.45*cos(PI2*t*(vec3(.12,.51,.92)+vec3(.88,.97,.85))); }\n\n//@Shane grid functions\nvec4 getGrid(vec2 p) {\n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n}\n\nvec3 segment(vec3 col, float d, float px, vec3 cx) {\n    col=mix(col,col*.25,smoothstep(.075+px,-px,d-.025));\n    col=mix(col,vec3(.0),smoothstep(px,-px,d-.025));\n    col=mix(col,cx,smoothstep(px,-px,d));\n    return col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 F )\n{\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float px = fwidth(uv.x)*PI2;\n    \n    uv+=T*vec2(.01,.03);\n    \n    vec4 h = getGrid(uv*scale);\n    vec2 p = h.xy;\n\n    float rnd = hash21(h.zw + vec2(.09, .04));\n    float rnd2 = hash21(h.zw + vec2(.37, 7.83)); \n    \n    rnd = floor(rnd*144.);\n    p.xy*=rot(rnd*PI/3.);\n    \n    float dir = mod(rnd, 2.)*2. - 1.;\n    float th = .15+.1*sin(uv.x*3.5+T);\n    float speed = (T*1.)*dir;\n    \n    vec3 d,a3;\n\n    if(rnd2<.25){\n        vec2 p0 = p - vec2(0, -harc);\n        vec2 p1 = p - vec2(0, harc);\n        vec2 p2 = p;\n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = abs(p2.y);\n        \n        a3.x = atan(p0.x, p0.y);\n        a3.y = atan(p1.x, p1.y);\n        a3.z = p2.x;\n\n        a3 = fract(a3*vec3(6./PI2, 6./PI2,3.) + vec3(-1, 1, 1)*speed - vec3(0, 0, .5)) - .5;\n    }\n    \n    else if(rnd2<.5){\n        vec2 p0 = p;\n        vec2 p1 = rot(PI/3.)*p;\n        vec2 p2 = rot(2.*PI/3.)*p;\n        d.x = abs(p0.y);\n        d.y = abs(p1.y);\n        d.z = abs(p2.y);\n        \n        a3.x = p0.x;\n        a3.y = p1.x;\n        a3.z = p2.x;\n        \n        a3 = fract(a3*3. + vec3(1, -1, 1)*speed - .5) - .5;\n    }\n    else {\n    \n        vec2 p0 = p - vec2(-.5, -radi);\n        vec2 p1 = p - vec2(.5, -radi);\n        vec2 p2 = p - vec2(0, harc);\n        d.x = length(p0) - radi;\n        d.y = length(p1) - radi;\n        d.z = length(p2) - radi;\n        \n        a3.x = atan(p0.x, p0.y);\n        a3.y = atan(p1.x, p1.y);\n        a3.z = atan(p2.x, p2.y);\n\n        a3 = fract(a3*6./PI2 + speed) - .5;\n    }\n    \n    d = abs(d) - th;\n    a3 = max(d+.1, (abs(a3)*2. - .5)/1.); \n\n\n    vec3 ch = hue((uv.y+125.)*.235);\n    float zz = sin((uv.x+uv.y)*400.)*2.-1.;\n    vec3 C = mix(vec3(.15), vec3(.0), smoothstep(px,-px,zz)*.5);\n\n    C = segment(C,d.x,px,ch);\n    C = mix(C, vec3(1), 1. - smoothstep(-px, px, a3.x));\n\n    C = segment(C,d.y,px,ch);\n    C = mix(C, vec3(1), 1. - smoothstep(-px, px, a3.y));\n\n    C = segment(C,d.z,px,ch);\n    C = mix(C, vec3(1), 1. - smoothstep(-px, px, a3.z));\n\n    // Output to screen\n    C = pow(C,vec3(.4545));\n    fragColor = vec4(C,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVSDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[748, 748, 767, 767, 812], [813, 813, 835, 835, 896], [897, 897, 916, 916, 983], [985, 1009, 1031, 1031, 1222], [1224, 1224, 1276, 1276, 1447], [1449, 1449, 1498, 1498, 3642]], "test": "untested"}
{"id": "mtd3R7", "name": "screen space ambient occlusion", "author": "mdb", "description": "test for some screen space ambient occlusion from depth buffer", "tags": ["blur", "lighting", "sampling", "ssao", "ambiantocclusion"], "likes": 15, "viewed": 700, "published": 3, "date": "1682161589", "time_retrieved": "2024-07-30T17:59:29.023402", "image_code": "//blur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = 1. / iResolution.xy;\n    vec3 col = vec3(0.);\n    float nb_accu = 0.;\n    \n    vec4 p0 = texture(iChannel0, uv);\n    \n    int n = 2;\n    for(int i=-n; i<=n; i++){\n    for(int j=-n; j<=n; j++){\n        vec2 uv2 = uv+vec2(i, j)*offset;\n        vec4 p = texture(iChannel0, uv2);\n        vec3 c = texture(iChannel1, uv2).rgb;\n        float w = smoothstep(1.0, 0.0, 10.*abs(p0.w - p.w)/p0.w)\n                *smoothstep(1.0, 0.0, length(p0.xyz - p.xyz));\n        col += c*w;\n        nb_accu += w;\n    }\n    }\n    col /= nb_accu;\n    if (p0.w > 100.) col = vec3(0.2);\n    fragColor = vec4(col, 1.);;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//rendering of the scene\n\n#define NUMBOX 15\nstruct Box{vec3 up, down;};\nBox[NUMBOX] boxs;\n\n// pseudo random numbers////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid initBoxs(){\n    seed = uint(iFrame)/400u;\n    for(int idx = 0; idx < NUMBOX - 1; idx++){\n        vec3 a = vec3(random(), random(), random());\n        vec3 b = vec3(random(), random(), random());\n        a = 2.0*a - 1.0;\n        b = 2.0*b - 1.0;\n        vec3 s = vec3(1.1);\n        a *= s; b *= s;\n        boxs[idx] = Box(max(a, b), min(a, b));\n    }\n    boxs[NUMBOX - 1] = Box(vec3(10.0, -0.95, 10.0), vec3(-10.0, -1.0, -10.0));\n}\n/////////////////////////////////////////////////////////////////////////\n\n\nvec2 box(vec3 ro, vec3 rd, Box AABB){\n        vec3 down = AABB.down;\n        vec3 up = AABB.up;\n        \n        vec3 dirfrac = 1.0 / rd;\n        float t1 = (down.x - ro.x)*dirfrac.x;\n        float t2 = (up.x - ro.x)*dirfrac.x;\n        float t3 = (down.y - ro.y)*dirfrac.y;\n        float t4 = (up.y - ro.y)*dirfrac.y;\n        float t5 = (down.z - ro.z)*dirfrac.z;\n        float t6 = (up.z - ro.z)*dirfrac.z;\n\n        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\n\nvec3 normal(vec3 pos, Box b){\n    pos -= 0.5*(b.up + b.down);\n    pos /= 0.5*abs(b.up - b.down);\n    vec3 n = vec3(0.0);\n    if(abs(pos.x)>0.995){n.x = pos.x;}\n    if(abs(pos.y)>0.995){n.y = pos.y;}\n    if(abs(pos.z)>0.995){n.z = pos.z;}\n    n = normalize(n);\n    return n;\n}\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 n){\n\n    float t = 1e3;\n    for(int i = 0; i < NUMBOX; i++){\n        Box B = boxs[i];\n        float t2 = box(ro, rd, B).x;\n        \n        if( t2 > 0.0001 && t2 < t){\n            t = t2;\n            n = normal(ro + t*rd, B);\n        }\n    }\n    if(t > 1e2) {\n        n = -rd;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initBoxs();\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    //ray\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 camPos = vec3(cos(iTime), 0.5 + 0.2*cos(iTime), sin(iTime))*2.0;\n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    //scene\n    vec3 n;\n    float t = intersect(camPos, rd, n);\n    \n    fragColor = vec4(n, t);\n}", "buffer_a_inputs": [], "buffer_b_code": "//ambient occlusion\n\nuint seed = 4u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid initRandomGenerator(vec2 uv, vec2 dim, int f){\n    seed = uint(uv.y*dim.x + uv.x) + uint(f)*uint(dim.x)*uint(dim.y);\n}\n//////////////////////////////////////////////////////////////////////////\n#define PI 3.14159265359\nvec3 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z);\n    if(dot(n, v) < 0.0) return -v;\n    return v;\n}\n\nvec3 sampleVec(vec3 n, float radius){\n    vec3 d = newDir(n);\n    float r = random();\n    d *= mix(0.001, radius, r*r);\n    return d;\n}\n\n\n/////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    initRandomGenerator(fragCoord, iResolution.xy, iFrame);\n    //camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 camPos = vec3(cos(iTime), 0.5 + 0.2*cos(iTime), sin(iTime))*2.0;\n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    \n    //ssao\n    int max_sample = 16;\n    float radius = 0.65;\n    \n    float ao = 0.;\n    float nb_sample = 0.;\n    vec4 fragData = texture(iChannel0, uv);\n    vec3 n = fragData.xyz;\n    float depth = fragData.w;\n    uv = 2. * uv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 pos = normalize(dir0 + right*uv.x + up*uv.y) * depth;\n    \n    \n    for(int i = 0; i < max_sample; i++){\n        \n        vec3 samplePos = pos + sampleVec(n, radius);\n        float depth2 = length(samplePos);\n        samplePos /= dot(samplePos, dir0);\n        vec2 uv2 = vec2(dot(right, samplePos), dot(up, samplePos));\n        uv2.x /= iResolution.x/iResolution.y;\n        uv2 = 0.5*uv2+0.5;\n        \n    \n        if(uv2.x >= 0. && uv2.x <= 1. && uv2.y >= 0. && uv2.y <= 1.){\n            float sampleDepth = texture(iChannel0, uv2).w;\n            \n            float rangeCheck = smoothstep(0.0, 1.0, radius / abs(depth - sampleDepth));\n            ao += (sampleDepth <= depth2 - 0.01 ? 1. : 0.)*rangeCheck;\n            nb_sample += 1.;\n        }\n        \n    }\n    ao /= nb_sample;\n    ao = 1. - ao;\n    \n    //out\n    fragColor = vec4(vec3(ao*0.95), 1.); \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtd3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 64, 64, 718]], "test": "untested"}
{"id": "mldGR7", "name": "Eighties Gradient Camera", "author": "iyadahmed", "description": "Python version: https://github.com/iyadahmed/EightiesGradientCam", "tags": ["camera", "effect", "artistic"], "likes": 1, "viewed": 346, "published": 3, "date": "1682156823", "time_retrieved": "2024-07-30T17:59:29.786363", "image_code": "// Smooth HSV to RGB conversion from: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Discretize coordinates\n    uv.y = floor(uv.y / 0.05) * 0.05;\n    \n    // Sample camera texture\n    vec4 col = texture(iChannel0, uv);\n    \n    // Convert to grayscale\n    // Reference: https://gist.github.com/Volcanoscar/4a9500d240497d3c0228f663593d167a#file-greyscale-frag-L20\n    float c = dot(col.rgb, vec3(0.21, 0.71, 0.07));\n    \n    // Blend between colors\n    //col.rgb = mix(vec3(1, 0, 0), vec3(0, 0, 1), c);\n    \n    // Or use grayscale as hue\n    col.rgb = hsv2rgb_smooth(vec3(c * .5, 1.0, 1.0));\n    \n    // Output\n    fragColor = col;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 110, 110, 288], [290, 290, 347, 397, 998]], "test": "untested"}
{"id": "mtdGRM", "name": "Zellij pattern 7 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "zellige"], "likes": 0, "viewed": 192, "published": 3, "date": "1682143198", "time_retrieved": "2024-07-30T17:59:30.693936", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv+t2)/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv-.5).yx\n        ;\n        uv =\n            -t2+triangle_wave(uv.yx-1.).yx\n        ;\n        col.y =\n            .5\n            //abs(sign(uv.x)-col.x)/2.\n        ;\n        col.xyz =\n            abs(col.yzx-sign(uv.x)-float(b)/2.)\n            //abs(vec3(col.zx,max(uv.y-uv.x,col.y)))\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return floor(mod(floor(-a*2.),b));\n}\n\nvec2 mainSound(int samp, float time){\n  time /= 2.;\n  float s1 =\n      8.,\n  s2 = 8.,\n  m0 = pow(2.,fmod(time/8.,3.)),\n  t = time/m0,\n  m1 = fmod(t+m0,s1);\n  t = s1*t/(1.+fmod(m1+floor(t*sign(s1/2.-m1)*2.)+floor(t/2.),2.));\n  float\n  m3 =\n      floor(fmod(time*m0*s1*sign(s1/2.-m1),s1)/2.)\n  ;\n  t /=\n      m0*4.\n  ;\n  float m2 =\n      1. + fmod(t,s1/2.);\n  ;\n  float a=\n      pow((1.-sqrt(fract(t)/5.))/5.,2.)\n  ;\n  float nb = time*pow(2.,(m3+m2-m1)/5.+9.);\n  return\n      abs(.5-vec2(fract(nb*.998+m2/2.),fract(nb+m2/2.)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdGRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1021]], "test": "untested"}
{"id": "dttGRM", "name": "QwQ", "author": "chenxianming", "description": "QwQ", "tags": ["cineshader"], "likes": 3, "viewed": 1563, "published": 3, "date": "1682140737", "time_retrieved": "2024-07-30T17:59:31.704235", "image_code": "#define PI 3.1415926\n#define showPixel 0\n\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat rasterize( vec2 p1, vec2 p2, in vec2 uv ){\n    return step( length( uv - ( p1 + p2 ) / 2. ) - distance( p1, p2) * .5, 0. );\n}\n\nfloat mExp( vec2 p1, vec2 p2, in vec2 uv ){\n    return ( uv.y - p2.y ) * ( p1.x - p2.x ) -( ( uv.x - p2.x ) * ( p1.y - p2.y ) );\n}\n\nfloat drawLine( vec2 p1, vec2 p2, in vec2 uv ){\n    \n    float p = mExp( p1, p2, uv );\n\n    return p;\n}\n\nfloat calcTriangle( vec3 pos ){\n    \n    vec2 uv = pos.xy;\n    \n    float p = drawLine( vec2( .0, .2 ), vec2( -.25, -.2 ), uv );\n\n    p = max( p, -drawLine( vec2( .0, .2 ), vec2( .25, -.2 ), uv ) );\n    \n    p = max( p, drawLine( vec2( -.25, -.2 ), vec2( .2, -.2 ), uv ) );\n    \n    uv *= 2.5;\n    \n    float t2 = drawLine( vec2( .0, .2 ), vec2( -.35, -.35 ), uv );\n    t2 = max( t2, -drawLine( vec2( .0, .2 ), vec2( .3, -.3 ), uv ) );\n    t2 = max( t2, drawLine( vec2( -.35, -.35 ), vec2( .2, -.35 ), uv ) );\n    \n    p = max( p, -t2 );\n    \n    return max( p, abs( pos.z ) - .02 );\n}\n\nfloat calcSquare( vec3 pos ){\n    vec2 uv = pos.xy;\n    \n    float p = abs( uv.x ) - .2;\n    \n    p = min( -p, -( abs( uv.y ) - .2 ) );\n    \n    p *= -1.;\n    \n    uv *= 1.5;\n    \n    float s2 = abs( uv.x ) - .2;\n    s2 = min( -s2, -( abs( uv.y ) - .2 ) );\n    s2 *= -1.;\n    \n    p = max( p, -s2 );\n    \n    return max( p, abs( pos.z ) - .02 );\n}\n\nfloat calcCross( vec3 pos ){\n    vec2 uv = pos.xy;\n    \n    uv *= rotation( PI * .25 );\n    \n    float p = drawLine( vec2( -.03, .2 ), vec2( .03, .2 ), uv );\n\n    p = max( -p, drawLine( vec2( -.03, .2 ), vec2( -.03, -.2 ), uv ) );\n    \n    p = max( p, -drawLine( vec2( .03, .2 ), vec2( .03, -.2 ), uv ) );\n    \n    p = min( -p, -drawLine( vec2( -.03, -.2 ), vec2( .03, -.2 ), uv ) );\n    \n    p *= -1.;\n    \n    uv *= rotation( PI * .5 );\n    \n    float c2 = drawLine( vec2( -.03, .2 ), vec2( .03, .2 ), uv );\n\n    c2 = max( -c2, drawLine( vec2( -.03, .2 ), vec2( -.03, -.2 ), uv ) );\n    \n    c2 = max( c2, -drawLine( vec2( .03, .2 ), vec2( .03, -.2 ), uv ) );\n    \n    c2 = min( -c2, -drawLine( vec2( -.03, -.2 ), vec2( .03, -.2 ), uv ) );\n    \n    c2 *= -1.;\n    \n    p = min( p, c2 );\n    \n    return max( p, abs( pos.z ) - .02 );\n}\n\nfloat calcCircle( vec3 pos ){\n    vec2 uv = pos.xy;\n    \n    float p = length( uv ) - .2;\n    \n    p = max( p, -( length( uv ) - .125 ) );\n    \n    return max( p, abs( pos.z ) - .02 );\n}\n\nfloat gi = 1.;\nfloat rand( in float ri ){\n    return (fract(ri * 412.531 + 0.513 ) - 0.5) + sin( ri );\n}\n\nfloat calcShape( vec3 p ){\n    float d = 5.;\n\n    vec3 cp, tp, sp, cip;\n    \n    float time = iMouse.z > .01 ? iTime * 1. : iTime;\n    \n    cp = p;\n    tp = p;\n    sp = p;\n    cip = p;\n    \n    tp.xz *= rotation( rand( 1. ) * time );\n    tp.yz *= rotation( rand( 2. ) * time * .1 );\n    tp.x += rand( 1. ) * cos( time ) * 3.;\n    tp.y += rand( 2. ) * sin( time );\n    tp.z += rand( 3. ) * sin( time );\n    \n    \n    sp.xz *= rotation( rand( 2. ) * time );\n    sp.yz *= rotation( rand( 3. ) * time * .1 );\n    sp.x += rand( 3. ) * sin( time ) * 3.;\n    sp.y += rand( 4. ) * cos( time );\n    sp.z += rand( 5. ) * sin( time );\n    \n\n    cp.xz *= rotation( rand( 3. ) * time );\n    cp.yz *= rotation( rand( 4. ) * time * .1 );\n    cp.x += rand( 7. ) * cos( time ) * 3.;\n    cp.y += rand( 8. ) * sin( time );\n    cp.z += rand( 9. ) * cos( time );\n    \n    \n    cip.xz *= rotation( rand( 4. ) * time );\n    cip.yz *= rotation( rand( 5. ) * time * .1 );\n    cip.x += rand( 10. ) * cos( time ) * 3.;\n    cip.y += rand( 11. ) * cos( time );\n    cip.z += rand( 12. ) * sin( time );\n    \n    \n    d = min( d, calcTriangle( tp ) );\n    d = min( d, calcSquare( sp ) );\n    d = min( d, calcCross( cp ) );\n    d = min( d, calcCircle( cip ) );\n    \n    return d;\n}\n\n\nvec2 repetition( inout vec2 p, vec2 size)\n{\n\n    vec2 h = size * .5;\n    vec2 cell = floor((p + h) / size);\n\n    p = mod(p + h, size) - h;\n    \n    return cell;\n}\n\nfloat calcNum1( in vec2 uv ){\n\n    float p = 0.;\n    \n    uv *= .8;\n    \n    p = drawLine( vec2( -.05, .2 ), vec2( -.05, -.2 ), uv );\n    p = max( p, -drawLine( vec2( .05, .2 ), vec2( .05, -.2 ), uv ) );\n    p = max( p, drawLine( vec2( -.05, -.2 ), vec2( .05, -.2 ), uv ) );\n    p = max( p, -drawLine( vec2( -.1, .2 ), vec2( .05, .2 ), uv ) );\n    \n    float p2 = 0.;\n    p2 = drawLine( vec2( -.1, .2 ), vec2( .05, .3 ), uv );\n    p2 = max( -p2, drawLine( vec2( .05, .2 ), vec2( .05, .3 ), uv ) );\n    p2 = min( -p2, -drawLine( vec2( -.1, .2 ), vec2( .05, .2 ), uv ) );\n    p = min( p, -p2 );\n    \n    \n    return p;\n}\n\nfloat calcNum2( in vec2 uv ){\n    float p = 0.;\n    uv.x += .1;\n    uv.y += .1;\n    uv *= .9;\n    \n    p = 0.36 * pow( uv.x, 2. ) + 0.25 * pow( uv.y, 2. ) + -0.60 * uv.x * uv.y + 0.16 * uv.x + -0.02 * uv.y + -0.02;\n    p = max( p, -( 0.25 * pow( uv.x, 2. ) + 0.16 * pow( uv.y, 2. ) + -0.40 * uv.x * uv.y + 0.08 * uv.x + -0.04 * uv.y + 0. ) );\n    \n    p = min( -p, -drawLine( vec2( -.05, .3 ), vec2( -.05, .2 ), uv ) );\n    p = min( p, -drawLine( vec2( .05, -.1 ), vec2( .15, -.1 ), uv ) ) * -1.;\n    \n    float p2 = 0.;\n    \n    p2 = drawLine( vec2( .05, -.1 ), vec2( .15, -.1 ), uv );\n    p2 = max( -p2, drawLine( vec2( -.05, -.15 ), vec2( .15, -.15 ), uv ) );\n    p2 = max( p2, -drawLine( vec2( -.05, -.15 ), vec2( -.05, -.1 ), uv ) );\n    p2 = min( -p2, -drawLine( vec2( .15, -.15 ), vec2( .15, -.1 ), uv ) );\n    \n    p = min( p, -p2 );\n    \n    return p;\n}\n\nfloat calcNum3( in vec2 uv ){\n    float p = 0.;\n    p = 0.12 * pow( uv.x, 2. ) + 0.25 * pow( uv.y, 2. ) + -0.35 * uv.x * uv.y + 0.10 * uv.x + -0.07 * uv.y + 0.;\n    uv.x += .25;\n    uv.y += .2;\n    p = max( p, -( 0.09 * pow( uv.x, 2. ) + 0.12 * pow( uv.y, 2. ) + -0.21 * uv.x * uv.y + 0.05 * uv.x + -0.04 * uv.y + 0. ) );\n    uv.x -= .25;\n    uv.y -= .2;\n    \n    p = -min( -p, -drawLine( vec2( -.2, .3 ), vec2( -.15, .2 ), uv ) );\n    \n    float p2 = 0.;\n    uv.x += .07;\n    \n    uv.y += .04;\n    \n    p2 = 0.01 * pow( uv.x, 2. ) + 0.25 * pow( uv.y, 2. ) + 0.10 * uv.x * uv.y + 0.06 * uv.x + 0.03 * uv.y + -0.01;\n    uv.x -= .05;\n    \n    p2 = max( p2, -( 0.02 * pow( uv.x, 2. ) + 0.13 * pow( uv.y, 2. ) + 0.11 * uv.x * uv.y + 0.03 * uv.x + 0.02 * uv.y + 0. ) );\n    \n    p2 = -min( -p2, -drawLine( vec2( -.22, .3 ), vec2( -.2, .2 ), uv ) );\n    \n    p2 = max( p2, drawLine( vec2( .2, .3 ), vec2( .15, .25 ), uv ) );\n    \n\n    p = min( p, p2 );\n    \n    return p;\n}\n\nfloat calcNum4( in vec2 uv ){\n    float p = 0.;\n\n    uv /= 1.5;\n\n    p = drawLine( vec2( .0, .0 ), vec2( .0, -.2 ), uv );\n    \n    p = max( p, -drawLine( vec2( .05, .3 ), vec2( .05, -.2 ), uv ) );\n    \n    \n    float p2 = 0.;\n    \n    p2 = drawLine( vec2( -.2, .0 ), vec2( .15, .0 ), uv );\n\n    p2 = max( p2, drawLine( vec2( .15, .1 ), vec2( .05, .1 ), uv ) );\n    \n    p = min( p, p2 );\n    \n    float p3 = drawLine( vec2( .0, .0 ), vec2( .0, -.2 ), uv );\n    p3 = -min( p3, drawLine( vec2( .15, .1 ), vec2( .05, .1 ), uv ) );\n    \n    p = min( p, p3 );\n    p = max( p, -drawLine( vec2( -.2, 0. ), vec2( .05, .3 ), uv ) );\n    p = max( p, drawLine( vec2( -.0, -.2 ), vec2( .05, -.2 ), uv ) );\n    p = max( p, -drawLine( vec2( .15, .1 ), vec2( .15, .0 ), uv ) );\n    \n    uv.x -= .02;\n    uv.y += .02;\n    \n    float p4 = drawLine( vec2( -.1, .1 ), vec2( .001, .2 ), uv );\n    p4 = -min( p4, -drawLine( vec2( -.05, .1 ), vec2( .0, .1 ), uv ) );\n    p4 = max( p4, -drawLine( vec2( -.0, .15 ), vec2( .0, .1 ), uv ) );\n    \n    p = max( p, -p4 );\n    \n    return p;\n}\n\nfloat calcNum5( in vec2 uv ){\n    float p = 0.;\n    \n    uv *= 1.1;\n    \n    p = 0.04 * pow( uv.x, 2. ) + 0.2025 * pow( uv.y, 2. ) + -0.18 * uv.x * uv.y + 0.017000000000000005 * uv.x + 0.05975 * uv.y + -0.0030937499999999997;\n    \n    p = max( p, -( 0.0225 * pow( uv.x, 2. ) + 0.22562500000000002 * pow( uv.y, 2. ) + -0.1425 * uv.x * uv.y + 0.00675 * uv.x + 0.052125000000000005 * uv.y + 0.00050625 ) );\n    \n    p = max( p, -drawLine( vec2( -.15, -.0 ), vec2( -.1, .05 ), uv ) );\n    \n    p = max( p, -drawLine( vec2( -.0, -.5 ), vec2( -.2, -.0 ), uv ) );\n    \n    float p2 = 0.;\n    \n    p2 = 0.03999999999999999 * pow( uv.x, 2. ) + 0.010000000000000002 * pow( uv.y, 2. ) + 0.04000000000000002 * uv.x * uv.y + 0.02600000000000001 * uv.x + -0.019000000000000003 * uv.y + -0.006974999999999997;\n    \n    p2 = max( p2, -( 0.02249999999999997 * pow( uv.x, 2. ) + 0.0006250000000000023 * pow( uv.y, 2. ) + -0.0075 * uv.x * uv.y + 0.0045000000000000005 * uv.x + -0.006749999999999999 * uv.y + -0.0015749999999999998 ) );\n    \n    p2 = max( p2, -drawLine( vec2( -.1, -.0 ), vec2( -.1, .05 ), uv ) );\n    \n    p2 = max( p2, -drawLine( vec2( .15, .0 ), vec2( .2, -.1 ), uv ) );\n    \n    // p = min( p, p2 );\n    \n    float p3 = 0.;\n    \n    p3 = drawLine( vec2( -.15, .3 ), vec2( -.15, -.0 ), uv );\n    \n    p3 = max( p3, -( drawLine( vec2( -.1, .25 ), vec2( -.1, .05 ), uv ) ) );\n    \n    p3 = max( p3, -drawLine( vec2( -.1, .05 ), vec2( -.15, -.0 ), uv ) );\n    \n    p3 = max( p3, -drawLine( vec2( -.15, .3 ), vec2( .2, .3 ), uv ) );\n    \n    p = min( p, p3 );\n    \n    float p4 = 0.;\n    \n    p4 = drawLine( vec2( -.1, .25 ), vec2( .2, .25 ), uv );\n    p4 = max( p4, -drawLine( vec2( -.15, .3 ), vec2( .2, .3 ), uv ) );\n    \n    p4 = max( p4, drawLine( vec2( -.15, .3 ), vec2( -.15, -.0 ), uv ) );\n    p4 = -min( -p4, -drawLine( vec2( .2, .25 ), vec2( .2, .3 ), uv ) );\n    \n    p = min( p, p4 );\n    \n    return p;\n}\n\nfloat calcNum6( in vec2 uv ){\n\n    float p = 0.;\n    \n    p = 0.040000000000000056 * pow( uv.x, 2. ) + 0.09000000000000002 * pow( uv.y, 2. ) + 0.12000000000000001 * uv.x * uv.y + -0.076 * uv.x + 0.014000000000000002 * uv.y + -0.008700000000000001;\n    \n    p = max( p, -( 0.06250000000000006 * pow( uv.x, 2. ) + 0.1089 * pow( uv.y, 2. ) + 0.16500000000000004 * uv.x * uv.y + -0.0758 * uv.x + -0.0002000000000000014 * uv.y + -0.002980000000000001 ) );\n    \n    p = -min( -p, -( drawLine( vec2( .15, .25 ), vec2( .1, .3 ), uv ) ) );\n    \n    p = max( p, ( drawLine( vec2( .1, .0 ), vec2( .2, .1 ), uv ) ) );\n    \n    float p2 = 0.;\n    \n    p2 = 0.2500000000000001 * pow( uv.x, 2. ) + 0.04000000000000001 * pow( uv.y, 2. ) + -0.20000000000000007 * uv.x * uv.y + -0.07200000000000002 * uv.x + -0.029 * uv.y + -0.011000000000000006;\n    \n    p2 = max( p2, -( 0.16000000000000003 * pow( uv.x, 2. ) + 0.006400000000000003 * pow( uv.y, 2. ) + -0.06399999999999997 * uv.x * uv.y + -0.03519999999999999 * uv.x + -0.012320000000000003 * uv.y + -0.0019360000000000002 ) );\n    \n    p2 = max( p2, -( drawLine( vec2( .1, .05 ), vec2( .2, .1 ), uv ) ) );\n    \n    p2 = max( p2, -( drawLine( vec2( .2, -.1 ), vec2( .2, -.3 ), uv ) ) );\n    \n    p = min( p, p2 );\n    \n    float p3 = 0.;\n    \n    p3 = 0.0009000000000000006 * pow( uv.x, 2. ) + 0.0625 * pow( uv.y, 2. ) + -0.014999999999999972 * uv.x * uv.y + 0.01643999999999999 * uv.x + 0.00820000000000001 * uv.y + -0.004783999999999998;\n    \n    p3 = -min( -p3, -( 0.052899999999999996 * pow( uv.x, 2. ) + 0.008099999999999996 * pow( uv.y, 2. ) + -0.04139999999999999 * uv.x * uv.y + -0.013888 * uv.x + 0.021296 * uv.y + -0.00064016 ) );\n    \n    p3 = max( p3, -( 0.12250000000000003 * pow( uv.x, 2. ) + 0.1764 * pow( uv.y, 2. ) + -0.294 * uv.x * uv.y + -0.0392 * uv.x + 0.07447999999999999 * uv.y + 0.002744 ) );\n    \n    p3 = -min( -p3, -( drawLine( vec2( .0, -.1 ), vec2( .2, -.3 ), uv ) ) );\n    \n    p = min( p, p3 );\n    \n    return p;\n}\n\nfloat calcNum7( in vec2 uv ){\n    float p = 0.;\n    \n    p = drawLine( vec2( -.05, .2 ), vec2( -.15, -.3 ), uv );\n    \n    p = max( p, -drawLine( vec2( .05, .2 ), vec2( -.05, -.3 ), uv ) );\n    \n    p = max( p, -drawLine( vec2( -.05, .2 ), vec2( .05, .2 ), uv ) );\n    \n    p = -min( -p, -drawLine( vec2( -.15, -.3 ), vec2( -.05, -.3 ), uv ) );\n    \n    float p2 = 0.;\n    \n    p2 = drawLine( vec2( -.2, .3 ), vec2( .05, .3 ), uv );\n    \n    p2 = -min( p2, -drawLine( vec2( -.2, .2 ), vec2( .05, .2 ), uv ) );\n    \n    p2 = max( p2, -drawLine( vec2( -.2, .2 ), vec2( -.2, .3 ), uv ) );\n    \n    p2 = -min( -p2, -drawLine( vec2( .05, .2 ), vec2( .05, .3 ), uv ) );\n    \n    p = min( p, p2 );\n    \n    return p;\n}\n\nfloat calcNum8( in vec2 uv ){\n    float p = 0.;\n    \n    uv.y *= 1.2;\n    \n    p = length( uv+vec2( 0., -.2 ) ) - .2;\n    \n    p = max( p, -( length( uv+vec2( 0., -.2 ) ) - .1 ) );\n    \n    float p2 = 0.;\n    \n    p2 = length( uv+vec2( 0., .17 ) ) - .2;\n    \n    p2 = max( p2, -( length( uv+vec2( 0., .17 ) ) - .1 ) );\n    \n    p = min( p, p2 );\n    \n    return p;\n}\n\nfloat calcNum9( in vec2 uv ){\n\n    float p = 0.;\n    \n    uv *= rotation( PI );\n    \n    p = 0.040000000000000056 * pow( uv.x, 2. ) + 0.09000000000000002 * pow( uv.y, 2. ) + 0.12000000000000001 * uv.x * uv.y + -0.076 * uv.x + 0.014000000000000002 * uv.y + -0.008700000000000001;\n    \n    p = max( p, -( 0.06250000000000006 * pow( uv.x, 2. ) + 0.1089 * pow( uv.y, 2. ) + 0.16500000000000004 * uv.x * uv.y + -0.0758 * uv.x + -0.0002000000000000014 * uv.y + -0.002980000000000001 ) );\n    \n    p = -min( -p, -( drawLine( vec2( .15, .25 ), vec2( .1, .3 ), uv ) ) );\n    \n    p = max( p, ( drawLine( vec2( .1, .0 ), vec2( .2, .1 ), uv ) ) );\n    \n    float p2 = 0.;\n    \n    p2 = 0.2500000000000001 * pow( uv.x, 2. ) + 0.04000000000000001 * pow( uv.y, 2. ) + -0.20000000000000007 * uv.x * uv.y + -0.07200000000000002 * uv.x + -0.029 * uv.y + -0.011000000000000006;\n    \n    p2 = max( p2, -( 0.16000000000000003 * pow( uv.x, 2. ) + 0.006400000000000003 * pow( uv.y, 2. ) + -0.06399999999999997 * uv.x * uv.y + -0.03519999999999999 * uv.x + -0.012320000000000003 * uv.y + -0.0019360000000000002 ) );\n    \n    p2 = max( p2, -( drawLine( vec2( .1, .05 ), vec2( .2, .1 ), uv ) ) );\n    \n    p2 = max( p2, -( drawLine( vec2( .2, -.1 ), vec2( .2, -.3 ), uv ) ) );\n    \n    p = min( p, p2 );\n    \n    float p3 = 0.;\n    \n    p3 = 0.0009000000000000006 * pow( uv.x, 2. ) + 0.0625 * pow( uv.y, 2. ) + -0.014999999999999972 * uv.x * uv.y + 0.01643999999999999 * uv.x + 0.00820000000000001 * uv.y + -0.004783999999999998;\n    \n    p3 = -min( -p3, -( 0.052899999999999996 * pow( uv.x, 2. ) + 0.008099999999999996 * pow( uv.y, 2. ) + -0.04139999999999999 * uv.x * uv.y + -0.013888 * uv.x + 0.021296 * uv.y + -0.00064016 ) );\n    \n    p3 = max( p3, -( 0.12250000000000003 * pow( uv.x, 2. ) + 0.1764 * pow( uv.y, 2. ) + -0.294 * uv.x * uv.y + -0.0392 * uv.x + 0.07447999999999999 * uv.y + 0.002744 ) );\n    \n    p3 = -min( -p3, -( drawLine( vec2( .0, -.1 ), vec2( .2, -.3 ), uv ) ) );\n    \n    p = min( p, p3 );\n    \n    return p;\n}\n\nfloat calcNum0( in vec2 uv ){\n    float p = 0.;\n    \n    uv.x *= 1.2;\n    \n    p = length( uv+vec2( 0., 0. ) ) - .3;\n    \n    p = max( p, -( length( uv+vec2( 0., 0. ) ) - .2 ) );\n    \n    uv.x /= 1.2;\n    \n    uv *= rotation( PI * -.15 );\n    \n    float p2 = abs( uv.x ) - .035;\n        \n    p2 = -min( -p2, -( abs( uv.y ) - .2 ) );\n\n    p = min( p, p2 );\n\n    return p;\n}\n\nfloat Numbers[10];\n\nvoid initNumb( vec2 p ){\n    Numbers[0] = calcNum0( p );\n    Numbers[1] = calcNum1( p );\n    Numbers[2] = calcNum2( p );\n    Numbers[3] = calcNum3( p );\n    Numbers[4] = calcNum4( p );\n    Numbers[5] = calcNum5( p );\n    Numbers[6] = calcNum6( p );\n    Numbers[7] = calcNum7( p );\n    Numbers[8] = calcNum8( p );\n    Numbers[9] = calcNum9( p );\n}\n\nfloat calcDot( vec3 pos ){\n    vec3 p = pos;\n    \n    float time = iMouse.z > .01 ? iTime * 3. : iTime;\n    \n    vec2 cell = repetition( p.xy, vec2( .05 ) );\n\n    float s = hash12( cell * 2.05 ) * 3.;\n    \n    p.x += cos( time * s ) * .008;\n    p.y += sin( time * s ) * .008;\n\n    int hh = int( iDate.w / 60. / 60.) % 100;\n    int mm = int( iDate.w / 60.) % 100;\n    \n    float px = 5.;\n    \n    initNumb( cell.xy * .05 + vec2( -1.6, 0. ) );\n    \n    px = min( px, Numbers[ int( ( int( iDate.a ) % 10 ) ) ] );\n\n    initNumb( cell.xy * .05 + vec2( -1.0, 0. ) );\n    \n    px = min( px, Numbers[ int( ( int( iDate.a / 10. ) % 6 ) ) ] );\n\n    initNumb( cell.xy * .05 + vec2( -.2, 0. ) );\n    \n    px = min( px, Numbers[ int( ( mm % 10 ) ) ] );\n\n    initNumb( cell.xy * .05 + vec2( .4, 0. ) );\n    \n    px = min( px, Numbers[ ( int( iDate.a / 10. / 60. ) % 6 ) ] );\n    \n    initNumb( cell.xy * .05 + vec2( 1.25, 0. ) );\n    \n    px = min( px, Numbers[ ( int( hh % 10 ) ) ] );\n    \n    initNumb( cell.xy * .05 + vec2( 1.8, 0. ) );\n    \n    px = min( px, Numbers[ ( int( iDate.a / 10. / 60. / 60. ) % 6 ) ] );\n    \n    if( showPixel != 0 ){\n        return max( px, abs( pos.z ) - .02 );\n    }\n    \n\n    if( distance( step( px, 0. ), p.x ) > .1 ){\n        return length( p + vec3( 0., 0., 0. ) ) - ( ( .015 - ( s * .005 ) ) ) * 1.; // ( 1. - abs( fract( iTime ) - .5 ) * 2. )\n    }\n    \n\n    return 5.;\n}\n\nfloat calcTime( vec3 p ){\n    float d = 3.;\n    \n    vec3 pos = p;\n    \n    pos.x -= .35;\n    pos.y -= .1;\n    float dott = length( pos ) - .02;\n    d = min( d, dott );\n    pos = p;\n    \n    pos.x -= .35;\n    pos.y += .1;\n    dott = length( pos ) - .02;\n    d = min( d, dott );\n    pos = p;\n    \n    pos.x += .5;\n    pos.y += .1;\n    dott = length( pos ) - .02;\n    d = min( d, dott );\n    pos = p;\n    \n    pos.x += .5;\n    pos.y -= .1;\n    dott = length( pos ) - .02;\n    d = min( d, dott );\n    pos = p;\n    \n    \n    pos.xy *= 1.7;\n    \n\n    d = min( d, calcDot( pos ) );\n\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    float d = 2.0;\n    \n    d = min( d, calcShape( p ) );\n    d = min( d, calcTime( p ) );\n\n\n    // d = min( d, opSmoothUnion( calcDot( p ), calcDotN( p ), .999999 ) );\n\n    return d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    \n    // screen size is 6m x 6m\n    vec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 2.3, 1.5);\n    vec3 rayDir = vec3(0.0, 0.0, -1.0);\n    \n    float depth = 0.0;\n    vec3 p;\n    \n    for(int i = 0; i < 128; i++) {\n        p = rayOri + rayDir * depth;\n        float dist = map(p);\n        depth += dist;\n        if (dist < 1e-6) {\n            break;\n        }\n    }\n    \n    depth = min(6.0, depth);\n    vec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n\n    \n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n    \n    if( ( map( p ) == calcTime( p ) ) ){\n        col = mix( vec3( 1. ), col, .1 );\n    }\n    \n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n    \"title\": \"My Shader 0\",\n    \"description\": \"Lorem ipsum dolor\",\n    \"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttGRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 95, 95, 194], [196, 196, 219, 219, 304], [306, 306, 328, 328, 448], [450, 450, 474, 474, 540], [542, 542, 590, 590, 673], [675, 675, 718, 718, 805], [807, 807, 854, 854, 910], [912, 912, 943, 943, 1497], [1499, 1499, 1528, 1528, 1846], [1848, 1848, 1876, 1876, 2684], [2686, 2686, 2715, 2715, 2872], [2889, 2889, 2915, 2915, 2978], [2980, 2980, 3006, 3006, 4228], [4231, 4231, 4274, 4274, 4393], [4395, 4395, 4424, 4424, 5013], [5015, 5015, 5044, 5044, 5877], [5879, 5879, 5908, 5908, 6846], [6848, 6848, 6877, 6877, 7912], [7914, 7914, 7943, 7943, 9827], [9829, 9829, 9858, 9858, 11809], [11811, 11811, 11840, 11840, 12522], [12524, 12524, 12553, 12553, 12890], [12892, 12892, 12921, 12921, 14903], [14905, 14905, 14934, 14934, 15277], [15299, 15299, 15323, 15323, 15645], [17046, 17046, 17071, 17071, 17638], [17640, 17640, 17659, 17659, 17845], [17847, 17847, 17877, 17877, 18159], [18161, 18161, 18218, 18218, 19137]], "test": "untested"}
{"id": "clt3zM", "name": "Color Study - Plate V-1b", "author": "Slals", "description": "Move the mouse to the right\n\nColor tone :\n\nBoth triangles are the same color, but the middle gradient make the color tone confusing", "tags": ["interactionofcolor"], "likes": 1, "viewed": 157, "published": 3, "date": "1682116309", "time_retrieved": "2024-07-30T17:59:32.478165", "image_code": "float rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - step(size, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(1.0);\n    \n    float MX = iMouse.x / iResolution.x;\n    float MY = iMouse.y / iResolution.y;\n    \n    vec2 s = vec2(0.15, 1.0);\n    \n    float rect = fill(rectSDF(uv, s), 1.0);\n    float mask = fill(rectSDF((uv + vec2(0.06, 0.0)) - uv.y * 0.12, s), 1.0);\n    \n    color *= rect * vec3((ceil(uv.y * 17.0) / 17.0) - 0.1);\n    color = mix(color, rect * vec3(0.4), rect - (mask * (1.0 - MX)));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clt3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [111, 111, 144, 144, 178], [180, 180, 237, 287, 781]], "test": "untested"}
{"id": "dlc3R7", "name": "N-Convex Dithering", "author": "matejloub", "description": "N-Convex Dithering (via Greedy Selection) is a lesser-known dithering algorithm that is compatible with arbitrary palettes. The output pixel colour is randomly selected based on a set of weighted candidates using Inverse Distance Weighting.", "tags": ["threshold", "dither", "palette", "ordered"], "likes": 2, "viewed": 175, "published": 3, "date": "1682107692", "time_retrieved": "2024-07-30T17:59:33.347840", "image_code": "// Algorithm configuration. Feel free to tinker with some of the values to explore the algorithm!\n#define N 4                    // Number of candidates per fragment\n#define DISTANCE_EXPONENT 1.0  // The exponent term of the IDW equation\n#define PALETTE_SIZE 16        // Number of colours in the palette\n#define PIXEL_SIZE 2.0         // Size of pixels in the shader output\n#define ENABLE_SORT            // Choose whether to enable the sorting procedure\n\n#define INFINITY 3.4e38        // 'Infinity'\n\n// Helper macro to convert an RGB hex code to a vec3\n#define RGB8(h) (vec3(h >> 16 & 0xFF, h >> 8 & 0xFF, h & 0xFF) / 255.0) \n\n    /*\n    N-Convex Dithering via Greedy Selection[1]. This algorithm attempts to find a set of N candidates\n    which form a convex hull around the input colour in colour space. Each candidate is given a weight\n    equal to the inverse of its distance to the input colour,  la Inverse Distance Weighting (IDW)[2].\n    The output colour is chosen by randomly (or psuedo-randomly) selecting from the set of available\n    candidates with respect to their weights. In this shader we use take values from a threshold matrix\n    to sample from the list of candidates. A sorting procedure is used to minimise artifacts from the\n    randomisation process. For more information, as well as a more sophisticated variant of this\n    algorithm, please see [3]!\n    \n    [1] K. Lemstrom, P. Franti. \"N-Candidate methods for location invariant dithering of color images\". \n        http://cs.uef.fi/sipu/pub/N-candidateDithering-IVC.pdf\n    [2] https://en.wikipedia.org/wiki/Inverse_distance_weighting\n    [3] https://www.shadertoy.com/view/dlcGzN\n    */\n\n// Using the Commodore 64's palette. Feel free to input your own!\nconst vec3 palette[PALETTE_SIZE] = vec3[](\n    RGB8(0x000000), RGB8(0x626262), RGB8(0x898989), RGB8(0xadadad),\n    RGB8(0xffffff), RGB8(0x9f4e44), RGB8(0xcb7e75), RGB8(0x6d5412),\n    RGB8(0xa1683c), RGB8(0xc9d487), RGB8(0x9ae29b), RGB8(0x5cab5e),\n    RGB8(0x6abfc6), RGB8(0x887ecb), RGB8(0x50459b), RGB8(0xa057a3));\n\n// Convert a gamma-encoded sRGB value to linear RGB\n// https://en.wikipedia.org/wiki/SRGB#From_sRGB_to_CIE_XYZ\nvec3 sRGBtoLinear(vec3 colour)\n{\n    vec3 linear;\n    linear.r = colour.r > 0.04045 ? pow((colour.r + 0.055) / 1.055, 2.4) : colour.r / 12.92;\n\tlinear.g = colour.g > 0.04045 ? pow((colour.g + 0.055) / 1.055, 2.4) : colour.g / 12.92;\n\tlinear.b = colour.b > 0.04045 ? pow((colour.b + 0.055) / 1.055, 2.4) : colour.b / 12.92;\n    return linear;\n}\n\n// Get the luminance value of a given colour\nfloat getLuminance(vec3 colour)\n{\n    return colour.r * 0.299 + colour.g * 0.587 + colour.b * 0.114;\n}\n\n// Sample the value in the threshold matrix for the current pixel\nfloat sampleThreshold(vec2 coord)\n{\n    // Sample the centre of the texel\n    ivec2 pixel = ivec2(coord / PIXEL_SIZE) % ivec2(iChannelResolution[1]);\n    vec2 uv = vec2(pixel) / iChannelResolution[1].xy;\n    vec2 offset = 0.5 / iChannelResolution[1].xy;\n    return texture(iChannel1, uv + offset).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the colour for this fragment\n    vec2 pixelSizeNormalised = PIXEL_SIZE * (1.0 / iResolution.xy);\n    vec2 uv = pixelSizeNormalised * floor(fragCoord / iResolution.xy / pixelSizeNormalised);\n    vec3 colour = texture(iChannel0, uv).rgb;\n\n    // Screen wipe effect\n    if (fragCoord.x < iMouse.x) \n    {\n        fragColor = vec4(colour, 1.0);\n        return;\n    }\n     \n    // ====================================== //\n    // Actual dithering algorithm starts here //\n    // ====================================== //\n    \n    // Create a mapping from sorted palette indices to actual indices\n    int mapLuminanceToIndex[PALETTE_SIZE];\n    \n    for (int i = 0; i < PALETTE_SIZE; i++) \n        mapLuminanceToIndex[i] = i;\n    \n#if defined ENABLE_SORT\n\n    // Sort the index array by the corresponding palette colours' luminance (bubble sort)\n    for (int i = PALETTE_SIZE - 1; i > 0; i--) \n    {\n      for (int j = 0; j < i; j++) \n      {\n          if (getLuminance(palette[mapLuminanceToIndex[j]]) > \n              getLuminance(palette[mapLuminanceToIndex[j+1]])) \n          { \n              // Swap the indices\n              int t = mapLuminanceToIndex[j]; \n              mapLuminanceToIndex[j] = mapLuminanceToIndex[j+1]; \n              mapLuminanceToIndex[j+1] = t; \n          }\n      }\n    }\n    \n#endif // ENABLE_SORT\n\n    // Find N candidates via the 'greedy selection' method\n    vec3 colourLinear = sRGBtoLinear(colour);\n    vec3 goalColour = colourLinear;\n    float totalWeight = 0.0;\n    float weights[PALETTE_SIZE];\n    bool markedColours[PALETTE_SIZE];\n    \n    for (int i = 0; i < N; i++)\n    {\n        float closestDistance = INFINITY;\n        int closestColour = 0;\n        \n        // Find the closest colour in the palette via brute force\n        for (int j = 0; j < PALETTE_SIZE; j++)\n        {\n            if (markedColours[j]) continue;\n            \n            vec3 difference = goalColour - sRGBtoLinear(palette[j]);\n            float distance = dot(difference, difference);\n\n            if (distance < closestDistance)\n            {\n                closestDistance = distance;\n                closestColour = j;\n            }\n        }\n        \n        // Mark this candidate as taken\n        markedColours[closestColour] = true;\n\n        // Offset the goal\n        vec3 quantError = colourLinear - sRGBtoLinear(palette[closestColour]);\n        goalColour += quantError;\n\n        // If the colour is an exact match just use it\n        float distance = dot(quantError, quantError);\n        \n        if (distance == 0.0)\n        {\n            fragColor = vec4(palette[closestColour], 1.0);\n            return;\n        }\n        \n        // Compute the weight\n        weights[closestColour] = 1.0 / pow(distance, DISTANCE_EXPONENT);\n        totalWeight += weights[closestColour];\n    }\n    \n    // Select the output colour from the frequency array\n    float randomValue = sampleThreshold(fragCoord) * totalWeight;\n    float cumulativeSum = 0.0;\n \n    for (int i = 0; i < PALETTE_SIZE; i++)\n    {\n        cumulativeSum += weights[mapLuminanceToIndex[i]];\n        \n        if (randomValue < cumulativeSum)\n        {\n             fragColor = vec4(palette[mapLuminanceToIndex[i]], 1.0);\n             return;\n        }\n    }\n\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlc3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2057, 2168, 2200, 2200, 2511], [2513, 2558, 2591, 2591, 2660], [2662, 2728, 2763, 2801, 3029], [3031, 3031, 3088, 3128, 6340]], "test": "untested"}
{"id": "dtdGRN", "name": "Goldberg Variation no. 1", "author": "incription", "description": "(wait for audio to load)\nBy Johann Sebastian Bach\nGraphics inspired by Smalin", "tags": ["music", "audio", "bach"], "likes": 1, "viewed": 266, "published": 3, "date": "1682096167", "time_retrieved": "2024-07-30T17:59:34.998427", "image_code": "\n\n#define F(x,y) col = mix(x, col, smoothstep(0., fwidth(y), y))\n\nvec4 mix4(vec4 v1, vec4 v2, float a) { return v1 * (1. - a) + v2 * a; }\n\nvec4 getNote(int n, int channel) {\n    return texelFetch(iChannel1, ivec2(n, channel), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x *= SCALE;\n\n    vec3 col = vec3(0.02);\n    vec3 effects = vec3(0);\n\n    for(int channel = 0; channel < CHANNELS; channel++) {\n        ivec2 index = ivec2(texelFetch(iChannel0, ivec2(channel, 0), 0).xy);\n        \n        for(int i = 0; i < index.y - index.x; i++) {\n            int noteIndex = index.x + i;\n            \n            vec4 noteBox = getNoteBox(getNote(noteIndex, channel), iTime);\n            vec4 nextNoteBox = getNoteBox(getNote(noteIndex + 1, channel), iTime);\n            \n            float d = sdNote(noteBox.xy - uv, noteBox.zw);\n            //vec3[6](vec3(1.000,0.000,0.000),vec3(1.000,0.000,0.918),vec3(0.114,0.000,0.980),vec3(0.000,1.000,0.384),vec3(1.000,0.969,0.000),vec3(0.867,0.478,0.031))[channel]\n            vec3 nCol = hsv2rgb(vec3(float(channel+1)/float(CHANNELS),.76,1.));\n            F(nCol, d);\n            //col = mix(col, vec3[6](vec3(1.000,0.000,0.000),vec3(1.000,0.000,0.918),vec3(0.114,0.000,0.980),vec3(0.000,1.000,0.384),vec3(1.000,0.969,0.000),vec3(0.867,0.478,0.031))[channel], float(d<=0.));\n            if(noteBox.x - noteBox.z < 0. && noteBox.x + noteBox.z > 0.) F(pow(col,vec3(0.05)), d);\n            \n            float t = 1. - (nextNoteBox.x - nextNoteBox.z) / (nextNoteBox.x - noteBox.x + noteBox.z - nextNoteBox.z);\n            vec4 lerped = mix4(noteBox, nextNoteBox, t * t);\n            effects = mix(effects, float((nextNoteBox.x - nextNoteBox.z) - (noteBox.x + noteBox.z) <= 0.5) * pow(col,vec3(0.2)), float(sdNote(lerped.xy - uv,lerped.zw) <= 0. && (noteBox.x - noteBox.z < 0. && nextNoteBox.x - nextNoteBox.z > 0.)));\n        }\n    }\n    col += effects;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    int n = uv.x;\n    int channel = uv.y;\n    \n    vec4 note = getNoteData(channel, n);\n   \n    fragColor = note;\n}", "buffer_a_inputs": [], "buffer_b_code": "\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int channelIndex = ivec2(fragCoord).x;\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    int left = 0;\n    int right = 1;\n    if(channelIndex < CHANNELS) {\n        left = int(data.x);\n        right = int(data.y);\n        \n        vec4 box = getNoteBox(getNoteData(channelIndex, left), iTime);\n        if(box.x + box.z < -.5 * SCALE * ASPECT) left += 1;\n        \n        box = getNoteBox(getNoteData(channelIndex, right), iTime);\n        if(box.x - box.z < .5 * SCALE * ASPECT && iTime < 114.) right += 1;\n    }\n    fragColor = vec4(left, right, -1, -1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define CENTER 60.\n#define BPM 60.\n#define SCALE 3.\n#define ASPECT 1.7777\n#define CHANNELS 2\n#define INTRO 1.5\n\nconst vec4 notes0[596] = vec4[596](vec4(0.0, 67, 0.15, 0.79), vec4(0.15, 66, 0.15, 0.79), vec4(0.3, 67, 0.45, 0.79), vec4(0.75, 62, 0.15, 0.79), vec4(0.9, 64, 0.15, 0.79), vec4(1.05, 66, 0.15, 0.79), vec4(1.2, 67, 0.15, 0.79), vec4(1.35, 69, 0.15, 0.79), vec4(1.5, 71, 0.15, 0.79), vec4(1.65, 73, 0.15, 0.79), vec4(1.8, 74, 0.15, 0.79), vec4(1.95, 73, 0.15, 0.79), vec4(2.1, 74, 0.45, 0.79), vec4(2.55, 69, 0.15, 0.79), vec4(2.7, 71, 0.15, 0.79), vec4(2.85, 73, 0.15, 0.79), vec4(3.0, 74, 0.15, 0.79), vec4(3.15, 76, 0.15, 0.79), vec4(3.3, 78, 0.15, 0.79), vec4(3.45, 74, 0.15, 0.79), vec4(3.6, 79, 0.15, 0.79), vec4(3.75, 78, 0.15, 0.79), vec4(3.9, 79, 0.45, 0.79), vec4(4.35, 78, 0.15, 0.79), vec4(4.5, 76, 0.15, 0.79), vec4(4.65, 74, 0.15, 0.79), vec4(4.8, 73, 0.15, 0.79), vec4(4.95, 76, 0.15, 0.79), vec4(5.1, 69, 0.15, 0.79), vec4(5.25, 67, 0.15, 0.79), vec4(5.4, 66, 0.15, 0.79), vec4(5.55, 64, 0.15, 0.79), vec4(5.7, 62, 0.15, 0.79), vec4(5.85, 61, 0.15, 0.79), vec4(6.0, 62, 0.15, 0.79), vec4(6.15, 66, 0.15, 0.79), vec4(6.3, 57, 0.15, 0.79), vec4(6.45, 55, 0.15, 0.79), vec4(6.6, 54, 0.15, 0.79), vec4(6.75, 57, 0.15, 0.79), vec4(6.9, 50, 0.3, 0.79), vec4(7.5, 74, 0.15, 0.79), vec4(7.65, 72, 0.15, 0.79), vec4(7.8, 74, 0.3, 0.79), vec4(8.1, 67, 0.3, 0.79), vec4(8.4, 59, 0.3, 0.79), vec4(8.7, 74, 0.3, 0.79), vec4(9.3, 76, 0.15, 0.79), vec4(9.45, 74, 0.15, 0.79), vec4(9.6, 76, 0.3, 0.79), vec4(9.9, 69, 0.3, 0.79), vec4(10.2, 60, 0.3, 0.79), vec4(10.5, 76, 0.3, 0.79), vec4(11.1, 78, 0.15, 0.79), vec4(11.25, 76, 0.15, 0.79), vec4(11.4, 78, 0.3, 0.79), vec4(11.7, 74, 0.3, 0.79), vec4(12.0, 81, 0.3, 0.79), vec4(12.3, 72, 0.6, 0.79), vec4(12.9, 71, 0.3, 0.79), vec4(13.35, 67, 0.15, 0.79), vec4(13.5, 71, 0.15, 0.79), vec4(13.65, 74, 0.15, 0.79), vec4(13.8, 79, 0.15, 0.79), vec4(13.95, 74, 0.15, 0.79), vec4(14.1, 79, 0.15, 0.79), vec4(14.25, 81, 0.15, 0.79), vec4(14.4, 83, 0.15, 0.79), vec4(14.55, 79, 0.15, 0.79), vec4(14.7, 74, 0.15, 0.79), vec4(14.85, 71, 0.15, 0.79), vec4(15.0, 67, 0.15, 0.79), vec4(15.15, 71, 0.15, 0.79), vec4(15.3, 74, 0.15, 0.79), vec4(15.45, 79, 0.15, 0.79), vec4(15.6, 83, 0.15, 0.79), vec4(15.75, 79, 0.15, 0.79), vec4(15.9, 78, 0.15, 0.79), vec4(16.05, 76, 0.15, 0.79), vec4(16.2, 81, 0.15, 0.79), vec4(16.35, 76, 0.15, 0.79), vec4(16.5, 73, 0.15, 0.79), vec4(16.65, 69, 0.15, 0.79), vec4(16.8, 66, 0.15, 0.79), vec4(16.95, 69, 0.15, 0.79), vec4(17.1, 73, 0.15, 0.79), vec4(17.25, 76, 0.15, 0.79), vec4(17.4, 81, 0.15, 0.79), vec4(17.55, 78, 0.15, 0.79), vec4(17.7, 76, 0.15, 0.79), vec4(17.85, 74, 0.15, 0.79), vec4(18.0, 79, 0.15, 0.79), vec4(18.15, 74, 0.15, 0.79), vec4(18.3, 71, 0.15, 0.79), vec4(18.45, 67, 0.15, 0.79), vec4(18.6, 64, 0.15, 0.79), vec4(18.75, 67, 0.15, 0.79), vec4(18.9, 71, 0.15, 0.79), vec4(19.05, 74, 0.15, 0.79), vec4(19.2, 79, 0.15, 0.79), vec4(19.35, 78, 0.15, 0.79), vec4(19.5, 76, 0.15, 0.79), vec4(19.65, 74, 0.15, 0.79), vec4(19.8, 73, 0.15, 0.79), vec4(19.95, 67, 0.15, 0.79), vec4(20.1, 64, 0.15, 0.79), vec4(20.25, 61, 0.15, 0.79), vec4(20.4, 57, 0.15, 0.79), vec4(20.55, 61, 0.15, 0.79), vec4(20.7, 64, 0.15, 0.79), vec4(20.85, 67, 0.15, 0.79), vec4(21.0, 73, 0.15, 0.79), vec4(21.15, 76, 0.15, 0.79), vec4(21.3, 74, 0.15, 0.79), vec4(21.45, 73, 0.15, 0.79), vec4(21.6, 74, 0.3, 0.79), vec4(21.9, 54, 0.3, 0.79), vec4(22.2, 54, 0.3, 0.79), vec4(22.5, 69, 0.3, 0.79), vec4(22.8, 74, 0.3, 0.79), vec4(23.1, 78, 0.3, 0.79), vec4(23.4, 71, 0.3, 0.79), vec4(23.7, 55, 0.3, 0.79), vec4(24.0, 55, 0.3, 0.79), vec4(24.3, 71, 0.3, 0.79), vec4(24.6, 76, 0.3, 0.79), vec4(24.9, 79, 0.3, 0.79), vec4(25.2, 73, 0.15, 0.79), vec4(25.35, 76, 0.15, 0.79), vec4(25.5, 69, 0.15, 0.79), vec4(25.65, 67, 0.15, 0.79), vec4(25.8, 66, 0.15, 0.79), vec4(25.95, 69, 0.15, 0.79), vec4(26.1, 74, 0.15, 0.79), vec4(26.25, 78, 0.15, 0.79), vec4(26.4, 79, 0.15, 0.79), vec4(26.55, 76, 0.15, 0.79), vec4(26.7, 74, 0.15, 0.79), vec4(26.85, 73, 0.15, 0.79), vec4(27.0, 78, 0.15, 0.79), vec4(27.15, 74, 0.15, 0.79), vec4(27.3, 73, 0.15, 0.79), vec4(27.45, 71, 0.15, 0.79), vec4(27.6, 69, 0.15, 0.79), vec4(27.75, 67, 0.15, 0.79), vec4(27.9, 66, 0.15, 0.79), vec4(28.05, 64, 0.15, 0.79), vec4(28.2, 62, 0.6, 0.79), vec4(28.8, 67, 0.15, 0.79), vec4(28.95, 66, 0.15, 0.79), vec4(29.1, 67, 0.45, 0.79), vec4(29.55, 62, 0.15, 0.79), vec4(29.7, 64, 0.15, 0.79), vec4(29.85, 66, 0.15, 0.79), vec4(30.0, 67, 0.15, 0.79), vec4(30.15, 69, 0.15, 0.79), vec4(30.3, 71, 0.15, 0.79), vec4(30.45, 73, 0.15, 0.79), vec4(30.6, 74, 0.15, 0.79), vec4(30.75, 73, 0.15, 0.79), vec4(30.9, 74, 0.45, 0.79), vec4(31.35, 69, 0.15, 0.79), vec4(31.5, 71, 0.15, 0.79), vec4(31.65, 73, 0.15, 0.79), vec4(31.8, 74, 0.15, 0.79), vec4(31.95, 76, 0.15, 0.79), vec4(32.1, 78, 0.15, 0.79), vec4(32.25, 74, 0.15, 0.79), vec4(32.4, 79, 0.15, 0.79), vec4(32.55, 78, 0.15, 0.79), vec4(32.7, 79, 0.45, 0.79), vec4(33.15, 78, 0.15, 0.79), vec4(33.3, 76, 0.15, 0.79), vec4(33.45, 74, 0.15, 0.79), vec4(33.6, 73, 0.15, 0.79), vec4(33.75, 76, 0.15, 0.79), vec4(33.9, 69, 0.15, 0.79), vec4(34.05, 67, 0.15, 0.79), vec4(34.2, 66, 0.15, 0.79), vec4(34.35, 64, 0.15, 0.79), vec4(34.5, 62, 0.15, 0.79), vec4(34.65, 61, 0.15, 0.79), vec4(34.8, 62, 0.15, 0.79), vec4(34.95, 66, 0.15, 0.79), vec4(35.1, 57, 0.15, 0.79), vec4(35.25, 55, 0.15, 0.79), vec4(35.4, 54, 0.15, 0.79), vec4(35.55, 57, 0.15, 0.79), vec4(35.7, 50, 0.3, 0.79), vec4(36.3, 74, 0.15, 0.79), vec4(36.45, 72, 0.15, 0.79), vec4(36.6, 74, 0.3, 0.79), vec4(36.9, 67, 0.3, 0.79), vec4(37.2, 59, 0.3, 0.79), vec4(37.5, 74, 0.3, 0.79), vec4(38.1, 76, 0.15, 0.79), vec4(38.25, 74, 0.15, 0.79), vec4(38.4, 76, 0.3, 0.79), vec4(38.7, 69, 0.3, 0.79), vec4(39.0, 60, 0.3, 0.79), vec4(39.3, 76, 0.3, 0.79), vec4(39.9, 78, 0.15, 0.79), vec4(40.05, 76, 0.15, 0.79), vec4(40.2, 78, 0.3, 0.79), vec4(40.5, 74, 0.3, 0.79), vec4(40.8, 81, 0.3, 0.79), vec4(41.1, 72, 0.6, 0.79), vec4(41.7, 71, 0.3, 0.79), vec4(42.15, 67, 0.15, 0.79), vec4(42.3, 71, 0.15, 0.79), vec4(42.45, 74, 0.15, 0.79), vec4(42.6, 79, 0.15, 0.79), vec4(42.75, 74, 0.15, 0.79), vec4(42.9, 79, 0.15, 0.79), vec4(43.05, 81, 0.15, 0.79), vec4(43.2, 83, 0.15, 0.79), vec4(43.35, 79, 0.15, 0.79), vec4(43.5, 74, 0.15, 0.79), vec4(43.65, 71, 0.15, 0.79), vec4(43.8, 67, 0.15, 0.79), vec4(43.95, 71, 0.15, 0.79), vec4(44.1, 74, 0.15, 0.79), vec4(44.25, 79, 0.15, 0.79), vec4(44.4, 83, 0.15, 0.79), vec4(44.55, 79, 0.15, 0.79), vec4(44.7, 78, 0.15, 0.79), vec4(44.85, 76, 0.15, 0.79), vec4(45.0, 81, 0.15, 0.79), vec4(45.15, 76, 0.15, 0.79), vec4(45.3, 73, 0.15, 0.79), vec4(45.45, 69, 0.15, 0.79), vec4(45.6, 66, 0.15, 0.79), vec4(45.75, 69, 0.15, 0.79), vec4(45.9, 73, 0.15, 0.79), vec4(46.05, 76, 0.15, 0.79), vec4(46.2, 81, 0.15, 0.79), vec4(46.35, 78, 0.15, 0.79), vec4(46.5, 76, 0.15, 0.79), vec4(46.65, 74, 0.15, 0.79), vec4(46.8, 79, 0.15, 0.79), vec4(46.95, 74, 0.15, 0.79), vec4(47.1, 71, 0.15, 0.79), vec4(47.25, 67, 0.15, 0.79), vec4(47.4, 64, 0.15, 0.79), vec4(47.55, 67, 0.15, 0.79), vec4(47.7, 71, 0.15, 0.79), vec4(47.85, 74, 0.15, 0.79), vec4(48.0, 79, 0.15, 0.79), vec4(48.15, 78, 0.15, 0.79), vec4(48.3, 76, 0.15, 0.79), vec4(48.45, 74, 0.15, 0.79), vec4(48.6, 73, 0.15, 0.79), vec4(48.75, 67, 0.15, 0.79), vec4(48.9, 64, 0.15, 0.79), vec4(49.05, 61, 0.15, 0.79), vec4(49.2, 57, 0.15, 0.79), vec4(49.35, 61, 0.15, 0.79), vec4(49.5, 64, 0.15, 0.79), vec4(49.65, 67, 0.15, 0.79), vec4(49.8, 73, 0.15, 0.79), vec4(49.95, 76, 0.15, 0.79), vec4(50.1, 74, 0.15, 0.79), vec4(50.25, 73, 0.15, 0.79), vec4(50.4, 74, 0.3, 0.79), vec4(50.7, 54, 0.3, 0.79), vec4(51.0, 54, 0.3, 0.79), vec4(51.3, 69, 0.3, 0.79), vec4(51.6, 74, 0.3, 0.79), vec4(51.9, 78, 0.3, 0.79), vec4(52.2, 71, 0.3, 0.79), vec4(52.5, 55, 0.3, 0.79), vec4(52.8, 55, 0.3, 0.79), vec4(53.1, 71, 0.3, 0.79), vec4(53.4, 76, 0.3, 0.79), vec4(53.7, 79, 0.3, 0.79), vec4(54.0, 73, 0.15, 0.79), vec4(54.15, 76, 0.15, 0.79), vec4(54.3, 69, 0.15, 0.79), vec4(54.45, 67, 0.15, 0.79), vec4(54.6, 66, 0.15, 0.79), vec4(54.75, 69, 0.15, 0.79), vec4(54.9, 74, 0.15, 0.79), vec4(55.05, 78, 0.15, 0.79), vec4(55.2, 79, 0.15, 0.79), vec4(55.35, 76, 0.15, 0.79), vec4(55.5, 74, 0.15, 0.79), vec4(55.65, 73, 0.15, 0.79), vec4(55.8, 78, 0.15, 0.79), vec4(55.95, 74, 0.15, 0.79), vec4(56.1, 73, 0.15, 0.79), vec4(56.25, 71, 0.15, 0.79), vec4(56.4, 69, 0.15, 0.79), vec4(56.55, 67, 0.15, 0.79), vec4(56.7, 66, 0.15, 0.79), vec4(56.85, 64, 0.15, 0.79), vec4(57.0, 62, 0.6, 0.79), vec4(57.6, 78, 0.15, 0.79), vec4(57.75, 79, 0.15, 0.79), vec4(57.9, 81, 0.45, 0.79), vec4(58.35, 83, 0.15, 0.79), vec4(58.5, 81, 0.15, 0.79), vec4(58.65, 79, 0.15, 0.79), vec4(58.8, 78, 0.15, 0.79), vec4(58.95, 76, 0.15, 0.79), vec4(59.1, 74, 0.15, 0.79), vec4(59.25, 72, 0.15, 0.79), vec4(59.4, 71, 0.15, 0.79), vec4(59.55, 72, 0.15, 0.79), vec4(59.7, 74, 0.45, 0.79), vec4(60.15, 76, 0.15, 0.79), vec4(60.3, 74, 0.15, 0.79), vec4(60.45, 72, 0.15, 0.79), vec4(60.6, 71, 0.15, 0.79), vec4(60.75, 69, 0.15, 0.79), vec4(60.9, 67, 0.15, 0.79), vec4(61.05, 66, 0.15, 0.79), vec4(61.2, 64, 0.15, 0.79), vec4(61.35, 68, 0.15, 0.79), vec4(61.5, 69, 0.15, 0.79), vec4(61.65, 71, 0.15, 0.79), vec4(61.8, 69, 0.15, 0.79), vec4(61.95, 64, 0.15, 0.79), vec4(62.1, 69, 0.15, 0.79), vec4(62.25, 71, 0.15, 0.79), vec4(62.4, 72, 0.15, 0.79), vec4(62.55, 69, 0.15, 0.79), vec4(62.7, 75, 0.15, 0.79), vec4(62.85, 76, 0.15, 0.79), vec4(63.0, 78, 0.15, 0.79), vec4(63.15, 76, 0.15, 0.79), vec4(63.3, 75, 0.15, 0.79), vec4(63.45, 73, 0.15, 0.79), vec4(63.6, 71, 1.35, 0.79), vec4(64.95, 75, 0.15, 0.79), vec4(65.1, 76, 0.45, 0.79), vec4(65.55, 63, 0.15, 0.79), vec4(65.7, 64, 0.45, 0.79), vec4(66.15, 51, 0.15, 0.79), vec4(66.3, 52, 0.3, 0.79), vec4(66.75, 80, 0.15, 0.79), vec4(66.9, 81, 0.45, 0.79), vec4(67.35, 68, 0.15, 0.79), vec4(67.5, 69, 0.45, 0.79), vec4(67.95, 56, 0.15, 0.79), vec4(68.1, 57, 0.45, 0.79), vec4(68.55, 59, 0.15, 0.79), vec4(68.7, 60, 0.15, 0.79), vec4(68.85, 66, 0.15, 0.79), vec4(69.0, 59, 0.15, 0.79), vec4(69.15, 63, 0.15, 0.79), vec4(69.3, 64, 0.15, 0.79), vec4(69.45, 67, 0.15, 0.79), vec4(69.6, 66, 0.15, 0.79), vec4(69.75, 64, 0.15, 0.79), vec4(69.9, 63, 0.15, 0.79), vec4(70.05, 69, 0.15, 0.79), vec4(70.2, 67, 0.15, 0.79), vec4(70.35, 66, 0.15, 0.79), vec4(70.5, 64, 0.15, 0.79), vec4(70.65, 63, 0.15, 0.79), vec4(70.8, 64, 0.15, 0.79), vec4(70.95, 67, 0.15, 0.79), vec4(71.1, 59, 0.15, 0.79), vec4(71.25, 57, 0.15, 0.79), vec4(71.4, 55, 0.15, 0.79), vec4(71.55, 59, 0.15, 0.79), vec4(71.7, 52, 0.3, 0.79), vec4(72.3, 76, 0.3, 0.79), vec4(72.6, 72, 0.3, 0.79), vec4(72.9, 76, 0.3, 0.79), vec4(73.2, 81, 0.3, 0.79), vec4(73.5, 69, 0.3, 0.79), vec4(74.1, 74, 0.3, 0.79), vec4(74.4, 71, 0.3, 0.79), vec4(74.7, 74, 0.3, 0.79), vec4(75.0, 79, 0.3, 0.79), vec4(75.3, 67, 0.3, 0.79), vec4(75.6, 72, 0.15, 0.79), vec4(75.75, 69, 0.15, 0.79), vec4(75.9, 64, 0.15, 0.79), vec4(76.05, 60, 0.15, 0.79), vec4(76.2, 57, 0.15, 0.79), vec4(76.35, 60, 0.15, 0.79), vec4(76.5, 64, 0.15, 0.79), vec4(76.65, 69, 0.15, 0.79), vec4(76.8, 72, 0.15, 0.79), vec4(76.95, 69, 0.15, 0.79), vec4(77.1, 72, 0.15, 0.79), vec4(77.25, 76, 0.15, 0.79), vec4(77.4, 78, 0.15, 0.79), vec4(77.55, 72, 0.15, 0.79), vec4(77.7, 69, 0.15, 0.79), vec4(77.85, 66, 0.15, 0.79), vec4(78.0, 62, 0.15, 0.79), vec4(78.15, 66, 0.15, 0.79), vec4(78.3, 69, 0.15, 0.79), vec4(78.45, 72, 0.15, 0.79), vec4(78.6, 78, 0.15, 0.79), vec4(78.75, 72, 0.15, 0.79), vec4(78.9, 78, 0.15, 0.79), vec4(79.05, 81, 0.15, 0.79), vec4(79.2, 83, 0.15, 0.79), vec4(79.35, 79, 0.15, 0.79), vec4(79.5, 74, 0.15, 0.79), vec4(79.65, 71, 0.15, 0.79), vec4(79.8, 67, 0.15, 0.79), vec4(79.95, 71, 0.15, 0.79), vec4(80.1, 74, 0.15, 0.79), vec4(80.25, 79, 0.15, 0.79), vec4(80.4, 83, 0.15, 0.79), vec4(80.55, 77, 0.15, 0.79), vec4(80.7, 83, 0.15, 0.79), vec4(80.85, 86, 0.15, 0.79), vec4(81.0, 76, 0.15, 0.79), vec4(81.15, 86, 0.15, 0.79), vec4(81.3, 84, 0.15, 0.79), vec4(81.45, 76, 0.15, 0.79), vec4(81.6, 74, 0.15, 0.79), vec4(81.75, 84, 0.15, 0.79), vec4(81.9, 83, 0.15, 0.79), vec4(82.05, 74, 0.15, 0.79), vec4(82.2, 72, 0.15, 0.79), vec4(82.35, 76, 0.15, 0.79), vec4(82.5, 78, 0.15, 0.79), vec4(82.65, 79, 0.15, 0.79), vec4(82.8, 81, 0.15, 0.79), vec4(82.95, 72, 0.15, 0.79), vec4(83.1, 71, 0.15, 0.79), vec4(83.25, 69, 0.15, 0.79), vec4(83.4, 71, 0.15, 0.79), vec4(83.55, 74, 0.15, 0.79), vec4(83.7, 71, 0.15, 0.79), vec4(83.85, 67, 0.15, 0.79), vec4(84.0, 72, 0.15, 0.79), vec4(84.15, 69, 0.15, 0.79), vec4(84.3, 67, 0.15, 0.79), vec4(84.45, 66, 0.15, 0.79), vec4(84.6, 71, 0.15, 0.79), vec4(84.75, 67, 0.15, 0.79), vec4(84.9, 66, 0.15, 0.79), vec4(85.05, 64, 0.15, 0.79), vec4(85.2, 62, 0.15, 0.79), vec4(85.35, 60, 0.15, 0.79), vec4(85.5, 59, 0.15, 0.79), vec4(85.65, 57, 0.15, 0.79), vec4(85.8, 55, 0.6, 0.79), vec4(86.4, 78, 0.15, 0.79), vec4(86.55, 79, 0.15, 0.79), vec4(86.7, 81, 0.45, 0.79), vec4(87.15, 83, 0.15, 0.79), vec4(87.3, 81, 0.15, 0.79), vec4(87.45, 79, 0.15, 0.79), vec4(87.6, 78, 0.15, 0.79), vec4(87.75, 76, 0.15, 0.79), vec4(87.9, 74, 0.15, 0.79), vec4(88.05, 72, 0.15, 0.79), vec4(88.2, 71, 0.15, 0.79), vec4(88.35, 72, 0.15, 0.79), vec4(88.5, 74, 0.45, 0.79), vec4(88.95, 76, 0.15, 0.79), vec4(89.1, 74, 0.15, 0.79), vec4(89.25, 72, 0.15, 0.79), vec4(89.4, 71, 0.15, 0.79), vec4(89.55, 69, 0.15, 0.79), vec4(89.7, 67, 0.15, 0.79), vec4(89.85, 66, 0.15, 0.79), vec4(90.0, 64, 0.15, 0.79), vec4(90.15, 68, 0.15, 0.79), vec4(90.3, 69, 0.15, 0.79), vec4(90.45, 71, 0.15, 0.79), vec4(90.6, 69, 0.15, 0.79), vec4(90.75, 64, 0.15, 0.79), vec4(90.9, 69, 0.15, 0.79), vec4(91.05, 71, 0.15, 0.79), vec4(91.2, 72, 0.15, 0.79), vec4(91.35, 69, 0.15, 0.79), vec4(91.5, 75, 0.15, 0.79), vec4(91.65, 76, 0.15, 0.79), vec4(91.8, 78, 0.15, 0.79), vec4(91.95, 76, 0.15, 0.79), vec4(92.1, 75, 0.15, 0.79), vec4(92.25, 73, 0.15, 0.79), vec4(92.4, 71, 1.35, 0.79), vec4(93.75, 75, 0.15, 0.79), vec4(93.9, 76, 0.45, 0.79), vec4(94.35, 63, 0.15, 0.79), vec4(94.5, 64, 0.45, 0.79), vec4(94.95, 51, 0.15, 0.79), vec4(95.1, 52, 0.3, 0.79), vec4(95.55, 80, 0.15, 0.79), vec4(95.7, 81, 0.45, 0.79), vec4(96.15, 68, 0.15, 0.79), vec4(96.3, 69, 0.45, 0.79), vec4(96.75, 56, 0.15, 0.79), vec4(96.9, 57, 0.45, 0.79), vec4(97.35, 59, 0.15, 0.79), vec4(97.5, 60, 0.15, 0.79), vec4(97.65, 66, 0.15, 0.79), vec4(97.8, 59, 0.15, 0.79), vec4(97.95, 63, 0.15, 0.79), vec4(98.1, 64, 0.15, 0.79), vec4(98.25, 67, 0.15, 0.79), vec4(98.4, 66, 0.15, 0.79), vec4(98.55, 64, 0.15, 0.79), vec4(98.7, 63, 0.15, 0.79), vec4(98.85, 69, 0.15, 0.79), vec4(99.0, 67, 0.15, 0.79), vec4(99.15, 66, 0.15, 0.79), vec4(99.3, 64, 0.15, 0.79), vec4(99.45, 63, 0.15, 0.79), vec4(99.6, 64, 0.15, 0.79), vec4(99.75, 67, 0.15, 0.79), vec4(99.9, 59, 0.15, 0.79), vec4(100.05, 57, 0.15, 0.79), vec4(100.2, 55, 0.15, 0.79), vec4(100.35, 59, 0.15, 0.79), vec4(100.5, 52, 0.3, 0.79), vec4(101.1, 76, 0.3, 0.79), vec4(101.4, 72, 0.3, 0.79), vec4(101.7, 76, 0.3, 0.79), vec4(102.0, 81, 0.3, 0.79), vec4(102.3, 69, 0.3, 0.79), vec4(102.9, 74, 0.3, 0.79), vec4(103.2, 71, 0.3, 0.79), vec4(103.5, 74, 0.3, 0.79), vec4(103.8, 79, 0.3, 0.79), vec4(104.1, 67, 0.3, 0.79), vec4(104.4, 72, 0.15, 0.79), vec4(104.55, 69, 0.15, 0.79), vec4(104.7, 64, 0.15, 0.79), vec4(104.85, 60, 0.15, 0.79), vec4(105.0, 57, 0.15, 0.79), vec4(105.15, 60, 0.15, 0.79), vec4(105.3, 64, 0.15, 0.79), vec4(105.45, 69, 0.15, 0.79), vec4(105.6, 72, 0.15, 0.79), vec4(105.75, 69, 0.15, 0.79), vec4(105.9, 72, 0.15, 0.79), vec4(106.05, 76, 0.15, 0.79), vec4(106.2, 78, 0.15, 0.79), vec4(106.35, 72, 0.15, 0.79), vec4(106.5, 69, 0.15, 0.79), vec4(106.65, 66, 0.15, 0.79), vec4(106.8, 62, 0.15, 0.79), vec4(106.95, 66, 0.15, 0.79), vec4(107.1, 69, 0.15, 0.79), vec4(107.25, 72, 0.15, 0.79), vec4(107.4, 78, 0.15, 0.79), vec4(107.55, 72, 0.15, 0.79), vec4(107.7, 78, 0.15, 0.79), vec4(107.85, 81, 0.15, 0.79), vec4(108.0, 83, 0.15, 0.79), vec4(108.15, 79, 0.15, 0.79), vec4(108.3, 74, 0.15, 0.79), vec4(108.45, 71, 0.15, 0.79), vec4(108.6, 67, 0.15, 0.79), vec4(108.75, 71, 0.15, 0.79), vec4(108.9, 74, 0.15, 0.79), vec4(109.05, 79, 0.15, 0.79), vec4(109.2, 83, 0.15, 0.79), vec4(109.35, 77, 0.15, 0.79), vec4(109.5, 83, 0.15, 0.79), vec4(109.65, 86, 0.15, 0.79), vec4(109.8, 76, 0.15, 0.79), vec4(109.95, 86, 0.15, 0.79), vec4(110.1, 84, 0.15, 0.79), vec4(110.25, 76, 0.15, 0.79), vec4(110.4, 74, 0.15, 0.79), vec4(110.55, 84, 0.15, 0.79), vec4(110.7, 83, 0.15, 0.79), vec4(110.85, 74, 0.15, 0.79), vec4(111.0, 72, 0.15, 0.79), vec4(111.15, 76, 0.15, 0.79), vec4(111.3, 78, 0.15, 0.79), vec4(111.45, 79, 0.15, 0.79), vec4(111.6, 81, 0.15, 0.79), vec4(111.75, 72, 0.15, 0.79), vec4(111.9, 71, 0.15, 0.79), vec4(112.05, 69, 0.15, 0.79), vec4(112.2, 71, 0.15, 0.79), vec4(112.35, 74, 0.15, 0.79), vec4(112.5, 71, 0.15, 0.79), vec4(112.65, 67, 0.15, 0.79), vec4(112.8, 72, 0.15, 0.79), vec4(112.95, 69, 0.15, 0.79), vec4(113.1, 67, 0.15, 0.79), vec4(113.25, 66, 0.15, 0.79), vec4(113.4, 71, 0.15, 0.79), vec4(113.55, 67, 0.15, 0.79), vec4(113.7, 66, 0.15, 0.79), vec4(113.85, 64, 0.15, 0.79), vec4(114.0, 62, 0.15, 0.79), vec4(114.15, 60, 0.15, 0.79), vec4(114.3, 59, 0.15, 0.79), vec4(114.45, 57, 0.15, 0.79), vec4(114.6, 55, 1.25, 0.79));\nconst vec4 notes1[508] = vec4[508](vec4(0.0, 43, 0.3, 0.79), vec4(0.3, 59, 0.15, 0.79), vec4(0.45, 57, 0.15, 0.79), vec4(0.6, 59, 0.3, 0.79), vec4(0.9, 55, 0.3, 0.79), vec4(1.2, 43, 0.3, 0.79), vec4(1.5, 55, 0.3, 0.79), vec4(1.8, 42, 0.3, 0.79), vec4(2.1, 54, 0.15, 0.79), vec4(2.25, 52, 0.15, 0.79), vec4(2.4, 54, 0.3, 0.79), vec4(2.7, 50, 0.3, 0.79), vec4(3.0, 42, 0.3, 0.79), vec4(3.3, 50, 0.3, 0.79), vec4(3.6, 40, 0.3, 0.79), vec4(3.9, 52, 0.15, 0.79), vec4(4.05, 50, 0.15, 0.79), vec4(4.2, 52, 0.3, 0.79), vec4(4.5, 55, 0.3, 0.79), vec4(4.8, 45, 0.3, 0.79), vec4(5.1, 61, 0.3, 0.79), vec4(5.4, 50, 0.3, 0.79), vec4(5.7, 54, 0.15, 0.79), vec4(5.85, 52, 0.15, 0.79), vec4(6.0, 54, 0.3, 0.79), vec4(6.3, 50, 0.3, 0.79), vec4(6.6, 38, 0.3, 0.79), vec4(7.05, 48, 0.15, 0.79), vec4(7.2, 47, 0.15, 0.79), vec4(7.35, 45, 0.15, 0.79), vec4(7.5, 47, 0.45, 0.79), vec4(7.95, 50, 0.15, 0.79), vec4(8.1, 52, 0.15, 0.79), vec4(8.25, 54, 0.15, 0.79), vec4(8.4, 55, 0.15, 0.79), vec4(8.55, 57, 0.15, 0.79), vec4(8.7, 59, 0.15, 0.79), vec4(8.85, 55, 0.15, 0.79), vec4(9.0, 48, 0.15, 0.79), vec4(9.15, 47, 0.15, 0.79), vec4(9.3, 48, 0.45, 0.79), vec4(9.75, 52, 0.15, 0.79), vec4(9.9, 54, 0.15, 0.79), vec4(10.05, 55, 0.15, 0.79), vec4(10.2, 57, 0.15, 0.79), vec4(10.35, 59, 0.15, 0.79), vec4(10.5, 60, 0.15, 0.79), vec4(10.65, 57, 0.15, 0.79), vec4(10.8, 50, 0.15, 0.79), vec4(10.95, 49, 0.15, 0.79), vec4(11.1, 50, 0.45, 0.79), vec4(11.55, 57, 0.15, 0.79), vec4(11.7, 59, 0.15, 0.79), vec4(11.85, 60, 0.15, 0.79), vec4(12.0, 62, 0.15, 0.79), vec4(12.15, 64, 0.15, 0.79), vec4(12.3, 66, 0.15, 0.79), vec4(12.45, 62, 0.15, 0.79), vec4(12.6, 67, 0.15, 0.79), vec4(12.75, 66, 0.15, 0.79), vec4(12.9, 67, 0.15, 0.79), vec4(13.05, 62, 0.15, 0.79), vec4(13.2, 59, 0.15, 0.79), vec4(13.35, 62, 0.15, 0.79), vec4(13.5, 55, 0.15, 0.79), vec4(13.65, 59, 0.15, 0.79), vec4(13.8, 50, 0.15, 0.79), vec4(13.95, 55, 0.15, 0.79), vec4(14.1, 47, 0.15, 0.79), vec4(14.25, 50, 0.15, 0.79), vec4(14.4, 43, 0.3, 0.79), vec4(14.7, 55, 0.3, 0.79), vec4(15.0, 59, 0.3, 0.79), vec4(15.3, 55, 0.3, 0.79), vec4(15.6, 43, 0.3, 0.79), vec4(15.9, 55, 0.3, 0.79), vec4(16.2, 42, 0.3, 0.79), vec4(16.5, 54, 0.3, 0.79), vec4(16.8, 57, 0.3, 0.79), vec4(17.1, 54, 0.3, 0.79), vec4(17.4, 42, 0.3, 0.79), vec4(17.7, 54, 0.3, 0.79), vec4(18.0, 40, 0.3, 0.79), vec4(18.3, 52, 0.3, 0.79), vec4(18.6, 55, 0.3, 0.79), vec4(18.9, 52, 0.3, 0.79), vec4(19.2, 40, 0.3, 0.79), vec4(19.5, 55, 0.3, 0.79), vec4(19.8, 45, 0.3, 0.79), vec4(20.1, 52, 0.3, 0.79), vec4(20.4, 55, 0.3, 0.79), vec4(20.7, 52, 0.3, 0.79), vec4(21.0, 45, 0.3, 0.79), vec4(21.3, 55, 0.3, 0.79), vec4(21.6, 54, 0.15, 0.79), vec4(21.75, 57, 0.15, 0.79), vec4(21.9, 62, 0.15, 0.79), vec4(22.05, 66, 0.15, 0.79), vec4(22.2, 69, 0.15, 0.79), vec4(22.35, 66, 0.15, 0.79), vec4(22.5, 62, 0.15, 0.79), vec4(22.65, 57, 0.15, 0.79), vec4(22.8, 54, 0.15, 0.79), vec4(22.95, 57, 0.15, 0.79), vec4(23.1, 50, 0.15, 0.79), vec4(23.25, 54, 0.15, 0.79), vec4(23.4, 55, 0.15, 0.79), vec4(23.55, 59, 0.15, 0.79), vec4(23.7, 62, 0.15, 0.79), vec4(23.85, 67, 0.15, 0.79), vec4(24.0, 71, 0.15, 0.79), vec4(24.15, 67, 0.15, 0.79), vec4(24.3, 62, 0.15, 0.79), vec4(24.45, 59, 0.15, 0.79), vec4(24.6, 55, 0.15, 0.79), vec4(24.75, 59, 0.15, 0.79), vec4(24.9, 52, 0.15, 0.79), vec4(25.05, 55, 0.15, 0.79), vec4(25.2, 57, 0.3, 0.79), vec4(25.5, 61, 0.3, 0.79), vec4(25.8, 62, 0.15, 0.79), vec4(25.95, 57, 0.15, 0.79), vec4(26.1, 54, 0.15, 0.79), vec4(26.25, 50, 0.15, 0.79), vec4(26.4, 57, 0.3, 0.79), vec4(26.7, 45, 0.3, 0.79), vec4(27.0, 38, 0.15, 0.79), vec4(27.15, 50, 0.15, 0.79), vec4(27.3, 52, 0.15, 0.79), vec4(27.45, 54, 0.15, 0.79), vec4(27.6, 55, 0.15, 0.79), vec4(27.75, 57, 0.15, 0.79), vec4(27.9, 59, 0.15, 0.79), vec4(28.05, 61, 0.15, 0.79), vec4(28.2, 62, 0.6, 0.79), vec4(28.8, 43, 0.3, 0.79), vec4(29.1, 59, 0.15, 0.79), vec4(29.25, 57, 0.15, 0.79), vec4(29.4, 59, 0.3, 0.79), vec4(29.7, 55, 0.3, 0.79), vec4(30.0, 43, 0.3, 0.79), vec4(30.3, 55, 0.3, 0.79), vec4(30.6, 42, 0.3, 0.79), vec4(30.9, 54, 0.15, 0.79), vec4(31.05, 52, 0.15, 0.79), vec4(31.2, 54, 0.3, 0.79), vec4(31.5, 50, 0.3, 0.79), vec4(31.8, 42, 0.3, 0.79), vec4(32.1, 50, 0.3, 0.79), vec4(32.4, 40, 0.3, 0.79), vec4(32.7, 52, 0.15, 0.79), vec4(32.85, 50, 0.15, 0.79), vec4(33.0, 52, 0.3, 0.79), vec4(33.3, 55, 0.3, 0.79), vec4(33.6, 45, 0.3, 0.79), vec4(33.9, 61, 0.3, 0.79), vec4(34.2, 50, 0.3, 0.79), vec4(34.5, 54, 0.15, 0.79), vec4(34.65, 52, 0.15, 0.79), vec4(34.8, 54, 0.3, 0.79), vec4(35.1, 50, 0.3, 0.79), vec4(35.4, 38, 0.3, 0.79), vec4(35.85, 48, 0.15, 0.79), vec4(36.0, 47, 0.15, 0.79), vec4(36.15, 45, 0.15, 0.79), vec4(36.3, 47, 0.45, 0.79), vec4(36.75, 50, 0.15, 0.79), vec4(36.9, 52, 0.15, 0.79), vec4(37.05, 54, 0.15, 0.79), vec4(37.2, 55, 0.15, 0.79), vec4(37.35, 57, 0.15, 0.79), vec4(37.5, 59, 0.15, 0.79), vec4(37.65, 55, 0.15, 0.79), vec4(37.8, 48, 0.15, 0.79), vec4(37.95, 47, 0.15, 0.79), vec4(38.1, 48, 0.45, 0.79), vec4(38.55, 52, 0.15, 0.79), vec4(38.7, 54, 0.15, 0.79), vec4(38.85, 55, 0.15, 0.79), vec4(39.0, 57, 0.15, 0.79), vec4(39.15, 59, 0.15, 0.79), vec4(39.3, 60, 0.15, 0.79), vec4(39.45, 57, 0.15, 0.79), vec4(39.6, 50, 0.15, 0.79), vec4(39.75, 49, 0.15, 0.79), vec4(39.9, 50, 0.45, 0.79), vec4(40.35, 57, 0.15, 0.79), vec4(40.5, 59, 0.15, 0.79), vec4(40.65, 60, 0.15, 0.79), vec4(40.8, 62, 0.15, 0.79), vec4(40.95, 64, 0.15, 0.79), vec4(41.1, 66, 0.15, 0.79), vec4(41.25, 62, 0.15, 0.79), vec4(41.4, 67, 0.15, 0.79), vec4(41.55, 66, 0.15, 0.79), vec4(41.7, 67, 0.15, 0.79), vec4(41.85, 62, 0.15, 0.79), vec4(42.0, 59, 0.15, 0.79), vec4(42.15, 62, 0.15, 0.79), vec4(42.3, 55, 0.15, 0.79), vec4(42.45, 59, 0.15, 0.79), vec4(42.6, 50, 0.15, 0.79), vec4(42.75, 55, 0.15, 0.79), vec4(42.9, 47, 0.15, 0.79), vec4(43.05, 50, 0.15, 0.79), vec4(43.2, 43, 0.3, 0.79), vec4(43.5, 55, 0.3, 0.79), vec4(43.8, 59, 0.3, 0.79), vec4(44.1, 55, 0.3, 0.79), vec4(44.4, 43, 0.3, 0.79), vec4(44.7, 55, 0.3, 0.79), vec4(45.0, 42, 0.3, 0.79), vec4(45.3, 54, 0.3, 0.79), vec4(45.6, 57, 0.3, 0.79), vec4(45.9, 54, 0.3, 0.79), vec4(46.2, 42, 0.3, 0.79), vec4(46.5, 54, 0.3, 0.79), vec4(46.8, 40, 0.3, 0.79), vec4(47.1, 52, 0.3, 0.79), vec4(47.4, 55, 0.3, 0.79), vec4(47.7, 52, 0.3, 0.79), vec4(48.0, 40, 0.3, 0.79), vec4(48.3, 55, 0.3, 0.79), vec4(48.6, 45, 0.3, 0.79), vec4(48.9, 52, 0.3, 0.79), vec4(49.2, 55, 0.3, 0.79), vec4(49.5, 52, 0.3, 0.79), vec4(49.8, 45, 0.3, 0.79), vec4(50.1, 55, 0.3, 0.79), vec4(50.4, 54, 0.15, 0.79), vec4(50.55, 57, 0.15, 0.79), vec4(50.7, 62, 0.15, 0.79), vec4(50.85, 66, 0.15, 0.79), vec4(51.0, 69, 0.15, 0.79), vec4(51.15, 66, 0.15, 0.79), vec4(51.3, 62, 0.15, 0.79), vec4(51.45, 57, 0.15, 0.79), vec4(51.6, 54, 0.15, 0.79), vec4(51.75, 57, 0.15, 0.79), vec4(51.9, 50, 0.15, 0.79), vec4(52.05, 54, 0.15, 0.79), vec4(52.2, 55, 0.15, 0.79), vec4(52.35, 59, 0.15, 0.79), vec4(52.5, 62, 0.15, 0.79), vec4(52.65, 67, 0.15, 0.79), vec4(52.8, 71, 0.15, 0.79), vec4(52.95, 67, 0.15, 0.79), vec4(53.1, 62, 0.15, 0.79), vec4(53.25, 59, 0.15, 0.79), vec4(53.4, 55, 0.15, 0.79), vec4(53.55, 59, 0.15, 0.79), vec4(53.7, 52, 0.15, 0.79), vec4(53.85, 55, 0.15, 0.79), vec4(54.0, 57, 0.3, 0.79), vec4(54.3, 61, 0.3, 0.79), vec4(54.6, 62, 0.15, 0.79), vec4(54.75, 57, 0.15, 0.79), vec4(54.9, 54, 0.15, 0.79), vec4(55.05, 50, 0.15, 0.79), vec4(55.2, 57, 0.3, 0.79), vec4(55.5, 45, 0.3, 0.79), vec4(55.8, 38, 0.15, 0.79), vec4(55.95, 50, 0.15, 0.79), vec4(56.1, 52, 0.15, 0.79), vec4(56.25, 54, 0.15, 0.79), vec4(56.4, 55, 0.15, 0.79), vec4(56.55, 57, 0.15, 0.79), vec4(56.7, 59, 0.15, 0.79), vec4(56.85, 61, 0.15, 0.79), vec4(57.0, 62, 0.6, 0.79), vec4(57.6, 38, 0.3, 0.79), vec4(57.9, 54, 0.15, 0.79), vec4(58.05, 52, 0.15, 0.79), vec4(58.2, 54, 0.3, 0.79), vec4(58.5, 50, 0.3, 0.79), vec4(58.8, 38, 0.3, 0.79), vec4(59.1, 54, 0.3, 0.79), vec4(59.4, 43, 0.3, 0.79), vec4(59.7, 59, 0.15, 0.79), vec4(59.85, 57, 0.15, 0.79), vec4(60.0, 59, 0.3, 0.79), vec4(60.3, 55, 0.3, 0.79), vec4(60.6, 43, 0.3, 0.79), vec4(60.9, 59, 0.3, 0.79), vec4(61.2, 48, 0.3, 0.79), vec4(61.5, 60, 0.15, 0.79), vec4(61.65, 59, 0.15, 0.79), vec4(61.8, 60, 0.3, 0.79), vec4(62.1, 54, 0.3, 0.79), vec4(62.4, 57, 0.3, 0.79), vec4(62.7, 60, 0.3, 0.79), vec4(63.0, 57, 0.3, 0.79), vec4(63.3, 54, 0.3, 0.79), vec4(63.6, 51, 0.15, 0.79), vec4(63.75, 47, 0.15, 0.79), vec4(63.9, 51, 0.15, 0.79), vec4(64.05, 54, 0.15, 0.79), vec4(64.2, 59, 0.15, 0.79), vec4(64.35, 63, 0.15, 0.79), vec4(64.5, 66, 0.15, 0.79), vec4(64.65, 69, 0.15, 0.79), vec4(64.8, 67, 0.45, 0.79), vec4(65.25, 66, 0.15, 0.79), vec4(65.4, 67, 0.45, 0.79), vec4(65.85, 54, 0.15, 0.79), vec4(66.0, 55, 0.45, 0.79), vec4(66.45, 47, 0.15, 0.79), vec4(66.6, 48, 0.45, 0.79), vec4(67.05, 71, 0.15, 0.79), vec4(67.2, 72, 0.45, 0.79), vec4(67.65, 59, 0.15, 0.79), vec4(67.8, 60, 0.45, 0.79), vec4(68.25, 52, 0.15, 0.79), vec4(68.4, 51, 0.3, 0.79), vec4(68.7, 57, 0.3, 0.79), vec4(69.0, 55, 0.3, 0.79), vec4(69.3, 46, 0.3, 0.79), vec4(69.6, 47, 0.3, 0.79), vec4(69.9, 54, 0.3, 0.79), vec4(70.2, 52, 0.3, 0.79), vec4(70.5, 55, 0.15, 0.79), vec4(70.65, 54, 0.15, 0.79), vec4(70.8, 55, 0.3, 0.79), vec4(71.1, 52, 0.3, 0.79), vec4(71.4, 40, 0.3, 0.79), vec4(71.85, 50, 0.15, 0.79), vec4(72.0, 48, 0.15, 0.79), vec4(72.15, 52, 0.15, 0.79), vec4(72.3, 57, 0.15, 0.79), vec4(72.45, 60, 0.15, 0.79), vec4(72.6, 64, 0.15, 0.79), vec4(72.75, 60, 0.15, 0.79), vec4(72.9, 57, 0.15, 0.79), vec4(73.05, 52, 0.15, 0.79), vec4(73.2, 48, 0.15, 0.79), vec4(73.35, 52, 0.15, 0.79), vec4(73.5, 50, 0.15, 0.79), vec4(73.65, 48, 0.15, 0.79), vec4(73.8, 47, 0.15, 0.79), vec4(73.95, 50, 0.15, 0.79), vec4(74.1, 55, 0.15, 0.79), vec4(74.25, 59, 0.15, 0.79), vec4(74.4, 62, 0.15, 0.79), vec4(74.55, 59, 0.15, 0.79), vec4(74.7, 55, 0.15, 0.79), vec4(74.85, 50, 0.15, 0.79), vec4(75.0, 47, 0.15, 0.79), vec4(75.15, 50, 0.15, 0.79), vec4(75.3, 48, 0.15, 0.79), vec4(75.45, 47, 0.15, 0.79), vec4(75.6, 45, 0.3, 0.79), vec4(75.9, 48, 0.3, 0.79), vec4(76.2, 52, 0.3, 0.79), vec4(76.5, 55, 0.3, 0.79), vec4(76.8, 54, 0.3, 0.79), vec4(77.1, 52, 0.3, 0.79), vec4(77.4, 50, 0.3, 0.79), vec4(77.7, 54, 0.3, 0.79), vec4(78.0, 57, 0.3, 0.79), vec4(78.3, 60, 0.3, 0.79), vec4(78.6, 59, 0.3, 0.79), vec4(78.9, 57, 0.3, 0.79), vec4(79.2, 55, 0.3, 0.79), vec4(79.5, 59, 0.3, 0.79), vec4(79.8, 62, 0.3, 0.79), vec4(80.1, 65, 0.3, 0.79), vec4(80.4, 64, 0.3, 0.79), vec4(80.7, 62, 0.3, 0.79), vec4(81.0, 60, 0.3, 0.79), vec4(81.3, 64, 0.3, 0.79), vec4(81.6, 66, 0.3, 0.79), vec4(81.9, 68, 0.3, 0.79), vec4(82.2, 69, 0.3, 0.79), vec4(82.5, 67, 0.3, 0.79), vec4(82.8, 66, 0.3, 0.79), vec4(83.1, 62, 0.3, 0.79), vec4(83.4, 67, 0.3, 0.79), vec4(83.7, 55, 0.3, 0.79), vec4(84.0, 62, 0.3, 0.79), vec4(84.3, 50, 0.3, 0.79), vec4(84.6, 55, 0.15, 0.79), vec4(84.75, 43, 0.15, 0.79), vec4(84.9, 45, 0.15, 0.79), vec4(85.05, 47, 0.15, 0.79), vec4(85.2, 48, 0.15, 0.79), vec4(85.35, 50, 0.15, 0.79), vec4(85.5, 52, 0.15, 0.79), vec4(85.65, 54, 0.15, 0.79), vec4(85.8, 55, 0.6, 0.79), vec4(86.4, 38, 0.3, 0.79), vec4(86.7, 54, 0.15, 0.79), vec4(86.85, 52, 0.15, 0.79), vec4(87.0, 54, 0.3, 0.79), vec4(87.3, 50, 0.3, 0.79), vec4(87.6, 38, 0.3, 0.79), vec4(87.9, 54, 0.3, 0.79), vec4(88.2, 43, 0.3, 0.79), vec4(88.5, 59, 0.15, 0.79), vec4(88.65, 57, 0.15, 0.79), vec4(88.8, 59, 0.3, 0.79), vec4(89.1, 55, 0.3, 0.79), vec4(89.4, 43, 0.3, 0.79), vec4(89.7, 59, 0.3, 0.79), vec4(90.0, 48, 0.3, 0.79), vec4(90.3, 60, 0.15, 0.79), vec4(90.45, 59, 0.15, 0.79), vec4(90.6, 60, 0.3, 0.79), vec4(90.9, 54, 0.3, 0.79), vec4(91.2, 57, 0.3, 0.79), vec4(91.5, 60, 0.3, 0.79), vec4(91.8, 57, 0.3, 0.79), vec4(92.1, 54, 0.3, 0.79), vec4(92.4, 51, 0.15, 0.79), vec4(92.55, 47, 0.15, 0.79), vec4(92.7, 51, 0.15, 0.79), vec4(92.85, 54, 0.15, 0.79), vec4(93.0, 59, 0.15, 0.79), vec4(93.15, 63, 0.15, 0.79), vec4(93.3, 66, 0.15, 0.79), vec4(93.45, 69, 0.15, 0.79), vec4(93.6, 67, 0.45, 0.79), vec4(94.05, 66, 0.15, 0.79), vec4(94.2, 67, 0.45, 0.79), vec4(94.65, 54, 0.15, 0.79), vec4(94.8, 55, 0.45, 0.79), vec4(95.25, 47, 0.15, 0.79), vec4(95.4, 48, 0.45, 0.79), vec4(95.85, 71, 0.15, 0.79), vec4(96.0, 72, 0.45, 0.79), vec4(96.45, 59, 0.15, 0.79), vec4(96.6, 60, 0.45, 0.79), vec4(97.05, 52, 0.15, 0.79), vec4(97.2, 51, 0.3, 0.79), vec4(97.5, 57, 0.3, 0.79), vec4(97.8, 55, 0.3, 0.79), vec4(98.1, 46, 0.3, 0.79), vec4(98.4, 47, 0.3, 0.79), vec4(98.7, 54, 0.3, 0.79), vec4(99.0, 52, 0.3, 0.79), vec4(99.3, 55, 0.15, 0.79), vec4(99.45, 54, 0.15, 0.79), vec4(99.6, 55, 0.3, 0.79), vec4(99.9, 52, 0.3, 0.79), vec4(100.2, 40, 0.3, 0.79), vec4(100.65, 50, 0.15, 0.79), vec4(100.8, 48, 0.15, 0.79), vec4(100.95, 52, 0.15, 0.79), vec4(101.1, 57, 0.15, 0.79), vec4(101.25, 60, 0.15, 0.79), vec4(101.4, 64, 0.15, 0.79), vec4(101.55, 60, 0.15, 0.79), vec4(101.7, 57, 0.15, 0.79), vec4(101.85, 52, 0.15, 0.79), vec4(102.0, 48, 0.15, 0.79), vec4(102.15, 52, 0.15, 0.79), vec4(102.3, 50, 0.15, 0.79), vec4(102.45, 48, 0.15, 0.79), vec4(102.6, 47, 0.15, 0.79), vec4(102.75, 50, 0.15, 0.79), vec4(102.9, 55, 0.15, 0.79), vec4(103.05, 59, 0.15, 0.79), vec4(103.2, 62, 0.15, 0.79), vec4(103.35, 59, 0.15, 0.79), vec4(103.5, 55, 0.15, 0.79), vec4(103.65, 50, 0.15, 0.79), vec4(103.8, 47, 0.15, 0.79), vec4(103.95, 50, 0.15, 0.79), vec4(104.1, 48, 0.15, 0.79), vec4(104.25, 47, 0.15, 0.79), vec4(104.4, 45, 0.3, 0.79), vec4(104.7, 48, 0.3, 0.79), vec4(105.0, 52, 0.3, 0.79), vec4(105.3, 55, 0.3, 0.79), vec4(105.6, 54, 0.3, 0.79), vec4(105.9, 52, 0.3, 0.79), vec4(106.2, 50, 0.3, 0.79), vec4(106.5, 54, 0.3, 0.79), vec4(106.8, 57, 0.3, 0.79), vec4(107.1, 60, 0.3, 0.79), vec4(107.4, 59, 0.3, 0.79), vec4(107.7, 57, 0.3, 0.79), vec4(108.0, 55, 0.3, 0.79), vec4(108.3, 59, 0.3, 0.79), vec4(108.6, 62, 0.3, 0.79), vec4(108.9, 65, 0.3, 0.79), vec4(109.2, 64, 0.3, 0.79), vec4(109.5, 62, 0.3, 0.79), vec4(109.8, 60, 0.3, 0.79), vec4(110.1, 64, 0.3, 0.79), vec4(110.4, 66, 0.3, 0.79), vec4(110.7, 68, 0.3, 0.79), vec4(111.0, 69, 0.3, 0.79), vec4(111.3, 67, 0.3, 0.79), vec4(111.6, 66, 0.3, 0.79), vec4(111.9, 62, 0.3, 0.79), vec4(112.2, 67, 0.3, 0.79), vec4(112.5, 55, 0.3, 0.79), vec4(112.8, 62, 0.3, 0.79), vec4(113.1, 50, 0.3, 0.79), vec4(113.4, 55, 0.15, 0.79), vec4(113.55, 43, 0.15, 0.79), vec4(113.7, 45, 0.15, 0.79), vec4(113.85, 47, 0.15, 0.79), vec4(114.0, 48, 0.15, 0.79), vec4(114.15, 50, 0.15, 0.79), vec4(114.3, 52, 0.15, 0.79), vec4(114.45, 54, 0.15, 0.79), vec4(114.6, 55, 1.25, 0.79));\nconst int sizes[10] = int[10](596,508,1,1,1,1,1,1,1,1);\n\nvec4 getNoteData(int channel, int n) {\n    switch(channel) {\n        case 0: return notes0[n];\n        case 1: return notes1[n];\n    }\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 getNoteBox(vec4 note, float t) {\n    t -= INTRO;\n    float m = 60. / BPM;\n    note.xz *= m;\n    float interval = .5 / 88.; \n    return vec4(note.x + note.z / 2. - t,                        \n               (note.y - CENTER) * interval * 2. - interval / 2.,\n                note.z / 2.,\n                interval * 2.);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdNote(in vec2 p, in vec2 wh) {\n    return sdBox(p, wh);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat noteToFrequency(float n) {\n    return 440. * exp2((n-60.)/12.);\n}", "sound_code": "#define pi 3.14159\n\n\n// Various temperaments, expressed as the number of cents from which they differ\n// from the equal temperament.\n// https://en.wikipedia.org/wiki/Musical_temperament\n\n// 12-tone equal temperament\nconst float[] adjustment = float[12](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\n\n// Five-limit tuning: unpleasant intervals appear when modulating\n//const float[] adjustment = float[12](0., 12., 4., 16., -14., -2., -10., 2., 14., -16., 18., -12.);\n\n// 1/4 comma meantone\n//const float[] adjustment = float[12](0., 16., -6., 10., -13., 3., -19., -3., 13., -10., 6., -16.);\n\nfloat pitch(float i)\n{\n    // Chromatic scale degree within the B minor scale.\n    // Goes from 0 (note B) to 11 (note A#).\n    int degree = int(mod(i - 6., 12.));\n    // Baroque tuning (middle A = 415hz vs 440hz)\n    // Adjust each degree with the number of cents prescribed.\n    return 440. * pow(2., (i - 69. + 0.01*adjustment[degree]) / 12.);\n}\n\nvec2 wave(vec2 f, vec2 a, float time)\n{\n    vec2 w = 2.*pi*fract(f * time);\n    //float v = pow(abs(sin(w / 2.)), 8.) - .5;\n    //float v = pow(max(0., (sin(w) + 1.) / 2.), 2.) - .5;\n    vec2 sw = sin(w/2.);\n    vec2 sw2 = sw*sw;\n    vec2 v = sw2*sw2 - .375; // Remove DC offset\n    //vec2 v = sw2*sw2*sw2 - .3125; // Remove DC offset\n    a *= sqrt(clamp(800./f, 1., 10.));\n    return a * v;\n}\n\nvec2 organ(vec2 f, float time)\n{\n    vec2 sound = vec2(0);\n    sound += wave(f, vec2(.08), time);\n    sound += wave(f * 2., vec2(0.8,1)*.01, time);\n    sound += wave(f * 4., vec2(.004), time);\n    sound += wave(f * .5, vec2(1,0.5)*.008, time);\n    return sound;\n}\n\n\nvec2 mainSound(int samp, float time)\n{\n    vec2 sound = vec2(0);\n\n    float t = time - INTRO;\n    t *= BPM / 60.;\n    for(int channel = 0; channel < CHANNELS; channel++)\n        for (int i=min(0, int(iSampleRate)) ; i<sizes[channel]; ++i)\n        {\n            vec4 note = getNoteData(channel, i);\n            note.y;\n            if (note.w == -1.)\n                continue;\n            if (note.x < t && t < note.x + note.z  + 5.)\n            {\n                float f = pitch(note.y);\n                // Add random pitch variation per note,\n                // so that if several notes with the same pitch are\n                // played at the same time, they are still\n                // decorrelated.\n                // Otherwise the combined tone sounds too loud\n                // (amplitude proportional to n, instead of sqrt(n)).\n                f += 0.3*sin(float(i));\n\n                float pos = sin(note.w);\n                vec2 pan = sqrt(vec2(1) + 0.5*vec2(1,-1)*pos);\n\n\n                float t_in = t - note.x; // Time since attack\n                float t_out = t_in - note.z; // Time since release\n                float env = smoothstep(0., .05, t_in) * smoothstep(.05,0.,t_out);\n                sound += pan*env*organ(vec2(f), time);\n                float rtime = 0.1 + smoothstep(100.,400.,f);\n                float rtau = 99./rtime; // Reverb decay time: lower for bass notes\n                float env_verb = clamp(1.-exp(-t_in*rtau),0.,1.)*clamp(exp(-t_out*rtau),0.,1.);\n                sound += 0.5 * rtime * env_verb * organ(f+vec2(-.2,.32), time);\n\n            }\n        }\n\n    return sound;\n}\n", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 104, 104, 137], [139, 139, 173, 173, 231], [233, 233, 290, 340, 2086]], "test": "untested"}
{"id": "dsGSDm", "name": "True Bresenham Lines in 30 LOC", "author": "PureAsbestos", "description": "Parallel line rasterization based on DDA / linear interpolation\nUnlike some GLSL line-drawing methods, this will always produce correct results with no breaks\nAlgorithm adapted from here: https://www.redblobgames.com/grids/line-drawing.html#interpolation", "tags": ["line", "lines", "demo", "lerp", "dda", "rasterization", "algorithm", "bresenham"], "likes": 7, "viewed": 367, "published": 3, "date": "1682095577", "time_retrieved": "2024-07-30T17:59:36.011718", "image_code": "// Created by PureAsbestos, 2023\n// Free for any use. Credit appreciated but not required.\n\nfloat diag(vec2 p0, vec2 p1)\n{\n    vec2 d = abs(p1 - p0);\n    return max(d.x, d.y);\n}\n\nfloat line(vec2 p, vec2 p0, vec2 p1)\n{\n    float stp = diag(p,p0);\n    float n = diag(p0,p1);\n    float t = (n==0.0)? 0.0 : stp/n; \n\n    vec2 pt = mix(p0, p1, t);\n    vec2 d = abs(p - round(pt));\n    return (d.x < 0.5\n         && d.y < 0.5\n         && stp <= n)\n          ? 1.0 : 0.0 ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n    fragColor.g = line(round(fragCoord/4.0), round(iResolution.xy/8.0), round(iMouse.xy/4.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 122, 122, 177], [179, 179, 217, 217, 466], [468, 468, 525, 525, 653]], "test": "untested"}
{"id": "dlcGzN", "name": "Thomas Knoll's Pattern Dithering", "author": "matejloub", "description": "A shader adaptation of Thomas Knoll's Pattern Dithering algorithm, as seen in Adobe Photoshop. It is a type of threshold-based dither that can accommodate arbitrary palettes. It works by selecting the output pixel colour from a set of weighted candidates.", "tags": ["threshold", "dither", "palette", "pattern", "bayer", "ordered", "knoll"], "likes": 10, "viewed": 578, "published": 3, "date": "1682087193", "time_retrieved": "2024-07-30T17:59:36.915302", "image_code": "// Algorithm configuration. Feel free to tinker with some of the values to explore the algorithm!\n#define N 32                   // Number of iterations per fragment (higher N = more samples)\n#define PALETTE_SIZE 16        // Number of colours in the palette\n#define ERROR_FACTOR 0.8       // Quantisation error coefficient (0 = no dithering)\n#define PIXEL_SIZE 2.0         // Size of pixels in the shader output\n#define ENABLE_SORT            // Choose whether to enable the sorting procedures\n#define OPTIMISED_KNOLL        // Run an optimised version of the algorithm\n\n#define INFINITY 3.4e38        // 'Infinity'\n\n// Helper macro to convert an RGB hex code to a vec3\n#define RGB8(h) (vec3(h >> 16 & 0xFF, h >> 8 & 0xFF, h & 0xFF) / 255.0) \n\n    /*\n    Thomas Knoll's Pattern Dithering algorithm[1]. For every iteration, we find the closest palette \n    colour to the 'goal' colour, which is first set to the current fragment colour. When the closest\n    colour is found, we record it as the candidate for this iteration and calculate the quantisation\n    error (the difference between it and our fragment colour). The sum of the quantisation error\n    and the current fragment is then used as the goal colour for the next iteration. Every time \n    we find a new candidate, we accumulate the total quantisation error. At the end, the frequency\n    of each candidate represents the proportion of its contribution to the input colour. An error\n    coefficient controls the intensity of the dither.\n    \n    The original algorithm maintains an array of candidates of size N, where N is the number of\n    iterations. The colour of the final pixel is selected by randomly (or psuedo-randomly) indexing\n    into the array of candidates - in this case, we use a texture, although any noise function will \n    also do. An intermediate step involves sorting the candidate array by luminance before we select \n    the final colour. This is done to ensure that candidate colours are in a consistent relative position \n    in the array, and it also ensures that colours with similar luminance values appear further apart \n    in the final image, minimising the appearance of 'clumps'.\n    \n    Included is an optimised version of the algorithm which forgoes the candidate array in favour of an \n    array representing the frequency of each palette colour by index. Selecting from the frequency array \n    is done by obtaining a random value from 0 to N-1 and summing the cumulative frequency until the sum \n    is greater than the value. Instead of sorting the entire array of candidates each time, we simply\n    pre-sort the palette. For large values of N, the performance difference is quite noticeable.\n    \n    [1] https://patents.google.com/patent/US6606166B1/en\n    */\n\n// Using the PICO-8 palette. Optimised version uses a pre-sorted palette.\n#if defined OPTIMISED_KNOLL\nconst vec3 palette[PALETTE_SIZE] = vec3[](\n    RGB8(0x000000), RGB8(0x1D2B53), RGB8(0x7E2553), RGB8(0xFF004D),\n    RGB8(0x5F574F), RGB8(0xAB5236), RGB8(0x008751), RGB8(0x83769C),\n    RGB8(0xFF77A8), RGB8(0xFFA300), RGB8(0x29ADFF), RGB8(0xC2C3C7),\n    RGB8(0x00E436), RGB8(0xFFCCAA), RGB8(0xFFEC27), RGB8(0xFFF1E8));\n#else\nconst vec3 palette[PALETTE_SIZE] = vec3[](\n    RGB8(0x000000), RGB8(0x1D2B53), RGB8(0x7E2553), RGB8(0x008751),\n    RGB8(0xAB5236), RGB8(0x5F574F), RGB8(0xC2C3C7), RGB8(0xFFF1E8),\n    RGB8(0xFF004D), RGB8(0xFFA300), RGB8(0xFFEC27), RGB8(0x00E436),\n    RGB8(0x29ADFF), RGB8(0x83769C), RGB8(0xFF77A8), RGB8(0xFFCCAA));\n#endif\n\n// Convert a gamma-encoded sRGB value to linear RGB\n// https://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html\nvec3 sRGBtoLinear(vec3 colour)\n{\n    return colour * (colour * (colour * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\n// Get the luminance value of a given colour\nfloat getLuminance(vec3 colour)\n{\n    return colour.r * 0.299 + colour.g * 0.587 + colour.b * 0.114;\n}\n\n// Find the closest palette colour to the input colour via brute force\nint getClosestColour(vec3 inputColour)\n{\n    float closestDistance = INFINITY;\n    int closestColour = 0;\n    \n    for (int i = 0; i < PALETTE_SIZE; i++)\n    {\n        vec3 difference = inputColour - sRGBtoLinear(palette[i]);\n        float distance = dot(difference, difference);\n        \n        if (distance < closestDistance)\n        {\n            closestDistance = distance;\n            closestColour = i;\n        }\n    }\n    \n    return closestColour;\n}\n\n// Sample the value in the threshold matrix for the current pixel\nfloat sampleThreshold(vec2 coord)\n{\n    // Sample the centre of the texel\n    ivec2 pixel = ivec2(coord / PIXEL_SIZE) % ivec2(iChannelResolution[1]);\n    vec2 uv = vec2(pixel) / iChannelResolution[1].xy;\n    vec2 offset = 0.5 / iChannelResolution[1].xy;\n    return texture(iChannel1, uv + offset).x * float(N - 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the colour for this fragment\n    vec2 pixelSizeNormalised = PIXEL_SIZE * (1.0 / iResolution.xy);\n    vec2 uv = pixelSizeNormalised * floor(fragCoord / iResolution.xy / pixelSizeNormalised);\n    vec3 colour = texture(iChannel0, uv).rgb;\n\n    // Screen wipe effect\n    if (fragCoord.x < iMouse.x) \n    {\n        fragColor = vec4(colour, 1.0);\n        return;\n    }\n  \n    // ====================================== //\n    // Actual dithering algorithm starts here //\n    // ====================================== //\n     \n#if defined OPTIMISED_KNOLL\n    \n    // Accumulate the frequencies for each palette colour\n    int frequency[PALETTE_SIZE];\n    vec3 quantError = vec3(0, 0, 0);\n    vec3 colourLinear = sRGBtoLinear(colour);\n\n    for (int i = 0; i < N; i++)\n    {\n        vec3 goalColour = colourLinear + quantError * ERROR_FACTOR;\n        int closestColour = getClosestColour(goalColour);\n        \n        frequency[closestColour] += 1;\n        quantError += colourLinear - sRGBtoLinear(palette[closestColour]);\n    }\n\n    // Select the output colour by accumulating the frequencies until the candidate is found\n    int randomValue = int(sampleThreshold(fragCoord));\n    int cumulativeSum = 0;\n \n    for (int i = 0; i < PALETTE_SIZE; i++)\n    {\n        cumulativeSum += frequency[i];\n        \n        if (randomValue < cumulativeSum)\n        {\n             fragColor = vec4(palette[i], 1.0);\n             return;\n        }\n    }\n    return;\n    \n#else // !OPTIMISED KNOLL\n\n    // Fill the candidate array\n    int candidates[N];\n    vec3 quantError = vec3(0, 0, 0);\n    vec3 colourLinear = sRGBtoLinear(colour);\n\n    for (int i = 0; i < N; i++)\n    {\n        vec3 goalColour = colourLinear + quantError * ERROR_FACTOR;\n        int closestColour = getClosestColour(goalColour);\n        \n        candidates[i] = closestColour;\n        quantError += colourLinear - sRGBtoLinear(palette[closestColour]);\n    }\n      \n#if defined ENABLE_SORT\n\n    // Sort the candidate array by luminance (bubble sort)\n    for (int i = N - 1; i > 0; i--) \n    {\n      for (int j = 0; j < i; j++) \n      {\n          if (getLuminance(palette[candidates[j]]) > getLuminance(palette[candidates[j+1]])) \n          { \n              // Swap the candidates\n              int t = candidates[j]; \n              candidates[j] = candidates[j+1]; \n              candidates[j+1] = t; \n          }\n      }\n    }\n    \n#endif // ENABLE_SORT\n\n    // Select from the candidate array, using the value in the threshold matrix\n    int index = int(sampleThreshold(fragCoord));\n    fragColor = vec4(palette[candidates[index]], 1.0);\n    \n#endif // OPTIMISED KNOLL\n} \n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3516, 3644, 3676, 3676, 3761], [3763, 3808, 3841, 3841, 3910], [3912, 3983, 4023, 4023, 4441], [4443, 4509, 4544, 4582, 4825], [4827, 4827, 4884, 4924, 7516]], "test": "untested"}
{"id": "Dt33z7", "name": "Lava?", "author": "i11212", "description": "Free to use", "tags": ["ex"], "likes": 11, "viewed": 271, "published": 3, "date": "1682084889", "time_retrieved": "2024-07-30T17:59:37.770016", "image_code": "/*\nMade By I11212\nTwitter: https://twitter.com/i11212_?t=us2GzKso5JLrTiwYIxuueg&s=09\nYoutube: https://youtube.com/channel/UCg21GlDi4TtGe-9CNpSlR9A\n*/\n\n#define lavacolor vec3(1,0.25,0)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nhighp vec3 getlava(\n\thighp vec2 x){\nhighp vec3 col;\nfor(int i = 0; i<16; i++){\nx *= 1.5;\nx.x += iTime/64.0;\nx *= rot(1.0);\nx += (sin(x.x+x.y+x.x*2.0-iTime/4.0)+\n\tcos(x.x*4.0))/16.0;\ncol.r += sin(x.x*2.0)*cos(x.y+iTime);\ncol.g += cos(x.x+x.y-cos(x.x-x.y+iTime*\n\tfloat(i)-x.y+x.x*4.0));\ncol.b += cos(x.x+x.y+iTime+cos(x.x-x.y)+\n\tiTime);\n\t}\nreturn col;\n\t}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / (\n\tiResolution.x, iResolution.y);\n\nhighp vec3 col = getlava(uv);\n\n\tfragColor = vec4(length(col/3.0)*lavacolor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt33z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 644, 644, 789]], "test": "untested"}
{"id": "clcGRM", "name": "Zellij pattern 6 (music)", "author": "jarble", "description": "A zellij tile pattern.\nClick and drag to move around.", "tags": ["fractal", "mosaic", "zellige"], "likes": 4, "viewed": 215, "published": 3, "date": "1682058559", "time_retrieved": "2024-07-30T17:59:38.660635", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    //uv = mod(uv,1.)+vec2(1.,0.);\n    for(int k = 0; k < 12; k++){\n        uv =\n            abs(.5-uv+t2)/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv+.5).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx-1.).yx\n        ;\n        {uv=uv*sign(uv.y-uv.x);}\n        col.x =\n            max(sign(uv.x-t2.y),col.x)\n        ;\n        //if(uv.y<0.)\n        col =\n            abs(col.yzx-float(b)/2.)\n        ;\n        //if(t2.x>t2.y) uv.x -= .5;\n\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float fmod(float a, float b,float f1){\n    //a += floor(a/b)/b*8.;\n    return\n        mod(floor(a/f1),b)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  //time *= 2.;\n  float\n  s1 = 8.,\n  f1 = pow(2.,2.+mod(floor(time/2.),3.)),\n  t=time/(1.+fmod(time*f1,2.,f1)),\n  m3 =\n      floor(fmod(floor(t*f1+fmod(t*s1,s1,f1)),s1,f1)/2.)\n  ;\n  t *= s1*s1/(1.+fmod(t*f1/s1,2.,f1));\n  float a=2.*sqrt((1.-sqrt(max(fract(t/s1/s1/2.),fract(t/s1/2.))))),\n  nb = pow(2.,(m3+1. + fmod(t/s1,s1,f1))/5.+6.5);\n  return abs(.5-vec2(fract(time*nb*.998),fract(time*nb)))*a;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcGRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1085]], "test": "untested"}
{"id": "mtt3RN", "name": "LCD Sub-pixel zoom effect", "author": "lazergenix", "description": "Wanted an effect to mimic what it is like to zoom in on an LCD monitor.\nDid not find an effect like this, so I decided to make it myself. Feel free to use!", "tags": ["2d", "effect"], "likes": 6, "viewed": 258, "published": 3, "date": "1682041935", "time_retrieved": "2024-07-30T17:59:39.522332", "image_code": "// LCD Sub-pixel zoom effect\n//\n// Note: Qaulity could be greatly improved (on small zoom values) by sampling\n//         the texture multiple times, but im too lazy to implement that\n\n/*\nMIT No Attribution License\nCopyright 2023 Lazergenix <lazergenixdev@gmail.com>\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the Software), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so.\n\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n// Here are some constants to play around with\n#define EFFECT_DROPOUT 0.254\n#define EFFECT_RANGE   3.0\n#define ZOOM_CENTER    float2(0.5, 0.5)\n#define HORZ_SPACING   0.02 * 3.0\n#define VERT_SPACING   0.05\n\n\n// I DESPISE GLSL (this message was made by hlsl gang)\n#define float4 vec4\n#define float3 vec3\n#define float2 vec2\n#define SAMPLE0(UV) texture(iChannel0, UV)\n#define saturate(X) clamp(X, 0.0, 1.0)\n#define frac fract\n#define COLOR_BLACK float3(0.0,0.0,0.0)\n#define COLOR_WHITE float3(1.0,1.0,1.0)\n#define lerp mix\n\nfloat3 subpixel(float2 uv, float ZoomLevel) {\n    float2 center = ZOOM_CENTER;\n\n    // Scale UV based on our Zoom Level\n    uv -= center;\n    uv *= 1.0/ZoomLevel;\n    uv += center;\n\n    // Get color at the UV Coords\n    float3 color = SAMPLE0(uv).rgb;\n\n    // calculate fragCoords\n    float2 fragCoords = frac(uv * iResolution.xy);\n    \n    // calculate which subpixel we are in\n    int i = int(fragCoords.x * 3.0);\n\n    float3 output_color;\n    float value;\n\n    // calculate 0.0 - 1.0 range for every subpixel\n    float a = frac(fragCoords.x * 3.0);\n    float b = fragCoords.y;\n    \n    \n    // output black if we are in-between sub pixels\n    if( a < HORZ_SPACING || a > (1.0-HORZ_SPACING) || b < VERT_SPACING || b > (1.0-VERT_SPACING) )\n        output_color = COLOR_BLACK;\n        \n    else {\n        switch(i) {\n        \n            // Map the given color channel to a color, so that brighter colors are more desaturated and brighter\n            \n            // RED\n            case 0: { float c = color.r; output_color = float3( min(1.0, 2.0*c),     max(0.0, 2.0*c-1.0), max(0.0, 2.0*c-1.0)); break; } \n            \n            // GREEN\n            case 1: { float c = color.g; output_color = float3( max(0.0, 2.0*c-1.0), min(1.0, 2.0*c),     max(0.0, 2.0*c-1.0)); break; }\n            \n            // BLUE\n            case 2: { float c = color.b; output_color = float3( max(0.0, 2.0*c-1.0), max(0.0, 2.0*c-1.0), min(1.0, 2.0*c)    ); break; }\n            \n            default: output_color = COLOR_WHITE; break; // This case should never be reached\n        };\n    }\n    \n\n    // Only apply the subpixel effect when reached a certain zoom level\n    float effect_amount = saturate((ZoomLevel-1.0) / (EFFECT_RANGE) - EFFECT_DROPOUT);\n    \n    return lerp(color, output_color, effect_amount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float2 tc = fragCoord.xy / iResolution.xy;\n    \n    //float zoom = exp(iMouse.x/100.0); // control zoom with mouse X\n    float zoom = exp( (sin(iTime)+1.0) * 2.4 );\n\n\tfloat3 color = subpixel(tc, zoom);\n\tfragColor = float4(color, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtt3RN.jpg", "access": "api", "license": "mit-0", "functions": [[1659, 1659, 1704, 1704, 3456], [3458, 3458, 3513, 3513, 3754]], "test": "untested"}
{"id": "mttGRN", "name": "Normalbrot", "author": "RandomScientist", "description": "Uses the normal mapping algorithms from https://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set#Normal_map_effect . Click and drag to pan, Shift + W/S to zoom, hit c for a center dot for screenshots :)", "tags": ["fractal", "mandelbrot", "normals"], "likes": 10, "viewed": 295, "published": 3, "date": "1682037096", "time_retrieved": "2024-07-30T17:59:40.620396", "image_code": "precision highp float;\n\n\nfloat mag(vec2 a){ return sqrt(dot(a,a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 c = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(keyDown(67)&&(mag(fragCoord-(iResolution.xy-iResolution.xy/2.)))<2.) c = vec4(1,0,0,1.0);\n    // Output to screen\n    fragColor = c;\n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst ivec2 POSITION = ivec2(1, 1);\nconst ivec2 ZOOM = ivec2(1,2);\nconst ivec2 BPOS = ivec2(2,2);\nconst ivec2 DPOSITION = ivec2(1,0);\nconst ivec2 OLDPOSITION = ivec2(2, 1);\nconst ivec2 DZOOM = ivec2(0,0);\nconst ivec2 OLDZOOM = ivec2(3, 0);\nconst ivec2 DBPOS = ivec2(0,1);\n// Henry Thasler's trick (this keeps the shader compiler from optimizing away precision that we want)\n// For some reason (at least on my machine), this needs only to be applied to subtractions\nfloat mul_frc(float a, float b) {\n  return a * b;\n}\n\nfloat add_frc(float a, float b) {\n  return a + b;\n}\n\nfloat sub_frc(float a, float b) {\n  return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);\n}\n\nfloat div_frc(float a, float b) {\n    return a / b;\n}\n\nfloat sqrt_frc(float a) {\n    return sqrt(a);\n}\n\n/*Double single precision numbers based on the ancient DSFUN90 fortran library. \nGlorious fortran 90 source here (thank god for internet archive): \nhttps://web.archive.org/web/20110807012734/http://crd.lbl.gov/~dhbailey/mpdist/dsfun90.tar.gz\n*/\n// create double-single number from float\nvec2 ftod(float a) {\n  return vec2(a, 0.0);\n}\n// Add: res = dsadd(a, b) => res = a + b\nvec2 dsadd (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float t1, t2, e;\n\n  t1 = add_frc(dsa.x, dsb.x);\n  e = sub_frc(t1, dsa.x);\n  t2 = add_frc(add_frc(add_frc(sub_frc(dsb.x, e), sub_frc(dsa.x, sub_frc(t1, e))), dsa.y), dsb.y);\n  dsc.x = add_frc(t1, t2);\n  dsc.y = sub_frc(t2, sub_frc(dsc.x, t1));\n  return dsc;\n}\n// Subtract: res = dssub(a, b) => res = a - b\nvec2 dssub (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float e, t1, t2;\n\n  t1 = sub_frc(dsa.x, dsb.x);\n  e = sub_frc(t1, dsa.x);\n  t2 = sub_frc(add_frc(add_frc(sub_frc(sub_frc(0.0, dsb.x), e), sub_frc(dsa.x, sub_frc(t1, e))), dsa.y), dsb.y);\n\n  dsc.x = add_frc(t1, t2);\n  dsc.y = sub_frc(t2, sub_frc(dsc.x, t1));\n  return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat dscompare(vec2 dsa, vec2 dsb) {\n  if (dsa.x < dsb.x) {\n    return -1.;\n  }\n  if (dsa.x > dsb.x) {\n    return 1.;\n  }\n  if (dsa.y < dsb.y) {\n    return -1.;\n  }\n  if (dsa.y > dsb.y) {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Multiply: res = dsmul(a, b) => res = a * b\nvec2 dsmul (vec2 dsa, vec2 dsb) {\n  vec2 dsc;\n  float c11, c21, c2, e, t1, t2;\n  float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n  cona = mul_frc(dsa.x, split);\n  conb = mul_frc(dsb.x, split);\n  a1 = sub_frc(cona, sub_frc(cona, dsa.x));\n  b1 = sub_frc(conb, sub_frc(conb, dsb.x));\n  a2 = sub_frc(dsa.x, a1);\n  b2 = sub_frc(dsb.x, b1);\n\n  c11 = mul_frc(dsa.x, dsb.x);\n  c21 = add_frc(mul_frc(a2, b2), add_frc(mul_frc(a2, b1), add_frc(mul_frc(a1, b2), sub_frc(mul_frc(a1, b1), c11))));\n\n  c2 = add_frc(mul_frc(dsa.x, dsb.y), mul_frc(dsa.y, dsb.x));\n\n  t1 = add_frc(c11, c2);\n  e = sub_frc(t1, c11);\n  t2 = add_frc(add_frc(mul_frc(dsa.y, dsb.y), add_frc(sub_frc(c2, e), sub_frc(c11, sub_frc(t1, e)))), c21);\n\n  dsc.x = add_frc(t1, t2);\n  dsc.y = sub_frc(t2, sub_frc(dsc.x, t1));\n\n  return dsc;\n}\n// Divide: res = dsdiv(a, b) => res = a / b\nconst float split = 8193.;\nvec2 dsdiv(vec2 dsa, vec2 dsb) {\n    float a1, a2, b1, b2, cona, conb, c11, c2, c21, e, s1, s2, t1, t2, t11, t12, t21, t22;\n    vec2 dsc;\n    s1 = div_frc(dsa.x, dsb.x);\n    cona = mul_frc(s1, split);\n    conb = mul_frc(dsb.x, split);\n    a1 = sub_frc(cona, sub_frc(cona, s1));\n    b1 = sub_frc(conb, sub_frc(conb, dsb.x));\n    a2 = sub_frc(s1, a1);\n    b2 = sub_frc(dsb.x, b1);\n    \n    c11 = mul_frc(s1, dsb.x);\n    c21 = add_frc(mul_frc(a2, b2), add_frc(mul_frc(a2, b1), add_frc(mul_frc(a1, b2), sub_frc(mul_frc(a1, b1), c11))));\n    \n    c2 = mul_frc(s1, dsb.y);\n    t1 = add_frc(c11, c2);\n    e = sub_frc(t1, c11);\n    \n    t2 = add_frc(add_frc(sub_frc(c2, e), sub_frc(c11, sub_frc(t1, e))),c21);\n    t12 = add_frc(t1, t2);\n    t22 = sub_frc(t2, sub_frc(t12, t1));\n    t11 = sub_frc(dsa.x, t12);\n    \n    e = sub_frc(t11, dsa.x);\n    t21 = add_frc(add_frc(sub_frc(-t12, e),sub_frc(dsa.x,sub_frc(t11,e))),sub_frc(dsa.y, t22));\n    \ns2 = div_frc(add_frc(t11, t21), dsb.x);\n    dsc.x = add_frc(s1, s2);\n    dsc.y = sub_frc(s2, sub_frc(dsc.x, s1));\n    return dsc;\n}\n// Absolute value: res = dsabs(a) = |a|\nvec2 dsabs(vec2 a) {\n    if(dscompare(a, vec2(0.0)) == -1.0) {return dsmul(a, ftod(-1.0));}\n    else {return a;}\n}\n//Max: res = dsmax(a, b) = a > b ? a : b\nvec2 dsmax(vec2 a, vec2 b) {\n    if(dscompare(a, b) == 1.0) {return a;} else {return b;}\n}\n//Min: res = dsmin(a, b) = a < b ? a : b\nvec2 dsmin(vec2 a, vec2 b) {\n    if(dscompare(a, b) == -1.0) {return a;} else {return b;}\n}\n\nvec2 dssqrt(vec2 a) {\n    float t1, t2, t3;\n    vec2 s0, s1, v0;\n    if(a.x == 0.0){return vec2(0.0,0.0);}\n    t1 = div_frc(1., sqrt(a.x));\n    //t2 = a.x * t1;\n    t2 = mul_frc(a.x, t1);\n    v0 = vec2(t2, 0.0);\n    s0 = dsmul(v0,v0);\n    s1 = dssub(a, s0);\n    //t3 = 0.5 * s1.x * t1;\n    t3 = mul_frc(mul_frc(s1.x, 0.5), t1);\n    s0.x = t2;\n    s0.y = 0.;\n    s1.x = t3;\n    s1.y = 0.;\n    return dsadd(s0, s1);\n}\n\n// this is still lossy, but it loses less information than pure single prec, soooo it's fine.\nvec2 double_ln(vec2 a) {\n    return\n    dsadd(vec2(log(a.x),0.0),\n    vec2(log(1.0+a.y/a.x),0.0)\n    );\n}\n\n//exp(x+y) = exp(x)*exp(y)\nvec2 double_exp(vec2 a) {\n    return dsmul(ftod(exp(a.x)),ftod(exp(a.y)));\n}\n\n// functions for 2d vectors of DS components\nvec4 to2d(vec2 a) {\n    return vec4(a.x, 0.0, a.y, 0.0);\n}\n//Hypot: res = hypot2d(<ai, bj>) = sqrt(a^2+b^2)\nvec2 hypot2d(vec4 z) {\n    vec2 t;\n    vec2 x = dsabs(z.xy);\n    vec2 y = dsabs(z.zw);\n    t = dsmin(x, y);\n    x = dsmax(x, y);\n    t = dsdiv(t, x);\n    if(z == vec4(0.0)) {return vec2(0.0);} else {\n        return dsmul(x, dssqrt(dsadd(ftod(1.0), dsmul(t, t))));\n    }\n}\n\n//Vector addition: add2d(a, b) = d2(a.x + b.x, a.y + b.y)\nvec4 add2d(vec4 a, vec4 b){ return vec4(dsadd(a.xy,b.xy),dsadd(a.zw,b.zw));}\n//Vector component wise multiplication: mul2d(a, b) = d2(a.x * b.x, a.y * b.y)\nvec4 mul2d(vec4 a, vec4 b){ return vec4(dsmul(a.xy,b.xy),dsmul(a.zw,b.zw));}\n//Vector component x scalar multiplication: mulBoth(a, b) = d2(a.x * b, a.y * b)\nvec4 mulBoth(vec4 a, vec2 b){ return vec4(dsmul(a.xy,b.xy),dsmul(a.zw,b.xy));}\n//Vector component / scalar division: divBoth(a, b) = d2(a.x / b, a.y / b)\nvec4 divBoth(vec4 a, vec2 b){ return vec4(dsdiv(a.xy, b.xy), dsdiv(a.zw, b.xy));}\n//Vector subtraction: sub2d(a, b) = d2(a.x - b.x, a.y - b.y)\nvec4 sub2d(vec4 a,vec4 b){return vec4(dssub(a.xy,b.xy),dssub(a.zw,b.zw));}\n//Vector dot product: dotd(a, b) = dot(a, b)\nvec2 dotd(vec4 a, vec4 b){return vec2(dsadd(dsmul(a.xy,b.xy),dsmul(a.zw,b.zw)));}\n// take the component wise square of a vector: square(a) = d2(a.x^2 + a.y^2) \nvec4 square(vec4 a){return vec4(dsmul(a.xy,a.xy),dsmul(a.zw,a.zw));}\n\n//numeric constants\nconst vec4 TWO = vec4(2.0,0.0,2.0,0.0);\nconst vec4 ONE = vec4(1.0,0.0,0.0,0.0);\nconst float PI = 3.14159265358979323846;\n//direction of incoming \"light\"\nconst vec2 light_direction = vec2(cos(PI/4.0), sin(PI/4.0));\n\n//macro to \"load\" a data pixel from iChannel0 (Buff_A)\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n// size of look behind buffer\n#define LOOKBEHIND_CT 2\n//keyboard\n#define keyDown(K) (texelFetch( iChannel1, ivec2(K,0),0 ).x==1.)\n        \nvec4 cmul(vec4 a, vec4 b) {\n    return vec4(dssub(dsmul(a.xy, b.xy), dsmul(a.zw,b.zw)), dsadd(dsmul(a.xy,b.zw), dsmul(a.zw, b.xy) ));\n}\nvec4 cdiv(vec4 a, vec4 b) {\n    vec2 bdot = dotd(b, b);\n    return vec4(\n        dsdiv(\n            dsadd(\n                dsmul(a.xy, b.xy),\n                dsmul(a.zw, b.zw)\n            ), \n            bdot), \n        dsdiv(\n            dssub(\n                dsmul(a.zw, b.xy),\n                dsmul(a.xy, b.zw)\n                )\n            ,\n            bdot)\n        );\n}\nvec4 csquare(vec4 a) {\n    return vec4(dssub(dsmul(a.xy,a.xy), dsmul(a.zw, a.zw)),dsmul(dsmul(a.zw,a.xy),ftod(2.)));\n}\n//complex conjugate of a\nvec4 conju(vec4 a) {return vec4(a.xy, dsmul(vec2(-1.0, 0.0), a.zw));}\n\nstruct Iterate {\n    vec4 z;\n    vec4 der;\n    vec4 der2;\n};\n\nconst float OVERFLOW = 100000000000000000.0;\nconst vec3 in_color = vec3(0.0);\n\nvec3 dmandel (vec4 c, int maxiter, float erad){\n    //init variables\n    Iterate current = Iterate(c, ONE, vec4(0.0));\n    vec2 erad2 = dsmul(ftod(erad), ftod(erad));\n    int stepstaken = 0;\n    float stepslimit = 2.0;\n    vec4 squared = vec4(0.0);\n    vec4 old = c;\n    vec4 u;\n    vec2 lo;\n    Iterate previousIterate;\n    \n    for (int i=0; i<maxiter; i++) {\n        //convenience for z^2\n        squared = square(current.z);\n        \n        // compute the next iteration's dz/dc\n        vec4 new_der = add2d(cmul(mul2d(TWO, current.der), current.z), ONE);\n        \n        //compute the next iteration's d^2z/d^2c\n        vec4 new_der2 = mul2d(TWO,add2d(cmul(current.der2, current.z), csquare(current.der)));\n        \n        //compute the next iteration's z\n        current.z = vec4(dsadd(dssub(squared.xy,squared.zw),c.xy),dsadd(dsmul(dsmul(current.z.zw,current.z.xy),ftod(2.)),c.zw));\n        \n        //set stored values\n        current.der = new_der;\n        current.der2 = new_der2;\n        \n        //update squared\n        squared = square(current.z);\n        \n        //test for escape\n        if(dscompare(dsadd(squared.xy, squared.zw), erad2) == 1.0) {\n            //normalized iteration count\n            float ni = float(i)+4.-log2(log2(dsadd(squared.xy,squared.zw).x));\n            \n            // we need this for later\n            squared = square(previousIterate.z);\n            \n            //nice gradient\n            vec3 col = 0.5 + 0.5*cos( 3.0 + ni*0.25 + vec3(0.0,0.6,1.0));\n            \n            //convenience for squared magnitude of z\n            vec2 magsq = dsadd(squared.xy, squared.zw);\n            \n            // complex analysis witchcraft\n            lo = dsmul(ftod(0.5), double_ln(magsq));\n            vec2 lop1 = dsadd(lo, ftod(1.0));\n            vec2 lop1XmagsqDer = dsmul(lop1, dotd(previousIterate.der, previousIterate.der));\n            vec2 loXmagsqZ = dsmul(lo, magsq);\n            u = sub2d(mulBoth(cmul(previousIterate.z, conju(previousIterate.der)), lop1XmagsqDer),\n                mulBoth(cmul(previousIterate.der, conju(previousIterate.der2)), loXmagsqZ)\n            );\n            \n            // if the witchcraft above will probably cause an overflow, use the normal derivative of M instead \n            // (I have no idea why the sqrt(erad) thing works, but it seems to make the switch correctly for any escape radius >= 1000)\n            if( hypot2d(previousIterate.der2).x > OVERFLOW / sqrt(erad - 999.0)) {\n                u = cdiv(previousIterate.z, previousIterate.der);\n            }\n            // if both normal generation methods will probably overflow, just return the color for this iteration\n            if(hypot2d(previousIterate.der).x > OVERFLOW) {\n                return col;\n            }\n            \n            // this function loses a lot less information than dssqrt(dotd(u, u))\n            vec2 hyp = hypot2d(u);\n            \n            //normalize u\n            u = divBoth(u, hyp);\n            \n            //lambertian lighting\n            float ref = dot(u.xz, light_direction) + 1.5;\n            ref /= 2.5;\n            \n            // shade color by light reflected\n            return ref * col;\n        }\n        \n        //brent's cycle detection\n        if(old==current.z) return in_color;\n        if(stepstaken==int(stepslimit)){\n            old = current.z;\n            stepstaken = 0;\n            stepslimit *= 2.;\n        }\n        stepstaken++;\n        \n        //store this iteration for potential use next iteration if it escapes\n        previousIterate = current;\n    }\n    return in_color;\n}", "buffer_a_code": "precision highp float;\n//macros\n// store/load macros that read/write vec4s to buffer A\n#define store(P,V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n//Keyboard macros\n#define keyDown(K) (texelFetch( iChannel1, ivec2(K,0),0 ).x==1.)\n\n\n//constants\n//keys\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n//define a memory boundary so we can use the rest of Buff_A for other things later\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\nconst int edit_me = 0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //if this pixel is outside of the memory boundary do other things(return)\n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    //passthrough previously defined values\n    fragColor = load(fragCoord);\n    //load relevant \"pixels\" from iChannel0 (which is set to display Buff_A) into local variables\n    float zoom = load(ZOOM).x;\n    vec2 pos = load(POSITION).xy;\n    vec2 bpos = load(BPOS).xy;\n    vec4 posd = load(DPOSITION);\n    store(OLDPOSITION, posd);\n    vec4 bposd = load(DBPOS);\n    vec2 dzoom = load(DZOOM).xy;\n    store(OLDZOOM, vec4(dzoom, vec2(0)));\n    //normalize mouse coordinates\n    vec4 mousecoords = vec4(iResolution.xy,iResolution.xy)-vec4(iMouse.xy,abs(iMouse.zw));\n    //default zoom value\n    if (zoom == 0.) zoom = 7.0;\n    if(dscompare(dzoom,ftod(0.))==0.) dzoom = ftod(0.01);\n    bool mouseDown = sign(iMouse.z) == 1.;\n    //set position to the latest base position plus the difference of mouse.xy and .zw if the mouse is held\n    if (mouseDown){ \n        pos = bpos + ((mousecoords.xy-mousecoords.zw)/pow(2.0,zoom));\n        posd = add2d(bposd,mul2d(to2d(mousecoords.xy-mousecoords.zw),vec4(dzoom,dzoom)));\n        \n    }\n    //update the base position if the mouse is not held\n    if (!mouseDown){ \n        bpos = pos;\n        bposd = posd;\n    }\n    //zoom in if w is held\n    if keyDown(87) {\n        //zoom faster if shift is held\n        if keyDown(16) {\n            zoom = zoom+.1;\n            dzoom = dsmul(dzoom,ftod(0.9));\n        }\n        else {\n            zoom = zoom+0.01;\n            dzoom = dsmul(dzoom,ftod(0.99));\n        }\n    }\n    //zoom out if s is held\n    if keyDown(83) {\n        //zoom faster if shift is held\n        if keyDown(16) {\n            zoom = zoom-0.1;\n            dzoom = dsmul(dzoom,ftod(1.1));\n        }\n        else {\n            zoom = zoom-0.01;\n            dzoom = dsmul(dzoom,ftod(1.01));\n        }\n    }\n    \n    store(DBPOS, bposd);\n    store(DPOSITION, posd);\n    store(DZOOM,vec4(dzoom,0.,0.));\n    store(ZOOM,vec4(zoom,0.,0.,0.));\n    store(POSITION,vec4(pos,0.,0.));\n    store(BPOS,vec4(bpos,0.,0.));\n    \n    \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nuint hashInt( uint x )\n{\n  x += x >> 11;\n  x ^= x << 7;\n  x += x >> 15;\n  x ^= x << 5;\n  x += x >> 12;\n  x ^= x << 9;\n  return x;\n}\n\nuint hashInt( uvec2 v )\n{\n  uint x = v.x, y = v.y;\n  x += x >> 11;\n  x ^= x << 7;\n  x += y;\n  x ^= x << 6;\n  x += x >> 15;\n  x ^= x << 5;\n  x += x >> 12;\n  x ^= x << 9;\n  return x;\n}\n\nuint hashInt( uvec3 v )\n{\n  uint x = v.x, y = v.y, z = v.z;\n  x += x >> 11;\n  x ^= x << 7;\n  x += y;\n  x ^= x << 3;\n  x += z ^ ( x >> 14 );\n  x ^= x << 6;\n  x += x >> 15;\n  x ^= x << 5;\n  x += x >> 12;\n  x ^= x << 9;\n  return x;\n}\n\nfloat rand(uint h) {\n  const uint mantissaMask = 0x007FFFFFu;\n  const uint one          = 0x3F800000u;\n\n  h &= mantissaMask;\n  h |= one;\n    \n  float  r2 = uintBitsToFloat( h );\n  return r2 - 1.0;\n}\n\nfloat random( float f ) {\n  return rand(hashInt(floatBitsToUint(f)));\n}\n\nfloat random( vec2 f ) {\n  return rand(hashInt(floatBitsToUint(f)));\n}\n\nfloat random( vec3 f ) {\n  return rand(hashInt(floatBitsToUint(f)));\n}\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 posd = load(DPOSITION);\n    vec2 dzoom = load(DZOOM).xy;\n    vec4 oldpos = load(OLDPOSITION);\n    vec2 oldzoom = load(OLDZOOM).xy;\n    vec2 epsilon = dsmul(dzoom, ftod(0.5));\n    epsilon = dsmul(epsilon, ftod(random(vec3(fragCoord, float(iTime)))));\n    vec4 dcoords = mul2d(sub2d(to2d(fragCoord),mul2d(to2d(iResolution.xy),vec4(ftod(.5),ftod(.5)))),vec4(dzoom,dzoom));\n    vec4 duv = add2d(posd,dcoords);\n    int mi = 100;\n    float escaperadius = 1000.0;\n    vec4 result = vec4(dmandel(vec4(dsadd(duv.xy, epsilon), dsadd(duv.zw, epsilon)), mi, escaperadius), 1.0);\n    if(posd == oldpos && dzoom == oldzoom) {\n        fragColor = (texelFetch(iChannel2, ivec2(fragCoord), 0) + result) / 2.0;\n    } else {\n        fragColor = result;\n    }\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 43, 43, 67], [69, 69, 125, 125, 329]], "test": "untested"}
{"id": "dldGR4", "name": "Smooth Blending Mask", "author": "Bers", "description": "Automatic projector blending masks generation example", "tags": ["projectionmapping"], "likes": 2, "viewed": 208, "published": 3, "date": "1682033238", "time_retrieved": "2024-07-30T17:59:41.627703", "image_code": "screenSpaceQuad randomQuad(float t, vec2 pos, float w, float h, float randomness)\n{\n    screenSpaceQuad quad;\n    float rdm = randomness;\n    quad.a = pos + vec2(0.+sin(t*0.120)*rdm,0.+cos(t*0.143)*rdm);\n    quad.b = pos + vec2(w +cos(t*0.102)*rdm,0.+cos(t*0.107)*rdm);\n    quad.c = pos + vec2(w +sin(t*0.096)*rdm,h +sin(t*0.112)*rdm);\n    quad.d = pos + vec2(0.+sin(t*0.134)*rdm,h +cos(t*0.123)*rdm);\n    \n    return quad;\n}\n\nCam setupPerspectiveCamera()\n{\n    Cam kCam;\n    kCam.O = vec3(0,0,0);\n    kCam.R = vec3(1,0,0);\n    kCam.U = vec3(0,1,0);\n    kCam.D = vec3(0,0,-1);\n    return kCam;\n}\n\nfloat calcBlendingMask_surfaceSpace(vec2 surfaceUV, screenSpaceQuad ssQuad, screenSpaceQuad ssQuad_other)\n{\n    float self_w = maskWeight(surfaceUV, ssQuad);\n    float other_w = maskWeight(surfaceUV, ssQuad_other);\n    return self_w/(self_w+other_w);\n}\n\nfloat calcBlendingMask_projectorSpace(vec2 maskUV, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad, screenSpaceQuad ssQuad_other)\n{\n    Cam perspectiveCam = setupPerspectiveCamera();\n    vec2 surface_uv = inversePerspective_uv(perspectiveCam, maskUV, ssQuad, wsQuad);\n    return calcBlendingMask_surfaceSpace(surface_uv, ssQuad, ssQuad_other);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = iResolution.y/iResolution.x;\n\tvec2 uv = -vec2(0.5,0.3)+2.0*fragCoord.xy / iResolution.xx;\n   \n    Cam perspectiveCam = setupPerspectiveCamera();\n   \n    screenSpaceQuad quad1 = randomQuad(iTime, vec2(0,0), 1., h, 0.2);\n    worldSpaceQuad wsQuad1;\n    resolvePerspective(perspectiveCam,quad1,wsQuad1);\n    \n    screenSpaceQuad quad2 = randomQuad(iTime*1.764+2., vec2(0.5,0), 1., h, 0.1);\n    worldSpaceQuad wsQuad2;\n    resolvePerspective(perspectiveCam,quad2,wsQuad2);\n    \n    fragColor = vec4(0,0,0,1);\n    \n    float totalCoverage = 0.;\n    float c1 = 0.;\n    if(!isOutside(uv,quad1) && int(iTime)%3!=1 )\n    {\n        float mask = calcBlendingMask_surfaceSpace(uv, quad1, quad2);\n        totalCoverage += mask;\n    }\n    \n    float c2 = 0.;\n    if(!isOutside(uv,quad2) && int(iTime)%3!=2)\n    {\n        float mask = calcBlendingMask_surfaceSpace(uv, quad2, quad1);\n        totalCoverage += mask;\n    }\n    \n    fragColor.rgb += vec3(1,1,1)*totalCoverage;\n    \n    //Precision test : make sure the sum of both projectors does not exceed 1.0 (with \n    float eps = 0.0001;\n    if(totalCoverage > (1.0+eps))\n    {\n        //Magenta if total light exceeds 1.0\n        fragColor.rgb = vec3(1,0,1);\n    }\n    \n    const float maskScale = 5.;\n    \n    //Calc Projector 1 mask\n    vec2 left_mask_uv = fragCoord.xy*maskScale/iResolution.xy;\n    if(left_mask_uv.x<1. && left_mask_uv.y<1.)\n    {\n        float mask = calcBlendingMask_projectorSpace(left_mask_uv, quad1, wsQuad1, quad2);\n        fragColor = vec4(vec3(1,1,1)*mask,1);\n        return;\n    }\n    \n    //Calc Projector 2 mask\n    vec2 right_mask_uv = fragCoord.xy*maskScale/iResolution.xy-vec2(maskScale-1.,0);\n    if(right_mask_uv.x>0. && right_mask_uv.y<1.)\n    {\n        float mask = calcBlendingMask_projectorSpace(right_mask_uv, quad2, wsQuad2, quad1);\n        fragColor = vec4(vec3(1,1,1)*mask,1);\n        return;\n    }\n    \n    float lineThickness = 0.005;\n    fragColor.rgb = mix(fragColor.rgb, vec3(1,0,0), smoothstep(lineThickness,0., distanceToQuadEdge(uv,quad1)));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0,1,0), smoothstep(lineThickness,0., distanceToQuadEdge(uv,quad2)));\n}", "image_inputs": [], "common_code": "struct Cam { vec3 R; vec3 U; vec3 D; vec3 O;}; //R=Right, U=Up, D=Direction, O=Origin\nstruct screenSpaceQuad{ vec2 a; vec2 b; vec2 c; vec2 d; };\nstruct worldSpaceQuad{  vec3 a; vec3 b; vec3 c; vec3 d; };\n\n//Function to cast a ray through a given coordinate (uv) on the image plane.\n//It returns the direction of a 3D Ray.\n//Note : screen center is uv=[0,0]\nvec3 ray(vec2 uv, Cam cam)\n{\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\n\n//Function which does the opposite of the previous function:\n//It receives a 3D world space position, then flattens it on the image plane \n//and returns its [uv] coordinates.\n//Note : screen center is uv=[0,0]\nvec2 camProj(Cam c, vec3 p)\n{\n    p = p-c.O;\n    float cZ = dot(p,c.D);\n    float cX = dot(p,c.R);\n\tfloat cY = dot(p,c.U);\n    return vec2(cX/cZ,cY/cZ);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nbool isOutside(vec2 uv, screenSpaceQuad quad)\n{\n    //Note: a is bottom_left, b is bottom_right, c is top_right, d is top_left\n    return dot( (quad.c-quad.b).yx*vec2(-1,1), uv-quad.c) < 0.\n        || dot( (quad.b-quad.a).yx*vec2(-1,1), uv-quad.b) < 0.\n    \t|| dot( (quad.a-quad.d).yx*vec2(-1,1), uv-quad.a) < 0.\n    \t|| dot( (quad.d-quad.c).yx*vec2(-1,1), uv-quad.d) < 0.;\n}\n\nfloat distanceToQuadEdge(vec2 uv, screenSpaceQuad quad)\n{\n    float d1 = distanceToLineSeg(uv, quad.c, quad.b);\n    float d2 = distanceToLineSeg(uv, quad.b, quad.a);\n    float d3 = distanceToLineSeg(uv, quad.a, quad.d);\n    float d4 = distanceToLineSeg(uv, quad.d, quad.c);\n    \n    return min(d1,min(d2,min(d3,d4)));\n}\n\nfloat smoothInternalQuadGrad(vec2 uv, screenSpaceQuad quad)\n{\n    float d1 = distanceToLineSeg(uv, quad.c, quad.b);\n    float d2 = distanceToLineSeg(uv, quad.b, quad.a);\n    float d3 = distanceToLineSeg(uv, quad.a, quad.d);\n    float d4 = distanceToLineSeg(uv, quad.d, quad.c);\n    \n    //Note : a parameter controls smoothness (and scales value)\n    float a = 0.01;\n    float NORMALIZATION_TERM = log((1.+a)/a);\n    d1 = log((d1+a)/a)/NORMALIZATION_TERM;\n    d2 = log((d2+a)/a)/NORMALIZATION_TERM;\n    d3 = log((d3+a)/a)/NORMALIZATION_TERM;\n    d4 = log((d4+a)/a)/NORMALIZATION_TERM;\n    return d1*d2*d3*d4;\n}\n\nfloat maskWeight(vec2 uv, screenSpaceQuad quad)\n{\n    if(isOutside(uv,quad))\n    {\n        return 0.0;\n    }\n    else\n    {\n        return smoothInternalQuadGrad(uv,quad);\n    }\n}\n\n//Utility function returning the intersection point of two 2D lines\n//[p1a,p1b] = line1\n//[p2a,p2b] = line1\nvec2 lineLineIntersection(vec2 p1a, vec2 p1b, vec2 p2a, vec2 p2b)\n{\n    vec2 d1 = (p1b-p1a); //Direction Line 1\n    vec2 d2 = (p2b-p2a); //Direction Line 2\n    vec2 d1n = vec2(d1.y, -d1.x); //orthogonal line to d1 (normal), optimal direction to reach d1 from anywhere\n    float dist = dot(p1a-p2a,d1n);//projection on the optimal direction = distance\n    float rate = dot(d2,d1n); //rate : how much is our d2 line in the optimal direction? (<=1.0)\n    float t = 10000000.0 ; //INFINITY! (rare parallel case)\n    if(rate != 0.0)\n\t\tt = dist/rate; //Starting from p2a, find the distance to reach the other line along d2.\n    return p2a+t*d2;  //start point + distance along d2 * d2 direction = intersection.\n}\n\n//Utility function to compute the distance along a ray to reach a plane, in 3D.\n//The value returned is the distance along ray to the plane intersection.\n//o = ray origin\n//d = ray direction\n//po = plane origin\n//pn = plane normal\nfloat rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) \n{\n    //Same principle as lineLineIntersection() :\n    //\"How far is the plane\"/\"approach rate\".\n    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.\n    return dot(po-o,pn)/dot(d,pn);\n}\n\n//perspectiveCam : the camera from which the points in screen space come from\n//P1 : known world space position of p1\n//p1 : screen space p1 (which is resolved, already)\n//p2 : screen space p2 (which must be adjacent to p1 - cannot be the opposite corner)\n//parallel_a : first point (screen space) in the other line parallel to (p1,p2)\n//parallel_b : second point (screen space) in the other line parallel to (p1,p2)\nvec3 resolveAdjacentCorner(in Cam perspectiveCam, vec3 P1, vec2 p1_resolved, vec2 p2_adjacent, vec2 parallel_a, vec2 parallel_b)\n{\n    //screen space intersection (vanishing point on the projection plane)\n    vec2 ssIntersec = lineLineIntersection(p1_resolved,p2_adjacent,parallel_a,parallel_b);\n    //Vanishing point direction, from camera, in world space.\n    vec3 dirVanishingPoint = ray(ssIntersec, perspectiveCam);\n    vec3 p1_to_p2 = dirVanishingPoint; //Since vanishing point is at \"infinity\", p1_to_p2 == dirVanishingPoint\n    vec3 r2 = ray(p2_adjacent, perspectiveCam);//Ray from camera to p2, in world space\n    \n    //<Line3D intersection : where p1_to_p2 crosses r2>\n    //(Note : this could probably be made simpler with a proper 3D line intersection formula)\n    //Find (rb,p1_to_p2) intersection:\n    vec3 n_cam_p1_p2 = cross(p1_to_p2,r2); //normal to the triangle formed by point p1, point p2 and the camera origin\n    vec3 n_plane_p2 = cross(n_cam_p1_p2,r2); //normal to the plane which is crossed by line p1-p2 at point p2\n    float t = rayPlaneIntersec(P1,p1_to_p2,perspectiveCam.O,n_plane_p2);\n    vec3 p2_ws = P1+t*p1_to_p2;\n    //</Line3D intersection>\n    return p2_ws;\n}\n    \n//Finds each corner, one by one.\nvoid resolvePerspective(in Cam perspectiveCam, in screenSpaceQuad ssQuad, out worldSpaceQuad wsQuad)\n{\n    vec3 ra = ray(ssQuad.a, perspectiveCam); //Find the direction of the ray passing by point a in screen space.\n\t                                      //For the sake of simplicity, screenspace [uv.x,uv.y] = worldspace [x,y]. Z = depth.\n    //Let's place point a in an arbitrary position along the ray ra. \n    //It does not matter at which distance exactly, as it is the relationship between\n    //the corners that is important. The first corner distance simply defines the scaling of the 3D scene.\n    wsQuad.a = perspectiveCam.O + 5.5*ra; //5.5 = arbitrary scaling. Projective geometry does not preserve world space scaling.\n    wsQuad.b = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.b, ssQuad.c, ssQuad.d);\n    wsQuad.c = resolveAdjacentCorner(perspectiveCam, wsQuad.b, ssQuad.b, ssQuad.c, ssQuad.a, ssQuad.d);\n    wsQuad.d = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.d, ssQuad.b, ssQuad.c);\n}\n\n\n//wsQuad.a = origin (lower left corner)\n//wsQuad.a,b,c,d = CCW point order.\nvec2 findParallelogramUV(vec3 o, vec3 d, worldSpaceQuad wsQuad)\n{\n    //Note : This is tricky because axis are not orthogonal.\n    vec3 uvX_ref = wsQuad.b-wsQuad.a; //horitonal axis\n    vec3 uvY_ref = wsQuad.d-wsQuad.a; //vertical axis\n    vec3 quadN = cross(uvY_ref,uvX_ref);\n    float t = rayPlaneIntersec(o, d, wsQuad.a, quadN);\n        \n    vec3 p = o+t*d;\n    vec3 X0_N = cross(uvY_ref,quadN);\n    vec3 Y0_N = cross(uvX_ref,quadN);\n    \n    //Vertical component : find the point where plane X0 is crossed\n    float t_x0 = rayPlaneIntersec(p, uvX_ref, wsQuad.a, X0_N);\n    vec3 pY = p+t_x0*uvX_ref-wsQuad.a;\n    //Horizontal component : find the point where plane Y0 is crossed\n    float t_y0 = rayPlaneIntersec(p, uvY_ref, wsQuad.a, Y0_N);\n    vec3 pX = p+t_y0*uvY_ref-wsQuad.a;\n    \n    //All is left to find is the relative length ot pX, pY compared to each axis reference\n    return vec2(dot(pX,uvX_ref)/dot(uvX_ref,uvX_ref),\n\t            dot(pY,uvY_ref)/dot(uvY_ref,uvY_ref));\n}\n\nvec2 inversePerspective_uv(Cam perspectiveCam, vec2 uv_01, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad )\n{\n    vec3 x_ws = wsQuad.b-wsQuad.a;\n    vec3 y_ws = wsQuad.d-wsQuad.a;\n    vec3 p_ws = wsQuad.a+uv_01.x*x_ws + uv_01.y*y_ws;\n    vec2 puv = camProj(perspectiveCam,p_ws);\n\treturn puv;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 83, 83, 425], [427, 427, 457, 457, 595], [597, 597, 704, 704, 849], [851, 851, 980, 980, 1194], [1196, 1196, 1253, 1253, 3414]], "test": "untested"}
{"id": "dld3R4", "name": "Color Study - Plate IV-4b", "author": "Slals", "description": "Relative temperature study :\n\nThe purple rectangle is hidden by the middle red and green, making it appears to be of 2 colors, but it's the same piece.", "tags": ["interactionofcolor"], "likes": 1, "viewed": 159, "published": 3, "date": "1682030794", "time_retrieved": "2024-07-30T17:59:42.762667", "image_code": "\nfloat rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - step(size, x);\n}\nfloat fillAA(float x, float size) {\n    return 1.0 - smoothstep(size - 0.011, size, x);\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    uv = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * (uv - 0.5);\n    return uv + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.776, 0.851, 0.878);\n    \n    float MX = iMouse.x / iResolution.x;\n    float MY = iMouse.y / iResolution.y;\n    \n    vec2 bgS = vec2(0.5, 1.0);\n    \n    vec2 bgOffset = vec2(0.25, 0.0);\n    \n    float bgLeft = fill(rectSDF(uv + bgOffset, bgS), 1.0);\n    float bgRight = fill(rectSDF(uv - bgOffset, bgS), 1.0);\n    float mid = fill(rectSDF(uv, bgS), 1.0);\n    float midRight = fill(rectSDF(uv - vec2(0.2, 0.0), vec2(0.1, 1.0)), 1.0);\n    \n    float B = fillAA(rectSDF(rotate(uv, -0.03), vec2(0.72)), 1.0);\n    \n    vec3 bgLeftColor = vec3(0.718, 0.388, 0.624);\n    vec3 bgRightColor = vec3(0.263, 0.169, 0.357);\n    vec3 midColor = vec3(0.918, 0.325, 0.282);\n    vec3 midRightColor = vec3(0.149, 0.231, 0.282);\n    vec3 BColor = vec3(0.569, 0.302, 0.533);\n    \n    color = bgLeft * bgLeftColor + bgRight * bgRightColor;\n    color = mix(color, B * BColor, B);\n    color = mix(color, mid * midColor, mid);\n    color = mix(color, midRight * midRightColor, midRight);\n    \n    // color = mix(color, bgLeft * bgLeftColor, MX);\n    // color = mix(color, bgRight * bgRightColor, MX);\n    color = mix(color, B * BColor, B * MX);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dld3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 33, 33, 110], [112, 112, 145, 145, 179], [180, 180, 215, 215, 269], [271, 271, 306, 306, 406], [408, 408, 465, 515, 1740]], "test": "untested"}
{"id": "mttGR4", "name": "Color Study - Plate IV-2", "author": "Slals", "description": "Relative temperature study :\n\nThe gray squares appears to be different because of the background temperature difference.", "tags": ["interactionofcolor"], "likes": 1, "viewed": 150, "published": 3, "date": "1682024945", "time_retrieved": "2024-07-30T17:59:43.659271", "image_code": "float rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - step(size, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.776, 0.851, 0.878); // TODO set a color\n    \n    vec2 S = vec2(0.35, 0.8);\n    vec2 SMid = vec2(0.15, 0.8);\n    vec2 SB = vec2(0.52, 0.2);\n    \n    vec2 offset = vec2(0.2, 0.1);\n    vec2 offsetB = vec2(0.25, 0.15);\n    vec2 midOffset = vec2(0.07403, 0.0);\n    \n    float MX = iMouse.x / iResolution.x;\n    float MY = iMouse.y / iResolution.y;\n    \n    float rectALeft = fill(rectSDF(uv + offset * vec2(1.0, -1.0), S), 0.8);\n    float rectARight = fill(rectSDF(uv - offset, S), 0.8);\n    float rectBLeft = fill(rectSDF(uv + offsetB * vec2(1.0, -1.0), S), 0.25);\n    float rectBRight = fill(rectSDF(uv - offsetB, S), 0.25);\n    \n    vec3 leftAColor = vec3(0.863, 0.906, 0.773);\n    vec3 rightAColor = vec3(0.208, 0.318, 0.361);\n    vec3 BColor = vec3(0.647, 0.667, 0.678);\n    \n    color = mix(color, rectALeft * mix(leftAColor, rightAColor, MX), rectALeft);\n    color = mix(color, rectARight * mix(rightAColor, leftAColor, MY), rectARight);\n    \n    color = mix(color, rectBLeft * BColor, rectBLeft);\n    color = mix(color, rectBRight * BColor, rectBRight);\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [111, 111, 144, 144, 178], [180, 180, 237, 287, 1455]], "test": "untested"}
{"id": "mltGR4", "name": "Pathtracer + Textures", "author": "ThePlaneGuy45", "description": "A cool pathtracer! \nwanted to improve on my last pathtracer in terms of textures and neatness and stuff, and tbh it was easier to code another than fix my other one.\n\nhttps://www.youtube.com/watch?v=Qz0KTGYJtUk\nhttps://www.shadertoy.com/view/XlXcW4", "tags": ["raytracing", "textures", "pathtracing"], "likes": 4, "viewed": 220, "published": 3, "date": "1682024877", "time_retrieved": "2024-07-30T17:59:44.909927", "image_code": "// Shader settings in Common\n// Scene editor in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nPathtracer by TPG45\n\nfeel free to use as a base for other projects, just give credit\nalso feel free to expand on this, just give credit for the base pathtracer\n\nIncludes:\n- lighting, diffuse + specular\n- refraction\n- textures & cubemaps\n- DOF & blur\n- Multipass sampling\n- Normal maps\n*/\n\n// Shader Settings\n#define FOCAL_LENGTH 500.0\n#define CAM_DISTANCE 250.0\n#define MAX_BOUNCES 10\n#define SAMPLES 10\n#define DOF_AMOUNT 5.0\n#define BLUR_AMOUNT 2.0\n\nstruct Material {\n\n    vec3 color;\n    bool useTexture;\n    bool useNormals;\n    int texID;\n    float texScale;\n    float bumpStrength;\n    float emission;\n    float glossiness;\n    float transparency;\n    float ior;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Triangle {\n\n    Material material;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec2 auv;\n    vec2 buv;\n    vec2 cuv;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n    int refrac;\n    int objID;\n    int hitID;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n// Extra trig + hyperbolic functions by me, if you want to use please credit.\nfloat cot(float x){return cos(x)/sin(x);}vec2 cot(vec2 x){return cos(x)/sin(x);}vec3 cot(vec3 x){return cos(x)/sin(x);}vec4 cot(vec4 x){return cos(x)/sin(x);}float sec(float x){return 1./cos(x);}vec2 sec(vec2 x){return 1./cos(x);}vec3 sec(vec3 x){return 1./cos(x);}vec4 sec(vec4 x){return 1./cos(x);}float csc(float x){return 1./sin(x);}vec2 csc(vec2 x){return 1./sin(x);}vec3 csc(vec3 x){return 1./sin(x);}vec4 csc(vec4 x){return 1./sin(x);}float coth(float x){float a=exp(x);float b=exp(-x);return(a+b)/(a-b);}vec2 coth(vec2 x){vec2 a=exp(x);vec2 b=exp(-x);return(a+b)/(a-b);}vec3 coth(vec3 x){vec3 a=exp(x);vec3 b=exp(-x);return(a+b)/(a-b);}vec4 coth(vec4 x){vec4 a=exp(x);vec4 b=exp(-x);return(a+b)/(a-b);}float sech(float x){return 2./(exp(x)+exp(-x));}vec2 sech(vec2 x){return 2./(exp(x)+exp(-x));}vec3 sech(vec3 x){return 2./(exp(x)+exp(-x));}vec4 sech(vec4 x){return 2./(exp(x)+exp(-x));}float csch(float x){return 2./(exp(x)-exp(-x));}vec2 csch(vec2 x){return 2./(exp(x)-exp(-x));}vec3 csch(vec3 x){return 2./(exp(x)-exp(-x));}vec4 csch(vec4 x){return 2./(exp(x)-exp(-x));}\n\nuint raySphere(in Sphere sph, inout Record rec) {\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    rec.objID++;\n    if (disc > 0.0) {\n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        if(dstNear < rec.dist) {\n            if(dstNear > 0.0) {\n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.offset = (rec.intersect - sph.center - sph.radius) / sph.radius - 0.5;\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                rec.hitID = rec.objID;\n                return uint(0x1);\n            }\n        }\n        return uint(0x0);\n    }\n}\nuint rayTri(in Triangle tri, inout Record rec) {\n    vec3 ab = tri.b - tri.a;\n    vec3 ac = tri.c - tri.a;\n    vec3 bc = tri.c - tri.b;\n    vec3 normal = ab.yzx * ac.zxy - ab.zxy * ac.yzx;\n    vec3 ao = rec.ray.origin - tri.a;\n    vec3 dao = cross(ao, rec.ray.normal);    \n    float det = 1.0 / (-dot(rec.ray.normal, normal));    \n    float dist = dot(ao, normal) * det;\n    float u = dot(ac, dao) * det;\n    float v = -dot(ab, dao) * det;\n    float w = 1.0 - u - v;    \n    bool hit = det >= 1e-6 && dist >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;    \n    rec.objID++;\n    if(hit && dist < rec.dist) {    \n        rec.intersect = (rec.ray.normal * dist) + rec.ray.origin;\n        rec.normal = normalize(normal);\n        rec.dist = dist;\n        rec.material = tri.material;\n        rec.hit = true;\n        rec.offset = vec3(u, v, w);\n        \n        float xba = tri.buv.x - tri.auv.x;\n        float xcb = tri.cuv.x - tri.buv.x;\n        float yba = tri.buv.y - tri.auv.y;\n        float ycb = tri.cuv.y - tri.buv.y;\n        rec.tangent = normalize(ycb * ab - yba * bc);\n        rec.bitangent = normalize(-xcb * ab + xba * bc);\n        rec.hitID = rec.objID;\n        \n        return uint(0x1);\n    }\n    return uint(0x0);\n}\nvec3 random(inout uvec3 state) {\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    return vec3(state)*(1.0/float(0xffffffffU));\n}\nvec3 randomNormal(vec3 normal, inout uvec3 state) {\n    vec3 y = random(state);\n    vec3 theta = 2.0 * 3.14159265358979 * y;\n    vec3 rho = sqrt(-2.0 * log(y));\n    y = normalize(rho * cos(theta));\n    if(dot(y, normal) < 0.0) {\n        y -= y;\n    }\n    return y;\n}", "buffer_a_code": "// Scene Editor ////////////////////////\nvoid distances( inout Record rec ) {\n\n    raySphere( Sphere( Material(vec3(0.8, 0.8, 0.8), false, false, 0, 1.0, 1.0, 0.0, 0.9, 0.0, 0.0), vec3(0.0, 100.0, 300.0), 100.0 ), rec );\n    raySphere( Sphere( Material(vec3(0.0, 0.0, 0.0), true, true, 3, 0.25, 10.0, 0.0, 0.1, 0.0, 0.0), vec3(0.0, 100.0, -300.0), 100.0 ), rec );\n    raySphere( Sphere( Material(vec3(1.0, 0.5, 0.5), false, true, 2, 1.0, 2.5, 0.0, 0.1, 0.8, 1.5), vec3(300.0, 100.0, 0.0), 100.0 ), rec );\n    raySphere( Sphere( Material(vec3(1.0, 1.0, 1.0), true, true, 2, 50.0, 40.0, 0.0, 0.15, 0.0, 0.0), vec3(0.0, -50000.0, 0.0), 50000.0 ), rec );\n    \n    rayTri( Triangle( Material(vec3(0.5, 0.5, 0.5), true, true, 1, 1.0, 10.0, 0.0, 0.2, 0.0, 0.0), vec3(0.0, 100.0, 300.0), vec3(300.0, 100.0, 0.0), vec3(0.0, 100.0, -300.0), vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0) ), rec );\n\n}\n////////////////////////////////////////\n\nvoid initRay( in vec2 fragCoord, inout Ray ray, uvec3 state ) {\n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    ray.origin = vec3(0.0, 0.0, -FOCAL_LENGTH) + vec3(random(state).xy * DOF_AMOUNT, 0.0);\n    ray.normal = normalize(vec3(fragCoord + random(state).x * BLUR_AMOUNT, 0.0) - ray.origin);\n    ray.origin.z -= CAM_DISTANCE;\n    mat2 rot = rot2(4.0 * mouse.y);\n    ray.origin.yz *= rot; ray.normal.yz *= rot;\n    rot = rot2(4.0 * mouse.x);\n    ray.origin.xz *= rot; ray.normal.xz *= rot;\n}\n\nvoid initRecord(inout Record rec, in Ray ray) {\n\n    rec.ray = ray;\n    rec.hit = false;\n    rec.dist = 100000.0;\n    rec.objID = 0;\n\n}\n\nvec4 triPlanar(sampler2D tex, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    vec3 blend = normalize(max(abs(normal), 0.000001));\n    float sum = blend.x + blend.y + blend.z;\n    blend /= sum;\n    vec4 x = texture(tex, offset.yz * scale + imgOffset);\n    vec4 y = texture(tex, offset.xz * scale + imgOffset);\n    vec4 z = texture(tex, offset.xy * scale + imgOffset);\n    return x * blend.x + y * blend.y + z * blend.z;\n\n}\n\nvec4 sampleTex(int id, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    switch(id){\n    case 1:\n        return triPlanar(iChannel1, offset, normal, scale, imgOffset);\n    case 2:\n        return triPlanar(iChannel2, offset, normal, scale, imgOffset);\n    case 3:\n        return triPlanar(iChannel3, offset, normal, scale, imgOffset);\n    }\n    return vec4(0.0);\n\n}\n\nfloat getHeight(vec4 tex) {\n\n    return dot(tex.rgb, vec3(.2126, .7152, .0722));\n\n}\n\nvec3 normal(int id, vec3 offset, vec3 normal, float scale, vec2 res, float strength) {\n\n    float current = getHeight(sampleTex(id, offset, normal, scale, vec2(0.0)));\n    float x = (getHeight(sampleTex(id, offset, normal, scale, vec2(1.0 / res.x, 0.0))) - current) * strength;\n    float y = (getHeight(sampleTex(id, offset, normal, scale, vec2(0.0, 1.0 / res.y))) - current) * strength;\n    return normalize(vec3(x, y, 1.0));\n\n}\n\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nvec3 Trace( in vec2 fragCoord, in uvec3 state ) {\n\n    vec3 final = vec3(0.0);\n\n    for( int i = 0; i < SAMPLES; i++ ) {\n\n        Ray ray;\n        Record rec;\n        initRay( fragCoord, ray, state );\n        initRecord( rec, ray );\n        rec.refrac = -1;\n    \n        vec3 color = vec3(0.0);\n        vec3 increment = vec3(1.0);\n    \n        for( int j = 0; j < MAX_BOUNCES; j++ ) {\n    \n            distances( rec );\n    \n            if( rec.hit ) {\n            \n                vec3 matColor;\n                vec3 nMap;\n            \n                if(rec.material.useTexture) {\n                    \n                    matColor = sampleTex(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, vec2(0.0)).rgb;\n                \n                } else {\n                \n                    matColor = rec.material.color;\n                \n                }\n                \n                if(rec.material.useNormals) {\n                \n                    nMap = normal(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, iChannelResolution[3].xy, rec.material.bumpStrength);\n                    rec.normal = worldSpace(nMap, rec.tangent, rec.bitangent, rec.normal);\n                \n                }\n                \n                float spec = float(rec.material.glossiness > random(state).x);\n                rec.ray.origin = rec.intersect;\n                if(rec.material.transparency > random(state).x || rec.refrac == rec.hitID) {\n                \n                    rec.ray.normal = refract(rec.ray.normal, rec.normal, clamp(rec.refrac > 0 ? rec.material.ior : 1.0 / rec.material.ior, 0.0, 1.0));\n                    \n                    if(rec.refrac > -1) {\n                    \n                        rec.refrac = -1;\n                    \n                    } else {\n                    \n                        rec.refrac = rec.hitID;\n                    \n                    }\n                \n                } else {\n                \n                    rec.ray.normal = normalize(mix(randomNormal(rec.normal, state), reflect(rec.ray.normal, rec.normal), spec));\n                    \n                }\n                initRecord(rec, rec.ray);\n        \n                color += (matColor * rec.material.emission) * increment;\n                increment *= mix(matColor, vec3(1.0), spec);\n    \n            } else {\n    \n                color += texture(iChannel0, rec.ray.normal).xyz * increment;\n                break;\n    \n            }\n        }\n    \n        final += color;\n        \n    }\n    \n    final /= float(SAMPLES);\n    \n    return final;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float ratio = 720.0/iResolution.y;\n    vec2 coord = ratio * fragCoord;\n\n    uvec3 state = uvec3(floatBitsToUint(coord), uint(iFrame));\n    \n    fragColor = vec4(Trace( coord - ratio * iResolution.xy / 2.0, state ), 1.0);\n    \n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = texture(iChannel0, rayDir) * length(texture(iChannel0, rayDir));\n}", "cube_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Save State Buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if(iMouse.z > 0.0) {\n    \n        fragColor = vec4(float(iFrame));\n        \n    }\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n\n    float frame = float(iFrame + 1) - texture(iChannel1, vec2(0.6, 0.5)).x;\n    \n    vec4 current = texture(iChannel2, uv);\n    \n    if(iMouse.z > 0.0) {\n    \n        fragColor = current;\n    \n    } else {\n    \n        fragColor = mix(fragColor, current, 1.0 / frame);\n    \n    }\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mltGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 197]], "test": "untested"}
{"id": "DttGzN", "name": "Color Study - Plate IV-1b", "author": "Slals", "description": "Relative temperature study :\n\nThe square sand color appears to be different because of the background temperature.", "tags": ["interactionofcolor"], "likes": 0, "viewed": 129, "published": 3, "date": "1682023235", "time_retrieved": "2024-07-30T17:59:45.812513", "image_code": "float rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - step(size, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(1.0);\n    \n    vec2 S = vec2(0.35, 0.8);\n    vec2 SMid = vec2(0.15, 0.8);\n    vec2 SB = vec2(0.52, 0.2);\n    \n    vec2 offset = vec2(0.2, 0.0);\n    vec2 midOffset = vec2(0.07403, 0.0);\n    \n    float MX = iMouse.x / iResolution.x;\n    float MY = iMouse.y / iResolution.y; \n    \n    vec3 leftAColor = vec3(0.949, 0.584, 0.218);\n    vec3 midLeftAColor = vec3(1.0, 0.918, 0.42);\n    vec3 rightAColor = vec3(0.09, 0.655, 0.757);\n    vec3 midRightAColor = vec3(0.055, 0.239, 0.514);\n    vec3 BColor = vec3(0.839, 0.549, 0.357);\n    \n    float ASize = 1.0;\n    float BSize = 1.0;\n    \n    float rectALeft = fill(rectSDF(uv + offset, S), ASize);\n    float rectAMidLeft = fill(rectSDF(uv + midOffset, SMid), ASize); \n    float rectARight = fill(rectSDF(uv - offset, S), ASize);\n    float rectAMidRight = fill(rectSDF(uv - midOffset, SMid), ASize);\n    float rectB = fill(rectSDF(uv, SB), BSize);\n    \n    color = rectALeft * mix(leftAColor, rightAColor, MY);\n    color += rectARight * mix(rightAColor, leftAColor, MY);\n    color = mix(color, rectB * BColor, rectB);\n    color = mix(color, rectAMidLeft * mix(midLeftAColor, midRightAColor, MX), rectAMidLeft);\n    color = mix(color, rectAMidRight * mix(midRightAColor, midLeftAColor, MX), rectAMidRight);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [111, 111, 144, 144, 178], [180, 180, 237, 287, 1637]], "test": "untested"}
{"id": "mttGR8", "name": "Path tracer attempt 4", "author": "pathtracerenthusiast", "description": "A path tracer with bloom, HDR, glossy reflections, multiple shapes, large amounts of configuration, glass, lights, and a good sky. Ive used stuff from Sebastian Lague and stuff produced by Bing AI and Ingo Quilez. Based on 3: 2.3. Demofox's tut was used.", "tags": ["pathtracer"], "likes": 1, "viewed": 192, "published": 3, "date": "1682016162", "time_retrieved": "2024-07-30T17:59:46.953463", "image_code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings, go to the 'Buffer B' tab.\n//To set or rwmove the maximum fnumber of frames go to the 'Common' tab.\n\n#define Bloom\n\n#define exposure .3\n\n//I used the Bing AI to improve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  float n = 1./float(2*w*w);\n  const float invpi = 1./PI;\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      float weight = n*invpi*exp(-float(x*x+y*y)*n);\n      //float weight = 1.;\n      color += texture(s, uv).xyz*weight;\n    }\n  }\n  return color;\n}\n\n#define size 2.25*((R.x+R.y)*.00119048)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    vec2 p = R-10.;\n    if(i.x>=p.x&&i.y>=p.y&&iFrame>maxFrame){o=vec4(1.);return;}\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    #ifdef Bloom\n    #ifdef maxFrame\n    if(iFrame>=maxFrame)\n    #endif\n    o.xyz += blur(iChannel1,i/R,int(size));\n    #endif\n    \n    \n    o.xyz *= exposure;\n    \n    o.xyz = ACESFilm(o.xyz);\n    o.xyz = linearToSRGB(o.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.1415926523\n#define d2r(a) a*(PI/180.)\n#define md(a,b) max(0.,dot(a,b))\n\n#define maxFrame 256\n\nfloat _seed;\n// Thanks to Dave_Hoskin for the random numbers\nfloat rand(){\n    float v = fract(_seed*.1031);\n    v *= _seed + 33.33;\n    v *= _seed + _seed;\n    v += 34.35;\n    float a = fract(v);\n    _seed++;\n    _seed *= 2.*a;\n    return a;\n}\n\nvec2 rand2(){\n    vec3 p = fract(_seed*vec3(.1031,.103,.0973));\n    p += dot(p,p.yzx+33.33);\n    vec2 a = fract((p.xx+p.yz)*p.zy);\n    _seed++;\n    _seed *= a.x+a.y;\n    return a;\n}\n\nvoid irand(vec2 i,float t){\n    vec3 p = vec3(i.y,t,i.x);\n    p = fract(p*.1031);\n    p += dot(p,p.zyx+32.31);\n    _seed = fract((p.x+p.y)*p.z);\n}\n\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\n\n\nstruct Mat {\n    float r;\n    float IOR;\n    vec3 col;\n    vec3 ems;\n    float spcCh;\n    vec3 spcCl;\n    float rfaCh;\n    vec3 absorb;\n};\n\n\nstruct AABB {\n    vec3 minv,maxv;\n};\n\nstruct SphBody {\n    vec3 c;\n    float rad;\n    bool isActive;\n};\n\nstruct BoxBody {\n    vec3 pos,size,rot;\n    bool inverted, isActive;\n};\n\nstruct QuadBody {\n    vec3 v0,v1,v2,v3;\n    bool fn, isActive;\n};\n\nstruct Obj {\n    SphBody sph;\n    BoxBody box;\n    QuadBody quad;\n    Mat mat;\n    AABB bound;\n};\n\nstruct BVHNode {\n    AABB bound;\n    uint left,right;\n};\n\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct NewHit {\n    float len;\n    vec3 nor;\n    Obj o;\n    bool ff;\n};\n\nstruct IntRes {\n    float len;\n    bool ff;\n};\n\n#define DefaultSph SphBody(vec3(0.),0.,false)\n#define DefaultBox BoxBody(vec3(0.),vec3(0.),vec3(0.),false,false)\n#define DefaultQuad QuadBody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),false,false)\n\n#define objC 9\nstruct NewWorld {\n    Obj objs[objC];\n    Viewer camera;\n};\n\nObj Obj_Sphere(vec3 pos,float rad,Mat m){\n    AABB bound = AABB(pos-rad-.0001,pos+rad+.0001);\n    return Obj(SphBody(pos,rad,true),DefaultBox,DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowSphere(vec3 pos,float rad,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Sphere(pos,rad,m);\n    objlst[idx1] = Obj_Sphere(pos,thickness-rad,m);\n}\n\nObj Obj_Box(vec3 pos,vec3 size,vec3 rot,Mat m){\n    AABB bound = AABB(pos-2.*size-.001,pos+2.*size+.0001);\n    return Obj(DefaultSph,BoxBody(pos,size,rot,false,true),DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowBox(vec3 pos,vec3 size,vec3 rot,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Box(pos,size,rot,m);\n    AABB bound = AABB(pos-2.*abs(size)-.001+thickness,pos+2.*abs(size)+.0001-thickness);\n    objlst[idx1] = Obj(DefaultSph,BoxBody(pos,size-thickness,rot,true,true),DefaultQuad,m,bound);\n}\n\nObj Obj_Quad(vec3 v0,vec3 v1,vec3 v2,vec3 v3,bool fn,Mat m){\n    vec3 minv = min(min(v0,v1),min(v2,v3));\n    vec3 maxv = max(max(v0,v1),max(v2,v3));\n    AABB bound = AABB(minv,maxv);\n    return Obj(DefaultSph,DefaultBox,QuadBody(v0,v1,v2,v3,fn,true),m,bound);\n}\n\nIntRes newSphereInt( in vec3 ro, vec3 rd, SphBody sph) {\n    ro -= sph.c;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sph.rad*sph.rad;\n    float h = b*b - c;\n    if( h<0. ) return IntRes(-1.,false);\n    h = sqrt( h );\n    if(length(ro)<=sph.rad){\n        return IntRes(-b+h,false);\n    }else{\n        return IntRes(-b-h,true);\n    }\n}\n\nbool insideAabb(vec3 p,vec3 s){\n    return (p.x<=s.x&&p.x>=-s.x)&&(p.y<=s.y&&p.y>=-s.y)&&(p.z<=s.z&&p.z>=-s.z);\n}\n\nIntRes newBoxInt( in vec3 ro, in vec3 rd, BoxBody box) {\n    mat3 r = rot3(-box.rot);\n    \n    ro, rd *= r;\n    ro -= box.pos;\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*abs(box.size);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return IntRes(-1.,false);\n    if(insideAabb(ro,abs(box.size))){\n        return IntRes(tF,box.inverted);\n    }else{\n        return IntRes(tN,!box.inverted);\n    }\n}\n\nfloat newQuadInt(vec3 ro,vec3 rd,QuadBody q){\n    vec3 n = cross(q.v1-q.v0,q.v2-q.v0);\n    float d = dot(n, q.v0);\n    \n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    return -1.;\n}\n\nbool aabbInt(in vec3 ro,vec3 rd,AABB box){\n    vec3 a = .5*(box.maxv+box.minv);\n    vec3 d = .5*(box.maxv-box.minv);\n    vec3 m = 1./rd;\n    vec3 n = m*(ro-a); \n    vec3 k = abs(m)*d;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return false;\n    return true;\n}\n\n\n\nconst float bias = 1.0001;\nvec3 newBoxNor(vec3 p,BoxBody b){\n    vec3 q = p-b.pos;\n    vec3 d = b.size;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float z = rand()*2.-1.;\n    float r = sqrt(1.-z*z);\n    float x = r*cos(phi), y = r*sin(phi);\n\treturn vec3(x,y,z);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nfloat reflectance(float cosv,float refidx){\n    float r0 = (1.-refidx)/(1.+refidx);\n    r0 *= r0;\n    return r0+(1.-r0)*pow(1.-cosv,5.);\n}\nvec3 hemi(vec3 h){\n    return reflect(uniformVec(),h);\n}\n\n\nvec3 LessThan(vec3 f, float val) {\n    return vec3(\n        (f.x < val) ? 1. : 0.,\n        (f.y < val) ? 1. : 0.,\n        (f.z < val) ? 1. : 0.);\n}\n \nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - .055,\n        rgb * 12.92,\n        LessThan(rgb, .0031308)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(((rgb + .055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        LessThan(rgb, 0.04045)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0., 1.);\n}\n\nfloat fresnel(float n1, float n2, vec3 nor, vec3 I, float f0, float f90) {\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(nor, I);\n        if (n1 > n2) {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.) return f90;\n            cosX = sqrt(1.-sinT2);\n        }\n        float x = 1.-cosX;\n        float ret = r0+(1.-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}", "buffer_a_code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n#define shutAp .6\n#define fcsDist 4.5\n#define blurAmt .001\n#define numLvls 8\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\n#define SkyMode 1\nconst float mode = 0.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\n\n\nNewWorld getNewWorld(float t){\n    NewWorld world;\n    Viewer cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(0.,2.,-3.5));\n    \n    mat2 rx = rot(d2r(-5.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(0.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(0.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.objs[0] = Obj_Sphere(vec3(0.,-402.001,0.),400.,Mat(.5,5.,vec3(.2,.5,1.),vec3(0.),.5,vec3(.2,.8,.8),0.,vec3(1.)));\n    //createObj_HollowSphere(vec3(-1.5,-.5,3.),1.5,.4,1,8,Mat(.2,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false),world.objs);\n    world.objs[1] = Obj_Sphere(vec3(-1.5,-.5,3.),1.5,Mat(.1,1.5,vec3(1.),vec3(0.),.4,vec3(.8,.2,.8),0.,vec3(1.)));\n    world.objs[2] = Obj_Sphere(vec3(1.5,-1.,2.),1.,Mat(.9,1.5,vec3(1.),vec3(0.),.6,vec3(.8,.8,.2),0.,vec3(1.)));\n    world.objs[3] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(3.5,-2.,-2.),vec3(3.5,-2.,3.5),vec3(-3.5,-2.,3.5),true,Mat(1.,1.52,vec3(1.),vec3(0.),.5,vec3(1.),0.,vec3(1.)));\n    world.objs[4] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(-3.5,5.,-2.),vec3(-3.5,5.,3.5),vec3(-3.5,-2.,3.5),false,Mat(.5,1.52,vec3(1.,.1,.1),vec3(0.),.5,vec3(1.,.1,.1),0.,vec3(1.)));\n    world.objs[5] = Obj_Quad(vec3(3.5,-2.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(3.5,-2.,3.5),true,Mat(.5,1.52,vec3(.1,1.,.1),vec3(0.),.5,vec3(.1,1.,.1),0.,vec3(1.)));\n    world.objs[6] = Obj_Quad(vec3(-3.5,5.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(-3.5,5.,3.5),false,Mat(0.,1.52,vec3(1.),vec3(0.),.5,vec3(1.),0.,vec3(1.)));\n    world.objs[7] = Obj_Box(vec3(0.,4.,.5),vec3(.75,.25,.75),d2r(vec3(0.)),Mat(.5,0.,vec3(.75,.775,.9),vec3(5.),1.,vec3(0.),0.,vec3(1.)));\n    world.objs[8] = Obj_Box(vec3(0.,-1.25,-.5),vec3(.75),d2r(vec3(0.)),Mat(0.,1.52,vec3(1.),vec3(0.),.4,vec3(1.),.95,vec3(3.,6.,9.)));\n    //TODO: Generate bounding boxes\n    \n    \n    world.camera = cam;\n    return world;\n}\n\nNewHit newInt(vec3 ro,vec3 rd,Obj objs[objC]){\n    NewHit h;\n    h.len = -1.;\n    \n    for(int i = 0; i < objC; i++) {\n        Obj o = objs[i];\n        //if(!aabbInt(ro,rd,o.bound)) continue;\n        if(o.sph.isActive) {IntRes res = newSphereInt(ro,rd,o.sph);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.box.isActive) {IntRes res = newBoxInt(ro,rd,o.box);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.quad.isActive) {float res = newQuadInt(ro,rd,o.quad);if(res>=.0001&&(res<h.len||h.len<0.)){h.o=o;h.ff=true;h.len=res;}}\n    }\n    \n    Obj o = h.o;\n    vec3 p = ro+rd*h.len;\n    \n    if(o.sph.isActive) h.nor = normalize(p-o.sph.c);//*sign(o.sph.rad);\n    else if(o.box.isActive) {BoxBody b = o.box;mat3 r = rot3(b.rot);mat3 rn = rot3(-b.rot);h.nor = newBoxNor(b.pos+(p-b.pos)*rn,b)*r;}\n    else if(o.quad.isActive) {QuadBody q = o.quad;h.nor = normalize(cross(q.v1-q.v0,q.v2-q.v0))*(q.fn?-1.:1.);}\n    \n    //h.nor *= h.ff?1.:-1.;\n    \n    return h;\n}\n\nconst vec3 sunDir = normalize(vec3(.5,1.,.75));\n//Sebastian Lagues's sky function\nvec3 getSky(float t,vec3 rd) {\n    #if SkyMode == 1\n    float skyGradT = pow(smoothstep(0.,.4,rd.y),.35);\n    vec3 skyGrad = mix(vec3(.05),vec3(.3,.6,.9),skyGradT);\n    \n    vec3 sun = pow(max(0.,dot(rd,sunDir)),40.)*10.*vec3(1.,.85,.7);\n    \n    float groundT = smoothstep(-.01,0.,rd.y);\n    \n    return mix(vec3(.25),skyGrad,groundT)+sun;\n    #elif SkyMode == 0\n    return vec3(0.);\n    #elif SkyMode == 2\n    return SRGBToLinear(texture(iChannel1,rd).xyz);\n    #endif\n}\n\nvec3 newRay(inout vec3 ro,inout vec3 rd,vec3 p,in vec3 n,Mat m,bool ff) {\n    vec3 oro = ro; vec3 ord = rd;\n    ro = p;\n    #if 0\n    vec3 mn = normalize(mix(n,hemi(n),m.r));\n    rd = reflect(rd,mn);\n    return m.col;\n    #else\n    if(!ff) n *= -1.;\n    \n    float specChance = m.spcCh;\n    float refraChance = m.rfaCh;\n    \n    float rayProb = 1.;\n    if(specChance > 0.) {\n        specChance = fresnel(ff?1.:m.IOR,ff?m.IOR:1.,rd,n,m.spcCh,1.);\n        \n        float chanceMultiplier = (1.-specChance) / (1.-m.spcCh);\n        refraChance *= chanceMultiplier;\n    }\n    \n    float doRefra = 0., doSpec = 0., roll = rand();\n    if(specChance > 0. && roll < specChance) {\n        doSpec = 1.;\n        rayProb = specChance;\n    } else if(refraChance > 0. && roll < specChance + refraChance) {\n        doRefra = 1.;\n        rayProb = refraChance;\n    } else {\n        rayProb = 1.-(specChance+refraChance);\n    }\n    \n    rayProb  = max(rayProb, .0001);\n    \n    float r2 = m.r*m.r;\n    \n    vec3 difDir = normalize(n+uniformVec());\n    vec3 refDir = reflect(rd,n);\n    vec3 specDir = normalize(mix(refDir,difDir,r2));\n    \n    vec3 refraDir = refract(rd,n,ff?1./m.IOR:m.IOR);\n    refraDir = normalize(mix(refraDir,normalize(uniformVec()-n),r2));\n    \n    rd = mix(difDir,specDir,doSpec);\n    rd = mix(rd,refraDir,doRefra);\n    \n    vec3 col = vec3(1.);\n    \n    if(doRefra==0.) col *= mix(m.col,m.spcCl,doSpec);\n    \n    return col / rayProb;\n    #endif\n    \n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    #ifdef maxFrame\n    if(iFrame>=maxFrame) {o=texelFetch(iChannel0,ivec2(i),0);return;}\n    #endif\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = floor(iTime*mode)/mode;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        NewWorld world = getNewWorld(ctime);\n        Viewer cam = world.camera;\n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        for(int _j = 0; _j<numLvls;_j++) {\n            NewHit hit = newInt(cam.ro,rd,world.objs); \n            if(hit.len==-1.) {tcol+=getSky(ctime,rd)*fcol;break;}                             \n            \n            if(!hit.ff) fcol *= exp(-hit.o.mat.absorb*hit.len);\n            \n            vec3 p = hit.len*rd+cam.ro;\n            \n            Mat mat = hit.o.mat;\n            \n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat,hit.ff);\n            \n            #if 1\n            {\n                float r_p = max(fcol.x,max(fcol.y,fcol.z));\n                if(rand()>r_p) break;\n                fcol /= r_p;\n            }\n            #endif\n        }\n        \n        ttcol += tcol;\n    }\n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texture(iChannel0,i/R);\n    o /= o.w;\n    float d = dot(o.xyz,vec3(1.));\n    o.xyz = d>4.?o.xyz:vec3(0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 289, 328, 328, 718]], "test": "untested"}
{"id": "ctd3z4", "name": "Abstract Liquid", "author": "SentientCymatic", "description": "Melting Chromatic Liquid Smoke Effect", "tags": ["water"], "likes": 19, "viewed": 570, "published": 3, "date": "1682015297", "time_retrieved": "2024-07-30T17:59:47.803191", "image_code": "vec2 hash2( float n ){return fract(sin(vec2(n,n+1.0))*vec2(432.14159,528.14159));}\n\nconst vec2 randConst = vec2(432.14159, 528.14159);\nconst float randMultiplier = 3.14159;\nfloat rand(const vec2 co) {\n    return fract(sin(co.x * randConst.x + co.y * randConst.y) * randMultiplier);}\n\nfloat custom_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);}\n\nfloat noise(in vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 n = p + vec2(2.5, -2.5);\n    float a = mix(rand(n), rand(n + vec2(1.0, 0.0)), f.x);\n    float b = mix(rand(n + vec2(0.0, 1.0)), rand(n + vec2(1.0, 1.0)), f.x);\n    return mix(a, b, f.y);}\n\nvec2 turbulence(vec2 p, float t, float scale){\n    float sum = 0.1;\n    float freq = scale;\n    float smoothness;\n    vec2 noise_coord;\n    for (int i = 0; i < 5; i++){\n        smoothness = custom_smoothstep(0.0, 10.0, float(i));\n        noise_coord = vec2(p + t * 0.25) + vec2(cos(float(i) * 0.5), sin(float(i) * 0.5)) * smoothness;\n        sum += abs(noise(noise_coord)) / freq;\n        freq *= 0.25;}\n    return vec2(sum, sum) * 0.1;}\n\nmat2 mtx = mat2( 0.87,  0.5, -0.5,  0.87 );\n\nfloat fbm( vec2 p ){\n    float f = 0.05;\n    f += 0.950000*noise( p ); p = mtx*p*3.0;\n    f += 0.200000*noise( p ); p = mtx*p*2.0;\n    f += 0.100000*noise( p ); p = mtx*p*2.0;\n    f += 0.050000*noise( p ); p = mtx*p*2.0;\n    f += 0.025000*noise( p ); p = mtx*p*1.0;\n    f += 0.005000*noise( p );\n    p = mtx*p*2.0;\n    f += 0.004*noise( p );\n    p = mtx*p*2.0;\n    f += 0.002*noise( p );\n    return f/0.95000;}\n\nfloat pattern(in vec2 p, in float t, in vec2 uv, out vec2 q, out vec2 r, out vec2 g) {\n    float s = dot(uv + 0.5, uv + 0.5);\n    float iMelty = 50.0, iFlowing = 10.0;\n    float l = custom_smoothstep(0.0, iMelty, sin(t * iFlowing));\n    q = mix(vec2(fbm(p + vec2(t * 1. + sin(t), t * 0.2 + cos(t))),\n                 fbm(p + vec2(t * 0.5 + sin(t + 0.5), t * 0.5 + cos(t + 1.5)))),\n            vec2(fbm(p), fbm(p + vec2(10.5, 1.5))),\n            l);\n    r = mix(vec2(fbm(p + 3.14159 * q + vec2(t * 0.25 + sin(t * 0.25), t * 0.25 + cos(t * 0.50)) + vec2(1.5, 10.5)),\n                 fbm(p + 2.0 * q + vec2(t * 0.5 + sin(t * 0.3), t * 0.4 + cos(t * 0.9)) + vec2(8.5, 4.8))),\n            vec2(fbm(p + 5.0 * q + vec2(t) + vec2(33.66, 66.33)), fbm(p + 4. * q + vec2(t) + vec2(8.5, 2.5))),\n            l);\n    g = mix(vec2(fbm(p + 2.0 * r + vec2(t * 0.5 + sin(t * 0.5), t * 0.5 + cos(t * 0.75)) + vec2(2.5, 5)),\n                 fbm(p + 1.5 * r + vec2(t * 0.75 + sin(t * 0.25), t * 0.5 + cos(t * 0.5)) + vec2(5, 2.5))),\n            vec2(fbm(p + 2.5 * r + vec2(t * 5.0) + vec2(2, 5)), fbm(p + 2. * r + vec2(t * 11.0) + vec2(5, 2.5))),\n            l);\n    vec2 v = turbulence(p * 0.1, t * 0.1, 20.);\n    vec2 m = vec2(fbm(p * 0.5 + vec2(t * 0.9, t * 0.9) + v * 0.5),\n                  fbm(p * 0.5 + vec2(t * 0.9, t * 0.9) + v * 0.5));\n    return mix(fbm(p + 2.5 * g + vec2(-t * 0.75 + sin(t * 0.5), -t * 0.5 + cos(t * 0.25)) + v * 2.5 + m * 0.25),\n               fbm(p + 5.0 * g + vec2(-t * 5.0) + v * 2.5),\n               l);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float iSmoke = 0.01;\n    float iSpeed = 0.25;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 q, r, g;\n    float noise = pattern(fragCoord * vec2(iSmoke), iTime * iSpeed, uv, q, r, g);\n    vec3 col = mix(vec3(0.2, 0.4, 0.2), vec3(0.0, 0.25, 0.5), custom_smoothstep(0.1, 1.0, noise));\n    col = mix(col, vec3(0.4, 0.2, 0.2), dot(q, q) * 1.5);\n    col = mix(col, vec3(0.2, 0.4, 0.0), 0.25 * g.y * g.y);\n    col = mix(col, vec3(0.4, 0.2, 0.2), custom_smoothstep(0.2, 0.5, 1.0 * r.g * r.g));\n    col = mix(col, vec3(0.2, 0.4, 0.6), 0.5 * g.x);\n    float timeScale = .25;\n    float xDrift = sin(uv.x * 3.14159 + iTime * timeScale);\n    float yDrift = cos(uv.y * 3.14159 + iTime * timeScale);\n    vec3 drift = vec3(xDrift, yDrift, -xDrift - yDrift) * .1;\n    col += drift;\n    col = mix(col, vec3(1), custom_smoothstep(0., 1., noise) * custom_smoothstep(0., 10., noise));\n    col *= noise * 2.;\n    fragColor = vec4(col, 1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctd3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 82], [173, 173, 200, 200, 282], [284, 284, 344, 344, 443], [445, 445, 468, 468, 744], [746, 746, 792, 792, 1183], [1230, 1230, 1250, 1250, 1640], [1642, 1642, 1728, 1728, 3161], [3163, 3163, 3217, 3217, 4145]], "test": "untested"}
{"id": "Dlt3z4", "name": "* ", "author": "kilika", "description": "* ", "tags": [], "likes": 0, "viewed": 106, "published": 3, "date": "1682015083", "time_retrieved": "2024-07-30T17:59:48.572135", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    // Create a grid of squares\n    vec2 p = uv * 5.0;\n    vec2 a = fract(p) - 0.5;\n    vec2 d = fwidth(p);\n    vec2 grid = smoothstep(-d, d, a);\n    \n    // Create a circular pattern\n    float r = length(uv);\n    float angle = atan(uv.y, uv.x);\n    float spiral = sin(8.0 * r - 20.0 * angle);\n    \n    // Add a blur effect\n    float blur = 0.03;\n    vec3 blurredColor = vec3(0.0);\n    for (float i = -2.0; i <= 2.0; i++) {\n        for (float j = -2.0; j <= 2.0; j++) {\n            vec2 offset = vec2(i, j) * blur;\n            blurredColor += texture(iChannel0, uv + offset).rgb;\n        }\n    }\n    blurredColor /= 25.0;\n    \n    // Harmonize the colors\n    vec3 harmonizedColor = vec3(0.0);\n    harmonizedColor.r = blurredColor.r + 0.25 * blurredColor.g + 0.25 * blurredColor.b;\n    harmonizedColor.g = blurredColor.g + 0.25 * blurredColor.r + 0.25 * blurredColor.b;\n    harmonizedColor.b = blurredColor.b + 0.25 * blurredColor.r + 0.25 * blurredColor.g;\n    \n    // Add an illusion of movement\n    vec2 offset = vec2(0.1 * iTime, 0.0);\n    vec3 color = vec3(0.0);\n    color += grid.x * vec3(1.0, 0.0, 0.0);\n    color += grid.y * vec3(0.0, 1.0, 0.0);\n    color += spiral * vec3(0.0, 0.0, 1.0);\n    color = texture(iChannel0, uv + offset).rgb * 0.5 + color * 0.5;\n    \n    fragColor = vec4(harmonizedColor * color, 1.0);\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlt3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1443]], "test": "untested"}
{"id": "dlSGWD", "name": "RiverScape", "author": "XT95", "description": "Another pathtraced Calanque!", "tags": ["water", "pathtracing", "rocks", "calanque"], "likes": 113, "viewed": 4176, "published": 3, "date": "1682008527", "time_retrieved": "2024-07-30T17:59:49.555506", "image_code": "// ----------------------------------------------------------------\n// RiverScape\n//\n// Article -> http://www.aduprat.com/portfolio/?page=articles/riverscape\n// ----------------------------------------------------------------\n\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes * RESOLUTION * invRes;\n    vec3 col = texture(iChannel0, uv).rgb / float(iFrame+1);\n    \n    col = ACES(col*8.5 + pow(col,vec3(1.5))*0.0);\n    col = pow(col, vec3(1.0,1.035,1.115));\n    \n    // vignetting\n    col *= vec3(1.) * smoothstep(1.8,.5, length(uv*2.-1.))*.25+.75;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define RESOLUTION iResolution.xy\n//#define RESOLUTION (vec2(1920.,1080.))\n\n\n\n// ---------------------------------------------\n// Hash & Random - From iq\n// ---------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(rand())/32767.0; }\nvec2 frand2() { return vec2(frand(), frand()); }\nvec3 frand3() { return vec3(frand(), frand(), frand()); }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(floatBitsToUint(p));\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat hash( vec2 p )\n{\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash3(i+vec3(0,0,0)).x, \n                        hash3(i+vec3(1,0,0)).x,f.x),\n                   mix( hash3(i+vec3(0,1,0)).x, \n                        hash3(i+vec3(1,1,0)).x,f.x),f.y),\n               mix(mix( hash3(i+vec3(0,0,1)).x, \n                        hash3(i+vec3(1,0,1)).x,f.x),\n                   mix( hash3(i+vec3(0,1,1)).x, \n                        hash3(i+vec3(1,1,1)).x,f.x),f.y),f.z);\n}\nvec4 noised( vec3 x )\n{\n\t// https://iquilezles.org/articles/gradientnoise\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash3( p+vec3(0,0,0) ).x;\n    float b = hash3( p+vec3(1,0,0) ).x;\n    float c = hash3( p+vec3(0,1,0) ).x;\n    float d = hash3( p+vec3(1,1,0) ).x;\n    float e = hash3( p+vec3(0,0,1) ).x;\n    float f = hash3( p+vec3(1,0,1) ).x;\n    float g = hash3( p+vec3(0,1,1) ).x;\n    float h = hash3( p+vec3(1,1,1) ).x;\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) ).yzwx;\n}\n\n\n// ---------------------------------------------\n// Maths\n// ---------------------------------------------\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,b,-b,a);\n}\n\n// From Fizzer - https://web.archive.org/web/20170610002747/http://amietia.com/lambertnotangent.html\nvec3 cosineSampleHemisphere(vec3 n)\n{\n    vec2 rnd = frand2();\n\n    float a = PI*2.*rnd.x;\n    float b = 2.0*rnd.y-1.0;\n    \n    vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(n + dir);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Microfacet\n// ---------------------------------------------\nfloat Fresnel(float n1, float n2, float VoH, float f0, float f90)\n{\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-VoH*VoH);\n        if (sinT2 > 1.0)\n            return f90;\n        VoH = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-VoH;\n    float ret = r0+(1.0-r0)*pow(x, 5.);\n    \n    return mix(f0, f90, ret);\n}\n\n\n// ---------------------------------------------\n// SDF Utils\n// ---------------------------------------------\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat hash( float p ) \n{\n    return fract(sin(p)*43758.5453123);\n}", "buffer_a_code": "// ---------------------------------------------\n// Sky\n// ---------------------------------------------\nfloat phaseFunction(float lightDotView)\n{\n    const float k = .9;\n\tfloat v = 1.0 - k * k;\n\tv /= (4.0 * PI * pow(1.0 + k * k - (2.0 * k)*lightDotView, 1.5));\n\treturn v;\n}\nvec3 skyColor(vec3 rd, vec3 sundir)\n{\n    rd.y += .05;\n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.15, .0) * exp(-rd.y*9.); // Red / Green \n    col += vec3(.3, .4, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    \n    return min(col,vec3(1.));\n    \n}\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Distance field \n// ---------------------------------------------\nfloat slice(vec3 p, vec3 dir, float offset, float smoothEdge, float baseD) {\n    //p *= .75;\n    float y = dot(p, dir);\n    float id = floor(y+.5);\n    offset *= max(0.,sign(hash(id)*100.-50.));\n    \n    float ksmooth = smoothEdge;\n    \n    float d =  smax(baseD + hash(id)*offset, abs(y-id)-.5, ksmooth);\n    d =  min(d, smax(baseD + hash(id+1.)*offset, abs(y-id-1.)-.5, ksmooth));\n    d =  min(d, smax(baseD + hash(id-1.)*offset, abs(y-id+1.)-.5, ksmooth));\n    \n    return d;\n}\n\n\n#define ROCKITERATION 7\nfloat fractal(in vec3 pos)\n{\n    const float scale = 2.8;\n    const float minRad2 = .822;\n    const vec4 scaled8 = vec4(3.51);\n\n    vec4 p = vec4(pos,1.), p0 = p;\n    float r2;\n    for (int i=0; i<ROCKITERATION; i++)\n    {\n        p.xz = rot(-p.y*.1) * p.xz;\n        p.xy = rot(-p.z*.1) * p.xy;\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n        p = p*scaled8 + p0;\n    }\n  \treturn ((length(p.xyz) - abs(scale - 1.0)) / p.w - pow(scale, float(1-ROCKITERATION)));\n}\n\nfloat displacement( vec3 p )\n{\n    // more cool tricks -> https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\n    vec3 pp = p;\n    float mgn = .5;\n    float d = 0.;\n    for(int i=0; i<4; i++)\n    {\n        vec4 rnd = noised(p+10.);\n        d += rnd.w * mgn;\n        \n        p *= 2.;\n        p += rnd.xyz*.4;\n        mgn *= .5;\n        \n    }\n    \n    \n    return d;\n}\n\n\n#define SLICE_SIZE 25.\nfloat rock(vec3 p) {\n    vec3 pp = p;\n    p.xz = mod(p.xz-2.,4.)-2.;\n    p.xz = rot(pp.x*.05) * p.xz;\n    \n\n   // float r = length(pp.yz)-1.;\n    //r = min(length(pp.yz-vec2(.5,-2.3))-1., r);\n    float r = fractal(p);\n    float d = smin(r, p.y+.1, .1);//smin(r, p.y+.3, .2);\n    d = max(d,p.y-1.2);\n    if (r<.3) {\n        d = mix(d*1.5, displacement(pp*25.+1.3)*.02-0.002, smoothstep(-1.,-1.3, p.z)*.25+.25);\n\n        d = slice(p*SLICE_SIZE, normalize(vec3(0.0,3.,2.+cos(p.x*5.)*.2)), 0.03,.3*smoothstep(0.8,0.3,noise(p*5.+1.1))*smoothstep(-.3,0.,p.y)*step(0.,length(p.xz-vec2(-.4,-1.))-.15), d*SLICE_SIZE)/SLICE_SIZE;\n    }\n    r = d;\n    \n    \n    return r;\n}\n\nfloat traceIn = 1.;\n\nfloat water(vec3 p) {\n    if (traceIn < 0.) return 9999.;\n    const mat2 mw = mat2(1.6,1.2,-1.2,1.6);\n    float d = p.y;\n    p *= 15.;\n    float amp = .005;\n    p.xz *= mw;\n    \n    // Add detail only if we are closed of the surface\n    if (d < .2) {\n        for(int i=0; i<3; i++)\n        {\n            d -= (1.-abs(sin(noise(p.xz)))) * amp;\n            amp *= .5;\n            p.xz *= mw;\n        }\n    }\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = min(rock(p), water(p));\n    return d;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Ray tracing \n// ---------------------------------------------\nfloat trace(vec3 ro, vec3 rd, vec2 nf) {\n    traceIn = (ro+rd*nf.x).y < 0. ? -1. : 1.;\n    float t = nf.x;\n    for(int i=min(0,iFrame); i<128; i++) {\n        float d = map(ro+rd*t);\n        if (t > nf.y || abs(d)<0.001) break;\n        t += d;\n    }\n    \n    return t;\n}\nfloat trace2(vec3 ro, vec3 rd, vec2 nf) {\n    traceIn = ro.y < 0. ? -1. : 1.;\n    float t = nf.x;\n    for(int i=min(0,iFrame); i<64; i++) {\n        float d = rock(ro+rd*t);\n        if (t > nf.y || abs(d)<0.001) break;\n        t += d;\n    }\n    \n    return t;\n}\nvec3 normal(vec3 p, float t) {\n    traceIn = p.y < 0. ? -1. : 1.;\n\n    vec2 eps = vec2(0.0001,0.0);\n    float d = map(p);\n    vec3 n;\n    n.x = d - map(p - eps.xyy);\n    n.y = d - map(p - eps.yxy);\n    n.z = d - map(p - eps.yyx);\n    n = normalize(n);\n    return n;\n}\n\n\n\n\n// ---------------------------------------------\n// Raw Frame\n// ---------------------------------------------\n#define sundir normalize( vec3(-5.,5.5,-5.))\n#define suncolor vec3(1.,.45,.25)\n\n// ---------------------------------------------\n// BRDFs\n// ---------------------------------------------\nfloat moisture(vec3 p) {\n    return smoothstep(0.0,.1, abs(p.y)+(noise(p*10.)-.5)*.0);\n}\nvec3 rock_albedo(vec3 p, vec3 n) {\n    float t = moisture(p);\n    float c = displacement(p*vec3(15.));\n    \n    vec3 col = mix(vec3(1.,.6,.4)*.7, vec3(1.,.7,.5), smoothstep(0.1,.3, abs(cos(p.y*15.-p.x*3.+c*.5))))*.2;\n    \n    if (p.y > 0.)\n    col *= smoothstep(0.05,.13, abs(p.y))*.75+.25;\n    \n    col = mix(vec3(1.,.5,.8)*.05, col, saturate(t+.25));\n    return col;\n}\nvec4 sampleRockBRDF(vec3 v, vec3 n, vec3 p, out vec3 l) {\n    l = cosineSampleHemisphere(n);\n    \n    float refl = 1.-moisture(p);\n    if (frand() < refl)\n        l = reflect(-v,n);\n    return vec4(rock_albedo(p, n), 1.);\n}\n\nvec4 sampleWaterBSDF(vec3 v, vec3 n, out vec3 l, inout bool isRefracted) {\n    \n    const float ior = 1.01;\n    float dielF = Fresnel(1., ior, abs(dot(v,n)), 0., 1.);\n    \n    \n    vec4 brdf = vec4(.6,.8,1.,1.);\n    if (frand() < dielF) {\n        l = reflect(-v,n);\n        brdf.a = dielF;\n    } else {\n        isRefracted = true;\n        l = refract(-v,n, 1./ior);\n        brdf.a = 1.-dielF;\n    }\n    l = normalize(l + (frand3()*2.-1.)*.01);\n    return brdf;\n}\n\n\n// ---------------------------------------------\n// Pathtracing\n// ---------------------------------------------\nvec4 pathtrace(vec3 ro, vec3 rd) {\n    \n    float firstDepth = 0.;\n    vec3 acc = vec3(0.);\n    vec3 abso = vec3(1.);\n    \n    for(int i=min(0,iFrame); i<3; i++) {\n        // trace\n        float t = trace(ro,rd, vec2(0.01, 100.));\n        vec3 p = ro + rd * t;\n        if (i == 0) firstDepth = t;\n        \n        // sky intersection ?\n        if (t >= 100.) {\n            //acc += vec3(1.) * abso;\n            acc += skyColor(rd,sundir)*2. * abso;\n            break;\n        }\n        \n        // info at intersection point\n        vec3 n = normal(p, t);\n        \n        // sample BRDF\n        bool isWater = (map(p) == water(p));\n        vec3 outDir;\n        bool isRefracted = false;\n        vec4 bsdf;\n        if (isWater) {\n            bsdf = sampleWaterBSDF(-rd, n, outDir, isRefracted);\n        } else {\n            vec3 bump = vec3(0.);\n            bump += noised(p*1550.).xyz;\n            bump += noised(p*600.).xyz;\n            bump += noised(p*1200.).xyz;\n            bump = mix(noised(p*450.).xyz*1., bump, moisture(p));\n            n  = normalize(n+bump*.3 );\n            bsdf = sampleRockBRDF(-rd, n, p, outDir);\n        }\n        \n        // medium absorption\n        traceIn = 1.;\n        if (water(p) < 0. && t > 0.3) {\n            abso *= exp(-t * (vec3(3.,1.5,1.)) * 1.5 );\n        }\n        \n        // sun light\n        if (!isWater)\n        {\n            vec3 srd = normalize(sundir + (hash3(p)*2.-1.)*.05);\n            float tt = trace2(p+n*.0, srd, vec2(0.01, 20.));\n            acc += suncolor*12.5 * max(dot(n,srd),0.) * step(20., tt) * rock_albedo(p, n) * abso;\n        }\n        \n        // brdf absorption\n        if ( bsdf.a > 0.)\n            abso *= bsdf.rgb;\n        \n        \n        // next direction\n        ro = p;\n        rd = outDir;\n        if (isRefracted) {\n            ro -= n*0.01;\n        } else {\n            ro += n*0.01;\n        }\n    }\n\n    return vec4(acc, firstDepth);\n}\n\n\n// ---------------------------------------------\n// Entrypoint\n// ---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x >= RESOLUTION.x || fragCoord.y >= RESOLUTION.y) {\n        fragColor = vec4(0.);\n        return;\n    }\n    vec2 invRes = vec2(1.) / RESOLUTION;\n    srand(ivec2(fragCoord), iFrame);\n    \n    // setup ray\n    vec2 uv = (fragCoord + frand2()-.5) * invRes;\n    vec3 ro = normalize(vec3(cos(-0.9), 0.1, sin(-0.9)))*1.5;\n    vec2 v = uv*2.-1.;\n    v.x *= RESOLUTION.x * invRes.y;\n    \n    // setup camera\n    const vec3 up = vec3(0.,1.,0.);\n    vec3 fw = normalize(vec3(0.,0.2,-1.1)-ro);\n    vec3 uu = normalize(cross(fw, up));\n    vec3 vv = normalize(cross(uu, fw));\n    vec3 er = normalize(vec3(v,6.8));\n    vec3 rd = uu * er.x + vv * er.y + fw * er.z;\n    \n    // depth of field\n    float focusDistance = 1.;\n    float blurAmount = 0.003;\n    vec3 go = blurAmount*vec3( normalize(frand2()*2.-1.)*sqrt(frand()), 0.0 );\n    vec3 gd = normalize( er*focusDistance - go );\n    ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    rd = normalize(rd);\n    \n    \n    // pathtrace\n    vec4 col = pathtrace(ro, rd);\n    col.rgb = mix(col.rgb, vec3(.6,.8,1.)*.5, smoothstep(00.,30., col.a));\n\n    // light scattering\n    vec3 acc = vec3(0.);\n    float phase = phaseFunction(dot(sundir,rd));\n    vec3 p = ro + rd * col.a * frand();\n    vec3 srd = normalize(sundir + (hash3(p)*2.-1.)*.05);\n    float tt = trace2(p, srd, vec2(0., 20.));\n    acc += vec3(1.,.7,.5)*phase*2. * step(20., tt);\n    \n    fragColor = vec4(min(col.rgb+acc,vec3(10.)),1.);\n    fragColor += texture(iChannel0, fragCoord/iResolution.xy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 252, 252, 438], [440, 440, 497, 497, 905]], "test": "untested"}
{"id": "mt33Rr", "name": "FBM LOD Test", "author": "pnoqable", "description": "wanted to see how much work can be saved when zooming out of an fbm. I chose lodFactor for the effect to be still noticable but-depending on monitor and ambiant brightness-you may wanna go fullscreen and play with the mouse a bit to get a good impression", "tags": ["fbmlod"], "likes": 2, "viewed": 180, "published": 3, "date": "1682000394", "time_retrieved": "2024-07-30T17:59:50.435154", "image_code": "vec3 noise33(vec3 p) {\n    vec3 q = vec3(dot(p, fract(vec3(234.757, 432.131, 375.987))),\n                  dot(p, fract(vec3(432.862, 654.345, 867.123))),\n                  dot(p, fract(vec3(876.132, 654.535, 342.456))));\n    return fract(cos(q)*7684.23);\n}\n\nvec3 smoothNoise33(vec3 p) {\n    vec3 c = floor(p);\n    vec3 l = fract(p);\n    vec3 blf = noise33(c),\n         brf = noise33(c+vec3(1,0,0)),\n         tlf = noise33(c+vec3(0,1,0)),\n         trf = noise33(c+vec3(1,1,0)),\n         blb = noise33(c+vec3(0,0,1)),\n         brb = noise33(c+vec3(1,0,1)),\n         tlb = noise33(c+vec3(0,1,1)),\n         trb = noise33(c+vec3(1,1,1));\n    l = l*l*(3.-2.*l);\n    //l = l*l*l*(l*(l*6.-15.)+10.);\n    return mix(mix(mix(blf, brf, l.x), mix(tlf, trf, l.x), l.y),\n               mix(mix(blb, brb, l.x), mix(tlb, trb, l.x), l.y), l.z);\n}\n\nvec3 fbm33(vec3 p, int levels) {\n    vec3 result = vec3(0);\n    float factor = 1.;\n    for(int l=0; l<levels; l++) {\n        result += smoothNoise33(factor*p) / factor;\n        factor *= 2.;\n    }\n    result /= 2. - 2. / float(factor);\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    float zoom = pow(2., 5. - 4. * cos(0.25 * iTime));\n    \n    vec2 uv = zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = zoom * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    if(iMouse.z <= 0.){\n        m = vec2(0);\n    }\n\n    // level of detail, only on right side:\n    float lodFactor = uv.x > m.x ? 0.333 : 0.;\n    \n    float levels = 5. - round( lodFactor * log2(zoom) );\n    \n    vec3 col = fbm33(vec3(uv, 0.1*iTime), int(levels));\n    \n    col *= smoothstep(0., 2.*dFdx(uv.x), abs(uv.x-m.x));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt33Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 257], [259, 259, 287, 287, 830], [832, 832, 864, 864, 1088], [1090, 1090, 1142, 1142, 1714]], "test": "untested"}
{"id": "dtcGz4", "name": "Globumorphic", "author": "drliquidglitch", "description": "working off IQ's tutorials", "tags": ["tutorial"], "likes": 1, "viewed": 155, "published": 3, "date": "1681998748", "time_retrieved": "2024-07-30T17:59:51.303831", "image_code": "float noise(vec2 x){\nreturn fract(x.y)+fract(x.y);\n}\n\n\nfloat fbm( vec2 p ) {\n    float f = 0.;\n    f += 0.5 + noise(p);\n    f += 0.25 + noise(p);\n    f += 0.125 + noise(p);\n    f /= 0.875;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float r = 0.2 + (0.1*cos(iTime*0.5))*cos(atan(uv.y, uv.x)*10.0*cos(iTime*0.5)+(iTime*0.25));\n    \n    col *= fbm(uv.xy)*smoothstep(r, r+0.2*abs(cos(iTime)), length( uv - vec2(0.5, 0.5)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 52], [55, 55, 76, 76, 204], [206, 206, 263, 313, 692]], "test": "untested"}
{"id": "csKXzR", "name": "Orb menu", "author": "Peace", "description": "Orb menu GUI", "tags": ["orb", "menu"], "likes": 8, "viewed": 255, "published": 3, "date": "1681984123", "time_retrieved": "2024-07-30T17:59:52.304156", "image_code": "const float HALF_PI = 1.57079632679;\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat _u(vec2 uv, float w, float v) \n{\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\n\nfloat _i(vec2 uv) \n{\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\n\nfloat _j(vec2 uv) \n{\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\n\nfloat _o(vec2 uv) \n{\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\nfloat aa(vec2 uv) \n{\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\n\nfloat cc(vec2 uv) \n{\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\n\nfloat CC(vec2 uv) \n{\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))), \n                        length(uv+vec2(-.22734,-.354)));\n}\n\nfloat gg(vec2 uv) \n{\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\n\nfloat ii(vec2 uv) \n{\n    return min(_i(uv),length(vec2(uv.x,uv.y - .75)));\n}\n\nfloat nn(vec2 uv) \n{\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\n\nfloat oo(vec2 uv) \n{\n    return _o(uv);\n}\n\nfloat rr(vec2 uv) \n{\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n   \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\n\nfloat tt(vec2 uv) \n{\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\n\nfloat II(vec2 uv) \n{\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\n\nfloat OO(vec2 uv) \n{\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\n\nvec2 clc(vec2 uv, float cp, float w) \n{\n    return uv - vec2(cp - (w * .5), 0.);\n}\n\n#define ch(l,w) x = min(x, l(clc((uvo * s  - f), cp += w, w)));\n\n#define a_ ch(aa,0.9);\n#define c_ ch(cc,0.9);\n#define g_ ch(gg,0.9);\n#define i_ ch(ii,0.4);\n#define n_ ch(nn,0.9);\n#define o_ ch(oo,0.9);\n#define r_ ch(rr,0.9);\n#define t_ ch(tt,0.9);\n#define C_ ch(CC,0.9);\n#define I_ ch(II,0.9);\n#define O_ ch(OO,0.9);\n\nvec4 perm(vec4 x) { x = ((x * 34.0) + 1.0) * x; return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat fbm(vec3 p)\n{\n    return (noise(p * 1.5) + noise(p * 2.25 + 186.791) * 0.5) * 0.6;\n}\n\nfloat specular(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    return max(0.0, dot(normal, normalize(light_dir + ray_dir)));\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n    return mix(a*a, b*b, h*h) - k * h * (1.0 - h);\n}\n\nvec2 smin2(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    float m = h * h * 0.5;\n    float s = m * k * 0.5;\n    return (a < b) ? vec2(a - s, m) : vec2(b - s, 1.0 - m);\n}\n\nvec4 getColor(vec2 uv, vec3 col, float seed)\n{\n    uv += (fbm(vec3(uv, iTime * 0.5) + seed) * 2.0 - 1.0) * 0.2;\n    float l = length(uv);\n    vec3 n = normalize(vec3(uv, -1.0));\n    vec3 light_dir = normalize(vec3(2.0, 2.0, -1.0));\n    vec3 view_dir = -normalize(vec3(uv, 1.0));\n    return vec4(col + 0.25 * pow(specular(light_dir, view_dir, n), 16.0), l);   \n}\n\nvec4 getOrbs(vec2 uv)\n{\n    const float smoothness = 0.75;\n    const float morphing = .5;\n    const float blending = 0.4;\n    \n    const float total_orbs = 4.0;\n    const float denom = 1.0 / total_orbs;\n    const float denom2 = 1.0 / (total_orbs - 1.0);\n    \n    vec2 o1off = uv * 1.2 - vec2(1.5, 2.5);\n    vec2 o2off = uv * 0.5 - vec2(-1.0, 0.2);\n    vec2 o3off = uv * 1.0 - vec2(2.5, 0);\n    vec2 o4off = uv * 1.3 - vec2(0.5, -2.5);\n    \n    vec4 o1c1 = getColor(o1off, vec3(1.0, 0.4, 0.7), 876.281);\n    vec4 o1c2 = getColor(o1off, vec3(0.7, 1.0, 0.7), 692.973);\n    vec4 o1c3 = getColor(o1off, vec3(1.0, 0.3, 0.6), 125.575);\n    \n    vec4 o2c1 = getColor(o2off, vec3(1.0, 0.55, 0.8), 8793.101);\n    vec4 o2c2 = getColor(o2off, vec3(0.2, 0.70, 1.00), 3789.79);\n    vec4 o2c3 = getColor(o2off, vec3(0.1, 0.60, 1.00), 2069.734);\n    \n    vec4 o3c1 = getColor(o3off, vec3(1.0, 0.5, 0.5), 4603.639);\n    vec4 o3c2 = getColor(o3off, vec3(0.8, 0.5, 1.0), 9222.128);\n    vec4 o3c3 = getColor(o3off, vec3(1.0, 0.7, 0.8), 1578.327);\n    \n    vec4 o4c1 = getColor(o4off, vec3(1.0, 0.5, 0.5), 7547.234);\n    vec4 o4c2 = getColor(o4off, vec3(1.0, 0.5, 0.9), 6827.066);\n    vec4 o4c3 = getColor(o4off, vec3(1.0, 0.5, 0.8), 9565.631);\n    \n    float i1 = smin(o4c1.w, smin(o3c1.w, smin(o2c1.w, o1c1.w, morphing), morphing), morphing);\n    float i2 = smin(o4c2.w, smin(o3c2.w, smin(o2c2.w, o1c2.w, morphing), morphing), morphing);\n    float i3 = smin(o4c3.w, smin(o3c3.w, smin(o2c3.w, o1c3.w, morphing), morphing), morphing);\n    \n    float s1 = smoothstep(1.0 + smoothness, 1.0 - smoothness, i1);\n    float s2 = smoothstep(1.0 + smoothness, 1.0 - smoothness, i2);\n    float s3 = smoothstep(1.0 + smoothness, 1.0 - smoothness, i3);\n    \n    vec3 c1 = s1 * (\n    o1c1.rgb * (denom + denom * (denom2 * (o2c1.w + o3c1.w + o4c1.w) - o1c1.w)) + \n    o2c1.rgb * (denom + denom * (denom2 * (o1c1.w + o3c1.w + o4c1.w) - o2c1.w)) + \n    o3c1.rgb * (denom + denom * (denom2 * (o1c1.w + o2c1.w + o4c1.w) - o3c1.w)) +\n    o4c1.rgb * (denom + denom * (denom2 * (o1c1.w + o2c1.w + o3c1.w) - o4c1.w))\n    );\n    \n    vec3 c2 = s2 * (\n    o1c2.rgb * (denom + denom * (denom2 * (o2c2.w + o3c2.w + o4c2.w) - o1c2.w)) + \n    o2c2.rgb * (denom + denom * (denom2 * (o1c2.w + o3c2.w + o4c2.w) - o2c2.w)) + \n    o3c2.rgb * (denom + denom * (denom2 * (o1c2.w + o2c2.w + o4c2.w) - o3c2.w)) +\n    o4c2.rgb * (denom + denom * (denom2 * (o1c2.w + o2c2.w + o3c2.w) - o4c2.w))\n    );\n    \n    vec3 c3 = s3 * (\n    o1c3.rgb * (denom + denom * (denom2 * (o2c3.w + o3c3.w + o4c3.w) - o1c3.w)) + \n    o2c3.rgb * (denom + denom * (denom2 * (o1c3.w + o3c3.w + o4c3.w) - o2c3.w)) + \n    o3c3.rgb * (denom + denom * (denom2 * (o1c3.w + o2c3.w + o4c3.w) - o3c3.w)) +\n    o4c3.rgb * (denom + denom * (denom2 * (o1c3.w + o2c3.w + o3c3.w) - o4c3.w))\n    );\n    \n    vec3 col = mix(c1, c2, smin2(i1, i2, blending).y);\n    col = mix(col, c3, smin2(smin(i1, i2, blending), i3, blending).y);\n    \n    return vec4(col, min(min(length(o1off.x), min(length(o2off), length(o3off))), length(o4off)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uvo = uv;\n    uv *= 4.0;\n    vec4 o = getOrbs(uv);\n    fragColor = vec4(o.rgb, 1.0);\n    \n    float px = 32.0/iResolution.x;\n    float x = 1.;\n    float cp = 0.;\n    \n    vec2 f = vec2(-5.3, 0.55);\n    float s = 6.0;\n    O_ r_ i_ g_ i_ n_\n    \n    f = vec2(-1.55, 8.25);\n    s = 16.0;\n    I_ n_ t_ r_ o_\n    \n    f = vec2(-2.0, -0.1);\n    s = 16.0;\n    C_ o_ n_ t_ a_ c_ t_\n    \n    float weight = 0.125;\n    float c = clamp(.6 + 16.0 * pow(x * x + 2.0 * x * x * x - 2.0 * x * x * x * x, 1.), 0.0, 1.0);\n    fragColor.rgb = mix(mix(o.rgb, vec3(1), c), o.rgb, smoothstep(weight - px, weight + px, x));\n    //fragColor.rgb = vec3(x);\n    //fragColor.rgb = vec3(o.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 74, 74, 199], [201, 201, 239, 239, 398], [400, 400, 420, 420, 474], [476, 476, 496, 496, 727], [729, 729, 749, 749, 813], [815, 815, 835, 835, 1085], [1087, 1087, 1107, 1107, 1346], [1348, 1348, 1368, 1368, 1653], [1655, 1655, 1675, 1675, 1823], [1825, 1825, 1845, 1845, 1901], [1903, 1903, 1923, 1923, 2013], [2015, 2015, 2035, 2035, 2056], [2058, 2058, 2078, 2078, 2234], [2236, 2236, 2256, 2256, 2394], [2396, 2396, 2416, 2416, 2573], [2575, 2575, 2595, 2595, 2662], [2664, 2664, 2703, 2703, 2746], [3067, 3067, 3086, 3086, 3161], [3163, 3163, 3184, 3184, 3675], [3677, 3677, 3696, 3696, 3767], [3769, 3769, 3828, 3828, 3896], [3898, 3898, 3937, 3937, 4046], [4048, 4048, 4087, 4087, 4247], [4249, 4249, 4295, 4295, 4610], [4612, 4612, 4635, 4635, 7651]], "test": "untested"}
{"id": "DdGSRc", "name": "CM_Volume VR", "author": "CMH", "description": "First volume rendering", "tags": ["volume", "vr"], "likes": 1, "viewed": 147, "published": 3, "date": "1681983431", "time_retrieved": "2024-07-30T17:59:53.293511", "image_code": "// Author:CMH\n// Title: volumetrics (learning shader from iq's code, thanks iq!)\n\n#define PI 3.141592654\n#define TWOPI 6.283185308\nfloat noise_3(in vec3 p);\t//[0,1]\nvec3 normalMap(vec3 p, vec3 n);\nvec3 FlameColour(float f);\nvec3 viridis_quintic( float x );\nmat3 fromEuler(vec3 ang);\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p)\n{\n  vec3 b=vec3(0.4);\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nfloat bump=0.01 * (noise_3(p*30.0)*2.0-1.0);\nmat3 rot=fromEuler(vec3(0.0,0.0,iTime*0.5));\nvec3 p1=(p+vec3(0.0,-0.0,1.5))*rot;\nvec3 p2=(p+vec3(1.5,-0.5,0.0))*-rot;\nvec3 p3=(p+vec3(-1.5,-0.8,0.0))*-rot;\nvec3 p4=(p+vec3(0.0,-0.3,-1.5))*rot;\n//return sdSphere(p1+vec3(0.,0.,0.0), 0.5)+bump;\n//return sdTorus(p+vec3(0.,0.,1.5),vec2(0.4,0.2))+bump;\n//return sdBox(p+vec3(0.,0.,1.5),vec3(0.5));\n//return sdBox(p1,vec3(0.4))+bump;\nreturn min(min(min(sdBox(p1),sdBox(p2)),sdBox(p3)),sdBox(p4))+bump;\n//return udRoundBox(p+vec3(0.0,0.0,1.5), vec3(0.3, 0.3, 0.3), 0.1)+bump;\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) \n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<32; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.8; //\n\t}\nreturn t;\n}\n\nfloat HenyeyGreenstein(float g, float costh){\n\treturn (1.0/(4.0 * PI))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n//volumetric raymarch\n//https://cglearn.eu/pub/advanced-computer-graphics/volumetric-rendering\n\nfloat density(vec3 p){\n\t//return (1.0-smoothstep(0.,0.1,map(p)))*2.0;\n\treturn (smoothstep(0.,0.1,map(p)))*0.5;\n\t}\n\nvec4 VolumetricRaymarch(vec3 samplePosition, vec3 marchDirection, int stepCount, float stepSize) {\n\tfloat ambientLight=9.;\n\tfloat directLight=15.0;\n\tvec3 l=vec3(0.5,0.3,-0.8)*fromEuler(vec3(0.0,0.0,iTime*0.2));\n\tfloat absorptionCoef=0.01;\n\tfloat scatteringCoef=0.04;\n\tfloat extinctionCoef = absorptionCoef + scatteringCoef;\n\tfloat transmittance = 1.0;\n\tvec3 illumination = vec3(0.0);\n\n    for (int i = 0; i < stepCount; i++) {\n        samplePosition += marchDirection * stepSize;\n        float currentDensity = density(1.0*samplePosition);\n        transmittance *= exp(-currentDensity * extinctionCoef * stepSize);        \n        float inScattering= ambientLight + directLight * HenyeyGreenstein(0.6,dot(-marchDirection,-l));  //directLight * phase(marchDirection, -l)\n        float outScattering = scatteringCoef * currentDensity;\n        vec3 currentLight = vec3(inScattering * outScattering);\n        illumination += transmittance * currentLight * stepSize;\n    }\n    return vec4(illumination, transmittance);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\nvec3 render( in vec3 RayOri, in vec3 RayDir ){\t\n\t//First Ray\n     vec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n\t\n    //Second Ray\n    float IOR=1.33;\n    vec3 Rd_2=refract(RayDir,n,1.0/IOR);\n\t\t\n//SHADING\n    vec3 result;\n\tresult= VolumetricRaymarch(RayOri, RayDir,32,0.1).xyz;\n\t//result= VolumetricRaymarch(p, Rd_2,32,0.1).xyz;;\n\t//result= FlameColour(clamp(result.x*1.0,0.0,1.0));\n\tresult= viridis_quintic(result.x);\n\treturn result;\n}\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n//void main()\n{\nvec2 uv = gl_FragCoord.xy/iResolution.xy;\nuv = uv*2.0-1.0;\nuv.x*= iResolution.x/iResolution.y;\nuv.y*=-1.0;// uv vvy\n//vec2 mouse=(u_mouse.xy/u_resolution.xy)*2.0-1.0;\nvec2 mouse=iMouse.xy/iResolution.xy;\n\n// camera option1  ()\n    //vec3 CameraRot=vec3(0.0, -mouse.y*1.6, -mouse.x*6.28);\n    vec3 CameraRot=vec3(0.0, -0.0, -0.0);\n\tvec3 ro= vec3(0.0, 0.0, 0.0);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, -1.0)*fromEuler(CameraRot); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UEZ\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//zzoom in! iMouse.z\n\tvec3 RayOri = ro;\n\n\tvec3 col = render(RayOri,RayDir);\n    fragColor = vec4( col, 1.0 );\t\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    //float time = iTime*0.25 + 0.01*iMouse.x;\n    //float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 col = render( fragRayOri + vec3(0.0,0.0,0.0), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}\n\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec3 viridis_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdGSRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 313, 348, 348, 374], [375, 375, 406, 406, 493], [494, 494, 516, 516, 623], [624, 624, 657, 657, 722], [723, 723, 766, 809, 853], [855, 855, 877, 877, 1443], [1445, 1474, 1503, 1503, 1721], [1723, 1752, 1793, 1793, 1911], [1913, 1913, 1958, 1958, 2041], [2139, 2139, 2161, 2208, 2252], [2254, 2254, 2352, 2352, 3269], [3271, 3298, 3350, 3350, 3527], [3529, 3537, 3563, 3563, 3933], [3935, 3935, 3981, 3995, 4399], [4401, 4421, 4492, 4492, 5328], [5331, 5331, 5425, 5542, 5652], [5671, 5700, 5723, 5723, 5773], [5774, 5774, 5796, 5796, 5876], [5877, 5877, 5899, 5899, 5987], [5989, 6001, 6027, 6027, 6648], [6650, 6719, 6753, 6753, 6931], [6933, 6933, 6974, 6974, 7089], [7091, 7091, 7118, 7118, 7191], [7193, 7193, 7220, 7220, 7251], [7252, 7252, 7285, 7285, 7828]], "test": "untested"}
{"id": "DlcGRN", "name": "Happy birthday cake", "author": "cisemsu", "description": "Birthday cake drawn without using a 2D curve", "tags": ["birthday", "cake"], "likes": 1, "viewed": 171, "published": 3, "date": "1681980757", "time_retrieved": "2024-07-30T17:59:54.248957", "image_code": "vec2 remap01(vec2 x, vec2 minvalue, vec2 maxvalue){\n    return clamp((x - minvalue) / (maxvalue - minvalue), 0.0, 1.0);\n}\nfloat radian (float angle){\n//to convert to radians\nfloat rad = angle / 180.*3.14159265;\nreturn rad;\n\n}\nvec2 rotation1(vec2 center,in vec2 fragCoord,float rotation){\n    //to rotate the ellipse\n    vec2 right = vec2 (-cos(rotation), sin(rotation));\n    vec2 up = vec2(-right.y,right.x);\n    \n    vec2 asd = fragCoord - center;\n    float x = dot(asd, right);\n    float y = dot(asd, up);\n    return vec2(x,y);\n\n\n}\nvoid elips(inout vec4 fragColor,vec3 color,in vec2 fragCoord,vec2 center, float radius1, float radius2,float rotation,vec3 color2){\n\n    vec2 rot = rotation1(center,fragCoord,rotation);\n    float result = (rot.x*rot.x)/(radius1*radius1) + (rot.y*rot.y)/(radius2*radius2);\n    \n    if (result <= 1. && fragCoord.y >= center.y)\n        fragColor = vec4(color,1.0);\n    else if (result <= 1. && fragCoord.y <= center.y)\n        fragColor = vec4(color2,1.0);}\n        \nvoid circle(vec2 uv,inout vec4 fragColor, in vec2 fragCoord,vec2 center,float radius,vec3 color){\n\n   float d = length (center - uv);\n   if (d <= radius){\n        fragColor = vec4 (color,1.0);\n    }\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv2 = fragCoord.xy;\n    \n    // The centers of the circles used in the eyes of the cake\n    vec2 center2 = vec2(380.,190.);\n    vec2 center3 = vec2(450.,190.);\n    vec2 center4 = vec2(375.,195.);\n    vec2 center5 = vec2(445.,195.);\n    vec2 center6 = vec2(387.,188.);\n    vec2 center7 = vec2(457.,188.);\n    vec2 center8 = vec2(380.,186.);\n    vec2 center9 = vec2(450.,186.);\n    \n    // Creams of the first layer of the cake\n    vec2 center_1a = vec2(346.,218.);\n    vec2 center_1b = vec2(362.,218.);\n    vec2 center_1c = vec2(377.,218.);\n    vec2 center_1d = vec2(392.,218.);\n    vec2 center_1e = vec2(407.,218.);\n    vec2 center_1f = vec2(422.,218.);\n    vec2 center_1g = vec2(437.,218.);\n    vec2 center_1h = vec2(452.,218.);\n    vec2 center_1i = vec2(467.,218.);\n    vec2 center_1j = vec2(482.,218.);\n    \n    // Creams of the second layer of the cake\n    vec2 center_2a = vec2(353.,298);\n    vec2 center_2b = vec2(369.,298);\n    vec2 center_2c = vec2(384.,298);\n    vec2 center_2d = vec2(399.,298);\n    vec2 center_2e = vec2(414.,298);\n    vec2 center_2f = vec2(429.,298);\n    vec2 center_2g = vec2(444.,298);\n    vec2 center_2h = vec2(460.,298);\n    vec2 center_2i = vec2(476.,298);\n    \n    \n    \n    float radius = 0.03 * iResolution.y; // for the size of your eyes\n    float radius2 = 0.0109 * iResolution.y; //for the size of your eyes\n    float radius3 = 0.009 * iResolution.y; //for the size of your eyes\n    float radius4 = 0.019 * iResolution.y; //for creams\n    \n    \n    // for creams color\n    vec3 yellow = vec3(255.0/255.0,218.0/255.0,185.0/255.0);\n    vec3 red = vec3(135.0/255.0,206.0/255.0,325.0/255.0);\n    vec3 blue = vec3(176.0/255.0,196.0/255.0,255.0/255.0);\n    vec3 blue2 = vec3(0.0/255.0,191.0/255.0,255.0/255.0);\n    vec3 black = vec3(0.0,0.0,0.0);\n    vec3 white = vec3(1.0,1.0,1.0);\n    vec3 orange = vec3(255.0/255.0,69.0/255.0,0.0/255.);\n    vec3 orange2 = vec3(255.0/255.0,102.0/255.0,0.0/255.);\n    vec3 cream = vec3(254.0/255.0,251.0/255.0,234.0/255.);\n\n    fragColor =vec4(mix(red, yellow, fragCoord.y/450.),1.0); //for background color\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 center = vec2(0.25,0.375);\n    vec2 extent = vec2(0.25);\n    uv.x *= ratio;\n    \n     // mouth radius \n     float radius_a = 30.0;\n     float radius_b = 20.0;\n     \n     // candles radius \n     float radius_c = 5.0;\n     float radius_d = 10.0;\n     \n     //eyelash radius\n     float radius_e = 2.0;\n     float radius_f = 9.0;\n     \n     //for mouth\n     vec2 location1 = vec2(415.,155.);\n     vec2 location2 = vec2(415.,160.);\n     \n     //for candles\n     vec2 location3 = vec2(364.,370.);\n     vec2 location4 = vec2(409.,370.);\n     vec2 location5 = vec2(459.,370.);\n     \n     //for eyelash\n     vec2 location6 = vec2(462.,205.);\n     vec2 location7 = vec2(463.,198.);\n     \n     //for blue eyes \n     vec2 location8 = vec2(367.,205.);\n     vec2 location9 = vec2(365.,198.);\n     \n     \n    if (uv.x >=0.75 && uv.x <= 1.1 && uv.y >=0.25 && uv.y <=0.5) // first layer of cake\n        fragColor = vec4 (254.0/255.0,251.0/255.0,234.0/255.,1.0);\n    if (uv.x >=0.77 && uv.x <= 1.080 && uv.y >=0.45 && uv.y <=0.68) //second layer of cake\n        fragColor = vec4 (254.0/255.0,251.0/255.0,234.0/255.,1.0);\n    if (uv.x >=0.80 && uv.x <= 0.820 && uv.y >=0.682 && uv.y <=0.80) //first candle\n       fragColor = vec4 (1.0/255.0,191.0/255.0,255.0/255.,1.0);\n    if (uv.x >=0.90 && uv.x <= 0.920 && uv.y >=0.682 && uv.y <=0.80) //second candle\n       fragColor = vec4 (0.0/255.0,191.0/255.0,255.0/255.,1.0);\n    if (uv.x >=1.01 && uv.x <= 1.03 && uv.y >=0.682 && uv.y <=0.80) //third candle\n       fragColor = vec4 (0.0/255.0,191.0/255.0,255.0/255.,1.0);\n        \n        \n   circle(uv2,fragColor,fragCoord,center8,radius,blue2);\n   circle(uv2,fragColor,fragCoord,center9,radius,blue2);\n   \n   circle(uv2,fragColor,fragCoord,center2,radius,black);\n   circle(uv2,fragColor,fragCoord,center3,radius,black);\n   \n   circle(uv2,fragColor,fragCoord,center4,radius2,white);\n   circle(uv2,fragColor,fragCoord,center5,radius2,white);\n   \n   circle(uv2,fragColor,fragCoord,center6,radius3,white);\n   circle(uv2,fragColor,fragCoord,center7,radius3,white);\n   \n\n\n\n   circle(uv2,fragColor,fragCoord,center_1a,radius4,vec3(148.0/255.0,0.0/255.0,211.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1b,radius4,vec3(75.0/255.0,0.0/255.0,130.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1c,radius4,vec3(0.0/255.0,0.0/255.0,125.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1d,radius4,vec3(0.0/255.0,255./255.0,211.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1e,radius4,vec3(255.0/255.0,255.0/255.0,.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1f,radius4,vec3(255.0/255.0,127.0/255.0,0.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1g,radius4,vec3(255.0/255.0,0.0/255.0,0.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1h,radius4,vec3(255.0/255.0,20.0/255.0,147.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1i,radius4,vec3(0.0/255.0,0.0/255.0,255.0/255.));\n   circle(uv2,fragColor,fragCoord,center_1j,radius4,vec3(123.0/255.0,104.0/255.0,238.0/255.));\n   \n   \n   \n   \n   circle(uv2,fragColor,fragCoord,center_2a,radius4,vec3(123.0/255.0,104.0/255.0,238.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2b,radius4,vec3(0.0/255.0,0.0/255.0,255.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2c,radius4,vec3(255.0/255.0,20.0/255.0,147.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2d,radius4,vec3(255.0/255.0,127.0/255.0,0.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2e,radius4,vec3(255.0/255.0,255.0/255.0,.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2f,radius4,vec3(0.0/255.0,255./255.0,211.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2g,radius4,vec3(0.0/255.0,0.0/255.0,125.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2h,radius4,vec3(75.0/255.0,0.0/255.0,130.0/255.));\n   circle(uv2,fragColor,fragCoord,center_2i,radius4,vec3(148.0/255.0,0.0/255.0,211.0/255.));\n \n  \n   vec3 color =vec3(mix(orange2, orange, fragCoord.y/450.));\n\n   elips(fragColor,black,fragCoord,location1,radius_a,radius_b,radian(110.),black);\n   elips(fragColor,cream,fragCoord,location2,radius_a,radius_b,radian(110.),cream);\n   elips(fragColor,color,fragCoord,location3,radius_c,radius_d,radian(0.),color);\n   elips(fragColor,color,fragCoord,location4,radius_c,radius_d,radian(0.),color);\n   elips(fragColor,color,fragCoord,location5,radius_c,radius_d,radian(0.),color);\n   \n   elips(fragColor,black,fragCoord,location6,radius_e,radius_f,radian(45.),black);\n   elips(fragColor,black,fragCoord,location7,radius_e,radius_f,radian(45.),black);\n   elips(fragColor,black,fragCoord,location8,radius_e,radius_f,radian(145.),black);\n   elips(fragColor,black,fragCoord,location9,radius_e,radius_f,radian(145.),black);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 121], [122, 122, 149, 173, 225], [226, 226, 287, 315, 533], [534, 534, 665, 665, 989], [999, 999, 1096, 1096, 1200], [1201, 1201, 1257, 1257, 8082]], "test": "untested"}
{"id": "mlt3z8", "name": "Bicycle Day 2023", "author": "scry", "description": "Bicycle Day!\nMouse enabled!", "tags": ["3d", "hoffman", "bike"], "likes": 43, "viewed": 380, "published": 3, "date": "1681957084", "time_retrieved": "2024-07-30T17:59:55.289176", "image_code": "//////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n#define pi acos(-1.)\n#define deg pi/180.\n#define time iTime*pi/10.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n#define cs vec3(1.,2.,3)\n#define R iResolution.xy\n\nvec3 rgb2hsv(vec3 c){vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);float e = 1.0e-10;return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);}vec3 hsv2rgb(vec3 c){vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);}float bitm(vec2 uv,int c) {float h = 5.;float w = 3.;int p = int(pow(2.,w));float line1 = 9591.;uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);float c1 = 0.;float cc = uv.x + uv.y*w;c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);c1 *= step(0.,uv.x)*step(0.,uv.y);c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));return (c1);}vec3 slogo(vec2 uv, float ar, float size) {size = 240./size;uv.x = 1.-uv.x;vec2 px = vec2(1./3.,1./5.);float ls = 4.1;uv *= 240./5.25/size;ls += 2.;float ul = length(uv);ul = length(vec2(uv.x*0.5,uv.y)-0.5);uv -= 0.4;uv.x *= ar*1.75;uv.y *= 1.04;int s = 29671;int c = 29263;int r = 31469;int y = 23186;uv.x= 5.-uv.x;float b = bitm(uv,s);uv.x -= 1./3.*4.;b += bitm(uv,c);uv.x -= 1./3.*4.;b += bitm(uv,r);uv.x -= 1./3.*4.;b += bitm(uv,y);float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));b = clamp(b,0.,1.);vec3 l = hsv2rgb(vec3(b+iTime/40.,0.1,rr-b*1.9))*rr;l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);return vec3(l);}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = a-b;\n    return 0.5*( (a+b) - sqrt(h*h+k) );\n}\n\nvec3 cpos() {\n    vec3 c = vec3(0.);\n    c.z -= 5.;\n    c.y += 2.;\n    c.x += 4.;\n    c.z += sin(time*4.)*0.4;\n    c.x += cos(time*2.-pi/2.)*0.6;\n    c.y += cos(time*4.)*0.45;\n    if (iMouse.z > 0.) {\n        c.xz *= r2d(-(iMouse.x/R.x)*pi*2.);\n        c.y += (iMouse.y/R.y)*12.;\n        c.y -= 4.;\n    }\n    //c.yz *= r2d(-(iMouse.y/R.y)*pi);\n    return c;\n}\n\nmat4 v() {\n    vec3 c = cpos();\n    vec3 l = c*0.;\n    vec3 f = normalize(l-c);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 u = cross(f,r);\n    return mat4(r,0,u,0,f,0,vec3(0.),1.);\n}\n\nfloat sdCyl(vec3 p, vec2 s) {\n    return max(length(p.xz)-s.x,abs(p.y)-s.y);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdVCap( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat bikeframe(vec3 p) {\n    vec3 o = p;\n    float th = 0.015;\n    float mk = 0.0002;\n    float d = sdVCap(p.yxz+vec3(-0.9,0.7,0.),1.58,th);\n    d = smin(d,sdVCap(vec3(p.xy*r2d(deg*20.),p.z)+vec3(0.4,0.45,0.),1.54,th),mk);\n    d = smin(d,sdVCap(vec3(p.xy*r2d(deg*-43.),p.z)+vec3(-0.2,0.5,0.),1.65,th),mk);\n    d = smin(d,sdVCap(vec3(p.xy*r2d(deg*20.),p.z)+vec3(-1.15,-0.2,0.),0.7,th),mk);\n    vec2 fb = p.xy*r2d(deg*20.);\n    p.z = abs(p.z)-(0.-(fb.x)*1.)*0.1;\n    d = smin(d,sdVCap(vec3(p.xy*r2d(deg*-30.),p.z)+vec3(1.1,1.,0.),1.4,th),mk);\n    d = smin(d,sdVCap(vec3(p.xy*r2d(deg*-100.),p.z)+vec3(-0.6,1.34,0.),1.2,th),mk);\n    p = o;\n    d = smin(d,sdCappedTorus(vec3(p.z,p.yx*r2d(deg*-20.))+vec3(0.,-0.1,-1.15),vec2(1.,0.),0.07,0.02),mk);\n    d = smin(d,sdVCap(vec3(p.xy*r2d(deg*20.),abs(p.z)-0.07)+vec3(-1.15,0.9,0.),1.,th),mk);\n    //p.z = abs(p.z)-(0.2-fb.y)*0.1;\n    //d = smin(d,sdVCap(vec3(p.xy*r2d(deg*20.),p.z)+vec3(-1.15,0.4,0.),0.7,th),mk);\n    return d;\n}\n\nfloat wheels(vec3 p) {\n    vec3 o = p;\n    p.x = abs(p.x)-1.45;\n    p.y += 0.38;\n    float d = sdTorus(p.xzy,vec2(0.9,0.01));\n    d = min(d,length(p)-0.01);\n    p.xy = vec2(length(p.xy),atan(p.x,p.y));\n    p.y /= pi;\n    float sc = 16.;\n    p.y = (fract(p.y*sc+time/pi*30.*(step(o.x,0.)-0.5)*2.)-sc*1.54)/sc;\n    p.y *= pi;\n    p.xy = vec2(p.x*sin(p.y),p.x*cos(p.y));\n    d = min(d,sdVCap(p.yxz,0.9,0.01));\n    return d;\n}\n\nfloat handlebars(vec3 p) {\n    vec3 o = p;\n    p.z = abs(p.z)-0.6;\n    float th = 0.015;\n    float mk = 0.0002;\n    float d = (sdVCap(vec3(p.yx,p.z)+vec3(-1.3,-0.75,0.),0.2,th));\n    d = smin(d,sdCappedTorus(vec3(p.yx,p.z)+vec3(-1.4,-0.98,0.),vec2(1.,0.),0.1,0.02),mk);\n    d = smin(d,sdVCap(vec3(p.yx,p.z)+vec3(-1.5,-0.68,0.),0.24,th*2.),mk);\n    d = smin(d,sdVCap(vec3(p.x,-p.z,p.y)+vec3(-0.72,-0.,-1.28),01.24,th*2.),mk);\n    return d;\n}\n\nfloat seat(vec3 p) {\n    vec3 o = p;\n    float s = 0.9;\n    p /= s;\n    p += vec3(0.8,-1.4,0.);\n    float d = smin(sdRhombus(p.zyx, 0.1, 0.3, 0.01, 0.1),sdRhombus(p+vec3(0.2,0.,0.), 0.1, 0.15, 0.01, 0.2)-0.01,0.002);\n    d *= s;\n    p /= s;\n    p.y += 0.04;\n    d = min(d,smin(sdRhombus(p.zyx, 0.1, 0.3, 0.01, 0.1),sdRhombus(p+vec3(0.2,0.,0.), 0.1, 0.15, 0.01, 0.2),0.002)*s);\n    p = o;\n    float th = 0.01;\n    float mk = 0.;\n    float sl = 0.64;\n    d = smin(d,sdVCap(vec3(p.xy*r2d(deg*20.),p.z)+vec3(0.4,-1.1+sl/2.,0.),sl,th),mk);\n    return d;\n}\n\nfloat pedals(vec3 p) {\n    float th = 0.02;\n    float s = 0.6;\n    float s2 = 0.1;\n    float mk = 0.0002;\n    vec3 o = p;\n    float ps = 4.;\n    p += vec3(0.2,0.5,0.);\n    p.xy *= r2d(time*-ps);\n    float d = (sdVCap(vec3(p.xz,p.y)+vec3(0.,s/4.,0.),s/2.,th));\n    d = smin(d,sdVCap(vec3(p.yx,p.z)+vec3(0.,0.,s/4.),s2,th),mk);\n    d = smin(d,sdVCap(vec3(p.yx,p.z)+vec3(0.,s2,-s/4.),s2,th),mk);\n    vec3 p1 = vec3(-s2,0.,s/2.);\n    vec3 p2 = vec3(s2,0.,-s/2.);\n    p1 = p+p1;\n    p2 = p+p2;\n    \n    p1.yx *= r2d(time*-ps);\n    p2.xy *= r2d(time*ps);\n    //vec3 p1 = vec3(p.yx,p.z)+vec3(0.,0.,s/2.);\n    //vec3 p2 = vec3(p.yx,p.z)+vec3(0.,s2,-s/2.);\n    s2 *= 1.4;\n    //d = smin(d,sdBox(p1,vec3(s2*1.2,th,s2),0.),mk);\n    //d = smin(d,sdBox(p2,vec3(s2*1.2,th,s2),0.),mk);\n    d = smin(d,sdBoxFrame(p1,vec3(s2*1.2,th,s2),0.),mk);\n    d = smin(d,sdBoxFrame(p2,vec3(s2*1.2,th,s2),0.),mk);\n    d = smin(d,sdBoxFrame(p1,vec3(s2*.5,th,s2),0.),mk);\n    d = smin(d,sdBoxFrame(p2,vec3(s2*.5,th,s2),0.),mk);\n    return d;\n}\n\nvec4 map(vec3 p, float rt) {\n    vec3 o = p;\n    p = (v()*vec4(p,1.)).xyz+cpos();\n    //p.xz *= r2d(deg*-75.+time*2.+rt);\n    //float d = sdCyl(p,vec2(0.1,0.5));\n    p.x += .5;\n    float d = bikeframe(p);\n    d = min(d,wheels(p));\n    d = min(d,handlebars(p));\n    d = min(d,seat(p));\n    d = min(d,pedals(p));\n    p.y += 1.4;\n    float px = floor(p.x+time/pi*5.);\n    p.x = fract(p.x+time/pi*5.)-0.5;\n    px = fract(px/5.)-0.5;\n    px = abs(px);\n    d = min(d,sdBoxFrame(p,vec3(0.5,0.1,0.4+px),0.));\n    return vec4(p,d);\n}\n\nvec3 calcNorm(vec3 p, float rt) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p-h.yyx,rt).w-map(p+h.yyx,rt).w,\n        map(p-h.yxy,rt).w-map(p+h.yxy,rt).w,\n        map(p-h.xyy,rt).w-map(p+h.xyy,rt).w\n    ));\n}\n\nvec2 RM(vec3 ro, vec3 rd, float rt) {\n    float dx = 0.;\n    float ii = 0.;\n    for (int i=0;i<70;i++) {\n        vec3 p = ro+rd*dx;\n        float dS = map(p,rt).w;\n        dx += dS/5.;\n        ii += 0.01/5.;\n        if (dx > 20. || dS < 0.015) {break;}\n    }\n    return vec2(dx,ii);\n}\n\nvec3 colo(vec3 p, vec3 n, vec3 ro, vec3 rd, vec2 d, float rt) {\n    vec3 col = vec3(0.);\n    float ebg = exp(-0.05*d.x);\n    //col += d.x/20.;\n    vec3 bg = vec3(0.);\n    float mrd = max(atan(rd.x-d.x,rd.y),atan(rd.x+d.x,rd.y));\n    col += n;\n    col = (col*ebg)+(bg*(1.-ebg));\n    col = clamp(col,0.,1.);\n    col += sin(cs+d.y*20.+time*4.+(rt)*pi/20.+atan(rd.x,rd.y)*0.+mrd*120.);\n    col -= floor(col)*0.1;\n    \n    col = sin(atan(rd.x-d.y,rd.y)*20.+atan(rd.x+d.y,rd.y)*20.+cs)*0.3+col*0.7;\n    col += sin(cs+d.y*80.+time*4.)*0.1+0.2;\n    vec3 acol = col;\n    col -= 0.34;\n    col *= 1.;\n    col = floor(col*4.)/5.;\n    col = mix(col,acol,sin(length(rd.xy)*50.+time*-10.)*0.2+0.8);\n    return col;\n}\n\nvec3 frm(vec2 uv, float rt) {\n    vec3 col = vec3(0.);\n    float r = 10./4.;\n    uv = fract(uv)-0.5;\n    //uv = (fract(uv*r)-0.5);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.4));\n    vec2 d = RM(ro,rd,rt);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p,rt);\n    col += colo(p,n,ro,rd,d,rt);\n    col = clamp(col,0.,1.);\n    return col;\n}\n\nvec3 tabs(vec2 uv) {\n    vec3 col = vec3(0.);\n    uv *= 1.1;\n    uv += 0.5;\n    \n    vec2 ov = uv;\n    float r = 1.;\n    //uv.y = log(uv.y+0.5);\n    if (abs(uv.x) > 0.4) {\n        \n        //uv *= r2d(sin(time*2.)*deg*90.);\n        //uv.y = abs(uv.y);\n        //uv *= r2d(-time);\n        //uv.x += time/10.+floor(uv.y*r-0.)/5.5;\n    }\n    uv.y += sin(time*2.+uv.x*25.)*0.005;\n    uv.x += cos(time*2.+uv.y*24.)*0.005;\n    //uv.y += time/pi/10.*5.;\n    vec2 cv = uv;\n    uv = (fract(uv*r-0.5)-0.5)/r;\n    //col += sin(atan(uv.x,uv.y)+cs);\n    vec2 dv = uv;\n    float dr = 600./pi;\n    dv = (fract(dv*dr-0.5)-0.5)/dr;\n    vec3 pc = sin(atan(dv.x,dv.y)+cs+time*20.+ov.y*100.+ov.x*40.);\n    float perf = smoothstep(0.001,0.,min(abs(uv.x),abs(uv.y))-0.001)*(sin(uv.x*600.+uv.y*600.)*0.5+0.5);\n    col += perf*pc;\n    //col += frm(cv*5.,0.);\n    col += frm(fract(cv*r),abs(abs(floor(cv.x*r))-1.)+floor(cv.y*r)*pi*2.);\n    //col += frm(fract(cv*r),floor(cv.x*10.)+floor(cv.y*10.));\n    //col += sin(abs(uv.x*20.)*10.+cs+sin(abs(uv.y)*20.)*10.)*0.7;\n    //col -= sin(perf*1.+4.+sin(ov.y)*20.)*perf;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = R.x/R.y;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    //uv *= 0.4;\n    vec3 col = vec3(0.);\n    float br = 582./388.;\n    vec2 brv = vec2(tv.x,1.-tv.y);\n    brv -= 0.5;\n    brv.x /= br;\n    brv *= 1.5;\n    brv += 0.5;\n    vec3 bikeref = texture(iChannel0,brv).xyz;\n    vec3 t = tabs(uv);\n    //col = frm(uv);\n    col = t;\n    col = clamp(col,0.,1.);\n    col *= smoothstep(0.08,0.,max(abs(uv.x),abs(uv.y))-0.4);\n    //col = mix(col,bikeref,0.2);\n    tv.x -= 0.2;\n    tv.x *= ar;\n    \n    col += slogo(tv,1.,300./1.)*(sin(vec3(cs*0.6+tv.x*20.))*0.4+0.6)*0.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlt3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 243, 243, 292], [345, 345, 366, 366, 665], [665, 665, 686, 686, 839], [839, 839, 866, 866, 1167], [1167, 1167, 1210, 1210, 1828], [1832, 1832, 1873, 1873, 1934], [1936, 1936, 1949, 1949, 2295], [2297, 2297, 2307, 2307, 2491], [2493, 2493, 2522, 2522, 2571], [2573, 2573, 2606, 2606, 2671], [2672, 2672, 2742, 2742, 2876], [2877, 2877, 2919, 2919, 2978], [2980, 2980, 3025, 3025, 3312], [3314, 3314, 3354, 3354, 3445], [3447, 3447, 3476, 3476, 3504], [3506, 3506, 3570, 3570, 3821], [3823, 3823, 3848, 3848, 4793], [4795, 4795, 4817, 4817, 5217], [5219, 5219, 5245, 5245, 5659], [5661, 5661, 5681, 5681, 6211], [6213, 6213, 6235, 6235, 7225], [7227, 7227, 7255, 7255, 7751], [7753, 7753, 7786, 7786, 7986], [7988, 7988, 8025, 8025, 8272], [8274, 8274, 8337, 8337, 8975], [8977, 8977, 9006, 9006, 9329], [9331, 9331, 9351, 9351, 10438], [10440, 10440, 10495, 10495, 11153]], "test": "untested"}
{"id": "wtGGDw", "name": "datamosh", "author": "armonnaeini", "description": "datamosh", "tags": ["campinput"], "likes": 1, "viewed": 554, "published": 3, "date": "1681952595", "time_retrieved": "2024-07-30T17:59:56.163837", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 1.5453);\n}\n\n\nfloat perlin(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 colorVariation(vec2 coord, float time) {\n    // Generate Perlin noise based on the coordinate and time\n    float noiseValue = perlin(coord * 1.0 + time * 1.0);\n\n    // Map the noise value to a color offset\n    vec3 colorOffset = vec3(\n        sin(noiseValue * 12.0) * 0.95 + 0.905,\n        cos(noiseValue * 12.0) * 0.9095 + 0.905,\n        sin(noiseValue*12.0) * 0.395 + 0.025\n    );\n\n    return colorOffset;\n}\n\nvec2 displace2(vec2 coord, float time) {\n    float noiseValue = perlin(coord * 5.0 + time*2.0);\n    \n    // Calculate the distance from the current coordinate to the center of the image\n    vec2 center = vec2(0.5, 0.0);\n    float distance = length(coord - center);\n    \n    // Calculate the displacement vector\n    vec2 displacement = vec2(cos(noiseValue) * 0.5 + 0.5, tan(noiseValue) * 0.5 + 0.5);\n    \n    // Scale the displacement vector based on the distance to the center\n    float scale =  distance-.5;\n    displacement *= scale/5.;\n    return coord + displacement*4.0;\n    \n    //return coord + vec2(cos(noiseValue) * 0.5 + 0.5, sin(noiseValue) * 0.5 + 0.5);\n}\n\nfloat avg(vec4 color) {\n    float displacement = (color.r/color.r*color.r)*sin(iTime/2.);\n    // Threshold to determine if the displacement is minimal\n    float threshold = 0.5;\n\n    // Return 0 if the displacement is below the threshold, otherwise return the calculated displacement\n    return (abs(displacement) < threshold) ? 0.0 : displacement;\n}\n\n// New function to create pixelated texture coordinates\nvec2 pixelate(vec2 coord, float pixelSize) {\n    return floor(coord * pixelSize) / pixelSize;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy);\n\n    // Pixelation factor (higher values for more pixelation)\n    //float pixelationFactor = sin(iTime) + sin(iTime / 4.0) * 256.0;\n    float pixelationFactor = 256.0;\n    // Use pixelated texture coordinates for displacement\n    \n    vec2 pixelatedCoord = pixelate(uv, pixelationFactor);\n    vec4 displace = texture(iChannel1, vec2(pixelatedCoord));\n    displace.rg *= vec2(cos(iTime + pixelatedCoord.y * cos(iTime/12.0)*4.0) * 0.5 + 0.5, sin(iTime + pixelatedCoord.y * 1.0) * 0.5 + 0.5);\n    \n    vec2 displaceNew = displace2(pixelatedCoord.xy, iTime);\n\n  \n    \n    // Datamosh effect\n    float displaceFactor = 1.151;\n    vec2 datamoshUV = displace.rg * displaceFactor;\n    vec3 colorVar = colorVariation(datamoshUV, iTime);\n    vec4 datamosh = texture(iChannel0, datamoshUV);\n    \n    fragColor = vec4(datamosh.rgb / colorVar.rgb, datamosh.a);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float avg(vec4 color) {\n    float displacement = (color.r/color.r*color.r)*sin(iTime/2.);\n     // Threshold to determine if the displacement is minimal\n    float threshold = 0.011125;\n\n    // Return 0 if the displacement is below the threshold, otherwise return the calculated displacement\n    return (abs(displacement) < threshold) ? 0.0 : displacement;\n}\n\n\n// New function to create pixelated texture coordinates\nvec2 pixelate(vec2 coord, float pixelSize) {\n    return floor(coord * pixelSize) / pixelSize;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    float drunk = 0.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec2 normalizedCoord = mod((fragCoord.xy + vec2(0, drunk)) / iResolution.xy, 1.0);\n    \n    // Mirror the UV coordinates at the top and bottom\n    vec2 mirroredUV = vec2(uv.x, 1.0 - abs(uv.y * 2.0 - 1.0));\n\n    // Pixelation factor (higher values for more pixelation)\n    float pixelationFactor = cos(iTime)+sin(iTime/4.0)*512.0;\n\n    // Use pixelated texture coordinates for displacement\n    vec2 pixelatedCoord = pixelate(normalizedCoord, pixelationFactor);\n    vec4 displace = texture(iChannel1, vec2(pixelatedCoord));\n    \n    //datamosh effect\n    float displaceFactor = 0.2;\n    vec2 datamoshUV = uv + displace.gr * displaceFactor;\n    \n    // Background image\n    vec4 background = texture(iChannel0, vec2(uv.y, uv.y));\n    vec4 background2 = texture(iChannel1, vec2(uv.x, uv.y - avg(displace*12.)));\n       \n    vec4 datamosh = texture(iChannel0, datamoshUV);\n    // Output to screen\n   // fragColor = (displace)*.01 * background + background2;\n    fragColor = datamosh;\n}\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 83], [86, 86, 107, 107, 316], [318, 318, 363, 425, 732], [734, 734, 774, 774, 1401], [1403, 1403, 1426, 1426, 1753], [1755, 1811, 1855, 1855, 1906], [1908, 1908, 1963, 2013, 2907]], "test": "untested"}
{"id": "Dtt3zH", "name": "Color Study - Plate IV-1a", "author": "Slals", "description": "Relative temperature study :\n\nThe center olive grey appears to be different because of the background temperature.", "tags": ["interactionofcolor"], "likes": 0, "viewed": 148, "published": 3, "date": "1681943252", "time_retrieved": "2024-07-30T17:59:57.182114", "image_code": "float rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - step(size, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(1.0);\n    \n    vec2 S = vec2(0.3, 0.8);\n    \n    vec2 offset = vec2(0.2, 0.0);\n    \n    float MX = iMouse.x / iResolution.x;\n    float MY = iMouse.y / iResolution.y; \n    \n    vec3 leftAColor = vec3(0.8, 0.9, 0.84);\n    vec3 rightAColor = vec3(0.572, 0.316, 0.444);\n    vec3 BColor = vec3(0.572, 0.572, 0.448);\n    \n    float ASize = 1.0;\n    float BSize = 0.7;\n    \n    float rectALeft = fill(rectSDF(uv + offset, S), ASize);\n    float rectARight = fill(rectSDF(uv - offset, S), ASize);\n    float rectBLeft = fill(rectSDF(uv + offset, S), BSize);\n    float rectBRight = fill(rectSDF(uv - offset, S), BSize);\n    \n    color = mix(mix(leftAColor, rightAColor, MX) * rectALeft, BColor * rectBLeft, rectBLeft);\n    color += mix(mix(rightAColor, leftAColor, MY) * rectARight, BColor * rectBRight, rectBRight);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtt3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 109], [111, 111, 144, 144, 178], [180, 180, 237, 287, 1197]], "test": "untested"}
{"id": "cttGRH", "name": "Bike zone", "author": "NinjaKoala", "description": "German bike zone sign", "tags": ["2d", "bike"], "likes": 5, "viewed": 152, "published": 3, "date": "1681941603", "time_retrieved": "2024-07-30T17:59:58.395869", "image_code": "float cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0;\n\n\tfloat d0 = 1e38;\n\n\tfloat t0=0.;\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0-uv,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=(((a3 * t) + a2) * t + a1) * t + a0-uv;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\n\t\tt0+=.5;\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot(float t){\n\treturn mat2(cos(t),sin(t),-sin(t),cos(t));\n}\n\nfloat line_segment_dis( vec2 p, vec2 a, vec2 b, float fac){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, fac );\n\treturn length(pa - ba*h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= vec2(.5,.55);\n    uv.y *= iResolution.y/iResolution.x;\n\n\tfloat border = 2./iResolution.x;\n\n\tfloat zoom = 3.;\n\n\tuv*=zoom;\n\tborder*=zoom;\n\n\tfloat dis = 1e38;\n\n\tdis = min(dis,abs(length(uv-vec2(.2,0))-.1)-.01);\n\tdis = min(dis,abs(length(uv+vec2(.2,0))-.1)-.01);\n\tdis = min(dis,line_segment_dis(uv, vec2(-.2,0), vec2(-.11,.17), 1.)-.01);\n\tdis = min(dis,line_segment_dis(uv, vec2(.2,0), vec2(.05,0), 1.)-.01);\n\tdis = min(dis,line_segment_dis(uv, vec2(.2,0), vec2(.125,.17), 1.)-.01);\n\tdis = min(dis,line_segment_dis(uv, vec2(.05,0), vec2(.125,.17), 1.2)-.01);\n\tdis = min(dis,line_segment_dis(uv, vec2(-.11,.17), vec2(.125,.17), 1.)-.01);\n\tdis = min(dis,line_segment_dis(uv, vec2(-.12,.15), vec2(.05,0), 1.)-.01);\n\tdis = min(dis,line_segment_dis(uv, vec2(.11,.21), vec2(.16,.21), 1.)-.01);\n\tdis = min(dis,cubic_bezier_dis(uv, vec2(-.11,.17), vec2(-.11,.17) + .4*vec2(.09,.17), vec2(-.1,.24), vec2(-.03,.24))-.01);\n\n\tvec3 color = mix(vec3(.08,.28,.53),vec3(1),smoothstep(0.,border,length(uv-vec2(0,.05))-.37));\n\tcolor = mix(vec3(1),color,smoothstep(0.,border,dis));\n\n\tdis = sdBox(uv+vec2(.3,.4),vec2(.07,.015));\n\tdis = min(dis,sdBox(uv+vec2(.3,.6),vec2(.07,.015)));\n\tdis = min(dis,sdBox((uv+vec2(.3,.5))*rot(-.548),vec2(.015,.11)));\n\n\tdis = min(dis, cubic_bezier_dis(uv,-vec2(.185,.5),-vec2(.185,.64), -vec2(.045,.64), -vec2(.045,.5))-.015);\n\tdis = min(dis, cubic_bezier_dis(uv,-vec2(.185,.5),-vec2(.185,.36), -vec2(.045,.36), -vec2(.045,.5))-.015);\n\n\tdis = min(dis,sdBox(uv-vec2(.17,-.5),vec2(.015,.116)));\n\tdis = min(dis,sdBox(uv-vec2(.02,-.5),vec2(.015,.116)));\n\tdis = min(dis,sdBox((uv-vec2(.095,-.5))*rot(.595),vec2(.015,.13)));\n\n\tdis = min(dis,abs(sdBox(uv+vec2(0,.08),vec2(.6))-.02)-.02);\n\tdis = min(dis,sdBox(uv-vec2(.3,-.4),vec2(.07,.015)));\n\tdis = min(dis,sdBox(uv-vec2(.3,-.6),vec2(.07,.015)));\n\tdis = min(dis,sdBox(uv-vec2(.29,-.5),vec2(.06,.015)));\n\tdis = min(dis,sdBox(uv-vec2(.245,-.5),vec2(.015,.09)));\n\n\n\tcolor = mix(vec3(0),color,smoothstep(0.,border,dis));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 81, 81, 256], [258, 258, 326, 326, 762], [764, 764, 793, 793, 873], [875, 875, 893, 893, 939], [941, 941, 1000, 1000, 1108], [1110, 1110, 1161, 1161, 3208]], "test": "untested"}
{"id": "Dtd3z8", "name": "pixel sort golf", "author": "01000001", "description": "First time I ever figured out how to do pixel sorting. And it's golfed too because why not :D\nf r o g  x2  :P\n\nVersion 1: 325 chars\nVersion 2: 320 chars (added comma after frog to reduce vec4 declarations)", "tags": ["sort"], "likes": 7, "viewed": 233, "published": 3, "date": "1681934203", "time_retrieved": "2024-07-30T17:59:59.695394", "image_code": "void mainImage( out vec4 f, vec2 o )\n{\n    f r o g;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 c, vec2 o )\n{\n    vec2 v = (o g;\n    float d = mod(o.x+float(iFrame)+o.y, 2.);\n\n    vec4 \n    \n    f r o g\n    \n    , b r (o + vec2(d * 2. - 1., 0)) g;\n    \n    if (d > .0) c = z b) < z f)?b:f;\n    else c = z b) > z f)?b:f;\n    \n    c = iFrame<9?texture(iChannel1, v):c; \n    \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define z length(\n#define r =texture(iChannel0,\n#define g /iResolution.xy)\n\n//abusing defines as much as possible\n//this one absolutely is obfuscated :D", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtd3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dlcGRH", "name": "tiny code star - spiral stepping", "author": "flockaroo", "description": "special thing here is that im stepping in a narrow spiral in view direction. the normal is then calculated from the triangle formed by last 3 step-points.\n...also check 1tweet version (no refl) [url]https://twigl.app/?ol=true&ss=-NTOvYWIEieDpcGD3IMg[/url]", "tags": ["normals", "spiral", "tiny", "octahedra", "golfed", "twigl"], "likes": 43, "viewed": 526, "published": 3, "date": "1681921939", "time_retrieved": "2024-07-30T18:00:00.531160", "image_code": "// created by florian berger (flockaroo) - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 5 intersecting octahedra\n\n// less than 1 tweet in twigl.app (no cubemap there):\n// https://twigl.app/?ol=true&ss=-NTOvYWIEieDpcGD3IMg\n\n//  explanation of spiral-stepping:\n// ---------------------------------\n//\n//  special thing here is that im stepping in a narrow spiral in view direction\n//  the normal is then calculated from the triangle formed by last 3 step-points\n// \n//  i think it works quite well, and might be even practicable for non-golfed code\n//\n\n\n#define rotate2D(x) mat2(cos(x-1.57*vec4(0,1,-1,0)))\n#define t iTime\n#define r iResolution\n#define FC vec4(c,0,1)\n\nvoid mainImage( out vec4 o, in vec2 c )\n{\n    vec3 z=vec3(0,0,85),q=z,p,u,v;\n    for(float w,d,i=0.;i++<80.;v=u,u=q,q+=(FC.rgb*2.-r.xyx)/r.x*d+vec3(sin(i),cos(i),0)) // sin,cos = spiral offs in x,y\n       for(d=w=6.;w>0.;w-=1.26){\n          p=q;p.xz*=rotate2D(t+w);p.xy*=rotate2D(1.);d=min(d,dot(p+sin(p)*.2,sign(p)*.3)-9.);\n       }\n    u=cross(q-u,q-v); // normal = cross product of 2 triangle edges (last 3 step points u,v,q)\n    o.xyz=texture(iChannel0,reflect(q-z,u)).xyz-u*.1;\n}\n\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcGRH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[718, 718, 759, 759, 1202]], "test": "untested"}
{"id": "dt33z8", "name": "Aurora Apollalis", "author": "QuantumSuper", "description": "An auto-VJ with a few simple frequency & compression visualizations. Utilizing buffer for frame blending & recent max amplitude indicators. \n\n- Use with audio in iChannel0 of Buffer A -", "tags": ["2d", "music", "buffer", "virtualdj"], "likes": 1, "viewed": 172, "published": 3, "date": "1681917257", "time_retrieved": "2024-07-30T18:00:02.122904", "image_code": "// Aurora Apollalis 0.13.230420 by QuantumSuper\n// auto-vj with simple frequency & compression visualizations\n// ...and more debugging than designing to get it running in VirtualDJ\n//\n// - use with audio in iChannel0 of Buffer A -\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = texelFetch( iChannel1, ivec2(fragCoord), 0).rgb; //read buffer\n    col *= abs(sin(.2666*iTime+vec3(0,.7854,1.571))); //color shift\n    fragColor = vec4( col, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// BUFFER A (0.22) of Aurora Apollalis by QuantumSuper\n// workaround for VirtualDJ to get music iChannel recognized & avoid buffer self read\n// iFrameRate also seem incompatible, use define to match yours\n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define FRAMERATE 30.\n \nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n}\n\nvoid mainImage( out vec4 col, in vec2 fC){\n    compressFft(); //initializes fft, ffts\n    vec2 uv = fC/iResolution.xy; //x,y each 0 to 1\n    \n    // Save sound info\n         if (fC.y<1.) col = fft;\n    else if (fC.y<2.) col = ffts;\n    else if (fC.y<3.) col.r = texelFetch(iChannel0,ivec2(uv.x*512.,0),0).x;\n    else if (fC.y<4.) col = (iFrame>1)? vec4(clamp( texelFetch( iChannel1, ivec2(fC.x,3), 0).r - .25/FRAMERATE, 3./iResolution.y, 1.)) : vec4(4./iResolution.y); //lastMax \n    else col = vec4(.5,.2,1.,0)*texelFetch(iChannel1,ivec2(fC.xy),0).x + clamp(texelFetch(iChannel0,ivec2(uv.x*512.,0),0).x-uv.y +4./iResolution.y,-.1,1.);\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// BUFFER B (0.44) of Aurora Apollalis by QuantumSuper\n// frame blending, recent max amplitude per frequency update, spectrum compressed into symbols\n// bonus: including rain when max indicator hits bottom of screen (marker hits its own position memory buffer)\n// \n// - use with audio in iChannel0 of Buffer A -\n\nfloat circ(vec2 pos, float rad){\n    rad -= length(pos);\n    return smoothstep(fwidth(-rad),0.,-rad);\n}\n\nfloat square(vec2 pos, float width){\n    pos = abs(pos)-width/2.;\n    width = max(pos.x,pos.y);\n    return smoothstep(fwidth(width),0.,width);\n}\n\nfloat triangle(vec2 pos, float scale){ //based on: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    pos /= scale;\n    pos = vec2( abs(pos.x) - 1., pos.y + 1./k);\n    if (pos.x+k*pos.y>0.) pos = vec2(pos.x-k*pos.y,-k*pos.x-pos.y)/2.;\n    pos.x -= clamp(pos.x,-2.,0.);\n    scale = -length(pos)*sign(pos.y);\n    return smoothstep(fwidth(scale),0.,scale);\n}\n\nvoid mainImage( out vec4 col, in vec2 fC){\n    vec2 uv = fC/iResolution.xy; //x,y each 0 to 1\n    vec2 uvs = (2.*fC-iResolution.xy) / max( iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    \n    // Sound texture & color fade\n    float amp = texelFetch( iChannel0, ivec2(fC.x,2), 0).r; //read prepared sound info (workaround)\n    vec4 ffts = texelFetch( iChannel0, ivec2(1), 0); //read prepared compression info 2 (workaround)\n    vec4 fft = texelFetch( iChannel0, ivec2(0), 0); //read prepared compression info 1 (workaround)\n    col = texelFetch( iChannel0, ivec2(fC.xy), 0);\n    if (fC.y>4.) col.g += .7*fft.w; //green tint atop\n    \n    // Max indicator\n    float lastMax = texelFetch( iChannel0, ivec2(fC.x,3), 0).r; //read last max (workaround)\n    if (floor(fC.y)==3.) col.r = (lastMax<amp)? amp : lastMax; //save new max    \n    if (uv.y>lastMax && uv.y<lastMax+.006) col.r = (floor(fC.y)==3.)? 1. : ffts.w; //draw max indicator\n    \n    // Compression symbols\n    col += .7 * (.3 + .7 * vec4(ffts.x,ffts.y,ffts.z, 0)) * dot( vec3(1), vec3(\n        circ(uvs+vec2(.5,0),.21*(.25+fft.x)),\n        square(uvs+vec2(   0),.36*(.25+fft.y)),\n        triangle(uvs-vec2(.5,-.06*(.25+fft.z)),.23*(.2+fft.z))));\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt33z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 287, 287, 467]], "test": "untested"}
{"id": "cl33R8", "name": "PT-Sphere-Box", "author": "jvb", "description": "Simple path tracing with direct shadow sampling ", "tags": ["pathtracing"], "likes": 7, "viewed": 293, "published": 3, "date": "1681904186", "time_retrieved": "2024-07-30T18:00:03.459331", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n#define PROCESSING_TEXTURE_SHADER\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n\n#define PI 3.1415926535\n\n#define BOUNCES         3\n#define SHADOW_VOLUME   1\n#define USE_AMBIENT     0\n#define MULTISAMPLE_TEX 0\n#define BARREL          1\n#define CROP_Y          0\n#define SSAMPLES        10\n#define GAMMA           1\n#define COLOR_GRAIN     1\n\n\nvec3 uniformlyRandomDirection(float seed);\nvec3 uniformlyRandomVector(float seed);\n\nvec3 rotatey(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.z*sin(ang),p.y,p.x*sin(ang)+p.z*cos(ang));  }\nvec3 rotatex(in vec3 p, float ang) { return vec3(p.x,p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang));  }\nvec3 rotatez(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang),p.z);  }\n\nvec2 sph(in vec3 p, float r, float o) { return vec2(length(p)-r, o); }\nvec2 rbox(in vec3 p, in vec3 b, float r, float o) { return vec2(length(max(abs(p)-b,0.0))-r, o); }\nvec2 sdbox( vec3 p, vec3 b, float o ) { vec3 d = abs(p) - b; return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o); }\nvec2 plane(in vec3 p, in vec3 n, float d, float o) { return vec2(dot(p,n)-d, o); }\n\nvec2 min2(in vec2 o1, in vec2 o2) { if (o1.x < o2.x) return o1; else return o2; }\nvec2 max2(in vec2 o1, in vec2 o2) { if (o1.x > o2.x) return o1; else return o2; }\nfloat lightgap = 1.0;\n\n\nvec3 lightpos;\nvec3 lightsize; \n\nvec2 scene(in vec3 p)\n{\n    vec2 d = vec2(1000.0, 0);\n    vec3 op = p;\n\n    lightpos = vec3(sin(time)*7.0,cos(time)*3.0,sin(time*0.7)*12.0);\n    lightsize = vec3(1,1,1)*1.0; \n\n    d = min2(d, vec2(-1,1)*sdbox(p-vec3(0,0,0), vec3(8,4,16), 3.0));\n    d = min2(d, vec2(1,1)*sdbox(p-vec3(0,-3,-8), vec3(1,1,1), 3.0));\n    d = min2(d, vec2(1,1)*sdbox(p-vec3(2.3,-3,-7.7), vec3(1,2,1), 3.0));\n    d = min2(d, vec2(1,1)*sph(p-vec3(-2.3,-3,-7.7), 1.0, 3.0));\n//    d = min2(d, vec2(1,1)*sdbox(p-lightpos, lightsize*1.0, 1.0));\n    \n    return d;\n}\n\n\n\nvec3 get_ambient(in vec3 p)\n{\n    vec3 s0 = vec3(0);\n    return s0;\n}\n\nvec3 get_tex(in vec3 p)\n{\n    vec3 op = p;\n    vec3 col = vec3(1);\n\t\n\tif (abs(lightpos.x-p.x)<lightsize.x && abs(lightpos.y-p.y)<lightsize.y && abs(lightpos.z-p.z)<lightsize.z) return vec3(22); \n    return vec3(0.0)+0.0*sin(p.z*0.3+2.0);\n}\nvec3 get_normal(in vec3 p)\n{\n    vec3 eps = vec3(0.00001, 0, 0);\n    float nx = scene(p + eps.xyy).x - scene(p - eps.xyy).x;\n    float ny = scene(p + eps.yxy).x - scene(p - eps.yxy).x;\n    float nz = scene(p + eps.yyx).x - scene(p - eps.yyx).x;\n    return normalize(vec3(nx,ny,nz));\n}\n\n\nfloat random(vec3 scale, float seed) {\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nfloat PHI = 1.61803398874989484820459;  //  = Golden Ratio\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat seed;\nfloat rand1()\n{\n    vec2 s = gl_FragCoord.xy/resolution.xy;\n    float n = fract(sin(seed+=1.0)*43758.5453123);\n    return fract(n + fract(sin(dot(vec2(n * s.y, s.x)*0.123,vec2(12.9898,78.233))) * 43758.5453));\n}\n//returns a random unit vector inside the given hemisphere\nvec3 rndDirHemisphere(vec3 n)\n{\n    float r2 = rand1();\n    float phi = 2.0*PI*rand1();\n    float sina = sqrt(r2);\n    float cosa = sqrt(1. - r2);\n    vec3 w = normalize(n), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n    return normalize((u*cos(phi) + v*sin(phi)) * sina + w * cosa);\n}\n\n\nvec3 cosineWeightedDirection(float seed, vec3 normal) {\n#if 0\n    float a = 2.0*random(vec3(12.9898, 78.233, 151.7182), seed)-1.0;\n    float b = 2.0*random(vec3(63.7264, 10.873, 623.6736), seed)-1.0;\n    float c = sqrt(1.0-a*a);\n    vec3 r = vec3(c*cos(b),a,c*sin(b));\n    return dot(r,normal) > 0.0 ? r : -r;\n#else\n    float u = random(vec3(12.9898, 78.233, 151.7182), seed);\n    float v = random(vec3(63.7264, 10.873, 623.6736), seed);\n    float r = sqrt(u);\n    float angle = 6.283185307179586 * v;\n    vec3 sdir, tdir;\n    if (abs(normal.x)<.5) {\n        sdir = cross(normal, vec3(1,0,0));\n    } else {\n        sdir = cross(normal, vec3(0,1,0));\n    }\n    tdir = cross(normal, sdir);\n    return r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal;\n#endif\n}\n\nvec3 uniformlyRandomDirection(float seed) {\n    float u = random(vec3(12.9898, 78.233, 151.7182), seed);\n    float v = random(vec3(63.7264, 10.873, 623.6736), seed);\n    float z = 1.0 - 2.0 * u; float r = sqrt(1.0 - z * z);\n    float angle = 6.283185307179586 * v;\n    return vec3(r * cos(angle), r * sin(angle), z);\n}\n\nvec3 uniformlyRandomVector(float seed) {\n    return uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed));\n}\n\nbool shadowray(out float shadow_dist, in vec3 ro, in vec3 rd, float time)\n{\n    \n    vec3 colorMask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    vec3 surfaceColor = vec3(0);\n    vec3 tex = vec3(0);\n    \n    vec3 pos = ro;\n    float dist = 0.0;\n    vec2 d = vec2(0);\n    bool hit = true; \n    for (int i = 0; i < 64; i++) {\n        d = scene(pos);\n\t    if (abs(d.x) < 0.00001) { hit = true; break; }\n        pos += rd*d.x;\n    }\n    dist = length(pos - ro);\n\t#if 0\n\tif (dist < length(rd)) \t\n\t\treturn true;  \n\telse\n\t\treturn false; \n\t#endif\n\tshadow_dist = dist; \n    return hit;\n}\n\nvec3 mr(in vec3 ro, in vec3 rd, float time)\n{\n    \n    vec3 colorMask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    vec3 surfaceColor = vec3(0);\n    vec3 tex = vec3(0);\n    \n    vec3 pos = ro;\n    float dist = 0.0;\n    vec2 d = vec2(0);\n    for (int i = 0; i < 80; i++) {\n        d = scene(pos);\n        if (abs(d.x) < 0.00001) break;\n        pos += rd*d.x;\n    }\n    dist = length(pos - ro);\n    if (true) {\n        float o = d.y;\n        vec3 n = get_normal(pos);\n        float shade = 1.0; //0.9+0.1*ambientOcclusion(pos+0.001*n, 1.0*n);\n        \n        tex = get_tex(pos);\n        \n        float refl = 0.0;\n        if (d.y == 1.0) {\n            if (abs(pos.z+8.0) < mouse.x*100.0 && abs(pos.y+2.0) > mouse.y*5.0)\n                surfaceColor = vec3(1,1,1)*(30.0);\n            else\n                surfaceColor = vec3(1,1,1)*0.0;\n            \n\t\t\tsurfaceColor = vec3(1,1,1)*300.0;\n            refl = 0.4;\n        }\n        else if (d.y == 2.0) {\n            surfaceColor = tex*vec3(1,1,1)*(0.0);\n            refl = 0.4;\n        }\n        else if (d.y == 3.0) {\n            surfaceColor = tex*vec3(1,1,1);\n            refl = 1.0;\n        }\n    }\n    return surfaceColor;\n}\n\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    vec3 surfaceColor = vec3(0);\n    vec3 tex = vec3(0);\n\tfor (int bounce = 0; bounce < BOUNCES; bounce++) {\n        vec3 pos = ro;\n        float dist = 0.0;\n        vec2 d = vec2(0);\n        \n        if (bounce == 0) {\n            for (int i = 0; i < 64; i++) {\n                d = scene(pos);\n                if (abs(d.x) < 0.00001) break;\n                pos += rd*d.x;\n            }\n        }\n        else {\n            for (int i = 0; i < 32; i++) {\n                d = scene(pos);\n                if (abs(d.x) < 0.00001) break;\n                pos += rd*d.x;\n            }\n        }\n        dist = length(pos - ro);\n        float o = d.y;\n        vec3 n = get_normal(pos);\n        float shade = 1.0;\n        if (true) {           \n #if SHADOW_VOLUME\n            vec3 lp = lightpos + uniformlyRandomVector(time)*lightsize;\n            vec3 l =  lp- pos;\n            float dp = 2.0*clamp(dot(n,normalize(l)), 0.0, 1.0); \n            //float dp = 2.0;\n            float shadow_dist = 0.0; \n            if (bounce >= 0) {\n                if ( shadowray(shadow_dist,pos+0.001*n, normalize(l), time) == false) {\n                    dp = 0.0;\n                }\n            if (shadow_dist < length(l)) dp = 0.0; \n\t\t\tcolor += 1.0*vec3(1.0)*dp;\n            }\n#endif\n            if (true) {\n#if MULTISAMPLE_TEX\n                tex = vec3(0);\n                for (int i = 0; i < 16; i++) {\n                    float AA = 0.01;\n                    tex += get_tex(pos + AA*uniformlyRandomVector(float(time)+float(i)));\n                }\n                tex /= 16.0;\n#else\n                tex = get_tex(pos);\n#endif\n            }\n            \n#if USE_AMBIENT\n            color += get_ambient(pos);\n#endif\n            float refl = 0.0;\n            if (d.y == 1.0) {\n\t\t\t\tsurfaceColor = vec3(1,1,1)*300.0;\n                refl = 0.4;\n            }\n            else if (d.y == 2.0) { // unlit\n                surfaceColor = tex*vec3(1,1,1)*(0.0);\n                refl = 0.4;\n            }\n            else if (d.y == 3.0) {\n                surfaceColor = tex*vec3(1,1,1);\n                refl =1.0;\n            }\n            colorMask *= surfaceColor;\n\t\t\tcolor += 1.0*shade*surfaceColor*clamp(dist, 1.0, 1.0); //*colorMask;\n            float rr = random(vec3(36.7539, 50.3658, 306.2759), time+float(bounce));\n            refl = clamp(refl*rr, 0.0, 1.0);\n            ro = pos+n*0.0001;\n            vec3 rd2 = reflect(rd, n);\n            rd = normalize(rndDirHemisphere(n));\n            rd = normalize(mix(rd, rd2, refl));\n        }\n    }\n    return clamp(color*0.1, 0.0, 2.0);\n}\n\n\nvoid make_camera(out vec3 ro, out vec3 rd, in vec2 p, float time)\n{\n    \n    float AA = 0.0025;\n    p += uniformlyRandomVector(time).xy*AA;\n    vec3 campos = vec3(sin(time)*10.0,1,0);\n    vec3 camtar = vec3(0,1,1);\n    vec3 camup = vec3(0,1,0);\n    \n    vec3 camdir = normalize(camtar-campos);\n    vec3 cu = normalize(cross(camdir, camup));\n    vec3 cv = normalize(cross(cu, camdir));\n    \n    \n    ro = vec3(0,-0.0,2.0);\n    rd = normalize(vec3(p.x,p.y,-2.));\n    \n#if BARREL\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*0.4, 0.))));\n    rd.z *= -1.0;\n#endif\n    \n    vec2 tmouse = vec2(10.6+time*0.001, 3.7+time*0.002);\n    tmouse = vec2(mouse.x*1.0,mouse.y*1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{    \n    vec2 p = 2.0*( fragCoord.xy / resolution.xy )-1.0;\n    p.x *= resolution.x/resolution.y;\n    \n    int pass = 0;\n    vec2 uv = fragCoord.xy / resolution.xy;\n    seed = (uv.y + (time+float(pass)) * 0.523413187) * sqrt(uv.x * 0.77777777 * time);\n    \n#if CROP_Y\n    if (abs(p.y) > 0.6) { gl_FragColor = vec4(0); return; }\n#endif\n    \n    vec3 color = vec3(0.0);\n    vec3 ro, rd;\n    for (int i = 0; i < SSAMPLES; i++) {\n        make_camera(ro,rd,p,time+float(i+pass));\n        color += rm(ro, rd, time+float(i+pass));\n    }\n    color /= float(SSAMPLES);\n    \n#if GAMMA\n    color = pow(color,1.0/vec3(1.3))*1.0;\n#endif\n    color *= vec3(0.98,0.98,1.0);\n#if COLOR_GRAIN\n    color += uniformlyRandomVector(time)*0.05;\n#endif\n\t\t\n\tcolor = mix(color, texture(iChannel0,fragCoord.xy/resolution.xy).xyz, 0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl33R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 152]], "test": "untested"}
{"id": "Dld3zn", "name": "Zellij pattern 5 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "zellige"], "likes": 4, "viewed": 280, "published": 3, "date": "1681877653", "time_retrieved": "2024-07-30T18:00:04.428739", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //fract(a+fract(a/2.+.5))\n        //fract(a+fract(a*2.+.5)/2.)\n        //fract(a+fract(a*4.)/4.)\n        //abs(fract(a)-abs(.5-fract(a)))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    //a *= sign(mod(floor(a/2.),2.)-.5);\n    vec2 a2 =\n        vec2(1.,0.5)\n        //vec2(1.-sign(a.x)/2.,0.5+sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)+.5;\n    uv.x = mod(uv.x,.5)+2.75;\n    for(int k = 0; k < 9; k++){\n        //k += int(uv.y<uv.x);\n        //uv.x += float(int(uv.x*4.)>>2);\n        //if((k)%3 == 0) t2 *= 0.;\n\n        uv =\n            abs(.5+uv+t2)/1.5\n            //abs(.5+uv+t2)/1.5*(1.+mod(floor(uv.y),2.)/2.)\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv-.5).yx\n            //-triangle_wave(uv+sign(.5-t2.x)+.5*sign(.5-uv.x)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        {uv=uv*sign(uv.y-uv.x);}\n        \n        //remove this line to make it gray\n        //if(uv.x<.5)\n        col.x =\n            max(sign(uv.x-t2.y),col.x)\n            //max(sign(uv.x-t2.y),1.-col.x)\n            //min(sign(uv.x-t2.y),col.x)\n            //max(distance(uv,t2+sin(iTime)),col.x)\n        ;\n        //if(t2.y>t2.x)\n        //if(uv.x>0.)\n        col =\n            abs(col.yzx/2.-float(b))\n            //vec3(col.zx,abs(uv.x*sign(t2.x-t2.y)-uv.y))\n        ;\n        //if(t2.x<t2.y) col=col.yzx;\n        //if(uv.x<uv.y) uv.x += .5;\n        //if(t2.x>t2.y) uv.x -= .5;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "float hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat fmod2(float a, float b){\n    return b*mod(floor(a),b);\n}\n\nfloat fmod1(float x, float y){\n    //x += floor((x*y)/8.);\n    //x += floor(hash11(floor(mod(floor(x/4.),y)))*8.);\n    /*\n    for(int i = 0; i < 3; i++){\n        x += mod(floor(x/2.),2.);\n        y += mod(floor(x/2.),2.);\n    }\n    */\n    //x += fmod2(x*4.,8.);\n    return\n        floor(mod(floor(x),y))\n        //mod(floor(floor(floor(x*2.)*y)/8.),y)\n        //floor(mod(floor(x*8.+floor(x/y)),y)/2.)*floor(mod(floor(x*8.),y/2.))\n        //mod(mod(floor(x/4.+2.),y*2.),8.)\n        //mod(mod(4.+floor(x),4.+floor(x/y)+y),y)\n        //floor(mod(floor(x),y)-mod(floor(x/2.),y))\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //fmod1(fmod1(fmod1(a,b)+2.,fmod1(a/8.,b+4.)+2.),b)\n        //fmod1(a+fmod1(a/2.,b),b)\n    ;\n}\n//#define fmod(x,y) floor(mod(floor(x),y))\n//#define fmod(x,y) floor(mod(floor(x+floor(pow((1.5),y))),y))\n//#define fmod(x,y) floor(mod(floor(x),floor(y/2.)+2.))\n//#define fmod(x,y) floor(mod(floor(x+pow(2.,floor(y/2.))),y))\n//#define fmod(x,y) floor(mod(floor(x*2./y),y))\n//#define fmod(x,y) floor(mod(floor(x)*floor(x/8./y),y))\n//#define fmod(x,y) floor(sqrt(mod(floor(x),y*y)))\n\n//#define fmod(a,b) mod(floor(a*2./b)*floor(a),b)\n//#define fmod(x,y) floor(mod(floor(-x*2.)/y,y))\n#define floor1(x) fmod((x*pow(2.,fmod(x/8.,3.))),2.)\n#define fmod1(x,y) mod(floor1(-x/2.),y)\n\nfloat fract1(float a){\n    return\n        fract(a)\n        //fract(a*(1.+fmod(a*1.5,1.5)))\n        //fract(a+fract(a*2.)/2.)\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  \n  /*\n  for(int i = 0; i < 3;i++){\n      time += fmod(time*4.,2.);\n      //time += fmod(time*pow(2.,fmod(time*2.,4.)-1.),2.);\n  }\n  */\n  \n  \n  float\n  s2 = 8.,\n  t=\n      time*(2.-fmod(time+floor1(time/2.),2.))/4.\n      //time*(2.-fmod(time+floor1(time/8.)+floor1(time/2.),2.))/4.\n  ,\n  m1 =\n      fmod1(t*s2,s2)\n  ;\n  /*\n  for(int i = 0; i < 3; i++){\n      t += mod(floor(t*4.),2.)/2.;\n  }\n  */\n  //t = s2*pow(2.,fmod(t*2.+m1,2.))*t/(1.+fmod(m1+floor(t/2.),2.));\n  float m3 =\n      fmod(-t/(m1+.5),s2)\n      //floor(fmod(-t/(m1+.5),s2*2.)/2.)\n  ;\n\n  float a=\n      64.*((1.-sqrt(fract(t)/1.125)))*.2\n      //pow(2.,2.-log(fract(t)/2.))/2.\n      //64.*((1.-sqrt(fract(t-.5)/1.125)))*.2\n      //64.*pow((1.-(fract(t))),2.)\n  ,\n  nb =\n      //time*pow(2.,fmod(-t*8.+m3+1.,m3+1.)/5.+7.)\n      time*pow(2.,(m3)/5.+7.)\n  ;\n\n  return \n      //abs(.5-vec2(fract1(nb*.998),fract1(nb)))*a\n      abs(a/8.-abs(.5-vec2(fract1(nb*.998),fract1(nb)))*a/4.)\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dld3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 253], [255, 255, 282, 323, 484], [486, 486, 543, 543, 2015]], "test": "untested"}
{"id": "dt33zr", "name": "glassvoronoi", "author": "brackets1", "description": "pattern", "tags": ["pattern"], "likes": 2, "viewed": 144, "published": 3, "date": "1681861722", "time_retrieved": "2024-07-30T18:00:05.418094", "image_code": "const float TWIRL_FACTOR = 0.5;\nconst float OFFSET_FACTOR = 1.0;\nconst float GROWTH_FACTOR = 0.5;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 hexagon(in vec2 p) {\n    vec2 q = vec2(p.x * 2.0 * 0.5773503, p.y + p.x * 0.5773503);\n    vec2 pi = floor(q), pf = fract(q);\n    float v = mod(pi.x + pi.y, 3.0);\n    float ca = step(1.0, v), cb = step(2.0, v);\n    vec2 ma = step(pf.xy, pf.yx);\n    float e = dot(ma, 1.0 - pf.yx + ca * (pf.x + pf.y - 1.0) + cb * (pf.yx - 2.0 * pf.xy));\n    p = vec2(q.x + floor(0.5 + p.y / 1.5), 2.0 * p.y / 3.0) * 0.5 + 0.5;\n    float f = length((fract(p) - 0.5) * vec2(1.0, 0.2));\n    return vec4(pi + ca - cb * ma, e, f);\n}\n\nvec2 twirl(vec2 p, float factor) {\n    float radius = length(p);\n    float angle = atan(p.y, p.x);\n    angle += factor * radius;\n    return vec2(cos(angle), sin(angle)) * radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Get time\n    float time = iTime * 0.5;\n\n    // Calculate tunnel distance\n    float tunnelDist = 5.0 + 3.0 * sin(time);\n\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Twirl the coordinates\n    vec2 twirled_p = twirl(p, TWIRL_FACTOR);\n\n    // Divide the cells from the center\n    float radius = length(p);\n    float scaleFactor = exp(-radius * GROWTH_FACTOR);\n    twirled_p /= scaleFactor;\n\n    // Apply a small random offset to each tile\n    vec4 h = hexagon(twirled_p * tunnelDist);\n    vec2 offset = vec2(rand(h.xy) - 0.5, rand(h.xy + 0.3) - 0.5) * OFFSET_FACTOR;\n    h = hexagon((twirled_p + offset) * tunnelDist);\n\n    vec3 col = vec3(h.z);\n    \n    col = mix(col, 1.0 - col, smoothstep(-0.2, .13, h.z));\n\n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt33zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 120, 120, 193], [195, 195, 220, 220, 709], [711, 711, 745, 745, 891], [893, 893, 948, 964, 1759]], "test": "untested"}
{"id": "mtcGzr", "name": "Cryptic", "author": "Slals", "description": "Visual interpretation of data encryption", "tags": ["2d", "infinite"], "likes": 1, "viewed": 163, "published": 3, "date": "1681859986", "time_retrieved": "2024-07-30T18:00:06.175070", "image_code": "precision mediump float;\n\nfloat rectSDF(vec2 st, vec2 s) {\n    st = st * 2.0 - 1.0;\n    return max(abs(st.x / s.x), abs(st.y / s.y));\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - step(size, x);\n}\n\nfloat random(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    vec2 xy = st;\n\n    vec3 color = vec3(0.0);\n\n    float r = random(st);\n\n    vec2 s = vec2(0.7, 0.8);\n\n    vec2 fpos = fract(st);\n\n    float rPos = random(vec2(fpos.y)) * 5.0;\n\n    xy.y = fract(xy.y * 100.0);\n    xy.x -= mod(iTime * rPos * 0.2, 2.0) - 1.0;\n\n    float rect = rectSDF(xy, s); \n    \n    if (st.x >= max((iMouse.x / iResolution.x), 0.2)) {\n        xy.y = st.y;\n        xy.y += (xy.y * 2.0 - 1.0) * r * r * r;\n        rect = rectSDF(xy, vec2(0.74));\n        xy.y -= (xy.y * 2.0 - 1.0) * r * r * r ;\n        float rectDif = rectSDF(xy, vec2(0.74));\n        color += vec3(0.2, 0.8 * r, 0.1) * fill(rectDif, 1.0);\n        color += vec3(0.2, 0.2 * r, 0.5) * fill(rect, 1.0); \n    } else {\n        color += fill(rect, 1.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 58, 58, 135], [137, 137, 170, 170, 204], [206, 206, 232, 232, 308], [310, 310, 367, 367, 1188]], "test": "untested"}
{"id": "ctc3Rr", "name": " time*mouse * rot symmetry2-2", "author": "timmaffett", "description": "added time and mouse factors to rotational symmetry2-2 by Acre https://shadertoy.com/view/csySWG\nit's always more interesting with time & mouse ;)", "tags": ["2d"], "likes": 18, "viewed": 262, "published": 3, "date": "1681839793", "time_retrieved": "2024-07-30T18:00:06.928057", "image_code": "// Fork of \" rotational symmetry2-2\" by Acre. https://shadertoy.com/view/csySWG\n// 2023-04-18 17:38:51\n\n#define iTime (iTime/20.0)   // adjust divisor to speed up or slow down\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nvec3 poison_apple=vec3(0.635,0.0,0.38);\nvec3 teal_blue=vec3(0.0,0.329,0.533);\nvec3 misty_green=vec3(0.811,0.894,0.819);\nvec3 darkblue_green=vec3(0.0,0.435,0.482);\nvec3 medium_gray=vec3(0.623,0.627,0.627);  \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col;\n    vec2 vec;\n    float d;\n    for(float i=0.0;i<60.0;i++)\n    {\n        vec=vec2(cos(i*iTime)*(i*0.04*mouse.y),sin(i*iTime)*(i*0.04*mouse.x));\n\n        d=sdCircle(p+vec,i*0.07);\n\n        col=(d>0.0&&mod(i,5.0)==0.) ? teal_blue      : col;\n        col=(d>0.0&&mod(i,5.0)==1.) ? poison_apple   : col;\n        col=(d>0.0&&mod(i,5.0)==2.) ? misty_green    : col;\n        col=(d>0.0&&mod(i,5.0)==3.) ? darkblue_green : col;\n        col=(d>0.0&&mod(i,5.0)==4.) ? medium_gray    : col;\n        col = mix(col, vec3(0.0), smoothstep(0.01,0.0,abs(d)) );\n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctc3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 219, 219, 245], [459, 459, 516, 516, 1289]], "test": "untested"}
{"id": "DlcGRr", "name": "velvet effect", "author": "FabriceNeyret2", "description": "stranger different look with sin( .1* ... ) at last line.", "tags": ["fire", "hardwarederivatives", "schlieren"], "likes": 21, "viewed": 493, "published": 3, "date": "1681838378", "time_retrieved": "2024-07-30T18:00:07.675059", "image_code": "// variant of https://shadertoy.com/view/DdGGDz\n// variant of \"Simple fire effect\" by guil. https://shadertoy.com/view/msyGRm\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy ,\n          p = 4.*( u+u - R ) / R.y,\n          r = sin( p+iTime*2.5 );\n    \n    r += sin( p * mat2(8,6,-8,6)*.16 + r*.64 +iTime*2.5 ) / 1.6,\n    O = vec4(.5+ .5*sin(.2*dFdx(length(r))*R.y) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 165, 165, 389]], "test": "untested"}
{"id": "Dlc3Rn", "name": "Interactive Mitchell-Netravali", "author": "FordPerfect", "description": "Left-click in highlighted square to set B (=y) and C (=x) filter coefficients.", "tags": ["filter", "bicubic", "mitchell"], "likes": 1, "viewed": 322, "published": 3, "date": "1681832736", "time_retrieved": "2024-07-30T18:00:08.421065", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Interactive Mitchell-Netravali filter demo. See\n//   https://en.wikipedia.org/wiki/Mitchell%E2%80%93Netravali_filters\n//   https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf\n// for details on these filetrs (also known as BC-splines).\n\n// Left-click in the highlighted square to set filter coeficients:\n//   B - y position (cyan)\n//   C - x position (yellow)\n\n// For comparison, left hand side shows nearest (bottom), and\n// linear (top) filtering.\n\n// Coefficients for some popular filters:\n//   Catmull-Rom:                               B=  0, C=1/2\n//   Mitchell-Netravali (recommended in paper): B=1/3, C=1/3\n\n// White line is B+2*C=1, recommended in paper.\n\n#define SCALE 4.0\n#define SPEED 0.0\n\nvec3 getTexel(ivec2 xy)\n{\n    return texture(iChannel0,(vec2(xy)+0.5)/vec2(textureSize(iChannel0,0))).rgb;\n}\n\nvec4 getWeights(mat4 W,float t)\n{\n\treturn W*vec4(1.0,t,t*t,t*t*t);\n}\n\nvec3 filterX(ivec2 inputPosFloor,int dy,vec4 w)\n{\n\treturn\n\t\tw.x*getTexel(ivec2(inputPosFloor.x-1,inputPosFloor.y+dy))+\n\t\tw.y*getTexel(ivec2(inputPosFloor.x  ,inputPosFloor.y+dy))+\n\t\tw.z*getTexel(ivec2(inputPosFloor.x+1,inputPosFloor.y+dy))+\n\t\tw.w*getTexel(ivec2(inputPosFloor.x+2,inputPosFloor.y+dy));\n}\n\nvec3 filterBC(vec2 uv,float B,float C)\n{\n\tvec2 xy=(uv-0.5);\n\tivec2 ixy=ivec2(floor(xy));\n\n\tfloat x=xy.x-float(ixy.x);\n\tfloat y=xy.y-float(ixy.y);\n    // Matrix for computing weights.\n    // WARNING: column-major.\n\tmat4 W=mat4(\n\t\tB/6.0      , 1.0-B/3.0   , B/6.0           , 0.0    ,\n\t\t-C-0.5*B   , 0.0         , C+0.5*B         , 0.0    ,\n\t\t2.0*C+0.5*B, C+2.0*B-3.0 , -2.0*C-2.5*B+3.0, -C     ,\n\t\t-C-B/6.0   , -C-1.5*B+2.0, C+1.5*B-2.0     , C+B/6.0);\n\tvec4 Wx=getWeights(W,x);\n\tvec4 Wy=getWeights(W,y);\n\n\treturn\n\t\tWy.x*filterX(ixy,-1,Wx)+\n\t\tWy.y*filterX(ixy, 0,Wx)+\n\t\tWy.z*filterX(ixy,+1,Wx)+\n\t\tWy.w*filterX(ixy,+2,Wx);\n}\n\nfloat line(vec2 pos,float A,float B,float C,float w)\n{\n    float x=dot(pos,vec2(A,B))+C;\n    x/=w;\n    return exp(-0.5*x*x);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float G=float(iResolution.y)/2.0;\n    float w=1.0/float(SCALE);\n    float v=float(SPEED);\n    vec2 xy=fragCoord;\n    vec2 uv=w*xy+v*float(iResolution.y)*vec2(sin(0.5*iTime),sin(0.37*iTime));\n    vec2 BC=clamp(abs(iMouse.yx),0.0,G)/G;\n\n    vec3 col=fragCoord.x<iResolution.x/2.0?\n        (fragCoord.y<iResolution.y/2.0?\n            getTexel(ivec2(floor(uv))).rgb:\n            texture(iChannel0,(uv)/vec2(textureSize(iChannel0,0))).rgb):\n        filterBC(uv,BC.x,BC.y);\n\n    if(xy.x<G&&xy.y<G)\n    {\n        vec2 mouse=BC.yx*G;\n        col+=0.25;\n        col+=vec3(0.0,1.0,0.0)*exp(-dot(xy-mouse,xy-mouse)/4.0);\n        col+=vec3(1.0,1.0,0.0)*line(xy,1.0,0.0,-mouse.x,0.5);\n        col+=vec3(0.0,1.0,1.0)*line(xy,0.0,1.0,-mouse.y,0.5);\n        col+=vec3(0.5,0.5,0.5)*line(xy,2.0,1.0,-G,1.0);\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlc3Rn.jpg", "access": "api", "license": "public-domain", "functions": [[810, 810, 835, 835, 918], [920, 920, 953, 953, 988], [990, 990, 1039, 1039, 1293], [1295, 1295, 1335, 1335, 1917], [1919, 1919, 1973, 1973, 2045], [2047, 2047, 2101, 2101, 2934]], "test": "untested"}
{"id": "ct33Rn", "name": "Simple Voxel DDA", "author": "me_123", "description": "A super simple, and fast DDA algorithm.", "tags": ["3d", "lighting", "voxel", "dda"], "likes": 21, "viewed": 528, "published": 3, "date": "1681830368", "time_retrieved": "2024-07-30T18:00:09.255833", "image_code": "vec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir*0.5 + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nfloat s(in vec3 p) {\n    return exp(p.z*0.1-3.0)+(texture(iChannel0, (p+112.613)*0.001).x+texture(iChannel0, (p)*0.004).x);\n}\nbool getBlock(in vec3 p) {\n    return s(p) < 0.8;\n}\nstruct hit {\n    vec3 normal;\n    float dist;\n    vec3 position;\n};\nhit DDA(in vec3 ro, in vec3 rd) {\n    vec3 i = floor(ro);\n    float dist;\n    int ii;\n    vec3 normal;\n    vec3 srd = sign(rd);\n    vec3 rdi = 1./(2.*rd);\n    for (ii = 0; ii < 200; ii += 1) {\n        if (getBlock(i)) break;\n        vec3 plain = ((1.+srd-2.*(ro-i))*rdi);\n        dist = min(plain.x, min(plain.y, plain.z));\n        normal = vec3(equal(vec3(dist), plain))*srd;\n        i += normal;\n    }\n    if (ii == 200) return hit(vec3(-1), -1., vec3(-1.0));\n    vec3 position = ro+rd*dist;\n    return hit(normal, dist, position);\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    hit h = DDA(ro, rd);\n    if (h.dist < 0.0) return vec3(0);\n    float l = mix(abs(dot(h.normal, normalize(vec3(1, 2, 3)))), 1., 0.7);\n    return vec3(l*4.0*pow(s(h.position), 5.0)*exp(-h.dist*0.02)*exp(h.position.z*0.03-1.5));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;//((fragCoord+hash33(vec3(fragCoord.xy, iTime)).xy) - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    vec2 m = vec2(iTime*0.8, 0.9);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*40.0;//*max(pow(2., 5.-iTime*2.0), 5.0);\n    vec3 rd = getRay(-normalize(ro), uv);\n    vec3 color = getColor(ro, rd);\n\n    //super sample\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct33Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 71, 285], [286, 286, 306, 306, 411], [412, 412, 438, 438, 463], [532, 532, 565, 565, 1067], [1068, 1068, 1107, 1107, 1339], [1340, 1340, 1397, 1397, 1942]], "test": "untested"}
{"id": "dsVXDd", "name": "Dunnos: Cemetery of Spirits", "author": "z0rg", "description": "The dunnos are looking at you !", "tags": ["2d", "ghost", "dunnos"], "likes": 41, "viewed": 442, "published": 3, "date": "1681826183", "time_retrieved": "2024-07-30T18:00:10.132489", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec3 col = texture(iChannel0, uv).xyz;\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat hash11(float seed)\n{\n  return fract(sin(seed*123.456)*123.456);\n}\nfloat rand()\n{\n  return hash11(_seed++);\n}\nmat2 r2d(float a)\n{\n  float c = cos(a), s= sin(a);\n   return mat2(c,-s,s,c);\n}\nfloat _sqr(vec2 uv, vec2 s)\n{\n  vec2 l = abs(uv)-s;\n  return max(l.x,l.y);\n}\n#define sat(a) clamp(a,0.,1.)\n// thx iq :)\nfloat _seg( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 rdrpass(vec2 uv, vec3 col, float i)\n{\n  vec2 rep = vec2(.3,.7);\n  float id = floor((uv.x+rep.x*.5)/rep.x);\n  uv.x= mod(uv.x+rep.x*.5,rep.x)-rep.x*.5;\n  uv.x+=sin(id*30.+i)*.05;\n  uv.x+=sin(id+i+iTime+uv.y*4.)*.02;\n  uv.y+=sin(id*30.+i*10.+iTime)*.02;\n  float th = mix(0.07,0.04,sin(id*3.3+i*2.2)*.5+.5);\n  float shape = _seg(uv,\n    vec2(0.,0.),vec2(0.,.2))-th;\n    vec3 rgb = mix(vec3(1.),vec3(.1,.5,.7),\n      sat((shape+.1)*5.));\n  col = mix(col, rgb*sat(uv.y*5.), 1.-sat(shape*400.));\n//  col += sat(rgb)*.01;\n  vec2 peye = uv;\n  peye.x = abs(peye.x);\n  float d = mix(0.035,0.02,sin(id+i)*.5+.5);\n  float eyes = length(peye-vec2(d,0.2))-.01;\n  col = mix(col, vec3(0.), 1.-sat(eyes*400.));\n  return col;\n}\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(0.);\n\n  for (float i = 0.; i<22.;i++)\n  {\n    col = rdrpass(uv+vec2(0.1*i,.1*i-.9), col,i);\n  }\n\n\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)\n   / iResolution.xx;\n   _seed= iTime+texture(iChannel0,uv).x;\n  vec3 col = rdr(uv*2.);\n  col+= rdr(uv+(vec2(rand(),rand())-.5)*.1)*.7;\n  if (iFrame != 0)\n  { \n      col = mix(col, \n      texture(iChannel1, fragCoord.xy/iResolution.xy).xyz, .9);\n  }\n  fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVXDd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 568]], "test": "untested"}
{"id": "dsGSDc", "name": "Water on the planet", "author": "ddinhddoong", "description": "to draw wall, mouse press on wall. To erase wall, mouse press on air\nW: water/ auto brush\nG: toggle gravity direction\nV: velocity display\nF: free surface display\nLBM: https://en.wikipedia.org/wiki/Lattice_Boltzmann_methods", "tags": ["2d", "simulation", "water", "fluid", "lbm", "latticeboltzmann", "freesurface"], "likes": 13, "viewed": 311, "published": 3, "date": "1681799383", "time_retrieved": "2024-07-30T18:00:11.169716", "image_code": "// visualization\n\n#define CUR_ARR 0\n\n/*\nvec3 hue2rgb(float i){\n    //return clamp(3.0*abs(1.-2.*fract(i+vec3(-1./3.,1./3.,0.)))-1.,0.,1.);\n    return 3.0*abs(1.-2.*fract(i+vec3(-1./3.,1./3.,0.)))-1.;\n}//*/\n\n// draw arrows \n// 2D vector field visualization by Morgan McGuire, from @morgan3d, http://casual-effects.com\nconst float PI = 3.1415927;\nconst int   ARROW_V_STYLE = 1;\nconst int   ARROW_LINE_STYLE = 2;\nconst int   ARROW_STYLE = ARROW_LINE_STYLE;\n#if CUR_ARR\n    const float ARROW_TILE_SIZE = 17.;\n    const float ARROW_HEAD_ANGLE = 90.0 * PI / 180.0;\n    const float ARROW_HEAD_LENGTH = ARROW_TILE_SIZE / 7.;\n    const float ARROW_SHAFT_THICKNESS = 2.;\n#else\n    const float ARROW_TILE_SIZE = 10.;\n    const float ARROW_HEAD_ANGLE = 60.0 * PI / 180.0;\n    const float ARROW_HEAD_LENGTH = ARROW_TILE_SIZE / 10.;\n    const float ARROW_SHAFT_THICKNESS = 0.;\n#endif\n\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\nfloat arrow(vec2 p, vec2 v) {\n\tp -= arrowTileCenterCoord(p);\n    float mag_v = length(v), mag_p = length(p);\n\tif (mag_v > .5) {\n\t\tvec2 dir_p = p / mag_p, dir_v = v / mag_v;\n\t\tmag_v = clamp(mag_v, 0.5, ARROW_TILE_SIZE / 3.);\n\t\tv = dir_v * mag_v;\n\t\tfloat dist;\t\t\n\t\tif (ARROW_STYLE == ARROW_LINE_STYLE) {\n\t\t\tdist = max(ARROW_SHAFT_THICKNESS / 4.0 - \n                    max(abs(dot(p, vec2(dir_v.y, -dir_v.x))),\n                        abs(dot(p, dir_v)) - mag_v + ARROW_HEAD_LENGTH / 2.0), \n                        min(0.0, dot(v - p, dir_v) - cos(ARROW_HEAD_ANGLE / 2.0) * length(v - p)) * 2.0 +\n                        min(0.0, dot(p, dir_v) + ARROW_HEAD_LENGTH - mag_v));\n\t\t} else {\n\t\t\tdist = min(0.0, mag_v - mag_p) * 2.0 +\n\t\t\t\t   min(0.0, dot(normalize(v - p), dir_v) - cos(ARROW_HEAD_ANGLE / 2.0)) * 2.0 * length(v - p) +\n\t\t\t\t   min(0.0, dot(p, dir_v) + 1.0) +\n\t\t\t\t   min(0.0, cos(ARROW_HEAD_ANGLE / 2.0) - dot(normalize(v * 0.33 - p), dir_v)) * mag_v * 0.8;\n\t\t}\n\t\t\n\t\treturn clamp(0.6 + dist, 0.0, 1.0);\n\t} else {\n\t\treturn max(0.0, 1.2 - mag_p);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    ivec2 idx = ivec2(fragCoord * 0.5);\n\n    float rho = RHO(iChannel1, idx);\n    float F_len = rho>0.001? F_Len(iChannel0, idx)*min(rho*3.,1.)*8.:0.;\n    //float v_len = rho>0.0001? V_Len(iChannel0, idx)*min(rho*10.,1.)*3.:0.;\n    vec2 v = vec2(V_x(iChannel0, idx),V_y(iChannel0, idx));\n\n    float v_len = length(v);\n    //v_len = rho>0.001? v_len*min(rho*10.,1.)*3.:0.;\n    float wall = Wall(iChannel2, idx);\n    ivec2 size = ivec2(iResolution*0.5);\n\n    vec4 color = vec4(.0,.02,.07,1.);                       // display background (sky)\n    color.xyz += vec3(.05, .2, .25)*rho + v_len*rho/2.;     // display fluid (density)\n    color += vec4(0,F_len,0,0)*KEY_F;                       // display force (free surface)\n    color += vec4(.3,.2,.1,0.)*wall;                        // display wall\n    //color += vec4(hue2rgb(v_len)*v_len*0.8,1)*KEY_V;      // display velocity (color)\n    // display velocity\n    ivec2 idx_tile = ivec2(arrowTileCenterCoord(fragCoord) * 0.5);\n    vec2 v_tile = vec2(V_x(iChannel0, idx_tile),V_y(iChannel0, idx_tile));\n    color -= vec4(-5.,-5.,5.,0.) * arrow(fragCoord.xy,\n#if CUR_ARR\n    v\n#else\n    v_tile\n#endif\n    * ARROW_TILE_SIZE * 10.) * KEY_V*\n    step(.1,RHO(iChannel1, idx_tile)) *\n#if CUR_ARR\n    step(F_Len(iChannel0, idx),.5) *\n#endif    \n    step(wall, .1); //step(Wall(iChannel2, idx_tile),.1);\n    \n    fragColor=color;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//from @ndel https://www.shadertoy.com/view/4dK3zG\n/*\n7 3 5\n2 0 1\n6 4 8\n*/\n#define f0(tex,idx) (texelFetch(tex, idx*2, 0).r)\n#define f1(tex,idx) (texelFetch(tex, idx*2, 0).g)\n#define f2(tex,idx) (texelFetch(tex, idx*2, 0).b)\n\n#define f3(tex,idx) (texelFetch(tex, idx*2+ivec2(1,0),0).r)\n#define f4(tex,idx) (texelFetch(tex, idx*2+ivec2(1,0),0).g)\n#define f5(tex,idx) (texelFetch(tex, idx*2+ivec2(1,0),0).b)\n\n#define f6(tex,idx) (texelFetch(tex, idx*2+ivec2(0,1),0).r)\n#define f7(tex,idx) (texelFetch(tex, idx*2+ivec2(0,1),0).g)\n#define f8(tex,idx) (texelFetch(tex, idx*2+ivec2(0,1),0).b)\n\n#define RHO(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).r)\n#define F_Len(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).g)\n#define V_x(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).b)\n#define V_y(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).a)\n\n#define PSI(tex,idx) (texelFetch(tex, idx*2+ivec2(1,1),0).a)\n\n#define Wall(tex, idx) (any(greaterThan(texelFetch(tex, idx*2,0).rg, vec2(0.5)))?1.:0.)\n\n#define KEY_F round(texelFetch(iChannel3, ivec2(70,2) , 0 ).x)\n#define KEY_G round(texelFetch(iChannel3, ivec2(71,2) , 0 ).x)\n#define KEY_V round(texelFetch(iChannel3, ivec2(86,2) , 0 ).x)\n#define KEY_W round(texelFetch(iChannel3, ivec2(87,2) , 0 ).x)\n\n#define dist2Mouse distance(iMouse.xy*0.5, vec2(idx))\n\nbool is_wall(in sampler2D ch,in ivec2 idx, in ivec2 size){\n    return (size.x < idx.x + 1) || (size.y < idx.y + 1) || (idx.x < 0) || (idx.y < 0) || (Wall(ch, idx) > 0.1);\n}\n\nvec4 save_color(in ivec2 off,in vec4[4] colors)\n{\n    return colors[/*3&*/(off.y<<1|off.x)];\n}\n\nconst float G_self = .7;          // affect the surface tension of the liquid molecules\nconst float G_wall = 0.25;         // affect the surface tension between the liquid and the wall\nconst float g = .008;             // gravity\nconst float k = 1.2;//.5;         // affect the viscidity, range: 0.1~1.9", "buffer_a_code": "// streaming step\n\n// kernal\nconst ivec2 off[25] = ivec2[25](\n    ivec2( 0, 0 ),\n    ivec2( 1, 0 ),ivec2( 0, -1 ),ivec2( -1, 0 ),ivec2( 0, 1 ),\n    ivec2( 1, -1 ), ivec2( -1, -1 ), ivec2( -1, 1 ), ivec2( 1, 1 ),\n    ivec2( 2, 0 ), ivec2( 0, -2 ), ivec2( -2, 0 ), ivec2( 0, 2 ),\n    ivec2( 1, -2 ), ivec2( -1, -2 ), ivec2( -1, 2 ), ivec2( 1, 2 ),\n    ivec2( 2, -1 ), ivec2( -2, -1 ), ivec2( -2, 1 ), ivec2( 2, 1 ),\n    ivec2( 2, -2 ), ivec2( -2, -2 ), ivec2( -2, 2 ), ivec2( 2, 2 )\n);\nconst float w[9] = float[9](\n    0., 1. / 21., 4. / 45., 0., 1. / 60., 2. / 315., 0., 0., 1. / 5040.\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 idx = ivec2(fragCoord*0.5);\n    ivec2 size = ivec2(iResolution*0.5);\n    \n    if(is_wall(iChannel2,idx,size))\n    {\n        discard;\n    }\n    \n    // density distribution\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8;\n    // total density\n    float rho;\n    float psi;\n\n    // get f0~8 from BufferB\n    f0 = f0(iChannel1, idx);\n    f1 = f1(iChannel1, idx);\n    f2 = f2(iChannel1, idx);\n    f3 = f3(iChannel1, idx);\n    f4 = f4(iChannel1, idx);\n    f5 = f5(iChannel1, idx);\n    f6 = f6(iChannel1, idx);\n    f7 = f7(iChannel1, idx);\n    f8 = f8(iChannel1, idx);\n    psi = PSI(iChannel1, idx);\n    // density\n    rho = f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8;\n    // velocity\n    /* density gradient = vec2(right - left, top - down)\n    7 3 5\n    2 0 1\n    6 4 8\n    */\n    vec2 v1 = (1./(rho+ 1e-20)) * vec2((f1 - f2 + f5 - f6 + f8 - f7),(f3 - f4 + f5 - f6 + f7 - f8));\n\n    // calculate external force (surface tension)\n    // Shan-Chen-type model, https://journals.aps.org/pre/pdf/10.1103/PhysRevE.47.1815\n    vec2 F = vec2(0, 0);\n    for(int i = 1; i < 25; i++) {\n        ivec2 offset = off[i];\n        ivec2 idx2 = idx + offset;\n        float psi_self = PSI(iChannel1, idx2);\n        float psi_wall = is_wall(iChannel2, idx2, size) ? 1. : 0.;\n        F += (G_self * psi_self + G_wall * psi_wall) * vec2(offset) * w[offset.x * offset.x + offset.y * offset.y];\n    }\n    \n    F *= max(psi,.95);\n    vec2 dir = (KEY_G > 0.)? vec2(0,-1) : normalize(vec2(size/2) - fragCoord*0.5);\n    vec2 a = F * min(1./(rho+ 1e-20), 100.) + g*dir; //gravity\n    vec2 v2 = v1 + a; // velocity2\n    \n    // velocity limit\n    const float max_speed = 0.6;//0.57735027;\n    if(length(v1) > max_speed) {\n        v1 = normalize(v1) * max_speed;\n        //v1 *= 0.1;\n    }\n    if(length(v2) > max_speed) {\n        v2 = normalize(v2) * max_speed;\n        //v2 *= 0.1;\n    }\n\n    // f_eq(i,v)\n    float sq_term = - 1.5 * (v1.x * v1.x + v1.y * v1.y);\n    float f0eq = 4. / 9. * rho * (1. + sq_term);\n    float f1eq = 1. / 9. * rho * (1. + 3. * v1.x + 4.5 * v1.x * v1.x + sq_term);\n    float f2eq = 1. / 9. * rho * (1. - 3. * v1.x + 4.5 * v1.x * v1.x + sq_term);\n    float f3eq = 1. / 9. * rho * (1. + 3. * v1.y + 4.5 * v1.y * v1.y + sq_term);\n    float f4eq = 1. / 9. * rho * (1. - 3. * v1.y + 4.5 * v1.y * v1.y + sq_term);\n    float f5eq = 1. / 36. * rho * (1. + 3. * (v1.x + v1.y) + 4.5 * (v1.x + v1.y) * (v1.x + v1.y) + sq_term);\n    float f6eq = 1. / 36. * rho * (1. - 3. * (v1.x + v1.y) + 4.5 * (v1.x + v1.y) * (v1.x + v1.y) + sq_term);\n    float f7eq = 1. / 36. * rho * (1. + 3. * (- v1.x + v1.y) + 4.5 * (- v1.x + v1.y) * (- v1.x + v1.y) + sq_term);\n    float f8eq = 1. / 36. * rho * (1. - 3. * (- v1.x + v1.y) + 4.5 * (- v1.x + v1.y) * (- v1.x + v1.y) + sq_term);\n    \n    // f_eq(i,v2)\n    float sq_term2 = - 1.5 * (v2.x * v2.x + v2.y * v2.y);\n    float f0eq2 = 4. / 9. * rho * (1. + sq_term2);\n    float f1eq2 = 1. / 9. * rho * (1. + 3. * v2.x + 4.5 * v2.x * v2.x + sq_term2);\n    float f2eq2 = 1. / 9. * rho * (1. - 3. * v2.x + 4.5 * v2.x * v2.x + sq_term2);\n    float f3eq2 = 1. / 9. * rho * (1. + 3. * v2.y + 4.5 * v2.y * v2.y + sq_term2);\n    float f4eq2 = 1. / 9. * rho * (1. - 3. * v2.y + 4.5 * v2.y * v2.y + sq_term2);\n    float f5eq2 = 1. / 36. * rho * (1. + 3. * (v2.x + v2.y) + 4.5 * (v2.x + v2.y) * (v2.x + v2.y) + sq_term2);\n    float f6eq2 = 1. / 36. * rho * (1. - 3. * (v2.x + v2.y) + 4.5 * (v2.x + v2.y) * (v2.x + v2.y) + sq_term2);\n    float f7eq2 = 1. / 36. * rho * (1. + 3. * (- v2.x + v2.y) + 4.5 * (- v2.x + v2.y) * (- v2.x + v2.y) + sq_term2);\n    float f8eq2 = 1. / 36. * rho * (1. - 3. * (- v2.x + v2.y) + 4.5 * (- v2.x + v2.y) * (- v2.x + v2.y) + sq_term2);\n\n    // f_new(i) = (1-k)*f(i) + (k-1)*f_eq(i,v1) + f_eq(i,v2)\n    f0 = (1. - k) * f0 + (k - 1.) * f0eq + f0eq2;\n    f1 = (1. - k) * f1 + (k - 1.) * f1eq + f1eq2;\n    f2 = (1. - k) * f2 + (k - 1.) * f2eq + f2eq2;\n    f3 = (1. - k) * f3 + (k - 1.) * f3eq + f3eq2;\n    f4 = (1. - k) * f4 + (k - 1.) * f4eq + f4eq2;\n    f5 = (1. - k) * f5 + (k - 1.) * f5eq + f5eq2;\n    f6 = (1. - k) * f6 + (k - 1.) * f6eq + f6eq2;\n    f7 = (1. - k) * f7 + (k - 1.) * f7eq + f7eq2;\n    f8 = (1. - k) * f8 + (k - 1.) * f8eq + f8eq2;\n    \n    // save\n    ivec2 off = ivec2(int(fragCoord.x) - 2*idx.x,int(fragCoord.y) - 2*idx.y);\n    fragColor = save_color(off,vec4[4](\n    vec4(f0,f1,f2,1.),\n    vec4(f3,f4,f5,1.),\n    vec4(f6,f7,f8,1.),\n    vec4(rho,length(F),((v1+v2)*0.5).xy)));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//collision step\n\n#define SizeChanged() (texelFetch(iChannel2, ivec2(0,0),0).r)\n\n#define PI 3.1415926535898\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    ivec2 idx = ivec2(fragCoord*0.5);\n    ivec2 size = ivec2(iResolution*0.5);\n\n    float f0, f1, f2, f3, f4, f5, f6, f7, f8;\n\n    if(!is_wall(iChannel2,idx,size)&&SizeChanged()<0.5)\n    {\n        ivec2 idx2;\n        //*\n        ivec2 sourcePos = ivec2(size.x/2,size.y/7*6);\n        if(length(vec2(sourcePos-idx))<6.) // water source\n        {\n            f4 = 0.5; //\n            //f1 = 1.; //\n        }\n        else//*/\n        if(iMouse.z > 0. && dist2Mouse < 8.) //add water with mouse\n        {\n           f0 = 0.5*(KEY_W);\n        }\n        else // streaming and handling boundary condition \n        {\n            /* If hit a wall, change to the opposite direction\n                7 3 5\n                2 0 1\n                6 4 8\n            */\n            f0 = f0(iChannel0, idx);\n            idx2 = idx + ivec2(-1, 0);\n            f1 = is_wall(iChannel2,idx2, size) ? f2(iChannel0, idx) : f1(iChannel0, idx2);\n            idx2 = idx + ivec2(1, 0);\n            f2 = is_wall(iChannel2,idx2, size) ? f1(iChannel0, idx) : f2(iChannel0, idx2);\n            idx2 = idx + ivec2(0, -1);\n            f3 = is_wall(iChannel2,idx2, size) ? f4(iChannel0, idx) : f3(iChannel0, idx2);\n            idx2 = idx + ivec2(0, 1);\n            f4 = is_wall(iChannel2,idx2, size) ? f3(iChannel0, idx) : f4(iChannel0, idx2);\n            idx2 = idx + ivec2(-1, -1);\n            f5 = is_wall(iChannel2,idx2, size) ? f6(iChannel0, idx) : f5(iChannel0, idx2);\n            idx2 = idx + ivec2(1, 1);\n            f6 = is_wall(iChannel2,idx2, size) ? f5(iChannel0, idx) : f6(iChannel0, idx2);\n            idx2 = idx + ivec2(1, -1);\n            f7 = is_wall(iChannel2,idx2, size) ? f8(iChannel0, idx) : f7(iChannel0, idx2);\n            idx2 = idx + ivec2(-1, 1);\n            f8 = is_wall(iChannel2,idx2, size) ? f7(iChannel0, idx) : f8(iChannel0, idx2);\n        }\n    }\n    \n    const float rho0 = 1.;\n    float rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n    float r = rho/rho0;\n    float p = max(r-1.,0.);\n    \n    /* pseudo-potential */\n    float psi = sign(r) * rho0 * clamp((\n    /* surface tension */ \n    1. - exp(-abs(r))\n    /* pressure, it makes the fluid more incompressible*/\n    - (1.5*p*sqrt(p))), //-p),\n    /* clamp */\n    -100.,1.);\n    \n    // save\n    ivec2 off = ivec2(int(fragCoord.x) - 2*idx.x,int(fragCoord.y) - 2*idx.y);\n    fragColor = save_color(off,vec4[4](\n    vec4(f0,f1,f2,1.),\n    vec4(f3,f4,f5,1.),\n    vec4(f6,f7,f8,1.),\n    vec4(rho,0,0,psi)));\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// draw wall\n\n#define IsInBox(box, idx) (idx.x > box.x && idx.x < box.y && idx.y > box.z && idx.y < box.w)\n\n#define Resolution() (texelFetch(iChannel2, ivec2(0,0), 0).zwx)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 idx = ivec2(fragCoord*0.5);\n    vec2 coord = fragCoord*0.5;\n    vec2 size = iResolution.xy*0.5;\n    vec3 resolution_old = Resolution();\n    vec4 data = texelFetch(iChannel2,idx*2,0);\n    \n    if(idx.x==0 && idx.y==0){\n        if(any(notEqual(resolution_old.xy,iResolution.xy))){\n            data = vec4(1., data.y, iResolution.xy);\n        }else{\n            data = vec4(0., data.y, iResolution.xy);\n        }\n    }\n    else if(resolution_old.z>0.5)\n    {    \n        //generate planet\n        vec2 center = size/2.;\n        vec2 dir = coord - center;\n        float ratio = size.y/100.;\n        float nScale = 4. * ratio;\n        float t = iDate.w;\n        float noise = 5. * ratio *(cos(coord.x/nScale + t) * sin(coord.y/nScale + t));\n        float r =  center.y/2.;\n        if(length(dir)+noise < r) \n            data = vec4(1.);\n    }\n\n    if(iMouse.z>0. && KEY_W == 0. && dist2Mouse < 8.) //The size of the eraser is bigger than the size of the brush\n    {\n        float clickData = Wall(iChannel2, ivec2(abs(iMouse.zw) / 2.));\n        if(clickData < 1.) // eraser\n            data.xy = vec2(0);\n        else if(dist2Mouse < 7.) // wall brush\n            data.xy = vec2(1);\n    }\n\n    // save\n    fragColor = data;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[871, 871, 908, 908, 974], [975, 975, 1004, 1004, 2029]], "test": "untested"}
{"id": "msyXDd", "name": "airpods-icon", "author": "dreness", "description": "converted from svg with https://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14", "tags": ["icon"], "likes": 3, "viewed": 146, "published": 3, "date": "1681792170", "time_retrieved": "2024-07-30T18:00:12.199961", "image_code": "#define ZERO min(0,iFrame)\n\nfloat border;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\t\n\treturn 3;\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\t//horner's method\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\t\n\tif(all(lessThan(uv,max(max(p0,p1),p2)+border)) && all(greaterThan(uv,min(min(p0,p1),p2)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint quadratic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\n\tfloat qu = (p0.y - 2. * p1.y + p2.y);\n\tfloat li = (-2. * p0.y + 2. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec2 roots = vec2(1e38);\n\tint n_roots = solve_quadric(vec2(co/qu,li/qu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\tfloat x_pos = p0.x - 2. * p1.x + p2.x;\n\t\t\tx_pos = x_pos * roots[i] + -2. * p0.x + 2. * p1.x;\n\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\tif(x_pos > uv.x){\n\t\t\t\tn_ints++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\t\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    \telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[98] p=vec2[](vec2(-0.109735,0.0382438),\n\t                  vec2(-0.0625072,0.0379592),\n\t                  vec2(-0.0237381,0.0750297),\n\t                  vec2(-0.0239248,0.119455),\n\t                  vec2(-0.0239517,0.163214),\n\t                  vec2(-0.0625072,0.2),\n\t                  vec2(-0.109735,0.2),\n\t                  vec2(-0.145373,0.2),\n\t                  vec2(-0.174403,0.180993),\n\t                  vec2(-0.192094,0.154231),\n\t                  vec2(-0.195962,0.148237),\n\t                  vec2(-0.197804,0.141895),\n\t                  vec2(-0.197804,0.134664),\n\t                  vec2(-0.197804,0.10358),\n\t                  vec2(-0.197804,0.0961886),\n\t                  vec2(-0.19606,0.0898471),\n\t                  vec2(-0.192094,0.0838526),\n\t                  vec2(-0.174528,0.0572511),\n\t                  vec2(-0.145373,0.0389109),\n\t                  vec2(-0.163739,0.0899628),\n\t                  vec2(-0.16808,0.0899628),\n\t                  vec2(-0.171308,0.0931914),\n\t                  vec2(-0.171308,0.0979141),\n\t                  vec2(-0.171308,0.140873),\n\t                  vec2(-0.171308,0.145435),\n\t                  vec2(-0.16808,0.148664),\n\t                  vec2(-0.163739,0.148664),\n\t                  vec2(-0.159114,0.148664),\n\t                  vec2(-0.155948,0.145435),\n\t                  vec2(-0.155948,0.140873),\n\t                  vec2(-0.155948,0.0979141),\n\t                  vec2(-0.155948,0.0931914),\n\t                  vec2(-0.159114,0.0899628),\n\t                  vec2(-0.0948728,-0.137991),\n\t                  vec2(-0.0441766,-0.137991),\n\t                  vec2(-0.0441766,0.0422197),\n\t                  vec2(-0.0583806,0.0312179),\n\t                  vec2(-0.0760086,0.0237643),\n\t                  vec2(-0.0948728,0.0213454),\n\t                  vec2(-0.0785254,-0.2),\n\t                  vec2(-0.0607463,-0.2),\n\t                  vec2(-0.0497445,-0.2),\n\t                  vec2(-0.0441766,-0.19493),\n\t                  vec2(-0.0441766,-0.185494),\n\t                  vec2(-0.0441766,-0.156063),\n\t                  vec2(-0.0948728,-0.156063),\n\t                  vec2(-0.0948728,-0.185494),\n\t                  vec2(-0.0948728,-0.19493),\n\t                  vec2(-0.0889229,-0.2),\n\t                  vec2(0.109735,0.0382438),\n\t                  vec2(0.145374,0.0389109),\n\t                  vec2(0.17459,0.0572511),\n\t                  vec2(0.192094,0.0838526),\n\t                  vec2(0.1959,0.0898471),\n\t                  vec2(0.197804,0.0961886),\n\t                  vec2(0.197804,0.10358),\n\t                  vec2(0.197804,0.134664),\n\t                  vec2(0.197804,0.141895),\n\t                  vec2(0.195962,0.148237),\n\t                  vec2(0.192094,0.154231),\n\t                  vec2(0.174466,0.180993),\n\t                  vec2(0.145374,0.2),\n\t                  vec2(0.109735,0.2),\n\t                  vec2(0.0625072,0.2),\n\t                  vec2(0.0239517,0.163214),\n\t                  vec2(0.0239248,0.119455),\n\t                  vec2(0.0237381,0.0750297),\n\t                  vec2(0.0625072,0.0379592),\n\t                  vec2(0.163739,0.0899628),\n\t                  vec2(0.159114,0.0899628),\n\t                  vec2(0.155948,0.0931914),\n\t                  vec2(0.155948,0.0979141),\n\t                  vec2(0.155948,0.140873),\n\t                  vec2(0.155948,0.145435),\n\t                  vec2(0.159114,0.148664),\n\t                  vec2(0.163739,0.148664),\n\t                  vec2(0.168079,0.148664),\n\t                  vec2(0.171308,0.145435),\n\t                  vec2(0.171308,0.140873),\n\t                  vec2(0.171308,0.0979141),\n\t                  vec2(0.171308,0.0931914),\n\t                  vec2(0.168079,0.0899628),\n\t                  vec2(0.0948728,-0.137991),\n\t                  vec2(0.0948728,0.0213454),\n\t                  vec2(0.0760086,0.0237643),\n\t                  vec2(0.0583806,0.0312179),\n\t                  vec2(0.0441766,0.0422197),\n\t                  vec2(0.0441766,-0.137991),\n\t                  vec2(0.0785259,-0.2),\n\t                  vec2(0.0889229,-0.2),\n\t                  vec2(0.0948728,-0.19493),\n\t                  vec2(0.0948728,-0.185494),\n\t                  vec2(0.0948728,-0.156063),\n\t                  vec2(0.0441766,-0.156063),\n\t                  vec2(0.0441766,-0.185494),\n\t                  vec2(0.0441766,-0.19493),\n\t                  vec2(0.0497445,-0.2),\n\t                  vec2(0.0607463,-0.2));\n\n\tivec2[20] seg=ivec2[](ivec2(12,13),\n\t                      ivec2(22,23),\n\t                      ivec2(29,30),\n\t                      ivec2(33,34),\n\t                      ivec2(34,35),\n\t                      ivec2(38,33),\n\t                      ivec2(39,40),\n\t                      ivec2(43,44),\n\t                      ivec2(44,45),\n\t                      ivec2(45,46),\n\t                      ivec2(55,56),\n\t                      ivec2(71,72),\n\t                      ivec2(78,79),\n\t                      ivec2(82,83),\n\t                      ivec2(86,87),\n\t                      ivec2(87,82),\n\t                      ivec2(91,92),\n\t                      ivec2(92,93),\n\t                      ivec2(93,94),\n\t                      ivec2(97,88));\n\n\tivec4[26] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(16,17,18,0),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(23,24,25,26),\n\t                        ivec4(26,27,28,29),\n\t                        ivec4(30,31,32,19),\n\t                        ivec4(35,36,37,38),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(46,47,48,39),\n\t                        ivec4(49,50,51,52),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(56,57,58,59),\n\t                        ivec4(59,60,61,62),\n\t                        ivec4(62,63,64,65),\n\t                        ivec4(65,66,67,49),\n\t                        ivec4(68,69,70,71),\n\t                        ivec4(72,73,74,75),\n\t                        ivec4(75,76,77,78),\n\t                        ivec4(79,80,81,68),\n\t                        ivec4(83,84,85,86),\n\t                        ivec4(88,89,90,91),\n\t                        ivec4(94,95,96,97));\n\n\tif(all(lessThan(uv,vec2(0.197804,0.2)+border)) && all(greaterThan(uv,vec2(-0.197804,-0.2)-border))){\n\t\tfor(int i=ZERO;i<20;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<26;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tborder=1./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\n    vec2 mouse=vec2(0);\n\n\tif(iMouse.x>0.0){\n\t\tmouse = iMouse.xy / iResolution.y;\n\t\tmouse.x -= .5 * iResolution.x / iResolution.y;\n\t\tmouse.y -= .75;\n\t}\n\t\n\tconst float pi=3.14159265358979;\n\n\tfloat t0=smoothstep(0.,0.,iTime);\n\tfloat t1=t0*6.*pi;\n\n\tmat2 rot=mat2(cos(t1),sin(t1),-sin(t1),cos(t1));\n\n    border*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=rot;\n\n\tuv.x+=mouse.x;\n\n\tfloat dis_sq=1e38;\n\n\tif(all(lessThan(uv,vec2(0.197804,0.2)+border)) && all(greaterThan(uv,vec2(-0.197804,-0.2)-border))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(uv));\n\t}\n\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n\n\tfragColor=vec4(smoothstep(-border, border, dis));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 164, 213, 248, 428], [430, 515, 558, 558, 1568], [1570, 1570, 1646, 1665, 1799], [1801, 1801, 1874, 1874, 2354], [2356, 2356, 2437, 2456, 2631], [2633, 2633, 2711, 2711, 3269], [3271, 3294, 3319, 3319, 3338], [3340, 3340, 3387, 3387, 3498], [3500, 3500, 3548, 3548, 3818], [3820, 3820, 3886, 3886, 4361], [4363, 4363, 4434, 4434, 5303], [12241, 12241, 12295, 12295, 13071]], "test": "untested"}
{"id": "dsyXDd", "name": "touchid-icon", "author": "dreness", "description": "converted from SVG with https://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14", "tags": ["icon"], "likes": 3, "viewed": 170, "published": 3, "date": "1681792026", "time_retrieved": "2024-07-30T18:00:13.133465", "image_code": "#define ZERO min(0,iFrame)\n\nfloat border;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\t\n\treturn 3;\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\t//horner's method\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\t\n\tif(all(lessThan(uv,max(max(p0,p1),p2)+border)) && all(greaterThan(uv,min(min(p0,p1),p2)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint quadratic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\n\tfloat qu = (p0.y - 2. * p1.y + p2.y);\n\tfloat li = (-2. * p0.y + 2. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec2 roots = vec2(1e38);\n\tint n_roots = solve_quadric(vec2(co/qu,li/qu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\tfloat x_pos = p0.x - 2. * p1.x + p2.x;\n\t\t\tx_pos = x_pos * roots[i] + -2. * p0.x + 2. * p1.x;\n\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\tif(x_pos > uv.x){\n\t\t\t\tn_ints++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\t\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    \telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[60] p=vec2[](vec2(-0.187406,-0.0602592),\n\t                  vec2(-0.18401,-0.0592106),\n\t                  vec2(-0.18213,-0.0563202),\n\t                  vec2(-0.183684,-0.0511147),\n\t                  vec2(-0.18854,-0.0333147),\n\t                  vec2(-0.190474,-0.0058193),\n\t                  vec2(-0.190342,0.0182969),\n\t                  vec2(-0.190288,0.0221276),\n\t                  vec2(-0.192634,0.0247534),\n\t                  vec2(-0.196504,0.0248624),\n\t                  vec2(-0.200583,0.0248855),\n\t                  vec2(-0.202983,0.0220421),\n\t                  vec2(-0.203147,0.0185379),\n\t                  vec2(-0.203496,-0.00438964),\n\t                  vec2(-0.201329,-0.0338275),\n\t                  vec2(-0.195851,-0.054813),\n\t                  vec2(-0.194748,-0.0593192),\n\t                  vec2(-0.191049,-0.0612226),\n\t                  vec2(-0.193155,0.0504699),\n\t                  vec2(-0.190039,0.0490327),\n\t                  vec2(-0.18565,0.0504389),\n\t                  vec2(-0.184329,0.0544637),\n\t                  vec2(-0.154316,0.144526),\n\t                  vec2(-0.0784164,0.187196),\n\t                  vec2(-0.00261069,0.187196),\n\t                  vec2(0.0365778,0.187196),\n\t                  vec2(0.0646098,0.176847),\n\t                  vec2(0.0849267,0.163359),\n\t                  vec2(0.0884543,0.161153),\n\t                  vec2(0.0927588,0.162551),\n\t                  vec2(0.0942736,0.166024),\n\t                  vec2(0.0957033,0.169746),\n\t                  vec2(0.0936057,0.172621),\n\t                  vec2(0.0904278,0.17461),\n\t                  vec2(0.0678964,0.189566),\n\t                  vec2(0.038124,0.2),\n\t                  vec2(-0.00261069,0.2),\n\t                  vec2(-0.0836923,0.2),\n\t                  vec2(-0.163888,0.154868),\n\t                  vec2(-0.19641,0.060392),\n\t                  vec2(-0.198003,0.0558544),\n\t                  vec2(-0.19641,0.0521327),\n\t                  vec2(0.196869,-0.0127652),\n\t                  vec2(0.200568,-0.0127652),\n\t                  vec2(0.203496,-0.00967311),\n\t                  vec2(0.203194,-0.0055317),\n\t                  vec2(0.196412,0.0635927),\n\t                  vec2(0.167586,0.118126),\n\t                  vec2(0.126074,0.152607),\n\t                  vec2(0.123098,0.155279),\n\t                  vec2(0.118957,0.155544),\n\t                  vec2(0.116634,0.153197),\n\t                  vec2(0.114202,0.150656),\n\t                  vec2(0.113814,0.146484),\n\t                  vec2(0.117123,0.143757),\n\t                  vec2(0.158044,0.107878),\n\t                  vec2(0.184142,0.060112),\n\t                  vec2(0.190466,-0.00578032),\n\t                  vec2(0.190824,-0.00981274),\n\t                  vec2(0.19317,-0.0127652));\n\n\tivec4[20] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,0),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,18),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,48),\n\t                        ivec4(48,49,50,51),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,57),\n\t                        ivec4(57,58,59,42));\n\n\tif(all(lessThan(uv,vec2(0.203496,0.2)+border)) && all(greaterThan(uv,vec2(-0.203496,-0.0612226)-border))){\n\t\tfor(int i=ZERO;i<20;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path1_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[42] p=vec2[](vec2(-0.160539,-0.116028),\n\t                  vec2(-0.158527,-0.11926),\n\t                  vec2(-0.154083,-0.12006),\n\t                  vec2(-0.150742,-0.117077),\n\t                  vec2(-0.137876,-0.106347),\n\t                  vec2(-0.131303,-0.0882912),\n\t                  vec2(-0.131442,-0.0721154),\n\t                  vec2(-0.131862,-0.044332),\n\t                  vec2(-0.143376,-0.0325533),\n\t                  vec2(-0.143376,0.00393138),\n\t                  vec2(-0.143376,0.076715),\n\t                  vec2(-0.079916,0.140175),\n\t                  vec2(-0.00671272,0.140175),\n\t                  vec2(0.0894953,0.140175),\n\t                  vec2(0.146499,0.0645871),\n\t                  vec2(0.147253,-0.0422654),\n\t                  vec2(0.147393,-0.0792868),\n\t                  vec2(0.142024,-0.111374),\n\t                  vec2(0.13274,-0.136181),\n\t                  vec2(0.131194,-0.140525),\n\t                  vec2(0.132965,-0.144138),\n\t                  vec2(0.135917,-0.145458),\n\t                  vec2(0.138979,-0.146531),\n\t                  vec2(0.142918,-0.145567),\n\t                  vec2(0.14441,-0.141395),\n\t                  vec2(0.153803,-0.114373),\n\t                  vec2(0.159638,-0.0804368),\n\t                  vec2(0.159638,-0.042351),\n\t                  vec2(0.159638,0.0714479),\n\t                  vec2(0.0976147,0.15256),\n\t                  vec2(-0.00671272,0.15256),\n\t                  vec2(-0.0869243,0.15256),\n\t                  vec2(-0.155761,0.0836688),\n\t                  vec2(-0.155761,0.00393138),\n\t                  vec2(-0.155761,-0.0291816),\n\t                  vec2(-0.143998,-0.0510212),\n\t                  vec2(-0.143804,-0.0720609),\n\t                  vec2(-0.143804,-0.0848491),\n\t                  vec2(-0.149359,-0.0984536),\n\t                  vec2(-0.159047,-0.106976),\n\t                  vec2(-0.161751,-0.109323),\n\t                  vec2(-0.162388,-0.113239));\n\n\tivec4[14] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,0));\n\n\tif(all(lessThan(uv,vec2(0.159638,0.15256)+border)) && all(greaterThan(uv,vec2(-0.162388,-0.146531)-border))){\n\t\tfor(int i=ZERO;i<14;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path2_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[30] p=vec2[](vec2(-0.0823633,-0.0549912),\n\t                  vec2(-0.0888974,-0.0396857),\n\t                  vec2(-0.0961619,-0.0196255),\n\t                  vec2(-0.0961619,-0.000590324),\n\t                  vec2(-0.0961619,0.0549916),\n\t                  vec2(-0.057913,0.0932405),\n\t                  vec2(-0.00261069,0.0932405),\n\t                  vec2(0.0159427,0.0932405),\n\t                  vec2(0.0308285,0.0884467),\n\t                  vec2(0.0453185,0.0791157),\n\t                  vec2(0.0491023,0.0768161),\n\t                  vec2(0.0528626,0.0780047),\n\t                  vec2(0.0541602,0.0804602),\n\t                  vec2(0.0558151,0.082962),\n\t                  vec2(0.0564989,0.0870489),\n\t                  vec2(0.0510137,0.0906537),\n\t                  vec2(0.0359565,0.100466),\n\t                  vec2(0.0168982,0.105679),\n\t                  vec2(-0.00261069,0.105679),\n\t                  vec2(-0.0650609,0.105679),\n\t                  vec2(-0.108601,0.0622795),\n\t                  vec2(-0.108601,-0.000590324),\n\t                  vec2(-0.108601,-0.0175124),\n\t                  vec2(-0.103675,-0.0373241),\n\t                  vec2(-0.0946391,-0.0597074),\n\t                  vec2(-0.0928988,-0.0637398),\n\t                  vec2(-0.0890299,-0.0651695),\n\t                  vec2(-0.0856733,-0.0637943),\n\t                  vec2(-0.0823633,-0.0624422),\n\t                  vec2(-0.0810657,-0.0586043));\n\n\tivec4[10] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,0));\n\n\tif(all(lessThan(uv,vec2(0.0564989,0.105679)+border)) && all(greaterThan(uv,vec2(-0.108601,-0.0651695)-border))){\n\t\tfor(int i=ZERO;i<10;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path3_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[42] p=vec2[](vec2(-0.122111,-0.150338),\n\t                  vec2(-0.107878,-0.142677),\n\t                  vec2(-0.0885402,-0.118405),\n\t                  vec2(-0.0838009,-0.0975601),\n\t                  vec2(-0.082946,-0.0935202),\n\t                  vec2(-0.0851916,-0.0902722),\n\t                  vec2(-0.0886953,-0.0894488),\n\t                  vec2(-0.0917567,-0.088765),\n\t                  vec2(-0.0949267,-0.0903887),\n\t                  vec2(-0.0959447,-0.094227),\n\t                  vec2(-0.101468,-0.115096),\n\t                  vec2(-0.114234,-0.129173),\n\t                  vec2(-0.127908,-0.138606),\n\t                  vec2(-0.132103,-0.141643),\n\t                  vec2(-0.132515,-0.145567),\n\t                  vec2(-0.130938,-0.148217),\n\t                  vec2(-0.129166,-0.150835),\n\t                  vec2(-0.125748,-0.152296),\n\t                  vec2(0.0725967,0.0550461),\n\t                  vec2(0.0911581,0.0277989),\n\t                  vec2(0.100061,-0.0127337),\n\t                  vec2(0.100061,-0.0550771),\n\t                  vec2(0.100061,-0.0999688),\n\t                  vec2(0.0878636,-0.144658),\n\t                  vec2(0.0658529,-0.17499),\n\t                  vec2(0.0636154,-0.177973),\n\t                  vec2(0.0630871,-0.18192),\n\t                  vec2(0.0655423,-0.184515),\n\t                  vec2(0.0678268,-0.18739),\n\t                  vec2(0.0729933,-0.187755),\n\t                  vec2(0.0754795,-0.184469),\n\t                  vec2(0.0995957,-0.151581),\n\t                  vec2(0.112617,-0.103208),\n\t                  vec2(0.112617,-0.0547195),\n\t                  vec2(0.112617,-0.00845229),\n\t                  vec2(0.102369,0.0323831),\n\t                  vec2(0.0841347,0.0612465),\n\t                  vec2(0.0813143,0.0656441),\n\t                  vec2(0.0771733,0.0663279),\n\t                  vec2(0.0742519,0.064533),\n\t                  vec2(0.071276,0.0626837),\n\t                  vec2(0.0700874,0.0587133));\n\n\tivec4[14] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,0),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,18));\n\n\tif(all(lessThan(uv,vec2(0.112617,0.0663279)+border)) && all(greaterThan(uv,vec2(-0.132515,-0.187755)-border))){\n\t\tfor(int i=ZERO;i<14;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path4_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[42] p=vec2[](vec2(-0.0824412,-0.174858),\n\t                  vec2(-0.052824,-0.151037),\n\t                  vec2(-0.0364616,-0.113184),\n\t                  vec2(-0.0366561,-0.070165),\n\t                  vec2(-0.0368503,-0.0380775),\n\t                  vec2(-0.0483878,-0.0176051),\n\t                  vec2(-0.0483878,0.00174074),\n\t                  vec2(-0.0483878,0.028032),\n\t                  vec2(-0.029982,0.0456065),\n\t                  vec2(-0.00445207,0.0456065),\n\t                  vec2(0.0331365,0.0456065),\n\t                  vec2(0.0509357,0.00985133),\n\t                  vec2(0.0512623,-0.0518216),\n\t                  vec2(0.051612,-0.113122),\n\t                  vec2(0.0293837,-0.161603),\n\t                  vec2(0.00105656,-0.188252),\n\t                  vec2(-0.00178726,-0.190738),\n\t                  vec2(-0.0017793,-0.194242),\n\t                  vec2(6.96385e-05,-0.196581),\n\t                  vec2(0.00208207,-0.199308),\n\t                  vec2(0.00644068,-0.2),\n\t                  vec2(0.00953312,-0.197156),\n\t                  vec2(0.0408127,-0.168736),\n\t                  vec2(0.0636547,-0.11233),\n\t                  vec2(0.0634061,-0.0515264),\n\t                  vec2(0.063072,0.0179317),\n\t                  vec2(0.0412634,0.057991),\n\t                  vec2(-0.00445207,0.057991),\n\t                  vec2(-0.0365241,0.057991),\n\t                  vec2(-0.0608037,0.0357241),\n\t                  vec2(-0.0608037,0.0021445),\n\t                  vec2(-0.0608037,-0.0171468),\n\t                  vec2(-0.0492892,-0.0431664),\n\t                  vec2(-0.0490951,-0.070165),\n\t                  vec2(-0.048901,-0.109183),\n\t                  vec2(-0.0639733,-0.143058),\n\t                  vec2(-0.0905836,-0.164897),\n\t                  vec2(-0.0940098,-0.167492),\n\t                  vec2(-0.0942274,-0.17161),\n\t                  vec2(-0.0920443,-0.174089),\n\t                  vec2(-0.0900629,-0.177064),\n\t                  vec2(-0.0860074,-0.178067));\n\n\tivec4[14] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,0));\n\n\tif(all(lessThan(uv,vec2(0.0636547,0.057991)+border)) && all(greaterThan(uv,vec2(-0.0942274,-0.2)-border))){\n\t\tfor(int i=ZERO;i<14;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path5_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[36] p=vec2[](vec2(-0.0404861,-0.190537),\n\t                  vec2(-0.0247224,-0.179186),\n\t                  vec2(-0.00876374,-0.159474),\n\t                  vec2(0.00225312,-0.128459),\n\t                  vec2(0.00361277,-0.124606),\n\t                  vec2(0.00222209,-0.120915),\n\t                  vec2(-0.00105691,-0.119897),\n\t                  vec2(-0.00416486,-0.118825),\n\t                  vec2(-0.00797969,-0.120169),\n\t                  vec2(-0.00930792,-0.123681),\n\t                  vec2(-0.0203327,-0.153484),\n\t                  vec2(-0.0339679,-0.169808),\n\t                  vec2(-0.0479606,-0.180187),\n\t                  vec2(-0.0509985,-0.182394),\n\t                  vec2(-0.0520785,-0.186287),\n\t                  vec2(-0.0500351,-0.189239),\n\t                  vec2(-0.0481857,-0.19258),\n\t                  vec2(-0.0438271,-0.193077),\n\t                  vec2(0.0129048,-0.0893557),\n\t                  vec2(0.0193224,-0.0664902),\n\t                  vec2(0.0159272,-0.0296713),\n\t                  vec2(0.00543068,-0.00445169),\n\t                  vec2(0.00332517,0.000777286),\n\t                  vec2(-0.000210009,0.00164766),\n\t                  vec2(-0.00357414,0.000404555),\n\t                  vec2(-0.00710932,-0.000838944),\n\t                  vec2(-0.0087876,-0.00440515),\n\t                  vec2(-0.00734998,-0.00840615),\n\t                  vec2(0.00312309,-0.0327944),\n\t                  vec2(0.00593548,-0.0657443),\n\t                  vec2(0.000349286,-0.0875608),\n\t                  vec2(-0.000536597,-0.0911505),\n\t                  vec2(0.000815499,-0.094266),\n\t                  vec2(0.00481689,-0.0950974),\n\t                  vec2(0.00865479,-0.0959829),\n\t                  vec2(0.0118248,-0.0935512));\n\n\tivec4[12] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,0),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,18));\n\n\tif(all(lessThan(uv,vec2(0.0193224,0.00164766)+border)) && all(greaterThan(uv,vec2(-0.0520785,-0.193077)-border))){\n\t\tfor(int i=ZERO;i<12;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tborder=1./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\n    vec2 mouse=vec2(0);\n\n\tif(iMouse.x>0.0){\n\t\tmouse = iMouse.xy / iResolution.y;\n\t\tmouse.x -= .5 * iResolution.x / iResolution.y;\n\t\tmouse.y -= .75;\n\t}\n\t\n\tconst float pi=3.14159265358979;\n\n\tfloat t0=smoothstep(0.,5.,iTime);\n\tfloat t1=t0*6.*pi;\n\n\tmat2 rot=mat2(cos(t1),sin(t1),-sin(t1),cos(t1));\n\n\tborder*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=rot;\n\n\tuv.x+=mouse.x;\n\n\tfloat dis_sq=1e38;\n\n\tif(all(lessThan(uv,vec2(0.203496,0.2)+border)) && all(greaterThan(uv,vec2(-0.203496,-0.2)-border))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path1_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path2_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path3_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path4_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path5_dis_sq(uv));\n\t}\n\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n\n\tfragColor=vec4(smoothstep(-border, border, dis));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 164, 213, 248, 428], [430, 515, 558, 558, 1568], [1570, 1570, 1646, 1665, 1799], [1801, 1801, 1874, 1874, 2354], [2356, 2356, 2437, 2456, 2631], [2633, 2633, 2711, 2711, 3269], [3271, 3294, 3319, 3319, 3338], [3340, 3340, 3387, 3387, 3498], [3500, 3500, 3548, 3548, 3818], [3820, 3820, 3886, 3886, 4361], [4363, 4363, 4434, 4434, 5303], [23699, 23699, 23753, 23753, 24721]], "test": "untested"}
{"id": "mdyXDd", "name": "bonjour-logo", "author": "dreness", "description": "Converted from SVG with https://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14", "tags": ["icon"], "likes": 1, "viewed": 152, "published": 3, "date": "1681791939", "time_retrieved": "2024-07-30T18:00:14.059988", "image_code": "#define ZERO min(0,iFrame)\n\nfloat border;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\t\n\treturn 3;\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\t//horner's method\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\t\n\tif(all(lessThan(uv,max(max(p0,p1),p2)+border)) && all(greaterThan(uv,min(min(p0,p1),p2)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint quadratic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\n\tfloat qu = (p0.y - 2. * p1.y + p2.y);\n\tfloat li = (-2. * p0.y + 2. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec2 roots = vec2(1e38);\n\tint n_roots = solve_quadric(vec2(co/qu,li/qu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\tfloat x_pos = p0.x - 2. * p1.x + p2.x;\n\t\t\tx_pos = x_pos * roots[i] + -2. * p0.x + 2. * p1.x;\n\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\tif(x_pos > uv.x){\n\t\t\t\tn_ints++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\t\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    \telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[78] p=vec2[](vec2(-0.221429,0.0935788),\n\t                  vec2(-0.221429,0.0274293),\n\t                  vec2(-0.14065,-0.0407099),\n\t                  vec2(-0.00529893,-0.0407099),\n\t                  vec2(0.0585909,-0.0407099),\n\t                  vec2(0.114833,-0.0250937),\n\t                  vec2(0.155012,0.00318739),\n\t                  vec2(0.145155,0.00821305),\n\t                  vec2(0.136588,0.0161222),\n\t                  vec2(0.13039,0.0253467),\n\t                  vec2(0.100136,-0.00248757),\n\t                  vec2(0.0524272,-0.0177156),\n\t                  vec2(-0.00529893,-0.0177156),\n\t                  vec2(-0.124562,-0.0177156),\n\t                  vec2(-0.170264,0.0462584),\n\t                  vec2(-0.170264,0.0840084),\n\t                  vec2(-0.170264,0.0926428),\n\t                  vec2(-0.168788,0.100679),\n\t                  vec2(-0.166233,0.10745),\n\t                  vec2(-0.183316,0.117712),\n\t                  vec2(-0.194868,0.136026),\n\t                  vec2(-0.196808,0.155875),\n\t                  vec2(-0.213132,0.140057),\n\t                  vec2(-0.221429,0.118757),\n\t                  vec2(0.101932,-0.0863272),\n\t                  vec2(0.101932,-0.00284158),\n\t                  vec2(0.0216754,0.121658),\n\t                  vec2(-0.0688512,0.16456),\n\t                  vec2(-0.068792,0.163877),\n\t                  vec2(-0.068792,0.163101),\n\t                  vec2(-0.068792,0.162629),\n\t                  vec2(-0.068792,0.152249),\n\t                  vec2(-0.0712882,0.142291),\n\t                  vec2(-0.0758584,0.133201),\n\t                  vec2(-0.00373913,0.10965),\n\t                  vec2(0.0634055,0.0137529),\n\t                  vec2(0.0634055,-0.0666723),\n\t                  vec2(0.0634055,-0.112964),\n\t                  vec2(0.0355884,-0.147266),\n\t                  vec2(0.000772347,-0.147266),\n\t                  vec2(0.00194447,-0.152468),\n\t                  vec2(0.00263565,-0.15773),\n\t                  vec2(0.00263565,-0.162933),\n\t                  vec2(0.00263565,-0.175809),\n\t                  vec2(-0.00109139,-0.188052),\n\t                  vec2(-0.00836803,-0.198676),\n\t                  vec2(-0.00753352,-0.198735),\n\t                  vec2(-0.00652157,-0.198735),\n\t                  vec2(-0.00556876,-0.198735),\n\t                  vec2(0.0568791,-0.198735),\n\t                  vec2(0.101932,-0.151726),\n\t                  vec2(0.11775,0.178987),\n\t                  vec2(0.00744199,0.178987),\n\t                  vec2(-0.112799,0.0156162),\n\t                  vec2(-0.112799,-0.0863272),\n\t                  vec2(-0.112799,-0.096758),\n\t                  vec2(-0.111416,-0.107551),\n\t                  vec2(-0.108684,-0.118589),\n\t                  vec2(-0.0995944,-0.108563),\n\t                  vec2(-0.0859089,-0.100864),\n\t                  vec2(-0.070158,-0.0986213),\n\t                  vec2(-0.0728312,-0.0893881),\n\t                  vec2(-0.0744838,-0.0780136),\n\t                  vec2(-0.0744838,-0.0666723),\n\t                  vec2(-0.0744838,0.0226398),\n\t                  vec2(0.0130241,0.139078),\n\t                  vec2(0.0994191,0.139078),\n\t                  vec2(0.122472,0.139078),\n\t                  vec2(0.141048,0.130469),\n\t                  vec2(0.151107,0.115485),\n\t                  vec2(0.160947,0.121531),\n\t                  vec2(0.172112,0.124508),\n\t                  vec2(0.184212,0.124508),\n\t                  vec2(0.192391,0.124508),\n\t                  vec2(0.200359,0.122948),\n\t                  vec2(0.207484,0.120367),\n\t                  vec2(0.19697,0.157064),\n\t                  vec2(0.163933,0.178987));\n\n\tivec4[26] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,0),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,48),\n\t                        ivec4(48,49,50,24),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,57),\n\t                        ivec4(57,58,59,60),\n\t                        ivec4(60,61,62,63),\n\t                        ivec4(63,64,65,66),\n\t                        ivec4(66,67,68,69),\n\t                        ivec4(69,70,71,72),\n\t                        ivec4(72,73,74,75),\n\t                        ivec4(75,76,77,51));\n\n\tif(all(lessThan(uv,vec2(0.207484,0.178987)+border)) && all(greaterThan(uv,vec2(-0.221429,-0.198735)-border))){\n\t\tfor(int i=ZERO;i<26;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat path1_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[36] p=vec2[](vec2(-0.133103,0.12541),\n\t                  vec2(-0.11231,0.12541),\n\t                  vec2(-0.0958842,0.141776),\n\t                  vec2(-0.0958842,0.162629),\n\t                  vec2(-0.0958842,0.183271),\n\t                  vec2(-0.112462,0.2),\n\t                  vec2(-0.133103,0.2),\n\t                  vec2(-0.153804,0.2),\n\t                  vec2(-0.170533,0.183271),\n\t                  vec2(-0.170533,0.162629),\n\t                  vec2(-0.170533,0.14208),\n\t                  vec2(-0.153804,0.12541),\n\t                  vec2(0.184212,0.0230698),\n\t                  vec2(0.204913,0.0230698),\n\t                  vec2(0.221429,0.0394959),\n\t                  vec2(0.221429,0.0602893),\n\t                  vec2(0.221429,0.0809898),\n\t                  vec2(0.204761,0.097719),\n\t                  vec2(0.184212,0.097719),\n\t                  vec2(0.16357,0.097719),\n\t                  vec2(0.146841,0.0809898),\n\t                  vec2(0.146841,0.0602893),\n\t                  vec2(0.146841,0.0397994),\n\t                  vec2(0.16357,0.0230698),\n\t                  vec2(-0.0616755,-0.2),\n\t                  vec2(-0.040823,-0.2),\n\t                  vec2(-0.0244561,-0.183633),\n\t                  vec2(-0.0244561,-0.162933),\n\t                  vec2(-0.0244561,-0.14208),\n\t                  vec2(-0.0411857,-0.125562),\n\t                  vec2(-0.0616755,-0.125562),\n\t                  vec2(-0.0823761,-0.125562),\n\t                  vec2(-0.0990465,-0.14208),\n\t                  vec2(-0.0990465,-0.162933),\n\t                  vec2(-0.0990465,-0.183482),\n\t                  vec2(-0.0823761,-0.2));\n\n\tivec4[12] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,0),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,12),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,24));\n\n\tif(all(lessThan(uv,vec2(0.221429,0.2)+border)) && all(greaterThan(uv,vec2(-0.170533,-0.2)-border))){\n\t\tfor(int i=ZERO;i<12;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tborder=1./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\n    vec2 mouse=vec2(0);\n\n\tif(iMouse.x>0.0){\n\t\tmouse = iMouse.xy / iResolution.y;\n\t\tmouse.x -= .5 * iResolution.x / iResolution.y;\n\t\tmouse.y -= .75;\n\t}\n\t\n\tconst float pi=3.14159265358979;\n\n\tfloat t0=smoothstep(0.,0.,iTime);\n\tfloat t1=t0*6.*pi;\n\n\tmat2 rot=mat2(cos(t1),sin(t1),-sin(t1),cos(t1));\n\n\tborder*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=exp(4.*mouse.y)*exp(1.-1.*t0);\n\tuv*=rot;\n\n\tuv.x+=mouse.x;\n\n\tfloat dis_sq=1e38;\n\n\tif(all(lessThan(uv,vec2(0.221429,0.2)+border)) && all(greaterThan(uv,vec2(-0.221429,-0.2)-border))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(uv));\n\t\tdis_sq=min(dis_sq,path1_dis_sq(uv));\n\t}\n\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n\n\tfragColor=vec4(smoothstep(-border, border, dis));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 164, 213, 248, 428], [430, 515, 558, 558, 1568], [1570, 1570, 1646, 1665, 1799], [1801, 1801, 1874, 1874, 2354], [2356, 2356, 2437, 2456, 2631], [2633, 2633, 2711, 2711, 3269], [3271, 3294, 3319, 3319, 3338], [3340, 3340, 3387, 3387, 3498], [3500, 3500, 3548, 3548, 3818], [3820, 3820, 3886, 3886, 4361], [4363, 4363, 4434, 4434, 5303], [13171, 13171, 13225, 13225, 14037]], "test": "untested"}
{"id": "dsGSWt", "name": "normal map but it's a sphere", "author": "ThePlaneGuy45", "description": "normals go brr", "tags": ["normalmap"], "likes": 1, "viewed": 259, "published": 3, "date": "1681781690", "time_retrieved": "2024-07-30T18:00:14.809983", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "uint raySphere(in Sphere sph, inout Record rec) {\n\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    \n    if (disc > 0.0) {\n    \n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        \n        if(dstNear < rec.dist) {\n        \n            if(dstNear > 0.0) {\n        \n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.offset = (rec.intersect - sph.center - sph.radius) / sph.radius - 0.5;\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                \n                return uint(0x1);\n        \n            }\n        \n        }\n        \n        return uint(0x0);\n    \n    }\n\n}\n\nvoid distances(inout Record rec) {\n\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 0, 10.0, 0.42, 0.75), vec3(200.0, 0.0, 0.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 1, 40.0, 0.42, 0.40), vec3(0.0, 0.0, 200.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 2, 10.0, 0.42, 0.80), vec3(-200.0, 0.0, 0.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 3, 10.0, 0.42, 0.60), vec3(0.0, 0.0, -200.0), 100.0), rec);\n\n}\n\nvoid initRay(inout Ray ray, in vec2 fragCoord) {\n\n    ray.origin = vec3(0.0, 0.0, -500.0);\n    ray.normal = normalize(vec3(fragCoord, 500.0));\n    mat2 rot = rot2(4.0 * (iMouse.y/iResolution.y-0.5));\n    ray.origin.yz *= rot;\n    ray.normal.yz *= rot;\n    rot = rot2(4.0 * (iMouse.x/iResolution.x-0.5));\n    ray.origin.xz *= rot;\n    ray.normal.xz *= rot;\n\n}\n\nvoid initRecord(inout Record rec, in Ray ray) {\n\n    rec.ray = ray;\n    rec.hit = false;\n    rec.dist = 100000.0;\n\n}\n\nvec4 triPlanar(sampler2D tex, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    vec3 blend = normalize(max(abs(normal), 0.000001));\n    float sum = blend.x + blend.y + blend.z;\n    blend /= sum;\n    vec4 x = texture(tex, offset.yz * scale + imgOffset);\n    vec4 y = texture(tex, offset.xz * scale + imgOffset);\n    vec4 z = texture(tex, offset.xy * scale + imgOffset);\n    return x * blend.x + y * blend.y + z * blend.z;\n\n}\n\nvec4 texturize(int id, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    switch(id) {\n    case 0:\n        return triPlanar(iChannel0, offset, normal, scale, imgOffset);\n    case 1:\n        return triPlanar(iChannel1, offset, normal, scale, imgOffset);\n    case 2:\n        return triPlanar(iChannel2, offset, normal, scale, imgOffset);\n    case 3:\n        return triPlanar(iChannel3, offset, normal, scale, imgOffset);\n    }\n    return vec4(0.0);\n\n}\n\nfloat getHeight(vec4 tex) {\n\n    return dot(tex.rgb, vec3(.2126, .7152, .0722));\n\n}\n\nvec3 normal(int id, vec3 offset, vec3 normal, float scale, vec2 res, float strength) {\n\n    float current = getHeight(texturize(id, offset, normal, scale, vec2(0.0)));\n    float x = (getHeight(texturize(id, offset, normal, scale, vec2(1.0 / res.x, 0.0))) - current) * strength;\n    float y = (getHeight(texturize(id, offset, normal, scale, vec2(0.0, 1.0 / res.y))) - current) * strength;\n    return normalize(vec3(x, y, 1.0));\n\n}\n\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nvec4 Trace(in vec2 fragCoord, vec3 iChannelResolution[4], float iTime) {\n\n    Ray ray;\n    Record rec;\n    initRay(ray, fragCoord);\n    initRecord(rec, ray);\n    distances(rec);\n    if(rec.hit) {\n        vec3 matColor;\n        vec3 nMap;\n        if(rec.material.useTexture) {\n            matColor = texturize(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, vec2(0.0)).xyz;\n            nMap = normal(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, iChannelResolution[3].xy, rec.material.bumpStrength);\n            rec.normal = worldSpace(nMap, rec.tangent, rec.bitangent, rec.normal);\n        } else {\n            matColor = rec.material.color;\n        }\n        vec3 lightNormal = normalize((vec3(400.0, 400.0, 400.0) * vec3(cos(iTime), 1.0, sin(iTime))) - rec.intersect);\n        float shade = clamp(dot(lightNormal, rec.normal), 0.0, 1.0);\n        float specang = acos(shade);\n        float specexp = specang / (1.0-rec.material.specular);\n        float spec = exp(-specexp * specexp) * rec.material.specular;\n        vec3 result = matColor * mix(vec3(0.2), vec3(1.0), shade) + vec3(spec);\n        return vec4(result, 1.0);\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / 720.0;\n    fragColor = Trace((fragCoord-(iResolution.xy)/2.0)/ratio, iChannelResolution, iTime);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BUMPSTRENGTH 10.0\n\nstruct Material {\n\n    vec3 color;\n    bool useTexture;\n    int texID;\n    float bumpStrength;\n    float texScale;\n    float specular;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGSWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 140]], "test": "untested"}
{"id": "msGSWd", "name": "Flower rug 2 (music)", "author": "jarble", "description": "Another colorful rug pattern.", "tags": ["fractal", "rug"], "likes": 4, "viewed": 181, "published": 3, "date": "1681776796", "time_retrieved": "2024-07-30T18:00:15.559977", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5+uv+t2)/1.5\n            //abs(.5*sign(t2.y-t2.x)+uv+t2)/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv+1.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx+floor(.5+t2.y+t2.x))\n        ;\n        {t2 = t2.yx; uv=uv.yx;}\n        col.x =\n            //sign(uv.x-uv.y)*sign(t2.x-t2.y)\n            max(sign(uv.x-t2.y)*sign(uv.y-t2.x),col.x)\n            //max(col.x,sign(uv.x-uv.y)*sign(t2.x-t2.y))\n            //max(col.x,float(b))\n        ;\n        col =\n            abs(col.yzx-float(b)/2.)\n            //abs(col.yzx*sign(uv.y-uv.x)-float(b)*sign(t2.x-t2.y))/2.\n            //abs(max(col.yzx*sign(uv.x-uv.y),col*sign(t2.x-t2.y))-float(b)/2.)\n            //min(col.yzx,abs(col.yzx-float(b)/2.))\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mdKXz1\n\nfloat fmod(float a, float b){\n    return\n        mod(floor(a),b)\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  float tempo = 8.;\n  tempo *= pow(2.,fmod(time*tempo,3.));\n\n  time /= tempo;\n  float s1 =\n      8.;\n\n  float s2 = tempo,\n  t=\n      time*tempo\n  ,\n  m1 =\n      fmod(t*8.,s2)\n  ,\n  m3 =\n      (fmod(t,abs(s2*2.-m1)+1.)-m1);\n  float m2 =\n      1. + fmod(t,s1)\n  ;\n  \n  float a=\n      64.*(1.-sqrt(fract(t/s1)/1.25))*.2\n  ,\n\n  nb = time*tempo*pow(2.,floor((m3+m2)/2.)/5.+6.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1411]], "test": "untested"}
{"id": "cdySWt", "name": "Fibonacci Spheres", "author": "delajor", "description": "Hey, this one looks OK!  Trick was to use a modulo on the radius.  Getting the golden variables is pretty tricky, though.  Just guessing really, mixing a handful of irrational numbers until it looks OK.  Proper treatment would require some sort of search.", "tags": ["raytracing"], "likes": 9, "viewed": 247, "published": 3, "date": "1681756154", "time_retrieved": "2024-07-30T18:00:16.322937", "image_code": "#define NUM_SPHERES 2048\n#define PSI  1.533751168755204288118041 \n#define PHI  sqrt(2.0)\n#define GPHI 0.5 * (1.0 +  sqrt(5.0))\n\n#define LIGHT_POWER 30.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct quat\n{\n    float s;\n    vec3 v;\n};\n\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula#Vector_formulation\n    //return p + 2.0 * cross(q.v, cross(q.v, p)) + 2.0 * cross(q.v, q.s * p); // cross-product is distributive\n    //return p + 2.0 * cross(q.v, q.s * p) + 2.0 * cross(q.v, cross(q.v, p)); // vector addition is commutative\n    //return p + 2.0 * q.s * cross(q.v, p) + 2.0 * cross(q.v, cross(q.v, p)); // scalar can be factored-out\n    // translate variable names\n    vec3 x = p;\n    float a = q.s;\n    vec3 omega = q.v;\n    return x + 2.0 * a * cross(omega, x) + 2.0 * cross(omega, cross(omega, x)); // Euler Rodrigues' Formula\n}\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, c;\n};\n\nmat3 rotate_around_z(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\n\nmat3 rotate_around_y(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nSphere getSphere(int i){\n    float N = float(NUM_SPHERES);\n    float t = float(i) / N;\n\n    float sqti = sqrt(t);\n    float sqt1i = sqrt(1.0 - t);\n\n    float u = iMouse.x / iResolution.x;\n    float v = iMouse.y / iResolution.y;\n    float golden = 0.5 * (1.0 + sqrt(5.0));\n    float sup_golden =1.4655712318767680266567312;\n    float psi4 = 1.533751168755204288118041;\n    float plastic = 1.32471795724474602596;\n    float root2 = sqrt(2.0);\n    float root3 = sqrt(3.0);\n    float good_guess = 1.57801;\n    float test = pow(1.0 / 2.0 / PI, 0.5);\n    \n    //float phi = plastic;\n    //float psi = sup_golden;\n    \n    //float phi = sup_golden;\n    //float psi = 0.1*plastic;\n\n    //float phi = root2;\n    float psi = plastic;\n    \n    float phi = golden;\n    //float psi = sup_golden;\n    float Nt = N * t;\n    \n\n    float NtP =(Nt) * plastic;\n    float thet = 2.0 * PI * Nt;\n    \n    float t0 = NtP - floor(NtP);\n    float x0 =  sqti * sin(thet / phi);\n    float x1 =  sqti * cos(thet / phi);\n    float y0 =  sqt1i * sin(thet / psi);\n    float y1 =  sqt1i * cos(thet / psi);\n    quat q = quat(y0, vec3(y1, x0, x1));\n    //vec3 p = rotate_around_y(0.1*float(iMouse.x)) * vec3(10.0 * x1, 10.0 * x0,t0);\n    \n    //vec3 c0 = vec3(1.0, 0.3, 0.2);\n    vec3 p0 = 3.0 * pow(t0, 1.0/3.0)* vec3(1.0, 0.0, 0.0);\n    vec3 p = rotate(q, p0);\n    //ugly keyframe ifs... blech\n    int tB = 600;\n    int tBh = tB/2;\n    int tBq = tB/4;\n    //vec3 p = 3.0 * vec3(x0, y0, z0);\n    float rest = -1.0 * PI / 3.0;\n    \n    if(iFrame%tB > tBh){\n        int fF = iFrame%tB - tBh;\n        float fl = 2.0 * float(fF % tBq)/ float(tBq) - 1.0;\n        if(fF <= tBq){\n           float zm = fl;\n            if(p[2] < zm - 0.2)\n                 return Sphere(0.0, vec3(-1.0), vec3(0.0));\n            if(p[2] > zm + 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n        }\n        if(fF > tBq){\n            float xm = fl;\n            if(p[0] < xm - 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n            if(p[0] > xm + 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n        }\n         p = rotate_around_y(rest) * p;\n    }\n    else\n        p = rotate_around_y(rest + 2.0 * PI * float(iFrame) / float(tBh)) * p;\n    //vec3 p = rotate_around_y(0.1*float(iMouse.x)) * vec3(10.0 * x1, 10.0 * x0,t0);\n    \n    vec3 c0 = vec3(\n        pow(cos(1.0 * PI*t + 0.0 * PI/3.0),2.0),\n        pow(cos(1.0 * PI*t + 2.0 * PI/3.0),2.0), \n        pow(cos(1.0 * PI*t + 4.0 * PI/3.0),2.0));\n\n    //p0 = rotate_around_y(0.2*float(iTime)) * p0;\n;\n    vec3 c = c0;\n    \n    \n    return Sphere(0.15, p, c);\n}\n\n#define MAX_STEPS 600\n#define MAX_DIST 1e10\n#define EPS .001\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n\n    int imin = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        Sphere sphere = getSphere(i);\n        vec3 c = sphere.p;\n        float r = sphere.r;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                imin = i;\n                d = sd;\n            }\n        }\n    }\n    return imin;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int i_s = findIntersection(camO, camL, -1, d);\n    \n    if (i_s == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    \n    vec3 lightPoint = vec3(-5.0, 5.0, -5.0);\n    Sphere sph = getSphere(i_s);\n    \n    // Sphere color\n    vec3 sColor = sph.c;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sph.p);\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint );\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, i_s, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (shadowedBy > -1) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, -25);\n    vec3 camL = normalize(vec3(uv.x, uv.y,6));\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdySWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 283, 283, 326], [371, 371, 475, 475, 1223], [1294, 1294, 1328, 1328, 1436], [1439, 1439, 1473, 1473, 1581], [1583, 1583, 1607, 1607, 4189], [4253, 4500, 4563, 4563, 5216], [5218, 5336, 5370, 5370, 6719], [6721, 6721, 6778, 6828, 7117]], "test": "untested"}
{"id": "ddKXD3", "name": "five tetrahedra star tinycode", "author": "flockaroo", "description": "5 intersecting tetrahedra - less than 1 tweet at twigl.app: [url]https://twigl.app/?ol=true&ss=-NTBw5cA8Txbmj0wIHQx[/url]\n...here's an older but more elaborate version of this [url]https://www.shadertoy.com/view/3tsXD4[/url]", "tags": ["star", "tetrahedra", "tiny", "dodecahedron", "golfed"], "likes": 20, "viewed": 360, "published": 3, "date": "1681731917", "time_retrieved": "2024-07-30T18:00:17.160697", "image_code": "// created by florian berger (flockaroo) - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 5 intersecting tetrahedra\n// the edges form a dodecahedron\n\n// less than 1 tweet in twigl.app:\n// https://twigl.app/?ol=true&ss=-NTBw5cA8Txbmj0wIHQx\n\n// ...a more elaborate version:\n// https://www.shadertoy.com/view/3tsXD4\n\n/*\n#define rotate2D(x) mat2(cos(x-vec4(0,1.57,-1.57,0)))\n#define t iTime\n#define r iResolution\n#define FC vec4(c,0,1)\n\nvoid mainImage( out vec4 o, in vec2 c )\n{\n    vec3 p,q=vec3(0,0,6),a,s=(FC.rgb*2.-r.xyx)/r.x;\n    float w,d,i=0.;\n    for(;i<80.;i++,q+=s*d)\n        for(d=w=6.+t;w>t;w-=1.3){\n            p=q;p.xz*=rotate2D(w);p.xy*=rotate2D(1.);\n            for(a=abs(p);a.z<a.x||a.z<a.y;p=p.zxy,a=a.zxy);\n            d=min(d,length(p.xz-vec2(p.y,1)*a.z/p.z)*.7-.07);\n        }\n    o.rgb=fwidth(q*40.); // ...Xor's fwidth trick always handy for tiny-code-normals\n}\n\n*/\n\n// fabrices optimizations so far:\n\n#define R(x) mat2(cos(x-vec4(0,33,11,0)))\n\nvoid mainImage( out vec4 o, vec2 c )\n{\n    vec3 a, r = iResolution, \n         q = 6./r, p;\n  \n    for(float w,d,i=0. ; i++<80.; q += ( vec3(c+c,0) - r.xyx ) / r.x*d )\n        for( d=w=6. ; w>0. ; w -= 1.3 ){\n            p = q;\n            p.xz *= R(iTime+w);\n            for( p.xy *= R(1.) ; ( a = abs(p) ).z < max(a.x,a.y) ; p = p.zxy );\n            d = min(d, length( p.xz - vec2(p.y,1)*a.z/p.z ) *.7 -.07 );\n        }\n    o.rgb = fwidth(q*r/9.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddKXD3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1013, 1013, 1051, 1051, 1463]], "test": "untested"}
{"id": "DtBGRW", "name": "PBR GGX BRDF", "author": "gelami", "description": "Implementing GGX for PBR with approximate multiscattering for learning\nHas depth of field with a number of custom bokeh shapes to choose from\n\nMouse drag to look around\nDefines in Common", "tags": ["3d", "raytracing", "pathtracing", "brdf", "pbr", "ggx", "mutliscattering"], "likes": 21, "viewed": 598, "published": 3, "date": "1681731522", "time_retrieved": "2024-07-30T18:00:18.270730", "image_code": "\n// PBR GGX BRDF by gelami\n// https://www.shadertoy.com/view/DtBGRW\n\n/* \n * Implementing GGX for PBR with approximate multiscattering for learning\n * Has depth of field with a number of custom bokeh shapes to choose from\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * List of bokeh shapes:\n *   Circle, Square, Polygon, Star, Heart,\n *   Crescent (Rejection sampling and approx.), Cross + 4 Circles, Annulus / 2D Torus, E\n * \n * For the crescent shape, there seems to be no exact way to uniformly sample it\n * You can do rejection sampling, but it takes too many tries when the crescent becomes thin\n * So an approximation I did is to sample on the two arcs of the cresent in a sine PDF,\n * and interpolate between them\n * \n * Here's the Desmos graph for the sampling:\n * https://www.desmos.com/calculator/uwcqvxdsjc\n * \n * I tried to implement random-walk multiscattering\n * but haven't gotten it to work yet though T_T\n * \n * Resources:\n * \n * - PBR implementation:\n * \n * Physically Based Rendering in Filament\n * https://google.github.io/filament/Filament.md.html\n *\n * - Multiscattering GGX approximation:\n * \n * A Multi-Faceted Exploration\n * https://blog.selfshadow.com/2018/05/13/multi-faceted-part-1/\n * \n * Revisiting Physically Based Shading at Imageworks\n * https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf\n * \n * Multiscattering BRDF Energy Compensation\n * https://patapom.com/blog/BRDF/MSBRDFEnergyCompensation/\n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-01-04 08:38:20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n        col = texelFetch(iChannel0, ivec2(1, 0), 0).rgb;\n    \n    col *= exp2(EXPOSURE);\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// 0 : Grid of spheres\n// 1 : Single sphere\n#define SCENE 0\n\n// 0 : Fake iridescent-like color\n// 1 : Metallic colors\n// 2 : White\n#define COLOR 1\n\n// Shape type of depth of field\n// 0 : Circle\n// 1 : Square\n// 2 : Polygon\n// 3 : Star\n// 4 : Heart\n// 5 : Crescent\n// 6 : Cross + 4 Circles\n// 7 : Annulus / 2D Torus\n// 8 : E\n#define DOF_TYPE 3\n\n// Number of sides for Polygon and Star shapes\n#define DOF_SIDES 5\n\n#define DOF_STRENGTH 0.1\n\n#define DOF_AUTOFOCUS\n#define DOF_FOCUS_DISTANCE 0.75\n\n#define ENABLE_SKY_STARS\n#define SKYBOX_STRENGTH 1.0\n#define EXPOSURE 0.0\n\n#define BOUNCES 4\n\n// 0: No importance sampling\n// 1: D importance sampling\n// 2: VNDF importance sampling\n#define GGX_IMPORTANCE_SAMPLING 2\n\n// 0: No Multiscattering\n// 1: Approx\n// 2: Random walk // TODO: Brokey T_T\n#define GGX_MULTISCATTERING 1\n\n//#define WHITE_FURNACE_TEST\n//#define STATIC_CAM\n//#define NO_ACCUMULATE\n\n#define MIN_ROUGHNESS 0.045\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPSILON 1e-3\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n#define INV_PI (1.0 / PI)\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 color;\n    vec3 emissive;\n    float roughness;\n    float metallic;\n    float transmission;\n    float clearcoat;\n    float ior;\n};\n\nstruct HitInfo\n{\n    float t;\n    vec3 normal;\n    vec3 bumpNormal;\n    bool inside;\n};\n\nHitInfo NewHitInfo()\n{\n    return HitInfo(MAX_DIST, vec3(0), vec3(0), false);\n}\n\nMaterial DefaultMaterial()\n{\n    return Material(vec3(1), vec3(0), 1.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nbool noHit(HitInfo hit)\n{\n    return hit.t >= MAX_DIST;\n}\n\nvec3 reorientedNormalMapping(vec3 n1, vec3 n2)\n{\n    vec3 t = (n1*0.5+0.5) * vec3( 2,  2, 2) + vec3(-1, -1,  0);\n    vec3 u = (n2*0.5+0.5) * vec3(-2, -2, 2) + vec3( 1,  1, -1);\n    vec3 r = t*dot(t, u)/t.z - u;\n    return r*0.5 + 0.5;\n}\n\nbool sphereIntersect(Ray ray, vec3 center, float radius, inout HitInfo hit)\n{\n    vec3 oc = ray.origin - center;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - radius * radius;\n    float h = b*b - c;\n    if( h < 0.0 || b > 0.0) return false;\n    h = sqrt( h );\n    vec2 t = vec2(-b-h, -b+h );\n    \n    bool inside = false;\n    if (t.x < 0.0)\n    {\n        t.x = t.y;\n        inside = true;\n    }\n    \n    if (t.x < hit.t)\n    {\n        hit.t = t.x;\n        hit.normal = normalize(ray.origin - center + ray.direction * hit.t);\n        if (inside) hit.normal = -hit.normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat pow5(float x)\n{\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat pow6(float x)\n{\n    float x2 = x * x;\n    return x2 * x2 * x2;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n    vec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(vec2(s),coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// Modified to work with 4 values at once\nuvec4 hash4i(inout uint y)\n{\n    uvec4 x = y * uvec4(213u, 2131u, 21313u, 213132u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\n// Modified to work with 4 values at once\nuvec3 hash3i(inout uint y)\n{\n    uvec3 x = y * uvec3(213u, 2131u, 21313u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3( hash3i(x) ) / float( 0xffffffffU );\n    //return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\n\n// Random point in circle\n// Very straightforward, unit circle scaled by sqrt of the radius\nvec2 randomPointInCircle()\n{\n    vec2 rand = hash2(state);\n    \n    float a = rand.x * TAU;\n    float r = sqrt(rand.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Random point in polygon\n// Pick a random side and\n// generate a point in a rhombus (equal quadrilateral),\n// and fold it if the point is outside the inner triangle\nvec2 randomPointInPolygon(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    vec2 p1 = s1 * rand.y + s2 * rand.z;\n    vec2 p2 = s1 * (1.0 - rand.y) + s2 * (1.0 - rand.z);\n    \n    return rand.y + rand.z > 1.0 ? p2 : p1;\n}\n\n// Random point in star\n// Same as the random point in polygon,\n// but without folding the rhombus into a triangle\nvec2 randomPointInStar(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    \n    return s1 * rand.y + s2 * rand.z;\n}\n\nvec2 randomPointInSquare()\n{\n    vec2 rand = hash2(state);\n    \n    return rand * 2.0 - 1.0;\n}\n\nvec2 randomPointInRectangle(vec2 a, vec2 b)\n{\n    vec2 rand = hash2(state);\n    \n    vec2 sq = rand * 2.0 - 1.0;\n    return a * sq.x + b * sq.y;\n}\n\nconst mat2 ROT_45 = mat2(sqrt(2.0)/2.0, sqrt(2.0)/2.0, -sqrt(2.0) / 2.0, sqrt(2.0)/2.0);\n\nvec2 randomPointTest()\n{\n    vec3 r = hash3(state);\n    vec3 r2 = hash3(state);\n    \n    vec2 a = vec2(0, 2);\n    vec2 b = vec2(0.5, 0);\n    vec2 rc = randomPointInRectangle(a, b);\n    vec2 c = randomPointInCircle() + a;\n    c.y = r.x < 0.5 ? -c.y : c.y;\n    \n    vec2 rc2 = randomPointInRectangle(a, b).yx;\n    vec2 c2 = vec2(c.y, c.x);\n    \n    float a1 = (2.0 * a.y) * (2.0 * b.x);\n    float a2 = PI;\n    \n    vec2 v = length(rc - a) < 1.0 || length(rc + a) < 1.0 || r.y < a2 / (a2 + a1) ? c : rc;\n    vec2 v2 = length(rc2 - a.yx) < 1.0 || length(rc2 + a.yx) < 1.0 || r2.y < a2 / (a2 + a1) ? c2 : rc2;\n    \n    vec2 sq = abs(v) - b.x;\n    v = max(sq.x, sq.y) < 0.0 || r.z < 0.5 ? v2 : v;\n    \n    return ROT_45 * v / a.y;\n}\n\nvec2 randomPointInE()\n{\n    vec2 rc1 = randomPointInRectangle(vec2(0, 1), vec2(0.2, 0));\n    vec2 rc2 = randomPointInRectangle(vec2(0, 0.2), vec2(0.5, 0)) + vec2(0.5 + 0.2, 0);\n    \n    rc2.y += (floor(hash(state) * 3.0) - 1.0) * (1.0 - 0.2);\n    \n    float a1 = 2.0 * 0.4;\n    float a2 = 3.0 * (0.4 * 1.0);\n    \n    vec2 v = hash(state) < a1 / (a1 + a2) ? rc1 : rc2;\n    v.x += 0.2 - (1.4 * 0.5);\n    \n    return v;\n}\n\nvec2 randomPointInCresent(float o)\n{\n    vec2 pa, pb, v;\n    \n    vec2 a = vec2(0, 0);\n    vec2 b = vec2(o, 0);\n    float r = 1.0;\n    \n    #define COUNT 50\n    for (int i = 0; i < COUNT; i++)\n    {\n        v = randomPointInCircle();\n    \n        pa = v - a;\n        pb = pa - b;\n        \n        if (dot(pb, pb) >= r)\n            break;\n    }\n    \n    return v + (a + b) * 0.5;\n}\n\nvec2 randomPointInCrescentApprox(float o)\n{\n    float r1 = 1.0;\n    float r2 = 1.0;\n    \n    float xi = (r1*r1 - r2*r2 + o*o) / (2.0 * o);\n    float yi = sqrt(r1*r1 - xi*xi);\n    \n    float a0 = atan(yi, xi);\n    float a1 = -a0;\n    float at = a1 - a0;\n    \n    float b0 = PI - a0;\n    float b1 = -b0;\n    float bt = b1 - b0;\n    \n    vec2 rand = hash2(state);\n    \n    // Inverse CDF of sine distribution\n    float t = acos(1.0 - 2.0 * rand.x) * INV_PI;\n    \n    vec2 p0 = vec2(cos(a0 + t * at), sin(a0 + t * at));\n    vec2 p1 = vec2(cos(b0 + t * bt)+o, sin(b0 + t * bt));\n    \n    vec2 pi = p0 - (p0.y / (p1.y - p0.y)) * (p1 - p0);\n\n    float ar1 = length(p0 + pi);\n    float ar2 = length(p1 + pi);\n    \n    // TODO: Find a better sampling distribution for line segment\n    //float t2 = (sqrt(ar1*ar1 * (1.0 - rand.y) + ar2*ar2 * rand.y) - min(ar1, ar2)) / abs(ar2 - ar1);\n    float t2 = rand.y;\n    \n    vec2 v = mix(p0, p1, t2);\n\n    return v + vec2(o, 0) * 0.5;\n}\n\nvec2 randomPointInAnnulus(float r1, float r2)\n{\n    vec2 rand = hash2(state);\n    \n    float theta = rand.x * TAU;\n    float v = rand.y;\n    float r = sqrt((1.0 - v) * r1*r1 + v * r2*r2);\n    \n    return vec2(cos(theta) * r, sin(theta) * r);\n    \n}\n\n// Random point in heart\n// It is generated by combining a square rotated 45 degrees\n// and a circle with one half reflected on the x axis\nvec2 randomPointInHeart()\n{\n    vec3 rand = hash3(state);\n    \n    const vec2 a = vec2(sqrt(2.0) / 2.0);\n    const vec2 b = vec2(-a.y, a.x);\n    \n    vec2 sq = rand.xy * 2.0 - 1.0;\n    sq = a * sq.x + b * sq.y;\n    \n    float an = rand.x * TAU;\n    float r = sqrt(rand.y);\n    vec2 c = vec2(cos(an), sin(an)) * r;\n    \n    if (dot(c, b) < 0.0)\n    {\n        c = -c;\n        c = c - a;\n        c.x = -c.x;\n    } else {\n        c = c - a;\n    }\n    \n    c.y += a.x * 2.0;\n    float a1 = 4.0;\n    float a2 = PI;\n    \n    vec2 v = rand.z < a1 / (a1 + a2) ? sq : c;\n    v.y += sqrt(2.0) - (sqrt(2.0) + (1.0 + a.y)) * 0.5;\n    \n    return v / sqrt(2.0);\n}\n\n// Random unit vector\n// Generate a random unit circle and scaled the z with a circular mapping\nvec3 randomUnitVector()\n{\n    vec2 rand = hash2(state);\n    rand.y = rand.y*2.-1.;\n    rand.x *= PI*2.;\n    \n    float r = sqrt(1. - rand.y*rand.y);\n    vec2 xy = vec2(cos(rand.x), sin(rand.x)) * r;\n    \n    return vec3(xy, rand.y);\n}\n\nvec3 randomHemisphere(vec3 n)\n{\n    vec3 r = randomUnitVector();\n    return dot(r, n) < 0.0 ? -r : r;\n}\n\n// Random cosine-weighted unit vector on a hemisphere\n// Unit vector + random unit vector\nvec3 randomCosineHemisphere(vec3 n)\n{\n    return normalize(randomUnitVector() + n);\n}\n\n// Orthonormal Basis\n// https://www.shadertoy.com/view/tlVczh\n// MBR method 2a variant\nmat3 getBasis(in vec3 n)\n{\n    float sz = n.z >= 0.0 ? 1.0 : -1.0;\n    float a  =  n.y/(1.0+abs(n.z));\n    float b  =  n.y*a;\n    float c  = -n.x*a;\n\n    vec3 xp = vec3(n.z+sz*b, sz*c, -n.x);\n    vec3 yp = vec3(c, 1.0-b, -sz*n.y);\n    \n    return mat3(xp, yp, n);\n}\n\nvoid getBasis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n    float sz = n.z >= 0.0 ? 1.0 : -1.0;\n    float a  =  n.y/(1.0+abs(n.z));\n    float b  =  n.y*a;\n    float c  = -n.x*a;\n\n    xp = vec3(n.z+sz*b, sz*c, -n.x);\n    yp = vec3(c, 1.0-b, -sz*n.y);\n}\n\n// PBR Stuff\n\n\nfloat F_Schlick(float u, float f0, float f90) {\n    return f0 + (f90 - f0) * pow5(1.0 - u);\n}\n\nfloat F_Schlick(float u, float f0) {\n    float f = pow5(1.0 - u);\n    return f + f0 * (1.0 - f);\n}\n\nvec3 F_Schlick(float u, vec3 f0) {\n    float f = pow5(1.0 - u);\n    return f + f0 * (1.0 - f);\n}\n\nfloat FresnelDielectric(float cosT, float eta)\n{\n    float scale = cosT > 0.0 ? 1.0 / eta : eta;\n    float cosTSq = 1.0 - (1.0 - cosT*cosT) * (scale*scale);\n    \n    if (cosTSq <= 0.0)\n    {\n        return 1.0;\n    }\n    \n    float cosTI = abs(cosT);\n    float cosTT = sqrt(cosTSq);\n\n    float Rs = (cosTI - eta * cosTT) / (cosTI + eta * cosTT);\n    float Rp = (eta * cosTI - cosTT) / (eta * cosTI + cosTT);\n    \n    return 0.5 * (Rs + Rp);\n}\n\nfloat pdfDiffuse()\n{\n    return INV_PI;\n}\n\nfloat Fd_Lambertian()\n{\n    return INV_PI;\n}\n\nfloat Fd_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(NoL, 1.0, f90);\n    float viewScatter = F_Schlick(NoV, 1.0, f90);\n    return lightScatter * viewScatter * INV_PI;\n}\n\nvec3 sampleDiffuse(vec3 normal)\n{\n    return randomCosineHemisphere(normal);\n}\n\n// \nfloat D_GGX(float NdotH, float roughness)\n{\n    float a = NdotH * roughness;\n    float k = roughness / (1.0 - NdotH * NdotH + a * a);\n    return k * k * INV_PI;\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 * NoL * NoV / (GGXV + GGXL);\n}\n\nfloat V_SmithGGXMasking(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    \n    float denom = sqrt(NoV * NoV * (1.0 - a2) + a2) + NoV;\n    \n    return 0.5 * NoV / denom;\n}\n\nfloat FresnelAvg(float ior)\n{\n    if (ior > 1.0)\n        return (ior - 1.0) / (4.08567 + 1.00071 * ior);\n    return 0.997118 + ior * (0.1014 + ior * (-0.965241 - 0.130607 * ior));\n}\n\nvec3 FresnelAvg(vec3 ior)\n{\n    return vec3(FresnelAvg(ior.x), FresnelAvg(ior.y), FresnelAvg(ior.z));\n}\n\n// https://patapom.com/blog/BRDF/MSBRDFEnergyCompensation/\nvec3 FresnelAvg2(vec3 f0)\n{\n    return f0 * (0.04 + f0 * (0.66 + 0.3 * f0));\n}\n\n// 1 - E\nfloat EnergyLoss(float cosT, float roughness)\n{\n    float u = cosT;\n    float r = roughness;\n    float S = -0.170718 * sqrt(u) + r * (4.07985 + r * (-11.5295 + r * (18.4961 - r * 9.23618)));\n    float t = 0.0632331 * u + r * (3.1434 + r * (-7.47567 + r * (13.0482 - r * 7.0401)));\n    return pow6(S) * pow(u, 3.0 / 4.0) / (pow6(t) + u * u);\n}\n\n// 1 - E\nfloat EnergyLossAvg(float roughness)\n{\n    float r = roughness;\n    return 0.592665 * r * r * r / (1.0 + r * (-1.47034 + r * 1.47196));\n}\n\nvec3 sampleSpecular(vec3 wo, float roughness, out vec3 wm)\n{\n#if GGX_IMPORTANCE_SAMPLING == 1\n    vec2 r = hash2(state);\n    float a2 = roughness * roughness;\n    \n    float cosTheta = sqrt((1.0 - r.x) / ((a2 - 1.0) * r.x + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = TAU * r.y;\n    \n    wm = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    \n    return -reflect(wo, wm);\n\n// VNDF Importance Sampling\n// https://hal.archives-ouvertes.fr/hal-01509746/document\n#elif GGX_IMPORTANCE_SAMPLING == 2\n    vec2 rand = hash2(state);\n    float U1 = rand.x;\n    float U2 = rand.y;\n    \n    float alpha_x = roughness;\n    float alpha_y = roughness;\n    vec3 V = normalize(vec3(alpha_x * wo.x, alpha_y * wo.y, wo.z));\n    // orthonormal basis\n    //vec3 T1, T2;\n    //getBasis(V, T1, T2);\n\n    vec3 T1 = (V.z < 0.9999) ? normalize(cross(V, vec3(0,0,1))) : vec3(1,0,0);\n    vec3 T2 = cross(T1, V);\n\n    // sample point with polar coordinates (r, phi)\n    float a = 1.0 / (1.0 + V.z);\n    float r = sqrt(U1);\n    float phi = (U2<a) ? U2/a * PI : PI + (U2-a)/(1.0-a) * PI;\n    float P1 = r*cos(phi);\n    float P2 = r*sin(phi)*((U2<a) ? 1.0 : V.z);\n    // compute normal\n    vec3 N = P1*T1 + P2*T2 + sqrt(max(0.0, 1.0 - P1*P1 - P2*P2))*V;\n    // unstretch\n    wm = normalize(vec3(alpha_x*N.x, alpha_y*N.y, max(0.0, N.z)));\n    \n    return -reflect(wo, wm);\n#else\n    return sampleHemisphere(vec3(0, 0, 1));\n#endif\n}\n\nfloat alpha_i(vec3 wi, float alpha)\n{\n    float m_alpha_x = alpha;\n    float m_alpha_y = alpha;\n    float invSinTheta2 = 1.0f / (1.0f - wi.z*wi.z);\n    float cosPhi2 = wi.x*wi.x*invSinTheta2;\n    float sinPhi2 = wi.y*wi.y*invSinTheta2;\n    float alpha_i = sqrt( cosPhi2*m_alpha_x*m_alpha_x + sinPhi2*m_alpha_y*m_alpha_y );\n    return alpha_i;\n\n}\n\nfloat SmithLambda(vec3 wi, float alpha)\n{\n    if (wi.z > 0.9999)\n        return 0.0;\n    if (wi.z < -0.9999)\n        return 1.0;\n    \n    #if 0\n    // a\n    float theta_i = acos(wi.z);\n    float a = 1.0f/tan(theta_i)/alpha_i(wi, alpha);\n    // value\n    return 0.5f*(-1.0 + sign(a) * sqrt(1.0 + 1.0/(a*a)));\n    \n    #else\n    \n    float inv_wz2 = 1.0 / max(wi.z * wi.z, EPSILON);\n    vec2 wa = vec2(wi.x, wi.y) * alpha;\n    float v = sqrt(1.0 + dot(wa, wa) * inv_wz2);\n    \n    if (wi.z <= 0.0)\n        v = -v;\n\n    return 0.5 * (v - 1.0);\n    #endif\n}\n\nfloat C1(float h)\n{\n    return saturate(0.5 * (h + 1.0));\n}\n\nfloat invC1(float h)\n{\n    return 2.0 * saturate(h) - 1.0;\n}\n\nfloat G1(vec3 w, float C1, float lambda)\n{\n    if (w.z > 0.9999)\n        return 1.0f;\n    if (w.z < EPSILON)\n        return 0.0f;\n    return pow(C1, lambda);\n}\n\nbool sampleHeight(vec3 wr, float U, float lambda, inout float h)\n{\n    if (wr.z > 0.9999)\n        return false;\n        \n    if (wr.z < -0.9999)\n    {\n        h = invC1(U * C1(h));\n        return true;\n    }\n    \n    if(abs(wr.z) < 0.0001)\n        return true;\n    \n    float G1_ = G1(wr, h, lambda);\n    \n    if (U > 1.0 - G1_)\n        return false;\n        \n    h = invC1(C1(h) / pow(1.0 - U, 1.0 / lambda));\n    return true;\n}\n\nfloat projectedArea(vec3 wi, float alpha)\n{\n    if(wi.z > 0.9999f)\n        return 1.0f;\n    if( wi.z < -0.9999f)\n        return 0.0f;\n    // a\n     float theta_i = acos(wi.z);\n     float sin_theta_i = sin(theta_i);\n     float alphai = alpha_i(wi, alpha);\n    // value\n     float value = 0.5f * (wi.z + sqrt(wi.z*wi.z + sin_theta_i*sin_theta_i*alphai*alphai));\n    return value;\n}\n\nfloat P22(float slope_x, float slope_y, float alpha)\n{\n    float m_alpha_x = alpha;\n    float m_alpha_y = alpha;\n    float tmp = 1.0f + slope_x*slope_x/(m_alpha_x*m_alpha_x) + slope_y*slope_y/(m_alpha_y*m_alpha_y);\n    float value = 1.0f / (PI * m_alpha_x * m_alpha_y) / (tmp * tmp);\n    return value;\n\n}\n\nfloat D(vec3 wm, float alpha)\n{\n    if( wm.z <= 0.0f)\n    return 0.0f;\n    // slope of wm\n    float slope_x = -wm.x/wm.z;\n    float slope_y = -wm.y/wm.z;\n    // value\n    float value = P22(slope_x, slope_y, alpha) / (wm.z*wm.z*wm.z*wm.z);\n    return value;\n}\n\nfloat D_wi(vec3 wi, vec3 wm, float alpha)\n{\n    if( wm.z <= 0.0f)\n    return 0.0f;\n    // normalization coefficient\n    float projectedarea = projectedArea(wi, alpha);\n    if(projectedarea == 0.0)\n    return 0.0;\n    float c = 1.0f / projectedarea;\n    // value\n    float value = c * max(0.0f, dot(wi, wm)) * D(wm, alpha);\n    return value;\n\n}\n\nfloat Fresnel(vec3 wi, vec3 wm, float eta)\n{\n    float cos_theta_i = dot(wi, wm);\n    float cos_theta_t2 = 1.0f - (1.0f-cos_theta_i*cos_theta_i) / (eta*eta);\n    // total internal reflection\n    if (cos_theta_t2 <= 0.0f) return 1.0f;\n    float cos_theta_t = sqrt(cos_theta_t2);\n    float Rs = (cos_theta_i - eta * cos_theta_t) / (cos_theta_i + eta * cos_theta_t);\n    float Rp = (eta * cos_theta_i - cos_theta_t) / (eta * cos_theta_i + cos_theta_t);\n    float F = 0.5f * (Rs * Rs + Rp * Rp);\n    return F;\n}\n\nfloat evalPhase(vec3 wi, vec3 wo, float lambda, float alpha, float eta)\n{\n#if 0\n    if (wi.z > 0.9999)\n        return 0.0;\n    \n    vec3 wh = normalize(wo - wi);\n    \n    if (wh.z < 0.0)\n        return 0.0;\n    \n    float pArea = (wi.z < -0.9999) ? 1.0 : lambda * wi.z;\n  \n    float dotW_WH = dot(-wi, wh);\n    \n    if (dotW_WH < 0.0)\n        return 0.0;\n        \n    return 0.25 * max(0.0f, dotW_WH) * D_GGX(wh.z, alpha) / max(pArea * dotW_WH, EPSILON);\n#else\n    \n    if (wi.z > 0.9999)\n        return 0.0;\n    \n    vec3 wh = normalize(wo + wi);\n\n    float res = float(wh.z > 0.0) * 0.25f * D_wi(wi, wh, alpha) / dot(wi, wh) * Fresnel(wi, wh, eta);\n    \n    eta = 1.0 / eta;\n    wh = -normalize(wi + wo * eta);\n    wh *= sign(wh.z);\n    if(dot(wh, wi) > 0.0)\n    {\n        res += eta*eta * (1.0-Fresnel(wi, wh, eta)) * D_wi(wi, wh, alpha) * max(0.0f, -dot(wo, wh)) *\n                1.0f / pow(dot(wi, wh)+eta*dot(wo,wh), 2.0f);\n    }\n    \n    return res;\n#endif\n}\n\nvec2 sampleP22_11(float cosI, float randx, float randy)\n{\n    if (cosI > 0.9999f || abs(cosI) < 1e-6f) {\n        float r = sqrt(randx / max(1.0f - randx, 1e-7f));\n        float phi = TAU * randy;\n        return vec2(r * cos(phi), r * sin(phi));\n    }\n\n    float sinI = sqrt(1.0f - cosI * cosI);\n    float tanI = sinI / cosI;\n    float projA = 0.5f * (cosI + 1.0f);\n    if (projA < 0.0001f)\n        return vec2(0.0f, 0.0f);\n    float A = 2.0f * randx * projA / cosI - 1.0f;\n    float tmp = A * A - 1.0f;\n    if (abs(tmp) < 1e-7f)\n        return vec2(0.0f, 0.0f);\n    tmp = 1.0f / tmp;\n    float D = sqrt(tanI * tanI * tmp * tmp - (A * A - tanI * tanI) * tmp);\n\n    float slopeX2 = tanI * tmp + D;\n    float slopeX = (A < 0.0f || slopeX2 > 1.0f / tanI) ? (tanI * tmp - D) : slopeX2;\n\n    float U2;\n    if (randy >= 0.5f)\n        U2 = 2.0f * (randy - 0.5f);\n    else\n        U2 = 2.0f * (0.5f - randy);\n    float z = (U2 * (U2 * (U2 * 0.27385f - 0.73369f) + 0.46341f)) /\n                  (U2 * (U2 * (U2 * 0.093073f + 0.309420f) - 1.0f) + 0.597999f);\n    float slopeY = z * sqrt(1.0f + slopeX * slopeX);\n\n    if (randy >= 0.5f)\n        return vec2(slopeX, slopeY);\n    \n    return vec2(slopeX, -slopeY);\n}\n\nvec3 samplePhase(vec3 wi, float alpha)\n{\n    vec2 rand = hash2(state);\n    vec3 wi_11 = normalize(vec3(alpha * wi.x, alpha * wi.y, wi.z));\n    vec2 slope_11 = sampleP22_11(wi_11.z, rand.x, rand.y);\n\n    vec3 cossin_phi = normalize(vec3(wi_11.x, wi_11.y, 0));\n    float slope_x = alpha * (cossin_phi.x * slope_11.x - cossin_phi.y * slope_11.y);\n    float slope_y = alpha * (cossin_phi.y * slope_11.x + cossin_phi.x * slope_11.y);\n\n    vec3 wm = normalize(vec3(-slope_x, -slope_y, 1));\n    \n    return -reflect(wi, wm);\n}\n\nvec3 MultiscatteringEval(vec3 wi, vec3 wo, float alpha)\n{\n    if (wo.z < 0.0)\n        return vec3(0);\n        \n    bool swapped = false;\n    if (wo.z < wi.z) {\n        vec3 tmp = wo;\n        //wo = wi;\n        //wi = tmp;\n        swapped = true;\n    }\n  \n    float eta = 1.45;\n    \n    vec3 wr = -wi;\n    \n    float lambda = SmithLambda(wr, alpha);\n    float shadowingLambda = SmithLambda(wo, alpha);\n    \n    //const float G2 = 1.0f / (1.0f - (lambda_r + 1.0f) + shadowing_lambda);\n    //float val = G2 * D_GGX(wh, alpha) * 0.25f / wi.z;\n    \n    float h = 1.0 + invC1(0.999);\n    vec3 throughput = vec3(1);\n    vec3 res = vec3(0);\n    \n    int order = 0;\n    \n    for (int i = 0; i < 10; i++)\n    {\n        if (!sampleHeight(wr, hash(state), lambda, h))\n            break;\n        \n        vec3 phase = evalPhase(wr, wo, lambda, alpha, eta) * throughput;\n        float shadowing = G1(wo, h, lambda);\n        \n        if (i == 0 || i+1 == 10)\n            res += throughput * phase * G1(wo, C1(h), shadowingLambda);\n        \n        wr = samplePhase(-wr, alpha);\n        //vec3 wm;\n        //wr = sampleSpecular(-wr, alpha, wm);\n        \n        lambda = SmithLambda(wr, alpha);\n    }\n    \n    //if (swapped)\n    //    res *= abs(wi.z / wo.z);\n        \n    return res;\n}\n\nvec3 MultiscatteringSample(vec3 wi, vec3 wo, float alpha)\n{\n    vec3 wr = -wi;\n    float h = 1.0 + invC1(0.999);\n    \n    float lambda = SmithLambda(wr, alpha);\n    vec3 throughput = vec3(1);\n    int order = 0;\n    \n    for (int i = 0; i < 10; i++)\n    {\n        if (!sampleHeight(wr, hash(state), lambda, h))\n            break;\n        \n        wr = samplePhase(-wr, alpha);\n        //vec3 wm;\n        //wr = sampleSpecular(-wr, alpha, wm);\n    \n        lambda = SmithLambda(wr, alpha);\n    }\n    \n    return wr;\n}\n\nfloat MultiscatteringGGXAlbedo(float r)\n{\n    float albedo = 0.806495f * exp(-1.98712f * r * r) + 0.199531f;\n    albedo -= ((((((1.76741f * r - 8.43891f) * r + 15.784f) * r - 14.398f) * r + 6.45221f) * r -\n              1.19722f) *\n                 r +\n             0.027803f) *\n                r +\n            0.00568739f;\n  return saturate(albedo);\n}\n\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "\nvec4 data = vec4(0);\n\nvec3 sampleTriplanarTexture(sampler2D channel, vec3 normal, vec3 position, float sharpness)\n{\n    vec3 n = pow(abs(normal), vec3(sharpness));\n    n /= n.x + n.y + n.z;\n    \n    vec3 tx = sRGBToLinear(texture(channel, position.zy).rgb);\n    vec3 ty = sRGBToLinear(texture(channel, position.xz).rgb);\n    vec3 tz = sRGBToLinear(texture(channel, position.yx).rgb);\n    \n    return tx * n.x + ty * n.y + tz * n.z;\n}\n\nvec3 sampleEquirectangularTexture(sampler2D channel, vec3 normal, vec2 scale, vec2 offset)\n{\n    float theta = atan(normal.z, normal.x) / TAU + 0.5;\n    float phi = acos(normal.y) / PI;\n    \n    return sRGBToLinear(texture(channel, (vec2(theta, phi) + offset) * scale).rgb);\n}\n\nvec3 sampleEquirectangularTexture(sampler2D channel, vec3 normal)\n{\n    return sampleEquirectangularTexture(channel, normal, vec2(1), vec2(0));\n}\n\nvec3 getSkybox(vec3 direction)\n{\n#ifdef WHITE_FURNACE_TEST\n    return vec3(1);\n#else\n    vec3 sky = sRGBToLinear(texture(iChannel1, direction).rgb);\n    vec3 stars = sampleEquirectangularTexture(iChannel2, direction, 5.0*vec2(1, 0.5), vec2(0.23, 0.285));\n#ifdef ENABLE_SKY_STARS\n    sky += 40.0*pow(stars, vec3(5.0));\n#endif\n    return SKYBOX_STRENGTH * sky;\n#endif\n}\n\nvec3 getColor(int i)\n{\n    vec3 color = vec3(1);\n    if (i == 0)\n        color = vec3(1.00, 0.85, 0.57); // Gold\n    else if (i == 1)\n        color = vec3(0.98, 0.90, 0.59); // Brass\n    else if (i == 2)\n        color = vec3(0.97, 0.74, 0.62); // Copper\n    else if (i == 3)\n        color = vec3(0.77, 0.78, 0.78); // Iron\n    else if (i == 4)\n        color = vec3(0.97, 0.96, 0.91); // Silver\n        \n    return sRGBToLinear(color);\n}\n\nvoid sceneIntersect(Ray ray, out HitInfo hit, out Material mat)\n{   \n    hit = NewHitInfo();\n    mat = DefaultMaterial();\n    \n#if SCENE == 0\n    #define NUM_SPHERES 5\n    for (int x = 0; x < NUM_SPHERES; x++)\n    for (int y = 0; y < NUM_SPHERES; y++)\n    {\n        float radius = 0.4;\n        float spacing = 0.05;\n        float xp = (float(x) - float(NUM_SPHERES - 1) / 2.0) * (2.0 * radius + spacing);\n        float yp = (float(y) - float(NUM_SPHERES - 1) / 2.0) * (2.0 * radius + spacing);\n        float roughness = float(x) / float(NUM_SPHERES - 1) * 0.8 + 0.2;//float(i) * 0.2;\n        float metallic = float(y) / float(NUM_SPHERES - 1) * 0.5 + 0.5;\n        \n        metallic = saturate(metallic);\n        roughness = saturate(roughness);\n        roughness *= roughness;\n        \n        if (sphereIntersect(ray, vec3(-xp, 0, -yp), radius, hit))\n        {\n            vec3 p = ray.origin + ray.direction * hit.t;\n            \n            float scale = 0.6;\n            float e = 2.0 / iChannelResolution[2].x;\n            vec3 tex = sampleEquirectangularTexture(iChannel2, hit.normal, scale * vec2(1.0, 0.5), vec2(xp, yp));\n            vec3 texDx = sampleEquirectangularTexture(iChannel2, hit.normal, scale * vec2(1.0, 0.5), vec2(xp + e, yp));\n            vec3 texDy = sampleEquirectangularTexture(iChannel2, hit.normal, scale * vec2(1.0, 0.5), vec2(xp, yp + e * 0.5));\n            \n            vec3 N = hit.normal;\n            vec3 A = abs(N.z) > 0.9999 ? vec3(0, 1, 0) : vec3(0, 0, 1);\n            vec3 T = normalize(cross(N, A));\n            vec3 B = cross(T, N);\n            \n            float h = luminance(tex);\n            float hx = luminance(texDx);\n            float hy = luminance(texDy);\n            vec3 tn = normalize(vec3(h - hx, (h - hy) * 2.0, e));\n            //vec3 tex = sampleTriplanarTexture(iChannel2, hit.normal, p * 0.3, 5.0);\n            float m = smoothstep(0.03, 0.1, luminance(tex));\n            \n            tn = normalize(mix(vec3(0, 0, 1), tn, 1.0 - m));\n            \n            hit.bumpNormal = normalize(T * tn.x + B * tn.y + N * tn.z);\n            \n            metallic = min(metallic, m);\n            roughness = max(roughness, 1.0 - m);\n            \n            uint r = uint(x+y*NUM_SPHERES)+23u;\n            uint r2 = r+123u;\n            \n            #if COLOR == 0\n            vec3 color = mix(palette(hash(r)), 1.0-palette(hash(r2)), pow(mix(abs(dot(hit.normal, ray.direction)), 1.0, roughness), 1.5));\n            #elif COLOR == 1\n            vec3 color = getColor(y);\n            #else\n            vec3 color = vec3(1);\n            #endif\n            \n            color = mix(saturate(tex * 5.0), color, m);\n            \n            mat = Material(color, vec3(0), roughness, metallic, 0.0, 1.0, 1.0);\n            \n            #ifdef WHITE_FURNACE_TEST\n            mat.color = vec3(1);\n            #endif\n        }\n    }\n#else\n    if (sphereIntersect(ray, vec3(0, 0, 0), 1.0, hit))\n    {\n        mat = DefaultMaterial();\n        //mat.color = vec3(1, 0.5, 0.5);\n        //mat.color = mix(vec3(1, 0.5, 0.5), vec3(0.3, 0.6, 1.0), pow(abs(dot(hit.normal, ray.direction)), 1.5));\n        mat.transmission = 0.0;\n        mat.roughness = 1.0;\n        mat.metallic = 0.0;\n        mat.ior = 1.33;\n        mat.clearcoat = 0.0;\n    }\n\n#endif\n    if (noHit(hit))\n    {\n        mat.emissive = getSkybox(ray.direction);\n    }\n}\n\nfloat pdfSpecular(float NdotV, float NdotL, float NdotWM, float WOdotWM, float roughness, vec3 wi)\n{\n#if GGX_MULTISCATTERING != 2\n\n#if GGX_IMPORTANCE_SAMPLING == 1\n    return NdotV * D_GGX(NdotWM, roughness) * NdotWM / (4.0 * WOdotWM);\n#elif GGX_IMPORTANCE_SAMPLING == 2\n    return V_SmithGGXMasking(NdotV, NdotL, roughness) * D_GGX(NdotWM, roughness);\n#else\n    return NdotV * INV_PI * 0.5;\n#endif\n\n#else\n    float D = D_GGX(NdotWM, roughness);\n    float lambda = SmithLambda(wi, roughness);\n    //float singlescatter = V_SmithGGXMasking(NdotV, NdotL, roughness) * D_GGX(NdotWM, roughness);\n    float singlescatter = 0.25 * D / max((1.0 + lambda), EPSILON);\n    \n    float multiscatter = NdotV * INV_PI;\n\n    float albedo = MultiscatteringGGXAlbedo(roughness);\n    \n    return (albedo * singlescatter + (1.0f - albedo) * multiscatter);\n#endif\n}\n\nvec3 Fr_GGX(float NdotV, float NdotL, float NdotH, float LdotH, float VdotH, vec3 f0, float roughness, vec3 wi, vec3 wo)\n{\n    float D = D_GGX(NdotH, roughness);\n    vec3  F = F_Schlick(LdotH, f0);\n    float V = V_SmithGGXCorrelated(NdotV, NdotL, roughness);\n\n#if GGX_MULTISCATTERING == 1\n    if (roughness <= MIN_ROUGHNESS)\n        return F * (D * V);\n\n    // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf\n    float Eavg = EnergyLossAvg(roughness);\n    float Ems = EnergyLoss(NdotV, roughness) * EnergyLoss(NdotL, roughness) * INV_PI / Eavg;\n    \n    #if 0\n    vec3 sqrtF0 = sqrt(f0);\n    vec3 fIor = (1.0 + sqrtF0) / (1.0 - sqrtF0);\n    vec3 Favg = FresnelAvg(1.0 / fIor);\n    vec3 Fms = (Favg * Favg * (1.0 - Eavg)) / (1.0 - Favg * Eavg);\n    #else\n    vec3 Fms = FresnelAvg2(f0);\n    #endif\n    \n    return F * (D * V) + Ems * Fms * NdotV / 2.0;\n#elif GGX_MULTISCATTERING == 2\n    \n    return MultiscatteringEval(wi, wo, roughness);\n#else\n    return F * (D * V);\n#endif\n}\n\nvec3 Fr_GGX_Transmission(float NdotV, float NdotL, float NdotH, float LdotH, float VdotH, vec3 f0, float iorV, float iorL, float roughness)\n{\n    float D = D_GGX(NdotH, roughness);\n    //vec3  F = F_Schlick(LdotH, f0);\n    float F = FresnelDielectric(LdotH, iorV);\n    float V = V_SmithGGXCorrelated(NdotV, NdotL, roughness);\n    float denom = iorL * LdotH +  iorV * VdotH;\n    \n    return 4.0 * f0 * (1.0 - F) * (D * V) * LdotH * VdotH * iorV * iorV / (denom * denom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    \n    vec2 o = halton(vec2(13, 23) * float(iFrame));\n    vec2 pv = (2. * (fragCoord + o - 0.5) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    data.xy = uv;\n    \n    vec3 ro = vec3(0, 0, 5);\n    vec3 lo = vec3(0, 0, 0);\n    \n    vec4 m = texelFetch(iChannel0, ivec2(0, 0), 0);\n    if (iFrame < 2)\n        m = vec4(0.59, 0.46, 0, 0);\n    \n    #ifdef STATIC_CAM\n    //m.xy = vec2(0.5, 0.334);\n    //m.xy = vec2(0.67, 0.45);\n    //m.xy = vec2(0.59, 0.46);\n    //m.xy = vec2(0.88, 0.44);\n    //m.xy = vec2(0.415, 0.46);\n    //m.xy = vec2(0.56, 0.44);\n    m.xy = vec2(0.59, 0.46);\n    #endif\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(0.59, 0.46, 0, 0);\n        } else\n        {\n            vec2 mn = iMouse.xy / iResolution.xy;\n            fragColor = vec4(m);\n            if (iMouse.z > 0.0)\n            {\n                if (fragColor.zw != vec2(0))\n                    fragColor.xy += (mn - m.zw);\n                fragColor.zw = mn;\n            } else\n            {\n                fragColor.zw = vec2(0);\n            }\n        }\n        return;\n    }\n    \n    float ax = -m.x * TAU + PI;\n    float ay = -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro.xz *= rot2D(PI);\n    ro += lo;\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    float fovScale = 4.0;\n    \n    float dofStrength = DOF_STRENGTH;\n    float dofDist = DOF_FOCUS_DISTANCE;\n    \n    #ifdef DOF_AUTOFOCUS\n    Ray dofRay = Ray(ro, cmat[2]);\n    HitInfo dofHit;\n    Material dofMat;\n    \n    sceneIntersect(dofRay, dofHit, dofMat);\n    \n    dofDist = dofHit.t / fovScale;\n    #endif\n    \n    #if DOF_TYPE == 0\n    vec2 rc = randomPointInCircle();\n    #elif DOF_TYPE == 1\n    vec2 rc = randomPointInSquare();\n    #elif DOF_TYPE == 2\n    vec2 rc = randomPointInPolygon(float(DOF_SIDES));\n    #elif DOF_TYPE == 3\n    vec2 rc = randomPointInStar(float(DOF_SIDES));\n    #elif DOF_TYPE == 4\n    vec2 rc = randomPointInHeart();\n    #elif DOF_TYPE == 5\n    //vec2 rc = randomPointInCresent(-0.5);\n    vec2 rc = randomPointInCrescentApprox(-0.5);\n    #elif DOF_TYPE == 6\n    vec2 rc = randomPointTest();\n    #elif DOF_TYPE == 7\n    vec2 rc = randomPointInAnnulus(0.5, 1.0);\n    #else\n    vec2 rc = randomPointInE();\n    #endif\n    \n    rc *= dofStrength * dofDist;\n    \n    pv -= rc / dofDist;\n    ro += cmat * vec3(rc, 0);\n    \n    vec3 rd = normalize(cmat * vec3(pv, fovScale));\n    \n    vec3 color = vec3(0);\n    vec3 throughput = vec3(1);\n    \n    Ray ray = Ray(ro, rd);\n    HitInfo hit;\n    Material mat;\n    \n    Ray rayNext;\n    HitInfo hitNext;\n    Material matNext;\n\n    sceneIntersect(ray, hit, mat);\n    \n    color += mat.emissive;\n    \n    int i = 0;\n    for (; i < BOUNCES; i++)\n    {\n        if (noHit(hit))\n            break;\n            \n        // Default clearcoat roughness to 0\n        #define CLEARCOAT_ROUGHNESS 0.0\n        float clearcoatRoughness = max(CLEARCOAT_ROUGHNESS, MIN_ROUGHNESS);\n        clearcoatRoughness *= clearcoatRoughness;\n        float roughness = max(mat.roughness, MIN_ROUGHNESS);\n        roughness *= roughness;\n        \n        vec3 normal = hit.bumpNormal != vec3(0) ? hit.bumpNormal : hit.normal;\n        \n        float NdotV = max((dot(hit.normal, -ray.direction)), EPSILON);\n        float NBdotV = max((dot(normal, -ray.direction)), EPSILON);\n        \n        vec3 f0 = mix(vec3(0.04), mat.color, mat.metallic);\n        vec3 fresnel3 = F_Schlick(NBdotV, f0);\n        float fresnel = (fresnel3.x + fresnel3.y + fresnel3.z) / 3.0;\n        \n        float clearcoatFresnel = F_Schlick(NdotV, 0.04);\n        \n        float clearcoatRayPdf = clearcoatFresnel * mat.clearcoat;\n        \n        // This is wrong but idk yet, sorry devsh v_v\n        float specularRayPdf = mix(fresnel, 1.0, mat.metallic);\n        float diffuseRayPdf = (1.0 - mat.transmission) * (1.0 - specularRayPdf);\n        float transmissionRayPdf = mat.transmission * (1.0 - specularRayPdf);\n        \n        specularRayPdf *= (1.0 - clearcoatRayPdf);\n        diffuseRayPdf *= (1.0 - clearcoatRayPdf);\n        transmissionRayPdf *= (1.0 - clearcoatRayPdf);\n        \n        float totalRayPdf = clearcoatRayPdf + specularRayPdf + transmissionRayPdf + diffuseRayPdf;\n        \n        bool isClearcoatRay = hash(state) < clearcoatRayPdf / totalRayPdf;\n        bool isSpecularRay = !isClearcoatRay && hash(state) < specularRayPdf / totalRayPdf;\n        bool isTransmissionRay = !isClearcoatRay && !isSpecularRay && hash(state) < transmissionRayPdf / totalRayPdf;\n        \n        //isClearcoatRay = false; isSpecularRay = true; isTransmissionRay = false;\n        \n        if (isClearcoatRay)\n            normal = hit.normal;\n        \n        mat3 tbn = getBasis(normal);\n        \n        vec3 wo = inverse(tbn) * -ray.direction;\n        vec3 wi, wm;\n        \n        if (isClearcoatRay)\n        {\n            wi = sampleSpecular(wo, clearcoatRoughness, wm);\n            rayNext.direction = tbn * wi;\n        } else if (isSpecularRay)\n        {\n        #if GGX_MULTISCATTERING == 2\n            wi = MultiscatteringSample(-wi, wo, roughness);\n        #else\n            wi = sampleSpecular(wo, roughness, wm);\n        #endif\n            rayNext.direction = tbn * wi;\n        } else if (isTransmissionRay)\n        {\n            sampleSpecular(wo, roughness, wm);\n            wi = -refract(wo, -wm, hit.inside ? mat.ior : 1.0 / mat.ior);\n            if (dot(wi, wi) < EPSILON)\n                wi = -reflect(wo, wm);\n            rayNext.direction = tbn * wi;\n        } else {\n            rayNext.direction = sampleDiffuse(hit.normal);\n        }\n        \n        rayNext.origin = ray.origin + ray.direction * hit.t + rayNext.direction * 1e-3;\n        rayNext.origin += (isTransmissionRay ? -hit.normal : hit.normal) * 1e-3;\n        \n        sceneIntersect(rayNext, hitNext, matNext);\n        \n        vec3 halfVector = normalize(-ray.direction + rayNext.direction);\n        \n        float NdotL = max(dot(normal, rayNext.direction), EPSILON);\n        float NdotH = max(dot(normal, halfVector), EPSILON);\n        float LdotH = max(dot(rayNext.direction, halfVector), EPSILON);\n        float VdotH = max(dot(-ray.direction, halfVector), EPSILON);\n        float WOdotWM = max(dot(wo, wm), EPSILON);\n        float NdotWM = max(wm.z, EPSILON);\n        \n        vec3 diffuse, specular;\n        \n        vec3 reflectance = vec3(0);\n        \n        if (isClearcoatRay)\n        {\n            specular = Fr_GGX(NdotV, NdotL, NdotH, LdotH, VdotH, vec3(1), clearcoatRoughness, wi, wo);\n            \n            float specularPdf = pdfSpecular(NdotV, NdotL, NdotWM, WOdotWM, clearcoatRoughness, wi);\n            \n            reflectance = throughput * matNext.emissive * specular / specularPdf;\n            throughput *= specular / specularPdf;\n            \n        } else if (isSpecularRay)\n        {\n            specular = Fr_GGX(NdotV, NdotL, NdotH, LdotH, VdotH, mat.color, roughness, wi, wo);\n            \n            float specularPdf = pdfSpecular(NdotV, NdotL, NdotWM, WOdotWM, roughness, wi);\n            \n            reflectance = throughput * matNext.emissive * specular / specularPdf;\n            throughput *= specular / specularPdf;\n            \n        } else if (isTransmissionRay)\n        {\n            float eta = wi.z > 0.0 ? mat.ior : 1.0 / mat.ior;\n            halfVector = normalize(-ray.direction + rayNext.direction * eta);\n            NdotL = max(abs(dot(normal, -rayNext.direction)), EPSILON);\n            NdotH = max(abs(dot(normal, halfVector)), EPSILON);\n            LdotH = max(abs(dot(-rayNext.direction, halfVector)), EPSILON);\n            VdotH = max(abs(dot(-ray.direction, halfVector)), EPSILON);\n            \n            float iorV = hit.inside ? mat.ior : 1.0;\n            float iorL = !hit.inside ? mat.ior : 1.0;\n            \n            specular = Fr_GGX_Transmission(NdotV, NdotL, NdotH, LdotH, VdotH, mat.color, iorV, iorL, roughness);\n            \n            float specularPdf = pdfSpecular(NdotV, NdotL, NdotH, VdotH, roughness, wi);\n            \n            reflectance = throughput * matNext.emissive * specular / specularPdf;\n            throughput *= specular / specularPdf;\n            \n        } else {\n            vec3 diffuseColor = mat.color;\n            #if 0\n            diffuse = diffuseColor * Fd_Burley(NdotV, NdotL, LdotH, roughness);\n            #else\n            diffuse = diffuseColor * Fd_Lambertian();\n            #endif\n            \n            float diffusePdf = pdfDiffuse();\n            \n            reflectance = throughput * matNext.emissive * diffuse / diffusePdf;\n            throughput *= diffuse / diffusePdf;\n        }\n        \n        color += reflectance;\n        \n        if (luminance(throughput) < 1.0 / 256.0)\n            break;\n        \n        if (noHit(hitNext))\n            break;\n        \n        ray = rayNext;\n        hit = hitNext;\n        mat = matNext;\n    }\n    \n    vec3 outColor = color;\n\n#ifndef NO_ACCUMULATE\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float blend = iFrame == 0 ? 1.0 : 1.0 / (1.0 + (1.0 / prevColor.a));\n    \n    #ifndef STATIC_CAM\n    if (m.zw != vec2(0))\n        blend = 1.0;\n    #endif\n    \n    fragColor = vec4(mix(prevColor.rgb, outColor, blend), blend);\n#else\n    fragColor = vec4(outColor, 1);\n#endif\n}\n", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1614, 1614, 1671, 1671, 2083]], "test": "untested"}
{"id": "DsKSzw", "name": "Blobby Lights", "author": "Dem0g", "description": "Several small lights dancing around each other, forming bigger blobs when close enough.\n", "tags": ["simple", "metablobs", "blob", "bw"], "likes": 0, "viewed": 87, "published": 3, "date": "1681728954", "time_retrieved": "2024-07-30T18:00:19.025711", "image_code": "#define LINES 10.0\n#define BLOBS 10.0\n\nfloat rand(float x) {\n    return fract(sin(dot(vec2(x,x),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 cubic_hermite(vec2 p0, vec2 p1, vec2 v0, vec2 v1, float t) {\n    float sq = t*t;\n    float cu = t*t*t;\n    \n    float h1 = 2.*cu-3.*sq+1.;\n    float h2 = -2.*cu+3.*sq;\n    float h3 = cu - 2.*sq + t;\n    float h4 = cu - sq;\n    return h1*p0+h2*p1+h3*v0+h4*v1;\n}\n\nfloat blob(vec2 uv, float seed, float intensity){\n    float t = iTime*rand(seed)*0.7;\n    vec2 pos0 = vec2(0.5,0.5)+random2(vec2(seed,floor(t)));\n    vec2 pos1 = vec2(0.5,0.5)+random2(vec2(seed,floor(t+1.)));\n    vec2 vel0 = random2(vec2(floor(t),seed));\n    vec2 vel1 = random2(vec2(floor(t+1.),seed));\n    \n    vec2 pos = cubic_hermite(pos0,pos1,vel0,vel1,fract(t));\n    return max(0.0,pow(distance(uv,pos),intensity));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .25;\n    uv *= 2.;\n    // Time varying pixel color\n    float height_field = 1.; //pow(distance(uv, vec2(0.5,0.5)),5.);\n    vec3 height_col = vec3(1.0,1.0,1.0);\n    for(float i = 0.; i<BLOBS; i+=1.){\n        vec3 r_color = vec3(rand(i),rand(i+1.),rand(i+2.));\n        height_field *= blob(uv,i,0.9);\n        height_col = mix(\n            height_col,\n            r_color,\n            1.-pow(blob(uv,i,0.9),2.)); \n    }\n    \n    height_field*= 100.5;\n         \n    float line_field = 0.0;\n    line_field = pow(height_field,-0.3);\n\n    /*for(float f = 0.0; f<LINES; f+=1.0){\n       line_field += step(height_field,f-(LINES/2.)+(1./(sqrt(BLOBS)))*(2.)) \n                   - step(height_field,f-(LINES/2.)+1./(sqrt(BLOBS)));  \n    }*/\n    \n    vec3 col = vec3(line_field);\n    \n    //col = height_col;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 60, 60, 171], [173, 173, 195, 195, 334], [337, 422, 444, 444, 848], [850, 850, 915, 915, 1115], [1117, 1117, 1166, 1166, 1540], [1541, 1541, 1598, 1648, 2557]], "test": "untested"}
{"id": "DdVXWc", "name": "RT exp: local consistency", "author": "daniel_chin", "description": "based on https://www.shadertoy.com/view/4sfGDB by Zavie. Trying to make the pseudo random sampler maintain local continuity in order to denoise. ", "tags": ["raytracing"], "likes": 4, "viewed": 322, "published": 3, "date": "1681719984", "time_retrieved": "2024-07-30T18:00:19.851503", "image_code": "/*\nbased on \nhttps://www.shadertoy.com/view/4sfGDB\nby Zavie\n\nmodified by Daniel Chin\n*/\n\n#define ENABLE_LOCAL_CONTINUITY\n\n#define SAMPLES 4\n#define MAXDEPTH 4\n#define ENABLE_NEXT_EVENT_PREDICTION\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\nfloat seed = 0.;\nfloat rand() {\n\treturn fract(sin(seed++)*43758.5453123);\n}\n\n//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return (\n    49.0 * (\n      dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n      + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) \n    ) + 1.0\n  ) * .5;\n\n}\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 radiance(int sample_i, vec2 fragPos, Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfloat it = iTime * .03;\n\tvec2 fp = fragPos * .1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n    vec3 v3 = vec3(it, float(depth), float(sample_i));\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n\n\t\tif (obj.refl == DIFF) {\n#ifdef ENABLE_LOCAL_CONTINUITY\n\t\t\tfloat r2 = snoise(vec4(\n\t\t\t\tv3, 0\n\t\t\t));\n\t\t\tfloat sn5 = snoise(vec4(\n\t\t\t\tv3, 5.2348965984\n\t\t\t));\n#else\n\t\t\tfloat r2 = rand();\n\t\t\tfloat sn5 = rand();\n#endif\n\t\t\tvec3 d = jitter(nl, 2.*PI*sn5, sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n#ifdef ENABLE_NEXT_EVENT_PREDICTION\n\t\t\t//for (int i = 0; i < NUM_SPHERES; ++i)\n\t\t\t{\n\t\t\t\t// Sphere s = sphere(i);\n\t\t\t\t// if (dot(s.e, vec3(1.)) == 0.) continue;\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 8;\n\n#ifdef ENABLE_LOCAL_CONTINUITY\n\t\t\t\tfloat sn10 = snoise(vec4(\n\t\t\t\t\tv3, 10.72309867\n\t\t\t\t));\n\t\t\t\tfloat sn20 = snoise(vec4(\n\t\t\t\t\tv3, 20.389287\n\t\t\t\t));\n#else\n        float sn10 = rand();\n        float sn20 = rand();\n#endif\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., sn10);\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*sn20, sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tfloat E = 1.;//float(depth==0);\n\t\t\tacc += mask * obj.e * E + mask * obj.c * e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, d);\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} else {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n\t\t\tfloat nc=1., nt=1.5, nnt=mix(nc/nt, nt/nc, float(a>0.));\n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t\tif (cos2t>0.) {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re/P,TP=(1.-Re)/(1.-P);\n#ifdef ENABLE_LOCAL_CONTINUITY\n\t\t\t\tfloat sn30 = snoise(vec4(\n\t\t\t\t\tv3, 30.01894375\n\t\t\t\t));\n#else\n        float sn30 = rand();\n#endif\n\t\t\t\tif (sn30<P) { mask *= RP; }\n\t\t\t\telse { mask *= obj.c*TP; r = Ray(x, tdir); }\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n\tseed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\tvec3 color = vec3(0.);\n\tfor (int i = 0; i < SAMPLES + min(0, iFrame); ++i) {\n#ifdef DEBUG\n    vec3 test = radiance(i, fragCoord.xy / iResolution.xy, Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n    if (dot(test, test) > 0.) color += vec3(1.); else color += vec3(0.5,0.,0.1);\n#else\n    color += radiance(i, fragCoord.xy / iResolution.xy, Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n#endif\n  }\n  vec4 accum = texture(iChannel0, fragCoord.xy / iResolution.xy);\n  accum = vec4(0,0,0,0);\n  float samples = accum.a + float(SAMPLES);\n  fragColor = vec4((accum.rgb * accum.a + color)/samples, samples);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 402, 402, 446], [448, 502, 523, 523, 560], [561, 561, 584, 584, 628], [629, 629, 656, 656, 704], [705, 705, 734, 734, 782], [784, 784, 813, 813, 1074], [1076, 1076, 1097, 1097, 3404], [3608, 3608, 3628, 3628, 4371], [4373, 4373, 4407, 4407, 4636], [4638, 4638, 4698, 4698, 4907], [4909, 4909, 4965, 4965, 5093], [5095, 5095, 5145, 5145, 7520], [7522, 7522, 7579, 7579, 8712]], "test": "untested"}
{"id": "csKSWc", "name": "Flower rug", "author": "jarble", "description": "Another colorful rug pattern.", "tags": ["fractal", "rug"], "likes": 4, "viewed": 185, "published": 3, "date": "1681715901", "time_retrieved": "2024-07-30T18:00:20.607482", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    for(int k = 0; k < 6; k++){\n        vec2 uv1 = uv;\n        uv =\n            abs(.5+uv+t2)/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv+.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        {t2 = t2.yx; uv=uv.yx;}\n        col.x =\n            abs(float(b)-col.x*max(sign(t2.x-t2.y),0.))\n            //fract(col.x+iTime+length(uv));\n        ;\n        col.xyz = abs(col.yzx-float(b)/2.);\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1030]], "test": "untested"}
{"id": "DdKSD3", "name": "Rainbow mosaic", "author": "jarble", "description": "Another colorful mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 3, "viewed": 177, "published": 3, "date": "1681711362", "time_retrieved": "2024-07-30T18:00:21.476159", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        //if(uv.y>0.) uv.x += .5;\n        //else uv.y += .5;\n        \n        uv =\n            abs(.5+uv-t2)/1.5\n        ;\n        //uv += sign(uv-uv.yx)/2.+.5;\n        if(uv.y>uv.x) uv = uv.yx;\n        //else k += 1;\n\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5+floor(.5+t2.y+t2.x))\n        ;\n        //if(t2.y>t2.x) t2 = t2.yx;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx+floor(.5+t2.y+t2.x))\n        ;\n        \n        {t2 = t2.yx*sign(t2.y-t2.x); uv=uv.yx;}\n\n        \n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n        ;\n        //uv /= 1.+mod(uv.y,2.);\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1203]], "test": "untested"}
{"id": "ddKSDK", "name": "interactive hexagonal voronoi", "author": "pnoqable", "description": "mouse up -> zoom out\nmouse right -> more chaos (and less performance)\nhit space -> see size of scanned neighbourhood\nreset shader after clicking somewhere -> watch chaos rizing :D", "tags": ["voronoi"], "likes": 5, "viewed": 222, "published": 3, "date": "1681674937", "time_retrieved": "2024-07-30T18:00:22.236128", "image_code": "vec2 hash22(vec2 x) {\n    x = vec2( dot(x, vec2(127.1,311.7)), dot(x, vec2(269.5,183.3)) ); \n    return fract(cos(x)*43758.5453);\n}\n\nvec3 hash23(vec2 x) {\n    vec3 y = vec3( dot(x, vec2(127.1,311.7)), dot(x, vec2(269.5,183.3)),  dot(x, vec2(169.5,274.6)) ); \n    return fract(cos(y)*43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 10. + 90. * m.y;\n\n    float idY = round(uv.y);\n    float idX = round(uv.x + fract(0.5*idY)) - fract(0.5*idY);\n\n    vec2 id = vec2(idX, idY);\n    vec2 st = uv - id;\n    \n    float minD1 = 2., minD2 = 2.;\n    vec2 minO1, minO2;\n    \n    float chaos = .2 + 4.8 * m.x;\n    chaos *= smoothstep(0., 5., iTime);\n    \n    float r = 1. + round(sqrt(3.)*chaos);\n    \n    for(float dy = -r; dy <= r; dy++) {\n        float r2 = r - 0.5*abs(dy);\n        for(float dx = -r2; dx <= r2; dx++) {\n            vec2 o = vec2(dx, dy);\n            vec2 x = hash22(id+o);\n            float a = 6.2831 * (x.x+(x.y-0.5)*iTime);\n            vec2 st2 = chaos*vec2(cos(a), sin(a));\n            float d = distance(st, o + st2);\n            if(d < minD2) {\n                if(d < minD1) {\n                    minD2 = minD1; minD1 = d;\n                    minO2 = minO1; minO1 = o;\n                } else {\n                    minD2 = d;\n                    minO2 = o;\n                }\n            }\n            \n            // hit space for debug output:\n            if(texelFetch(iChannel0, ivec2(32, 2), 0).r > 0.  && id == o){\n                fragColor = vec4(1,0,0,1);\n                return;\n            }\n        }\n    }\n    \n    float dSum = minD1 + minD2;\n    vec3 col1 = hash23(id+minO1);\n    vec3 col2 = hash23(id+minO2);\n    \n    float delta = minD2 - minD1;\n    float width = 1.*fwidth(delta);\n    \n    vec3 col = vec3(mix(col1, col2, smoothstep(width, -width, delta)));\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddKSDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 131], [133, 133, 154, 154, 297], [299, 299, 351, 351, 1962]], "test": "untested"}
{"id": "dsKXWV", "name": "deform image", "author": "kilika", "description": "deform,image", "tags": ["deform"], "likes": 1, "viewed": 173, "published": 3, "date": "1681657947", "time_retrieved": "2024-07-30T18:00:22.998090", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Input image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 inputColor = texture(iChannel0, uv);\n\n    // Subdivision parameters\n    float numDivisions = 10.0;\n    float divisionStrength = 0.05;\n\n    // Deform the image based on mouse position\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 delta = (uv - mouse) * numDivisions;\n    delta *= 1.0 - pow(length(delta), 2.0) * divisionStrength;\n\n    // Apply the subdivided deformation\n    for (float i = 1.0; i <= numDivisions; i++) {\n        float t = i / numDivisions;\n        vec2 p = fract(delta + vec2(t, t));\n        inputColor = mix(inputColor, texture(iChannel0, p), 0.8);\n    }\n\n    // Output the final color\n    fragColor = inputColor;\n}\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 74, 769]], "test": "untested"}
{"id": "cdKXDV", "name": "Logarithmic spirals tweaked", "author": "mrange", "description": "CC0: Logarithmic spirals tweaked\nBeen travelling and was messing around with this before travel\nLooked better than I remembered so publishing it now.\n", "tags": ["2d"], "likes": 42, "viewed": 582, "published": 3, "date": "1681647663", "time_retrieved": "2024-07-30T18:00:23.855797", "image_code": "// CC0: Logarithmic spirals tweaked\n//  Been travelling and was messing around with this before travel\n//  Looked better than I remembered so publishing it now.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(1.2);\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nfloat forward(float l) {\n  return exp2(ExpBy*l);\n}\n\nfloat reverse(float l) {\n  return log2(l)/ExpBy;\n}\n\nvec3 sphere(vec3 col, mat2 rot, vec3 bcol, vec2 p, float r, float aa) {\n  vec3 lightDir = normalize(vec3(1.0, 1.5, 2.0));\n  lightDir.xy *= rot;\n  float z2 = (r*r-dot(p, p));\n  vec3 rd = -normalize(vec3(p, 0.1));\n  if (z2 > 0.0) {\n    float z = sqrt(z2);\n    vec3 cp = vec3(p, z);\n    vec3 cn = normalize(cp);\n    vec3 cr = reflect(rd, cn);\n    float cd= max(dot(lightDir, cn), 0.0);\n    vec3 cspe = pow(max(dot(lightDir, cr), 0.0), 10.0)*tanh(8.0*(bcol))*0.5;\n    vec3 ccol = mix(0.2, 1.0, cd*cd)*bcol;\n    ccol += cspe;\n    float d = length(p)-r;\n    col = mix(col, ccol, smoothstep(0.0, -aa, d));\n  }\n  return col;\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\n\nvec2 transform(vec2 p) {\n  vec2 sp0 = toSmith(p-0.);\n  vec2 sp1 = toSmith(p+vec2(1.0)*ROT(0.12*TIME));\n  vec2 sp2 = toSmith(p-vec2(1.0)*ROT(0.23*TIME));\n  p = fromSmith(sp0+sp1-sp2);\n  return p;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n//  float aa = 4.0/RESOLUTION.y;\n  vec2 np = p + 1.0/RESOLUTION.y;\n  vec2 tp = transform(p);\n  vec2 ntp = transform(np);\n  float aa = 2.0*distance(tp, ntp);\n  p = tp;\n\n  float ltm = 0.75*TIME;\n  mat2 rot0 = ROT(-0.125*ltm); \n  p *= rot0;\n  float mtm = fract(ltm);\n  float ntm = floor(ltm);\n  float gd = dot(p, p);\n  float zz = forward(mtm);\n\n  vec2 p0 = p;\n  p0 /= zz;\n\n  float l0 = length(p0);\n  \n  float n0 = ceil(reverse(l0));\n  float r0 = forward(n0);\n  float r1 = forward(n0-1.0);\n  float r = (r0+r1)/2.0;\n  float w = r0-r1;\n  float nn = n0;\n  n0 -= ntm;\n\n  vec2 p1 = p0;\n  float reps = floor(TAU*r/(w));\n  mat2 rot1 = ROT(0.66*n0); \n  p1 *= rot1;\n  float m1 = modPolar(p1, reps)/reps;\n  p1.x -= r;\n  \n  vec3 ccol = (1.0+cos(0.85*vec3(0.0, 1.0, 2.0)+TAU*(m1)+0.5*n0))*0.5;\n  vec3 gcol = (1.+cos(vec3(0.0, 1.0, 2.0) + 0.125*ltm))*0.01;\n  mat2 rot2 = ROT(TAU*m1);\n\n  vec3 col = vec3(0.0);\n  float fade = 0.5+0.5*cos(TAU*m1+0.33*ltm);\n  col = sphere(col, rot0*rot1*rot2, ccol*mix(0.25, 1.0, sqrt(fade)), p1, mix(0.125, 0.5, fade)*w, aa/zz);\n  col *= 1.5;\n  col += gcol/max(gd, 0.001);\n  col += gcol*aa*10.0;\n//  col -= 0.05*vec3(0.0, 1.0, 2.0).zyx*(length(pp)+0.25);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, p);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 372, 421, 421, 820], [822, 822, 846, 846, 872], [874, 874, 898, 898, 924], [926, 926, 997, 997, 1544], [1546, 1546, 1569, 1649, 1788], [1790, 1790, 1815, 1894, 2033], [2036, 2036, 2060, 2060, 2232], [2234, 2334, 2353, 2353, 2440], [2442, 2549, 2575, 2575, 2759], [2761, 2761, 2791, 2824, 4022], [4024, 4024, 4081, 4081, 4252]], "test": "untested"}
{"id": "DsVSDV", "name": "Gears and conveyor belt", "author": "yasuo", "description": "The idea came from the previous shader post of Shane's comment.", "tags": ["graphicdesign", "cineshader"], "likes": 33, "viewed": 1869, "published": 3, "date": "1681647586", "time_retrieved": "2024-07-30T18:00:24.689567", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(3.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat innerGear(vec2 p, float dir){\n    p*=Rot(radians(-iTime*45.+45.)*dir);\n    vec2 prevP = p;\n\n    //p*=Rot(radians(iTime*45.+20.));\n    p = DF(p,7.);\n    p-=vec2(0.24);\n    p*=Rot(deg45);\n    float d = B(p,vec2(0.01,0.06));\n    p = prevP;\n    float d2 = abs(length(p)-0.42)-0.02;\n    d = min(d,d2);\n    d2 = abs(length(p)-0.578)-0.02;\n    d = min(d,d2);\n    d2 = abs(length(p)-0.499)-0.005;\n    d = min(d,d2);\n    \n    p = DF(p,7.);\n    p-=vec2(0.43);\n    p*=Rot(deg45);\n    d2 = B(p,vec2(0.01,0.04));\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec3 pattern1(vec2 p, vec3 col, float dir){\n    vec2 prevP = p;\n    float size = 0.499;\n    float thick = 0.15;\n    \n    p+=vec2(size);\n    float d = abs(length(p)-size)-thick;\n    d = max(d,innerGear(p,dir));\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p = prevP;\n    p-=vec2(size);\n    d = abs(length(p)-size)-thick;\n    d = max(d,innerGear(p,dir));\n    col = mix(col,vec3(1.),S(d,0.0));  \n    \n    return col;\n}\n\nvec3 pattern2(vec2 p, vec3 col, float dir){\n\n    vec2 prevP = p;\n    float size = 0.33;\n    float thick = 0.15;\n    float thift = 0.0;\n    float speed = 0.3;\n    \n    p-=vec2(size,0.);\n    float d = B(p,vec2(size,thick));\n    \n    p.x+=thift;\n    p.x-=iTime*speed*dir;\n    p.x=mod(p.x,0.08)-0.04;\n    d = max(d,B(p,vec2(0.011,thick)));\n    p = prevP;\n    d = max(-(abs(p.y)-0.1),d);\n    //d = min(B(p,vec2(1.,0.1)),d);\n    p.y=abs(p.y)-0.079;\n    d = min(B(p,vec2(1.,0.02)),d);\n    \n    p = prevP;\n    p-=vec2(0.0,size);\n    float d2 = B(p,vec2(thick,size));\n    \n    p.y+=thift;\n    p.y+=iTime*speed*dir;\n    p.y=mod(p.y,0.08)-0.04;\n    d2 = max(d2,B(p,vec2(thick,0.011)));\n    \n    p = prevP;\n    d2 = max(-(abs(p.x)-0.1),d2);\n    d2 = min(B(p,vec2(0.005,1.)),d2);\n    p.x=abs(p.x)-0.079;\n    d2 = min(B(p,vec2(0.02,1.)),d2);    \n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p+=vec2(0.0,size);\n    d2 = B(p,vec2(thick,size));\n    \n    p.y+=thift;\n    p.y-=iTime*speed*dir;\n    p.y=mod(p.y,0.08)-0.04;\n    d2 = max(d2,B(p,vec2(thick,0.011)));\n        \n    p = prevP;\n    d2 = max(-(abs(p.x)-0.1),d2);\n    d2 = min(B(p,vec2(0.005,1.)),d2);\n    p.x=abs(p.x)-0.079;\n    d2 = min(B(p,vec2(0.02,1.)),d2);   \n    \n    d = min(d,d2);\n    \n    p = prevP;\n    p+=vec2(size,0.0);\n    d2 = B(p,vec2(size,thick));\n    \n    p.x+=thift;\n    p.x+=iTime*speed*dir;\n    p.x=mod(p.x,0.08)-0.04;\n    d2 = max(d2,B(p,vec2(0.011,thick)));\n    d = min(d,d2);    \n    p = prevP;\n    d = max(-(abs(p.y)-0.1),d);\n    d = min(B(p,vec2(1.,0.005)),d);\n    p.y=abs(p.y)-0.079;\n    d = min(B(p,vec2(1.,0.02)),d);    \n    \n    p = prevP;\n    d2 = abs(B(p,vec2(size*0.3)))-0.05;\n    d = min(d,d2); \n    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    d = B(p,vec2(0.08));\n    col = mix(col,vec3(0.),S(d,0.0));\n    \n    p*=Rot(radians(60.*iTime*dir));\n    d = B(p,vec2(0.03));\n    col = mix(col,vec3(1.),S(d,0.0));     \n     \n    return col;\n}\n\nvec3 drawBelt(vec2 p, vec3 col, float size){\n    vec2 prevP = p;\n    \n    p*=size;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    float dir = mod(id.x+id.y,2.)*2.-1.;\n    float n = random(id);\n    \n    if(n<0.5){\n        if(n<0.25){\n            gr.x*=-1.;\n        }\n        col = pattern1(gr,col,dir);\n    } else {\n        if(n>0.75){\n            gr.x*=-1.;\n        }\n        col = pattern2(gr,col,dir);\n    }\n    \n    return col;\n}\n\nvec3 gear(vec2 p, vec3 col, float dir){\n    vec2 prevP = p;\n\n    p*=Rot(radians(iTime*45.+13.)*-dir);\n    p = DF(p,7.);\n    p-=vec2(0.23);\n    p*=Rot(deg45);\n    float d = B(p,vec2(0.01,0.04));\n    p = prevP;\n    float d2 = abs(length(p)-0.29)-0.02;\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    p*=Rot(radians(iTime*30.-30.)*dir);\n    p = DF(p,6.);\n    p-=vec2(0.14);\n    p*=Rot(radians(45.));\n    d = B(p,vec2(0.01,0.03));\n    p = prevP;\n    d2 =abs( length(p)-0.1)-0.02;\n    p*=Rot(radians(iTime*25.+30.)*-dir);\n    d2 = max(-(abs(p.x)-0.05),d2);\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    return col;\n}\n\nvec3 item0(vec2 p, vec3 col, float dir){\n    vec2 prevP = p;\n    p.x*=dir;\n    p*=Rot(radians(iTime*30.+30.));\n    float d = abs(length(p)-0.2)-0.05;\n    col = mix(col,vec3(0.3),S(d,0.0));\n    \n    d = abs(length(p)-0.2)-0.05;\n    d = max(-p.x,d);\n    float a = clamp(atan(p.x,p.y)*0.5,0.3,1.);\n    \n    col = mix(col,vec3(a),S(d,0.0));\n    \n    return col;\n}\n\n\nvec3 item1(vec2 p, vec3 col, float dir){\n    p.x*=dir;\n    vec2 prevP = p;\n    p*=Rot(radians(iTime*30.+30.));\n    float d = abs(length(p)-0.25)-0.04;\n    d = abs(max((abs(p.y)-0.15),d))-0.005;\n    float d2 = abs(length(p)-0.25)-0.01;\n    d2 = max((abs(p.y)-0.12),d2);\n    d = min(d,d2);\n    \n    d2 = abs(length(p)-0.27)-0.01;\n    d2 = max(-(abs(p.y)-0.22),d2);\n    d = min(d,d2);\n    d2 = B(p,vec2(0.01,0.32));\n    d2 = max(-(abs(p.y)-0.22),d2);\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(iTime*-20.+30.));\n    p = DF(p,2.);\n    p-=vec2(0.105);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.03,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(length(p)-0.09)-0.005;\n    d2 = max(-(abs(p.x)-0.03),d2);\n    d2 = max(-(abs(p.y)-0.03),d2);\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.6),S(d,0.0));\n    \n    return col;\n}\n\nvec3 item2(vec2 p, vec3 col, float dir){\n    p.x*=dir;\n    p*=Rot(radians(iTime*50.-10.));\n    vec2 prevP = p;\n    float d = abs(length(p)-0.15)-0.005;\n    float d2 =  abs(length(p)-0.2)-0.01;\n    d2 = max((abs(p.y)-0.15),d2);\n    d = min(d,d2);\n    \n    p = DF(p,1.);\n    p-=vec2(0.13);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.008,0.1));\n    d = min(d,d2);    \n    \n    p = prevP;\n    p = DF(p,4.);\n    p-=vec2(0.18);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.005,0.02));\n    d = min(d,d2);   \n    \n    col = mix(col,vec3(0.6),S(d,0.0));\n    \n    return col;\n}\n\nfloat needle(vec2 p){\n    p.y-=0.05;\n    p*=1.5;\n    vec2 prevP = p;\n    p.y-=0.3;\n    p.x*=6.;\n    float d = Tri(p,vec2(0.3));\n    p = prevP;\n    p.y+=0.1;\n    p.x*=2.;\n    p.y*=-1.;\n    float d2 = Tri(p,vec2(0.1));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 item3(vec2 p, vec3 col, float dir){\n    \n    p*=Rot(radians(sin(iTime*dir)*120.));\n    vec2 prevP = p;\n   \n    p.y= abs(p.y)-0.05;\n    float d = needle(p);\n    p = prevP;\n    float d2 = abs(length(p)-0.1)-0.003;\n    d2 = max(-(abs(p.x)-0.05),d2);\n    d = min(d,d2);\n    d2 = abs(length(p)-0.2)-0.005;\n    d2 = max(-(abs(p.x)-0.08),d2);\n    d = min(d,d2);\n    \n    p = DF(p,4.);\n    p-=vec2(0.18);\n    d2 = length(p)-0.01;\n    p = prevP;\n    d2 = max(-(abs(p.x)-0.03),d2);\n    d = min(d,d2);   \n    \n    col = mix(col,vec3(0.6),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawGearsAndItems(vec2 p, vec3 col, float size){\n    vec2 prevP = p;\n    p*=size;\n    p+=vec2(0.5);\n    \n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    \n    float n = random(id);\n    float dir = mod(id.x+id.y,2.)*2.-1.;\n    if(n<0.3){\n        col = gear(gr,col,dir);\n    } else if(n>=0.3 && n<0.5){\n        col = item0(gr,col,dir);\n    } else if(n>=0.5 && n<0.7){\n        col = item1(gr,col,dir);\n    } else if(n>=0.7 && n<0.8) {\n        col = item2(gr,col,dir);\n    } else if(n>=0.8){\n        col = item3(gr,col,dir);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    p.y+=iTime*0.1;\n    \n    float size = 4.;\n    vec3 col = vec3(0.);\n    col = drawBelt(p,col,size);\n    col = drawGearsAndItems(p,col,size);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 444, 467, 467, 540], [542, 542, 577, 577, 1087], [1089, 1089, 1132, 1132, 1506], [1508, 1508, 1551, 1551, 3422], [3424, 3424, 3468, 3468, 3865], [3867, 3867, 3906, 3906, 4516], [4518, 4518, 4558, 4558, 4877], [4880, 4880, 4920, 4920, 5729], [5731, 5731, 5771, 5771, 6302], [6304, 6304, 6325, 6325, 6555], [6557, 6557, 6597, 6597, 7122], [7124, 7124, 7177, 7177, 7685], [7687, 7687, 7744, 7744, 7981]], "test": "untested"}
{"id": "dsyXDK", "name": "Endless Highway", "author": "storyxx", "description": "A bit of art, inspired by the music video to \"Repetition\" by Max Cooper (https://youtu.be/nO9aot9RgQc)", "tags": ["road", "car"], "likes": 14, "viewed": 325, "published": 3, "date": "1681601113", "time_retrieved": "2024-07-30T18:00:25.544282", "image_code": "#define PI 3.1415926535\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*PI/2.0 : atan(y, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coords = uv*2.0 - 1.0;\n    coords.y *= iResolution.y / iResolution.x;\n    \n    \n    vec3 clr = vec3(0);\n    int iter = 100;\n    for (int i=0; i<iter; i++) {\n        float t = rand(vec2(i, 1.0));\n        \n        float scale = rand(vec2(t, 1.0)) + 1.0;\n        float x = rand(vec2(scale, 1.0))*2.0 - 1.0;\n        float y = rand(vec2(x, 1.0))*2.0 - 1.0;\n\n        float d = sdBox(coords+vec2(x,y), vec2(0.1, 0.1));\n        \n        if (abs(d-scale) < 0.05) {\n            float r1 = rand(vec2(y, 1.0));\n            float g1 = rand(vec2(r1, 1.0));\n            float b1 = rand(vec2(g1, 1.0));\n            \n            float r2 = rand(vec2(b1, 1.0));\n            float g2 = rand(vec2(r2, 1.0));\n            float b2 = rand(vec2(g2, 1.0));\n            \n            float rx = coords.x + x;\n            float ry = coords.y + y;\n            float angle = abs(atan2(ry, rx)+PI);\n        \n            clr = vec3(float(i)/float(iter));\n            clr *= float((abs(d-scale) > 0.005 || sin(angle*100.0) > 0.0) && abs(d-scale) < 0.045);\n            \n            float s1 = 1.0+rand(vec2(b2, 1.0));\n            float r_angle = fract(iTime*0.1*s1 + rand(vec2(s1, 1.0)))*2.0*PI;\n            float angle_sdf = min(abs(angle-r_angle), min(abs(angle+2.0*PI-r_angle), abs(angle-2.0*PI-r_angle)));\n            if (angle_sdf < 0.02 && d-scale > 0.01 && d-scale < 0.04) {\n                clr *= vec3(r1,g1,b1);\n            }\n            \n            float s2 = 1.0+rand(vec2(s1, 1.0));\n            r_angle = (1.0-fract(iTime*0.1*s2 + rand(vec2(s2, 1.0))))*2.0*PI;\n            angle_sdf = min(abs(angle-r_angle), min(abs(angle+2.0*PI-r_angle), abs(angle-2.0*PI-r_angle)));\n            if (angle_sdf < 0.02 && d-scale < -0.01 && d-scale > -0.04) {\n                clr *= vec3(r2,g2,b2);\n            }\n        }\n    }    \n    \n    fragColor = vec4(clr,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyXDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 45, 45, 115], [117, 117, 154, 154, 234], [236, 236, 273, 273, 326], [328, 328, 385, 385, 2267]], "test": "untested"}
{"id": "ddySWG", "name": "fwidth ray tracer test", "author": "pnoqable", "description": "A simple idea how to use fwidth in ray tracing for anti aliasing the edge of a sphere. Turned out to be a bit tricky though as fwidth doesn't like to be nested inside if blocks..", "tags": ["fwidth"], "likes": 1, "viewed": 190, "published": 3, "date": "1681597738", "time_retrieved": "2024-07-30T18:00:26.351125", "image_code": "vec4 sphere(vec3 ro, vec3 rd, vec3 c, float r) {\n    vec3 roc = c - ro;\n    float x = dot(rd, roc);\n    float yy = dot(roc, roc) - x*x;\n    float dxdx = r*r - yy;\n    float w = fwidth(dxdx);\n\n    if(dxdx > 0.) {\n        float dx = sqrt(dxdx);\n        float x0 = x - dx;\n        \n        if(x0 > 0.) {\n            float alpha = smoothstep(0., 2.*w, dxdx);\n            return vec4(ro + x0 * rd, alpha);\n        }\n    }\n    \n    return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1. - length(uv/2.));\n    \n    vec3 lightDir = normalize(vec3(sin(iTime), -0.3, cos(iTime)));\n    \n    vec3 ro = vec3(0, 0, -1.5);\n    vec3 rd = normalize(vec3(uv, 1.));\n\n    vec4 sphere = sphere(ro, rd, vec3(0), 1.);\n\n    if(sphere.a > 0.) {\n        vec3 normal = sphere.xyz;\n        float brightness = pow(max(0., dot(-lightDir, normal)), 4.);\n        col = mix(col, vec3(brightness), sphere.a);\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddySWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 444], [446, 446, 503, 503, 1030]], "test": "untested"}
{"id": "cdGXDK", "name": "Music Boxes", "author": "QuantumSuper", "description": "So much to learn from such seemingly simple ideas. Soft shadows, ambient light, reflection effects - each a journey on its own and each one visibly worth it.\n\nUse with music in iChannel0.", "tags": ["raymarching", "music"], "likes": 7, "viewed": 242, "published": 3, "date": "1681580824", "time_retrieved": "2024-07-30T18:00:27.172928", "image_code": "// Music Boxes 0.4.230415 by QuantumSuper\n// auti-vj with a bunch of bouncing boxes\n// Ray marching inspired by The Art of Code: youtu.be/PGtv-dBi2wE\n// Lighting & shadows based on iq's work: https://www.shadertoy.com/view/lsKcDD\n//\n// - use with music in iChannel0, floor texure in iChannel1 & cubemap in iChannel2 -\n\n#define aTime .2133333*iTime \n#define MAX_STEP 70\n#define MAX_DIST 80.\n#define MIN_DIST 0.02\n#define AA 1. \n\nstruct object{\n\tint type; //0: plane; 1: box\n    vec3 pos; //position\n\tvec4 param; //horizontal plane (height,0,0,0); box (width, height, depth, 0);\n};\nobject[6] objects; //stores geometry definitions\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n    //fft.x = step(.9,fft.x); //weaken weaker sounds, hard limit\n}\n\nmat2 rotM2(float a){float c = cos(a), s = sin(a); return mat2(c,s,-s,c);}\n\nfloat sdPlane(vec3 p, float h){return p.y-h;}\n\nfloat sdBox(vec3 p, vec3 b){ //source: https://iquilezles.org/articles/distfunctions/\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat getDistance(vec3 p){\t\n\tfloat minDist = MAX_DIST; //max minDist\n\t\n\tfor (int n=0; n<objects.length(); n++){ //get the distance to each object\t\n             if (objects[n].type == 0) minDist = min( minDist, sdPlane(p-objects[n].pos,objects[n].param.x)); //horizontal Plane\n        else if (objects[n].type == 1) minDist = min( minDist, sdBox(p-objects[n].pos,objects[n].param.xyz)); //box     \n    }\n    \n\treturn minDist;\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection){ //cf. The Art of Code's ray marching tutorial: youtu.be/PGtv-dBi2wE\n\tfloat rayLength = MIN_DIST; \n\tfloat radSphere;\n\t\n\tfor (int n=0; n<MAX_STEP; n++){\n\t\tradSphere = getDistance(rayOrigin+rayLength*rayDirection); //get sphere\n\t\trayLength += radSphere; //march\n\t\tif (rayLength>MAX_DIST || abs(radSphere)<MIN_DIST) break;\n\t}\n\t\n\treturn rayLength;\n}\n\nvec3 guessNormal(vec3 pos){ //estimate the surface normal at pos\n\tvec2 tangent = vec2(.01*MIN_DIST, 0); //sensitive!\n\t\n\tvec3 normal = getDistance(pos) - vec3(\n\t\tgetDistance(pos-tangent.xyy),\n\t\tgetDistance(pos-tangent.yxy), \n\t\tgetDistance(pos-tangent.yyx)\n\t\t);\n\t\t\n\treturn normalize(normal);\n}\n\nfloat calcAO( vec3 pos, vec3 nor){ //see iq again: https://www.shadertoy.com/view/lsKcDD\n\tfloat occ = 0.;\n    float sca = 1.;\n    \n    for (int i=0;i<5;i++){\n        float h = .001 + .15*float(i)/4.;\n        float d = getDistance( pos+h*nor);\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    \n    return clamp( 1.-1.5*occ, 0., 1.);    \n}\n\nfloat softShadow( vec3 ro, vec3 rd, float mint, float maxt, float w){ //source: https://iquilezles.org/articles/rmshadows/\n    float res = 1.;\n    float t = mint;\n    \n    for (int i=0;i<256 && t<maxt;i++){\n        float h = getDistance(ro + t*rd);\n        res = min( res, h/(w*t));\n        t += clamp( h, .005, .5);\n        if (res<-1. || t>maxt) break;\n    }\n    res = max(res,-1.);\n    \n    return .25*(1.+res)*(1.+res)*(2.-res);\n}\n\nvec3 render(vec3 pos, vec3 dir){\n    // Light initialization\n    vec3 lightPos = vec3(4,6,4);\n    vec3 lightCol = .5*vec3(sin(aTime*1.123),sin(aTime*1.234),sin(aTime*1.345))\n                    + .5 + step(.9,fft.x);\n    \n    // Depth calculation\n    float rayDist = rayMarch(pos,dir); \n    vec3 rayPos = pos+rayDist*dir;   \n    vec3 lightDir = normalize( lightPos-rayPos);\n    \n    // Texture\n    lightCol *= (rayPos.y<ffts.w || rayPos.y<.03)? //global geometry hack rather than object based\n                    (rayPos.y>0.03)? \n                        .7*texture( iChannel1, (rayPos.xz*rotM2(1.5708)+rayPos.y-ffts.w+.42)/5., 0.).x:\n                        .5*texture( iChannel1, .1*rayPos.xz, 0.).x:\n                    1.5;\n    \n    // Shadows\n    vec3 surfNormal = guessNormal(rayPos);\n    float amp = clamp( dot(lightDir, surfNormal), 0., 1.) * softShadow( rayPos, lightDir, MIN_DIST, MAX_DIST, .5);\n    vec3 col = lightCol * amp;\n    \n    // Light speck\n    vec3  halo = normalize( lightDir-dir );\n    float speck = (.1+.9*pow( clamp( dot(surfNormal,halo),0.,1.), 16.)) * amp * (.04+.96*pow( clamp(1.0+dot(halo,dir),0.,1.), 5.));  \n    speck = (rayPos.y<ffts.w || rayPos.y<.03)? //same global geo hack\n                speck : (.005+15.*speck) * clamp( dot(textureLod( iChannel2, reflect(dir,surfNormal), 1.).rgb,halo), 0., 1.); //cubemap reflection\n    col+= lightCol * speck;\n    \n    // Ambient light\n    amp = clamp( .5+.5*surfNormal.y, 0., 1.) * calcAO( rayPos, surfNormal);\n    col += lightCol * amp * vec3(.1,.05,.1);\n        \n    // Fog\n    col *= exp(-0.0001*rayDist*rayDist*rayDist); //simple distance based attenuation\n    \n    // Utility\n    //col = .06*vec3(rayPos); //depth map\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    compressFft(); //initializes fft, ffts\n    \n    // Camera initialization\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1\n    vec3 camPos = vec3(0,3.+1.5*sin(.5*aTime),0) + (6.*cos(2.*aTime)+9.) * vec3(sin(aTime), 0,-cos(aTime)); //ray origin, rotating on circle\n    vec3 camDir = normalize( vec3( uv.x, vec2(uv.y,1)*rotM2(-.15+.1*cos(2.*aTime)-.2*sin(.5*aTime)))); //ray direction, static, slightly downwards\n    camDir.xz *=rotM2(-aTime);\n\t\n\t// Object initializations\n    objects = object[](\n\t\tobject(0, vec3(0), vec4(0)), //horizontal plane\n\t\tobject(1, vec3(1.5,0,1.5), vec4(1,4.*fft.x+ffts.w,1,0)), //box 1\n        object(1, vec3(-1.5,0,1.5), vec4(1,4.*fft.y+ffts.w,1,0)), //box 2\n        object(1, vec3(1.5,0,-1.5), vec4(1,4.*fft.z+ffts.w,1,0)), //box 3\n        object(1, vec3(-1.5,0,-1.5), vec4(1,4.*fft.w+ffts.w,1,0)),//box 4\n        object(1, vec3(0), vec4(3,ffts.w,3,0)) //pedestal\n        );\n    \n    // Render\n    vec3 col = vec3(0);\n    for(float m=0.;m<AA;m++) //simple antialiasing (for AA>=2.)\n        for(float n=0.;n<AA;n++)\n            col += render(camPos+vec3(m,n,.0)*length(camPos.xy)/iResolution.x,camDir); //sloppy pixel estimation     \n    col /= AA*AA;\n    \n    // Finalizations\n    col = 1. - exp(-col); //tone mapping\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33049, "src": "https://soundcloud.com/skelermusic/contracts", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGXDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[681, 681, 700, 785, 1845], [1847, 1847, 1867, 1867, 1920], [1922, 1922, 1953, 1953, 1967], [1969, 1969, 1997, 2054, 2141], [2143, 2143, 2169, 2169, 2569], [2571, 2571, 2621, 2689, 2966], [2968, 2968, 2995, 3032, 3259], [3261, 3261, 3295, 3349, 3605], [3607, 3607, 3676, 3729, 4041], [4043, 4043, 4075, 4103, 5763]], "test": "untested"}
{"id": "mdVSWy", "name": "my julia sets discovery", "author": "dkaraush", "description": "click and drag to discover yourself!", "tags": ["juliasets"], "likes": 0, "viewed": 147, "published": 3, "date": "1681574334", "time_retrieved": "2024-07-30T18:00:27.917937", "image_code": "#define MAX_ITERATIONS 80.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 r = iResolution.xy, uv = fragCoord.xy/r.y-vec2(.5*r.x/r.y-.5,0.);\n    \n    float R = 2., t = iTime / 2.;\n    \n    vec2 c;\n    if (iMouse.z > 0.) {\n        c = (iMouse.xy / iResolution.xy - .5) * 2.;\n    } else {\n        float tA = .8, tB = 20., g = mod(t, tA + tB + tA), a = (g < tA) ? g/tA*3.14/2. : (g < tA + tB) ? 3.14/2.+(g-tA)/tB*3.14 : (g-tA-tB)/tA*3.14/2.+3.*3.14/2.;\n        c = vec2(cos(a), sin(a)) * .75;\n    }\n    \n    if (length(fragCoord.xy - (c * .5 + .5) * iResolution.xy) < 10.) {\n        fragColor = vec4(1., 0., 0., 0.);\n        return;\n    }\n    \n    float S = 1.8; // CHANGE FOR SCALE\n    vec2 z = (uv - .5) * S;\n    \n    float i = 0.;\n    for (; (z.x * z.x + z.y * z.y) < R * R && i < MAX_ITERATIONS; ++i) {\n        float xtemp = z.x * z.x - z.y * z.y;\n        z.y = 2. * z.x * z.y + c.y;\n        z.x = xtemp + c.x;\n    }\n    \n    if (i == MAX_ITERATIONS) {\n        fragColor = vec4(vec3(0.), 1.);\n    } else {\n        float j = i / MAX_ITERATIONS;\n        fragColor = vec4(.5+.6*(clamp(abs(mod(j*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.)-.5),1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 83, 83, 1163]], "test": "untested"}
{"id": "lsXXDH", "name": "Lofi video/film (webcam)", "author": "teadrinker", "description": "Click and move mouse around to change parameters!\nSimulate early video/tv footage by combining sharpening and an approximation of the color response of photographic film.", "tags": ["video", "webcam", "film", "lofi", "vintage"], "likes": 5, "viewed": 530, "published": 3, "date": "1681573916", "time_retrieved": "2024-07-30T18:00:28.672917", "image_code": "\n\nconst float si = 5.; // sampling quality for sharpening, kind of \n\n\nvec4 colorAdjust(vec4 col) { \n    \n    // simulate film colors\n\tcol = \t\tvec4(col.x*0.8+col.y*0.2,\n\t\t\t\t\t col.x*0.2+col.y*0.6+col.z*0.2,\n\t\t\t\t\t col.y*0.7+col.z*0.3,1);\t\n                    \n    // increase saturation\n    float sat = 1.0;\n    float o = 1. + sat;\n    float z = -sat / 2.;\n\tcol = \t\tvec4(col.x*o+col.y*z+col.z*z,\n\t\t\t\t\t col.x*z+col.y*o+col.z*z,\n\t\t\t\t\t col.x*z+col.y*z+col.z*o, 1);\t                     \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.5;\n    float contrast = 0.3;\n\n    if(length(iMouse.xy) > 0.) {\n        contrast = iMouse.y/iResolution.y;\n        radius = iMouse.x/iResolution.x;\n    }\n\n\tfloat muln= 1. / pow((si)*2.,2.);\n\tfloat blurs = pow(radius,5.)/(si*2.);\n    \n\tvec2 uv = vec2(iResolution.x-fragCoord.x, iResolution.y - fragCoord.y) / iResolution.xy;\n\tvec4 color = vec4(0);\n\tfor(float x = -si+0.5 ; x < si; x++) {\n\t\tfor(float y = -si+0.5 ; y < si; y++) {\n\t\t\tvec4 col = (texture(iChannel0, uv + blurs*vec2(float(x),float(y))) );\n\t\t\tcolor = color + col;\n  \t\t}\n\t}\n    vec4 org = texture(iChannel0, uv);\n    vec4 sharpenedImage = org - color * muln;\n\tfragColor = colorAdjust(sharpenedImage*0.005*(20.*pow(contrast,3.))/blurs + 0.3*org + 0.3);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsXXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 98, 132, 498], [500, 500, 557, 557, 1291]], "test": "untested"}
{"id": "ddKXWG", "name": "spiral illusion 2", "author": "FabriceNeyret2", "description": "no spiral here !\ninspiration: https://twitter.com/gsarcone/status/1647024195996463106", "tags": ["2d", "illusion", "perception", "short", "golf", "reproduction"], "likes": 18, "viewed": 291, "published": 3, "date": "1681567030", "time_retrieved": "2024-07-30T18:00:29.435877", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;                       // normalized coordinates \n // U *= mat2(cos(.3*iTime+vec4(0,11,33,0))) / exp2(.3*iTime);   // optional rotation + zoom\n    float y = length(U),        a = atan(U.y,U.x), n = 48./6.28, // polar coords\n          L = round(log(y)*8.), A = round(a*n),        // (L,A) : disc id\n          l = exp(L/8.);                               // (l,A/n): disc pos (polar)\n    mod(A-L, 2.) < 1. ?  l += l/60. : l;               // offset 1 disc /2 to suggest spiral\n    U = U/l - cos( A/n - vec2(0,1.57));                // disc local coords\n    y = y/l - 1.;                                      // local radial coord\n    mod(A-L, 4.) < 2. ? y = -y : y;                    // disc gradient direction\n    l = 60.*length(U) - 2.5;                           // disc SDF\n    O = vec4( mix( .5, fract(60.*y/5.5+.5), smoothstep( 1., -1., l/fwidth(l) ) )); // draw disc \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddKXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 976]], "test": "untested"}
{"id": "cdVXDG", "name": "Zellij pattern 4", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "music", "zellige"], "likes": 7, "viewed": 174, "published": 3, "date": "1681547256", "time_retrieved": "2024-07-30T18:00:30.182880", "image_code": "vec2 f1(vec2 a){\n    return\n        abs(fract(a)-.5)\n        //min(abs(fract(a*2.)-.5),abs(fract(a)-.5))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        f1((a1)*(a2.x+a2.y))\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5+uv+t2)/1.5\n        ;\n        if(uv.x>0.) uv.x -= .5;\n\n        t2 =\n            -triangle_wave(uv.yx+.5)\n        ;\n        uv =\n            t2-triangle_wave(uv)\n        ;\n        \n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n        ;\n        //if(uv.y<uv.x) col=col.yzx;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b,float f1){\n    return\n        mod(floor(a/f1),b)\n        //mod(floor(a/f1)*floor(a),b)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float f1 = pow(2.,2.+mod(floor(time/2.),2.));\n  float s1 = 8.,\n  t=time/(1.+fmod(time,2.,f1)),\n  m3 =\n      fmod(floor(t*f1+fmod(t,s1,f1)),s1,f1)\n  ;\n  t *= f1*f1/(1.+fmod(t/s1,2.,f1));\n  float a=sqrt((1.-sqrt(max(fract(t/s1/s1/2.),fract(t/s1/2.)))))*.2,\n  nb = time*pow(2.,(m3+1. + fmod(t/s1,s1,f1))/5.+6.5);\n  return abs(.5-vec2(fract(nb*.998),fract(nb)))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 112], [114, 114, 141, 141, 245], [247, 247, 304, 304, 969]], "test": "untested"}
{"id": "mdyXDy", "name": "Zellij pattern 3 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "music", "zellige"], "likes": 5, "viewed": 282, "published": 3, "date": "1681535341", "time_retrieved": "2024-07-30T18:00:31.038592", "image_code": "vec2 f1(vec2 a){\n    return\n        //abs(.5-fract(a))*abs(.5-fract(a*2.))\n        //min(abs(fract(a)-.5),abs(fract(a*1.5)-.5))\n        //max(abs(.5-fract(a)),abs(.5-fract(a.yx+.5)))\n        abs(.5-fract(a))\n    ;    \n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        f1((a1)*(a2.x+a2.y))\n        //sqrt(f1((a1)*(a2.x+a2.y)))\n    ;\n}\n\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        \n        //if((k)%3 == 0) t2 *= 0.;\n\n        //k += int(uv.y>uv.x);\n        \n        //if(t2.x<t2.y)t2.x -= .5;\n        \n        \n        \n        uv =\n            abs(.5+uv+t2)/1.5\n            //abs(.5+uv+t2*(1.+mod(floor(uv.y),2.)/2.))/1.5\n            //abs(.5+uv-t2*sign(uv.x-uv.y))/1.5\n        ;\n        //uv += binary_digit(k,2)/2.;\n        uv.x -= .5;\n        //if(k%2==0&&uv.y>uv.x) uv /= 1.5;\n        \n        \n\n        t2 =\n            -triangle_wave(uv+.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n            //t2-triangle_wave(uv.yx-floor(.5+t2.y+t2.x))\n        ;\n        \n        \n\n        {t2 = t2.yx; uv=uv.yx;}\n        //uv.x = uv.x-col.x/1.5;\n\n        //if(t2.x>t2.y)\n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n            //vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),col.y))\n            //vec3(col.zx,max(uv.x-uv.y,col.y))\n            //vec3(col.zx,max(abs(uv.x-uv.y)*sign(-t2.x+t2.y),col.x))\n        ;\n        //if(uv.x>uv.y) uv.y -= .5;\n        //if(uv.x>uv.y && k%5 == 0) {uv = -uv;break;}\n\n        //if(uv.x>uv.y) col=col.yzx;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fract1(float a){\n    return\n        fract(a)\n        //abs(fract(a)+.25)/1.25\n        //abs(max(fract(a/2.),fract(a*2.))+.25)/1.25\n        //fract(a+pow(fract(a*2.),2.))\n    ;\n}\n\nfloat fmod2(float a, float b){\n    return b*mod(floor(a),b);\n}\n\nfloat fmod1(float a, float b){\n    //a += fmod2(a*b,8.);\n    //a += floor(a/b)/8.;\n    //a /= (1. + floor(mod(1.+a/2.*b,2.)));\n    /*\n    for(int i = 0; i < 3; i++){\n        a += floor(a/2.)/2.;\n    }\n    */\n    \n    //a += floor(a/8.*b)/8.*b;\n    //a += floor(a*2./b)/b;\n    /*\n    for(int i = 0; i < 3; i++){\n        a += mod(floor(a*2.),2.);\n        //a /= (1. + floor(mod(a/2.,2.)));\n    }\n    */\n    //a -= floor(a/8.)/8.;\n    \n    a = (a + pow(2.,mod(floor(a),3.)));\n    a += pow(2.,mod(floor(a*8.),8.));\n    \n    return\n        mod(floor(a*b),b)*mod(floor(a/b)*floor(a*b),b/2.)\n        //floor(mod(floor(a*b),b/2.)*mod(floor(a/b)*floor(a*b),b)/2.)\n        //mod(mod(floor(a*b),b)*mod(floor(a/b)*floor(a*b),b*8.),b)\n        //mod(floor(floor(a*b)/3./4.),b)\n        //mod(floor(a*b/2.+8./b)+floor(a*b/2.+b/8.)+floor((a+8.)/b),b)\n        //floor(mod(floor(a*b),b*2.)*mod(floor(a*b),b)/4.)\n        //mod(mod(floor(a*b),floor(a/b)+b),b)\n        //mod(mod(floor(a/2.+4.),floor(a/8.+4.)),b)\n        //mod(mod(floor((a+2.)*b),floor(a/2.)),b)\n        //max(mod(floor(a*8./b),b),mod(floor(a/b),b))\n        //mod(floor(a*b),floor(b/2.))*mod(floor(a*pow(b,floor(mod(floor(a/b),b)/b))),(b))\n        //floor(sqrt(mod(floor(a*b),b)*mod(floor(a/b)*floor(a*b)/2.,b*2.)))\n        //mod(floor(a*b),(b/2.))*mod(floor(a/b)*floor(a*b/2.),b)\n        //floor(sqrt((b/2.+mod(floor(a*b),b))*(b/2.+mod(floor(a/b)*floor(a*b),b))))\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //fmod1(a+fmod1(a/2.,b/2.),b)\n    ;\n}\n\nvec2 mainSound(int samp, float t){\n  float tempo = 2.;\n  //t /= tempo;\n\n  //t += floor(t*pow(2.,mod(floor(t/2.),3.)));\n  \n  /*\n  for(int i = 0; i < 3; i++){\n      t += mod(floor(t*2.),2.)/2.+mod(floor(t*2.),2.)/2.;\n      //a /= (1. + floor(mod(a/2.,2.)));\n  }\n  */\n  \n  //t += floor(t*pow(2.,fmod(t/4.,4.)))/pow(2.,fmod(t/4.,4.));\n  float s1 =\n      8.\n  ;\n  float p1 = 1. + floor(mod((1.+t/4.)/2.,2.));\n  t *= p1/2.;\n  \n  /*\n  for(int i = 0; i < 3; i++){\n      t += mod(floor(t*4.),2.)/2.;\n  }\n  */\n  \n  float a=\n      //128.*pow((1.-sqrt(fract1(t*p1))),2.)\n      //(2.-1.*log(fract(t*p1)))*(2.-1.*log(fract(t*p1)))\n      2.*pow(log(fract(t*p1)/2.),2.)\n  ,\n  nb =\n      .5*t*tempo*pow(2.,(2.+fmod(t/s1,s1/2.)+fmod(t,s1)+1.)/5.+7.)/p1\n      //.5*t*tempo*pow(2.,(2.+fmod(t,s1)+1. + fmod(floor(t/s1),2.))/5.+7.)/p1\n  ;\n  return\n      log(abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a)\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //log(abs(a/4.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 219], [221, 221, 248, 248, 438], [440, 440, 473, 473, 507], [509, 509, 566, 566, 2009]], "test": "untested"}
{"id": "DsGSDy", "name": "Year of Truchets #012", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nexp +1 woven truchets (basic level)", "tags": ["2d"], "likes": 20, "viewed": 242, "published": 3, "date": "1681525119", "time_retrieved": "2024-07-30T18:00:31.911259", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #012\n    04/15/2023  @byt3_m3chanic \n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nconst float scale = 9.;\nconst float s4 = .577350;\nconst float s3 = .288683;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\n\nvec3 hue(float t) {\n    return .45 + .45*cos(PI2*t*(vec3(.12,.47,.92)+vec3(0.88,.97,.85))); \n}\n\n//@Shane\nvec4 hexGrid(vec2 uv, float scale) {\n    uv*=scale;\n    const vec2 s = vec2(1.732, 1.);\n    vec4 hC = floor(vec4(uv, uv - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h4 = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n    return dot(h4.xy, h4.xy) < dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = F.xy/max(R.x,R.y);\n    vec2 vv = uv;\n    \n    vec3 C = vec3(.05);\n    uv += vec2(.0,.0325) * T;\n    \n    float px = scale/R.x;\n    \n    vec4 hex = hexGrid(uv,scale);\n    vec2 id = hex.zw, p = hex.xy;\n   \n    float check = mod(id.y+id.x,2.)*2.-1.;\n    float rnd = hash21(id);\n    float dir =  -1.;\n    mat2 r2 = rot(1.047197);\n    \n    if(rnd<.5) {\n        p *= r2;\n        p.y = -p.y;\n    } \n\n    // set vectors\n    vec2 p0 = p - vec2(-s3, .5);\n    vec2 p1 = p - vec2( s4,  0);\n    vec2 p2 = p - vec2(-s3,-.5);\n    \n    // find closest point\n    vec3 d3 = vec3(length(p0), length(p1), length(p2));\n    vec2 pp = vec2(0);\n\n    if(d3.x>d3.y) pp = p1;\n    if(d3.y>d3.z) pp = p2;\n    if(d3.z>d3.x && d3.y>d3.x) pp = p0;\n\n    // hex background\n    float tileform = max(abs(hex.x)*.8660254 + abs(hex.y)*.5, abs(hex.y)) - .5;\n    float cells = smoothstep(px,-px, abs(tileform)-.006);\n    \n    float thk = .1,spc=.001;\n    float circle = length(pp)-s3;\n    circle = abs(circle)-thk;\n\n    float c1 = 1e5, c2 = 1e5, c3 = 1e5; \n    vec2 pq = p;\n    float rwd = fract(rnd*3232.32);\n    \n    if(rnd>.8) {\n        c3 = length(pq.x)-thk;\n        circle = c3;\n        c3 = abs(c3+spc)-spc;\n        pq *= r2;\n        c2 = length(pq.x)-thk;\n        circle = min(c2,circle);\n        c2 = abs(c2+spc)-spc;\n        pq *= r2;\n        c1 = length(pq.x)-thk;\n        circle = min(c1,circle);\n        c1 = abs(c1+spc)-spc;\n        c1 = rwd>.4?rwd>.7?c2:c3:c1;\n        circle = max(circle,-c1);\n    }\n    \n    if(rnd<.045) {\n        pq*=r2;pq*=r2;circle = length(pq.x)-thk;\n        c2 = length(p0)-s3;\n        c1 = length(p0+vec2(-.58,1.))-s3;\n        c1 = min(c2,c1);\n        c1 = abs(c1)-thk;\n        circle = min(circle,c1);\n    } else if(rnd<.075) {\n        circle = length(pq.x)-thk;\n        c2 = length(p1)-s3;\n        c1 = length(p1+vec2(1.155,0))-s3;\n        c1 = min(c2,c1);\n        c1 = abs(c1)-thk;\n        circle = min(circle,c1);\n    }\n     \n    float pc = length(p)-.07;\n    float sc = smoothstep(px,-px,circle-.05);\n    float sd = smoothstep(px,-px,circle+.05);\n    float sh = smoothstep(.1+px,-px,circle-.025);\n    float pi = smoothstep(px,-px,length(p)-.025);\n    pc = abs(abs(abs(abs(abs(pc)-.12)-.06)-.03)-.015)-.0075;\n    pc = smoothstep(px,-px,pc);\n    \n    circle = abs(abs(circle)-.02)-.01;\n    circle = smoothstep(px,-px,circle);\n\n    //mixdowns and stuff\n    vec3 clx = vec3(0.800,0.200,0.000);\n    vec3 clr = vec3(0.004,0.349,0.396);\n    \n    C = mix(C,clx,pc);\n    C = mix(C,vec3(0),cells);\n    C = mix(C,vec3(1),pi);\n    C = mix(C,C*.3,sh);\n    \n    C = mix(C,vec3(0),sc);\n    C = mix(C,clr,circle);\n    C = mix(C,texture(iChannel0,p*2.).rgb,sd);\n    C = mix(C,C*.5,cells);\n    \n    //output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1);\n}\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGSDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[507, 507, 525, 525, 568], [569, 569, 590, 590, 650], [652, 652, 671, 671, 746], [748, 757, 793, 793, 1059], [1061, 1061, 1102, 1102, 3860]], "test": "untested"}
{"id": "ddGSWy", "name": "ElloFractunnelBmove", "author": "elloskelling", "description": "A simple tunnel, based on my [url=https://www.shadertoy.com/view/wljyWR]\"swiss cheese caves\"[/url] fractal.", "tags": ["3d", "raymarching", "fractal"], "likes": 4, "viewed": 275, "published": 3, "date": "1681522276", "time_retrieved": "2024-07-30T18:00:32.729072", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n// and https://www.shadertoy.com/view/tl2yWR\n\n#define BEATMOVE 1\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    return length(sin((p*(i+1.0)/size))*size) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n    \tresult += planet_surface(p*i,i)/(i*i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return -result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\n    float beat = 0.5*freqs[0]*freqs[0]\n                +0.5*freqs[1]*freqs[1];\n//                +0.25*freqs[2]*freqs[2]\n//                +0.25*freqs[3]*freqs[3];\n    beat = sqrt(beat);\n    \n    float highs = sqrt(0.5*(freqs[4]*freqs[4]+freqs[5]*freqs[5]));\n\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    //viewDir.xy *= rot(mix(iTime/5.0,iTime/5.0+0.5,beat));\n    viewDir.xy *= rot(iTime/5.0);\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*5.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir + beat/10.;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p))+beat/5.;\n    vec3 K_d = K_a+highs/5.;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[649, 649, 686, 686, 742], [744, 744, 779, 779, 1007], [1009, 1009, 1032, 1032, 1059], [1061, 1061, 1089, 1089, 1219], [1222, 1643, 1734, 1734, 2040], [2055, 2309, 2374, 2374, 2506], [2508, 2597, 2626, 2626, 2936], [2938, 3430, 3570, 3570, 4180], [4182, 4552, 4637, 4637, 5052], [5054, 5381, 5430, 5465, 5596], [5598, 5598, 5655, 5655, 7306]], "test": "untested"}
{"id": "csGXDy", "name": "Liquid tile", "author": "drliquidglitch", "description": "An animated mosaic tile pattern.", "tags": ["mosaic"], "likes": 3, "viewed": 184, "published": 3, "date": "1681506298", "time_retrieved": "2024-07-30T18:00:33.590768", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord)/iResolution.y*4.;\n    uv.y += iTime/2.;\n    vec3 col = vec3(0);\n    vec2 offset = vec2(0.),\n    uv1 = uv;\n    uv.x += sin(iTime * uv.y * 0.02)  * 0.05;\n    uv.y += cos(iTime * uv.x * 0.02)  * 0.02;\n\n    for(int k = 0; k < 5; k++){\n        uv =\n            abs(fract(uv.yx+floor(uv1.y+floor(uv.x))/pow(2.,mod(floor(uv.x-iTime/2.),3.)))-(1.5*iTime*0.01))\n            //abs(fract(uv.yx+floor(uv1.y+floor(uv.y*8.)/8.)/8.)-.5)\n            //abs(fract(uv.yx+sign(uv.y-uv.x)*floor(uv1.y+floor(uv.y))/8.)-.5)\n        ;\n        if(uv.y < uv.x) col =\n            //vec3(col.yz,abs(min(uv.x,uv.y)))\n            vec3(col.yz,abs(max(uv.x,uv.y)))\n        ;\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 809]], "test": "untested"}
{"id": "DsGXWy", "name": "Art of the Day: \"Infinity (1995)", "author": "FabriceNeyret2", "description": "inspiration: https://twitter.com/gsarcone/status/1646925484221947925", "tags": ["2d", "short", "golf", "reproduction"], "likes": 25, "viewed": 289, "published": 3, "date": "1681504744", "time_retrieved": "2024-07-30T18:00:34.418555", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = abs( u+u - R ) / R.y,          // normalized coordinates\n          A = abs( U - .5 ),                 // 2 symmetries\n          V = U + vec2(-U.y,U);              // 45-tilted coords\n    float d =  max(A.x,A.y);                 // distance to square borders\n    d =  d > .5             ? 0.             // outside\n       : max(V.x,V.y) > .75 ? d              // out diamond\n       :        min(V.x,V.y)/2.;             // in diamond\n    d = cos(1e2*d);                          // wave pattern\n    O = .5 + d/2e2 *R.yyyy;                  // turned to antialiased strips\n // O = vec4 ( d/fwidth(d) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 687]], "test": "untested"}
{"id": "cdGXWy", "name": "Clouds2Vicuna", "author": "Sergeindamix", "description": "Simple 2D layered animation. Better in full screen (could become a screen saver?) \nreversioned by anon8231489123_vicuna-13b-GPTQ-4bit-128g", "tags": ["2d", "minimalist"], "likes": 6, "viewed": 184, "published": 3, "date": "1681503653", "time_retrieved": "2024-07-30T18:00:35.173537", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"Toon Cloud\" by Antoine Clappier - March 2015\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n#define TAU 6.28318530718\n\n\nconst vec3 BackColor\t= vec3(0.6, 0.4, 0.8);\nconst vec3 CloudColor\t= vec3(0.9,0.30,0.7);\n\n\nfloat Func(float pX)\n{\n\treturn 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));\n}\n\n\nfloat FuncR(float pX)\n{\n\treturn 0.5 + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));\n}\n\n\nfloat Layer(vec2 pQ, float pT)\n{\n\tvec2 Qt = 3.5*pQ;\n\tpT *= 0.5;\n\tQt.x += pT;\n\n\tfloat Xi = floor(Qt.x);\n\tfloat Xf = Qt.x - Xi -0.5;\n\n\tvec2 C;\n\tfloat Yi;\n\tfloat D = 1.0 - step(Qt.y,  Func(Qt.x));\n\n\t// Disk:\n\tYi = Func(Xi + 0.5);\n\tC = vec2(Xf, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+ pT/80.0));\n\n\t// Previous disk:\n\tYi = Func(Xi+1.0 + 0.5);\n\tC = vec2(Xf-1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));\n\n\t// Next Disk:\n\tYi = Func(Xi-1.0 + 0.5);\n\tC = vec2(Xf+1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));\n\n\treturn min(1.0, D);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Setup:\n\tvec2 UV = 2.0*(fragCoord.xy - iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\t\n\t\n\t// Render:\n\tvec3 Color= BackColor;\n\n\tfor(float J=0.0; J<=1.0; J+=0.2)\n\t{\n\t\t// Cloud Layer: \n\t\tfloat Lt =  iTime * (0.5 + 1.0 * J) * (1.0 + 0.1 * sin(226.0 * J)) + 17.0 * J;\n        vec2 Lp = vec2(0.0, 0.3 + 1.5 * ( J - 0.5));\n\t\tfloat L = Layer(UV + Lp, Lt);\n\n\t\t// Blur and color:\n\t\tfloat Blur = 1.0 * abs(2.0 - 5.0 * J) / (11.0 - 5.0 * J);\n\n\t\tfloat V = step(0.0, 1.0) * mix(0.0, 1.0, 1.0 - smoothstep(0.0, 0.01 + 0.2 * Blur, L));\n\t\tColor += mix(Color, vec3(0.0, 0.0, 0.8), V);\n\t}\n\n\tfragColor = vec4(Color, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGXWy.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[514, 514, 536, 536, 607], [610, 610, 633, 633, 686], [689, 689, 721, 721, 1265], [1269, 1269, 1326, 1337, 1943]], "test": "untested"}
{"id": "DsGSWy", "name": "Clouds anon8231489123_vicuna-13b", "author": "Sergeindamix", "description": "Simple 2D layered animation. Better in full screen (could become a screen saver?) \nreversioned by anon8231489123_vicuna-13b-GPTQ-4bit-128g", "tags": ["2d", "minimalist"], "likes": 3, "viewed": 163, "published": 3, "date": "1681503238", "time_retrieved": "2024-07-30T18:00:36.015286", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"Toon Cloud\" by Antoine Clappier - March 2015\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n#define TAU 6.28318530718\n\n\nconst vec3 BackColor\t= vec3(0.6, 0.4, 0.8);\nconst vec3 CloudColor\t= vec3(0.9,0.30,0.7);\n\n\nfloat Func(float pX)\n{\n\treturn 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));\n}\n\n\nfloat FuncR(float pX)\n{\n\treturn 0.5 + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));\n}\n\n\nfloat Layer(vec2 pQ, float pT)\n{\n\tvec2 Qt = 3.5*pQ;\n\tpT *= 0.5;\n\tQt.x += pT;\n\n\tfloat Xi = floor(Qt.x);\n\tfloat Xf = Qt.x - Xi -0.5;\n\n\tvec2 C;\n\tfloat Yi;\n\tfloat D = 1.0 - step(Qt.y,  Func(Qt.x));\n\n\t// Disk:\n\tYi = Func(Xi + 0.5);\n\tC = vec2(Xf, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+ pT/80.0));\n\n\t// Previous disk:\n\tYi = Func(Xi+1.0 + 0.5);\n\tC = vec2(Xf-1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));\n\n\t// Next Disk:\n\tYi = Func(Xi-1.0 + 0.5);\n\tC = vec2(Xf+1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));\n\n\treturn min(1.0, D);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Setup:\n\tvec2 UV = 2.0*(fragCoord.xy - iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\t\n\t\n\t// Render:\n\tvec3 Color= BackColor;\n\n\tfor(float J=0.0; J<=1.0; J+=0.2)\n\t{\n\t\t// Cloud Layer: \n\t\tfloat Lt =  iTime * (0.5 + 1.0 * J) * (1.0 + 0.1 * sin(226.0 * J)) + 17.0 * J;\n        vec2 Lp = vec2(0.0, 0.3 + 1.5 * ( J - 0.5));\n\t\tfloat L = Layer(UV + Lp, Lt);\n\n\t\t// Blur and color:\n\t\tfloat Blur = 1.0 * abs(2.0 - 5.0 * J) / (11.0 - 5.0 * J);\n\n\t\tfloat V = step(0.0, 1.0) * mix(0.0, 1.0, 1.0 - smoothstep(0.0, 0.01 + 0.2 * Blur, L));\n\t\tvec3 Lc=  mix( CloudColor, vec3(1.0), J);\n\n\t\tColor = mix(Color, vec3(1.0), V);\n\t}\n\n\tfragColor = vec4(Color, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGSWy.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[514, 514, 536, 536, 607], [610, 610, 633, 633, 686], [689, 689, 721, 721, 1265], [1269, 1269, 1326, 1337, 1977]], "test": "untested"}
{"id": "dsKXz3", "name": "anisotropic kuwahara filtering", "author": "aaaaaa123456", "description": "i think there are some issues with this implementation but i'm fairly happy with it (not optimized in the slightest)", "tags": ["kuwaharafiltering"], "likes": 1, "viewed": 262, "published": 3, "date": "1681498832", "time_retrieved": "2024-07-30T18:00:36.888950", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel1, uv).xyz ,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst int kernelSize = 5;\nconst float[kernelSize] kernel = float[kernelSize](0.3829, 0.2417, 0.0606, 0.0060, 0.0002);\n\nmat2 calcSst(float ix, float iy) {\n    return mat2(\n        ix * ix, ix * iy,\n        ix * iy, iy * iy\n    );\n}\n\nvec3 dt(vec2 uv, vec2 t) {\n    return texture(iChannel3, uv - t).xyz - texture(iChannel3, uv + t).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Get the smooth structure tensor\n    vec3 k = vec3(1.0 / iResolution.x, 1.0 / iResolution.y, 0.0);\n    \n    // Discrete integral of the directional derivatives multiplied by a gaussian weighting function\n    vec3 swx, swy;\n    \n    for (int i = -kernelSize + 1; i < kernelSize; i ++) {\n        float w = kernel[abs(i)];\n        \n        swx += w * dt(uv - k.xz * float(i), k.xz);\n        swy += w * dt(uv - k.zy * float(i), k.zy);\n    }\n    \n    // Structure tensor!\n    mat2 sst = calcSst(swx.x, swy.x) + calcSst(swx.y, swy.y) + calcSst(swx.z, swy.z);\n    \n    // Now we get the anisotropy and orientation of this pixel from the smooth structure tensor\n    // First we get the eigenvalues\n    float mean = (sst[0][0] + sst[1][1]) * 0.5;\n    float p = sqrt(mean * mean - determinant(sst));\n    \n    float a1 = mean + p;\n    float a2 = mean - p;\n    \n    float anisotropy = (a1 - a2) / (a1 + a2);\n    \n    // This is just a guess but the anisotropy seems to be inverted? maybe this means i have a bigger issue\n    anisotropy = max(0.0, 1.0 - anisotropy);\n    \n    // Orientation\n    float ox = 1.0 * sign(a2);\n    float oy = sst[0][1] / (a2 - sst[1][1]);\n    vec2 orientation = normalize(vec2(ox, oy));\n    \n    // Final buffer for the effect\n    fragColor = vec4(orientation.x, orientation.y, anisotropy, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nmat2 R(float theta) {\n    return mat2(\n        cos(theta), -sin(theta),\n        sin(theta), cos(theta)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 ba = texture(iChannel0, uv);\n    \n    // Fetch previously computed values\n    vec2 orientation = ba.xy;\n    float anisotropy = ba.z;\n    \n    float phi = atan(orientation.y / orientation.x);\n    \n    float a = ((alpha + anisotropy) / alpha) * (radius / pixelSize.x);\n    float b = (alpha / (alpha + anisotropy)) * (radius / pixelSize.y);\n    \n    mat2 S = mat2(\n        1.0 / a, 0.0,\n        0.0, 1.0 / b\n    ) * R(-phi);\n    \n    mat2 transform = S * R(-phi);\n    float zeta = 2.0 / radius;\n    float gamma = (2.0 * PI) / float(sectors);\n    float eta = (zeta + cos(gamma)) / (sin(gamma) * sin(gamma));\n    \n    vec4 m[sectors];\n    vec3 s[sectors];\n    \n    for (int i = 0; i < sectors; i ++) {\n        m[i] = vec4(0.0);\n        s[i] = vec3(0.0);\n    }\n    \n    // Get the bounding box\n    for (float dx = -radius; dx <= radius; dx += pixelSize.x) {\n        for (float dy = -radius; dy <= radius; dy += pixelSize.y) {\n            vec3 c = texture(iChannel3, uv + vec2(dx, dy)).rgb;\n            \n            for (int i = 0; i < sectors; ++ i) {\n                vec2 p = vec2(dx, dy) / pixelSize;\n                p *= S * R((-2.0 * PI * float(i)) / float(sectors));\n            \n                float k0 = step(eta * p.y * p.y, p.x) * ((p.x + zeta) - eta * p.y * p.y);\n                // k0 is the weighting for this pixel\n                // Now we add this sector\n                m[i] += vec4(c * k0, k0);\n                s[i] += c * c * k0;\n            }\n        }\n    }\n    \n    // Yippee\n    vec4 o = vec4(0.0);\n    for (int i = 0; i < sectors; i ++) {\n        m[i].rgb /= m[i].w;\n        s[i] = abs(s[i] / m[i].w - m[i].rgb * m[i].rgb);\n        \n        float sigma2 = s[i].r + s[i].g + s[i].b;\n        float w = 1.0 / (1.0 + pow(255.0 * sigma2, 0.5 * q));\n        \n        o += vec4(m[i].rgb * w, w);\n    }\n    \n    fragColor = vec4(o.rgb / o.w, 1.0);\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float alpha = 1.0;\nconst float radius = 0.03;\nconst int sectors = 8;\nconst float q = 15.0;\n\nconst float PI = 3.1415;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 318]], "test": "untested"}
{"id": "csGSWG", "name": "Solme AVIX for Windows Terminal", "author": "mrange", "description": "Solme AVIX for Windows Terminal\nDid this for a friend's company\n\nAvailable in windows terminal shader gallery: https://mrange.github.io/windows-terminal-shader-gallery/", "tags": ["2d"], "likes": 1, "viewed": 165, "published": 3, "date": "1681492364", "time_retrieved": "2024-07-30T18:00:37.747654", "image_code": "// Solme AVIX for Windows Terminal\n//  Did this for a friend's company\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rot45 = ROT(radians(45.0));\nconst vec3 dim = vec3(0.675, -0.025, 0.012);\n\nvec2 off(float n) {\n//  return vec2(-(1.5-n)*dim.x-dim.y, 0.0);\n  return 0.5*sin(vec2(1.0, sqrt(0.5))*(TIME-1.25*n));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: CC0, author: Mrten Rnge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat segmentx(vec2 p, float off) {\n  p.x -= off;\n  float d0 = length(p);\n  float d1 = abs(p.y);\n  return p.x > 0.0 ? d0 : d1;\n}\n\nvec2 dBox(vec2 p) {\n  p *= rot45;\n  const float roff = 0.065;\n  float d = box(p, vec2(0.25-roff));\n  float dd = d-0.18;\n  d -= 0.0275+roff;\n  d = abs(d);\n  d -= dim.z;\n  return vec2(d, dd);\n}\n\nvec2 dA(vec2 p) {\n  p -= off(0.0);\n  vec2 p0 = p;\n  vec2 d0 = dBox(p0);\n  vec2 p1 = p;\n  const mat2 rot1 = ROT(radians(-62.0));\n  p1.x = pabs(p1.x, dim.z*1.5);\n  p1.x -= 0.095;\n  p1.y += 0.075;\n  p1 *= rot1;\n  float d1 = segmentx(p1, 0.03)-dim.z;\n  vec2 p2 = p;\n  p2.y -= -0.03;\n  p2.x = abs(p2.x);\n  float d2 = segmentx(p2, 0.07)-dim.z;\n  float d = d0.x;\n  d = min(d, d1);\n  d = min(d, d2);\n  return vec2(d, d0.y);\n}\n\nvec2 dV(vec2 p) {\n  p -= off(1.0);\n  vec2 p0 = p;\n  vec2 d0 = dBox(p0);\n  vec2 p1 = p;\n  const mat2 rot1 = ROT(radians(62.0));\n  p1.x = pabs(p1.x, dim.z*1.5);\n  p1.x -= 0.095;\n  p1.y -= 0.075;\n  p1 *= rot1;\n  float d1 = segmentx(p1, 0.03)-dim.z;\n  float d = d0.x;\n  d = min(d, d1);\n  return vec2(d, d0.y);\n}\n\nvec2 dI(vec2 p) {\n  p -= off(2.0);\n  vec2 p0 = p;\n  vec2 d0 = dBox(p0);\n  vec2 p1 = p;\n  p1.y = abs(p1.y);\n  p1 = p1.yx;\n  float d1 = segmentx(p1, 0.10)-dim.z;\n  float d = d0.x;\n  d = min(d, d1);\n  return vec2(d, d0.y);\n}\n\nvec2 dX(vec2 p) {\n  p -= off(3.0);\n  vec2 p0 = p;\n  vec2 d0 = dBox(p0);\n  vec2 p1 = p;\n  p1 = abs(p1);\n  p1 *= rot45;\n  float d1 = segmentx(p1, 0.145)-dim.z;\n  float d = d0.x;\n  d = min(d, d1);\n  return vec2(d, d0.y);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 4.0/RESOLUTION.y;\n  \n  vec2 dA = dA(p);\n  vec2 dV = dV(p);\n  vec2 dI = dI(p);\n  vec2 dX = dX(p);\n\n  float d = dX.x;\n  d = pmax(d, -dI.y, dim.z);\n  d = min(d, dI.x);\n  d = pmax(d, -dV.y, dim.z);\n  d = min(d, dV.x);\n  d = pmax(d, -dA.y, dim.z);\n  d = min(d, dA.x);\n\n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, d));\n  col = sqrt(col);\n  return col;\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 353, 397, 453], [455, 555, 594, 594, 679], [681, 769, 808, 808, 837], [839, 927, 957, 957, 985], [987, 1105, 1132, 1132, 1208], [1210, 1210, 1245, 1245, 1338], [1340, 1340, 1359, 1359, 1531], [1533, 1533, 1550, 1550, 1950], [1952, 1952, 1969, 1969, 2259], [2261, 2261, 2278, 2278, 2482], [2484, 2484, 2501, 2501, 2703], [2705, 2705, 2726, 2726, 3117], [3119, 3119, 3176, 3176, 3329]], "test": "untested"}
{"id": "DsVSzd", "name": "Analytical plotting", "author": "robobo1221", "description": "A analytical way to plot a curve instead of subdividing the plot. Uses derivatives of the function", "tags": ["graph", "plot"], "likes": 1, "viewed": 183, "published": 3, "date": "1681475125", "time_retrieved": "2024-07-30T18:00:38.606358", "image_code": "const float eps = 0.001;\n\nconst float a = 0.0025;\nfloat s = 7.0;\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat f(float x) {\n    return sin(2.0 * x);\n}\n\nfloat df(float x) {\n    float f1 = f(x + eps);\n    float f2 = f(x - eps);\n    return (f1 - f2) / (2.0 * eps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.x;\n    \n    float x = (uv.x - 0.5) * s;\n    float y = (uv.y - 0.25) * s;\n    \n    float fx = f(x);\n    float dx = df(x);\n    \n    // Simplified normal direction grad = abs(dot(normalize(vec2(dx, dy)), vec2(0, 1)))\n    // = grad = abs(dot(vec2(dx, dy) / sqrt(dx * dx + dy * dy), vec2(0.0, 1.0)))\n    // = grad = abs(dy / sqrt(dx * dx + dy * dy))\n    // dy in this case is always 1.0 so:\n    // grad = 1.0 / sqrt(dx * dx + 1.0)\n    float t = sqrt(dx * dx + 1.0);\n    float thickness = a * s * t;\n\n    vec3 color = vec3(smoothstep(thickness, thickness * 0.5, abs(y - fx)));\n    \n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(a * s, a * s * 0.5, abs(y)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(a * s, a * s * 0.5, abs(x)));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 105, 105, 172], [174, 174, 192, 192, 219], [221, 221, 240, 240, 332], [334, 334, 391, 391, 1211]], "test": "untested"}
{"id": "cdKSRK", "name": "[Revision 2023] Voyager: the 6th", "author": "totetmatt", "description": "4k exe gfx (16/22)\nSo yeah, no fancy Sub surface scattering  or volumetric stuff that I have no clue what it is.\nTrick is like photography long exposure, the central platnet and ring are running and it's accumulating. Then by adding some shadow and bump.", "tags": ["revision"], "likes": 24, "viewed": 564, "published": 3, "date": "1681463173", "time_retrieved": "2024-07-30T18:00:39.476033", "image_code": "\n/*\nInspiration https://youtu.be/Yht48rTHwAU?t=1372\n\nGreetings to all the folks that are inspiring to me, help me and keep me hooked to the scene !\n\nFlopine, Nusan, Evvvvil, z0rg, cosa, yx, blackle, 0b5vr, ps, jeenio, alien, zavie, alkama, aldroid, kamoshika\nthe entire Rev 2023 French Corner, The PT folks, the JP scene, The lovebyte crazy sceners, Ghostclub awesome VTubers\n\nand all the other I forgot !\n\n\n*/\n\n/* \n\n \nBase is actually from this shader https://www.shadertoy.com/view/fsyGDw\n\nFrom comments I saw:\n- Yes it's not a scientific representation of Saturn\n- The missing moons are behind the planet that's why they are not shown\n\n\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    fragColor /= fragColor.a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n/*\n\nGreetings to all the folks that are inspiring to me, help me and keep me hooked to the scene !\n\nFlopine, Nusan, Evvvvil, z0rg, cosa, yx, blackle, 0b5vr, ps, jeenio, alien, zavie, alkama, aldroid, kamoshika\nthe entire Rev 2023 French Corner, The PT folks, the JP scene, The lovebyte crazy sceners, Ghostclub awesome VTubers\n\nand all the other I forgot !\n\n\n*/\n\n/* \n\nBase is actually from this shader https://www.shadertoy.com/view/fsyGDw\n\nFrom comments I saw:\n- Yes it's not a scientific representation of Saturn\n- The missing moons are behind the planet that's why they are not shown\n\n\n\n*/\n\n\n \nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(49.3, 69.51))) * 4420.1234);\n}\n\nfloat diam(vec3 p,float s){\n     p = abs(p);\n     return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\nvec2 sdf(vec3 p){\nvec3 op=p;\np.xz*=rot(.7+fract(hash())*.1);\np.yz*=rot(.2);\n\n    p.xz*=rot(float(iFrame)*.01+fract(hash()));\n    vec2 h;\n    h.x = 1000.+length(p)-1.;\n    vec4 pp = vec4(p,1.);\n    float s = 0.;\n    for(float i=0.;i<=11.;i++){\n        pp.xyz = abs(pp.xyz)-4.95;;\n        pp*=1.7;\n        pp.xz*=rot(.785+i);\n        pp.xy*=rot(-.785+i);\n        float q = (diam(pp.xyz,1.95))/pp.a;\n        h.x = mod(i,2.)==0. ? mix(q,h.x,0.75): min(q,h.x);\n        s+=clamp(cos(pp.y)+sin(pp.x),0.,1.);\n    }\n    s/=pp.a*1.8;\n    float qq = abs(length(p.xz)-2.5)-.75;\n    qq = max(abs(p.y)-.05+dot(sin(op.xz*2.+float(iFrame)),cos(op.zx*3.))*.05,qq);\n    h.x = max(qq,h.x);\n        h.x = min(h.x, length(op-vec3(1.,-.1,-.5))-.05);\n        h.x = min(h.x, length(op-vec3(-1.9,.2,2.5))-.02-s);\n        h.x = min(h.x, length(op-vec3(2.5,1.1,2.5))-.07-s);\n         h.x = min(h.x, length(op-vec3(2.0,0.15,-1.7))-.1+s);\n           h.x = min(h.x, length(op-vec3(-2.0,0.0,.5))-.1+s);\n    h.x = min(length(p)-1.-s,h.x);\n\n    h.y = 1.;\n    return h;\n}\nvec3 qo(vec3 s, vec3 p){ return s*sdf(p+s).x;}\n\nvec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee); return normalize(qo(e.xyy,p)+qo(e.yxy,p)+qo(e.yyx,p)+qo(e.xxx,p));}\n\n\n// hash functions adapted from Devour\n// https://www.shadertoy.com/view/3llSzM\n\nvec2 hash2(){return vec2(hash(),hash());}\nfloat ao(vec3 rp, vec3 n, float k){return clamp(sdf(rp+n*k).x/k,.0,1.) ;}\nfloat gao(vec3 rp,vec3 n){ return (ao(rp,n,.1)+ao(rp,n,1.5)+ao(rp,n,2.7) );  }\nvec3 pal(float q, float t){return vec3(q,0.5,.5)+vec3(.5,.2,.5)*cos(6.28*(1.*t+vec3(.0,.5,.9)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tseed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=.5;\n        vec4 pframe = vec4(texture(iChannel0,fragCoord.xy/iResolution.xy));\n        fragColor = pframe;\n  if(rand(float(iFrame)*uv) <= .5f) discard;\n    // Time varying pixel color\n vec3 ro = vec3(0.1,0.1,-5.);\n    vec3 rp = ro;\n    vec3 rd = normalize(vec3(uv,1.-.7*sqrt(length(uv))));\n\n    vec3 col = vec3(.0);\n    vec3 light = vec3(20.,5.,3.);\n    for(float i=0.;i<=99.;i++){\n        vec2 d = sdf(rp);\n           rp+=rd*d.x;\n        if(d.x <=.001){\n            vec3 n = norm(rp,.0003);\n            float diff =max(0.,dot(normalize(light),n));\n            float spc = pow(max(0.,dot(rd,reflect(-normalize(light),n))),8.);\n            col = vec3(1.+fract(hash()))*diff+spc*20.;\n            col = mix(vec3(.01),col,gao(rp,n)/3.);\n            break;\n        }\n    }\n    \n    rd = normalize(light-rp);\n    rp+=rd*.002;\n    float mm=10.;\n    for(float i=0.;i<=99.;i++){\n        vec2 d = sdf(rp);\n    \n        mm=min(distance(rp,light),mm);\n            if(d.x < .0001){ col*=0.;break;}\n         d.x = abs(d.x);\n          rp+=rd*d.x;\n        if(d.x <=.001){\n            col*=.5;\n            \n        } \n\n      \n    \n    }\n    if(mm >1.1){\n            col*=.7;\n    } else {\n        col*=10.;\n    }\n\n\n\tcol =(col+pframe.xyz/float(iFrame));\n   \n    //Output to screen\n   fragColor.rgb += col; \n    fragColor.a ++;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 797]], "test": "untested"}
{"id": "mdyXRd", "name": "saddinger_projected", "author": "graygoose", "description": "click, hold and move mouse to rotate.", "tags": ["fractal", "simple"], "likes": 2, "viewed": 90, "published": 3, "date": "1681449282", "time_retrieved": "2024-07-30T18:00:40.385601", "image_code": "// Fork of \"newtons_fract_simple\" by graygoose. https://shadertoy.com/view/sdKBDw\n// 2023-04-14 05:14:18\n\n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define MAX_ITERS 300.\n#define SPHERE_EPS .00000005\n\nvec3 sphereMapping(vec3 dir) {\n  float t_off = 0.01*cos(iTime*0.15);\n  vec2 uv = vec2(atan(dir.z, dir.x-t_off), asin(dir.y));\n  uv /= TAU;\n  uv += .5;\n  \n  float t = iTime * 0.1;\n  vec2 c = vec2(-cos(t) * cos(t), sin(t) * cos(t));\n\n  vec2 z = vec2(0.0, 0.0);\n  float iter;\n  for (iter=0.; iter < MAX_ITERS; iter++) {\n    vec2 newZ = dot(z, z) + c;\n    if (dot(newZ, newZ) > 4.0) break;\n    z = newZ;\n  }\n\n  float displacement = iter / float(MAX_ITERS);\n  vec3 normal = normalize(dir);\n  vec3 perturbation = displacement * normal;\n  \n  float maxDisplacement = .01 * length(normal);\n  perturbation *= min(0.0, maxDisplacement / length(perturbation));\n  \n  return texture(iChannel0, uv).rgb + perturbation;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec2 z = ( 2.0 * U - iResolution.xy ) / iResolution.y;\n  \n  float t = iTime * 0.5;\n  \n  vec3 rayDir = normalize(vec3(z, -1.0));\n  vec3 rayPos = vec3(0.0, 0.0, 1.25);\n  \n\n  float dist = 0.0;\n  vec3 color = vec3(0.0);\n  for (int i = 0; i < 100; i++) {\n    vec3 pos = rayPos + dist * rayDir;\n    vec3 normal = normalize(pos);\n    float d = length(pos) - 1.0 + 0.2 * length(sphereMapping(normal));    \n    if (d < SPHERE_EPS) {\n      color = sphereMapping(normal);\n    }\n    dist += d;\n    if (dist > 10.0) break;\n  }\n\n  O = vec4(5.*color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// physics constants\n#define K .1\n\n// shadertoy common\n#define R iResolution.xy\n#define UV (U / R)\n#define A(U) texture(iChannel0, UV)\n#define B(U) texture(iChannel1, UV)\n#define C(U) texture(iChannel2, UV)\n#define D(U) texture(iChannel3, UV)\n\n// math\nvec2 wrap(in vec2 p, in vec2 res) {\n    vec2 wrapped = mod(p, res);\n    wrapped += step(wrapped, vec2(0.0)) * res;\n    return wrapped;\n}\n\n\n\nvec4 lap(in sampler2D c, in vec2 p, in vec2 r) {\n    vec4 sum = vec4(0.0);\n\n    sum += texelFetch(c, ivec2(wrap(p + vec2(0, -1), r)), 0);\n    sum += texelFetch(c, ivec2(wrap(p + vec2(-1, 0), r)), 0);\n    sum -= 4.0 * texelFetch(c, ivec2(wrap(p + vec2(0, 0), r)), 0);\n    sum += texelFetch(c, ivec2(wrap(p + vec2(1, 0), r)), 0);\n    sum += texelFetch(c, ivec2(wrap(p + vec2(0, 1), r)), 0);\n\n    return sum;\n}\n\nvec2 sob(in sampler2D tex, in vec2 uv, in vec2 resolution) {\n    mat3 kernelX = mat3(-1, 0, 1, -2, 0, 2, -1, 0, 1);\n    mat3 kernelY = mat3(-1, -2, -1, 0, 0, 0, 1, 2, 1);\n    float stepX = 1.0 / resolution.x;\n    float stepY = 1.0 / resolution.y;\n    mat3 sampleX, sampleY;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            vec2 offset = vec2(float(i - 1) * stepX, float(j - 1) * stepY);\n            vec2 s = texture(tex, uv + offset).xy;\n            sampleX[i][j] = s.x;\n            sampleY[i][j] = s.y;\n        }\n    }\n    vec2 gradient;\n    gradient.x = dot(sampleX[0], kernelX[0]) + dot(sampleX[1], kernelX[1]) + dot(sampleX[2], kernelX[2]);\n    gradient.y = dot(sampleY[0], kernelY[0]) + dot(sampleY[1], kernelY[1]) + dot(sampleY[2], kernelY[2]);\n    return normalize(gradient);\n}\n#define NROOTS 3\nvec2 roots[NROOTS];\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\n\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.753,0.380,0.796,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}", "buffer_a_code": "void mainImage(out vec4 Q, in vec2 U) {\n    vec4 wave = texture(iChannel0, U / R.xy);\n    vec2 waveReal = vec2(wave.x, wave.y);\n    vec2 waveImag = vec2(wave.z, wave.w);\n\n    if (iFrame < 1) {\n        wave = vec4(0.);\n        wave.zw = vec2(0.5);\n        wave.xy = vec2(0.5 * cos(0.1 * length(U - 0.5 * R.xy)), 0.5 * sin(0.1 * length(U - 0.5 * R.xy)));\n    }\n\n\n    vec4 L = lap(iChannel0, U, R) - wave;\n\n    vec4 dwave = vec4(\n        (wave.z + L.x),\n        (wave.x + L.y),\n        (wave.y + L.z),\n        (wave.w + L.w)\n     );\n    wave -= K * normalize(dwave);\n\n\n\n    // Normalize wave\n    float mag = length(wave);\n    wave /= mag;\n\n    // Update buffer\n    Q = normalize(wave) * .5;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 C1 = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    vec4 L0 = filter3x3(fragCoord.xy, LAPLACIAN, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n    vec4 G0 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel0, iResolution.xy);\n\n    fragColor = C0 + G1 * G1;\n    fragColor *= -L0;\n\n    fragColor -= 0.1* .45*(C0+G0) + .34*(G1+C1); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 244, 244, 919], [921, 921, 960, 960, 1506]], "test": "untested"}
{"id": "dsGXRd", "name": "Tile mosaic morph", "author": "jarble", "description": "An animated mosaic tile pattern.", "tags": ["mosaic"], "likes": 4, "viewed": 167, "published": 3, "date": "1681446918", "time_retrieved": "2024-07-30T18:00:41.255276", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord)/iResolution.y*4.;\n    uv.y += iTime/2.;\n    vec3 col = vec3(0);\n    vec2 offset = vec2(0.),\n    uv1 = uv;\n    for(int k = 0; k < 5; k++){\n        uv =\n            abs(fract(uv.yx+floor(uv1.y+floor(uv.y))/pow(2.,mod(floor(uv.x-iTime/2.),3.)))-.5)\n            //abs(fract(uv.yx+floor(uv1.y+floor(uv.y*8.)/8.)/8.)-.5)\n            //abs(fract(uv.yx+sign(uv.y-uv.x)*floor(uv1.y+floor(uv.y))/8.)-.5)\n        ;\n        if(uv.y < uv.x) col =\n            //vec3(col.yz,abs(min(uv.x,uv.y)))\n            vec3(col.yz,abs(max(uv.x,uv.y)))\n        ;\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 702]], "test": "untested"}
{"id": "ddGSRd", "name": "JuliaEllo", "author": "elloskelling", "description": "It's a fractal tunnel, by way of a Julia-type set and some conformal maps.\n\n Best viewed in full screen", "tags": ["fractal", "zoom", "mobius"], "likes": 1, "viewed": 206, "published": 3, "date": "1681440269", "time_retrieved": "2024-07-30T18:00:42.104006", "image_code": "//from https://www.shadertoy.com/view/4lcGWf\n\n#define AUDIO\n\nconst float PI = 3.14159265359;\nconst vec2 CA = vec2(-0.200,-0.380);\nconst vec2 CB = vec2(-0.610,0.635);\nvec2 CC = vec2(-0.440,0.170);\nconst vec2 CD = vec2(0.170,-0.10); \nconst float C=1.5; \nconst float C2=23.7; \nconst vec3 Color = vec3(0.450,0.513,1.000);\nconst float Speed = 2.;\n#ifdef AUDIO\nfloat iAudio = 0.;\n#else\nconst float iAudio = .15;\n#endif\n\n// Complex functions\nvec2 cis(in float a){ return vec2(cos(a), sin(a));}\nvec2 cMul(in vec2 a, in vec2 b) { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y * b.x);}\nvec2 cDiv(in vec2 a, in vec2 b) { return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / (b.x*b.x+b.y*b.y); }\nvec2 cLog(in vec2 a){ return vec2(log(length(a)),atan(a.y,a.x)); }\nvoid fill(inout float[9] k){for( int i=0;i<8;i++) { k[i] = 0.;} }\n// Elliptic J function calculation ported from d3\n// https://github.com/d3/d3-geo-projection/blob/master/src/elliptic.js\nvec4 ellipticJ(float u, float m){\n    float ai, b=sqrt(1.-m), phi, t, twon=1.;\n    float a[9],c[9];\n    fill(a); fill(c);\n\ta[0] = 1.; c[0] = sqrt(m);\n    int i=0;\n    for (int j=1;j<8;j++){\n        if ((c[j-1] / a[j-1]) > 0.1) {\n            i++;\n            ai = a[j-1];\n            c[j] = (ai - b) * .5;\n            a[j] = (ai + b) * .5;\n            b = sqrt(ai * b);\n            twon *= 2.;\n        }\n    }\n    for (int j=8;j>0;j--){\n        if (j == i) phi = twon * a[j] * u;\n        if (j <= i){\n            t = c[j] * sin(b = phi) / a[j];\n            phi = (asin(t) + phi) / 2.;\n        }\n    }\n    return vec4(sin(phi), t = cos(phi), t / cos(phi - b), phi);\n}\n// Jacobi's cn tiles the plane with a sphere \nvec2 cn(vec2 z, float m) {\n    vec4 a = ellipticJ(z.x, m), b = ellipticJ(z.y, 1. - m);\n    return vec2(a[1] * b[1] , -a[0] * a[2] * b[0] * b[2] )/ (b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0]);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 domain(vec2 z){\n    return vec3(hsv2rgb(vec3(atan(z.y,z.x)/PI*8.+1.224,1.,1.)));\n}\n// A Julia fractal, but with a Mobius transformation instead of a translation\nvec3 M(vec2 z,vec2 c){\n    vec3 mean;\n    float ci;\n    int k=0;\n\tvec3 color;\n    for ( int i=0; i<50;i++){\n        z = cMul(z,z);\n        z = cDiv(cMul(CA,z)+CB+cis(iTime)*iAudio,cMul(z,CC)+CD);          \n        if (i < 3) continue;\n\t \tmean += length(z);\n        float amount = pow(7./float(i),2.608);\n        color = (1.-amount)*color+amount*length(z)*domain(z);\n        k++;\n    }\n\tmean /= float(k-3);\n    // Hacky color time!\n\tci =  log2(C2*log2(length(mean/C)));\n\tci = max(0.,ci);\n    vec3 color2 = .5+.5*cos(ci + Color)+.3;\n\tcolor = color2*(color);\n    \n    return color;\n}\nvec3 color(vec2 z){\n    z = cLog(z) * 1.179;\n    z.x -= mod(iTime/float(Speed),1.)*3.7;\n    z *= mat2(1,-1,1,1);\n    z = cn(z,0.5);\n    return M(z,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef AUDIO\n    iAudio = texture(iChannel0, vec2(0.1, 0.)).r;\n    iAudio = pow(iAudio,4.);\n\t#endif\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\tfragColor = vec4(color(uv),1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGSRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 435, 456, 456, 486], [487, 487, 520, 520, 575], [576, 576, 609, 609, 682], [683, 683, 704, 704, 749], [816, 937, 970, 970, 1602], [1603, 1649, 1675, 1675, 1844], [1846, 1846, 1868, 1868, 2037], [2038, 2038, 2058, 2058, 2125], [2126, 2204, 2226, 2226, 2784], [2785, 2785, 2804, 2804, 2937], [2939, 2939, 2996, 2996, 3201]], "test": "untested"}
{"id": "msyXzt", "name": "KaleidoEllo", "author": "elloskelling", "description": "Kaleidoscope fractal tunnel. Use mouse to look around.", "tags": ["fractal"], "likes": 2, "viewed": 183, "published": 3, "date": "1681440071", "time_retrieved": "2024-07-30T18:00:42.956727", "image_code": "// from https://www.shadertoy.com/view/XtcXWM\n\nfloat time() { return iTime; }\nvec2 resolution() { return iResolution.xy; }\n\nfloat hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\nfloat de(vec3 p) {\n\tvec3 op = p;\n\tp = fract(p + 0.5) - 0.5;\n\tp.xz *= rotate(3.14159);\n\tconst int it = 7;\n\tfor(int i = 0; i < it; i++) {\n\t\tp = abs(p);\n\t\tp.xz *= rotate(-0.1 + 0.1*sin(time()));\n\t\tp.xy *= rotate(0.3);\n\t\tp.yz *= rotate(0.0 + 0.2*cos(0.45*time()));\n\t\tp = 2.0*p - 1.0;\n\t}\n    \n    float c = length(op.xz - vec2(0, 0.1*time())) - 0.08;\n\t\n\treturn max(-c, (length(max(abs(p) - 1.3 + texture(iChannel0, vec2(0)).r, 0.0)))*exp2(-float(it)));\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001*t || t >= mx) break;\n\t\tt += d;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005;\n\tfor(int i= 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d);\n\t\ts += s/(float(i) + 1.0);\n\t}\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(1);\n\t\n\tfloat t = trace(ro, rd, 10.0);\n    if(t < 10.0) {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n        vec3 ref = normalize(reflect(rd, nor));\n\n        float occ = ao(pos, nor);\n        float dom = smoothstep(0.0, 0.3, trace(pos + nor*0.001, ref, 0.3));\n\n        col = 0.1*vec3(occ);\n        col += clamp(1.0 + dot(rd, nor), 0.0, 1.0)*mix(vec3(1), vec3(1.0, 0.3, 0.3), 1.0 - dom);\n\t\tcol *= vec3(7.0*abs(cos(20.0*pos.x)), 2.3*abs(sin(10.0*pos.z)), 3.0 + t);\t\n    }\n    \n    col = mix(col, vec3(10), 1.0 - exp(-0.16*t));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (-resolution() + 2.0*fragCoord.xy)/resolution().y;\n  \n\tfloat atime = 0.1*time();\n\tvec3 ro = vec3(0.0, 0.0, atime);    \n    vec3 la = vec3(vec2(0), atime + 1.0);\n    \n\tvec3 ww = normalize(la-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n    mat3 ca = mat3(uu, vv, ww);\n\tvec3 rd = normalize(ca*vec3(uv, 1.97));\n\t\n\tvec3 col = render(ro, rd);\n\t\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\tfragColor = vec4(col*0.9, 1);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 61, 61, 77], [78, 78, 97, 97, 122], [124, 124, 145, 145, 184], [186, 186, 208, 208, 277], [279, 279, 297, 297, 728], [730, 730, 771, 771, 908], [910, 910, 931, 931, 1101], [1295, 1295, 1326, 1326, 1901], [1903, 1903, 1960, 1960, 2454]], "test": "untested"}
{"id": "ddySzt", "name": "ElloFractunnel", "author": "elloskelling", "description": "A simple tunnel, based on my [url=https://www.shadertoy.com/view/wljyWR]\"swiss cheese caves\"[/url] fractal.", "tags": ["3d", "raymarching", "fractal"], "likes": 3, "viewed": 207, "published": 3, "date": "1681439541", "time_retrieved": "2024-07-30T18:00:43.773543", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n// and https://www.shadertoy.com/view/tl2yWR\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    return length(sin((p*(i+1.0)/size))*size) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n    \tresult += planet_surface(p*i,i)/(i*i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return -result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\n    float beat = 0.5*freqs[0]*freqs[0]\n                +0.5*freqs[1]*freqs[1];\n//                +0.25*freqs[2]*freqs[2]\n//                +0.25*freqs[3]*freqs[3];\n    beat = sqrt(beat);\n    \n    float highs = sqrt(0.5*(freqs[4]*freqs[4]+freqs[5]*freqs[5]));\n\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    //viewDir.xy *= rot(mix(iTime/5.0,iTime/5.0+0.5,beat));\n    viewDir.xy *= rot(iTime/5.0);\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*5.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir + beat/10.;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p))+beat/5.;\n    vec3 K_d = K_a+highs/5.;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddySzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[629, 629, 666, 666, 722], [724, 724, 759, 759, 987], [989, 989, 1012, 1012, 1039], [1041, 1041, 1069, 1069, 1199], [1202, 1623, 1714, 1714, 2020], [2035, 2289, 2354, 2354, 2486], [2488, 2577, 2606, 2606, 2916], [2918, 3410, 3550, 3550, 4160], [4162, 4532, 4617, 4617, 5032], [5034, 5361, 5410, 5445, 5576], [5578, 5578, 5635, 5635, 7286]], "test": "untested"}
{"id": "msVXRc", "name": "Year of Truchets #010", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 19, "viewed": 209, "published": 3, "date": "1681437256", "time_retrieved": "2024-07-30T18:00:44.622273", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #010\n    04/14/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI    3.14159265358\n#define PI2   6.28318530718\n#define SQ3   1.732\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\n\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), .0, 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n// @iq.\nfloat box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat time,ga1,ga2,ga3,ga4,tmod;\n\n// @Shane\nvec4 hexGrid(vec2 uv, float scale) {\n    uv*=scale;\n    const vec2 s = vec2(SQ3, 1.);\n    vec4 hC = floor(vec4(uv, uv - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h4 = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n    return dot(h4.xy, h4.xy) < dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n}\n\n// globals and constants\nmat2 r60,turn,twist;\nvec2 gid,sid;  \nvec3 hp, hit;\nvec4 hexTiles = vec4(0);\nfloat thrs=.15,xln,tm,bgf=0.;\n\nconst float scale = .255;\nconst float sx = SQ3/scale;\nconst float s4 = .577350;\nconst float s3 = .288683;\nconst float amt = 9.;\n\nvec2 map(vec3 pos, float sg) {\n\n    vec2 res =vec2(1e5,0.);\n\n    // scale and grid motion\n    pos.z  *= scale;\n    pos.xy *= rot(ga3*-1.5707);\n    pos.x  += ga2*sx;\n    \n    hexTiles=hexGrid(pos.xy,scale);\n    vec2 p  = hexTiles.xy;\n    vec2 id = hexTiles.zw;\n\n    float rnd = hash21(id);\n    float dir = 1.;\n\n    if (rnd>.5) {\n        p *= r60;\n        p.y=-p.y;\n        dir = -1.;\n    } \n    \n    // set vectors\n    vec2 p0 = p - vec2(-s3, .5);\n    vec2 p1 = p - vec2(s4,  0);\n    vec2 p2 = p - vec2(-s3,-.5);\n    \n    vec2 da = vec2(0);\n    \n    // find closest points\n    vec3 a3 = vec3(atan(p0.x, p0.y),atan(p1.x, p1.y),atan(p2.x, p2.y));\n    vec3 d3 = vec3(length(p0), length(p1), length(p2));\n    vec2 pp = vec2(0);\n\n    if (d3.x>d3.y) {\n        pp = p1;\n        da = vec2(d3.y, a3.y);\n    }\n    if (d3.y>d3.z) {\n        pp = p2;\n        da = vec2(d3.z, a3.z);\n    }\n    if (d3.z>d3.x && d3.y>d3.x) {\n        pp = p0;\n        da = vec2(d3.x, a3.x);\n    }\n    \n    const float zset = .35;\n    vec3 dp = vec3(pp,pos.z+zset);\n    float ft = .02+.01*sin(pos.x*.415);\n    float tx = torus(dp,vec2(s3,ft));\n    float ff = .11+.1*sin(pos.x*.213+T);\n    float tp = torus(dp+vec3(0,0,3.5),vec2(s3,ff));\n\n    float d = length(pp);\n    float pathMotion = da.y / PI2 * amt + (time*.65);\n    float x =fract(pathMotion) - .5;\n    float y = d-s3;\n\n    //fix id's for each ball\n    vec2 cid = vec2(\n       floor(d),\n       floor(pathMotion)-.5\n    );\n\n    cid = mod(cid,3.);\n        \n    vec3 tu = vec3(vec2(x*.25,y),pos.z+zset);\n    vec3 ty = tu, du = tu;\n    \n    float balls=length(ty)-.095;\n    twist = rot(cid.y*PI+T*dir);\n    tu.zy *= twist;\n    du.zy *= rot(cid.y*PI-T*dir);\n    \n    float boxs = box(tu,vec3(.075))-.002;\n    boxs = max(boxs,-balls);\n\n    if (boxs<res.x && cid.y<1.) {\n        res = vec2(boxs*.8,4.);\n        hp = tu;\n    }\n\n    balls = box(du,vec3(.025,.0075,.065))-.002;\n    \n    if(balls<res.x && cid.y>2.) {\n        res = vec2(balls,3.);\n        hp = ty;\n    }\n    \n    if (tx<res.x) {\n        res = vec2(tx,1.);\n        hp = dp;\n    }\n    \n    if (tp<res.x) {\n        res = vec2(tp,2.);\n        hp = dp;\n    } \n    \n    float fx = pos.z+4.5;\n    if (fx<res.x && bgf==1.) {\n        res = vec2(fx,9.);\n        hp = pos;\n    }\n    \n    // rescale\n    res.x *= 1./scale;\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = 1e-3*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d,0.);\n        if(ray.x<1e-4*d||d>40.) break;\n        d += i<32?ray.x*.3:ray.x*.95;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n.zy*=twist;//??maybe\n    n = max(abs(n), 1e-4);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec4 FC = vec4(.075);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100);\n    hit = hp;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<40.)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(10.,15.,25.);\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hit;\n \n        float diff = clamp(dot(n,l),.1,.95);\n\n        if (m==1.) { h = vec3(.05); ref=vec3(.0); }\n        if (m==2.) { h = vec3(0.502,0.502,0.502); ref=h*.3; }\n        if (m==3.) { h = vec3(0.659,0.000,0.000); ref=h*.5; }\n        if (m==4.) { h = tex3D(iChannel2,hp*6.,n).rgb; ref=vec3(.1); }\n        if (m==9.) { \n            h = texture(iChannel2,hp.xy).rgb; \n            ref = h;\n            vec2 f = fract(hit.xy*.15)-.5;\n            if(f.x*f.y>0.) { h=vec3(.0);  }\n\n        }\n        \n        C = (diff*h);\n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r60 = rot(1.0471975512);\n    time = T*.75;\n    tmod = mod(time, 10.);\n    float t1 = lsp(0., 5., tmod);\n    float t2 = lsp(5., 10., tmod);\n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n    ga2 = ga1+floor(time*.1);\n    ga3 = eoc(t2);\n    ga3 = ga3*ga3*ga3;\n    ga3 = ga3+floor(time*.1);\n\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,6.75);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    \n    \n    float ttt = T*.5;\n    tm   = mod(ttt, 20.);\n    \n    float t3 = lsp(3.,  5., tm);\n    float t4 = lsp(13., 15., tm);\n    \n    ga4 = ((t3-t4)*2.2)-1.1;\n    xln = ga4-(.025*sin(uv.y*25.+T*5.));\n\n    if(uv.x>xln) {\n        ro = vec3(0,0,2.15);\n        FC.rgb = vec3(.095);\n        bgf=1.;\n    }\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.;\n    \n    float clip = length(uv)-.5;\n    \n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.0001*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    if(uv.x+.01>xln && uv.x-.01<xln)C=vec3(1);\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVXRc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[441, 441, 460, 460, 505], [506, 506, 528, 528, 584], [586, 586, 630, 630, 683], [684, 684, 704, 704, 740], [742, 750, 779, 779, 866], [868, 868, 899, 899, 964], [1000, 1010, 1046, 1046, 1310], [1573, 1573, 1603, 1603, 3877], [3879, 3879, 3909, 3909, 4156], [4158, 4158, 4201, 4201, 4424], [4426, 4484, 4531, 4531, 4757], [4781, 4781, 4875, 4875, 5839], [5841, 5841, 5882, 5882, 7168]], "test": "untested"}
{"id": "msVXzc", "name": "Colorful Aurora", "author": "TreW", "description": "Something I tinkered into making while watching a tutorial...\nLooks like a old wallpaper or something", "tags": ["2d"], "likes": 0, "viewed": 123, "published": 3, "date": "1681413024", "time_retrieved": "2024-07-30T18:00:45.449063", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 q = p - vec2(0.5,0.5);\n    \n    float r = 0.1 + 0.1*cos(q.x*100. + cos(sin(q.x) *iTime)*5.);\n    vec3 col = vec3( (sin(iTime)+0.3)*clamp(abs(0.5 - q.x), 0.1, 0.5),\n    clamp(cos(iTime+sin(q.x*q.y)),0.3,0.8) , \n    (cos(iTime)+0.3)*0.15+q.yx);\n    \n    col -= smoothstep(r, r+0.5,length(q));\n\n    // Output to screen\n    fragColor = vec4(col,1.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 454]], "test": "untested"}
{"id": "DdKSW1", "name": "new_droply", "author": "darkwolf007", "description": "water", "tags": ["water"], "likes": 5, "viewed": 128, "published": 3, "date": "1681396835", "time_retrieved": "2024-07-30T18:00:46.329708", "image_code": "vec4 getv(vec2 p) {\n\treturn texelFetch(iChannel0, ivec2(p), 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy ;\n    \n    \n  \tvec4 a = texture(iChannel0, uv);\n    vec3 dp = vec3(0.9, 0.9, 0)/iResolution.xyx;\n    vec4 b = texture(iChannel0, uv+dp.xz);\n    vec4 c = texture(iChannel0, uv+dp.zy);\n    float dx = a.x-b.x;\n    float dy = a.x-c.x;\n    vec3 normal = normalize(vec3(vec2(dx, dy), 1.0));\n    vec3 iray = normalize(vec3(fragCoord.xy-0.5*iResolution.xy, 1.2*iResolution.y));\n    vec3 d1 = refract(iray, normal, 1.3);\n   \n                      \n    vec4 im = texture(iChannel1, d1);\n    vec3 it = im.xyz;\n    float l = length(it);\n    it *= 1.5;\n    im.xyz = it;\n    \n\n   \tvec4 v = getv(fragCoord * 1.);\n    vec4 color = vec4(0.);\n    if (v.x < 0.01) {\n    \tcolor = mix(vec4(0., 0., 0., 1.), vec4(1., 0., 0., 1.), smoothstep(0.0, 0.03, v.x));\n    } else if (v.x < 0.1) {\n    \tcolor = mix(vec4(1., 0., 0., 1.), vec4(0., 1., 0., 1.), smoothstep(0.01, 0.1, v.x));\n    } else {\n        color = mix(vec4(0., 1., 0., 1.), vec4(0., 0., 1., 1.), smoothstep(0.1, 1.0, v.x));\n    }\n    \n    \n    fragColor = im;// +color;\n    //fragColor = color;\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float BIG_DROP_RATE = 0.01;\nconst float BIG_DROP_SIZE = 10.;\nconst float BIG_DROP_DEPTH = 0.2;\n\nconst float SMALL_DROP_RATE = 0.001;\nconst float SMALL_DROP_SIZE = 0.00003;\n\nconst int R = 4; // watter attraction radius\n\n\n//------------------------------\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#define hv(p) hash12((p * .152 + iTime * 1500. + 50.0))\n//----------------------------\n", "buffer_b_code": "//BUFFER B - calculate amount of water moving between neighbour cells\n\nvec4 getv(vec2 p) {\n\treturn texelFetch(iChannel0, ivec2(p), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame  == 0) {\n    \tfragColor = vec4(0.);\n    } else {\n        vec2 p = fragCoord;\n        float vp = getv(p).x;\n        vec4 dv = vec4(\n            getv(p + vec2(-1., 0.)).x,\n            getv(p + vec2(0., -1.)).x,\n            getv(p + vec2(1., 0.)).x,\n            getv(p + vec2(0., 1.)).x\n        );\n\n        \n        // atract to water in close area\n        vec2 fd = vec2(0.);\n        float size = vp;\n        for (int dy=-R; dy<=R; dy++){\n            for (int dx=-R; dx<=R; dx++) {\n                if (dx == 0 && dy == 0 || (dx * dx + dy * dy > R * R)) {\n                    continue;\n                }\n\n                float a = getv(p+vec2(dx, dy)).x;\n                size += a;\n                vec2 dir = vec2(dx, dy);\n                vec2 ndir = normalize(dir);\n                vec2 c= pow(a, 0.4)*0.25 * ndir / pow(length(dir),0.9);\n                if (a > 0.06) {\n                    c *= 2. + a*1.;\n                }\n                fd += c;\n            }\n        }\n        // add gravity with tweaks to make smaller droplets stick\n        vec2 down = vec2(0, -1.0)*2.0*vp;\n        if (vp > 0.06) {\n            down *= 1.+1.*pow(vp, 1.)+0.01*size;\n        } else {\n            down *= 0.01;\n        }\n        fd += down;\n\n        vec4 dif = max(vec4(vp)-dv, 0.); // spread to neighbours that have less water\n        if (p.x <= 1.) {\n            dv.x = 0.;\n        }\n        if (p.y <= 1.) {\n           dv.y = 0.;\n        }\n        dif *= 0.16;\n        if (vp < 0.01) {\n             dif *= 0.5;\n        }\n\n        vec4 fa = vec4(abs(min(fd.xy, 0.)), max(fd.xy, 0.)); //add force from attraction and gravity\n        dif += fa * 0.007;\n        dif *= 0.5;\n\n        // try to avoid going in to negative values or exceeding maximum\n        float sm = dot(dif, vec4(1.));\n        float red = sm == 0. ? 1.0 : min(vp, sm)/sm;\n        dif *= red;\n        dif = min(dif, vec4(1.)-dv);\n        fragColor = dif;\n    }\n}", "buffer_b_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// buffer D - store and update amount of water in each cell\n\nvec4 getv(vec2 p) {\n\treturn texelFetch(iChannel0, ivec2(p), 0);\n}\n\nvec4 getm(vec2 p) {\n\treturn texelFetch(iChannel1, ivec2(p), 0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        vec2 p = fragCoord;\n    \tvec4 v = getv(p);\n        if (length(p - iMouse.xy) < 12. && iMouse.z > 0.) {\n        \tv.x += 0.5;\n        }\n        \n        float sh = hv(p);\n        v.x += SMALL_DROP_SIZE * step(SMALL_DROP_RATE, sh) * sh;  // add little bit of water everywhere all the time\n        \n        if (hv(vec2(1, 0)) < fract(iTime) * BIG_DROP_RATE) { // once in a while add big drop somewhere in the picture\n        \tvec2 dp = vec2(hv(vec2(iTime, 0)), hv(vec2(0, 1)));\n\t\t\tdp *= iResolution.xy;\n            float size = hv(vec2(2, 0));\n\t\t\tif (distance(dp, p) < BIG_DROP_SIZE * mix(0.5, 1., size)) {\n                v.x += BIG_DROP_DEPTH;\n\t\t\t}\n        }\n        \n        vec4 moveOut = getm(p);\n        vec4 moveIn = vec4(\n        \tgetm(p + vec2(-1., 0.)).z,\n            getm(p + vec2(0., -1.)).w,\n            getm(p + vec2(1., 0.)).x,\n            getm(p + vec2(0., 1.)).y   \n        );\n        \n        v.x += 1.0*dot(vec4(1.), moveIn-moveOut);\n        \n        v = clamp(v, 0.0, 1.0);\n        if (p.y <= 1. || p.x < 1. || p.x > iResolution.x - 2. || p.y > iResolution.y - 2.) {\n            v.x = 0.;\n        }\n        fragColor = v;\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKSW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 65], [68, 68, 125, 125, 1197]], "test": "untested"}
{"id": "msyXR3", "name": "weird fluid sim type thing", "author": "oatmealine", "description": "I've had the idea to store colors in the blue channel and the velocity of pixels in the red and green channels (for X and Y, respectively) and while I ran into many issues I had not considered, I think it still came out well", "tags": ["2d", "simulation"], "likes": 1, "viewed": 312, "published": 3, "date": "1681373130", "time_retrieved": "2024-07-30T18:00:47.184423", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(float2rgb(texture(iChannel0, uv).b), 1.0);\n    //fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SEARCH_RANGE 10\n#define DAMPING 0.8\n#define SEARCH_WEIGHT 1.2\n\nfloat hash(vec2 p){\n  return fract(1e4*sin(17.*p.x+p.y*0.1)*(0.1+abs(sin(p.y*13.+p.x))));\n}\n\nfloat noise(vec2 x){\n  vec2 f = fract(x);\n  vec2 i = x-f;\n\tfloat a = hash(i);\n\tfloat b = hash(i+vec2(1.,0.));\n\tvec2 u = f*f*(3.-2.*f);\n\treturn mix(a,b,u.x)+((hash(i+vec2(0.,1.))-a)*(1.-u.x)+(hash(i+1.)-b)*u.x)*u.y;\n}\n\nfloat fbm(vec2 p){\n  float value = 0.;\n  float freq = 1.;\n  float amp = 0.5;\n  for (int i=0; i<5; i++) {\n    value += amp*(noise((p-1.)*freq));\n    freq *= 1.9;\n    amp *= 0.6;\n  }\n  return value;\n}\n\nvec3 noiseTimeBabey(vec2 uv) {\n    return vec3(\n        hash(uv + vec2(iTime, -iTime)),\n        hash(uv + vec2(iTime * 0.5, iTime)),\n        hash(uv + vec2(-iTime, -iTime))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (\n        iTime < 1.0 ||\n        (iMouse.z > 1.0 && abs(iMouse.x - fragCoord.x) < 32.0 && abs(iMouse.y - fragCoord.y) < 32.0)\n    ) {\n        fragColor = vec4(noiseTimeBabey(fragCoord.xy / iResolution.xy), 1.0);\n    } else {\n        vec2 thisUV = fragCoord / iResolution.xy;\n        float dt = iTimeDelta;\n        \n        // calculate Wind\n        float windAngle = fbm(vec2(thisUV.x + iTime * 0.3, thisUV.y - iTime * 0.3));\n        vec2 windVel = vec2(cos(windAngle * PI * 2.0), sin(windAngle * PI * 2.0)) * dt;\n        \n        // search in a range for potential collissions\n        vec3 accumCol = vec3(0.0, 0.0, 0.0);\n        vec2 accumVel = vec2(0.0, 0.0);\n        float accumWeight = 0.0;\n\n        for (int x = -SEARCH_RANGE; x <= SEARCH_RANGE; x++) {\n            for (int y = -SEARCH_RANGE; y <= SEARCH_RANGE; y++) {\n                vec2 uv = (fragCoord + vec2(float(x), float(y))) / iResolution.xy;\n                vec3 data;\n                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n                  data = noiseTimeBabey(uv);\n                } else {\n                  data = texture(iChannel1, uv).rgb;\n                }\n                \n                // extract data\n                vec2 vel = data.rg;\n                vec3 col = float2rgb(data.b);\n                \n                // predict next pos\n                vec2 pos = clamp(uv + vel * dt, 0.0, 1.0);\n                // dampen velocity\n                vel *= pow(DAMPING, dt);\n                \n                // calculate a \"weight\" of sorts of how much the pixel's new position\n                // would overlap with ours\n                float dist = length(pos - thisUV);\n                float weight = 1.0 - (smoothstep(0.0, SEARCH_WEIGHT, dist) / SEARCH_WEIGHT);\n                \n                // add onto our accumulator\n                accumCol += col * weight;\n                accumVel += vel * weight;\n                accumWeight += weight;\n            }\n        }\n        \n        if (accumWeight > 0.0) {\n            // average\n            vec3 col = accumCol / accumWeight;\n            vec2 vel = accumVel / accumWeight;\n            // add wind vel\n            vel += windVel;\n\n            // output\n            fragColor = vec4(vec3(vel.x, vel.y, rgb2float(col)), 1.0);\n        } else {\n            fragColor = vec4(vec3(windVel.x, windVel.y, rgb2float(noiseTimeBabey(thisUV))), 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\n\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\nvec3 float2rgb(float h) {\n    return hue2rgb(h);\n}\nfloat rgb2float(vec3 c) {\n\tfloat cMax=max(max(c.r,c.g),c.b),\n\t      cMin=min(min(c.r,c.g),c.b),\n\t      delta=cMax-cMin;\n\tvec3 hsv=vec3(0.,0.,cMax);\n\tif(cMax>cMin){\n\t\tif(c.r==cMax){\n\t\t\thsv.x=(c.g-c.b)/delta;\n\t\t}else if(c.g==cMax){\n\t\t\thsv.x=2.+(c.b-c.r)/delta;\n\t\t}else{\n\t\t\thsv.x=4.+(c.r-c.g)/delta;\n\t\t}\n\t\thsv.x=fract(hsv.x/6.);\n\t}\n\treturn hsv.x;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 205]], "test": "untested"}
{"id": "mdyXR3", "name": "Anti Tiling", "author": "l1ghtrider", "description": "Anti Tiling", "tags": ["2d", "voronoi", "tiling", "antitiling"], "likes": 2, "viewed": 195, "published": 3, "date": "1681372992", "time_retrieved": "2024-07-30T18:00:48.018194", "image_code": "vec2 hash2( vec2 p )\n{\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nvec4 voronoi( in vec2 x, out vec2 yuanxin, out float rotValue, out vec2 indexOffset )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        #ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif        \n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            indexOffset = g;\n            yuanxin = g - 0.5 + o;\n            rotValue = d / 2.0f;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        #ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif        \n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4(mr, md, 0.2 + (mg.x + 1.0) * (mg.y + 1.0));\n}\n\nvec2 rot2d(vec2 v,float d)\n{\n    float s = sin(d),c = cos(d);\n    mat2 rot = mat2(c,-s,s,c);\n    return rot * v;\n}\n\n//#define DisplayVoronoi\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tileScale = 1.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    uv = uv * 3.0f;\n\n    vec2 yuanxin;\n    float rotVal;\n    vec2 indexOffset;\n    vec4 vor = voronoi( uv * tileScale, yuanxin, rotVal, indexOffset);\n\n    vec3 col = texture(iChannel0,uv).rgb;\n\n    vec2 hehe = uv - ((floor(uv) + 0.5) + yuanxin);\n    float rotV = hash2(indexOffset + floor(uv)).x;\n    rotV = 0.5;\n    vec3 col2 = texture(iChannel0, ( \n        ( (floor(uv) + 0.5) + yuanxin)\n        + rot2d(hehe, (rotV) * 1.5 * smoothstep(0.01,0.5,vor.z))\n    \n     ) ).rgb ;\n    //col2 *= smoothstep(0.0,0.1,dot(hehe,hehe));\n\n    if(iMouse.z <= 0.0)\n    {\n        //col = col2;\n        //col2 = col;\n        col = mix(col2, col, 1.0-smoothstep(0.05,0.1,vor.z));\n#ifdef DisplayVoronoi\n        col = vec3(smoothstep(0.02,0.04,vor.z));\n        col *= smoothstep(0.0,0.001,dot(vor.xy,vor.xy));\n        //col = vec3(1.0 - dot(vor.xy,vor.xy));\n        \n#endif\n\n    }//else\n    //col = mix(col, col2, 1.0-smoothstep(0.03,0.08,vor.z));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 138], [140, 140, 227, 227, 1497], [1499, 1499, 1527, 1527, 1613], [1641, 1641, 1698, 1698, 2800]], "test": "untested"}
{"id": "csGXRc", "name": "Test shader for api nonsense", "author": "trisscanva", "description": "Testing a thing", "tags": ["2d", "test", "simple", "canva"], "likes": 1, "viewed": 152, "published": 3, "date": "1681358988", "time_retrieved": "2024-07-30T18:00:48.863932", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "DdySRc", "name": "julia_sphere", "author": "graygoose", "description": "uh, yeah uh - I'll fix it. sure i will.", "tags": ["fractal", "julia", "pathtrace"], "likes": 1, "viewed": 178, "published": 3, "date": "1681357063", "time_retrieved": "2024-07-30T18:00:49.716652", "image_code": "#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define MAX_ITERS 150.\n#define SPHERE_EPS .00001\n\nvec3 sphereMapping(vec3 dir) {\n  float t_off = 0.01*cos(iTime*0.15);\n  vec2 uv = vec2(atan(dir.z, dir.x+t_off), asin(dir.y));\n  uv /= TAU;\n  uv += .5;\n  \n  float t = iTime * 0.5;\n  vec2 c = vec2(-cos(t) * cos(t), sin(t) * cos(t));\n\n  vec2 z = vec2(0.0, 0.0);\n  float iter;\n  for (iter=0.; iter < MAX_ITERS; iter++) {\n    vec2 newZ = dot(z, z) + c;\n    if (dot(newZ, newZ) > 4.0) break;\n    z = newZ;\n  }\n\n  float displacement = iter / float(MAX_ITERS);\n  vec3 normal = normalize(dir);\n  vec3 perturbation = displacement * normal;\n  \n  float maxDisplacement = .01 * length(normal);\n  perturbation *= min(0.0, maxDisplacement / length(perturbation));\n  \n  return texture(iChannel0, uv).rgb + perturbation;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec2 z = ( 2.0 * U - iResolution.xy ) / iResolution.y;\n  \n  float t = iTime * 0.5;\n  vec2 c = vec2(-cos(t) * cos(t), sin(t) * cos(t));\n  \n  vec3 rayDir = normalize(vec3(z, -1.0));\n  vec3 rayPos = vec3(0.0, 0.0, 1.25);\n  \n\n  float dist = 0.0;\n  vec3 color = vec3(0.0);\n  for (int i = 0; i < 100; i++) {\n    vec3 pos = rayPos + dist * rayDir;\n    vec3 normal = normalize(pos);\n    float d = length(pos) - 1.0 + 0.2 * length(sphereMapping(normal));    \n    if (d < SPHERE_EPS) {\n      color = sphereMapping(normal);\n      break;\n    }\n    dist += d;\n    if (dist > 10.0) break;\n  }\n\n  O = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265359\n#define MAX_ITERS 150\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec2 z = ( 2.*U - iResolution.xy ) / iResolution.y;\n  \n  float t = iTime * .2;\n  \n  vec2 c = vec2(-cos(t)*cos(t), sin(t)*cos(t));\n  \n  O = vec4(0);\n  int i=0;\n  for (; i < MAX_ITERS && dot(z,z) < 4.; i++) \n    z = mat2(z,-z.y,z.x) * z + c;\n  \n  if (i < MAX_ITERS) {\n    float t = float(i)/float(MAX_ITERS);\n    vec3 color = vec3(t-z.x, cos(z.y-c.x)*sin(z.x-c.y), t+z.y);\n    color = 0.5 + 0.5*sin(PI*(color-t));\n    O = vec4(color, 1.0);\n  }\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdySRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 135, 135, 810], [812, 812, 851, 851, 1459]], "test": "untested"}
{"id": "DdyXz3", "name": "Blue and white rug", "author": "jarble", "description": "A fractal rug pattern.\nI think [url=https://www.shadertoy.com/view/DlKfRK]this one[/url] is even better!", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 25, "viewed": 451, "published": 3, "date": "1681353955", "time_retrieved": "2024-07-30T18:00:50.537458", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 6.,c1=0.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    for(int k = 0; k < 9; k++){\n    \n        uv.y -= 1./4.;\n        \n        uv = (uv+t2)/scale;\n        \n        uv = ((vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv-.5);\n        uv =\n            (t2-triangle_wave(uv.yx))\n            \n            //WOW!\n            //(t2-triangle_wave(uv.yx))-vec2(floor(-uv.x),0.)\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n        ;\n        //{t2.x = (t2.x-sign(t2.y/2.-t2.x)); }\n        //{t2.x = (t2.x+1.*sign(t2.y-t2.x)); }\n\n        //t2.x = (t2.x+1.5*sign(t2.y-t2.x));\n        \n        vec2 uv1 =\n            uv\n            //triangle_wave((uv-.5)/3.)-triangle_wave((uv.yx)/3.)\n        ;\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            max(abs(uv1.y-uv1.x)/2.,c1)\n        ;\n        c1 =\n            max(abs(2.*c1-1.),c1/4.)\n            \n            //gold and blue\n            //(1.5-max(abs(2.*c1-1.),c1/4.))\n            \n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n            max(max(length(uv-t2-c1),abs(uv.y-uv.x))/3.,col.x)\n           \n            //c1\n            \n            //silver and gold\n            //max(length(c1-uv-t2)/3.,col.x)\n           \n            //blue and gold\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        //if(uv.y>-.25)\n        col =\n            abs(col-(1.-(c1*col.x)))\n            //abs(col*c1-(1.-(col.x)))\n        ;\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            //abs(col1-col*c1-1.).yzx\n        ;\n    }\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\nfloat fmod(float a, float b,float modulus){\n    for(float i = 1.; i < mod(floor(a/b),modulus); i++){\n        //a /= 2.0;\n        //a /= 1.0+mod(floor(a),2.);\n        a += mod1(floor(a/2.),b)*i;\n    }\n    float a1 = a;\n    return\n        mod(floor(a),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    //the modulus should be a prime number\n    //this makes some interesting rhythms\n    float modulus =\n        //3.\n        5.\n        //7.\n    ;\n    \n    return\n        fmod(floor(a),b,modulus)\n    ;\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float tempo = .25;\n  time /= tempo;\n  float s1 =\n      8.;\n  vec3\n  rhythm =\n      vec3(1.)\n      \n      //more rhythms here!\n      //vec3(2.)\n      //vec3(2.,2.,1.)\n      //vec3(2.,1.,1.)\n  ;\n  for(float i = 1.; i < mod(floor(time),5.); i++){\n      time += mod(floor(time*2./rhythm.x),s1)*i;\n      time /= 1.+fmod(floor(time/rhythm.y)*2.,2.,5.);\n      tempo *= 1.+fmod(floor(time/rhythm.z)*2.,2.,5.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m1 =\n      fmod(t,s2,5.)\n  ,\n  m3 =\n      fmod(t,1.+m1,5.)+fmod(t/8.,2.,5.);\n  t /=\n      (1.+fmod(t/s1,2.,5.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1,5.)\n  ,note=floor((m3+m2)/2.)/5.\n  ;\n  vec2 a=\n      //vec2((1.-sqrt(fract(t/s1)/1.25))*.2)\n      -vec2((log(1./64./4.+fract1(t/s1)/8.)))\n\n      //pow(1.-log(1./16./2.+fract(t/s1)/4.),2.)\n  ,\n  nb = vec2(time*tempo*pow(2.,note+6.5));\n  vec2 \n  sitar = log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.)),\n  gamelan = a/16./4.*abs(log(1.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n  ,steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,oud =       a/16./2.*abs(\n      synth(1./2.,a,0.,1.,nb*2.,1./2.)\n      +.5*synth(1./8.,a,1./8.,1.,nb,1./2.))/2.\n  ,synth_drum = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ,synth_drum1 = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4./m2))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.*m2)))\n  ,guitar = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1.)),\n  electric_guitar = abs(guitar-oud)\n  ;\n  return\n      \n      //abs(oud-steel_drum/8.)\n      \n      //electric_guitar\n      (gamelan-steel_drum/2.)\n      \n      \n      //oud\n      //abs(.5-vec2(fract(nb.x*.998*2.),fract(nb.y)))*a\n      \n      \n      //log(abs(a/4.-2.*abs(.5-vec2(fract(nb*.998*2.),fract(nb*2.)))*a))\n\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 129], [131, 131, 188, 188, 2203]], "test": "untested"}
{"id": "mdVSzK", "name": "Raeytreacre", "author": "ThePlaneGuy45", "description": "reflecting go brrr\n\nplease tell me if u have improvements I'm still inexperienced with this type of programming\n\nworking on tri textur\n\nhttps://www.youtube.com/watch?v=Qz0KTGYJtUk\nhttps://www.shadertoy.com/view/XlXcW4\nhttps://www.shadertoy.com/view/Xltfzj", "tags": ["raytracer"], "likes": 2, "viewed": 221, "published": 3, "date": "1681350472", "time_retrieved": "2024-07-30T18:00:51.575682", "image_code": "#define blurQUAL 3.0\n#define blurDIR 16.0\n#define blurSIZE 2.0\n\n// Blur by existical, https://www.shadertoy.com/view/Xltfzj\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x;\n    \n    vec2 rad = blurSIZE / iResolution.xy * ratio;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    for( float i = 0.0; i < TAU; i += TAU/blurDIR ) {\n    \n\t\tfor( float j = 1.0/blurQUAL; j <= 1.0; j += 1.0/blurQUAL ) {\n        \n            vec4 add = texture(iChannel0, uv + vec2( cos(i), sin(i) ) * rad * j);\n            \n            if(dot(abs(add), add) > 0.0) {\n        \n                color += add;\n                \n            }\n            \n        }\n        \n    }\n    \n    color /= blurQUAL * blurDIR + blurSIZE;\n    \n    fragColor = color;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    if(iMouse.z > 0.0) {\n    \n        if(fragCoord.x/iResolution.x < 0.5){\n        \n            fragColor = (iMouse - vec4(iResolution.xy/2.0, 0.0, 0.0)) * 4.0;\n        \n        } else {\n        \n            fragColor = vec4(float(iFrame));\n            \n        }\n        \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Triangle + Sphere algorithm found in the video:\n// \"Coding Adventure: Ray Tracing\" by Sebastian Lague\n// https://www.youtube.com/watch?v=Qz0KTGYJtUk\n\nuint raySphere(in Sphere sph, inout Record rec) {\n\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    \n    if (disc > 0.0) {\n    \n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        \n        if(dstNear < rec.dist) {\n        \n            if(dstNear > 0.0) {\n        \n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.center = (rec.intersect - sph.center - sph.radius) / sph.radius;\n                \n                return uint(0x1);\n        \n            }\n        \n        }\n        \n        return uint(0x0);\n    \n    }\n\n}\n\nuint rayTri(in Triangle tri, inout Record rec) {\n\n    vec3 ab = tri.b - tri.a;\n    vec3 ac = tri.c - tri.a;\n    vec3 normal = ab.yzx * ac.zxy - ab.zxy * ac.yzx;\n    vec3 ao = rec.ray.origin - tri.a;\n    vec3 dao = cross(ao, rec.ray.normal);\n    \n    float det = 1.0 / (-dot(rec.ray.normal, normal));\n    \n    float dist = dot(ao, normal) * det;\n    float u = dot(ac, dao) * det;\n    float v = -dot(ab, dao) * det;\n    float w = 1.0 - u - v;\n    \n    bool hit = det >= 1e-6 && dist >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;\n    \n    if(hit && dist < rec.dist) {\n    \n        rec.intersect = (rec.ray.normal * dist) + rec.ray.origin;\n        rec.normal = normalize(normal);\n        rec.dist = dist;\n        rec.material = tri.material;\n        rec.hit = true;\n        rec.center = tri.a;\n                \n        return uint(0x1);\n    \n    }\n    \n    return uint(0x0);\n\n}\n\n/*= Objects ========================================*/\n/*==================================================*/\n\nvoid distances(inout Record rec) {\n\n    raySphere(Sphere(Material(vec3(0.0, 0.0, 0.0), true, 2, vec3(0.0), 1.0, 0.0, 0.0, 0.0, vec3(1.0, 1.0, 1.0)), vec3(100.0, 120.0, 50.0), 60.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.0, 1.0), false, 0, vec3(0.0), 0.0, 0.0, 0.0, 0.0, vec3(1.0, 1.0, 1.0)), vec3(0.0, 60.0, -50.0), 50.0), rec);\n    raySphere(Sphere(Material(vec3(1.0, 1.0, 1.0), false, 0, vec3(0.0), 0.0, 0.0, 0.2, 1.0, vec3(1.0, 1.0, 1.0)), vec3(-50.0, 150.0, 0.0), 50.0), rec);\n    \n    rayTri(Triangle(Material(vec3(0.0, 1.0, 0.0), false, 0, vec3(0.0), 0.0, 0.0, 0.0, 0.0, vec3(1.0, 1.0, 1.0)), vec3(100.0, 120.0, 50.0), vec3(0.0, 60.0, -50.0), vec3(-50.0, 150.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0)), rec);\n    \n    rayTri(Triangle(Material(vec3(0.75, 0.75, 0.75), false, 0, vec3(0.0), 0.0, 0.0, 0.1, 1.0, vec3(1.0, 1.0, 1.0)), vec3(-250.0, 0.0, -250.0), vec3(-250.0, 0.0, 250.0), vec3(250.0, 0.0, -250.0), vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0)), rec);\n    rayTri(Triangle(Material(vec3(0.75, 0.75, 0.75), false, 0, vec3(0.0), 0.0, 0.0, 0.1, 1.0, vec3(1.0, 1.0, 1.0)), vec3(250.0, 0.0, 250.0), vec3(250.0, 0.0, -250.0), vec3(-250.0, 0.0, 250.0), vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0)), rec);\n}\n\n/*==================================================*/\n/*==================================================*/\n\nvoid initRay(vec2 fragCoord, inout Record rec) {\n\n    rec.ray.origin = vec3(0.0, 0.0, 0.0);\n    rec.ray.normal = normalize(vec3(fragCoord, FOCAL_LENGTH) - rec.ray.origin);\n\n}\n\nvoid initRecord(inout Record rec) {\n\n    rec.hit = false;\n    rec.dist = 10000000.0;\n\n}\n\n// Random vec3 function Copyright  2017 Inigo Quilez\n// Can be found here: https://www.shadertoy.com/view/XlXcW4\n\nvec3 random(inout uvec3 state) {\n\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    \n    return vec3(state)*(1.0/float(0xffffffffU));\n\n}\n\n// Normal distrobution also found in Sebastian Lague video linked above\n\nvec3 randomNormal(vec3 normal, inout uvec3 state) {\n\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    state = ((state>>8U)^state.yzx)*1103515245U;\n    \n    vec3 y = vec3(state)*(1.0/float(0xffffffffU));\n    \n    vec3 theta = 2.0 * PI * y;\n    vec3 rho = sqrt(-2.0 * log(y));\n    y = rho * cos(theta);\n    \n    if(dot(y, normal) < 0.0) {\n        \n        y -= y;\n        \n    }\n    \n    return y;\n    \n}\n\nfloat sech(float x) {\n\n    return 6.0 / ( exp(x) + exp(-x) );\n\n}\n\nvec3 sky(inout Record rec) {\n\n    float t = tanh(rec.ray.normal.y) * 0.5 + 0.5;\n    float d = dot(rec.ray.normal, normalize(vec3(-1.0, 1.0, 1.0)));\n    d = sech(500.0 * (1.0 - d));\n    vec3 sky =  mix(vec3(0.01, 0.12, 0.17), vec3(0.35, 0.74, 0.95), t);\n    return mix(sky, vec3(1.0, 0.93, 0.71) * SUNSTRENGTH, d);\n\n}\n\nvec4 triPlanar(sampler2D tex, vec3 offset, vec3 normal, float scale) {\n\n    vec3 blend = normalize(max(abs(normal), 0.000001));\n    float sum = blend.x + blend.y + blend.z;\n    blend /= sum;\n    vec4 x = texture(tex, offset.yz * scale);\n    vec4 y = texture(tex, offset.xz * scale);\n    vec4 z = texture(tex, offset.xy * scale);\n    return x * blend.x + y * blend.y + z * blend.z;\n\n}\n\nvec4 texturize(int id, vec3 offset, vec3 normal, float scale) {\n\n    switch(id) {\n    case 0:\n        return triPlanar(iChannel0, offset, normal, scale);\n    case 1:\n        return triPlanar(iChannel1, offset, normal, scale);\n    case 2:\n        return triPlanar(iChannel2, offset, normal, scale);\n    case 3:\n        return triPlanar(iChannel3, offset, normal, scale);\n    }\n    return vec4(0.0);\n\n}\n/*\nvec2 triUV(vec2 a, b, c, p, auv, buv, cuv) {\n\n    ac = a-c;\n    bc = b-c;\n    ca = c-a;\n    cb = c-b;\n    pc = p-c;\n    barya = (bc.y * pc.x + cb.x * pc.y) / (bc.y * ac.x + cb.x * ac.y);\n    baryb = (ca.y * pc.x + ac.x * pc.y) / (bc.y * ac.x + cb.x * ac.y);\n    baryc = 1.0 - barya - baryb;\n    uv = barya * auv + baryb * buv + baryc * cuv;\n\n}\n*/\nvec3 singleRay(in Camera cam, in vec2 fragCoord, inout uvec3 state) {\n\n    Record rec;\n    initRecord(rec);\n    initRay(fragCoord, rec);\n    \n    rec.ray.normal = normalize(rec.ray.normal + vec3(random(state).xy * 0.01, 0.0));\n    \n    rec.ray.origin += cam.position + random(state);\n    \n    rec.ray.normal.zy = vec2(\n        cos(cam.direction.y) * rec.ray.normal.z - sin(cam.direction.y) * rec.ray.normal.y,\n        sin(cam.direction.y) * rec.ray.normal.z + cos(cam.direction.y) * rec.ray.normal.y\n    );\n    rec.ray.normal.zx = vec2(\n        cos(cam.direction.x) * rec.ray.normal.z - sin(cam.direction.x) * rec.ray.normal.x,\n        sin(cam.direction.x) * rec.ray.normal.z + cos(cam.direction.x) * rec.ray.normal.x\n    );\n    \n    vec3 increment = vec3(1.0);\n    vec3 color = vec3(0.0);\n    \n    bool first = true;\n    \n    for ( int i; i < MAXBOUNCES; i++ ) {\n    \n        distances(rec);\n        \n        if(rec.hit) {\n        \n            rec.ray.origin = rec.intersect;\n            float spec = float(rec.material.glossiness > random(state).x);\n            rec.ray.normal = mix(randomNormal(rec.normal, state), reflect(rec.ray.normal, rec.normal), spec);\n            initRecord(rec);\n            \n            vec3 matColor;\n            if(rec.material.usetexture) {\n            \n                matColor = texturize(rec.material.texID, rec.center + rec.material.texOffset, rec.normal, rec.material.texScale).rgb;\n            \n            } else {\n            \n                matColor = rec.material.color;\n            \n            }\n        \n            color += (matColor * rec.material.emission) * increment;\n            increment *= mix(matColor, rec.material.clearcoatcolor, rec.material.clearcoat);\n        \n        } else {\n        \n            float mul;\n        \n            if(first) {\n            \n                mul = 1.0;\n            \n            } else {\n            \n                mul = SKYMUL;\n            \n            }\n        \n            color += sky(rec) * mul * increment;\n            \n            break;\n        \n        }\n        \n        first = false;\n    \n    }\n    \n    return color;\n\n}\n\nvec3 Trace(in Camera cam, in vec2 fragCoord, inout uvec3 state) {\n\n    vec3 color = vec3(0.0);\n    float sub = float(SAMPLES);\n    \n    for(int i; i < SAMPLES; i++) {\n    \n        vec3 result = singleRay(cam, fragCoord, state);\n        \n        if(length(result) == 0.0) {\n        \n            sub--;\n        \n        } else {\n        \n            color += singleRay(cam, fragCoord, state);\n        \n        }\n    \n    }\n    \n    if(sub > 0.0) {\n    \n        color /= sub;\n        \n    }\n    \n    return color;\n\n}\n\nCamera getCam(vec2 iMouse) {\n\n    Camera cam;\n    \n    cam.direction = vec3(iMouse.xy, 1.0);\n    cam.position = vec3(0.0, 0.0, -500.0);\n    cam.position.zy = vec2(\n        cos(cam.direction.y) * cam.position.z - sin(cam.direction.y) * cam.position.y,\n        sin(cam.direction.y) * cam.position.z + cos(cam.direction.y) * cam.position.y\n    );\n    cam.position.zx = vec2(\n        cos(cam.direction.x) * cam.position.z - sin(cam.direction.x) * cam.position.x,\n        sin(cam.direction.x) * cam.position.z + cos(cam.direction.x) * cam.position.x\n    );\n    \n    return cam;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float ratio = iResolution.y/iResolution.x;\n    \n    vec2 mouse = (texture(iChannel1, vec2(0.4, 0.5)).xy / iResolution.xy - vec2(0.5, 0.5)) * vec2(1.0, ratio);\n    vec2 coord = (fragCoord / iResolution.xy - vec2(0.5, 0.5)) * vec2(1.0, ratio);\n\n    Camera cam = getCam(mouse);\n    uvec3 state = uvec3(fragCoord, iFrame);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 old = texture(iChannel0, uv);\n    vec4 current = vec4(Trace(cam, coord, state),1.0);\n    \n    float frame = float(iFrame + 1) - texture(iChannel1, vec2(0.6, 0.5)).x;\n    \n    fragColor = vec4(frame);\n    \n    float weight = 1.0 / frame;\n    \n    if( iMouse.z > 0.0 ) {\n    \n        fragColor = current;\n    \n    } else {\n    \n        fragColor = mix(old, current, weight);\n    \n    }\n    \n}", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define FOCAL_LENGTH 0.4\n#define FOCUS_LENGTH 500.0\n#define MAXBOUNCES 10\n#define SAMPLES 10\n\n#define SKYMUL 0.5\n#define SUNSTRENGTH 200.0\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\n// Most of the code is my own, except the tracing/random distribution functions.\n// I am not smart enough to make those ;-;\n// If you want to use any piece of code OTHER than those functions, please credit me.\n// If you use any other things in here, credit the original creator.\n// Links to sources in both code + description\n// - TPG\n\nstruct Material {\n\n    vec3 color;\n    bool usetexture;\n    int texID;\n    vec3 texOffset;\n    float texScale;\n    float emission;\n    float glossiness;\n    float clearcoat;\n    vec3 clearcoatcolor;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Triangle {\n\n    Material material;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec2 auv;\n    vec2 buv;\n    vec2 cuv;\n\n};\n\nstruct Camera {\n\n    vec3 position;\n    vec3 direction;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 center;\n\n};", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 182, 182, 835]], "test": "untested"}
{"id": "dsySzK", "name": "Sphere Tracing Anti-aliasing", "author": "gelami", "description": "Anti-aliasing sphere tracing by keeping track of near-hits,\ncalculating the coverage and compositing them together with multiple shading calls.\n", "tags": ["3d", "raymarching", "antialiasing", "spheretracing", "aa"], "likes": 13, "viewed": 278, "published": 3, "date": "1681336681", "time_retrieved": "2024-07-30T18:00:52.428402", "image_code": "\n// Sphere Tracing Anti-aliasing by gelami\n// https://www.shadertoy.com/view/dsySzK\n\n/*\n *  Anti-aliasing sphere tracing by keeping track of near-hits,\n *  calculating the coverage and compositing them together with multiple shading calls.\n *  \n *  Does distance estimation (dividing by the length of the gradient)\n *  to improve anti-aliasing for inexact distance fields\n *  \n *  The anti-aliasing implementation adapted from:\n *  Bacterium - bgs\n *  https://www.shadertoy.com/view/MdBSDt\n *  \n *  Also another shader that does it:\n *  Neptune Racing - Dave_Hoskins\n *  https://www.shadertoy.com/view/XtX3Rr\n *\n *  The original sphere tracing paper that had a section about this AA technique:\n *  https://graphics.stanford.edu/courses/cs348b-20-spring-content/uploads/hart.pdf\n *          \n */\n\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-04-12 11:15:51\n\nvec4 debug = vec4(-1);\n\nfloat gyroid(vec3 p)\n{\n    return dot(sin(p), cos(p.yzx));\n}\n\nfloat map(vec3 p)\n{\n    float d = MAX_DIST;\n    \n    vec3 tpos = p * 0.6;\n    float h = sin(tpos.x * 1.0) + sin(tpos.z * 1.5) + cos((tpos.x - tpos.z) * 5.0) * 0.1 + cos(-tpos.x * 4.0 + tpos.z * 8.0) * 0.07;\n    d = p.y - h * 0.3 + 1.8;\n    \n    vec3 gp = p;\n    vec2 sgp = vec2(4.0);\n    gp.xz = mod(gp.xz + sgp*0.5, sgp) - sgp*0.5;\n    float g = (abs(gyroid(p * TAU + iTime)) - 0.3) / (TAU * 2.);\n    \n    d = smin(d, smax(g, (length(gp) - 1.), .01), .5);\n    \n    //d = min(d, length(gp) - 1.0);\n    \n    float s = length(p - vec3(2, 0, 2)) - 1.0 + sin((p.x + p.y + p.z)*8.0) * 0.05;\n    //d = min(d, s * 0.6);\n    \n    return d;\n}\n\nvec3 gradient(vec3 p)\n{\n    const vec2 e = vec2(0, 1e-3);\n    return (vec3(map(p + e.yxx),\n                 map(p + e.xyx),\n                 map(p + e.xxy)) - map(p)) / e.y;\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 e = vec2(0, 1e-3);\n    return normalize(\n        vec3(\n            map(p + e.yxx),\n            map(p + e.xyx),\n            map(p + e.xxy)) - map(p)\n        );\n}\n\nvec3 getSkybox(vec3 rd)\n{\n    return texture(iChannel1, rd).rgb;\n    //return rd*0.5+0.5;\n}\n\nvec3 shade(vec3 pos, vec3 rd, vec3 n)\n{\n    vec3 color = vec3(0.5);\n    color = vec3(n*.5+.5);\n\n    float f = pow(1.0 - max(dot(-rd, n), 0.0), 5.0);\n    vec3 ref = getSkybox(reflect(rd, n));\n\n    color = mix(color, ref, f * 0.2);\n    \n    return color;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0);\n    \n    // Anti-aliasing implementation adapted from:\n    // Bacterium - bgs\n    // https://www.shadertoy.com/view/MdBSDt\n    float t = 0.;\n    vec4 distStack = vec4(-1);\n    \n    // I think this should depend on FoV\n    float aa = 1.0 / iResolution.y;\n    \n    float pd = 0.0;\n    bool near = false;\n    for (int i = 0; i < STEPS; i++)\n    {\n        float d = map(ro + rd * t);\n        \n        if (d < pd)\n            near = true;\n        else if (near && pd < aa * (t - pd) && distStack.w < 0.0)\n        {\n            distStack.w = t - pd;\n            distStack = distStack.wxyz;\n            \n            near = false;\n        }\n        \n        t += d;\n        pd = d;\n        \n        if (d < EPS || t >= MAX_DIST)\n            break;\n    }\n    vec3 pos = ro + rd * t;\n    vec3 n = normal(pos);\n    \n    color = t < MAX_DIST ? shade(pos, rd, n) : getSkybox(rd);\n    \n    if (debug.x > debug.z)\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            if (distStack[i] < 0.0)\n                break;\n\n            vec3 pos = ro + rd * distStack[i];\n            float d = map(pos);\n            \n            // Distance estimation by dividing the distance by the length of its gradient\n            // https://iquilezles.org/articles/distance/\n            vec3 grad = gradient(pos);\n            float lgrad = length(grad);\n            vec3 n = grad / lgrad;\n            \n            d /= lgrad;\n\n            #if 1\n            float alpha = saturate(d / (aa * distStack[i]));\n            #else\n            // Cone tracing alpha calculation from the original sphere tracing paper\n            // https://graphics.stanford.edu/courses/cs348b-20-spring-content/uploads/hart.pdf\n            // There's basically no difference lol\n            float r = aa * distStack[i];\n            float alpha = 0.5 - d * sqrt(r*r - d*d) / (PI * r*r) - (1.0 / PI) * asin(d / r);\n            alpha = 1.0-saturate(alpha * 2.0);\n            #endif\n            \n            #if 1\n            color = mix(color, shade(pos, rd, n), 1.0-alpha);\n            #else\n            color = mix(color, vec3(1,0,0), 1.0-alpha);\n            #endif\n        }\n    }\n    \n    //color = vec3(distStack.xyz);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, 4);\n    vec3 lo = vec3(0, 0, 0);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.x < 2. ? -PI * .7 + iTime * .2 : -m.x * PI;\n    float ay = iMouse.y < 2. ? 0.12 * PI : -m.y * PI + PI * 0.5;\n    \n    float fov = 2.0;\n    debug.xy = uv;\n    debug.z = sin(iTime * 0.6) * 0.5 + 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, fov));\n\n    vec3 col = render(ro, rd);\n    \n    //if (int(fragCoord.x) == int(iResolution.x * debug.z))\n    col = mix(col, vec3(1, 0.1, 0.1), smoothstep(1.0/iResolution.y, 0.5/iResolution.y, abs(uv.x - debug.z)));\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    col = smoothstep(vec3(0), vec3(1), col);\n    //col = ACESFilm(col*0.45);\n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsySzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[931, 931, 953, 953, 991], [993, 993, 1012, 1012, 1626], [1628, 1628, 1651, 1651, 1803], [1805, 1805, 1826, 1826, 2002], [2004, 2004, 2029, 2029, 2095], [2097, 2097, 2136, 2136, 2351], [2353, 2353, 2384, 2384, 4602], [4604, 4604, 4661, 4661, 5695]], "test": "untested"}
{"id": "mdVSRV", "name": "noisier", "author": "mpusch88", "description": "WIP", "tags": ["noise", "gpt"], "likes": 0, "viewed": 162, "published": 3, "date": "1681335556", "time_retrieved": "2024-07-30T18:00:53.173410", "image_code": "float snoise(vec3 v);\nfloat sdSphere(vec3 p, float r);\nfloat sdScene(vec3 p, float time);\nvec3 calcNormal(vec3 p, float time);\n\n// Permutation function\nvec4 permute(vec4 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\n// Inverse square root approximation function\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// ShaderToy main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = iTime * 0.5;\n\n    vec3 camPos = vec3(0, 0, -4.0);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camDir, camUp));\n    vec3 camForward = normalize(cross(camRight, camUp));\n\n    vec3 rayOrigin = camPos;\n    vec3 rayDirection = normalize(uv.x * camRight + uv.y * camUp + 2.0 * camForward);\n\n    // Raymarching loop\n    float t = 0.0;\n    float raymarchStep = 0.05;\n    const int maxSteps = 100;\n    vec3 pos = rayOrigin;\n    for (int i = 0; i < maxSteps; i++) {\n        pos = rayOrigin + t * rayDirection;\n        float sdf = sdScene(pos, time);\n        if (sdf < 0.001) {\n            break;\n        }\n        t += sdf * raymarchStep;\n    }\n\n    // Shading and output\n    vec3 normal = calcNormal(pos, time);\n    vec3 light = vec3(1.0, 1.0, 1.0);\n    vec3 lightDirection = normalize(light - pos);\n    float diffuse = max(0.0, dot(normal, lightDirection));\n    fragColor = vec4(vec3(diffuse), 1.0);\n}\n\n// Signed distance function for a sphere\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Signed distance function for the scene\nfloat sdScene(vec3 p, float time) {\n    float displacement = snoise(p * 1.5 + time) * 0.2;\n    return sdSphere(p, 2.0 + displacement);\n}\n\n// Calculate the normal at a given point\nvec3 calcNormal(vec3 p, float time) {\n    float eps = 0.001;\n    vec3 ex = vec3(eps, 0, 0);\n    vec3 ey = vec3(0, eps, 0);\n    vec3 ez = vec3(0, 0, eps);\n    float x = sdScene(p + ex, time) - sdScene(p - ex, time);\n    float y = sdScene(p + ey, time) - sdScene(p - ey, time);\n    float z = sdScene(p + ez, time) - sdScene(p - ez, time);\n    return normalize(vec3(x, y, z));\n}\n\n// Simplex noise function\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    // x0 from second corner\n    vec3 x1 = x0 - i1 + C.xxx;\n    // x0 from third corner\n    vec3 x2 = x0 - i2 + C.yyy;\n    // x0 from last corner\n    vec3 x3 = x0 - D.yyy;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec4 p0 = permute(i.z + vec4(0.0, i1.z, i2.z, 1.0));\n    vec4 p1 = permute(p0 + i.y + vec4(0.0, i1.y, i2.y, 1.0));\n    vec4 p = permute(p1 + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0_new = vec3(a0.xy, h.x);\n    vec3 p1_new = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    // Normalize gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0_new, p0_new), dot(p1_new, p1_new), dot(p2, p2), dot(p3, p3)));\n    p0_new *= norm.x;\n    p1_new *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0_new, x0), dot(p1_new, x1), dot(p2, x2), dot(p3, x3)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 152, 174, 174, 223], [225, 271, 299, 299, 353], [355, 382, 437, 437, 1571], [1573, 1614, 1647, 1647, 1675], [1677, 1719, 1754, 1754, 1855], [1857, 1898, 1935, 1935, 2273], [2275, 2301, 2323, 2323, 4249]], "test": "untested"}
{"id": "dsVXRK", "name": "Painter-ify", "author": "fishy", "description": "repeated edge convolution (not sure if I did it right). Smooths areas of low contrast while retaining edges (mostly). Click to reset", "tags": ["convolution", "painter"], "likes": 4, "viewed": 228, "published": 3, "date": "1681331813", "time_retrieved": "2024-07-30T18:00:53.920413", "image_code": "void mainImage(out vec4 c, in vec2 p)\n{\n    c = texelFetch(iChannel0, ivec2(p), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define mag(x) dot(x.rgb, vec3(0.2126, 0.7152, 0.0722))\n\nvec2 edgeTangent(vec2 uv, sampler2D tex, float o)\n{\n    vec3 e = vec3(-o, 0, o);\n    float x = \n    mag(texture(tex, uv + e.xz /*-1, 01*/))*01. + mag(texture(tex, uv + e.zz /*01, 01*/))*-1. + \n    mag(texture(tex, uv + e.xy /*-1, 00*/))*02. + mag(texture(tex, uv + e.zy /*01, 00*/))*-2. + \n    mag(texture(tex, uv + e.xx /*-1, -1*/))*01. + mag(texture(tex, uv + e.zx /*01, -1*/))*-1.;\n    float y = \n    mag(texture(tex, uv + e.xz /*-1, 01*/))*01. + mag(texture(tex, uv + e.yz /*00, 01*/))*02. + mag(texture(tex, uv + e.zz /*01, 01*/))*01. +\n    mag(texture(tex, uv + e.xx /*-1, -1*/))*-1. + mag(texture(tex, uv + e.yx /*00, -1*/))*-2. + mag(texture(tex, uv + e.zx /*01, -1*/))*-1.;\n    \n    return vec2(-y, x);\n}\n\nvec4 edgeConvolution(in vec2 uv, sampler2D tex, float steps, float strength)\n{\n    vec4 res = vec4(0);\n    for(float i = 0.; i < steps; i++)\n    {\n        vec4 s = texture(tex, uv);\n        res += s;\n        vec2 edge = edgeTangent(uv, tex, 0.01);\n        uv += edge/steps*strength;\n    }\n    return res / steps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float currentFrame = texture(iChannel0, uv).w;\n\n    vec3 col = edgeConvolution(uv, iChannel0, 50., 0.03/(currentFrame)).rgb;\n\n    fragColor = vec4(col, 1);\n\n    if(iFrame == 0 || iMouse.w >= 0.)\n    {\n        fragColor = texture(iChannel1, uv);\n        currentFrame = 0.;\n    }\n    fragColor.w = currentFrame + 1.;\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 85]], "test": "untested"}
{"id": "DsKSzV", "name": "Landscape Of Frequencies", "author": "QuantumSuper", "description": "Learning buffers.\nA sound visualization with buffered frequency spectrum history, some colors, and symmetry.\n\n- use with audio in iChannel0 of Buffer A -", "tags": ["music", "buffer", "spectrogram"], "likes": 1, "viewed": 248, "published": 3, "date": "1681325963", "time_retrieved": "2024-07-30T18:00:54.678386", "image_code": "// Landscape Of Frequencies 0.21.230412 by QuantumSuper\n// sound visualization with buffered frequency spectrum history\n// \n// - use with audio in iChannel0 of Buffer A -\n\nvoid mainImage( out vec4 c, in vec2 p ){ \n    float s = .2+.3*cos(.133*iTime);\n    p = abs(s-p/iResolution.xy)+s; //define & warp space  \n    c = texture(iChannel1, p);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// BUFFER A (0.2) of Landscape Of Frequencies by QuantumSuper\n// reading iChannel1 & overlaying it on Buffer B\n// \n// - use with audio in iChannel0 of Buffer A -\n\nvoid mainImage( out vec4 c, in vec2 p ){\n    p /= iResolution.xy; \n    c = vec4( clamp( texelFetch(iChannel0,ivec2(int(1023.*abs(p.x-.5)),0),0).x-p.y ,.0,1.) ); //spectrum\n    c *= 3. * abs( vec4(sin(.2*iTime),sin(.4*iTime),sin(.8*iTime),0) + abs(p.x-.5) ); //color\n    c += vec4(.996,.994,.998,1) * smoothstep(.8, 0., length(c)) * texture(iChannel1,p); //history\n    c.a = 1.; // ?mandatory\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32989, "src": "https://soundcloud.com/tontoepferei/drift", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// BUFFER B (0.2) of Landscape Of Frequencies by QuantumSuper\n// reading Buffer A, resizing & shifting image\n// \n// - use with audio in iChannel0 of Buffer A -\n\nvoid mainImage( out vec4 c, in vec2 p ){\n    c = texture(iChannel0, fract(p/iResolution.xy/.995)-vec2(.0025+.002*sin(.8*iTime),.004+.0005*sin(.5*iTime)) ); //move background\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 212, 212, 342]], "test": "untested"}
{"id": "csVXzK", "name": "Knits & Sips", "author": "Bercon", "description": "Compo entry to 4k Executable Graphics at Revision 2023, placed 5th. Converted to WebGL 2 and use to Shadertoy uniforms.", "tags": ["4k", "teapot", "revision", "executablegraphics"], "likes": 38, "viewed": 713, "published": 3, "date": "1681325362", "time_retrieved": "2024-07-30T18:00:55.633832", "image_code": "// Copyright Jerry Ylilammi\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//     http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvec3 D(vec3 p) { // Pseudo RNG\n\tp = fract(p * vec3(.1031, .1030, .0973));\n  p += dot(p, p.yxz + 33.33);\n  return fract((p.xxy + p.yxx) * p.zyx) * 2. - 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n  fragColor = vec4(fragColor.xyz / (fragColor.xyz + .1667) * 1.25 + D(fragCoord.xxy) * .002, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Copyright Jerry Ylilammi\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//     http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//////////////////// RANDOM ////////////////////\n\nvec3 D(vec3 p) { // Pseudo RNG\n\tp = fract(p * vec3(.1031, .1030, .0973));\n  p += dot(p, p.yxz + 33.33);\n  return fract((p.xxy + p.yxx) * p.zyx) * 2. - 1.;\n}\n\n// Globals\nfloat time;\nfloat curDist;\nfloat inside = 1.;\nfloat PI = acos(-1.);\nfloat tmp;\nvec4 material;\nvec3 rand;\n\nvec3 cosineSampleHemisphere(vec3 n){\n  float r = sqrt(rand.x);\n  float theta = 2. * PI * rand.y;\n  vec3 B = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n  return normalize(r * sin(theta) * B + sqrt(1.0 - rand.x) * n + r * cos(theta) * cross( B, n ));\n}\n\n//////////////////// MATH ////////////////////\n\nvec3 qRotate(vec3 p, vec4 q) {\n  return p + 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n}\n\n//////////////////// TEXTURE ////////////////////\n\nfloat noise(vec3 p) { // Simplex 3D noise\n  vec3 s = floor(p + (p.x + p.y + p.z) / 3.);\n  vec3 x = p - s + (s.x + s.y + s.z) / 6.;\n  vec3 i = step(x.yzx, x);\n\tvec3 i1 = i * (1. - i.zxy);\n  vec3 i2 = 1. - i.zxy * (1. - i);\n\tvec3 x1 = x - i1 + 1. / 6.;\n\tvec3 x2 = x - i2 + 1. / 3.;\n\tvec3 x3 = x - .5;\n\tvec4 w = max(\n    .6 - vec4(\n      dot(x, x),\n      dot(x1, x1),\n      dot(x2, x2),\n      dot(x3, x3)\n    ),\n    0.\n  );\n\treturn .5 + 18. * dot(\n    vec4(\n      dot(D(s), x),\n      dot(D(s + i1), x1),\n      dot(D(s + i2), x2),\n      dot(D(s + 1.), x3)\n    ),\n    w * w * w * w\n  );\n}\n\n//////////////////// BEZIER ////////////////////\n\n// By iq: https://www.shadertoy.com/view/ldj3Wh\nvec2 fBezier(vec3 pos, vec3 A, vec3 B, vec3 C) {\n  vec3 a = B - A;\n  vec3 b = A - 2. * B + C;\n  vec3 c = a * 2.;\n  vec3 d = A - pos;\n  vec3 t;\n\n  float kk = 1. / dot(b, b);\n  float kx = kk * dot(a, b);\n  float ky = kk * (2. * dot(a, a) + dot(d, b)) / 3.;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kk * dot(d, a);\n  float h = q * q + 4.0 * p3;\n\n  if(h >= 0.0) {\n    h = sqrt(h);\n    p3 /= q;\n    vec2 x = abs(p) < 0.001 ? vec2(p3, -p3 - q) :  (vec2(h, -h) - q) * .5;\n    x = sign(x) * pow(abs(x), vec2(1./3.));\n    kk = clamp(x.x + x.y - kx, 0.0, 1.);\n    t = d + (c + b * kk) * kk;\n    return vec2(sqrt(dot(t, t)), kk);\n  }\n  float z = sqrt(-p);\n  float v = acos(q / (p * z * 2.)) / 3.;\n  float m = cos(v);\n  float n = sin(v) * 1.732050808;\n  a = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0., 1.);\n  t = d + (c + b * a.x) * a.x;\n  kx = dot(t, t);\n  t = d + (c + b * a.y) * a.y;\n  ky = dot(t, t);\n  if( ky < kx )\n    return vec2(sqrt(ky), a.y );\n\n  return vec2(sqrt(kx), a.x);\n}\n\nfloat fBezier4(vec3 p, vec3 A, vec3 AB, vec3 BC, vec3 C) {\n  vec3 B = (AB + BC) * .5;\n  return min(fBezier(p, A, AB, B), fBezier(p, B, BC, C)).x;\n}\n\n//////////////////// PRIMITIVES ////////////////////\n\nfloat fEllipsoid( vec3 p, vec3 r ) {\n  return (tmp = length(p/r)) < 1. ? (tmp - 1.) * min(min(r.x, r.y), r.z) : tmp * (tmp - 1.) / length( p / (r * r));\n}\n\nfloat fCylinder(vec3 p, float r, float h) {\n  p.xy = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(p.x,p.y),0.0) + length(max(p.xy,0.0));\n}\n\nfloat fCircle(vec3 p, float r) {\n\treturn length(vec2(p.z, length(p.xy) - r));\n}\n\n//////////////////// OPERATIONS ////////////////////\n\nfloat unionSmooth(float d1, float d2, float k) {\n  return mix( d2, d1, (tmp = clamp( .5 + .5*(d2-d1)/k, .0, 1. )) ) - k * tmp * (1. - tmp);\n}\n\nfloat diffSmooth(float d2, float d1, float k) {\n  return mix( d2, -d1, (tmp = clamp( .5 - .5*(d2+d1)/k, .0, 1. )) ) + k * tmp * (1. - tmp);\n}\n\nvoid closest(float f, vec4 m) {\n  if (curDist > f) {\n    curDist = f;\n    material = m;\n  }\n}\n\n//////////////////// OBJECTS ////////////////////\n\nvoid fNeedle(vec3 p) {\n  vec2 c = vec2(sin(.12), cos(.12));\n  vec2 q = vec2( length(p.xy), -(p.z - 1.2) );\n  closest(max(\n    fCylinder(p, .03, 1.2),\n    length(q - c * max(dot(q, c), 0.0)) * sign(q.x * c.y - q.y * c.x)\n  ) - .0105, vec4(p, 0));\n}\n\nvoid fCup(vec3 p) {\n  if ((tmp = length(p) - .9) > .2) { closest(tmp, vec4(0)); return; }\n  p /= 1.3;\n  closest(\n    unionSmooth(\n      diffSmooth(\n        unionSmooth(\n          fBezier(vec3(length(p.xy), 0, p.z), vec3(.4, 0, .4), vec3(.4, 0, 0), vec3(0)).x - 0.015,\n          fCircle(p - vec3(0,0,.01), .2) - .03,\n          .025\n        ),\n        length(vec3(abs(p.xy) - vec2(.141, .141), p.z + .02)) - .03,\n        0.03),\n      fBezier4(p - clamp( p, -.02,.02), vec3(.4, 0, .34), vec3(.56, 0, .41), vec3(0.54, 0, .13), vec3(0.3, 0, .1))  - .025,\n      .03\n    ) * 1.3,\n    vec4(5)\n  );\n}\n\nvoid fPlate(vec3 p) {\n  if ((tmp = length(p) - .8) > .2) { closest(tmp, vec4(0)); return; }\n  p /= 1.3;\n  closest(\n    unionSmooth(\n      fBezier(vec3(length(p.xy), 0, p.z), vec3(.6, 0, .12), vec3(.39, 0,  -0.01), vec3(0)).x - 0.0125,\n      fCircle(p - vec3(0,0,.01), .25) - .03,\n      .02\n    ) * 1.3,\n    vec4(5)\n  );\n}\n\nvoid fSpoon(vec3 p) {\n  if ((tmp = length(p - vec3(.8,0,0)) - 1.) > .2) { closest(tmp, vec4(0)); return; }\n  float e = fEllipsoid(p, vec3(.45, .3, .3));\n  vec2 b = fBezier(p, vec3(.33, 0, -.305), vec3(.36, 0, .08), vec3(1.6, 0, .26));\n  vec2 b2 = fBezier(p, vec3(.456, 0, -0.53) , vec3(.5, 0, -.09), vec3(1.8, 0, .08));\n  closest(\n    diffSmooth(\n      diffSmooth(\n        unionSmooth(\n          diffSmooth(\n            abs(e) - .012,\n            -fEllipsoid(p + vec3(0,0,.4), vec3(.45, .3, .3)),\n            .01),\n          diffSmooth(\n            b.x - .09 + (1. - b.y * b.y) * .05,\n            b2.x - .25,\n            .01),\n          .05),\n        e + .012,\n        .005),\n      -min(e - .012, -p.z - .18),\n      .01),\n    vec4(6)\n  );\n}\n\nvoid fLid(vec3 p) {\n  if ((tmp = length(p) - .8) > .2) { closest(tmp, vec4(0)); return; }\n  closest(\n    unionSmooth(\n      unionSmooth(\n        fBezier(vec3(length(p.xy), 0, p.z), vec3(.49, .0, 0), vec3(.25, .0,  .21), vec3(0, 0, .2)).x - 0.015,\n        length(p - vec3(0,0,.32)) - .1,\n        .07\n      ),\n      fCircle(p - vec3(0,0,-.03), .43) - .04,\n      0.03\n    ),\n    vec4(p, 4)\n  );\n}\n\nvoid fTeapot(vec3 p) {\n  // Body\n  float ellipsoid = diffSmooth(\n    fEllipsoid(p + vec3(0,0,.1), vec3(1, 1, .8)), // Body\n    p.z + .8, // Slice bottom\n    .2);\n\n  if (ellipsoid > .9)\n    closest(ellipsoid - .7, vec4(0));\n  else {\n    // Spout\n    vec3 sp = qRotate(p + vec3(.7,0,.1), vec4(0, 0.342, 0, 0.939));\n    float spout = diffSmooth(\n      fBezier4(vec3(length(sp.xy), 0.0001, sp.z),\n        vec3(.3, .0, 0),\n        vec3(.4, .0, .1),\n        vec3(.0, .0, .9),\n        vec3(.09, .0, 1.2)\n      ) - 0.035,\n      dot(sp - vec3(0,0,1.1), normalize(vec3(-.5, 0, -.8))),\n      0.035);\n\n    // Handle\n    vec2 seg1 = fBezier(p, vec3(1.1, 0, .65), vec3(.9, 0, .65), vec3(.77, 0, .43));\n    float handle = seg1.x - seg1.y * seg1.y * .03;\n    seg1 = fBezier(p, vec3(1.1, 0, .65), vec3(1.36, 0, .65), vec3(1.4, 0, .3));\n    handle = min(handle, seg1.x);\n    seg1 = fBezier(p, vec3(1.4, 0, .3), vec3(1.46, 0, -.2), vec3(.77, 0, -.4));\n    handle = min(handle, seg1.x - seg1.y * seg1.y * .04);\n    handle = unionSmooth(handle - .085, length(p - vec3(1.17,0,.71)) - .055, .06); // Handle bump\n\n    float body =\n      unionSmooth(\n        diffSmooth(\n          unionSmooth(\n            ellipsoid, // Body\n            fCylinder(p - vec3(0, 0, .68), .55, .015) - .05, // Top lip\n          .1),\n          fCylinder(p - vec3(0, 0, .68), .5, .3), .03), // Drill top hole,\n        fCylinder(p + vec3(0, 0, .7), .55, .015) - .05,  // Bottom foot\n      .2);\n\n    float res = max(unionSmooth(unionSmooth(body, handle, .1), spout, .1), -(ellipsoid + .06)); // Hollow out\n\n    if (res < .05) // Only evaluate noise if close enough that it would matter\n      res += noise(p * 10.) * .002; // Noise\n\n    closest(res, vec4(p + vec3(0, 0, .1), handle < min(spout, body) ? 2 : 3));\n  }\n}\n\nvoid fKnitting(vec3 p) {\n  p.x += noise(p * 4.) * .05;\n  p.y += noise(p * 4. + vec3(10)) * .05;\n\n  p.z += sin(p.y * 8. + p.x * 4.) * .03;\n  p.z -= 1. - cos(clamp(p.x * .3, -1., 1.));\n  p.z -= 1. - cos(clamp(p.y * (.45 + .05 * time), -2., 2.));\n\n  for (float i = 0.; i < 4.; i++) {\n    float phase = floor(i * .5 + .1);\n    vec3 q = p * 15. + vec3(mod(i,2.),phase,0);\n    vec2 c = vec2(1, 2) * clamp(floor(q.xy / vec2(1, 2) + .5), -vec2(19,26), vec2(20, 27));\n    q.xy = q.xy - c;\n    q.x *= mod(c.x, 2.) * 2. - 1.;\n    if (i == 0.) { // If we are far away, just approximate distance with sphere and skip 8x bezier curve\n      if ((tmp = length(q) - 2.) > 1.) {\n        closest(tmp * .066, vec4(0)); // 1. / 15. * .9 == 0.06\n        break;\n      }\n    }\n    c.x =\n      fBezier4(q, vec3(.5, .4, 0), vec3(-.2, .4, 0), vec3(-.3, -.2, .5), vec3(0, -.5, .5)) - .3 + .1 * noise(q * vec3(12,2,12));\n    closest(c.x * .06, vec4(c.x, abs((c.y * 2. - i - phase) * (1. - phase * 2.)) + 150., 0, 1)); // 1. / 15. * .9 == 0.06 Safety factor to account for space deformation\n    p *= vec3(1, -1, 1);\n  }\n}\n\n//////////////////// TRACING ////////////////////\n\n\nvoid field(vec3 p) {\n  curDist = 100.;\n\n  fTeapot(qRotate(p - vec3(-1.4, 0.34, 0.67), vec4(-0.195, 0.106, -0.975, -.0045)));\n  fLid(qRotate(p - mix(vec3(-0.77, -.013, 1.9), vec3(-.81, -.013, 1.85), time), vec4(-0.266, -0.103, -0.307, 0.908)));\n  fKnitting(qRotate(p - vec3(1.3, -.27, -0.87), vec4(-.00432, 0.108, 0.632, 0.767)));\n  fNeedle(qRotate(p - vec3(0.082, 0.3, -0.11), mix(vec4(0.777, -0.15, -0.17, -0.587), vec4(0.745, -0.148, -0.261, -0.596), time)));\n  fNeedle(qRotate(p - vec3(0.92, -0.61, -0.5), vec4(0.632, -0.457, -0.616, -0.109)));\n  if (p.x > 0.) {\n    float teaThickness =\n      .05\n      + sin(p.x * 15. + time * 1.5) * .01\n      + cos(p.y * 15. + time * 1.5) * .01;\n    closest(fBezier(p, vec3(.16, 0.25, .78), vec3(1.1, .1, 1.4), vec3(2.2, -.1, .2)).x - teaThickness, vec4(7));\n    closest(fBezier(p, vec3(2.5, -.3, .4), vec3(2.7, -.8, 2), mix(vec3(1.3, -.3, 1.7), vec3(1.4, -.3, 1.8), time)).x - teaThickness, vec4(7));\n\n    fCup(qRotate(p - vec3(2.6, -0.18, 0.25), vec4(-0.119, 0.301, 0.325, 0.889)));\n    fPlate(qRotate(p - vec3(2.7, -0.17, -0.08), mix(vec4(-0.106, 0.156, 0.497, 0.847), vec4(-0.0788, 0.125, 0.486, 0.861), time)));\n    fSpoon(qRotate(p - mix(vec3(3.2, -0.71, 0.84), vec3(3.3, -0.75, 0.87), time), mix(vec4(-0.415, 0.0586, 0.904, 0.0811), vec4(-0.408, 0.0718, 0.909, 0.0511), time)));\n  } else {\n    fCup(qRotate(p - mix(vec3(-1.9, -1.6, .18), vec3(-2, -1.6, .22), time), vec4(-0.0414, -0.164, 0.314, 0.934)));\n    fPlate(qRotate(p - mix(vec3(-1.9, -1.5, -.18), vec3(-1.9, -1.5, -0.14), time), vec4(0.12, -0.168, -0.206, 0.956)));\n    fSpoon(qRotate(p - mix(vec3(-.86, -0.92, -0.27), vec3(-.91, -0.92, -.24), time), vec4(-0.05, -0.109, 0.983, -0.137)));\n  }\n}\n\n// Compiles fast and works with WebGL 1\nvec3 calcNormal(vec3 p) {\n  vec4 e = vec4(0.0005, 0, 0, 0);\n  vec4 v;\n  for(int i=0; i<4; i++) {\n    field(p + e.xyz);\n    v.x = curDist;\n    e = e.wxyz;\n    v = v.wxyz;\n  }\n  return normalize(v.xwz - v.y);\n}\n\n//////////////////// SHADING ////////////////////\n\nfloat flowers(vec4 mat, float a, float b) {\n  b = atan(sqrt(mat.x * mat.x + mat.y * mat.y), mat.z) / PI * b  + .6;\n  vec2 uv = .5 - fract(abs(vec2(atan(mat.y, mat.x) / PI * a, b) + vec2(floor(mod(b, 2.)), .0) * .5));\n  a = mod(atan(uv.y, uv.x) + PI * .2, PI * .4) - PI * .2;\n  uv = vec2(cos(a), sin(a)) * length(uv);\n  uv.x -= noise(mat.xyz * 10.) * .08;\n  return min(\n    length(uv) - .05,\n    diffSmooth(\n      length(uv - vec2(.28,0)) - .13,\n      fEllipsoid(vec3(uv - vec2(.3,0), 0) + vec3(.1,0,0), vec3(.1, .025, 1)),\n      0.05\n    )\n  );\n}\n\n//////////////////// MAIN ////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n  rand = D(vec3(fragCoord.xy, fragColor.w));\n  time = fract(rand.z * 1000.); // Motion blur\n  vec2 np = (gl_FragCoord.xy + rand.xy * 0.5) / iResolution.xy * 2. - 1.;\n  np.y *= iResolution.y/iResolution.x;\n  rand = abs(D(rand*2.));\n  \n  ////////// CAMERA \n  \n  // Used in entry\n  //vec3 origin = vec3(-0.3990, -3.0709, 0.5419);\n  \n  // Add to support camera movement  \n  vec4 mouse = iMouse;\n  if (mouse.z > 1.) fragColor = vec4(0);\n  if (mouse.x < 1. && mouse.y < 1.) mouse = vec4(iResolution.xy * .5, 0, 0); // Default mouse to center\n  vec3 X = vec3(-1.7 + (.5 - mouse.x / iResolution.x) * 2. * PI, 1.525 + (mouse.y / iResolution.y - .5) * PI, 3.1);  \n  vec3 origin = vec3(sin(X.y) * cos(X.x), sin(X.y) * sin(X.x), cos(X.y)) * X.z + vec3(0,0,.4);\n  // End of addition  \n  \n  \n  vec3 fw = normalize(vec3(0,0,.4) - origin);\n  vec3 rt = normalize(cross(fw, normalize(vec3(0,0,1))));\n  mat3 transform = mat3(rt, fw, cross(rt, fw));\n  float len = length(np);\n  vec3 dir = normalize(transform * vec3(np / len * sin(len), cos(len)).xzy);\n  vec3 color = vec3(1);\n  vec3 result = vec3(0);\n\n  fw = origin + dir * 3.; // Focus distance\n  origin += transform * vec3(rand.x, 0, rand.y) * .05; // Depth of field\n  dir = normalize(fw - origin);\n\n  for (int i = 0; i < 4; i++) { // Bounces\n    float dist = .001;\n    for (int i = 0; i <150; i++) { // Shadows i from surrounding loop, but we don't care\n      field(origin + dir * dist);\n      curDist *= inside;\n      dist += max(curDist, 0.0005);\n      if (curDist < 0.0001 || dist > 9.) break;\n    }\n\n    if (dist > 0.0 && dist < 9.) {\n      rand = abs(D(rand*2.));\n      vec3 pos = origin + dir * dist;\n      vec3 normal = calcNormal(pos);\n      vec3 diffuse = vec3(.56);\n      float eta = 1.08 - 0.42 * inside;\n      float spots = 0.;\n      float fresnel = 0.;\n      float blue = 0.;\n\n      if (material.w == 3. && length(material.xy) > .52) { // body + spout\n        if (flowers(material, 7.5, 10.) > .0) blue = 1.;\n        if (material.z > .64) blue = 1.; // Near rim solid blue\n        if (material.z < -.63) blue = 0.; // White bottom\n        if (length(material.xyz) > 1.17) blue = 1.; // Tip of spout solid blue\n        else if (material.z > .69 ) spots = 1.;\n      } else if (material.w == 4.) { // lid\n        if (flowers(material - vec4(0,0,-.25,0), 2.5, 4.) > 0.) blue = 1.;\n        if (material.z > .205) spots = 1.;\n        if (material.z < -.01) blue = 0.;\n      } else if (material.w == 2.)  // handle\n        spots = dot(normal, normalize(pos-vec3(-2.3, .2, 1.4)));\n      else if (material.w == 0.) { // needle\n        float n = noise(material.xyz * vec3(150,150,2));\n        diffuse = mix(vec3(0.97, 0.8, 0.7), vec3(.72, .49, .28), n * n) * .6;\n      } else if (material.w == 1.) // knitting\n        diffuse = mix(\n          vec3(1, .2, 0),\n          vec3(1,0.718,0.012),\n          fract(material.y * PI)\n        ) * .4;\n\n      if (material.w > 1.) { // Not needle, knitting\n        float cosThetaI = abs(dot(dir, normal));\n        float sinThetaTSq = eta * eta * (1.0 - cosThetaI * cosThetaI);\n        if (sinThetaTSq > 1.0) fresnel = 1.0; // Total internal reflection\n        else {\n          float cosThetaT = sqrt(max(1.0 - sinThetaTSq, 0.0));\n          float rs = (eta * cosThetaT - cosThetaI) / (eta * cosThetaT + cosThetaI);\n          float rp = (eta * cosThetaI - cosThetaT) / (eta * cosThetaI + cosThetaT);\n          fresnel = mix(0.04, 1.0, (rs * rs + rp * rp) * .5);\n        }\n      }\n\n      if (rand.z < fresnel || material.w == 6.) { // Reflect / clear coat or spoon\n        dir = reflect(dir, normal);\n        if (material.w < 5.) // Blurry teapot + lid\n          dir = normalize(dir + cosineSampleHemisphere(normal) * .06);\n      } else if (material.w == 7.) { // Refract\n        if (inside < 0.)\n          color *= exp(-(1. - vec3(1., .4, .2)) * dist * 35.); // Absorption\n        dir = refract(dir, normal * inside, eta);\n        inside *= -1.;\n      } else {\n        if (spots > 0.) {\n          vec3 a = material.xyz  * 20.;\n          vec3 fp = floor(a);\n          blue = 1. - smoothstep(.3, .1, length(.5 - (a - fp) - D(fp) * .3));\n        }\n        color *= mix(diffuse, vec3(.035, .1, .314), blue);\n        dir = cosineSampleHemisphere(normal);\n      }\n\n      origin = pos + normal * 0.005 * inside;\n\n    } else {\n      float coord = atan(dir.y, dir.x);\n      float f = (1. + dir.z) * .5 + .1;\n      if (abs(dir.z) < .6 && coord > -1. && coord < .2)\n        result = color * 2.5; // Fill Right side\n      else if (abs(dir.z) < .6 && coord < -2.2)\n        result = color * 6.5; // Primary\n      else {\n        dir = qRotate(dir, normalize(vec4(0, 0,  -0.14, 0.99 + time *.3)));\n        result = color\n          * f * f * f * (.5 + .5 * dir.y)\n          * (sin(atan(dir.z, dir.x) * 12.) < 0. ? vec3(.3,.27,.24) : vec3(.19,.22,.24));\n      }\n\n      break;\n    }\n  }\n\n  fragColor = vec4(\n    mix(fragColor.rgb, result, 1. / (fragColor.w + 1.)),\n    fragColor.w + 1.\n  );\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVXzK.jpg", "access": "api", "license": "apache-2.0", "functions": [[590, 590, 606, 620, 746], [748, 748, 803, 803, 964]], "test": "untested"}
{"id": "DsVXzK", "name": "Pins&Needles", "author": "blackle", "description": "4k exegfx for revision 2023", "tags": ["4kexegfx"], "likes": 42, "viewed": 488, "published": 3, "date": "1681321802", "time_retrieved": "2024-07-30T18:00:56.395794", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n#define FK(k) floatBitsToInt(k*k*7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a); int y = FK(b);\n  return float((x-y*y)*(x*x+y)-x)/2.14e9;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv=(fragCoord/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    float noise = hash(uv.x,uv.y);\n    fragColor = pow(smoothstep(vec4(-.1,-.12,-.16,0.)*.5,vec4(1.5),sqrt(\n        fragColor/fragColor.w/4.*(1.0 - dot(uv,uv)*0.6))\n    ) + noise*.025,vec4(1.2,1.15,1.1,1.0));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat linedist(vec3 p, vec3 a, vec3 b, float sc) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k+cos((k*k*k)*dot(b-a,b-a)*23.)*sc,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat knob(vec3 p, float sc) {\n    p = abs(p);\n    p = erot(p,normalize(vec3(1,1,0)),.95);\n    p -= .6-sc*5.;\n    p = abs(p);\n    return linedist(p,vec3(0),vec3(.5),sc)-sc;\n}\n\nfloat scene(vec3 p) {\n    float d = 100000.;\n    \n    vec3 op = p;\n    for (int i = 0; i < 10; i++) {\n        float a = float(i);\n        p = erot(op, normalize(vec3(sin(a), cos(a*3.34), sin(a*-4.2+4.))), .5);\n        d = min(d,knob(p,mix(.02,.01,float(i)/8.)));\n    }\n    return d;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\n\n#define FK(k) floatBitsToInt(k*k*7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a); int y = FK(b);\n  return float((x-y*y)*(x*x+y)-x)/2.14e9;\n}\n\nvec3 pixel_color( vec2 uv, float hs )\n{\n    uv.x += .25;\n    float animorphic = 2.39;\n    uv.y /= animorphic;\n    // float hs = hash(hash(uv.x,uv.y),t);\n    float hs2 = hash(hs,4.);\n    float hs3 = hash(hs,6.);\n    vec3 off = normalize(tan(vec3(hs,hs2,hs3)))*.015;\n    vec3 init = vec3(-1.75,1.1,.0);\n    vec3 cam = normalize(vec3(1.2+off.x,uv));\n    cam = erot(cam,vec3(1,0,0),off.z);\n    \n    init = erot(init,vec3(0,0,1),5.48);\n    cam = erot(cam,vec3(0,0,1),5.48);\n    cam.z *= animorphic;\n    cam = erot(cam,normalize(vec3(-2,1,0)),.5);\n    \n    vec3 p = init;\n    float atten = 1.;\n    for (int i = 0; i < 250; i++) {\n        float dist = scene(p);\n        if (abs(dist) < 0.0001) {\n            vec3 n = norm(p);\n            atten *= (1.-abs(dot(cam,n))*.98)*.9;\n            cam = reflect(cam,n);\n            p += n*.001;\n        }\n        p += cam*dist*mix(1.,1.3,smoothstep(.2,1.,dist));\n        if (distance(init,p)>10.) break;\n    }\n    return vec3(8.*atten);\n}\n\nbool logo(vec2 uv) {\n    float id = round(uv.y * 10.5);\n    vec2 uv2 = vec2(uv.x, id / 10.5);\n    if (length(uv2*vec2(1.0,0.8) + vec2(0.75, 0.0)) < 1. && length(uv2) < .9) return mod(id,2.) > .5;\n    if (length(uv)<1.&&uv.x<0.)return true;\n    return abs(length(uv) - 1.) < 0.07;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=(fragCoord/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iFrame == 0) {\n        fragColor = vec4(0);\n    }\n    \n    float noise = hash(uv.x,uv.y);\n    float hs = hash(noise,float(iFrame));\n    float hs2 = hash(hs,345.);\n\n    uv+=vec2(hs,hs2)/iResolution.x;\n\n    if (abs(uv.y) > 1./2.39) {\n        fragColor += vec4(.01,.011,.012,1);\n        return;\n    }\n    if (logo((uv+vec2(-.83,.36))*40.)) {\n        fragColor += vec4(2,2,2, 1);\n        return;\n    }\n    vec3 col = pixel_color(uv, hash(hs,25.));\n    fragColor += vec4(col, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVXzK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[250, 250, 280, 280, 356], [358, 358, 411, 411, 762]], "test": "untested"}
{"id": "DsKSRK", "name": "double event refraction RT", "author": "natet", "description": "RT shader that has 2 refraction events for a sphere SDF", "tags": ["raytracing"], "likes": 1, "viewed": 129, "published": 3, "date": "1681320061", "time_retrieved": "2024-07-30T18:00:57.153768", "image_code": "Sphere sphere1 = Sphere(2.5,1.0,64.0,vec3(0.9,0.9,0.0),vec3(0.0,0.0,8.0));\n\nLight light = Light(vec3(0.8,0.5,0.8),vec3(20.0,40.0,-30.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Move stuff around\n    sphere1.pos = vec3(cos(iTime*1.25)*6.0+2.0,sin(iTime*1.25)*2.0,8.0 +(sin(45.17+iTime*1.25)*4.0));\n    //light.pos = vec3(sin(iTime)*50.0,(cos(iTime)*40.0)+30.0,-30.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Make a value to correct for the aspect ratio. If the screen was always square this wouldnt be necessary. \n    float xCorrect = max(iResolution.x, iResolution.y) / min(iResolution.x, iResolution.y);\n    \n    //make a 2D vector of the current pixel's position, normalized to 0-1 and shifted on the X so that the world is centered (also dont know why this is necessary), and scale the X values so that it corrects for the aspect\n    //ratio distortion. \n    vec2 normalizedPosition = vec2(map(fragCoord.x-(iResolution.x/4.5),0.0,iResolution.x,0.0,1.0)*xCorrect,map(fragCoord.y,0.0,iResolution.y,0.0,1.0));\n\n    //Make the current lookVector for this pixel by converting the normalized pixel position we just made to be between -0.5 and 0.5 for x and y (this is because im not doing anything with camera projection or parameters.\n    //The camera view is always looking straight ahead (toward +ve z in world space) and the FoV is set by the screen resolution.)\n    vec3 lookVector = vec3(normalizedPosition.x-0.5, normalizedPosition.y-0.5, 1.0);\n\n    //Set the ray origin vector\n    vec3 origin = vec3(0,0,0);\n    \n    //calculate the distance along the ray of the first and second intersctions with the sphere\n\tfloat t0 = SphereIntersection(origin, lookVector, sphere1.pos, sphere1.radius, false);\n\tfloat t1 = SphereIntersection(origin, lookVector, sphere1.pos, sphere1.radius, true);\n    \n    vec2 offset = vec2(0.5+mod(iTime*0.075,1.0),0.0);\n    vec2 scale = vec2(2.0,1.0);\n    \n    \n    // Output to screen\n    if(t0 > 0.0){\n        vec4 col = calcReflection(origin, lookVector, sphere1.pos, t0, offset, scale, iChannel0);\n        col = (col*0.5) + 0.5*calcRefraction(origin, lookVector, sphere1.pos, sphere1.radius, t0, offset, scale, 2.3, iChannel0);\n        fragColor = col;\n        //fragColor = calcReflection(origin, lookVector, sphere1.pos, t0, offset, scale, iChannel0);\n        //fragColor = calcRefraction(origin, lookVector, sphere1.pos, t0, offset, scale, 1.1, iChannel0);\n    } else {\n        fragColor = calcEnv(lookVector, offset, vec2(scale.x,scale.y*-1.0), iChannel0);\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926538\n\nstruct Sphere\n{\n    float radius;\n    float ID;\n    float shininess;\n    vec3 col;\n    vec3 pos;\n};\n\nstruct Light\n{\n    vec3 col;\n    vec3 pos;\n};\n\n//https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9 glsl map function\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//Based on https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\nfloat SphereIntersection(vec3 O, vec3 D, vec3 C, float R, bool backfacing){\n\t//I'll try to comment how this function works but its been so long since I wrote it for my terrible CPU oF raytracer that I don't really remember, but it is based on the analytical solution from the above URL.\n\t//Analytical algebra is not something I was ever taught (atleast properly) at school, so I'm not quick at it at the best of times, let alone when it's being used with vectors. \n\t//O = origin\n\t//D = look/ray direction\n\t//C = sphere position\n\t//R = sphere radius\n\t//Calculate the origin of this ray relative to the location of the sphere\n\tvec3 newOrigin = O - C;\n\n\t//Define the values for the analytical solution based on the geometric parameters of the ray and the sphere. \n\tfloat a = dot(D,D);\n\tfloat b = 2.0 * dot(newOrigin,D);\n\tfloat c = dot(newOrigin,newOrigin) - (R*R);\n\n\t//Calculate the discriminant for the components of the quadratic function outline in the linked article that we just calculated above\n\tfloat delta = (b * b -  4.0 * a * c);\n\n\tfloat t0;\n\tfloat t1;\n\n\t//If the discriminant (delta) is < 0 then the ray hasn't intersected anything (there is no root of the quadratic equation)\n\t//First Interesction Logic:\n\tif(delta < 0.0){\n\t\t//For actual rendering, t should be set to -1 so that it makes the returned vector 0:\n\t\tt0 = -1.0;\n\t} \n\t//if delta > 0 then there is atleast one root to the equation, so the ray has intersected something, so we want to output the distance along the ray that this has happened. \n\telse {\n\t\t\n\t\t//Calculate the numerator of the quadratic for the -sqrt(delta) root.\n\t\tfloat numerator = (-1.0 * b - sqrt(delta)) / (2.0 * a);\n\n\t\t//if this numerator is >= 0 then its the right root and we can write it to the t0 variable, for the first intersection. If not, make t0 the +sqrt(delta) root.\n\t\tif (numerator >= 0.0){\n\t\t\tt0 = numerator;\n\t\t}\n\t\telse {\n\t\t\tt0 = (-1.0 * b + sqrt(delta)) / (2.0 * a);\n\t\t}\n\t}\n\n\t//Second Intersection Logic: \n\tif (delta < 0.0) {\n\t\tt1 = -1.0;\n\n\t}\n\telse {\n\n\t\t//Calculate the numerator of the quadratic for the -sqrt(delta) root.\n\t\tfloat numerator = (-1.0 * b - sqrt(delta)) / (2.0 * a);\n\n\t\t//if this numerator is *NOT* >= 0 then its the right root and we can write it to the t1 variable, for the first intersection. If not, make t1 the +sqrt(delta) root.\n\t\tif (!(numerator >= 0.0)) {\n\t\t\tt1 = numerator;\n\t\t}\n\t\telse {\n\t\t\tt1 = (-1.0 * b + sqrt(delta)) / (2.0 * a);\n\t\t}\n\n\t}\n\n\tif (!backfacing) {\n\t\t//Return the first intersection\n\t\treturn t0;\n\t}\n\telse {\n\t\t//Return the second intersection\n\t\treturn t1;\n\t}\n}\n\n//Also based on https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection , see the \"Computing the Normal at the Intersection Point\" section\nvec3 getSphereNormal(vec3 O, vec3 D, vec3 C, float T){\n\t//O = ray origin\n\t//D = look/ray direction\n\t//C = sphere centre position\n\t//T = distance along the ray of intersection, so either t0 or t1 in this usecase\n\t//Calculate the vector for the point on the sphere that our ray hit\n\tvec3 P = O + T * D;\n\t//Calculate the normal of this point by subtracting the sphere's location from the location of the ray hit\n\tvec3 N = P - C;\n\treturn normalize(N);\n}\n\nvec4 calcReflection(vec3 O, vec3 D, vec3 C, float T, vec2 offset, vec2 scale, sampler2D tex) {\n    //ray hitpoint\n    vec3 surfacePosition = O + T * D;\n    //Normal at hitpoint\n    vec3 normal = getSphereNormal(O,D,C,T);\n    // Compute direction from eye to the surface position\n    // Note: eye is at (0,0,0) in view space\n    vec3 eyeDir = normalize(surfacePosition);\n\n    // Compute reflection direction\n    vec3 reflDir = reflect(eyeDir, normal);\n\n    vec3 worldSpaceReflDir = normalize(reflDir);\n    \n    // Calculate direction of reflection in polar coordinates\n    float theta = atan(worldSpaceReflDir.z, worldSpaceReflDir.x);\n    float phi = asin(worldSpaceReflDir.y);\n    // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n    vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n    // Lookup the color from the reflection map\n    return texture(tex, fract((envLookupCoords+offset)*scale));\n}\n\nvec4 calcEnv(vec3 D, vec2 offset, vec2 scale, sampler2D tex) {\n\n    // Calculate direction of environment in polar coordinates\n    float theta = atan(D.z, D.x);\n    float phi = asin(D.y);\n    // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n    vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n    // Lookup the color from the reflection map\n    return texture(tex, fract((envLookupCoords+offset)*scale));\n\n}\n\nvec4 calcRefraction(vec3 O, vec3 D, vec3 C, float R, float T, vec2 offset, vec2 scale, float ior, sampler2D tex) {\n\t//O = ray origin\n\t//D = look/ray direction\n\t//C = sphere centre position\n\t//T = distance along the ray of intersection, so either t0 or t1 in this usecase\n    //ray at hitpoint\n    vec3 surfacePosition = O + T * D;\n    //Normal at hitpoint\n    vec3 normal = getSphereNormal(O,D,C,T);\n    \n    \n    float eta = 1.0/ior;\n\n    // Compute direction from eye to the surface position\n    // Note: eye is at (0,0,0) in view space\n    vec3 eyeDir = normalize(surfacePosition);\n\n    // Compute refraction direction for the first intersection (front of sphere)\n    vec3 refrDir = refract(eyeDir, normal, eta);\n    \n    //Ray trace from the refraction direction to hit the back of the sphere\n    float newHit = SphereIntersection(surfacePosition, refrDir, C, R, false);\n    \n    if(newHit < 0.0){\n        vec3 newHitPos = surfacePosition + newHit * eyeDir;\n        vec3 newNormal = getSphereNormal(surfacePosition, eyeDir, C, newHit);\n        vec3 newEyeDir = normalize(newHitPos);\n        vec3 newRefrDir = refract(newEyeDir, newNormal, eta);\n        vec3 worldSpaceReflDir = normalize(newRefrDir);\n        // Calculate direction of refraction in polar coordinates\n        float theta = atan(worldSpaceReflDir.z, worldSpaceReflDir.x);\n        float phi = asin(worldSpaceReflDir.y);\n        // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n        vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n        // Lookup the color from the environment map\n        return texture(tex, fract((envLookupCoords+offset)*scale));\n    } else {\n\n        vec3 worldSpaceReflDir = normalize(refrDir);\n\n        // Calculate direction of refraction in polar coordinates\n        float theta = atan(worldSpaceReflDir.z, worldSpaceReflDir.x);\n        float phi = asin(worldSpaceReflDir.y);\n        // Use polar coordinates to calculate the texture co-ordinates to lookup from the environment map\n        vec2 envLookupCoords = vec2(0.5 * theta / PI + 0.5, 0.5 - phi / PI);\n\n        // Lookup the color from the environment map\n        return texture(tex, fract((envLookupCoords+offset)*scale));\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 196, 225, 2597]], "test": "untested"}
{"id": "dsKSDh", "name": "Path tracer attempt 3 v2.3", "author": "pathtracerenthusiast", "description": "A path tracer with bloom, HDR, glossy reflections, multiple shapes, large amounts of configuration, glass, lights, and a good sky. Ive used stuff from Sebastian Lague and stuff produced by Bing AI and Ingo Quilez. Only10288 chars.", "tags": ["pathtracer"], "likes": 1, "viewed": 226, "published": 3, "date": "1681307384", "time_retrieved": "2024-07-30T18:00:58.108216", "image_code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings, go to the 'Buffer B' tab.\n//To set or rwmove the maximum fnumber of frames go to the 'Common' tab.\n\n#define Bloom\n\n//I used the Bing AI to improve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  float n = 1./float(2*w*w);\n  const float invpi = 1./PI;\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      float weight = n*invpi*exp(-float(x*x+y*y)*n);\n      //float weight = 1.;\n      color += texture(s, uv).xyz*weight;\n    }\n  }\n  return color;\n}\n\n#define size 2.75*((R.x+R.y)*.00119048)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    vec2 p = R-10.;\n    if(i.x>=p.x&&i.y>=p.y&&iFrame>maxFrame){o=vec4(1.);return;}\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    #ifdef Bloom\n    #ifdef maxFrame\n    if(iFrame>=maxFrame)\n    #endif\n    o.xyz += blur(iChannel1,i/R,int(size));\n    #endif\n    \n    //Comment out the above and uncomment the below to see what will be bloomed.\n    //o.xyz = texelFetch(iChannel1,ivec2(i),0).xyz;\n    \n    o /= o+1.;\n    o = pow(o,vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.1415926523\n#define d2r(a) a*(PI/180.)\n\n#define maxFrame 1000\n\nfloat _seed;\nfloat rand(void) {\n    _seed += 1.;\n    return fract(81.29*sin(38.23*+_seed-12.13)-12.21);\n}\nvec2 rand2(void) {return vec2(rand(),rand());}\nfloat srand(float s) {\n    return fract(37.12*sin(91.04*s-76.82)-19.35);\n}\nvoid irand(vec2 c,float f){\n    _seed = srand(f)*f+srand(c.x)*c.y+srand(c.y)*c.x;\n}\n\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\n\n\nstruct Mat {\n    float r;\n    vec3 col;\n    vec3 ems;\n    float spch;\n    vec3 spcl;\n    float refidx;\n    bool refq;\n};\n\n\nstruct AABB {\n    vec3 minv,maxv;\n};\n\nstruct SphBody {\n    vec3 c;\n    float rad;\n    bool isActive;\n};\n\nstruct BoxBody {\n    vec3 pos,size,rot;\n    bool isActive;\n};\n\nstruct QuadBody {\n    vec3 v0,v1,v2,v3;\n    bool isActive;\n};\n\nstruct Obj {\n    SphBody sph;\n    BoxBody box;\n    QuadBody quad;\n    Mat mat;\n    AABB bound;\n};\n\nstruct BVHNode {\n    AABB bound;\n    uint left,right;\n};\n\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct NewHit {\n    float len;\n    vec3 nor;\n    Obj o;\n    bool ff;\n};\n\nstruct IntRes {\n    float len;\n    bool ff;\n};\n\n#define DefaultSph SphBody(vec3(0.),0.,false)\n#define DefaultBox BoxBody(vec3(0.),vec3(0.),vec3(0.),false)\n#define DefaultQuad QuadBody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),false)\n\n#define objC 9\nstruct NewWorld {\n    Obj objs[objC];\n    Viewer camera;\n};\n\nObj Obj_Sphere(vec3 pos,float rad,Mat m){\n    AABB bound = AABB(pos-rad-.0001,pos+rad+.0001);\n    return Obj(SphBody(pos,rad,true),DefaultBox,DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowSphere(vec3 pos,float rad,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Sphere(pos,rad,m);\n    objlst[idx1] = Obj_Sphere(pos,thickness-rad,m);\n}\n\nObj Obj_Box(vec3 pos,vec3 size,vec3 rot,Mat m){\n    AABB bound = AABB(pos-2.*size-.001,pos+2.*size+.0001);\n    return Obj(DefaultSph,BoxBody(pos,size,rot,true),DefaultQuad,m,bound);\n}\n\nObj Obj_Quad(vec3 v0,vec3 v1,vec3 v2,vec3 v3,Mat m){\n    vec3 minv = min(min(v0,v1),min(v2,v3));\n    vec3 maxv = max(max(v0,v1),max(v2,v3));\n    AABB bound = AABB(minv,maxv);\n    return Obj(DefaultSph,DefaultBox,QuadBody(v0,v1,v2,v3,true),m,bound);\n}\n\nIntRes newSphereInt( in vec3 ro, vec3 rd, SphBody sph) {\n    ro -= sph.c;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sph.rad*sph.rad;\n    float h = b*b - c;\n    if( h<0. ) return IntRes(-1.,false);\n    h = sqrt( h );\n    if(length(ro)<=sph.rad){\n        return IntRes(-b+h,false);\n    }else{\n        return IntRes(-b-h,true);\n    }\n}\n\nbool insideAabb(vec3 p,vec3 s){\n    return (p.x<=s.x&&p.x>=-s.x)&&(p.y<=s.y&&p.y>=-s.y)&&(p.z<=s.z&&p.z>=-s.z);\n}\n\nIntRes newBoxInt( in vec3 ro, in vec3 rd, BoxBody box) {\n    mat3 r = rot3(-box.rot);\n    ro -= box.pos;\n    ro, rd *= r;\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return IntRes(-1.,false);\n    if(insideAabb(ro,box.size)){\n        return IntRes(tF,false);\n    }else{\n        return IntRes(tN,true);\n    }\n}\n\nfloat newQuadInt(vec3 ro,vec3 rd,QuadBody q){\n    vec3 n = cross(q.v1-q.v0,q.v2-q.v0);\n    float d = dot(n, q.v0);\n    \n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    return -1.;\n}\n\nbool aabbInt(in vec3 ro,vec3 rd,AABB box){\n    vec3 a = .5*(box.maxv+box.minv);\n    vec3 d = .5*(box.maxv-box.minv);\n    vec3 m = 1./rd;\n    vec3 n = m*(ro-a); \n    vec3 k = abs(m)*d;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return false;\n    return true;\n}\n\n\n\nconst float bias = 1.0001;\nvec3 newBoxNor(vec3 p,BoxBody b){\n    vec3 q = p-b.pos;\n    vec3 d = b.size;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float x = rand()*2.-1.;\n    float z = rand();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nfloat reflectance(float cosv,float refidx){\n    float r0 = (1.-refidx)/(1.+refidx);\n    r0 *= r0;\n    return r0+(1.-r0)*pow(1.-cosv,5.);\n}", "buffer_a_code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n#define shutAp .6\n#define fcsDist 4.5\n#define blurAmt .048\n#define numLvls 4\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\n#define BeautifulSky\nconst float mode = 0.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\n\n\nvoid sort(inout AABB boxes[2*objC-1],int axis){\n    float vs[boxes.length()];\n    if(axis==0) for(int i = 0; i<boxes.length();i++){\n        vs[i] = boxes[i].minv.x;\n    }\n    else if(axis==1) for(int i = 0; i<boxes.length();i++){\n        vs[i] = boxes[i].minv.y;\n    }\n    else for(int i = 0; i<boxes.length();i++){\n        vs[i] = boxes[i].minv.z;\n    }\n    \n    float avrg = 0.;\n    for(int i = 0; i < boxes.length(); i++) {\n        avrg += vs[i];\n    }\n    avrg /= float(boxes.length());\n    \n    int highid = 0;\n    int lowid = 0;\n    AABB high[boxes.length()/2];\n    AABB low[boxes.length()-high.length()];\n    for(int i = 0; i < boxes.length(); i++) {\n        if(vs[i]<=avrg) {low[lowid] = boxes[i];lowid++;}\n        else {high[highid] = boxes[i];highid++;}\n    }\n    int boxid = 0;\n    for(int i = 0; i < low.length(); i++) {\n        boxes[boxid] = low[i];\n        boxid ++;\n    }\n    for(int i = 0; i < high.length(); i++) {\n        boxes[boxid] = high[i];\n        boxid ++;\n    }\n}\n\nNewWorld getNewWorld(float t){\n    NewWorld world;\n    Viewer cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(1.5,2.,-2.));\n    \n    mat2 rx = rot(d2r(0.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(0.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(0.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.objs[0] = Obj_Sphere(vec3(0.,-1002.001,0.),1000.,Mat(.75,vec3(.3,.4,1.),vec3(0.),.5,vec3(.2,.5,.15),1.52,false));\n    createObj_HollowSphere(vec3(-1.5,-.5,3.),1.5,.4,1,8,Mat(.2,vec3(1.),vec3(0.),0.,vec3(1.),1.52,true),world.objs);\n    world.objs[2] = Obj_Sphere(vec3(1.5,-1.,2.),1.,Mat(.8,vec3(1.),vec3(0.),0.,vec3(1.),1.52,true));\n    world.objs[3] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(3.5,-2.,-2.),vec3(3.5,-2.,3.5),vec3(-3.5,-2.,3.5),Mat(.7,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false));\n    world.objs[4] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(-3.5,5.,-2.),vec3(-3.5,5.,3.5),vec3(-3.5,-2.,3.5),Mat(.5,vec3(1.,0.,0.),vec3(0.),0.,vec3(1.,0.,0.),1.52,false));\n    world.objs[5] = Obj_Quad(vec3(3.5,-2.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(3.5,-2.,3.5),Mat(.5,vec3(0.,1.,0.),vec3(0.),0.,vec3(0.,1.,0.),1.52,false));\n    world.objs[6] = Obj_Quad(vec3(-3.5,5.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(-3.5,5.,3.5),Mat(0.,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false));\n    world.objs[7] = Obj_Box(vec3(0.,4.,.5),vec3(.75,.25,.75),d2r(vec3(0.)),Mat(.5,vec3(.75,.775,.9),vec3(5.),0.,vec3(0.),1.52,false));\n    \n    //TODO: Generate bounding boxes\n    \n    \n    world.camera = cam;\n    return world;\n}\n\nNewHit newInt(vec3 ro,vec3 rd,Obj objs[objC]){\n    NewHit h;\n    h.len = -1.;\n    \n    for(int i = 0; i < objC; i++) {\n        Obj o = objs[i];\n        if(!aabbInt(ro,rd,o.bound)) continue;\n        if(o.sph.isActive) {IntRes res = newSphereInt(ro,rd,o.sph);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.box.isActive) {IntRes res = newBoxInt(ro,rd,o.box);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.quad.isActive) {float res = newQuadInt(ro,rd,o.quad);if(res>=.0001&&(res<h.len||h.len<0.)){h.o=o;h.ff=true;h.len=res;}}\n    }\n    \n    Obj o = h.o;\n    vec3 p = ro+rd*h.len;\n    \n    if(o.sph.isActive) h.nor = normalize(p-o.sph.c);\n    else if(o.box.isActive) {BoxBody b = o.box;mat3 r = rot3(b.rot);mat3 rn = rot3(-b.rot);h.nor = newBoxNor(b.pos+(p-b.pos)*rn,b)*r;}\n    else if(o.quad.isActive) {QuadBody q = o.quad;h.nor = normalize(cross(q.v1-q.v0,q.v2-q.v0));}\n    \n    h.nor *= h.ff?1.:-1.;\n    \n    return h;\n}\n\nconst vec3 sunDir = normalize(vec3(.5,1.,.75));\n//Sebastian Lagues's sky function\nvec3 getSky(float t,vec3 rd) {\n    #ifdef BeautifulSky\n    float skyGradT = pow(smoothstep(0.,.4,rd.y),.35);\n    vec3 skyGrad = mix(vec3(.05),vec3(.3,.6,.9),skyGradT);\n    \n    vec3 sun = pow(max(0.,dot(rd,sunDir)),40.)*10.*vec3(1.,.85,.7);\n    \n    float groundT = smoothstep(-.01,0.,rd.y);\n    \n    return mix(vec3(.25),skyGrad,groundT)+sun;\n    #else\n    return vec3(0.);\n    #endif\n}\n\nvec3 newRay(inout vec3 ro,inout vec3 rd,vec3 p,vec3 n,Mat m,float isSpec,bool ff) {\n    vec3 oro = ro; vec3 ord = rd;\n    ro = p;\n    if(m.refq){\n        float refrat = ff?1./m.refidx:m.refidx;\n        float cosT = max(dot(-rd,n),0.);\n        float sinT = sqrt(1.-cosT*cosT);\n        if(refrat*sinT<=1.&&reflectance(cosT,refrat)<=rand()) rd = refract(rd,n,refrat);\n        else rd = reflect(rd,n);\n    }else{\n        vec3 reflected = reflect(rd,n);\n        rd = normalize(mix(reflected,cosDir(reflected),m.r*(1.-isSpec)));\n    }\n    return mix(m.col,m.spcl,isSpec);\n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    #ifdef maxFrame\n    if(iFrame>=maxFrame) {o=texelFetch(iChannel0,ivec2(i),0);return;}\n    #endif\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = floor(iTime*mode)/mode;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        NewWorld world = getNewWorld(ctime);\n        Viewer cam = world.camera;\n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        for(int _j = 0; _j<numLvls;_j++) {\n            NewHit hit = newInt(cam.ro,rd,world.objs); \n            if(hit.len==-1.) {tcol+=getSky(ctime,rd)*fcol;break;}                             \n            \n            vec3 p = hit.len*rd+cam.ro;\n            \n            Mat mat = hit.o.mat;\n            \n            float isSpec = mat.spch>rand()?1.:0.;\n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat,isSpec,hit.ff);\n            \n            #if 1\n            {\n                float r_p = max(fcol.x,max(fcol.y,fcol.z));\n                if(rand()>r_p) break;\n                fcol /= r_p;\n            }\n            #endif\n        }\n        \n        ttcol += tcol;\n    }\n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texture(iChannel0,i/R);\n    o /= o.w;\n    float d = dot(o.xyz,vec3(1.));\n    o.xyz = d>4.?o.xyz:vec3(0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 268, 307, 307, 697]], "test": "untested"}
{"id": "msySRm", "name": "raycast trying to do", "author": "Virg", "description": "raycast", "tags": ["raycast"], "likes": 0, "viewed": 123, "published": 3, "date": "1681305999", "time_retrieved": "2024-07-30T18:00:58.855219", "image_code": "#define PI 3.1415926535\n\nvec3 camPose = vec3(-20.,8.,0.);\nvec3 camDir = vec3(0.8,-0.3,0.2);\n\n                                    \nvec3 light = vec3(0.,20.,0.);\nfloat rev;\nvec2 ext;\nfloat castDist = 100.;\nfloat displayDisCenter = 1.;\n\nfloat stepC = 0.01;\nfloat gFov = PI/2.;\n\n\nvoid rayCast(out vec4 fragColor, vec2 ang);\nvec3 rotateX(vec3 vec, float ang);\nvec3 rotateZ(vec3 vec, float ang);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    camDir.x = cos(iTime);\n    camDir.z = sin(iTime);\n\n    camPose.x = sin(iTime)*40.;\n    camPose.z = -cos(iTime)*40.;\n    \n    light.x = cos(iTime)*20.;\n    light.z = sin(iTime)*20.;\n    \n    rev = iResolution.x/iResolution.y;\n    ext = iResolution.xy;\n    \n    fragColor = vec4(vec3(0),1.0); //bg\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *=rev;\n    float vFov = gFov/rev;\n\n    float gFov2 = gFov/2.;\n    float vFov2 = vFov/2.;\n    \n    \n    vec2 ang = vec2(\n                    gFov*(uv.x/rev)-gFov/2.,\n                    vFov*(uv.y/1.)-vFov/2.\n                   );\n    //ang = vec2(-3.,0.);\n    \n    \n    rayCast(fragColor,ang);\n    \n    //if(distance(vec2(0.7,0.8),uv)<0.1){\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    //}\n    \n\n    // Time varying pixel color\n    \n}\n\n\n\nvec3 rotateXYZ(vec3 vec, vec3 axis, float t){\n    float x2 = vec.x;\n    float y2 = vec.y;\n    float z2 = vec.z;\n    \n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    \n    return axis * (dot(axis,vec)) + cos(t)*cross(cross(axis,vec),axis) + sin(t)*(cross(axis,vec));\n}\n\n\nvoid rayCast(out vec4 fragColor, vec2 ang){\n\n\tvec4 spheres[2];\n\tspheres[0]=vec4(vec3(0.,2.,0.),5.);\n     spheres[1]=vec4(vec3(0.,0.,12.),4.);\n    \n    vec3 diagonalAxis = normalize(cross(camDir,vec3(0.,1.,0.)));\n    \n    vec3 verticalAxis = normalize(cross(camDir,diagonalAxis));\n    \n    \n    \n    vec3 res = rotateXYZ(camDir,verticalAxis,ang.x);\n    res = normalize(rotateXYZ(res,diagonalAxis,ang.y));\n    \n    //gl_FragColor = vec4(vec3(abs(res.x),abs(res.y),abs(res.z)),1.);\n    //return;\n\n    float dist=0.;\n    vec3 color = vec3(0.,0.,0.);\n    bool breakCasting = false;\n\n    for(float i = 1.;i<100.;i+=0.1){\n        if(breakCasting){\n            break;\n        }\n        vec3 pnt = camPose + res*i;\n        \n        dist = i/100.;\n        // pnt.y =1.;\n        if(pnt.y<0.){\n            color=vec3(1.);\n            break;\n        }\n        \n        for(int sp = 0;sp<2;sp++){\n           if(distance(pnt,spheres[sp].xyz)<spheres[sp].w){\n                vec3 normal = normalize(pnt - spheres[sp].xyz);\n                vec3 shapeToLight = normalize(light - pnt);\n                float colorAberation = dot(normal,shapeToLight);\n                float codir = dot(-res,normal)/2.;\n\n                //float val = length(colorAberation);\n                vec3 softLight = vec3(0.5,0.5,0.5);\n                color = mix(softLight,vec3(1.),colorAberation);\n                // color = mix(softLight,color,1.-codir);\n                breakCasting = true;\n                break;\n            //    gl_FragColor = vec4(vec3(1.),1.);\n            //    return;\n           }\n        }\n\n        \n    }\n    color = mix(color,vec3(0.,0.,0.),dist);\n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msySRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 391, 448, 448, 1367], [1371, 1371, 1416, 1416, 1659], [1662, 1662, 1705, 1705, 3326]], "test": "untested"}
{"id": "cdVSDz", "name": "cucube - 4K GFX@Revision2023", "author": "z0rg", "description": "My participation to the 4K executable graphics @revision 2023", "tags": ["cube", "revision", "cucube"], "likes": 18, "viewed": 442, "published": 3, "date": "1681295877", "time_retrieved": "2024-07-30T18:00:59.616184", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 rgb = texture(iChannel0, uv).xyz;\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.35;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nfloat _grid(vec3 p, vec3 sp, float sz)\n{\n    p = mod(p+sp*.5,sp)-sp*.5;\n    return min(length(p.xy)-sz, min(length(p.xz)-sz, length(p.yz)-sz));\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    vec3 pp = p;\n    vec3 repp = vec3(.5);\n    vec3 idp = floor((pp+repp*.5)/repp);\n    pp = mod(pp+repp*.5,repp)-repp*.5;\n    pp += sin(idp)*.2;\n    float hide = (sin(idp.x+idp.z+idp.y)*.5+.5)*.1;\n    acc = _min(acc, vec2(length(pp)-.01+hide, -2.));\n    acc = _min(acc, vec2(length(p)-1., 0.));\n\n    vec3 pc= p;\n    vec3 rep = vec3(1.);\n    vec3 maxRep = 5.*rep;\n    pc = max(-maxRep*.5, pc);\n    pc = min(maxRep*.5, pc);\n    vec3 id =floor((pc+rep*.5)/rep);\n    pc = mod(pc+rep*.5,rep)-rep*.5;\n    vec3 offcir = vec3(.5)*sign(sin(id*vec3(2.,3.,4.)));\n    float shapeSel = mod(id.x+11.*id.y+id.z*2.,2.);\n    float shape = mix(\n    _cube(pc, vec3(.5)), \n    length(pc+offcir)-1., \n    shapeSel);\n    float glob = _cube(p, maxRep-maxRep*.5);\n    \n    shape = max(shape, _cube(pc, vec3(.485)));\n    shape = mix(shape, 100., mod(id.y+mod(id.x+id.z,2.),2.));\n    shape = max(shape, glob);\n    if (shapeSel == 1.)\n    {\n        shapeSel += mod(id.x, 2.);\n    }\n    acc = _min(acc, vec2(shape, shapeSel));\n    \n    float wires = _cucube(pc, vec3(.5), vec3(.001))+.007;\n    wires = max(wires, glob);\n    acc = _min(acc, vec2(wires, -2.));\n    \n    float ground = -p.y+maxRep.y*.5+.007;\n    \n    acc = _min(acc, vec2(ground, -1.));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 30.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.4;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n    vec3 col = n*.5+.5;\n    vec3 ldir = normalize(vec3(1.,-1.,1.));\n    float ldotn = sat(dot(ldir, n));\n    if (res.z == -1.)\n        col = vec3(.1)*ldotn;\n    if (res.z == -2.)\n      col = vec3(1.);\n    if (res.z == 0.)\n        col = vec3(.2)*ldotn;\n    if (res.z > 0.)\n        col = mix(vec3(1.), vec3(1.,0.,0.), res.z-1.);\n    col = col.xxx;\n    col = mix(col, col*vec3(0.988,0.290,0.325), 1.-sat((abs(p.z)-1.)*100.));\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    float d = 6.;\n    vec3 ro = vec3(d,1,-d);\n    vec3 ta = vec3(0.,1.5,0.);\n    vec3 rd = normalize(ta-ro);\n    vec2 dof = (vec2(rand(), rand())-.5)*.1;\n    ro.xy+= dof*3.;\n    rd.xy -= dof*.45;\n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    float depth = 100.;\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(p, n, rd, res);\n        vec3 refl = normalize(reflect(rd, n)\n        +(vec3(rand(), rand(), rand())-.5)*.05);\n        vec3 resrefl = trace(p+n*0.01, refl, 128);\n        if (resrefl.y > 0.)\n        {\n            vec3 prefl = p+n*0.01+refl*resrefl.y;\n            vec3 nrefl = getNorm(prefl, resrefl.x);\n            col += getMat(prefl, nrefl, refl, resrefl)*vec3(0.439,0.459,1.000);\n        }\n    }\n    vec3 red = vec3(0.604,0.071,0.710);\n    col = mix(col, 2.*mix(red.xxx, red,.5)*(1.-sat(abs(uv.x*2.))), 1.-exp(-depth*0.017));\n    return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n    vec2 off = normalize(vec2(1.))*.01*sat(length(uv));\n    vec3 col = vec3(0.);\n    float alea = mod(float(iFrame),3.);\n        col.x = rdr(uv+off).x;\n        col.y = rdr(uv).y;\n        col.z = rdr(uv-off).z;\n    return col;\n}\n/*\nvoid main()\n{\n    vec2 ouv = (fragCoord)/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    // taken frm luna // \t// seed the RNG (again taken from Devour)\n    _seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n    vec3 col = pow(rdr2(uv), vec3(1.5))*1.5;\n    col += pow(rdr(uv+(vec2(rand(), rand())-.5)*.1), vec3(2.));\n    col = sat(col);\n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n    \n\n    col = sat(col);\n    //if (iFrame != 0)\n    //col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord)/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    // taken frm luna's blossom // seed the RNG (again taken from Devour)\n    _seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n    vec3 col = pow(rdr2(uv), vec3(1.5))*1.5;\n    col += pow(rdr(uv+(vec2(rand(), rand())-.5)*.1), vec3(2.));\n    col = sat(col);\n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n    \n\n    col = sat(col);\n    if (iFrame != 0)\n        col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVSDz.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 570]], "test": "untested"}
{"id": "csySzy", "name": "Steins;Gate synth", "author": "Peace", "description": "Synthesizes steins;gate's \"gate of steiner -piano-\" MIDI.\n- With destructive wave interference, try putting two stereo speakers together, it will get quiter.\n- Wrote custom MIDI to glsl converter program for this", "tags": ["sound", "music", "piano", "synth", "synthesizer", "gate", "midi", "steins"], "likes": 3, "viewed": 351, "published": 3, "date": "1681294873", "time_retrieved": "2024-07-30T18:01:00.365181", "image_code": "float getSound(float x)\n{\n    return MainSound(0, x + iTime).x;\n}\n\n//Math constants\n#define PI 3.14159\n#define TWO_PI 6.28318\n\n//Frequency range to which the halo reacts currently set to 0-512hz\n#define FREQ 512.0\n \nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) \n{\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvn = uv * 2.0 - 1.0;\n    uvn.x *= iResolution.x / iResolution.y;\n    \n    float angle = atan(normalize(uvn).x, normalize(uvn).y);\n    float angleNormalized = angle / PI;\n\n    float inner_halo = max(pow(1.0 - abs(length(uvn) - 0.6), 8.0), 0.0) * 2.0;\n    inner_halo *= inner_halo;\n    \n\tfloat outer_halo = max(pow(abs(length(uvn)), 4.0), 0.0) * 0.25;\n    float halo = inner_halo + outer_halo;\n    \n    float s = abs(getSound(abs(angleNormalized) * 2.0));\n    \n    vec3 col = halo * hsv2rgb(vec3(angleNormalized * 0.5 + 0.5 - iTime * 0.1, 1.0, 1.0)) * s;\n    \n    col = pow(col, vec3(2));\n    col += max(length(col) / sqrt(3.0) - 1.0, 0.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time)\n{\n    return MainSound(samp, time);\n}                            ", "sound_inputs": [], "common_code": "const float T = 6.28318531;\n\nfloat x = 0.0; // Current time\nfloat o = 0.0;\n\nfloat w(float freq) {\n    return sin((x * freq + o) * T);\n}\n\nfloat env(float start, float duration, float attack) {\n    float dt = max(0.0, x - start);\n    return min(dt / attack, exp(2.0 * (attack - dt) / sqrt(duration)));\n} \n\nfloat p(float freq, float start, float duration) {\n    float s = 0.0;\n    s += w(freq * 1.0) * 0.15;\n    s += w(freq * 2.0) * 0.2;\n    s += w(freq * 4.0) * 0.075;\n    s += w(freq * 6.0) * 0.015;\n    return s * env(start, duration, 0.001);\n}\n\nfloat music() {\n    float s = 0.0;\n    s+=p(392., 0.02, 0.04)+p(466.16, 0.03, 0.04)+p(622.25, 0.04, 0.04)+p(293.66, 0.12, 0.04)+p(392., 0.20, 0.04)+p(466.16, 0.28, 0.04)+p(587.33, 0.36, 0.04)+p(293.66, 0.44, 0.04)+p(392., 0.52, 0.04)+p(466.16, 0.60, 0.04)+p(554.37, 0.68, 0.04)+p(293.66, 0.76, 0.04)+p(392., 0.84, 0.04)+p(466.16, 0.92, 0.04)+p(587.33, 1., 0.04)+p(293.66, 1.08, 0.04)+p(392., 1.16, 0.04)+p(466.16, 1.24, 0.04)+p(196., 0.04, 1.28)+p(622.25, 1.32, 0.04)+p(440., 1.32, 0.04)+p(293.66, 1.40, 0.04)+p(392., 1.48, 0.04)+p(440., 1.56, 0.04)+p(587.33, 1.64, 0.04)+p(293.66, 1.72, 0.04)+p(392., 1.80, 0.04)+p(440., 1.88, 0.04)+p(554.37, 1.96, 0.04)+p(293.66, 2.04, 0.04)+p(392., 2.12, 0.04)+p(440., 2.20, 0.04)+p(587.33, 2.28, 0.04)+p(293.66, 2.36, 0.04)+p(392., 2.44, 0.04)+p(440., 2.52, 0.04)+p(196., 1.32, 1.28)+p(622.25, 2.60, 0.04)+p(415.30, 2.60, 0.04)+p(261.63, 2.68, 0.04)+p(392., 2.76, 0.04)+p(415.30, 2.84, 0.04)+p(587.33, 2.92, 0.04)+p(261.63, 3., 0.04)+p(392., 3.08, 0.04)+p(415.30, 3.16, 0.04)+p(523.25, 3.24, 0.04)+p(261.63, 3.32, 0.04)+p(392., 3.40, 0.04)+p(415.30, 3.48, 0.04)+p(587.33, 3.56, 0.04)+p(261.63, 3.64, 0.04)+p(392., 3.72, 0.04)+p(415.30, 3.80, 0.04)+p(174.61, 2.60, 1.28)+p(349.23, 3.88, 0.04)+p(523.25, 3.88, 0.04)+p(220., 3.96, 0.04)+p(349.23, 4.04, 0.04)+p(392., 4.12, 0.04)+p(523.25, 4.20, 0.04)+p(220., 4.28, 0.04)+p(349.23, 4.36, 0.04)+p(392., 4.44, 0.04)+p(146.83, 3.88, 0.68)+p(196., 4.52, 0.04)+p(587.33, 4.52, 0.04)+p(493.88, 4.52, 0.04)+p(293.66, 4.68, 0.04)+p(349.23, 4.76, 0.04)+p(174.61, 4.84, 0.04)+p(246.94, 4.86, 0.04)+p(698.46, 4.88, 0.04)+p(622.25, 4.96, 0.04)+p(587.33, 5.04, 0.04)+p(523.25, 5.12, 0.04);\n    s+=p(196., 5.20, 0.04)+p(293.66, 5.28, 0.04)+p(440., 5.36, 0.04)+p(466.16, 5.44, 0.04)+p(1244.51, 5.20, 0.32)+p(622.25, 5.20, 0.32)+p(196., 5.52, 0.04)+p(293.66, 5.60, 0.04)+p(440., 5.68, 0.04)+p(466.16, 5.76, 0.04)+p(587.33, 5.52, 0.32)+p(1174.66, 5.52, 0.32)+p(196., 5.84, 0.04)+p(293.66, 5.92, 0.04)+p(440., 6., 0.04)+p(466.16, 6.08, 0.04)+p(554.37, 5.84, 0.32)+p(1108.73, 5.84, 0.32)+p(196., 6.16, 0.04)+p(293.66, 6.24, 0.04)+p(440., 6.32, 0.04)+p(466.16, 6.40, 0.04)+p(587.33, 6.16, 0.32)+p(1174.66, 6.16, 0.32)+p(196., 6.48, 0.04)+p(277.18, 6.56, 0.04)+p(392., 6.64, 0.04)+p(440., 6.72, 0.04)+p(1244.51, 6.48, 0.32)+p(622.25, 6.48, 0.32)+p(196., 6.80, 0.04)+p(277.18, 6.88, 0.04)+p(392., 6.96, 0.04)+p(440., 7.04, 0.04)+p(1174.66, 6.80, 0.32)+p(587.33, 6.80, 0.32)+p(196., 7.12, 0.04)+p(277.18, 7.20, 0.04)+p(392., 7.28, 0.04)+p(440., 7.36, 0.04)+p(1108.73, 7.12, 0.32)+p(554.37, 7.12, 0.32)+p(196., 7.44, 0.04)+p(277.18, 7.52, 0.04)+p(392., 7.60, 0.04)+p(440., 7.68, 0.04)+p(587.33, 7.44, 0.32)+p(1174.66, 7.44, 0.32)+p(622.25, 7.72, 0.04)+p(830.61, 7.74, 0.04)+p(174.61, 7.76, 0.04)+p(261.63, 7.84, 0.04)+p(392., 7.92, 0.04)+p(415.30, 8., 0.04)+p(1046.50, 7.76, 0.32)+p(523.25, 8.16, 0.04)+p(698.46, 8.24, 0.04)+p(783.99, 8.32, 0.04)+p(207.65, 8.40, 0.32)+p(392., 8.40, 0.32)+p(523.25, 8.40, 0.32)+p(1046.50, 8.40, 0.32)+p(329.63, 8.40, 0.32)+p(196., 8.72, 0.32)+p(130.81, 8.72, 0.32)+p(932.33, 8.72, 0.32)+p(466.16, 8.72, 0.32)+p(174.61, 9.08, 0.04)+p(261.63, 9.16, 0.04)+p(311.13, 9.24, 0.04)+p(392., 9.32, 0.04)+p(415.30, 9.04, 0.68)+p(523.25, 9.06, 0.66)+p(783.99, 9.08, 0.64)+p(87.31, 9.72, 0.68)+p(196., 9.72, 1.28)+p(261.63, 9.72, 1.28)+p(207.65, 9.72, 1.28)+p(130.81, 10.84, 0.16)+p(87.31, 11., 0.24)+p(349.23, 11., 0.24)+p(207.65, 11.24, 0.40)+p(196., 11.24, 0.40)+p(130.81, 11.24, 0.40)+p(87.31, 11.64, 0.24)+p(261.63, 11.24, 0.80)+p(349.23, 12.04, 0.04)+p(261.63, 12.12, 0.04)+p(349.23, 12.20, 0.04)+p(130.81, 11.88, 0.40)+p(196., 11.88, 0.40)+p(207.65, 11.88, 0.40)+p(130.81, 12.28, 0.24)+p(392., 12.28, 0.24)+p(196., 12.52, 0.40)+p(155.56, 12.52, 0.40)+p(233.08, 12.52, 0.40)+p(130.81, 12.92, 0.24)+p(261.63, 12.52, 0.80)+p(392., 13.32, 0.04)+p(261.63, 13.40, 0.04)+p(392., 13.48, 0.04)+p(196., 13.16, 0.40)+p(233.08, 13.16, 0.40)+p(155.56, 13.16, 0.40)+p(155.56, 13.56, 0.24)+p(415.30, 13.56, 0.40)+p(415.30, 13.96, 0.04)+p(466.16, 14.04, 0.04)+p(415.30, 14.12, 0.04)+p(233.08, 13.80, 0.40)+p(207.65, 13.80, 0.40)+p(174.61, 13.80, 0.40)+p(77.78, 14.20, 0.24)+p(392., 14.20, 0.40)+p(392., 14.60, 0.04)+p(622.25, 14.68, 0.04)+p(523.25, 14.76, 0.04)+p(155.56, 14.44, 0.40)+p(196., 14.44, 0.40)+p(233.08, 14.44, 0.40)+p(87.31, 14.84, 0.24)+p(233.08, 15.32, 0.04)+p(196., 15.08, 0.36);\n    return s;\n}\n\nvec2 MainSound(int samp, float time) {\n    x = time / 2.5 - 0.2;\n    \n    float m = music();\n    \n    // Destructive Wave Interference (for fun)\n    // uncomment and when you bring L/R speakers together sound gets quitter\n    //o = 0.5;\n    //float m2 = music(); \n    //return vec2(m, m2);\n    \n    return vec2(m);\n}                            ", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csySzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 65], [216, 216, 238, 238, 407], [409, 409, 434, 434, 484], [486, 486, 543, 543, 1271]], "test": "untested"}
{"id": "ddVSRy", "name": "Black and white rug 2", "author": "jarble", "description": "A fractal rug pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 12, "viewed": 218, "published": 3, "date": "1681281249", "time_retrieved": "2024-07-30T18:01:01.151080", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord)/iResolution.y/16.0\n    + vec2(iTime/2.0,iTime/3.0)/64.;\n    if(iMouse.z>.5)\n    uv = (uv.xy + iMouse.xy / iResolution.xy/4.);\n    float col = 0.;\n    for(int k = 0; k < 9; k++){\n        uv =\n            abs(fract(uv.yx-vec2(uv.x,-uv.y)*2.)-.5)\n        ;\n        col =\n            max(length(uv/2.),col)\n        ;\n        col =\n            max(abs(col*2.-1.),col/4.);\n    }\n    fragColor = vec4(min(vec3(col*2.),vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    a += floor(a/2.);\n    a += floor(a/4.);\n    /*\n    for(float i = 1.; i < mod(floor(a/i),8.); i++){\n        a += mod(floor(a/2.),b)*i;\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    float a1 = a;\n    return\n        mod(floor(a),b)\n        //mod(floor(-a),b+mod(floor(a),b))\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  float tempo = 2.;\n  time /= tempo;\n  float s1 =\n      8.;\n  float s2 = 8.,\n  t=\n      time*4.,\n  m1 =\n      fmod(t*4./(1.+fmod(t*2.,2.)),s2)\n  ,\n  m3 =\n      (fmod(t/(1.+fmod(t*2.,2.)),abs(s2*2.-m1)+1.)-m1);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  float a=\n      64.*(1.-sqrt(fract(t/s1)/1.25))*.2\n      //abs(log(.125/64.+fract(t/s1)/64.))\n  ,\n  nb = time*tempo*pow(2.,floor((m3+m2)/2.)/5.+6.5);\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 539]], "test": "untested"}
{"id": "dsySD1", "name": "stylized clouds", "author": "ArmandB", "description": "for minecraft some day, need to fix some stuff", "tags": ["3d"], "likes": 1, "viewed": 315, "published": 3, "date": "1681268067", "time_retrieved": "2024-07-30T18:01:01.924014", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n}\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159265;\nconst float epsilon = 0.0001;\nconst int maxsteps = 512;\nconst int maxlightsteps = 8;\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\nconst int far = 1000;\nconst float cameraFrustum = 0.7;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n    mat3 transmat;\n};\n\nstruct Hit {\n    bool hit;\n    float dist;\n    vec3 point;\n    vec3 normal;\n    float shadow;\n};\n\n//fakes x^n for specular effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//https://iquilezles.org/articles/noacos/\nmat3 rotationAlign(vec3 d, vec3 z){\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0f/(1.0f+c);\n\n    return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                 v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                 v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    vec3 uvd = normalize(uv);\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 ro = uv*rotmat + cameraPos;\n    vec3 rd = uvd*rotmat;\n    mat3 rottomat = rotationAlign(uvd,vec3(0,0,1));\n    mat3 TransitionMatrix = mat3(\n        vec3(1,0,0)*rottomat*rotmat, \n        vec3(0,1,0)*rottomat*rotmat, \n        vec3(0,0,1)*rottomat*rotmat\n    );\n    return Camera(cameraPos, Ray(ro, rd), uv.xy, TransitionMatrix);\n}\n\nfloat smin( float a, float b, float k){\n     float h = max(k-abs(a-b), 0.0)/k;\n     return min(a, b) - h*h*k*0.25;\n}\n\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat voronoi3d(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                vec3 d = floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)) - uv;\n                n = smin(n,dot(d,d),0.1);\n            }\n        }\n    }\n    return sqrt(n);\n}\n\nfloat voronoi4d(vec4 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                for (int w = -1; w < 2; w++){\n                    n = min(n,distance(floor(uv) + vec4(x,y,z,w) + hash44(floor(uv) + vec4(x,y,z,w)),uv));\n                }\n            }\n        }\n    }\n    return n;\n}", "buffer_a_code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity;\n        \n        if (position.y < -100.0){\n            position = vec3(0,24,0);\n        }\n        \n        if (iFrame == 0){\n            position = vec3(0,6,0);\n        }\n        col.xyz = position;\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//todo:\n//stabilize voxel positions\n//touch ups\n\nconst vec4 cloudLit[] = vec4[](\n    vec4(0.7,0.7,0.8,0.2),\n    vec4(0.8,0.3,0.4,0.25),\n    vec4(1,0.95,0.9,0.3),\n    vec4(1,0.95,0.9,0.7),\n    vec4(0.8,0.3,0.4,0.75),\n    vec4(0.7,0.7,0.8,0.8),\n    vec4(0.7,0.7,0.8,1)\n);\n\nconst vec4 cloudShadowed[] = vec4[](\n    vec4(0.4,0.4,0.5,0.2),\n    vec4(0.5,0.3,0.4,0.25),\n    vec4(0.7,0.7,0.8,0.3),\n    vec4(0.7,0.7,0.8,0.7),\n    vec4(0.5,0.3,0.4,0.75),\n    vec4(0.4,0.4,0.5,0.8),\n    vec4(0.4,0.4,0.5,1)\n);\n\nvec3 lerpGrad(vec4[7] grad, float x){\n    x = fract(x);\n    for (int i = 0; i < grad.length(); i++){\n        if (grad[i].a > x){\n            vec4 gradStart = grad[i - 1];\n            vec4 gradEnd = grad[i];\n            return mix(gradStart.rgb,gradEnd.rgb,smoothstep(gradStart.a,gradEnd.a,x));\n        }\n    }\n}\n\nfloat noise(vec3 x){\n    return textureLod(iChannel1, x/30.0, 0.0).x;\n}\n\nfloat sceneSdf(vec3 p){\n    float v0 = noise(p/64.0);\n    float v1 = noise(p/16.0 + noise(p/vec3(30,5,30)));\n    float v2 = noise(p/8.0 + noise(p/vec3(20,10,20)));\n    float v3 = 1.0 - noise(p/1.5);\n    float yshape = min(abs(p.y*0.07),abs(p.y*0.6-30.0)+0.2);\n    float n = v0*4.0 + v1*2.0 + v2*v1 + v3*v2*0.5 - 3.0 + yshape;\n    return n/2.0;\n}\n\n//https://www.shadertoy.com/view/fstSRH\nHit marchRay2(Ray ray, mat3 transitionMatrix, vec3 lightDir){\n    mat3 inverseTransitionMatrix = inverse(transitionMatrix);\n    vec3 pos = transitionMatrix*ray.origin;\n    vec3 dir = transitionMatrix*ray.direction;\n    float t = 0.0;\n    bool hit = false;\n    \n    for(int i = 0; i < far; i++){\n        vec3 dist = (fract(-pos*sign(dir)) + 1e-4)/abs(dir);\n        float dmin = min(dist.x, min(dist.y, dist.z));\n        \n        pos += dir*dmin;\n        t += dmin;\n        float sdf = sceneSdf(inverseTransitionMatrix*(ceil(pos) - 0.5));\n        if (sdf < 0.0) {\n            hit = true;\n            break;\n        } else if (sdf > 1.0){ //massive fps improvement\n            float stepsize = sdf*sdf*t/(abs(ray.direction.y*1000.0) + 1.0);\n            t += stepsize;\n            pos += dir*stepsize;\n            i += int(sdf*stepsize);\n        }\n    }\n    \n    vec3 lightpos = ceil(pos)-0.5;\n    lightDir = transitionMatrix*lightDir;\n    float shadow = 0.0;\n    \n    for(int i = 0; i < 20; i++){\n        vec3 dist = (fract(-lightpos*sign(-lightDir)) + 1e-4)/abs(-lightDir);\n        float dmin = min(dist.x, min(dist.y, dist.z));\n        \n        lightpos += -lightDir*dmin;\n        if (sceneSdf(inverseTransitionMatrix*(ceil(lightpos) - 0.5)) < 0.0) shadow += 0.08;\n    }\n    \n    //get normal from position\n    vec3 dist = abs(fract(pos) - 0.5);\n    vec3 normal = vec3(0,0,1);\n    if (dist.x >= dist.y && dist.x >= dist.z) normal = vec3(1,0,0);\n    else if (dist.y >= dist.x && dist.y >= dist.z) normal = vec3(0,1,0);\n    \n    pos = inverseTransitionMatrix*pos;\n    normal = inverseTransitionMatrix*normal;\n    normal = faceforward(normal,ray.direction,normal);\n    return Hit(hit, t, pos, normal, shadow*shadow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    vec3 lightDirection = texelFetch(iChannel0, ivec2(6,0),0).xyz;\n    float t = texelFetch(iChannel0, ivec2(6,0),0).w;\n    vec4 col = vec4(0);\n\n    Hit hit = marchRay2(ray, cam.transmat, lightDirection);\n    float interpolant = hit.shadow*0.4;\n    col = vec4(mix(lerpGrad(cloudLit,t), lerpGrad(cloudShadowed,t), clamp(floor(interpolant*6.0)/6.0,0.0,1.0)),1);\n    col = mix(col,vec4(0.4,0.4,0.5,1),clamp(hit.dist/500.0,0.0,1.0));\n    if (!hit.hit){\n        col = vec4(0);\n    }\n\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsySD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 118]], "test": "untested"}
{"id": "DsVXzG", "name": "Year of Truchets #009", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nJust had a timing idea from my last shader", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 16, "viewed": 252, "published": 3, "date": "1681261404", "time_retrieved": "2024-07-30T18:01:02.703929", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #009\n    04/12/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.37,45.93)))*4374.23); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq shapes\nfloat box( vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\nfloat box( vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat speed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,time=0.;\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0);\nmat2 r45,r25;\n\nconst float size = 1.35;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\nconst float spce = size;\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    vec3 q = vec3(0);\n    float id = 0.;\n    p.z+=time;\n    for(int i = 0; i<2; i++)\n    {\n        // based on @Shanes multi-tap stuff\n        // though cut down to two taps\n        float cnt = i==0 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n        vec3 r = q; \n\n        float xid = floor(mod(qf,10.));\n        float t3 = lsp(xid, xid+1., tmod);\n        t3 = eoc(t3);\n        t3 = t3*t3*t3;\n        \n        float sw = t3*size;\n        float ga1 = floor(time*.1)*size;\n        r.z-=sw+ga1;\n        \n        float zid = floor((r.z + hlf)/size);\n        r.z = mod(r.z+hlf,size)-hlf;\n   \n        float hs = hash21(vec2(qf,zid));\n        if (hs>.5) r.x *= -1.;\n\n        vec2 d2 = vec2(length(r.xz-hlf), length(r.xz+hlf));\n        vec2 gx = d2.x<d2.y ? vec2(r.xz-hlf) : vec2(r.xz+hlf);\n        vec3 tq = vec3(gx.x,r.y,gx.y);\n\n        float thk = .2+.1*sin(p.x*.72);//(p.z-sw-ga1)\n        float d3 = box(r,vec3(hlf*.88));\n        float d4 = trs(tq,vec2(hlf,thk));\n\n        \n        if (hs>.6) d4 = min(length(r.yz)-thk,length(r.yx)-thk);\n        if (hs>.07&&hs<.1) d4 = min(length(r.yz)-thk, length(vec3(r.yx,abs(r.z)-hlf))-thk);\n        if (hs<.07) d4 = min(length(r.yx)-thk, length(vec3(abs(r.x)-hlf,r.yz))-thk);\n\n        d4 = max(abs(d4)-.05,-d4);\n        d3 = max(d3,d4);\n\n        if (d3<res.x){\n            hs = fract(hs*432.32);\n            res = vec2(d3,hs<.5?4.:3.);\n            hit= r;\n            gid = vec3(id,qf, 1.);\n        }\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.25:ray.x*.75;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(float t) {\n    t+=T*.045;\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(0.88,.97,.85))); \n}\n\nvec4 FC = vec4(.075);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(10.,15.,25.);\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint*vec3(-1.,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n\n        // materials  \n        if(m==3.){\n            h = hue((25.+sid.y)*.035);\n            ref = h*.5;\n        }\n        if(m==4.){\n            h = vec3(.05);\n            ref = vec3(.05);\n        }\n        C = (diff*h);\n        \n       // C = mix(FC.rgb,C,exp(-.000005*d*d*d));\n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    time = (T+512.32);\n    tmod = mod(time, 10.);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,6.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? .5 : .5-(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n    mat2 rx=rot(1.-.2*sin(T*.1)), ry=rot(.3*sin(T*.1));\n    \n    ro.yz*=rx,ro.xz*=ry;\n    rd.yz*=rx,rd.xz*=ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00075*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVXzG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[483, 483, 502, 502, 547], [548, 548, 570, 570, 625], [626, 626, 670, 670, 725], [726, 726, 746, 746, 784], [786, 799, 827, 827, 916], [917, 917, 948, 948, 1028], [1029, 1029, 1055, 1055, 1124], [1358, 1358, 1379, 1379, 2965], [2967, 2967, 2997, 2997, 3236], [3238, 3238, 3281, 3281, 3511], [3513, 3513, 3532, 3532, 3622], [3646, 3646, 3740, 3740, 4548], [4550, 4550, 4591, 4591, 5490]], "test": "untested"}
{"id": "DsVSRy", "name": "Ethereal Spectrum Cascade", "author": "GPT4POWERUSER", "description": "Ethereal Spectrum Cascade is a captivating shader that generates a constantly repeating, cascading pattern that seemingly extends infinitely upwards. ", "tags": ["colors", "rainbow", "depthoffield", "infinite", "cascade"], "likes": 10, "viewed": 420, "published": 3, "date": "1681255228", "time_retrieved": "2024-07-30T18:01:03.466888", "image_code": "#define t iTime\n#define SAMPLES 10\n#define FOCAL_DISTANCE 4.0\n#define FOCAL_RANGE 6.0\nmat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p){\n    p.xz *= m(t * 0.4);\n    p.xy *= m(t * 0.3);\n    vec3 q = p * 2.0 + t;\n    return length(p + vec3(sin(t * 0.7))) * log(length(p) + 1.0) + sin(q.x + sin(q.z + sin(q.y))) * 0.5 - 1.0;\n}\n\nvec3 hslToRgb(vec3 hsl) {\n    vec3 rgb = clamp(abs(mod(hsl.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return hsl.z + hsl.y * (rgb - 0.5) * (1.0 - abs(2.0 * hsl.z - 1.0));\n}\n\n\n\n\nvec3 getColor(in vec2 fragCoord, in float depth) {\n    vec2 p = fragCoord.xy / iResolution.y - vec2(.9, .5);\n    vec3 cl = vec3(0.);\n    float d = depth;\n\n    for (int i = 0; i <= 5; i++) {\n        vec3 p = vec3(0, 0, 5.0) + normalize(vec3(p, -1.0)) * d;\n        float rz = map(p);\n        float f = clamp((rz - map(p + .1)) * 0.5, -0.1, 1.0);\n\n        float hue = mod(t * 1.0 + float(i) / 5.0, 1.0);\n        vec3 color = hslToRgb(vec3(hue, 1.0, 0.5));\n\n        vec3 l = color + vec3(5.0, 2.5, 3.0) * f;\n        cl = cl * l + smoothstep(2.5, 0.0, rz) * 0.7 * l;\n\n        d += min(rz, 1.0);\n    }\n\n    return cl;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    float depthSum = 0.0;\n    float focalFactor = 0.0;\n\n    for (int i = 0; i < SAMPLES; i++) {\n        float depth = FOCAL_DISTANCE + (float(i) / float(SAMPLES - 1)) * FOCAL_RANGE;\n        vec3 sampleColor = getColor(fragCoord, depth);\n        float weight = 1.0 / (1.0 + abs(depth - FOCAL_DISTANCE));\n\n        color += sampleColor * weight;\n        depthSum += weight;\n    }\n\n    color /= depthSum;\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 102, 102, 150], [152, 152, 170, 170, 357], [359, 359, 384, 384, 553], [558, 558, 608, 608, 1171]], "test": "untested"}
{"id": "DsKXzG", "name": "Three Spinners", "author": "delajor", "description": "Nothing going on here, I snuck this into a product a long time ago as loading easter egg and thought I'd put it here for prosperity.", "tags": ["procedural"], "likes": 3, "viewed": 148, "published": 3, "date": "1681251682", "time_retrieved": "2024-07-30T18:01:04.216883", "image_code": "\n#define M_PI 3.14159265358979323846\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = float(iTime);\n    vec2 p = uv - 0.5 + 0.05*vec2(cos(t), sin(t));\n    float a = atan(p.x, p.y);\n    float l = length(p);\n    float ct  = cos(t);\n    float ct0 = sin(t);\n    float rady = cos(1.5*log(1.0*l) + 0.1*t)*sin(1.5*a + 1.0*ct*log(l));\n    float radx = sin(1.5*log(1.0*l) + 0.1*t)*cos(1.5*a + 1.0*ct*log(l));\n    float a2 = atan(radx, rady);\n    float l2 = length(vec2(radx, rady));\n    float rad2 = sin(log(1.0*l2)+0.1*t)*cos(1.0*a2 - 8.0*l*ct0*log(0.5*l2));\n    float but = l - 0.5;\n    fragColor = vec4(vec3(rad2*rad2),1.0-l2);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 95, 145, 738]], "test": "untested"}
{"id": "dsGXRG", "name": "Fibonacci Cylinder", "author": "delajor", "description": "Trying to build a volume with good sampling characteristics.  Can't quite get a good golden ratio for the z-axis, just guessed.  I'll have to dig a bit more into figuring out how to calculate that ratio.", "tags": ["raytracing"], "likes": 15, "viewed": 345, "published": 3, "date": "1681246798", "time_retrieved": "2024-07-30T18:01:05.059630", "image_code": "#define NUM_SPHERES 2048\n#define PSI  1.533751168755204288118041 \n#define PHI  sqrt(2.0)\n#define GPHI 0.5 * (1.0 +  sqrt(5.0))\n\n#define LIGHT_POWER 30.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, c;\n};\n\nmat3 rotate_around_z(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\n\nmat3 rotate_around_y(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\nSphere getSphere(int i){\n    float N = float(NUM_SPHERES);\n    float t = float(i) / N;\n\n    float sqti = sqrt(t);\n    float sqt1i = sqrt(5.0 - t);\n\n    float u = iMouse.x / iResolution.x;\n    float v = iMouse.y / iResolution.y;\n    float golden = 0.5 * (1.0 + sqrt(5.0));\n    float sup_golden =1.4655712318767680266567312;\n    float psi4 = 1.533751168755204288118041;\n    float plastic = 1.32471795724474602596;\n    float root2 = sqrt(2.0);\n    float root3 = sqrt(3.0);\n    float good_guess = 1.57801;\n    float test = pow(1.0 / 2.0 / PI, 0.5);\n    \n    //float phi = plastic;\n    //float psi = sup_golden;\n    \n    //float phi = sup_golden;\n    //float psi = 0.1*plastic;\n\n    //float phi = root2;\n    //float psi = psi4;\n    \n    float phi = golden;\n    float psi = good_guess;\n    float Nt = N * t;\n    float NtP = (Nt) / psi;\n    float t0 = NtP - floor(NtP);\n    float thet = 2.0 * PI * Nt;\n        \n    float x0 = sqti * cos(thet * phi);\n    float y0 = sqti * sin(thet * phi);\n    float z0 = 2.0 * t0 - 1.0;\n    \n    //ugly keyframe ifs... blech\n    int tB = 600;\n    int tBh = tB/2;\n    int tBq = tB/4;\n    vec3 p = 3.0 * vec3(x0, y0, z0);\n    float rest = -1.0 * PI / 10.0;\n    \n    if(iFrame%tB > tBh){\n        int fF = iFrame%tB - tBh;\n        float fl = 2.0 * float(fF % tBq)/ float(tBq) - 1.0;\n        if(fF <= tBq){\n           float zm = fl;\n            if(z0 < zm - 0.2)\n                 return Sphere(0.0, vec3(-1.0), vec3(0.0));\n            if(z0 > zm + 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n        }\n        if(fF > tBq){\n            float xm = fl;\n            if(x0 < xm - 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n            if(x0 > xm + 0.2)\n                return Sphere(0.0, vec3(-1.0), vec3(0.0));\n        }\n         p = rotate_around_y(rest) * p;\n    }\n    else\n        p = rotate_around_y(rest + 2.0 * PI * float(iFrame) / float(tBh)) * p;\n    //vec3 p = rotate_around_y(0.1*float(iMouse.x)) * vec3(10.0 * x1, 10.0 * x0,t0);\n    \n    vec3 c0 = vec3(\n        pow(cos(1.0 * PI*t + 0.0 * PI/3.0),2.0),\n        pow(cos(1.0 * PI*t + 2.0 * PI/3.0),2.0), \n        pow(cos(1.0 * PI*t + 4.0 * PI/3.0),2.0));\n\n    //p0 = rotate_around_y(0.2*float(iTime)) * p0;\n;\n    vec3 c = c0;\n    \n    \n    return Sphere(0.15, p, c);\n}\n\n#define MAX_STEPS 600\n#define MAX_DIST 1e10\n#define EPS .001\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n\n    int imin = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        Sphere sphere = getSphere(i);\n        vec3 c = sphere.p;\n        float r = sphere.r;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                imin = i;\n                d = sd;\n            }\n        }\n    }\n    return imin;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int i_s = findIntersection(camO, camL, -1, d);\n    \n    if (i_s == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    \n    vec3 lightPoint = vec3(-5.0, 5.0, -5.0);\n    Sphere sph = getSphere(i_s);\n    \n    // Sphere color\n    vec3 sColor = sph.c;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sph.p);\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint );\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, i_s, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (shadowedBy > -1) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, -25);\n    vec3 camL = normalize(vec3(uv.x, uv.y,6));\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 283, 283, 326], [398, 398, 432, 432, 540], [543, 543, 577, 577, 685], [687, 687, 711, 711, 2973], [3037, 3284, 3347, 3347, 4000], [4002, 4120, 4154, 4154, 5503], [5505, 5505, 5562, 5612, 5901]], "test": "untested"}
{"id": "ddGXRG", "name": "Pathtracing WIP 1", "author": "FifthStateOfMatter", "description": "Nice\n", "tags": ["3d", "pathtracing", "pathtracer", "pbr"], "likes": 2, "viewed": 196, "published": 3, "date": "1681244151", "time_retrieved": "2024-07-30T18:01:05.913347", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //vec4 col = vec4(texture(iChannel0, uv).xyz, 1);\n    fragColor = texture(iChannel0, uv);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0/2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec3 backCol = vec3(1);\n\nstruct material{\n    vec3 col;\n    float brightness;\n    float smoothness;\n    float specularProbability;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n};\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random32(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y)*p.z);\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return fract(p.x + p.y);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return mix(lerpBottomFront, lerpTopFront, frc.y);\n}\n\nfloat fbm(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 6; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nSDF sphere(vec3 p, float r, material mat){\n    return SDF((length(p) - r)*0.9, mat);\n}\n\nSDF plane(vec3 p, vec3 n, float h, material mat){\n    return SDF(length((p - h)*n)*0.9, mat);\n}\n\nSDF box(vec3 p, vec3 s, material mat){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat);\n}\n\nSDF infinitePatternSDF(vec3 p, vec3 c, material mat){\n    vec3 q = mod(p + 0.5*c, c) - 0.5*c;\n    return sphere(q, 1.0, mat);\n}\n\nSDF fuselage(vec3 p, material mat){\n    p.z *= 0.125;\n    p.y -= 0.1;\n    p.x *= 1.5;\n    p.x += smoothstep(0.0, 1.0, p.z)*0.2*sign(p.x)*abs(p.z);\n    p.y *= 0.7;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z*0.8 + 0.3)*2.0;\n    p.y += smoothstep(0.0, 1.0, -p.z)*0.6;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, -p.z*3.5 - 0.3)*2.0;\n    \n    p.y -= smoothstep(0.0, 1.0, p.z)*1.0;\n    \n    SDF s = sphere(p - vec3(0, 0, 0), 0.25, mat);\n    return SDF(s.dist*0.5, mat);\n}\n\nSDF wings(vec3 p, material mat){\n    p.y += 0.1;\n    p.z -= 0.12;\n    p.x *= 0.14;\n    p.y *= 3.5;\n    p.z *= 0.4;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, -p.z)*7.0;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z)*2.0;\n    p.y -= smoothstep(0.0, 1.0, abs(p.x))*2.0;\n    p.y += smoothstep(0.0, 1.0, p.z + 0.1)*0.2;\n    p.z -= smoothstep(0.0, 1.0, abs(p.x))*1.0;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z)*0.1;\n    \n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.3, mat);\n}\n\nSDF horizontalStabilizer(vec3 p, material mat){\n    p.z -= 1.5;\n    p.y -= 0.15;\n    p.x *= 0.3;\n    p.y *= 4.0;\n    p.z *= 0.8;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, -p.z)*6.0;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, p.z)*2.0;\n    p.y += smoothstep(0.0, 1.0, p.z + 0.1)*0.1;\n    p.z -= smoothstep(0.0, 1.0, abs(p.x))*1.0;\n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.3, mat);\n}\n\nSDF verticalStabilizer(vec3 p, material mat){\n    p.z -= 1.6;\n    p.y -= 0.3;\n    p.x *= 3.0;\n    p.y *= p.y > 0.0 ? 0.4 : 1.0;\n    p.z *= 0.8;\n    p.y *= 1.0 + smoothstep(0.0, 1.0, -p.z)*6.0;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, p.z + 0.3)*1.0;\n    p.x *= 1.0 + smoothstep(0.0, 1.0, p.y - 0.1)*2.0;\n    p.x += smoothstep(0.0, 1.0, p.z)*0.1;\n    p.z *= 1.0 + smoothstep(0.0, 1.0, p.y)*2.0;\n    p.z -= smoothstep(0.0, 1.0, abs(p.y))*1.0;\n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.2, mat);\n}\n\nSDF canopy(vec3 p, material mat){\n    p.y -= 0.2;\n    p.z += 0.7;\n    p.z *= 0.4;\n    p.x *= 1.6;\n    p.y += smoothstep(0.0, 1.0, -p.z);\n    SDF s = sphere(p, 0.25, mat);\n    return SDF(s.dist*0.7, mat);\n}\n\nSDF engine(vec3 p, material mat){\n    p.z *= 0.4;\n    SDF intake = sphere(p, 0.3, mat);\n    p.z /= 0.4;\n    p.z -= 9.8;\n    SDF cutout = sphere(p, 10.0, mat);\n    p.z += 9.5;\n    p.x *= 0.7;\n    p.z *= 0.2;\n    p.y -= smoothstep(0.0, 1.0, p.z);\n    p.x *= 1.0 + smoothstep(0.0, 1.0, p.z + 0.1)*4.0;\n    float s = max(-intake.dist, max(cutout.dist, sphere(p, 0.25, mat).dist));\n    return SDF(s*0.4, mat);\n}\n\nSDF airplaneSDF(vec3 p, material mat){\n    SDF can = canopy(p, material(vec3(0.5), 0.5, 1.0, 0.2));\n    \n    float s = min(min(min(min(min(fuselage(p, mat).dist, engine(p, mat).dist), can.dist), verticalStabilizer(p, mat).dist), horizontalStabilizer(p, mat).dist), wings(p, mat).dist);\n    if(s == can.dist){\n        return can;\n    }else{\n        return SDF(s, mat);\n    }\n}\n\nSDF scene(vec3 p){\n    SDF ground = plane(p, vec3(0, 1, 0), -0.5, material(vec3(1), 0.5, 1.0, 1.0));\n    SDF b1 = sphere(p - vec3(0, 0, 2), 0.5, material(vec3(1), 0.5, 1.0, 1.0));\n    SDF l1 = box(p - vec3(1.5, 1, 2), vec3(0.25), material(vec3(0, 1, 1), 10.0, 0.0, 0.0));\n    SDF l2 = sphere(p - vec3(-1, 0, 2), 0.5, material(vec3(1), 0.5, 1.0, 1.0));\n    float closest = min(ground.dist, min(b1.dist, min(l1.dist, l2.dist)));\n    if(closest == ground.dist){\n        return ground;\n    }else if(closest == b1.dist){\n        return b1;\n    }else if(closest == l2.dist){\n        return l2;\n    }else{\n        return l1;\n    }\n}\n\nfloat raymarch(vec3 o, vec3 d, inout bool h, inout material mat){\n    float t = 0.0;\n    for(int i = 0; i < 300 && t <= 100.0 && !h; i++){\n        SDF s = scene(o + d*t);\n        mat  = s.mat;\n        t += s.dist;\n        if(abs(s.dist) <= 0.002*t && t >= 0.0) h = true;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 h){\n    vec2 e = vec2(0, 0.01);\n    return normalize(vec3(\n        scene(h + e.yxx).dist - scene(h - e.yxx).dist,\n        scene(h + e.xyx).dist - scene(h - e.xyx).dist,\n        scene(h + e.xxy).dist - scene(h - e.xxy).dist\n    ));\n}\n\nvoid getPixelCol(vec3 o, vec3 d, inout vec3 col, float seed){\n    bool hit = false;\n    material mat = material(vec3(1), 1.0, 0.0, 0.0);\n    float t = raymarch(o, d, hit, mat);\n    float depth = t;\n    vec3 dens = 1.0 - exp(-t*vec3(0.01, 0.011, 0.015));\n    if(hit){\n        col *= mix(mat.col*mat.brightness, backCol, dens);\n        col = clamp(col, vec3(0), vec3(1));\n        if(mat.brightness > 1.0) return;\n        for(int i = 0; i < 10; i++){\n            hit = false;\n            vec3 n = getNormal(o + d*t);\n            o = o + d*t;\n            //From Sebastian Lague\n            bool isSpecularBounce = mat.specularProbability <= (random32(o*2093847.4832 + 293.482 + seed) + 1.0)/2.0;\n            vec3 dd = normalize(vec3(random32(o*2093847.4832 + 293.482 + seed), random32(o*3283742.438 + 213.847 + seed), random32(o*208347.483 + 283.837 + seed)));\n            vec3 sd = normalize(reflect(d, n));\n            d = mix(dd, sd, mat.smoothness*(isSpecularBounce ? 0.0 : 1.0));\n            d *= sign(dot(d, n));\n            t = raymarch(o, d, hit, mat);\n            dens = 1.0 - exp(-t*vec3(0.1, 0.11, 0.15));\n            if(hit){\n                //col = mix(col, vec3(1), isSpecularBounce ? 0.0 : 1.0);\n                col *= mix(mat.col*mat.brightness*clamp(dot(d, n), 0.0, 1.0)*2.0, backCol, dens);\n            }else{\n                col *= backCol*mat.brightness*clamp(dot(d, n), 0.0, 1.0)*2.0;\n                break;\n            }\n            if(mat.brightness > 1.0) return;\n        }\n    }else{\n        col *= backCol;\n        return;\n    }\n    col = mix(col, backCol, 1.0 - exp(-depth*vec3(0.01, 0.011, 0.015)));\n}\n\nconst float focalLength = 4.0;\nconst float aperture = 0.3;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(1);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 1, -2);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(radians(10.0), radians(0.0))));\n    vec3 focalPoint = o + d*focalLength;\n    vec3 so = o + vec3(random3(d*483092.4837 + float(iFrame)), random3(d*327463.3247 + float(iFrame)), random3(d*227422.2347 + float(iFrame)))*aperture;\n    vec3 cd = normalize(focalPoint - so);\n    getPixelCol(so, cd, col, float(iFrame));\n    fragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //vec4 col = ;\n    fragColor = texture(iChannel1, uv)*(1.0 - 1.0/float(iFrame + 1)) + texture(iChannel0, uv)*1.0/float(iFrame + 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 248]], "test": "untested"}
{"id": "mdGSzG", "name": "hash based rendering", "author": "janpitokiala", "description": "puts color at random pixel and slightly fades", "tags": ["tag"], "likes": 2, "viewed": 118, "published": 3, "date": "1681237975", "time_retrieved": "2024-07-30T18:01:06.832889", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define perFrame 100\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 pixel = vec3(0.0,0.0,0.0);\n    for(int i=0;i<perFrame;i++) {\n      vec2 hashed = hash21(iTime+float(i))*iResolution.xy;\n      if(floor(hashed.x) == floor(fragCoord.x)) {\n        if(floor(hashed.y) == floor(fragCoord.y)) {\n          pixel = vec3(uv.x,uv.y,1.0);\n        }\n      }\n    }\n    color = max(color*0.9995, pixel);\n    fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 222]], "test": "untested"}
{"id": "ddyXRG", "name": "Cinq variations sur 1 mme thme", "author": "wungasaurus", "description": "Inspired by Max Bill: 'Quinze variations sur un mme thme', 1935-1938, with animations.\n\nThere is a disabled 6th variation which didn't turn out to have a good transition with any others, so it was scrapped.\n\nhttps://demozoo.org/graphics/322541/", "tags": ["2d", "revision", "gif"], "likes": 16, "viewed": 270, "published": 3, "date": "1681236806", "time_retrieved": "2024-07-30T18:01:07.828228", "image_code": "// 'Cinq variations sur un mme thme':\n//   Inspired by from Max Bill: Quinze variations sur un mme thme, 1935-1938, with animations.\n// wungasaurus, Revision 2023, animated gif\n\nfloat noise(in vec2 uv) {\n    return fract(sin(dot(uv.xy ,vec2(123.18692, 895.2234))) * 19395.1791);\n}\n\nbool isBitSet( float x,  int bit) {\n    return (uint(round(x)) & (1u << bit)) != 0u;\n}\n\n// https://graphics.stanford.edu/%7Eseander/bithacks.html#CountBitsSetParallel\nint popcount(in float f)\n{\n    int i = int(f);\n    i = i - ((i >> 1) & 0x55555555);\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n    i = (i + (i >> 4)) & 0x0F0F0F0F;\n    return (i * 0x01010101) >> 24;\n}\n\nfloat gain(float x, float k)\n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// All SDFs from/based on https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdRing(vec2 p, float r1, float r2) {\n    return abs(sdCircle(p, r1)) - r2;\n}\nfloat sdRingRing(vec2 p, float r1, float r2, float r3) {\n    return abs(sdRing(p, r1,  r2)) - r3;\n}\n\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\n\nfloat ngon_ring(in int n, in vec2 p, in float r1, float r2) {\n    return abs(nGon(n, p, r1)) - r2;\n}\nfloat ngon_ringring(in int n, in vec2 p, in float r1, float r2, float r3) {\n    return abs(ngon_ring(n, p, r1, r2)) - r3;\n}\n\n// Classic 2D rotate.\nvec2 rotate( in vec2 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    return mat2(co,-si,si,co)*p;\n}\n\nfloat shapecomb(float res, in int fillbit, float m, float d0, float d1, float d2, float d3, float d4, float d5) {\n  float d = 0.;\n\n  // ok\n  // x 0 1 2 3 4 5\n  // 0   / + + + -    round    line\n  // 1     + + - -    angular  line\n  // 2       + - +    angular  fill\n  // 3         / /    round    fill\n  // 4           -    round    ring\n  // 5.               angular  ring\n\n  float ds[5] = float[](d0, d1, d2, d3, d4);\n\n    for (int i = 0; i < ds.length(); ++i) {\n        if (m <= float(i + 1)) {\n            d = mix(ds[i], ds[(i + 1) % ds.length()], m - float(i));\n            break;\n        }\n    }\n\n   if (d < 0.01) {\n      if(!isBitSet(res, fillbit))\n      res += float(1u<<fillbit);\n   }\n   return res;\n}\n\nfloat shape_1(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(8, uv, r1);\n  float d1 = 10.*ngon_ring(8, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(8, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_2(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(7, uv, r1);\n  float d1 = 10.*ngon_ring(7, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(7, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_3(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(6, uv, r1);\n  float d1 = 10.*ngon_ring(6, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(6, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_4(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(5, uv, r1);\n  float d1 = 10.*ngon_ring(5, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(5, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_5(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(4, uv, r1);\n  float d1 = 10.*ngon_ring(4, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(4, uv, r1, r2, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nfloat shape_6(in float res, in int fillbit, in vec2 uv, in float r1, in float r2, in float m) {\n  float d0 = sdRing(uv, r1+r2, r2);\n  float d3 = sdCircle(uv, r1+r2+.04);\n  float d2 = nGon(3, uv, r1);\n  float d1 = 10.*ngon_ring(3, uv, r1, 0.001);\n  float d4 = 20.*sdRingRing(uv, r1+r2, r2, 0.001);\n  float d5 = 20.*ngon_ringring(3, uv, r1, r2*.5, 0.001);\n  return shapecomb(res, fillbit, m, d0, d1, d2, d3, d4, d5);\n}\n\nvec3 col_1 = vec3(109.,50.,116.)/vec3(255.);\nvec3 col_2 = vec3(179.,74.,43.)/vec3(255.);\nvec3 col_4 = vec3(66.,110.,58.)/vec3(255.);\nvec3 col_3 = vec3(55.,49.,93.)/vec3(255.);\nvec3 col_5 = vec3(161.,49.,41.)/vec3(255.);\nvec3 col_6 = vec3(252.,190.,60.)/vec3(255.);\nvec3 col_bg = vec3(244.,239.,224.)/vec3(255.);\nvec3 col_bg_dark = vec3(192.,191.,173.)/vec3(255.);\nvec3 col_intersect = vec3(37.,33.,30.)/vec3(255.);\n\nvec4  fC ( in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p/=1.4;\n    //p+=vec2(.0, -.15);\n    p += vec2(0., -.03);\n\n//p/=4.;\n//p+=vec2(-.4,-.2);\n\n    vec3 col = col_bg;\n\n    float m = 0.;\n\n    float q =  mod(iTime/2., 5.);\n\n\n         if (q <= 1.) q = 0. + gain(q - 0., 6.);\n    else if (q <= 2.) q = 1. + gain(q - 1., 4.);\n    else if (q <= 3.) q = 2. + gain(q - 2., 5.);\n    else if (q <= 4.) q = 3. + gain(q - 3., 6.);\n    else if (q <= 5.) q = 4. + gain(q - 4., 5.);\n    else if (q <= 6.) q = 5. + gain(q - 5., 6.);\n\n    m = shape_1(m, 0, rotate(p + vec2(.0020, .0300), 0.000), 0.600, 0.014, q);\n    m = shape_2(m, 1, rotate(p + vec2(.0580, .0870), 0.110), 0.520, 0.015, q);\n    m = shape_3(m, 2, rotate(p + vec2(.1040, .0130), 0.560), 0.432, 0.014, q);\n    m = shape_4(m, 3, rotate(p + vec2(.0160, .0100), 0.350), 0.344, 0.020, q);\n    m = shape_5(m, 4, rotate(p + vec2(.0910, .0680), 0.665), 0.248, 0.024, q);\n    m = shape_6(m, 5, rotate(p + vec2(.0055, .0055), 2.235), 0.144, 0.050, q);\n\n    vec4 col_shapes = vec4(0.);\n    if (isBitSet(m, 0)) col_shapes = vec4(col_1, 1.);\n    if (isBitSet(m, 1)) col_shapes = vec4(col_2, 1.);\n    if (isBitSet(m, 2)) col_shapes = vec4(col_3, 1.);\n    if (isBitSet(m, 3)) col_shapes = vec4(col_4, 1.);\n    if (isBitSet(m, 4)) col_shapes = vec4(col_5, 1.);\n    if (isBitSet(m, 5)) col_shapes = vec4(col_6, 1.);\n\n    vec4 col_intersect_any = vec4(0.);\n    if (popcount(m) > 1)\n        col_intersect_any = vec4(col_intersect, 1.);\n\n    vec4 col_xor = vec4(0.);\n\n    if (isBitSet(m, 5) && !isBitSet(m, 4))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 4) && !isBitSet(m, 3))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 3) && !isBitSet(m, 2))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 2) && !isBitSet(m, 1))\n        col_xor = vec4(col_bg, 1.);\n    if (isBitSet(m, 1) && !isBitSet(m, 0))\n        col_xor = vec4(col_bg, 1.);\n\n         if (q <= 1.) col_xor = vec4(0.);\n    else if (q <= 2.) col_xor = vec4(0.);\n    else if (q <= 3.) col_xor = vec4(col_xor.xyz, smoothstep(0., col_xor.w, q - 2.));\n    else if (q <= 4.) col_xor = vec4(col_xor.xyz, smoothstep(col_xor.w, 0., q - 3.));\n    else if (q <= 5.) col_xor = vec4(0.);\n    else if (q <= 6.) col_xor = vec4(0.);\n\n    vec3 bgcol[7] = vec3[](col_bg, col_bg, col_bg_dark, col_bg_dark, col_bg, col_bg, col_bg);\n\n    if (col_shapes.w > 0.) col = col_shapes.xyz;\n    else\n    {\n       for (int i = 0; i < bgcol.length(); ++i) {\n            if (q <= float(i + 1)) {\n                col = mix(bgcol[i], bgcol[(i + 1) % bgcol.length()], q - float(i)).xyz;\n                break;\n            }\n       }\n    }\n\n         if (q <= 1.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w > 0. ? (1.-(q-0.)) : 0.);\n    else if (q <= 2.) col = mix(col, col_intersect_any.xyz, 0.);\n    else if (q <= 3.) col = mix(col, col_intersect_any.xyz, 0.);\n    else if (q <= 4.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w > 0. ? (   (q-3.)) : 0.);\n    else if (q <= 5.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w);\n    else if (q <= 6.) col = mix(col, col_intersect_any.xyz, col_intersect_any.w);\n\n    //col = mix(col, col_xor.xyz, col_xor.w);\n    //col += col_xor.xyz * col_xor.w;\n\n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    // Antialiasing from https://www.shadertoy.com/view/wtjfRV\n    float A = 8., s = 1./A, x, y;\n\n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n\n    fragColor /= A*A;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    fragColor = vec4(fragColor.xyz + noise(p)/18.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddyXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 211, 211, 288], [290, 290, 325, 325, 376], [378, 457, 483, 483, 666], [668, 668, 698, 698, 777], [779, 854, 889, 889, 917], [919, 919, 961, 961, 1001], [1002, 1002, 1058, 1058, 1101], [1103, 1103, 1148, 1188, 1575], [1577, 1577, 1638, 1638, 1677], [1678, 1678, 1753, 1753, 1801], [1803, 1825, 1860, 1860, 1941], [2655, 2655, 2750, 2750, 3068], [3070, 3070, 3165, 3165, 3483], [3485, 3485, 3580, 3580, 3898], [3900, 3900, 3995, 3995, 4313], [4315, 4315, 4410, 4410, 4728], [4730, 4730, 4825, 4825, 5146], [8848, 8848, 8905, 8905, 9271]], "test": "untested"}
{"id": "cdGXzy", "name": "Super Fibonacci Spirals", "author": "delajor", "description": "In my quest to find a Fibonacci Helix/Volume I found this nice little paper, Fibonacci Quats!\nAlexa_Super-Fibonacci_Spirals_Fast_Low-Discrepancy_Sampling_of_SO3_CVPR_2022_paper.pdf\nI wanted to do something neat with this, but this will do.", "tags": ["raytracing"], "likes": 7, "viewed": 239, "published": 3, "date": "1681235079", "time_retrieved": "2024-07-30T18:01:08.671972", "image_code": "#define NUM_SPHERES 512\n#define PSI  1.533751168755204288118041 \n#define PHI  sqrt(2.0)\n#define GPHI 0.5 * (1.0 +  sqrt(5.0))\n\n#define LIGHT_POWER 20.\n#define SPECULAR_POWER 20.\n#define AMBIENT .3\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct quat\n{\n    float s;\n    vec3 v;\n};\n\nquat conjugate(quat q)\n{\n    return quat(q.s,-q.v);\n}\n\nfloat norm_squared(quat q)\n{\n    return q.s * q.s + dot(q.v, q.v);\n}\n\nfloat norm(quat q)\n{\n    return sqrt(norm_squared(q));\n}\n\nquat mul(float s, quat q)\n{\n    return quat(s * q.s, s * q.v);\n}\n\nquat div(quat q, float s)\n{\n    return quat(q.s / s, q.v / s);\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat normalify(quat q) // NOTE: can't reuse function name normalize here\n{\n    return div(q, norm(q));\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\n//quat inverse(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat invert(quat q) // NOTE: can't reuse function name inverse here\n{\n    return div(conjugate(q), norm_squared(q));\n}\n\nquat neg(quat q)\n{\n    return quat(-q.s,-q.v);\n}\n\nquat add(quat a, quat b)\n{\n    return quat(a.s + b.s, a.v + b.v);\n}\n\nquat sub(quat a, quat b)\n{\n    return quat(a.s - b.s, a.v - b.v);\n}\n\nquat mul(quat a, quat b)\n{\n    return quat(a.s * b.s - dot(a.v, b.v), a.s * b.v + b.s * a.v + cross(a.v, b.v));\n}\n\nquat div(quat a, quat b)\n{\n    return mul(a, invert(b));\n}\n\nvec3 rotate(quat q, vec3 p) // NOTE: order of parameters copies order of applying rotation matrix: M v\n{\n    return p + 2.0 * cross(q.v, cross(q.v, p) + q.s * p); // suggested by mla, requires q to be unit (i.e. normalized)\n\n    // Derive to https://en.wikipedia.org/wiki/Euler%E2%80%93Rodrigues_formula#Vector_formulation\n    //return p + 2.0 * cross(q.v, cross(q.v, p)) + 2.0 * cross(q.v, q.s * p); // cross-product is distributive\n    //return p + 2.0 * cross(q.v, q.s * p) + 2.0 * cross(q.v, cross(q.v, p)); // vector addition is commutative\n    //return p + 2.0 * q.s * cross(q.v, p) + 2.0 * cross(q.v, cross(q.v, p)); // scalar can be factored-out\n    // translate variable names\n    vec3 x = p;\n    float a = q.s;\n    vec3 omega = q.v;\n    return x + 2.0 * a * cross(omega, x) + 2.0 * cross(omega, cross(omega, x)); // Euler Rodrigues' Formula\n}\n\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, c;\n};\n\nmat3 rotate_around_z(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, -_sin, 0, _sin, _cos, 0, 0, 0, 1);\n}\n\n\nmat3 rotate_around_y(float angle){\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(_cos, 0, _sin, 0, 1, 0, -_sin, 0, _cos);\n}\n\n\nSphere getSphere0(int i){\n    float N = float(NUM_SPHERES);\n    float t = float(i) / N;\n\n    float sqti = sqrt(t);\n    float sqt1i = sqrt(1.0 - t);\n    float thet = 2.0 * PI *N * t;\n    float NtP = (N * t) / PSI;\n    float t0 = NtP - floor(NtP);\n    float x0 =  sqti * sin(thet / PHI);\n    float x1 =  sqti * cos(thet / PHI);\n    float y0 =  sqt1i * sin(thet / PSI);\n    float y1 =  sqt1i * cos(thet / PSI);\n    quat q = quat(y0, vec3(y1, x0, x1));\n    //vec3 p = rotate_around_y(0.1*float(iMouse.x)) * vec3(10.0 * x1, 10.0 * x0,t0);\n    \n    vec3 c0 = vec3(1.0, 0.3, 0.2);\n    vec3 p0 = vec3(3.0, 0.0, 0.0);\n    //p0 = rotate_around_y(0.2*float(iTime)) * p0;\n\n    vec3 p = rotate(q, p0);\n    vec3 c = rotate(q, c0);\n    \n    p = rotate_around_y(0.1*float(iTime)) * p;\n    return Sphere(0.15, p, c0);\n}\n#define MAX_STEPS 600\n#define MAX_DIST 1e10\n#define EPS .001\n\n// Find a nearest ray-sphere intersection\n// o - ray origin\n// l - ray direction (normalized)\n// ignore - sphere to ignore when detecting intersection (used for shadows)\n// d - distance output\n// Returns sphere number, -1 if no intersection found\nint findIntersection(vec3 o, vec3 l, int ignore, out float d) {\n\n    int imin = -1;\n    d = 1e5;\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n        if (i == ignore) {\n            continue;\n        }\n        Sphere sphere = getSphere0(i);\n        vec3 c = sphere.p;\n        float r = sphere.r;\n\n        // Ray-sphere intersection formula\n        vec3 t1 = o - c;\n        float t1l = length(t1);\n        float t2 = dot(l, t1);\n        float s = t2 * t2 - t1l * t1l + r * r;\n        if (s >= 0.) {\n            float ss = sqrt(s);\n            float sd = min(-t2 + ss, -t2 - ss);\n            if (sd >= 0. && sd < d) {\n                imin = i;\n                d = sd;\n            }\n        }\n    }\n    return imin;\n}\n\n// Trace a single ray\n// camO - camera origin\n// camL - camera ray direction (normalized)\n// Returns a fragment color\nvec3 trace(vec3 camO, vec3 camL) {\n    float d = 0.;\n    int i_s = findIntersection(camO, camL, -1, d);\n    \n    if (i_s == -1) {\n        // There was no intersection, return background color\n        return vec3(0, 0, 0);\n    }\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    \n    vec3 lightPoint = vec3(0.0);\n    Sphere sph = getSphere0(i_s);\n    \n    // Sphere color\n    vec3 sColor = sph.c;\n    vec3 aColor = sColor * vec3(AMBIENT, AMBIENT, AMBIENT);\n\n    // Intersection point\n    vec3 iPoint = camO + camL * d;\n    vec3 iNormal = normalize(iPoint - sph.p);\n\n    // Light direction vector\n    vec3 lightDir = normalize(lightPoint - iPoint );\n    \n    // Check if there's another sphere between this one and the light source\n    float dShadow = 0.;\n    int shadowedBy = findIntersection(iPoint, lightDir, i_s, dShadow);\n    dShadow = float(shadowedBy + 1) / 5.0;\n    if (false) {\n        // We're under shadow, use ambient color\n        return aColor;\n    }\n    \n    // Lighting (diffusion and specular)\n    float cosA = clamp(dot(iNormal, lightDir), 0., 1.);\n    float cosS = clamp(dot(-camL, reflect(-lightDir, iNormal)), 0., 1.);\n\n    float dSquared = pow(length(iPoint - lightPoint), 2.);\n    \n    return aColor +\n        sColor * lightColor * cosA * LIGHT_POWER / dSquared +\n        lightColor * pow(cosS, SPECULAR_POWER) * LIGHT_POWER / dSquared;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Camera\n    vec3 camO = vec3(0, 0, -25);\n    vec3 camL = normalize(vec3(uv.x, uv.y,6));\n    \n    // Ray-tracing\n    fragColor = vec4(trace(camO, camL), 1.);      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 282, 282, 325], [370, 370, 394, 394, 423], [425, 425, 453, 453, 493], [495, 495, 515, 515, 551], [553, 553, 580, 580, 617], [619, 619, 646, 646, 683], [685, 783, 857, 857, 887], [889, 1083, 1152, 1152, 1201], [1203, 1203, 1221, 1221, 1251], [1253, 1253, 1279, 1279, 1320], [1322, 1322, 1348, 1348, 1389], [1391, 1391, 1417, 1417, 1504], [1506, 1506, 1532, 1532, 1564], [1566, 1566, 1670, 1670, 2418], [2490, 2490, 2524, 2524, 2632], [2635, 2635, 2669, 2669, 2777], [2780, 2780, 2805, 2805, 3582], [3645, 3892, 3955, 3955, 4609], [4611, 4729, 4763, 4763, 6091], [6093, 6093, 6150, 6200, 6489]], "test": "untested"}
{"id": "cdGSzG", "name": "wavt3st", "author": "andreaferrario", "description": "wavt3st.frag", "tags": ["test"], "likes": 3, "viewed": 159, "published": 3, "date": "1681231606", "time_retrieved": "2024-07-30T18:01:09.690249", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = iResolution.xy, u = (fragCoord+fragCoord-uv)/ uv.y;    \n    //fragColor.rgb*=0.;\n    vec2 uv = 10.0 * fragCoord/iResolution.xy;\n    vec2 translate = vec2(-0.500,-0.500);\n    uv += translate;\n    \n   \n    // Time varying pixel color\n   \n    vec3 col = vec3(0.080,0.440,0.890);\n    vec3 col2 = vec3(0.078,0.318,0.882);\n    for(int n = 1; n < 50 ; n++){\n        float i = float (n);\n         uv += vec2(1.0 / i * sin(i * uv.y + iTime + 10.0 * i) + 0.8, \n         0.4 / i * sin(uv.x + iTime + 0.3 * i)+2.0);\n        \n        \n    }\n    col += 1.128 * sin(uv.y) + -0.500, 0.5 * cos(uv.x) + 0.5, sin(uv.x + uv.y);\n    col2 += sin(uv.x *cos(iTime/2.0) * 0.1 + sin(uv.y * sin(iTime / 60.0) * 100.0));\n    col += sin(uv.x *sin(iTime/1200.0) * 50.0 + sin(uv.x * sin(abs(iTime / 60.0)) * 20.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 204, 965]], "test": "untested"}
{"id": "mdVXDm", "name": "Falling star?", "author": "i11212", "description": "Free to use by @i11212", "tags": ["ex"], "likes": 3, "viewed": 377, "published": 3, "date": "1681224734", "time_retrieved": "2024-07-30T18:01:10.681598", "image_code": "/*\nMade By I11212\nTwitter: https://twitter.com/i11212_?t=us2GzKso5JLrTiwYIxuueg&s=09\nYoutube: https://youtube.com/channel/UCg21GlDi4TtGe-9CNpSlR9A\n*/\n\nhighp float hash(\n\thighp vec2 x){\nreturn fract(sin(dot(\n\tx,vec2(11,57)))*4e3);\n\t}\n\nhighp float star(\n\thighp vec2 x){\nx *= mat2(cos(0.5),-sin(0.5),sin(0.5),cos(0.5));\nx.y += iTime*16.0;\nhighp float shape = (1.0-length(\n\tfract(x-vec2(0,0.5))-0.5));\nx *= vec2(1,0.1);\nhighp vec2 fr = fract(x);\nhighp float random = step(hash(floor(x)),0.01),\n\t        tall = (1.0-(abs(fr.x-0.5)+fr.y))*random;\nreturn clamp(clamp((shape-random)*step(hash(\n\tfloor(x+vec2(0,0.05))),0.01),0.0,1.0)+tall,0.0,1.0);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/(\n    iResolution.x, iResolution.y);\n\n    fragColor = pow(vec4(star(uv*24.0))*1.1,\n                    vec4(16,6,4,1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[644, 644, 701, 701, 871]], "test": "untested"}
{"id": "ddVSDm", "name": "Aurora?", "author": "i11212", "description": "Free to use by @i11212", "tags": ["ex"], "likes": 11, "viewed": 514, "published": 3, "date": "1681223892", "time_retrieved": "2024-07-30T18:01:11.755726", "image_code": "/*\nMade By I11212\nTwitter: https://twitter.com/i11212_?t=us2GzKso5JLrTiwYIxuueg&s=09\nYoutube: https://youtube.com/channel/UCg21GlDi4TtGe-9CNpSlR9A\n*/\n\n#define matrot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define amount 4.0\n#define saturate(x) clamp(x,0.0,1.0)\n#define downcol vec3(0,1,0.25)\n#define upcol vec3(0,0.25,1)\n#define steps 32.0\n\nhighp float voronoi(\n\thighp vec2 x){\nhighp float n = 0.0;\nfor(int i = 0; i<int(amount); i++){\nn = max(n, abs(\n\t\tsin(x.x)*\n        cos(x.y))),\n\nx *= matrot(0.25),\n\nx += vec2(sin(iTime),\n\tcos(iTime))/(\n\tamount/2.0)*0.0,\n\nx += float(i)/amount;\n\t}\nreturn 1.0-(n);\n\t}/*voronoi from https://www.shadertoy.com/view/7d2cWR*/\n\nhighp float fbm(\n\thighp vec2 x,\n\thighp float s){\nx -= iTime;\nhighp float f = voronoi(x);\nf *= (voronoi(x*6.0+4.0+iTime*6.0)+s);\n\nreturn saturate(pow(f,3.0));\n\t}\n\nhighp vec3 aurora(\n\thighp vec2 x,\n\thighp vec3 sky){\nfor(float i = 0.0; i<steps; i++){\nx *= 0.97;\nsky = mix(sky, sqrt(mix(upcol, downcol, i/(steps))),\n\tfbm(x,(i/(steps*2.0))));\n\t}\nreturn sky;\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*vec2(0.5,0))/\n    (iResolution.x,iResolution.y);\n\n    if(uv.y>0.5){\n    uv /= uv.y-0.5;\n    fragColor = vec4(aurora(uv,vec3(0)),1.0);\n}else{ fragColor = vec4(0);}}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1015, 1015, 1072, 1072, 1276]], "test": "untested"}
{"id": "clsSWH", "name": "Revision 2023 - Dive Network ", "author": "totetmatt", "description": "tutu tutu tuu tu tu tu tu tuuuu", "tags": ["gif"], "likes": 35, "viewed": 621, "published": 3, "date": "1681214627", "time_retrieved": "2024-07-30T18:01:12.660308", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n \n    vec4 pframer = texture(iChannel0,-.0025+fragCoord.xy/iResolution.xy).rrrr;\n     vec4 pframeg = texture(iChannel0,.0015+fragCoord.xy/iResolution.xy).gggg; \n        vec4 pframeb = texture(iChannel0,.0015+fragCoord.xy/iResolution.xy).bbbb ;\n        \n        \n    fragColor = vec4(pframer.r,pframeb.b,pframeg.g,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat de(vec2 pp){\n    vec3 p =vec3(pp,1.);\n    for(float i=0.;i++<8.;){\n        p.xy = mod(p.xy-1.,2.)-1.;\n        p*=1.3/dot(p.xy,p.xy);\n    }\n    return .25*length(p.xy/p.z);\n}\nfloat n21(vec2 p){\n     p = fract(p*vec2(233.34,851.73));\n     p +=dot(p,p+23.45);\n     return fract(p.x*p.y);\n}\nvec2 n22(vec2 p){\n    float n=n21(p);\n    return vec2(n,n21(p+n));\n}\nvec2 pos(vec2 id,vec2 off,float z){\n    return off+sin(n22(id+off+z)*iTime)*.4;\n}\nfloat line( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);   \n    return length(pa - ba * h)-.005;\n}\n\n\nfloat sdf(vec2 uv, vec3 ids){\n\n    vec2 id=floor(uv),gv=fract(uv)-.5;\n   \n    \n    vec2 p[9];\n    \n    int i=0;\n    for(int y=-1;y<=1;y++)for(int x=-1;x<=1;x++)p[i++]=pos(id,vec2(x,y),ids.z);\n          \n    float m=1000.;\n\n    for(int i=0;i<9;i++){\n        m =min(m,line(gv,p[4],p[i]));\n        m = min(length(gv-p[i])-abs(n21(ids.zz+2.)*.2),m);\n    }       \n         m=min(m,line(gv,p[1],p[3]));\n         m=min(m,line(gv,p[1],p[5]));\n         m=min(m,line(gv,p[7],p[3]));\n         m=min(m,line(gv,p[7],p[5]));\n       return m;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y; \n    vec3 col = vec3(0);\n    vec3 p,d=normalize(vec3(uv,1.-.3*sqrt(length(uv*5.))));\n    for(float i=0.,e=0.,g=0.;i++<50.;){\n        p = d*g;\n        p.xy*=rot(iTime*.5+n21(p.xy)*.05);\n        p.z +=2.+tan(floor(iTime)+pow(fract(iTime),.85)+n21(uv.xy)*.01)+n21(p.xy)*(.05+.05*length(uv));\n        vec3 id = floor(p);\n        float zz;\n        p.z = modf(p.z,zz)-.5;     \n        float d = max(abs(p.z)-.1,sdf(p.xy+9.,id));\n        g+=e=max(.001,mix(d,abs(d),+floor(n21(p.xy)*2.)*floor(mod(id.z,2.))));\n        col += vec3(1.*sin(i*i*e+p.z))*.065/exp(.25*i*i*e);\n    }\n  \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsSWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 376]], "test": "untested"}
{"id": "ddGSWw", "name": "Specular Self-Shadowing", "author": "Hatchling", "description": "Encodes visibility data from a heightmap, allowing also specular self-shadowing.\nLeft: New technique.\nRight: Normal mapping, reflections attenuated by ambient occlusion.", "tags": ["gi", "occlusion", "ambient", "bentnormals"], "likes": 9, "viewed": 354, "published": 3, "date": "1681166409", "time_retrieved": "2024-07-30T18:01:13.616751", "image_code": "// Shader Summary:\n// Encodes visibility data from a heightmap, allowing fast direct light self-shadowing and ambient GI.\n// Left: New technique.\n// Right: Standard technique.\n// Given a heightmap, computes the percentage of visible rays (occlusion),\n// the average visible ray direction (bent normals),\n// and the angular variability (for self shadowing). These values are weighted by a Lambertian BRDF (dot product).\n// This data can be used to do fast realtime GI on textured surfaces, including self shadowing for direct lights.\n\n// Image buffer:\n// Uses the previously baked visibility map to do fast realtime GI on a textured surface.\n\nfloat softDot(vec3 a, vec3 b)\n{\n    float r = dot(a, b) * 0.5 + 0.5;\n    return r * r;\n}\n\nfloat hardDot(vec3 a, vec3 b)\n{\n    float r = dot(a, b) * 0.5 + 0.5;\n    r *= r;\n    r *= r;\n    r *= r;\n    return r * r * 15.;\n}\n\nvec3 environmentLighting(vec3 dir)\n{\n    return \n     //   + softDot(dir, normalize(vec3(0,5,0))) * vec3(0.3, 0.6, 1.0)\n   //     + softDot(dir, normalize(vec3(0.5,-1,0.0))) * vec3(1.0, 0.5, 0.1) * 0.5\n   //     + softDot(dir, normalize(vec3(-1.5,0.5,1.5))) * vec3(0.7, 0.3, 0.2) * 0.5\n        + pow(texture(iChannel1, dir, 5.).rgb, vec3(2.2)) * 2.0;\n}\n\nvec3 environmentLightingSharp(vec3 dir)\n{\n    return \n    //    + hardDot(dir, normalize(vec3(0,5,0))) * vec3(0.3, 0.6, 1.0)\n  //      + hardDot(dir, normalize(vec3(0.5,-1,0.0))) * vec3(1.0, 0.5, 0.1) * 0.5\n    //    + hardDot(dir, normalize(vec3(-1.5,0.5,1.5))) * vec3(0.7, 0.3, 0.2) * 0.5\n        + pow(texture(iChannel1, dir).rgb, vec3(2.2)) * 2.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Virtual mouse (auto-controlled when 0,0)\n    vec2 virtualMouse;\n    if(iMouse.xy == vec2(0,0))\n    {\n        virtualMouse.xy = (vec2(sin(iTime), cos(iTime * 1.618)) * 0.5 + 0.5) * iResolution.xy;\n    }\n    else\n    {\n        virtualMouse.xy = iMouse.xy;\n    }\n\n    float sampleCount = float(iFrame);\n    vec4 data = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    data.xyz /= data.a;\n    vec3 direction = normalize(data.xyz);\n    float occlusion = data.a / sampleCount;\n    float mag = length(data.xyz);\n    float power = magToPower(mag);\n\n    vec4 normalHeight = texture(iChannel2, fragCoord/iChannelResolution[2].xy);\n    vec3 normal = normalize(normalHeight.xyz);\n    \n    vec3 lightPos = vec3(virtualMouse.xy, depthMax * ((sin(iTime * 2.618)+1.0) * 2.0 + 1.0));\n    vec3 pixelPos = vec3(fragCoord, normalHeight.w);\n    vec3 lightDir = normalize(lightPos - pixelPos);\n    float lightDistSqr = dot(lightPos - pixelPos,lightPos - pixelPos) / (depthMax * 1000.);\n    vec3 reflDir = reflect(vec3(0,0,-1), normal);\n    float lDotD = max(0.,dot(direction, lightDir));\n    float lDotN = max(0.,dot(normal, lightDir));\n    float lDotR = max(0.,dot(lightDir, reflDir));\n    float rDotD = max(0.,dot(direction, reflDir));\n    float vDotN = max(0.,dot(vec3(0,0,1), normal));\n    \n    // (1-dot) ^ 5 for fresnel approx.\n    float fresnel = 1.0 - vDotN;\n    fresnel *= fresnel;\n    fresnel *= fresnel;\n    fresnel *= 1.0 - vDotN;\n    fresnel = mix(fresnel * 3.0, 1.0, 0.3);\n            \n    fragColor = vec4(0);\n    \n    // Left\n    if(fragCoord.x < iResolution.x * 0.5)\n    {\n        float specShadowing = pow(rDotD, power);\n        \n        // Add environment reflection.\n        fragColor.rgb += environmentLightingSharp(reflDir) * fresnel * specShadowing;    \n        \n        // Harden shadows.\n        specShadowing = smoothstep(0., 1., specShadowing);    \n        specShadowing = smoothstep(0., 1., specShadowing);    \n        specShadowing = smoothstep(0., 1., specShadowing);\n\n        // Add specular.\n        fragColor.rgb += vec3(1.0,0.8,0.5) / lightDistSqr * pow(lDotR, 20.) * 3. * specShadowing * fresnel;\n    }\n    else\n    {\n        // Add environment reflection.\n        fragColor.rgb += environmentLightingSharp(reflDir) * fresnel * occlusion;    \n        \n        // Add specular.\n        fragColor.rgb += vec3(1.0,0.8,0.5) / lightDistSqr * pow(lDotR, 20.) * 3. * fresnel;\n    }\n\n    // Tonemap.\n    {\n        fragColor.rgb = linearToGamma(fragColor.rgb);\n        fragColor.rgb /= (0.5 + fragColor.rgb);\n        fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n        fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n    }  \n  \n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A:\n// Caches the normal and height values for faster processing.\n\n\nfloat GetDepth(vec2 fragCoord)\n{\n    return texture(iChannel0, fragCoord/iChannelResolution[0].xy / scale).r * depthMax;\n}\n\nvec3 GetNormal(vec2 fragCoord)\n{\n    float ang1 = (1.0 / 12.0) * 6.2831853;\n    float ang2 = (5.0 / 12.0) * 6.2831853;\n    float ang3 = (9.0 / 12.0) * 6.2831853;\n    \n    vec3 v1 = vec3(fragCoord + vec2(sin(ang1), cos(ang1)) * 0.5 * scale, 0);\n    vec3 v2 = vec3(fragCoord + vec2(sin(ang2), cos(ang2)) * 0.5 * scale, 0);\n    vec3 v3 = vec3(fragCoord + vec2(sin(ang3), cos(ang3)) * 0.5 * scale, 0);\n    \n    v1.z = GetDepth(v1.xy);\n    v2.z = GetDepth(v2.xy);\n    v3.z = GetDepth(v3.xy);\n    \n    vec3 norm = normalize(cross(v1 - v2, v3 - v2));\n    \n    return norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = GetNormal(fragCoord);\n    fragColor.a = GetDepth(fragCoord);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float scale = 1.0;\n\nconst float depthMax = 100.0 * scale;\n\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\nfloat curve(float x) \n{ \n   float y = (1.0 - 1.0/(x+1.0))*2.0;\n   y = 1.-y;\n   y = pow(y, 2.25);\n   y = 1.-y;\n   y *= 0.74;\n   y += x*0.26;\n   return y;\n} \n\nfloat myFunc2(float x)\n{\n    const float mini = 0.752;\n    const float maxi = 1.0;\n    \n    x = (x-mini)/(maxi-mini);\n    \n    x = clamp(x, 0., 1.);\n    \n    return curve(x);\n}\n\nfloat magToPower(float magnitude)\n{\n    float x = myFunc2(magnitude);\n    \n    x = -x/(x-1.0);\n    \n    return x;\n}", "buffer_b_code": "// Buffer B:\n// Computes the visibility mapping, where:\n// x, y, z: The average direction of all unoccluded rays\n//     - Direction: Average direction visible to the texel.\n//     - Magnitude: Encodes the variation of visible ray directions. \n// w: The weighted number of unoccluded rays.\n\nvec4 GetNormalDepth(vec2 fragCoord)\n{\n    return texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n}\n\nfloat RayIsVisible(vec2 fragCoord, vec3 dir)\n{\n    vec4 normDepth = GetNormalDepth(fragCoord);\n    \n    normDepth.xyz = normalize(normDepth.xyz);\n\n    vec3 rayPos;\n    rayPos.xy = fragCoord;\n    rayPos.z = normDepth.w;\n    \n    float rDotN = dot(normDepth.xyz, dir);\n    if(rDotN < 0.0)\n        return 0.0;//dir -= 2.0 * rDotN * normDepth.xyz;\n     \n    if(dir.z <= 0.0)\n    {\n        return 0.0;\n    }\n    \n    float exitDepthDiff = depthMax - rayPos.z;\n    \n    if(exitDepthDiff <= 0.0)\n    {\n        return rDotN;\n    }\n    \n    vec3 exitPos = rayPos + dir * exitDepthDiff / dir.z;\n    \n    const int steps = 256;\n    for(int i = 1; i <= steps; i++)\n    {\n        vec3 pointAlongRay = mix(rayPos, exitPos, float(i) / float(steps));\n        \n        if(pointAlongRay.z <= GetNormalDepth(pointAlongRay.xy).w)\n            return 0.0;\n    }\n    \n    return rDotN;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texture(iChannel2, fragCoord/iChannelResolution[2].xy);\n    \n    vec4 noise = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n\n    vec2  aa = hash2( noise.x + float(iFrame)*203.1 );\n    float ra = sqrt(aa.y);\n    float rx = ra*cos(6.2831*aa.x); \n    float ry = ra*sin(6.2831*aa.x);\n    float rz = sqrt(1.0-aa.y);\n    vec3  dir = normalize(vec3(rx,ry,rz));\n\n    float weight = RayIsVisible(fragCoord, dir);\n\n        fragColor.xyz += dir * weight;\n        fragColor.a += weight;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[642, 642, 673, 673, 730], [732, 732, 763, 763, 862], [864, 864, 900, 900, 1216], [1218, 1218, 1259, 1259, 1571], [1574, 1574, 1631, 1683, 4340]], "test": "untested"}
{"id": "csGSD1", "name": "Fast Baked GI via Visibility Map", "author": "Hatchling", "description": "Encodes visibility data from a heightmap, allowing fast direct light self-shadowing and ambient GI.\nLeft: New technique.\nRight: Normal mapping with ambient occlusion.", "tags": ["gi", "occlusion", "ambient", "bentnormals"], "likes": 32, "viewed": 740, "published": 3, "date": "1681157192", "time_retrieved": "2024-07-30T18:01:14.986090", "image_code": "// Shader Summary:\n// Encodes visibility data from a heightmap,\n// allowing fast direct light self-shadowing and ambient GI.\n// Left: New technique.\n// Right: Standard technique.\n// Given a heightmap, \n// computes the percentage of visible rays (occlusion),\n// the average visible ray direction (bent normals),\n// and their angular variability (for self shadowing). \n// These values are weighted by a Lambertian BDRF (dot product).\n// This data can be used to do fast realtime GI on textured surfaces, \n// including self shadowing for direct lights.\n\n// Image buffer:\n// Uses the previously baked visibility map to do fast realtime GI on a textured surface.\n\nconst float EnvMaxMipLevel = 8.;\n\nfloat softDot(vec3 a, vec3 b)\n{\n    float r = dot(a, b) * 0.5 + 0.5;\n    return r * r;\n}\n\nvec3 encironmentLighting(vec3 dir, float power)\n{\n    return //vec3(-powerToMipBias(power+1.0) / EnvMaxMipLevel);\n       // + softDot(dir, normalize(vec3(0,5,0))) * vec3(0.3, 0.6, 1.0)\n     //   + softDot(dir, normalize(vec3(0.5,-1,0.0))) * vec3(1.0, 0.5, 0.1) * 0.5\n     //   + softDot(dir, normalize(vec3(-1.5,0.5,1.5))) * vec3(0.7, 0.3, 0.2) * 0.5\n        + pow(textureLod(iChannel1, dir, EnvMaxMipLevel + powerToMipBias(power)).rgb, vec3(2.2))  * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Virtual mouse (auto-controlled when 0,0)\n    vec2 virtualMouse;\n    if(iMouse.xy == vec2(0,0))\n    {\n        virtualMouse.xy = (vec2(sin(iTime), cos(iTime * 1.618)) * 0.5 + 0.5) * iResolution.xy;\n    }\n    else\n    {\n        virtualMouse.xy = iMouse.xy;\n    }\n\n    float sampleCount = float(iFrame);\n    vec4 data = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    \n    if(data.a == 0.)\n    {\n        data.xyz = vec3(0,0,1);\n        data.a = 1.0;\n    }\n    else\n    {\n        data.xyz /= data.a;\n    }\n    \n    vec3 direction = normalize(data.xyz);\n    float occlusion = data.a / sampleCount * 2.0;\n    float mag = length(data.xyz);\n    float power = magToPower(mag);\n\n    vec4 normalHeight = texture(iChannel2, fragCoord/iChannelResolution[2].xy);\n    vec3 normal = normalize(normalHeight.xyz);\n    \n    vec3 lightPos = vec3(virtualMouse.xy, depthMax * ((sin(iTime * 2.618)+1.0) * 2.0 + 1.0));\n    vec3 pixelPos = vec3(fragCoord, normalHeight.w);\n    vec3 lightDir = normalize(lightPos - pixelPos);\n    float lightDistSqr = dot(lightPos - pixelPos,lightPos - pixelPos) / (depthMax * 1000.);\n    vec3 reflDir = reflect(vec3(0,0,-1), normal);\n    float lDotD = max(0.,dot(direction, lightDir));\n    float lDotN = max(0.,dot(normal, lightDir));\n    float lDotR = max(0.,dot(lightDir, reflDir));\n    float rDotD = max(0.,dot(direction, reflDir));\n    float vDotN = max(0.,dot(vec3(0,0,1), normal));\n           \n    float specularAmt;\n    float diffuseAmt;\n    {\n\n        // dot ^ 5 for fresnel approx.\n        float fresnel = 1.0-vDotN;\n        fresnel *= fresnel;\n        fresnel *= fresnel;\n        fresnel *= 1.0-vDotN;\n\n        specularAmt = mix(0.1f, 1.0f, fresnel);\n        diffuseAmt = 1.0 - specularAmt;\n    }\n        \n    // Left\n    if(fragCoord.x < iResolution.x * 0.5)\n    {        \n\n        \n        float specShadowing = pow(rDotD, power);\n        \n        // Harden shadows.\n        specShadowing = smoothstep(0., 1., specShadowing);    \n        specShadowing = smoothstep(0., 1., specShadowing);    \n        specShadowing = smoothstep(0., 1., specShadowing);\n\n        // Add environment lighting.\n        fragColor.rgb = encironmentLighting(direction, power) \n                      * occlusion \n                      * diffuseAmt;\n\n        \n        // Add environment reflection.\n        {\n            fragColor.rgb += encironmentLighting(reflDir, 20.0) \n                           * 3. \n                           * specShadowing \n                           * specularAmt;    \n        }\n\n        // Add diffuse.\n        {\n            float shadowing = pow(lDotD, power);\n\n            // Harden shadows.\n            shadowing = smoothstep(0., 1., shadowing);    \n            shadowing = smoothstep(0., 1., shadowing);    \n            shadowing = smoothstep(0., 1., shadowing);\n\n            fragColor.rgb += vec3(1.0,0.8,0.5) \n                           / lightDistSqr \n                           * lDotN \n                           * shadowing \n                           * diffuseAmt;\n        }\n\n        // Add specular.\n        fragColor.rgb += vec3(1.0,0.8,0.5) \n                       / lightDistSqr \n                       * pow(lDotR, 20.0) \n                       * 3. \n                       * specShadowing \n                       * specularAmt;\n        \n\n        // Tonemap.\n        {\n            fragColor.rgb = linearToGamma(fragColor.rgb);\n            fragColor.rgb /= (0.5 + fragColor.rgb);\n            fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n            fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n        }\n    }\n    \n    // Right\n    else\n    {\n        // Add environment lighting.\n        fragColor.rgb = encironmentLighting(normal, 1000000.0) \n                      * occlusion \n                      * diffuseAmt;\n\n        // Add environment reflection.\n        {\n            fragColor.rgb += encironmentLighting(reflDir, 20.0) \n                           * 3. \n                           * specularAmt;    \n        }\n        \n        // Add diffuse.\n        {\n\n            fragColor.rgb += vec3(1.0,0.8,0.5) \n                           / lightDistSqr \n                           * lDotN \n                           * diffuseAmt;\n        }\n\n        // Add specular.\n        {\n            fragColor.rgb += vec3(1.0,0.8,0.5) \n                           / lightDistSqr \n                           * pow(lDotR, 20.) \n                           * 3.\n                           * specularAmt;\n        }\n\n        // Tonemap.\n        {\n            fragColor.rgb = linearToGamma(fragColor.rgb);\n            fragColor.rgb /= (0.5 + fragColor.rgb);\n            fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n            fragColor.rgb = smoothstep(vec3(0), vec3(1), fragColor.rgb);\n        }  \n    }\n  \n // fragColor.rgb = vec3(occlusion);\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A:\n// Caches the normal and height values for faster processing.\n\nfloat GetDepth(vec2 fragCoord)\n{\n    return texture(iChannel0, fragCoord/iChannelResolution[0].xy).r * depthMax;\n}\n\nvec3 GetNormal(vec2 fragCoord)\n{\n    float ang1 = (1.0 / 12.0) * 6.2831853;\n    float ang2 = (5.0 / 12.0) * 6.2831853;\n    float ang3 = (9.0 / 12.0) * 6.2831853;\n    \n    vec3 v1 = vec3(fragCoord + vec2(sin(ang1), cos(ang1)) * 0.5, 0);\n    vec3 v2 = vec3(fragCoord + vec2(sin(ang2), cos(ang2)) * 0.5, 0);\n    vec3 v3 = vec3(fragCoord + vec2(sin(ang3), cos(ang3)) * 0.5, 0);\n    \n    v1.z = GetDepth(v1.xy);\n    v2.z = GetDepth(v2.xy);\n    v3.z = GetDepth(v3.xy);\n    \n    vec3 norm = normalize(cross(v1 - v2, v3 - v2));\n    \n    return norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = GetNormal(fragCoord);\n    fragColor.a = GetDepth(fragCoord);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float depthMax = 100.0;\n\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\nfloat curve(float x) \n{ \n   float y = (1.0 - 1.0/(x+1.0))*2.0;\n   y = 1.-y;\n   y = pow(y, 2.25);\n   y = 1.-y;\n   y *= 0.74;\n   y += x*0.26;\n   return y;\n} \n\nfloat myFunc2(float x)\n{\n    const float mini = 0.752;\n    const float maxi = 1.0;\n    \n    x = (x-mini)/(maxi-mini);\n    \n    x = clamp(x, 0., 1.);\n    \n    return curve(x);\n}\n\nfloat magToPower(float magnitude)\n{\n    float x = myFunc2(magnitude);\n    \n    x = -x/(x-1.0);\n    \n    return x;\n}\n\nfloat powerToMipBias(float power)\n{\n    return -(log2(power)*0.445743);\n}", "buffer_b_code": "// Buffer B:\n// Computes the visibility mapping, where:\n// x, y, z: The average direction of all unoccluded rays\n//     - Direction: Average direction visible to the texel.\n//     - Magnitude: Encodes the variation of visible ray directions. \n// w: The weighted number of unoccluded rays.\n\nvec4 GetNormalDepth(vec2 fragCoord)\n{\n    return texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n}\n\nfloat RayIsVisible(vec2 fragCoord, vec3 dir)\n{\n    vec4 normDepth = GetNormalDepth(fragCoord);\n    \n    normDepth.xyz = normalize(normDepth.xyz);\n\n    vec3 rayPos;\n    rayPos.xy = fragCoord;\n    rayPos.z = normDepth.w;\n    \n    float rDotN = dot(normDepth.xyz, dir);\n    if(rDotN < 0.0)\n        return 0.0;//dir -= 2.0 * rDotN * normDepth.xyz;\n     \n    if(dir.z <= 0.0)\n    {\n        return 0.0;\n    }\n    \n    float exitDepthDiff = depthMax - rayPos.z;\n    \n    if(exitDepthDiff <= 0.0)\n    {\n        return rDotN;\n    }\n    \n    vec3 exitPos = rayPos + dir * exitDepthDiff / dir.z;\n    \n    const int steps = 64;\n    for(int i = 1; i <= steps; i++)\n    {\n        vec3 pointAlongRay = mix(rayPos, exitPos, float(i) / float(steps));\n        \n        if(pointAlongRay.z <= GetNormalDepth(pointAlongRay.xy).w)\n            return 0.0;\n    }\n    \n    return rDotN;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texture(iChannel2, fragCoord/iChannelResolution[2].xy);\n    \n    vec4 noise = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n\n    vec2  aa = hash2( noise.x + float(iFrame)*203.1 );\n    float ra = sqrt(aa.y);\n    float rx = ra*cos(6.2831*aa.x); \n    float ry = ra*sin(6.2831*aa.x);\n    float rz = sqrt(1.0-aa.y);\n    vec3  dir = normalize(vec3(rx,ry,rz));\n\n    float weight = RayIsVisible(fragCoord, dir);\n\n        fragColor.xyz += dir * weight;\n        fragColor.a += weight;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[693, 693, 724, 724, 781], [783, 783, 832, 832, 1240], [1242, 1242, 1299, 1351, 6159]], "test": "untested"}
{"id": "DsKXDW", "name": "Immersed", "author": "ruojake", "description": "Journey into mystery", "tags": ["3d", "raymarching", "terrain", "clouds", "blur", "abstract", "360"], "likes": 7, "viewed": 307, "published": 3, "date": "1681150255", "time_retrieved": "2024-07-30T18:01:16.049247", "image_code": "// Immersed by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// You may sacrifice some detail for fps gain by undefining HIGHQ in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tc = ivec2(fragCoord);\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec4 bl0 = texelFetch(iChannel0, tc, 0);\n    \n    vec4 bl1 = texelFetch(iChannel1, tc, 0);\n    \n    ivec2 o = ivec2(0,1);\n    vec4 bl2\n        = texelFetch(iChannel2, tc - o * 3, 0)\n        + texelFetch(iChannel2, tc + o * 3, 0)\n        + texelFetch(iChannel2, tc - o * 2, 0) * 6.\n        + texelFetch(iChannel2, tc + o * 2, 0) * 6.\n        + texelFetch(iChannel2, tc - o, 0) * 15.\n        + texelFetch(iChannel2, tc + o, 0) * 15.\n        + texelFetch(iChannel2, tc, 0) * 20.;\n    bl2 /= 64.;\n    vec4 bl3 =  textureLod(iChannel2, fragCoord / iResolution.xy, 3.25);\n    \n    float dist = length(uv);\n    \n    fragColor = mix(bl1, bl0, clamp(dist * 5. - .8, 0., 1.));\n    fragColor = mix(fragColor, bl2, clamp(dist * 5. - 1.8, 0., 1.));\n    fragColor = mix(fragColor, bl3, clamp(dist * 5. - 3.4, 0., 1.));\n    \n    float dth = fract(dot(fragCoord + float(17 * (iFrame & 7)), vec2(.161616, .778797)));\n    fragColor.rgb += dth / 255.;\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FK(X) floatBitsToInt(cos(X)) ^ floatBitsToInt(X)\n\n// Undefine if chugging\n#define HIGHQ\n\nfloat hash12(vec2 p)\n{\n    int x = FK(p.x);\n    int y = FK(p.y);\n    \n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p), f = smoothstep(0., 1., p - i);\n    vec2 o = vec2(1,0);\n    \n    \n    return mix(\n        mix(hash12(i), hash12(i + o), f.x),\n        mix(hash12(i + o.yx), hash12(i + 1.), f.x),\n        f.y\n    );\n}\n\nfloat cloud(vec2 p)\n{\n    float a = .5;\n    float res = 0.;\n    mat2 r = rot(2.);\n    float s = 1.;\n    for (int i = 0; i < 4; ++i)\n    {\n        p.y += iTime * .3 * a * s;\n        s *= -1.;\n        res += noise(p) * a;\n        a *= .5;\n        p += 5.;\n        p *= r;\n        p *= 2.;\n    }\n    return res * res * 2.;\n}\n\n#define FBM(X,N) \\\nfloat X(vec2 p){ \\\n    float a = .5, res = 0., s = 1.;\\\n    mat2 r = rot(2.);\\\n    for(int i= 0; i < N; ++i){\\\n        res += noise(p) * a; a *= .5;\\\n        p += 3.; p.x += iTime * .1 * sqrt(a) * s; s *= -1.; p *= r; p *= 2.;\\\n    }\\\n    return res;\\\n}\n\n#define HGT(X,F) \\\nfloat X(vec3 p){ return p.y - F(p.xz*.25) * 2. + .1; }\n\n#define NML(X,H, E) \\\nvec3 X(vec3 p, float d){ \\\n    const vec2 e = vec2(E, 0);\\\n    return normalize(\\\n        d - vec3(H(p - e.xyy), H(p - e.yxy), H(p - e.yyx))\\\n    );\\\n}\n\n\nFBM(fbm0,9)\nFBM(fbm1,7)\nFBM(fbm2,4)\n\nHGT(height0,fbm0)\nHGT(height1,fbm1)\nHGT(height2,fbm2)\n\nNML(normal0, height0, .001)\nNML(normal1, height1, .002)\nNML(normal2, height2, .01)\n\n#ifdef HIGHQ\n    #define NEARHEIGHT t < 3. ? height00(p) * .75 : \n    #define NEARNORMAL t < 3. ? normal00(p, d) :\n    \n    FBM(fbm00, 14)\n    HGT(height00, fbm00)\n    NML(normal00, height00, .0005)\n#else\n    #define NEARHEIGHT \n    #define NEARNORMAL\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    uv *= rot(iTime * -.01);\n    vec2 pol = vec2(atan(uv.y, uv.x), length(uv) * -4.5 + .8);\n    float dth = fract(dot(fragCoord + float(17 * (iFrame & 7)), vec2(.161616, .778797)));\n    \n    vec3 ro = vec3(0,2,iTime * -.1);\n    vec3 rd = normalize(vec3(0,pol.y, 1.4));\n    rd.xz *= rot(pol.x + dth * .001);\n    vec3 p = ro;\n    float t = height2(p) + dth * .002, i = 0., d;\n    float o = -1.;\n    for(;i < 1. && t < 50. && rd.y <= 0.; i += 1./128.)\n    {\n        p = ro + rd * t;\n        d = NEARHEIGHT t < 6. ? height0(p) * .75 : t < 15. ? height1(p) * .95 : height2(p) * 1.3;\n        if (false && o > 0. && d > 0.)\n        {\n            d = d*o/(o-d);\n        }\n        o = d;\n        t += d;\n        if (abs(d) < .0001 * t) break;\n    }\n    \n    vec3 sky = mix(vec3(.9), vec3(.2, .5, 1.), max(rd.y + .2, 0.));\n    vec3 ld = normalize(vec3(rd.xz * rot(-.3),.3).xzy);\n    vec3 col = sky;\n    if (t < 50. && rd.y <= 0.)\n    {\n        vec3 n = NEARNORMAL t < 6. ? normal0(p, d) : t < 15. ? normal1(p, d) : normal2(p, d);\n        \n        \n        float l = dot(ld, n) * .5 + .5;\n        l *= l;\n        \n        col = mix(vec3(.7,.4,.1), vec3(.2,.8,.2), smoothstep(.95,1.,n.y));\n        col = mix(col * l, vec3(l), l*l*l);\n        col *= 1. - i*i;\n        col = mix(sky, col, exp(-t * .04 + pow(p.y * .5, 3.)));\n        \n    }\n    \n    col = mix(vec3(col.g), col, 1. + clamp(1. - t * .3 + .4, 0., 1.));\n    if(rd.y < 0.)\n    {\n        float T = t;\n        t = 1.25 / -rd.y + dth * .01;\n        float v = 0.;\n        for(int j = 0; j < 40 && t < T ; ++j)\n        {\n            p = ro + rd * t;\n            t += .0075 / -rd.y;\n            v -= cloud(p.xz * vec2(.4,.2)) * sin(float(j) * .079);\n        }\n        float l = 1. - max(cloud(p.xz + ld.xz * .3 / ld.y) + v * .125 + .125, 0.); \n        col = mix(mix(vec3(.07, .1, .2), vec3(1), l*l), col, exp(v / (t * 2.5 + 5.)));\n    }\n\n    col *= 1.-pow(clamp(length(uv),0.,1.), 4.);\n    //col = vec3(i);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tc = ivec2(fragCoord);\n    ivec2 o = ivec2(1,0);\n    fragColor\n        = texelFetch(iChannel0, tc - o * 3, 0)\n        + texelFetch(iChannel0, tc + o * 3, 0)\n        + texelFetch(iChannel0, tc - o * 2, 0) * 6.\n        + texelFetch(iChannel0, tc + o * 2, 0) * 6.\n        + texelFetch(iChannel0, tc - o, 0) * 15.\n        + texelFetch(iChannel0, tc + o, 0) * 15.\n        + texelFetch(iChannel0, tc, 0) * 20.;\n    fragColor /= 64.;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tc = ivec2(fragCoord);\n    ivec2 o = ivec2(0,1);\n    fragColor\n        = texelFetch(iChannel0, tc - o * 3, 0)\n        + texelFetch(iChannel0, tc + o * 3, 0)\n        + texelFetch(iChannel0, tc - o * 2, 0) * 6.\n        + texelFetch(iChannel0, tc + o * 2, 0) * 6.\n        + texelFetch(iChannel0, tc - o, 0) * 15.\n        + texelFetch(iChannel0, tc + o, 0) * 15.\n        + texelFetch(iChannel0, tc, 0) * 20.;\n    fragColor /= 64.;\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tc = ivec2(fragCoord);\n    ivec2 o = ivec2(1,0);\n    fragColor\n        = texelFetch(iChannel0, tc - o * 3, 0)\n        + texelFetch(iChannel0, tc + o * 3, 0)\n        + texelFetch(iChannel0, tc - o * 2, 0) * 6.\n        + texelFetch(iChannel0, tc + o * 2, 0) * 6.\n        + texelFetch(iChannel0, tc - o, 0) * 15.\n        + texelFetch(iChannel0, tc + o, 0) * 15.\n        + texelFetch(iChannel0, tc, 0) * 20.;\n    fragColor /= 64.;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKXDW.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[188, 188, 245, 245, 1304]], "test": "untested"}
{"id": "msKXDD", "name": "Rainbow Filter!", "author": "Cast_E", "description": "A rainbow effect using hsv to rgb converter (saturation included)\nSource: https://gist.github.com/983/e170a24ae8eba2cd174f", "tags": ["filter", "rainbow", "hsv"], "likes": 0, "viewed": 174, "published": 3, "date": "1681149543", "time_retrieved": "2024-07-30T18:01:16.959813", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 hsv = vec3(uv.y + -iTime, 1, 1);\n    float saturation = 1.;\n    \n    vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    \n    vec3 rainbow = vec3(hsv.z * mix(k.xxx, clamp(p - k.xxx, 0., saturation), hsv.y));\n    \n    vec3 color = rainbow * texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 473]], "test": "untested"}
{"id": "msVXWD", "name": "Handwritten Digit Recognizer CNN", "author": "kishimisu", "description": "All infos are in the Image description!", "tags": ["number", "convolution", "learning", "digit", "linear", "model", "ai", "machine", "neural", "recognition", "network", "convolutional", "prediction", "ml"], "likes": 258, "viewed": 11213, "published": 3, "date": "1681146843", "time_retrieved": "2024-07-30T18:01:18.286266", "image_code": "/* CNN Digit Recognizer by @kishimisu (2023) - https://www.shadertoy.com/view/msVXWD\n\n    A Convolutional Neural Network implementation pre-trained on the MNIST dataset.\n\n    - Draw digits between 0-9 in the right square\n    - It can take some time to compile\n    - Exactly 2023 trainable parameters!\n    \n    Python notebook created for this project: \n    - https://colab.research.google.com/drive/1bOAI1xb8Z4D5LoNd_lAm6BIuLJ3OYjNi\n    \n    ***\n    \n    I wasn't very satisfied with my previous version (see fork) that was using a\n    very basic network containing one hidden layer only. It achieved 92% accuracy\n    during training but translated poorly in shaders.\n\n    This time I've used a more efficient approach for this kind of task: a basic CNN\n    with only 2 convolution + max pooling layers, and only one fully connected layer.\n    It achieved a 98% accuracy during training, and it seems to make better predictions\n    in shadertoy despite having half less parameters (2023 vs 4120).\n    \n    Note that it seem to struggle to predict the '6' and '9', and also if the digits\n    are too off-centered. I couldn't augment the data for such a tiny network size!\n   \n  ### Technical issues ###\n  \n    The first CNN architecture I tried to implement was very similar to this one, but\n    instead of having 8 and 5 feature maps respectively, I had 10 and 10.\n    Increasing the number of feature map exponentially increases the number of weights,\n    thus the amount of computations, characters and compilation time.\n\n    Here the computational intensity doesn't seem to be a problem, but the compilation\n    time is what really made me struggle with this project.\n\n    If you look around in the code, you will see that there are no loops for the network\n    calculation, despite the fact that a CNN heavily relies on loops and nested loops.\n    When using loops, the compilation time went to the moon and it was very impractical,\n    this is why I preferred to decompose every calculation, at the cost of a big increase\n    in the character count (this shader could be twice as short) and degraded readability.\n  \n  ### Network Architecture ###\n  \n  (Buffer A)\n  * Input layer\n   - 28x28 = 784 inputs\n  \n  (Buffer B)\n  * First convolution group (8 feature maps):\n   - Convolution Layer (kernel size=5x5, stride=1)   : 28x28 => 8x24x24\n   - ReLU activation function\n   - Max Pooling Layer (kernel size=2x2, stride=2x2) : 8x24x24 => 8x12x12\n  \n  (Buffer C)\n  * Second convolution group (5 feature maps):\n   - Convolution Layer (kernel size=5x5, stride=1)   : 8x12x12 => 5x8x8\n   - ReLU activation function\n   - Max Pooling Layer (kernel size=2x2, stride=2x2) : 5x8x8 => 5x4x4\n  \n  (Buffer D)\n  * Fully connected layer\n   - 5x4x4 = 80 => 10\n   \n  (Image)\n  * Softmax function\n  \n   Total number of parameters: 2,023!\n*/\n\n// Text utilities\nfloat char(vec2 u, vec2 p) {\n    return texture(iChannel3, (u + p) / 16.).r * step(0., min(u.x,u.y)) * step(max(u.x,u.y), 1.);\n}\nfloat printInputLayer(vec2 u) {\n    print _I _n _p _u _t _sp _L _a _y _e _r _end\n}\nfloat printConv(vec2 u, int i) {\n    print _C _o _n _v _o _l _u _t _i _o _n _sp _dig(i) _end\n}\nfloat printMaxPooling(vec2 u, int i) {\n    print _M _a _x _sp _P _o _o _l _i _n _g _sp _dig(i) _end\n}\nfloat printFullyConnected(vec2 u) {\n    print _F _u _l _l _y _sp _C _o _n _n _e _c _t _e _d _end\n}\nfloat printOutputLayer(vec2 u) {\n    print _O _u _t _p _u _t _sp _L _a _y _e _r _end\n}\nfloat printPrediction(vec2 u) {\n    print _P _r _e _d _i _c _t _i _o _n _dd _end\n}\n\nfloat rect(vec2 p) {\n    vec2 d = abs(p-.5)-.5;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\n// Color\nfloat sigmoid(float x) {\n  return 2.0 / (1.0 + exp(-x)) - 1.0;\n}\nvec3 pal(float x) {\n    x /= 8.;\n    x = 1.-x;\n    return cos( 6.28318*(vec3(1.258, 0.838, 0.708)*x+vec3(0.5)) )*.5+.5;\n}\n\n// Calculates the denominator part for the softmax function,\n// And take advantage of the loop to store the predicted outcome\nfloat getExpSumAndPrediction(inout vec2 prediction) {\n    float sum = 0.;\n    float upp = -1e7;\n\n    for (float i = 0.; i < num_classes; i++) {\n        float val = texture(iChannel2, vec2(i+.5,.5) / R).r;\n        if (val > upp) {\n            upp = val;\n            prediction = vec2(i, exp(val));\n        }\n        sum += exp(val);\n    }\n    return sum;\n}\n\n// Displays a portion of a texture containing feature map data\n// p : normalized uv coordinates (0-1)\n// s : scaling factor\n// r.xy : x/y start (in pixels)\n// r.zw : x/y end   (in pixels)\nvec3 displayFeatureMaps(vec2 p, vec2 s, vec4 r, float feature_maps, sampler2D smp) { \n    p = p*s + vec2(1.-s.x,0)/2.; // scale and center uvs\n    \n    float fp = 1./feature_maps;\n    float id = floor(p.x*feature_maps); // current feature map id\n    float m = 1.1; // border width\n    \n    //check bounds\n    if (min(p.x,p.y) < 0. || max(p.x,p.y) > 1. || abs(mod(p.x, fp) - fp*.5) > fp/m/2. || abs(p.y-.5) > 1./m/2.) \n        return vec3(0);\n    \n    m *= .999;               // fix overflow issue\n    p *= m;                  // scale down\n    p.x -= (m-1.) * id * fp; // offset x from id\n    p.x -= (m-1.) * .5 * fp; // re-center x\n    p.y -= (m-1.) * .5;      // re-center y\n    p *= r.zw / R;           // crop\n    p.xy += r.xy/R;          // offset origin\n    \n    float val = texture(smp, p).r;             // Get value\n    if (r.y > .0) val = 1. - sigmoid(val)*1.3; // Change color map for convolution (as it can go negative)\n    return pal(val); // Return mapped color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / R;\n    vec3 col;\n\n    vec2 prediction; // index, confidence\n    float exp_sum = getExpSumAndPrediction(prediction);\n\n    uv.x *= iAspect;\n\n    // Left part of the screen (visualizations)\n    if (uv.x < iAspect - 1.) {\n        uv.x += 1.;\n        // Prediction panel\n        if(uv.y < .12) {            \n            uv = vec2(uv.x - 1.05, uv.y) * 10.;\n            col += printPrediction(uv);\n            col += vec3(1,0,0) * char(uv*.7 - vec2(3.5,-.1), vec2(prediction.x,12));\n            col = mix(pal(prediction.y/exp_sum*3.), col, length(col));\n        }\n        // Output panel\n        else if (uv.y < .47) {\n            // Transform to upper right area\n            vec2 tuv = vec2( (uv.x - 1.) / (iAspect - 1.), (uv.y-.12) /(.43-.12));\n            // Current output index\n            float idx = floor(tuv.x * num_classes);\n            \n            // Output value for the current index\n            float val = texture(iChannel2, vec2(idx+.5,.5) / R).r;\n            // Apply the softmax function\n            val = exp(val) / exp_sum; \n\n            // Draw bars\n            col = mix(vec3(1,0,0), vec3(0,1,0), val) * smoothstep(0., .01, val - tuv.y);   \n            col = pal(val*2.5) * smoothstep(0., .01, val - tuv.y);\n\n            // Draw \"output\" text\n            uv = vec2(uv.x - .98, uv.y-.41) * 22.;\n            col += printOutputLayer(uv);\n            \n            // Draw digits\n            tuv = vec2(fract(tuv.x*num_classes), tuv.y*4.);\n            col += vec3(char(tuv, vec2(idx,12))); \n        }\n        // Fully connected layer\n        else if (uv.y < .5) {\n            vec2 tuv = vec2( (uv.x - 1.) / (iAspect - 1.), (uv.y-.47) /(.48-.47));\n            float id = floor(tuv.x * 16. * feature_maps_2);\n            float x = mod(id, 4.*feature_maps_2);\n            float y = floor(id / (4.*feature_maps_2));\n            \n            col = pal(texelFetch(iChannel1, ivec2(x,y), 0).r);\n        }\n        // Feature maps\n        else {\n            // Display texts\n            uv = (uv - vec2(.98,.96)) * 24.;\n            col += printConv(uv, 1);\n            \n            uv.y += 3.;\n            col += printMaxPooling(uv, 1);\n            \n            uv.y += 2.85;\n            col += printConv(uv, 2);\n            \n            uv.y += 2.5;\n            col += printMaxPooling(uv, 2);\n            \n            uv.y += 2.4;\n            col += printFullyConnected(uv);\n            \n            // Remap uv\n            uv  = fragCoord / R;\n            uv.x = uv.x / (1. - R.y/R.x);\n            \n            // Display feature maps\n            uv.y -= .88;\n            col += displayFeatureMaps(uv, vec2(10./feature_maps_1,12), vec4(0, 12, 24.*feature_maps_1, 24), feature_maps_1, iChannel0);\n\n            uv.y += .115;\n            col += displayFeatureMaps(uv, vec2(1.2*10./feature_maps_1,1.2*12.), vec4(0, 0, 12.*feature_maps_1, 12), feature_maps_1, iChannel0);\n\n            uv.y += .11;\n            col += displayFeatureMaps(uv, vec2(1.95*10./feature_maps_1,1.95*8.), vec4(0, 4, 8.*feature_maps_2, 8), feature_maps_2, iChannel1);\n            \n            uv.y += .1;\n            col += displayFeatureMaps(uv, vec2(2.5*10./feature_maps_1,2.5*8.), vec4(0, 0, 4.*feature_maps_2, 4), feature_maps_2, iChannel1);\n        }\n    }\n    // Display drawing\n    else {\n        uv.x = uv.x - iAspect + 1.;\n        col += printInputLayer((uv-vec2(0,.9))*15.);\n        col += vec3(0.14,1,0.51) * smoothstep(.015, 0.004, abs(rect(uv)));           \n        col += texture(iChannel0, fragCoord / R).r;\n    }\n         \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* This buffer handles the drawing part */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / R;\n    vec2 m = (iMouse.xy - fragCoord) / R.y;\n    \n    float d = smoothstep(.06, 0., length(m)); // \"Pen\" intensity\n    d *= step(0., iMouse.z);                  // Only draw on mouse press\n        \n    // Accumulate values and keep them in the [0-1] range\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = clamp(col + d, 0., 1.);\n    \n    col *= step(iMouse.w,0.); // Reset on new click\n        \n    fragColor = vec4(col, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/* This buffer is responsible for:\n   - Convolution Layer 1 (kernel size=5x5, stride=1)   : 28x28 => 8x24x24\n   - ReLU activation function\n   - Max Pooling Layer 1 (kernel size=2x2, stride=2x2) : 8x24x24 => 8x12x12\n   \n   This is done as a 2-frame process: first the Convolution feature maps \n   are calculated and stored in Buffer B, which is then read again to \n   calculate and store the Max Pooling feature maps.\n   It also draws the (pixelated) input layer on the right.\n*/  \n\n#define pool_size 12.\n\n// Get normalized input pixel\n// p: [0, input_res-1]\nfloat i(vec2 p) {  \n    p = vec2((p.x+.5) / iAspect, p.y+.5) / input_res;\n    p.x += 1. - 1./iAspect;\n    float val = textureLod(iChannel0, p, log2(iResolution.y/input_res)).r;\n    return (val - mean) / std; // Normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 uv = fragCoord / R;\n    vec3 col = vec3(0);\n    \n    vec2 f = fragCoord - .5;\n    ivec2 F = ivec2(f);\n    \n    // Max Pooling\n    if (F.x < int(pool_size * feature_maps_1) && F.y < int(pool_size)) {\n        ivec2 p = ivec2(f*2.) + ivec2(0, pool_size);\n        \n        float x = max(texelFetch(iChannel1, p, 0).r,\n                  max(texelFetch(iChannel1, p + ivec2(0,1), 0).r,\n                  max(texelFetch(iChannel1, p + ivec2(1,0), 0).r,\n                      texelFetch(iChannel1, p + ivec2(1,1), 0).r)));\n                      \n        // ReLU activation function\n        x = max(0., x); \n        \n        col = vec3(x);\n    }\n    // Convolution\n    else if (F.x < int(pool_size * feature_maps_1 * 2.) && F.y >= int(pool_size) && F.y < int(pool_size*3.)) {\n        int fmap = int(f.x / (pool_size*2.));\n        vec2 p = mod(f - vec2(0,pool_size), pool_size*2.);\n        float x;\n        \n        if (fmap == 0) x = -.256220*i(p) - .263963*i(p+vec2(1,0)) - .222650*i(p+vec2(2,0)) - .121450*i(p+vec2(3,0)) + .008962*i(p+vec2(4,0)) - .286535*i(p+vec2(0,1)) - .128346*i(p+vec2(1,1)) - .119005*i(p+vec2(2,1)) - .105653*i(p+vec2(3,1)) + .106190*i(p+vec2(4,1)) - .196784*i(p+vec2(0,2)) + .015316*i(p+vec2(1,2)) + .154883*i(p+vec2(2,2)) + .169439*i(p+vec2(3,2)) + .155174*i(p+vec2(4,2)) - .088119*i(p+vec2(0,3)) + .207242*i(p+vec2(1,3)) + .153355*i(p+vec2(2,3)) + .170941*i(p+vec2(3,3)) + .058379*i(p+vec2(4,3)) + .179226*i(p+vec2(0,4)) + .170095*i(p+vec2(1,4)) + .187621*i(p+vec2(2,4)) + .115604*i(p+vec2(3,4)) + .211174*i(p+vec2(4,4)) + .026794;\n        else if (fmap == 1) x = -.208491*i(p) - .246941*i(p+vec2(1,0)) - .118710*i(p+vec2(2,0)) + .029216*i(p+vec2(3,0)) + .134078*i(p+vec2(4,0)) + .175747*i(p+vec2(0,1)) + .050075*i(p+vec2(1,1)) - .259553*i(p+vec2(2,1)) - .155585*i(p+vec2(3,1)) - .184678*i(p+vec2(4,1)) + .216247*i(p+vec2(0,2)) + .372172*i(p+vec2(1,2)) + .049592*i(p+vec2(2,2)) - .160362*i(p+vec2(3,2)) + .087013*i(p+vec2(4,2)) - .088406*i(p+vec2(0,3)) + .108477*i(p+vec2(1,3)) + .387428*i(p+vec2(2,3)) + .045766*i(p+vec2(3,3)) + .116031*i(p+vec2(4,3)) - .219892*i(p+vec2(0,4)) - .266197*i(p+vec2(1,4)) + .089884*i(p+vec2(2,4)) + .015118*i(p+vec2(3,4)) + .100712*i(p+vec2(4,4)) + .024362;\n        else if (fmap == 2) x = -.152888*i(p) + .072108*i(p+vec2(1,0)) + .141602*i(p+vec2(2,0)) + .300121*i(p+vec2(3,0)) - .126745*i(p+vec2(4,0)) - .232032*i(p+vec2(0,1)) - .066877*i(p+vec2(1,1)) + .099079*i(p+vec2(2,1)) + .214114*i(p+vec2(3,1)) + .106322*i(p+vec2(4,1)) - .143861*i(p+vec2(0,2)) - .108627*i(p+vec2(1,2)) + .071171*i(p+vec2(2,2)) + .197545*i(p+vec2(3,2)) + .184703*i(p+vec2(4,2)) - .112155*i(p+vec2(0,3)) - .106069*i(p+vec2(1,3)) - .093000*i(p+vec2(2,3)) + .101620*i(p+vec2(3,3)) + .161687*i(p+vec2(4,3)) - .083832*i(p+vec2(0,4)) - .058263*i(p+vec2(1,4)) - .031437*i(p+vec2(2,4)) + .034528*i(p+vec2(3,4)) + .223640*i(p+vec2(4,4)) - .389324;\n        else if (fmap == 3) x =  .127065*i(p) + .067651*i(p+vec2(1,0)) + .237392*i(p+vec2(2,0)) + .122720*i(p+vec2(3,0)) + .263380*i(p+vec2(4,0)) + .272143*i(p+vec2(0,1)) + .229455*i(p+vec2(1,1)) + .201271*i(p+vec2(2,1)) + .158494*i(p+vec2(3,1)) + .083364*i(p+vec2(4,1)) + .087063*i(p+vec2(0,2)) + .005914*i(p+vec2(1,2)) - .107822*i(p+vec2(2,2)) + .037689*i(p+vec2(3,2)) - .241690*i(p+vec2(4,2)) - .144014*i(p+vec2(0,3)) - .320903*i(p+vec2(1,3)) - .222353*i(p+vec2(2,3)) - .283808*i(p+vec2(3,3)) - .332431*i(p+vec2(4,3)) - .049706*i(p+vec2(0,4)) - .170751*i(p+vec2(1,4)) - .223001*i(p+vec2(2,4)) - .079481*i(p+vec2(3,4)) + .056033*i(p+vec2(4,4)) - .100076;\n        else if (fmap == 4) x =  .033839*i(p) + .143132*i(p+vec2(1,0)) - .216749*i(p+vec2(2,0)) - .075409*i(p+vec2(3,0)) - .010285*i(p+vec2(4,0)) + .097860*i(p+vec2(0,1)) + .241089*i(p+vec2(1,1)) + .214650*i(p+vec2(2,1)) - .225313*i(p+vec2(3,1)) - .184724*i(p+vec2(4,1)) - .270974*i(p+vec2(0,2)) - .187646*i(p+vec2(1,2)) + .235756*i(p+vec2(2,2)) + .272372*i(p+vec2(3,2)) - .101422*i(p+vec2(4,2)) - .151017*i(p+vec2(0,3)) + .042975*i(p+vec2(1,3)) - .064422*i(p+vec2(2,3)) + .240397*i(p+vec2(3,3)) - .020506*i(p+vec2(4,3)) + .119857*i(p+vec2(0,4)) - .080291*i(p+vec2(1,4)) - .152493*i(p+vec2(2,4)) - .076686*i(p+vec2(3,4)) + .018775*i(p+vec2(4,4)) - .021946;\n        else if (fmap == 5) x = -.408473*i(p) - .134044*i(p+vec2(1,0)) - .069418*i(p+vec2(2,0)) + .135106*i(p+vec2(3,0)) + .173311*i(p+vec2(4,0)) - .176028*i(p+vec2(0,1)) - .379614*i(p+vec2(1,1)) - .162828*i(p+vec2(2,1)) - .082388*i(p+vec2(3,1)) - .015580*i(p+vec2(4,1)) - .027795*i(p+vec2(0,2)) - .173466*i(p+vec2(1,2)) - .435070*i(p+vec2(2,2)) - .292225*i(p+vec2(3,2)) - .234535*i(p+vec2(4,2)) + .202488*i(p+vec2(0,3)) + .089885*i(p+vec2(1,3)) - .082089*i(p+vec2(2,3)) - .095222*i(p+vec2(3,3)) - .332411*i(p+vec2(4,3)) + .152386*i(p+vec2(0,4)) + .277061*i(p+vec2(1,4)) + .114890*i(p+vec2(2,4)) + .061884*i(p+vec2(3,4)) - .197509*i(p+vec2(4,4)) + .094496;\n        else if (fmap == 6) x = -.160558*i(p) - .262113*i(p+vec2(1,0)) + .070456*i(p+vec2(2,0)) + .071991*i(p+vec2(3,0)) + .223662*i(p+vec2(4,0)) - .250266*i(p+vec2(0,1)) - .110144*i(p+vec2(1,1)) - .006879*i(p+vec2(2,1)) + .095233*i(p+vec2(3,1)) + .134715*i(p+vec2(4,1)) - .217089*i(p+vec2(0,2)) - .253514*i(p+vec2(1,2)) - .046932*i(p+vec2(2,2)) + .212780*i(p+vec2(3,2)) + .138915*i(p+vec2(4,2)) - .067716*i(p+vec2(0,3)) - .162607*i(p+vec2(1,3)) - .162463*i(p+vec2(2,3)) - .006180*i(p+vec2(3,3)) + .204881*i(p+vec2(4,3)) - .164372*i(p+vec2(0,4)) - .196290*i(p+vec2(1,4)) - .336171*i(p+vec2(2,4)) - .003429*i(p+vec2(3,4)) + .090525*i(p+vec2(4,4)) - .214098;\n        else if (fmap == 7) x =  .314642*i(p) + .069870*i(p+vec2(1,0)) - .232515*i(p+vec2(2,0)) - .196920*i(p+vec2(3,0)) - .258605*i(p+vec2(4,0)) + .182785*i(p+vec2(0,1)) - .227795*i(p+vec2(1,1)) - .121011*i(p+vec2(2,1)) - .160892*i(p+vec2(3,1)) - .082476*i(p+vec2(4,1)) + .000842*i(p+vec2(0,2)) - .182144*i(p+vec2(1,2)) - .192695*i(p+vec2(2,2)) - .022503*i(p+vec2(3,2)) - .187570*i(p+vec2(4,2)) - .158919*i(p+vec2(0,3)) - .226402*i(p+vec2(1,3)) - .036234*i(p+vec2(2,3)) + .014082*i(p+vec2(3,3)) - .162542*i(p+vec2(4,3)) - .310638*i(p+vec2(0,4)) - .177386*i(p+vec2(1,4)) - .002980*i(p+vec2(2,4)) - .114051*i(p+vec2(3,4)) - .113300*i(p+vec2(4,4)) + .144752;\n              \n        //x = max(0., x);\n        col = vec3(x);\n    }   \n    // Displays the pixelated version of the input (on the right)\n    else {\n        uv.x -= 1. - 1./iAspect;\n        uv.x *= iAspect;\n        uv = floor(uv * input_res);\n        col = vec3(i(uv)*std+mean);\n    }\n    \n    fragColor = vec4(col, 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/* This buffer is responsible for:\n   - Convolution Layer 2 (kernel size=5x5, stride=1)   : 8x12x12 => 5x8x8\n   - ReLU activation function\n   - Max Pooling Layer 2 (kernel size=2x2, stride=2x2) : 5x8x8 => 5x4x4\n   \n   This is done as a 2-frame process: first the Convolution feature maps \n   are calculated and stored in Buffer C, which is then read again to \n   calculate and store the Max Pooling feature maps.\n*/\n   \n#define pool_size 4.\n\nfloat i(vec2 p) { \n    return texelFetch(iChannel0, ivec2(p), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 uv = fragCoord / R;\n    vec3 col = vec3(0);\n    \n    vec2 f = fragCoord - .5;\n    ivec2 F = ivec2(f);\n    \n    // Max Pooling\n    if (F.x < int(pool_size * feature_maps_2) && F.y < int(pool_size)) {\n        ivec2 p = ivec2(f*2.) + ivec2(0, pool_size);\n        \n        float x = max(texelFetch(iChannel1, p, 0).r,\n                  max(texelFetch(iChannel1, p + ivec2(0,1), 0).r,\n                  max(texelFetch(iChannel1, p + ivec2(1,0), 0).r,\n                      texelFetch(iChannel1, p + ivec2(1,1), 0).r)));\n        \n        // ReLU activation function\n        x = max(0., x); \n        \n        col = vec3(x);\n    }\n    // Convolution\n    else if (F.x < int(pool_size * feature_maps_2 * 2.) && F.y >= int(pool_size) && F.y < int(pool_size*3.)) {\n        int fmap = int(f.x / (pool_size*2.));\n        vec2 p = mod(f - vec2(0,pool_size), pool_size*2.);\n        float x;\n\n        if (fmap == 0) {\n            x = -.046534*i(p+vec2(0,0)) - .073340*i(p+vec2(1,0)) - .104696*i(p+vec2(2,0)) - .128232*i(p+vec2(3,0)) - .058648*i(p+vec2(4,0)) - .096220*i(p+vec2(0,1)) - .058887*i(p+vec2(1,1)) - .051275*i(p+vec2(2,1)) - .135895*i(p+vec2(3,1)) - .095000*i(p+vec2(4,1)) + .021992*i(p+vec2(0,2)) + .008313*i(p+vec2(1,2)) - .001602*i(p+vec2(2,2)) - .100098*i(p+vec2(3,2)) - .076632*i(p+vec2(4,2)) + .074367*i(p+vec2(0,3)) + .046224*i(p+vec2(1,3)) + .047301*i(p+vec2(2,3)) - .039357*i(p+vec2(3,3)) - .088746*i(p+vec2(4,3)) - .022489*i(p+vec2(0,4)) - .013636*i(p+vec2(1,4)) + .026681*i(p+vec2(2,4)) - .035710*i(p+vec2(3,4)) - .047739*i(p+vec2(4,4)) ;\n            x +=  .164134*i(p+vec2(12,0)) + .110662*i(p+vec2(13,0)) - .037616*i(p+vec2(14,0)) - .125064*i(p+vec2(15,0)) - .127855*i(p+vec2(16,0)) + .073158*i(p+vec2(12,1)) + .050712*i(p+vec2(13,1)) - .040878*i(p+vec2(14,1)) - .127835*i(p+vec2(15,1)) - .127839*i(p+vec2(16,1)) - .017567*i(p+vec2(12,2)) - .023066*i(p+vec2(13,2)) - .121369*i(p+vec2(14,2)) - .149846*i(p+vec2(15,2)) - .128354*i(p+vec2(16,2)) - .002525*i(p+vec2(12,3)) - .038398*i(p+vec2(13,3)) - .063718*i(p+vec2(14,3)) - .087393*i(p+vec2(15,3)) - .119930*i(p+vec2(16,3)) - .008945*i(p+vec2(12,4)) + .011088*i(p+vec2(13,4)) - .008347*i(p+vec2(14,4)) - .025335*i(p+vec2(15,4)) - .090066*i(p+vec2(16,4)) ;\n            x +=  .105954*i(p+vec2(24,0)) + .068219*i(p+vec2(25,0)) + .052490*i(p+vec2(26,0)) + .059224*i(p+vec2(27,0)) + .077750*i(p+vec2(28,0)) + .096263*i(p+vec2(24,1)) + .074264*i(p+vec2(25,1)) + .048235*i(p+vec2(26,1)) + .092739*i(p+vec2(27,1)) + .073469*i(p+vec2(28,1)) + .032869*i(p+vec2(24,2)) + .095552*i(p+vec2(25,2)) + .097416*i(p+vec2(26,2)) + .096990*i(p+vec2(27,2)) + .111675*i(p+vec2(28,2)) + .016135*i(p+vec2(24,3)) + .048912*i(p+vec2(25,3)) + .076057*i(p+vec2(26,3)) + .040083*i(p+vec2(27,3)) + .111671*i(p+vec2(28,3)) + .062053*i(p+vec2(24,4)) + .030614*i(p+vec2(25,4)) + .042673*i(p+vec2(26,4)) + .015659*i(p+vec2(27,4)) - .054323*i(p+vec2(28,4)) ;\n            x +=  .004916*i(p+vec2(36,0)) - .063013*i(p+vec2(37,0)) - .071405*i(p+vec2(38,0)) - .037116*i(p+vec2(39,0)) + .002900*i(p+vec2(40,0)) - .057140*i(p+vec2(36,1)) - .132976*i(p+vec2(37,1)) - .109345*i(p+vec2(38,1)) - .126376*i(p+vec2(39,1)) - .090146*i(p+vec2(40,1)) - .072674*i(p+vec2(36,2)) - .033938*i(p+vec2(37,2)) - .056043*i(p+vec2(38,2)) - .173670*i(p+vec2(39,2)) - .207806*i(p+vec2(40,2)) - .030818*i(p+vec2(36,3)) + .016815*i(p+vec2(37,3)) - .042149*i(p+vec2(38,3)) - .167785*i(p+vec2(39,3)) - .189784*i(p+vec2(40,3)) - .013633*i(p+vec2(36,4)) + .030919*i(p+vec2(37,4)) - .033668*i(p+vec2(38,4)) - .096383*i(p+vec2(39,4)) - .144897*i(p+vec2(40,4)) ;\n            x +=  .133044*i(p+vec2(48,0)) + .078342*i(p+vec2(49,0)) - .021171*i(p+vec2(50,0)) - .039290*i(p+vec2(51,0)) - .146281*i(p+vec2(52,0)) + .059153*i(p+vec2(48,1)) + .065948*i(p+vec2(49,1)) - .078621*i(p+vec2(50,1)) - .080518*i(p+vec2(51,1)) - .103001*i(p+vec2(52,1)) + .026036*i(p+vec2(48,2)) + .026372*i(p+vec2(49,2)) - .058402*i(p+vec2(50,2)) - .017815*i(p+vec2(51,2)) - .025400*i(p+vec2(52,2)) + .019300*i(p+vec2(48,3)) + .019241*i(p+vec2(49,3)) - .021274*i(p+vec2(50,3)) + .035523*i(p+vec2(51,3)) + .018338*i(p+vec2(52,3)) + .083902*i(p+vec2(48,4)) - .007695*i(p+vec2(49,4)) - .036464*i(p+vec2(50,4)) - .009007*i(p+vec2(51,4)) - .055234*i(p+vec2(52,4)) ;\n            x +=  .192597*i(p+vec2(60,0)) + .108261*i(p+vec2(61,0)) + .024767*i(p+vec2(62,0)) + .030960*i(p+vec2(63,0)) - .021334*i(p+vec2(64,0)) + .024290*i(p+vec2(60,1)) + .086279*i(p+vec2(61,1)) - .003715*i(p+vec2(62,1)) - .018433*i(p+vec2(63,1)) - .032012*i(p+vec2(64,1)) - .074780*i(p+vec2(60,2)) + .007053*i(p+vec2(61,2)) - .009388*i(p+vec2(62,2)) + .038558*i(p+vec2(63,2)) + .067052*i(p+vec2(64,2)) - .160614*i(p+vec2(60,3)) - .032528*i(p+vec2(61,3)) + .063304*i(p+vec2(62,3)) + .005934*i(p+vec2(63,3)) + .048658*i(p+vec2(64,3)) - .018971*i(p+vec2(60,4)) + .061493*i(p+vec2(61,4)) + .078854*i(p+vec2(62,4)) + .110024*i(p+vec2(63,4)) + .083818*i(p+vec2(64,4)) ;\n            x +=  .003607*i(p+vec2(72,0)) + .026321*i(p+vec2(73,0)) + .060368*i(p+vec2(74,0)) + .036074*i(p+vec2(75,0)) + .171541*i(p+vec2(76,0)) + .032160*i(p+vec2(72,1)) + .089552*i(p+vec2(73,1)) + .114002*i(p+vec2(74,1)) + .135316*i(p+vec2(75,1)) + .164947*i(p+vec2(76,1)) + .029636*i(p+vec2(72,2)) + .102024*i(p+vec2(73,2)) + .157455*i(p+vec2(74,2)) + .134793*i(p+vec2(75,2)) + .202357*i(p+vec2(76,2)) + .053904*i(p+vec2(72,3)) + .043092*i(p+vec2(73,3)) + .043481*i(p+vec2(74,3)) + .042083*i(p+vec2(75,3)) + .038933*i(p+vec2(76,3)) + .065984*i(p+vec2(72,4)) + .022676*i(p+vec2(73,4)) - .006638*i(p+vec2(74,4)) - .040437*i(p+vec2(75,4)) - .006689*i(p+vec2(76,4)) ;\n            x += -.148014*i(p+vec2(84,0)) - .131265*i(p+vec2(85,0)) - .006657*i(p+vec2(86,0)) + .028222*i(p+vec2(87,0)) + .059049*i(p+vec2(88,0)) - .088015*i(p+vec2(84,1)) - .044709*i(p+vec2(85,1)) + .008072*i(p+vec2(86,1)) + .089204*i(p+vec2(87,1)) + .032808*i(p+vec2(88,1)) + .034581*i(p+vec2(84,2)) + .050597*i(p+vec2(85,2)) + .079305*i(p+vec2(86,2)) + .068517*i(p+vec2(87,2)) - .010634*i(p+vec2(88,2)) + .015563*i(p+vec2(84,3)) + .152927*i(p+vec2(85,3)) + .181252*i(p+vec2(86,3)) + .039751*i(p+vec2(87,3)) + .100112*i(p+vec2(88,3)) + .027230*i(p+vec2(84,4)) + .100313*i(p+vec2(85,4)) + .128368*i(p+vec2(86,4)) + .128317*i(p+vec2(87,4)) + .169261*i(p+vec2(88,4)) + .015435;\n        }\n        else if (fmap == 1) {\n            x =  .168473*i(p+vec2(0,0)) + .032020*i(p+vec2(1,0)) + .080606*i(p+vec2(2,0)) + .144209*i(p+vec2(3,0)) + .231596*i(p+vec2(4,0)) + .079855*i(p+vec2(0,1)) + .003243*i(p+vec2(1,1)) - .009647*i(p+vec2(2,1)) + .048977*i(p+vec2(3,1)) + .097265*i(p+vec2(4,1)) - .072842*i(p+vec2(0,2)) - .098611*i(p+vec2(1,2)) - .112680*i(p+vec2(2,2)) - .060538*i(p+vec2(3,2)) - .056511*i(p+vec2(4,2)) - .103706*i(p+vec2(0,3)) - .094244*i(p+vec2(1,3)) - .127457*i(p+vec2(2,3)) - .089937*i(p+vec2(3,3)) - .037145*i(p+vec2(4,3)) + .136340*i(p+vec2(0,4)) + .058937*i(p+vec2(1,4)) - .078355*i(p+vec2(2,4)) - .123603*i(p+vec2(3,4)) - .098124*i(p+vec2(4,4)) ;\n            x += -.024345*i(p+vec2(12,0)) - .065386*i(p+vec2(13,0)) - .066836*i(p+vec2(14,0)) + .031687*i(p+vec2(15,0)) + .098069*i(p+vec2(16,0)) + .086487*i(p+vec2(12,1)) + .033651*i(p+vec2(13,1)) + .040699*i(p+vec2(14,1)) + .055580*i(p+vec2(15,1)) + .070794*i(p+vec2(16,1)) + .086650*i(p+vec2(12,2)) + .063994*i(p+vec2(13,2)) + .065869*i(p+vec2(14,2)) + .089419*i(p+vec2(15,2)) + .060025*i(p+vec2(16,2)) - .023042*i(p+vec2(12,3)) - .027093*i(p+vec2(13,3)) + .019867*i(p+vec2(14,3)) + .046299*i(p+vec2(15,3)) + .117471*i(p+vec2(16,3)) + .039959*i(p+vec2(12,4)) - .012688*i(p+vec2(13,4)) - .050492*i(p+vec2(14,4)) + .038449*i(p+vec2(15,4)) + .067053*i(p+vec2(16,4)) ;\n            x += -.027017*i(p+vec2(24,0)) - .127440*i(p+vec2(25,0)) - .171092*i(p+vec2(26,0)) - .129185*i(p+vec2(27,0)) - .076406*i(p+vec2(28,0)) - .017304*i(p+vec2(24,1)) + .018061*i(p+vec2(25,1)) - .080205*i(p+vec2(26,1)) - .125497*i(p+vec2(27,1)) - .040958*i(p+vec2(28,1)) + .052195*i(p+vec2(24,2)) + .109802*i(p+vec2(25,2)) + .033683*i(p+vec2(26,2)) + .025611*i(p+vec2(27,2)) - .034670*i(p+vec2(28,2)) + .028702*i(p+vec2(24,3)) + .125819*i(p+vec2(25,3)) + .089908*i(p+vec2(26,3)) + .069893*i(p+vec2(27,3)) - .003656*i(p+vec2(28,3)) - .058450*i(p+vec2(24,4)) - .017720*i(p+vec2(25,4)) + .019981*i(p+vec2(26,4)) - .024931*i(p+vec2(27,4)) - .032475*i(p+vec2(28,4)) ;\n            x += -.061035*i(p+vec2(36,0)) + .061276*i(p+vec2(37,0)) + .113922*i(p+vec2(38,0)) + .197254*i(p+vec2(39,0)) + .130410*i(p+vec2(40,0)) - .031010*i(p+vec2(36,1)) - .154345*i(p+vec2(37,1)) - .095403*i(p+vec2(38,1)) + .088329*i(p+vec2(39,1)) + .161673*i(p+vec2(40,1)) - .033375*i(p+vec2(36,2)) - .160063*i(p+vec2(37,2)) - .197056*i(p+vec2(38,2)) - .179653*i(p+vec2(39,2)) - .062698*i(p+vec2(40,2)) + .046245*i(p+vec2(36,3)) - .054445*i(p+vec2(37,3)) - .112475*i(p+vec2(38,3)) - .129480*i(p+vec2(39,3)) - .065540*i(p+vec2(40,3)) + .007957*i(p+vec2(36,4)) + .003427*i(p+vec2(37,4)) + .009232*i(p+vec2(38,4)) - .005896*i(p+vec2(39,4)) + .022805*i(p+vec2(40,4)) ;\n            x += -.070249*i(p+vec2(48,0)) - .085293*i(p+vec2(49,0)) - .033846*i(p+vec2(50,0)) - .002253*i(p+vec2(51,0)) + .170257*i(p+vec2(52,0)) + .021667*i(p+vec2(48,1)) + .018398*i(p+vec2(49,1)) - .070920*i(p+vec2(50,1)) + .013574*i(p+vec2(51,1)) + .094702*i(p+vec2(52,1)) + .098059*i(p+vec2(48,2)) + .163548*i(p+vec2(49,2)) + .151802*i(p+vec2(50,2)) + .081656*i(p+vec2(51,2)) + .102940*i(p+vec2(52,2)) + .051876*i(p+vec2(48,3)) + .170479*i(p+vec2(49,3)) + .141152*i(p+vec2(50,3)) + .148914*i(p+vec2(51,3)) + .167806*i(p+vec2(52,3)) + .011094*i(p+vec2(48,4)) + .130688*i(p+vec2(49,4)) + .115504*i(p+vec2(50,4)) + .151504*i(p+vec2(51,4)) + .114944*i(p+vec2(52,4)) ;\n            x +=  .040850*i(p+vec2(60,0)) - .090765*i(p+vec2(61,0)) - .123967*i(p+vec2(62,0)) - .145776*i(p+vec2(63,0)) - .089269*i(p+vec2(64,0)) + .041644*i(p+vec2(60,1)) + .016847*i(p+vec2(61,1)) - .085726*i(p+vec2(62,1)) - .143723*i(p+vec2(63,1)) - .142347*i(p+vec2(64,1)) + .055868*i(p+vec2(60,2)) + .071702*i(p+vec2(61,2)) + .010950*i(p+vec2(62,2)) - .033863*i(p+vec2(63,2)) - .115396*i(p+vec2(64,2)) - .034491*i(p+vec2(60,3)) - .016859*i(p+vec2(61,3)) - .003221*i(p+vec2(62,3)) + .029593*i(p+vec2(63,3)) + .055885*i(p+vec2(64,3)) - .021719*i(p+vec2(60,4)) - .088430*i(p+vec2(61,4)) - .045182*i(p+vec2(62,4)) - .036528*i(p+vec2(63,4)) - .000889*i(p+vec2(64,4)) ;\n            x += -.045231*i(p+vec2(72,0)) - .020948*i(p+vec2(73,0)) - .155331*i(p+vec2(74,0)) - .198503*i(p+vec2(75,0)) - .212880*i(p+vec2(76,0)) - .022472*i(p+vec2(72,1)) + .073340*i(p+vec2(73,1)) + .054503*i(p+vec2(74,1)) - .092496*i(p+vec2(75,1)) - .186318*i(p+vec2(76,1)) - .016517*i(p+vec2(72,2)) + .083499*i(p+vec2(73,2)) + .099173*i(p+vec2(74,2)) + .082856*i(p+vec2(75,2)) - .058938*i(p+vec2(76,2)) - .026629*i(p+vec2(72,3)) + .041044*i(p+vec2(73,3)) + .056476*i(p+vec2(74,3)) + .039056*i(p+vec2(75,3)) + .017643*i(p+vec2(76,3)) - .082308*i(p+vec2(72,4)) - .057666*i(p+vec2(73,4)) - .053039*i(p+vec2(74,4)) - .028161*i(p+vec2(75,4)) - .017550*i(p+vec2(76,4)) ;\n            x +=  .057026*i(p+vec2(84,0)) + .055334*i(p+vec2(85,0)) + .153768*i(p+vec2(86,0)) + .078982*i(p+vec2(87,0)) + .143101*i(p+vec2(88,0)) - .047424*i(p+vec2(84,1)) - .015665*i(p+vec2(85,1)) - .013397*i(p+vec2(86,1)) + .002743*i(p+vec2(87,1)) + .061596*i(p+vec2(88,1)) - .063201*i(p+vec2(84,2)) - .017605*i(p+vec2(85,2)) - .060343*i(p+vec2(86,2)) - .056431*i(p+vec2(87,2)) - .013590*i(p+vec2(88,2)) - .022667*i(p+vec2(84,3)) + .011825*i(p+vec2(85,3)) - .042425*i(p+vec2(86,3)) - .148410*i(p+vec2(87,3)) - .080338*i(p+vec2(88,3)) - .044272*i(p+vec2(84,4)) + .107271*i(p+vec2(85,4)) + .148680*i(p+vec2(86,4)) + .082134*i(p+vec2(87,4)) - .009649*i(p+vec2(88,4)) + .035864;\n        }\n        else if (fmap == 2) {\n            x =  .064619*i(p+vec2(0,0)) - .002426*i(p+vec2(1,0)) + .033947*i(p+vec2(2,0)) + .044316*i(p+vec2(3,0)) + .115687*i(p+vec2(4,0)) + .053022*i(p+vec2(0,1)) + .065041*i(p+vec2(1,1)) + .066363*i(p+vec2(2,1)) + .073362*i(p+vec2(3,1)) + .040481*i(p+vec2(4,1)) - .053032*i(p+vec2(0,2)) + .086060*i(p+vec2(1,2)) + .069675*i(p+vec2(2,2)) + .034031*i(p+vec2(3,2)) + .030123*i(p+vec2(4,2)) + .021665*i(p+vec2(0,3)) - .060047*i(p+vec2(1,3)) - .090843*i(p+vec2(2,3)) + .005910*i(p+vec2(3,3)) + .192376*i(p+vec2(4,3)) - .167963*i(p+vec2(0,4)) - .160012*i(p+vec2(1,4)) - .120027*i(p+vec2(2,4)) + .010712*i(p+vec2(3,4)) + .100215*i(p+vec2(4,4)) ;\n            x +=  .031789*i(p+vec2(12,0)) + .080503*i(p+vec2(13,0)) + .040288*i(p+vec2(14,0)) + .009264*i(p+vec2(15,0)) + .049026*i(p+vec2(16,0)) + .095390*i(p+vec2(12,1)) + .100852*i(p+vec2(13,1)) + .003961*i(p+vec2(14,1)) - .014274*i(p+vec2(15,1)) - .038138*i(p+vec2(16,1)) + .061696*i(p+vec2(12,2)) + .101006*i(p+vec2(13,2)) + .027643*i(p+vec2(14,2)) - .047844*i(p+vec2(15,2)) - .048016*i(p+vec2(16,2)) - .077837*i(p+vec2(12,3)) - .095082*i(p+vec2(13,3)) - .145615*i(p+vec2(14,3)) - .099213*i(p+vec2(15,3)) - .044476*i(p+vec2(16,3)) - .134099*i(p+vec2(12,4)) - .114614*i(p+vec2(13,4)) - .105741*i(p+vec2(14,4)) - .051032*i(p+vec2(15,4)) + .076231*i(p+vec2(16,4)) ;\n            x += -.033284*i(p+vec2(24,0)) - .048057*i(p+vec2(25,0)) - .050669*i(p+vec2(26,0)) - .023352*i(p+vec2(27,0)) - .044807*i(p+vec2(28,0)) - .032219*i(p+vec2(24,1)) - .009562*i(p+vec2(25,1)) + .003693*i(p+vec2(26,1)) + .044597*i(p+vec2(27,1)) + .040209*i(p+vec2(28,1)) - .022571*i(p+vec2(24,2)) - .045959*i(p+vec2(25,2)) - .114624*i(p+vec2(26,2)) - .064666*i(p+vec2(27,2)) - .033394*i(p+vec2(28,2)) - .060179*i(p+vec2(24,3)) - .132713*i(p+vec2(25,3)) - .120706*i(p+vec2(26,3)) - .112588*i(p+vec2(27,3)) - .064358*i(p+vec2(28,3)) - .137772*i(p+vec2(24,4)) - .115105*i(p+vec2(25,4)) - .073647*i(p+vec2(26,4)) - .000281*i(p+vec2(27,4)) + .030574*i(p+vec2(28,4)) ;\n            x += -.118146*i(p+vec2(36,0)) - .095420*i(p+vec2(37,0)) - .058021*i(p+vec2(38,0)) - .016661*i(p+vec2(39,0)) - .014902*i(p+vec2(40,0)) + .040134*i(p+vec2(36,1)) + .011013*i(p+vec2(37,1)) + .116889*i(p+vec2(38,1)) + .098456*i(p+vec2(39,1)) + .146382*i(p+vec2(40,1)) + .115527*i(p+vec2(36,2)) + .098948*i(p+vec2(37,2)) + .132890*i(p+vec2(38,2)) + .074907*i(p+vec2(39,2)) + .059989*i(p+vec2(40,2)) + .067840*i(p+vec2(36,3)) - .003165*i(p+vec2(37,3)) + .103561*i(p+vec2(38,3)) + .104807*i(p+vec2(39,3)) + .111656*i(p+vec2(40,3)) + .156925*i(p+vec2(36,4)) + .045268*i(p+vec2(37,4)) + .018593*i(p+vec2(38,4)) - .069436*i(p+vec2(39,4)) - .049523*i(p+vec2(40,4)) ;\n            x +=  .011728*i(p+vec2(48,0)) + .040852*i(p+vec2(49,0)) + .000240*i(p+vec2(50,0)) - .038427*i(p+vec2(51,0)) - .041976*i(p+vec2(52,0)) - .004255*i(p+vec2(48,1)) + .019583*i(p+vec2(49,1)) + .026010*i(p+vec2(50,1)) + .004745*i(p+vec2(51,1)) - .038317*i(p+vec2(52,1)) + .002854*i(p+vec2(48,2)) - .036712*i(p+vec2(49,2)) + .026922*i(p+vec2(50,2)) - .005803*i(p+vec2(51,2)) - .110613*i(p+vec2(52,2)) - .035845*i(p+vec2(48,3)) + .022496*i(p+vec2(49,3)) - .012490*i(p+vec2(50,3)) - .087088*i(p+vec2(51,3)) - .068759*i(p+vec2(52,3)) - .026644*i(p+vec2(48,4)) - .063738*i(p+vec2(49,4)) - .021046*i(p+vec2(50,4)) - .010263*i(p+vec2(51,4)) - .051859*i(p+vec2(52,4)) ;\n            x +=  .110702*i(p+vec2(60,0)) + .117118*i(p+vec2(61,0)) + .138851*i(p+vec2(62,0)) + .014485*i(p+vec2(63,0)) - .029469*i(p+vec2(64,0)) + .102581*i(p+vec2(60,1)) + .112743*i(p+vec2(61,1)) + .125491*i(p+vec2(62,1)) + .069034*i(p+vec2(63,1)) + .028476*i(p+vec2(64,1)) + .019210*i(p+vec2(60,2)) - .007038*i(p+vec2(61,2)) - .054246*i(p+vec2(62,2)) - .028243*i(p+vec2(63,2)) - .069148*i(p+vec2(64,2)) + .042524*i(p+vec2(60,3)) - .052357*i(p+vec2(61,3)) - .005603*i(p+vec2(62,3)) - .055190*i(p+vec2(63,3)) - .034142*i(p+vec2(64,3)) - .022592*i(p+vec2(60,4)) + .026197*i(p+vec2(61,4)) + .019640*i(p+vec2(62,4)) - .063740*i(p+vec2(63,4)) + .017314*i(p+vec2(64,4)) ;\n            x +=  .003538*i(p+vec2(72,0)) - .035311*i(p+vec2(73,0)) - .035084*i(p+vec2(74,0)) - .022011*i(p+vec2(75,0)) - .042928*i(p+vec2(76,0)) - .008708*i(p+vec2(72,1)) + .019993*i(p+vec2(73,1)) - .008411*i(p+vec2(74,1)) - .053142*i(p+vec2(75,1)) - .093495*i(p+vec2(76,1)) - .087310*i(p+vec2(72,2)) - .042563*i(p+vec2(73,2)) - .083762*i(p+vec2(74,2)) - .084108*i(p+vec2(75,2)) - .095313*i(p+vec2(76,2)) - .109650*i(p+vec2(72,3)) - .156403*i(p+vec2(73,3)) - .100507*i(p+vec2(74,3)) - .030987*i(p+vec2(75,3)) - .052391*i(p+vec2(76,3)) - .115120*i(p+vec2(72,4)) - .115170*i(p+vec2(73,4)) + .005497*i(p+vec2(74,4)) + .009972*i(p+vec2(75,4)) + .064793*i(p+vec2(76,4)) ;\n            x += -.029818*i(p+vec2(84,0)) - .073513*i(p+vec2(85,0)) - .021365*i(p+vec2(86,0)) + .038191*i(p+vec2(87,0)) - .053594*i(p+vec2(88,0)) + .001866*i(p+vec2(84,1)) - .106707*i(p+vec2(85,1)) - .135535*i(p+vec2(86,1)) - .090814*i(p+vec2(87,1)) + .005511*i(p+vec2(88,1)) - .072168*i(p+vec2(84,2)) - .092473*i(p+vec2(85,2)) + .030897*i(p+vec2(86,2)) + .044974*i(p+vec2(87,2)) + .017658*i(p+vec2(88,2)) + .098985*i(p+vec2(84,3)) + .078218*i(p+vec2(85,3)) + .025579*i(p+vec2(86,3)) + .027096*i(p+vec2(87,3)) + .056002*i(p+vec2(88,3)) + .109690*i(p+vec2(84,4)) + .114611*i(p+vec2(85,4)) + .064988*i(p+vec2(86,4)) + .029201*i(p+vec2(87,4)) - .029181*i(p+vec2(88,4)) + .044618;\n        }\n        else if (fmap == 3) {\n            x = -.065041*i(p+vec2(0,0)) - .044827*i(p+vec2(1,0)) - .045408*i(p+vec2(2,0)) - .027479*i(p+vec2(3,0)) - .016581*i(p+vec2(4,0)) - .113267*i(p+vec2(0,1)) - .034325*i(p+vec2(1,1)) - .067802*i(p+vec2(2,1)) - .019938*i(p+vec2(3,1)) - .008703*i(p+vec2(4,1)) - .003708*i(p+vec2(0,2)) + .025421*i(p+vec2(1,2)) + .018985*i(p+vec2(2,2)) + .013058*i(p+vec2(3,2)) - .022186*i(p+vec2(4,2)) + .074049*i(p+vec2(0,3)) + .122886*i(p+vec2(1,3)) + .084369*i(p+vec2(2,3)) + .107888*i(p+vec2(3,3)) + .004665*i(p+vec2(4,3)) + .177412*i(p+vec2(0,4)) + .168101*i(p+vec2(1,4)) + .157727*i(p+vec2(2,4)) + .035967*i(p+vec2(3,4)) - .169895*i(p+vec2(4,4)) ;\n            x +=  .094543*i(p+vec2(12,0)) + .121074*i(p+vec2(13,0)) + .071699*i(p+vec2(14,0)) + .048749*i(p+vec2(15,0)) + .077483*i(p+vec2(16,0)) + .050495*i(p+vec2(12,1)) + .062031*i(p+vec2(13,1)) + .092835*i(p+vec2(14,1)) + .042366*i(p+vec2(15,1)) - .018972*i(p+vec2(16,1)) + .031505*i(p+vec2(12,2)) + .065801*i(p+vec2(13,2)) + .005604*i(p+vec2(14,2)) - .043289*i(p+vec2(15,2)) - .050872*i(p+vec2(16,2)) - .012502*i(p+vec2(12,3)) + .039254*i(p+vec2(13,3)) + .035616*i(p+vec2(14,3)) - .093267*i(p+vec2(15,3)) - .114860*i(p+vec2(16,3)) + .109167*i(p+vec2(12,4)) + .041145*i(p+vec2(13,4)) + .025472*i(p+vec2(14,4)) - .034760*i(p+vec2(15,4)) - .068790*i(p+vec2(16,4)) ;\n            x +=  .074297*i(p+vec2(24,0)) + .107164*i(p+vec2(25,0)) + .038573*i(p+vec2(26,0)) + .018497*i(p+vec2(27,0)) - .066989*i(p+vec2(28,0)) + .045576*i(p+vec2(24,1)) + .043657*i(p+vec2(25,1)) + .064087*i(p+vec2(26,1)) + .037835*i(p+vec2(27,1)) - .016352*i(p+vec2(28,1)) - .004218*i(p+vec2(24,2)) + .015408*i(p+vec2(25,2)) + .042173*i(p+vec2(26,2)) + .078353*i(p+vec2(27,2)) + .014127*i(p+vec2(28,2)) + .021499*i(p+vec2(24,3)) - .003591*i(p+vec2(25,3)) + .021562*i(p+vec2(26,3)) + .030094*i(p+vec2(27,3)) - .077727*i(p+vec2(28,3)) - .043636*i(p+vec2(24,4)) - .038942*i(p+vec2(25,4)) + .041748*i(p+vec2(26,4)) + .021877*i(p+vec2(27,4)) - .089420*i(p+vec2(28,4)) ;\n            x += -.025842*i(p+vec2(36,0)) - .024335*i(p+vec2(37,0)) - .034287*i(p+vec2(38,0)) - .035360*i(p+vec2(39,0)) + .001802*i(p+vec2(40,0)) + .018795*i(p+vec2(36,1)) + .002706*i(p+vec2(37,1)) - .062916*i(p+vec2(38,1)) - .121407*i(p+vec2(39,1)) - .060586*i(p+vec2(40,1)) - .051345*i(p+vec2(36,2)) - .001345*i(p+vec2(37,2)) - .131490*i(p+vec2(38,2)) - .040997*i(p+vec2(39,2)) - .003273*i(p+vec2(40,2)) - .048635*i(p+vec2(36,3)) + .047884*i(p+vec2(37,3)) + .027771*i(p+vec2(38,3)) + .022292*i(p+vec2(39,3)) + .015396*i(p+vec2(40,3)) - .082129*i(p+vec2(36,4)) + .025646*i(p+vec2(37,4)) + .064377*i(p+vec2(38,4)) + .022169*i(p+vec2(39,4)) + .098010*i(p+vec2(40,4)) ;\n            x +=  .023513*i(p+vec2(48,0)) + .081035*i(p+vec2(49,0)) + .050733*i(p+vec2(50,0)) + .038003*i(p+vec2(51,0)) - .023454*i(p+vec2(52,0)) + .021369*i(p+vec2(48,1)) + .075130*i(p+vec2(49,1)) + .023919*i(p+vec2(50,1)) + .010114*i(p+vec2(51,1)) - .046117*i(p+vec2(52,1)) + .038494*i(p+vec2(48,2)) + .071608*i(p+vec2(49,2)) + .054695*i(p+vec2(50,2)) + .017425*i(p+vec2(51,2)) - .019284*i(p+vec2(52,2)) - .024073*i(p+vec2(48,3)) - .025879*i(p+vec2(49,3)) - .032753*i(p+vec2(50,3)) - .007604*i(p+vec2(51,3)) - .005919*i(p+vec2(52,3)) - .022793*i(p+vec2(48,4)) - .027887*i(p+vec2(49,4)) + .023217*i(p+vec2(50,4)) + .056594*i(p+vec2(51,4)) - .005012*i(p+vec2(52,4)) ;\n            x +=  .145032*i(p+vec2(60,0)) + .115085*i(p+vec2(61,0)) + .068654*i(p+vec2(62,0)) - .015920*i(p+vec2(63,0)) + .008778*i(p+vec2(64,0)) + .137004*i(p+vec2(60,1)) + .114580*i(p+vec2(61,1)) + .112755*i(p+vec2(62,1)) - .015727*i(p+vec2(63,1)) - .019876*i(p+vec2(64,1)) + .114773*i(p+vec2(60,2)) + .001262*i(p+vec2(61,2)) - .060381*i(p+vec2(62,2)) - .203856*i(p+vec2(63,2)) - .173244*i(p+vec2(64,2)) - .027702*i(p+vec2(60,3)) - .130193*i(p+vec2(61,3)) - .220279*i(p+vec2(62,3)) - .297398*i(p+vec2(63,3)) - .198849*i(p+vec2(64,3)) + .036194*i(p+vec2(60,4)) - .086494*i(p+vec2(61,4)) - .231162*i(p+vec2(62,4)) - .261053*i(p+vec2(63,4)) - .139979*i(p+vec2(64,4)) ;\n            x +=  .051161*i(p+vec2(72,0)) + .028729*i(p+vec2(73,0)) + .026783*i(p+vec2(74,0)) + .109775*i(p+vec2(75,0)) + .048805*i(p+vec2(76,0)) - .032467*i(p+vec2(72,1)) - .027144*i(p+vec2(73,1)) + .034998*i(p+vec2(74,1)) + .090104*i(p+vec2(75,1)) + .017593*i(p+vec2(76,1)) - .070456*i(p+vec2(72,2)) - .112503*i(p+vec2(73,2)) - .021751*i(p+vec2(74,2)) + .052960*i(p+vec2(75,2)) - .030093*i(p+vec2(76,2)) + .041898*i(p+vec2(72,3)) - .083327*i(p+vec2(73,3)) - .084202*i(p+vec2(74,3)) - .028898*i(p+vec2(75,3)) - .085812*i(p+vec2(76,3)) + .006779*i(p+vec2(72,4)) - .005748*i(p+vec2(73,4)) + .023357*i(p+vec2(74,4)) - .028606*i(p+vec2(75,4)) - .105384*i(p+vec2(76,4)) ;\n            x +=  .077756*i(p+vec2(84,0)) - .054394*i(p+vec2(85,0)) - .055692*i(p+vec2(86,0)) - .035044*i(p+vec2(87,0)) - .019320*i(p+vec2(88,0)) + .055786*i(p+vec2(84,1)) + .011287*i(p+vec2(85,1)) - .020608*i(p+vec2(86,1)) - .057911*i(p+vec2(87,1)) - .028529*i(p+vec2(88,1)) + .066594*i(p+vec2(84,2)) + .144801*i(p+vec2(85,2)) + .038596*i(p+vec2(86,2)) + .021778*i(p+vec2(87,2)) + .012389*i(p+vec2(88,2)) + .015986*i(p+vec2(84,3)) + .062553*i(p+vec2(85,3)) + .152408*i(p+vec2(86,3)) + .034392*i(p+vec2(87,3)) + .143995*i(p+vec2(88,3)) - .057195*i(p+vec2(84,4)) - .097240*i(p+vec2(85,4)) + .051983*i(p+vec2(86,4)) + .045353*i(p+vec2(87,4)) + .025535*i(p+vec2(88,4)) + .005539;\n        }\n        else if (fmap == 4) {\n            x = -.151024*i(p+vec2(0,0)) - .085353*i(p+vec2(1,0)) - .020371*i(p+vec2(2,0)) + .038760*i(p+vec2(3,0)) - .017698*i(p+vec2(4,0)) - .146046*i(p+vec2(0,1)) - .083711*i(p+vec2(1,1)) - .046654*i(p+vec2(2,1)) + .045819*i(p+vec2(3,1)) + .086094*i(p+vec2(4,1)) - .099861*i(p+vec2(0,2)) - .173572*i(p+vec2(1,2)) - .204014*i(p+vec2(2,2)) - .150274*i(p+vec2(3,2)) - .153582*i(p+vec2(4,2)) - .139883*i(p+vec2(0,3)) - .050268*i(p+vec2(1,3)) + .151440*i(p+vec2(2,3)) + .127305*i(p+vec2(3,3)) - .059448*i(p+vec2(4,3)) - .017022*i(p+vec2(0,4)) + .141502*i(p+vec2(1,4)) + .131710*i(p+vec2(2,4)) + .131854*i(p+vec2(3,4)) + .132665*i(p+vec2(4,4)) ;\n            x +=  .028596*i(p+vec2(12,0)) + .001047*i(p+vec2(13,0)) - .036430*i(p+vec2(14,0)) - .042759*i(p+vec2(15,0)) - .047757*i(p+vec2(16,0)) + .008165*i(p+vec2(12,1)) - .015975*i(p+vec2(13,1)) - .116590*i(p+vec2(14,1)) - .035810*i(p+vec2(15,1)) - .025485*i(p+vec2(16,1)) - .116234*i(p+vec2(12,2)) - .083054*i(p+vec2(13,2)) - .144707*i(p+vec2(14,2)) - .098301*i(p+vec2(15,2)) - .066349*i(p+vec2(16,2)) - .088110*i(p+vec2(12,3)) - .064091*i(p+vec2(13,3)) - .054771*i(p+vec2(14,3)) + .074695*i(p+vec2(15,3)) + .067527*i(p+vec2(16,3)) - .006192*i(p+vec2(12,4)) + .032544*i(p+vec2(13,4)) + .078078*i(p+vec2(14,4)) + .200340*i(p+vec2(15,4)) + .234686*i(p+vec2(16,4)) ;\n            x +=  .113024*i(p+vec2(24,0)) + .110267*i(p+vec2(25,0)) + .063846*i(p+vec2(26,0)) + .049881*i(p+vec2(27,0)) + .009695*i(p+vec2(28,0)) + .100619*i(p+vec2(24,1)) + .063978*i(p+vec2(25,1)) + .018875*i(p+vec2(26,1)) + .029239*i(p+vec2(27,1)) + .006424*i(p+vec2(28,1)) - .139673*i(p+vec2(24,2)) - .104241*i(p+vec2(25,2)) - .064975*i(p+vec2(26,2)) - .035013*i(p+vec2(27,2)) - .037164*i(p+vec2(28,2)) - .241233*i(p+vec2(24,3)) - .229522*i(p+vec2(25,3)) - .180526*i(p+vec2(26,3)) - .114720*i(p+vec2(27,3)) - .077498*i(p+vec2(28,3)) - .180585*i(p+vec2(24,4)) - .059412*i(p+vec2(25,4)) - .062612*i(p+vec2(26,4)) + .002683*i(p+vec2(27,4)) + .002933*i(p+vec2(28,4)) ;\n            x +=  .025844*i(p+vec2(36,0)) - .008108*i(p+vec2(37,0)) + .030224*i(p+vec2(38,0)) + .084082*i(p+vec2(39,0)) - .035616*i(p+vec2(40,0)) + .042340*i(p+vec2(36,1)) - .088508*i(p+vec2(37,1)) - .012998*i(p+vec2(38,1)) + .068494*i(p+vec2(39,1)) + .095155*i(p+vec2(40,1)) + .089146*i(p+vec2(36,2)) + .034854*i(p+vec2(37,2)) + .112012*i(p+vec2(38,2)) + .107305*i(p+vec2(39,2)) + .146836*i(p+vec2(40,2)) + .077914*i(p+vec2(36,3)) + .031680*i(p+vec2(37,3)) + .100960*i(p+vec2(38,3)) + .038912*i(p+vec2(39,3)) - .046642*i(p+vec2(40,3)) - .052792*i(p+vec2(36,4)) - .119617*i(p+vec2(37,4)) + .066024*i(p+vec2(38,4)) + .048530*i(p+vec2(39,4)) - .066909*i(p+vec2(40,4)) ;\n            x +=  .132893*i(p+vec2(48,0)) + .075638*i(p+vec2(49,0)) - .040484*i(p+vec2(50,0)) - .002135*i(p+vec2(51,0)) - .011319*i(p+vec2(52,0)) + .073798*i(p+vec2(48,1)) - .033863*i(p+vec2(49,1)) + .013071*i(p+vec2(50,1)) - .068327*i(p+vec2(51,1)) - .034962*i(p+vec2(52,1)) - .018041*i(p+vec2(48,2)) + .051831*i(p+vec2(49,2)) - .003209*i(p+vec2(50,2)) + .045083*i(p+vec2(51,2)) - .023776*i(p+vec2(52,2)) - .010383*i(p+vec2(48,3)) - .048997*i(p+vec2(49,3)) - .023641*i(p+vec2(50,3)) - .003945*i(p+vec2(51,3)) + .008028*i(p+vec2(52,3)) - .041111*i(p+vec2(48,4)) + .000938*i(p+vec2(49,4)) - .051027*i(p+vec2(50,4)) - .017615*i(p+vec2(51,4)) + .055404*i(p+vec2(52,4)) ;\n            x += -.004129*i(p+vec2(60,0)) - .031338*i(p+vec2(61,0)) - .051943*i(p+vec2(62,0)) - .041951*i(p+vec2(63,0)) - .032597*i(p+vec2(64,0)) - .048305*i(p+vec2(60,1)) - .066592*i(p+vec2(61,1)) - .038255*i(p+vec2(62,1)) - .064113*i(p+vec2(63,1)) + .055801*i(p+vec2(64,1)) - .074688*i(p+vec2(60,2)) - .049016*i(p+vec2(61,2)) + .044922*i(p+vec2(62,2)) + .068887*i(p+vec2(63,2)) + .146106*i(p+vec2(64,2)) + .030208*i(p+vec2(60,3)) - .076818*i(p+vec2(61,3)) + .027783*i(p+vec2(62,3)) + .140470*i(p+vec2(63,3)) + .144964*i(p+vec2(64,3)) + .049108*i(p+vec2(60,4)) + .020163*i(p+vec2(61,4)) + .121420*i(p+vec2(62,4)) + .205076*i(p+vec2(63,4)) + .226896*i(p+vec2(64,4)) ;\n            x +=  .091393*i(p+vec2(72,0)) + .126330*i(p+vec2(73,0)) + .095413*i(p+vec2(74,0)) - .014538*i(p+vec2(75,0)) - .030099*i(p+vec2(76,0)) + .013168*i(p+vec2(72,1)) + .041257*i(p+vec2(73,1)) + .029750*i(p+vec2(74,1)) + .073070*i(p+vec2(75,1)) - .086262*i(p+vec2(76,1)) - .078126*i(p+vec2(72,2)) - .132817*i(p+vec2(73,2)) - .086798*i(p+vec2(74,2)) - .036953*i(p+vec2(75,2)) - .040775*i(p+vec2(76,2)) - .191780*i(p+vec2(72,3)) - .112947*i(p+vec2(73,3)) - .109343*i(p+vec2(74,3)) - .150807*i(p+vec2(75,3)) - .148036*i(p+vec2(76,3)) - .017872*i(p+vec2(72,4)) - .029193*i(p+vec2(73,4)) - .024341*i(p+vec2(74,4)) + .008525*i(p+vec2(75,4)) - .054663*i(p+vec2(76,4)) ;\n            x += -.080706*i(p+vec2(84,0)) - .014936*i(p+vec2(85,0)) + .009476*i(p+vec2(86,0)) + .022717*i(p+vec2(87,0)) + .089186*i(p+vec2(88,0)) - .055918*i(p+vec2(84,1)) + .047336*i(p+vec2(85,1)) + .101627*i(p+vec2(86,1)) + .111755*i(p+vec2(87,1)) + .058078*i(p+vec2(88,1)) + .085592*i(p+vec2(84,2)) + .116362*i(p+vec2(85,2)) + .077001*i(p+vec2(86,2)) + .119588*i(p+vec2(87,2)) + .047873*i(p+vec2(88,2)) + .111052*i(p+vec2(84,3)) + .068810*i(p+vec2(85,3)) + .062873*i(p+vec2(86,3)) + .089996*i(p+vec2(87,3)) + .017395*i(p+vec2(88,3)) - .049681*i(p+vec2(84,4)) - .073608*i(p+vec2(85,4)) - .052349*i(p+vec2(86,4)) - .055716*i(p+vec2(87,4)) - .013794*i(p+vec2(88,4)) - .083093;\n        }\n        \n        //x = max(0., x);\n        col = vec3(x);\n    }\n    \n    fragColor = vec4(col, 1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R              (iResolution.xy)\n#define iAspect        (iResolution.x/iResolution.y)\n\n// Input image dimension (28*28 = 784 input nodes)\n#define input_res      28.\n\n// Number of feature maps in the first layer\n#define feature_maps_1 8.\n\n// Number of feature maps in the second layer\n#define feature_maps_2 5.\n\n// Number of output nodes (10 digits: 0-9)\n#define num_classes    10.\n\n// Mean and variance that was used to normalize the input dataset\n#define mean           0.1307\n#define std            0.3081\n\n// Quick hack to display text easily\n#define print float d = 0.; (0\n#define _end  ); return d;\n#define _     ); u.x -= .4; d += char(u, \n#define _sp   ); u.x -= .4; (0\n#define _dig(i) _ vec2(i,12)\n#define _dd _ vec2(10, 12)\n#define _C _ vec2(3, 11)\n#define _F _ vec2(6,11)\n#define _H _ vec2(8,11)\n#define _I _ vec2(9,11)\n#define _L _ vec2(12,11)\n#define _M _ vec2(13,11)\n#define _O _ vec2(15,11)\n#define _P _ vec2(0,10)\n#define _a _ vec2(1,9)\n#define _c _ vec2(3,9)\n#define _d _ vec2(4,9)\n#define _e _ vec2(5,9)\n#define _f _ vec2(6,9)\n#define _g _ vec2(7,9)\n#define _i _ vec2(9)\n#define _l _ vec2(12,9)\n#define _n _ vec2(14,9)\n#define _o _ vec2(15,9)\n#define _p _ vec2(0,8)\n#define _r _ vec2(2,8)\n#define _s _ vec2(3,8)\n#define _t _ vec2(4,8)\n#define _u _ vec2(5,8)\n#define _v _ vec2(6,8)\n#define _x _ vec2(8)\n#define _y _ vec2(9,8)", "buffer_d_code": "/* This buffer acts as the fully connected layer and is responsible\n   for the output node calculations (predictions)\n*/\n\nfloat i(int x, int y) {\n    return texelFetch(iChannel0, ivec2(x,y), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord / R;\n    vec3 col = vec3(0);\n\n    ivec2 F = ivec2(fragCoord - .5);\n    \n    if (F.x < int(num_classes)  && F.y == 0) {        \n        float x;\n        \n        // Each if/else correspond to an output node (classes predictions)\n        if (F.x == 0) x = -.075143*i(0,0) - .056622*i(1,0) - .121313*i(2,0) + .038140*i(3,0) + .107850*i(0,1) + .188001*i(1,1) + .055559*i(2,1) - .006876*i(3,1) + .001238*i(0,2) + .081469*i(1,2) + .061499*i(2,2) - .014917*i(3,2) + .090366*i(0,3) - .058191*i(1,3) + .039274*i(2,3) - .097306*i(3,3) + .152312*i(4,0) - .003635*i(5,0) + .084143*i(6,0) + .125680*i(7,0) + .092808*i(4,1) - .042792*i(5,1) - .217296*i(6,1) - .008191*i(7,1) - .016148*i(4,2) + .040513*i(5,2) - .097174*i(6,2) - .288848*i(7,2) - .039060*i(4,3) + .055375*i(5,3) + .026479*i(6,3) - .100895*i(7,3) - .080106*i(8,0) + .108912*i(9,0) + .155070*i(10,0) + .070415*i(11,0) - .210549*i(8,1) - .061629*i(9,1) + .051988*i(10,1) - .081011*i(11,1) - .035969*i(8,2) - .020141*i(9,2) - .061554*i(10,2) + .046853*i(11,2) - .003657*i(8,3) + .052620*i(9,3) + .024415*i(10,3) + .029756*i(11,3) + .145766*i(12,0) - .123348*i(13,0) - .211711*i(14,0) - .090868*i(15,0) + .052405*i(12,1) - .168870*i(13,1) + .045629*i(14,1) + .150798*i(15,1) - .015225*i(12,2) + .010330*i(13,2) + .044918*i(14,2) + .157409*i(15,2) - .025917*i(12,3) + .003875*i(13,3) + .003508*i(14,3) + .108845*i(15,3) - .289601*i(16,0) + .004226*i(17,0) - .055828*i(18,0) - .068674*i(19,0) - .291888*i(16,1) + .052395*i(17,1) + .014539*i(18,1) - .073194*i(19,1) - .017768*i(16,2) - .024752*i(17,2) + .010479*i(18,2) - .106618*i(19,2) + .088511*i(16,3) + .022097*i(17,3) + .028473*i(18,3) + .014830*i(19,3) + .053830;\n        else if (F.x == 1) x =  .118176*i(0,0) + .307418*i(1,0) + .035010*i(2,0) - .127493*i(3,0) + .127779*i(0,1) + .149029*i(1,1) + .094610*i(2,1) - .073976*i(3,1) + .010956*i(0,2) + .078971*i(1,2) + .082320*i(2,2) + .008612*i(3,2) + .076737*i(0,3) + .168552*i(1,3) + .186871*i(2,3) - .035339*i(3,3) - .015820*i(4,0) + .036516*i(5,0) - .146051*i(6,0) - .180930*i(7,0) - .170593*i(4,1) - .077640*i(5,1) + .025629*i(6,1) - .123664*i(7,1) - .165897*i(4,2) - .227003*i(5,2) - .072458*i(6,2) - .017666*i(7,2) - .102989*i(4,3) - .030075*i(5,3) - .088207*i(6,3) + .055515*i(7,3) + .137357*i(8,0) + .228489*i(9,0) + .022315*i(10,0) + .254441*i(11,0) - .020429*i(8,1) + .017245*i(9,1) - .087207*i(10,1) + .008994*i(11,1) + .023044*i(8,2) + .044528*i(9,2) + .069337*i(10,2) - .039198*i(11,2) + .076846*i(8,3) - .057162*i(9,3) - .143618*i(10,3) - .169474*i(11,3) - .177619*i(12,0) + .025151*i(13,0) + .033428*i(14,0) - .101687*i(15,0) - .147556*i(12,1) + .020280*i(13,1) - .051744*i(14,1) - .066299*i(15,1) + .011121*i(12,2) + .083689*i(13,2) - .029114*i(14,2) - .205382*i(15,2) + .036833*i(12,3) + .025825*i(13,3) - .043088*i(14,3) - .131485*i(15,3) + .181081*i(16,0) - .172405*i(17,0) - .000713*i(18,0) + .102880*i(19,0) + .141426*i(16,1) + .051331*i(17,1) - .106324*i(18,1) + .047509*i(19,1) + .093582*i(16,2) - .000411*i(17,2) - .079680*i(18,2) - .056620*i(19,2) - .060069*i(16,3) + .054039*i(17,3) - .072068*i(18,3) - .033597*i(19,3) + .074264;\n        else if (F.x == 2) x =  .075104*i(0,0) - .062261*i(1,0) - .243282*i(2,0) - .211665*i(3,0) + .067593*i(0,1) + .049483*i(1,1) + .006165*i(2,1) - .104614*i(3,1) - .070173*i(0,2) + .056063*i(1,2) + .041839*i(2,2) + .022482*i(3,2) - .044319*i(0,3) - .037660*i(1,3) + .098334*i(2,3) + .088488*i(3,3) + .187212*i(4,0) + .098346*i(5,0) + .135175*i(6,0) + .002778*i(7,0) - .002911*i(4,1) + .052746*i(5,1) + .057234*i(6,1) + .060808*i(7,1) - .081446*i(4,2) - .102199*i(5,2) - .116797*i(6,2) + .039287*i(7,2) + .031106*i(4,3) + .081425*i(5,3) - .057470*i(6,3) - .228619*i(7,3) - .065109*i(8,0) - .080685*i(9,0) + .095244*i(10,0) + .107105*i(11,0) + .127165*i(8,1) + .022375*i(9,1) + .155364*i(10,1) + .155487*i(11,1) + .190379*i(8,2) + .096634*i(9,2) - .021882*i(10,2) + .098712*i(11,2) + .026928*i(8,3) + .034139*i(9,3) + .019663*i(10,3) - .052137*i(11,3) - .153903*i(12,0) - .100958*i(13,0) + .056287*i(14,0) - .086529*i(15,0) - .207472*i(12,1) - .086102*i(13,1) + .039555*i(14,1) - .094216*i(15,1) - .018086*i(12,2) + .023409*i(13,2) + .064830*i(14,2) + .066338*i(15,2) + .020448*i(12,3) + .145752*i(13,3) + .130498*i(14,3) + .108338*i(15,3) + .000179*i(16,0) - .044342*i(17,0) + .028753*i(18,0) + .132895*i(19,0) + .120966*i(16,1) + .090906*i(17,1) - .047338*i(18,1) - .036944*i(19,1) + .201408*i(16,2) + .132772*i(17,2) + .001545*i(18,2) - .074028*i(19,2) + .065345*i(16,3) + .026543*i(17,3) + .014589*i(18,3) + .012444*i(19,3) + .001615;\n        else if (F.x == 3) x = -.090207*i(0,0) - .089532*i(1,0) + .088258*i(2,0) + .058080*i(3,0) + .064625*i(0,1) - .119222*i(1,1) + .018076*i(2,1) + .064042*i(3,1) - .006809*i(0,2) - .155456*i(1,2) - .149699*i(2,2) - .041605*i(3,2) - .170260*i(0,3) - .177147*i(1,3) + .018428*i(2,3) + .047750*i(3,3) - .046373*i(4,0) - .095485*i(5,0) + .008783*i(6,0) + .175543*i(7,0) - .130315*i(4,1) - .002828*i(5,1) + .037634*i(6,1) - .033963*i(7,1) - .169322*i(4,2) - .005636*i(5,2) + .071235*i(6,2) + .205786*i(7,2) - .126502*i(4,3) - .006692*i(5,3) + .101685*i(6,3) + .008342*i(7,3) + .274166*i(8,0) + .024771*i(9,0) + .013405*i(10,0) + .056795*i(11,0) + .131263*i(8,1) - .104002*i(9,1) - .045315*i(10,1) - .075801*i(11,1) + .045826*i(8,2) - .047754*i(9,2) - .018996*i(10,2) + .083615*i(11,2) + .138966*i(8,3) + .088836*i(9,3) + .012930*i(10,3) + .001248*i(11,3) - .091140*i(12,0) + .022401*i(13,0) + .068219*i(14,0) + .065187*i(15,0) - .133591*i(12,1) - .033201*i(13,1) + .030706*i(14,1) + .058613*i(15,1) - .068666*i(12,2) + .005972*i(13,2) + .027504*i(14,2) - .062614*i(15,2) + .031467*i(12,3) + .142602*i(13,3) + .144359*i(14,3) + .099213*i(15,3) + .154107*i(16,0) + .130326*i(17,0) + .009151*i(18,0) - .029851*i(19,0) + .053593*i(16,1) + .070038*i(17,1) - .052174*i(18,1) + .128651*i(19,1) + .163541*i(16,2) + .085602*i(17,2) - .060960*i(18,2) - .008063*i(19,2) - .071249*i(16,3) - .036413*i(17,3) - .015864*i(18,3) + .027310*i(19,3) - .104617;\n        else if (F.x == 4) x =  .136695*i(0,0) + .182818*i(1,0) + .088052*i(2,0) - .039925*i(3,0) - .075844*i(0,1) - .063367*i(1,1) - .108014*i(2,1) - .018086*i(3,1) - .016628*i(0,2) + .062744*i(1,2) - .095771*i(2,2) + .023198*i(3,2) + .095606*i(0,3) + .207663*i(1,3) + .257984*i(2,3) + .050648*i(3,3) - .120700*i(4,0) - .035294*i(5,0) - .000187*i(6,0) - .263116*i(7,0) + .238731*i(4,1) - .057893*i(5,1) - .049301*i(6,1) + .094419*i(7,1) + .145201*i(4,2) + .049918*i(5,2) + .015038*i(6,2) + .188535*i(7,2) + .033250*i(4,3) + .025587*i(5,3) + .010658*i(6,3) + .094547*i(7,3) - .208576*i(8,0) - .017720*i(9,0) + .027217*i(10,0) - .136156*i(11,0) + .057621*i(8,1) + .095122*i(9,1) + .049686*i(10,1) - .050623*i(11,1) + .057528*i(8,2) + .102234*i(9,2) - .040277*i(10,2) - .056215*i(11,2) - .068852*i(8,3) - .109990*i(9,3) - .117830*i(10,3) - .144675*i(11,3) + .127953*i(12,0) + .057657*i(13,0) + .086862*i(14,0) - .095754*i(15,0) + .144894*i(12,1) + .062875*i(13,1) + .099320*i(14,1) - .072185*i(15,1) + .162736*i(12,2) - .058694*i(13,2) - .002515*i(14,2) - .135430*i(15,2) + .072161*i(12,3) - .046754*i(13,3) - .110878*i(14,3) - .080166*i(15,3) + .154885*i(16,0) + .071826*i(17,0) - .033267*i(18,0) + .041170*i(19,0) - .037779*i(16,1) + .082510*i(17,1) - .084086*i(18,1) - .254560*i(19,1) - .260250*i(16,2) - .118318*i(17,2) - .200516*i(18,2) - .217559*i(19,2) + .004250*i(16,3) + .052013*i(17,3) - .009852*i(18,3) - .003096*i(19,3) + .031150;\n        else if (F.x == 5) x = -.178578*i(0,0) - .033715*i(1,0) + .062495*i(2,0) + .123911*i(3,0) - .079341*i(0,1) + .031328*i(1,1) + .149985*i(2,1) + .108790*i(3,1) + .038392*i(0,2) + .003860*i(1,2) - .044916*i(2,2) - .071479*i(3,2) + .076275*i(0,3) - .004897*i(1,3) - .237388*i(2,3) - .230086*i(3,3) - .031948*i(4,0) - .050418*i(5,0) - .017694*i(6,0) + .111659*i(7,0) - .039834*i(4,1) - .025885*i(5,1) - .176076*i(6,1) - .183601*i(7,1) + .027238*i(4,2) - .043208*i(5,2) - .044587*i(6,2) - .167072*i(7,2) + .077036*i(4,3) + .070081*i(5,3) + .041857*i(6,3) + .004037*i(7,3) + .214419*i(8,0) + .019067*i(9,0) + .095564*i(10,0) + .148249*i(11,0) + .134796*i(8,1) - .039023*i(9,1) + .041526*i(10,1) + .005519*i(11,1) - .112477*i(8,2) + .055217*i(9,2) + .067744*i(10,2) + .044419*i(11,2) - .122010*i(8,3) + .016899*i(9,3) + .044329*i(10,3) + .063331*i(11,3) - .001170*i(12,0) - .028405*i(13,0) + .030677*i(14,0) + .049971*i(15,0) + .042898*i(12,1) - .076075*i(13,1) + .022667*i(14,1) + .100927*i(15,1) + .034227*i(12,2) - .115852*i(13,2) - .045271*i(14,2) - .131120*i(15,2) - .008138*i(12,3) - .096292*i(13,3) - .225341*i(14,3) - .307498*i(15,3) + .201879*i(16,0) + .121726*i(17,0) + .031848*i(18,0) + .067965*i(19,0) + .023252*i(16,1) + .037581*i(17,1) + .023188*i(18,1) + .232835*i(19,1) - .031391*i(16,2) + .004997*i(17,2) + .187920*i(18,2) + .183176*i(19,2) - .064285*i(16,3) - .002638*i(17,3) + .052543*i(18,3) - .082024*i(19,3) - .017540;\n        else if (F.x == 6) x = -.057050*i(0,0) - .134399*i(1,0) - .122724*i(2,0) + .064394*i(3,0) + .152000*i(0,1) + .019556*i(1,1) - .031776*i(2,1) + .052156*i(3,1) + .120772*i(0,2) + .019357*i(1,2) - .115102*i(2,2) - .147379*i(3,2) + .144365*i(0,3) + .184400*i(1,3) + .120577*i(2,3) - .019055*i(3,3) + .079528*i(4,0) + .057769*i(5,0) + .057480*i(6,0) + .174716*i(7,0) + .053453*i(4,1) + .056713*i(5,1) + .046551*i(6,1) + .032610*i(7,1) - .024766*i(4,2) + .009873*i(5,2) + .027833*i(6,2) - .121777*i(7,2) + .013510*i(4,3) + .102499*i(5,3) + .162073*i(6,3) + .072631*i(7,3) - .205622*i(8,0) + .027753*i(9,0) + .091037*i(10,0) + .137706*i(11,0) - .183732*i(8,1) - .047233*i(9,1) + .046830*i(10,1) + .028960*i(11,1) - .140672*i(8,2) - .056614*i(9,2) + .043881*i(10,2) + .193260*i(11,2) - .102161*i(8,3) - .208817*i(9,3) - .029989*i(10,3) - .065135*i(11,3) + .217860*i(12,0) - .006298*i(13,0) - .055235*i(14,0) - .113672*i(15,0) + .057800*i(12,1) - .220906*i(13,1) - .069267*i(14,1) + .140712*i(15,1) - .056603*i(12,2) - .370280*i(13,2) - .220436*i(14,2) + .038400*i(15,2) + .030640*i(12,3) - .147402*i(13,3) - .168191*i(14,3) - .072018*i(15,3) - .313547*i(16,0) - .158284*i(17,0) - .113741*i(18,0) - .166187*i(19,0) - .227553*i(16,1) - .054454*i(17,1) - .016922*i(18,1) + .154416*i(19,1) - .079466*i(16,2) + .002345*i(17,2) + .173209*i(18,2) + .188420*i(19,2) - .089767*i(16,3) - .142408*i(17,3) + .083195*i(18,3) + .138831*i(19,3) + .062103;\n        else if (F.x == 7) x =  .147193*i(0,0) + .231966*i(1,0) + .095020*i(2,0) - .021941*i(3,0) - .015895*i(0,1) + .098792*i(1,1) - .064944*i(2,1) + .028368*i(3,1) - .136790*i(0,2) + .175537*i(1,2) + .016196*i(2,2) - .011436*i(3,2) - .031492*i(0,3) - .118787*i(1,3) - .043338*i(2,3) + .017880*i(3,3) - .221716*i(4,0) - .069914*i(5,0) - .040570*i(6,0) - .206222*i(7,0) - .126974*i(4,1) - .234906*i(5,1) + .035792*i(6,1) + .030831*i(7,1) - .134563*i(4,2) - .213465*i(5,2) + .049959*i(6,2) + .099537*i(7,2) - .079816*i(4,3) - .178674*i(5,3) - .040387*i(6,3) + .037523*i(7,3) - .199892*i(8,0) - .095019*i(9,0) - .164849*i(10,0) - .186725*i(11,0) + .029778*i(8,1) - .013067*i(9,1) - .014325*i(10,1) + .173757*i(11,1) + .129778*i(8,2) + .101528*i(9,2) - .001108*i(10,2) - .035187*i(11,2) + .130584*i(8,3) + .126925*i(9,3) + .099189*i(10,3) + .093081*i(11,3) - .153988*i(12,0) + .038824*i(13,0) - .056654*i(14,0) - .262340*i(15,0) - .112262*i(12,1) - .117450*i(13,1) + .019426*i(14,1) + .059725*i(15,1) + .094022*i(12,2) + .049326*i(13,2) + .097184*i(14,2) + .059849*i(15,2) - .030705*i(12,3) + .048778*i(13,3) + .043639*i(14,3) + .007166*i(15,3) + .163268*i(16,0) - .075866*i(17,0) - .079359*i(18,0) + .009316*i(19,0) + .137176*i(16,1) + .078078*i(17,1) + .059982*i(18,1) - .152829*i(19,1) + .149950*i(16,2) + .121865*i(17,2) + .041333*i(18,2) - .092270*i(19,2) + .027952*i(16,3) + .119484*i(17,3) + .015529*i(18,3) + .022465*i(19,3) + .095845;\n        else if (F.x == 8) x =  .101581*i(0,0) - .153697*i(1,0) + .087488*i(2,0) + .134878*i(3,0) + .058520*i(0,1) - .103262*i(1,1) - .027637*i(2,1) + .025659*i(3,1) + .027267*i(0,2) - .168094*i(1,2) - .074472*i(2,2) - .056747*i(3,2) + .033896*i(0,3) - .106226*i(1,3) - .103624*i(2,3) + .036806*i(3,3) + .270243*i(4,0) + .123119*i(5,0) - .034506*i(6,0) + .101094*i(7,0) - .030633*i(4,1) + .001415*i(5,1) + .058839*i(6,1) + .056024*i(7,1) + .130417*i(4,2) - .075567*i(5,2) + .055068*i(6,2) + .210288*i(7,2) + .208224*i(4,3) + .107936*i(5,3) + .080834*i(6,3) - .075402*i(7,3) - .089749*i(8,0) - .095844*i(9,0) - .007633*i(10,0) + .024116*i(11,0) - .082534*i(8,1) - .040337*i(9,1) - .038216*i(10,1) - .191360*i(11,1) + .058365*i(8,2) - .010573*i(9,2) - .021778*i(10,2) + .023169*i(11,2) - .005684*i(8,3) + .035098*i(9,3) + .000621*i(10,3) + .043171*i(11,3) + .036995*i(12,0) - .024414*i(13,0) - .004137*i(14,0) + .111172*i(15,0) + .171594*i(12,1) + .115655*i(13,1) - .067570*i(14,1) + .011079*i(15,1) + .106235*i(12,2) + .140141*i(13,2) - .012020*i(14,2) + .082657*i(15,2) - .097238*i(12,3) + .019621*i(13,3) + .036329*i(14,3) + .020079*i(15,3) - .133260*i(16,0) - .044889*i(17,0) + .119676*i(18,0) + .152850*i(19,0) - .176713*i(16,1) - .128383*i(17,1) - .056316*i(18,1) + .203849*i(19,1) - .098394*i(16,2) - .037967*i(17,2) + .070011*i(18,2) + .007828*i(19,2) - .077018*i(16,3) - .069563*i(17,3) - .126146*i(18,3) - .001432*i(19,3) - .044117;\n        else if (F.x == 9) x = -.015266*i(0,0) + .220139*i(1,0) + .158281*i(2,0) - .043156*i(3,0) - .140757*i(0,1) - .192276*i(1,1) + .099127*i(2,1) + .100479*i(3,1) + .083019*i(0,2) - .081278*i(1,2) + .040925*i(2,2) + .026422*i(3,2) - .016084*i(0,3) - .155025*i(1,3) - .070794*i(2,3) + .061902*i(3,3) - .219633*i(4,0) - .134163*i(5,0) - .024233*i(6,0) - .090113*i(7,0) + .140044*i(4,1) - .128167*i(5,1) + .021798*i(6,1) - .015829*i(7,1) + .158091*i(4,2) + .027792*i(5,2) - .006498*i(6,2) + .047264*i(7,2) + .129774*i(4,3) + .055528*i(5,3) + .042968*i(6,3) - .199966*i(7,3) + .003728*i(8,0) + .077743*i(9,0) - .039579*i(10,0) - .318130*i(11,0) - .104920*i(8,1) + .012678*i(9,1) + .015643*i(10,1) - .261913*i(11,1) - .115093*i(8,2) - .157660*i(9,2) - .109066*i(10,2) + .067627*i(11,2) - .031246*i(8,3) + .082480*i(9,3) + .064080*i(10,3) + .034145*i(11,3) + .079449*i(12,0) + .015166*i(13,0) + .038041*i(14,0) - .036254*i(15,0) + .080809*i(12,1) + .096782*i(13,1) + .078773*i(14,1) - .034160*i(15,1) - .155258*i(12,2) + .041642*i(13,2) + .051072*i(14,2) + .096575*i(15,2) - .323720*i(12,3) - .105083*i(13,3) + .060075*i(14,3) + .020082*i(15,3) + .161809*i(16,0) + .179472*i(17,0) - .093735*i(18,0) - .048794*i(19,0) - .066893*i(16,1) + .111825*i(17,1) - .136923*i(18,1) - .050122*i(19,1) - .233065*i(16,2) - .025723*i(17,2) + .110846*i(18,2) + .062413*i(19,2) - .007978*i(16,3) + .001238*i(17,3) - .011578*i(18,3) + .110131*i(19,3) + .050840;\n\n        col = vec3(x);\n    }\n    \n    fragColor = vec4(col, 1);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2825, 2843, 2871, 2871, 2971], [3522, 3522, 3542, 3542, 3624], [3626, 3635, 3659, 3659, 3699], [3700, 3700, 3719, 3719, 3821], [3823, 3949, 4002, 4002, 4304], [4306, 4494, 4578, 4578, 5472], [5474, 5474, 5531, 5531, 9100]], "test": "untested"}
{"id": "DstXD4", "name": "[Revision23] Fracaelid", "author": "EvilRyu", "description": "Made for Revision 2023: https://demozoo.org/graphics/322470/\nCaelid but fractal\n4K procudural gfx coders, love you all", "tags": ["fractal", "flower", "tree", "mandelbox", "apollonian"], "likes": 53, "viewed": 947, "published": 3, "date": "1681133288", "time_retrieved": "2024-07-30T18:01:19.401284", "image_code": "vec3 tonemap(vec3 x)\n{\n    const float a = 2.51, b = .03, c = 2.43, d = .59, e = .14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    col = tonemap(col);\n    col = pow(col, vec3(.45));\n    col = col * .6 + .4 * col * col * (3. - 2. * col);\n    col *= .5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .1);\n    col = pow(col, vec3(.45));\n    fragColor.xyz=col;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Revision 2023 4K Executable Graphics Entry\n\nfloat seed;\n\n#define PI 3.1415926535\n#define HEIGHT(z) sin(z * .2  + 1.) * 2.\n\n#define MAT_TREE_TRUNK 0.\n#define MAT_TREE_LEAVES 1.\n#define MAT_FLOWER 2.\n#define MAT_FLOWER_LEAVES 3.\n#define MAT_GRASSLAND 4.\n#define MAT_WALL 5.\n\nvec3 sunDir = normalize(vec3(-.7, 1, -.1));\nvec3 sunCol = vec3(1.);\n\nvec2 hash21(float p)\n{\n    vec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat noise(vec3 p)\n{\n    const vec3 s = vec3(7, 157, 113);\n    vec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip;\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p)\n{\n    mat3 m = mat3(.0, .8, .6,\n        -.8, .36, -.48,\n        -.6, -.48, .64);\n    float f = 0., s = .5;\n    for (int i = 0; i < 4; ++i)\n    {\n        f += s * noise(p);\n        p = m * p * 2.01;\n        s *= .5;\n    }\n\n    return f;\n}\n\nfloat bump(vec3 p)\n{\n    return fbm(p * vec3(.1, .025, .1) * iResolution.x);\n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2. / iResolution.y, 0);\n    vec3 g = vec3(bump(p - e.xyy) - bump(p + e.xyy),\n        bump(p - e.yxy) - bump(p + e.yxy),\n        bump(p - e.yyx) - bump(p + e.yyx)) / (e.x * 2.);\n    g = (g - n * dot(g, n));\n    return normalize(n + g * weight);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n\n}\n\n// Used for the wall (y=1.) and the grass like fractal (y=0.)\nfloat mandelBox(vec3 z, float y)\n{\n    // vec4(fixedRadius2, minRadius2, foldingLimit, scale);\n    vec4 params = vec4(2., .1, 1.4, 3.);\n\n    if(y<1.)z.x = mod(z.y + 1., 2.) - 1.;\n    else\n    {\n        params.z = 1.8;\n        params.x = 2.3;\n        if (z.y > -3.16) return 100.;\n        z.z = mod(z.z, 2.) - 1.;\n    }\n    vec3 offset = z;\n    float dr = 1.;\n\n    for (int n = 0; n < 9; ++n)\n    {\n        z.xy *= mat2(.54, .84, -.84, .54);\n\n        z = clamp(z, -params.z, params.z) * 2.0 - z;\n\n        float r2 = dot(z, z);\n        if (r2 < params.y)\n        {\n            float temp = (params.x / params.y);\n            z *= temp;\n            dr *= temp;\n        }\n        else if (r2 < params.x)\n        {\n            float temp = (params.x / r2);\n            z *= temp;\n            dr *= temp;\n        }\n\n        z = params.w * z + offset;\n        dr = dr * abs(params.w) + 1.;\n    }\n    return length(z) / abs(dr);\n}\n\n\nvec3 c = vec3(.808, .22, 2.137);\nfloat fractal(vec3 p)\n{\n    float scale = 1.;\n    vec3 q = p;\n    for(int i=0; i < 14;i++)\n    {\n        float a = 2.;\n        if (i == 3 && q.x<-44.) a = 2.4;\n        p = a*clamp(p, -c, c) - p;\n        float k = max(1. / dot(p, p), .03);\n        p *= k;\n        scale *= k;\n    }\n\n    float l = min(length(p.xz), mandelBox(p*1.8, 0.)/1.8+.01);  // 2.3\n    \n    float rxy = l - .4;\n    float n = l * p.z;\n    rxy = max(rxy, -n / length(p) - .01);\n    return rxy / abs(scale * 1.5);\n}\n\nvec3 fractalMate(vec3 p)\n{\n    vec3 q = p;\n    vec3 acc = vec3(0);\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 p1 = 2. * clamp(p, -c, c) - p;\n        acc += distance(p, p1) * max(1./ dot(p, p), .3);\n        p = p1 * max(1. / dot(p1, p1), .03);;\n    }\n\n    vec3 k = vec3(.3, .2, .2);\n    if (q.z < 4.8) k = vec3(.5, .4, .2);\n    q.xy *= rot(.2);\n    if (q.y < 34. && q.y > -5. && q.z > 4.5 && abs(q.x+32.7)<3.) k = vec3(2,.9,.8);\n    return vec3(.4, .4, .3) + k * cos(3. * acc);\n}\n\n// KIFS fold with id recorded for each folded space, in order to apply some variations\nvec2 fold(vec2 p, float s, out float id)\n{\n    float a = PI / s + atan(p.x, p.y);\n    float n = PI * 2. / s;\n    a = floor(a / n);\n    id = mod(a, s);\n    p *= rot(-a * n);\n    return p;\n}\n\n// Bar but scales differently on the three axis\nfloat dbar2(vec3 p, vec3 a, vec3 b, vec3 r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), .0, 1.);\n    return (length((pa - ba * h) / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\n// Tree branches and leaves (i>=4.)\nvec4 dBranches(vec3 p, float i, float id, float len)\n{\n    p.x += sin(p.y * 4.) * (.2 - .1 * step(4., i)) * (hash21(id * 17. + i + 3.).x * .5 + .5) * smoothstep(.5, 1., p.y);\n    vec3 dir = normalize(vec3(0, 2, -1));\n    float k = .1 - smoothstep(.6, 2.5, p.y) * .07;\n    float l = 3.;\n    if (i >= 4.)\n    {\n        p.x *= .4;\n        p.z += abs(sin(p.x * 25.)) * .05;\n        //p.x += abs(sin(p.y * 30.)) * .005;\n        k = .1 - sin(p.y * 2. + 2.5) * .1;\n        l = 3.;\n    }\n    else if (i > 0.) k *= 0.2;\n    else k -= noise(p*vec3(50,10,50))*.02 - .01;\n\n    float dcap = dbar2(p + vec3(0, 0, len),\n        vec3(0, 0, len),\n        vec3(0, 0, len) + len * l * dir,\n        vec3(k));\n\n    return vec4(p, dcap);\n}\n\nvec2 tree(vec3 z0)\n{\n    z0.xz *= rot(-.2);\n\n    vec4 z = vec4(z0, 1.);\n    vec3 p = z.xyz;\n\n    p.x -= sin(p.y * 2.) * .1;\n    float d = max(abs(p.y - .1) - 1., length(p.xz) - .22 - noise(p.zyx * vec3(50, 10, 50)) * .02 + smoothstep(0., 1.3, p.y) * .3);\n\n    float id = 0., numLayers = 7., mateid = 0.;\n\n    // The position to clone more branches\n    vec4 branchClonePos = z;\n    float branchCloneIndex = 3.;\n    float branchLayer = 4.;\n\n    // The position to clone more leaves\n    vec4 leafClonePos = z;\n    float leafCloneIndex = 4.;\n\n    // 1 iteration of folding is not enough to create thick leaves, so there are numLayers\n    for (float layerIndex = 1., i = 0.; layerIndex <= numLayers; layerIndex += 1.)\n    {\n        for (; i < 5.; i += 1.)\n        {\n            float f = 5. + (layerIndex > 1. ? 4. : 0.);\n            float spread = -.95 - i / 7.;\n\n            if (i == branchCloneIndex)\n                branchClonePos = z;\n\n            if (layerIndex == 1. && i == leafCloneIndex)\n                leafClonePos = z;\n\n\n            z.xz = fold(z.xz, f, id);\n            z.yz *= rot(-spread);\n\n\n            float len = 1. + id / f / 3.;\n            vec4 res = dBranches(z.xyz, i, id, len);\n            float dcap = res.w / z.w;\n\n            // for leaves\n            if (i >= 4.)\n            {\n                float d1 = dcap +.011;\n                if (d1 < d)\n                {\n                    d = d1;\n                    mateid = 1.;\n                }\n            }\n            // for branches\n            else\n            {\n                if (dcap < d)\n                {\n                    d = smin(d, dcap, .05 - .04 * step(2., float(i)));\n                    mateid = 0.;\n                }\n            }\n\n            z.zy += vec2(1., -2.) * len;\n            z *= 2.;\n        }\n\n\n        if (layerIndex < branchLayer)\n        {\n            z = branchClonePos;\n            // place more branches uniformly on the parent branch\n            z.zy -= normalize(vec2(1., -2.)) * (hash21(layerIndex * 17.).x+1.) * branchCloneIndex * 2. / branchLayer;;\n\n            //z *= 4. - branchCloneIndex + 1.;\n            i = branchCloneIndex;\n\n        }\n        else\n        {\n            z = leafClonePos;\n            z.zy -= normalize(vec2(1., -2.)) * (layerIndex - 2.) * leafCloneIndex / (numLayers - branchLayer);//  / (numLeafLayers);\n            i = leafCloneIndex;\n\n            // folding to add more leaves in each layer\n            z.xzy = abs(z.xzy) - 1.;\n        }\n        z.xy *= rot(.2 * (numLayers - layerIndex));\n    }\n\n    return vec2(d * .5, mateid);\n}\n\n// Almost the same with dBranches, but only for flower pedels\nvec4 dPedals(vec3 p, float i, float id, float fid)\n{\n    p.z += sin(p.y * id / 2.) * .05;\n    p.z += sin(p.y * 2.) * (.65 - i / 5.);\n    float k = .1 - sin(p.y * 2. + 2.5) * .1;\n\n    if (i == 1.)\n    {\n        p.z += abs(sin(p.x * 5.)) * .15;\n        p.z += abs(sin((p.y - abs(p.x)) * 15.)) * .01;\n        p.x += sin(p.z * 60.) * .01;\n    }\n\n    float dcap = dbar2(p + vec3(0, 0, 1),\n        vec3(0, 0, 1),\n        vec3(0, 0, 1) + 2.8 * normalize(vec3(0, 2, -1)),\n        vec3(k * (3.-fid), k, .03)) + .01;\n    return vec4(p, dcap);\n}\n\n// Almost the same with tree, but no layers \nvec2 flower(vec3 z0, float fid)\n{\n    z0.xz *= rot(fid);\n    z0.z *= -1.;\n    vec4 z = vec4(z0, 1);\n\n    vec3 p = z.xyz;\n    z.yz *= rot(-.5);\n    p.z -= sin(p.y * 1.5) * .1;\n\n    float mateid = 0.;\n    float d = max(abs(p.y + 1.8) - 2., length(p.xz) - .1 + smoothstep(0., 2., p.y) * 0.1);\n\n    float id = 0., f = 5. + fid * 4., spread = 1.8, dcap, i;\n    //z.xz = mul(rot(fid*.3), z.xz);\n\n    z.xz = fold(z.xz, f, id);\n    z.yz *= rot(spread);\n\n    for (i = 1.; i <= 6.; i += 1.)\n    {\n        vec4 res = dPedals(z.xyz, i, id, fid);\n        dcap = res.w / z.w;\n\n        if (dcap < d)\n        {\n            mateid = i < 2. ? 3. : 2.;\n            d = dcap;\n        }\n\n        z = vec4(z0, 1);\n        z.yz *= rot(-.5);\n        z.xz *= rot(0.3 * i);\n        z.xz = fold(z.xz, 7. + i + fid * 4., id);\n        z.yz *= rot(1.2);// - (i+1.)/100.);\n\n        if (i > 1.)z.zy += vec2(.1 * i, 0);\n        //z.z *= -1.;\n        z *= 1. + i * .5;// + 2.*i - 2.;\n    }\n\n    return vec2(d * .5, mateid);\n}\n\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), .0) + length(max(d, .0));\n}\n\n\nvec2 map(vec3 p)\n{\n    float mateid = 4.;\n\n    vec3 q = p - vec3(.87, 3., 1.82);\n\n    vec2 r0 = tree((q - vec3(.3,.1,2)) * .37); r0.x /= .37;\n    vec2 r1 = flower(1.8*(q + vec3(4.3, 1.8, -7)), 0.); r1.x /= 1.8;\n    vec2 r2 = flower(1.2 * (q + vec3(4.5, -.2, -3)), 1.); r2.x /= 1.2;\n\n\n    // begin: the grass land\n    q = p + vec3(-35, 4.5, 16);\n    q.y += HEIGHT(q.z);\n    vec2 r4 = vec2(fractal(q.xzy), 4.);\n    float s0 = box(p - vec3(6., 5, -23.5), vec3(1.5));\n    r4.x = max(r4.x, -s0);\n    // end: the grass land\n\n    // begin: the wall\n    p.xz *= rot(.1);\n    p.x = -abs(p.x+11.) - 9.8;\n    vec2 r6 = vec2(box(p + vec3(79,0,0), vec3(70, 1e5, 1e5)), 4.);\n\n    if (p.z > 5.)p.y -= sin(p.z * .2 + 3.) * 2.;\n    else p.y -= (abs(fract(p.z * .037) - .5) * 4. - 1.)*.5;\n    vec2 r5 = vec2(max(r6.x, mandelBox((p * .1 - vec3(-3., 3.5+smoothstep(10.,0.,p.z)*.3, 1.)), 2.) / .1), 5.);\n    // end: the wall\n\n\n    vec2 r = r0;\n    if (r1.x < r.x) r = r1;\n    if (r2.x < r.x) r = r2;\n    if (r4.x < r.x) r = r4;\n    if (r5.x < r.x) r = r5;\n\n    return r;\n\n}\n\n\nvec3 getMaterial(float id, vec3 p)\n{\n   if (id == MAT_GRASSLAND)\n    {\n        p = p + vec3(-35, 4.5, 16);\n        p.y += HEIGHT(p.z);\n        vec3 col = fractalMate(p.xzy);\n\n        col = mix(vec3(1.1, .1, 0), col, smoothstep(3.5, 4.9, p.y));\n        col = mix(vec3(.12, .3, .1), col, 1. - smoothstep(5., 25., p.y));\n\n        return col;\n    }\n    else if (id == MAT_TREE_TRUNK)\n    {\n        return  vec3(.169, .114, .081)*2.;\n    }\n    else if (id == MAT_TREE_LEAVES)\n    {\n        return vec3(2, .8, 0);\n    }\n    else if (id == MAT_FLOWER)\n    {\n        return vec3(.9, .1, .1);\n    }\n    else if (id == MAT_FLOWER_LEAVES)\n    {\n        return mix(vec3(.1, .25, .1), vec3(.8),fbm(p*5.)*.5);\n    }\n    else if (id == MAT_WALL)\n    {\n        return vec3(.69, .565, .451);\n    }\n    return vec3(1);\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 n = vec3(0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.);\n        n += e * map(p + .001 * e * t).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float s = 1.,t = .001;\n    for(int i = 0; i < 32; i++)\n    {\n        vec2 h = map(ro + rd * t);\n        if (h.y == MAT_FLOWER_LEAVES) h.x *= .35;\n        s = min(s, 16. * h.x / t);\n        if (h.x < 1e-4) break;\n        t += clamp(h.x, .01, .05);\n    }\n    return clamp(s, 0., 1.);\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    float rnd = .9 + .1 * hash21(seed++).x;\n    float t = .01;\n    vec2 res = vec2(1e9);\n    bool hit = false;\n    \n    for(int i = 0; i < 1024; ++i)\n    {\n        res = map(ro + t * rd);\n        res.x = abs(res.x) * rnd;\n        float k = res.y == 5. ? 10. : 1.;\n        if (res.x < .0005 * k + .0002 * t)\n        {\n            hit = true;\n            break;\n        }\n        if (t > 100.)\n        {\n            break;\n        }\n        \n        t += res.x;\n    }\n    if (!hit) t = -1.;\n\n    return vec2(t, res.y);\n}\n\nvec3 phongBrdf(vec3 toLight, vec3 toEye, vec3 normal, vec3 pos, vec3 albedo)\n{\n    float fre = .04 + .96 * pow(1. - max(0., dot(toLight, normalize(toLight + toEye))), 5.);\n\n    float spec = fre * 9. * pow(max(0., dot(reflect(-toLight, normal), toEye)), 16.);\n\n    return (.2 * spec + .8 * (1. - fre) * albedo) / PI;\n}\n\nvec3 getHemisphereSampleCosWeighted(vec3 n, vec2 s)\n{\n    vec3 o1 = normalize(abs(n.x) > abs(n.z) ? vec3(-n.y, n.x, 0.0) : vec3(0.0, -n.z, n.y));\n    vec3 o2 = normalize(cross(n, o1));\n    s.x = s.x * 2. * PI;\n    float oneminus = sqrt(1. - s.y);\n    return cos(s.x) * oneminus * o1 + sin(s.x) * oneminus * o2 + s.y * n;\n}\n\n\nfloat mapCloud(vec3 p)\n{\n    p *= .01;\n    return smoothstep(.1, 1., fbm(p * vec3(.5, 1, 1)) + .5 * fbm(p * 2.5));\n}\n\nvec3 renderCloud(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 skycol = vec3(.053, .001, .0001);\n    skycol = mix(skycol, vec3(0), smoothstep(.1, 1., fbm(vec3(uv * vec2(12, 60), 1))));\n\n    vec4 sum = vec4(0, 0, 0, 1);\n\n    float t = (100.0 - ro.y) / rd.y, dt = .2;\n\n    if (t < 0.) return skycol;\n\n    float rnd = .95 + .05 * hash21(seed++).x;\n\n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float d = mapCloud(p) * rnd;\n\n        if (d > 0.)\n        {\n            float s = 0.;\n            vec3 st = normalize(p + sunDir);\n            vec3 sp = p;\n            for (int j = 0; j < 10; j++)\n                s += mapCloud(sp += st);\n\n            sum.xyz += exp(-s * .1) * d * vec3(1.5) * sunCol * (1. - d) * sum.a;\n            sum.a *= 1. - d;\n        }\n\n        if (sum.a < .1 || t > 1000.) break;\n\n        t += dt;\n        dt = max(1., .1 * t);\n    }\n    sum.xyz = mix(sum.xyz, skycol, smoothstep(0., 3., t / 800.));\n    return sum.xyz;\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 throughput = vec3(1.), Lo = vec3(0), pos, q, n, albedo, nextRd, direct;\n\n    vec3 cloud = renderCloud(ro, rd, uv);\n    vec3 sky = cloud * vec3(.585, .014, .0015);;\n    sky = mix(sky, vec3(1, .2, 0), smoothstep(.1,1.,dot(cloud,cloud)));\n    sky = mix(vec3(0,.5,1) * .0005, sky, smoothstep(0.,1.,length((uv-vec2(.3,.4))*vec2(.5,1))-.1));\n\n    // bounces\n    for (int i = 0; i < 3; ++i)\n    {\n        vec2 hit = intersect(ro, rd);\n        q = pos = ro + hit.x * rd;\n\n        if (hit.x < 0.)\n        {\n            Lo = Lo + throughput * sky;\n            break;\n        }\n\n        n = getNormal(pos, hit.x);\n\n        albedo = getMaterial(hit.y, pos);\n\n        q.y -= HEIGHT(q.z);\n\n        float a = 0., b = 0.;\n        if (hit.y == MAT_TREE_TRUNK) a = .2, b = 30.;\n        if (q.y <= .05) a = .5, b = 100.;\n        if(a > 0.)\n            n = bump_mapping(q * a, n, b / max(iResolution.x, iResolution.y));\n\n        if (hit.y == MAT_TREE_LEAVES)\n            sunDir = normalize(vec3(-1, 1, 1));\n\n        float sha = shadow(pos + 0.001 * n, sunDir);\n        if (hit.y == MAT_TREE_LEAVES)\n            sha = smoothstep(.1, .8, sha);\n        \n        direct = (sunCol * phongBrdf(sunDir, -rd, n, pos, albedo) * max(0., dot(n, sunDir)) * sha);\n\n        if (hit.y == MAT_TREE_LEAVES)\n            direct += sunCol * max(0., dot(-n, sunDir)) * albedo * 0.3 *sha;\n\n        Lo += throughput * direct;\n\n        // Further bounces only for tree and flower\n        if (hit.y > MAT_FLOWER) break;\n\n        // Sample brdf\n        nextRd = normalize(getHemisphereSampleCosWeighted(n, hash21(seed++)));\n        float pdf = max(0., dot(n, nextRd)) / PI;\n        if (pdf < .0001) break;\n\n        throughput *= phongBrdf(nextRd, -rd, n, pos, albedo) * max(0., dot(nextRd, n)) / pdf * (hit.y == 0. ? .2 : 1.);\n                                  \n        rd = nextRd;\n        ro = pos + .002 * n;\n    }\n\n    return Lo;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = float(iFrame) + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\n    vec2 offset = -.5 + hash21(seed++);\n    vec2 p = (fragCoord + offset) / iResolution.xy; \n    p = 2. * p - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // partial rendering, only render 16 scanlines per frame\n    float lineCount = ceil(iResolution.y / 16.);\n    int line = int(fragCoord.y / iResolution.y * lineCount);\n    \n    vec4 prevCol = texelFetch( iChannel0, ivec2(fragCoord), 0);\n    if(iFrame == 0) prevCol = vec4(0);\n    \n    if(line != iFrame % int(lineCount)) \n    {\n        fragColor = prevCol;\n        return;\n    }\n\n    vec3 ro = vec3(-4.76, 4.86, 29.46);\n    vec3 ta = vec3(-4.72, 4.87, 28.46);\n\n    vec3 forward = normalize(ta - ro);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n\n    vec3 rd = normalize(p.x * right + p.y * up + 1.8 * forward);\n\n    // Blend with previous samples\n    fragColor = vec4(mix(prevCol.xyz, scene(ro,rd,p), 1./(prevCol.w+1.)), prevCol.w+1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 141], [143, 143, 200, 200, 548]], "test": "untested"}
{"id": "mdKXWh", "name": "crossbars 2", "author": "FabriceNeyret2", "description": "inspiration: https://twitter.com/pickover/status/1644864126462599169", "tags": ["2d", "2tweets", "short", "reproduction"], "likes": 50, "viewed": 1056, "published": 3, "date": "1681111042", "time_retrieved": "2024-07-30T18:01:20.258992", "image_code": "// variant of https://shadertoy.com/view/msGXW1\n\n  #define S(v)     smoothstep(0.,1., v)                   // for AAdraw AND for arc shape \n  #define H(p)     fract(sin((p+.17) * 12.9898) * 43.5453)// hash\n  #define N(s,x)  (s)* floor( 4.*H(d+T-7.7*(X+x)+x)/(s) ) // random node(time#, ball#, stage#)\n  #define R       (floor(iResolution.xy/8.)*8.)           // to avoid fwidth artifact\n//#define arc(t) mix(i,j, S(fract(t)) ) - U.y             // arc trajectory\n  #define arc(t) mix( i+sin(i*iTime)*.2*s, j+sin(j*iTime)*.4*s, S(fract(t)) ) - U.y // animated variant\n           \nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = 4.*U/R - 2.;                                    // normalize window in [-2,2] = 4 stages\n    float s = exp2(-floor(1.-U.x)), S=s, i,j,v,n;       // 2 / number of nodes at each stage\n    \n    O = vec4(1);                                        // start with a white page\n    for( i = .5*s-2.; i < 2.; i += s )                  // === drawing the net (same as ref)\n        for( j = s-2.; j < 2.; j += s+s )               // on each stage, loop on in/out pairs\n            v = arc(U.x),      \n            O *= .5+.5* S( abs(v)/fwidth(v) );          // blacken-draw curve arc()=0\n\n    for ( n=0.; n<1.; n+=.1 )  {                        // === drawing the balls                                  \n        float d = H(n),                                 // lauch 10 per second, at random time d\n              X = floor(U.x), x = U.x-X,                // X = stage#, T = time#\n              t = 2.-iTime+d, T = floor(t); t-=T;       // t = x coords ( fract(t) do each stage in // )                                                      \n        s = S;\n        if (t<.1 && x>.9 ) s*=2., X++;                  // manage ball at stage transition\n        if (t>.9 && x<.1 ) s/=2., X--;\n        i = .5*s-2. + N(s   ,0.);                       // select in/out nodes ( mimic draw curve above )\n        j =    s-2. + N(2.*s,1.);                       // 1: offset for the input nodes \n        v = arc(t);                                         \n        O = mix( vec4(1,0,0,1), O,                      // blend-draw ball\n                 S( length( vec2( fract(U.x-t+.5)-.5, v )*R/4. ) -5. ) );\n    }                                                   // fract: to draw all stages in parallel\n  \n    O = sqrt(O);                                        // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[579, 579, 617, 617, 2376]], "test": "untested"}
{"id": "dsGSWW", "name": "...sitting at the end of the way", "author": "oatmealine", "description": "shifting, turning. it perplexed them both", "tags": ["3d", "experimental", "messy", "glitchybutinafunway"], "likes": 6, "viewed": 392, "published": 3, "date": "1681098959", "time_retrieved": "2024-07-30T18:01:21.339104", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// largely adapted from https://www.shadertoy.com/view/ld23DV\n\n// The MIT License\n// Copyright  2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    #if 1\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\t#else\n    // more robust\n    vec3 k = vec3(rdd.x>=0.0?rad.x:-rad.x, rdd.y>=0.0?rad.y:-rad.y, rdd.z>=0.0?rad.z:-rad.z);\n    vec3 t1 = (-roo - k)*m;\n    vec3 t2 = (-roo + k)*m;\n    #endif\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return vec4(-1.0);\n\n    #if 1\n    // this works as long as the ray origin is not inside the box\n    vec4 res = vec4(tN, step(tN,t1) );\n    #else\n    // use this instead if your rays origin can be inside the box\n    vec4 res = (tN>0.0) ? vec4( tN, step(vec3(tN),t1)) :\n                          vec4( tF, step(t2,vec3(tF)));\n    #endif\n    \n    // add sign to normal and convert to ray space\n\tres.yzw = (txi * vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n\n\treturn res;\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    \n    vec4 behind = texture(iChannel1, fragCoord/iResolution.xy);\n\n     // camera movement\t\n\tvec3 ro = vec3( 2.5 * mix(behind.r, 1.0, 0.4), 1.0 * mix(behind.g, 1.0, 0.4), 2.5 + sin(behind.b * 6.0) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    // rotate and translate box\t\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iTime );\n\tmat4 tra = translate( 0.0, 1.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\n\t// raytrace box\n\tvec3 box = vec3(0.8,0.8,0.8) ;\n\tvec4 res = iBox( ro, rd, txx, txi, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\ttmin = res.x - tan(dot(res.yzw, vec3(0.0, 1.0, 0.0)) * 1.7) * 0.4;\n\t\tnor = res.yzw;\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.0, 1.0, 0.0);\n    \n\tif( tmin<100.0 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // material\n\t\tfloat occ = 1.0;\n\t\tvec3  mate = vec3(1.0);\n        // recover box space data (we want to do shading in object space)\t\t\t\n        vec3 opos = (txx*vec4(pos,1.0)).xyz;\n        vec3 onor = (txx*vec4(nor,0.0)).xyz;\n        mate = abs(onor.x)*texture( iChannel0, 0.2*opos.yz ).xyz + \n               abs(onor.y)*texture( iChannel0, 0.2*opos.zx ).xyz + \n               abs(onor.z)*texture( iChannel0, 0.2*opos.xy ).xyz;\n        mate *= 0.35;\n        occ = 0.6 + 0.4*nor.y;\t\n\t\t\n        // lighting\n        vec3  lig = normalize(vec3(0.8,0.4,-0.6));\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        vec3  hal = normalize(lig-rd);\n        float amb = 0.6 + 0.4*nor.y;\n        float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n        float spe = clamp(dot(nor,hal),0.0,1.0);\n        col  = 4.0*vec3(1.00,0.80,0.60)*dif;\n        col += 2.0*vec3(0.20,0.30,0.40)*amb;\n        col += 2.0*vec3(0.30,0.20,0.10)*bou;\n        col *= mate;            \n        col += 0.3*pow(spe,8.0)*dif*(0.04+0.96*pow(clamp(dot(lig,hal),0.0,1.0),5.0));\n        col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tmin*tmin) );           \n\t}\n\n    // gamma\n    col = pow( col, vec3(0.45) );\n\n\tfragColor = vec4( col, 1.0 );\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define PI 3.1415926538\n\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\n#define PALETTE_SIZE 4\nvec3 colors[PALETTE_SIZE] = vec3[](\n  RGB(0,   0,   0  ),\n  RGB(128, 0,   128),\n  RGB(255, 0,   255),\n  RGB(255, 255, 0  )\n);\n\nfloat gray(vec3 color) {\n  return (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5;\n}\n\nvec3 getPalette(vec3 col) {\n  float g = clamp(gray(col), 0.0, 0.99);\n  return colors[int(floor(g * float(PALETTE_SIZE)))];\n}\nvec3 getPaletteComplex(vec3 col) {\n  // comparasion\n  float minDist = 9e9;\n  int newCol;\n\n  for (int i = 0; i < PALETTE_SIZE; i++) {\n    vec3 compareCol = colors[i];\n\n    vec3 distVec = abs(col - compareCol);\n    float dist = (distVec.r + distVec.g + distVec.b) / 3.0;\n\n    if (dist < minDist) {\n      newCol = i;\n      minDist = dist;\n    }\n  }\n\n  return colors[newCol];\n}\n\n// adapted from https://www.shadertoy.com/view/ldBGRR\nvec3 plasma( vec2 p )\n{\n// main code, *original shader by: 'Plasma' by Viktor Korsun (2011)\nfloat x = p.x;\nfloat y = p.y;\nfloat mov0 = x+y+cos(sin(iTime)*2.0)*100.+sin(x/100.)*1000.;\nfloat mov1 = y / 0.9 +  iTime;\nfloat mov2 = x / 0.2;\nfloat c1 = abs(sin(mov1+iTime)/2.+mov2/2.-mov1-mov2+iTime);\nfloat c2 = abs(sin(c1+sin(mov0/1000.+iTime)+sin(y/40.+iTime)+sin((x+y)/100.)*3.));\nfloat c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));\nreturn vec3(c1,c2,c3);\n}\n\nfloat green(vec3 tex) {\n    return (1.0 - tex.r) * tex.g * (1.0 - tex.b);\n}\n\nconst int lookupSize = 64;\nconst float errorCarry = 0.8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 tex = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    if (green(tex.rgb) > 0.95) {\n        vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n        float ratio = iResolution.y / iResolution.x;\n        uv.y *= ratio;\n        uv = round(uv * 32.0) / 32.0;\n        vec2 normalized = normalize(uv);\n        float uvDot = dot(normalized, vec2(1.0, 0.0));\n        uv *= 0.75 + min(tan(uvDot * 2.14 + iTime * 0.2) * 0.1, 0.0);\n        uv.y /= ratio;\n        vec4 rTex = texture(iChannel0, uv + 0.5);\n        if (green(rTex.rgb) > 0.95) {\n            vec2 base = (fragCoord.xy / iResolution.xy - 0.5) * 0.99 + 0.5;\n            float thisTexR = texture(iChannel1, fract(base + vec2(sin(iTime * 0.55 + uv.y) * 0.2, cos(iTime * 0.4 + uv.x) * 0.2))).r;\n            float thisTexG = texture(iChannel1, fract(base + vec2(sin(iTime * 0.55 - uv.y) * 0.2, cos(iTime * -0.4 - uv.x) * 0.2))).g;\n            float thisTexB = texture(iChannel1, fract(vec2(1.0 - base.x, base.y) + vec2(sin(iTime * -0.55 + uv.y) * 0.2, cos(iTime * -0.4 + uv.x) * 0.2))).b;\n            vec3 thisTex = vec3(thisTexR, thisTexG, thisTexB);\n            float luma = (1.0 - thisTex.r) * (1.0 - thisTex.g) * (1.0 - thisTex.b);\n            \n            fragColor = vec4(getPaletteComplex(plasma((fragCoord.xy / iResolution.xy - 0.5) * 2.0) * luma * 0.3) - thisTex * 0.3, 1.0);\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    } else {\n        // adapted from https://www.shadertoy.com/view/4sjGRD\n        int topGapY = int(iResolution.y - fragCoord.y);\n\n        int cornerGapX = int((fragCoord.x < 10.0) ? fragCoord.x : iResolution.x - fragCoord.x);\n        int cornerGapY = int((fragCoord.y < 10.0) ? fragCoord.y : iResolution.y - fragCoord.y);\n        int cornerThreshhold = ((cornerGapX == 0) || (topGapY == 0)) ? 5 : 4;\n\n        vec3 xError = vec3(0.0);\n        for(int xLook=0; xLook<lookupSize; xLook++){\n            vec2 uv = (fragCoord.xy + vec2(-lookupSize+xLook,0)) / iResolution.xy;\n            vec3 sourcePixel = texture(iChannel0, uv).rgb;\n            vec3 col = getPalette(sourcePixel) + xError;\n            xError = (sourcePixel - col) * errorCarry;\n        }\n\n        vec3 yError = vec3(0.0);\n        for(int yLook=0; yLook<lookupSize; yLook++){\n            vec2 uv = (fragCoord.xy + vec2(0,-lookupSize+yLook)) / iResolution.xy;\n            vec3 sourcePixel = texture(iChannel0, uv).rgb;\n            vec3 col = getPalette(sourcePixel) + yError;\n            yError = (sourcePixel - col) * errorCarry;\n        }\n\n        vec3 final = getPalette(texture(iChannel0, fragCoord.xy / iResolution.xy).rgb + xError * 0.5 + yError * 0.5);\n\n        fragColor = vec4(final, 1.0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]], "test": "untested"}
{"id": "cdySDW", "name": "Year of Truchets #008", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 18, "viewed": 221, "published": 3, "date": "1681094653", "time_retrieved": "2024-07-30T18:01:22.257647", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #008\n    04/09/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.37,45.93)))*4374.23); }\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e - b), 0.0, 1.0); }\n\n//@iq shapes\nfloat box( vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.025;\n}\nfloat box( vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat cap( vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat floorspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.;\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0),speed=vec3(0);\nmat2 r45,r25;\n\nconst float size = 4.;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\nconst float spce = size;\nconst vec3  grid = vec3(1,1,1);\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    float id;\n    vec3 q=vec3(0), sp=p;\n    \n    for(int i = 0; i<2; i++)\n    {\n        // based on @Shanes multi-tap stuff\n        // though cut down to two taps\n        float cnt = i==0 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n        vec3 r= q;\n   \n        float intspace = 50.;//start space\n        float ff = qf-size;  //id pluse obj space\n        float fp = floorspeed-1.; //offsets to start and pause\n        float fs = floorspeed+2.; //begin area\n        //if past start ent = 0 ? if greater hold at start else move into space to 0\n        float ent= ff<fp ? 0. : ff>fs ? intspace : clamp(1.-ga3,0.,1.)*intspace;\n        if(i==0) ent = -ent;//flip direction\n        r-=vec3(0,0,ent);\n         \n        // making ids for the new clamp domains \n        float nf = floor((r.z + hlf)/size);\n        float hs = hash21(vec2(nf,qf));\n        // clamp domains for truchet\n        r.z = r.z-size*clamp(round(r.z/size),-3.,3.);\n     \n        // standard truchet stuff\n        if(hs>.5) r.x*=-1.;\n        \n        vec2 d2 = vec2(length(r.xz-hlf), length(r.xz+hlf));\n        vec2 gx = d2.x<d2.y ? vec2(r.xz-hlf) : vec2(r.xz+hlf);\n        vec3 tq = vec3(gx.x,r.y,gx.y);\n    \n        float d3=box(r,vec3(1.9));\n        float d4=trs(tq,vec2(2.,.5));\n\n        if(hs>.6) d4 = min(length(r.yz)-.5,length(r.yx)-.5);\n   \n        if(hs>.075&&hs<.15) d4 = min(length(r.yz)-.5, length(vec3(r.yx,abs(r.z)-hlf))-.5);\n    \n        if(hs<.075) d4 = min(length(r.yx)-.5, length(vec3(abs(r.x)-hlf,r.yz))-.5);\n        d3=max(d3,d4);\n        \n        if(d3<res.x){\n            hs=fract(hs*432.32);\n            res = vec2(d3,hs<.5?4.:3.);\n            hit= r;\n            gid = vec3(qf,nf,1);\n        }\n    }\n    \n    float fl = p.y+4.;\n    if(fl<res.x){\n        res=vec2(fl,2.);\n        hit=p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(float t) {\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(0.88,.97,.85))); \n}\n\nvec4 FC = vec4(0.647,0.753,0.753,0.);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(15.,35.,35.);\n        vec3 l = normalize(lpos);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint*vec3(-1.,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n\n        float clr;\n        \n        // materials\n        if(m==2.){\n            h=vec3(.05);\n            \n            float px = 4./R.x;\n            float sc = .18;\n            \n            vec2 id= floor(hp.xz*sc);\n            vec2 f = fract(hp.xz*sc)-.5;\n            float ck = mod(id.x+id.y,2.)*2.-1.;\n\n            float hs = hash21(id);\n            if(hs>.5) f.x*=-1.;\n\n            vec2 d2 = vec2(length(f-.5),length(f+.5));\n            vec2 gx = d2.x<d2.y ? vec2(f-.5):vec2(f+.5);\n\n            float p = length(gx)-.5;\n            float d = abs(p)-.05;\n\n            p = (ck>.5^^hs>.5) ? smoothstep(px,-px,p):smoothstep(-px,px,p);\n            d = smoothstep(px,-px,d);\n\n            h = mix(h,hue(hp.x*.0085)*.2,p);\n            h = mix(h,hue(hp.x*.0085)*.4,d);\n             \n            ref=vec3(max(p,d)*h);\n\n        }\n        if(m==3.){\n            h = hue(sid.x*.0085);\n            ref = h*.5;\n        }\n        if(m==4.){\n            h = vec3(.5);\n            ref = vec3(.2);\n        }\n        C = (diff*h);\n        \n        C = mix(FC.rgb,C,exp(-.0000005*d*d*d));\n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // var names are so off now\n    // but too lazy to change\n   // r45=rot(-.585);\n    r25=rot(-.785);\n\n    float time = (T+40.)*4.;\n    tmod = mod(time, 10.);\n    float t3 = lsp(5.0, 10.0, tmod);\n    ga1 = (time*.1);\n    ga3 = tmod<5.?t3+1.:t3;\n    speed = vec3(abs(ga1*spce),0,0);\n    floorspeed=floor(speed.x);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*20.,-25.);\n    vec3 rd = vec3(0.,0.,1.);\n\n    mat2 turn = rot(time*.01);\n    ro.yz*=r25,ro.xz*=turn;\n    rd.yz*=r25,rd.xz*=turn;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n    C = clamp(C,vec3(.01),vec3(1));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdySDW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[483, 483, 502, 502, 547], [548, 548, 570, 570, 625], [626, 626, 664, 664, 709], [711, 724, 752, 752, 841], [842, 842, 873, 873, 953], [954, 954, 989, 989, 1094], [1095, 1095, 1121, 1121, 1190], [1465, 1465, 1486, 1486, 3425], [3427, 3427, 3457, 3457, 3696], [3698, 3698, 3741, 3741, 3967], [3969, 3969, 3988, 3988, 4063], [5799, 5799, 5840, 5927, 6696]], "test": "untested"}
{"id": "csVXzh", "name": "N-gon rotation with colors", "author": "Oman395", "description": "Inspired by a fantastic wallpaper I saw on the catppuccin discord. Includes all cpt themes inbuilt, as well as several pride flag colors. Still needs anti aliasing (I did try already lol), but other than that it's pretty good looking!", "tags": ["colors", "rotation", "polygon", "ngon", "geometric", "pride"], "likes": 8, "viewed": 375, "published": 3, "date": "1681085138", "time_retrieved": "2024-07-30T18:01:23.163226", "image_code": "// Take a wild guess\n#define SIDES 6\n// Number of shapes to display. If REPEAT is true, this just scales distance between polygons.\n#define NUM_SHAPES 10\n// If true, shapes won't end after NUM_SHAPES shapes\n#define REPEAT true\n// Gee, I wonder\n// Seriously though, if you change this, things will break\n#define PI 3.14159265\n#define TAU PI * 2.0\n\n// Offset in radians per second between polyhons\n#define ROT_OFFSET -0.1\n// Radians per second for the first polygon\n#define START_ROT 0.5\n// Time scale\n#define ROT_SCALE 0.4\n// Width of individual lines\n// This goes inwards from the shape, so set this however high you want\n#define SHAPE_WIDTH 0.01\n// If this is defined, shape rotation will not offset until 1 cycle of colors are complete\n// This is mostly good for pride flags\n// #define MULTICOLOR_SHAPES\n// Themes\n// Catppuccin themes\n// #define MOCHA\n#define MACCHIATO\n// #define FRAPPE\n// #define LATTE\n\n// Pride themes\n// Feel free to add to this, add an elif to the colors definition and bg definition and comment here\n// Or dm it to me, AutisticMOFO#0521\n// #define TRANS\n// #define GAY\n// #define BI\n// If defined, this will limit time to +- TIME_BOUNDS / 2.0, and use a sin curve to make it not juddery.\n// #define TIME_BOUNDS 8.0\n\n// If defined, distance between shapes will pulse with music\n// #define USE_MUSIC\n\n// If defined, antialiasing will be enabled-- this will make lines much smoother, but also significantly thicker (by ~3px).\n#define AA\n\nconst vec4 colors[] = vec4[](\n    #if defined(MACCHIATO)\n    vec4(138, 173, 244, 255) / 255.0, // Blue\n    vec4(139, 213, 202, 255) / 255.0, // Teal\n    vec4(166, 218, 149, 255) / 255.0, // Green\n    vec4(245, 169, 127, 255) / 255.0, // Peach\n    vec4(237, 135, 150, 255) / 255.0, // Red\n    vec4(198, 160, 246, 255) / 255.0  // Mauve\n    #elif defined(MOCHA)\n    vec4(137, 180, 250, 255) / 255.0,\n    vec4(148, 226, 213, 255) / 255.0,\n    vec4(166, 227, 161, 255) / 255.0,\n    vec4(250, 179, 135, 255) / 255.0,\n    vec4(243, 139, 168, 255) / 255.0,\n    vec4(203, 166, 247, 255) / 255.0\n    #elif defined(FRAPPE)\n    vec4(140, 170, 238, 255) / 255.0, // Blue\n    vec4(129, 200, 190, 255) / 255.0, // Teal\n    vec4(166, 209, 137, 255) / 255.0, // Green\n    vec4(239, 159, 118, 255) / 255.0, // Peach\n    vec4(231, 130, 132, 255) / 255.0, // Red\n    vec4(202, 158, 230, 255) / 255.0  // Mauve\n    #elif defined(LATTE)\n    vec4(30, 102, 245, 255) / 255.0, // Blue\n    vec4(23, 146, 153, 255) / 255.0, // Teal\n    vec4(64, 160, 43, 255) / 255.0, // Green\n    vec4(254, 100, 11, 255) / 255.0, // Peach\n    vec4(210, 15, 57, 255) / 255.0, // Red\n    vec4(136, 57, 239, 255) / 255.0  // Mauve\n    #elif defined(GAY)\n    vec4(228, 3, 3, 255) / 255.0,\n    vec4(255, 140, 0, 255) / 255.0,\n    vec4(255, 237, 0, 255) / 255.0,\n    vec4(0, 128, 38, 255) / 255.0,\n    vec4(0, 77, 255, 255) / 255.0,\n    vec4(117, 7, 135, 255) / 255.0\n    #elif defined(TRANS)\n    vec4(91, 206, 250, 255) / 255.0,\n    vec4(245, 169, 184, 255) / 255.0,\n    vec4(1),\n    vec4(245, 169, 184, 255) / 255.0,\n    vec4(91, 206, 250, 255) / 255.0\n    #elif defined(BI)\n    vec4(214, 2, 112, 255) / 255.0,\n    vec4(214, 2, 112, 255) / 255.0,\n    vec4(155, 79, 150, 255) / 255.0,\n    vec4(0, 56, 168, 255) / 255.0,\n    vec4(0, 56, 168, 255) / 255.0\n    #endif\n);\n\nconst vec4 bg = vec4(\n    #if defined(MACCHIATO)\n    36, 39, 58\n    #elif defined(MOCHA)\n    30, 30, 46\n    #elif defined(FRAPPE)\n    48, 52, 70\n    #elif defined(LATTE)\n    239, 241, 245\n    #else\n    0,0,0\n    #endif\n    ,255\n) / 255.0;\n\n// https://math.stackexchange.com/questions/1641859/distance-function-for-n-prism\nfloat nGon(in int n, in vec2 p, in float r) {\n    // these 2 lines can be precomputed\n    float an = TAU / float(n);\n    float he = r * tan(0.5 * an);\n\n    // rotate to first sector\n    p = -p.yx; // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // side of polygon\n    return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x-r);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / iResolution.y;\n    vec2 ouv = uv;\n    float mr = max(iResolution.x / iResolution.y, iResolution.y / iResolution.x);\n    fragColor = bg;\n    float mult = 1.0;\n    for(int i = 0; i < (REPEAT ? NUM_SHAPES * 2 : NUM_SHAPES); i++) {\n        float percent = float(i + 1) / float(NUM_SHAPES);\n        // Ideally we would start i at the minimum possible radius that the pixel could be intersecting with, but quite frankly I have no idea how to do that.\n        // I would probably either need to assume that every polygon has an internal radius of a triangle, or implement a seperate function to calculate the inner radius\n        // of an ngon-- I really don't feel like doing that. I might come back to this later and fix it, but for now this runs at ~60fps on my slow laptop @ 1440p, so\n        // I'm happy :D\n        #ifndef MUSIC\n        // Because of the variable radius' from MUSIC, it's easier to just skip this optimization if music is turned on\n        if(distance(ouv, vec2(0)) < percent * mr - SHAPE_WIDTH - 3.0 / iResolution.y * 2.0) continue;\n        #endif\n        float offset = float(ROT_OFFSET) * float(i);\n        #ifdef MULTICOLOR_SHAPES\n        offset = float(ROT_OFFSET) * floor(float(i) / float(colors.length()));\n        #endif\n        #ifdef TIME_BOUNDS\n        uv = rotate(ouv, (sin((mod(iTime, TIME_BOUNDS * 2.0) - TIME_BOUNDS) / TIME_BOUNDS * PI) * ROT_SCALE * (offset + START_ROT)));\n        #else\n        uv = rotate(ouv, (iTime * ROT_SCALE * (offset + START_ROT)));\n        #endif\n        float r = percent * mr;\n        float r2 = percent * mr;\n        #ifdef USE_MUSIC\n        float xp = float(i % NUM_SHAPES) / float(NUM_SHAPES);\n        r -= 0.5 * (1.0 / float(SIDES / 2));\n        r2 -= 0.5 * (1.0 / float(SIDES / 2));\n        r += texture(iChannel1, vec2(xp, 0)).r * (1.0 / float(NUM_SHAPES)) * float(SIDES / 2);\n        r2 += texture(iChannel1, vec2(xp, 0)).r * (1.0 / float(NUM_SHAPES)) * float(SIDES / 2);\n        #endif\n        r2 -= SHAPE_WIDTH;\n        float avgR = r2 + SHAPE_WIDTH / 2.0;\n        #ifdef AA\n        float pm = mult;\n        float m = smoothstep(SHAPE_WIDTH / 2.0 + 3.0 / iResolution.y, SHAPE_WIDTH / 2.0, abs(nGon(SIDES, uv, avgR)));\n        if(m >= 0.0) {\n            fragColor = (1.0 - mult * m) * fragColor + colors[((i) % colors.length())] * mult * m;\n            mult -= m;\n        }\n        if(mult <= 0.0) return;\n        #else\n        if(abs(nGon(SIDES, uv, avgR)) <= SHAPE_WIDTH / 2.0) {\n            fragColor = colors[((i) % colors.length())];\n            return;\n        }\n        #endif\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3522, 3604, 3649, 3689, 4070], [4072, 4072, 4102, 4102, 4186], [4188, 4188, 4245, 4245, 6856]], "test": "untested"}
{"id": "DdVSzR", "name": "RetroVision (Revision 2023)", "author": "dean_the_coder", "description": "Based on my entry for the 4Kb Executable Graphics compo at Revision 2023.\n(Some changes made to improve performance.)\nhttps://demozoo.org/graphics/322475/", "tags": ["3d", "reflection", "raymarch", "camera", "glass", "wood", "antique"], "likes": 92, "viewed": 6187, "published": 3, "date": "1681055350", "time_retrieved": "2024-07-30T18:01:24.254309", "image_code": "// 'RetroVision' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/DdVSzR\n// https://demozoo.org/graphics/322475/\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Based on my entry for the 4Kb Executable Graphics compo at Revision 2023.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t.0002\n#define START_DIST\t1.0\n#define MAX_STEPS\t100.\n#define MAX_RDIST\t5.\n#define MAX_RSTEPS\t32.\n#define SHADOW_STEPS\t20.0\n\n#define LIGHT_RGB\tvec3(2, 1.32, 1.16)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0.0, 1.0, a)\n\nbool hitGlass;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat dot3(vec3 v) { return dot(v, v); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\n///////////////////////////////////////////////////////////////////////////////\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// roughness: (0.0, 1.0], default: 0.5\n// Returns unsigned noise [0.0, 1.0]\nfloat fbm(vec3 p, int octaves, float roughness) {\n\tfloat sum = 0.0,\n\t      amp = 1.,\n\t      tot = 0.0;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.0;\n\t}\n\treturn sum / tot;\n}\n\nvec3 randomPos(float seed) {\n\tvec4 s = vec4(seed, 0, 1, 2);\n\treturn vec3(h21(s.xy), h21(s.xz), h21(s.xw)) * 100.0 + 100.;\n}\n\n// Returns unsigned noise [0.0, 1.0]\nfloat fbmDistorted(vec3 p, int octaves, float roughness, float distortion) {\n\tp += (vec3(n31(p + randomPos(0.0)), n31(p + randomPos(1.0)), n31(p + randomPos(2.0))) * 2. - 1.) * distortion;\n\treturn fbm(p, octaves, roughness);\n}\n\n// vec3: detail(/octaves), dimension(/inverse contrast), lacunarity\n// Returns signed noise.\nfloat musgraveFbm(vec3 p, float octaves, float dimension, float lacunarity) {\n\tfloat sum = 0.0,\n\t      amp = 1.0;\n\tfloat pwMul = pow(lacunarity, -dimension);\n\twhile (octaves-- > 0.0) {\n\t\tfloat n = n31(p) * 2. - 1.;\n\t\tsum += n * amp;\n\t\tamp *= pwMul;\n\t\tp *= lacunarity;\n\t}\n\treturn sum;\n}\n\n// Wave noise along X axis.\nvec3 waveFbmX(vec3 p, float distort, int detail, float detailScale, float roughness) {\n\tfloat n = p.x * 20.0;\n\tn += distort != 0.0 ? distort * fbm(p * detailScale, detail, roughness) : 0.0;\n\treturn vec3(sin(n) * 0.5 + 0.5, p.yz);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Math\n// Smooth min()\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat remap01(float f, float in1, float in2) { return sat((f - in1) / (in2 - in1)); }\n\n///////////////////////////////////////////////////////////////////////////////\n// Space manipulation.\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 dx(vec3 p, float e) {\n\tp.x += e;\n\treturn p;\n}\n\nvec3 dy(vec3 p, float e) {\n\tp.y += e;\n\treturn p;\n}\n\nvec3 dz(vec3 p, float e) {\n\tp.z += e;\n\treturn p;\n}\n\n// Return abs(p.x) with offset.\nvec3 ax(vec3 p, float d) { return vec3(abs(p.x) - d, p.yz); }\n\n// Return abs(p.y) with offset.\nvec3 ay(vec3 p, float d) { return vec3(p.x, abs(p.y) - d, p.z); }\n\n// Return abs(p.z) with offset.\nvec3 az(vec3 p, float d) { return vec3(p.xy, abs(p.z) - d); }\n\n// Polar/circular repeat.\nvec3 opModPolar(vec3 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.x, p.y) + angle + o, 2. * angle) - angle;\n\tp.xy = length(p.xy) * vec2(cos(a), sin(a));\n\treturn p;\n}\n\n// Convert 2D sdf into 3D sdf.\nfloat insulate(vec3 p, float sdf2d) {\n\tfloat dp = p.x; // distance to plane\n\treturn sqrt(dp * dp + sdf2d * sdf2d);\n}\n\n// Bend space along the x axis.\nvec3 bend(vec3 p, float k) {\n\tfloat c = cos(k * p.x);\n\tfloat s = sin(k * p.x);\n\tp.xy *= mat2(c, s, -s, c);\n\treturn p;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// SDFs\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xy) - t.x, p.z);\n\treturn length(q) - t.y;\n}\n\nfloat arc(vec3 p, float l, float a) {\n\tvec2 sc = vec2(sin(a), cos(a));\n\tfloat ra = 0.5 * l / a;\n\tp.x -= ra;\n\tvec2 q = p.xy - 2.0 * sc * max(0.0, dot(sc, p.xy));\n\tfloat u = abs(ra) - length(q);\n\tfloat d2 = (q.y < 0.0) ? dot(q + vec2(ra, 0.0), q + vec2(ra, 0.0)) : u * u;\n\tfloat s = sign(a);\n\treturn sqrt(d2 + p.z * p.z);\n}\n\nfloat hex3D(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.8660254, .5, .57735);\n\tp = abs(p);\n\tp.zy -= 2. * min(dot(k.xy, p.zy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.zy - vec2(clamp(p.z, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.x - h.y);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Environment/textures/materials.\nvec3 skyCol(float y) {\n    return pow(vec3(max(1.0 - y * 0.5, 0.0)), vec3(6, 3, 1.5)) * vec3(1, 0.7, 0.6);\n}\n\n// Sky with clouds.\nvec3 sky(vec3 rd) {\n\treturn skyCol(rd.y);\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * 0.5 + 0.5) * 0.8;\n}\n\n// Wood material. Returns rgb, depth\nvec4 matWood(vec3 p) {\n\tfloat n1 = fbmDistorted(p * vec3(1, .15, .15) * 8., 8, .5, 1.12);\n\tn1 = mix(n1, 1., 0.2);\n\tfloat n2 = musgraveFbm(vec3(n1 * 4.6), 8., 0., 2.5);\n\tfloat n3 = mix(n2, n1, 0.85);\n\tvec3 q = waveFbmX(p * vec3(0.01, .15, .15), .4, 3, 3., 3.);\n\tfloat dirt = 1. - musgraveFbm(q, 15., 0.26, 2.4) * .4;\n\tfloat grain = 1. - S(0.2, 1.0, musgraveFbm(p * vec3(500, 6, 1), 2., 2., 2.5)) * 0.2;\n\tn3 *= dirt * grain;\n\tvec3 c1 = vec3(.032, .012, .004);\n\tvec3 c2 = vec3(.25, .11, .037);\n\tvec3 c3 = vec3(.52, .32, .19);\n\tfloat depth = grain * n3;\n\tvec3 col = mix(c1, c2, remap01(n3, 0.185, 0.565));\n\tcol = mix(col, c3, remap01(n3, 0.565, 1.));\n\treturn vec4(col, depth);\n}\n\n#define SKY_ID\t0\n#define PLANK_ID\t1\n#define CAM_WOOD_ID\t2\n#define LEATHER_ID\t3\n#define LENS_COLOR_BACK_ID\t4\n#define BELOW_ARE_REFLECTIVE\t5\n#define BRASS_ID\t6\n#define DARKER_BRASS_ID\t7\n#define GLASS_ID\t8\n#define INLAY_ID\t9\n\nfloat screw(vec3 p) {\n\tp.xy *= rot(0.6);\n\treturn cyl(p, vec2(.02, 0.01 * S(0.001, 0.003, abs(p.x))));\n}\n\nfloat nutCap(vec3 p) { return min(cap(p, .02, .015), hex3D(p, vec2(.02))); }\n\nfloat knob(vec3 p, float r, float w) {\n\tp.z = abs(p.z + w);\n\tfloat l = length(p.xy),\n\t      a = atan(p.y, p.x);\n\tfloat d = l - r;\n\td += S(0.8, 1., sin(a * 400. * r)) * 0.002 * S(1.5, 0.5, p.z / w);\n\tp.z -= w;\n\td = smin(d, p.z, -0.01);\n\tr *= 0.7;\n\td = min(d, tor(p, vec2(r, r * 0.1)));\n\tp.z -= w * 3.;\n\td = smin(min(d, l - r), p.z, -0.01);\n\tr *= .85;\n\td = smin(d, tor(p, vec2(r, r * 0.05)), 0.01);\n\treturn min(d, length(p) - r * 0.2);\n}\n\nfloat s(vec3 p) {\n\tp = dy(dx(p.zyx, .04), .08);\n\tp.xy *= rot(-0.4);\n\tp.y = p.x < 1.0 ? p.y : -p.y;\n\tp.x = abs(p.x);\n\tp.xy *= rot(-0.707);\n\treturn arc(p, .18, 0.85);\n}\n\nHit sdf(vec3 p) {\n\tp.y -= 0.1;\n\n\t// Planks.\n\tvec3 q = p + vec3(0, 1.5, 0), v3;\n\tq.xz *= rot(0.15);\n\tfloat f = floor(q.x);\n\tq.x = fract(q.x) - 0.5;\n\tq = bend(q, .1 * n31(p * .5));\n\tfloat d = box(q, vec3(0.485, .5, 99));\n    q = p * .016;\n    q.z += f;\n\n\tHit h = Hit(d, PLANK_ID, q);\n\n\t// Camera front box.\n\tp.y += 0.15;\n\tf = .85 - step(0.0, p.y) * (1. - cos(p.z)) * 0.6;\n\tv3 = vec3(0.45, f, 0.64);\n\td = box(p, v3 - .044) - .044;\n\tq = dx(p, -0.83);\n\td = smin(d, -box(q, v3 - 0.06), -0.1);\n\tU(h, d * 0.95, CAM_WOOD_ID, p);\n\n\t// Front box top brass pattern.\n\td = box2d(p.xz, vec2(.23, .5));\n\td = max(d, .17 - length(az(ax(p, .24), .52).xz));\n\td = abs(d) - 0.005;\n\tf = p.y - f - 0.01;\n\td = smin(d, f, -0.01);\n\tf -= abs(sin(atan(p.z, p.x) * 14.)) * 0.006 * S(.07, .09, length(p.xz));\n\td = min(d, box2d(p.xz, vec2(0.07, .28)) - 0.03);\n\td = smin(d, f, -0.005);\n\tU(h, d, BRASS_ID, p);\n\n\t// Front box inlay.\n\tq.x += .78;\n\td = box(q, v3 - 0.08) - 0.02;\n\tU(h, d * 0.94, INLAY_ID, p);\n\n\t// Front box nuts.\n\tv3 = dx(q, -.41);\n\tv3 = az(ay(v3, .65), .53);\n\tv3.yz *= rot(0.5);\n\td = nutCap(v3);\n\td = min(d, s(dx(v3, .017)));\n\tU(h, d, BRASS_ID, p);\n\n\t// Camera back box.\n\tq.zxy = bend(p.zxy, 0.2);\n\tq.x += 0.7;\n\tv3 = vec3(0.2405, .9, 0.6505);\n\td = smin(box(q, v3) - .02, box(q, vec3(.18, .98, .46)), .025);\n\td -= S(0., 1., abs(f)) * 0.001;\n\tU(h, d, LEATHER_ID, q);\n\n\t// Back box dials.\n\tq.y -= .885;\n\td = box(ay(q, 0.014), vec3(0.265, -.002, .675));\n\td = min(d, knob(p.xzy + vec3(.65, .38, -1.025), .1, .01));\n\n\t// Strap bolt.\n\td = min(d, cyl(p + vec3(.5, -.73, 0), vec2(.04 - 0.008 * S(0., 0.02, p.z + .82), .85)));\n\n\t// Side focus wheel.\n\td = min(d, knob(dz(p - vec3(.05, -.1, 0), .67), .25, .01));\n\tU(h, d, BRASS_ID, p);\n\n\t// Main lens barrel.\n\tq = dy(ax(p, 0.), 0.2);\n\tfloat l = length(q.yz);\n\tf = S(.0, .01, p.x - .62);\n\tf -= S(.06, 0., abs(p.x - .69)) * 0.2 * abs(sin(atan(q.y, q.z) * 60.));\n\td = max(l - .3 + 0.01 * f, .23 - l);\n\td = max(d, q.x - .75);\n\tU(h, d, DARKER_BRASS_ID, p);\n\tq.x -= .756;\n\td = min(d, tor(q.zyx, vec2(.21 + 0.096 * step(.25, l), 0)));\n\tU(h, d, BRASS_ID, p);\n\n\t// Lens inside.\n\td = max(l - .2, .15 - l);\n\td = max(d, q.x + 0.16);\n\tU(h, d, DARKER_BRASS_ID, p);\n\td = min(d, q.x + .2);\n\td = max(d, l - .25);\n\tU(h, d, LENS_COLOR_BACK_ID, p);\n\n\t// Lens screws.\n\td = screw(dx(opModPolar(q.zyx, 6., .3), -0.255)) + 0.012;\n\tU(h, d, BRASS_ID, p);\n\n\t// Lens.\n\tif (!hitGlass) {\n\t\tq = dx(q, 1.04);\n\t\td = max(length(q) - 1., l - .21);\n\t\tU(h, d, GLASS_ID, q);\n\t}\n\n\t// Main lens brass surround.\n\tq = dy(dx(p, -0.466), 0.2);\n\tv3 = q;\n\tl = length(q.yz);\n\td = l - .44;\n\tfloat a = atan(q.y, q.z);\n\tf = tor(q.zyx, vec2(.3, 0.03 - 0.0005 * abs(sin(a * 50.)))); // Weld ring.\n\tq = ay(az(q, .3), .3);\n\td = min(d, length(q.yz) - 0.1);\n\tf = min(f, max(insulate(q, d) - 0.008, abs(q.x) - 0.006));\n\ta = sin(a * 8.) * 0.015;\n\tl -= .39;\n\tf = min(f, insulate(v3, abs(l) - abs(a)) - 0.0011); // Intertwines.\n\tf = min(f, nutCap(q - .03));\n\tU(h, f, BRASS_ID, p);\n\td = max(d + 0.01, abs(q.x) - 0.0005);\n\tU(h, d, DARKER_BRASS_ID, p);\n\n\t// View lens barrel.\n\tq = dy(dx(p.zyx, .26), -.5);\n\tl = length(q.xy);\n\td = abs(l - .13) + .005;\n\td = max(d, abs(q.z) - .6);\n\tU(h, d, BRASS_ID, p);\n\td = max(l - .11, abs(q.z) - .46);\n\tU(h, d, LENS_COLOR_BACK_ID, q);\n\tif (!hitGlass) {\n\t\td = max(length(q) - .56, l - .115);\n\t\tU(h, d, GLASS_ID, q);\n\t}\n\n\th.d -= 0.01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 lp, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.0;\n\tfloat s = 1.,\n\t      t = .002, d;\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = sdf(t * ld + p).d;\n\t\ts = min(s, 2.5 * d / t); // tweak sharpness.\n\t\tt += max(0.01, d);\n\t\tif (s < 0.01) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n, vec2 h) {\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(min2(ao / h));\n}\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld, float h) { return S01(sdf(h * ld + p).d / h); }\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, Hit h) {\n\tif (h.id == SKY_ID) return sky(rd);\n\tvec3 lp = vec3(6, 6, 7),\n\t     ld = normalize(lp - p),\n\t     c = vec3(0.06);\n\tfloat spe = 10.0,\n\t      shine = 3.;\n\n\tif (h.id == PLANK_ID) {\n        vec4 m = matWood(h.p * 3.2);\n\t\tc = m.rgb * 0.3;\n        n += (m.w - 0.5) * 0.15;\n\t\tspe = 10.;\n\t}\n\telse {\n        float g = musgraveFbm(p * vec3(700, 70, 70), 2., 1.0, .5);\n        if (h.id == CAM_WOOD_ID) {\n            c = vec3(0.15, .1, .1);\n            n += g * 0.015;\n            shine = 5.;\n            spe = 33.;\n        } else if (h.id == INLAY_ID) {\n            c = vec3(0.7, .7, .6);\n            n += g * 0.01;\n            shine = 1.;\n        }\n        else {\n            if (h.id == BRASS_ID) \n                c = vec3(0.7, 0.6, 0.2);\n            else if (h.id == DARKER_BRASS_ID)\n                c = vec3(0.35, 0.3, 0.1);\n            else shine = 1.;\n            c *= .7 + .3 * n31(p * vec3(300, 25, 25));\n        }\n    }\n\n\tvec3 l = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n    \n\tl *= fakeEnv(ld * 8.);\n\tl.xy = 0.1 + 0.9 * l.xy; // Diffuse.\n\tl.yz *= 0.1 + 0.9 * ao(p, n, vec2(.2, 1)); // Ambient occlusion.\n\tl *= vec3(1., .03, .3); // Light contributions (key, reverse, sky).\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine; // Specular (Blinn-Phong)\n    l.x *= 0.3 + 0.7 * S(3.5, 1.8, length(p.xz));\n\tl.x *= 0.05 + 0.95 * shadow(p, lp, ld, n); // Shadow.\n    l.x *= 0.2 + 0.8 * S(2.8, 2., length(p.xz)); // Spotlight.\n\tl.x *= dot(lp, lp) / (5. + dot(lp - p, lp - p)); // Light falloff\n\tfloat fre = S(.7, 1., 1. + dot(rd, n)) * 0.02;\n\tvec3 sky = skyCol(1.0);\n\tvec3 col = mix((sum2(l.xy) * LIGHT_RGB + l.z * sky) * c, sky, fre);\n\n\t// Distance Fog.\n\tfloat fg = 1.0 - exp(dot3(p - ro) * -0.001);\n\n\treturn mix(vec3(.06, .04, .04), col, 1.0 - sat(fg));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// March the scene.\n\tvec3 p = ro;\n\tfloat d = START_DIST, i;\n\tHit h;\n\tvec3 n,\n\t     col = vec3(0),\n\t     glassP = col, glassN;\n\thitGlass = false;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\th = sdf(p);\n\t\tif (abs(h.d) < MIN_DIST * d) {\n\t\t\tif (!hitGlass && h.id == GLASS_ID) {\n\t\t\t\thitGlass = true;\n\t\t\t\tglassP = p;\n\t\t\t\tglassN = normalize(h.p);\n\t\t\t\tvec3 v = normalize(refract(rd, glassN, .65));\n\t\t\t\tp += v * min(sdf(p + v * .02).d, .02);\n\t\t\t\tcol += 0.003;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tcol += lights(p, ro, rd, n = N(p, d), h);\n\tif (h.id > BELOW_ARE_REFLECTIVE || hitGlass) {\n\t\tif (hitGlass) {\n\t\t\tp = glassP;\n\t\t\tn = glassN;\n\t\t\tcol += vec3(10, 7, 10) * 100. * pow(sat(dot(normalize(vec3(8.86, 4, 8) - rd), n)), 50.);\n\t\t\tcol += vec3(1, 1, 2.5) * .02 * S(0., .01, pow(sat(dot(normalize(vec3(8.86, 4.38, 10) - rd), n)), 35.) * 200.);\n\t\t\tcol += vec3(10, 7, 10) * 50. * pow(sat(dot(normalize(vec3(8.86, -4, -7) - rd), n)), 50.);\n\t\t}\n\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * 0.01;\n\t\tro = p;\n\t\td = 0.01;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol = col + (1. - col) * 0.03 * lights(p, ro, rd, N(p, d), h);\n\t}\n\n\treturn pow(max(vec3(0), col), vec3(0.45));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 ro = vec3(1.85 + sin(iTime * 0.2) * 0.2, 1.3, -1.2);\n\tvec3 col = march(ro, rayDir(ro, uv));\n\n    // Vignette.\n\tcol *= 1.0 - 0.5 * dot(uv, uv);\n\t\n\t// Grain\n\tcol += (h21(fc) - 0.5) / 50.;\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVSzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1003, 1003, 1049, 1049, 1083], [1085, 1085, 1105, 1105, 1129], [1131, 1131, 1151, 1151, 1175], [1177, 1177, 1197, 1197, 1231], [1233, 1233, 1253, 1253, 1273], [1275, 1275, 1295, 1295, 1321], [1323, 1403, 1423, 1423, 1520], [1522, 1522, 1541, 1541, 1562], [1564, 1564, 1583, 1640, 1924], [1926, 2002, 2051, 2051, 2251], [2253, 2253, 2281, 2281, 2376], [2378, 2415, 2491, 2491, 2641], [2643, 2736, 2813, 2813, 3021], [3023, 3051, 3137, 3137, 3282], [3284, 3388, 3427, 3427, 3509], [3511, 3511, 3557, 3557, 3596], [3598, 3701, 3720, 3720, 3787], [3789, 3789, 3815, 3815, 3839], [3841, 3841, 3867, 3867, 3891], [3893, 3893, 3919, 3919, 3943], [3945, 3977, 4003, 4003, 4038], [4040, 4072, 4098, 4098, 4137], [4139, 4171, 4197, 4197, 4232], [4234, 4260, 4303, 4303, 4451], [4453, 4484, 4521, 4521, 4600], [4602, 4634, 4662, 4662, 4753], [4755, 4843, 4870, 4870, 4941], [4943, 4943, 4972, 4972, 5043], [5045, 5045, 5073, 5073, 5173], [5175, 5175, 5212, 5212, 5264], [5266, 5266, 5293, 5293, 5361], [5363, 5363, 5400, 5400, 5684], [5686, 5686, 5715, 5715, 5975], [5977, 5977, 6008, 6008, 6136], [6138, 6253, 6275, 6275, 6361], [6363, 6383, 6402, 6402, 6426], [6428, 6428, 6451, 6471, 6521], [6523, 6560, 6582, 6582, 7234], [7459, 7459, 7480, 7480, 7562], [7564, 7564, 7586, 7586, 7640], [7642, 7642, 7680, 7680, 8077], [8079, 8079, 8096, 8096, 8245], [8247, 8247, 8264, 8264, 11583], [11585, 11585, 11610, 11610, 11817], [11819, 11819, 11867, 11914, 12167], [12169, 12205, 12239, 12239, 12340], [12342, 12386, 12423, 12423, 12460], [12462, 12462, 12516, 12516, 14331], [14333, 14333, 14363, 14384, 15783], [15785, 15785, 15830, 15830, 16086]], "test": "untested"}
{"id": "ddKXWh", "name": "Wallpaper Pink Void", "author": "iVader", "description": "black soap hole", "tags": ["fbm", "portal", "soap"], "likes": 6, "viewed": 366, "published": 3, "date": "1681054369", "time_retrieved": "2024-07-30T18:01:25.094064", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * .2;\n    \n    vec2 uv = ( fragCoord * 0.25 ) / iResolution.y;\n    vec2 st = vec2(\n        length( uv ) * 1.5,\n        atan( uv.y, uv.x )\n    );\n    \n    st.y += st.x * 1.1;\n        \n    float x = fbm3d(\n        vec3(\n            sin( st.y ),\n            cos( st.y ),\n            pow( st.x, .3 ) + t * .1\n        ),\n        3\n    );\n\tfloat y = fbm3d(\n        vec3(\n            cos( 1. - st.y ),\n            sin( 1. - st.y ),\n            pow( st.x, .5 ) + t * .1\n        ),\n        4\n    );\n    \n    float r = fbm3d(\n        vec3(\n            x,\n            y,\n            st.x + t * .3\n        ),\n        5\n    );\n    r = fbm3d(\n        vec3(\n            r - x,\n            r - y,\n            r + t * .3\n        ),\n        6\n    );\n    \n    float c = ( r + st.x * 5. ) / 6.;\n    \n    fragColor = vec4(\n        smoothstep( .3, .4, c ),\n        smoothstep( .4, .55, c ),\n        smoothstep( .2, .55, c ),\n        1.0\n    );\n}", "image_inputs": [], "common_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define HALF_PI 1.57079632679\n\n\n// FBM implementation from\n// https://github.com/MaxBittker/glsl-fractal-brownian-noise\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nfloat fbm3d(vec3 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n\n    \n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * snoise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddKXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1001]], "test": "untested"}
{"id": "clf3DX", "name": "Spectral Cornell Box MIS + HWSS", "author": "gelami", "description": "Spectral Cornell box path tracing with NEE/MIS and basic HWSS\nHas depth of field with 3 bokeh shapes to choose from\nAlso added basic glossy and transmission, change SCENE to 1 in Common to show\n\nClick and drag to move camera", "tags": ["3d", "raytracing", "box", "mis", "cornell", "wavelength", "spectral", "hero", "hwss"], "likes": 26, "viewed": 687, "published": 3, "date": "1681040338", "time_retrieved": "2024-07-30T18:01:26.041531", "image_code": "// Fork of \"Cornell Box MIS\" by gelami. https://shadertoy.com/view/dtlGD2\n// 2022-12-31 17:16:06\n\n// Spectral Cornell Box MIS + HWSS\n// https://www.shadertoy.com/view/clf3DX\n\n/*\n * Spectral Cornell box path tracing with NEE/MIS and basic HWSS\n * \n * Has depth of field with 3 bokeh shapes to choose from\n * Also added basic glossy and transmission, change SCENE to 1 in Common to show\n *\n * Click and drag to move camera\n * Defines in Common\n *\n * Surface reflectances are curve fit from the original data\n * since reading directly from the array was slow\n * Ideally you could also store it in a buffer instead\n * \n * Previous version (RGB):\n * Cornell Box MIS - gelami\n * https://www.shadertoy.com/view/dtlGD2\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n        col = texelFetch(iChannel0, ivec2(1, 0), 0).rgb;\n    \n    col *= exp2(EXPOSURE);\n    col = wavelengthXYZtoRGB(col);\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n// Scene\n// 0 : Cornell Box\n// 1 : Cornell Box +\n#define SCENE 0\n\n#define BOUNCES 6\n#define EXPOSURE 3.0\n\n#define DOF\n// Shape type of depth of field\n// 0 : Circle\n// 1 : Polygon\n// 2 : Star\n#define DOF_TYPE 1\n\n#define DOF_SIDES 5\n#define DOF_STRENGTH 0.05\n#define DOF_FOCUS_DISTANCE 0.35\n\n#define USE_CURVE_FIT_SURFACE_REFLECTANCES\n\n// Illuminant\n// 0 : Cornell box light\n// 1 : D65\n#define ILLUMINANT 0\n\n//#define STATIC_CAM\n//#define NO_ACCUMULATE\n\n#define SKYBOX\n#define SKYBOX_STRENGTH 0.2\n\n#define MAX_DIST 100.\n#define EPSILON 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec4 wv;\n};\n\nstruct Material\n{\n    vec4 color;\n    vec4 emissive;\n    float roughness;\n    float transmission;\n    float ior;\n};\n\nstruct HitInfo\n{\n    float t;\n    vec3 normal;\n    bool inside;\n};\n\n// Ray-Box Intersection\n// https://iquilezles.org/articles/intersectors/\n\nbool boxIntersect( Ray ray, vec3 boxSize, inout HitInfo hit ) \n{\n    vec3 m = 1.0 / ray.direction;\n    vec3 n = m * ray.origin;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    \n    if( tN > tF || tF < 0.0) return false;\n    \n    bool inside = false;\n    vec3 normal;\n    if (tN < 0.0)\n    {\n        tN = tF;\n        normal = -sign(ray.direction)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n        inside = true;\n    } else {\n        normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    }\n    \n    if (tN < hit.t)\n    {\n        hit.t = tN;\n        hit.normal = normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\nbool boxIntersectInsideZ( Ray ray, vec3 boxSize, inout HitInfo hit ) \n{\n    vec3 m = 1.0 / ray.direction;\n    vec3 n = m * ray.origin;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    \n    if( tN > tF || tF < 0.0) return false;\n    \n    vec3 normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    if (tN < 0.0 || normal.z > 0.0)\n    {\n        normal = -sign(ray.direction)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);;\n        if (normal.z < 0.0) return false;\n        tN = tF;\n    }\n    \n    if (tN < hit.t)\n    {\n        hit.t = tN;\n        hit.normal = normal;\n        hit.inside = false;\n        return true;\n    }\n    return false;\n}\n\nbool sphereIntersect(Ray ray, vec3 center, float radius, inout HitInfo hit)\n{\n    vec3 oc = ray.origin - center;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - radius * radius;\n    float h = b*b - c;\n    if( h < 0.0 || b > 0.0) return false;\n    h = sqrt( h );\n    vec2 t = vec2(-b-h, -b+h );\n    \n    bool inside = false;\n    if (t.x < 0.0)\n    {\n        t.x = t.y;\n        inside = true;\n    }\n    \n    if (t.x < hit.t)\n    {\n        hit.t = t.x;\n        hit.normal = normalize(ray.origin - center + ray.direction * hit.t);\n        if (inside) hit.normal = -hit.normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\n\n\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\n\nvec2 sqr(vec2 x) { return x*x; }\n\nvec3 sqr(vec3 x) { return x*x; }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n    vec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(vec2(s),coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\n// Random point in circle\n// Very straightforward, unit circle scaled by sqrt of the radius\nvec2 randomPointInCircle()\n{\n    vec2 rand = hash2(state);\n    \n    float a = rand.x * TAU;\n    float r = sqrt(rand.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Random point in polygon\n// Pick a random side and\n// generate a point in a rhombus (equal quadrilateral),\n// and fold it if the point is outside the inner triangle\nvec2 randomPointInPolygon(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    vec2 p1 = s1 * rand.y + s2 * rand.z;\n    vec2 p2 = s1 * (1.0 - rand.y) + s2 * (1.0 - rand.z);\n    \n    return rand.y + rand.z > 1.0 ? p2 : p1;\n}\n\n// Random point in star\n// Same as the random point in polygon,\n// but without folding the rhombus into a triangle\nvec2 randomPointInStar(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    \n    return s1 * rand.y + s2 * rand.z;\n}\n\n// Random unit vector\n// Generate a random unit circle and scaled the z with a circular mapping\nvec3 randomUnitVector()\n{\n    vec2 rand = hash2(state);\n    rand.y = rand.y*2.-1.;\n    rand.x *= PI*2.;\n    \n    float r = sqrt(1. - rand.y*rand.y);\n    vec2 xy = vec2(cos(rand.x), sin(rand.x)) * r;\n    \n    return vec3(xy, rand.y);\n}\n\n// Random cosine-weighted unit vector on a hemisphere\n// Unit vector + random unit vector\nvec3 randomCosineHemisphere(vec3 n)\n{\n    return normalize(randomUnitVector() + n);\n}\n\nvec4 generateWavelengths()\n{\n    float x = hash(state);\n    return 400.0 + 300.0 * fract(x + vec4(0.0, 0.25, 0.5, 0.75));\n}\n\n// Curve fit surface reflectances based on the data\n// from the Cornell Box Data site\n// http://www.graphics.cornell.edu/online/box/data.html\nfloat getSurfaceReflectanceWhite(float wv)\n{\n    float x = wv;\n    return -408.105\n            + x * (3.70066\n            + x * (-0.0133045\n            + x * (0.0000237522\n            + x * (-2.10608*1e-8 \n            + 7.4214*1e-12 * x ))));\n}\n\nfloat getSurfaceReflectanceGreen(float wv)\n{\n    float x = wv;\n    return 538.481\n            + x * (-4.86156\n            + x * (0.017303\n            + x * (-0.0000303503\n            + x * (2.62543*1e-8 \n            + -8.96752*1e-12 * x ))));\n}\n\nfloat getSurfaceReflectanceRed(float wv)\n{\n    float x = wv;\n    return 126.229\n            + x * (-1.38886\n            + x * (0.0059851\n            + x * (-0.0000126345\n            + x * (1.30701*1e-8 \n            + -5.29943*1e-12 * x ))));\n}\n\nvec3 getSurfaceReflectanceCurveFit(float wv)\n{\n    wv = clamp(wv, 400.0, 700.0);\n    return vec3(\n        getSurfaceReflectanceWhite(wv),\n        getSurfaceReflectanceGreen(wv),\n        getSurfaceReflectanceRed(wv));\n}\n\nvec4 getSurfaceReflectanceWhite(vec4 wv)\n{\n    vec4 x = wv;\n    return -408.105\n            + x * (3.70066\n            + x * (-0.0133045\n            + x * (0.0000237522\n            + x * (-2.10608*1e-8 \n            + 7.4214*1e-12 * x ))));\n}\n\nvec4 getSurfaceReflectanceGreen(vec4 wv)\n{\n    vec4 x = wv;\n    return 538.481\n            + x * (-4.86156\n            + x * (0.017303\n            + x * (-0.0000303503\n            + x * (2.62543*1e-8 \n            + -8.96752*1e-12 * x ))));\n}\n\nvec4 getSurfaceReflectanceRed(vec4 wv)\n{\n    vec4 x = wv;\n    return 126.229\n            + x * (-1.38886\n            + x * (0.0059851\n            + x * (-0.0000126345\n            + x * (1.30701*1e-8 \n            + -5.29943*1e-12 * x ))));\n}\n\nmat3x4 getSurfaceReflectanceCurveFit(vec4 wv)\n{\n    wv = clamp(wv, 400.0, 700.0);\n    return mat3x4(\n        getSurfaceReflectanceWhite(wv),\n        getSurfaceReflectanceGreen(wv),\n        getSurfaceReflectanceRed(wv));\n}\n\n// Surface reflectances from data\n// http://www.graphics.cornell.edu/online/box/data.html\n// Returns white, red, and green\nvec3 getSurfaceReflectance(float wv)\n{\n    const vec3[76] surfaceReflectances = vec3[](\n        vec3(0.343, 0.092, 0.040),\n        vec3(0.445, 0.096, 0.046),\n        vec3(0.551, 0.098, 0.048),\n        vec3(0.624, 0.097, 0.053),\n        vec3(0.665, 0.098, 0.049),\n        vec3(0.687, 0.095, 0.050),\n        vec3(0.708, 0.095, 0.053),\n        vec3(0.723, 0.097, 0.055),\n        vec3(0.715, 0.095, 0.057),\n        vec3(0.710, 0.094, 0.056),\n        vec3(0.745, 0.097, 0.059),\n        vec3(0.758, 0.098, 0.057),\n        vec3(0.739, 0.096, 0.061),\n        vec3(0.767, 0.101, 0.061),\n        vec3(0.777, 0.103, 0.060),\n        vec3(0.765, 0.104, 0.062),\n        vec3(0.751, 0.107, 0.062),\n        vec3(0.745, 0.109, 0.062),\n        vec3(0.748, 0.112, 0.061),\n        vec3(0.729, 0.115, 0.062),\n        vec3(0.745, 0.125, 0.060),\n        vec3(0.757, 0.140, 0.059),\n        vec3(0.753, 0.160, 0.057),\n        vec3(0.750, 0.187, 0.058),\n        vec3(0.746, 0.229, 0.058),\n        vec3(0.747, 0.285, 0.058),\n        vec3(0.735, 0.343, 0.056),\n        vec3(0.732, 0.390, 0.055),\n        vec3(0.739, 0.435, 0.056),\n        vec3(0.734, 0.464, 0.059),\n        vec3(0.725, 0.472, 0.057),\n        vec3(0.721, 0.476, 0.055),\n        vec3(0.733, 0.481, 0.059),\n        vec3(0.725, 0.462, 0.059),\n        vec3(0.732, 0.447, 0.058),\n        vec3(0.743, 0.441, 0.059),\n        vec3(0.744, 0.426, 0.061),\n        vec3(0.748, 0.406, 0.061),\n        vec3(0.728, 0.373, 0.063),\n        vec3(0.716, 0.347, 0.063),\n        vec3(0.733, 0.337, 0.067),\n        vec3(0.726, 0.314, 0.068),\n        vec3(0.713, 0.285, 0.072),\n        vec3(0.740, 0.277, 0.080),\n        vec3(0.754, 0.266, 0.090),\n        vec3(0.764, 0.250, 0.099),\n        vec3(0.752, 0.230, 0.124),\n        vec3(0.736, 0.207, 0.154),\n        vec3(0.734, 0.186, 0.192),\n        vec3(0.741, 0.171, 0.255),\n        vec3(0.740, 0.160, 0.287),\n        vec3(0.732, 0.148, 0.349),\n        vec3(0.745, 0.141, 0.402),\n        vec3(0.755, 0.136, 0.443),\n        vec3(0.751, 0.130, 0.487),\n        vec3(0.744, 0.126, 0.513),\n        vec3(0.731, 0.123, 0.558),\n        vec3(0.733, 0.121, 0.584),\n        vec3(0.744, 0.122, 0.620),\n        vec3(0.731, 0.119, 0.606),\n        vec3(0.712, 0.114, 0.609),\n        vec3(0.708, 0.115, 0.651),\n        vec3(0.729, 0.117, 0.612),\n        vec3(0.730, 0.117, 0.610),\n        vec3(0.727, 0.118, 0.650),\n        vec3(0.707, 0.120, 0.638),\n        vec3(0.703, 0.122, 0.627),\n        vec3(0.729, 0.128, 0.620),\n        vec3(0.750, 0.132, 0.630),\n        vec3(0.760, 0.139, 0.628),\n        vec3(0.751, 0.144, 0.642),\n        vec3(0.739, 0.146, 0.639),\n        vec3(0.724, 0.150, 0.657),\n        vec3(0.730, 0.152, 0.639),\n        vec3(0.740, 0.157, 0.635),\n        vec3(0.737, 0.159, 0.642)\n    );\n    \n    float floatIdx = clamp((wv - 400.0) / (700.0 - 400.0), 0.0, 1.0) * 75.0;\n    int idx = int(floor(floatIdx));\n    float fac = fract(floatIdx);\n    \n    return mix(surfaceReflectances[idx], surfaceReflectances[idx + 1], fac);\n}\n\nmat3x4 getSurfaceReflectance(vec4 wv)\n{\n    vec3 s0 = getSurfaceReflectance(wv.x);\n    vec3 s1 = getSurfaceReflectance(wv.y);\n    vec3 s2 = getSurfaceReflectance(wv.z);\n    vec3 s3 = getSurfaceReflectance(wv.w);\n    return mat3x4(\n        vec4(s0.x, s1.x, s2.x, s3.x),\n        vec4(s0.y, s1.y, s2.y, s3.y),\n        vec4(s0.z, s1.z, s2.z, s3.z));\n}\n\nfloat getLightStrength(float wv)\n{\n    const float[] lightStrength = float[](0.0, 8.0, 15.6, 18.4);\n    \n    float floatIdx = clamp((wv - 400.0) / (700.0 - 400.0), 0.0, 1.0) * 3.0;\n    int idx = int(floor(floatIdx));\n    float fac = fract(floatIdx);\n    \n    return mix(lightStrength[idx], lightStrength[idx + 1], fac);\n}\n\nvec4 getLightStrength(vec4 wv)\n{\n    return vec4(getLightStrength(wv.x), getLightStrength(wv.y), getLightStrength(wv.z), getLightStrength(wv.w));\n}\n\n// Curve fit CIE Standard Illuminant D65\n// https://en.wikipedia.org/wiki/Illuminant_D65\n// Original data from\n// https://web.archive.org/web/20171122140854/http://www.cie.co.at/publ/abst/datatables15_2004/std65.txt\n// Range [46.4182, 117.812]\nvec4 getLightStrengthD65(vec4 wv)\n{\n    vec4 x = clamp(wv, 380.0, 780.0);\n    return -10906.5 +\n        x * (88.3842 +\n        x * (-0.280601 +\n        x * (0.000441847 + \n        (-3.46017*1e-7+1.07868*1e-10 * x) * x)));\n}\n\nvec3 XYZtoRGB( vec3 xyz ) {\n    const mat3 XYZ_TO_RGB = mat3( 3.2404542, -1.5371385, -0.4985314,\n                                 -0.9692660,  1.8760108,  0.0415560,\n                                  0.0556434, -0.2040259,  1.0572252);\n    return xyz * XYZ_TO_RGB;\n}\n    \nconst vec3 CIE1931ColObs_Sum = vec3(21.371524, 21.371327, 21.371540);\n\nvec3 wavelengthToXYZ( float wv ) {\n    \n    const vec3[] CIE1931ColObs = vec3[](\n        vec3(0.001368, 0.000039, 0.006450),\n        vec3(0.002236, 0.000064, 0.010550),\n        vec3(0.004243, 0.000120, 0.020050),\n        vec3(0.007650, 0.000217, 0.036210),\n        vec3(0.014310, 0.000396, 0.067850),\n        vec3(0.023190, 0.000640, 0.110200),\n        vec3(0.043510, 0.001210, 0.207400),\n        vec3(0.077630, 0.002180, 0.371300),\n        vec3(0.134380, 0.004000, 0.645600),\n        vec3(0.214770, 0.007300, 1.039050),\n        vec3(0.283900, 0.011600, 1.385600),\n        vec3(0.328500, 0.016840, 1.622960),\n        vec3(0.348280, 0.023000, 1.747060),\n        vec3(0.348060, 0.029800, 1.782600),\n        vec3(0.336200, 0.038000, 1.772110),\n        vec3(0.318700, 0.048000, 1.744100),\n        vec3(0.290800, 0.060000, 1.669200),\n        vec3(0.251100, 0.073900, 1.528100),\n        vec3(0.195360, 0.090980, 1.287640),\n        vec3(0.142100, 0.112600, 1.041900),\n        vec3(0.095640, 0.139020, 0.812950),\n        vec3(0.057950, 0.169300, 0.616200),\n        vec3(0.032010, 0.208020, 0.465180),\n        vec3(0.014700, 0.258600, 0.353300),\n        vec3(0.004900, 0.323000, 0.272000),\n        vec3(0.002400, 0.407300, 0.212300),\n        vec3(0.009300, 0.503000, 0.158200),\n        vec3(0.029100, 0.608200, 0.111700),\n        vec3(0.063270, 0.710000, 0.078250),\n        vec3(0.109600, 0.793200, 0.057250),\n        vec3(0.165500, 0.862000, 0.042160),\n        vec3(0.225750, 0.914850, 0.029840),\n        vec3(0.290400, 0.954000, 0.020300),\n        vec3(0.359700, 0.980300, 0.013400),\n        vec3(0.433450, 0.994950, 0.008750),\n        vec3(0.512050, 1.000000, 0.005750),\n        vec3(0.594500, 0.995000, 0.003900),\n        vec3(0.678400, 0.978600, 0.002750),\n        vec3(0.762100, 0.952000, 0.002100),\n        vec3(0.842500, 0.915400, 0.001800),\n        vec3(0.916300, 0.870000, 0.001650),\n        vec3(0.978600, 0.816300, 0.001400),\n        vec3(1.026300, 0.757000, 0.001100),\n        vec3(1.056700, 0.694900, 0.001000),\n        vec3(1.062200, 0.631000, 0.000800),\n        vec3(1.045600, 0.566800, 0.000600),\n        vec3(1.002600, 0.503000, 0.000340),\n        vec3(0.938400, 0.441200, 0.000240),\n        vec3(0.854450, 0.381000, 0.000190),\n        vec3(0.751400, 0.321000, 0.000100),\n        vec3(0.642400, 0.265000, 0.000050),\n        vec3(0.541900, 0.217000, 0.000030),\n        vec3(0.447900, 0.175000, 0.000020),\n        vec3(0.360800, 0.138200, 0.000010),\n        vec3(0.283500, 0.107000, 0.000000),\n        vec3(0.218700, 0.081600, 0.000000),\n        vec3(0.164900, 0.061000, 0.000000),\n        vec3(0.121200, 0.044580, 0.000000),\n        vec3(0.087400, 0.032000, 0.000000),\n        vec3(0.063600, 0.023200, 0.000000),\n        vec3(0.046770, 0.017000, 0.000000),\n        vec3(0.032900, 0.011920, 0.000000),\n        vec3(0.022700, 0.008210, 0.000000),\n        vec3(0.015840, 0.005723, 0.000000),\n        vec3(0.011359, 0.004102, 0.000000),\n        vec3(0.008111, 0.002929, 0.000000),\n        vec3(0.005790, 0.002091, 0.000000),\n        vec3(0.004109, 0.001484, 0.000000),\n        vec3(0.002899, 0.001047, 0.000000),\n        vec3(0.002049, 0.000740, 0.000000),\n        vec3(0.001440, 0.000520, 0.000000),\n        vec3(0.001000, 0.000361, 0.000000),\n        vec3(0.000690, 0.000249, 0.000000),\n        vec3(0.000476, 0.000172, 0.000000),\n        vec3(0.000332, 0.000120, 0.000000),\n        vec3(0.000235, 0.000085, 0.000000),\n        vec3(0.000166, 0.000060, 0.000000),\n        vec3(0.000117, 0.000042, 0.000000),\n        vec3(0.000083, 0.000030, 0.000000),\n        vec3(0.000059, 0.000021, 0.000000),\n        vec3(0.000042, 0.000015, 0.000000)\n    );\n\n    float floatIdx = clamp((wv - 380.0) / (780.0 - 380.0), 0.0, 1.0) * 80.0;\n    int idx = int(floor(floatIdx));\n    float fac = fract(floatIdx);\n    \n    return mix(CIE1931ColObs[idx], CIE1931ColObs[idx + 1], fac);\n}\n\nvec3 wavelengthXYZtoRGB( vec3 xyz )\n{\n    const vec3 avg = vec3(35.24199783, 23.04154372, 21.87036498) / 35.24199783;\n    \n    return max(XYZtoRGB(xyz), vec3(0));\n}\n\nvec3 wavelengthToRGB( float wv )\n{\n    //vec3 avg = XYZtoRGB(CIE1931ColObs_Sum);\n    //avg /= max(max(avg.x, avg.y), avg.z);\n    //Eqv: vec3(25.74837142, 20.2662644, 19.42341068) / 25.74837142;\n    \n    // With max average\n    const vec3 avg = vec3(35.24199783, 23.04154372, 21.87036498) / 35.24199783;\n    \n    return max(XYZtoRGB(wavelengthToXYZ(wv)), vec3(0)) / avg;\n}\n\nfloat tanhCurve( float x, float a, float b, float o, float k )\n{\n    return tanh((x - o) * k) * a + b;\n}\n\nvec2 tanhCurve( vec2 x, vec2 a, vec2 b, vec2 o, vec2 k )\n{\n    return tanh((x - o) * k) * a + b;\n}\n\nvec4 tanhCurve( vec4 x, float a, float b, float o, float k )\n{\n    return tanh((x - o) * k) * a + b;\n}\n\nfloat RGBtoSpectrum(vec3 rgb, float wv)\n{\n    float x = (wv - 380.0) / (730.0 - 380.0);\n    vec2 t = tanhCurve(x + vec2(0, .285), vec2(.475, -.475), vec2(.495), vec2(.585), vec2(30.));\n    vec3 z = vec3(t.x, 1.0 - t.x - t.y, t.y) * rgb;\n    return z.x + z.y + z.z;\n}\n\nvec4 RGBtoSpectrum(vec3 rgb, vec4 wv)\n{\n    vec4 x = (wv - 380.0) / (730.0 - 380.0);\n    vec4 ta = tanhCurve(x + 0.0, 0.475, 0.495, 0.585, 30.0);\n    vec4 tb = tanhCurve(x + 0.285, -0.475, 0.495, 0.585, 30.0);\n    mat3x4 z = mat3x4(ta, 1.0 - ta - tb, tb);\n    return z * rgb;\n}\n\nfloat cauchy(float wv, float b, float c)\n{\n    float x = wv * 0.001;\n    return b + c / (x * x);\n}\n\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2022-12-31 10:10:47\n\n#define LIGHT_POS vec3(0.278, 0.5489, 0.2795)\n#define LIGHT_SIZE vec2(0.13, 0.105)\n\nvec3 sampleLight()\n{\n    vec2 r = (hash2(state) - 0.5) * LIGHT_SIZE;\n    return LIGHT_POS + vec3(r.x, 0, r.y);\n}\n\nvec4 getSkybox(vec3 direction, vec4 wv)\n{\n    vec3 env = sRGBToLinear(texture(iChannel1, direction).rgb);\n    vec4 spd = RGBtoSpectrum(env, wv);\n    return SKYBOX_STRENGTH * spd;\n}\n\nvoid sceneIntersect(Ray ray, out HitInfo hit, out Material mat)\n{\n    hit = HitInfo(MAX_DIST, vec3(0), false);\n    mat = Material(vec4(0), vec4(0), 1.0, 0.0, 1.0);\n    \n    #ifdef USE_CURVE_FIT_SURFACE_REFLECTANCES\n    mat3x4 surfaceRef = getSurfaceReflectanceCurveFit(ray.wv);\n    #else\n    mat3x4 surfaceRef = getSurfaceReflectance(ray.wv);\n    #endif\n    \n    // Walls\n    Ray oldRay = ray;\n    ray.origin -= vec3(0.556, 0.549, 0.559) / 2.0;\n    if (boxIntersectInsideZ(ray, vec3(0.556, 0.549, 0.559) / 2.0, hit))\n    {\n        int idx = 0;\n        vec3 pos = ray.origin + ray.direction * hit.t;\n        if (abs(hit.normal.x) > 0.0)\n        {\n            idx = pos.x < 0.0 ? 2 : 1;\n        }\n        vec4 color = surfaceRef[idx];\n        vec4 emissive = vec4(0);\n        \n        if (!hit.inside && hit.normal.z < 0.0)\n        {\n            vec4 tex = texture(iChannel3, (pos.xy / vec2(0.556, 0.549) + 0.5) / vec2(6, 1));\n            emissive = RGBtoSpectrum(sRGBToLinear(tex.rgb) * tex.a, ray.wv);\n            color *= (1.0 - tex.a);\n        }\n        \n        mat = Material(color, emissive, 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n    \n    // Short box\n    ray.origin -= vec3(0.556 - 0.186, 0.0826, 0.559 - 0.169);\n    mat2 rotMat1 = rot2D(radians(17.0));\n    mat2 rotMat2 = rot2D(radians(-17.0));\n    ray.origin.xz *= rotMat1;\n    ray.direction.xz *= rotMat1;\n    if (boxIntersect(ray, vec3(0.167, 0.165, 0.167) / 2.0, hit))\n    {\n        hit.normal.xz *= rotMat2;\n        //mat = Material(surfaceRef[0], vec4(0.0), 0.0, 0.0, 1.0);\n        mat = Material(surfaceRef[0], vec4(0.0), 1.0, 0.0, 1.333);\n        #if SCENE == 1\n        mat.transmission = 1.0;\n        mat.roughness = 0.4;\n        #endif\n    }\n    ray = oldRay;\n    \n    // Tall box\n    ray.origin -= vec3(0.556 - 0.351, 0.1651, 0.559 - 0.351);\n    ray.origin.xz *= rotMat2;\n    ray.direction.xz *= rotMat2;\n    if (boxIntersect(ray, vec3(0.166, 0.33, 0.168) / 2.0, hit))\n    {\n        hit.normal.xz *= rotMat1;\n        mat = Material(surfaceRef[0], vec4(0.0), 1.0, 0.0, 1.0);\n        #if SCENE == 1\n        mat.roughness = 0.0;\n        #endif\n    }\n    ray = oldRay;\n    \n    // Light\n    ray.origin -= LIGHT_POS;\n    if (boxIntersect(ray, vec3(LIGHT_SIZE.x, 0.0001, LIGHT_SIZE.y) * 0.5, hit))\n    {\n        #if ILLUMINANT == 0\n        vec4 emissive = getLightStrength(ray.wv);\n        #else\n        vec4 emissive = getLightStrengthD65(ray.wv) * 0.18;\n        #endif\n        mat = Material(vec4(0.0), emissive, 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n    \n#if SCENE == 0\n#elif SCENE == 1\n    // Sphere\n    //ray.origin -= vec3(0.2, 0.2, 0.4);\n    if (sphereIntersect(ray, vec3(0.08, 0.15, 0.4), 0.08, hit))\n    {\n        //RGBtoSpectrum(vec3(0.6, 0.2, 0.9), ray.wv)\n        mat = Material(vec4(1), vec4(0.0), 0.0, 1.0, 1.4);\n    }\n    ray = oldRay;\n    \n    /*\n    if (sphereIntersect(ray, vec3(0.2, 0.4, 0.25), 0.005, hit))\n    {\n        mat = Material(vec4(0), getLightStrengthD65(ray.wv), 0.0, 0.0, 1.4);\n    }\n    ray = oldRay;\n    */\n    \n    if (sphereIntersect(ray, vec3(0.44, 0.33, 0.15), 0.1, hit))\n    {\n        mat = Material(surfaceRef[0], vec4(0.0), 0.6, 0.0, 1.0);\n    }\n    ray = oldRay;\n#else\n    \n#endif\n}\n\n#define MIS_HEURISTIC 0\nfloat misWeight(float pdfA, float pdfB)\n{\n    #if MIS_HEURISTIC == 0\n    // Balance heuristic\n    return pdfA / (pdfA + pdfB);\n    #else\n    // Power heuristic\n    return pdfA*pdfA / (pdfA*pdfA + pdfB*pdfB);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    \n    vec2 o = halton(vec2(13, 23) * float(iFrame+1));\n    vec2 pv = (2. * (fragCoord + o - 0.5) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0.278, 0.273, -0.8);\n    vec3 lo = ro + vec3(0, 0, 1.0);\n    \n    vec4 m = texelFetch(iChannel0, ivec2(0, 0), 0);\n    if (iFrame < 2)\n        m = vec4(0.5, 0.5, 0, 0);\n                \n    #ifdef STATIC_CAM\n    m = vec4(0.5, 0.5, 0.0, 0.0);\n    #endif\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(0.5, 0.5, 0, 0);\n        } else\n        {\n            vec2 mn = iMouse.xy / iResolution.xy;\n            fragColor = vec4(m);\n            if (iMouse.z > 0.0)\n            {\n                if (fragColor.zw != vec2(0))\n                    fragColor.xy += (mn - m.zw);\n                fragColor.zw = mn;\n            } else\n            {\n                fragColor.zw = vec2(0);\n            }\n        }\n        return;\n    }\n    \n    float ax = -m.x * TAU;\n    float ay = m.y * PI - PI * 0.5;\n    \n    ro -= lo;\n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    #ifdef DOF\n    float dofStrength = DOF_STRENGTH;\n    float dofDist = DOF_FOCUS_DISTANCE;\n    \n    #if DOF_TYPE == 0\n    vec2 rc = randomPointInCircle();\n    #elif DOF_TYPE == 1\n    vec2 rc = randomPointInPolygon(float(DOF_SIDES));\n    #elif DOF_TYPE == 2\n    vec2 rc = randomPointInStar(float(DOF_SIDES));\n    #endif\n    \n    rc *= dofStrength * dofDist;\n    \n    pv -= rc / dofDist;\n    ro += cmat * vec3(rc, 0);\n    #endif\n    \n    vec3 rd = normalize(cmat * vec3(pv, 2.333));\n    \n    vec4 wv = generateWavelengths();\n    \n    vec4 color = vec4(0.0);\n    vec4 throughput = vec4(1.0);\n    \n    Ray ray = Ray(ro, rd, wv);\n    HitInfo hit;\n    Material mat;\n    sceneIntersect(ray, hit, mat);\n    \n    color += mat.emissive;\n    \n    bool dispersed = false;\n    for (int i = 0; i < BOUNCES; i++)\n    {\n    \n        if (hit.t >= MAX_DIST)\n        {\n            #ifdef SKYBOX\n            color += SKYBOX_STRENGTH * throughput * getSkybox(ray.direction, ray.wv);\n            #endif\n            break;\n        }\n        \n        float ior = mat.transmission > 0.0 ? cauchy(wv.x, mat.ior, 0.05) : 1.0;\n        float roughness = mat.roughness * mat.roughness;\n        \n        vec3 diffuseRay = normalize(hit.normal + randomUnitVector());\n        vec3 glossyRay = normalize(mix(reflect(ray.direction, hit.normal), diffuseRay, roughness));\n        vec3 transmissionRay = refract(ray.direction, hit.normal, hit.inside ? ior : 1.0 / ior);\n        transmissionRay = mix(transmissionRay, -diffuseRay, roughness);\n        \n        if (dot(transmissionRay, transmissionRay) < EPSILON)\n            transmissionRay = glossyRay;\n        \n        bool isGlossy = hash(state) > roughness;\n        bool isTransmission = hash(state) < mat.transmission;\n        \n        Ray rayNext;\n        rayNext.origin = ray.origin + ray.direction * hit.t + hit.normal * EPSILON * (1.0 - 2.0 * float(isTransmission));\n        \n        rayNext.direction = isGlossy ? glossyRay : diffuseRay;\n        rayNext.direction = isTransmission ? transmissionRay : rayNext.direction;\n        rayNext.direction = normalize(rayNext.direction);\n        rayNext.wv = ray.wv;\n        \n        HitInfo hitNext;\n        Material matNext;\n        sceneIntersect(rayNext, hitNext, matNext);\n        \n        float G0 = max(dot(rayNext.direction, hit.normal), 0.0) *\n                   max(dot(-rayNext.direction, vec3(0, -sign(rayNext.direction.y), 0)), 0.0) / max(hitNext.t * hitNext.t, EPSILON);\n        \n        // Glossy is un-physical so just made PDF the same as diffuse as well *shrug*\n        vec4 brdf = mat.color / PI;\n        float brdfPdf = 1.0 / PI;\n        float lightPdf = 1.0 / ((LIGHT_SIZE.x * LIGHT_SIZE.y) * G0);\n        \n        float diffuseW = !isTransmission ? misWeight(brdfPdf, lightPdf) : 1.0;\n        \n        vec4 Le = matNext.emissive;\n        color += throughput * Le * diffuseW * brdf / brdfPdf;\n        \n        vec3 lightPos = sampleLight();\n        vec3 lightDir = lightPos - rayNext.origin;\n        float lightDist = length(lightDir);\n        lightDir /= lightDist;\n        \n        float G = max(dot(lightDir, hit.normal), 0.0) *\n                  max(dot(-lightDir, vec3(0, -sign(lightDir.y), 0)), 0.0) / max(lightDist * lightDist, EPSILON);\n        \n        if (!isTransmission && G > 0.0)\n        {\n            Ray rayLight;\n            rayLight.origin = rayNext.origin + lightDir * EPSILON;\n            rayLight.direction = lightDir;\n            rayLight.wv = ray.wv;\n            \n            HitInfo hitLight;\n            Material matLight;\n            sceneIntersect(rayLight, hitLight, matLight);\n            \n            //if (abs(hitLight.t - lightDist) < 1e-3) \n            if (hitLight.t < lightDist && any(greaterThan(matLight.emissive, vec4(0))))\n            {\n                float brdfPdf = 1.0 / PI;\n                float lightPdf = 1.0 / ((LIGHT_SIZE.x * LIGHT_SIZE.y) * G);\n\n                float lightW = misWeight(lightPdf, brdfPdf);\n\n                vec4 lightLe = matLight.emissive;\n                color += throughput * brdf * lightLe / lightPdf;\n            }\n        }\n        \n        throughput *= brdf / brdfPdf;\n        \n        \n        if (isTransmission && !dispersed)\n        {\n            dispersed = true;\n            throughput *= vec4(4, 0, 0, 0);\n        }\n        \n        if (dot(throughput, throughput) < EPSILON)\n            break;\n            \n        ray = rayNext;\n        hit = hitNext;\n        mat = matNext;\n    }\n    \n    #if 1\n    vec3 outColor = wavelengthToXYZ(wv.x) * color.x +\n                    wavelengthToXYZ(wv.y) * color.y +\n                    wavelengthToXYZ(wv.z) * color.z +\n                    wavelengthToXYZ(wv.w) * color.w;\n    outColor /= 4.0;\n    #else\n    vec3 outColor = wavelengthToXYZ(wv.x) * color.x;\n    #endif\n    \n    //outColor = mix(outColor, vec3(0.5), 1.0-saturate(abs(fragCoord.x - iResolution.x * 0.5)));\n    \n#ifndef NO_ACCUMULATE\n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    #ifdef STATIC_CAM\n    float blend = iFrame == 0 ? 1.0 : 1.0 / (1.0 + (1.0 / prevColor.a));\n    #else\n    float blend = iFrame == 0 || m.zw != vec2(0) ? 1.0 : 1.0 / (1.0 + (1.0 / prevColor.a));\n    #endif\n    \n    fragColor = vec4(mix(prevColor.rgb, outColor, blend), blend);\n#else\n    fragColor = vec4(outColor, 1);\n#endif\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clf3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[720, 720, 777, 777, 1228]], "test": "untested"}
{"id": "dtlGD2", "name": "Cornell Box MIS", "author": "gelami", "description": "A simple Cornell box path tracing example with NEE/MIS\nUses only box primitives for everything (for u danil)\n\nClick and drag to move camera", "tags": ["3d", "raytracing", "box", "mis", "cornell", "nee"], "likes": 14, "viewed": 419, "published": 3, "date": "1681039773", "time_retrieved": "2024-07-30T18:01:27.854683", "image_code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2022-12-31 10:10:47\n\n// Cornell Box MIS by gelami\n// https://www.shadertoy.com/view/dtlGD2\n\n/*\n * A simple Cornell box path tracing example with NEE/MIS\n * Uses only box primitives for everything (for u danil)\n * The walls are a single box with the front plane removed\n * \n * Click and drag to move camera\n * Defines in Common\n * \n * Thanks to koiava and cschied for their MIS/NEE examples\n * \n * Direct Light using MIS - koiava\n * https://www.shadertoy.com/view/4sSXWt\n *\n * Path tracing cornellbox with MIS\n * https://www.shadertoy.com/view/4lfcDr\n *\n * Spectral version:\n * Spectral Cornell Box MIS + HWSS - gelami\n * https://www.shadertoy.com/view/clf3DX\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n        color = texelFetch(iChannel0, ivec2(1, 0), 0).rgb;\n    \n    color *= exp2(EXPOSURE);\n    \n    color = max(color, vec3(0));\n    color = color / (1. + luminance(color));\n    \n    #ifdef COMPARE_MIS\n    if (int(fragCoord.x) == int(iResolution.x * 0.5))\n        color = vec3(1, 0.05, 0);\n    #endif\n    \n    fragColor = vec4(linearTosRGB(color), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define NEE\n#define MIS\n//#define COMPARE_MIS\n\n#define SKYBOX\n#define SKYBOX_STRENGTH 0.2\n\n#define BOUNCES 6\n#define EXPOSURE 0.0\n\n#define MAX_DIST 100.\n#define EPSILON 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec3 color;\n    vec3 emissive;\n    float roughness;\n    float transmission;\n    float ior;\n};\n\nstruct HitInfo\n{\n    float t;\n    vec3 normal;\n    bool inside;\n};\n\n// Ray-Box Intersection\n// https://iquilezles.org/articles/intersectors/\n\nbool boxIntersect( Ray ray, vec3 boxSize, inout HitInfo hit ) \n{\n    vec3 m = 1.0 / ray.direction;\n    vec3 n = m * ray.origin;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    \n    if( tN > tF || tF < 0.0) return false;\n    \n    bool inside = false;\n    vec3 normal;\n    if (tN < 0.0)\n    {\n        tN = tF;\n        t1 = t2;\n        normal = -sign(ray.direction)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n        inside = true;\n    } else {\n        normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    }\n    \n    if (tN < hit.t)\n    {\n        hit.t = tN;\n        hit.normal = normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\nbool boxIntersectInsideZ( Ray ray, vec3 boxSize, inout HitInfo hit ) \n{\n    vec3 m = 1.0 / ray.direction;\n    vec3 n = m * ray.origin;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    \n    if( tN > tF || tF < 0.0) return false;\n    \n    bool inside = false;\n    vec3 normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    if (tN < 0.0 || normal.z > 0.0)\n    {\n        normal = -sign(ray.direction)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);;\n        if (normal.z < 0.0) return false;\n        tN = tF;\n        inside = true;\n    }\n    \n    if (tN < hit.t)\n    {\n        hit.t = tN;\n        hit.normal = normal;\n        hit.inside = inside;\n        return true;\n    }\n    return false;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 c) { return dot(c, vec3(0.2126, 0.7152, 0.0722)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n    vec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(vec2(s),coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec3 randomUnitVector()\n{\n    vec2 rand = hash2(state);\n    rand.y = rand.y*2.-1.;\n    rand.x *= PI*2.;\n    \n    float r = sqrt(1. - rand.y*rand.y);\n    vec2 xy = vec2(cos(rand.x), sin(rand.x)) * r;\n    \n    return vec3(xy, rand.y);\n}\n\nvec3 randomCosineHemisphere(vec3 n)\n{\n    return normalize(randomUnitVector() + n);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "\n#define LIGHT_POS vec3(0.278, 0.5489, 0.2795)\n#define LIGHT_SIZE vec2(0.13, 0.105)\n\nvec3 sampleLight()\n{\n    vec2 r = (hash2(state) - 0.5) * 2.0;\n    return LIGHT_POS + vec3(LIGHT_SIZE.x * r.x, 0.0001, LIGHT_SIZE.y * r.y) * 0.5;\n}\n\nvec3 getSkybox(vec3 direction)\n{\n    vec3 env = sRGBToLinear(texture(iChannel1, direction).rgb);\n    return SKYBOX_STRENGTH * env;\n}\n\nvoid sceneIntersect(Ray ray, out HitInfo hit, out Material mat)\n{\n    hit = HitInfo(MAX_DIST, vec3(0), false);\n    mat = Material(vec3(0), vec3(0), 1.0, 0.0, 1.0);\n    \n    // Walls\n    Ray oldRay = ray;\n    ray.origin -= vec3(0.556, 0.549, 0.559) / 2.0;\n    if (boxIntersectInsideZ(ray, vec3(0.556, 0.549, 0.559) / 2.0, hit))\n    {\n        vec3 pos = ray.origin + ray.direction * hit.t;\n        \n        vec3 color = vec3(1);\n        vec3 emissive = vec3(0);\n        float sgn = float(hit.inside) * 2.0 - 1.0;\n        if (hit.normal.x * sgn > 0.0)\n            color = vec3(0.8, 0.12, 0.12);\n        else if (hit.normal.x * sgn < 0.0)\n            color = vec3(0.24, 0.65, 0.2);\n        \n        if (!hit.inside && hit.normal.z < 0.0)\n        {\n            vec4 tex = texture(iChannel3, (pos.xy / vec2(0.556, 0.549) + 0.5) / vec2(6, 1));\n            emissive = sRGBToLinear(tex.rgb) * tex.a;\n            color = vec3(1.0 - tex.a);\n        }\n        mat = Material(color, emissive, 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n    \n    // Short box\n    ray.origin -= vec3(0.556 - 0.186, 0.0825, 0.559 - 0.169);\n    mat2 rotMat1 = rot2D(radians(17.0));\n    mat2 rotMat2 = rot2D(radians(-17.0));\n    ray.origin.xz *= rotMat1;\n    ray.direction.xz *= rotMat1;\n    if (boxIntersect(ray, vec3(0.167, 0.165, 0.167) / 2.0, hit))\n    {\n        hit.normal.xz *= rotMat2;\n        mat = Material(vec3(1), vec3(0), 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n    \n    // Tall box\n    ray.origin -= vec3(0.556 - 0.351, 0.165, 0.559 - 0.351);\n    ray.origin.xz *= rotMat2;\n    ray.direction.xz *= rotMat2;\n    if (boxIntersect(ray, vec3(0.166, 0.33, 0.168) / 2.0, hit))\n    {\n        hit.normal.xz *= rotMat1;\n        mat = Material(vec3(1), vec3(0), 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n    \n    // Light\n    ray.origin -= LIGHT_POS;\n    if (boxIntersect(ray, vec3(LIGHT_SIZE.x, 0.0001, LIGHT_SIZE.y) / 2.0, hit))\n    {\n        mat = Material(vec3(0), vec3(12), 1.0, 0.0, 1.0);\n    }\n    ray = oldRay;\n}\n\n#define MIS_HEURISTIC 0\nfloat misWeight(float pdfA, float pdfB)\n{\n    #if MIS_HEURISTIC == 0\n    // Balance heuristic\n    return pdfA / (pdfA + pdfB);\n    #else\n    // Power heuristic\n    return pdfA*pdfA / (pdfA*pdfA + pdfB*pdfB);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    \n    vec2 o = halton(vec2(13, 23) * float(iFrame+1));\n    vec2 ndc = (2. * (fragCoord + o - 0.5) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0.278, 0.273, -0.8);\n    vec3 lo = ro + vec3(0, 0, 1);\n    \n    vec4 m = texelFetch(iChannel0, ivec2(0, 0), 0);\n    if (iFrame < 2)\n        m = vec4(0.5, 0.5, 0, 0);\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0)\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(0.5, 0.5, 0, 0);\n        } else\n        {\n            vec2 mn = iMouse.xy / iResolution.xy;\n            fragColor = vec4(m);\n            if (iMouse.z > 0.0)\n            {\n                if (fragColor.zw != vec2(0))\n                    fragColor.xy += (mn - m.zw);\n                fragColor.zw = mn;\n            } else\n            {\n                fragColor.zw = vec2(0);\n            }\n        }\n        return;\n    }\n    \n    float ax = -m.x * TAU;\n    float ay = m.y * PI - PI * 0.5;\n    \n    ro -= lo;\n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    vec3 rd = normalize(cmat * vec3(ndc, 2.35));\n    \n    vec3 color = vec3(0);\n    vec3 throughput = vec3(1);\n    \n    Ray ray = Ray(ro, rd);\n    \n    HitInfo hit;\n    Material mat;\n    sceneIntersect(ray, hit, mat);\n    \n    color += mat.emissive;\n    \n    for (int i = 0; i < BOUNCES; i++)\n    {\n        if (hit.t >= MAX_DIST)\n        {\n            #ifdef SKYBOX\n            color += SKYBOX_STRENGTH * throughput * getSkybox(ray.direction);\n            #endif\n            break;\n        }\n        \n        Ray rayNext;\n        rayNext.origin = ray.origin + ray.direction * hit.t + hit.normal * EPSILON;\n        rayNext.direction = randomCosineHemisphere(hit.normal);\n        \n        HitInfo hitNext;\n        Material matNext;\n        sceneIntersect(rayNext, hitNext, matNext);\n        \n        vec3 Le = matNext.emissive;\n        \n        float G0 = max(dot(rayNext.direction, hit.normal), 0.0) *\n                   max(dot(-rayNext.direction, vec3(0, -sign(rayNext.direction.y), 0)), 0.0) / (hitNext.t * hitNext.t);\n        \n        vec3 brdf = mat.color / PI;\n        float brdfPdf = 1.0 / PI;\n        float lightPdf = 1.0 / ((LIGHT_SIZE.x * LIGHT_SIZE.y) * G0);\n        \n        #ifdef NEE\n        #ifdef MIS\n        #ifdef COMPARE_MIS\n        float diffuseW = uv.x > 0.5 ? misWeight(brdfPdf, lightPdf) : 0.5;\n        #else\n        float diffuseW = misWeight(brdfPdf, lightPdf);\n        #endif\n        #else\n        float diffuseW = 1.0;\n        #endif\n        #else\n        float diffuseW = 1.0;\n        #endif\n        \n        color += throughput * brdf * diffuseW * Le / brdfPdf;\n        \n        vec3 lightPos = sampleLight();\n        vec3 lightDir = lightPos - rayNext.origin;\n        float lightDist = length(lightDir);\n        lightDir /= lightDist;\n        \n        \n        float G = max(dot(lightDir, hit.normal), 0.0) *\n                  max(dot(-lightDir, vec3(0, -sign(lightDir.y), 0)), 0.0) / (lightDist * lightDist);\n        \n        #ifdef NEE\n        if (G > 0.0)\n        {\n            Ray rayLight;\n            rayLight.origin = rayNext.origin + lightDir * EPSILON;\n            rayLight.direction = lightDir;\n            HitInfo hitLight;\n            Material matLight;\n            sceneIntersect(rayLight, hitLight, matLight);\n\n            float vis = float(dot(matLight.emissive, vec3(1)) > 0.0);\n\n            vec3 brdf = mat.color / PI;\n            float brdfPdf = 1.0 / PI;\n            float lightPdf = 1.0 / ((LIGHT_SIZE.x * LIGHT_SIZE.y) * G);\n\n            #ifdef MIS\n            #ifdef COMPARE_MIS\n            float lightW = uv.x > 0.5 ? misWeight(lightPdf, brdfPdf) : 0.5;\n            #else\n            float lightW = misWeight(lightPdf, brdfPdf);\n            #endif\n            #else\n            float lightW = 1.0;\n            #endif\n\n            vec3 lightLe = matLight.emissive;\n            color += throughput * brdf * lightLe * lightW * vis / lightPdf;\n        }\n        #endif\n        \n        throughput *= brdf / brdfPdf;\n        \n        ray = rayNext;\n        hit = hitNext;\n        mat = matNext;\n    }\n    \n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float blend = iFrame == 0 || m.zw != vec2(0) ? 1.0 : 1.0 / (1.0 + (1.0 / prevColor.a));\n    \n    fragColor = vec4(mix(prevColor.rgb, color, blend), blend);\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[753, 753, 810, 810, 1390]], "test": "untested"}
{"id": "msGXW1", "name": "crossbars", "author": "FabriceNeyret2", "description": "inspiration: https://twitter.com/pickover/status/1644864126462599169\ntry the animated variant line #34 ;-)", "tags": ["2d", "2tweets", "short", "golf", "reproduction"], "likes": 36, "viewed": 494, "published": 3, "date": "1681028896", "time_retrieved": "2024-07-30T18:01:28.681472", "image_code": "// more readable version below\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    int n = 1 << 5 - int( U *= .5 / floor(iResolution.xy/8.) ), k=0;       // number of left nodes on the given strip\n    \n    for( O = vec4(1) ; k<n*n/2; k++ )                                      // foreach curve\n        O *= .5+ .5* min( 1., abs( O.a = mix( .5 +     float(k%n) ,        // strip right node index\n                                              1. + 2.* float(k/n) ,        // strip left node index\n                                              smoothstep(0.,1.,fract(U.x)) // curve shave\n                                            ) - U.y * float(n/4)\n                                 ) / fwidth(O.a) );                        // AA draw greying cuve\n    O = sqrt(O);                                                           // to sRGB\n}\n\n\n\n\n\n/** // --- 257 chars\n\n#define S(v) smoothstep(0.,1., v)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U *= .5/ floor(iResolution.xy/8.);\n    float s = exp2(ceil(U.x-4.)), i, j, v;\n    \n    O = vec4(1);  \n    for( i = .5*s-2.; i < 2.; i += s )\n        for( j = s-2.; j < 2.; j += s+s )   \n            O *= .5+.5* S( abs( v = mix(i,j, S(fract(U.x)) )\n                             // v = mix( i+sin(i*iTime)*.2*s, j+sin(j*iTime)*.4*s, S(fract(U.x)) )   \n                                -U.y+2.\n                              )/fwidth(v) );\n    O = sqrt(O);\n}\n\n/**/\n\n\n\n\n\n/** // --- 267 chars\n\n#define S(v) smoothstep(0.,1., v)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = 4.*U/( floor(iResolution.xy/8.)*8. )  - 2.;\n    float s = exp2(-floor(2.-U.x)), i, j, v;\n    \n    O = vec4(1);  \n    for( i = .5*s-2.; i < 2.; i += s )\n        for( j = s-2.; j < 2.; j += s+s )\n            v = mix(i,j, S(fract(U.x)) ) - U.y,      \n         // v = mix( i+sin(i*iTime)*.2*s, j+sin(j*iTime)*.4*s, S(fract(U.x)) ) - U.y,      \n            O *= .5+.5* S( abs(v)/fwidth(v) );\n            \n    O = sqrt(O);\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 71, 71, 829]], "test": "untested"}
{"id": "dsyXW1", "name": "Revision 2023 jam entry", "author": "kostik1337", "description": "Livecoded in 60 minutes or so during h0ffman DJ set", "tags": ["revision", "jam", "livecode"], "likes": 7, "viewed": 243, "published": 3, "date": "1681027536", "time_retrieved": "2024-07-30T18:01:29.625947", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat hash(float t) {return fract(sin(t) * 24535.365);}\nfloat hash(vec2 t) {return hash(dot(t, vec2(34.646,43.66442)));}\nfloat hash(vec3 t) {return hash(dot(t, vec3(34.646,43.66442, 12.544)));}\n\n#define INF (1e10)\n#define time iTime\n#define mr(t) (mat2(cos(t),sin(t),-sin(t),cos(t)))\n#define sat(t) (clamp(t, 0.,1.))\n\n#define BPM 130.\n#define beat (time * BPM/60.)\n\nfloat ffts(float t) {return texture(iChannel0, vec2(t, 0.)).r;}\nfloat ffti(float t) {return 0.;}\nvec4 prev(vec2 p) {return texture(iChannel1, p);}\n\nfloat box(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat beatstep(float b, float x) {return floor(b) + smoothstep(.0, .3, fract(b)); }\n\nfloat noise(float t) {\n  return mix(hash(floor(t)), hash(floor(t+1.)), smoothstep(0.,1.,fract(t)));\n}\n\nfloat boxs = .4;\n\nfloat map(vec3 p) {\n  //p.yz *= mr(1.5*beatstep(beat/8., .1));\n  p.xy *= mr(.2*sin(beat*.2));\n  p.xz *= mr(.2*sin(beat*.3));\n  p.yz *= mr(ffti(.1)*.3);\n  p.xz *= mr(ffti(.13)*.5);\n  \n  float off = .005;\n  vec3 s = vec3(boxs);\n  float m, i;\n  for(i=0.;i<3.;++i) {\n    s /= 2.;\n    vec3 sig = sign(p);\n    p = abs(p)-s-off;\n    float bb = beat/4.;\n    float thresh = fract(bb);\n    thresh = mix(1., .5, smoothstep(.0, .1, thresh) * (1.-smoothstep(.9, 1., thresh)));\n    if (hash(sig + floor(bb)) < thresh) break;\n  }\n  m = box(p, s - off*i);\n  return m;\n}\n\nvec3 pal(float t, float p) {\n  return vec3(pow(t, 5.)) + vec3(.2, .1, 1.) * pow(t, .5);\n}\n\n#define quant(x,t) (floor(x/t)*t)\n\nvec3 bg(vec2 p) {\n  vec3 c = vec3(0.);\n  p.y += noise(p.x/4.+.3*time);\n  p.y += noise(p.x/6.3+.1*time);\n  vec2 op=p;\n  float h = .05;\n  float ycid = floor(p.y/h);\n  p.y = fract(p.y/h);\n  float I=8.;\n  float hh = ffts(hash(ycid));\n  for (float i=0.; i<I;++i) {\n    vec2 p1 = p;\n    float xdiv = mix(1.4, 3., hash(ycid+i*.35));\n    p1.x -= mix(.3, 1., hash(ycid+i*.88)) * quant(beat, .25);\n    p1.x += hash(op.y)*.5;\n    p1.x = fract(p1.x / xdiv);\n    c += pal(p1.x, mix(5., 1., sat(5.*hh)));\n  }\n  c *= mix(1., 5., hh);\n  return c / I;\n}\n\nvec3 norm(vec3 p) {\n  vec2 E = vec2(.001, .0);\n  return normalize(vec3(\n    map(p+E.xyy),\n    map(p+E.yxy),\n    map(p+E.yyx)\n  )-map(p));\n}\n\nfloat raymarch(vec3 O, vec3 D, out float i, out bool hit) {\n  float d = 0.;\n  for (i=0.; i<64.; ++i) {\n    vec3 p = O+D*d;\n    float m = map(p);\n    d += m;\n    if(m < .001*d) {\n      hit = true;\n      return d;\n    }\n  }\n  hit = false;\n  return INF;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 O = vec3(0., 0., -2.), D = normalize(vec3(uv, 1.));\n  vec2 rot = vec2(0.);\n  rot.x += .2*sin(time)+.4*sin(.3*beatstep(beat/4., .2));\n  rot.y += .3*sin(time)+.4*sin(.2*beatstep(beat/4., .3));\n  O.xz *= mr(rot.x);\n  D.xz *= mr(rot.x);\n  O.yz *= mr(rot.y);\n  D.yz *= mr(rot.y);\n  \n  vec3 c = vec3(0.);\n  bool hit;\n  float i;\n  float d = raymarch(O, D, i, hit);\n  vec3 n;\n  if (hit) {\n    vec3 p = O+D*d;\n    n = norm(p);\n    vec3 D1 = reflect(D, n);\n    float d1;\n    if(D1.z > 0.) d1 = (1.-p.z)/D1.z;\n    else d1 = (-2.-p.z)/D1.z;\n    vec3 p1 = p+D1*d1;\n    \n    c += bg(p.xy) * exp(-d*1.1) * exp(-i/8.)*.6;\n    c += bg(p1.xy) * dot(D1, n) * exp(-d1*2.)*3.;\n  } else {\n    float d1 = (1.-O.z)/D.z;\n    vec3 p = O+D*d1;\n    float shad = raymarch(p, vec3(0.,0.,-1.), i, hit);\n    shad = step(20., shad);\n    c += bg(p.xy)*shad * exp(-d1/8.);\n  }\n\n  uv = fragCoord/iResolution.xy;\n  if (hit) {\n    vec4 pr = prev(uv + .03*n.xy);\n    c += pr.rgb * pow(abs(n.z), 2.) * .9;\n  }\n\tfragColor = vec4(c, (hit?1.:0.) * d);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32970, "src": "https://soundcloud.com/paulosborn/i-find-it-hard-to-let-go-sometimes-neanderpaul-gnotek-idm", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyXW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "dsySW1", "name": "Revision 2023 ShaderJam - eimink", "author": "eimink", "description": "Shadertoy adaptation of my livecoded shader during Hoffman's DJ set. Might be more glitchy in here than in bonzomatic.", "tags": ["sdf", "livecode", "shaderjam", "fakeglow"], "likes": 3, "viewed": 235, "published": 3, "date": "1681024996", "time_retrieved": "2024-07-30T18:01:30.500608", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hello Revision 2023!\n\nconst float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 64;\n\nfloat time;\nfloat fft;\nfloat ffts;\n\nvec3 glow = vec3(0.0);\n\nvoid rot(inout vec2 p, float a){\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sphere(vec3 p, float r){\n  return length(p)-r;\n}\n\nfloat box(vec3 p, float b){\n  vec3 d = abs(p)-b;\n  return length(max(d,.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat scene(vec3 p){\n  vec3 pp = p;\n  \n  for(int i = 0; i < 4; ++i){\n    pp = abs(pp) - vec3(0.75, 2.0, 1.5);\n    rot(pp.xz, time*0.3+sin(4.*fft));\n    rot(pp.zy, fft*2.5);\n    rot(pp.xy, fft*0.5+time*0.1+cos(8.*ffts));\n  }\n  \n  float spheres = sphere(pp,1.0+ffts*50.);\n  float spheres2 = sphere(pp,3.+ffts*5.);\n  float spheres3 = sphere(pp,3.25+ffts*5.);\n  float spheres4 = sphere(pp,3.5+ffts*5.);\n  float spheres5 = sphere(pp,3.75+ffts*5.);\n  float spheres6 = sphere(pp,4.+ffts*5.);\n  \n  pp = p;\n  for (int i = 0; i < 3; ++i){\n    pp = abs(pp) - vec3(2.5,2.5,3.5);\n    rot(pp.xz, time*.5+cos(10.*ffts));\n    rot(pp.xy, fft*5.2);\n  }\n  float boxes = box(pp,1.0);\n  \n  pp = p;\n  \n  for (int i = 0; i < 5; ++i)\n  {\n    pp = abs(pp) - vec3(.5,3.0,5.5);\n    rot(pp.xy, time*.2+sin(6.*fft));\n    rot(pp.yz, time*.6+cos(12.*ffts));\n  }\n  \n  float boxes2 = box(pp,1.0*ffts*5.);\n  glow += vec3(0.9,0.04,0.5) * 0.05 / abs(boxes2)+0.01;    \n  glow += vec3(0.5,0.04,0.9) * 0.01 / abs(boxes)+0.001;\n  glow += vec3(0.08,0.45,0.85) * 0.02 / abs(spheres) +0.01;\n  glow += vec3(0.85,0.08,0.45) * 0.012 / abs(spheres3)+0.001;\n  glow += vec3(0.85,0.8,0.85) * 0.012 / abs(spheres4)+0.001;\n  glow += vec3(0.08,0.45,0.85) * 0.02 / abs(spheres2) +0.01;\n  glow += vec3(0.85,0.08,0.45) * 0.012 / abs(spheres5)+0.001;\n  glow += vec3(0.08,0.45,0.85) * 0.02 / abs(spheres6) +0.01;\n  return sphere(p,1.+ffts*12.);\n}\n\nfloat march (vec3 ro, vec3 rd){\n  float t = E;\n  vec3 p = ro;\n  for(int i = 0; i < STEPS; ++i)\n  {\n    float d = scene(p);\n    t += d;\n    p = ro+rd * t;\n    if (d < E || t > FAR) {\n      break;\n    }\n  }\n  return t;\n}\n\nvec3 normals(vec3 p){\n  vec3 e = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p + e.xyy) - scene(p - e.xyy),\n    scene(p + e.yxy) - scene(p - e.yxy),\n    scene(p + e.yyx) - scene(p - e.yyx)\n  ));\n}\n\nvec3 shade(vec3 rd, vec3 p, vec3 ld){\n  vec3 n = normals(p);\n  \n  float l = max(dot(n, ld), 0.0);\n  float a = max(dot(reflect(rd, ld), n), 0.0);\n  float s = pow(a, .1);\n  \n  return vec3(1.)*l + vec3(.9)*s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 col = vec3(0.0);\n  time = iTime;\n  ffts = texelFetch( iChannel0, ivec2(85,.25), 0).x*.05; \n  fft = iTime*.05+abs(texelFetch( iChannel0, ivec2(.1,.25), 0).x)*.01; \n  \n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 q = -1.0 + 2.0*uv;\n  q.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(4.0-sin(2.0*time)+sin(4.0*time)*3., -4.0+sin(time+ffts)*3., 15.0+cos(time)*5.);\n  vec3 rt = vec3(0.0, 0.0, -1.0);\n  \n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z, vec3(0.0,1.0,0.0)));\n  vec3 y = normalize(cross(x,z));\n  vec3 rd = normalize(mat3(x,y,z)*vec3(q,1.0/radians(94.0)));\n  \n  float t = march(ro, rd);\n  vec3 p = ro + rd * t;\n  vec3 ld = normalize(vec3(0.0,0.0,-10.0)-p);\n  \n  rot(q, time*.5);\n  \n  if (t < FAR){\n    col = shade(rd, p, ld)*.05;\n  }\n  \n  col += glow;\n  \n  fragColor = vec4(col,1.);\n  \n \n}", "buffer_a_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufA = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec4 bufB = texelFetch(iChannel1,ivec2(fragCoord),0);\n    fragColor = mix(bufB,bufA,0.5);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsySW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 117]], "test": "untested"}
{"id": "ddGXWh", "name": "BathroomFloor", "author": "elloskelling", "description": "Overlapping grids of squares, spinning at different rates", "tags": ["sound", "beat"], "likes": 1, "viewed": 139, "published": 3, "date": "1681013152", "time_retrieved": "2024-07-30T18:01:31.557782", "image_code": "float square(vec2 p, float size)\n{\n    p /= size;\n    vec2 q = mod(p, vec2(1.0));\n    if (q.x < 0.5 && q.y < 0.5) {\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    float size = 0.1;\n    float size2 = 0.11;\n    \n    float RV = 1.0;  // radians per second\n    float RV2 = 1.0+0.1*sin(iTime*0.05); // radians per second for second grid\n    \n    float beatThreshold = 0.5;\n    float pulseAmount = 1.75;\n    float pulseTime = 0.1;\n    float pulseWidth = 0.1;\n    float angle = iTime * RV;\n    float angle2 = iTime * RV2;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    mat2 rot2 = mat2(cos(angle2), -sin(angle2), sin(angle2), cos(angle2));\n    vec3 color = vec3(0.0);\n    vec2 q = vec2(p.x, p.y);\n    vec2 q2 = vec2(p.x+0.1*cos(iTime*0.1), p.y+0.1*sin(iTime*0.1));\n    \n    q = rot * q;\n    q2 = rot2 * q2;\n    q = mod(q, vec2(size, size));\n    q2 = mod(q2, vec2(size2, size2));\n\n\tfloat freqs[6];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.03, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.05, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[4] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[5] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\n    float beat = 0.25*freqs[0]*freqs[0]\n                +0.25*freqs[1]*freqs[1]\n                +0.25*freqs[2]*freqs[2]\n                +0.25*freqs[3]*freqs[3];\n    beat = sqrt(beat);\n    \n    float highs = sqrt(0.5*(freqs[4]*freqs[4]+freqs[5]*freqs[5]));\n    \n    size *= mix(1.2, pulseAmount, beat);\n    size2 *= mix(1.1, pulseAmount, highs);\n\n    if (square(q, size) > 0.5) {\n        color = vec3(0.6, 0.6, 0.6);\n    }\n    \n    if (square(q2, size2) > 0.5) {\n        if (square(q, size) > 0.5) {\n            color = vec3(1.0);\n        } else {\n            color = vec3(0.6, 0.6, 0.6);\n        }\n    }\n    fragColor = vec4(color+beat/2.5, 1.0);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 159], [161, 161, 216, 216, 2028]], "test": "untested"}
{"id": "msVXDR", "name": "Path tracer attempt 3 v2.1", "author": "pathtracerenthusiast", "description": "A path tracer with bloom, HDR, glossy reflections, multiple shapes, large amounts of configuration, glass, lights, and a good sky. Ive used stuff from Sebastian Lague and stuff produced by Bing AI and Ingo Quilez. Only9189 chars.", "tags": ["pathtracer"], "likes": 0, "viewed": 184, "published": 3, "date": "1680978809", "time_retrieved": "2024-07-30T18:01:32.674795", "image_code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings, go to the 'Buffer B' tab.\n//To set or rwmove the maximum fnumber of frames go to the 'Common' tab.\n\n#define Bloom\n\n//I used the Bing AI to improve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  float n = 1./float(2*w*w);\n  const float invpi = 1./PI;\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      float weight = n*invpi*exp(-float(x*x+y*y)*n);\n      //float weight = 1.;\n      color += texture(s, uv).xyz*weight;\n    }\n  }\n  return color;\n}\n\n#define size 3.5*((R.x+R.y)*.00119048)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    #ifdef Bloom\n    #ifdef maxFrame\n    if(iFrame>=maxFrame)\n    #endif\n    o.xyz += blur(iChannel1,i/R,int(size));\n    #endif\n    \n    //Comment out the above and uncomment the below to see what will be bloomed.\n    //o.xyz = texelFetch(iChannel1,ivec2(i),0).xyz;\n    \n    o /= o+1.;\n    o = pow(o,vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.1415926523\n#define sat(a) clamp(a,0.,1.)\n#define md(a,b) max(dot(a,b),0.)\n#define d2r(a) a*(PI/180.)\n\n//#define maxFrame 200\n\nfloat _seed;\nfloat rand(void) {\n    _seed += 1.;\n    return fract(81.29*sin(38.23*+_seed-12.13)-12.21);\n}\nvec2 rand2(void) {return vec2(rand(),rand());}\nfloat srand(float s) {\n    return fract(37.12*sin(91.04*s-76.82)-19.35);\n}\nvoid irand(vec2 c,float f){\n    _seed = srand(f)*f+srand(c.x)*c.y+srand(c.y)*c.x;\n}\n\nstruct Mat {\n    float r;\n    vec3 col;\n    vec3 ems;\n    float spch;\n    vec3 spcl;\n    float refidx;\n    bool refq;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rad;\n    bool solid;\n    Mat m;\n};\n\nstruct Plane {\n    vec4 p;\n    Mat m;\n};\n\nstruct Box{\n    vec3 pos,siz,rot;\n    bool solid;\n    Mat m;\n};\n\nstruct Quad {\n    vec3 v0,v1,v2,v3;\n    Mat m;\n};\n\n//d_spw => Spheres per world\n//d_bpw => Boxes per world\n//d_qpw => Quads per world\n//planeq => Planes per world\n#define d_spw 3\n#define d_bpw 1\n#define d_qpw 4\n#define planeq 0\nstruct World {\n    Sphere spheres[d_spw];\n    #if planeq==1\n    Plane plane;\n    #endif\n    Box boxes[d_bpw];\n    Quad quads[d_qpw];\n    \n};\n//TODO: Add more uses for WorldSize. Use it for lights as well? Should the number of planes be kept at 1?\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct Hit {\n    int id;\n    int type;\n    vec3 nor;\n    float len;\n    bool ff;\n};\n\nstruct Light {\n    vec3 pos,col;\n    float str;\n};\n\n\nvec2 sphereInt( in vec3 ro, vec3 rd, Sphere sphere) {\n    ro -= sphere.pos;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sphere.rad*sphere.rad;\n    float h = b*b - c;\n    if( h<0. ) return vec2(-1.);\n    h = sqrt( h );\n    if(length(ro)<=sphere.rad&&!sphere.solid){\n        return vec2(-b+h,1.);\n    }else{\n        return vec2(-b-h,0.);\n    }\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)-p.w)/dot(rd,p.xyz);\n}\n//The following function was generated by Bing AI\nfloat quadInt(vec3 ro, vec3 rd, Quad q) {\n    // Compute quad normal and plane constant\n    vec3 n = cross(q.v1-q.v0,q.v2-q.v0);\n    float d = dot(n, q.v0);\n    \n    // Check if ray is parallel to quad\n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    // Compute ray-plane intersection\n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    // Check if intersection point is inside quad\n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    // Otherwise, no hit\n    return -1.;\n}\n\nbool insideAabb(vec3 p,vec3 s){\n    return (p.x<=s.x&&p.x>=-s.x)&&(p.y<=s.y&&p.y>=-s.y)&&(p.z<=s.z&&p.z>=-s.z);\n}\n\nvec2 boxInt( in vec3 ro, in vec3 rd, vec3 b,bool solid) \n{\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*b;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return vec2(-1.);\n    if(insideAabb(ro,b)&&!solid){\n        return vec2(tF,1.);\n    }else{\n        return vec2(tN,0.);\n    }\n}\n\nconst float bias = 1.0001;\nvec3 boxNor(Box b,vec3 p){\n    vec3 q = p-b.pos;\n    vec3 d = b.siz;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float x = rand()*2.-1.;\n    float z = rand();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\nfloat reflectance(float cosv,float refidx){\n    float r0 = (1.-refidx)/(1.+refidx);\n    r0 *= r0;\n    return r0+(1.-r0)*pow(1.-cosv,5.);\n}", "buffer_a_code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n#define shutAp .6\n#define fcsDist 4.5\n#define blurAmt .048\n#define numLvls 8\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\n#define BeautifulSky\nconst float mode = 1.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\nvoid getScene(float t, out World world, out Viewer cam) {\n    cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(1.5,2.,-2.));\n    \n    mat2 rx = rot(d2r(0.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(0.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(0.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.spheres[0] = Sphere(vec3(-1.5,-.5,3.),1.5,false,Mat(.2,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false));\n    world.spheres[1] = Sphere(vec3(1.5,-1.,2.),1.,true,Mat(.8,vec3(1.),vec3(0.),0.,vec3(1.),1.52,true));\n    world.spheres[2] = Sphere(vec3(0.,-1002.001,.75),1000.,false,Mat(.75,vec3(.3,.4,1.),vec3(0.),.5,vec3(.2,.5,.15),1.52,false));\n    \n    world.boxes[0] = Box(vec3(0.,4.,.5),vec3(.75,.25,.75),d2r(vec3(0.)),false,Mat(.5,vec3(.75,.775,.9),vec3(5.),0.,vec3(0.),1.52,false));\n    \n    world.quads[0] = Quad(vec3(-3.5,-2.,-2.),vec3(3.5,-2.,-2.),vec3(3.5,-2.,3.5),vec3(-3.5,-2.,3.5),Mat(.7,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false));\n    world.quads[1] = Quad(vec3(-3.5,5.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(-3.5,5.,3.5),Mat(1.,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false));\n    world.quads[2] = Quad(vec3(-3.5,-2.,-2.),vec3(-3.5,5.,-2.),vec3(-3.5,5.,3.5),vec3(-3.5,-2.,3.5),Mat(.5,vec3(1.,0.,0.),vec3(0.),0.,vec3(1.,0.,0.),1.52,false));\n    world.quads[3] = Quad(vec3(3.5,-2.,-2.), vec3(3.5,5.,-2.), vec3(3.5,5.,3.5), vec3(3.5,-2.,3.5), Mat(.5,vec3(0.,1.,0.),vec3(0.),0.,vec3(0.,1.,0.),1.52,false));\n    \n    #if planeq==1\n    world.plane = Plane(vec4(normalize(vec3(0.,0.,-1.)),-3.5),Mat(.5+.5*sin(t),vec3(1.),vec3(0.,0.,.2),0.,vec3(1.),0.,false));\n    #endif\n}\nconst vec3 sunDir = normalize(vec3(.5,1.,.75));\n//Sebastian Lagues's sky function\nvec3 getSky(float t,vec3 rd) {\n    #ifdef BeautifulSky\n    float skyGradT = pow(smoothstep(0.,.4,rd.y),.35);\n    vec3 skyGrad = mix(vec3(.05),vec3(.3,.6,.9),skyGradT);\n    \n    vec3 sun = pow(max(0.,dot(rd,sunDir)),40.)*10.*vec3(1.,.75,.25);\n    \n    float groundT = smoothstep(-.01,0.,rd.y);\n    \n    return mix(vec3(.25),skyGrad,groundT)+sun;\n    #else\n    return vec3(0.);\n    #endif\n}\n\n\nHit intersect(vec3 ro, vec3 rd, World world) {\n    vec3 r = vec3(9999999.,-1.,-1.);\n    bool ff = true;\n    \n    for(int i = 0; i<d_spw;i++) {\n        vec2 d = sphereInt(ro,rd,world.spheres[i]);\n        if(d.x<r.x&&d.x>=.001) {r = vec3(d.x,i,0.);ff=d.y!=1.;}\n    }\n    \n    #if planeq==1\n    {\n        float d = planeInt(ro,rd,world.plane.p);;\n        if(d<r.x&&d>=.001) {r = vec3(d,0.,1.);ff=true;}\n    }\n    #endif\n    \n    for(int i = 0; i<d_bpw;i++) {\n        Box box = world.boxes[i];\n        mat3 rot = rot3(-box.rot);\n        vec2 d = boxInt((ro-box.pos)*rot,rd*rot,box.siz,box.solid);\n        if(d.x<r.x&&d.x>=.001) {r = vec3(d.x,i,2.);ff=d.y!=1.;}\n    }\n    \n    for(int i = 0; i<d_qpw;i++) {\n        float d = quadInt(ro,rd,world.quads[i]);\n        if(d<r.x&&d>=.001) {r = vec3(d,i,3.);ff=true;}\n    }\n    \n    Hit h = Hit(int(r.y),int(r.z),vec3(0.),r.x,ff);\n    \n    vec3 p = ro+rd*h.len;\n    \n    if(h.type==0) h.nor = normalize(p-world.spheres[h.id].pos);\n    #if planeq==1\n    else if(h.type==1) h.nor = world.plane.p.xyz;\n    #endif\n    else if(h.type==2) {Box b = world.boxes[h.id];h.nor = boxNor(b,b.pos+(p-b.pos)*rot3(-b.rot))*rot3(b.rot);}\n    else if(h.type==3) {Quad q = world.quads[h.id];h.nor = normalize(cross(q.v1-q.v0,q.v2-q.v0));}\n    \n    h.nor *= ff?1.:-1.;\n    \n    return h;\n}\n\nvec3 newRay(inout vec3 ro,inout vec3 rd,vec3 p,vec3 n,Mat m,float isSpec,bool ff) {\n    vec3 oro = ro; vec3 ord = rd;\n    ro = p;\n    if(m.refq){\n        float refrat = ff?1./m.refidx:m.refidx;\n        float cosT = max(dot(-rd,n),0.);\n        float sinT = sqrt(1.-cosT*cosT);\n        if(refrat*sinT<=1.&&reflectance(cosT,refrat)<=rand()) rd = refract(rd,n,refrat);\n        else rd = reflect(rd,n);\n    }else{\n        vec3 reflected = reflect(rd,n);\n        rd = normalize(mix(reflected,cosDir(reflected),m.r*(1.-isSpec)));\n    }\n    return mix(m.col,m.spcl,isSpec);\n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    #ifdef maxFrame\n    if(iFrame>=maxFrame) {o=texelFetch(iChannel0,ivec2(i),0);return;}\n    #endif\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = floor(iTime*mode)/mode;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        World world;\n        Viewer cam;\n        getScene(ctime,world,cam);\n        \n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        for(int _j = 0; _j<numLvls;_j++) {\n            Hit hit = intersect(cam.ro,rd,world); \n            if(hit.type==-1) {tcol+=getSky(ctime,rd)*fcol;break;}                             \n            \n            vec3 p = hit.len*rd+cam.ro;\n            Mat mat;\n            if(hit.type==0) {mat = world.spheres[hit.id].m;}\n            #if planeq==1\n            else if(hit.type==1) {mat = world.plane.m;}\n            #endif\n            else if(hit.type==2) {mat = world.boxes[hit.id].m;}\n            else if(hit.type==3) {mat = world.quads[hit.id].m;}\n            \n            #if 0\n            for(int _k=0;_k<3;_k++){\n                vec3 dir = uniformVec();\n                vec3 poi = rand()*hit.len*rd+cam.ro;\n                Hit h = intersect(poi,dir,world);\n                if(h.type<0){tcol += getSky(ctime,dir)*fcol;continue;}\n                Mat m;\n                if(h.type==0) {m = world.spheres[h.id].m;}\n                #if planeq==1\n                else if(h.type==1) {m = world.plane.m;}\n                #endif\n                else if(h.type==2) {m = world.boxes[h.id].m;}\n                else if(h.type==3) {m = world.quads[h.id].m;}\n                tcol += m.ems*fcol;\n            }\n            #endif\n            \n            float isSpec = mat.spch>rand()?1.:0.;\n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat,isSpec,hit.ff);\n            \n            #if 1\n            {\n                float r_p = max(fcol.x,max(fcol.y,fcol.z));\n                if(rand()>r_p) break;\n                fcol /= r_p;\n            }\n            #endif\n        }\n        \n        ttcol += tcol;\n    }\n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texture(iChannel0,i/R);\n    o /= o.w;\n    float d = dot(o.xyz,vec3(1.));\n    o.xyz = d>4.?o.xyz:vec3(0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 268, 307, 307, 697]], "test": "untested"}
{"id": "dtjXWW", "name": "Ray Marched 3D Cantor Dust", "author": "SpinningCube", "description": "Click and Drag to rotate the camera.\n\nIn my attempt to make a raymarched Menger sponge, I made this instead, and through a bit of searching found out that it is apparently called Cantor dust, a multidimensional representation of the Cantor set.", "tags": ["3d", "raymarching", "fractal", "cantor"], "likes": 7, "viewed": 251, "published": 3, "date": "1680977276", "time_retrieved": "2024-07-30T18:01:33.605307", "image_code": "/*\n * Ray Marched 3D Cantor Dust\n * \n * In my attempt to make a raymarched Menger sponge, I made this instead, and\n * through a bit of searching found out that it is apparently called Cantor dust,\n * a multidimensional representation of the Cantor set. 3D Cantor dust is also\n * sometimes called the Cantor cube.\n * \n * \n * by SpinningCube\n * \n */\n\nconst float pi = 3.1415926536;\n\n// These two aren't really all that related\nfloat minDist = 0.00002;\nfloat maxDist = 100.0;\n\nvec3 sunDir = vec3(1, 0.5, -0.5); // Vector pointing towards the sun\n\nvec3 ambient = vec3(0.05); // Color of the sky\n\nvec3 planeColor = vec3(0.05, 0.45, 0.8); // Color of the ground plane\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\nfloat sphere(vec3 samplePos, vec3 spherePos, float radius) {\n    return distance(samplePos, spherePos) - radius;\n}\n\nfloat ground(vec3 samplePos, float y) {\n    return samplePos.y - y;\n}\n\nfloat box(vec3 samplePos, vec3 boxCenter, vec3 boxSize) {   \n    vec3 dist0 = abs(samplePos - boxCenter) - boxSize;\n    return length(max(dist0, 0.0)) + min(0.0, max(max(dist0.x, dist0.y), dist0.z));\n}\n\n// SDF of 3D Cantor dust\n// Made in an attempt to make a Menger sponge\nfloat cantor(vec3 samplePos, vec3 center, vec3 size, int iter) {\n    samplePos -= center;\n    for (int i = 0; i < iter; i++) {\n        samplePos *= -sign(samplePos);\n        samplePos += size/1.5;\n        size /= 3.0;\n    }\n    return box(samplePos, vec3(0.0), size);\n    float dist = box(samplePos, vec3(0.0) + size * vec3(0.5, 0, 0), size * vec3(1.5, 1, 1));\n    dist = min(dist, box(samplePos, vec3(0.0) + size * vec3(0, 0.5, 0), size * vec3(1, 1.5, 1)));\n    dist = min(dist, box(samplePos, vec3(0.0) + size * vec3(0, 0, 0.5), size * vec3(1, 1, 1.5)));\n    return dist;\n}\n\nfloat sceneDist(vec3 pos) {\n    // Rotating the sample point, which rotates the object\n    vec3 objPos = pos;\n    objPos.xz *= rotate(-0.1 * iTime);\n    objPos.yz *= rotate(0.05 * iTime);\n    \n    int iter = int(5.0 * abs(mod(iTime/6.0 - 0.7, 2.0) - 1.0));\n    \n    float dist = cantor(objPos, vec3(0.0), vec3(0.3), iter);\n    dist = min(dist, ground(pos, -0.55));\n    \n    return dist;\n}\n\n// Tetrahedron sampling code by IQ\n// Modified to fit this project\nvec3 calcNormal( vec3 p, float epsilon ) {\n    float h = 2.5 * epsilon;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * sceneDist( p + k.xyy*h ) + \n                      k.yyx * sceneDist( p + k.yyx*h ) + \n                      k.yxy * sceneDist( p + k.yxy*h ) + \n                      k.xxx * sceneDist( p + k.xxx*h ) );\n}\n\nvec4 raycast(vec3 rayOrigin, vec3 rayDir, float maxDist, int maxIter, float epsilon, float initLength) {\n    float rayLength = initLength;\n    float SDE;\n    for (int i = 0; i < maxIter; i++) {\n        vec3 samplePos = rayOrigin + rayDir * rayLength;\n        SDE = sceneDist(samplePos);\n        rayLength += SDE;\n        \n        if (SDE < epsilon) {\n            return vec4(1, samplePos);\n        } else if (rayLength > maxDist) {\n            return vec4(0);\n        }\n    }\n    return vec4(0);\n}\n\nvec3 directionalLight(vec3 lightDir, vec3 lightColor, float intensity, vec3 surfNormal, vec3 surfPos, vec3 surfColor, float shadow) {\n    lightDir = normalize(lightDir);\n    vec4 shadowRay = raycast(surfPos + minDist * 1.01 * surfNormal, lightDir, maxDist, 500, minDist, 0.0);\n    return (1.0 - shadowRay.x * shadow) * lightColor * intensity * surfColor * max(0.0, dot(lightDir, surfNormal));\n}\n\nvec3 lighting(vec3 surfNormal, vec4 raycast, vec3 surfColor, vec3 ambient) {  \n    vec3 surfPos = raycast.yzw;\n    \n    vec3 col = vec3(0.0);\n    \n    // Direct Lighting\n    col += directionalLight(sunDir, vec3(1), 3.0, surfNormal, surfPos, surfColor, 1.0);\n    \n    // Bounce Lighting from Plane\n    col += surfColor * planeColor * 0.5 * max(0.0, (dot(surfNormal, vec3(0, -1, 0)) + 1.0));\n    \n    // Ambient Lighting from Sky\n    col += surfColor * ambient * 0.5 * max(0.0, (dot(surfNormal, vec3(0, 1, 0)) + 1.0));\n    \n    // Final color\n    return mix(ambient, col, raycast.x);\n}\n\n// Outputs rendered image in linear color\nvec3 render(vec2 fragCoord) {\n    \n    // Some scene parameters\n    float focalLength = 1.3;\n    vec3 camPos = vec3(0, 0, -1.5);\n    \n    // Convert screen coordinates to ray direction vectors\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 rayDir = normalize(vec3((fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y), focalLength));\n    \n    // Mouse controls\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5);   \n    if (mouse == vec2(-0.5)) {\n        mouse = vec2(-0.01, -.03);\n    }    \n    mouse.y = min(0.115, mouse.y);\n    \n    // Camera rotation\n    camPos.yz *= rotate(pi * -mouse.y);\n    camPos.xz *= rotate(2. * pi * -mouse.x);\n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    // Raycast and determine surface normal\n    vec4 raycast = raycast(camPos, rayDir, maxDist, 10000, minDist, 0.0);\n    vec3 surfNormal = calcNormal(raycast.yzw, minDist);\n    \n    // Object color\n    vec3 objectColor = raycast.yzw;\n    objectColor.xz *= rotate(3. * 0.2 * iTime);\n    objectColor.xy *= rotate(3. * 0.05 * iTime);\n    objectColor += vec3(0.45);  \n    objectColor = mix(vec3(0.8, 0.05, 0.0), objectColor, 0.75);\n    \n    // Calculate final color\n    return 1.5 * lighting(surfNormal, raycast, raycast.z < -0.5 ? planeColor : objectColor, ambient);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Render image\n    vec3 col = render(fragCoord);\n    \n    // Lazy tonemapping\n    col = vec3(tanh(1.1 * col.r), tanh(1.1 * col.g), tanh(1.1 * col.b));\n    \n    // Gamma correction\n    col = pow(col, vec3(1.0/2.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[663, 663, 685, 685, 779], [781, 781, 841, 841, 895], [897, 897, 936, 936, 966], [968, 968, 1025, 1025, 1169], [1171, 1242, 1306, 1306, 1817], [1819, 1819, 1846, 1905, 2207], [2209, 2276, 2318, 2318, 2612], [2614, 2614, 2718, 2718, 3111], [3113, 3113, 3246, 3246, 3507], [3509, 3509, 3585, 3585, 4092], [4094, 4136, 4165, 4199, 5453], [5455, 5455, 5512, 5532, 5794]], "test": "untested"}
{"id": "csGSzW", "name": "Path tracer attempt 3 v2.0", "author": "pathtracerenthusiast", "description": "A pathtracer. Bloom, HDR, importance sampling, completely configurable. There is a better sky now. I also added a feature that allows things like tomatoes to be made. Some improvments to bloom and the sphere intersector.", "tags": ["pathtracer"], "likes": 2, "viewed": 214, "published": 3, "date": "1680968009", "time_retrieved": "2024-07-30T18:01:35.184086", "image_code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings ,,go to the 'Buffer B' tab.\n\n//I used the Bing AI to improve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  float n = 1./float(2*w*w);\n  const float invpi = 1./PI;\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      float weight = n*invpi*exp(-float(x*x+y*y)*n);\n      //float weight = 1.;\n      color += texture(s, uv).xyz*weight;\n    }\n  }\n  return color;\n}\n\n#define size 3.25*((R.x+R.y)*.00119048)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    //Comment out to remove bloom.\n    o.xyz += blur(iChannel1,i/R,int(size));\n    \n    //Comment out the above and uncomment the below to see what will be bloomed.\n    //o.xyz = texelFetch(iChannel1,ivec2(i),0).xyz;\n    \n    o /= o+1.;\n    o = pow(o,vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.1415926523\n#define sat(a) clamp(a,0.,1.)\n#define md(a,b) max(dot(a,b),0.)\n#define d2r(a) a*(PI/180.)\n\nfloat _seed;\nfloat rand(void) {\n    _seed += 1.;\n    return fract(81.29*sin(38.23*+_seed-12.13)-12.21);\n}\nvec2 rand2(void) {return vec2(rand(),rand());}\nfloat srand(float s) {\n    return fract(37.12*sin(91.04*s-76.82)-19.35);\n}\nvoid irand(vec2 c,float f){\n    _seed = srand(f)*f+srand(c.x)*c.y+srand(c.y)*c.x;\n}\n\nvec3 mrefract(vec3 I,vec3 N,float i0,float i1){\n    float a = i0/i1;\n    float idn = dot(I,N);\n    float k = 1.-a*a*idn*idn;\n    if(k<0.) return vec3(0.);\n    return a*I-(a*idn+sqrt(k))*N;\n}\n\nstruct Mat {\n    float r;\n    vec3 col;\n    vec3 ems;\n    float spch;\n    vec3 spcl;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rad;\n    Mat m;\n};\n\nstruct Plane {\n    vec4 p;\n    Mat m;\n};\n\nstruct Box{\n    vec3 pos,siz,rot;\n    Mat m;\n};\n\nstruct Quad {\n    vec3 v0,v1,v2,v3;\n    Mat m;\n};\n\n//d_spw => Spheres per world\n//d_bpw => Boxes per world\n//d_qpw => Quads per world\n//planeq => Planes per world\n#define d_spw 3\n#define d_bpw 1\n#define d_qpw 4\n#define planeq 0\nstruct World {\n    Sphere spheres[d_spw];\n    #if planeq==1\n    Plane plane;\n    #endif\n    Box boxes[d_bpw];\n    Quad quads[d_qpw];\n    \n};\n//TODO: Add more uses for WorldSize. Use it for lights as well? Should the number of planes be kept at 1?\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct Hit {\n    int id;\n    int type;\n    vec3 nor;\n    float len;\n};\n\nstruct Light {\n    vec3 pos,col;\n    float str;\n};\n\n\nfloat sphereInt( in vec3 ro, vec3 rd, Sphere sphere) {\n    ro -= sphere.pos;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sphere.rad*sphere.rad;\n    float h = b*b - c;\n    if( h<0. ) return -1.;\n    h = sqrt( h );\n    if(length(ro)<=sphere.rad){\n        return -b+h;\n    }else{\n        return -b-h;\n    }\n}\n\nfloat planeInt( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)-p.w)/dot(rd,p.xyz);\n}\n//The following function was generated by Bing AI\nfloat quadInt(vec3 ro, vec3 rd, Quad q) {\n    // Compute quad normal and plane constant\n    vec3 n = cross(q.v1-q.v0,q.v2-q.v0);\n    float d = dot(n, q.v0);\n    \n    // Check if ray is parallel to quad\n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    // Compute ray-plane intersection\n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    // Check if intersection point is inside quad\n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    // Otherwise, no hit\n    return -1.;\n}\n\nfloat boxInt( in vec3 ro, in vec3 rd, vec3 b) \n{\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*b;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return -1.;\n    return tN;\n}\n\nconst float bias = 1.0001;\nvec3 boxNor(Box b,vec3 p){\n    vec3 q = p-b.pos;\n    vec3 d = b.siz;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float x = rand()*2.-1.;\n    float z = rand();\n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(phi),cos(phi)),x);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\nfloat fresnel(float n1, float n2, vec3 nor, vec3 I, float f0, float f90){\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(nor, I);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.-cosX*cosX);\n            if (sinT2 > 1.)\n                return f90;\n            cosX = sqrt(1.-sinT2);\n        }\n        float x = 1.-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        return mix(f0, f90, ret);\n}", "buffer_a_code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n#define shutAp .6\n#define fcsDist 1.3\n#define blurAmt .003\n#define numLvls 8\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\nconst float mode = 0.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\nvoid getScene(float t, out World world, out Viewer cam) {\n    cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(1.5,2.,-5.));\n    \n    mat2 rx = rot(d2r(-3.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(-3.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(-2.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.spheres[0] = Sphere(vec3(-1.5,-.5,3.),1.5,Mat(.2,vec3(1.),vec3(0.),0.,vec3(1.)));\n    world.spheres[1] = Sphere(vec3(1.5,-1.,2.),1.,Mat(.8,vec3(1.),vec3(0.),0.,vec3(1.)));\n    world.spheres[2] = Sphere(vec3(0.,-1002.,.75),1000.,Mat(.75,vec3(.3,.4,1.),vec3(0.),.5,vec3(.2,.5,.15)));\n    \n    world.boxes[0] = Box(vec3(0.,4.,.5),vec3(.75,.25,.75),d2r(vec3(0.)),Mat(.5,vec3(.25),vec3(7.5),.75,vec3(.75)));\n    \n    world.quads[0] = Quad(vec3(-3.5,-2.,-2.),vec3(3.5,-2.,-2.),vec3(3.5,-2.,3.5),vec3(-3.5,-2.,3.5),Mat(.7,vec3(1.),vec3(0.),0.,vec3(1.)));\n    world.quads[1] = Quad(vec3(-3.5,5.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(-3.5,5.,3.5),Mat(.3,vec3(1.),vec3(0.),0.,vec3(1.)));\n    world.quads[2] = Quad(vec3(-3.5,-2.,-2.),vec3(-3.5,5.,-2.),vec3(-3.5,5.,3.5),vec3(-3.5,-2.,3.5),Mat(.5,vec3(1.,0.,0.),vec3(0.),0.,vec3(1.,0.,0.)));\n    world.quads[3] = Quad(vec3(3.5,-2.,-2.), vec3(3.5,5.,-2.), vec3(3.5,5.,3.5), vec3(3.5,-2.,3.5), Mat(.5,vec3(0.,1.,0.),vec3(0.),0.,vec3(0.,1.,0.)));\n    \n    #if planeq==1\n    world.plane = Plane(vec4(normalize(vec3(0.,0.,-1.)),-3.5),Mat(.5+.5*sin(t),vec3(1.),vec3(0.,0.,.2),0.,vec3(1.)));\n    #endif\n}\nconst vec3 sunDir = normalize(vec3(.5,1.,.75));\n//Sebastian Lagues's sky function\nvec3 getSky(float t,vec3 rd) {\n    float skyGradT = pow(smoothstep(0.,.4,rd.y),.35);\n    vec3 skyGrad = mix(vec3(.05),vec3(.3,.6,.9),skyGradT);\n    \n    vec3 sun = pow(max(0.,dot(rd,sunDir)),40.)*3.*vec3(1.,.75,.25);\n    \n    float groundT = smoothstep(-.01,0.,rd.y);\n    \n    return mix(vec3(.25),skyGrad,groundT)+sun;\n}\n\n\nHit intersect(vec3 ro, vec3 rd, World world) {\n    vec3 r = vec3(9999999.,-1.,-1.);\n    \n    for(int i = 0; i<d_spw;i++) {\n        float d = sphereInt(ro,rd,world.spheres[i]);\n        if(d<r.x&&d>=.001) r = vec3(d,i,0.);\n    }\n    \n    #if planeq==1\n    {\n        float d = planeInt(ro,rd,world.plane.p);;\n        if(d<r.x&&d>=.001) r = vec3(d,0.,1.);\n    }\n    #endif\n    \n    for(int i = 0; i<d_bpw;i++) {\n        mat3 rot = rot3(-world.boxes[i].rot);\n        float d = boxInt((ro-world.boxes[i].pos)*rot,rd*rot,world.boxes[i].siz);\n        if(d<r.x&&d>=.001) r = vec3(d,i,2.);\n    }\n    \n    for(int i = 0; i<d_qpw;i++) {\n        float d = quadInt(ro,rd,world.quads[i]);\n        if(d<r.x&&d>=.001) r = vec3(d,i,3.);\n    }\n    \n    Hit h = Hit(int(r.y),int(r.z),vec3(0.),r.x);\n    \n    vec3 p = ro+rd*h.len;\n    \n    if(h.type==0) h.nor = normalize(p-world.spheres[h.id].pos);\n    #if planeq==1\n    else if(h.type==1) h.nor = world.plane.p.xyz;\n    #endif\n    else if(h.type==2) {Box b = world.boxes[h.id];h.nor = boxNor(b,b.pos+(p-b.pos)*rot3(-b.rot))*rot3(b.rot);}\n    else if(h.type==3) {Quad q = world.quads[h.id];h.nor = normalize(cross(q.v1-q.v0,q.v2-q.v0));}\n    \n    return h;\n}\n\nvec3 newRay(inout vec3 ro,inout vec3 rd,vec3 p,vec3 n,Mat m,float isSpec) {\n    vec3 oro = ro; vec3 ord = rd;\n    ro = p;\n    float r = 2.*m.r-m.r*m.r;\n    vec3 reflected = reflect(rd,n);\n    rd = normalize(mix(reflected,cosDir(reflected),m.r*(1.-isSpec)));\n    return mix(m.col,m.spcl,isSpec);\n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = floor(iTime*mode)/mode;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        World world;\n        Viewer cam;\n        getScene(ctime,world,cam);\n        \n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        for(int _j = 0; _j<numLvls;_j++) {\n            Hit hit = intersect(cam.ro,rd,world);\n            if(hit.type==-1) {tcol+=getSky(ctime,rd)*fcol*clamp(pow(1.3,-float(_j)),.5,1.);break;}\n            //                                            The above darkens the sky with each bounce.\n            \n            vec3 p = hit.len*rd+cam.ro;\n            Mat mat;\n            if(hit.type==0) {mat = world.spheres[hit.id].m;}\n            #if planeq==1\n            else if(hit.type==1) {mat = world.plane.m;}\n            #endif\n            else if(hit.type==2) {mat = world.boxes[hit.id].m;}\n            else if(hit.type==3) {mat = world.quads[hit.id].m;}\n            \n            #if 0\n            for(int _k=0;_k<3;_k++){\n                vec3 dir = uniformVec();\n                vec3 poi = rand()*hit.len*rd+cam.ro;\n                Hit h = intersect(poi,dir,world);\n                if(h.type<0){tcol += getSky(ctime,dir)*fcol;continue;}\n                Mat m;\n                if(h.type==0) {m = world.spheres[h.id].m;}\n                #if planeq==1\n                else if(h.type==1) {m = world.plane.m;}\n                #endif\n                else if(h.type==2) {m = world.boxes[h.id].m;}\n                else if(h.type==3) {m = world.quads[h.id].m;}\n                tcol += m.ems*fcol;\n            }\n            #endif\n            \n            float isSpec = mat.spch>rand()?1.:0.;\n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat,isSpec);\n            \n            #if 1\n            {\n                float r_p = max(fcol.x,max(fcol.y,fcol.z));\n                if(rand()>r_p) break;\n                fcol /= r_p;\n            }\n            #endif\n        }\n        \n        ttcol += tcol;\n    }\n    o += vec4(ttcol / spp,1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texture(iChannel0,i/R);\n    o /= o.w;\n    float d = dot(o.xyz,vec3(1.));\n    o.xyz = d>2.25?o.xyz:vec3(0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 181, 220, 220, 610], [652, 652, 691, 691, 1020]], "test": "untested"}
{"id": "Ds3SWf", "name": "flow field 1", "author": "frosty", "description": "pushing pixels tangential to image gradient", "tags": ["texture", "gradient", "flow", "sobol"], "likes": 4, "viewed": 260, "published": 3, "date": "1680954560", "time_retrieved": "2024-07-30T18:01:36.261206", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord/iResolution.xy);\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord/iResolution.xy);\n    \n    vec2 r = vec2(textureSize(iChannel0, 0));\n    \n    vec2 d0100 = vec2(1, 0) / r;\n    vec2 d0001 = vec2(0, 1) / r;\n    \n    vec2 t0101 = uv;\n    \n    vec2 t0000 = t0101 - d0100 - d0001;\n    vec2 t0001 = t0000 + d0001;\n    vec2 t0010 = t0001 + d0001;\n    \n    vec2 t0100 = t0101 - d0001;\n    vec2 t0110 = t0101 + d0001;\n    \n    vec2 t1000 = t0101 + d0100 - d0001;\n    vec2 t1001 = t1000 + d0001;\n    vec2 t1010 = t1000 + d0001;\n    \n    vec4 c0000 = texture(iChannel0, t0000);\n    vec4 c0001 = texture(iChannel0, t0001);\n    vec4 c0010 = texture(iChannel0, t0010);\n    vec4 c0100 = texture(iChannel0, t0100);\n    vec4 c0101 = texture(iChannel0, t0101);\n    vec4 c0110 = texture(iChannel0, t0110);\n    vec4 c1000 = texture(iChannel0, t1000);\n    vec4 c1001 = texture(iChannel0, t1001);\n    vec4 c1010 = texture(iChannel0, t1010);\n    \n    float K0000 = 1.0;\n    float K0001 = 2.0;\n    float K0010 = 1.0;\n    float K0100 = 0.0;\n    float K0101 = 0.0;\n    float K0110 = 0.0;\n    float K1000 = -1.0;\n    float K1001 = -2.0;\n    float K1010 = -1.0;    \n    \n    vec4 Du = \n          K0000 * c0000\n        + K0001 * c0001\n        + K0010 * c0010\n        + K0100 * c0100\n        + K0101 * c0101\n        + K0110 * c0110\n        + K1000 * c1000\n        + K1001 * c1001\n        + K1010 * c1010;\n        \n    vec4 Dv = \n          K0000 * c0000\n        + K0100 * c0001\n        + K1000 * c0010\n        + K0001 * c0100\n        + K0101 * c0101\n        + K1001 * c0110\n        + K0010 * c1000\n        + K0110 * c1001\n        + K1010 * c1010;\n        \n    float du = (Du.x + Du.y + Du.z) / 3.0;\n    float dv = (Dv.x + Dv.y + Dv.z) / 3.0;\n    \n    //fragColor = vec4(du, dv, 0.0, 0.0);\n    //fragColor = vec4(du, dv, 0.0, 0.0);\n    vec2 D = vec2(-dv, du);\n    vec2 st = uv - 0.01 * D;    \n    //fragColor = vec4(-D, 0.0, 1.0);\n    if (iFrame == 0) {\n        fragColor = texture(iChannel0, st);\n    }\n    else {\n        fragColor = texture(iChannel1, st);\n    }\n    //fragColor = vec4(du, dv, 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3SWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 145]], "test": "untested"}
{"id": "msBSWK", "name": "Falling Sand CA Ultimate", "author": "gelami", "description": "An improved falling sand cellular automata simulation\n\nControls:\nMouse to draw\n0-9 Select material\nArrow keys to move camera\n-/+ Zoom in/out\n[ / ] Change mouse radius", "tags": ["automata", "falling", "cellular", "sand", "margolus"], "likes": 44, "viewed": 910, "published": 3, "date": "1680942427", "time_retrieved": "2024-07-30T18:01:37.980609", "image_code": "// Fork of \"Falling Sand CA v2\" by gelami. https://shadertoy.com/view/DsSSRd\n// 2022-12-12 20:12:05\n\n// Falling Sand CA Ultimate by gelami\n// https://www.shadertoy.com/view/msBSWK\n\n/*\n *  An improved falling sand cellular automaton simulation\n *  \n *  Cells are processed in 2x2 blocks to simplify the neighborhood checks\n *  and allows them to be processed in parallel without race conditions.\n *  The blocks are then offset using a cyclic Margolus neighborhood offset to prevent bias\n *  Has multiple types of materials that can interact with each other different\n *\n *  The biggest change from the previous iterations is the introduction of\n *  swaps instead of a 1D linear mapping of state in each block.\n *  Each cell in a 2x2 block can switch its position with another cell in the same block,\n *  Leading to a simpler model that can support multiple types of materials\n *  \n *  Controls:\n *  Mouse: Draw Material\n *  0 - 9: Select Material Type\n *  \n *  Arrow Keys: Move Camera\n *  Plus/Minus: Zoom in/out\n *  Left/Right Brackets: Change Mouse Radius\n *  \n *  Space: Clear\n *  R: Reset\n *\n *  1: Smoke\n *  2: Fire\n *  3: Lava\n *  4: Water\n *  5: Sand\n *  6: Stone\n *  7: Wood\n *  8: Grass\n *  9: Wall\n *  0: Eraser\n *  \n *  This is one of 4 shaders that explores falling sand cellular automata in the GPU\n * \n *  Previous entries:\n *  Falling Sand CA v1 - gelami\n *  https://www.shadertoy.com/view/DsjSzc\n *  \n *  Falling Sand CA v2 - gelami\n *  https://www.shadertoy.com/view/DsSSRd\n *  \n */\n\n// Pixel Art Filtering by Klems\n// https://www.shadertoy.com/view/MllBWf\nvec2 getCoordsAA(vec2 uv)\n{\n    float w = 1.0; // 1.5\n    vec2 fl = floor(uv + 0.5);\n    vec2 fr = fract(uv + 0.5);\n    vec2 aa = fwidth(uv) * w * 0.5;\n    fr = smoothstep(0.5 - aa, 0.5 + aa, fr);\n    \n    return fl + fr - 0.5;\n}\n\nvec4 sampleTexAA(sampler2D ch, vec2 uv, vec2 res)\n{\n    return texture(ch, getCoordsAA(uv) / res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+4);\n    vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n    vec4 mouse = texelFetch(iChannel0, IRES-ivec2(2, 1), 0);\n    float scale = scene.x;\n    vec2 center = scene.zw;\n    float radius = mouse.x;\n    float id = mouse.y;\n    float px = 1.0 / scale;\n    \n    fragCoord -= RES * 0.5;\n    fragCoord /= scale;\n    fragCoord += center;\n    \n    fragColor = sampleTexAA(iChannel2, fragCoord, RES);\n    \n    vec2 mousePos = (iMouse.xy - RES * 0.5) / scale + center;\n    float brush = smoothstep(0.0, px, abs(length(fragCoord - mousePos) - radius));\n    \n    float bleft = texelFetch(iChannel3, ivec2(KEY_BRACKET_LEFT, 0), 0).r;\n    float bright = texelFetch(iChannel3, ivec2(KEY_BRACKET_RIGHT, 0), 0).r;\n        \n    if (iMouse.z > 0.0 || bleft > 0.0 || bright > 0.0)\n        fragColor = mix(fragColor, vec4(0.8), 1.0-brush);\n    \n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0));\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define BUFFER_OFFSET 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    // Keyboard functions\n    if (p == IRES-1)\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(SCALE, 0, ZOOM_POINT);\n            return;\n        }\n        \n        vec4 prev = texelFetch(iChannel0, p, 0);\n    \n        float up = texelFetch(iChannel3, ivec2(KEY_UP, 0), 0).r;\n        float down = texelFetch(iChannel3, ivec2(KEY_DOWN, 0), 0).r;\n        float left = texelFetch(iChannel3, ivec2(KEY_LEFT, 0), 0).r;\n        float right = texelFetch(iChannel3, ivec2(KEY_RIGHT, 0), 0).r;\n    \n        float zoomin = texelFetch(iChannel3, ivec2(KEY_PLUS, 0), 0).r;\n        float zoomout = texelFetch(iChannel3, ivec2(KEY_MINUS, 0), 0).r;\n\n        vec2 speed = vec2(15.0 / prev.x);\n        float zoom = log2(prev.x + 1.0) * 0.08;\n        \n        if (zoomin > 0.0)\n            prev.x += zoom;\n        if (zoomout > 0.0)\n            prev.x -= zoom;\n        \n        prev.x = max(prev.x, 1.0);\n    \n        prev.w += up * speed.y;\n        prev.w -= down * speed.y;\n        prev.z -= left * speed.x;\n        prev.z += right * speed.x;\n        \n        prev.zw = clamp(prev.zw, RES * 0.5 / prev.x, RES - RES * 0.5 / prev.x);\n        \n        fragColor = prev;\n        return;\n        \n    } else if (p == IRES - ivec2(2, 1))\n    {\n        if (iFrame < 2)\n        {\n            fragColor = vec4(MOUSE_RADIUS, SAND, 0, 0);\n            return;\n        }\n        \n        vec4 prev = texelFetch(iChannel0, p, 0);\n                \n        for (int i = 0; i < 10; i++)\n        {\n            if (texelFetch(iChannel3, ivec2(KEY_0 + i, 0), 0).r > 0.0)\n                prev.y = float(i);\n        }\n        \n        float bleft = texelFetch(iChannel3, ivec2(KEY_BRACKET_LEFT, 0), 0).r;\n        float bright = texelFetch(iChannel3, ivec2(KEY_BRACKET_RIGHT, 0), 0).r;\n        \n        float radiusChange = 0.2;\n        prev.x -= bleft * radiusChange;\n        prev.x += bright * radiusChange;\n        \n        prev.x = max(prev.x, 1.0);\n        \n        if (iMouse.z > 0.0)\n        {\n            prev.zw = iMouse.xy;\n        } else {\n            prev.zw = vec2(0);\n        }\n        \n        fragColor = prev;\n        return;\n    }\n    \n    float space = texelFetch(iChannel3, ivec2(KEY_SPACE, 0), 0).r;\n    float reset = texelFetch(iChannel3, ivec2(KEY_R, 0), 0).r;\n    \n    if (space > 0.0)\n    {\n    \n        fragColor = vec4(AIR, 0, fragCoord / RES);\n        return;\n    }\n    \n    if (iFrame < 2 || reset > 0.0)\n    {\n        if (fragCoord.y == 0.5)\n        {\n            fragColor = vec4(WALL, 0, fragCoord / RES);\n            return;\n        }\n        \n        vec4 tex = texture(iChannel1, fragCoord / RES);\n        float id = mod(round(tex.x * WALL * 3.0 - 1.0), WALL+1.0);\n        \n        if (id == LAVA && tex.y < 0.2)\n            id = SMOKE;\n        if (id == STONE && tex.z < 0.3)\n            id = SAND;\n        if (id == PLANT && hash(state) < 0.8)\n            id = WATER;\n        \n        //float id = hash(state) < 0.05 ? SAND : AIR;\n        fragColor = vec4(id, 0, fragCoord / RES);\n        return;\n    }\n\n    vec2 mousePos = vec2(0);\n    // Mouse interaction\n    if (iMouse.z > 0.0)\n    {\n        mousePos = iMouse.xy;   \n    } else {\n        //mp = vec2(sin(iTime * 0.9) * 0.4 * RES.x + RES.x * 0.5, RES.y * 0.8);\n    }\n    \n    if (mousePos != vec2(0))\n    {\n        vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n        vec4 mouse = texelFetch(iChannel0, IRES-ivec2(2, 1), 0);\n        float scale = scene.x;\n        vec2 center = scene.zw;\n        float radius = mouse.x;\n        float id = mouse.y;\n        vec2 prevMousePos = mouse.zw;\n        \n        if (prevMousePos != vec2(0))\n        {\n            vec2 m = (mousePos - RES * 0.5) / scale + center;\n            vec2 mp = (prevMousePos - RES * 0.5) / scale + center;\n            float d = sdSegment(fragCoord, m, mp);\n            //float d = length(fragCoord - m);\n\n            if (d < radius && hash(state) < MOUSE_STRENGTH)\n            {\n                fragColor = vec4(id, 0, fragCoord / RES + iTime * 0.1);\n                return;\n            }\n        }\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n    fragColor.y = getOpacity(fragColor.x);\n    if (fragColor.x == FIRE || fragColor.x == LAVA)\n        fragColor.y = 0.0;\n    //fragColor.y = float(fragColor.x != AIR);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SCALE 2.0\n\n#define MOUSE_RADIUS 3.0\n#define MOUSE_STRENGTH 0.5\n\n#define IMPROVED_OFFSET\n\n//#define RAINBOW_MODE\n\n#define ZOOM_POINT vec2(RES * 0.5 / SCALE)\n\n#define AIR 0.0\n#define SMOKE 1.0\n#define FIRE 2.0\n#define LAVA 3.0\n#define WATER 4.0\n#define SAND 5.0\n#define STONE 6.0\n#define WOOD 7.0\n#define PLANT 8.0\n#define WALL 9.0\n\n#define EPSILON 1e-4\n\n#define RES iResolution.xy\n#define IRES ivec2(iResolution.xy)\n\n#define sampleTex0(p) texelFetch(iChannel0, ivec2(p) % IRES, 0)\n#define sampleTex1(p) texelFetch(iChannel1, ivec2(p), 0)\n\n#define PI (acos(-1.0))\n#define TAU (2.0 * PI)\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_0 = 48;\n\nconst int KEY_PLUS = 187;\nconst int KEY_MINUS = 189;\n\nconst int KEY_BRACKET_LEFT = 219;\nconst int KEY_BRACKET_RIGHT = 221;\n\nconst int KEY_SPACE = 32;\nconst int KEY_R = 82;\n\n// 1D LOD Gaussian blur from Fabrice\n// https://www.shadertoy.com/view/WtKfD3\nvec4 gaussian1D(sampler2D tx, vec2 U, vec2 D, vec2 R)\n{\n    const int N = 32;\n    const float w = 0.1;\n    \n    float z = ceil(max(0., log2(w*R.y/float(N))));\n    \n    vec4  O = vec4(0);                                                      \n    float r = float(N-1)/2., g, t=0., x;                                    \n    for( int k=0; k<N; k++ ) {                                              \n        x = float(k)/r-1.;                                                  \n        t += g = exp(-8.0*x*x );                                            \n        O += g * texture(tx, (U+w*x*D) *R.y/R, z );     \n    }                                                                       \n    return O/t;                                                             \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// Modified to work with 4 values at once\nuvec4 hash4i(inout uint y)\n{\n    uvec4 x = y * uvec4(213u, 2131u, 21313u, 213132u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvoid swap(inout vec4 a, inout vec4 b)\n{\n    vec4 tmp = a;\n    a = b;\n    b = tmp;\n}\n\nvec4 sampleCells(sampler2D ch, ivec2 p, ivec2 res)\n{\n    if (p.x == 0 && p.y == 0)\n        return vec4(WALL, 0, 0, 0);\n        \n    if (p.x < 0 || p.x >= res.x || p.y < 0 || p.y >= res.y)\n        return vec4(WALL, 0, 0, 0);\n    \n    if (p.x >= res.x-1 || p.y >= res.y-1)\n        return vec4(WALL, 0, 0, 0);\n    \n    p = clamp(p, ivec2(0), res-1);  \n    \n    vec4 tex = texelFetch(ch, ivec2(p), 0);\n    \n    return tex;\n}\n\nivec2 getMargolusOffset(int frame)\n{\n#ifndef IMPROVED_OFFSET\n    frame = frame % 2;\n    if (frame == 1)\n        return ivec2(1, 1);\n    return ivec2(0, 0);\n#else\n    frame = frame % 4;\n\n    if (frame == 1)\n        return ivec2(1, 1);\n    else if (frame == 2)\n       return ivec2(0, 1);\n    else if (frame == 3)\n        return ivec2(1, 0);\n    return ivec2(0, 0);\n#endif\n}\n\nint cellToID(vec4 p)\n{\n    return int(dot(p, vec4(1, 2, 4, 8)));\n}\n\nvec4 IDToCell(int id)\n{\n    return vec4(id%2, (id/2)%2, (id/4)%2, (id/8)%2);\n}\n\nfloat getOpacity(float id)\n{\n    if (id == SMOKE)\n        return 0.2;\n    else if (id == FIRE)\n        return 0.8;\n    else if (id == LAVA)\n        return 0.9;\n    else if (id == WATER)\n        return 0.4;\n    else if (id >= SAND)\n        return 1.0;\n    return 0.0;\n}\n\nvec4 simulate(sampler2D ch, ivec2 p, ivec2 res, int frame, int bof)\n{\n    ivec2 of = getMargolusOffset(frame + bof);\n        \n    p += of;\n    \n    ivec2 fp = (p / 2) * 2;\n    ivec2 fr = p & 1;\n    int x = fr.x + (fr.y) * 2;\n    \n    fp -= of;\n    p -= of;\n    \n    vec4 t00 = sampleCells(ch, fp + ivec2(0, 0), res);\n    vec4 t10 = sampleCells(ch, fp + ivec2(1, 0), res);\n    vec4 t01 = sampleCells(ch, fp + ivec2(0, 1), res);\n    vec4 t11 = sampleCells(ch, fp + ivec2(1, 1), res);\n    \n    if (t00.x == AIR && t10.x == AIR &&\n        t01.x == AIR && t11.x == AIR)\n        return vec4(0);\n    \n    vec4 tn00 = sampleCells(ch, fp + ivec2(0, -1), res);\n    vec4 tn10 = sampleCells(ch, fp + ivec2(1, -1), res);\n    \n    ivec2 o = ivec2(fr.x, fr.y);\n    \n    vec4 v = hash43(uvec3(fp, frame));\n    vec4 v2 = hash43(uvec3(fp, frame/8));\n    \n    if (v.x < 0.5)\n    {\n        swap(t00, t10);\n        swap(t01, t11);\n    }\n    \n    // Sand\n    if ((t01.x == SAND && t11.x < SAND ||\n        t01.x < SAND && t11.x == SAND) &&\n        t00.x < SAND && t10.x < SAND && v.y < 0.4)\n    {\n        swap(t01, t11);\n    }\n    if (t01.x == SAND)\n    {\n        if (t00.x < SAND)\n        {\n            if (v.z < 0.9) swap(t01, t00);\n        } else if (t11.x < SAND && t10.x < SAND)\n        {\n            swap(t01, t10);\n        }\n    }\n    if (t11.x == SAND)\n    {\n        if (t10.x < SAND)\n        {\n            if (v.z < 0.9) swap(t11, t10);\n        } else if (t00.x < SAND && t01.x < SAND)\n        {\n            swap(t11, t00);\n        }\n    }\n    \n    // Stone\n    if ((t01.x == STONE && t11.x < SAND ||\n        t01.x < SAND && t11.x == STONE) &&\n        t00.x < SAND && t10.x < SAND && v.y < 0.05)\n    {\n        swap(t01, t11);\n    }\n    if (t01.x == STONE && v.z < 0.8)\n    {\n        if (t00.x < SAND)\n        {\n            swap(t01, t00);\n        } else if (t11.x < SAND && t10.x < SAND)\n        {\n            swap(t01, t10);\n        }\n    }\n    if (t11.x == STONE && v.z < 0.8)\n    {\n        if (t10.x < SAND)\n        {\n            swap(t11, t10);\n        } else if (t00.x < SAND && t01.x < SAND)\n        {\n            swap(t11, t00);\n        }\n    }\n    \n    // Water\n    if ((t00.x == WATER || t10.x == WATER ||\n         t01.x == WATER || t11.x == WATER))\n    {\n        if (t00.x == FIRE)\n        {\n            t00.x = SMOKE;\n        }\n        if (t10.x == FIRE)\n        {\n            t10.x = SMOKE;\n        }\n        if (t01.x == FIRE)\n        {\n            t01.x = SMOKE;\n        }\n        if (t11.x == FIRE)\n        {\n            t11.x == SMOKE;\n        }\n    }\n    \n    bool a = false;\n    if (t01.x == WATER)\n    {\n        if (t00.x < WATER && v.z < 0.95)\n        {\n            //if (v.z < 0.9)\n                swap(t01, t00);\n                a = true;\n        } \n        else if (t11.x < WATER && t10.x < WATER && v.x < 0.2)\n        {\n            swap(t01, t10);\n            a = true;\n        }\n    }\n    if (t11.x == WATER)\n    {\n        if (t10.x < WATER && v.z < 0.95)\n        {\n            //if (v.z < 0.9)\n                swap(t11, t10);\n                a = true;\n                \n        } else if (t01.x < WATER && t00.x < WATER && v.x < 0.2)\n        {\n            swap(t11, t00);\n            a = true;\n        }\n    }\n    //if (t00.x >= WATER && t10.x >= WATER)\n    //if (v.w < 1.0)\n    if (!a)\n    {\n        if ((t01.x == WATER && t11.x < WATER ||\n            t01.x < WATER && t11.x == WATER) &&\n            (t00.x >= WATER && t10.x >= WATER || v.w < 0.8))\n        {\n            swap(t01, t11);\n        }\n        if ((t00.x == WATER && t10.x < WATER ||\n            t00.x < WATER && t10.x == WATER) &&\n            (tn00.x >= WATER && tn10.x >= WATER || v.w < 0.8))\n        {\n            swap(t00, t10);\n        }\n    }\n    \n    \n    // Lava\n    if ((t00.x == LAVA && t10.x < LAVA ||\n        t00.x < LAVA && t10.x == LAVA) && v.y < 0.2)\n    {\n        swap(t00, t10);\n    }\n    if (t01.x == LAVA)\n    {\n        if (t00.x == WATER)\n        {\n            t01.x = STONE;\n            t00.x = SMOKE;\n        }\n        if (t11.x == WATER)\n        {\n            t01.x = STONE;\n            t11.x = SMOKE;\n        }\n        if (t00.x < LAVA)\n        {\n            if (v.z < 0.5) swap(t01, t00);\n        } \n        else if (t11.x < LAVA && t10.x < LAVA)\n        {\n            swap(t01, t10);\n        }\n    }\n    if (t11.x == LAVA)\n    {\n        if (t01.x == WATER)\n        {\n            t11.x = STONE;\n            t01.x = SMOKE;\n        }\n        if (t10.x == WATER)\n        {\n            t11.x = STONE;\n            t10.x = SMOKE;\n        }\n        if (t10.x < LAVA)\n        {\n            if (v.z < 0.5) swap(t11, t10);\n        }\n        else if (t01.x < LAVA && t00.x < LAVA)\n        {\n            swap(t11, t00);\n        }\n    }\n    \n    \n    // Smoke\n    if (t00.x == SMOKE && t01.x > SMOKE && v.w < 0.02)\n    {\n        t00.x = AIR;\n    }\n    \n    if ((t00.x == SMOKE && t10.x < SMOKE ||\n        t00.x < SMOKE && t10.x == SMOKE) && v.y < 0.1)\n    {\n        swap(t00, t10);\n    }\n    if ((t01.x == SMOKE && t11.x < SMOKE ||\n        t01.x < SMOKE && t11.x == SMOKE) && v.y < 0.1)\n    {\n        swap(t01, t11);\n    }\n    if (t00.x == SMOKE)\n    {\n        if (t01.x < SMOKE)\n        {\n            if (v.z < 0.2)\n                swap(t00, t01);\n        } else if (t10.x < SMOKE)\n        {\n            swap(t00, t10);\n        }\n    }\n    if (t10.x == SMOKE)\n    {\n        if (t11.x < SMOKE)\n        {\n            if (v.z < 0.2)\n                swap(t10, t11);\n        } else if (t00.x < SMOKE)\n        {\n            swap(t10, t00);\n        }\n    }\n    \n    \n    // Fire\n    if ((t00.x == FIRE || t10.x == FIRE ||\n         t01.x == FIRE || t11.x == FIRE ||\n         t00.x == LAVA || t10.x == LAVA ||\n         t01.x == LAVA || t11.x == LAVA) && v.x < 0.03)\n    {\n        if (t00.x == WOOD || t00.x == PLANT)\n        {\n            t00.x = FIRE;\n        }\n        if (t10.x == WOOD || t00.x == PLANT)\n        {\n            t10.x = FIRE;\n        }\n        if (t01.x == WOOD || t00.x == PLANT)\n        {\n            t01.x = FIRE;\n        }\n        if (t11.x == WOOD || t00.x == PLANT)\n        {\n            t11.x == FIRE;\n        }\n    }\n    \n    if ((t01.x == FIRE && t11.x < FIRE ||\n        t01.x < FIRE && t11.x == FIRE) && v.y < 0.05)\n    {\n        swap(t01, t11);\n    }\n    if (t00.x == FIRE)\n    {\n        if (t01.x == AIR && v.w < 0.005)\n        {\n            t01.x = SMOKE;\n        }\n        \n        if (v.x < 0.002)\n        {\n            t00.x = SMOKE;\n        } else if (v.z < 0.05)\n        {\n            if (t01.x < FIRE)\n            {\n                    swap(t00, t01);\n            } else if (t10.x < FIRE)\n            {\n                swap(t00, t10);\n            }\n        }\n    }\n    if (t10.x == FIRE)\n    {\n        if (v.x < 0.002)\n        {\n            t10.x = SMOKE;\n        }\n        else if (v.z < 0.05)\n        {\n            if (t11.x < FIRE)\n            {\n                swap(t10, t11);\n            } else if (t00.x < FIRE)\n            {\n                swap(t10, t00);\n            }\n         }\n    }\n    \n    // Plant\n    if (t00.x == PLANT && t01.x == WATER && t10.x != PLANT &&\n       (tn00.x == SAND || tn00.x == PLANT) && v.w < 0.01)\n    {\n        t01.x = PLANT;\n    }\n    if (t01.x == PLANT)\n    {\n        if (t00.x < SAND)\n        {\n            swap(t01, t00);\n        }\n    }\n    \n    \n    if (v.x < 0.5)\n    {\n        swap(t00, t10);\n        swap(t01, t11);\n    }\n    \n    switch (x)\n    {\n        case 0:\n            return t00;\n        case 1:\n            return t10;\n        case 2:\n            return t01;\n        case 3:\n            return t11;\n    }\n    \n    return vec4(0);\n}\n\n// https://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n  \nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + EPSILON);\n    return vec3(HCV.x, S, HCV.z);\n}\n\nvec3 RGBtoHSL(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n", "buffer_b_code": "\n#define BUFFER_OFFSET 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+1);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || p == IRES-ivec2(2, 1) || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n#define BUFFER_OFFSET 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+2);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || p == IRES-ivec2(2, 1) || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\n// Cheap mipmap blur from Michael Moroz\n// https://www.shadertoy.com/view/WsVGWV\nfloat weight(float t, float log2radius, float gamma)\n{\n    return exp(-gamma*pow(log2radius-t,2.));\n}\n\nvec4 sampleBlurred(sampler2D ch, vec2 uv, float radius, float gamma)\n{\n    vec4 pix = vec4(0.);\n    float norm = 0.;\n    // Weighted integration over mipmap levels\n    for(float i = 0.; i < 10.; i += 1.0)\n    {\n        float k = weight(i, log2(radius), gamma);\n        pix += k*texture(ch, uv, i); \n        norm += k;\n    }\n    \n    return pix / norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+3);\n    vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n    float scale = scene.x;\n    vec2 center = scene.zw;\n    \n    // Culling\n    /*\n    vec2 bl = center - RES * 0.5 / scale - 1.0;\n    vec2 tr = center + RES * 0.5 / scale + 1.0;\n    \n    if (fragCoord.x < bl.x || fragCoord.x >= tr.x ||\n        fragCoord.y < bl.y || fragCoord.y >= tr.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }*/\n\n    vec4 data = sampleTex0(fragCoord);\n    float id = data.x;\n    \n    vec4 rand = hash42(uvec2(fragCoord));\n    \n    vec2 uv = fragCoord / RES;\n    \n    if (id == WATER || id == LAVA)\n    {\n        float a = (texture(iChannel2, uv * 4.0).r + iTime * 0.5) * TAU;\n        uv += 1.2 * vec2(cos(a), sin(a)) / RES * vec2(RES.y / RES.x, 1.0);\n    }\n    vec3 bg = texture(iChannel1, uv * 2.0, 2.0).rgb * 0.25;//vec3(26, 29, 33) / 255.0;\n    bg = round(bg * 64.0) / 64.0;\n    \n    vec3 col;\n    \n    if (id == SMOKE)\n        col = vec3(0.5);\n    else if (id == FIRE)\n        col = vec3(1.0, 0.25, 0);\n    else if (id == LAVA)\n        col = vec3(1.0, 0.4, 0);\n    else if (id == WATER)\n        col = vec3(0.2, 0.3, 0.9);\n    else if (id == SAND)\n        col = vec3(225, 177, 89) / 255.0;\n    else if (id == STONE)\n        col = vec3(0.25);\n    else if (id == WOOD)\n        col = vec3(0.196,0.129,0.102);\n    else if (id == PLANT)\n        col = vec3(0.4, 0.65, 0.1);\n    else if (id == WALL)\n        col = vec3(0.09, 0.08, 0.13);\n    else\n        col = vec3(bg);\n    \n    vec3 hsl = RGBtoHSL(col);\n    \n    if (id != WATER)\n    {\n        vec3 r2 = rand.xyz;\n        if (id == LAVA)\n            r2 = 0.5 + 0.5 * sin((r2 + iTime * 0.4) * TAU);\n        \n        hsl.x = hsl.x + (r2.z - 0.5) * 8.0 / 255.0;\n        hsl.y = hsl.y + (r2.x - 0.5) * 20.0 / 255.0;\n        hsl.z = hsl.z + (r2.y - 0.5) * 16.0 / 255.0;\n\n        vec3 rgb = HSLtoRGB(hsl);\n        col = rgb;\n    }\n    \n#ifdef RAINBOW_MODE\n    hsl = vec3(fract(data.z * 4.0 + data.x * 1.2232), 0.5 + 0.5 * fract(data.w * 4.0), 0.5);\n    col = mix(col, HSLtoRGB(hsl), 0.5);\n#endif\n\n    float r = rand.w;\n    if (id == LAVA)\n        r = 0.5 + 0.5 * sin((r - iTime * 0.4) * TAU);\n    col *= 0.9 + 0.1 * r;\n    \n    bg *= 0.9 + 0.1 * rand.z;\n    \n    /*\n    vec2 ldir = normalize(vec2(0, 1));\n    \n    vec2 n = vec2(0);\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            if (x == 0 && y == 0)\n                continue;\n            float b = float(sampleTex0(fragCoord + vec2(x, y)).x != AIR);\n            \n            n += vec2(x, y) * (1.0 - b) * (abs(x) + abs(y) < 2 ? 1.0 : sqrt(2.0) / 2.0);\n        }\n    }\n    \n    n = normalize(n);\n    */\n    \n    //float dif = max(dot(n, ldir), 0.0);\n    //float sha = max(dot(n, -ldir), 0.0);\n    \n    float up = sampleTex0(fragCoord + vec2(0, 1)).x;\n    float down = sampleTex0(fragCoord - vec2(0, 1)).x;\n    float dif = float(up < id);\n    float sha = float(down < id);// * float(!(down >= SAND && id >= SAND));\n    \n    float occ = sampleBlurred(iChannel0, fragCoord / RES, 16.0, 0.5).y;\n    occ = saturate((1.0 - occ) / 0.25);\n    \n    col *= 0.2 + 0.8 * occ;\n    col *= 0.6 + 0.4 * max(dif, 1.0 - sha);\n    col += col * 0.3 * dif;\n    \n    float op = getOpacity(id);\n    \n    col = mix(bg, col, op);\n    \n    //col = vec3(bg);\n    \n    fragColor = vec4(col, occ);\n}", "buffer_d_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBSWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1500, 1573, 1600, 1600, 1802], [1804, 1804, 1855, 1855, 1904], [1906, 1906, 1963, 1963, 2891]], "test": "untested"}
{"id": "DsSSRd", "name": "Falling Sand CA v2", "author": "gelami", "description": "A falling sand cellular automata example which uses an improved cyclic Margolus neighborhood to remove bias.\n\nArrow keys to move camera\nPlus (+) / Minus (-) to zoom in/out", "tags": ["automata", "falling", "cellular", "sand", "margolus"], "likes": 12, "viewed": 408, "published": 3, "date": "1680940578", "time_retrieved": "2024-07-30T18:01:39.656129", "image_code": "// Fork of \"Falling Sand CA\" by gelami. https://shadertoy.com/view/DsjSzc\n// 2022-12-10 15:20:43\n\n// Falling Sand CA v2 by gelami\n// https://www.shadertoy.com/view/DsSSRd\n\n/*\n * A falling sand cellular automata example which uses an improved cyclic\n * Margolus neighborhood to remove bias.\n * Also has the rules randomly applied to create more interesting behaviors.\n * The simulation is then run 4 times in Buffer A-D for a 4x faster speed.\n * Plus some shading and shadows for the look\n * \n * Arrow keys to move camera\n * Plus (+) / Minus (-) to zoom in/out\n *\n * This is one of 4 shaders that explores falling sand cellular automata in the GPU\n * \n * Previous entry:\n * Falling Sand CA v1 - gelami\n * https://www.shadertoy.com/view/DsjSzc\n * \n * Next entry:\n * Falling Sand CA Ultimate - gelami\n * https://www.shadertoy.com/view/msBSWK\n *\n */\n\nfloat scale;\nvec2 getCoordsAA(vec2 uv)\n{\n    float w = 1.0; // 1.5\n    vec2 fl = floor(uv + 0.5);\n    vec2 fr = fract(uv + 0.5);\n    vec2 aa = fwidth(uv) * w * 0.5;\n    fr = smoothstep(0.5 - aa, 0.5 + aa, fr);\n    \n    return fl + fr - 0.5;\n}\n\nvec4 sampleTexAA(sampler2D ch, vec2 uv, vec2 res)\n{\n    return texture(ch, getCoordsAA(uv) / res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+4);\n    vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n    scale = scene.x;\n    vec2 center = scene.zw;\n    \n    fragCoord -= RES * 0.5;\n    fragCoord /= scale;\n    fragCoord += center;\n\n    vec4 h = sampleTexAA(iChannel0, fragCoord, RES);\n\n    vec4 r = sampleTexAA(iChannel1, mod(fragCoord, vec2(256)), vec2(256));\n    \n    vec3 bg = vec3(26, 29, 33) / 255.0;\n    \n    #ifndef CHEESE\n    vec3 col = vec3(225, 177, 89) / 255.0;\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x + (r.z - 0.5) * 5.0 / 255.0;\n    hsl.y = hsl.y + (r.x - 0.5) * 20.0 / 255.0;\n    hsl.z = hsl.z + (r.y - 0.5) * 40.0 / 255.0;\n    \n    #else\n    \n    vec3 col = vec3(0.957,0.714,0.184);\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x - r.y * 3.0 / 255.0;\n    hsl.y = hsl.y + r.z * 0.4;\n    hsl.z = mix(hsl.z, 0.9, pow(r.z, 6.0));\n    #endif\n    \n    vec2 n = vec2(0);\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            if (x == 0 && y == 0)\n                continue;\n            float b = sampleTexAA(iChannel0, fragCoord + vec2(x, y), RES).x;\n            \n            n += vec2(x, y) * (1.0 - b) * (abs(x) + abs(y) < 2 ? 1.0 : sqrt(2.0) / 2.0);\n        }\n    }\n    \n    n = normalize(n);\n    \n    col = HSLtoRGB(hsl);\n    \n    col *= 0.9 + 0.1 * r.w;\n    \n    vec2 ldir = normalize(vec2(0, 1));\n    \n    //float dif = max(dot(n, ldir), 0.0);\n    //float sha = max(dot(n, -ldir), 0.0);\n    float dif = 1.0 - sampleTexAA(iChannel0, fragCoord + vec2(0, 1), RES).x;\n    float sha = 1.0 - sampleTexAA(iChannel0, fragCoord - vec2(0, 1), RES).x;\n    \n    vec2 fr = fract(fragCoord);\n    float t = fract(getCoordsAA(fragCoord).y);\n    \n    float ao = 0.0;\n    #define DIST 16\n    for (int i = 1; i <= DIST; i++)\n    {\n       ao += sampleTexAA(iChannel0, fragCoord + ldir * float(i), RES).x;\n    }\n    //if (ao > 0.0)\n    //    ao += 1.0 - mix(fr.y, fr.y - 1.0, t);\n    ao /= float(DIST);\n    ao = min(ao, 1.0);\n    ao = sqrt(ao);\n    \n    col *= 0.2 + 0.8 * min(1.0 - ao, 1.0 - sha * 0.5);\n    col += col * 0.2 * dif;\n    \n    col = mix(bg, col, h.x);\n    \n    vec4 r2 = hash4(state);\n    \n    //col = vec3(ao);\n    \n    //col = vec3(h.x * HSLtoRGB(r2.xyz));\n    \n    // Output to screen\n    fragColor = vec4(col, 1);\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define BUFFER_OFFSET 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    // Keyboard functions\n    if (p == IRES-1)\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(SCALE, 0, ZOOM_POINT);\n            return;\n        }\n        \n        const int KEY_LEFT  = 37;\n        const int KEY_UP    = 38;\n        const int KEY_RIGHT = 39;\n        const int KEY_DOWN  = 40;\n\n        const int KEY_PLUS = 187;\n        const int KEY_MINUS = 189;\n        \n        vec4 prev = texelFetch(iChannel0, p, 0);\n    \n        float up = texelFetch(iChannel3, ivec2(KEY_UP, 0), 0).r;\n        float down = texelFetch(iChannel3, ivec2(KEY_DOWN, 0), 0).r;\n        float left = texelFetch(iChannel3, ivec2(KEY_LEFT, 0), 0).r;\n        float right = texelFetch(iChannel3, ivec2(KEY_RIGHT, 0), 0).r;\n    \n        float zoomin = texelFetch(iChannel3, ivec2(KEY_PLUS, 0), 0).r;\n        float zoomout = texelFetch(iChannel3, ivec2(KEY_MINUS, 0), 0).r;\n    \n        vec2 speed = vec2(15.0 / prev.x);\n        float zoom = 0.08;\n        \n        if (zoomin > 0.0)\n            prev.x += zoom;\n        if (zoomout > 0.0)\n            prev.x -= zoom;\n        \n        prev.x = max(prev.x, 1.0);\n    \n        prev.w += up * speed.y;\n        prev.w -= down * speed.y;\n        prev.z -= left * speed.x;\n        prev.z += right * speed.x;\n        \n        prev.zw = clamp(prev.zw, RES * 0.5 / prev.x, RES - RES * 0.5 / prev.x);\n        \n        fragColor = prev;\n        return;\n    }\n    \n    if (iFrame < 2)\n    {\n        if (fragCoord.y == 0.5)\n        {\n            fragColor = vec4(1, 15, fragCoord);\n            return;\n        }\n        \n        bool v = sampleTex1(p % 256).x < 0.05;\n        fragColor = vec4(v, 0, fragCoord);\n        return;\n    }\n\n    // Mouse interaction\n    if (iMouse.z > 0.0)\n    {\n        vec4 scene = texelFetch(iChannel0, IRES-1, 0);\n        float scale = scene.x;\n        vec2 center = scene.zw;\n\n        vec2 m = (iMouse.xy - RES * 0.5) / scale + center;\n        float d = length(fragCoord - m);\n        \n        bool v = sampleTex1((ivec2(fragCoord) + ivec2(313, 713) * iFrame) % 256).x < 0.2;\n        if (d < MOUSE_RADIUS && v)\n        {\n            fragColor = vec4(1, 0, fragCoord);\n            return;\n        }\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SCALE 4.0\n\n#define MOUSE_RADIUS 8.0\n\n//#define CHEESE\n\n#define ZOOM_POINT vec2(RES * 0.5 / SCALE)\n\n#define EPSILON 1e-4\n\n#define RES iResolution.xy\n#define IRES ivec2(iResolution.xy)\n\n#define sampleTex0(p) texelFetch(iChannel0, ivec2(p) % IRES, 0)\n#define sampleTex1(p) texelFetch(iChannel1, ivec2(p), 0)\n\nvec4 sampleCells(sampler2D ch, ivec2 p, ivec2 res)\n{\n    if (p.y < 0)\n        return vec4(1, 15, 0, 0);\n\n    //if (p.x < 0 || p.x >= res.x || p.y >= res.y)\n    //    return vec4(0);\n    \n    if (p.x >= res.x-1 && p.y >= res.y-1)\n        return vec4(0);\n    \n    p = clamp(p, ivec2(0), res-1);  \n    \n    vec4 tex = texelFetch(ch, ivec2(p), 0);\n    \n    return tex;\n}\n\nivec2 getMargolusOffset(int frame)\n{\n#if 0\n    frame = frame % 2;\n    if (frame == 1)\n        return ivec2(1, 1);\n    return ivec2(0, 0);\n#else\n    frame = frame % 4;\n\n    if (frame == 1)\n        return ivec2(1, 1);\n    else if (frame == 2)\n       return ivec2(0, 1);\n    else if (frame == 3)\n        return ivec2(1, 0);\n    return ivec2(0, 0);\n#endif\n}\n\nint cellToID(vec4 p)\n{\n    return int(dot(p, vec4(1, 2, 4, 8)));\n}\n\nvec4 IDToCell(int id)\n{\n    return vec4(id%2, (id/2)%2, (id/4)%2, (id/8)%2);\n}\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec4 hash4i(inout uint y)\n{\n    uvec4 x = y * uvec4(213u, 2131u, 21313u, 213132u);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    y = x.x;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash42(uvec2 p)\n{\n    uint x = p.x*2131u + p.y*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 hash43(uvec3 p)\n{\n    uint x = p.x*461u + p.y*2131u + p.z*2131u*2131u;\n    return vec4( hash4i(x) ) / float( 0xffffffffU );\n    //return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\nvec4 simulate(sampler2D ch, ivec2 p, ivec2 res, int frame, int bof)\n{\n    // Cyclic update order fixes 2 high ledge not updating\n    ivec2 of = getMargolusOffset(frame + bof);\n        \n    p += of;\n    \n    ivec2 fp = (p / 2) * 2;\n    \n    ivec2 fr = p & 1;\n    \n    int x = fr.x + (fr.y) * 2;\n    \n    fp -= of;\n    p -= of;\n    \n    vec4 t00 = sampleCells(ch, fp + ivec2(0, 0), res);\n    vec4 t10 = sampleCells(ch, fp + ivec2(1, 0), res);\n    vec4 t01 = sampleCells(ch, fp + ivec2(0, 1), res);\n    vec4 t11 = sampleCells(ch, fp + ivec2(1, 1), res);\n    \n    int id = cellToID(vec4(t00.x, t10.x, t01.x, t11.x));\n    \n    const int rules[16] = int[](\n    \n        // http://www.mirekw.com/ca/rullex_marg.html\n        // Note: Values assume Y Down\n        // Sand (Y up)\n        0, 1, 2, 3, 1, 3, 3, 7, 2, 3, 3, 11, 3, 7, 11, 15\n        \n    );\n    \n    const int sideToSide[16] = int[](\n        // Move side to side\n        0, 2, 1, 3, 8, 5, 6, 7, 4, 10, 9, 11, 12, 13, 14, 15\n    );\n    \n    \n    int r = rules[id];\n    \n    ivec2 o = ivec2(fr.x, fr.y);\n    \n    vec4 v = hash43(uvec3(fp, frame));\n    \n    if (v.y < 0.4)\n        r = id;\n    \n    int b = int(sampleCells(ch, ivec2(fp) - ivec2(0, 2), res).y);\n    \n    if (v.x < 0.2 && b < 4)\n    {\n        r = sideToSide[r];\n    }\n    \n    vec4 d = sampleCells(ch, fp + o, res);\n    \n    vec4 cell = IDToCell(r);\n    \n    return vec4(cell[x], id, d.zw);\n}\n\n// https://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n  \nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + EPSILON);\n    return vec3(HCV.x, S, HCV.z);\n}\n\nvec3 RGBtoHSL(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n", "buffer_b_code": "\n#define BUFFER_OFFSET 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+1);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n#define BUFFER_OFFSET 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+2);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n#define BUFFER_OFFSET 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame+3);\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    if (p == IRES-1 || iFrame < 2)\n    {\n        fragColor = sampleTex0(p);\n        return;\n    }\n    \n    fragColor = simulate(iChannel0, p, IRES, iFrame, BUFFER_OFFSET);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSSRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[860, 860, 887, 887, 1089], [1091, 1091, 1142, 1142, 1191], [1193, 1193, 1250, 1250, 3534]], "test": "untested"}
{"id": "7ls3WN", "name": "Nested Poncelet Polygons", "author": "mla", "description": "Tangents between N equally spaced points on a circle envelope a nest of inner circles. If the points divide the circle exactly, we get a nest of Poncelet polygons. Applying a projective mapping gives nested conics.\n\nMouse changes projective mapping.", "tags": ["poncelet", "porism"], "likes": 15, "viewed": 252, "published": 3, "date": "1680937196", "time_retrieved": "2024-07-30T18:01:40.733249", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Nested Poncelet Polygons\n// Matthew Arcus, mla, 2023.\n//\n// Another gem of projective geometry. Given a pair of conics, if an\n// n-gon can be inscribed in one such that it circumscribes the other,\n// then there are an infinite number of such n-gons. It's difficult in\n// general to find such an n-gon in the first place, but here's an\n// easy special case.\n//\n// Inscribe a regular m/n-gon in a circle, find the incircle of the\n// polygon and then apply a projective transformation. Here, we map\n// points (-1,0),(0,1) and (0,-1) on the unit circle to themselves,\n// and the point (1,0) to the mouse position.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Geometric constructions\n//\n// Homogeneous coordinates used throughout (so the lines and points are\n// \"projective\"):\n// (x,y,z) represents the point (x/z,y/z) for z != 0\n// (x,y,0) represents a \"point at infinity\" which acts like a direction.\n// (a,b,c) represents the line ax + by + cz = 0\n// (0,0,c) represents the \"line at infinity\"\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159;\n\n// The line between two projective points, or the intersection of two\n// projective lines, is just their cross product.\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Distance functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat point(vec3 p, vec3 q) {\n  float pz = p.z, qz = q.z;\n  p *= qz; q *= pz;\n  return distance(p,q)/abs(p.z);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\nfloat conic(vec3 p, mat3 m) {\n  float s = dot(p,m*p);\n  vec3 ds = 2.0*m*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\nmat3 circlemat(vec4 c) {\n  // (x-a)^2 + (y-b)^2 = r^2\n  // x2 -2ax + a2 + y2 -2by + b2 -r2 = 0\n  vec3 q = c.xyz;\n  float r2 = c.w;\n  q /= q.z;\n  return mat3(1,0,-q.x,\n              0,1,-q.y,\n              -q.x,-q.y,dot(q.xy,q.xy)-r2);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return rgb;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 diagram(vec3 p, vec3 P) {\n  float NMIN = 2.0;\n  float NMAX = 19.0;\n  float N = NMIN+(NMAX-NMIN)*(0.5-0.5*cos(PI*0.1*iTime));\n  float M = 6.0;\n  vec3 A = vec3(0,-1,1), B = vec3(-1,0,1), C = vec3(0,1,1);\n  mat3 X = rproject(A,B,C,P), Y = rproject(A,B,C,vec3(1,0,1));\n  mat3 T = inverse(X)*Y;\n  mat3 S = inverse(T);\n  float theta = PI/N; // Segment half angle\n  float lmin = 0.004, lmax = 0.005+fwidth(p.x);\n  float pmin = 0.01, pmax = 0.02;\n  float r = cos(M*theta);\n  mat3 c1 = circlemat(vec4(0,0,1,1));\n  mat3 c2 = circlemat(vec4(0,0,1,r*r));\n  vec3 col = vec3(1,1,0.8);\n  //col = mix(vec3(0.5),col,0.75+0.75*smoothstep(lmin,lmax,conic(p,c1)));\n  //col = mix(vec3(0,0,1),col,0.5+0.5*smoothstep(lmin,lmax,conic(p,c2)));\n  float t = 0.1*PI*iTime;\n  for (float i = 0.0; i < N; i++) {\n    vec3 p0 = vec3(cos(2.0*i*theta+t),sin(2.0*i*theta+t),1);\n    for (float j = 1.0; j <= floor(0.5*N); j++) {\n      vec3 p1 = vec3(cos(2.0*(mod(i+j,N))*theta+t),sin(2.0*(mod(i+j,N))*theta+t),1);\n      //col = mix(vec3(0,0.5,0),col,0.5+0.5*smoothstep(lmin,lmax,line(p,p0,p1)));\n      vec3 basecol = h2rgb((j-1.0)/floor(0.5*(NMAX-NMIN)));\n      col = mix(basecol,col,smoothstep(0.0,lmax,line(p,T*p0,T*p1)));\n    }\n  }\n  for (float j = 0.0; j < 0.5*N; j++) {\n    float r = cos(j*theta);\n    float d = conic(p,transpose(S)*circlemat(vec4(0,0,1,r*r))*S);\n    col = mix(vec3(0.5),col,smoothstep(0.0,lmax,d));\n  }\n  for (float i = 0.0; i < N; i++) {\n    vec3 p0 = vec3(cos(2.0*i*theta+t),sin(2.0*i*theta+t),1);\n    col = mix(vec3(0),col,smoothstep(pmin,pmax,point(p,T*p0)));\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 1.2;\n  vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1.0);\n  vec3 P = iMouse.x <= 0.0 ? vec3(-0.5,0,1.0)\n    : vec3(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y,1);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ls3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1311, 1431, 1458, 1458, 1481], [1483, 1671, 1722, 1829, 2071], [2258, 2258, 2287, 2287, 2370], [2372, 2372, 2400, 2400, 2445], [2447, 2447, 2483, 2483, 2513], [2515, 2515, 2544, 2544, 2676], [2678, 2678, 2702, 2772, 2914], [2916, 2916, 2937, 2937, 3089], [3275, 3275, 3305, 3305, 4849], [4851, 4851, 4904, 4904, 5184]], "test": "untested"}
{"id": "dll3zH", "name": "Deform Remix", "author": "MaxShaders", "description": "Remix of IQ's Deform - Waves shader", "tags": ["abstract"], "likes": 5, "viewed": 228, "published": 3, "date": "1680934636", "time_retrieved": "2024-07-30T18:01:41.801393", "image_code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\nfloat Vignette(vec2 uv) {\n    return 0.5 * length((2. * uv - iResolution.xy) / iResolution.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n\tvec2 q = (3.0*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 p = q;\n    \n    float time = (300. + iTime * 0.5 + iMouse.x)*0.02;\n    \n\tp += 6.*cos( .2*p.yx + time);\n\n\tfloat r = length( p );\n    \n    vec3 col1 = texture( iChannel0, vec2(r,0.0), 0.0 ).zyx;\n    vec3 col2 = texture( iChannel0, vec2(r+0.04,0.0), 0.0 ).zyx;\n\n    vec3 col = col1;\n    col += 0.1;\n    col *= 1.0 + 0.4*sin(r+vec3(2.0,3.0,3.0));\n    col -= 4.0*max(vec3(0.0),col1-col2).x;\n    col += 1.0*max(vec3(0.0),-col1).x - 0.1;\n    col *= -1.7 - Vignette(uv);\n\n    fragColor = vec4(col, 1.);\n    //fragColor = vec4(Vignette(uv));\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dll3zH.jpg", "access": "api", "license": "proprietary-license", "functions": [[642, 642, 667, 667, 738], [740, 740, 796, 796, 1423]], "test": "untested"}
{"id": "DsjSzc", "name": "Falling Sand CA v1", "author": "gelami", "description": "Basic cellular automata falling sand example which uses a Margolus neighborhood with randomly applied rules to create more interesting behaviors.\n\nArrow keys to move camera\nPlus (+) / Minus (-) to zoom in/out", "tags": ["2d", "automata", "falling", "cellular", "sand", "margolus"], "likes": 8, "viewed": 312, "published": 3, "date": "1680934342", "time_retrieved": "2024-07-30T18:01:42.740881", "image_code": "// 2022-12-10 03:05:10\n\n/*\n * Basic cellular automata falling sand example which uses a Margolus neighborhood\n * with randomly applied rules to create more interesting behaviors.\n *\n * Arrow keys to move camera\n * Plus (+) / Minus (-) to zoom in/out\n *\n * This is one of 4 shaders that explores falling sand cellular automata in the GPU\n *\n * Next entries:\n * Falling Sand CA v2 - gelami\n * https://www.shadertoy.com/view/DsSSRd\n * \n * Falling Sand CA Ultimate - gelami\n * https://www.shadertoy.com/view/msBSWK\n * \n */\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 scene = texelFetch(iChannel2, ivec2(0), 0);\n    float scale = scene.x;\n    vec2 center = scene.zw;\n    \n    fragCoord -= RES * 0.5;\n    fragCoord /= scale;\n    fragCoord += center;\n\n    vec4 h = sampleTex0(fragCoord);\n\n    vec4 r = sampleTex1(ivec2(fragCoord) % 256);\n    \n    vec3 bg = vec3(26, 29, 33) / 255.0;\n    \n    #if 1\n    vec3 col = vec3(225, 177, 89) / 255.0;\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x + (r.z - 0.5) * 5.0 / 255.0;\n    hsl.y = hsl.y + (r.x - 0.5) * 20.0 / 255.0;\n    hsl.z = hsl.z + (r.y - 0.5) * 40.0 / 255.0;\n    \n    #else\n    \n    vec3 col = vec3(0.957,0.714,0.184);\n    vec3 hsl = RGBtoHSL(col);\n    \n    hsl.x = hsl.x - r.y * 3.0 / 255.0;\n    hsl.y = hsl.y + r.z * 0.5;\n    hsl.z = mix(hsl.z, 0.95, pow(r.z, 8.0));\n    #endif\n    \n    col = HSLtoRGB(hsl);\n    \n    col *= 0.9 + 0.1 * r.w;\n    col = mix(bg, col, h.x);\n    \n    vec4 r2 = sampleTex1(ivec2(floor(h.zw / 12.0)) % 256);\n    \n    //col = vec3(h.x * HSLtoRGB(r2.xyz));\n    \n    // Output to screen\n    fragColor = vec4(col, 1);\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nint cellToID(vec4 p)\n{\n    return int(dot(p, vec4(1, 2, 4, 8)));\n}\n\nvec4 IDToCell(int id)\n{\n    return vec4(id%2, (id/2)%2, (id/4)%2, (id/8)%2);\n}\n\nvec4 sampleCells(ivec2 p)\n{\n    //if (p.y < 0)\n    //    return vec4(1, 15, 0, 0);\n\n    //if (p.x < 0 || p.x >= IRES.x || p.y >= IRES.y)\n    //    return vec4(0);\n    \n    p = clamp(p, ivec2(0), IRES-1);  \n    \n    return texelFetch(iChannel0, ivec2(p), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2)\n    {\n        if (fragCoord.y == 0.5)\n        {\n            fragColor = vec4(1, 15, fragCoord);\n            return;\n        }\n        \n        /*\n        if (fragCoord.y > RES.y / SCALE)\n        {\n            fragColor = vec4(0);\n            return;\n        }*/\n        \n        bool v = sampleTex1(ivec2(fragCoord) % 256).x < 0.05;\n        fragColor = vec4(v, 0, fragCoord);\n        return;\n    }\n\n    if (iMouse.z > 0.0)\n    {\n        vec4 scene = texelFetch(iChannel2, ivec2(0), 0);\n        float scale = scene.x;\n        vec2 center = scene.zw;\n    \n        vec2 m = (iMouse.xy - RES * 0.5) / scale + center;\n        float d = length(fragCoord - m);\n        bool v = sampleTex1((ivec2(fragCoord) + ivec2(3, 7) * iFrame) % 256).x < 0.2;\n        if (d < 10.0)\n        {\n            fragColor = vec4(1, 0, fragCoord);\n            return;\n        }\n    }\n\n    ivec2 p = ivec2(floor(fragCoord));\n    \n    p += iFrame % 2;\n    \n    ivec2 fp = (p / 2) * 2;\n    \n    ivec2 fr = p & 1;\n    \n    int x = fr.x + (1-fr.y) * 2;\n    \n    fp -= iFrame % 2;\n    p -= iFrame % 2;\n    \n    vec4 t00 = sampleCells(fp + ivec2(0, 0));\n    vec4 t10 = sampleCells(fp + ivec2(1, 0));\n    vec4 t01 = sampleCells(fp + ivec2(0, 1));\n    vec4 t11 = sampleCells(fp + ivec2(1, 1));\n    \n    int id = cellToID(vec4(t00.x, t10.x, t01.x, t11.x));\n    \n    const int rules[16] = int[](\n    \n        // http://www.mirekw.com/ca/rullex_marg.html\n        // Note: Values assume Y Down\n        // Sand\n        0,4,8,12,4,12,12,13, 8,12,12,14,12,13,14,15\n        // Billiards\n        //0,8,4,3,2,5,9,7,1,6,10,11,12,13,14,15\n        \n    );\n    \n    const int sideToSide[16] = int[](\n        // Move side to side\n        //0, 2, 1, 3, 8, 6, 5, 11, 4, 10, 9, 7, 12, 14, 13, 15\n        //0, 1, 2, 3, 8, 5, 6, 7, 4, 9, 10, 11, 12, 13, 14, 15\n        0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 13, 14, 15\n    );\n    \n    const int invertY[16] = int[](\n        // Inverted Y\n        0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15\n    );\n    \n    vec4 v = sampleTex1((ivec2(fp) + ivec2(313, 123) * iFrame) % 256);\n    \n    int r = rules[id];\n    \n    ivec2 o = ivec2(fr.x, fr.y);\n    \n    \n    /*\n    if (r == 5 && o.x == 1 && o.y == 0 || r == 10 && o.x == 0 && o.y == 0)\n    {\n        o.x = 1 - o.x;\n        o.y = 1 - o.y;\n    } else if (r != invertY[id] && o.y == 0)\n    {\n        o.y = 1 - o.y;\n    }*/\n    \n    vec4 b = sampleCells(ivec2(fp) - ivec2(0, 2));\n    \n    // Prevent sand from moving to side on contact\n    float b0 = sampleCells(ivec2(fragCoord) + ivec2(-1, -1)).x;\n    float b1 = sampleCells(ivec2(fragCoord) + ivec2(0, -1)).x;\n    float b2 = sampleCells(ivec2(fragCoord) + ivec2(1, -1)).x;\n\n    if (v.y > 0.8)\n        r = invertY[id];\n    else if (v.x < 0.3 && b.y != 15.0)\n    {\n        r = invertY[sideToSide[invertY[r]]];\n        //o.x = 1 - o.x;\n    }\n    vec4 d = sampleCells(fp + o);\n    \n    vec4 cell = IDToCell(r);\n    \n    fragColor = vec4(cell[x], id, d.zw);\n    //fragColor = d;\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SCALE 4.0\n\n#define ZOOM_POINT vec2(RES * 0.5 / SCALE)\n\n#define EPSILON 1e-4\n\n#define RES iResolution.xy\n#define IRES ivec2(iResolution.xy)\n\n#define sampleTex0(p) texelFetch(iChannel0, ivec2(p) % IRES, 0)\n#define sampleTex1(p) texelFetch(iChannel1, ivec2(p), 0)\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\n\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(0)); }\n\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\n\n// https://www.chilliant.com/rgb2hsv.html\n\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n  \nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + EPSILON);\n    return vec3(HCV.x, S, HCV.z);\n}\n\nvec3 RGBtoHSL(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n", "buffer_c_code": "\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_PLUS = 187;\nconst int KEY_MINUS = 189;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pix = ivec2(fragCoord);\n    \n    if (pix == ivec2(0))\n    {\n        if (iFrame == 0)\n        {\n            fragColor = vec4(SCALE, 0, ZOOM_POINT);\n            return;\n        }\n        \n        vec4 prev = texelFetch(iChannel0, pix, 0);\n    \n        float up = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n        float down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n        float left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        float right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r;\n    \n        float zoomin = texelFetch(iChannel1, ivec2(KEY_PLUS, 0), 0).r;\n        float zoomout = texelFetch(iChannel1, ivec2(KEY_MINUS, 0), 0).r;\n    \n        vec2 speed = vec2(15.0 / prev.x);\n        float zoom = 0.08;\n        \n        if (zoomin > 0.0)\n            prev.x += zoom;\n        if (zoomout > 0.0)\n            prev.x -= zoom;\n        \n        prev.x = max(prev.x, 1.0);\n    \n        prev.w += up * speed.y;\n        prev.w -= down * speed.y;\n        prev.z -= left * speed.x;\n        prev.z += right * speed.x;\n        \n        prev.zw = clamp(prev.zw, RES * 0.5 / prev.x, RES - RES * 0.5 / prev.x);\n        \n        fragColor = prev;\n        return;\n    }\n\n    fragColor = vec4(0);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 578, 578, 1626]], "test": "untested"}
{"id": "csjXDh", "name": "Infinite Corridor", "author": "gelami", "description": "A corridor scene created using infinitely repeating analytic raytraced primitives.\n\nClick and drag to look around\nDon't look behind you", "tags": ["3d", "raytracing", "infinite", "corridor", "flickering", "repetiton"], "likes": 22, "viewed": 346, "published": 3, "date": "1680900246", "time_retrieved": "2024-07-30T18:01:43.801047", "image_code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2022-12-05 00:34:31\n\n/*\n * A corridor scene created using infinitely repeating\n * analytic raytraced primitives. \n *\n * Click and drag to look around\n * Don't look behind you\n * \n * T'was initially made as a proof of concept for the infinitely repeating primitives,\n * apologies for the messy code v _ v\n * \n * Thanks to sebbi and demofox for the inspiration\n * \n * Infinite quad grid - sebbi\n * https://www.shadertoy.com/view/lly3Rc\n * \n * Infinite Plane Shape Raytracing - demofox \n * https://www.shadertoy.com/view/MlK3zt\n * \n */\n\n#define AA\n\n#define FOG\n#define FOG_STRENGTH 0.225\n\n//#define SHOW_MATERIALS\n\nfloat RayPlane(vec3 ro, vec3 rd, vec3 n)\n{\n    float d = dot(rd, n);\n    if (d == 0.0) return MAX_DIST;\n    float t = -dot(ro, n) / d;\n    if (t < 0.0) t = MAX_DIST;\n    return t;\n}\n\nfloat RayCorridor(vec3 ro, vec3 rd, vec2 s, out vec3 normal)\n{\n    vec2 m = 1.0 / rd.xy; // can precompute if traversing a set of aligned boxes\n    vec2 n = m * ro.xy;   // can precompute if traversing a set of aligned boxes\n    vec2 k = abs(m) * s;\n    vec2 t2 = -n + k;\n    float t = min(t2.x, t2.y);\n    normal.x = float(t2.x <= t);\n    normal.y = float(t2.y < t2.x);\n    normal.xy *= -sign(rd.xy);\n    \n    return t;\n}\n\n// Repeating Planes with Rectangular Hole aligned at Z\nfloat RayPlaneRectHoleRepeat(vec3 ro, vec3 rd, vec3 s)\n{\n    if (rd.z == 0.0)\n        return MAX_DIST;\n    ro.z = fract(ro.z / s.z) * s.z;\n    float o = fract(ro.z / s.z) * s.z;\n    if (rd.z < 0.0)\n    {\n        ro.z = s.z - ro.z;\n        rd.z = -rd.z;\n    }\n    float t = -(ro.z - s.z) / rd.z;\n    vec3 p = ro + rd * t;\n    vec2 st = s.z * -rd.xy / rd.z;\n    \n    if (abs(p.x) < s.x && abs(p.y) < s.y)\n    {\n        vec2 sp = (s.xy + p.xy * sign(st)) / abs(st);\n        t += s.z * ceil(min(sp.x, sp.y)) / rd.z;\n    }\n    \n    return t;\n}\n\nfloat RayPlaneSlabRepeatX(vec3 ro, vec3 rd, vec2 s)\n{\n    if (rd.z == 0.0)\n        return MAX_DIST;\n    ro.z = fract(ro.z / s.y) * s.y;\n    float o = fract(ro.z / s.y) * s.y;\n    if (rd.z < 0.0)\n    {\n        ro.z = s.y - ro.z;\n        rd.z = -rd.z;\n    }\n    float t = -(ro.z - s.y) / rd.z;\n    vec3 p = ro + rd * t;\n    float st = s.y * -rd.x / rd.z;\n    \n    if (abs(p.x) < s.x)\n    {\n        float sp = (s.x + p.x * sign(st)) / abs(st);\n        t += s.y * ceil(sp) / rd.z;\n    }\n    \n    return t;\n}\n\nfloat RayPlaneSlabRepeatY(vec3 ro, vec3 rd, vec2 s)\n{\n    if (rd.z == 0.0)\n        return MAX_DIST;\n    ro.z = fract(ro.z / s.y) * s.y;\n    float o = fract(ro.z / s.y) * s.y;\n    if (rd.z < 0.0)\n    {\n        ro.z = s.y - ro.z;\n        rd.z = -rd.z;\n    }\n    float t = -(ro.z - s.y) / rd.z;\n    vec3 p = ro + rd * t;\n    float st = s.y * -rd.y / rd.z;\n    \n    if (abs(p.y) < s.y)\n    {\n        float sp = (s.x + p.y * sign(st)) / abs(st);\n        t += s.y * ceil(sp) / rd.z;\n    }\n    \n    return t;\n}\n\nvec3 getTexture(vec2 uv, int mat)\n{\n    if (mat == 0)\n        return sRGBToLinear(texture(iChannel0, uv).rgb);\n    else if (mat == 1)\n        return sRGBToLinear(texture(iChannel1, uv).rgb);\n    else if (mat == 2)\n        return sRGBToLinear(texture(iChannel2, uv).rgb);\n    else if (mat == 4)\n        return sRGBToLinear(texture(iChannel3, uv).rgb);\n        \n    return sRGBToLinear(texture(iChannel0, uv).rgb);\n}\n\nvec3 getTexture(vec2 uv, vec2 ddx, vec2 ddy, int mat)\n{\n    if (mat == 0)\n        return sRGBToLinear(textureGrad(iChannel0, uv, ddx, ddy).rgb);\n    else if (mat == 1)\n        return sRGBToLinear(textureGrad(iChannel1, uv, ddx, ddy).rgb);\n    else if (mat == 2)\n        return sRGBToLinear(textureGrad(iChannel2, uv, ddx, ddy).rgb);\n    else if (mat == 4)\n        return sRGBToLinear(textureGrad(iChannel3, uv, ddx, ddy).rgb);\n        \n    return sRGBToLinear(textureGrad(iChannel0, uv, ddx, ddy).rgb);\n}\n\nvec3 triplanar(sampler2D tex, vec3 p, vec3 n)\n{\n    vec3 cw = pow(abs(n) / dot(abs(n), vec3(1)), vec3(1.0));\n    \n    vec3 cx = texture(iChannel0, p.yz).rgb;\n    vec3 cy = texture(iChannel0, -p.xz).rgb;\n    vec3 cz = texture(iChannel0, p.xy).rgb;\n    \n    vec3 alb = cx * cw.x + cy * cw.y + cz * cw.z;\n    \n    return sRGBToLinear(alb);\n}\n\nfloat getFlicker(int i)\n{\n    return float((28273198 >> (i%25)) & 1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0);\n    \n#ifdef AA\n    for (int x = 0; x < 4; x++)\n    {\n    \n    const vec2[] offsets = vec2[](\n        vec2(1.0/8.0, 3.0/8.0),\n        vec2(3.0/8.0, -1.0/8.0),\n        vec2(-1.0/8.0, -3.0/8.0),\n        vec2(-3.0/8.0, 1.0/8.0)\n    );\n    vec2 o = offsets[x];\n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    vec2 pvdx = (2. * (fragCoord + o + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 pvdy = (2. * (fragCoord + o + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n#else\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 pvdx = (2. * (fragCoord + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 pvdy = (2. * (fragCoord + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n#endif\n\n    float bd0 = 0.08;\n    pv *= 1.0 + dot(pv, pv) * bd0;\n    pvdx *= 1.0 + dot(pvdx, pvdx) * bd0;\n    pvdy *= 1.0 + dot(pvdy, pvdy) * bd0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, -0.3, 0);\n    \n    ro.x += sin(iTime * 0.5) * 0.02;\n    ro.y += sin(iTime * 6.0) * 0.05;\n    ro.z += (iTime + cos(iTime * 0.8) * 0.12 + sin(iTime * PI) * 0.03) * 2.25;\n\n    vec3 lo = vec3(0, 0, 1.5);\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? 0.0 : -m.x * TAU;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? 0.0 : -(m.y * PI + PI * .5);\n    \n    //ax = PI / 2.0;\n    //ro -= lo;\n    lo.yz *= rot2D(ay);\n    lo.xz *= rot2D(ax);\n    lo += ro;\n    \n    mat3 cmat = getCameraMatrix(ro, lo, sin(iTime * 3.0) * 0.025);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    vec3 rddx = normalize(cmat * vec3(pvdx, 2));\n    vec3 rddy = normalize(cmat * vec3(pvdy, 2));\n    vec3 srd = sign(rd);\n    \n    int mat = 1;\n\n    float occRad = 0.3;\n    float occ = 1.0;\n    \n    const float corridorWidth = 1.3;\n    const float corridorHeight = 1.5;\n    const vec2 corridorSize = vec2(1.3, 1.5);\n    const vec2 columnSize = vec2(0.4, 0.3);\n    const float columnSpacing = 3.0;\n    const float columnDepth = 0.5;\n\n    // Column sides Z\n    float t = RayPlaneRectHoleRepeat(ro + vec3(0, 0, columnDepth * step(0.0, rd.z)), rd, vec3(corridorSize - columnSize, columnSpacing));\n    \n    vec3 tp = ro + rd * t;\n    \n    vec3 n = vec3(0, 0, -sign(rd.z));\n    occ = min(corridorSize.x - abs(tp.x), min(corridorSize.y - abs(tp.y), corridorSize.y - abs(tp.y -  columnSize.y ))) / 0.5;\n    \n    // Column side X\n    vec3 cn;\n    float c = RayCorridor(ro, rd, corridorSize - columnSize, cn);\n    \n    tp = ro + rd * c;\n    \n    if (c < t && fract(tp.z / columnSpacing) * columnSpacing > columnSpacing - columnDepth)\n    {\n        t = c;\n        n = cn;\n        occ = max(corridorSize.x - columnSize.x - abs(tp.x), corridorSize.y - columnSize.y - abs(tp.y)) / occRad;\n        mat = 1;\n    }\n    \n    // Walls/floor/ceiling\n    float c2 = RayCorridor(ro, rd, corridorSize, cn);\n    if (c2 < t)\n    {\n        t = c2;\n        n = cn;\n        tp = ro + rd * c2;\n        occ = max(corridorSize.x - abs(tp.x), corridorSize.y - columnSize.y - abs(tp.y));\n        occ = min(occ, abs(0.8 - tp.y));\n        float g = fract(tp.z / columnSpacing) * columnSpacing;\n        occ = min(occ, min(g, columnSpacing - columnDepth - g));\n        occ *= 2.;\n        \n        mat = 0;\n        if (cn.y > 0.0)\n            mat = 2;\n        else if (cn.y < 0.0)\n            mat = 1;\n    }\n    \n    // Slanted ceiling\n    vec3 s1n = vec3(-1, -1, 0);\n    if (rd.x < 0.0)\n        s1n.x = -s1n.x;\n    s1n = normalize(s1n);\n    vec3 s2n = vec3(0, -1, 0);\n    float s1 = RayPlane(ro - vec3(srd.x * 0.2, corridorHeight, 0), rd, s1n);\n    float s2 = RayPlane(ro - vec3(0, 0.8, 0), rd, s2n);\n    if (s2 > s1)\n    {\n        s1 = s2;\n        s1n = s2n;\n    }\n    \n    tp = ro + rd * s1;\n    if (fract(tp.z / columnSpacing) * columnSpacing > columnSpacing - columnDepth)\n    {\n        tp.z = fract(tp.z / columnSpacing) * columnSpacing - columnSpacing + columnDepth * step(rd.z, 0.0);\n        s1 += RayPlane(tp, rd, vec3(0, 0, -srd.z));\n        s1n = vec3(0, 0, -srd.z);\n    }\n    \n    if (s1 < t)\n    {\n        t = s1;\n        n = s1n;\n        occ = corridorSize.x - abs(tp.x);\n        mat = 0;\n    }\n    \n    vec3 fp = vec3(0, -(corridorHeight - columnSize.y) + EPS, 0);\n    float fl = RayPlane(ro - fp, rd, vec3(0, 1, 0));\n    tp = ro + rd * fl;\n    if (fl < t)\n    {\n        t = fl;\n        n = vec3(0, 1, 0);\n        float occ0 = fract(tp.z / columnSpacing) * columnSpacing;\n        float occ1 = columnSpacing - columnDepth - occ0;\n        occ = max(min(occ0, occ1), corridorSize.x - columnSize.x - abs(tp.x)) * 2.;\n        occ = min(occ, (corridorSize.x - abs(tp.x)) * 2.0);\n        mat = 2;\n    }\n    \n    \n    const float bof = 0.1;\n    const float bsp = 3.0;\n    const float bbf = 0.1;\n    float bp1 = RayPlaneSlabRepeatY(ro - fp + vec3(0, 0, mix(bbf, columnDepth - bbf, step(0.0, rd.z))), rd, vec2(corridorHeight + bof, columnSpacing * bsp));\n    \n    tp = ro + rd * bp1;\n    if (bp1 < t)\n    {\n        t = bp1;\n        n = vec3(0, 0, -srd.z);\n        mat = 0;\n        occ = min(corridorSize.x - columnSize.x - abs(tp.x), corridorSize.y - columnSize.y - abs(tp.y));\n        occ *= 2.0;\n    }\n    \n    float bp = RayPlane(ro - fp - vec3(0, corridorHeight + bof, 0), rd, vec3(0, -1, 0));\n    tp = ro + rd * bp;\n    if (bp < t && fract((tp.z + bbf) / (columnSpacing*bsp)) * columnSpacing*bsp > columnSpacing*bsp - columnDepth + bbf*2.0)\n    {\n        t = bp;\n        n = vec3(0, -1, 0);\n        occ = (corridorSize.x - columnSize.x - abs(tp.x)) * 2.0;\n        mat = 0;\n    }\n    \n    float np = RayPlane(ro * vec3(1, 1, 0) + vec3(0, 0, 5.0 + sin(iTime * 0.3) * 3.5), rd, vec3(0, 0, 1));\n    \n    tp = ro + rd * np;\n    tp.x *= hash22(vec2(floor(iTime*12.0), 3)).x < 0.5 ? -1.0 : 1.0;\n    vec4 tex = texture(iChannel3, (tp.xy + vec2(0.5 + 1.0*mod(floor(iTime * 12.0), 6.0), 0.9)) * vec2(240.0/256.0/6.0, 1));\n    if (np < t && tex.a > 0.5 && tp.x < 240.0/256.0/2.0 && tp.x > -240.0/256.0/2.)\n    {\n        t = np;\n        n = vec3(0, 0, 1);\n        mat = 4;\n        occ = 1.0;\n    }\n    \n    \n    float r = 0.15;\n    float s = columnSpacing;\n    float lightHeight = corridorSize.y + 0.02;\n    \n    vec3 cp = ro - vec3(0, lightHeight, columnSpacing * 0.5);\n    cp.z = fract(cp.z / s) * s;\n    vec2 cyl = RayCylinder(cp, rd, r);\n    \n    float ct = max(cyl.x, 0.0);\n    \n    tp = cp + rd * ct;\n    \n    float ip = floor(tp.z / s) * s;\n    \n    vec3 of = vec3(0, 0, ip);\n    vec3 of2 = vec3(0, 0, ip + s);\n    vec2 sph0 = RaySphere(cp - of, rd, r);\n    vec2 sph1 = RaySphere(cp - of2, rd, r);\n    \n    float sph = sph0.x;\n    \n    if (sph1.x < sph)\n    {\n        sph = sph1.x;\n        of = of2;\n    }\n    \n    ct = sph > ct - EPS ? sph : MAX_DIST;\n    \n    tp = cp + rd * ct;\n    \n    if (ct < t)\n    {\n        t = ct;\n        n = normalize(tp - of);\n        occ = 1.0;\n        mat = 3;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 pdx = ro - rddx * dot(ro - p, n) / dot(rddx, n);\n    vec3 pdy = ro - rddy * dot(ro - p, n) / dot(rddy, n);\n    \n    float i = (floor((p.z) / s - EPS)) * s;\n    float f = p.z - i;\n    \n    vec3 tn, bn;\n    basis(n, tn, bn);\n    \n    vec3 col = vec3(p);\n    \n    float sc = mat == 0 ? 0.8 : mat == 1 ? 0.4 : 0.1;\n    vec2 st = vec2(dot(p, tn), dot(p, bn));\n    vec2 ddx = vec2(dot(pdx, tn), dot(pdx, bn)) - st;\n    vec2 ddy = vec2(dot(pdy, tn), dot(pdy, bn)) - st;\n    \n    if (mat == 1 || mat == 0)\n    {\n        st += hash22(vec2(i, 5)) * 3.0;\n    }\n    if (mat == 0 && rd.x < 0.0 && abs(n.z) < 0.5)\n    {\n        st += hash22(vec2(3.5, 2.5));\n    }\n    st *= sc;\n    ddx *= sc;\n    ddy *= sc;\n    \n    float eps = EPS * sc;\n    vec3 alb = getTexture(st, ddx, ddy, mat);\n    vec3 albDx = getTexture(st + vec2(eps, 0), ddx, ddy, mat);\n    vec3 albDy = getTexture(st + vec2(0, eps), ddx, ddy, mat);\n    \n    float h = luminance(alb);\n    float hx = luminance(albDx);\n    float hy = luminance(albDy);\n    \n    if (mat != 3)\n        n = normalize(n * 50.0 + (tn * (h - hx) + bn * (h - hy)) / eps);\n    \n    float dif = 1.0;\n    float spec = 1.0;\n    if (mat == 0)\n    {\n        alb = alb*alb*(3.0 - 2.0 * alb);\n        alb = RGBtoHSV(alb);\n\n        alb.x += 0.55 + (hash21(floor(i / 16.0)).x - 0.5) * 0.05;\n        alb.y *= 0.4;\n        alb.z *= 0.8;\n\n        alb = HSVtoRGB(saturate(alb));\n        spec = 0.7;\n    } else if (mat == 1)\n    {\n        alb = alb*alb*(3.0 - 2.0 * alb);\n        //alb *= 0.8;\n        spec = 1.5;\n    } else if (mat == 2) {\n        alb = RGBtoHSV(alb);\n        \n        alb.y *= 0.8;\n        alb.z *= 0.8;\n\n        alb = HSVtoRGB(saturate(alb));\n        \n        spec = 0.2;\n    } else if (mat == 3) {\n        alb = vec3(5.0);\n    } else if (mat == 4) {\n        alb = sRGBToLinear(tex.rgb);\n    }\n    \n    vec3 ldir = rd;\n    float dif0 = max(dot(n, -ldir), 0.0);\n    float spec0 = pow(max(dot(reflect(-ldir, n), rd), 0.0), 5.0);\n    vec3 spotDir = normalize(cmat[2] + vec3(0, 0.01, 0) * sin(iTime * 7.0));\n    float atten0 = 0.4 * saturate((1.0 - (1.0 - dot(spotDir, rd)) / (1.0 - 0.85)));\n    atten0 *= 0.7 + 0.3 * getFlicker(int(iTime * 16.0));\n    atten0 += 0.005;\n    \n    dif0 *= atten0;\n    spec0 *= atten0;\n    \n    vec3 lpos = vec3(0, lightHeight, columnSpacing * 0.5);\n    lpos.z += (floor((p.z) / s - EPS)) * s;\n    \n    ldir = p - lpos;\n    float ldist = length(ldir);\n    ldir /= ldist;\n    \n    float dif1 = max(dot(n, -ldir), 0.0);\n    float spec1 = pow(max(dot(reflect(-ldir, n), rd), 0.0), 25.0);\n    float atten1 = 2.0 / max(ldist*ldist * 4.0 + 8.0 * ldist, EPS);\n    float flk = getFlicker(int(iTime * 8.0 + i * 3.0));\n    float flkt = (p.z - i) / columnSpacing - 0.5;\n    float flk1 = getFlicker(int(iTime * 8.0 + (i + sign(flkt) * s) * 3.0));\n    //flkt = abs(flkt) * 2.0;//smoothstep(0.0, 1.0, abs(flkt))\n    flkt = (abs(flkt) * 2.0 - 0.7) / 0.3;\n    flkt = smoothstep(0.0, 1.0, flkt) * 0.5;\n    flk = mix(flk, flk1, flkt);\n    \n    atten1 *= flk * 0.9 + 0.1;\n    dif1 *= atten1;\n    spec1 *= atten1;\n    \n    dif *= dif0 + dif1;\n    spec *= spec0 + spec1;\n    \n    occ = saturate(occ / occRad);\n    occ = mix(occ, 1.0, 0.1);\n    \n#ifdef SHOW_MATERIALS\n    col = uv.x < 0.25 ? vec3(alb * occ)  :\n          uv.x < 0.5  ? vec3(dif * occ)  :\n          uv.x < 0.75 ? vec3(spec * occ) :\n                        vec3(n);\n#else\n    col = alb * (dif + spec * 2.0) * occ;\n    \n    if (mat == 3)\n    {\n        col = mix(col * 0.2, alb, flk);\n    }\n    \n    vec3 fogCol = vec3(0.05, 0.18, 0.2) * 0.12;\n#ifdef FOG\n    col = mix(col, fogCol, 1.0 - exp(-t * FOG_STRENGTH));\n#endif\n#endif\n    \n    col = max(col, vec3(0));\n    //col = col / (1. + col);\n    //col = Tonemap_Uchimura(col);\n    col = mix(col / (1. + col), ACESFilm(col), 0.5);\n    \n    col *= 0.5 + 0.5 / (1.0 + dot(pv, pv) * 0.5);\n    \n    tot += col;\n    \n#ifdef AA\n    }\n    tot /= 4.0;\n#endif\n\n    fragColor = vec4(linearTosRGB(tot), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n\n// Orthonormal basis\n// https://www.shadertoy.com/view/tlVczh\n#define METHOD 1\n#if METHOD == 0\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  // MBR method 2a variant, seems similiar to pixar\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n}\n#elif METHOD == 1\n// Goofy ahh basis but Z-aligned\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n    vec3 u = abs(n.y) > 0.9999 ? vec3(0, 0, 1) : vec3(0, 1, 0);\n    xp = normalize(cross(n, u));\n    yp = cross(n, xp);\n}\n#endif\n\n\n// https://iquilezles.org/articles/intersectors/\nvec2 RaySphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( b > 0.0 || h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 RayCylinder( in vec3 ro, in vec3 rd, float cr )\n{\n    vec3 ca = vec3(0, 0, 1);\n    vec3  oc = ro;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(MAX_DIST); //no intersection\n    h = sqrt(h);\n    if (-b+h < 0.0) return vec2(MAX_DIST);\n    return vec2(-b-h,-b+h)/a;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo, float a)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(sin(a), cos(a), 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec2 saturate(vec2 x)\n{\n    return clamp(x, vec2(0), vec2(0));\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nfloat luminance(vec3 c)\n{\n    return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// RGB to HSV conversion from\n// https://www.chilliant.com/rgb2hsv.html\nvec3 RGBtoHCV(in vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + 1e-5) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSV(in vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float S = HCV.y / (HCV.z + 1e-5);\n    return vec3(HCV.x, S, HCV.z);\n}\n\n\nvec3 HUEtoRGB(in float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n  \nvec3 HSVtoRGB(in vec3 HSV)\n{\n    vec3 RGB = HUEtoRGB(HSV.x);\n    return ((RGB - 1.0) * HSV.y + 1.0) * HSV.z;\n}\n\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.76;//2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nfloat Tonemap_Uchimura(float x) {\n    const float P = 1.0;  // max display brightness\n    const float a = 1.0;  // contrast\n    const float m = 0.22; // linear section start\n    const float l = 0.4;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n    return Tonemap_Uchimura(x, P, a, m, l, c, b);\n}\n\nvec3 Tonemap_Uchimura(vec3 c)\n{\n    return vec3(Tonemap_Uchimura(c.x), Tonemap_Uchimura(c.y), Tonemap_Uchimura(c.z));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[701, 701, 743, 743, 882], [884, 884, 946, 946, 1306], [1308, 1363, 1419, 1419, 1901], [1903, 1903, 1956, 1956, 2406], [2408, 2408, 2461, 2461, 2911], [2913, 2913, 2948, 2948, 3327], [3329, 3329, 3384, 3384, 3833], [3835, 3835, 3882, 3882, 4173], [4175, 4175, 4200, 4200, 4246]], "test": "untested"}
{"id": "dsVXRm", "name": "3D low poly rotating Amogus", "author": "GetItemFromBlock", "description": "Fork of https://www.shadertoy.com/view/DdcSz8\nThis acts as a test for a bigger 3d model (228 triangles in this case)", "tags": ["3d", "rasterizer", "lowpoly", "sus", "amogus", "sussy"], "likes": 5, "viewed": 241, "published": 3, "date": "1680895060", "time_retrieved": "2024-07-30T18:01:45.052700", "image_code": "// Fork of \"Space Ship with Anaglyph 3D\" by GetItemFromBlock. https://shadertoy.com/view/DdcSz8\n// GetItemFromBlock - 2023-04-07\n\n// Based on \"Rasterizer - Cube\" by iq. https://shadertoy.com/view/XdlGzn\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Update - 2023-05-30\n// Added reflection on the glass, not sure if this is an improvement...\n\n// Update - 2024-02-09\n// Added environment cubemap for background, to go with the glass reflection\n\nvec3 rasterize(in vec2 fragCoord)\n{\n    vec2 px = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    vec3 cameraPos = texelFetch(iChannel1, ivec2(0,4), 0).rgb;\n    mat4 m = mat4(\n        texelFetch(iChannel1,ivec2(0,5),0),\n        texelFetch(iChannel1,ivec2(0,6),0),\n        texelFetch(iChannel1,ivec2(0,7),0),\n        texelFetch(iChannel1,ivec2(0,8),0)\n    );\n    //vec3 color = vec3(0.478,0.478,0.478);\n    vec3 color = texture(iChannel2, (m * vec4(normalize(vec3(px, 1.5)), 0.)).xyz).rgb;\n    // clear zbuffer\n    float mindist = -1000000.0;\n    \n    for (int i = 0; i < TRIANGLE_COUNT; i++)\n    {\n        vec4 bounds = texelFetch(iChannel0, ivec2(i, 3), 0);\n        if (px.x < bounds.x || px.x > bounds.y || px.y < bounds.z || px.y > bounds.w)\n        {\n            continue;\n        }\n        vec4 frb = texelFetch(iChannel0, ivec2(i, 1), 0);\n        vec4 frc = texelFetch(iChannel0, ivec2(i, 2), 0);\n        vec2 cp0 = frb.xy;\n        vec2 cp1 = frb.zw;\n        vec2 cp2 = frc.xy;\n\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n                        \n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            vec4 fra = texelFetch(iChannel0, ivec2(i, 0), 0);\n            float w0 = fra.x;\n            float w1 = fra.y;\n            float w2 = fra.z;\n            \n            vec3 p0 = vectors[triangles[i].a] * w0;\n            vec3 p1 = vectors[triangles[i].b] * w1;\n            vec3 p2 = vectors[triangles[i].c] * w2;\n            \n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n            \n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n\n\t\t\t// depth (-1/z) buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n                \n                vec3 na = vectors[triangles[i].na] * w0;\n                vec3 nb = vectors[triangles[i].nb] * w1;\n                vec3 nc = vectors[triangles[i].nc] * w2;\n                vec3 n = ba.x*na + ba.y*nb + ba.z*nc;\n                \n\t\t\t\t// perform lighting/shading \n                vec3 worldPos = p0 * ba.x + p1 * ba.y + p2 * ba.z;\n                worldPos *= z;\n                n = normalize(n*z);\n                vec3 viewdir = normalize(cameraPos-worldPos);\n\t\t\t\tcolor = shader(-viewdir, n, vectors[triangles[i].col]);\n                float f = 0.95;\n                if (vectors[triangles[i].col].r < .5)\n                {\n                    f = 0.9;\n                }\n                color = mix(texture(iChannel2, reflect(viewdir, n)).rgb, color, f);\n\t\t\t}\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(rasterize(fragCoord), 1);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < 1)\n    {\n        if (coord.y < 9)\n        {\n            float rx = iMouse.z <= 0. ? .3 + .3 * sin(iTime * .55) : (iMouse.y/iResolution.y-.5)*-3.1415;\n            float ry = iMouse.z <= 0. ? .3*iTime : iMouse.x/iResolution.x*10.;\n            if (coord.y == 4)\n            {\n                fragColor = vec4(0,0,-8,0) * setRotation( rx, 0.,  0. ) * setRotation( 0., ry, 0. );\n            }\n            else if (coord.y < 4)\n            {\n                mat4 mv = setTranslation(0., 0., -8. ) * \n                   setRotation( rx, 0.,  0. ) * \n                   setRotation( 0., ry, 0. );\n                fragColor = mv[coord.y];\n            }\n            else\n            {\n                mat4 m = setRotation(rx, ry, 0.);\n                fragColor = m[coord.y - 5];\n            }\n        }\n    }\n}", "buffer_a_inputs": [], "common_code": "#define TRIANGLE_COUNT 228\n\nstruct Triangle\n{\n    int a;\n    int na;\n    int b;\n    int nb;\n    int c;\n    int nc;\n    int col;\n};\n\nconst Triangle triangles[TRIANGLE_COUNT] = Triangle[TRIANGLE_COUNT](\n    Triangle(0, 1, 2, 3, 4, 5, 6),\n    Triangle(7, 8, 0, 1, 9, 10, 6),\n    Triangle(2, 3, 11, 12, 13, 14, 6),\n    Triangle(15, 16, 17, 18, 19, 20, 6),\n    Triangle(0, 1, 21, 22, 17, 18, 6),\n    Triangle(23, 24, 25, 26, 27, 28, 6),\n    Triangle(29, 30, 25, 26, 23, 24, 6),\n    Triangle(0, 1, 4, 5, 21, 22, 6),\n    Triangle(29, 30, 31, 32, 33, 34, 6),\n    Triangle(31, 32, 23, 24, 35, 36, 6),\n    Triangle(35, 36, 23, 24, 27, 28, 6),\n    Triangle(19, 20, 17, 18, 37, 38, 6),\n    Triangle(4, 5, 13, 14, 39, 40, 6),\n    Triangle(41, 42, 43, 44, 45, 46, 6),\n    Triangle(4, 5, 33, 34, 45, 46, 6),\n    Triangle(47, 48, 15, 16, 49, 50, 6),\n    Triangle(11, 12, 51, 52, 53, 54, 6),\n    Triangle(47, 48, 9, 10, 15, 16, 6),\n    Triangle(55, 56, 7, 8, 9, 10, 6),\n    Triangle(57, 58, 55, 56, 47, 48, 6),\n    Triangle(59, 60, 53, 54, 51, 52, 6),\n    Triangle(61, 62, 51, 52, 55, 56, 6),\n    Triangle(37, 38, 47, 48, 49, 50, 6),\n    Triangle(63, 64, 57, 58, 37, 38, 6),\n    Triangle(35, 36, 65, 66, 67, 68, 6),\n    Triangle(17, 18, 43, 44, 69, 70, 6),\n    Triangle(11, 12, 53, 54, 59, 60, 6),\n    Triangle(7, 8, 55, 56, 51, 52, 6),\n    Triangle(59, 60, 61, 62, 71, 72, 6),\n    Triangle(71, 72, 61, 62, 25, 26, 6),\n    Triangle(57, 58, 61, 62, 55, 56, 6),\n    Triangle(9, 10, 0, 1, 15, 16, 6),\n    Triangle(35, 36, 27, 28, 65, 66, 6),\n    Triangle(65, 66, 27, 28, 69, 70, 6),\n    Triangle(2, 3, 7, 8, 11, 12, 6),\n    Triangle(2, 3, 0, 1, 7, 8, 6),\n    Triangle(15, 16, 0, 1, 17, 18, 6),\n    Triangle(27, 28, 25, 26, 61, 62, 6),\n    Triangle(27, 28, 61, 62, 63, 64, 6),\n    Triangle(63, 64, 61, 62, 57, 58, 6),\n    Triangle(29, 30, 71, 72, 25, 26, 6),\n    Triangle(21, 22, 4, 5, 45, 46, 6),\n    Triangle(33, 34, 39, 40, 71, 72, 6),\n    Triangle(73, 74, 35, 36, 67, 68, 6),\n    Triangle(67, 68, 65, 66, 41, 42, 6),\n    Triangle(39, 40, 13, 14, 71, 72, 6),\n    Triangle(33, 34, 31, 32, 73, 74, 6),\n    Triangle(43, 44, 21, 22, 45, 46, 6),\n    Triangle(31, 32, 29, 30, 23, 24, 6),\n    Triangle(27, 28, 63, 64, 69, 70, 6),\n    Triangle(63, 64, 37, 38, 69, 70, 6),\n    Triangle(43, 44, 17, 18, 21, 22, 6),\n    Triangle(45, 46, 33, 34, 73, 74, 6),\n    Triangle(4, 5, 2, 3, 13, 14, 6),\n    Triangle(45, 46, 73, 74, 67, 68, 6),\n    Triangle(67, 68, 41, 42, 45, 46, 6),\n    Triangle(4, 5, 39, 40, 33, 34, 6),\n    Triangle(49, 50, 15, 16, 19, 20, 6),\n    Triangle(11, 12, 7, 8, 51, 52, 6),\n    Triangle(13, 14, 11, 12, 59, 60, 6),\n    Triangle(47, 48, 55, 56, 9, 10, 6),\n    Triangle(61, 62, 59, 60, 51, 52, 6),\n    Triangle(37, 38, 57, 58, 47, 48, 6),\n    Triangle(33, 34, 71, 72, 29, 30, 6),\n    Triangle(41, 42, 65, 66, 69, 70, 6),\n    Triangle(73, 74, 31, 32, 35, 36, 6),\n    Triangle(41, 42, 69, 70, 43, 44, 6),\n    Triangle(71, 72, 13, 14, 59, 60, 6),\n    Triangle(37, 38, 17, 18, 69, 70, 6),\n    Triangle(49, 50, 19, 20, 37, 38, 6),\n    Triangle(75, 76, 77, 78, 79, 80, 6),\n    Triangle(81, 82, 79, 80, 83, 84, 6),\n    Triangle(85, 86, 79, 80, 81, 82, 6),\n    Triangle(77, 78, 87, 88, 89, 90, 6),\n    Triangle(79, 80, 89, 90, 83, 84, 6),\n    Triangle(91, 92, 93, 94, 95, 96, 6),\n    Triangle(91, 92, 95, 96, 97, 98, 6),\n    Triangle(99, 100, 97, 98, 87, 88, 6),\n    Triangle(101, 102, 103, 104, 105, 106, 6),\n    Triangle(103, 104, 107, 108, 109, 110, 6),\n    Triangle(111, 112, 113, 114, 93, 94, 6),\n    Triangle(115, 116, 117, 118, 81, 82, 6),\n    Triangle(119, 120, 121, 122, 123, 124, 6),\n    Triangle(125, 126, 127, 128, 121, 122, 6),\n    Triangle(127, 128, 129, 130, 123, 124, 6),\n    Triangle(125, 126, 131, 132, 127, 128, 6),\n    Triangle(127, 128, 131, 132, 133, 134, 6),\n    Triangle(127, 128, 133, 134, 129, 130, 6),\n    Triangle(135, 136, 137, 138, 103, 104, 6),\n    Triangle(137, 138, 107, 108, 103, 104, 6),\n    Triangle(137, 138, 85, 86, 117, 118, 6),\n    Triangle(99, 100, 75, 76, 139, 140, 6),\n    Triangle(131, 132, 141, 142, 133, 134, 6),\n    Triangle(133, 134, 143, 144, 129, 130, 6),\n    Triangle(145, 146, 129, 130, 143, 144, 6),\n    Triangle(141, 142, 115, 116, 143, 144, 6),\n    Triangle(143, 144, 81, 82, 145, 146, 6),\n    Triangle(147, 148, 113, 114, 149, 150, 6),\n    Triangle(113, 114, 101, 102, 105, 106, 6),\n    Triangle(105, 106, 109, 110, 141, 142, 6),\n    Triangle(141, 142, 131, 132, 149, 150, 6),\n    Triangle(125, 126, 149, 150, 131, 132, 6),\n    Triangle(119, 120, 97, 98, 95, 96, 6),\n    Triangle(95, 96, 147, 148, 119, 120, 6),\n    Triangle(151, 152, 89, 90, 123, 124, 6),\n    Triangle(129, 130, 83, 84, 151, 152, 6),\n    Triangle(87, 88, 119, 120, 123, 124, 6),\n    Triangle(85, 86, 75, 76, 79, 80, 6),\n    Triangle(77, 78, 75, 76, 99, 100, 6),\n    Triangle(77, 78, 99, 100, 87, 88, 6),\n    Triangle(79, 80, 77, 78, 89, 90, 6),\n    Triangle(99, 100, 139, 140, 91, 92, 6),\n    Triangle(91, 92, 139, 140, 153, 154, 6),\n    Triangle(139, 140, 135, 136, 153, 154, 6),\n    Triangle(153, 154, 111, 112, 93, 94, 6),\n    Triangle(91, 92, 153, 154, 93, 94, 6),\n    Triangle(99, 100, 91, 92, 97, 98, 6),\n    Triangle(111, 112, 103, 104, 101, 102, 6),\n    Triangle(111, 112, 135, 136, 103, 104, 6),\n    Triangle(105, 106, 103, 104, 109, 110, 6),\n    Triangle(153, 154, 135, 136, 111, 112, 6),\n    Triangle(113, 114, 111, 112, 101, 102, 6),\n    Triangle(109, 110, 117, 118, 115, 116, 6),\n    Triangle(109, 110, 107, 108, 117, 118, 6),\n    Triangle(81, 82, 117, 118, 85, 86, 6),\n    Triangle(147, 148, 125, 126, 121, 122, 6),\n    Triangle(121, 122, 127, 128, 123, 124, 6),\n    Triangle(123, 124, 129, 130, 151, 152, 6),\n    Triangle(119, 120, 147, 148, 121, 122, 6),\n    Triangle(135, 136, 139, 140, 137, 138, 6),\n    Triangle(139, 140, 75, 76, 137, 138, 6),\n    Triangle(137, 138, 117, 118, 107, 108, 6),\n    Triangle(137, 138, 75, 76, 85, 86, 6),\n    Triangle(133, 134, 141, 142, 143, 144, 6),\n    Triangle(141, 142, 109, 110, 115, 116, 6),\n    Triangle(143, 144, 115, 116, 81, 82, 6),\n    Triangle(147, 148, 93, 94, 113, 114, 6),\n    Triangle(113, 114, 105, 106, 149, 150, 6),\n    Triangle(105, 106, 141, 142, 149, 150, 6),\n    Triangle(147, 148, 149, 150, 125, 126, 6),\n    Triangle(95, 96, 93, 94, 147, 148, 6),\n    Triangle(87, 88, 97, 98, 119, 120, 6),\n    Triangle(151, 152, 83, 84, 89, 90, 6),\n    Triangle(89, 90, 87, 88, 123, 124, 6),\n    Triangle(129, 130, 145, 146, 83, 84, 6),\n    Triangle(145, 146, 81, 82, 83, 84, 6),\n    Triangle(155, 156, 157, 158, 159, 160, 6),\n    Triangle(161, 162, 163, 164, 157, 158, 6),\n    Triangle(165, 166, 167, 168, 163, 164, 6),\n    Triangle(167, 168, 169, 170, 171, 172, 6),\n    Triangle(171, 172, 173, 174, 175, 176, 6),\n    Triangle(175, 176, 177, 178, 179, 180, 6),\n    Triangle(179, 180, 181, 182, 159, 160, 6),\n    Triangle(179, 180, 159, 160, 163, 164, 6),\n    Triangle(175, 176, 179, 180, 163, 164, 6),\n    Triangle(183, 156, 184, 185, 186, 187, 6),\n    Triangle(188, 162, 189, 190, 184, 185, 6),\n    Triangle(191, 192, 193, 194, 189, 190, 6),\n    Triangle(193, 194, 195, 196, 197, 198, 6),\n    Triangle(197, 198, 199, 200, 201, 202, 6),\n    Triangle(201, 202, 203, 204, 205, 206, 6),\n    Triangle(205, 206, 207, 178, 208, 209, 6),\n    Triangle(208, 209, 210, 182, 186, 187, 6),\n    Triangle(184, 185, 208, 209, 186, 187, 6),\n    Triangle(201, 202, 205, 206, 197, 198, 6),\n    Triangle(189, 190, 208, 209, 184, 185, 6),\n    Triangle(189, 190, 193, 194, 208, 209, 6),\n    Triangle(155, 156, 161, 162, 157, 158, 6),\n    Triangle(161, 162, 165, 166, 163, 164, 6),\n    Triangle(165, 166, 211, 212, 167, 168, 6),\n    Triangle(211, 212, 169, 170, 167, 168, 6),\n    Triangle(171, 172, 169, 170, 213, 214, 6),\n    Triangle(171, 172, 213, 214, 173, 174, 6),\n    Triangle(175, 176, 173, 174, 177, 178, 6),\n    Triangle(179, 180, 177, 178, 181, 182, 6),\n    Triangle(181, 182, 155, 156, 159, 160, 6),\n    Triangle(171, 172, 175, 176, 163, 164, 6),\n    Triangle(167, 168, 171, 172, 163, 164, 6),\n    Triangle(159, 160, 157, 158, 163, 164, 6),\n    Triangle(183, 156, 188, 162, 184, 185, 6),\n    Triangle(188, 162, 191, 192, 189, 190, 6),\n    Triangle(191, 192, 215, 212, 193, 194, 6),\n    Triangle(215, 212, 195, 196, 193, 194, 6),\n    Triangle(197, 198, 195, 196, 199, 200, 6),\n    Triangle(201, 202, 199, 200, 203, 204, 6),\n    Triangle(205, 206, 203, 204, 207, 178, 6),\n    Triangle(208, 209, 207, 178, 210, 182, 6),\n    Triangle(210, 182, 183, 156, 186, 187, 6),\n    Triangle(197, 198, 205, 206, 208, 209, 6),\n    Triangle(193, 194, 197, 198, 208, 209, 6),\n    Triangle(216, 217, 218, 219, 220, 221, 222),\n    Triangle(223, 224, 218, 219, 216, 217, 222),\n    Triangle(218, 219, 225, 226, 220, 221, 222),\n    Triangle(218, 219, 227, 228, 229, 230, 222),\n    Triangle(231, 232, 233, 234, 235, 236, 222),\n    Triangle(231, 232, 237, 238, 233, 234, 222),\n    Triangle(229, 230, 235, 236, 225, 226, 222),\n    Triangle(239, 240, 223, 224, 216, 217, 222),\n    Triangle(216, 217, 241, 242, 243, 244, 222),\n    Triangle(235, 236, 220, 221, 225, 226, 222),\n    Triangle(245, 246, 247, 248, 239, 240, 222),\n    Triangle(239, 240, 249, 250, 245, 246, 222),\n    Triangle(233, 234, 237, 238, 251, 252, 222),\n    Triangle(251, 252, 249, 250, 253, 254, 222),\n    Triangle(249, 250, 239, 240, 253, 254, 222),\n    Triangle(253, 254, 239, 240, 216, 217, 222),\n    Triangle(227, 228, 231, 232, 229, 230, 222),\n    Triangle(223, 224, 247, 248, 218, 219, 222),\n    Triangle(218, 219, 229, 230, 225, 226, 222),\n    Triangle(218, 219, 247, 248, 227, 228, 222),\n    Triangle(241, 242, 216, 217, 220, 221, 222),\n    Triangle(229, 230, 231, 232, 235, 236, 222),\n    Triangle(233, 234, 251, 252, 255, 256, 222),\n    Triangle(255, 256, 253, 254, 243, 244, 222),\n    Triangle(255, 256, 251, 252, 253, 254, 222),\n    Triangle(235, 236, 233, 234, 255, 256, 222),\n    Triangle(235, 236, 255, 256, 257, 258, 222),\n    Triangle(255, 256, 243, 244, 257, 258, 222),\n    Triangle(235, 236, 257, 258, 220, 221, 222),\n    Triangle(227, 228, 247, 248, 245, 246, 222),\n    Triangle(237, 238, 231, 232, 227, 228, 222),\n    Triangle(247, 248, 223, 224, 239, 240, 222),\n    Triangle(251, 252, 237, 238, 245, 246, 222),\n    Triangle(237, 238, 227, 228, 245, 246, 222),\n    Triangle(251, 252, 245, 246, 249, 250, 222),\n    Triangle(220, 221, 257, 258, 241, 242, 222),\n    Triangle(241, 242, 257, 258, 243, 244, 222),\n    Triangle(243, 244, 253, 254, 216, 217, 222)\n);\n\nconst vec3 vectors[] = vec3[](\n    vec3(-1.467723, 1.402789, 2.793147),\n    vec3(-0.9203  , 0.2487  , 0.3018  ),\n    vec3(-1.390775, 1.580521, 1.996575),\n    vec3(-0.7356  , 0.5517  ,-0.393   ),\n    vec3(-1.411498, 1.156415, 1.847106),\n    vec3(-0.8643  , 0.106   ,-0.4917  ),\n    vec3( 0.603827, 0.001314, 0.      ),\n    vec3(-1.36174 , 1.647689, 2.73756 ),\n    vec3(-0.5053  , 0.7799  , 0.3694  ),\n    vec3(-1.300665, 1.395768, 2.978765),\n    vec3(-0.3311  , 0.433   , 0.8384  ),\n    vec3(-1.28026 , 1.726427, 2.190668),\n    vec3(-0.3523  , 0.9208  ,-0.1676  ),\n    vec3(-1.268954, 1.508682, 1.840646),\n    vec3(-0.2984  , 0.5351  ,-0.7904  ),\n    vec3(-1.357872, 0.951839, 3.078538),\n    vec3(-0.5358  , 0.0964  , 0.8388  ),\n    vec3(-1.40081 ,-1.367545, 3.047107),\n    vec3(-0.6128  ,-0.3116  , 0.7262  ),\n    vec3(-1.295568,-1.061999, 3.118558),\n    vec3(-0.2574  ,-0.0679  , 0.9639  ),\n    vec3(-1.480515,-1.104696, 2.663844),\n    vec3(-0.9969  ,-0.0574  , 0.0541  ),\n    vec3( 1.352643,-1.110194, 1.804947),\n    vec3( 0.7963  ,-0.1519  ,-0.5856  ),\n    vec3( 1.365353, 1.0269  , 1.826562),\n    vec3( 0.869   , 0.0625  ,-0.4908  ),\n    vec3( 1.407727,-1.352349, 2.164311),\n    vec3( 0.9684  ,-0.2158  ,-0.1254  ),\n    vec3( 1.212074,-0.951105, 1.698061),\n    vec3( 0.2902  ,-0.0916  ,-0.9526  ),\n    vec3( 1.222955,-1.378182, 1.814199),\n    vec3( 0.3432  ,-0.5075  ,-0.7904  ),\n    vec3(-1.300193,-1.096719, 1.706141),\n    vec3(-0.4828  ,-0.1866  ,-0.8556  ),\n    vec3( 1.284787,-1.566153, 2.039392),\n    vec3( 0.5078  ,-0.7497  ,-0.4243  ),\n    vec3( 1.307832,-1.32026 , 3.060651),\n    vec3( 0.5811  ,-0.3151  , 0.7504  ),\n    vec3(-1.260415, 1.061015, 1.717737),\n    vec3(-0.3195  , 0.1121  ,-0.9409  ),\n    vec3(-1.32314 ,-1.659542, 2.685035),\n    vec3(-0.4541  ,-0.8825  , 0.1224  ),\n    vec3(-1.396928,-1.548611, 2.917764),\n    vec3(-0.6126  ,-0.6372  , 0.4677  ),\n    vec3(-1.428629,-1.405746, 1.99554 ),\n    vec3(-0.8667  ,-0.356   ,-0.3495  ),\n    vec3( 1.206166, 0.967467, 3.084249),\n    vec3( 0.3064  , 0.1041  , 0.9462  ),\n    vec3( 1.200113,-1.03675 , 3.119145),\n    vec3( 0.2298  ,-0.0535  , 0.9718  ),\n    vec3( 1.262524, 1.688401, 2.634125),\n    vec3( 0.4992  , 0.8075  , 0.3143  ),\n    vec3( 1.139729, 1.73404 , 2.328427),\n    vec3( 0.187   , 0.9814  ,-0.0435  ),\n    vec3( 1.289506, 1.440924, 2.956904),\n    vec3( 0.5483  , 0.4791  , 0.6855  ),\n    vec3( 1.365445, 1.065426, 2.951288),\n    vec3( 0.8815  , 0.0792  , 0.4656  ),\n    vec3( 1.250601, 1.651799, 1.990116),\n    vec3( 0.4023  , 0.7373  ,-0.5427  ),\n    vec3( 1.401426, 1.569483, 2.154963),\n    vec3( 0.877   , 0.454   ,-0.1572  ),\n    vec3( 1.401238,-1.12958 , 2.765244),\n    vec3( 0.9869  ,-0.067   , 0.147   ),\n    vec3( 1.291773,-1.66797 , 2.426756),\n    vec3( 0.5403  ,-0.8403  ,-0.044   ),\n    vec3(-1.302087,-1.646724, 2.252542),\n    vec3(-0.4463  ,-0.8738  ,-0.1928  ),\n    vec3( 1.301057,-1.609408, 2.844538),\n    vec3( 0.556   ,-0.7175  , 0.4195  ),\n    vec3( 1.227662, 1.19807 , 1.719471),\n    vec3( 0.3854  , 0.2605  ,-0.8852  ),\n    vec3(-1.285415,-1.493353, 1.922389),\n    vec3(-0.3093  ,-0.6951  ,-0.649   ),\n    vec3(-1.217086, 2.938846,-0.176011),\n    vec3(-0.6477  , 0.7552  ,-0.101   ),\n    vec3(-1.622429, 1.862037,-0.606663),\n    vec3(-0.9235  , 0.2141  ,-0.3182  ),\n    vec3(-1.68248 , 1.841972, 0.695523),\n    vec3(-0.9332  , 0.2348  , 0.2721  ),\n    vec3(-1.068662, 1.82449 , 1.552062),\n    vec3(-0.5704  , 0.2287  , 0.7889  ),\n    vec3(-1.689393,-0.869488, 1.075233),\n    vec3(-0.882   ,-0.144   , 0.4486  ),\n    vec3(-1.152853, 2.722428, 0.967582),\n    vec3(-0.6137  , 0.6536  , 0.4429  ),\n    vec3(-1.415963,-0.776979,-1.260082),\n    vec3(-0.7346  ,-0.1299  ,-0.666   ),\n    vec3(-1.93473 ,-0.922571,-0.08375 ),\n    vec3(-0.9794  ,-0.1716  ,-0.1068  ),\n    vec3(-0.175346, 1.971682,-1.629237),\n    vec3(-0.0857  , 0.2119  ,-0.9735  ),\n    vec3( 1.310212,-0.764196,-1.391554),\n    vec3( 0.6317  ,-0.1223  ,-0.7655  ),\n    vec3( 0.03659 ,-1.247743,-1.767346),\n    vec3( 0.034   ,-0.3467  ,-0.9374  ),\n    vec3(-0.709323,-0.873116,-1.673044),\n    vec3(-0.3481  ,-0.1378  ,-0.9273  ),\n    vec3(-1.142164, 2.421096,-1.127311),\n    vec3(-0.6135  , 0.4187  ,-0.6696  ),\n    vec3( 1.785885, 1.874228, 0.104558),\n    vec3( 0.9778  , 0.1951  , 0.0765  ),\n    vec3( 1.502465, 2.705021, 0.341846),\n    vec3( 0.7915  , 0.5977  , 0.1279  ),\n    vec3( 1.832933,-0.525335, 0.844863),\n    vec3( 0.9321  ,-0.069   , 0.3555  ),\n    vec3( 0.924295, 2.905094, 1.039198),\n    vec3( 0.4459  , 0.7508  , 0.4873  ),\n    vec3( 1.090202, 2.001804, 1.543903),\n    vec3( 0.5834  , 0.2657  , 0.7675  ),\n    vec3( 1.49786 , 2.053238,-0.864546),\n    vec3( 0.8192  , 0.2818  ,-0.4996  ),\n    vec3( 1.868159,-0.883777,-0.38379 ),\n    vec3( 0.9457  ,-0.1969  ,-0.2588  ),\n    vec3(-0.145196, 1.793973, 1.891736),\n    vec3(-0.0473  , 0.2204  , 0.9743  ),\n    vec3(-0.164957, 2.916597, 1.374194),\n    vec3(-0.0938  , 0.736   , 0.6704  ),\n    vec3(-1.001877,-1.804617,-1.106118),\n    vec3(-0.435   ,-0.6612  ,-0.6112  ),\n    vec3(-0.226168,-2.217284,-0.586741),\n    vec3(-0.05    ,-0.9624  ,-0.2671  ),\n    vec3(-1.453075,-1.949871,-0.244972),\n    vec3(-0.6469  ,-0.7469  ,-0.1538  ),\n    vec3( 1.180051,-2.03489 ,-0.146759),\n    vec3( 0.5018  ,-0.8558  ,-0.1257  ),\n    vec3( 0.247903,-2.215911, 0.783412),\n    vec3( 0.0869  ,-0.9714  , 0.2208  ),\n    vec3(-0.980138,-1.907405, 1.265499),\n    vec3(-0.3976  ,-0.7508  , 0.5275  ),\n    vec3( 1.117519,-1.737701, 1.234505),\n    vec3( 0.548   ,-0.653   , 0.5227  ),\n    vec3( 0.186035,-1.763462, 1.680504),\n    vec3( 0.1068  ,-0.6502  , 0.7522  ),\n    vec3( 0.859297, 3.033141,-0.69366 ),\n    vec3( 0.4295  , 0.8218  ,-0.3743  ),\n    vec3(-0.000116, 3.341052, 0.069966),\n    vec3(-0.0135  , 0.9999  , 0.0098  ),\n    vec3(-0.364997, 2.897427,-1.150696),\n    vec3(-0.1594  , 0.7449  ,-0.6479  ),\n    vec3( 1.204457,-0.873788, 1.658136),\n    vec3( 0.5741  ,-0.1682  , 0.8013  ),\n    vec3(-0.225264,-1.033825, 2.026991),\n    vec3(-0.0771  ,-0.2006  , 0.9766  ),\n    vec3(-1.187404,-0.920757, 1.666351),\n    vec3(-0.5754  ,-0.1717  , 0.7996  ),\n    vec3( 0.935133,-1.767241,-1.217108),\n    vec3( 0.4317  ,-0.6673  ,-0.6069  ),\n    vec3( 1.708557,-1.59444 , 0.34817 ),\n    vec3( 0.8348  ,-0.5396  , 0.1093  ),\n    vec3(-1.434041,-1.800185, 0.822176),\n    vec3(-0.7014  ,-0.6422  , 0.3094  ),\n    vec3( 0.831202, 2.356372,-1.365111),\n    vec3( 0.3996  , 0.3879  ,-0.8306  ),\n    vec3(-0.93491 ,-1.618467,-0.451282),\n    vec3(-0.1377  ,-0.1789  ,-0.9742  ),\n    vec3(-0.530737,-2.889741,-0.133112),\n    vec3( 0.3739  ,-0.7006  ,-0.6077  ),\n    vec3(-0.999855,-2.889733,-0.190104),\n    vec3(-0.2628  ,-0.6993  ,-0.6648  ),\n    vec3(-0.367151,-1.618192,-0.329993),\n    vec3( 0.5581  ,-0.1936  ,-0.8069  ),\n    vec3(-0.313601,-2.889274, 0.184539),\n    vec3( 0.6963  ,-0.7026  ,-0.1466  ),\n    vec3(-0.052068,-1.617912, 0.155811),\n    vec3( 0.9554  ,-0.2095  ,-0.2082  ),\n    vec3(-0.386844,-2.889226, 0.567175),\n    vec3( 0.5652  ,-0.7124  , 0.416   ),\n    vec3(-0.378584,-1.616668, 0.918831),\n    vec3( 0.52    ,-0.185   , 0.8339  ),\n    vec3(-0.813541,-2.889732, 0.804367),\n    vec3(-0.0313  ,-0.6939  , 0.7193  ),\n    vec3(-1.421094,-1.618265, 0.72398 ),\n    vec3(-0.8018  ,-0.2014  , 0.5626  ),\n    vec3(-1.226044,-2.889809, 0.562201),\n    vec3(-0.586   ,-0.6968  , 0.4137  ),\n    vec3(-1.542358,-1.618513, 0.15584 ),\n    vec3(-0.9715  ,-0.1871  ,-0.1454  ),\n    vec3(-1.298914,-2.889162, 0.186281),\n    vec3(-0.6986  ,-0.697   ,-0.1615  ),\n    vec3(-1.325592,-1.619295,-0.234516),\n    vec3(-0.7009  ,-0.1768  ,-0.691   ),\n    vec3( 0.58163 ,-1.618467,-0.451283),\n    vec3( 0.985781,-2.889972,-0.13307 ),\n    vec3( 0.4927  ,-0.6176  ,-0.6131  ),\n    vec3( 0.516732,-2.890274,-0.190001),\n    vec3(-0.2102  ,-0.7563  ,-0.6196  ),\n    vec3( 1.149391,-1.618192,-0.329991),\n    vec3( 1.202925,-2.889342, 0.184543),\n    vec3( 0.6914  ,-0.7222  , 0.0191  ),\n    vec3( 1.464474,-1.617913, 0.155839),\n    vec3( 0.9554  ,-0.2095  ,-0.2081  ),\n    vec3( 1.129697,-2.889226, 0.567173),\n    vec3( 0.5929  ,-0.7124  , 0.3755  ),\n    vec3( 1.137954,-1.616668, 0.918831),\n    vec3( 0.5166  ,-0.1866  , 0.8357  ),\n    vec3( 0.901738,-2.889104, 0.742969),\n    vec3( 0.2527  ,-0.7221  , 0.6439  ),\n    vec3( 0.581628,-1.617971, 1.039093),\n    vec3(-0.1784  ,-0.1914  , 0.9652  ),\n    vec3( 0.608176,-2.889617, 0.77928 ),\n    vec3(-0.1992  ,-0.8297  , 0.5215  ),\n    vec3( 0.095441,-1.618265, 0.723978),\n    vec3(-0.8072  ,-0.1916  , 0.5583  ),\n    vec3( 0.290496,-2.889809, 0.562202),\n    vec3(-0.5958  ,-0.7021  , 0.3899  ),\n    vec3(-0.02582 ,-1.618513, 0.155844),\n    vec3( 0.21772 ,-2.889588, 0.186276),\n    vec3(-0.6964  ,-0.7002  ,-0.1571  ),\n    vec3( 0.190945,-1.619295,-0.234516),\n    vec3(-0.106058,-1.618755, 0.580282),\n    vec3( 0.9054  ,-0.2039  , 0.3724  ),\n    vec3(-0.934912,-1.617971, 1.039093),\n    vec3(-0.1891  ,-0.1956  , 0.9623  ),\n    vec3( 1.410479,-1.618755, 0.580282),\n    vec3(-0.960804, 1.288955,-0.684665),\n    vec3(-0.5033  ,-0.2777  , 0.8182  ),\n    vec3(-1.358191, 1.751234,-1.389909),\n    vec3(-0.9951  , 0.0858  ,-0.0501  ),\n    vec3(-1.079545, 0.825385,-1.393688),\n    vec3(-0.648   ,-0.7599  ,-0.0525  ),\n    vec3( 0.012758, 0.233458, 0.8     ),\n    vec3(-1.062384, 1.96787 ,-0.8331  ),\n    vec3(-0.6389  , 0.3591  , 0.6804  ),\n    vec3(-0.887294, 0.954699,-1.876111),\n    vec3(-0.3988  ,-0.666   ,-0.6304  ),\n    vec3(-0.916477, 2.242859,-1.838715),\n    vec3(-0.4541  , 0.6825  ,-0.5727  ),\n    vec3(-0.97117 , 1.454208,-2.086228),\n    vec3(-0.5252  ,-0.116   ,-0.843   ),\n    vec3( 0.106831, 1.920776,-2.159937),\n    vec3( 0.0235  , 0.2341  ,-0.9719  ),\n    vec3( 1.307449, 1.70823 ,-1.950975),\n    vec3( 0.6963  , 0.1068  ,-0.7097  ),\n    vec3( 1.015787, 0.917776,-1.84717 ),\n    vec3( 0.4196  ,-0.688   ,-0.5921  ),\n    vec3( 0.844611, 2.298428,-1.840639),\n    vec3( 0.2996  , 0.7721  ,-0.5605  ),\n    vec3(-0.529151, 2.049039,-0.659852),\n    vec3(-0.1397  , 0.4637  , 0.8749  ),\n    vec3(-0.864466, 0.862488,-0.987976),\n    vec3(-0.3271  ,-0.7945  , 0.5116  ),\n    vec3( 1.044633, 1.046928,-0.817629),\n    vec3( 0.455   ,-0.5831  , 0.673   ),\n    vec3( 0.045353, 2.489471,-1.193927),\n    vec3(-0.0083  , 0.9822  , 0.1874  ),\n    vec3(-1.067586, 2.288848,-1.218919),\n    vec3(-0.5835  , 0.7928  , 0.176   ),\n    vec3( 0.793809, 2.103578,-0.737679),\n    vec3( 0.2323  , 0.5827  , 0.7788  ),\n    vec3( 1.2354  , 2.263201,-1.239253),\n    vec3( 0.6771  , 0.7184  , 0.1593  ),\n    vec3( 1.127047, 1.606074,-0.651544),\n    vec3( 0.5295  , 0.0297  , 0.8478  ),\n    vec3( 1.484032, 1.411086,-1.31485 ),\n    vec3( 0.9762  ,-0.2037  , 0.0747  ),\n    vec3( 0.858789, 0.754818,-1.180439),\n    vec3( 0.3027  ,-0.9355  , 0.1825  )\n);\n\nfloat cross2d( in vec2 a, in vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nconst vec3 lightDir = normalize(vec3(.5, 1, -1));\nconst vec3 lightCol = vec3(.3, .3, .3);\nconst float smoothness = 256.;\n\nvec3 shader(vec3 view, vec3 normal, vec3 color)\n{\n    float deltaA = dot(lightDir,normal);\n    if (deltaA < 0.) deltaA = 0.;\n    vec3 halfV = normalize(lightDir + view);\n    float deltaB = pow(max(dot(normal,halfV), 0.0), smoothness);\n    return color + lightCol * deltaA + deltaB;\n}", "buffer_b_code": "vec4 processTriangle(ivec2 coord)\n{\n\tmat4 mvp = mat4(\n        texelFetch(iChannel0,ivec2(0,0),0),\n        texelFetch(iChannel0,ivec2(0,1),0),\n        texelFetch(iChannel0,ivec2(0,2),0),\n        texelFetch(iChannel0,ivec2(0,3),0)\n    );\n    vec3 ep0 = (mvp * vec4(vectors[triangles[coord.x].a],1.0)).xyz;\n    vec3 ep1 = (mvp * vec4(vectors[triangles[coord.x].b],1.0)).xyz;\n    vec3 ep2 = (mvp * vec4(vectors[triangles[coord.x].c],1.0)).xyz;\n\n    // transform to clip space\n    float w0 = 1.0/ep0.z;\n    float w1 = 1.0/ep1.z;\n    float w2 = 1.0/ep2.z;\n\n    if (coord.y == 0)\n    {\n        return vec4(w0,w1,w2,0);\n    }\n\n    vec2 cp0 = 2.0*ep0.xy * -w0;\n    vec2 cp1 = 2.0*ep1.xy * -w1;\n    vec2 cp2 = 2.0*ep2.xy * -w2;\n    if (coord.y == 1)\n    {\n        return vec4(cp0, cp1);\n    }\n    else if (coord.y == 2)\n    {\n        return vec4(cp2, 0, 0);\n    }\n    float minY = min(min(cp0.y, cp1.y), cp2.y);\n    float maxY = max(max(cp0.y, cp1.y), cp2.y);\n    float minX = min(min(cp0.x, cp1.x), cp2.x);\n    float maxX = max(max(cp0.x, cp1.x), cp2.x);\n    return vec4(minX, maxX, minY, maxY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < TRIANGLE_COUNT)\n    {\n        if (coord.y < 4)\n        {\n            fragColor = processTriangle(coord);\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVXRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[489, 489, 524, 524, 3230], [3232, 3232, 3289, 3289, 3338]], "test": "untested"}
{"id": "ddVXRm", "name": "Black and white rug", "author": "jarble", "description": "A fractal rug pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 19, "viewed": 272, "published": 3, "date": "1680894313", "time_retrieved": "2024-07-30T18:01:45.907415", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 12; k++){\n        uv = abs(uv+t2+.5);\n        t2 =\n            triangle_wave(uv+.5)/scale\n            //triangle_wave(uv-.5*sign(t2.y-uv.x))/scale\n        ;\n        uv = (t2-triangle_wave(uv.yx))/1.5;\n        col.x =\n            max(length(uv+t2)/2.,col.x)\n        ;\n        col.x =\n            max(abs(col.x-(1.-col.x)),col.x/4.);\n    }\n    fragColor = vec4(vec3(col.x),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //float a1 = a;\n    //a += floor((a1)/2.);\n    //a += floor(floor(a1/2.)/3.);\n    //a += floor(floor(a1/4.)/5.);\n    \n    return\n        mod(floor(a),b)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float tempo = 1.,\n  t2=(1.+fmod(time*2.*pow(2.,fmod(time/8.,3.)),2.));\n  time /= t2*2.;\n  tempo /= (1.+fmod(time/2.,2.));\n  time /= tempo;\n  float t1 = (1.+fmod(time/2.,2.));\n  float s1 =\n      8./t1;\n\n  float s2 = 4.*t1,\n  t=\n      time*t1\n  ,\n  m1 =\n      fmod(t*4.,s2)\n  ,\n  m3 =\n      (fmod(t,abs(s2*2.-m1)+1.)-m1);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  float a=\n      64.*(1.-sqrt(fract(t/s1)/1.25))*.2\n  ,\n  nb = 4.*time*tempo*pow(2.,floor((m3+m2)/2.)/5.+6.5);\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 61, 162], [164, 164, 221, 221, 884]], "test": "untested"}
{"id": "msj3Dh", "name": "Fast Minmax Terrain Traversal", "author": "gelami", "description": "Fast traversal of a heightmap by pre-calculating the minmax mimaps of the texture. Also known as Quadtree Displacement Mapping (QDM)\n\nClick and drag to look around", "tags": ["terrain", "displacement", "lod", "heightmap", "quadtree", "minmax"], "likes": 21, "viewed": 433, "published": 3, "date": "1680890509", "time_retrieved": "2024-07-30T18:01:47.035399", "image_code": "\n// Minmax Terrain Traversal - gelami\n// https://www.shadertoy.com/view/msj3Dh\n\n/*\n * Fast traversal of a heightmap by pre-calculating the minmax mimaps of the texture.\n *   Also known as Quadtree Displacement Mapping (QDM)\n *\n * The mipmap is computed in a buffer in 8 passes,\n *   though it should've probably done in the cubemap instead.\n * There's still some artifacts on the traversal, as I've pretty much just hacked it.\n * Ideally you'd traverse using a step mask to increment the IDs,\n *   but I've just relied on using only on the position instead.\n * \n * Instructions:\n * - Click and drag to look around\n * - Defines in Common\n * - To change textures, change both iChannel0 in Image and Buffer A\n *     or change getHeightmap() in Common for procedural functions\n * \n * Buffer A computes the mipmaps in 8 passes\n * Buffer B stores the sky-view LUT\n * Image does the traversal\n *\n * This shader was inspired by:\n * Tesselation-Free Displacement Mapping\n * https://research.adobe.com/publication/tessellation-free-displacement-mapping-for-ray-tracing/\n *\n * Sky atmosphere taken from (thank u Jodie):\n * Cheap sky simulation - Jodie\n * https://www.shadertoy.com/view/ttSGzh\n *\n * I've just found out after finishing this that Fabrice already did this before, and\n * without pre-calculating the minmax mipmaps (using some magic)\n * fast heightfield rendering - FabriceNeyret2\n * https://www.shadertoy.com/view/wtdXDj\n *\n * TODO for next time:\n * - Random scale and height per tile\n * - Calculate mipmap in cubemap\n *\n */\n\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat intersectSlab( in vec3 ro, in vec3 ird, vec2 span ) \n{\n    if (ro.y > span.x && ro.y < span.y )\n        return MAX_DIST;\n\n    vec3 m = ird;\n    float n = ro.y * ird.y;\n    vec2 k = span * ird.y;\n    vec2 tN = -n + k;\n    float t = min(tN.x, tN.y);\n    if (t < 0.) t = MAX_DIST;\n    return t;\n}\n\nfloat intersectColumn( vec3 ro, vec3 ird, vec3 center, float size, out vec3 normal ) \n{\n    ro -= center;\n    vec3 n = ird * ro;\n    vec3 k = abs(ird) * vec3(size, 1, size);\n    vec3 t1 = -n + k;\n    float t = min( min( t1.x, t1.y ), t1.z );\n    normal = -sign(ird) * step(t1, t1.yzx) * step(t1, t1.zxy);\n    return t;\n}\n\nfloat intersectBox( vec3 ro, vec3 ird, vec3 center, vec3 size, out vec3 normal ) \n{\n    ro -= center;\n    vec3 n = ird * ro;\n    vec3 k = abs(ird) * size;\n    vec3 t1 = -n + k;\n    float t = min( min( t1.x, t1.y ), t1.z );\n    normal = -sign(ird) * step(t1, t1.yzx) * step(t1, t1.zxy);\n    return t;\n}\n\nfloat intersectObject( vec3 ro, vec3 rd, vec3 center, float size, out vec3 n )\n{\n    vec2 uv = center.xz;\n    vec2 res = iChannelResolution[1].xy;\n    \n    float s = 1.;\n    vec2 p00 = uv + vec2(-.5, -.5) * size * s;\n    vec2 p10 = uv + vec2( .5, -.5) * size * s;\n    vec2 p01 = uv + vec2(-.5,  .5) * size * s;\n    vec2 p11 = uv + vec2( .5,  .5) * size * s;\n    \n    float lod = float(MIN_LOD);\n    float t00 = getHeightmap(iChannel0, p00, lod) * SCALE;\n    float t10 = getHeightmap(iChannel0, p10, lod) * SCALE;\n    float t01 = getHeightmap(iChannel0, p01, lod) * SCALE;\n    float t11 = getHeightmap(iChannel0, p11, lod) * SCALE;\n            \n    vec3 v0 = vec3(p00, t00).xzy;\n    vec3 v1 = vec3(p10, t10).xzy;\n    vec3 v2 = vec3(p01, t01).xzy;\n    vec3 v3 = vec3(p11, t11).xzy;\n\n    vec3 n0, n1;\n    vec3 tri0 = triIntersect(ro, rd, v0, v2, v1, n0);\n    vec3 tri1 = triIntersect(ro, rd, v1, v2, v3, n1);\n\n    float t = MAX_DIST;\n    \n    if (tri0.x < t)\n    {\n        t = tri0.x;\n        n = n0;\n    }\n    if (tri1.x < t)\n    {\n        t = tri1.x;\n        n = n1;\n    }\n    \n    return t;\n}\n\nstruct HitInfo {\n    vec3 p;\n    vec3 n;\n    float t;\n    float size;\n    bool hit;\n    int lod;\n    int i;\n};\n\nHitInfo trace(vec3 ro, vec3 rd, int startLod)\n{\n    HitInfo h;\n\n    vec3 srd = sign(rd);\n    \n    if (abs(rd.x) < EPS) rd.x = srd.x * EPS;\n    if (abs(rd.y) < EPS) rd.y = srd.y * EPS;\n    if (abs(rd.z) < EPS) rd.z = srd.z * EPS;\n    \n    vec3 ird = 1. / rd;\n    \n    vec3 p = ro;\n    float scale = SCALE;\n    \n    vec3 n;\n    vec3 bn;\n    bool hit = false;\n    int lod = startLod;\n    float size = 1. / getLodSize(lod);\n    \n    int minLod = MIN_LOD;\n    float t = 0.;\n    //float mh = getTextureLodNearest(iChannel1, iChannelResolution[0].xy, vec2(.5), LOD_LEVELS-1).y * scale;\n    float mh = scale;\n    \n    vec2 id = floor(p.xz/size);\n    int i = 0;\n    \n    if (iFrame < LOD_LEVELS)\n    {\n        h.t = -ro.y * ird.y;\n        h.t = h.t < 0.0 ? MAX_DIST : h.t;\n        h.p = ro + rd * t;\n        h.n = vec3(0, 1, 0);\n        h.size = 1. / getLodSize(MIN_LOD);\n        h.hit = ird.y > 0.0 ? false : true;\n        h.lod = MIN_LOD;\n        h.i = i;\n        \n        return h;\n    }\n    for (; i < MAX_STEPS; i++)\n    {\n        vec2 h = getTextureLodNearest(iChannel1, iChannelResolution[1].xy, (id + .5) * size, lod).xy * scale;\n        vec3 center = vec3((id + .5) * size, .5).xzy;\n        \n        if (p.y >= h.x && p.y <= h.y)\n        {\n            if (lod <= minLod)\n            {\n            #ifdef INTERSECT_OBJECT\n                vec3 nn;\n                float nt = intersectObject(p, rd, center, size, nn);\n                \n                if (nt < MAX_DIST)\n                {\n                    t += nt;\n                    p += rd * nt;\n                    n = nn;\n                    hit = true;\n                    break;\n                }\n            #else\n                vec3 center = vec3((id + .5) * size, (h.x + h.y) * 0.5).xzy;\n                //float nt = intersectBox(p, rd, center, vec3(size * 0.5, h.y - h.x, size * 0.5), bn);\n\n                n = bn;\n                hit = true;\n                break;\n            #endif\n            } else {\n                lod--;\n                size *= .5;\n                id = floor(p.xz/size);\n                continue;\n            }\n        }\n        \n        float sd = intersectSlab(p, ird, h);\n\n        float cd = intersectColumn(p, ird, center, size * .5, bn);\n\n        if (sd <= cd)\n        {\n            if (lod <= minLod)\n            {\n            #ifdef INTERSECT_OBJECT\n                vec3 nn;\n                float nt = intersectObject(p, rd, center, size, nn);\n                \n                if (nt < MAX_DIST)\n                {\n                    t += nt;\n                    p += rd * nt;\n                    n = nn;\n                    hit = true;\n                    break;\n                }\n            #else\n                t += sd;\n                p += rd * sd;\n                n = -vec3(0, 1, 0) * srd.y;\n                hit = true;\n                break;\n            #endif\n            } else {\n                t += sd - EPS;\n                p += rd * (sd - EPS);\n                lod--;\n                size *= .5;\n                id = floor(p.xz/size);\n                continue;\n            }\n        }\n        \n        t += cd;\n        #ifdef INTERSECT_OBJECT\n        p += rd * (cd + EPS);\n        #else\n        p += rd * cd - bn * EPS;\n        #endif\n        \n        //p.xz = fract(p.xz);\n        vec2 pid = id;\n        id = floor(p.xz/size);\n        n = bn;\n        \n        #ifdef DYNAMIC_LOD\n        minLod = clamp(int(ceil(log(t))), 0, LOD_LEVELS);\n        #endif\n        \n        #if 1\n        if (floor(pid/2.) != floor(id/2.) && lod < LOD_LEVELS-1)\n        {\n            lod++;\n            size *= 2.;\n            id = floor(p.xz/size);\n        }\n        #endif\n        \n        //if (any(lessThan(p, vec3(0))) || any(greaterThanEqual(p, vec3(1)))) break;\n        \n        if (p.y > mh && rd.y > 0. || p.y < 0. && rd.y < 0.) break;\n    }\n    \n    h.p = p;\n    h.n = n;\n    h.t = t;\n    h.size = size;\n    h.hit = hit;\n    h.lod = lod;\n    h.i = i;\n    \n    return h;\n}\n\nvec3 getSkyTexture(vec3 rd)\n{\n    float x = atan(rd.z, rd.x) / TAU;\n    float y = -asin(rd.y);\n    y = 0.5 + 0.5 * sign(y) * sqrt(abs(y) / (PI * 0.5));\n    //y = asin(rd.y) / TAU;\n    vec3 col = texture(iChannel2, vec2(x, y) * (iResolution.xy - 1.) / iResolution.xy + 0.5 / iResolution.xy).rgb;\n    \n    vec3 nightCol = vec3(0.004,0.012,0.03) * 0.3;\n    \n    return max(col, nightCol);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    float px = 1. / iResolution.y;\n    \n    vec3 ro = vec3(0, -.3, 0);\n    vec3 lo = vec3(0, 0, 1);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax, ay;\n    \n    if (any(lessThan(iMouse.xy, vec2(2))))\n    {\n        ax = PI * 0.05;\n        ay = PI * 0.05;\n    } else {\n        ax = -m.x * TAU;\n        ay = PI * 0.5 + m.y * PI * 0.75;\n    }\n    \n    lo.yz *= rot2D(-ay);\n    lo.xz *= rot2D(ax);\n    lo += ro;\n    \n    vec3 of = vec3(0.2, 0, 0.6) * iTime;\n    \n    ro += of;\n    lo += of;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    vec3 ird = 1. / rd;\n    vec3 srd = sign(rd);\n    \n    vec3 p = ro + .5;\n    p.xz = fract(p.xz);\n    \n    vec3 n = vec3(0);\n    HitInfo tr = trace(p, rd, LOD_LEVELS-1);\n    \n    //fragColor = vec4(tr.n, 1);\n    //return;\n    \n    int lod = tr.lod;\n    float size = tr.size;\n    bool hit = tr.hit;\n    float t = tr.hit ? tr.t : MAX_DIST;\n    \n    p = ro + 0.5 + rd * t;\n    n = tr.n;\n\n    p.xz = fract(p.xz);\n    vec2 id = floor(p.xz/size);\n    \n    vec3 col = vec3(0);\n    \n#ifdef INTERSECT_OBJECT\n\n#ifdef SMOOTH_NORMALS\n    vec2 tuv = p.xz + 0.5 * size;\n    float e = 1.0 / getLodSize(lod);\n    \n    #if 0\n    float hx0 = getHeightmap(iChannel0, tuv - vec2(e, 0), float(lod)) * SCALE;\n    float hy0 = getHeightmap(iChannel0, tuv - vec2(0, e), float(lod)) * SCALE;\n    float hx1 = getHeightmap(iChannel0, tuv + vec2(e, 0), float(lod)) * SCALE;\n    float hy1 = getHeightmap(iChannel0, tuv + vec2(0, e), float(lod)) * SCALE;\n    #else\n    \n    float hx0 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv - vec2(e, 0), lod).y * SCALE;\n    float hy0 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv - vec2(0, e), lod).y * SCALE;\n    float hx1 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv + vec2(e, 0), lod).y * SCALE;\n    float hy1 = getTextureLod0(iChannel1, iChannelResolution[1].xy, tuv + vec2(0, e), lod).y * SCALE;\n    \n    #endif\n    n = normalize(vec3(hx0 - hx1, e, hy0 - hy1));\n#endif\n    \n    vec3 alb = textureLod(iChannel0, p.xz, float(lod)).rgb;\n#else\n    vec3 alb = textureLod(iChannel0, (id + .5) * size, float(lod)).rgb;\n    \n#endif\n    \n    vec3 amb = getSkyTexture(vec3(0, 1, 0));\n    \n    vec3 ldir = normalize(texelFetch(iChannel1, ivec2(iResolution.xy-1.), 0).rgb);\n    vec3 lldir = normalize(vec3(ldir.xz, max(ldir.y, 0.0)).yzx);\n    vec3 lcol = getSkyTexture(lldir);\n    float la = 1.-pow(1.-ldir.y, 8.);\n    \n    HitInfo sh;\n    if (ldir.y > 0.0)\n    {\n        sh = trace(p + ldir * EPS, ldir, MIN_LOD);\n        \n        float dif = max(dot(n, ldir), 0.0);\n        float sha = float(!sh.hit) * la;\n        dif = dif * sha;\n        \n        col += alb * max(dif * 0.5, 0.02);\n\n        col += alb * sha * lcol * 0.8;\n\n        col += alb * amb * max(dot(reflect(ldir, n), n), 0.0) * 0.5;\n        col += alb * sha * pow(max(dot(normalize(-rd + ldir), n), 0.0), 200.0) * 0.5;\n    }\n    \n    col += alb * dot(abs(n), vec3(0.2, 0.6, 0.2)) * 0.08;\n    col += amb * 0.3;\n    \n#ifndef INTERSECT_OBJECT\n    col *= dot(abs(n), vec3(.85, 1, .7));\n#endif\n    \n    vec3 ard = vec3(rd.xz, abs(rd.y)).xzy;\n    vec3 sky = getSkyTexture(normalize(ard * vec3(1, 0.1, 1)));\n\n#ifdef FOG\n    \n    vec3 fogCol = sky;\n    \n    float a = .02;\n    float b = 4.;\n    \n    float fog = (a/b) * exp(-ro.y*b) * (1.0-exp( -t*rd.y*b ))/rd.y;\n    \n    col = mix(fogCol, col, saturate(1.-fog));\n#endif\n\n    //col = vec3(p.xz, 0);\n    \n    vec3 bg = vec3(0.678,0.859,0.922);\n    \n    if (!hit)\n    {\n        col = getSkyTexture(ard);\n\n        if (ldir.y < 0.0)\n        {\n            vec3 stars;\n\n            vec2 spc = vec2(atan(rd.z, rd.x) / PI, -asin(rd.y) / PI) * 200.;\n            vec2 sid = floor(spc);\n            vec4 h = hash42(sid);\n            vec2 suv = fract(spc) - hash22(sid) - (hash22(sid+iTime) - 0.5) * 0.03;\n            float str = pow(h.x, 3.);\n\n            stars += smoothstep(0.2, 1.0, str * 0.02 / length(suv));\n            stars *= pow(-ldir.y, .33);\n            stars *= mix(palette(h.y), vec3(1), 0.3);\n            \n            col += stars;\n        }\n    }\n    \n    float cosT = dot(rd, ldir);\n    float sunT = acos(cosT);\n    float sunR = 0.526 * TAU / 180.;\n    float sunMask = smoothstep(0.0, px * 2.0, sunR - sunT);\n    sunMask *= pow(1.-(sunT / sunR), 1.0);\n    sunMask *= la;\n\n    col += vec3(1, .8, .4) * 200. * lcol * saturate(sunMask);\n    //col = mix(col, vec3(1, .8, .4) * 200. * lcol, saturate(sunMask));\n    \n    #ifdef SHOW_STEPS\n    #ifdef SHOW_SHADOW_STEPS\n    float s = float(sh.i) / float(MAX_STEPS-1);\n    #else\n    float s = float(tr.i) / float(MAX_STEPS-1);\n    #endif\n    \n    col = pow(turbo(s), vec3(2.2));\n    \n    if (fragCoord.y < 11.)\n        col = pow(turbo(fragCoord.x / iResolution.x), vec3(2.2));\n    #endif\n    \n    #ifdef VIEW_LODS\n    \n    vec2 st = fragCoord.xy / iResolution.y;\n    int i = int(iTime)%(LOD_LEVELS+1);\n    if (i == 0)\n    {\n        col = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    } else {\n        col = getTextureLodNearest(iChannel1, iChannelResolution[0].xy, st, i).rgb;\n        \n        if (st.x > 1. || st.y > 1.)\n            col = vec3(0);\n    }\n    #endif\n\n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    //col = 1.0-exp(-col*2.0);\n    fragColor = vec4(pow(col, vec3(1./2.2)), 1);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nconst vec2 off[9] = vec2[9](\n    vec2(-1, -1), vec2(-1,  1), \n\tvec2( 1, -1), vec2( 1,  1), \n\tvec2( 1,  0), vec2( 0, -1), \n\tvec2( 0,  1), vec2(-1,  0), vec2(0, 0)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (all(equal(ivec2(fragCoord-.5), ivec2(iResolution.xy-1.))))\n    {\n        vec3 ldir = normalize(vec3(-0.6, 1, 0.3));\n    \n        ldir.yz *= rot2D(-iTime * PI * 0.05 + PI * 0.25);\n        //ldir.yz *= rot2D(-42.8 * PI * 0.05 + PI * 0.25);\n        \n        \n        ldir = normalize(ldir);\n        fragColor = vec4(ldir, 1);\n        return;\n    }\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    int lod = 0;\n    for(; lod <= LOD_LEVELS; lod++)\n    {\n        if (fragCoord.x < float(LOD_TEX_END[lod]))\n            break;\n    }\n    \n    float offset = float(LOD_TEX_END[lod]);\n    float size = getLodSize(lod);\n    if (fragCoord.y < size && lod <= LOD_LEVELS)\n    {\n        uv = fract((fragCoord - vec2(LOD_TEX_START[lod], 0)) / size);\n        \n        if (lod > 0)\n        {\n            float size2 = getLodSize(lod-1);\n            vec2 px = uv * size2 + .5;\n            \n            float sizen1 = getLodSize(lod-1);\n            vec2 res = iChannelResolution[1].xy;\n            \n            vec4 t00 = getTextureLodNearest(iChannel1, res, (px - vec2(0, 0)) / size2, lod-1);\n            vec4 t10 = getTextureLodNearest(iChannel1, res, (px - vec2(1, 0)) / size2, lod-1);\n            vec4 t01 = getTextureLodNearest(iChannel1, res, (px - vec2(0, 1)) / size2, lod-1);\n            vec4 t11 = getTextureLodNearest(iChannel1, res, (px - vec2(1, 1)) / size2, lod-1);\n            \n            float minH = min(min(t00.r, t10.r), min(t01.r, t11.r));\n            float maxH = max(max(t00.g, t10.g), max(t01.g, t11.g));\n            \n            //fragColor = max(max(t00, t10), max(t01, t11));\n            //fragColor.a = 1.;\n            \n            fragColor = vec4(minH, maxH, 0, 1);\n            \n            //fragColor = vec4(px / size2,0,1);\n            //fragColor = texture(iChannel0, uv).rrrr;\n        } else {\n            \n            vec2 res = iChannelResolution[0].xy;\n            \n            uv = fract((floor(fragCoord) - vec2(LOD_TEX_START[lod], 0)) / size) + .5 / res;\n        \n            float minH = 1e3;\n            float maxH = -1e3;\n            \n            int d = 4;\n            \n            for (int x = -d; x <= d; x++)\n            {\n                for (int y = -d; y <= d; y++)\n                {\n                    float t = getHeightmap(iChannel0, uv + vec2(x, y) / res);\n                    \n                    minH = min(minH, t);\n                    maxH = max(maxH, t);\n                }\n            }\n            \n            fragColor = vec4(minH, maxH, 0, 1);\n            //fragColor = texture(iChannel0, uv).rrrr;\n        }\n    } else {\n        fragColor = vec4(vec3(0), 1);\n    }\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Distance fog\n#define FOG\n\n// Intersect object (currently only triangles)\n// Comment to enable columns only\n#define INTERSECT_OBJECT\n\n// Enable lod distance (doesn't do much for perf anyways)\n//#define DYNAMIC_LOD\n\n// Show the number of steps taken to traverse\n//#define SHOW_STEPS\n//#define SHOW_SHADOW_STEPS\n\n//#define SMOOTH_NORMALS\n\n// \n//#define VIEW_LODS\n\n#define MAX_STEPS 256\n#define SCALE 0.15\n\n#define MIN_LOD 0\n//#define MIN_LOD (int(iTime / 2.) % LOD_LEVELS)\n#define LOD_LEVELS 8\n\n\n#define EPS 2e-5\n#define PI (acos(-1.))\n#define TAU (2.*PI)\n#define MAX_DIST 1e3\n\nconst int LOD_TEX_START[LOD_LEVELS+1] = int[](0, 256, 384, 448, 480, 496, 504, 508, 510);\nconst int LOD_TEX_END[LOD_LEVELS+1] = int[](256, 384, 448, 480, 496, 504, 508, 510, 511);\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nfloat luminance(vec3 c)\n{\n    return dot(c, vec3(0.2126, 0.7152, 0.0722));\n}\n\nfloat getLodSize(int lod)\n{\n    return float(1<<(LOD_LEVELS-lod));\n}\n\n// Heightmap\nfloat getHeightmap(sampler2D tex, vec2 uv, float lod)\n{\n    // Using textures\n    return pow(luminance(textureLod(tex, uv, lod+2.0).rgb), 1.);\n    //return textureLod(tex, uv, lod).r;\n    \n    // Procedural\n    //return saturate((sin(uv.x*TAU) * cos(uv.y*TAU)) * 0.5 + 0.5);\n}\n\nfloat getHeightmap(sampler2D tex, vec2 uv)\n{\n    return getHeightmap(tex, uv, 0.);\n}\n\nvec4 getTextureLod0(sampler2D tex, vec2 size, vec2 uv, int lod)\n{\n    vec2 tex_size = vec2(getLodSize(0));\n    vec2 new_uv = fract(uv) * tex_size - 0.5;\n    \n    return textureLod(tex, new_uv / size, 0.0);\n}\n\nvec4 getTextureLod(sampler2D tex, vec2 size, vec2 uv, int lod)\n{\n    vec2 tex_size = vec2(getLodSize(lod));\n    vec2 new_uv = fract(uv) * tex_size + vec2(LOD_TEX_START[lod], 0);\n\n    return texture(tex, new_uv / size);\n}\n\nvec4 getTextureLodNearest(sampler2D tex, vec2 size, vec2 uv, int lod)\n{\n    vec2 tex_size = vec2(getLodSize(lod));\n    vec2 new_uv = fract(uv) * tex_size + vec2(LOD_TEX_START[lod], 0);\n\n    return texelFetch(tex, ivec2(new_uv), 0);\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, .95, .9) * t + vec3(0, .3, .5)));\n}\n\nvec3 paletteR(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1) * t + vec3(0, .3, .5)));\n}\n\n// Turbo Colormap\n// https://www.shadertoy.com/view/3lBXR3\nvec3 turbo(float t) {\n\n    const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n    const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n    const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n    const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n    const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n    const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n    const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n// https://iquilezles.org/articles/intersectors/\n\n// Ray-Sphere Intersection\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Ray-Box Intersection\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(MAX_DIST); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n// Ray-Tri Intersection\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, out vec3 normal )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3 n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    \n    if (d > 0.0) return vec3(MAX_DIST, 0, 0);\n    \n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    \n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) return vec3(MAX_DIST, 0, 0);\n    \n    normal = normalize(n);\n    return vec3( t, u, v );\n}\n\n// cheap sky simulation - Jodie\n// https://www.shadertoy.com/view/ttSGzh\n\n#define atmosphereHeight 8228.\n#define earthRadius 6371000.\n#define mieHeight 1200\n//http://www.vendian.org/mncharity/dir3/starcolor/\n#define sunColor pow(vec3(0xff,0xf5,0xf2)/255.,vec3(2.2))\n#define ozoneHeight 30000.\n// http://skyrenderer.blogspot.com/2012/10/ozone-absorption.html\n// https://www.spectroscopyeurope.com/article/new-broadband-high-resolution-ozone-absorption-cross-sections\n#define ozoneCoefficient (vec3(3.426, 8.298, .356) * 6e-5 / 100.)\n#define mieCoefficient 3e-6 // adjust for foggier look\n#define earthAlbedo pow(vec3(0x99,0x92,0x80)/255.,vec3(2.2))\n\n// ( Riley, Ebert, Kraus )\n//#define rayleighCoefficient vec3(5.8e-6  , 1.35e-5 , 3.31e-5 )\n// ( Bucholtz )\n//#define rayleighCoefficient vec3(4.847e-6, 1.149e-5, 2.87e-5 ) \n// ( Thalman, Zarzana, Tolbert, Volkamer )\n//#define rayleighCoefficient vec3(5.358e-6, 1.253e-5, 3.062e-5)\n// ( Penndorf )\n#define rayleighCoefficient vec3(5.178e-6, 1.226e-5, 3.06e-5 )\n\n#define up vec3(0,1,0)\n\n//b = dotup\nvec3 getSkyThicknesses(float b){\n    const vec4 sr = earthRadius + vec4(\n        atmosphereHeight,\n        mieHeight,\n        ozoneHeight,\n        ozoneHeight + atmosphereHeight\n    );\n    b*=earthRadius;\n    const float r2 = earthRadius * earthRadius;\n    vec4 z = sqrt( sr * sr + (b * b - r2) );\n    return vec3(b+z.xy, z.w-z.z);\n}\n\n// Improved Rayleigh phase for single scattering\n// https://old.cescg.org/CESCG-2009/papers/PragueCUNI-Elek-Oskar09.pdf\n// note: integral from -1 to 1 of function in the paper is 2.24\n#define phaseRayleigh(a) (( .4 * (a) + 1.12 )/2.24)\n//#define phaseRayleigh(a) ((3./8.)*(1.+(a)*(a)))\n\n// (Henyey Greenstein)\n// https://www.astro.umd.edu/~jph/HG_note.pdf\nfloat phaseg(float x,float g){\n    const float  b = 1./2.;\n    float a = inversesqrt(1.+g*g-2.*g*x);\n\treturn b*(1.-g*g)*a*a*a;\n}\nfloat phaseMie(const float VdotL, const float depth){\n    //curve fit with turingbot\n    float g = atan(sin(pow(0.7,depth*mieCoefficient)));\n    return phaseg(VdotL, g);\n}\n\n// https://iquilezles.org/articles/sphereshadow\nfloat sphSoftShadow(vec3 position,vec3 L){\n    const float k = 5.;\n    //vec4 sph = vec4(-up*earthRadius,earthRadius);\n    vec3 oc = position + up * earthRadius;\n    float b = dot( oc, L );\n    float c = dot( oc, oc ) - earthRadius*earthRadius;\n    float h = b*b - c;\n    \n    float d = -earthRadius + sqrt( max(0.0,earthRadius*earthRadius-h));\n    float t = -b - sqrt( max(0.0,h) );\n    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t );\n}\n\nvec3 getSky(const vec3 V, const vec3 L) {\n\n    const mat3 coeffs = mat3(\n        rayleighCoefficient      ,\n        vec3(mieCoefficient*1.11), // mie absorbs (Bruneton)\n        ozoneCoefficient\n    );\n    \n    float VdotUp = -V.y;\n    float LdotUp = -L.y;\n    \n    vec3 thicknesses = getSkyThicknesses(VdotUp);\n    float VdotL = dot(V, L);\n\n    vec3 rayleighScatter =(thicknesses.x * phaseRayleigh(VdotL))          * rayleighCoefficient;\n    float     mieScatter = thicknesses.y * phaseMie(VdotL, thicknesses.y) *      mieCoefficient;\n\n\tvec3 scattering = rayleighScatter + mieScatter;\n    \n    vec3 sunCoeff = coeffs * getSkyThicknesses(LdotUp);\n    vec3 viewCoeff = coeffs * thicknesses;\n    vec3 absorption = (exp(-viewCoeff)-exp(-sunCoeff)) / (sunCoeff - viewCoeff);\n    \n    //  integral of x from 0 to 1\n    //  exp( -a*x - b*(1-x) )\n    //\n    //  e - e\n    // ---------\n    //  (a - b) \n    \n    float earthShadow = sphSoftShadow(thicknesses.x*V,L);\n    \n    if(dot(V,up)<0.)return earthAlbedo * sunColor * exp(-sunCoeff);\n\n    return sunColor * scattering * absorption * earthShadow;\n}\n\nvec3 sphere(vec3 rpos, vec3 rd){\n\n    vec3 oc = -rpos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - 1.; \n\t\n\tfloat h = b*b - c; \n\n    float t = b - sqrt(h);\n\tvec3 n = oc-rd*t;\n    if(n.z<0.||h<0.)return rd.xzy;\n    return n;\n\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ldir = texelFetch(iChannel0, ivec2(iResolution.xy-1.), 0).rgb;\n    \n    float y = uv.y;\n    if (y < 0.5) {\n\t\ty = 1.0 - 2.0 * y;\n\t\ty = -y * y;\n\t} else {\n\t\ty = y * 2.0 - 1.0;\n\t\ty = y * y;\n\t}\n    \n    float theta = uv.x * TAU;\n    float phi = -y * 0.5 * PI;\n    \n    vec3 rd = vec3(cos(theta) * cos(phi), sin(phi), sin(theta) * cos(phi));\n\n    fragColor = vec4(getSky(rd, ldir), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msj3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1530, 1530, 1570, 1570, 1716], [1718, 1718, 1778, 1778, 2017], [2019, 2019, 2106, 2106, 2339], [2341, 2341, 2424, 2424, 2642], [2644, 2644, 2724, 2724, 3736], [3850, 3850, 3897, 3897, 7817], [7819, 7819, 7848, 7848, 8206], [8208, 8208, 8265, 8265, 13726]], "test": "untested"}
{"id": "mdVXzw", "name": "Fork: Scaled Branchless Voxel rc", "author": "avokado", "description": "Fork of https://www.shadertoy.com/view/4dX3zl handling scaling of voxels", "tags": ["3d", "raymarching", "raycasting", "voxel", "dda"], "likes": 4, "viewed": 879, "published": 3, "date": "1680889691", "time_retrieved": "2024-07-30T18:01:47.787389", "image_code": "//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\nconst int MAX_RAY_STEPS = 258;\nconst float gridScale = 4.; // Change this to the desired scale\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n\treturn d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\trayDir.xz = rotate2d(rayDir.xz, iTime);\n    rayPos /= gridScale;\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos)) continue;\n\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\n        //All components of mask are false except for the corresponding largest component\n        //of sideDist, which is the axis along which the ray should be incremented.\n        sideDist += vec3(mask) * deltaDist;\n        mapPos += ivec3(vec3(mask)) * rayStep;\n\n\t}\n\t\n\tvec3 color;\n\tif (mask.x) {\n\t\tcolor = vec3(0.5);\n\t}\n\tif (mask.y) {\n\t\tcolor = vec3(1.0);\n\t}\n\tif (mask.z) {\n\t\tcolor = vec3(0.75);\n\t}\n\tfragColor.rgb = color;\n\t//fragColor.rgb = vec3(0.1 * noiseDeriv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 259, 259, 283], [286, 286, 317, 317, 413], [416, 416, 440, 440, 571], [573, 573, 605, 605, 716], [718, 718, 775, 775, 2130]], "test": "untested"}
{"id": "mdVSRD", "name": "Backrooms Level 4242", "author": "cedricl", "description": "Creepy :D\nInfinite resource : https://twitter.com/SpaceLiminalBot", "tags": ["backrooms"], "likes": 27, "viewed": 623, "published": 3, "date": "1680886400", "time_retrieved": "2024-07-30T18:01:48.564312", "image_code": "vec2 GetUV(vec2 uv) \n{ \n    return vec2(uv.x + abs(sin(113.*iTime))*.0005/(1.-uv.y), floor(uv.y*ScanH) * ScanH_Inv); \n}\n\nfloat Rnd(float In) { return fract(sin(In * 37549.54368976) + sin(In * 375.4567)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x = (uv.x-0.5) / cos(Roundness*abs(uv.y - .5)) + 0.5;\n    uv.y = (uv.y-0.5) / cos(Roundness*abs(uv.x - .5)) + 0.5;\n    uv.x += HNOISE_AMOUNT * Rnd(iTime + 0.1*uv.y) * abs(uv.x - .5);\n    \n    fragColor = texture(iChannel0, GetUV(uv));\n    \n    float band = smoothstep(.0, .05, fract(uv.y * .1 + .2*iTime + .1*Rnd(iTime)));    \n    fragColor.xyz *= mix(vec3(1., .8, .75), vec3(1.), band);\n   \n    float band2 = 1. - smoothstep(.0, .01, fract(uv.y * .09 + .1*iTime + .1*Rnd(iTime)));\n    fragColor.xyz += .5 * band2 * vec3(.4, .5, 1.3) * rand2(GetUV(vec2(0.01*uv.x, iTime + floor(uv.y*ScanH))));\n    \n    float band3 = 1. - smoothstep(.0, .2, fract(uv.y * .23 + .23*iTime + .4*Rnd(iTime)));\n    fragColor.xyz += .6 * band3 * vec3(1., .5, 1.2) * smoothstep(.95, 1., rand2(GetUV(vec2(.01*uv.x, iTime + floor(uv.y*ScanH))))\n                                                        - .09*rand2(GetUV(vec2(.5*uv.x, iTime + floor(uv.y*ScanH))))       \n                                                    );\n\n    fragColor += CHROMA_AMOUNT * vec4(1., 0., 0.5, 0.) * texture(iChannel0, GetUV(uv + vec2(CHROMA_DIST, 0.)));\n    fragColor += CHROMA_AMOUNT * vec4(0., 1., 0.5, 0.) * texture(iChannel0, GetUV(uv - vec2(CHROMA_DIST, 0.)));\n    fragColor /= 1. + 2.*CHROMA_AMOUNT;\n\n    fragColor += GHOST_AMOUNT * (0.3-texture(iChannel0, GetUV(uv - vec2(GHOST_DIST, 0.))));\n    \n    vec4 Coeff = vec4(2. - (fragColor.x + fragColor.y + fragColor.z) * 0.33);\n    Coeff *= mix(pow(abs(sin(uv.y*ScanH*3.14159)), 2.6), 1., ScanDep);\n    vec4 Mask = vec4(0.);\n    float P = (uv.x*GridW + floor(uv.y * GridH)) * 3.14159;\n    Mask.x = mix(pow(max(0., sin(P)), GridPow), 1.15*Gain, GridDep);\n    Mask.y = mix(pow(max(0., sin(P+2.2)), GridPow), 1.25*Gain, GridDep);\n    Mask.z = mix(pow(max(0., sin(P+4.4)), GridPow), 1.25*Gain, GridDep);\n    Coeff *= Mask;\n    Coeff *= pow(1. - length(uv-vec2(0.5)), Vignetting);\n    \n    fragColor *= mix(vec4(1.), Coeff, GLOBALMIX);\n    fragColor *= smoothstep(0.0, BorderSharpness, 0.5 - abs(uv.x - 0.5));\n    fragColor *= smoothstep(0.0, BorderSharpness, 0.5 - abs(uv.y - 0.5));\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ScanH 240.\n#define ScanH_Inv (1./ScanH)\n#define ScanDep 0.7\n#define GridW 460.\n#define GridH 280.\n#define GridPow 2.1\n#define GridDep 0.8\n#define Roundness 0.6\n#define Gain 1.55\n#define Vignetting 1.1\n#define BorderSharpness .01\n\n#define BLUR_MIX 0.8\n#define BLUR_RADIUS 40.\n#define BLUR_CURVE_POW 0.45\n#define BLUR_SAMPLES 8.\n\n#define PERSISTENCE 0.2\n\n#define CHROMA_DIST 0.0015\n#define CHROMA_AMOUNT .7\n\n#define GHOST_AMOUNT 0.2\n#define GHOST_DIST 0.004\n\n#define HNOISE_AMOUNT 0.006\n\n#define GLOBALMIX 0.9\n\nfloat rand2(vec2 co) { return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); }\n", "buffer_a_code": "vec4 blurH(vec2 uv, float r, float sampleNum )\n{\n    vec4 col = vec4(0);\n    vec2 unit = 1.0 / iResolution.xy;\n\n    float sampleStep = r / sampleNum;\n\n    float count = 0.0;\n\n    for(float x = -r; x < r; x += sampleStep)\n    {\n        float weight = pow(r - abs(x), BLUR_CURVE_POW);\n        col += texture(iChannel0, uv + vec2(x * unit.x, uv.y * unit.y) ) * weight;\n        count += weight;\n    }\n\n    return col / count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = mix(blurH(uv, BLUR_RADIUS, BLUR_SAMPLES ), texture(iChannel0, uv), BLUR_MIX);\n    fragColor = mix(fragColor, texture(iChannel1, uv), PERSISTENCE);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 blurH(vec2 uv, float r, float sampleNum )\n{\n    vec4 col = vec4(0);\n    vec2 unit = 1.0 / iResolution.xy;\n\n    float sampleStep = r / sampleNum;\n\n    float count = 0.0;\n\n    for(float x = -r; x < r; x += sampleStep)\n    {\n        float weight = pow(r - abs(x), BLUR_CURVE_POW);\n        col += texture(iChannel0, uv + vec2(uv.x * unit.x, x * unit.y) ) * weight;\n        count += weight;\n    }\n\n    return col / count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = mix(blurH(uv, BLUR_RADIUS, BLUR_SAMPLES ), texture(iChannel0, uv), BLUR_MIX);\n    fragColor = mix(fragColor, texture(iChannel1, uv), PERSISTENCE);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define FAR 400.\n#define INVFOV .35\n#define REP 3.5\n#define REP2 (REP*.5)\n#define K 3.\n\nfloat noise(vec2 co)\n{\n\tvec2 P = floor(co);\n\tvec2 t = fract(co);\n\tfloat l0 = mix(rand2(P-vec2(1,0)), rand2(P), smoothstep(0.,1.,t.x));\n\tfloat l1 = mix(rand2(P-vec2(1,1)), rand2(P-vec2(0,1)), smoothstep(0.,1.,t.x));\n\treturn mix(l1, l0, smoothstep(0.,1.,t.y));\n}\n\nfloat map(vec3 p)\n{\n    float cellrnd = noise(floor(p.xz / REP) - REP2);\n    p.xz = mod(p.xz, REP) - REP2;\n    \n    float cl = abs(p.y - .5);\n    float fl = abs(p.y + .5);\n    vec3 q = abs(p * vec3(1., .1, 1.)) - .55 * cellrnd;\n    float bx = length(max(q, .0)) + min(max(q.x, max(q.y, q.z)), .0);\n    return min(bx, min(cl, fl));\n}\n\nvec4 trace(vec3 o, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 400; i++)\n    {\n        float d = map(o);\n        if(abs(d) < 0.001)\t\n            return vec4(o, t);\n        o += rd * d;\n        t += d;\n    }\n    return vec4(o, FAR);\n}\n\nvec3 N(vec3 p)\n{\n    const float e = 0.02;\n    return normalize(vec3(\n        map(vec3(p.x + e, p.y, p.z)) - map(vec3(p.x - e, p.y, p.z)),\n        map(vec3(p.x, p.y + e, p.z)) - map(vec3(p.x, p.y - e, p.z)),\n        map(vec3(p.x, p.y, p.z  + e)) - map(vec3(p.x, p.y, p.z - e))\n    ));\n}\n\nfloat turb(float t)\n{\n    return sin(1.7*t) + .39*sin(2.9*t) + .19*sin(7.9*t) + .071*sin(17.9*t);\n}\n\nfloat T(vec2 p, vec2 uv, float XMask)\n{\n    float trez = 240.;\n    float r = texture(iChannel0, (floor(.66*(uv)*trez)+p)/trez).r;\n    r *= step(.45, uv.y) * step(.46, 1.-uv.y);\n    r *= step(-1. + XMask, uv.x) * step(2. - XMask -.1, 1.-uv.x);\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord/iResolution.xy) - 0.5) * 2.;\n    uv.y *= iResolution.y/iResolution.x;\n\n    float STime = iTime * 0.1;\n    \n    vec3 o = vec3(.1*turb(STime*3.), 0. + .05*abs(sin(20.*STime)), STime*-8. + 1.6*turb(STime*1.07));\n    float LR = -.5+smoothstep(.35, .65, .5+.5*sin(STime*5.2)*sin(STime*1.23));\n    vec3 front = normalize(vec3((2.15 + .6*turb(STime*2.)) * LR, 0.15 * turb(STime*4.),-1.));\n    vec3 right = normalize(vec3(front.z, .05*turb(10.*STime), -front.x));\n    vec3 up = cross(front, right);\n    vec3 rd = normalize(front + uv.x*INVFOV*right + uv.y*INVFOV*up);\n    vec4 s = trace(o, rd);\n    \n    vec3 n = N(s.xyz);\n    if(dot(rd, n) > 0.)\n        n *= -1.;\n    \n    vec3 l = o + vec3(-.3, 0, -.3);\n    l.y = .445;\n    \n    vec3 color = vec3(0.);\n    float ldist = length(l-s.xyz);\n    if(trace(s.xyz+0.01*n, normalize(l-s.xyz)).a > ldist-0.01)\n    {\n        float aoe = .3;\n        float d = map(s.xyz + aoe * n);\n        float o = d / aoe;\n        \n        if(n.y < -.999)\n        {\n            float gran = 3.;\n            float grid = clamp(smoothstep(.46, .5, fract(gran*s.z)) * smoothstep(.54, .5, fract(gran*s.z)) + smoothstep(.46, .5, fract(gran*s.x)) * smoothstep(.54, .5, fract(gran*s.x)), 0., 1.);\n            vec3 Col = mix(25.3, 20., grid) * vec3(1., .8, .3);\n            color += Col * max(0., 1. / pow(ldist*15.25, 1.3));\n\n            float gran2 = .2;\n            float grid2 = clamp(smoothstep(.95, .92, fract(gran2*s.z)) * smoothstep(.98, .95, fract(gran2*s.z)) + smoothstep(.8, .77, fract(gran2*s.x)) * smoothstep(.83, .8, fract(gran2*s.x)), 0., 1.);\n            color = mix(color, vec3(1.), vec3(1.-grid2) / pow(ldist*.25, 1.1));            \n\n            color -= .1 * pow((1.-o), 4.);\n        }\n        else\n        {\n            vec3 Col = 2.2 * vec3(1., .8, .3);\n            if(n.y > .99)\n                Col = mix(.9, 1.2, smoothstep(.3, .8, noise(1.3*s.xz) + noise(2.3*s.xz))) * mix(.5, 1.2, noise(50.*s.xz) / ldist) * vec3(1., .65, .2);\n            color += Col * max(0., -dot(normalize(s.xyz - l), n)) / pow(ldist*0.25, 1.4) - .1 * pow((1.-o), 4.);\n        }\n        \n    }\n    \n    fragColor = vec4(clamp(color, 0., 1.),1.);\n    \n    float flash = step(.5, fract(iTime));\n    fragColor += T(vec2(6., 6.) * 16., uv, 0.) * flash;\n    fragColor += T(vec2(8., 6.) * 16., uv, .1) * flash;\n    fragColor += T(vec2(14.6, 5.1) * 16., uv, .2) * flash;\n    fragColor.xyz = mix(fragColor.xyz, vec3(2,0,0), T(vec2(9.6, 9.8) * 16., uv, .3));\n}\n\n\n", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define PI2 6.2831\nvec2 mainSound( in int samp, float time )\n{\n    vec2 Out = vec2(0.0);\n    \n    for(int i = 0; i < 12; i++)\n    {\n        float HTime = .5*time - .137*float(i);\n        float wv1 = smoothstep(0.1, 0.21+0.1*sin(HTime), sin(PI2*(27.5 + 1.1137*float(i))*HTime));\n        float wv2 = smoothstep(0.15, 0.351+0.2*sin(HTime), sin(PI2*(35.0 + 1.5137*float(i))*HTime));\n        float wv3 = mix(wv1, wv2, 0.5+0.5*sin(0.3*HTime));\n        Out += 0.05*vec2( wv3 * cos(0.2 * HTime),  wv3 * sin(0.2 * HTime) ) / pow(float(i+1), 0.7);\n    }\n    \n    float t = fract(time * 1.1 + .3*sin(time) + .17*sin(time * 1.37));\n    float s = smoothstep(.1, .05, t) * smoothstep(.0, .05, t);\n    Out += .9 * vec2(sin(time * 240.)) * s;\n    \n    return Out * clamp(0.3*time, 0., 1.);\n}\n", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 119], [121, 121, 142, 142, 205], [207, 207, 264, 264, 2408]], "test": "untested"}
{"id": "dsKSRw", "name": "Cartoon 2", "author": "DrieStone", "description": "A revised cartoon shader with halftone and edges.", "tags": ["halftone", "comic", "newsprint"], "likes": 2, "viewed": 231, "published": 3, "date": "1680884228", "time_retrieved": "2024-07-30T18:01:49.554663", "image_code": "#define BLUR_SIZE 9\n#define THRESHOLD 0.8\n#define EDGES_AMNT 200.0\n#define DOTSIZE 1.48\n#define D2R(d) radians(d)\n#define MIN_S 2.5\n#define MAX_S 19.0\n#define SPEED 0.57\n#define SST 0.888\n#define SSQ 0.288\n#define ORIGIN (0.5 * iResolution.xy)\n#define KERNEL_SIZE 9\n#define KERNEL_OFFSET vec2[KERNEL_SIZE](vec2(-1, -1), vec2(0, -1), vec2(1, -1), vec2(-1, 0), vec2(0, 0), vec2(1, 0), vec2(-1, 1), vec2(0, 1), vec2(1, 1))\n\nfloat R;\nfloat S;\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec4 rgb2cmyki(in vec3 c) {\n    float k = max(max(c.r, c.g), c.b);\n    return min(vec4(c.rgb / k, k), 1.0);\n}\n\nvec3 cmyki2rgb(in vec4 c) {\n    return c.rgb * c.a;\n}\n\nvec2 px2uv(in vec2 px) {\n    return vec2(px / iResolution.xy);\n}\n\nvec2 grid(in vec2 px) {\n    return px - mod(px, S);\n}\n\nvec4 ss(in vec4 v) {\n    return smoothstep(SST - SSQ, SST + SSQ, v);\n}\n\nmat2 rotm(in float r) {\n    float cr = cos(r);\n    float sr = sin(r);\n    return mat2(cr, -sr, sr, cr);\n}\n\nvec4 halftone(in vec2 fc, in mat2 m) {\n    vec2 smp = (grid(m * fc) + 0.5 * S) * m;\n    float s = min(length(fc - smp) / (DOTSIZE * 0.5 * S), 1.0);\n    vec3 texc = pow(texture(iChannel0, px2uv(smp + ORIGIN)).rgb, vec3(2.2));\n    vec4 c = rgb2cmyki(texc);\n    return c + s;\n}\n\nvoid make_kernel(out vec4[9] result, sampler2D tex, vec2 uv) {\n    vec2 offset = 1.0 / iResolution.xy;\n    result[0] = texture(tex, uv + vec2(-offset.x, -offset.y));\n    result[1] = texture(tex, uv + vec2(0.0, -offset.y));\n    result[2] = texture(tex, uv + vec2(offset.x, -offset.y));\n    result[3] = texture(tex, uv + vec2(-offset.x, 0.0));\n    result[4] = texture(tex, uv);\n    result[5] = texture(tex, uv + vec2(offset.x, 0.0));\n    result[6] = texture(tex, uv + vec2(-offset.x, offset.y));\n    result[7] = texture(tex, uv + vec2(0.0, offset.y));\n    result[8] = texture(tex, uv + vec2(offset.x, offset.y));\n}\n\nfloat crushBlacks(float value, float crushFactor, float cutoff) {\n    return value < cutoff ? pow(value, crushFactor) : value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 currentColor = texture(iChannel0, uv);\n\n    // Find outlines\n    float intensity = 7.0; // Increase this value for more pronounced edges\n    vec4 n[9];\n    make_kernel(n, iChannel0, fragCoord / iResolution.xy);\n\n    // Calculate Sobel\n    vec4 sobel = vec4(0.0);\n    int kernel[9] = int[](0, 1, 2, 3, 4, 5, 6, 7, 8);\n    int kernel_v[9] = int[](6, 3, 0, 7, 4, 1, 8, 5, 2);\n\n    for (int i = 0; i < 9; i++) {\n        vec4 edge_h = intensity * (n[kernel[i]] - n[kernel[8 - i]]);\n        vec4 edge_v = intensity * (n[kernel_v[i]] - n[kernel_v[8 - i]]);\n        sobel += sqrt(edge_h * edge_h + edge_v * edge_v) * 0.5;\n    }\n\n    sobel = clamp(sobel / 5.0, 0.0, 1.0); // Adjust the division value (e.g., 5.0) to control edge threshold\n\n    vec4 colors = vec4(0.0);\n    float totalWeight = 1.0;\n\n    for (int i = 0; i < KERNEL_SIZE; i++) {\n        vec4 neighbor = texture(iChannel0, uv + KERNEL_OFFSET[i] / iResolution.xy);\n\n        float weight = 1.0 - length(neighbor.rgb - currentColor.rgb);\n        weight = weight > THRESHOLD ? 1.0 : 0.0;\n        totalWeight += weight;\n        colors.rgb += neighbor.rgb * weight;\n    }\n\n    colors.rgb /= totalWeight;\n    fragColor = vec4(colors.rgb, 1.0);\n\n    // Halftone effect\n    S = MIN_S + (MAX_S - MIN_S) * 2.0 * (iResolution.x / 20.0) / iResolution.x;\n    R = D2R(180.0 * (iResolution.x / 80.0) / iResolution.y);\n\n    vec2 fc = fragCoord.xy - ORIGIN;\n    mat2 mc = rotm(R + D2R(15.0));\n    mat2 mm = rotm(R + D2R(75.0));\n    mat2 my = rotm(R);\n    mat2 mk = rotm(R + D2R(45.0));\n\n    vec4 ht = vec4(\n        halftone(fc, mc).r,\n        halftone(fc, mm).g,\n        halftone(fc, my).b,\n        halftone(fc, mk).a\n    );\n    vec3 c = cmyki2rgb(ss(ht));\n    c = pow(c, vec3(1.0 / 1.2)); // Gamma encode.\n    fragColor = mix(fragColor, vec4(c, 1.0), 0.3); // mix in halftone\n\n    // Increase saturation\n    float saturationFactor = 1.3; // Adjust this value to control the saturation level\n    vec3 hsv = rgb2hsv(fragColor.rgb);\n    hsv.y *= saturationFactor;\n\n    // Increase contrast\n    float contrastFactor = 1.10; // Adjust this value to control the contrast level\n    hsv.z = (hsv.z - 0.5) * contrastFactor + 0.5;\n    fragColor.rgb = hsv2rgb(hsv);\n\n    fragColor = mix(fragColor, vec4(0.0, 0.0, 0.0, 1.0), sobel); // add outlines\n\n     fragColor.rgb += max(0., min(1., 1. - totalWeight / EDGES_AMNT)) * 0.55;\n\n    // Crush blacks\n    float crushFactor = 7.1; // Adjust this value to control the crushing of blacks\n    float cutoff = 0.65; // Adjust this value to control the cutoff for crushing blacks\n    fragColor.rgb = vec3(crushBlacks(fragColor.r, crushFactor, cutoff), crushBlacks(fragColor.g, crushFactor, cutoff), crushBlacks(fragColor.b, crushFactor, cutoff));\n\n\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 462, 462, 797], [799, 799, 821, 821, 990], [993, 993, 1020, 1020, 1102], [1104, 1104, 1131, 1131, 1157], [1159, 1159, 1183, 1183, 1223], [1225, 1225, 1248, 1248, 1278], [1280, 1280, 1300, 1300, 1350], [1352, 1352, 1375, 1375, 1457], [1459, 1459, 1497, 1497, 1733], [2349, 2349, 2414, 2414, 2477]], "test": "untested"}
{"id": "mdSGzz", "name": "Voxel Suzanne RLE", "author": "gelami", "description": "Voxel traversal example of Suzanne stored using run-length encoding/decoding, which allows to store much a bigger resolution at a reduced compilation time.\n\nClick and drag to control camera rotation\nReset time if voxels look jarbled", "tags": ["3d", "voxel", "box", "encoding", "traversal", "blender", "decoding", "rle", "suzanne"], "likes": 26, "viewed": 435, "published": 3, "date": "1680880061", "time_retrieved": "2024-07-30T18:01:51.401726", "image_code": "// Fork of \"Voxel Suzanne\" by gelami. https://shadertoy.com/view/cdsGz7\n// 2022-10-30 04:04:06\n\n// Voxel Suzanne by gelami\n// https://www.shadertoy.com/view/cdsGz7\n\n/* \n * Voxel traversal example of Suzanne stored using run-length encoding/decoding,\n *   which allows to store much a bigger resolution at a reduced compilation time.\n *\n * Also has per face smoothed voxel normals\n *   and a hacky bloom using a separable Gaussian blur\n *\n * Click and drag to control camera rotation\n * Reset time if voxels look jarbled\n *\n * Previous entry: \n * Voxel Suzanne - gelami\n * https://www.shadertoy.com/view/cdsGz7\n * \n * The next iteration to this was supposed to be SVOs,\n *   but I couldn't get it to work sadly so that would have to wait T_T\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel1, uv).rgb;\n    \n    // 1D Y Gaussian blur pass\n    vec3 blr = gaussian1D(iChannel0, fragCoord / iResolution.y, vec2(0, 1), iResolution.xy);\n    \n    vec3 tot = col;\n    \n    tot += blr * 0.8;\n    \n    //tot = blr;\n    \n    tot = saturate(tot);\n    tot = tot / (1. + tot);\n    fragColor = vec4(pow(tot, vec3(1./2.2)), 1.0);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SUBTRACT_MODEL\n#define TEXTURE_MOVEMENT\n\n//#define SHOW_NORMALS\n\n// 0 = Face normal\n// 1 = Coarse derivative normal\n// 2 = Smooth 3x3x3 normal\n// 3 = Smooth face normal\n#define NORMAL_TYPE 3\n\n// Change to select resolution, then reset time to regenerate buffer\n// 0 = 32px\n// 1 = 64px\n// 2 = 128px (Warning: Very computationally heavy)\n#define RESOLUTION 1\n\n#if RESOLUTION == 0\n  #define RES 32\n  #define STEPS 128\n  #define AA 0\n#elif RESOLUTION == 1\n  #define RES 64\n  #define STEPS 256\n  #define AA 0\n#elif RESOLUTION == 2\n  #define RES 128\n  #define STEPS 512\n  #define AA 0\n#endif\n\n#define URES uint(RES)\n\n#define VOXEL_COUNT (URES*URES*URES)\n\n//#define BAYER\n\n#define A(x) uintBitsToFloat(x + uint(iz))\n\n#define PI (acos(-1.))\n\n\nvec3 prefilter(vec3 c)\n{\n\n    float b = max(c.r, max(c.g, c.b)); \n    \n    //return c * smoothstep(0.0, 0.5, b);\n    \n    float w = max(b - 0.02, 0.0);\n    w /= max(b, 1e-5);\n    return c * w;\n}\n\n\n#if 1\n// 1D LOD Gaussian blur from Fabrice\n// https://www.shadertoy.com/view/WtKfD3\nvec3 gaussian1D(sampler2D tx, vec2 U, vec2 D, vec2 R)\n{\n    const int N = 14;\n    const float w = 0.05;\n    \n    float z = ceil(max(0., log2(w*R.y/float(N))));\n    \n    vec3  O = vec3(0);                                                      \n    float r = float(N-1)/2., g, t=0., x;                                    \n    for( int k=0; k<N; k++ ) {                                              \n        x = float(k)/r-1.;                                                  \n        t += g = exp(-8.0*x*x );                                            \n        O += g * prefilter(textureLod(tx, (U+w*x*D) *R.y/R, z ).rgb);     \n    }                                                                       \n    return O/t;                                                             \n}\n#else\n\nvec3 gaussian1D(sampler2D tx, vec2 U, vec2 D, vec2 R)\n{\n    const int N = 24;\n    float w = 2.0;\n    \n    vec3 O = vec3(0);\n    float r = float(N-1)/2., g, t=0., x;\n    for (int k=-N; k<=N; k++)\n    {\n        x = float(k);\n        g = exp(-2.0 * x*x / float(N*N));\n        t += g;\n        O += g * prefilter(textureLod(tx, (U + w * x * D / R.y) * R.y/R, 0.0).rgb);\n    }\n    return O/t;\n}\n\n#endif\n\nfloat gyroid(vec3 p)\n{\n    return dot(sin(p), cos(p.yzx));\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, .95, .9) * t + vec3(0, .3, .5)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// Ray-Box Intersection\n// https://iquilezles.org/articles/intersectors/\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}", "buffer_a_code": "\n// Run-length decoding\n\n/*\n#define B(x) if(i == x) return y;\n\nuvec4 getData(uint i)\n{\n\n#if RESOLUTION == 2\n    B(0u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(2u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(3u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(4u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(5u, uvec4(2139062143u, 2139038338u, 2072476039u, 2139062143u)) B(6u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(7u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(8u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(9u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(10u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(11u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(12u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(13u, uvec4(2139062143u, 2139062143u, 2138604665u, 2322959221u)) B(14u, uvec4(2339866495u, 2139062143u, 2139062143u, 2139062143u)) B(15u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(16u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(17u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(18u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(19u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(20u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(21u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062131u)) B(22u, uvec4(2339606385u, 2406649205u, 2306834303u, 2139062143u)) B(23u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(24u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(25u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(26u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(27u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(28u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(29u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(30u, uvec4(2139062143u, 2138083184u, 2440008048u, 2406714239u)) B(31u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(32u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(33u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(34u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(35u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(36u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(37u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(38u, uvec4(2139062143u, 2139062143u, 2139062125u, 2281802094u)) B(39u, uvec4(2456719983u, 2423491455u, 2139062143u, 2139062143u)) B(40u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(41u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(42u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(43u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(44u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(45u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(46u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(47u, uvec4(2139057283u, 209939846u, 126315668u, 1821601680u)) B(48u, uvec4(1938456447u, 2139062143u, 2139062143u, 2139062143u)) B(49u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(50u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(51u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(52u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(53u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(54u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(55u, uvec4(2139062143u, 2139062143u, 2139062143u, 2137752589u)) B(56u, uvec4(2221638922u, 2255193863u, 2272039790u, 2440398719u)) B(57u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(58u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(59u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(60u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(61u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(62u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(63u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(64u, uvec4(2139062143u, 2139062143u, 2138997099u, 2215543914u)) B(65u, uvec4(2232190569u, 2248377091u, 2271974510u, 2424274815u)) B(66u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(67u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(68u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(69u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(70u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(71u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(72u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(73u, uvec4(2139062143u, 2139062143u, 1753354627u, 1770262405u)) B(74u, uvec4(1753550213u, 1787756934u, 1804889999u, 2139062143u)) B(75u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(76u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(77u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(78u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(79u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(80u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(81u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(82u, uvec4(2139062143u, 2139062119u, 2198963304u, 2215544424u)) B(83u, uvec4(2231665924u, 2238355051u, 2473692287u, 2139062143u)) B(84u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(85u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(86u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(87u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(88u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(89u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(90u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(91u, uvec4(2139062143u, 2137555475u, 2187887632u, 2238153743u)) B(92u, uvec4(2238284803u, 2281866857u, 2523697779u, 2306834303u)) B(93u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(94u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(95u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(96u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(97u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(98u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(99u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(100u, uvec4(2139062143u, 2139056513u, 2122519171u, 1753419909u)) B(101u, uvec4(1753482885u, 75851928u, 1788112528u, 2139062143u)) B(102u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(103u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(104u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(105u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(106u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(107u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(108u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(109u, uvec4(2139062143u, 2139055746u, 327378820u, 293889924u)) B(110u, uvec4(277178500u, 76022406u, 1754753939u, 1905033087u)) B(111u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(112u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(113u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(114u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(115u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(116u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(117u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(118u, uvec4(2139062143u, 2139062119u, 2165670248u, 2199028839u)) B(119u, uvec4(2215675239u, 2215150340u, 2255001449u, 2523697780u)) B(120u, uvec4(2290057087u, 2139062143u, 2139062143u, 2139062143u)) B(121u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(122u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(123u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(124u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(125u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(126u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(127u, uvec4(2139062143u, 2139062143u, 2139056259u, 310666884u)) B(128u, uvec4(293955205u, 260466564u, 76087686u, 1771530900u)) B(129u, uvec4(1871675263u, 2139062143u, 2139062143u, 2139062143u)) B(130u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(131u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(132u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(133u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(134u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(135u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(136u, uvec4(2139062143u, 2139062143u, 2139062117u, 2182316903u)) B(137u, uvec4(2215740519u, 2215675239u, 2232321640u, 2557056620u)) B(138u, uvec4(2456980095u, 2139062143u, 2139062143u, 2139062143u)) B(139u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(140u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(141u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(142u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(143u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(144u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(145u, uvec4(2139062143u, 2139062143u, 2139062119u, 2165670248u)) B(146u, uvec4(2199028839u, 2215675239u, 2215609959u, 2573768554u)) B(147u, uvec4(2507051135u, 2139062143u, 2139062143u, 2139062143u)) B(148u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(149u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(150u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(151u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(152u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(153u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(154u, uvec4(2139062143u, 2139062143u, 2139062116u, 2172551954u)) B(155u, uvec4(2204664593u, 2238088463u, 2254931213u, 2255001705u)) B(156u, uvec4(2523697778u, 2340388735u, 2139062143u, 2139062143u)) B(157u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(158u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(159u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(160u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(161u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(162u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(163u, uvec4(2139062143u, 2139062143u, 2139062143u, 2137424658u)) B(164u, uvec4(2187887632u, 2238153998u, 2254931214u, 2254997511u)) B(165u, uvec4(2305398379u, 2490339199u, 2139062143u, 2139062143u)) B(166u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(167u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(168u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(169u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(170u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(171u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(172u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062116u)) B(173u, uvec4(2189263888u, 2221442063u, 2254931213u, 2271708683u)) B(174u, uvec4(2288555882u, 2506986098u, 2340388735u, 2139062143u)) B(175u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(176u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(177u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(178u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(179u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(180u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(181u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(182u, uvec4(1703050628u, 293759364u, 260401284u, 243689605u)) B(183u, uvec4(210200711u, 143223190u, 1821601680u, 2139062143u)) B(184u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(185u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(186u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(187u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(188u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(189u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(190u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(191u, uvec4(2139062143u, 1669561732u, 260336004u, 226912645u)) B(192u, uvec4(193423749u, 193424006u, 126446484u, 1838314124u)) B(193u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(194u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(195u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(196u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(197u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(198u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(199u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(200u, uvec4(2139062143u, 2139062116u, 2206040848u, 2188084237u)) B(201u, uvec4(2238350348u, 2271839243u, 2288616713u, 2288748292u)) B(202u, uvec4(2322371695u, 2406844543u, 2139062143u, 2139062143u)) B(203u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(204u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(205u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(206u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(207u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(208u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(209u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139055747u)) B(210u, uvec4(276982660u, 226847364u, 210135684u, 193424005u)) B(211u, uvec4(159935366u, 109669257u, 25914770u, 1905162882u)) B(212u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(213u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(214u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(215u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(216u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(217u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(218u, uvec4(2139062143u, 2139062143u, 2139062143u, 1870888070u)) B(219u, uvec4(2055633543u, 2038921607u, 2038921352u, 2022209671u)) B(220u, uvec4(1753354119u, 1753419143u, 1770261384u, 1770261129u)) B(221u, uvec4(1770326154u, 1770521993u, 1804075914u, 1821601425u)) B(222u, uvec4(1938587519u, 2139062143u, 2139062143u, 2139062143u)) B(223u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(224u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(225u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(226u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(227u, uvec4(2139062143u, 2136310651u, 2239399544u, 2272888442u)) B(228u, uvec4(2239594879u, 2139062143u, 2139062143u, 2139062143u)) B(229u, uvec4(193101189u, 2055763850u, 1988916110u, 1922003343u)) B(230u, uvec4(1905291408u, 1905226127u, 1905226127u, 1905226382u)) B(231u, uvec4(1921934210u, 210658435u, 193880965u, 160327045u)) B(232u, uvec4(143484551u, 93153161u, 42822038u, 1804889745u)) B(233u, uvec4(1921874053u, 2139062143u, 2139062143u, 2139062143u)) B(234u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(235u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(236u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(237u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(238u, uvec4(2139062143u, 2136245625u, 2272823414u, 2322959220u)) B(239u, uvec4(2339736438u, 2306312313u, 2272888442u, 2256176762u)) B(240u, uvec4(2256176762u, 2256111481u, 2289535606u, 2339671411u)) B(241u, uvec4(2389872496u, 2440008302u, 2473366636u, 2506855787u)) B(242u, uvec4(2523633003u, 2506855788u, 2490143852u, 2490143840u)) B(243u, uvec4(2198443104u, 2215154529u, 2231800929u, 2265224034u)) B(244u, uvec4(2298582115u, 2623839079u, 2557056366u, 2406779263u)) B(245u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(246u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(247u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(248u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(249u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139050882u)) B(250u, uvec4(2072410248u, 1988785292u, 1938649742u, 1921872781u)) B(251u, uvec4(1938584716u, 1955362186u, 1988785802u, 1972073867u)) B(252u, uvec4(1972139148u, 1938715279u, 1905291154u, 1855155603u)) B(253u, uvec4(1821731734u, 1788307608u, 1754883993u, 1738106778u)) B(254u, uvec4(1721395097u, 1738106777u, 1754818712u, 1585645464u)) B(255u, uvec4(1585710489u, 1587634081u, 1604411551u, 1654482076u)) B(256u, uvec4(1704552854u, 1838183814u, 2139062143u, 2139062143u)) B(257u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(258u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(259u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(260u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(261u, uvec4(2139062143u, 2139049861u, 2022274443u, 1938649742u)) B(262u, uvec4(1888448911u, 1888514192u, 1888448911u, 1921938062u)) B(263u, uvec4(1921938062u, 1921938062u, 1905226128u, 1888579219u)) B(264u, uvec4(1838378388u, 1805019799u, 1754883993u, 1738172059u)) B(265u, uvec4(1687970972u, 1688036253u, 1671259037u, 1671324573u)) B(266u, uvec4(1671257473u, 94198947u, 1570987427u, 1570987426u)) B(267u, uvec4(1604411551u, 1654547356u, 1721330069u, 1854961031u)) B(268u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(269u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(270u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(271u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(272u, uvec4(2139062143u, 2139062143u, 2139062143u, 1266973064u)) B(273u, uvec4(1988785037u, 1905225872u, 1871802002u, 1855025041u)) B(274u, uvec4(1871802257u, 1871802257u, 1871802257u, 1871802257u)) B(275u, uvec4(1871867283u, 1838443669u, 1788307863u, 1771595674u)) B(276u, uvec4(1721460124u, 1687970718u, 1654547103u, 1637834912u)) B(277u, uvec4(1621123233u, 1604411297u, 1604410532u, 1537563557u)) B(278u, uvec4(1537498276u, 1570987426u, 1604411551u, 1654547356u)) B(279u, uvec4(1721264789u, 1854896005u, 2139062143u, 2139062143u)) B(280u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(281u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(282u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(283u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(284u, uvec4(2139048834u, 2072409994u, 1938649487u, 1871801747u)) B(285u, uvec4(1838312851u, 1838378387u, 1838313106u, 1855090322u)) B(286u, uvec4(1855090322u, 1855155603u, 1821731733u, 1805019544u)) B(287u, uvec4(1754883993u, 1738171804u, 1688036254u, 1637835168u)) B(288u, uvec4(1621123233u, 1587699362u, 1587699363u, 1570987427u)) B(289u, uvec4(1554275237u, 1520851622u, 1520786341u, 1554275492u)) B(290u, uvec4(1570922401u, 1621058205u, 1687906200u, 1788112783u)) B(291u, uvec4(1988525951u, 2139062143u, 2139062143u, 2139062143u)) B(292u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(293u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(294u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(295u, uvec4(2139062143u, 2139062143u, 2139062088u, 2222557300u)) B(296u, uvec4(2356252527u, 2439877484u, 2490078571u, 2506855532u)) B(297u, uvec4(2490143852u, 2490143852u, 2490143852u, 2490143852u)) B(298u, uvec4(2506790506u, 2540279911u, 2590415462u, 2607062371u)) B(299u, uvec4(2657263457u, 2673910111u, 2724110942u, 2724111196u)) B(300u, uvec4(2757534812u, 2774246747u, 2774181466u, 2790893401u)) B(301u, uvec4(2807670617u, 2791023963u, 2774311774u, 2724110689u)) B(302u, uvec4(2657328229u, 2590545771u, 2473627255u, 2189393791u)) B(303u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(304u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(305u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(306u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(307u, uvec4(2139062143u, 1266842757u, 2005561743u, 1855089812u)) B(308u, uvec4(1804954261u, 1788242582u, 1788242582u, 1788177301u)) B(309u, uvec4(1804954517u, 1804954518u, 1788242583u, 1754818713u)) B(310u, uvec4(1738171803u, 1704748189u, 1671324064u, 1621188513u)) B(311u, uvec4(1604476323u, 1571052708u, 1554340773u, 1520851622u)) B(312u, uvec4(1520916903u, 1504139432u, 1487427752u, 1487362471u)) B(313u, uvec4(1520851622u, 1537498276u, 1570922400u, 1637835676u)) B(314u, uvec4(1704552854u, 1821536652u, 2139062143u, 2139062143u)) B(315u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(316u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(317u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(318u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062084u)) B(319u, uvec4(2222622580u, 2356121965u, 2473301354u, 2523502440u)) B(320u, uvec4(2556991337u, 2540279657u, 2540279657u, 2540279657u)) B(321u, uvec4(2540279657u, 2556991591u, 2590415717u, 2607127651u)) B(322u, uvec4(2657263457u, 2690687326u, 2740822877u, 2757534812u)) B(323u, uvec4(2774181466u, 2807670617u, 2807670617u, 2824317271u)) B(324u, uvec4(2841094487u, 2841094232u, 2824382553u, 2807670618u)) B(325u, uvec4(2774246748u, 2740887904u, 2690752099u, 2607257705u)) B(326u, uvec4(2507051123u, 2323611519u, 2139062143u, 2139062143u)) B(327u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(328u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(329u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(330u, uvec4(2139062143u, 2139062143u, 2139062084u, 2239334257u)) B(331u, uvec4(2423100266u, 2523502440u, 2556926056u, 2556926311u)) B(332u, uvec4(2557056873u, 2540279657u, 2540279656u, 2573703527u)) B(333u, uvec4(2573703782u, 2607062371u, 2640551522u, 2673910111u)) B(334u, uvec4(2724111197u, 2757469531u, 2790958682u, 2807670617u)) B(335u, uvec4(2824317271u, 2841094487u, 2841094487u, 2841094742u)) B(336u, uvec4(2841094487u, 2841094488u, 2824382298u, 2790958683u)) B(337u, uvec4(2757599838u, 2724175969u, 2657393255u, 2557121646u)) B(338u, uvec4(2423556223u, 2139062143u, 2139062143u, 2139062143u)) B(339u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(340u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(341u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(342u, uvec4(2139062143u, 2139062085u, 2189198708u, 2372833899u)) B(343u, uvec4(2506725224u, 2556926310u, 2590415207u, 2573703527u)) B(344u, uvec4(2573703527u, 2573703527u, 2573703527u, 2590350181u)) B(345u, uvec4(2623839587u, 2657197921u, 2690687327u, 2724045916u)) B(346u, uvec4(2774247002u, 2790958936u, 2824382807u, 2841094742u)) B(347u, uvec4(2857806422u, 2857806422u, 2857806422u, 2857806422u)) B(348u, uvec4(2857806422u, 2857871703u, 2824382553u, 2791023963u)) B(349u, uvec4(2757599839u, 2707464034u, 2623904360u, 2523697776u)) B(350u, uvec4(2390197375u, 2139062143u, 2139062143u, 2139062143u)) B(351u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(352u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(353u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(354u, uvec4(2139062143u, 2139047555u, 2072408209u, 1804954007u)) B(355u, uvec4(1738106522u, 1704617371u, 1704682906u, 1721394842u)) B(356u, uvec4(1721394842u, 1721394842u, 1721460123u, 1704747934u)) B(357u, uvec4(1654612384u, 1621188258u, 1587764644u, 1554340774u)) B(358u, uvec4(1504204968u, 1487493033u, 1470781098u, 1454003628u)) B(359u, uvec4(1420580012u, 1420580012u, 1420580012u, 1420580267u)) B(360u, uvec4(1437291947u, 1437226921u, 1470716071u, 1504139941u)) B(361u, uvec4(1554210210u, 1604346270u, 1671194264u, 1771465873u)) B(362u, uvec4(1921810303u, 2139062143u, 2139062143u, 2139062143u)) B(363u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(364u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(365u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(366u, uvec4(2139062143u, 2135065720u, 2305656065u, 2372573031u)) B(367u, uvec4(2573572709u, 2607062116u, 2607127396u, 2623839078u)) B(368u, uvec4(2590415462u, 2590415716u, 2623839587u, 2640551522u)) B(369u, uvec4(2673975391u, 2724111197u, 2757535066u, 2790958937u)) B(370u, uvec4(2824382807u, 2841029461u, 2874518612u, 2891230292u)) B(371u, uvec4(2891230547u, 2907942227u, 2907942227u, 2907942227u)) B(372u, uvec4(2908007508u, 2874518358u, 2857806167u, 2841159514u)) B(373u, uvec4(2790958428u, 2740887904u, 2674040164u, 2590480490u)) B(374u, uvec4(2490273908u, 2290057087u, 2139062143u, 2139062143u)) B(375u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(376u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(377u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(378u, uvec4(2139062143u, 2139047042u, 2089121419u, 1788242072u)) B(379u, uvec4(1721394587u, 1687970716u, 1671259036u, 1687970972u)) B(380u, uvec4(1687970972u, 1687970972u, 1688036253u, 1671324064u)) B(381u, uvec4(1621188514u, 1587764389u, 1537628839u, 1504139688u)) B(382u, uvec4(1470781099u, 1437291948u, 1420580012u, 1420645293u)) B(383u, uvec4(1387156142u, 1387221423u, 1370444462u, 1387156142u)) B(384u, uvec4(1387090861u, 1420580012u, 1420514986u, 1454004136u)) B(385u, uvec4(1487362726u, 1520786595u, 1587634335u, 1654416794u)) B(386u, uvec4(1754688658u, 1888384644u, 2139062143u, 2139062143u)) B(387u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(388u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(389u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(390u, uvec4(2139062143u, 2139062143u, 1166310023u, 1803616660u)) B(391u, uvec4(1754818202u, 1687970716u, 1671258782u, 1654481566u)) B(392u, uvec4(1654481821u, 1671259292u, 1687970718u, 1654547103u)) B(393u, uvec4(1637900449u, 1604476324u, 1554340774u, 1520916649u)) B(394u, uvec4(1470715818u, 1454069163u, 1437356974u, 1387156142u)) B(395u, uvec4(1387221423u, 1370444207u, 1370444207u, 1370444207u)) B(396u, uvec4(1370444207u, 1387156142u, 1387156141u, 1420580012u)) B(397u, uvec4(1437226666u, 1470650535u, 1520851621u, 1554210465u)) B(398u, uvec4(1620992924u, 1721264533u, 1838248587u, 2139062143u)) B(399u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(400u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(401u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(402u, uvec4(2139062143u, 2139062143u, 2139062143u, 1099263367u)) B(403u, uvec4(42690967u, 1738171548u, 1654481566u, 1637769886u)) B(404u, uvec4(1637769886u, 1654481821u, 1671259037u, 1671324318u)) B(405u, uvec4(1654612384u, 1604476579u, 1571052709u, 1537628584u)) B(406u, uvec4(1487493034u, 1454003628u, 1420645293u, 1403933358u)) B(407u, uvec4(1387221423u, 1370443952u, 1353797553u, 1337020337u)) B(408u, uvec4(1337020592u, 1353732272u, 1353732271u, 1387156142u)) B(409u, uvec4(1387156396u, 1420580011u, 1454004136u, 1487362725u)) B(410u, uvec4(1554210210u, 1604346270u, 1687840663u, 1804889743u)) B(411u, uvec4(1971814271u, 2139062143u, 2139062143u, 2139062143u)) B(412u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(413u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(414u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(415u, uvec4(914492545u, 1854343046u, 1788307353u, 1704682397u)) B(416u, uvec4(1654546846u, 1637834911u, 1637769631u, 1637769886u)) B(417u, uvec4(1671259038u, 1654546848u, 1621123233u, 1604476579u)) B(418u, uvec4(1554340774u, 1520982185u, 1454003883u, 1437357229u)) B(419u, uvec4(1403868078u, 1370444208u, 1353732273u, 1337020337u)) B(420u, uvec4(1337020337u, 1337020337u, 1337020337u, 1337020337u)) B(421u, uvec4(1337020592u, 1353732271u, 1387156142u, 1387091116u)) B(422u, uvec4(1420514985u, 1470716071u, 1520786340u, 1570922399u)) B(423u, uvec4(1654482330u, 1737976723u, 1888321407u, 2139062143u)) B(424u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(425u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(426u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(427u, uvec4(2139062143u, 2139062065u, 2222622473u, 2221640193u)) B(428u, uvec4(2181203816u, 2573572963u, 2640420704u, 2690621535u)) B(429u, uvec4(2690686816u, 2673975137u, 2673974882u, 2673975137u)) B(430u, uvec4(2690687072u, 2707333981u, 2757535067u, 2790958936u)) B(431u, uvec4(2841094742u, 2874518611u, 2924654162u, 2941366352u)) B(432u, uvec4(2958078032u, 2974724686u, 2991501902u, 3008213837u)) B(433u, uvec4(3008213837u, 3008213838u, 2991501902u, 2991501647u)) B(434u, uvec4(2974855248u, 2941366098u, 2924653908u, 2891230038u)) B(435u, uvec4(2841094233u, 2807670363u, 2740887904u, 2674039910u)) B(436u, uvec4(2573833581u, 2423556479u, 2139062143u, 2139062143u)) B(437u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(438u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(439u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(440u, uvec4(2139062064u, 2289535495u, 2238290021u, 2607062369u)) B(441u, uvec4(2673844319u, 2707333471u, 2690621536u, 2673975137u)) B(442u, uvec4(2673975137u, 2673975137u, 2690622046u, 2740823132u)) B(443u, uvec4(2774181721u, 2824382807u, 2857741396u, 2907942482u)) B(444u, uvec4(2924654416u, 2974789967u, 2991501902u, 2991502157u)) B(445u, uvec4(3008213837u, 3008213837u, 3008213837u, 3008213837u)) B(446u, uvec4(3008213837u, 3008213838u, 2991501647u, 2974855248u)) B(447u, uvec4(2941366098u, 2907941973u, 2874518103u, 2824382298u)) B(448u, uvec4(2774311774u, 2707463779u, 2623969386u, 2490404223u)) B(449u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(450u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(451u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(452u, uvec4(2139062143u, 2139062143u, 2139041413u, 2039051915u)) B(453u, uvec4(126248858u, 1687970462u, 1621122977u, 1587699106u)) B(454u, uvec4(1570922144u, 1604346016u, 1621123232u, 1621123233u)) B(455u, uvec4(1604411298u, 1587764389u, 1537694120u, 1487492779u)) B(456u, uvec4(1437357229u, 1403933103u, 1370509489u, 1337020338u)) B(457u, uvec4(1303596467u, 1303661748u, 1286884532u, 1286884533u)) B(458u, uvec4(1270172597u, 1270172597u, 1270172597u, 1286819251u)) B(459u, uvec4(1303596467u, 1303531441u, 1337020591u, 1370378926u)) B(460u, uvec4(1403802795u, 1454004136u, 1487362725u, 1554145184u)) B(461u, uvec4(1637770394u, 1754688912u, 1955102591u, 2139062143u)) B(462u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(463u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(464u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(465u, uvec4(2139062143u, 797472650u, 159607180u, 109536668u)) B(466u, uvec4(1654546592u, 1587699107u, 1554209955u, 1570921889u)) B(467u, uvec4(1604346016u, 1621123232u, 1621123233u, 1587764644u)) B(468u, uvec4(1554340774u, 1504204969u, 1470781099u, 1420645294u)) B(469u, uvec4(1387221424u, 1337020338u, 1320373683u, 1303596468u)) B(470u, uvec4(1270172597u, 1270172598u, 1253460662u, 1253460662u)) B(471u, uvec4(1253460662u, 1253460917u, 1270172596u, 1286884532u)) B(472u, uvec4(1303596466u, 1320308656u, 1353732271u, 1387156141u)) B(473u, uvec4(1420514985u, 1470650790u, 1537498530u, 1604280989u)) B(474u, uvec4(1704553108u, 1871609727u, 2139062143u, 2139062143u)) B(475u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(476u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(477u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(478u, uvec4(730494347u, 159672205u, 92890268u, 1654611618u)) B(479u, uvec4(1570987171u, 1554275235u, 1554210209u, 1604346016u)) B(480u, uvec4(1621123232u, 1621188258u, 1587764644u, 1537628840u)) B(481u, uvec4(1487492779u, 1437357229u, 1403933104u, 1353797553u)) B(482u, uvec4(1337085363u, 1303661748u, 1286949813u, 1270172598u)) B(483u, uvec4(1253460407u, 1236748727u, 1236748727u, 1253460662u)) B(484u, uvec4(1253460662u, 1253460662u, 1253395636u, 1286884532u)) B(485u, uvec4(1286819506u, 1320243376u, 1353667245u, 1403803051u)) B(486u, uvec4(1437226920u, 1504009379u, 1587634334u, 1687906199u)) B(487u, uvec4(1821471880u, 2139062143u, 2139062143u, 2139062143u)) B(488u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(489u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(490u, uvec4(2139062143u, 2139062143u, 2139062143u, 2133690997u)) B(491u, uvec4(2349368678u, 2382661987u, 2657132637u, 2740757595u)) B(492u, uvec4(2774181211u, 2757469021u, 2707333471u, 2707399007u)) B(493u, uvec4(2707399262u, 2740757851u, 2790958936u, 2841094742u)) B(494u, uvec4(2874453331u, 2924654416u, 2974790222u, 3008213836u)) B(495u, uvec4(3041637707u, 3058349642u, 3058349897u, 3075061577u)) B(496u, uvec4(3075061577u, 3075061577u, 3091773257u, 3075061577u)) B(497u, uvec4(3075061577u, 3075126858u, 3058349387u, 3041702733u)) B(498u, uvec4(3008213838u, 2974789713u, 2941365843u, 2891295318u)) B(499u, uvec4(2841159514u, 2774311774u, 2690817381u, 2573898608u)) B(500u, uvec4(2390720383u, 2139062143u, 2139062143u, 2139062143u)) B(501u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(502u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(503u, uvec4(2139062143u, 2139062143u, 2133623929u, 2316075368u)) B(504u, uvec4(2349303653u, 2382463234u, 2321718879u, 2723980378u)) B(505u, uvec4(2774181466u, 2774181211u, 2724045372u, 2266734908u)) B(506u, uvec4(2283512123u, 2283577660u, 2233377374u, 2724045916u)) B(507u, uvec4(2774181721u, 2841029461u, 2891230546u, 2941366352u)) B(508u, uvec4(2974724941u, 3008214092u, 3041637706u, 3075061577u)) B(509u, uvec4(3075061832u, 3091773512u, 3091773767u, 3108485447u)) B(510u, uvec4(3108485447u, 3108485447u, 3108485448u, 3075061577u)) B(511u, uvec4(3075061577u, 3058414923u, 3041637453u, 3008213583u)) B(512u, uvec4(2974789713u, 2924654163u, 2891295318u, 2841159514u)) B(513u, uvec4(2757599840u, 2657393511u, 2540540021u, 2256502655u)) B(514u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(515u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(516u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(517u, uvec4(2139062143u, 780499337u, 209938315u, 143091100u)) B(518u, uvec4(1654611363u, 1537563302u, 1504074150u, 998317733u)) B(519u, uvec4(931993251u, 965743777u, 982586529u, 982586529u)) B(520u, uvec4(982521249u, 982390690u, 965482660u, 981932710u)) B(521u, uvec4(1520916649u, 1470780844u, 1420645294u, 1370509489u)) B(522u, uvec4(1337085364u, 1286949813u, 1270237878u, 1236814008u)) B(523u, uvec4(1220102073u, 1203324857u, 1203390138u, 1186612922u)) B(524u, uvec4(1186612922u, 1186612922u, 1186613177u, 1203324856u)) B(525u, uvec4(1220036792u, 1236748726u, 1253460917u, 1270107571u)) B(526u, uvec4(1303531440u, 1353732526u, 1387091115u, 1453938855u)) B(527u, uvec4(1520786595u, 1587569308u, 1721330323u, 1905033087u)) B(528u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(529u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(530u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(531u, uvec4(2139062143u, 2133623930u, 2282456168u, 2315815012u)) B(532u, uvec4(2640420700u, 2757404249u, 2807605049u, 2283316791u)) B(533u, uvec4(2417141047u, 2484118073u, 2517541433u, 2551030329u)) B(534u, uvec4(2551030329u, 2534318649u, 2517607225u, 2450629945u)) B(535u, uvec4(2383652665u, 2300029015u, 2857806676u, 2907942737u)) B(536u, uvec4(2958013006u, 3008213836u, 3041637962u, 3075061577u)) B(537u, uvec4(3091708231u, 3108485702u, 3125197382u, 3141909317u)) B(538u, uvec4(3141909317u, 3141909317u, 3141974598u, 3125197382u)) B(539u, uvec4(3125197382u, 3125262408u, 3091773512u, 3091838538u)) B(540u, uvec4(3058414668u, 3024925518u, 2991566928u, 2941431123u)) B(541u, uvec4(2908007254u, 2824447579u, 2757599840u, 2657393512u)) B(542u, uvec4(2507051135u, 2139062143u, 2139062143u, 2139062143u)) B(543u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(544u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(545u, uvec4(2139062143u, 2139062143u, 2139062058u, 2248967527u)) B(546u, uvec4(2299038052u, 2623578459u, 2774181465u, 2788854038u)) B(547u, uvec4(2805371408u, 2805307149u, 2755107083u, 2738395914u)) B(548u, uvec4(2721684489u, 2721684489u, 2721684489u, 2738395913u)) B(549u, uvec4(2755172873u, 2788726538u, 2822344718u, 2856027669u)) B(550u, uvec4(2891165266u, 2941366351u, 2991502157u, 3024926026u)) B(551u, uvec4(3075061577u, 3091773512u, 3108485447u, 3125132101u)) B(552u, uvec4(3141909572u, 3158621253u, 3141909317u, 3141909317u)) B(553u, uvec4(3141909317u, 3141909317u, 3141974598u, 3125197382u)) B(554u, uvec4(3108550728u, 3091773258u, 3058349642u, 3041702988u)) B(555u, uvec4(3008278864u, 2958077778u, 2908007253u, 2857871449u)) B(556u, uvec4(2791088735u, 2690817126u, 2557186930u, 2306834303u)) B(557u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(558u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(559u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(560u, uvec4(2139062143u, 1048930950u, 143287452u, 1571052198u)) B(561u, uvec4(1504066694u, 396834707u, 245839512u, 195442075u)) B(562u, uvec4(161822365u, 144849310u, 128006814u, 111360160u)) B(563u, uvec4(94582944u, 94648479u, 78002122u, 935999386u)) B(564u, uvec4(44972431u, 179261872u, 1353797554u, 1320373684u)) B(565u, uvec4(1286949559u, 1236814008u, 1220102074u, 1186612922u)) B(566u, uvec4(1186678203u, 1169966268u, 1153189052u, 1153189052u)) B(567u, uvec4(1153189052u, 1153189052u, 1169900987u, 1169900987u)) B(568u, uvec4(1169901242u, 1186612921u, 1203325112u, 1219971766u)) B(569u, uvec4(1253395381u, 1286819251u, 1320243375u, 1370379181u)) B(570u, uvec4(1420449704u, 1504074660u, 1570857374u, 1687841173u)) B(571u, uvec4(1871544191u, 2139062143u, 2139062143u, 2139062143u)) B(572u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(573u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(574u, uvec4(2139062143u, 2139062143u, 2134607479u, 2321914972u)) B(575u, uvec4(2757404249u, 2805567758u, 2805438474u, 2805308423u)) B(576u, uvec4(2788597253u, 2771886084u, 2738462978u, 2738463489u)) B(577u, uvec4(2755184696u, 3375941943u, 3392653879u, 3392719176u)) B(578u, uvec4(3108812364u, 3041637962u, 3075061577u, 3091773767u)) B(579u, uvec4(3125197382u, 3141909317u, 3158621252u, 3158621507u)) B(580u, uvec4(3175333187u, 3175333187u, 3175333443u, 3175333187u)) B(581u, uvec4(3175333187u, 3158621253u, 3141909317u, 3141909318u)) B(582u, uvec4(3108485447u, 3108550473u, 3075126858u, 3041637453u)) B(583u, uvec4(3008278863u, 2958143314u, 2907941973u, 2857871449u)) B(584u, uvec4(2791088735u, 2690817127u, 2540540022u, 2206171007u)) B(585u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(586u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(587u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(588u, uvec4(2139062078u, 2272627813u, 2606540122u, 2788921102u)) B(589u, uvec4(2805504009u, 2805373958u, 2805309698u, 2788607801u)) B(590u, uvec4(3325675321u, 3359164472u, 3375876663u, 3392653879u)) B(591u, uvec4(3392719419u, 3326589513u, 3091839048u, 3108550983u)) B(592u, uvec4(3108485702u, 3141909317u, 3158621252u, 3175333187u)) B(593u, uvec4(3192045122u, 3192110403u, 3175333187u, 3192045122u)) B(594u, uvec4(3192045122u, 3192110403u, 3175333187u, 3158621253u)) B(595u, uvec4(3141909317u, 3141974343u, 3108485448u, 3075061578u)) B(596u, uvec4(3041637708u, 3008213583u, 2974789713u, 2924719189u)) B(597u, uvec4(2857871449u, 2791023455u, 2690817126u, 2557186930u)) B(598u, uvec4(2323611519u, 2139062143u, 2139062143u, 2139062143u)) B(599u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(600u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(601u, uvec4(2139062143u, 2139062072u, 2289405023u, 2181470556u)) B(602u, uvec4(2774116154u, 2533861176u, 3342321719u, 3342387001u)) B(603u, uvec4(3325675321u, 3359164472u, 3375876663u, 3409365814u)) B(604u, uvec4(3409431098u, 3343170886u, 3142040135u, 3125197638u)) B(605u, uvec4(3141909317u, 3158621507u, 3175333443u, 3175333187u)) B(606u, uvec4(3192045122u, 3192045122u, 3192045377u, 3208822338u)) B(607u, uvec4(3192045122u, 3192045122u, 3192110403u, 3158621252u)) B(608u, uvec4(3158686533u, 3141909063u, 3108485447u, 3091838793u)) B(609u, uvec4(3058414923u, 3024991053u, 2991566929u, 2924719188u)) B(610u, uvec4(2874583384u, 2807800925u, 2707529316u, 2590610544u)) B(611u, uvec4(2373943167u, 2139062143u, 2139062143u, 2139062143u)) B(612u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(613u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(614u, uvec4(2139062143u, 2139062070u, 2272628063u, 2231736155u)) B(615u, uvec4(2772537096u, 2822489400u, 3342387000u, 3325675065u)) B(616u, uvec4(3325740857u, 3359164727u, 3392588598u, 3409365814u)) B(617u, uvec4(3409431097u, 3359686981u, 3158686790u, 3141909573u)) B(618u, uvec4(3158621507u, 3175398723u, 3175333442u, 3192045122u)) B(619u, uvec4(3208757057u, 3208822338u, 3208757057u, 3208757057u)) B(620u, uvec4(3208822338u, 3192045122u, 3192045123u, 3175332932u)) B(621u, uvec4(3158621253u, 3141909062u, 3125262663u, 3108485193u)) B(622u, uvec4(3075061323u, 3024925773u, 2991566928u, 2958143059u)) B(623u, uvec4(2891295319u, 2824447325u, 2724175715u, 2607322734u)) B(624u, uvec4(2407497599u, 2139062143u, 2139062143u, 2139062143u)) B(625u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(626u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(627u, uvec4(2139062143u, 2139062068u, 2272627807u, 2265355607u)) B(628u, uvec4(2839527739u, 3292185913u, 3325675066u, 3308963386u)) B(629u, uvec4(3342452792u, 3375876662u, 3409365814u, 3409365815u)) B(630u, uvec4(3392784446u, 3275996740u, 3175464005u, 3158621508u)) B(631u, uvec4(3175333187u, 3192045122u, 3208822338u, 3192045377u)) B(632u, uvec4(3208757057u, 3208757313u, 3208757057u, 3208757057u)) B(633u, uvec4(3208757058u, 3192045122u, 3192045122u, 3175398468u)) B(634u, uvec4(3158621253u, 3141909062u, 3125262663u, 3091838793u)) B(635u, uvec4(3058414923u, 3024990798u, 2991566929u, 2924719189u)) B(636u, uvec4(2857871449u, 2791023455u, 2690817126u, 2557251957u)) B(637u, uvec4(2239725439u, 2139062143u, 2139062143u, 2139062143u)) B(638u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(639u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(640u, uvec4(2139062143u, 2139036033u, 495344770u, 411785869u)) B(641u, uvec4(143808170u, 1069628611u, 1002781381u, 986004421u)) B(642u, uvec4(986069703u, 969423049u, 935999179u, 919287499u)) B(643u, uvec4(919287755u, 936000454u, 1103119039u, 1136477373u)) B(644u, uvec4(1153254334u, 1119765438u, 1119765183u, 1103053248u)) B(645u, uvec4(1086341567u, 1103053248u, 1086341312u, 1086341567u)) B(646u, uvec4(1103053247u, 1103053247u, 1103053502u, 1119765182u)) B(647u, uvec4(1136411836u, 1153189052u, 1169835706u, 1186613176u)) B(648u, uvec4(1220037046u, 1253460916u, 1303596466u, 1336955310u)) B(649u, uvec4(1387091115u, 1453938855u, 1537498529u, 1637770393u)) B(650u, uvec4(1788113291u, 2139062143u, 2139062143u, 2139062143u)) B(651u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(652u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(653u, uvec4(2139062143u, 2139062143u, 2132116506u, 2237433365u)) B(654u, uvec4(2321190664u, 2420945986u, 3191783996u, 3275539515u)) B(655u, uvec4(3292251451u, 3325740856u, 3375876663u, 3392588598u)) B(656u, uvec4(3409300534u, 3426143031u, 3392849728u, 3242377026u)) B(657u, uvec4(3208822339u, 3192110658u, 3192045377u, 3225534273u)) B(658u, uvec4(3208757312u, 3225468992u, 3225534528u, 3225468992u)) B(659u, uvec4(3225468992u, 3225534273u, 3208757057u, 3208757058u)) B(660u, uvec4(3192045122u, 3175398468u, 3158621253u, 3125197382u)) B(661u, uvec4(3125262408u, 3091838538u, 3058414668u, 3024990799u)) B(662u, uvec4(2958077778u, 2908007254u, 2841159514u, 2774376801u)) B(663u, uvec4(2657393257u, 2490403967u, 2139062143u, 2139062143u)) B(664u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(665u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(666u, uvec4(2139062143u, 2139062143u, 2139062143u, 344332420u)) B(667u, uvec4(1585845386u, 1535639940u, 177097654u, 1153188796u)) B(668u, uvec4(1048773564u, 1036205252u, 1002781638u, 986134729u)) B(669u, uvec4(935999434u, 919287499u, 902641100u, 902576074u)) B(670u, uvec4(969424579u, 1103119039u, 1119765438u, 1119830718u)) B(671u, uvec4(1119830464u, 1086341567u, 1103118528u, 1086341312u)) B(672u, uvec4(1086406848u, 1086341312u, 1086341312u, 1086341567u)) B(673u, uvec4(1103053247u, 1103053502u, 1119765181u, 1136477372u)) B(674u, uvec4(1153189051u, 1186612922u, 1186547896u, 1219971766u)) B(675u, uvec4(1253395636u, 1303531185u, 1353667246u, 1403737769u)) B(676u, uvec4(1487362725u, 1570857119u, 1671129238u, 1854832511u)) B(677u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(678u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(679u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(680u, uvec4(2139034754u, 2089162883u, 1585910920u, 1552486285u)) B(681u, uvec4(1270171322u, 1169899394u, 79380100u, 29179331u)) B(682u, uvec4(1019558854u, 969423049u, 935999179u, 919287245u)) B(683u, uvec4(885863884u, 902575819u, 969424324u, 1086407359u)) B(684u, uvec4(1119765438u, 1119830718u, 1119830464u, 1086341312u)) B(685u, uvec4(1103118528u, 1086341312u, 1086406593u, 1086341312u)) B(686u, uvec4(1086341312u, 1086341567u, 1103053247u, 1103053247u)) B(687u, uvec4(1119765182u, 1119700156u, 1153189052u, 1169835706u)) B(688u, uvec4(1186613176u, 1220037046u, 1253395636u, 1303531185u)) B(689u, uvec4(1353732526u, 1403803050u, 1470650789u, 1554210719u)) B(690u, uvec4(1671129238u, 1854832511u, 2139062143u, 2139062143u)) B(691u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(692u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(693u, uvec4(2139062143u, 2139062143u, 2139034754u, 2089097347u)) B(694u, uvec4(1602688135u, 1569263500u, 1270236603u, 1169899393u)) B(695u, uvec4(96157315u, 45956547u, 1019493573u, 986200265u)) B(696u, uvec4(935999179u, 919352525u, 885863629u, 902575819u)) B(697u, uvec4(952712389u, 1086407104u, 1119830718u, 1119830464u)) B(698u, uvec4(1103053248u, 1086341312u, 1086406848u, 1086341312u)) B(699u, uvec4(1086406593u, 1069629632u, 1086341312u, 1086341312u)) B(700u, uvec4(1103053247u, 1103053247u, 1119765182u, 1119699901u)) B(701u, uvec4(1153189052u, 1169835706u, 1186613176u, 1220037046u)) B(702u, uvec4(1253460916u, 1303531185u, 1353732526u, 1403803050u)) B(703u, uvec4(1470650789u, 1554210719u, 1671129238u, 1854832511u)) B(704u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(705u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(706u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(707u, uvec4(2139035009u, 2089097346u, 1619399816u, 1552486540u)) B(708u, uvec4(1270171322u, 1186611329u, 79380355u, 45891267u)) B(709u, uvec4(1019493573u, 986200265u, 935999180u, 902575309u)) B(710u, uvec4(885863629u, 902575819u, 952712389u, 1086407104u)) B(711u, uvec4(1119830463u, 1119830464u, 1103053248u, 1086341312u)) B(712u, uvec4(1086406848u, 1086341313u, 1069629377u, 1069629632u)) B(713u, uvec4(1086341312u, 1086341312u, 1103053247u, 1103053247u)) B(714u, uvec4(1119765182u, 1119699901u, 1153189052u, 1153124026u)) B(715u, uvec4(1186613176u, 1220037046u, 1253460916u, 1286819505u)) B(716u, uvec4(1353732526u, 1403803050u, 1470650789u, 1554210719u)) B(717u, uvec4(1671128983u, 1838186367u, 2139062143u, 2139062143u)) B(718u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(719u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(720u, uvec4(2139062143u, 2139062143u, 2139034753u, 2089097346u)) B(721u, uvec4(1619399816u, 1552486540u, 1270171322u, 1186611329u)) B(722u, uvec4(79380355u, 45891267u, 1019493573u, 986200265u)) B(723u, uvec4(935999180u, 902575309u, 885863629u, 902575819u)) B(724u, uvec4(952712389u, 1086407104u, 1119830463u, 1119830464u)) B(725u, uvec4(1103053248u, 1086341312u, 1086406848u, 1086341313u)) B(726u, uvec4(1069629377u, 1069629632u, 1086341312u, 1086341312u)) B(727u, uvec4(1103053247u, 1103053247u, 1119765182u, 1119699901u)) B(728u, uvec4(1153189052u, 1153124026u, 1186613176u, 1220037046u)) B(729u, uvec4(1253460916u, 1286819505u, 1353732526u, 1403803050u)) B(730u, uvec4(1470650789u, 1554210719u, 1671128983u, 1838186367u)) B(731u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(732u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(733u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(734u, uvec4(2139034498u, 2089097347u, 1602688135u, 1569263500u)) B(735u, uvec4(1270236603u, 1169899393u, 96157315u, 45956547u)) B(736u, uvec4(1019493573u, 986200265u, 935999179u, 919352525u)) B(737u, uvec4(885863629u, 902575819u, 952712389u, 1086407104u)) B(738u, uvec4(1119830718u, 1119830464u, 1103053248u, 1086341312u)) B(739u, uvec4(1086406848u, 1086341312u, 1086406593u, 1069629632u)) B(740u, uvec4(1086341312u, 1086341312u, 1103053247u, 1103053247u)) B(741u, uvec4(1119765182u, 1119699901u, 1153189052u, 1169835706u)) B(742u, uvec4(1186613176u, 1220037046u, 1253460916u, 1303531185u)) B(743u, uvec4(1353732526u, 1403803050u, 1470650789u, 1554210719u)) B(744u, uvec4(1671129238u, 1854832511u, 2139062143u, 2139062143u)) B(745u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(746u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(747u, uvec4(2139062143u, 2139062143u, 2139034754u, 2089162883u)) B(748u, uvec4(1585910920u, 1552486285u, 1270171322u, 1169899394u)) B(749u, uvec4(79380100u, 29179331u, 1019558854u, 969423049u)) B(750u, uvec4(935999179u, 919287245u, 885863884u, 902575819u)) B(751u, uvec4(969424324u, 1086407359u, 1119765438u, 1119830718u)) B(752u, uvec4(1119830464u, 1086341312u, 1103118528u, 1086341312u)) B(753u, uvec4(1086406593u, 1086341312u, 1086341312u, 1086341567u)) B(754u, uvec4(1103053247u, 1103053247u, 1119765182u, 1119700156u)) B(755u, uvec4(1153189052u, 1169835706u, 1186613176u, 1220037046u)) B(756u, uvec4(1253395636u, 1303531185u, 1353732526u, 1403803050u)) B(757u, uvec4(1470650789u, 1554210719u, 1671129238u, 1854832511u)) B(758u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(759u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(760u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(761u, uvec4(2139062035u, 2249753694u, 2249493083u, 2281800714u)) B(762u, uvec4(2387326532u, 3158555710u, 2198060093u, 3275539515u)) B(763u, uvec4(3309028922u, 3342387511u, 3392653878u, 3409365813u)) B(764u, uvec4(3442854965u, 3426208313u, 3359556417u, 3225599810u)) B(765u, uvec4(3192110658u, 3208822338u, 3208757312u, 3225534273u)) B(766u, uvec4(3225468992u, 3225468992u, 3242246208u, 3225468992u)) B(767u, uvec4(3225468992u, 3225534273u, 3208757057u, 3208822338u)) B(768u, uvec4(3192044867u, 3175398468u, 3158620998u, 3125197382u)) B(769u, uvec4(3108550728u, 3075126858u, 3041702989u, 2991501648u)) B(770u, uvec4(2941431379u, 2874583384u, 2807735645u, 2707464035u)) B(771u, uvec4(2607322734u, 2390720383u, 2139062143u, 2139062143u)) B(772u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(773u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(774u, uvec4(2139062143u, 2139062143u, 2139034756u, 444947590u)) B(775u, uvec4(361388687u, 143674548u, 1119764162u, 1019428036u)) B(776u, uvec4(1002716101u, 1002846919u, 952711114u, 935999179u)) B(777u, uvec4(919287244u, 919353035u, 936000199u, 1086407359u)) B(778u, uvec4(1119830718u, 1136542654u, 1119765183u, 1103118783u)) B(779u, uvec4(1103053248u, 1086341312u, 1086341568u, 1086341312u)) B(780u, uvec4(1086341312u, 1086341567u, 1103053247u, 1103053247u)) B(781u, uvec4(1119765182u, 1119700156u, 1153189052u, 1169835706u)) B(782u, uvec4(1186613176u, 1220037046u, 1253460916u, 1286884786u)) B(783u, uvec4(1336955055u, 1387091115u, 1453938855u, 1520786849u)) B(784u, uvec4(1637770394u, 1771335820u, 2139062143u, 2139062143u)) B(785u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(786u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(787u, uvec4(2139062143u, 2139062143u, 2139062143u, 2132181277u)) B(788u, uvec4(2254209560u, 2337967368u, 2455153215u, 3241984827u)) B(789u, uvec4(3308963130u, 3309028666u, 3325740857u, 3359164727u)) B(790u, uvec4(3392588598u, 3409365814u, 3409431351u, 3392915009u)) B(791u, uvec4(3225599811u, 3175398724u, 3175333442u, 3192110658u)) B(792u, uvec4(3192045377u, 3208757312u, 3225534273u, 3208757312u)) B(793u, uvec4(3225468992u, 3225534273u, 3208757057u, 3208757057u)) B(794u, uvec4(3208822338u, 3192045123u, 3158621252u, 3158621253u)) B(795u, uvec4(3125197382u, 3125262408u, 3091838538u, 3058414669u)) B(796u, uvec4(3008213583u, 2958143058u, 2908007254u, 2841159515u)) B(797u, uvec4(2757599585u, 2657393002u, 2490469247u, 2139062143u)) B(798u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(799u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(800u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(801u, uvec4(898069900u, 1602684565u, 1470709697u, 1002715845u)) B(802u, uvec4(969292230u, 986004166u, 986134984u, 952711114u)) B(803u, uvec4(919287499u, 919287499u, 935999944u, 1052984254u)) B(804u, uvec4(1153254844u, 1169966269u, 1153254333u, 1136542398u)) B(805u, uvec4(1119830718u, 1119765183u, 1103053247u, 1103053248u)) B(806u, uvec4(1103053247u, 1103053247u, 1103053247u, 1119765182u)) B(807u, uvec4(1119765182u, 1119700156u, 1153189052u, 1169900986u)) B(808u, uvec4(1186613177u, 1203259831u, 1236683701u, 1270107570u)) B(809u, uvec4(1320308656u, 1370379180u, 1437226920u, 1504074659u)) B(810u, uvec4(1604346524u, 1721265297u, 1971683199u, 2139062143u)) B(811u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(812u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(813u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062073u)) B(814u, uvec4(2272628063u, 2231736155u, 2772537096u, 2822489400u)) B(815u, uvec4(3342387000u, 3325675065u, 3325740857u, 3359164727u)) B(816u, uvec4(3392588598u, 3409365814u, 3409431097u, 3359686981u)) B(817u, uvec4(3158686790u, 3141909573u, 3158621507u, 3175398723u)) B(818u, uvec4(3175333442u, 3192045122u, 3208757057u, 3208822338u)) B(819u, uvec4(3208757057u, 3208757057u, 3208822338u, 3192045122u)) B(820u, uvec4(3192045123u, 3175332932u, 3158621253u, 3141909062u)) B(821u, uvec4(3125262663u, 3108485193u, 3075061323u, 3024925773u)) B(822u, uvec4(2991566928u, 2958143059u, 2891295319u, 2824447325u)) B(823u, uvec4(2724175715u, 2607322734u, 2407497599u, 2139062143u)) B(824u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(825u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(826u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062070u)) B(827u, uvec4(2289405023u, 2181470556u, 2774116154u, 2533861176u)) B(828u, uvec4(3342321719u, 3342387001u, 3325675321u, 3359164472u)) B(829u, uvec4(3375876663u, 3409365814u, 3409431098u, 3343170886u)) B(830u, uvec4(3142040135u, 3125197638u, 3141909317u, 3158621507u)) B(831u, uvec4(3175333443u, 3175333187u, 3192045122u, 3192045122u)) B(832u, uvec4(3192045377u, 3208822338u, 3192045122u, 3192045122u)) B(833u, uvec4(3192110403u, 3158621252u, 3158686533u, 3141909063u)) B(834u, uvec4(3108485447u, 3091838793u, 3058414923u, 3024991053u)) B(835u, uvec4(2991566929u, 2924719188u, 2874583384u, 2807800925u)) B(836u, uvec4(2707529316u, 2590610544u, 2373943167u, 2139062143u)) B(837u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(838u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(839u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062073u)) B(840u, uvec4(2272627813u, 2606540122u, 2788921102u, 2805504009u)) B(841u, uvec4(2805373958u, 2805309698u, 2788607801u, 3325675321u)) B(842u, uvec4(3359164472u, 3375876663u, 3392653879u, 3392719419u)) B(843u, uvec4(3326589513u, 3091839048u, 3108550983u, 3108485702u)) B(844u, uvec4(3141909317u, 3158621252u, 3175333187u, 3192045122u)) B(845u, uvec4(3192110403u, 3175333187u, 3192045122u, 3192045122u)) B(846u, uvec4(3192110403u, 3175333187u, 3158621253u, 3141909317u)) B(847u, uvec4(3141974343u, 3108485448u, 3075061578u, 3041637708u)) B(848u, uvec4(3008213583u, 2974789713u, 2924719189u, 2857871449u)) B(849u, uvec4(2791023455u, 2690817126u, 2557186930u, 2323611519u)) B(850u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(851u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(852u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(853u, uvec4(2139062075u, 2255981157u, 2623317082u, 2790893369u)) B(854u, uvec4(2433656631u, 2550834997u, 2617746998u, 2651170103u)) B(855u, uvec4(2684658489u, 2701304633u, 2734793784u, 3359164728u)) B(856u, uvec4(3375876663u, 3392653880u, 3376986444u, 3058480459u)) B(857u, uvec4(3058349897u, 3075061832u, 3108485702u, 3125197637u)) B(858u, uvec4(3141909572u, 3158621252u, 3175333187u, 3175333187u)) B(859u, uvec4(3175333187u, 3192110403u, 3175333187u, 3175332932u)) B(860u, uvec4(3158686533u, 3141909317u, 3141974343u, 3108485448u)) B(861u, uvec4(3075061578u, 3058349387u, 3024991054u, 2974789713u)) B(862u, uvec4(2941431123u, 2891295319u, 2824447580u, 2724175970u)) B(863u, uvec4(2624034669u, 2423686015u, 2139062143u, 2139062143u)) B(864u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(865u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(866u, uvec4(2139062143u, 2139062143u, 2139062143u, 2134934890u)) B(867u, uvec4(2248706660u, 2623382618u, 2790893116u, 2249697079u)) B(868u, uvec4(2467211062u, 2550900277u, 2601100598u, 2634588729u)) B(869u, uvec4(2651300154u, 2651235128u, 2684724024u, 2684724280u)) B(870u, uvec4(2667882039u, 3392653879u, 2583866937u, 2399842129u)) B(871u, uvec4(2958078287u, 2991502157u, 3024926026u, 3075061832u)) B(872u, uvec4(3091773767u, 3125197382u, 3125197637u, 3141909572u)) B(873u, uvec4(3158621252u, 3158621252u, 3158621252u, 3158621252u)) B(874u, uvec4(3158686533u, 3141909317u, 3141909318u, 3125197382u)) B(875u, uvec4(3108485448u, 3091773258u, 3058349387u, 3041702733u)) B(876u, uvec4(3008278864u, 2941365843u, 2908006999u, 2824447579u)) B(877u, uvec4(2757599585u, 2657393257u, 2507115903u, 2139062143u)) B(878u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(879u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(880u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(881u, uvec4(2139040646u, 210069385u, 143221916u, 1621187493u)) B(882u, uvec4(1520851366u, 982062759u, 915542183u, 899091876u)) B(883u, uvec4(932776867u, 949684898u, 966527394u, 966527394u)) B(884u, uvec4(966527395u, 949684644u, 949619110u, 949422760u)) B(885u, uvec4(965742250u, 998643116u, 1403933359u, 1370509234u)) B(886u, uvec4(1320373684u, 1286949559u, 1236748728u, 1220036793u)) B(887u, uvec4(1203324858u, 1169900987u, 1169966268u, 1153189307u)) B(888u, uvec4(1169900987u, 1169900987u, 1169900987u, 1169900987u)) B(889u, uvec4(1186612922u, 1186612921u, 1220036792u, 1219971766u)) B(890u, uvec4(1253460661u, 1286884531u, 1320243376u, 1353667245u)) B(891u, uvec4(1420514730u, 1470650790u, 1554145184u, 1654417048u)) B(892u, uvec4(1804825225u, 2139062143u, 2139062143u, 2139062143u)) B(893u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(894u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(895u, uvec4(2139062143u, 2139062143u, 2139041156u, 2055736196u)) B(896u, uvec4(1753876616u, 1688035743u, 1554274982u, 1504139431u)) B(897u, uvec4(965220518u, 932188837u, 932450466u, 966135458u)) B(898u, uvec4(966266274u, 966266274u, 966200994u, 966135715u)) B(899u, uvec4(965874085u, 965612455u, 965285800u, 1470781099u)) B(900u, uvec4(1420645295u, 1370509234u, 1320373683u, 1286949814u)) B(901u, uvec4(1253525943u, 1236813753u, 1203324858u, 1186612922u)) B(902u, uvec4(1186678203u, 1169900987u, 1169900987u, 1169901242u)) B(903u, uvec4(1186612922u, 1186612922u, 1186613176u, 1220036792u)) B(904u, uvec4(1220037046u, 1253460916u, 1286884531u, 1320308656u)) B(905u, uvec4(1353667245u, 1403868331u, 1453873574u, 1537498530u)) B(906u, uvec4(1620993179u, 1754623632u, 2139062143u, 2139062143u)) B(907u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(908u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(909u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062057u)) B(910u, uvec4(2239334668u, 2204601096u, 2271583330u, 2673714011u)) B(911u, uvec4(2774181465u, 2790893115u, 2166269239u, 2367071033u)) B(912u, uvec4(2417271098u, 2434048314u, 2434048314u, 2417336634u)) B(913u, uvec4(2383913529u, 2350425146u, 2266670682u, 2807605591u)) B(914u, uvec4(2857741396u, 2907942481u, 2958078287u, 2991436876u)) B(915u, uvec4(3041637707u, 3058349641u, 3091773512u, 3108485447u)) B(916u, uvec4(3108485447u, 3125197382u, 3125197382u, 3125197382u)) B(917u, uvec4(3125197382u, 3125262663u, 3108485192u, 3091773513u)) B(918u, uvec4(3075061322u, 3058414923u, 3024991053u, 2991566928u)) B(919u, uvec4(2958143058u, 2908007254u, 2841159514u, 2774311774u)) B(920u, uvec4(2690817126u, 2573898609u, 2357165951u, 2139062143u)) B(921u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(922u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(923u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(924u, uvec4(746879370u, 209807500u, 126313870u, 25232010u)) B(925u, uvec4(1654546338u, 1554274981u, 1520851621u, 1520786338u)) B(926u, uvec4(1570913415u, 463551624u, 463551368u, 480328837u)) B(927u, uvec4(513957538u, 1571052709u, 1520916905u, 1454069164u)) B(928u, uvec4(1420645039u, 1370509489u, 1320373683u, 1303661749u)) B(929u, uvec4(1270172343u, 1236748727u, 1236814008u, 1220036792u)) B(930u, uvec4(1220102073u, 1203324857u, 1203324857u, 1203324857u)) B(931u, uvec4(1203325111u, 1236748727u, 1236748726u, 1270172597u)) B(932u, uvec4(1270107571u, 1303531441u, 1336955310u, 1387156396u)) B(933u, uvec4(1437226665u, 1487362724u, 1570922654u, 1687906199u)) B(934u, uvec4(1838183814u, 2139062143u, 2139062143u, 2139062143u)) B(935u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(936u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(937u, uvec4(2139062143u, 2139062143u, 2139062143u, 764048780u)) B(938u, uvec4(142960270u, 76112798u, 1621122467u, 1554275237u)) B(939u, uvec4(1520786340u, 1537432993u, 1587634081u, 1604411297u)) B(940u, uvec4(1604476579u, 1554340774u, 1520916649u, 1470781099u)) B(941u, uvec4(1420645294u, 1387221169u, 1337085619u, 1303596213u)) B(942u, uvec4(1270172598u, 1253460662u, 1253525943u, 1236748727u)) B(943u, uvec4(1236748727u, 1236748728u, 1219971511u, 1236748727u)) B(944u, uvec4(1236748727u, 1253460662u, 1253395381u, 1286819251u)) B(945u, uvec4(1303596721u, 1336955311u, 1370379180u, 1437226665u)) B(946u, uvec4(1487362725u, 1554210464u, 1654482329u, 1788047502u)) B(947u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(948u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(949u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(950u, uvec4(2139062143u, 2139062143u, 2133494389u, 2332656743u)) B(951u, uvec4(2365950308u, 2623709022u, 2724045660u, 2740757595u)) B(952u, uvec4(2740757341u, 2707398752u, 2690687072u, 2690687326u)) B(953u, uvec4(2724111197u, 2757469786u, 2824382806u, 2874518612u)) B(954u, uvec4(2907942481u, 2958078287u, 2974790221u, 3008214092u)) B(955u, uvec4(3024926027u, 3041637707u, 3058349641u, 3075061577u)) B(956u, uvec4(3075061577u, 3075126858u, 3058349642u, 3058349642u)) B(957u, uvec4(3058349388u, 3024925772u, 3024925518u, 2991501648u)) B(958u, uvec4(2958077778u, 2907941973u, 2874518103u, 2824447324u)) B(959u, uvec4(2740887904u, 2657393511u, 2540474740u, 2290057087u)) B(960u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(961u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(962u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(963u, uvec4(2139062143u, 2139041416u, 2005535107u, 1770784391u)) B(964u, uvec4(1704747678u, 1621122722u, 1570987171u, 1554210210u)) B(965u, uvec4(1570856864u, 1621123232u, 1621123232u, 1621188259u)) B(966u, uvec4(1571052709u, 1537628584u, 1487493034u, 1454068909u)) B(967u, uvec4(1403933359u, 1370509233u, 1337085619u, 1303596467u)) B(968u, uvec4(1303661493u, 1270172597u, 1270237878u, 1253460662u)) B(969u, uvec4(1253460662u, 1253460662u, 1270172597u, 1270107316u)) B(970u, uvec4(1286884787u, 1303531186u, 1336955056u, 1353667246u)) B(971u, uvec4(1387091115u, 1453938600u, 1504074660u, 1570922399u)) B(972u, uvec4(1654482329u, 1788112782u, 2139062143u, 2139062143u)) B(973u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(974u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(975u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(976u, uvec4(2139041157u, 2039051915u, 126248858u, 1687970462u)) B(977u, uvec4(1621122977u, 1587699106u, 1570922144u, 1604346016u)) B(978u, uvec4(1621123232u, 1621123233u, 1604411298u, 1587764389u)) B(979u, uvec4(1537694120u, 1487492779u, 1437357229u, 1403933103u)) B(980u, uvec4(1370509489u, 1337020338u, 1303596467u, 1303661748u)) B(981u, uvec4(1286884532u, 1286884533u, 1270172597u, 1270172597u)) B(982u, uvec4(1270172597u, 1286819251u, 1303596467u, 1303531441u)) B(983u, uvec4(1337020591u, 1370378926u, 1403802795u, 1454004136u)) B(984u, uvec4(1487362725u, 1554145184u, 1637770394u, 1754688912u)) B(985u, uvec4(1955102591u, 2139062143u, 2139062143u, 2139062143u)) B(986u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(987u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(988u, uvec4(2139062143u, 2139062143u, 2139062143u, 2133887095u)) B(989u, uvec4(2315748713u, 2556795748u, 2640420703u, 2690621790u)) B(990u, uvec4(2707398751u, 2690686817u, 2673975137u, 2673975137u)) B(991u, uvec4(2673975391u, 2724111197u, 2757535066u, 2807670872u)) B(992u, uvec4(2841094741u, 2891230547u, 2924654162u, 2941301071u)) B(993u, uvec4(2974790222u, 2991501902u, 3008213837u, 3008213837u)) B(994u, uvec4(3008213837u, 3008213837u, 3008213837u, 3008213837u)) B(995u, uvec4(3008279118u, 2974789968u, 2958077777u, 2941431123u)) B(996u, uvec4(2891295573u, 2857871448u, 2807735644u, 2740887904u)) B(997u, uvec4(2657328230u, 2557121648u, 2373943167u, 2139062143u)) B(998u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(999u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1000u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1001u, uvec4(2139062143u, 2133886074u, 2265547883u, 2315354626u)) B(1002u, uvec4(2271779173u, 2606996833u, 2673909855u, 2690621536u)) B(1003u, uvec4(2673909601u, 2673975137u, 2657263457u, 2673975392u)) B(1004u, uvec4(2690687326u, 2740823132u, 2774247002u, 2807605591u)) B(1005u, uvec4(2857806677u, 2891165266u, 2924654417u, 2958078032u)) B(1006u, uvec4(2958078286u, 2991501902u, 2991502157u, 3008213837u)) B(1007u, uvec4(3008213837u, 3008279118u, 2991501902u, 2974789968u)) B(1008u, uvec4(2958077777u, 2941431378u, 2908007508u, 2874583383u)) B(1009u, uvec4(2824447833u, 2791023454u, 2707464034u, 2623969641u)) B(1010u, uvec4(2506985588u, 2306834303u, 2139062143u, 2139062143u)) B(1011u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1012u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1013u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1014u, uvec4(2139042946u, 209809031u, 126249623u, 1738106267u)) B(1015u, uvec4(1671258782u, 1637769631u, 1621057950u, 1637835166u)) B(1016u, uvec4(1654547357u, 1671324318u, 1637900448u, 1621188514u)) B(1017u, uvec4(1587764389u, 1537628840u, 1487492778u, 1454069164u)) B(1018u, uvec4(1420645293u, 1403933103u, 1370509488u, 1353797553u)) B(1019u, uvec4(1337020337u, 1337020337u, 1337020337u, 1337020337u)) B(1020u, uvec4(1337020337u, 1353732272u, 1353667246u, 1387156141u)) B(1021u, uvec4(1420580011u, 1453938601u, 1487362725u, 1537498530u)) B(1022u, uvec4(1604280989u, 1704617879u, 1804824717u, 2139062143u)) B(1023u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1024u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1025u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1026u, uvec4(2139062143u, 2139062143u, 2139062079u, 2238547714u)) B(1027u, uvec4(2338953063u, 2590284898u, 2640485985u, 2657263201u)) B(1028u, uvec4(2657263202u, 2640551267u, 2640551267u, 2657263202u)) B(1029u, uvec4(2673975391u, 2724111197u, 2757535067u, 2790893656u)) B(1030u, uvec4(2841094742u, 2857741396u, 2907942227u, 2924654162u)) B(1031u, uvec4(2941366097u, 2941300816u, 2974789967u, 2974789967u)) B(1032u, uvec4(2974855248u, 2958078032u, 2958077778u, 2924654162u)) B(1033u, uvec4(2924719188u, 2891230038u, 2857871448u, 2807735644u)) B(1034u, uvec4(2740822623u, 2690752100u, 2590480235u, 2490273653u)) B(1035u, uvec4(2273279871u, 2139062143u, 2139062143u, 2139062143u)) B(1036u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1037u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1038u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1039u, uvec4(1115978375u, 1803616660u, 1754818202u, 1687970716u)) B(1040u, uvec4(1671258782u, 1654481566u, 1654481821u, 1671259292u)) B(1041u, uvec4(1687970718u, 1654547103u, 1637900449u, 1604476324u)) B(1042u, uvec4(1554340774u, 1520916649u, 1470715818u, 1454069163u)) B(1043u, uvec4(1437356974u, 1387156142u, 1387221423u, 1370444207u)) B(1044u, uvec4(1370444207u, 1370444207u, 1370444207u, 1387156142u)) B(1045u, uvec4(1387156141u, 1420580012u, 1437226666u, 1470650535u)) B(1046u, uvec4(1520851621u, 1554210465u, 1620992924u, 1721264533u)) B(1047u, uvec4(1838248587u, 2139062143u, 2139062143u, 2139062143u)) B(1048u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1049u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1050u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1051u, uvec4(2139062143u, 1115847813u, 1988848278u, 1754818202u)) B(1052u, uvec4(1704682652u, 1671193501u, 1671193756u, 1687970972u)) B(1053u, uvec4(1687970972u, 1687970973u, 1671259038u, 1637900449u)) B(1054u, uvec4(1604476579u, 1554340774u, 1520916903u, 1504204714u)) B(1055u, uvec4(1454069163u, 1437357228u, 1420580013u, 1403867822u)) B(1056u, uvec4(1387156143u, 1370444207u, 1387156142u, 1387156141u)) B(1057u, uvec4(1403868332u, 1420580011u, 1454003882u, 1470650535u)) B(1058u, uvec4(1520851621u, 1554210465u, 1621058204u, 1704618134u)) B(1059u, uvec4(1821536398u, 1988394879u, 2139062143u, 2139062143u)) B(1060u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1061u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1062u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1063u, uvec4(2139062143u, 2139062085u, 2222492013u, 2231471466u)) B(1064u, uvec4(2540149093u, 2590350180u, 2623839077u, 2607062116u)) B(1065u, uvec4(2607192678u, 2590415462u, 2607062116u, 2640551267u)) B(1066u, uvec4(2657263457u, 2690622046u, 2740823132u, 2774181466u)) B(1067u, uvec4(2807670872u, 2841094486u, 2874518357u, 2891230292u)) B(1068u, uvec4(2891230292u, 2907942227u, 2907942227u, 2907942227u)) B(1069u, uvec4(2907942228u, 2891230037u, 2874583638u, 2841094488u)) B(1070u, uvec4(2807735898u, 2774311774u, 2707464034u, 2640616039u)) B(1071u, uvec4(2557121646u, 2423556223u, 2139062143u, 2139062143u)) B(1072u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1073u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1074u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1075u, uvec4(2139062143u, 2139062143u, 2135131003u, 2255524203u)) B(1076u, uvec4(2506725223u, 2573638245u, 2590350181u, 2607127142u)) B(1077u, uvec4(2590415462u, 2590415462u, 2590415462u, 2607127397u)) B(1078u, uvec4(2623774306u, 2673975392u, 2707333726u, 2740823132u)) B(1079u, uvec4(2774247001u, 2824382552u, 2841094487u, 2857806422u)) B(1080u, uvec4(2857741396u, 2891230292u, 2891230292u, 2891230292u)) B(1081u, uvec4(2891295573u, 2874518357u, 2857871703u, 2841159513u)) B(1082u, uvec4(2807735644u, 2740822623u, 2690752099u, 2623969385u)) B(1083u, uvec4(2523697522u, 2357165951u, 2139062143u, 2139062143u)) B(1084u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1085u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1086u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1087u, uvec4(2139062143u, 2139062143u, 1115847813u, 1955425938u)) B(1088u, uvec4(1804954007u, 1754818457u, 1721394841u, 1738106777u)) B(1089u, uvec4(1738106777u, 1738106777u, 1738106777u, 1738171803u)) B(1090u, uvec4(1704748189u, 1671324063u, 1637900449u, 1604476324u)) B(1091u, uvec4(1554340774u, 1520851623u, 1487427753u, 1470715818u)) B(1092u, uvec4(1454003882u, 1454003882u, 1454003882u, 1454003882u)) B(1093u, uvec4(1454003882u, 1454004137u, 1470650536u, 1504074661u)) B(1094u, uvec4(1537498530u, 1604411551u, 1654416794u, 1754688658u)) B(1095u, uvec4(1888384900u, 2139062143u, 2139062143u, 2139062143u)) B(1096u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1097u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1098u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1099u, uvec4(2139062143u, 2139062143u, 1166375303u, 1905290643u)) B(1100u, uvec4(1788242327u, 1754818456u, 1754818457u, 1738041751u)) B(1101u, uvec4(1771530647u, 1771530647u, 1754883993u, 1738106778u)) B(1102u, uvec4(1721459869u, 1671259038u, 1654612129u, 1604476579u)) B(1103u, uvec4(1571052453u, 1537628838u, 1520916903u, 1504204713u)) B(1104u, uvec4(1470715817u, 1470715817u, 1470715818u, 1453938601u)) B(1105u, uvec4(1470715817u, 1487427751u, 1520851622u, 1537498530u)) B(1106u, uvec4(1587699616u, 1637770394u, 1738042004u, 1854960776u)) B(1107u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1108u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1109u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1110u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1111u, uvec4(2139062143u, 2135196794u, 2272562287u, 2439877483u)) B(1112u, uvec4(2506790505u, 2540214376u, 2540279657u, 2540279657u)) B(1113u, uvec4(2540279657u, 2540279657u, 2540279912u, 2556926566u)) B(1114u, uvec4(2607127397u, 2623774306u, 2673975392u, 2707333981u)) B(1115u, uvec4(2740823132u, 2757535066u, 2790958937u, 2807670617u)) B(1116u, uvec4(2807670871u, 2841094487u, 2841094487u, 2824382552u)) B(1117u, uvec4(2824447833u, 2807735643u, 2774311774u, 2707464289u)) B(1118u, uvec4(2657327975u, 2557056366u, 2423491199u, 2139062143u)) B(1119u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1120u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1121u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1122u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1123u, uvec4(2135261820u, 2239203953u, 2406388332u, 2490078570u)) B(1124u, uvec4(2506790506u, 2523567722u, 2523567467u, 2506855787u)) B(1125u, uvec4(2506855787u, 2523567722u, 2540214376u, 2573703781u)) B(1126u, uvec4(2607127652u, 2640551521u, 2690687327u, 2707399261u)) B(1127u, uvec4(2740823132u, 2757535067u, 2774181466u, 2790958937u)) B(1128u, uvec4(2807670616u, 2824382552u, 2824382297u, 2807735898u)) B(1129u, uvec4(2791023708u, 2757599839u, 2690752355u, 2623904105u)) B(1130u, uvec4(2523697777u, 2357165951u, 2139062143u, 2139062143u)) B(1131u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1132u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1133u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1134u, uvec4(2139062143u, 2139062143u, 2139062143u, 2135196793u)) B(1135u, uvec4(2289339505u, 2406453613u, 2473366635u, 2506855787u)) B(1136u, uvec4(2490143852u, 2490143852u, 2490143852u, 2490143852u)) B(1137u, uvec4(2490144106u, 2523567977u, 2556926566u, 2590415716u)) B(1138u, uvec4(2640551522u, 2673975136u, 2707399262u, 2724110942u)) B(1139u, uvec4(2740757596u, 2757535067u, 2774246746u, 2790958681u)) B(1140u, uvec4(2807670617u, 2807670363u, 2774246748u, 2740888158u)) B(1141u, uvec4(2707529315u, 2623904360u, 2540409712u, 2390196863u)) B(1142u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1143u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1144u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1145u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1146u, uvec4(2139062143u, 2139062091u, 2189133431u, 2322828657u)) B(1147u, uvec4(2406453613u, 2473431661u, 2473431917u, 2473431662u)) B(1148u, uvec4(2456719982u, 2456719982u, 2456720237u, 2473366891u)) B(1149u, uvec4(2506856041u, 2556991847u, 2573703781u, 2623839587u)) B(1150u, uvec4(2657197921u, 2690687072u, 2707333726u, 2724110942u)) B(1151u, uvec4(2740822877u, 2740757595u, 2774181466u, 2790958427u)) B(1152u, uvec4(2774312028u, 2757599839u, 2707464034u, 2640616295u)) B(1153u, uvec4(2557121647u, 2406909567u, 2139062143u, 2139062143u)) B(1154u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1155u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1156u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1157u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1158u, uvec4(2135458937u, 2289470067u, 2373029744u, 2423230830u)) B(1159u, uvec4(2456719727u, 2440008047u, 2440008047u, 2440008047u)) B(1160u, uvec4(2440008047u, 2440008301u, 2473432172u, 2506790761u)) B(1161u, uvec4(2540279911u, 2590415717u, 2623839331u, 2657263202u)) B(1162u, uvec4(2673975136u, 2690687072u, 2707399007u, 2707399004u)) B(1163u, uvec4(2757469531u, 2774246492u, 2757600093u, 2724176224u)) B(1164u, uvec4(2674040419u, 2623969386u, 2507050871u, 2239725439u)) B(1165u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1166u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1167u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1168u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1169u, uvec4(2139062143u, 2139062143u, 2135590264u, 2306182003u)) B(1170u, uvec4(2373095024u, 2406584176u, 2423296112u, 2406584178u)) B(1171u, uvec4(2389872242u, 2389872242u, 2389872241u, 2406584432u)) B(1172u, uvec4(2439943021u, 2473432171u, 2523567976u, 2573703527u)) B(1173u, uvec4(2590415716u, 2623839332u, 2640551267u, 2640551267u)) B(1174u, uvec4(2657328483u, 2640150789u, 2640094045u, 2740822877u)) B(1175u, uvec4(2740822623u, 2707464034u, 2657328230u, 2573833582u)) B(1176u, uvec4(2423621503u, 2139062143u, 2139062143u, 2139062143u)) B(1177u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1178u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1179u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1180u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1181u, uvec4(1300396934u, 2022209162u, 1955361677u, 1921938061u)) B(1182u, uvec4(1938649996u, 1955361932u, 1972008586u, 1988785547u)) B(1183u, uvec4(1972073868u, 1955361678u, 1922003344u, 1871867539u)) B(1184u, uvec4(1838378133u, 1805019799u, 1754818713u, 1738106777u)) B(1185u, uvec4(1738172058u, 1738106777u, 1738107032u, 1754816131u)) B(1186u, uvec4(127426180u, 93937313u, 1604411297u, 1621058205u)) B(1187u, uvec4(1687971225u, 1771466128u, 1971748735u, 2139062143u)) B(1188u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1189u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1190u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1191u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1192u, uvec4(2139062143u, 2139062143u, 2139050117u, 2038921352u)) B(1193u, uvec4(1988785547u, 1955296651u, 1988720520u, 2038921606u)) B(1194u, uvec4(2055633542u, 2055633542u, 2055633287u, 2038986634u)) B(1195u, uvec4(1988850829u, 1938715279u, 1888579474u, 1855155348u)) B(1196u, uvec4(1821731733u, 1805020053u, 1804954517u, 1821666452u)) B(1197u, uvec4(1821666452u, 1619200404u, 1619265683u, 1636107924u)) B(1198u, uvec4(1636238483u, 1653146004u, 1671193755u, 1738041749u)) B(1199u, uvec4(1854895241u, 2139062143u, 2139062143u, 2139062143u)) B(1200u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1201u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1202u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1203u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1204u, uvec4(2139062143u, 2139051139u, 2072345222u, 2022144390u)) B(1205u, uvec4(2055568769u, 2139062143u, 2139062143u, 2139062143u)) B(1206u, uvec4(2131460733u, 2239400055u, 2323025011u, 2389872497u)) B(1207u, uvec4(2406584432u, 2423361393u, 2406584177u, 2406584178u)) B(1208u, uvec4(2389872227u, 2181860964u, 2198572643u, 2231996005u)) B(1209u, uvec4(2231930214u, 2265288039u, 2298645865u, 2523632750u)) B(1210u, uvec4(2440203640u, 2239725439u, 2139062143u, 2139062143u)) B(1211u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1212u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1213u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1214u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1215u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1216u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1217u, uvec4(2137949052u, 2256176762u, 2272888697u, 2272888696u)) B(1218u, uvec4(2289600632u, 2271773199u, 2271773453u, 2271839243u)) B(1219u, uvec4(2288616458u, 2305393928u, 2322171909u, 2305525763u)) B(1220u, uvec4(2322371438u, 2440268927u, 2139062143u, 2139062143u)) B(1221u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1222u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1223u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1224u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1225u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1226u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1227u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062117u)) B(1228u, uvec4(2198897259u, 2215478634u, 2215413354u, 2215348074u)) B(1229u, uvec4(2231994475u, 2248575339u, 2298579821u, 2456915578u)) B(1230u, uvec4(2189393791u, 2139062143u, 2139062143u, 2139062143u)) B(1231u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1232u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1233u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1234u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1235u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1236u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1237u, uvec4(2139062143u, 2139062143u, 1736670595u, 276982660u)) B(1238u, uvec4(226847364u, 210200964u, 193489285u, 159935367u)) B(1239u, uvec4(76180628u, 1871672712u, 2139062143u, 2139062143u)) B(1240u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1241u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1242u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1243u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1244u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1245u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1246u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1247u, uvec4(1736670596u, 260336004u, 226912645u, 193423749u)) B(1248u, uvec4(193424006u, 126446484u, 1838314124u, 2139062143u)) B(1249u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1250u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1251u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1252u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1253u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1254u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1255u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1256u, uvec4(2139062143u, 1719827844u, 293759364u, 260401284u)) B(1257u, uvec4(243689605u, 210200711u, 143223190u, 1821601680u)) B(1258u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1259u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1260u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1261u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1262u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1263u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1264u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1265u, uvec4(2139062143u, 2139062143u, 2137358973u, 2215674984u)) B(1266u, uvec4(2215609959u, 2232256359u, 2248902760u, 2540344685u)) B(1267u, uvec4(2456980351u, 2139062143u, 2139062143u, 2139062143u)) B(1268u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1269u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1270u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1271u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1272u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1273u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1274u, uvec4(2139062143u, 2139062143u, 2139062143u, 1736643202u)) B(1275u, uvec4(1753485445u, 1736773254u, 1736773254u, 1753745289u)) B(1276u, uvec4(1771465620u, 1871675263u, 2139062143u, 2139062143u)) B(1277u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1278u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1279u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1280u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1281u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1282u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1283u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062118u)) B(1284u, uvec4(2172551954u, 2204664593u, 2238088463u, 2254931213u)) B(1285u, uvec4(2255001705u, 2523697778u, 2340388735u, 2139062143u)) B(1286u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1287u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1288u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1289u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1290u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1291u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1292u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1293u, uvec4(2139056257u, 360802435u, 310667140u, 277178244u)) B(1294u, uvec4(260466585u, 1754753685u, 1854963583u, 2139062143u)) B(1295u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1296u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1297u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1298u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1299u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1300u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1301u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1302u, uvec4(2139062143u, 1719800707u, 1736708484u, 1736708229u)) B(1303u, uvec4(1736773254u, 1754818966u, 1821536906u, 2139062143u)) B(1304u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1305u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1306u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1307u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1308u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1309u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1310u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1311u, uvec4(2139062143u, 2139056515u, 310666884u, 293955205u)) B(1312u, uvec4(260466564u, 76087686u, 1771530900u, 1871675263u)) B(1313u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1314u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1315u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1316u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1317u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1318u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1319u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1320u, uvec4(2139062143u, 2139062143u, 1736512897u, 1753420420u)) B(1321u, uvec4(1736708229u, 1736706179u, 75917463u, 1771465874u)) B(1322u, uvec4(1955102591u, 2139062143u, 2139062143u, 2139062143u)) B(1323u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1324u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1325u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1326u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1327u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1328u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1329u, uvec4(2139062143u, 2139062143u, 2139062143u, 1786909571u)) B(1330u, uvec4(1736708484u, 1736708229u, 1753482376u, 42363031u)) B(1331u, uvec4(1804824972u, 2139062143u, 2139062143u, 2139062143u)) B(1332u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1333u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1334u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1335u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1336u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1337u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1338u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139056513u)) B(1339u, uvec4(2122519171u, 1753419909u, 1753482885u, 75851928u)) B(1340u, uvec4(1788112528u, 2139062143u, 2139062143u, 2139062143u)) B(1341u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1342u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1343u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1344u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1345u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1346u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1347u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062120u)) B(1348u, uvec4(2182316648u, 2215675239u, 2215609705u, 2214823938u)) B(1349u, uvec4(2255066732u, 2457045375u, 2139062143u, 2139062143u)) B(1350u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1351u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1352u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1353u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1354u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1355u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1356u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1357u, uvec4(2139057027u, 293890180u, 243689605u, 75826309u)) B(1358u, uvec4(1788242835u, 1905033087u, 2139062143u, 2139062143u)) B(1359u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1360u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1361u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1362u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1363u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1364u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1365u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1366u, uvec4(2137686545u, 2204730383u, 2238219533u, 2238353153u)) B(1367u, uvec4(2255197295u, 2407497599u, 2139062143u, 2139062143u)) B(1368u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1369u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1370u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1371u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1372u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1373u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1374u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1375u, uvec4(2088856452u, 243559045u, 210135430u, 58917767u)) B(1376u, uvec4(1804889744u, 2139062143u, 2139062143u, 2139062143u)) B(1377u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1378u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1379u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1380u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1381u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1382u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1383u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1384u, uvec4(1787039108u, 1803881094u, 1804011399u, 1821601425u)) B(1385u, uvec4(1971814271u, 2139062143u, 2139062143u, 2139062143u)) B(1386u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1387u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1388u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1389u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1390u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1391u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1392u, uvec4(2139062143u, 2139062143u, 2139062143u, 2137948940u)) B(1393u, uvec4(2204993031u, 2272040044u, 2473562227u, 2323611519u)) B(1394u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1395u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1396u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1397u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1398u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1399u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1400u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1401u, uvec4(2139062143u, 2139062143u, 2137950209u, 2305725038u)) B(1402u, uvec4(2456785011u, 2340388735u, 2139062143u, 2139062143u)) B(1403u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1404u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1405u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1406u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1407u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1408u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1409u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1410u, uvec4(2138017648u, 2440008048u, 2406714239u, 2139062143u)) B(1411u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1412u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1413u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1414u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1415u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1416u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1417u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1418u, uvec4(2139062143u, 2139062129u, 2339606385u, 2406649205u)) B(1419u, uvec4(2306834303u, 2139062143u, 2139062143u, 2139062143u)) B(1420u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1421u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1422u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1423u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1424u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1425u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1426u, uvec4(2139062143u, 2139062143u, 2139062143u, 2138473593u)) B(1427u, uvec4(2322959221u, 2339866495u, 2139062143u, 2139062143u)) B(1428u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1429u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1430u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1431u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1432u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1433u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1434u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1435u, uvec4(2139062143u, 2038594439u, 2038923135u, 2139062143u)) B(1436u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1437u, uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u)) B(1438u, uvec4(2139052032u, 0u, 0u, 0u))\n#endif\n}\n*/\n\nuvec3 decodeRLE(uint id, uint s, uint lp, uint o)\n{\n    id *= 32u;\n    \n#if RESOLUTION == 0\n    // 32px\n    #define DATA_LENGTH 226u\n    const uvec4 data[] = uvec4[](uvec4(2139062143u, 2134279295u, 2139062143u, 2139062019u), uvec4(2239725439u, 2139062143u, 1736514181u, 2139062143u), uvec4(2139062113u, 2181267740u, 2206171007u, 2139062143u), uvec4(1115751553u, 445022079u, 2139062143u, 2134999327u), uvec4(2164425499u, 2222948223u, 2139038850u, 511795073u), uvec4(511909252u, 478420100u, 427885188u, 428284804u), uvec4(2139062143u, 2130936603u, 2233173020u, 2216461340u), uvec4(2233108249u, 2283309079u, 2300021015u, 2300086044u), uvec4(2189393791u, 2137031962u, 2249885210u, 2249885210u), uvec4(2266532119u, 2316732950u, 2316732950u, 2316797977u), uvec4(2256502655u, 2135065113u, 2266531609u, 2266597145u), uvec4(2283309335u, 2316667669u, 2350156821u, 2333444630u), uvec4(2316797978u, 2222948223u, 2132772376u, 2283309080u), uvec4(2283309079u, 2316733205u, 2350156820u, 2350156820u), uvec4(2350156821u, 2333444631u, 2266727295u, 2139054210u), uvec4(478680969u, 378083209u, 394925707u, 361501581u), uvec4(328077966u, 311300750u, 327947404u, 344659593u), uvec4(428244863u, 2136900099u, 2165803279u, 2164689421u), uvec4(2231666958u, 2214955286u, 2333445140u, 2366803729u), uvec4(2400292625u, 2400357906u, 2383580436u, 2350156567u), uvec4(2266792575u, 2139047042u, 394857874u, 244453010u), uvec4(328143758u, 311300751u, 294588815u, 294588815u), uvec4(294589069u, 328012939u, 378083717u, 2139062081u), uvec4(2198835470u, 2450363150u, 2467271185u, 2417069841u), uvec4(2417004560u, 2417069841u, 2400292625u, 2400357652u), uvec4(2333509912u, 2273279871u, 964757121u, 311365521u), uvec4(244518547u, 244519312u, 294588816u, 277876880u), uvec4(277877135u, 294588815u, 311235468u, 361437063u), uvec4(2139062073u, 2164687122u, 2400162062u, 2467205902u), uvec4(2467401745u, 2400292880u, 2417004560u, 2417069841u), uvec4(2400292626u, 2366868501u, 2333575039u, 2139046019u), uvec4(261164690u, 227741331u, 261230992u, 294588816u), uvec4(277876880u, 294588815u, 294588815u, 311235723u), uvec4(378083463u, 2139062082u, 2182580493u, 2450428430u), uvec4(2450755347u, 2383580690u, 2400292625u, 2400292625u), uvec4(2400292626u, 2366868756u, 2333509913u, 2239725439u), uvec4(1065485185u, 394858369u, 109710725u, 76091012u), uvec4(92870283u, 361501837u, 311366031u, 294588815u), uvec4(311300750u, 311235724u, 344659847u, 478314367u), uvec4(2134934044u, 2283243798u, 2300021015u, 2316733205u), uvec4(2350091539u, 2383580690u, 2383580691u, 2350156820u), uvec4(2333509913u, 2256502655u, 2105940104u, 411572360u), uvec4(411572106u, 378213772u, 344724620u, 344724620u), uvec4(344724875u, 361371527u, 461602687u, 2139030658u), uvec4(428284039u, 428284295u, 428349577u, 394925451u), uvec4(361501836u, 361436554u, 378148744u, 444891007u), uvec4(2139045765u, 444996230u, 444996230u, 445061257u), uvec4(394925706u, 378148490u, 378148744u, 428244863u), uvec4(2139054211u, 461708164u, 478420100u, 478485127u), uvec4(428349576u, 394860425u, 394860679u, 478314367u), uvec4(2139062019u, 2183037279u, 2166260509u, 2216461340u), uvec4(2216263938u, 2216265499u, 2222948223u, 2139062143u), uvec4(1098981249u, 42146692u, 2139062143u, 2139062114u), uvec4(2164556058u, 2256502655u, 2139062143u, 2130870787u), uvec4(2166129535u, 2139062143u, 2139056257u, 444956543u), uvec4(2139062143u, 2139030405u, 2139062143u, 2139062143u), uvec4(75792255u, 19712u, 0u, 0u));\n#elif RESOLUTION == 1\n    // 64px\n    #define DATA_LENGTH 1093u\n    const uvec4 data[] = uvec4[](uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2134541116u, 2239725439u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 1485322376u, 998473599u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2132314678u), uvec4(2306834303u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(377555073u, 897779075u, 914980735u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2132115720u, 2184545025u), uvec4(2197914422u, 2306834303u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062099u, 2164949300u, 2181595700u, 2352449151u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2136310025u), uvec4(2184479235u, 2197914421u, 2323611519u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062098u, 2181661235u, 2198307636u), uvec4(2335607167u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2131984703u, 2181595700u, 2198176821u, 2335802239u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2132181257u), uvec4(2184479239u, 2201259062u, 2290057087u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062036u, 2164883764u, 2198242101u), uvec4(2198111286u, 2319025279u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 1434533506u, 125973891u, 92550532u), uvec4(25573001u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2136244607u, 2139062143u), uvec4(58867077u, 998652550u, 981875334u, 981873282u), uvec4(109392771u, 75903876u, 59126923u, 931692415u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139051138u, 1015298694u, 981875333u, 998587269u), uvec4(998587269u, 998587015u, 965228426u, 915092876u), uvec4(881603724u, 898315659u, 797049995u, 798044303u), uvec4(848114827u, 948273023u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2136179515u, 2235139896u), uvec4(2285340983u, 2285471545u, 2268629048u, 2302118199u), uvec4(2318765108u, 2368965938u, 2402389809u, 2402390062u), uvec4(2452460078u, 2452590896u, 2402455092u, 2319090559u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139033988u, 965228169u, 915027594u, 915027594u), uvec4(915027594u, 915092875u, 881669006u, 848244880u), uvec4(814821265u, 798044050u, 764620179u, 764554898u), uvec4(798044303u, 848115081u, 998408063u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 310524551u), uvec4(915027339u, 881603723u, 898315659u, 898315660u), uvec4(881603725u, 848245136u, 814821265u, 781397395u), uvec4(764620180u, 747908244u, 747842963u, 781332113u), uvec4(814691212u, 914915199u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 260257674u, 881603468u), uvec4(881603724u, 881603724u, 864891790u, 848179855u), uvec4(831532946u, 781397395u, 764685460u, 747907989u), uvec4(731196309u, 747908244u, 747908498u, 797979022u), uvec4(864827016u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2131788092u, 2234878771u, 2368900658u), uvec4(2368965939u, 2368965939u, 2385677873u, 2419101999u), uvec4(2452525869u, 2485884203u, 2519373354u, 2519373354u), uvec4(2519373354u, 2519438635u, 2486014765u, 2452590641u), uvec4(2385807929u, 2222948223u, 2139062143u, 2139062143u), uvec4(2139062143u, 2136048182u, 2335411505u, 2385677873u), uvec4(2402389554u, 2385678129u, 2402390064u, 2435813933u), uvec4(2485949739u, 2519373354u, 2536085289u, 2536085289u), uvec4(2536085289u, 2536085035u, 2502661420u, 2469302575u), uvec4(2419231797u, 2306834303u, 2139062143u, 2139062143u), uvec4(2139062143u, 2135458818u, 2218036274u, 2385612592u), uvec4(2402389809u, 2402389809u, 2402390063u, 2452525869u), uvec4(2485949739u, 2519308328u, 2552797224u, 2552797479u), uvec4(2569509159u, 2552862505u, 2536085290u, 2502661165u), uvec4(2469302576u, 2385742902u, 2273279871u, 2139062143u), uvec4(2139062143u, 2139062143u, 1216625548u, 848179344u), uvec4(797978768u, 797978768u, 814755985u, 798109331u), uvec4(764685206u, 714549656u, 681060504u, 681125530u), uvec4(647636889u, 664348569u, 664348568u, 697772439u), uvec4(697707412u, 764554897u, 831403146u, 981630847u), uvec4(2139062143u, 2139062143u, 2139062143u, 2131330563u), uvec4(2201194032u, 2418971182u, 2435748143u, 2419101744u), uvec4(2435813933u, 2485949739u, 2519373608u, 2552797479u), uvec4(2586221094u, 2586221094u, 2586221094u, 2586221094u), uvec4(2586221095u, 2552797225u, 2519373355u, 2485949230u), uvec4(2419232054u, 2273279871u, 2139062143u, 2139062143u), uvec4(2139062087u, 2218493443u, 2217840431u, 2435748397u), uvec4(2452525104u, 2419101743u, 2452525869u, 2485884458u), uvec4(2536085544u, 2569443878u, 2602933029u, 2602933284u), uvec4(2619644964u, 2619644964u, 2602998310u, 2586220840u), uvec4(2552796970u, 2502726445u, 2452655668u, 2335932799u), uvec4(2139062143u, 2139062143u, 2139062143u, 2131330107u), uvec4(2248377393u, 2418905900u, 2469237276u, 2248904989u), uvec4(2265682205u, 2232259118u, 2452460843u, 2519308328u), uvec4(2569509414u, 2586156068u, 2619644964u, 2636356899u), uvec4(2636356899u, 2636422180u, 2619644709u, 2602998310u), uvec4(2569574185u, 2536150316u, 2469302322u, 2369161087u), uvec4(2139062143u, 2139062143u, 2139062143u, 2131264060u), uvec4(2248312366u, 2452460316u, 2215416602u, 2332529180u), uvec4(2349240604u, 2366017821u, 2332463900u, 2282329131u), uvec4(2519373608u, 2569509414u, 2602933029u, 2619579683u), uvec4(2653068834u, 2653134115u, 2636356899u, 2636356899u), uvec4(2636421925u, 2602932775u, 2569574185u, 2519438381u), uvec4(2452655668u, 2323611519u, 2139062143u, 2139062143u), uvec4(2139062031u, 2184545281u, 2267976492u, 2484767749u), uvec4(2484768515u, 2451279874u, 2451345665u, 2451350812u), uvec4(2770240770u, 2619906343u, 2602933029u, 2619645219u), uvec4(2636357154u, 2653068834u, 2653068834u, 2653068834u), uvec4(2653134115u, 2636356645u, 2602933029u, 2586286121u), uvec4(2536150316u, 2452590642u, 2352514431u, 2139062143u), uvec4(2139062143u, 2139062143u, 1333999498u, 764616075u), uvec4(76815013u, 446962852u, 480517285u, 480648357u), uvec4(614278301u, 614278045u, 597566110u, 580854175u), uvec4(564076959u, 564077214u, 580788894u, 580788894u), uvec4(597500828u, 630924698u, 664348568u, 697707412u), uvec4(764490126u, 898137983u, 2139062143u, 2139062143u), uvec4(2139062093u, 2184743467u, 2501681948u, 2736562973u), uvec4(2753340699u, 2786829852u, 2770444323u, 2653134370u), uvec4(2653069089u, 2669781025u, 2669780769u, 2669780769u), uvec4(2669780770u, 2653068834u, 2653068835u, 2619644965u), uvec4(2586221095u, 2552862251u, 2486014511u, 2402585215u), uvec4(2139062143u, 2139062143u, 2139062143u, 1266757507u), uvec4(159851166u, 513940898u, 497229220u, 480582566u), uvec4(463871141u, 547431071u, 580854431u, 564076960u), uvec4(547365024u, 547365279u, 564142240u, 547299743u), uvec4(580788894u, 580789148u, 614213019u, 630859672u), uvec4(680995477u, 747843472u, 848068479u, 2139062143u), uvec4(2139062143u, 2139062074u, 2185069577u, 2233703969u), uvec4(2652872990u, 2736628764u, 2770052635u, 2786895134u), uvec4(2736889890u, 2669781024u, 2686558240u, 2686492704u), uvec4(2686492705u, 2686492704u, 2686492449u, 2669846050u), uvec4(2653068835u, 2619644965u, 2586286120u, 2552862251u), uvec4(2469367858u, 2352514175u, 2139062143u, 2139062143u), uvec4(2139062141u, 2185004296u, 2233769250u, 2652872990u), uvec4(2736628764u, 2770052635u, 2786895134u, 2736889889u), uvec4(2686558240u, 2686558240u, 2686492704u, 2686492959u), uvec4(2703269920u, 2686492449u, 2669846050u, 2653068835u), uvec4(2619644965u, 2586220840u, 2552862251u, 2486014257u), uvec4(2369226367u, 2139062143u, 2139062143u, 2139062140u), uvec4(2185004296u, 2233769250u, 2652872990u, 2736628764u), uvec4(2770052635u, 2786895134u, 2736889889u, 2686558240u), uvec4(2686558240u, 2686492704u, 2686492959u, 2703269920u), uvec4(2686492449u, 2669846050u, 2653068835u, 2619644965u), uvec4(2586220840u, 2552862251u, 2486014257u, 2369226367u), uvec4(2139062143u, 2139062143u, 2139062140u, 2185069577u), uvec4(2233703969u, 2652872990u, 2736628764u, 2770052635u), uvec4(2786895134u, 2736889890u, 2669781024u, 2686558240u), uvec4(2686492704u, 2686492705u, 2686492704u, 2686492449u), uvec4(2669846050u, 2653068835u, 2619644965u, 2586286120u), uvec4(2552862251u, 2469367858u, 2352514175u, 2139062143u), uvec4(2139062143u, 2139062143u, 243347331u, 159851166u), uvec4(513940898u, 497229220u, 480582566u, 463871141u), uvec4(547431071u, 580854431u, 564076960u, 547365024u), uvec4(547365279u, 564142240u, 547299743u, 580788894u), uvec4(580789148u, 614213019u, 630859672u, 680995477u), uvec4(747843472u, 848068479u, 2139062143u, 2139062143u), uvec4(2139062091u, 2184743467u, 2501681948u, 2736562973u), uvec4(2753340699u, 2786829852u, 2770444323u, 2653134370u), uvec4(2653069089u, 2669781025u, 2669780769u, 2669780769u), uvec4(2669780770u, 2653068834u, 2653068835u, 2619644965u), uvec4(2586221095u, 2552862251u, 2486014511u, 2402585215u), uvec4(2139062143u, 2139062143u, 2139062143u, 1300445066u), uvec4(764616075u, 76815013u, 446962852u, 480517285u), uvec4(480648357u, 614278301u, 614278045u, 597566110u), uvec4(580854175u, 564076959u, 564077214u, 580788894u), uvec4(580788894u, 597500828u, 630924698u, 664348568u), uvec4(697707412u, 764490126u, 898137983u, 2139062143u), uvec4(2139062143u, 2139062095u, 2184545281u, 2267976492u), uvec4(2484767749u, 2484768515u, 2451279874u, 2451345665u), uvec4(2451350812u, 2770240770u, 2619906343u, 2602933029u), uvec4(2619645219u, 2636357154u, 2653068834u, 2653068834u), uvec4(2653068834u, 2653134115u, 2636356645u, 2602933029u), uvec4(2586286121u, 2536150316u, 2452590642u, 2352514431u), uvec4(2139062143u, 2139062143u, 2139062143u, 1216494726u), uvec4(42348178u, 764615812u, 210967179u, 127016076u), uvec4(110173325u, 110173579u, 110304392u, 160705430u), uvec4(714549401u, 664413851u, 630924700u, 597500830u), uvec4(580788894u, 597500829u, 597500829u, 597500829u), uvec4(614147483u, 630859673u, 680995222u, 731131282u), uvec4(814625930u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139031172u, 998638468u, 831532435u, 747842962u), uvec4(478546833u, 495389585u, 495259026u, 781331861u), uvec4(731261336u, 681125786u, 647636380u, 614212764u), uvec4(614278045u, 597500829u, 597501084u, 614212763u), uvec4(630924954u, 647571607u, 697772693u, 747843216u), uvec4(848115335u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139031428u, 998638468u, 831467409u, 781331858u), uvec4(781201552u, 814755730u, 781397396u, 731261591u), uvec4(697837721u, 647636635u, 630924699u, 630989980u), uvec4(614212764u, 614212763u, 647636634u, 647571608u), uvec4(680995477u, 747842962u, 814625931u, 998342527u), uvec4(2139062143u, 2139062143u, 2139062143u, 1216742275u), uvec4(864956560u, 781332113u, 781266832u, 814755985u), uvec4(798109076u, 747973526u, 714549400u, 681125786u), uvec4(647636634u, 647636634u, 647636634u, 647636634u), uvec4(647636888u, 681060758u, 714484628u, 747843216u), uvec4(848115335u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062024u, 2218495026u, 2385547311u, 2419101743u), uvec4(2419101744u, 2419101999u, 2452525869u, 2485884458u), uvec4(2536085544u, 2552797224u, 2569443878u, 2586286375u), uvec4(2569509159u, 2569508905u, 2536085289u, 2519438381u), uvec4(2452525361u, 2385807930u, 2189393791u, 2139062143u), uvec4(2139062143u, 2139062143u, 1250165380u, 881603214u), uvec4(831467663u, 831467919u, 831467919u, 831532946u), uvec4(781397396u, 747973526u, 697837720u, 681060504u), uvec4(681125785u, 664348568u, 697772439u, 697772693u), uvec4(731131283u, 781267086u, 864827015u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 276969099u), uvec4(864891278u, 848179599u, 831402638u, 848245135u), uvec4(831533201u, 798109076u, 747973526u, 714484375u), uvec4(697772439u, 697772439u, 697772439u, 697707413u), uvec4(731196563u, 781266832u, 848049545u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 1333869701u), uvec4(898315149u, 848179853u, 864891789u, 864891790u), uvec4(848179600u, 814821266u, 781397396u, 731196310u), uvec4(714484374u, 714484374u, 714484374u, 731196308u), uvec4(764620178u, 797979022u, 881473924u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2131788599u), uvec4(2318699571u, 2352254004u, 2352254004u, 2352188723u), uvec4(2385677874u, 2402390063u, 2452525869u, 2469237804u), uvec4(2485949483u, 2502661419u, 2502726700u, 2485949485u), uvec4(2452590641u, 2385742902u, 2290057087u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139049602u, 981939850u), uvec4(898315404u, 881538443u, 898315659u, 898380940u), uvec4(881668751u, 831533201u, 798043795u, 764620179u), uvec4(764685460u, 747908243u, 764620434u, 781267087u), uvec4(864827016u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139049348u, 965228169u, 915027594u), uvec4(915027594u, 915027594u, 915092875u, 881669006u), uvec4(848244880u, 814821265u, 798044050u, 764620179u), uvec4(764554898u, 798044303u, 848115081u, 998408063u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(1367554949u, 965163144u, 931739528u, 965163399u), uvec4(948451465u, 931739530u, 898380941u, 864891535u), uvec4(831467919u, 831532690u, 764554898u, 798044303u), uvec4(848180362u, 981696383u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2136113724u, 2218427962u), uvec4(2251982139u, 2235270459u, 2235270459u, 2235205433u), uvec4(2285341238u, 2335542324u, 2352254005u, 2335542063u), uvec4(2181335855u, 2435878706u, 2369030968u, 2239725439u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139034753u, 2139062143u, 2130936381u, 2235270714u), uvec4(2251982394u, 2251982386u, 2181465395u, 2198111795u), uvec4(2214823476u, 2335672447u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2132050238u, 2181530165u, 2198176821u), uvec4(2214692406u, 2306834303u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062100u, 2164883764u, 2198242101u, 2198111286u), uvec4(2319025279u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2136375561u, 2184479239u, 2201259062u, 2290057087u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062100u, 2168422920u), uvec4(2184479493u, 2218101561u, 2206171007u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062102u, 2181661235u, 2198307636u), uvec4(2335607167u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139035009u, 159528066u, 58917251u, 898269055u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2132050186u), uvec4(2167702024u, 2184481847u, 2256502655u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 394332290u, 897778051u), uvec4(25376393u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062038u, 2164818229u, 2198176566u, 2306834303u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 1451898505u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062103u), uvec4(2285406267u, 2206171007u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 478362757u, 2139062143u, 2139062143u), uvec4(2139037952u, 0u, 0u, 0u));\n#elif RESOLUTION == 2\n    // 128px\n    #define DATA_LENGTH 5753u\n    const uvec4 data[] = uvec4[](uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139038338u, 2072476039u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2138604665u, 2322959221u), uvec4(2339866495u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062131u), uvec4(2339606385u, 2406649205u, 2306834303u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2138083184u, 2440008048u, 2406714239u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062125u, 2281802094u), uvec4(2456719983u, 2423491455u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139057283u, 209939846u, 126315668u, 1821601680u), uvec4(1938456447u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2137752589u), uvec4(2221638922u, 2255193863u, 2272039790u, 2440398719u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2138997099u, 2215543914u), uvec4(2232190569u, 2248377091u, 2271974510u, 2424274815u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 1753354627u, 1770262405u), uvec4(1753550213u, 1787756934u, 1804889999u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062119u, 2198963304u, 2215544424u), uvec4(2231665924u, 2238355051u, 2473692287u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2137555475u, 2187887632u, 2238153743u), uvec4(2238284803u, 2281866857u, 2523697779u, 2306834303u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139056513u, 2122519171u, 1753419909u), uvec4(1753482885u, 75851928u, 1788112528u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139055746u, 327378820u, 293889924u), uvec4(277178500u, 76022406u, 1754753939u, 1905033087u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062119u, 2165670248u, 2199028839u), uvec4(2215675239u, 2215150340u, 2255001449u, 2523697780u), uvec4(2290057087u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139056259u, 310666884u), uvec4(293955205u, 260466564u, 76087686u, 1771530900u), uvec4(1871675263u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062117u, 2182316903u), uvec4(2215740519u, 2215675239u, 2232321640u, 2557056620u), uvec4(2456980095u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062119u, 2165670248u), uvec4(2199028839u, 2215675239u, 2215609959u, 2573768554u), uvec4(2507051135u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062116u, 2172551954u), uvec4(2204664593u, 2238088463u, 2254931213u, 2255001705u), uvec4(2523697778u, 2340388735u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2137424658u), uvec4(2187887632u, 2238153998u, 2254931214u, 2254997511u), uvec4(2305398379u, 2490339199u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062116u), uvec4(2189263888u, 2221442063u, 2254931213u, 2271708683u), uvec4(2288555882u, 2506986098u, 2340388735u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(1703050628u, 293759364u, 260401284u, 243689605u), uvec4(210200711u, 143223190u, 1821601680u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 1669561732u, 260336004u, 226912645u), uvec4(193423749u, 193424006u, 126446484u, 1838314124u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062116u, 2206040848u, 2188084237u), uvec4(2238350348u, 2271839243u, 2288616713u, 2288748292u), uvec4(2322371695u, 2406844543u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139055747u), uvec4(276982660u, 226847364u, 210135684u, 193424005u), uvec4(159935366u, 109669257u, 25914770u, 1905162882u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 1870888070u), uvec4(2055633543u, 2038921607u, 2038921352u, 2022209671u), uvec4(1753354119u, 1753419143u, 1770261384u, 1770261129u), uvec4(1770326154u, 1770521993u, 1804075914u, 1821601425u), uvec4(1938587519u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2136310651u, 2239399544u, 2272888442u), uvec4(2239594879u, 2139062143u, 2139062143u, 2139062143u), uvec4(193101189u, 2055763850u, 1988916110u, 1922003343u), uvec4(1905291408u, 1905226127u, 1905226127u, 1905226382u), uvec4(1921934210u, 210658435u, 193880965u, 160327045u), uvec4(143484551u, 93153161u, 42822038u, 1804889745u), uvec4(1921874053u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2136245625u, 2272823414u, 2322959220u), uvec4(2339736438u, 2306312313u, 2272888442u, 2256176762u), uvec4(2256176762u, 2256111481u, 2289535606u, 2339671411u), uvec4(2389872496u, 2440008302u, 2473366636u, 2506855787u), uvec4(2523633003u, 2506855788u, 2490143852u, 2490143840u), uvec4(2198443104u, 2215154529u, 2231800929u, 2265224034u), uvec4(2298582115u, 2623839079u, 2557056366u, 2406779263u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139050882u), uvec4(2072410248u, 1988785292u, 1938649742u, 1921872781u), uvec4(1938584716u, 1955362186u, 1988785802u, 1972073867u), uvec4(1972139148u, 1938715279u, 1905291154u, 1855155603u), uvec4(1821731734u, 1788307608u, 1754883993u, 1738106778u), uvec4(1721395097u, 1738106777u, 1754818712u, 1585645464u), uvec4(1585710489u, 1587634081u, 1604411551u, 1654482076u), uvec4(1704552854u, 1838183814u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139049861u, 2022274443u, 1938649742u), uvec4(1888448911u, 1888514192u, 1888448911u, 1921938062u), uvec4(1921938062u, 1921938062u, 1905226128u, 1888579219u), uvec4(1838378388u, 1805019799u, 1754883993u, 1738172059u), uvec4(1687970972u, 1688036253u, 1671259037u, 1671324573u), uvec4(1671257473u, 94198947u, 1570987427u, 1570987426u), uvec4(1604411551u, 1654547356u, 1721330069u, 1854961031u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 1266973064u), uvec4(1988785037u, 1905225872u, 1871802002u, 1855025041u), uvec4(1871802257u, 1871802257u, 1871802257u, 1871802257u), uvec4(1871867283u, 1838443669u, 1788307863u, 1771595674u), uvec4(1721460124u, 1687970718u, 1654547103u, 1637834912u), uvec4(1621123233u, 1604411297u, 1604410532u, 1537563557u), uvec4(1537498276u, 1570987426u, 1604411551u, 1654547356u), uvec4(1721264789u, 1854896005u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139048834u, 2072409994u, 1938649487u, 1871801747u), uvec4(1838312851u, 1838378387u, 1838313106u, 1855090322u), uvec4(1855090322u, 1855155603u, 1821731733u, 1805019544u), uvec4(1754883993u, 1738171804u, 1688036254u, 1637835168u), uvec4(1621123233u, 1587699362u, 1587699363u, 1570987427u), uvec4(1554275237u, 1520851622u, 1520786341u, 1554275492u), uvec4(1570922401u, 1621058205u, 1687906200u, 1788112783u), uvec4(1988525951u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062088u, 2222557300u), uvec4(2356252527u, 2439877484u, 2490078571u, 2506855532u), uvec4(2490143852u, 2490143852u, 2490143852u, 2490143852u), uvec4(2506790506u, 2540279911u, 2590415462u, 2607062371u), uvec4(2657263457u, 2673910111u, 2724110942u, 2724111196u), uvec4(2757534812u, 2774246747u, 2774181466u, 2790893401u), uvec4(2807670617u, 2791023963u, 2774311774u, 2724110689u), uvec4(2657328229u, 2590545771u, 2473627255u, 2189393791u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 1266842757u, 2005561743u, 1855089812u), uvec4(1804954261u, 1788242582u, 1788242582u, 1788177301u), uvec4(1804954517u, 1804954518u, 1788242583u, 1754818713u), uvec4(1738171803u, 1704748189u, 1671324064u, 1621188513u), uvec4(1604476323u, 1571052708u, 1554340773u, 1520851622u), uvec4(1520916903u, 1504139432u, 1487427752u, 1487362471u), uvec4(1520851622u, 1537498276u, 1570922400u, 1637835676u), uvec4(1704552854u, 1821536652u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062084u), uvec4(2222622580u, 2356121965u, 2473301354u, 2523502440u), uvec4(2556991337u, 2540279657u, 2540279657u, 2540279657u), uvec4(2540279657u, 2556991591u, 2590415717u, 2607127651u), uvec4(2657263457u, 2690687326u, 2740822877u, 2757534812u), uvec4(2774181466u, 2807670617u, 2807670617u, 2824317271u), uvec4(2841094487u, 2841094232u, 2824382553u, 2807670618u), uvec4(2774246748u, 2740887904u, 2690752099u, 2607257705u), uvec4(2507051123u, 2323611519u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062084u, 2239334257u), uvec4(2423100266u, 2523502440u, 2556926056u, 2556926311u), uvec4(2557056873u, 2540279657u, 2540279656u, 2573703527u), uvec4(2573703782u, 2607062371u, 2640551522u, 2673910111u), uvec4(2724111197u, 2757469531u, 2790958682u, 2807670617u), uvec4(2824317271u, 2841094487u, 2841094487u, 2841094742u), uvec4(2841094487u, 2841094488u, 2824382298u, 2790958683u), uvec4(2757599838u, 2724175969u, 2657393255u, 2557121646u), uvec4(2423556223u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062085u, 2189198708u, 2372833899u), uvec4(2506725224u, 2556926310u, 2590415207u, 2573703527u), uvec4(2573703527u, 2573703527u, 2573703527u, 2590350181u), uvec4(2623839587u, 2657197921u, 2690687327u, 2724045916u), uvec4(2774247002u, 2790958936u, 2824382807u, 2841094742u), uvec4(2857806422u, 2857806422u, 2857806422u, 2857806422u), uvec4(2857806422u, 2857871703u, 2824382553u, 2791023963u), uvec4(2757599839u, 2707464034u, 2623904360u, 2523697776u), uvec4(2390197375u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139047555u, 2072408209u, 1804954007u), uvec4(1738106522u, 1704617371u, 1704682906u, 1721394842u), uvec4(1721394842u, 1721394842u, 1721460123u, 1704747934u), uvec4(1654612384u, 1621188258u, 1587764644u, 1554340774u), uvec4(1504204968u, 1487493033u, 1470781098u, 1454003628u), uvec4(1420580012u, 1420580012u, 1420580012u, 1420580267u), uvec4(1437291947u, 1437226921u, 1470716071u, 1504139941u), uvec4(1554210210u, 1604346270u, 1671194264u, 1771465873u), uvec4(1921810303u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2135065720u, 2305656065u, 2372573031u), uvec4(2573572709u, 2607062116u, 2607127396u, 2623839078u), uvec4(2590415462u, 2590415716u, 2623839587u, 2640551522u), uvec4(2673975391u, 2724111197u, 2757535066u, 2790958937u), uvec4(2824382807u, 2841029461u, 2874518612u, 2891230292u), uvec4(2891230547u, 2907942227u, 2907942227u, 2907942227u), uvec4(2908007508u, 2874518358u, 2857806167u, 2841159514u), uvec4(2790958428u, 2740887904u, 2674040164u, 2590480490u), uvec4(2490273908u, 2290057087u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139047042u, 2089121419u, 1788242072u), uvec4(1721394587u, 1687970716u, 1671259036u, 1687970972u), uvec4(1687970972u, 1687970972u, 1688036253u, 1671324064u), uvec4(1621188514u, 1587764389u, 1537628839u, 1504139688u), uvec4(1470781099u, 1437291948u, 1420580012u, 1420645293u), uvec4(1387156142u, 1387221423u, 1370444462u, 1387156142u), uvec4(1387090861u, 1420580012u, 1420514986u, 1454004136u), uvec4(1487362726u, 1520786595u, 1587634335u, 1654416794u), uvec4(1754688658u, 1888384644u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 1166310023u, 1803616660u), uvec4(1754818202u, 1687970716u, 1671258782u, 1654481566u), uvec4(1654481821u, 1671259292u, 1687970718u, 1654547103u), uvec4(1637900449u, 1604476324u, 1554340774u, 1520916649u), uvec4(1470715818u, 1454069163u, 1437356974u, 1387156142u), uvec4(1387221423u, 1370444207u, 1370444207u, 1370444207u), uvec4(1370444207u, 1387156142u, 1387156141u, 1420580012u), uvec4(1437226666u, 1470650535u, 1520851621u, 1554210465u), uvec4(1620992924u, 1721264533u, 1838248587u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 1099263367u), uvec4(42690967u, 1738171548u, 1654481566u, 1637769886u), uvec4(1637769886u, 1654481821u, 1671259037u, 1671324318u), uvec4(1654612384u, 1604476579u, 1571052709u, 1537628584u), uvec4(1487493034u, 1454003628u, 1420645293u, 1403933358u), uvec4(1387221423u, 1370443952u, 1353797553u, 1337020337u), uvec4(1337020592u, 1353732272u, 1353732271u, 1387156142u), uvec4(1387156396u, 1420580011u, 1454004136u, 1487362725u), uvec4(1554210210u, 1604346270u, 1687840663u, 1804889743u), uvec4(1971814271u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(914492545u, 1854343046u, 1788307353u, 1704682397u), uvec4(1654546846u, 1637834911u, 1637769631u, 1637769886u), uvec4(1671259038u, 1654546848u, 1621123233u, 1604476579u), uvec4(1554340774u, 1520982185u, 1454003883u, 1437357229u), uvec4(1403868078u, 1370444208u, 1353732273u, 1337020337u), uvec4(1337020337u, 1337020337u, 1337020337u, 1337020337u), uvec4(1337020592u, 1353732271u, 1387156142u, 1387091116u), uvec4(1420514985u, 1470716071u, 1520786340u, 1570922399u), uvec4(1654482330u, 1737976723u, 1888321407u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062065u, 2222622473u, 2221640193u), uvec4(2181203816u, 2573572963u, 2640420704u, 2690621535u), uvec4(2690686816u, 2673975137u, 2673974882u, 2673975137u), uvec4(2690687072u, 2707333981u, 2757535067u, 2790958936u), uvec4(2841094742u, 2874518611u, 2924654162u, 2941366352u), uvec4(2958078032u, 2974724686u, 2991501902u, 3008213837u), uvec4(3008213837u, 3008213838u, 2991501902u, 2991501647u), uvec4(2974855248u, 2941366098u, 2924653908u, 2891230038u), uvec4(2841094233u, 2807670363u, 2740887904u, 2674039910u), uvec4(2573833581u, 2423556479u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062064u, 2289535495u, 2238290021u, 2607062369u), uvec4(2673844319u, 2707333471u, 2690621536u, 2673975137u), uvec4(2673975137u, 2673975137u, 2690622046u, 2740823132u), uvec4(2774181721u, 2824382807u, 2857741396u, 2907942482u), uvec4(2924654416u, 2974789967u, 2991501902u, 2991502157u), uvec4(3008213837u, 3008213837u, 3008213837u, 3008213837u), uvec4(3008213837u, 3008213838u, 2991501647u, 2974855248u), uvec4(2941366098u, 2907941973u, 2874518103u, 2824382298u), uvec4(2774311774u, 2707463779u, 2623969386u, 2490404223u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139041413u, 2039051915u), uvec4(126248858u, 1687970462u, 1621122977u, 1587699106u), uvec4(1570922144u, 1604346016u, 1621123232u, 1621123233u), uvec4(1604411298u, 1587764389u, 1537694120u, 1487492779u), uvec4(1437357229u, 1403933103u, 1370509489u, 1337020338u), uvec4(1303596467u, 1303661748u, 1286884532u, 1286884533u), uvec4(1270172597u, 1270172597u, 1270172597u, 1286819251u), uvec4(1303596467u, 1303531441u, 1337020591u, 1370378926u), uvec4(1403802795u, 1454004136u, 1487362725u, 1554145184u), uvec4(1637770394u, 1754688912u, 1955102591u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 797472650u, 159607180u, 109536668u), uvec4(1654546592u, 1587699107u, 1554209955u, 1570921889u), uvec4(1604346016u, 1621123232u, 1621123233u, 1587764644u), uvec4(1554340774u, 1504204969u, 1470781099u, 1420645294u), uvec4(1387221424u, 1337020338u, 1320373683u, 1303596468u), uvec4(1270172597u, 1270172598u, 1253460662u, 1253460662u), uvec4(1253460662u, 1253460917u, 1270172596u, 1286884532u), uvec4(1303596466u, 1320308656u, 1353732271u, 1387156141u), uvec4(1420514985u, 1470650790u, 1537498530u, 1604280989u), uvec4(1704553108u, 1871609727u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(730494347u, 159672205u, 92890268u, 1654611618u), uvec4(1570987171u, 1554275235u, 1554210209u, 1604346016u), uvec4(1621123232u, 1621188258u, 1587764644u, 1537628840u), uvec4(1487492779u, 1437357229u, 1403933104u, 1353797553u), uvec4(1337085363u, 1303661748u, 1286949813u, 1270172598u), uvec4(1253460407u, 1236748727u, 1236748727u, 1253460662u), uvec4(1253460662u, 1253460662u, 1253395636u, 1286884532u), uvec4(1286819506u, 1320243376u, 1353667245u, 1403803051u), uvec4(1437226920u, 1504009379u, 1587634334u, 1687906199u), uvec4(1821471880u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2133690997u), uvec4(2349368678u, 2382661987u, 2657132637u, 2740757595u), uvec4(2774181211u, 2757469021u, 2707333471u, 2707399007u), uvec4(2707399262u, 2740757851u, 2790958936u, 2841094742u), uvec4(2874453331u, 2924654416u, 2974790222u, 3008213836u), uvec4(3041637707u, 3058349642u, 3058349897u, 3075061577u), uvec4(3075061577u, 3075061577u, 3091773257u, 3075061577u), uvec4(3075061577u, 3075126858u, 3058349387u, 3041702733u), uvec4(3008213838u, 2974789713u, 2941365843u, 2891295318u), uvec4(2841159514u, 2774311774u, 2690817381u, 2573898608u), uvec4(2390720383u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2133623929u, 2316075368u), uvec4(2349303653u, 2382463234u, 2321718879u, 2723980378u), uvec4(2774181466u, 2774181211u, 2724045372u, 2266734908u), uvec4(2283512123u, 2283577660u, 2233377374u, 2724045916u), uvec4(2774181721u, 2841029461u, 2891230546u, 2941366352u), uvec4(2974724941u, 3008214092u, 3041637706u, 3075061577u), uvec4(3075061832u, 3091773512u, 3091773767u, 3108485447u), uvec4(3108485447u, 3108485447u, 3108485448u, 3075061577u), uvec4(3075061577u, 3058414923u, 3041637453u, 3008213583u), uvec4(2974789713u, 2924654163u, 2891295318u, 2841159514u), uvec4(2757599840u, 2657393511u, 2540540021u, 2256502655u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 780499337u, 209938315u, 143091100u), uvec4(1654611363u, 1537563302u, 1504074150u, 998317733u), uvec4(931993251u, 965743777u, 982586529u, 982586529u), uvec4(982521249u, 982390690u, 965482660u, 981932710u), uvec4(1520916649u, 1470780844u, 1420645294u, 1370509489u), uvec4(1337085364u, 1286949813u, 1270237878u, 1236814008u), uvec4(1220102073u, 1203324857u, 1203390138u, 1186612922u), uvec4(1186612922u, 1186612922u, 1186613177u, 1203324856u), uvec4(1220036792u, 1236748726u, 1253460917u, 1270107571u), uvec4(1303531440u, 1353732526u, 1387091115u, 1453938855u), uvec4(1520786595u, 1587569308u, 1721330323u, 1905033087u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2133623930u, 2282456168u, 2315815012u), uvec4(2640420700u, 2757404249u, 2807605049u, 2283316791u), uvec4(2417141047u, 2484118073u, 2517541433u, 2551030329u), uvec4(2551030329u, 2534318649u, 2517607225u, 2450629945u), uvec4(2383652665u, 2300029015u, 2857806676u, 2907942737u), uvec4(2958013006u, 3008213836u, 3041637962u, 3075061577u), uvec4(3091708231u, 3108485702u, 3125197382u, 3141909317u), uvec4(3141909317u, 3141909317u, 3141974598u, 3125197382u), uvec4(3125197382u, 3125262408u, 3091773512u, 3091838538u), uvec4(3058414668u, 3024925518u, 2991566928u, 2941431123u), uvec4(2908007254u, 2824447579u, 2757599840u, 2657393512u), uvec4(2507051135u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062058u, 2248967527u), uvec4(2299038052u, 2623578459u, 2774181465u, 2788854038u), uvec4(2805371408u, 2805307149u, 2755107083u, 2738395914u), uvec4(2721684489u, 2721684489u, 2721684489u, 2738395913u), uvec4(2755172873u, 2788726538u, 2822344718u, 2856027669u), uvec4(2891165266u, 2941366351u, 2991502157u, 3024926026u), uvec4(3075061577u, 3091773512u, 3108485447u, 3125132101u), uvec4(3141909572u, 3158621253u, 3141909317u, 3141909317u), uvec4(3141909317u, 3141909317u, 3141974598u, 3125197382u), uvec4(3108550728u, 3091773258u, 3058349642u, 3041702988u), uvec4(3008278864u, 2958077778u, 2908007253u, 2857871449u), uvec4(2791088735u, 2690817126u, 2557186930u, 2306834303u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 1048930950u, 143287452u, 1571052198u), uvec4(1504066694u, 396834707u, 245839512u, 195442075u), uvec4(161822365u, 144849310u, 128006814u, 111360160u), uvec4(94582944u, 94648479u, 78002122u, 935999386u), uvec4(44972431u, 179261872u, 1353797554u, 1320373684u), uvec4(1286949559u, 1236814008u, 1220102074u, 1186612922u), uvec4(1186678203u, 1169966268u, 1153189052u, 1153189052u), uvec4(1153189052u, 1153189052u, 1169900987u, 1169900987u), uvec4(1169901242u, 1186612921u, 1203325112u, 1219971766u), uvec4(1253395381u, 1286819251u, 1320243375u, 1370379181u), uvec4(1420449704u, 1504074660u, 1570857374u, 1687841173u), uvec4(1871544191u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2134607479u, 2321914972u), uvec4(2757404249u, 2805567758u, 2805438474u, 2805308423u), uvec4(2788597253u, 2771886084u, 2738462978u, 2738463489u), uvec4(2755184696u, 3375941943u, 3392653879u, 3392719176u), uvec4(3108812364u, 3041637962u, 3075061577u, 3091773767u), uvec4(3125197382u, 3141909317u, 3158621252u, 3158621507u), uvec4(3175333187u, 3175333187u, 3175333443u, 3175333187u), uvec4(3175333187u, 3158621253u, 3141909317u, 3141909318u), uvec4(3108485447u, 3108550473u, 3075126858u, 3041637453u), uvec4(3008278863u, 2958143314u, 2907941973u, 2857871449u), uvec4(2791088735u, 2690817127u, 2540540022u, 2206171007u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062078u, 2272627813u, 2606540122u, 2788921102u), uvec4(2805504009u, 2805373958u, 2805309698u, 2788607801u), uvec4(3325675321u, 3359164472u, 3375876663u, 3392653879u), uvec4(3392719419u, 3326589513u, 3091839048u, 3108550983u), uvec4(3108485702u, 3141909317u, 3158621252u, 3175333187u), uvec4(3192045122u, 3192110403u, 3175333187u, 3192045122u), uvec4(3192045122u, 3192110403u, 3175333187u, 3158621253u), uvec4(3141909317u, 3141974343u, 3108485448u, 3075061578u), uvec4(3041637708u, 3008213583u, 2974789713u, 2924719189u), uvec4(2857871449u, 2791023455u, 2690817126u, 2557186930u), uvec4(2323611519u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062072u, 2289405023u, 2181470556u), uvec4(2774116154u, 2533861176u, 3342321719u, 3342387001u), uvec4(3325675321u, 3359164472u, 3375876663u, 3409365814u), uvec4(3409431098u, 3343170886u, 3142040135u, 3125197638u), uvec4(3141909317u, 3158621507u, 3175333443u, 3175333187u), uvec4(3192045122u, 3192045122u, 3192045377u, 3208822338u), uvec4(3192045122u, 3192045122u, 3192110403u, 3158621252u), uvec4(3158686533u, 3141909063u, 3108485447u, 3091838793u), uvec4(3058414923u, 3024991053u, 2991566929u, 2924719188u), uvec4(2874583384u, 2807800925u, 2707529316u, 2590610544u), uvec4(2373943167u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062070u, 2272628063u, 2231736155u), uvec4(2772537096u, 2822489400u, 3342387000u, 3325675065u), uvec4(3325740857u, 3359164727u, 3392588598u, 3409365814u), uvec4(3409431097u, 3359686981u, 3158686790u, 3141909573u), uvec4(3158621507u, 3175398723u, 3175333442u, 3192045122u), uvec4(3208757057u, 3208822338u, 3208757057u, 3208757057u), uvec4(3208822338u, 3192045122u, 3192045123u, 3175332932u), uvec4(3158621253u, 3141909062u, 3125262663u, 3108485193u), uvec4(3075061323u, 3024925773u, 2991566928u, 2958143059u), uvec4(2891295319u, 2824447325u, 2724175715u, 2607322734u), uvec4(2407497599u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062068u, 2272627807u, 2265355607u), uvec4(2839527739u, 3292185913u, 3325675066u, 3308963386u), uvec4(3342452792u, 3375876662u, 3409365814u, 3409365815u), uvec4(3392784446u, 3275996740u, 3175464005u, 3158621508u), uvec4(3175333187u, 3192045122u, 3208822338u, 3192045377u), uvec4(3208757057u, 3208757313u, 3208757057u, 3208757057u), uvec4(3208757058u, 3192045122u, 3192045122u, 3175398468u), uvec4(3158621253u, 3141909062u, 3125262663u, 3091838793u), uvec4(3058414923u, 3024990798u, 2991566929u, 2924719189u), uvec4(2857871449u, 2791023455u, 2690817126u, 2557251957u), uvec4(2239725439u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139036033u, 495344770u, 411785869u), uvec4(143808170u, 1069628611u, 1002781381u, 986004421u), uvec4(986069703u, 969423049u, 935999179u, 919287499u), uvec4(919287755u, 936000454u, 1103119039u, 1136477373u), uvec4(1153254334u, 1119765438u, 1119765183u, 1103053248u), uvec4(1086341567u, 1103053248u, 1086341312u, 1086341567u), uvec4(1103053247u, 1103053247u, 1103053502u, 1119765182u), uvec4(1136411836u, 1153189052u, 1169835706u, 1186613176u), uvec4(1220037046u, 1253460916u, 1303596466u, 1336955310u), uvec4(1387091115u, 1453938855u, 1537498529u, 1637770393u), uvec4(1788113291u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2132116506u, 2237433365u), uvec4(2321190664u, 2420945986u, 3191783996u, 3275539515u), uvec4(3292251451u, 3325740856u, 3375876663u, 3392588598u), uvec4(3409300534u, 3426143031u, 3392849728u, 3242377026u), uvec4(3208822339u, 3192110658u, 3192045377u, 3225534273u), uvec4(3208757312u, 3225468992u, 3225534528u, 3225468992u), uvec4(3225468992u, 3225534273u, 3208757057u, 3208757058u), uvec4(3192045122u, 3175398468u, 3158621253u, 3125197382u), uvec4(3125262408u, 3091838538u, 3058414668u, 3024990799u), uvec4(2958077778u, 2908007254u, 2841159514u, 2774376801u), uvec4(2657393257u, 2490403967u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 344332420u), uvec4(1585845386u, 1535639940u, 177097654u, 1153188796u), uvec4(1048773564u, 1036205252u, 1002781638u, 986134729u), uvec4(935999434u, 919287499u, 902641100u, 902576074u), uvec4(969424579u, 1103119039u, 1119765438u, 1119830718u), uvec4(1119830464u, 1086341567u, 1103118528u, 1086341312u), uvec4(1086406848u, 1086341312u, 1086341312u, 1086341567u), uvec4(1103053247u, 1103053502u, 1119765181u, 1136477372u), uvec4(1153189051u, 1186612922u, 1186547896u, 1219971766u), uvec4(1253395636u, 1303531185u, 1353667246u, 1403737769u), uvec4(1487362725u, 1570857119u, 1671129238u, 1854832511u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139034754u, 2089162883u, 1585910920u, 1552486285u), uvec4(1270171322u, 1169899394u, 79380100u, 29179331u), uvec4(1019558854u, 969423049u, 935999179u, 919287245u), uvec4(885863884u, 902575819u, 969424324u, 1086407359u), uvec4(1119765438u, 1119830718u, 1119830464u, 1086341312u), uvec4(1103118528u, 1086341312u, 1086406593u, 1086341312u), uvec4(1086341312u, 1086341567u, 1103053247u, 1103053247u), uvec4(1119765182u, 1119700156u, 1153189052u, 1169835706u), uvec4(1186613176u, 1220037046u, 1253395636u, 1303531185u), uvec4(1353732526u, 1403803050u, 1470650789u, 1554210719u), uvec4(1671129238u, 1854832511u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139034754u, 2089097347u), uvec4(1602688135u, 1569263500u, 1270236603u, 1169899393u), uvec4(96157315u, 45956547u, 1019493573u, 986200265u), uvec4(935999179u, 919352525u, 885863629u, 902575819u), uvec4(952712389u, 1086407104u, 1119830718u, 1119830464u), uvec4(1103053248u, 1086341312u, 1086406848u, 1086341312u), uvec4(1086406593u, 1069629632u, 1086341312u, 1086341312u), uvec4(1103053247u, 1103053247u, 1119765182u, 1119699901u), uvec4(1153189052u, 1169835706u, 1186613176u, 1220037046u), uvec4(1253460916u, 1303531185u, 1353732526u, 1403803050u), uvec4(1470650789u, 1554210719u, 1671129238u, 1854832511u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139035009u, 2089097346u, 1619399816u, 1552486540u), uvec4(1270171322u, 1186611329u, 79380355u, 45891267u), uvec4(1019493573u, 986200265u, 935999180u, 902575309u), uvec4(885863629u, 902575819u, 952712389u, 1086407104u), uvec4(1119830463u, 1119830464u, 1103053248u, 1086341312u), uvec4(1086406848u, 1086341313u, 1069629377u, 1069629632u), uvec4(1086341312u, 1086341312u, 1103053247u, 1103053247u), uvec4(1119765182u, 1119699901u, 1153189052u, 1153124026u), uvec4(1186613176u, 1220037046u, 1253460916u, 1286819505u), uvec4(1353732526u, 1403803050u, 1470650789u, 1554210719u), uvec4(1671128983u, 1838186367u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139034753u, 2089097346u), uvec4(1619399816u, 1552486540u, 1270171322u, 1186611329u), uvec4(79380355u, 45891267u, 1019493573u, 986200265u), uvec4(935999180u, 902575309u, 885863629u, 902575819u), uvec4(952712389u, 1086407104u, 1119830463u, 1119830464u), uvec4(1103053248u, 1086341312u, 1086406848u, 1086341313u), uvec4(1069629377u, 1069629632u, 1086341312u, 1086341312u), uvec4(1103053247u, 1103053247u, 1119765182u, 1119699901u), uvec4(1153189052u, 1153124026u, 1186613176u, 1220037046u), uvec4(1253460916u, 1286819505u, 1353732526u, 1403803050u), uvec4(1470650789u, 1554210719u, 1671128983u, 1838186367u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139034498u, 2089097347u, 1602688135u, 1569263500u), uvec4(1270236603u, 1169899393u, 96157315u, 45956547u), uvec4(1019493573u, 986200265u, 935999179u, 919352525u), uvec4(885863629u, 902575819u, 952712389u, 1086407104u), uvec4(1119830718u, 1119830464u, 1103053248u, 1086341312u), uvec4(1086406848u, 1086341312u, 1086406593u, 1069629632u), uvec4(1086341312u, 1086341312u, 1103053247u, 1103053247u), uvec4(1119765182u, 1119699901u, 1153189052u, 1169835706u), uvec4(1186613176u, 1220037046u, 1253460916u, 1303531185u), uvec4(1353732526u, 1403803050u, 1470650789u, 1554210719u), uvec4(1671129238u, 1854832511u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139034754u, 2089162883u), uvec4(1585910920u, 1552486285u, 1270171322u, 1169899394u), uvec4(79380100u, 29179331u, 1019558854u, 969423049u), uvec4(935999179u, 919287245u, 885863884u, 902575819u), uvec4(969424324u, 1086407359u, 1119765438u, 1119830718u), uvec4(1119830464u, 1086341312u, 1103118528u, 1086341312u), uvec4(1086406593u, 1086341312u, 1086341312u, 1086341567u), uvec4(1103053247u, 1103053247u, 1119765182u, 1119700156u), uvec4(1153189052u, 1169835706u, 1186613176u, 1220037046u), uvec4(1253395636u, 1303531185u, 1353732526u, 1403803050u), uvec4(1470650789u, 1554210719u, 1671129238u, 1854832511u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062035u, 2249753694u, 2249493083u, 2281800714u), uvec4(2387326532u, 3158555710u, 2198060093u, 3275539515u), uvec4(3309028922u, 3342387511u, 3392653878u, 3409365813u), uvec4(3442854965u, 3426208313u, 3359556417u, 3225599810u), uvec4(3192110658u, 3208822338u, 3208757312u, 3225534273u), uvec4(3225468992u, 3225468992u, 3242246208u, 3225468992u), uvec4(3225468992u, 3225534273u, 3208757057u, 3208822338u), uvec4(3192044867u, 3175398468u, 3158620998u, 3125197382u), uvec4(3108550728u, 3075126858u, 3041702989u, 2991501648u), uvec4(2941431379u, 2874583384u, 2807735645u, 2707464035u), uvec4(2607322734u, 2390720383u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139034756u, 444947590u), uvec4(361388687u, 143674548u, 1119764162u, 1019428036u), uvec4(1002716101u, 1002846919u, 952711114u, 935999179u), uvec4(919287244u, 919353035u, 936000199u, 1086407359u), uvec4(1119830718u, 1136542654u, 1119765183u, 1103118783u), uvec4(1103053248u, 1086341312u, 1086341568u, 1086341312u), uvec4(1086341312u, 1086341567u, 1103053247u, 1103053247u), uvec4(1119765182u, 1119700156u, 1153189052u, 1169835706u), uvec4(1186613176u, 1220037046u, 1253460916u, 1286884786u), uvec4(1336955055u, 1387091115u, 1453938855u, 1520786849u), uvec4(1637770394u, 1771335820u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2132181277u), uvec4(2254209560u, 2337967368u, 2455153215u, 3241984827u), uvec4(3308963130u, 3309028666u, 3325740857u, 3359164727u), uvec4(3392588598u, 3409365814u, 3409431351u, 3392915009u), uvec4(3225599811u, 3175398724u, 3175333442u, 3192110658u), uvec4(3192045377u, 3208757312u, 3225534273u, 3208757312u), uvec4(3225468992u, 3225534273u, 3208757057u, 3208757057u), uvec4(3208822338u, 3192045123u, 3158621252u, 3158621253u), uvec4(3125197382u, 3125262408u, 3091838538u, 3058414669u), uvec4(3008213583u, 2958143058u, 2908007254u, 2841159515u), uvec4(2757599585u, 2657393002u, 2490469247u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(898069900u, 1602684565u, 1470709697u, 1002715845u), uvec4(969292230u, 986004166u, 986134984u, 952711114u), uvec4(919287499u, 919287499u, 935999944u, 1052984254u), uvec4(1153254844u, 1169966269u, 1153254333u, 1136542398u), uvec4(1119830718u, 1119765183u, 1103053247u, 1103053248u), uvec4(1103053247u, 1103053247u, 1103053247u, 1119765182u), uvec4(1119765182u, 1119700156u, 1153189052u, 1169900986u), uvec4(1186613177u, 1203259831u, 1236683701u, 1270107570u), uvec4(1320308656u, 1370379180u, 1437226920u, 1504074659u), uvec4(1604346524u, 1721265297u, 1971683199u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062073u), uvec4(2272628063u, 2231736155u, 2772537096u, 2822489400u), uvec4(3342387000u, 3325675065u, 3325740857u, 3359164727u), uvec4(3392588598u, 3409365814u, 3409431097u, 3359686981u), uvec4(3158686790u, 3141909573u, 3158621507u, 3175398723u), uvec4(3175333442u, 3192045122u, 3208757057u, 3208822338u), uvec4(3208757057u, 3208757057u, 3208822338u, 3192045122u), uvec4(3192045123u, 3175332932u, 3158621253u, 3141909062u), uvec4(3125262663u, 3108485193u, 3075061323u, 3024925773u), uvec4(2991566928u, 2958143059u, 2891295319u, 2824447325u), uvec4(2724175715u, 2607322734u, 2407497599u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062070u), uvec4(2289405023u, 2181470556u, 2774116154u, 2533861176u), uvec4(3342321719u, 3342387001u, 3325675321u, 3359164472u), uvec4(3375876663u, 3409365814u, 3409431098u, 3343170886u), uvec4(3142040135u, 3125197638u, 3141909317u, 3158621507u), uvec4(3175333443u, 3175333187u, 3192045122u, 3192045122u), uvec4(3192045377u, 3208822338u, 3192045122u, 3192045122u), uvec4(3192110403u, 3158621252u, 3158686533u, 3141909063u), uvec4(3108485447u, 3091838793u, 3058414923u, 3024991053u), uvec4(2991566929u, 2924719188u, 2874583384u, 2807800925u), uvec4(2707529316u, 2590610544u, 2373943167u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062073u), uvec4(2272627813u, 2606540122u, 2788921102u, 2805504009u), uvec4(2805373958u, 2805309698u, 2788607801u, 3325675321u), uvec4(3359164472u, 3375876663u, 3392653879u, 3392719419u), uvec4(3326589513u, 3091839048u, 3108550983u, 3108485702u), uvec4(3141909317u, 3158621252u, 3175333187u, 3192045122u), uvec4(3192110403u, 3175333187u, 3192045122u, 3192045122u), uvec4(3192110403u, 3175333187u, 3158621253u, 3141909317u), uvec4(3141974343u, 3108485448u, 3075061578u, 3041637708u), uvec4(3008213583u, 2974789713u, 2924719189u, 2857871449u), uvec4(2791023455u, 2690817126u, 2557186930u, 2323611519u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062075u, 2255981157u, 2623317082u, 2790893369u), uvec4(2433656631u, 2550834997u, 2617746998u, 2651170103u), uvec4(2684658489u, 2701304633u, 2734793784u, 3359164728u), uvec4(3375876663u, 3392653880u, 3376986444u, 3058480459u), uvec4(3058349897u, 3075061832u, 3108485702u, 3125197637u), uvec4(3141909572u, 3158621252u, 3175333187u, 3175333187u), uvec4(3175333187u, 3192110403u, 3175333187u, 3175332932u), uvec4(3158686533u, 3141909317u, 3141974343u, 3108485448u), uvec4(3075061578u, 3058349387u, 3024991054u, 2974789713u), uvec4(2941431123u, 2891295319u, 2824447580u, 2724175970u), uvec4(2624034669u, 2423686015u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2134934890u), uvec4(2248706660u, 2623382618u, 2790893116u, 2249697079u), uvec4(2467211062u, 2550900277u, 2601100598u, 2634588729u), uvec4(2651300154u, 2651235128u, 2684724024u, 2684724280u), uvec4(2667882039u, 3392653879u, 2583866937u, 2399842129u), uvec4(2958078287u, 2991502157u, 3024926026u, 3075061832u), uvec4(3091773767u, 3125197382u, 3125197637u, 3141909572u), uvec4(3158621252u, 3158621252u, 3158621252u, 3158621252u), uvec4(3158686533u, 3141909317u, 3141909318u, 3125197382u), uvec4(3108485448u, 3091773258u, 3058349387u, 3041702733u), uvec4(3008278864u, 2941365843u, 2908006999u, 2824447579u), uvec4(2757599585u, 2657393257u, 2507115903u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139040646u, 210069385u, 143221916u, 1621187493u), uvec4(1520851366u, 982062759u, 915542183u, 899091876u), uvec4(932776867u, 949684898u, 966527394u, 966527394u), uvec4(966527395u, 949684644u, 949619110u, 949422760u), uvec4(965742250u, 998643116u, 1403933359u, 1370509234u), uvec4(1320373684u, 1286949559u, 1236748728u, 1220036793u), uvec4(1203324858u, 1169900987u, 1169966268u, 1153189307u), uvec4(1169900987u, 1169900987u, 1169900987u, 1169900987u), uvec4(1186612922u, 1186612921u, 1220036792u, 1219971766u), uvec4(1253460661u, 1286884531u, 1320243376u, 1353667245u), uvec4(1420514730u, 1470650790u, 1554145184u, 1654417048u), uvec4(1804825225u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139041156u, 2055736196u), uvec4(1753876616u, 1688035743u, 1554274982u, 1504139431u), uvec4(965220518u, 932188837u, 932450466u, 966135458u), uvec4(966266274u, 966266274u, 966200994u, 966135715u), uvec4(965874085u, 965612455u, 965285800u, 1470781099u), uvec4(1420645295u, 1370509234u, 1320373683u, 1286949814u), uvec4(1253525943u, 1236813753u, 1203324858u, 1186612922u), uvec4(1186678203u, 1169900987u, 1169900987u, 1169901242u), uvec4(1186612922u, 1186612922u, 1186613176u, 1220036792u), uvec4(1220037046u, 1253460916u, 1286884531u, 1320308656u), uvec4(1353667245u, 1403868331u, 1453873574u, 1537498530u), uvec4(1620993179u, 1754623632u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062057u), uvec4(2239334668u, 2204601096u, 2271583330u, 2673714011u), uvec4(2774181465u, 2790893115u, 2166269239u, 2367071033u), uvec4(2417271098u, 2434048314u, 2434048314u, 2417336634u), uvec4(2383913529u, 2350425146u, 2266670682u, 2807605591u), uvec4(2857741396u, 2907942481u, 2958078287u, 2991436876u), uvec4(3041637707u, 3058349641u, 3091773512u, 3108485447u), uvec4(3108485447u, 3125197382u, 3125197382u, 3125197382u), uvec4(3125197382u, 3125262663u, 3108485192u, 3091773513u), uvec4(3075061322u, 3058414923u, 3024991053u, 2991566928u), uvec4(2958143058u, 2908007254u, 2841159514u, 2774311774u), uvec4(2690817126u, 2573898609u, 2357165951u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(746879370u, 209807500u, 126313870u, 25232010u), uvec4(1654546338u, 1554274981u, 1520851621u, 1520786338u), uvec4(1570913415u, 463551624u, 463551368u, 480328837u), uvec4(513957538u, 1571052709u, 1520916905u, 1454069164u), uvec4(1420645039u, 1370509489u, 1320373683u, 1303661749u), uvec4(1270172343u, 1236748727u, 1236814008u, 1220036792u), uvec4(1220102073u, 1203324857u, 1203324857u, 1203324857u), uvec4(1203325111u, 1236748727u, 1236748726u, 1270172597u), uvec4(1270107571u, 1303531441u, 1336955310u, 1387156396u), uvec4(1437226665u, 1487362724u, 1570922654u, 1687906199u), uvec4(1838183814u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 764048780u), uvec4(142960270u, 76112798u, 1621122467u, 1554275237u), uvec4(1520786340u, 1537432993u, 1587634081u, 1604411297u), uvec4(1604476579u, 1554340774u, 1520916649u, 1470781099u), uvec4(1420645294u, 1387221169u, 1337085619u, 1303596213u), uvec4(1270172598u, 1253460662u, 1253525943u, 1236748727u), uvec4(1236748727u, 1236748728u, 1219971511u, 1236748727u), uvec4(1236748727u, 1253460662u, 1253395381u, 1286819251u), uvec4(1303596721u, 1336955311u, 1370379180u, 1437226665u), uvec4(1487362725u, 1554210464u, 1654482329u, 1788047502u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2133494389u, 2332656743u), uvec4(2365950308u, 2623709022u, 2724045660u, 2740757595u), uvec4(2740757341u, 2707398752u, 2690687072u, 2690687326u), uvec4(2724111197u, 2757469786u, 2824382806u, 2874518612u), uvec4(2907942481u, 2958078287u, 2974790221u, 3008214092u), uvec4(3024926027u, 3041637707u, 3058349641u, 3075061577u), uvec4(3075061577u, 3075126858u, 3058349642u, 3058349642u), uvec4(3058349388u, 3024925772u, 3024925518u, 2991501648u), uvec4(2958077778u, 2907941973u, 2874518103u, 2824447324u), uvec4(2740887904u, 2657393511u, 2540474740u, 2290057087u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139041416u, 2005535107u, 1770784391u), uvec4(1704747678u, 1621122722u, 1570987171u, 1554210210u), uvec4(1570856864u, 1621123232u, 1621123232u, 1621188259u), uvec4(1571052709u, 1537628584u, 1487493034u, 1454068909u), uvec4(1403933359u, 1370509233u, 1337085619u, 1303596467u), uvec4(1303661493u, 1270172597u, 1270237878u, 1253460662u), uvec4(1253460662u, 1253460662u, 1270172597u, 1270107316u), uvec4(1286884787u, 1303531186u, 1336955056u, 1353667246u), uvec4(1387091115u, 1453938600u, 1504074660u, 1570922399u), uvec4(1654482329u, 1788112782u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139041157u, 2039051915u, 126248858u, 1687970462u), uvec4(1621122977u, 1587699106u, 1570922144u, 1604346016u), uvec4(1621123232u, 1621123233u, 1604411298u, 1587764389u), uvec4(1537694120u, 1487492779u, 1437357229u, 1403933103u), uvec4(1370509489u, 1337020338u, 1303596467u, 1303661748u), uvec4(1286884532u, 1286884533u, 1270172597u, 1270172597u), uvec4(1270172597u, 1286819251u, 1303596467u, 1303531441u), uvec4(1337020591u, 1370378926u, 1403802795u, 1454004136u), uvec4(1487362725u, 1554145184u, 1637770394u, 1754688912u), uvec4(1955102591u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2133887095u), uvec4(2315748713u, 2556795748u, 2640420703u, 2690621790u), uvec4(2707398751u, 2690686817u, 2673975137u, 2673975137u), uvec4(2673975391u, 2724111197u, 2757535066u, 2807670872u), uvec4(2841094741u, 2891230547u, 2924654162u, 2941301071u), uvec4(2974790222u, 2991501902u, 3008213837u, 3008213837u), uvec4(3008213837u, 3008213837u, 3008213837u, 3008213837u), uvec4(3008279118u, 2974789968u, 2958077777u, 2941431123u), uvec4(2891295573u, 2857871448u, 2807735644u, 2740887904u), uvec4(2657328230u, 2557121648u, 2373943167u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2133886074u, 2265547883u, 2315354626u), uvec4(2271779173u, 2606996833u, 2673909855u, 2690621536u), uvec4(2673909601u, 2673975137u, 2657263457u, 2673975392u), uvec4(2690687326u, 2740823132u, 2774247002u, 2807605591u), uvec4(2857806677u, 2891165266u, 2924654417u, 2958078032u), uvec4(2958078286u, 2991501902u, 2991502157u, 3008213837u), uvec4(3008213837u, 3008279118u, 2991501902u, 2974789968u), uvec4(2958077777u, 2941431378u, 2908007508u, 2874583383u), uvec4(2824447833u, 2791023454u, 2707464034u, 2623969641u), uvec4(2506985588u, 2306834303u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139042946u, 209809031u, 126249623u, 1738106267u), uvec4(1671258782u, 1637769631u, 1621057950u, 1637835166u), uvec4(1654547357u, 1671324318u, 1637900448u, 1621188514u), uvec4(1587764389u, 1537628840u, 1487492778u, 1454069164u), uvec4(1420645293u, 1403933103u, 1370509488u, 1353797553u), uvec4(1337020337u, 1337020337u, 1337020337u, 1337020337u), uvec4(1337020337u, 1353732272u, 1353667246u, 1387156141u), uvec4(1420580011u, 1453938601u, 1487362725u, 1537498530u), uvec4(1604280989u, 1704617879u, 1804824717u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062079u, 2238547714u), uvec4(2338953063u, 2590284898u, 2640485985u, 2657263201u), uvec4(2657263202u, 2640551267u, 2640551267u, 2657263202u), uvec4(2673975391u, 2724111197u, 2757535067u, 2790893656u), uvec4(2841094742u, 2857741396u, 2907942227u, 2924654162u), uvec4(2941366097u, 2941300816u, 2974789967u, 2974789967u), uvec4(2974855248u, 2958078032u, 2958077778u, 2924654162u), uvec4(2924719188u, 2891230038u, 2857871448u, 2807735644u), uvec4(2740822623u, 2690752100u, 2590480235u, 2490273653u), uvec4(2273279871u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(1115978375u, 1803616660u, 1754818202u, 1687970716u), uvec4(1671258782u, 1654481566u, 1654481821u, 1671259292u), uvec4(1687970718u, 1654547103u, 1637900449u, 1604476324u), uvec4(1554340774u, 1520916649u, 1470715818u, 1454069163u), uvec4(1437356974u, 1387156142u, 1387221423u, 1370444207u), uvec4(1370444207u, 1370444207u, 1370444207u, 1387156142u), uvec4(1387156141u, 1420580012u, 1437226666u, 1470650535u), uvec4(1520851621u, 1554210465u, 1620992924u, 1721264533u), uvec4(1838248587u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 1115847813u, 1988848278u, 1754818202u), uvec4(1704682652u, 1671193501u, 1671193756u, 1687970972u), uvec4(1687970972u, 1687970973u, 1671259038u, 1637900449u), uvec4(1604476579u, 1554340774u, 1520916903u, 1504204714u), uvec4(1454069163u, 1437357228u, 1420580013u, 1403867822u), uvec4(1387156143u, 1370444207u, 1387156142u, 1387156141u), uvec4(1403868332u, 1420580011u, 1454003882u, 1470650535u), uvec4(1520851621u, 1554210465u, 1621058204u, 1704618134u), uvec4(1821536398u, 1988394879u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062085u, 2222492013u, 2231471466u), uvec4(2540149093u, 2590350180u, 2623839077u, 2607062116u), uvec4(2607192678u, 2590415462u, 2607062116u, 2640551267u), uvec4(2657263457u, 2690622046u, 2740823132u, 2774181466u), uvec4(2807670872u, 2841094486u, 2874518357u, 2891230292u), uvec4(2891230292u, 2907942227u, 2907942227u, 2907942227u), uvec4(2907942228u, 2891230037u, 2874583638u, 2841094488u), uvec4(2807735898u, 2774311774u, 2707464034u, 2640616039u), uvec4(2557121646u, 2423556223u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2135131003u, 2255524203u), uvec4(2506725223u, 2573638245u, 2590350181u, 2607127142u), uvec4(2590415462u, 2590415462u, 2590415462u, 2607127397u), uvec4(2623774306u, 2673975392u, 2707333726u, 2740823132u), uvec4(2774247001u, 2824382552u, 2841094487u, 2857806422u), uvec4(2857741396u, 2891230292u, 2891230292u, 2891230292u), uvec4(2891295573u, 2874518357u, 2857871703u, 2841159513u), uvec4(2807735644u, 2740822623u, 2690752099u, 2623969385u), uvec4(2523697522u, 2357165951u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 1115847813u, 1955425938u), uvec4(1804954007u, 1754818457u, 1721394841u, 1738106777u), uvec4(1738106777u, 1738106777u, 1738106777u, 1738171803u), uvec4(1704748189u, 1671324063u, 1637900449u, 1604476324u), uvec4(1554340774u, 1520851623u, 1487427753u, 1470715818u), uvec4(1454003882u, 1454003882u, 1454003882u, 1454003882u), uvec4(1454003882u, 1454004137u, 1470650536u, 1504074661u), uvec4(1537498530u, 1604411551u, 1654416794u, 1754688658u), uvec4(1888384900u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 1166375303u, 1905290643u), uvec4(1788242327u, 1754818456u, 1754818457u, 1738041751u), uvec4(1771530647u, 1771530647u, 1754883993u, 1738106778u), uvec4(1721459869u, 1671259038u, 1654612129u, 1604476579u), uvec4(1571052453u, 1537628838u, 1520916903u, 1504204713u), uvec4(1470715817u, 1470715817u, 1470715818u, 1453938601u), uvec4(1470715817u, 1487427751u, 1520851622u, 1537498530u), uvec4(1587699616u, 1637770394u, 1738042004u, 1854960776u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2135196794u, 2272562287u, 2439877483u), uvec4(2506790505u, 2540214376u, 2540279657u, 2540279657u), uvec4(2540279657u, 2540279657u, 2540279912u, 2556926566u), uvec4(2607127397u, 2623774306u, 2673975392u, 2707333981u), uvec4(2740823132u, 2757535066u, 2790958937u, 2807670617u), uvec4(2807670871u, 2841094487u, 2841094487u, 2824382552u), uvec4(2824447833u, 2807735643u, 2774311774u, 2707464289u), uvec4(2657327975u, 2557056366u, 2423491199u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2135261820u, 2239203953u, 2406388332u, 2490078570u), uvec4(2506790506u, 2523567722u, 2523567467u, 2506855787u), uvec4(2506855787u, 2523567722u, 2540214376u, 2573703781u), uvec4(2607127652u, 2640551521u, 2690687327u, 2707399261u), uvec4(2740823132u, 2757535067u, 2774181466u, 2790958937u), uvec4(2807670616u, 2824382552u, 2824382297u, 2807735898u), uvec4(2791023708u, 2757599839u, 2690752355u, 2623904105u), uvec4(2523697777u, 2357165951u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2135196793u), uvec4(2289339505u, 2406453613u, 2473366635u, 2506855787u), uvec4(2490143852u, 2490143852u, 2490143852u, 2490143852u), uvec4(2490144106u, 2523567977u, 2556926566u, 2590415716u), uvec4(2640551522u, 2673975136u, 2707399262u, 2724110942u), uvec4(2740757596u, 2757535067u, 2774246746u, 2790958681u), uvec4(2807670617u, 2807670363u, 2774246748u, 2740888158u), uvec4(2707529315u, 2623904360u, 2540409712u, 2390196863u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062091u, 2189133431u, 2322828657u), uvec4(2406453613u, 2473431661u, 2473431917u, 2473431662u), uvec4(2456719982u, 2456719982u, 2456720237u, 2473366891u), uvec4(2506856041u, 2556991847u, 2573703781u, 2623839587u), uvec4(2657197921u, 2690687072u, 2707333726u, 2724110942u), uvec4(2740822877u, 2740757595u, 2774181466u, 2790958427u), uvec4(2774312028u, 2757599839u, 2707464034u, 2640616295u), uvec4(2557121647u, 2406909567u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2135458937u, 2289470067u, 2373029744u, 2423230830u), uvec4(2456719727u, 2440008047u, 2440008047u, 2440008047u), uvec4(2440008047u, 2440008301u, 2473432172u, 2506790761u), uvec4(2540279911u, 2590415717u, 2623839331u, 2657263202u), uvec4(2673975136u, 2690687072u, 2707399007u, 2707399004u), uvec4(2757469531u, 2774246492u, 2757600093u, 2724176224u), uvec4(2674040419u, 2623969386u, 2507050871u, 2239725439u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2135590264u, 2306182003u), uvec4(2373095024u, 2406584176u, 2423296112u, 2406584178u), uvec4(2389872242u, 2389872242u, 2389872241u, 2406584432u), uvec4(2439943021u, 2473432171u, 2523567976u, 2573703527u), uvec4(2590415716u, 2623839332u, 2640551267u, 2640551267u), uvec4(2657328483u, 2640150789u, 2640094045u, 2740822877u), uvec4(2740822623u, 2707464034u, 2657328230u, 2573833582u), uvec4(2423621503u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(1300396934u, 2022209162u, 1955361677u, 1921938061u), uvec4(1938649996u, 1955361932u, 1972008586u, 1988785547u), uvec4(1972073868u, 1955361678u, 1922003344u, 1871867539u), uvec4(1838378133u, 1805019799u, 1754818713u, 1738106777u), uvec4(1738172058u, 1738106777u, 1738107032u, 1754816131u), uvec4(127426180u, 93937313u, 1604411297u, 1621058205u), uvec4(1687971225u, 1771466128u, 1971748735u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139050117u, 2038921352u), uvec4(1988785547u, 1955296651u, 1988720520u, 2038921606u), uvec4(2055633542u, 2055633542u, 2055633287u, 2038986634u), uvec4(1988850829u, 1938715279u, 1888579474u, 1855155348u), uvec4(1821731733u, 1805020053u, 1804954517u, 1821666452u), uvec4(1821666452u, 1619200404u, 1619265683u, 1636107924u), uvec4(1636238483u, 1653146004u, 1671193755u, 1738041749u), uvec4(1854895241u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139051139u, 2072345222u, 2022144390u), uvec4(2055568769u, 2139062143u, 2139062143u, 2139062143u), uvec4(2131460733u, 2239400055u, 2323025011u, 2389872497u), uvec4(2406584432u, 2423361393u, 2406584177u, 2406584178u), uvec4(2389872227u, 2181860964u, 2198572643u, 2231996005u), uvec4(2231930214u, 2265288039u, 2298645865u, 2523632750u), uvec4(2440203640u, 2239725439u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2137949052u, 2256176762u, 2272888697u, 2272888696u), uvec4(2289600632u, 2271773199u, 2271773453u, 2271839243u), uvec4(2288616458u, 2305393928u, 2322171909u, 2305525763u), uvec4(2322371438u, 2440268927u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062117u), uvec4(2198897259u, 2215478634u, 2215413354u, 2215348074u), uvec4(2231994475u, 2248575339u, 2298579821u, 2456915578u), uvec4(2189393791u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 1736670595u, 276982660u), uvec4(226847364u, 210200964u, 193489285u, 159935367u), uvec4(76180628u, 1871672712u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(1736670596u, 260336004u, 226912645u, 193423749u), uvec4(193424006u, 126446484u, 1838314124u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 1719827844u, 293759364u, 260401284u), uvec4(243689605u, 210200711u, 143223190u, 1821601680u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2137358973u, 2215674984u), uvec4(2215609959u, 2232256359u, 2248902760u, 2540344685u), uvec4(2456980351u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 1736643202u), uvec4(1753485445u, 1736773254u, 1736773254u, 1753745289u), uvec4(1771465620u, 1871675263u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062118u), uvec4(2172551954u, 2204664593u, 2238088463u, 2254931213u), uvec4(2255001705u, 2523697778u, 2340388735u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139056257u, 360802435u, 310667140u, 277178244u), uvec4(260466585u, 1754753685u, 1854963583u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 1719800707u, 1736708484u, 1736708229u), uvec4(1736773254u, 1754818966u, 1821536906u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139056515u, 310666884u, 293955205u), uvec4(260466564u, 76087686u, 1771530900u, 1871675263u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 1736512897u, 1753420420u), uvec4(1736708229u, 1736706179u, 75917463u, 1771465874u), uvec4(1955102591u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 1786909571u), uvec4(1736708484u, 1736708229u, 1753482376u, 42363031u), uvec4(1804824972u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139056513u), uvec4(2122519171u, 1753419909u, 1753482885u, 75851928u), uvec4(1788112528u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062120u), uvec4(2182316648u, 2215675239u, 2215609705u, 2214823938u), uvec4(2255066732u, 2457045375u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139057027u, 293890180u, 243689605u, 75826309u), uvec4(1788242835u, 1905033087u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2137686545u, 2204730383u, 2238219533u, 2238353153u), uvec4(2255197295u, 2407497599u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2088856452u, 243559045u, 210135430u, 58917767u), uvec4(1804889744u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(1787039108u, 1803881094u, 1804011399u, 1821601425u), uvec4(1971814271u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2137948940u), uvec4(2204993031u, 2272040044u, 2473562227u, 2323611519u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2137950209u, 2305725038u), uvec4(2456785011u, 2340388735u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2138017648u, 2440008048u, 2406714239u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062129u, 2339606385u, 2406649205u), uvec4(2306834303u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2138473593u), uvec4(2322959221u, 2339866495u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2038594439u, 2038923135u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139062143u, 2139062143u, 2139062143u, 2139062143u), uvec4(2139052032u, 0u, 0u, 0u));\n#endif\n\n    if (iFrame >= 4)\n        return uvec3(o, s, lp);\n\n    uint e = DATA_LENGTH * uint(iFrame);\n    \n    uint i = e;\n    //uint s = 0u;\n    \n    //uint lp = 0u;\n    //uint o = 0u;\n    \n    // Run-length decoding\n    // Stored as 8-bit per data with 1 flag bit and 7 length bits\n    while(i < e + DATA_LENGTH)\n    {\n        uint d = data[i>>4u][(i>>2u)%4u]>>((3u-(i%4u))*8u);\n        uint v = (d >> 7u) & 1u;\n        uint c = d & 127u;\n        \n        if (s + c > id)\n        {\n            \n            uint l = min(s + c - id, 32u) - lp;\n            uint o2 = v == 1u ? (1u << l) - 1u : 0u;\n            \n            o = o | (o2 << lp);\n            lp += l;\n            \n            if (lp >= 32u)\n                return uvec3(o, s, lp);\n        }\n        \n        s += c;\n        i++;\n    }\n    \n    return uvec3(o, s, lp);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint id = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x);\n    \n    if (id * 32u >= VOXEL_COUNT)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if (iFrame < 4 && prev.a < 0.5)\n    {\n        uint s = iFrame == 0 ? 0u : floatBitsToUint(prev.y);\n        uint lp = iFrame == 0 ? 0u : floatBitsToUint(prev.z);\n        uint o = iFrame == 0 ? 0u : floatBitsToUint(prev.x);\n    \n        uvec3 data = decodeRLE(id, s, lp, o);\n    \n\n        fragColor = vec4(uintBitsToFloat(data), data.z >= 32u);\n\n    } else {\n        fragColor = prev;//texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Scene rendering\n\nbool sampleData(vec3 id)\n{\n    uvec3 uid = uvec3(id);\n    \n    uint i = uid.y + uid.x * uint(RES) + uid.z * uint(RES) * uint(RES);\n    \n    uint j = i / 32u;\n    \n    ivec2 coord = ivec2(j % uint(iResolution.x), j / uint(iResolution.x));\n    \n    uint udata = floatBitsToUint(texelFetch(iChannel0, coord, 0).r);\n    \n    return (udata & (1u << (i % 32u))) > 0u;\n}\n\nbool getVoxel(vec3 id)\n{\n    #if 0\n    bool b = length(id - float(RES) * .5) < float(RES) * .5;\n    #else\n    bool b = sampleData(id);\n    #endif\n\n    #ifdef SUBTRACT_MODEL\n    if (iFrame >= 4)\n    {\n        float f = sin(iTime * 1.)*0.6+0.5;\n        vec3 o = vec3(0.2, -1.2, 0.5) * iTime;\n        \n        #if RESOLUTION == 0\n        float scale = 0.2;\n        #elif RESOLUTION == 1\n        float scale = 0.3;\n        #elif RESOLUTION == 2\n        float scale = 0.5;\n        #endif\n        scale *= 64.0 / float(RES);\n        \n        b = b && abs(gyroid(id * scale + o)) > f * 1.2;\n\n        //float f2 = sin(iTime * 1.3)*0.36+0.5;\n        //b = b && id.y < float(RES) * f2;\n    }\n    #endif\n    \n    return b;\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nvec3 getEnvironmentMap(vec3 rd)\n{\n    return mix(pow(textureLod(iChannel1, rd, 0.).rgb, vec3(2.2)), vec3(1), 0.2);\n}\n\nmat4 bayer = mat4(0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef BAYER\n    ivec2 ic = (ivec2(fragCoord))%4;\n    if (int(bayer[ic.x][ic.y]) != iFrame%16)\n        discard;\n    #endif\n    \n    vec3 tot = vec3(0);\n    \n  #if AA > 0\n    for (int x = 0; x <= AA; x++)\n    {\n        for (int y = 0; y <= AA; y++)\n        {\n    \n    vec2 o = (vec2(x, y) - float(AA) * .5) / float(AA+1);\n    \n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n  #else\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n  #endif\n  \n    vec3 ro = vec3(0, 1, 1.8) * .5;\n    vec3 lo = vec3(0, 0, 0);\n    \n    vec2 mp = iMouse.xy / iResolution.xy;\n    float ax = iMouse.z < 0. || iMouse.x == 0. ? -PI * .7 + iTime * .25 : -mp.x * PI;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? 0. : -mp.y * PI + PI * .333;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    \n    vec3 bn;\n    vec2 bb = boxIntersection(ro, rd, vec3(.5), bn);\n    \n    vec3 p = ro + rd * (max(bb.x, 0.0) + 1e-4);\n    \n    vec3 vp = (p + .5) * float(RES);\n    vec3 id = floor(vp);\n    vec3 ird = 1. / rd;\n    vec3 srd = sign(rd);\n    vec3 dd = abs(ird);\n    vec3 sd = ((id - vp) + (srd * .5) + .5) * ird;\n    \n    vec3 m;\n    bool hit = false;\n    \n    vec3 col;\n    \n    if (bb.x > 0.)\n    {\n        for (int i = 0; i < STEPS; i++)\n        {\n            bool b = getVoxel(id);\n            \n            if (b)\n            {\n                hit = true;\n                break;\n            }\n\n            m = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\n            sd += m * srd * ird;\n            id += m * srd;\n\n            if (any(lessThan(id, vec3(0))) || any(greaterThanEqual(id, vec3(RES))))\n                break;\n\n        }\n\n        m = any(bvec3(m)) ? m : abs(bn);\n        \n        vec3 tn = (id / float(RES) - 0.5 - ro - srd * 0.5 / float(RES) + 0.5 / float(RES)) * ird;\n        float t = max(tn.x, max(tn.y, tn.z));\n        \n        p = ro + rd * t;\n        \n        vec3 vuv = fract((p + rd * 1e-6 + 0.5) * float(RES));\n        \n    #if NORMAL_TYPE == 0\n        // Face normal\n        vec3 n = -m * srd;\n    #elif NORMAL_TYPE == 1\n        \n        // Coarse normal\n    \n        float vleft = float(getVoxel(id + vec3(-1, 0, 0)));\n        float vright = float(getVoxel(id + vec3(1, 0, 0)));\n        float vbottom = float(getVoxel(id + vec3(0, -1, 0)));\n        float vtop = float(getVoxel(id + vec3(0, 1, 0)));\n        float vback = float(getVoxel(id + vec3(0, 0, -1)));\n        float vforward = float(getVoxel(id + vec3(0, 0, 1)));\n        \n        vec3 n = normalize(vec3(vleft - vright, vbottom - vtop, vback - vforward));\n        \n        n = dot(n, n) > 0.0 ? n : -m * srd;\n        \n        // Smoother normal\n     #elif NORMAL_TYPE == 2\n        \n        // 3x3x3 area around voxel\n        vec3 n = vec3(0);\n        vec3 no = -m * srd;\n        \n        for (int x = -1; x <= 1; x++)\n            for (int y = -1; y <= 1; y++)\n                for (int z = -1; z <= 1; z++)\n        {\n            vec3 o = vec3(x, y, z);\n            //o += no; // Better but face dependent\n            \n            bool v = getVoxel(id + o);\n            \n            if (!v)\n                n += normalize(o);\n        }\n        \n        n = dot(n, n) > 0.0 ? normalize(n) : -m * srd;\n        \n        // 2x2x3 area aligned toward face normal\n      #elif NORMAL_TYPE == 3\n        \n        vec3 n = vec3(0);\n        \n        vec3 nn = -m * srd;\n        vec3 nt = nn.yzx;\n        vec3 nb = cross(nt, nn);\n        \n        for (int x = -1; x <= 1; x++)\n            for (int y = -1; y <= 1; y++)\n                for (int z = 0; z <= 1; z++)\n        {\n            vec3 o = nn * float(z) + nt * float(x) + nb * float(y);\n            \n            bool v = getVoxel(id + o);\n            \n            if (!v)\n                n += normalize(o);\n        }\n        \n        n = dot(n, n) > 0.0 ? normalize(n) : nn;\n        \n    #endif\n        \n        vec3 ldir = cmat * normalize(vec3(2, 1, 0.5));\n        \n        float fl = step(length(fract(id / 8.0) - 0.5 - (hash33(id) - 0.5)), 0.5);\n        \n        vec3 tuv = id / float(RES);\n    #ifdef TEXTURE_MOVEMENT\n        tuv -= vec3(0.3, 0.2, 0.1) * iTime * 0.3;\n    #endif\n        \n        vec3 tx = pow(texture(iChannel2, tuv.yz - vec2(.952, .032)).rgb, vec3(2.2));\n        vec3 ty = pow(texture(iChannel2, tuv.xz - vec2(.323, .533)).rgb, vec3(2.2));\n        vec3 tz = pow(texture(iChannel2, tuv.yx - vec2(.343, .212)).rgb, vec3(2.2));\n        \n        vec3 w = abs(n);\n        \n        w /= dot(w, vec3(1));\n        \n        vec3 alb = mix(vec3(tx * w.x + ty * w.y + tz * w.z), vec3(1), 0.02);\n        //vec3 alb = palette(hash13(floor(id / 8.0)));\n        vec3 dif = vec3(1);\n        vec3 gl = getEnvironmentMap(reflect(rd, n));\n        float fr = pow(max(dot(-rd, n), 0.), 5.);\n\n        col += mix(dif, gl, 1.-fr) * alb * 0.15;\n        col += max(dot(n, ldir), 0.) * alb * vec3(1, 0.8, 0.6) * 2.5;\n        col += pow(alb.b + alb.g, 2.5) * vec3(0.2, 0.9, 0.9) * 1.0;\n        col *= float(hit);\n        \n    #if NORMAL_TYPE == 0\n        col *= dot(m, vec3(.8, 1., .6));\n    #endif\n        \n    #ifdef SHOW_NORMALS\n        col = n;\n    #endif\n    }\n    if (!hit) {\n        vec3 crd = normalize(vec3(pv, 2));\n        float vig = pow(crd.z, 6.);\n        vec3 w = getEnvironmentMap(rd);\n        vec3 bg = vec3(.95, 0.9, 1) * 0.05 * w;\n        col = vec3(bg * vig);\n    }\n    \n    tot += col;\n    \n  #if AA > 0\n        }\n    }\n    tot /= float((AA+1)*(AA+1));\n  #endif\n  \n    //uint o = floatBitsToUint(texelFetch(iChannel0, ivec2(fragCoord), 0).r);\n    //tot = vec3(o & 255u, (o >> 8u) & 255u, (o >> 16u) & 255u) / 255.;\n    \n    tot = max(tot, vec3(0));\n    fragColor = vec4(tot, 1);\n}", "buffer_b_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// 1D X Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = gaussian1D(iChannel0, fragCoord / iResolution.y, vec2(1, 0), iResolution.xy);\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[746, 746, 803, 803, 1263]], "test": "untested"}
{"id": "cdsGz7", "name": "Voxel Suzanne", "author": "gelami", "description": "A basic voxel example of Suzanne from Blender using Amanatides-Woo's voxel traversal algorithm\nVoxels are stored as 1 bit per voxel in the red channel of Buffer A, with 32 voxels stored pixel\n\nMouse drag to control camera rotation", "tags": ["3d", "voxel", "box", "traversal", "blender", "suzanne"], "likes": 18, "viewed": 712, "published": 3, "date": "1680877708", "time_retrieved": "2024-07-30T18:01:53.025384", "image_code": "\n// Voxel Suzanne by gelami\n// https://www.shadertoy.com/view/cdsGz7\n\n/* \n * A basic voxel traversal of Suzanne from Blender\n * using Amanatides-Woo's voxel traversal algorithm\n *   (A Fast Voxel Traversal Algorithm for Ray Tracing)\n * Voxels are stored as 1 bit per voxel in the red channel of Buffer A,\n *   with 32 voxels stored per pixel\n *\n * Click and drag to control camera rotation\n *\n * Thanks to SebH for the inspiration for this,\n *   and to fb39ca4 for the reference implementation of the voxel traversal algorithm.\n * \n * Bunny Amanatide - SebH\n * https://www.shadertoy.com/view/3sKXDK\n * \n * Branchless Voxel Raycasting - fb39ca4\n * https://www.shadertoy.com/view/4dX3zl\n * \n * Here's my other shader that uses run-length encoding\n *   to better store the voxels and reduce the compile time:\n * \n * Voxel Suzanne RLE - gelami\n * https://www.shadertoy.com/view/mdSGzz\n */\n\nbool sampleData(vec3 id)\n{\n    uvec3 uid = uvec3(id);\n    \n#ifndef HIGH_RES\n    uint i = uid.x + uid.z * uint(RES);\n    \n    ivec2 coord = ivec2(i % uint(iResolution.x), i / uint(iResolution.x));\n    \n    uint udata = floatBitsToUint(texelFetch(iChannel0, coord, 0).r);\n    \n    return (udata & (1u << uid.y)) > 0u;\n#else\n\n    uint i = (uid.x + uid.z * uint(RES)) * 2u + uid.y/32u;\n    \n    ivec2 coord = ivec2(i % uint(iResolution.x), i / uint(iResolution.x));\n    \n    uint udata = floatBitsToUint(texelFetch(iChannel0, coord, 0).r);\n    \n    return (udata & (1u << (uid.y%32u))) > 0u;\n#endif\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nvec3 getEnvironmentMap(vec3 rd)\n{\n    return mix(pow(textureLod(iChannel1, rd, 0.).rgb, vec3(2.2)), vec3(1), 0.2);\n}\n\nmat4 bayer = mat4(0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef BAYER\n    ivec2 ic = (ivec2(fragCoord))%4;\n    if (int(bayer[ic.x][ic.y]) != iFrame%16)\n        discard;\n    #endif\n    \n    vec3 tot = vec3(0);\n    \n  #if AA > 0\n    for (int x = 0; x <= AA; x++)\n    {\n        for (int y = 0; y <= AA; y++)\n        {\n    \n    vec2 o = (vec2(x, y) - float(AA) * .5) / float(AA+1);\n    \n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n  #else\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n  #endif\n  \n    vec3 ro = vec3(0, 1, 1.8) * .5;\n    vec3 lo = vec3(0, 0, 0);\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? -PI * .7 + iTime * .2 : -iMouse.x / iResolution.x * PI;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? 0. : -iMouse.y / iResolution.y * PI + PI * .333;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n    \n    vec3 bn;\n    vec2 bb = boxIntersection(ro, rd, vec3(.5), bn);\n    \n    vec3 p = ro + rd * (bb.x + 1e-4);\n    \n    vec3 vp = (p + .5) * float(RES);\n    vec3 id = floor(vp);\n    vec3 ird = 1. / rd;\n    vec3 srd = sign(rd);\n    vec3 dd = abs(ird);\n    vec3 sd = ((id - vp) + (srd * .5) + .5) * ird;\n    \n    vec3 m;\n    bool hit = false;\n    \n    vec3 col;\n    \n    if (bb.x > 0.)\n    {\n        for (int i = 0; i < STEPS; i++)\n        {\n            #if 0\n            bool b = length(id - float(RES) * .5) < float(RES) * .5;\n            #else\n            bool b = sampleData(id);\n            #endif\n            \n            if (b)\n            {\n                hit = true;\n                break;\n            }\n\n            m = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\n            sd += m * srd * ird;\n            id += m * srd;\n\n            if (any(lessThan(id, vec3(0))) || any(greaterThanEqual(id, vec3(RES))))\n                break;\n\n        }\n\n        m = any(bvec3(m)) ? m : abs(bn);\n        \n        vec3 n = -m * srd;\n\n        vec3 ldir = cmat * normalize(vec3(2., 1., .5));\n        \n        vec3 alb = palette(hash13(id));\n        vec3 dif = vec3(1);\n        vec3 gl = getEnvironmentMap(reflect(rd, n));\n        float fr = pow(max(dot(-rd, n), 0.), 5.);\n\n        col = mix(dif, gl, 1.-fr) * alb;\n        col += max(dot(n, ldir), 0.) * alb;\n        col *= dot(m, vec3(.8, 1., .6));\n        col *= float(hit);\n    }\n    if (!hit) {\n        vec3 crd = normalize(vec3(pv, 2));\n        float vig = pow(crd.z, 6.);\n        vec3 w = getEnvironmentMap(rd);\n        vec3 bg = vec3(.95, 0.9, 1) * 0.05 * w;\n        col = vec3(bg * vig);\n    }\n    \n    tot += col;\n    \n  #if AA > 0\n        }\n    }\n    tot /= float((AA+1)*(AA+1));\n  #endif\n  \n    tot = saturate(tot);\n    tot = tot / (1. + tot);\n    fragColor = vec4(pow(tot, vec3(1./2.2)),1.0);\n    fragColor += hash13(vec3(fragCoord, iTime)) / 256.;\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Might take a while to compile\n// (65s for high res and 5s for low on my machine)\n//#define HIGH_RES\n\n#ifdef HIGH_RES\n  #define RES 64\n  #define STEPS 256\n  #define AA 0\n#else\n  #define RES 32\n  #define STEPS 128\n  #define AA 1\n#endif\n\n//#define BAYER\n\n// Thank you danil for the article\n// https://arugl.medium.com/float-precision-on-gpu-bugs-features-178ddd030f\n#define A(x) uintBitsToFloat(x + uint(iz))\n\n#define PI (acos(-1.))\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0), vec3(1));\n}\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(PI * (vec3(1, .95, .9) * t + vec3(0, .3, .5)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Ray-Box Intersection\n// https://iquilezles.org/articles/intersectors/\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}", "buffer_a_code": "\n\n//const uint data[1024] = uint[1024](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1966080u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 2031616u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 2097152u, 2031616u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1146880u, 917504u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1081344u, 2064384u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 32768u, 1867776u, 983040u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1572864u, 524288u, 0u, 0u, 524288u, 1835008u, 3932160u, 3932160u, 3932160u, 3964928u, 4161536u, 1966080u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 3670016u, 4063232u, 1966080u, 1966080u, 1966080u, 4063232u, 8323072u, 16711680u, 16711680u, 16744448u, 16744448u, 16744448u, 8323072u, 1572864u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 4063232u, 4128768u, 4128768u, 4128768u, 4128768u, 8323072u, 16744448u, 33521664u, 33521664u, 33521664u, 33521664u, 33521664u, 16711680u, 8257536u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 6291456u, 8323072u, 4161536u, 4161536u, 4161536u, 8355840u, 16744448u, 33521664u, 33538048u, 67092480u, 67092480u, 67076096u, 33521664u, 33521664u, 16711680u, 3932160u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 8257536u, 8355840u, 8355840u, 8355840u, 8355840u, 16760832u, 33538048u, 67092480u, 67092480u, 67092480u, 67092480u, 67092480u, 67092480u, 67076096u, 33521664u, 8323072u, 1835008u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 786432u, 16711680u, 16744448u, 8372224u, 8372224u, 16760832u, 33538048u, 67092480u, 67100672u, 134209536u, 134209536u, 134209536u, 134209536u, 67092480u, 67092480u, 33538048u, 16744448u, 8257536u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 9175040u, 16744448u, 16760960u, 8373216u, 8372704u, 16769024u, 33546240u, 67100672u, 134213632u, 134213632u, 134213632u, 134213632u, 134209536u, 134209536u, 67100672u, 67092480u, 33538048u, 8323072u, 1572864u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 12582912u, 16744448u, 8388576u, 8388576u, 8388576u, 33553408u, 67104768u, 67104768u, 134213632u, 134213632u, 134213632u, 134213632u, 134213632u, 134213632u, 67100672u, 67100672u, 33538048u, 16744448u, 4063232u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 7340032u, 8388544u, 8388576u, 8388592u, 16777184u, 33554304u, 67107840u, 67106816u, 134215680u, 134215680u, 134215680u, 134213632u, 134213632u, 134213632u, 134213632u, 67100672u, 33538048u, 16744448u, 8323072u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1056768u, 4194176u, 4194272u, 8388592u, 16777184u, 33554368u, 67107840u, 67106816u, 134215680u, 134215680u, 134215680u, 134215680u, 134213632u, 134213632u, 134213632u, 67100672u, 33546240u, 33538048u, 8323072u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1056768u, 4194176u, 4194272u, 8388592u, 16777184u, 33554368u, 67107840u, 67106816u, 134215680u, 134215680u, 134215680u, 134215680u, 134213632u, 134213632u, 134213632u, 67100672u, 33546240u, 33538048u, 8323072u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 7340032u, 8388544u, 8388576u, 8388592u, 16777184u, 33554304u, 67107840u, 67106816u, 134215680u, 134215680u, 134215680u, 134213632u, 134213632u, 134213632u, 134213632u, 67100672u, 33538048u, 16744448u, 8323072u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 12582912u, 16744448u, 8388576u, 8388576u, 8388576u, 33553408u, 67104768u, 67104768u, 134213632u, 134213632u, 134213632u, 134213632u, 134213632u, 134213632u, 67100672u, 67100672u, 33538048u, 16744448u, 4063232u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 9175040u, 16744448u, 16760960u, 8373216u, 8372704u, 16769024u, 33546240u, 67100672u, 134213632u, 134213632u, 134213632u, 134213632u, 134209536u, 134209536u, 67100672u, 67092480u, 33538048u, 8323072u, 1572864u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 786432u, 16711680u, 16744448u, 8372224u, 8372224u, 16760832u, 33538048u, 67092480u, 67100672u, 134209536u, 134209536u, 134209536u, 134209536u, 67092480u, 67092480u, 33538048u, 16744448u, 8257536u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 8257536u, 8355840u, 8355840u, 8355840u, 8355840u, 16760832u, 33538048u, 67092480u, 67092480u, 67092480u, 67092480u, 67092480u, 67092480u, 67076096u, 33521664u, 8323072u, 1835008u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 6291456u, 8323072u, 4161536u, 4161536u, 4161536u, 8355840u, 16744448u, 33521664u, 33538048u, 67092480u, 67092480u, 67076096u, 33521664u, 33521664u, 16711680u, 3932160u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 4063232u, 4128768u, 4128768u, 4128768u, 4128768u, 8323072u, 16744448u, 33521664u, 33521664u, 33521664u, 33521664u, 33521664u, 16711680u, 8257536u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 3670016u, 4063232u, 1966080u, 1966080u, 1966080u, 4063232u, 8323072u, 16711680u, 16711680u, 16744448u, 16744448u, 16744448u, 8323072u, 1572864u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1572864u, 524288u, 0u, 0u, 524288u, 1835008u, 3932160u, 3932160u, 3932160u, 3964928u, 4161536u, 1966080u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 32768u, 1867776u, 983040u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1081344u, 2064384u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1146880u, 917504u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 2097152u, 2031616u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 2031616u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1966080u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u);\n\n#if 0\n\n#define DAT(i, x) if (id4 == i) { return x[id%4u]; }\n\nuint getData(uint id)\n{\n    if (id >= 1024u)\n        return 0u;\n        \n    uint id4 = id / 4u;\n\n    DAT(0u, uvec4(0u, 0u, 0u, 0u)) DAT(1u, uvec4(0u, 0u, 0u, 0u)) DAT(2u, uvec4(0u, 0u, 0u, 0u)) DAT(3u, uvec4(0u, 0u, 0u, 0u)) DAT(4u, uvec4(0u, 0u, 0u, 0u)) DAT(5u, uvec4(0u, 1966080u, 0u, 0u)) DAT(6u, uvec4(0u, 0u, 0u, 0u)) DAT(7u, uvec4(0u, 0u, 0u, 0u)) DAT(8u, uvec4(0u, 0u, 0u, 0u)) DAT(9u, uvec4(0u, 0u, 0u, 0u)) DAT(10u, uvec4(0u, 0u, 0u, 0u)) DAT(11u, uvec4(0u, 0u, 0u, 0u)) DAT(12u, uvec4(0u, 0u, 0u, 0u)) DAT(13u, uvec4(0u, 2031616u, 0u, 0u)) DAT(14u, uvec4(0u, 0u, 0u, 0u)) DAT(15u, uvec4(0u, 0u, 0u, 0u)) DAT(16u, uvec4(0u, 0u, 0u, 0u)) DAT(17u, uvec4(0u, 0u, 0u, 0u)) DAT(18u, uvec4(0u, 0u, 0u, 0u)) DAT(19u, uvec4(0u, 0u, 0u, 0u)) DAT(20u, uvec4(0u, 0u, 0u, 0u)) DAT(21u, uvec4(2097152u, 2031616u, 0u, 0u)) DAT(22u, uvec4(0u, 0u, 0u, 0u)) DAT(23u, uvec4(0u, 0u, 0u, 0u)) DAT(24u, uvec4(0u, 0u, 0u, 0u)) DAT(25u, uvec4(0u, 0u, 0u, 0u)) DAT(26u, uvec4(0u, 0u, 0u, 0u)) DAT(27u, uvec4(0u, 0u, 0u, 0u)) DAT(28u, uvec4(0u, 0u, 0u, 0u)) DAT(29u, uvec4(1146880u, 917504u, 0u, 0u)) DAT(30u, uvec4(0u, 0u, 0u, 0u)) DAT(31u, uvec4(0u, 0u, 0u, 0u)) DAT(32u, uvec4(0u, 0u, 0u, 0u)) DAT(33u, uvec4(0u, 0u, 0u, 0u)) DAT(34u, uvec4(0u, 0u, 0u, 0u)) DAT(35u, uvec4(0u, 0u, 0u, 0u)) DAT(36u, uvec4(0u, 0u, 0u, 1081344u)) DAT(37u, uvec4(2064384u, 0u, 0u, 0u)) DAT(38u, uvec4(0u, 0u, 0u, 0u)) DAT(39u, uvec4(0u, 0u, 0u, 0u)) DAT(40u, uvec4(0u, 0u, 0u, 0u)) DAT(41u, uvec4(0u, 0u, 0u, 0u)) DAT(42u, uvec4(0u, 0u, 0u, 0u)) DAT(43u, uvec4(0u, 0u, 0u, 0u)) DAT(44u, uvec4(0u, 0u, 32768u, 1867776u)) DAT(45u, uvec4(983040u, 0u, 0u, 0u)) DAT(46u, uvec4(0u, 0u, 0u, 0u)) DAT(47u, uvec4(0u, 0u, 0u, 0u)) DAT(48u, uvec4(0u, 0u, 0u, 0u)) DAT(49u, uvec4(0u, 0u, 0u, 0u)) DAT(50u, uvec4(0u, 1572864u, 524288u, 0u)) DAT(51u, uvec4(0u, 524288u, 1835008u, 3932160u)) DAT(52u, uvec4(3932160u, 3932160u, 3964928u, 4161536u)) DAT(53u, uvec4(1966080u, 0u, 0u, 0u)) DAT(54u, uvec4(0u, 0u, 0u, 0u)) DAT(55u, uvec4(0u, 0u, 0u, 0u)) DAT(56u, uvec4(0u, 0u, 0u, 0u)) DAT(57u, uvec4(0u, 0u, 0u, 0u)) DAT(58u, uvec4(3670016u, 4063232u, 1966080u, 1966080u)) DAT(59u, uvec4(1966080u, 4063232u, 8323072u, 16711680u)) DAT(60u, uvec4(16711680u, 16744448u, 16744448u, 16744448u)) DAT(61u, uvec4(8323072u, 1572864u, 0u, 0u)) DAT(62u, uvec4(0u, 0u, 0u, 0u)) DAT(63u, uvec4(0u, 0u, 0u, 0u)) DAT(64u, uvec4(0u, 0u, 0u, 0u)) DAT(65u, uvec4(0u, 0u, 0u, 0u)) DAT(66u, uvec4(4063232u, 4128768u, 4128768u, 4128768u)) DAT(67u, uvec4(4128768u, 8323072u, 16744448u, 33521664u)) DAT(68u, uvec4(33521664u, 33521664u, 33521664u, 33521664u)) DAT(69u, uvec4(16711680u, 8257536u, 0u, 0u)) DAT(70u, uvec4(0u, 0u, 0u, 0u)) DAT(71u, uvec4(0u, 0u, 0u, 0u)) DAT(72u, uvec4(0u, 0u, 0u, 0u)) DAT(73u, uvec4(0u, 0u, 0u, 6291456u)) DAT(74u, uvec4(8323072u, 4161536u, 4161536u, 4161536u)) DAT(75u, uvec4(8355840u, 16744448u, 33521664u, 33538048u)) DAT(76u, uvec4(67092480u, 67092480u, 67076096u, 33521664u)) DAT(77u, uvec4(33521664u, 16711680u, 3932160u, 0u)) DAT(78u, uvec4(0u, 0u, 0u, 0u)) DAT(79u, uvec4(0u, 0u, 0u, 0u)) DAT(80u, uvec4(0u, 0u, 0u, 0u)) DAT(81u, uvec4(0u, 0u, 0u, 8257536u)) DAT(82u, uvec4(8355840u, 8355840u, 8355840u, 8355840u)) DAT(83u, uvec4(16760832u, 33538048u, 67092480u, 67092480u)) DAT(84u, uvec4(67092480u, 67092480u, 67092480u, 67092480u)) DAT(85u, uvec4(67076096u, 33521664u, 8323072u, 1835008u)) DAT(86u, uvec4(0u, 0u, 0u, 0u)) DAT(87u, uvec4(0u, 0u, 0u, 0u)) DAT(88u, uvec4(0u, 0u, 0u, 0u)) DAT(89u, uvec4(0u, 0u, 786432u, 16711680u)) DAT(90u, uvec4(16744448u, 8372224u, 8372224u, 16760832u)) DAT(91u, uvec4(33538048u, 67092480u, 67100672u, 134209536u)) DAT(92u, uvec4(134209536u, 134209536u, 134209536u, 67092480u)) DAT(93u, uvec4(67092480u, 33538048u, 16744448u, 8257536u)) DAT(94u, uvec4(0u, 0u, 0u, 0u)) DAT(95u, uvec4(0u, 0u, 0u, 0u)) DAT(96u, uvec4(0u, 0u, 0u, 0u)) DAT(97u, uvec4(0u, 0u, 9175040u, 16744448u)) DAT(98u, uvec4(16760960u, 8373216u, 8372704u, 16769024u)) DAT(99u, uvec4(33546240u, 67100672u, 134213632u, 134213632u)) DAT(100u, uvec4(134213632u, 134213632u, 134209536u, 134209536u)) DAT(101u, uvec4(67100672u, 67092480u, 33538048u, 8323072u)) DAT(102u, uvec4(1572864u, 0u, 0u, 0u)) DAT(103u, uvec4(0u, 0u, 0u, 0u)) DAT(104u, uvec4(0u, 0u, 0u, 0u)) DAT(105u, uvec4(0u, 0u, 12582912u, 16744448u)) DAT(106u, uvec4(8388576u, 8388576u, 8388576u, 33553408u)) DAT(107u, uvec4(67104768u, 67104768u, 134213632u, 134213632u)) DAT(108u, uvec4(134213632u, 134213632u, 134213632u, 134213632u)) DAT(109u, uvec4(67100672u, 67100672u, 33538048u, 16744448u)) DAT(110u, uvec4(4063232u, 0u, 0u, 0u)) DAT(111u, uvec4(0u, 0u, 0u, 0u)) DAT(112u, uvec4(0u, 0u, 0u, 0u)) DAT(113u, uvec4(0u, 0u, 7340032u, 8388544u)) DAT(114u, uvec4(8388576u, 8388592u, 16777184u, 33554304u)) DAT(115u, uvec4(67107840u, 67106816u, 134215680u, 134215680u)) DAT(116u, uvec4(134215680u, 134213632u, 134213632u, 134213632u)) DAT(117u, uvec4(134213632u, 67100672u, 33538048u, 16744448u)) DAT(118u, uvec4(8323072u, 0u, 0u, 0u)) DAT(119u, uvec4(0u, 0u, 0u, 0u)) DAT(120u, uvec4(0u, 0u, 0u, 0u)) DAT(121u, uvec4(0u, 0u, 1056768u, 4194176u)) DAT(122u, uvec4(4194272u, 8388592u, 16777184u, 33554368u)) DAT(123u, uvec4(67107840u, 67106816u, 134215680u, 134215680u)) DAT(124u, uvec4(134215680u, 134215680u, 134213632u, 134213632u)) DAT(125u, uvec4(134213632u, 67100672u, 33546240u, 33538048u)) DAT(126u, uvec4(8323072u, 0u, 0u, 0u)) DAT(127u, uvec4(0u, 0u, 0u, 0u)) DAT(128u, uvec4(0u, 0u, 0u, 0u)) DAT(129u, uvec4(0u, 0u, 1056768u, 4194176u)) DAT(130u, uvec4(4194272u, 8388592u, 16777184u, 33554368u)) DAT(131u, uvec4(67107840u, 67106816u, 134215680u, 134215680u)) DAT(132u, uvec4(134215680u, 134215680u, 134213632u, 134213632u)) DAT(133u, uvec4(134213632u, 67100672u, 33546240u, 33538048u)) DAT(134u, uvec4(8323072u, 0u, 0u, 0u)) DAT(135u, uvec4(0u, 0u, 0u, 0u)) DAT(136u, uvec4(0u, 0u, 0u, 0u)) DAT(137u, uvec4(0u, 0u, 7340032u, 8388544u)) DAT(138u, uvec4(8388576u, 8388592u, 16777184u, 33554304u)) DAT(139u, uvec4(67107840u, 67106816u, 134215680u, 134215680u)) DAT(140u, uvec4(134215680u, 134213632u, 134213632u, 134213632u)) DAT(141u, uvec4(134213632u, 67100672u, 33538048u, 16744448u)) DAT(142u, uvec4(8323072u, 0u, 0u, 0u)) DAT(143u, uvec4(0u, 0u, 0u, 0u)) DAT(144u, uvec4(0u, 0u, 0u, 0u)) DAT(145u, uvec4(0u, 0u, 12582912u, 16744448u)) DAT(146u, uvec4(8388576u, 8388576u, 8388576u, 33553408u)) DAT(147u, uvec4(67104768u, 67104768u, 134213632u, 134213632u)) DAT(148u, uvec4(134213632u, 134213632u, 134213632u, 134213632u)) DAT(149u, uvec4(67100672u, 67100672u, 33538048u, 16744448u)) DAT(150u, uvec4(4063232u, 0u, 0u, 0u)) DAT(151u, uvec4(0u, 0u, 0u, 0u)) DAT(152u, uvec4(0u, 0u, 0u, 0u)) DAT(153u, uvec4(0u, 0u, 9175040u, 16744448u)) DAT(154u, uvec4(16760960u, 8373216u, 8372704u, 16769024u)) DAT(155u, uvec4(33546240u, 67100672u, 134213632u, 134213632u)) DAT(156u, uvec4(134213632u, 134213632u, 134209536u, 134209536u)) DAT(157u, uvec4(67100672u, 67092480u, 33538048u, 8323072u)) DAT(158u, uvec4(1572864u, 0u, 0u, 0u)) DAT(159u, uvec4(0u, 0u, 0u, 0u)) DAT(160u, uvec4(0u, 0u, 0u, 0u)) DAT(161u, uvec4(0u, 0u, 786432u, 16711680u)) DAT(162u, uvec4(16744448u, 8372224u, 8372224u, 16760832u)) DAT(163u, uvec4(33538048u, 67092480u, 67100672u, 134209536u)) DAT(164u, uvec4(134209536u, 134209536u, 134209536u, 67092480u)) DAT(165u, uvec4(67092480u, 33538048u, 16744448u, 8257536u)) DAT(166u, uvec4(0u, 0u, 0u, 0u)) DAT(167u, uvec4(0u, 0u, 0u, 0u)) DAT(168u, uvec4(0u, 0u, 0u, 0u)) DAT(169u, uvec4(0u, 0u, 0u, 8257536u)) DAT(170u, uvec4(8355840u, 8355840u, 8355840u, 8355840u)) DAT(171u, uvec4(16760832u, 33538048u, 67092480u, 67092480u)) DAT(172u, uvec4(67092480u, 67092480u, 67092480u, 67092480u)) DAT(173u, uvec4(67076096u, 33521664u, 8323072u, 1835008u)) DAT(174u, uvec4(0u, 0u, 0u, 0u)) DAT(175u, uvec4(0u, 0u, 0u, 0u)) DAT(176u, uvec4(0u, 0u, 0u, 0u)) DAT(177u, uvec4(0u, 0u, 0u, 6291456u)) DAT(178u, uvec4(8323072u, 4161536u, 4161536u, 4161536u)) DAT(179u, uvec4(8355840u, 16744448u, 33521664u, 33538048u)) DAT(180u, uvec4(67092480u, 67092480u, 67076096u, 33521664u)) DAT(181u, uvec4(33521664u, 16711680u, 3932160u, 0u)) DAT(182u, uvec4(0u, 0u, 0u, 0u)) DAT(183u, uvec4(0u, 0u, 0u, 0u)) DAT(184u, uvec4(0u, 0u, 0u, 0u)) DAT(185u, uvec4(0u, 0u, 0u, 0u)) DAT(186u, uvec4(4063232u, 4128768u, 4128768u, 4128768u)) DAT(187u, uvec4(4128768u, 8323072u, 16744448u, 33521664u)) DAT(188u, uvec4(33521664u, 33521664u, 33521664u, 33521664u)) DAT(189u, uvec4(16711680u, 8257536u, 0u, 0u)) DAT(190u, uvec4(0u, 0u, 0u, 0u)) DAT(191u, uvec4(0u, 0u, 0u, 0u)) DAT(192u, uvec4(0u, 0u, 0u, 0u)) DAT(193u, uvec4(0u, 0u, 0u, 0u)) DAT(194u, uvec4(3670016u, 4063232u, 1966080u, 1966080u)) DAT(195u, uvec4(1966080u, 4063232u, 8323072u, 16711680u)) DAT(196u, uvec4(16711680u, 16744448u, 16744448u, 16744448u)) DAT(197u, uvec4(8323072u, 1572864u, 0u, 0u)) DAT(198u, uvec4(0u, 0u, 0u, 0u)) DAT(199u, uvec4(0u, 0u, 0u, 0u)) DAT(200u, uvec4(0u, 0u, 0u, 0u)) DAT(201u, uvec4(0u, 0u, 0u, 0u)) DAT(202u, uvec4(0u, 1572864u, 524288u, 0u)) DAT(203u, uvec4(0u, 524288u, 1835008u, 3932160u)) DAT(204u, uvec4(3932160u, 3932160u, 3964928u, 4161536u)) DAT(205u, uvec4(1966080u, 0u, 0u, 0u)) DAT(206u, uvec4(0u, 0u, 0u, 0u)) DAT(207u, uvec4(0u, 0u, 0u, 0u)) DAT(208u, uvec4(0u, 0u, 0u, 0u)) DAT(209u, uvec4(0u, 0u, 0u, 0u)) DAT(210u, uvec4(0u, 0u, 0u, 0u)) DAT(211u, uvec4(0u, 0u, 0u, 0u)) DAT(212u, uvec4(0u, 0u, 32768u, 1867776u)) DAT(213u, uvec4(983040u, 0u, 0u, 0u)) DAT(214u, uvec4(0u, 0u, 0u, 0u)) DAT(215u, uvec4(0u, 0u, 0u, 0u)) DAT(216u, uvec4(0u, 0u, 0u, 0u)) DAT(217u, uvec4(0u, 0u, 0u, 0u)) DAT(218u, uvec4(0u, 0u, 0u, 0u)) DAT(219u, uvec4(0u, 0u, 0u, 0u)) DAT(220u, uvec4(0u, 0u, 0u, 1081344u)) DAT(221u, uvec4(2064384u, 0u, 0u, 0u)) DAT(222u, uvec4(0u, 0u, 0u, 0u)) DAT(223u, uvec4(0u, 0u, 0u, 0u)) DAT(224u, uvec4(0u, 0u, 0u, 0u)) DAT(225u, uvec4(0u, 0u, 0u, 0u)) DAT(226u, uvec4(0u, 0u, 0u, 0u)) DAT(227u, uvec4(0u, 0u, 0u, 0u)) DAT(228u, uvec4(0u, 0u, 0u, 0u)) DAT(229u, uvec4(1146880u, 917504u, 0u, 0u)) DAT(230u, uvec4(0u, 0u, 0u, 0u)) DAT(231u, uvec4(0u, 0u, 0u, 0u)) DAT(232u, uvec4(0u, 0u, 0u, 0u)) DAT(233u, uvec4(0u, 0u, 0u, 0u)) DAT(234u, uvec4(0u, 0u, 0u, 0u)) DAT(235u, uvec4(0u, 0u, 0u, 0u)) DAT(236u, uvec4(0u, 0u, 0u, 0u)) DAT(237u, uvec4(2097152u, 2031616u, 0u, 0u)) DAT(238u, uvec4(0u, 0u, 0u, 0u)) DAT(239u, uvec4(0u, 0u, 0u, 0u)) DAT(240u, uvec4(0u, 0u, 0u, 0u)) DAT(241u, uvec4(0u, 0u, 0u, 0u)) DAT(242u, uvec4(0u, 0u, 0u, 0u)) DAT(243u, uvec4(0u, 0u, 0u, 0u)) DAT(244u, uvec4(0u, 0u, 0u, 0u)) DAT(245u, uvec4(0u, 2031616u, 0u, 0u)) DAT(246u, uvec4(0u, 0u, 0u, 0u)) DAT(247u, uvec4(0u, 0u, 0u, 0u)) DAT(248u, uvec4(0u, 0u, 0u, 0u)) DAT(249u, uvec4(0u, 0u, 0u, 0u)) DAT(250u, uvec4(0u, 0u, 0u, 0u)) DAT(251u, uvec4(0u, 0u, 0u, 0u)) DAT(252u, uvec4(0u, 0u, 0u, 0u)) DAT(253u, uvec4(0u, 1966080u, 0u, 0u)) DAT(254u, uvec4(0u, 0u, 0u, 0u)) DAT(255u, uvec4(0u, 0u, 0u, 0u))\n\n    return 0u;\n}\n\n#else\n\n#ifndef HIGH_RES\n\n#define DAT(i, x) if (id16 == i) { return x; }\n\nmat4 unpackData(uint id)\n{       \n    uint id16 = id / 16u;\n    \n    int iz = min(iFrame, 0);\n\n    // This is so stupid TT_TT\n    \n    //DAT(0u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(1u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1966080u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(2u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(3u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(2031616u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(4u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(5u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(2097152u), uintBitsToFloat(2031616u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(6u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(7u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1146880u), uintBitsToFloat(917504u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(8u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(9u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1081344u), uintBitsToFloat(2064384u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(10u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(11u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(32768u), uintBitsToFloat(1867776u), uintBitsToFloat(983040u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(12u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1572864u), uintBitsToFloat(524288u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(524288u), uintBitsToFloat(1835008u), uintBitsToFloat(3932160u))) DAT(13u, mat4(uintBitsToFloat(3932160u), uintBitsToFloat(3932160u), uintBitsToFloat(3964928u), uintBitsToFloat(4161536u), uintBitsToFloat(1966080u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(14u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(3670016u), uintBitsToFloat(4063232u), uintBitsToFloat(1966080u), uintBitsToFloat(1966080u), uintBitsToFloat(1966080u), uintBitsToFloat(4063232u), uintBitsToFloat(8323072u), uintBitsToFloat(16711680u))) DAT(15u, mat4(uintBitsToFloat(16711680u), uintBitsToFloat(16744448u), uintBitsToFloat(16744448u), uintBitsToFloat(16744448u), uintBitsToFloat(8323072u), uintBitsToFloat(1572864u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(16u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(4063232u), uintBitsToFloat(4128768u), uintBitsToFloat(4128768u), uintBitsToFloat(4128768u), uintBitsToFloat(4128768u), uintBitsToFloat(8323072u), uintBitsToFloat(16744448u), uintBitsToFloat(33521664u))) DAT(17u, mat4(uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(16711680u), uintBitsToFloat(8257536u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(18u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(6291456u), uintBitsToFloat(8323072u), uintBitsToFloat(4161536u), uintBitsToFloat(4161536u), uintBitsToFloat(4161536u), uintBitsToFloat(8355840u), uintBitsToFloat(16744448u), uintBitsToFloat(33521664u), uintBitsToFloat(33538048u))) DAT(19u, mat4(uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67076096u), uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(16711680u), uintBitsToFloat(3932160u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(20u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(8257536u), uintBitsToFloat(8355840u), uintBitsToFloat(8355840u), uintBitsToFloat(8355840u), uintBitsToFloat(8355840u), uintBitsToFloat(16760832u), uintBitsToFloat(33538048u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u))) DAT(21u, mat4(uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67076096u), uintBitsToFloat(33521664u), uintBitsToFloat(8323072u), uintBitsToFloat(1835008u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(22u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(786432u), uintBitsToFloat(16711680u), uintBitsToFloat(16744448u), uintBitsToFloat(8372224u), uintBitsToFloat(8372224u), uintBitsToFloat(16760832u), uintBitsToFloat(33538048u), uintBitsToFloat(67092480u), uintBitsToFloat(67100672u), uintBitsToFloat(134209536u))) DAT(23u, mat4(uintBitsToFloat(134209536u), uintBitsToFloat(134209536u), uintBitsToFloat(134209536u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(33538048u), uintBitsToFloat(16744448u), uintBitsToFloat(8257536u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(24u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(9175040u), uintBitsToFloat(16744448u), uintBitsToFloat(16760960u), uintBitsToFloat(8373216u), uintBitsToFloat(8372704u), uintBitsToFloat(16769024u), uintBitsToFloat(33546240u), uintBitsToFloat(67100672u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u))) DAT(25u, mat4(uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134209536u), uintBitsToFloat(134209536u), uintBitsToFloat(67100672u), uintBitsToFloat(67092480u), uintBitsToFloat(33538048u), uintBitsToFloat(8323072u), uintBitsToFloat(1572864u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(26u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(12582912u), uintBitsToFloat(16744448u), uintBitsToFloat(8388576u), uintBitsToFloat(8388576u), uintBitsToFloat(8388576u), uintBitsToFloat(33553408u), uintBitsToFloat(67104768u), uintBitsToFloat(67104768u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u))) DAT(27u, mat4(uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(67100672u), uintBitsToFloat(67100672u), uintBitsToFloat(33538048u), uintBitsToFloat(16744448u), uintBitsToFloat(4063232u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(28u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(7340032u), uintBitsToFloat(8388544u), uintBitsToFloat(8388576u), uintBitsToFloat(8388592u), uintBitsToFloat(16777184u), uintBitsToFloat(33554304u), uintBitsToFloat(67107840u), uintBitsToFloat(67106816u), uintBitsToFloat(134215680u), uintBitsToFloat(134215680u))) DAT(29u, mat4(uintBitsToFloat(134215680u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(67100672u), uintBitsToFloat(33538048u), uintBitsToFloat(16744448u), uintBitsToFloat(8323072u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(30u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1056768u), uintBitsToFloat(4194176u), uintBitsToFloat(4194272u), uintBitsToFloat(8388592u), uintBitsToFloat(16777184u), uintBitsToFloat(33554368u), uintBitsToFloat(67107840u), uintBitsToFloat(67106816u), uintBitsToFloat(134215680u), uintBitsToFloat(134215680u))) DAT(31u, mat4(uintBitsToFloat(134215680u), uintBitsToFloat(134215680u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(67100672u), uintBitsToFloat(33546240u), uintBitsToFloat(33538048u), uintBitsToFloat(8323072u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(32u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1056768u), uintBitsToFloat(4194176u), uintBitsToFloat(4194272u), uintBitsToFloat(8388592u), uintBitsToFloat(16777184u), uintBitsToFloat(33554368u), uintBitsToFloat(67107840u), uintBitsToFloat(67106816u), uintBitsToFloat(134215680u), uintBitsToFloat(134215680u))) DAT(33u, mat4(uintBitsToFloat(134215680u), uintBitsToFloat(134215680u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(67100672u), uintBitsToFloat(33546240u), uintBitsToFloat(33538048u), uintBitsToFloat(8323072u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(34u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(7340032u), uintBitsToFloat(8388544u), uintBitsToFloat(8388576u), uintBitsToFloat(8388592u), uintBitsToFloat(16777184u), uintBitsToFloat(33554304u), uintBitsToFloat(67107840u), uintBitsToFloat(67106816u), uintBitsToFloat(134215680u), uintBitsToFloat(134215680u))) DAT(35u, mat4(uintBitsToFloat(134215680u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(67100672u), uintBitsToFloat(33538048u), uintBitsToFloat(16744448u), uintBitsToFloat(8323072u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(36u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(12582912u), uintBitsToFloat(16744448u), uintBitsToFloat(8388576u), uintBitsToFloat(8388576u), uintBitsToFloat(8388576u), uintBitsToFloat(33553408u), uintBitsToFloat(67104768u), uintBitsToFloat(67104768u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u))) DAT(37u, mat4(uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(67100672u), uintBitsToFloat(67100672u), uintBitsToFloat(33538048u), uintBitsToFloat(16744448u), uintBitsToFloat(4063232u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(38u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(9175040u), uintBitsToFloat(16744448u), uintBitsToFloat(16760960u), uintBitsToFloat(8373216u), uintBitsToFloat(8372704u), uintBitsToFloat(16769024u), uintBitsToFloat(33546240u), uintBitsToFloat(67100672u), uintBitsToFloat(134213632u), uintBitsToFloat(134213632u))) DAT(39u, mat4(uintBitsToFloat(134213632u), uintBitsToFloat(134213632u), uintBitsToFloat(134209536u), uintBitsToFloat(134209536u), uintBitsToFloat(67100672u), uintBitsToFloat(67092480u), uintBitsToFloat(33538048u), uintBitsToFloat(8323072u), uintBitsToFloat(1572864u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(40u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(786432u), uintBitsToFloat(16711680u), uintBitsToFloat(16744448u), uintBitsToFloat(8372224u), uintBitsToFloat(8372224u), uintBitsToFloat(16760832u), uintBitsToFloat(33538048u), uintBitsToFloat(67092480u), uintBitsToFloat(67100672u), uintBitsToFloat(134209536u))) DAT(41u, mat4(uintBitsToFloat(134209536u), uintBitsToFloat(134209536u), uintBitsToFloat(134209536u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(33538048u), uintBitsToFloat(16744448u), uintBitsToFloat(8257536u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(42u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(8257536u), uintBitsToFloat(8355840u), uintBitsToFloat(8355840u), uintBitsToFloat(8355840u), uintBitsToFloat(8355840u), uintBitsToFloat(16760832u), uintBitsToFloat(33538048u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u))) DAT(43u, mat4(uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67076096u), uintBitsToFloat(33521664u), uintBitsToFloat(8323072u), uintBitsToFloat(1835008u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(44u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(6291456u), uintBitsToFloat(8323072u), uintBitsToFloat(4161536u), uintBitsToFloat(4161536u), uintBitsToFloat(4161536u), uintBitsToFloat(8355840u), uintBitsToFloat(16744448u), uintBitsToFloat(33521664u), uintBitsToFloat(33538048u))) DAT(45u, mat4(uintBitsToFloat(67092480u), uintBitsToFloat(67092480u), uintBitsToFloat(67076096u), uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(16711680u), uintBitsToFloat(3932160u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(46u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(4063232u), uintBitsToFloat(4128768u), uintBitsToFloat(4128768u), uintBitsToFloat(4128768u), uintBitsToFloat(4128768u), uintBitsToFloat(8323072u), uintBitsToFloat(16744448u), uintBitsToFloat(33521664u))) DAT(47u, mat4(uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(33521664u), uintBitsToFloat(16711680u), uintBitsToFloat(8257536u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(48u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(3670016u), uintBitsToFloat(4063232u), uintBitsToFloat(1966080u), uintBitsToFloat(1966080u), uintBitsToFloat(1966080u), uintBitsToFloat(4063232u), uintBitsToFloat(8323072u), uintBitsToFloat(16711680u))) DAT(49u, mat4(uintBitsToFloat(16711680u), uintBitsToFloat(16744448u), uintBitsToFloat(16744448u), uintBitsToFloat(16744448u), uintBitsToFloat(8323072u), uintBitsToFloat(1572864u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(50u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1572864u), uintBitsToFloat(524288u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(524288u), uintBitsToFloat(1835008u), uintBitsToFloat(3932160u))) DAT(51u, mat4(uintBitsToFloat(3932160u), uintBitsToFloat(3932160u), uintBitsToFloat(3964928u), uintBitsToFloat(4161536u), uintBitsToFloat(1966080u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(52u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(53u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(32768u), uintBitsToFloat(1867776u), uintBitsToFloat(983040u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(54u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(55u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1081344u), uintBitsToFloat(2064384u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(56u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(57u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1146880u), uintBitsToFloat(917504u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(58u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(59u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(2097152u), uintBitsToFloat(2031616u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(60u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(61u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(2031616u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(62u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u))) DAT(63u, mat4(uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(1966080u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u)))\n    DAT(0u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(1u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(1966080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(2u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(3u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(2031616u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(4u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(5u, mat4(A(0u), A(0u), A(0u), A(0u), A(2097152u), A(2031616u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(6u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(7u, mat4(A(0u), A(0u), A(0u), A(0u), A(1146880u), A(917504u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(8u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(9u, mat4(A(0u), A(0u), A(0u), A(1081344u), A(2064384u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(10u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(11u, mat4(A(0u), A(0u), A(32768u), A(1867776u), A(983040u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(12u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1572864u), A(524288u), A(0u), A(0u), A(524288u), A(1835008u), A(3932160u))) DAT(13u, mat4(A(3932160u), A(3932160u), A(3964928u), A(4161536u), A(1966080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(14u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3670016u), A(4063232u), A(1966080u), A(1966080u), A(1966080u), A(4063232u), A(8323072u), A(16711680u))) DAT(15u, mat4(A(16711680u), A(16744448u), A(16744448u), A(16744448u), A(8323072u), A(1572864u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(16u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(4063232u), A(4128768u), A(4128768u), A(4128768u), A(4128768u), A(8323072u), A(16744448u), A(33521664u))) DAT(17u, mat4(A(33521664u), A(33521664u), A(33521664u), A(33521664u), A(16711680u), A(8257536u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(18u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6291456u), A(8323072u), A(4161536u), A(4161536u), A(4161536u), A(8355840u), A(16744448u), A(33521664u), A(33538048u))) DAT(19u, mat4(A(67092480u), A(67092480u), A(67076096u), A(33521664u), A(33521664u), A(16711680u), A(3932160u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(20u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(8257536u), A(8355840u), A(8355840u), A(8355840u), A(8355840u), A(16760832u), A(33538048u), A(67092480u), A(67092480u))) DAT(21u, mat4(A(67092480u), A(67092480u), A(67092480u), A(67092480u), A(67076096u), A(33521664u), A(8323072u), A(1835008u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(22u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(786432u), A(16711680u), A(16744448u), A(8372224u), A(8372224u), A(16760832u), A(33538048u), A(67092480u), A(67100672u), A(134209536u))) DAT(23u, mat4(A(134209536u), A(134209536u), A(134209536u), A(67092480u), A(67092480u), A(33538048u), A(16744448u), A(8257536u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(24u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(9175040u), A(16744448u), A(16760960u), A(8373216u), A(8372704u), A(16769024u), A(33546240u), A(67100672u), A(134213632u), A(134213632u))) DAT(25u, mat4(A(134213632u), A(134213632u), A(134209536u), A(134209536u), A(67100672u), A(67092480u), A(33538048u), A(8323072u), A(1572864u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(26u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(12582912u), A(16744448u), A(8388576u), A(8388576u), A(8388576u), A(33553408u), A(67104768u), A(67104768u), A(134213632u), A(134213632u))) DAT(27u, mat4(A(134213632u), A(134213632u), A(134213632u), A(134213632u), A(67100672u), A(67100672u), A(33538048u), A(16744448u), A(4063232u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(28u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(7340032u), A(8388544u), A(8388576u), A(8388592u), A(16777184u), A(33554304u), A(67107840u), A(67106816u), A(134215680u), A(134215680u))) DAT(29u, mat4(A(134215680u), A(134213632u), A(134213632u), A(134213632u), A(134213632u), A(67100672u), A(33538048u), A(16744448u), A(8323072u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(30u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1056768u), A(4194176u), A(4194272u), A(8388592u), A(16777184u), A(33554368u), A(67107840u), A(67106816u), A(134215680u), A(134215680u))) DAT(31u, mat4(A(134215680u), A(134215680u), A(134213632u), A(134213632u), A(134213632u), A(67100672u), A(33546240u), A(33538048u), A(8323072u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(32u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1056768u), A(4194176u), A(4194272u), A(8388592u), A(16777184u), A(33554368u), A(67107840u), A(67106816u), A(134215680u), A(134215680u))) DAT(33u, mat4(A(134215680u), A(134215680u), A(134213632u), A(134213632u), A(134213632u), A(67100672u), A(33546240u), A(33538048u), A(8323072u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(34u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(7340032u), A(8388544u), A(8388576u), A(8388592u), A(16777184u), A(33554304u), A(67107840u), A(67106816u), A(134215680u), A(134215680u))) DAT(35u, mat4(A(134215680u), A(134213632u), A(134213632u), A(134213632u), A(134213632u), A(67100672u), A(33538048u), A(16744448u), A(8323072u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(36u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(12582912u), A(16744448u), A(8388576u), A(8388576u), A(8388576u), A(33553408u), A(67104768u), A(67104768u), A(134213632u), A(134213632u))) DAT(37u, mat4(A(134213632u), A(134213632u), A(134213632u), A(134213632u), A(67100672u), A(67100672u), A(33538048u), A(16744448u), A(4063232u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(38u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(9175040u), A(16744448u), A(16760960u), A(8373216u), A(8372704u), A(16769024u), A(33546240u), A(67100672u), A(134213632u), A(134213632u))) DAT(39u, mat4(A(134213632u), A(134213632u), A(134209536u), A(134209536u), A(67100672u), A(67092480u), A(33538048u), A(8323072u), A(1572864u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(40u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(786432u), A(16711680u), A(16744448u), A(8372224u), A(8372224u), A(16760832u), A(33538048u), A(67092480u), A(67100672u), A(134209536u))) DAT(41u, mat4(A(134209536u), A(134209536u), A(134209536u), A(67092480u), A(67092480u), A(33538048u), A(16744448u), A(8257536u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(42u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(8257536u), A(8355840u), A(8355840u), A(8355840u), A(8355840u), A(16760832u), A(33538048u), A(67092480u), A(67092480u))) DAT(43u, mat4(A(67092480u), A(67092480u), A(67092480u), A(67092480u), A(67076096u), A(33521664u), A(8323072u), A(1835008u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(44u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6291456u), A(8323072u), A(4161536u), A(4161536u), A(4161536u), A(8355840u), A(16744448u), A(33521664u), A(33538048u))) DAT(45u, mat4(A(67092480u), A(67092480u), A(67076096u), A(33521664u), A(33521664u), A(16711680u), A(3932160u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(46u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(4063232u), A(4128768u), A(4128768u), A(4128768u), A(4128768u), A(8323072u), A(16744448u), A(33521664u))) DAT(47u, mat4(A(33521664u), A(33521664u), A(33521664u), A(33521664u), A(16711680u), A(8257536u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(48u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3670016u), A(4063232u), A(1966080u), A(1966080u), A(1966080u), A(4063232u), A(8323072u), A(16711680u))) DAT(49u, mat4(A(16711680u), A(16744448u), A(16744448u), A(16744448u), A(8323072u), A(1572864u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(50u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1572864u), A(524288u), A(0u), A(0u), A(524288u), A(1835008u), A(3932160u))) DAT(51u, mat4(A(3932160u), A(3932160u), A(3964928u), A(4161536u), A(1966080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(52u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(53u, mat4(A(0u), A(0u), A(32768u), A(1867776u), A(983040u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(54u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(55u, mat4(A(0u), A(0u), A(0u), A(1081344u), A(2064384u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(56u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(57u, mat4(A(0u), A(0u), A(0u), A(0u), A(1146880u), A(917504u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(58u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(59u, mat4(A(0u), A(0u), A(0u), A(0u), A(2097152u), A(2031616u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(60u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(61u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(2031616u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(62u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(63u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(1966080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)))\n    \n    return mat4(0);\n}\n\n#else\n\n// Compiles faster on my machine (47s), at the cost of some perf\n//#define RETURN_TWICE\n\nmat4 unpackData(uint id)\n{   \n    int iz = min(iFrame, 0);\n    \n#ifdef RETURN_TWICE\n    uint id32 = id / 32u;\n    uint ida = (id / 16u) % 2u;\n    \n    // mat4 double\n    #define DAT(i, x, y) if (id32 == i) { if (ida == 0u) return x; else return y; }\n    DAT(0u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(1u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(2u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(224u), A(0u), A(496u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(3u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(4u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(5u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(6u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(1020u), A(0u), A(1020u), A(0u), A(224u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(7u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(8u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(9u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(10u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(2046u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(11u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(12u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(13u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(14u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(1026u), A(0u), A(1799u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(15u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(16u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(17u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(18u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(1537u), A(0u), A(1911u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(19u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(20u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(21u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(22u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(2147483648u), A(1024u), A(2147483648u), A(1537u), A(2147483648u), A(2047u), A(0u), A(252u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(23u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(24u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(25u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(26u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(2147483648u), A(1536u), A(2147483648u), A(1905u), A(0u), A(1023u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(27u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(28u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(29u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(30u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3221225472u), A(1536u)), mat4(A(3221225472u), A(1793u), A(2147483648u), A(1023u), A(0u), A(511u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(31u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(32u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(33u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(34u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(3221225472u), A(768u)), mat4(A(3221225472u), A(961u), A(2147483648u), A(1023u), A(0u), A(56u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(35u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(36u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(37u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(38u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(768u), A(3221225472u), A(896u)), mat4(A(3221225472u), A(1023u), A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(39u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(40u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(41u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(42u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(256u), A(3758096384u), A(448u), A(3221225472u), A(481u)), mat4(A(2147483648u), A(511u), A(0u), A(60u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(43u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(44u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(45u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(46u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(1610612736u), A(192u), A(3758096384u), A(480u), A(3221225472u), A(507u)), mat4(A(2147483648u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(47u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(48u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(49u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(128u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(192u), A(0u), A(992u), A(0u), A(2016u))) DAT(50u, mat4(A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(1610612736u), A(992u), A(3758096384u), A(1008u), A(3758096384u), A(1009u), A(3221225472u), A(511u)), mat4(A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(51u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(52u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(53u, mat4(A(0u), A(0u), A(0u), A(768u), A(0u), A(960u), A(0u), A(1008u), A(0u), A(1008u), A(0u), A(496u), A(0u), A(496u), A(0u), A(496u)), mat4(A(0u), A(496u), A(0u), A(496u), A(0u), A(496u), A(0u), A(1016u), A(0u), A(2040u), A(0u), A(4092u), A(0u), A(8188u), A(0u), A(16380u))) DAT(54u, mat4(A(0u), A(16380u), A(0u), A(16380u), A(0u), A(16376u), A(0u), A(16376u), A(1610612736u), A(16376u), A(3758096384u), A(16383u), A(3221225472u), A(8191u), A(2147483648u), A(4095u)), mat4(A(0u), A(2047u), A(0u), A(248u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(55u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(56u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(57u, mat4(A(0u), A(1792u), A(0u), A(1984u), A(0u), A(2032u), A(0u), A(2040u), A(0u), A(2044u), A(0u), A(1020u), A(0u), A(1016u), A(0u), A(1016u)), mat4(A(0u), A(1020u), A(0u), A(2044u), A(0u), A(2044u), A(0u), A(4092u), A(0u), A(8190u), A(0u), A(16382u), A(0u), A(16382u), A(0u), A(32767u))) DAT(58u, mat4(A(0u), A(32767u), A(0u), A(32767u), A(0u), A(65535u), A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(32767u), A(3221225472u), A(32767u), A(2147483648u), A(16383u)), mat4(A(0u), A(16383u), A(0u), A(4092u), A(0u), A(448u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(59u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(60u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(61u, mat4(A(0u), A(1920u), A(0u), A(4080u), A(0u), A(2044u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u)), mat4(A(0u), A(2046u), A(0u), A(4094u), A(0u), A(4094u), A(0u), A(8191u), A(0u), A(16383u), A(0u), A(32767u), A(2147483648u), A(32767u), A(2147483648u), A(65535u))) DAT(62u, mat4(A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(2147483648u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(3221225472u), A(65535u), A(2147483648u), A(65535u)), mat4(A(0u), A(32767u), A(0u), A(16382u), A(0u), A(4088u), A(0u), A(384u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(63u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(64u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1536u))) DAT(65u, mat4(A(0u), A(4064u), A(0u), A(4092u), A(0u), A(4094u), A(0u), A(4095u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u)), mat4(A(0u), A(4095u), A(0u), A(4095u), A(0u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(3221225472u), A(131071u))) DAT(66u, mat4(A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(2147483648u), A(131071u)), mat4(A(2147483648u), A(65535u), A(0u), A(32767u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(67u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(68u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3584u))) DAT(69u, mat4(A(0u), A(8184u), A(0u), A(8190u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(2147483648u), A(4095u)), mat4(A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u))) DAT(70u, mat4(A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u)), mat4(A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(71u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(72u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(2048u), A(0u), A(7936u))) DAT(73u, mat4(A(0u), A(8188u), A(0u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(8191u)), mat4(A(2147483648u), A(8191u), A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(524287u))) DAT(74u, mat4(A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(524287u), A(3221225472u), A(262143u)), mat4(A(2147483648u), A(262143u), A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(960u), A(0u), A(0u), A(0u), A(0u))) DAT(75u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(76u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(16376u))) DAT(77u, mat4(A(0u), A(16382u), A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(4095u), A(3221225472u), A(4095u), A(3221225472u), A(8191u), A(3221225472u), A(8191u)), mat4(A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(1048575u))) DAT(78u, mat4(A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(524287u)), mat4(A(3221225472u), A(524287u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(65535u), A(0u), A(16380u), A(0u), A(4088u), A(0u), A(0u), A(0u), A(0u))) DAT(79u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(80u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(15600u), A(0u), A(16380u))) DAT(81u, mat4(A(0u), A(16383u), A(2147483648u), A(16383u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(16383u)), mat4(A(3758096384u), A(32767u), A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u))) DAT(82u, mat4(A(4026531840u), A(1048575u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u)), mat4(A(3221225472u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(2032u), A(0u), A(0u))) DAT(83u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(84u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(32760u), A(0u), A(32766u))) DAT(85u, mat4(A(2147483648u), A(32767u), A(3221225472u), A(16383u), A(3221225472u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u)), mat4(A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(2097151u))) DAT(86u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u)), mat4(A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(131071u), A(2147483648u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(384u))) DAT(87u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(88u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(29176u), A(0u), A(65532u), A(0u), A(65535u))) DAT(89u, mat4(A(3221225472u), A(65535u), A(3221225472u), A(32767u), A(3758096384u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u), A(4026531840u), A(65535u)), mat4(A(4026531840u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u))) DAT(90u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(1048575u)), mat4(A(4026531840u), A(1048575u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u), A(0u), A(2032u))) DAT(91u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(92u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(65534u), A(2147483648u), A(65535u))) DAT(93u, mat4(A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(4026531840u), A(16383u), A(4026531840u), A(32767u), A(4026531840u), A(65535u)), mat4(A(4160749568u), A(131071u), A(4160749568u), A(262143u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4227858432u), A(1048575u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u))) DAT(94u, mat4(A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u)), mat4(A(4160749568u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u), A(0u), A(8188u))) DAT(95u, mat4(A(0u), A(256u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(96u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(131070u), A(3221225472u), A(131071u))) DAT(97u, mat4(A(3758096384u), A(65535u), A(3758096384u), A(32767u), A(4026660864u), A(8191u), A(4026661888u), A(8191u), A(4026563584u), A(16383u), A(4026531840u), A(16383u), A(4160749568u), A(65535u), A(4160749568u), A(131071u)), mat4(A(4227858432u), A(262143u), A(4227858432u), A(524287u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(4194303u))) DAT(98u, mat4(A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u)), mat4(A(4160749568u), A(2097151u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u))) DAT(99u, mat4(A(0u), A(2032u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(100u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(96u), A(0u), A(129528u), A(2147483648u), A(131071u), A(3221225472u), A(131071u))) DAT(101u, mat4(A(3758219264u), A(65535u), A(4028627968u), A(16383u), A(4030725120u), A(8191u), A(4030725632u), A(8191u), A(4162845696u), A(16383u), A(4161010688u), A(32767u), A(4227858432u), A(65535u), A(4227858432u), A(131071u)), mat4(A(4261412864u), A(262143u), A(4261412864u), A(524287u), A(4261412864u), A(1048575u), A(4261412864u), A(1048575u), A(4261412864u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(102u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(2097151u)), mat4(A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u))) DAT(103u, mat4(A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(104u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(24576u), A(0u), A(65264u), A(3221225472u), A(131071u), A(3758096384u), A(131071u))) DAT(105u, mat4(A(4034918400u), A(65535u), A(4060085248u), A(16383u), A(4194303488u), A(8191u), A(4227857920u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(32767u), A(4294172672u), A(65535u), A(4278190080u), A(131071u)), mat4(A(4278190080u), A(524287u), A(4278190080u), A(524287u), A(4278190080u), A(1048575u), A(4278190080u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(106u, mat4(A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(2097151u)), mat4(A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(65535u), A(2147483648u), A(32767u))) DAT(107u, mat4(A(0u), A(8190u), A(0u), A(992u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(108u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(28672u), A(0u), A(65472u), A(3758096384u), A(65535u), A(4043300864u), A(65535u))) DAT(109u, mat4(A(4294966272u), A(32767u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4292870144u), A(262143u)), mat4(A(4290772992u), A(524287u), A(4286578688u), A(1048575u), A(4286578688u), A(1048575u), A(4286578688u), A(2097151u), A(4286578688u), A(2097151u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(110u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u)), mat4(A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(32767u))) DAT(111u, mat4(A(0u), A(16383u), A(0u), A(2040u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(112u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(32736u), A(4227858432u), A(32767u), A(4294965248u), A(16383u))) DAT(113u, mat4(A(4294966272u), A(8191u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294705152u), A(262143u)), mat4(A(4292870144u), A(524287u), A(4290772992u), A(1048575u), A(4290772992u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(114u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u))) DAT(115u, mat4(A(2147483648u), A(16383u), A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(116u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1024u), A(469762048u), A(8128u), A(4294934528u), A(8191u), A(4294965248u), A(8191u))) DAT(117u, mat4(A(4294966272u), A(4095u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294836224u), A(262143u)), mat4(A(4293918720u), A(524287u), A(4292870144u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(118u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(262143u), A(4026531840u), A(131071u), A(3758096384u), A(65535u))) DAT(119u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(120u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(503316480u), A(1984u), A(4294950912u), A(4095u), A(4294959104u), A(2047u))) DAT(121u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u)), mat4(A(4294443008u), A(524287u), A(4292870144u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(122u, mat4(A(4290772992u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(65535u))) DAT(123u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(480u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(124u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(520093696u), A(992u), A(4294950912u), A(2047u), A(4294959104u), A(2047u))) DAT(125u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u)), mat4(A(4294443008u), A(524287u), A(4293918720u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(126u, mat4(A(4290772992u), A(8388607u), A(4290772992u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u))) DAT(127u, mat4(A(3221225472u), A(32767u), A(0u), A(8191u), A(0u), A(1008u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(128u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(520093696u), A(992u), A(4294950912u), A(2047u), A(4294959104u), A(2047u))) DAT(129u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u)), mat4(A(4294443008u), A(524287u), A(4293918720u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(130u, mat4(A(4290772992u), A(8388607u), A(4290772992u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u))) DAT(131u, mat4(A(3221225472u), A(32767u), A(0u), A(8191u), A(0u), A(1008u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(132u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(503316480u), A(1984u), A(4294950912u), A(4095u), A(4294959104u), A(2047u))) DAT(133u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u)), mat4(A(4294443008u), A(524287u), A(4292870144u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(134u, mat4(A(4290772992u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(65535u))) DAT(135u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(480u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(136u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1024u), A(469762048u), A(8128u), A(4294934528u), A(8191u), A(4294965248u), A(8191u))) DAT(137u, mat4(A(4294966272u), A(4095u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294836224u), A(262143u)), mat4(A(4293918720u), A(524287u), A(4292870144u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(138u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(262143u), A(4026531840u), A(131071u), A(3758096384u), A(65535u))) DAT(139u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(140u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(32736u), A(4227858432u), A(32767u), A(4294965248u), A(16383u))) DAT(141u, mat4(A(4294966272u), A(8191u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294705152u), A(262143u)), mat4(A(4292870144u), A(524287u), A(4290772992u), A(1048575u), A(4290772992u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(142u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u)), mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u))) DAT(143u, mat4(A(2147483648u), A(16383u), A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(144u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(28672u), A(0u), A(65472u), A(3758096384u), A(65535u), A(4043300864u), A(65535u))) DAT(145u, mat4(A(4294966272u), A(32767u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4292870144u), A(262143u)), mat4(A(4290772992u), A(524287u), A(4286578688u), A(1048575u), A(4286578688u), A(1048575u), A(4286578688u), A(2097151u), A(4286578688u), A(2097151u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(146u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u)), mat4(A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(32767u))) DAT(147u, mat4(A(0u), A(16383u), A(0u), A(2040u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(148u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(24576u), A(0u), A(65264u), A(3221225472u), A(131071u), A(3758096384u), A(131071u))) DAT(149u, mat4(A(4034918400u), A(65535u), A(4060085248u), A(16383u), A(4194303488u), A(8191u), A(4227857920u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(32767u), A(4294172672u), A(65535u), A(4278190080u), A(131071u)), mat4(A(4278190080u), A(524287u), A(4278190080u), A(524287u), A(4278190080u), A(1048575u), A(4278190080u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(150u, mat4(A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(2097151u)), mat4(A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(65535u), A(2147483648u), A(32767u))) DAT(151u, mat4(A(0u), A(8190u), A(0u), A(992u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(152u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(96u), A(0u), A(129528u), A(2147483648u), A(131071u), A(3221225472u), A(131071u))) DAT(153u, mat4(A(3758219264u), A(65535u), A(4028627968u), A(16383u), A(4030725120u), A(8191u), A(4030725632u), A(8191u), A(4162845696u), A(16383u), A(4161010688u), A(32767u), A(4227858432u), A(65535u), A(4227858432u), A(131071u)), mat4(A(4261412864u), A(262143u), A(4261412864u), A(524287u), A(4261412864u), A(1048575u), A(4261412864u), A(1048575u), A(4261412864u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(154u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(2097151u)), mat4(A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u))) DAT(155u, mat4(A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(156u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(131070u), A(3221225472u), A(131071u))) DAT(157u, mat4(A(3758096384u), A(65535u), A(3758096384u), A(32767u), A(4026660864u), A(8191u), A(4026661888u), A(8191u), A(4026563584u), A(16383u), A(4026531840u), A(16383u), A(4160749568u), A(65535u), A(4160749568u), A(131071u)), mat4(A(4227858432u), A(262143u), A(4227858432u), A(524287u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(4194303u))) DAT(158u, mat4(A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u)), mat4(A(4160749568u), A(2097151u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u))) DAT(159u, mat4(A(0u), A(2032u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(160u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(65534u), A(2147483648u), A(65535u))) DAT(161u, mat4(A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(4026531840u), A(16383u), A(4026531840u), A(32767u), A(4026531840u), A(65535u)), mat4(A(4160749568u), A(131071u), A(4160749568u), A(262143u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4227858432u), A(1048575u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u))) DAT(162u, mat4(A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u)), mat4(A(4160749568u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u), A(0u), A(8188u))) DAT(163u, mat4(A(0u), A(256u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(164u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(29176u), A(0u), A(65532u), A(0u), A(65535u))) DAT(165u, mat4(A(3221225472u), A(65535u), A(3221225472u), A(32767u), A(3758096384u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u), A(4026531840u), A(65535u)), mat4(A(4026531840u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u))) DAT(166u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(1048575u)), mat4(A(4026531840u), A(1048575u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u), A(0u), A(2032u))) DAT(167u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(168u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(32760u), A(0u), A(32766u))) DAT(169u, mat4(A(2147483648u), A(32767u), A(3221225472u), A(16383u), A(3221225472u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u)), mat4(A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(2097151u))) DAT(170u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u)), mat4(A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(131071u), A(2147483648u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(384u))) DAT(171u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(172u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(15600u), A(0u), A(16380u))) DAT(173u, mat4(A(0u), A(16383u), A(2147483648u), A(16383u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(16383u)), mat4(A(3758096384u), A(32767u), A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u))) DAT(174u, mat4(A(4026531840u), A(1048575u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u)), mat4(A(3221225472u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(2032u), A(0u), A(0u))) DAT(175u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(176u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(16376u))) DAT(177u, mat4(A(0u), A(16382u), A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(4095u), A(3221225472u), A(4095u), A(3221225472u), A(8191u), A(3221225472u), A(8191u)), mat4(A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(1048575u))) DAT(178u, mat4(A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(524287u)), mat4(A(3221225472u), A(524287u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(65535u), A(0u), A(16380u), A(0u), A(4088u), A(0u), A(0u), A(0u), A(0u))) DAT(179u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(180u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(2048u), A(0u), A(7936u))) DAT(181u, mat4(A(0u), A(8188u), A(0u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(8191u)), mat4(A(2147483648u), A(8191u), A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(524287u))) DAT(182u, mat4(A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(524287u), A(3221225472u), A(262143u)), mat4(A(2147483648u), A(262143u), A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(960u), A(0u), A(0u), A(0u), A(0u))) DAT(183u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(184u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3584u))) DAT(185u, mat4(A(0u), A(8184u), A(0u), A(8190u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(2147483648u), A(4095u)), mat4(A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u))) DAT(186u, mat4(A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u)), mat4(A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(187u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(188u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1536u))) DAT(189u, mat4(A(0u), A(4064u), A(0u), A(4092u), A(0u), A(4094u), A(0u), A(4095u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u)), mat4(A(0u), A(4095u), A(0u), A(4095u), A(0u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(3221225472u), A(131071u))) DAT(190u, mat4(A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(2147483648u), A(131071u)), mat4(A(2147483648u), A(65535u), A(0u), A(32767u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(191u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(192u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(193u, mat4(A(0u), A(1920u), A(0u), A(4080u), A(0u), A(2044u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u)), mat4(A(0u), A(2046u), A(0u), A(4094u), A(0u), A(4094u), A(0u), A(8191u), A(0u), A(16383u), A(0u), A(32767u), A(2147483648u), A(32767u), A(2147483648u), A(65535u))) DAT(194u, mat4(A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(2147483648u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(3221225472u), A(65535u), A(2147483648u), A(65535u)), mat4(A(0u), A(32767u), A(0u), A(16382u), A(0u), A(4088u), A(0u), A(384u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(195u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(196u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(197u, mat4(A(0u), A(1792u), A(0u), A(1984u), A(0u), A(2032u), A(0u), A(2040u), A(0u), A(2044u), A(0u), A(1020u), A(0u), A(1016u), A(0u), A(1016u)), mat4(A(0u), A(1020u), A(0u), A(2044u), A(0u), A(2044u), A(0u), A(4092u), A(0u), A(8190u), A(0u), A(16382u), A(0u), A(16382u), A(0u), A(32767u))) DAT(198u, mat4(A(0u), A(32767u), A(0u), A(32767u), A(0u), A(65535u), A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(32767u), A(3221225472u), A(32767u), A(2147483648u), A(16383u)), mat4(A(0u), A(16383u), A(0u), A(4092u), A(0u), A(448u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(199u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(200u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(201u, mat4(A(0u), A(0u), A(0u), A(768u), A(0u), A(960u), A(0u), A(1008u), A(0u), A(1008u), A(0u), A(496u), A(0u), A(496u), A(0u), A(496u)), mat4(A(0u), A(496u), A(0u), A(496u), A(0u), A(496u), A(0u), A(1016u), A(0u), A(2040u), A(0u), A(4092u), A(0u), A(8188u), A(0u), A(16380u))) DAT(202u, mat4(A(0u), A(16380u), A(0u), A(16380u), A(0u), A(16376u), A(0u), A(16376u), A(1610612736u), A(16376u), A(3758096384u), A(16383u), A(3221225472u), A(8191u), A(2147483648u), A(4095u)), mat4(A(0u), A(2047u), A(0u), A(248u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(203u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(204u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(205u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(128u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(192u), A(0u), A(992u), A(0u), A(2016u))) DAT(206u, mat4(A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(1610612736u), A(992u), A(3758096384u), A(1008u), A(3758096384u), A(1009u), A(3221225472u), A(511u)), mat4(A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(207u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(208u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(209u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(210u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(1610612736u), A(192u), A(3758096384u), A(480u), A(3221225472u), A(507u)), mat4(A(2147483648u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(211u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(212u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(213u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(214u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(256u), A(3758096384u), A(448u), A(3221225472u), A(481u)), mat4(A(2147483648u), A(511u), A(0u), A(60u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(215u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(216u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(217u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(218u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(768u), A(3221225472u), A(896u)), mat4(A(3221225472u), A(1023u), A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(219u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(220u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(221u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(222u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(3221225472u), A(768u)), mat4(A(3221225472u), A(961u), A(2147483648u), A(1023u), A(0u), A(56u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(223u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(224u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(225u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(226u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3221225472u), A(1536u)), mat4(A(3221225472u), A(1793u), A(2147483648u), A(1023u), A(0u), A(511u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(227u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(228u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(229u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(230u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(2147483648u), A(1536u), A(2147483648u), A(1905u), A(0u), A(1023u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(231u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(232u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(233u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(234u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(2147483648u), A(1024u), A(2147483648u), A(1537u), A(2147483648u), A(2047u), A(0u), A(252u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(235u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(236u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(237u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(238u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(1537u), A(0u), A(1911u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(239u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(240u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(241u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(242u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(1026u), A(0u), A(1799u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(243u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(244u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(245u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(246u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(2046u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(247u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(248u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(249u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(250u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(1020u), A(0u), A(1020u), A(0u), A(224u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(251u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(252u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(253u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(254u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(224u), A(0u), A(496u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(255u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)), mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)))\n#else\n    uint id16 = id / 16u;\n\n    // mat4 single\n    #define DAT(i, x) if (id16 == i) { return x; }\n    DAT(0u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(1u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(2u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(3u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(4u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(5u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(224u), A(0u), A(496u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(6u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(7u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(8u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(9u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(10u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(11u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(12u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(13u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(1020u), A(0u), A(1020u), A(0u), A(224u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(14u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(15u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(16u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(17u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(18u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(19u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(20u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(21u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(2046u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(22u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(23u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(24u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(25u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(26u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(27u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(28u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(29u, mat4(A(0u), A(0u), A(0u), A(1026u), A(0u), A(1799u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(30u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(31u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(32u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(33u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(34u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(35u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(36u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(37u, mat4(A(0u), A(0u), A(0u), A(1537u), A(0u), A(1911u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(38u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(39u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(40u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(41u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(42u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(43u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(44u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(45u, mat4(A(2147483648u), A(1024u), A(2147483648u), A(1537u), A(2147483648u), A(2047u), A(0u), A(252u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(46u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(47u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(48u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(49u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(50u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(51u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(52u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(53u, mat4(A(2147483648u), A(1536u), A(2147483648u), A(1905u), A(0u), A(1023u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(54u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(55u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(56u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(57u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(58u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(59u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(60u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3221225472u), A(1536u))) DAT(61u, mat4(A(3221225472u), A(1793u), A(2147483648u), A(1023u), A(0u), A(511u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(62u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(63u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(64u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(65u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(66u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(67u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(68u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(3221225472u), A(768u))) DAT(69u, mat4(A(3221225472u), A(961u), A(2147483648u), A(1023u), A(0u), A(56u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(70u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(71u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(72u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(73u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(74u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(75u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(76u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(768u), A(3221225472u), A(896u))) DAT(77u, mat4(A(3221225472u), A(1023u), A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(78u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(79u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(80u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(81u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(82u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(83u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(84u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(256u), A(3758096384u), A(448u), A(3221225472u), A(481u))) DAT(85u, mat4(A(2147483648u), A(511u), A(0u), A(60u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(86u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(87u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(88u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(89u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(90u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(91u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(92u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(1610612736u), A(192u), A(3758096384u), A(480u), A(3221225472u), A(507u))) DAT(93u, mat4(A(2147483648u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(94u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(95u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(96u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(97u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(98u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(128u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(99u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(192u), A(0u), A(992u), A(0u), A(2016u))) DAT(100u, mat4(A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(1610612736u), A(992u), A(3758096384u), A(1008u), A(3758096384u), A(1009u), A(3221225472u), A(511u))) DAT(101u, mat4(A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(102u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(103u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(104u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(105u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(106u, mat4(A(0u), A(0u), A(0u), A(768u), A(0u), A(960u), A(0u), A(1008u), A(0u), A(1008u), A(0u), A(496u), A(0u), A(496u), A(0u), A(496u))) DAT(107u, mat4(A(0u), A(496u), A(0u), A(496u), A(0u), A(496u), A(0u), A(1016u), A(0u), A(2040u), A(0u), A(4092u), A(0u), A(8188u), A(0u), A(16380u))) DAT(108u, mat4(A(0u), A(16380u), A(0u), A(16380u), A(0u), A(16376u), A(0u), A(16376u), A(1610612736u), A(16376u), A(3758096384u), A(16383u), A(3221225472u), A(8191u), A(2147483648u), A(4095u))) DAT(109u, mat4(A(0u), A(2047u), A(0u), A(248u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(110u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(111u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(112u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(113u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(114u, mat4(A(0u), A(1792u), A(0u), A(1984u), A(0u), A(2032u), A(0u), A(2040u), A(0u), A(2044u), A(0u), A(1020u), A(0u), A(1016u), A(0u), A(1016u))) DAT(115u, mat4(A(0u), A(1020u), A(0u), A(2044u), A(0u), A(2044u), A(0u), A(4092u), A(0u), A(8190u), A(0u), A(16382u), A(0u), A(16382u), A(0u), A(32767u))) DAT(116u, mat4(A(0u), A(32767u), A(0u), A(32767u), A(0u), A(65535u), A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(32767u), A(3221225472u), A(32767u), A(2147483648u), A(16383u))) DAT(117u, mat4(A(0u), A(16383u), A(0u), A(4092u), A(0u), A(448u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(118u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(119u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(120u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(121u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(122u, mat4(A(0u), A(1920u), A(0u), A(4080u), A(0u), A(2044u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u))) DAT(123u, mat4(A(0u), A(2046u), A(0u), A(4094u), A(0u), A(4094u), A(0u), A(8191u), A(0u), A(16383u), A(0u), A(32767u), A(2147483648u), A(32767u), A(2147483648u), A(65535u))) DAT(124u, mat4(A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(2147483648u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(3221225472u), A(65535u), A(2147483648u), A(65535u))) DAT(125u, mat4(A(0u), A(32767u), A(0u), A(16382u), A(0u), A(4088u), A(0u), A(384u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(126u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(127u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(128u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(129u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1536u))) DAT(130u, mat4(A(0u), A(4064u), A(0u), A(4092u), A(0u), A(4094u), A(0u), A(4095u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u))) DAT(131u, mat4(A(0u), A(4095u), A(0u), A(4095u), A(0u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(3221225472u), A(131071u))) DAT(132u, mat4(A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(2147483648u), A(131071u))) DAT(133u, mat4(A(2147483648u), A(65535u), A(0u), A(32767u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(134u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(135u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(136u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(137u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3584u))) DAT(138u, mat4(A(0u), A(8184u), A(0u), A(8190u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(2147483648u), A(4095u))) DAT(139u, mat4(A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u))) DAT(140u, mat4(A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u))) DAT(141u, mat4(A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(142u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(143u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(144u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(145u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(2048u), A(0u), A(7936u))) DAT(146u, mat4(A(0u), A(8188u), A(0u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(8191u))) DAT(147u, mat4(A(2147483648u), A(8191u), A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(524287u))) DAT(148u, mat4(A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(524287u), A(3221225472u), A(262143u))) DAT(149u, mat4(A(2147483648u), A(262143u), A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(960u), A(0u), A(0u), A(0u), A(0u))) DAT(150u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(151u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(152u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(153u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(16376u))) DAT(154u, mat4(A(0u), A(16382u), A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(4095u), A(3221225472u), A(4095u), A(3221225472u), A(8191u), A(3221225472u), A(8191u))) DAT(155u, mat4(A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(1048575u))) DAT(156u, mat4(A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(524287u))) DAT(157u, mat4(A(3221225472u), A(524287u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(65535u), A(0u), A(16380u), A(0u), A(4088u), A(0u), A(0u), A(0u), A(0u))) DAT(158u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(159u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(160u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(161u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(15600u), A(0u), A(16380u))) DAT(162u, mat4(A(0u), A(16383u), A(2147483648u), A(16383u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(16383u))) DAT(163u, mat4(A(3758096384u), A(32767u), A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u))) DAT(164u, mat4(A(4026531840u), A(1048575u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u))) DAT(165u, mat4(A(3221225472u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(2032u), A(0u), A(0u))) DAT(166u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(167u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(168u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(169u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(32760u), A(0u), A(32766u))) DAT(170u, mat4(A(2147483648u), A(32767u), A(3221225472u), A(16383u), A(3221225472u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u))) DAT(171u, mat4(A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(2097151u))) DAT(172u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u))) DAT(173u, mat4(A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(131071u), A(2147483648u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(384u))) DAT(174u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(175u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(176u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(177u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(29176u), A(0u), A(65532u), A(0u), A(65535u))) DAT(178u, mat4(A(3221225472u), A(65535u), A(3221225472u), A(32767u), A(3758096384u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u), A(4026531840u), A(65535u))) DAT(179u, mat4(A(4026531840u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u))) DAT(180u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(1048575u))) DAT(181u, mat4(A(4026531840u), A(1048575u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u), A(0u), A(2032u))) DAT(182u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(183u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(184u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(185u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(65534u), A(2147483648u), A(65535u))) DAT(186u, mat4(A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(4026531840u), A(16383u), A(4026531840u), A(32767u), A(4026531840u), A(65535u))) DAT(187u, mat4(A(4160749568u), A(131071u), A(4160749568u), A(262143u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4227858432u), A(1048575u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u))) DAT(188u, mat4(A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u))) DAT(189u, mat4(A(4160749568u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u), A(0u), A(8188u))) DAT(190u, mat4(A(0u), A(256u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(191u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(192u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(193u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(131070u), A(3221225472u), A(131071u))) DAT(194u, mat4(A(3758096384u), A(65535u), A(3758096384u), A(32767u), A(4026660864u), A(8191u), A(4026661888u), A(8191u), A(4026563584u), A(16383u), A(4026531840u), A(16383u), A(4160749568u), A(65535u), A(4160749568u), A(131071u))) DAT(195u, mat4(A(4227858432u), A(262143u), A(4227858432u), A(524287u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(4194303u))) DAT(196u, mat4(A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u))) DAT(197u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u))) DAT(198u, mat4(A(0u), A(2032u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(199u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(200u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(201u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(96u), A(0u), A(129528u), A(2147483648u), A(131071u), A(3221225472u), A(131071u))) DAT(202u, mat4(A(3758219264u), A(65535u), A(4028627968u), A(16383u), A(4030725120u), A(8191u), A(4030725632u), A(8191u), A(4162845696u), A(16383u), A(4161010688u), A(32767u), A(4227858432u), A(65535u), A(4227858432u), A(131071u))) DAT(203u, mat4(A(4261412864u), A(262143u), A(4261412864u), A(524287u), A(4261412864u), A(1048575u), A(4261412864u), A(1048575u), A(4261412864u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(204u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(2097151u))) DAT(205u, mat4(A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u))) DAT(206u, mat4(A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(207u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(208u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(209u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(24576u), A(0u), A(65264u), A(3221225472u), A(131071u), A(3758096384u), A(131071u))) DAT(210u, mat4(A(4034918400u), A(65535u), A(4060085248u), A(16383u), A(4194303488u), A(8191u), A(4227857920u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(32767u), A(4294172672u), A(65535u), A(4278190080u), A(131071u))) DAT(211u, mat4(A(4278190080u), A(524287u), A(4278190080u), A(524287u), A(4278190080u), A(1048575u), A(4278190080u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(212u, mat4(A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(2097151u))) DAT(213u, mat4(A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(65535u), A(2147483648u), A(32767u))) DAT(214u, mat4(A(0u), A(8190u), A(0u), A(992u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(215u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(216u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(217u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(28672u), A(0u), A(65472u), A(3758096384u), A(65535u), A(4043300864u), A(65535u))) DAT(218u, mat4(A(4294966272u), A(32767u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4292870144u), A(262143u))) DAT(219u, mat4(A(4290772992u), A(524287u), A(4286578688u), A(1048575u), A(4286578688u), A(1048575u), A(4286578688u), A(2097151u), A(4286578688u), A(2097151u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(220u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u))) DAT(221u, mat4(A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(32767u))) DAT(222u, mat4(A(0u), A(16383u), A(0u), A(2040u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(223u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(224u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(225u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(32736u), A(4227858432u), A(32767u), A(4294965248u), A(16383u))) DAT(226u, mat4(A(4294966272u), A(8191u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294705152u), A(262143u))) DAT(227u, mat4(A(4292870144u), A(524287u), A(4290772992u), A(1048575u), A(4290772992u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(228u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(229u, mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u))) DAT(230u, mat4(A(2147483648u), A(16383u), A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(231u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(232u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(233u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1024u), A(469762048u), A(8128u), A(4294934528u), A(8191u), A(4294965248u), A(8191u))) DAT(234u, mat4(A(4294966272u), A(4095u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294836224u), A(262143u))) DAT(235u, mat4(A(4293918720u), A(524287u), A(4292870144u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(236u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(237u, mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(262143u), A(4026531840u), A(131071u), A(3758096384u), A(65535u))) DAT(238u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(239u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(240u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(241u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(503316480u), A(1984u), A(4294950912u), A(4095u), A(4294959104u), A(2047u))) DAT(242u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u))) DAT(243u, mat4(A(4294443008u), A(524287u), A(4292870144u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(244u, mat4(A(4290772992u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(245u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(65535u))) DAT(246u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(480u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(247u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(248u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(249u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(520093696u), A(992u), A(4294950912u), A(2047u), A(4294959104u), A(2047u))) DAT(250u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u))) DAT(251u, mat4(A(4294443008u), A(524287u), A(4293918720u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(252u, mat4(A(4290772992u), A(8388607u), A(4290772992u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(253u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u))) DAT(254u, mat4(A(3221225472u), A(32767u), A(0u), A(8191u), A(0u), A(1008u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(255u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(256u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(257u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(520093696u), A(992u), A(4294950912u), A(2047u), A(4294959104u), A(2047u))) DAT(258u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u))) DAT(259u, mat4(A(4294443008u), A(524287u), A(4293918720u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(260u, mat4(A(4290772992u), A(8388607u), A(4290772992u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(261u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u))) DAT(262u, mat4(A(3221225472u), A(32767u), A(0u), A(8191u), A(0u), A(1008u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(263u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(264u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(265u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(201326592u), A(0u), A(503316480u), A(1984u), A(4294950912u), A(4095u), A(4294959104u), A(2047u))) DAT(266u, mat4(A(4294966272u), A(2047u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294934528u), A(262143u))) DAT(267u, mat4(A(4294443008u), A(524287u), A(4292870144u), A(1048575u), A(4292870144u), A(2097151u), A(4292870144u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(268u, mat4(A(4290772992u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(269u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(65535u))) DAT(270u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(480u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(271u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(272u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(273u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1024u), A(469762048u), A(8128u), A(4294934528u), A(8191u), A(4294965248u), A(8191u))) DAT(274u, mat4(A(4294966272u), A(4095u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294836224u), A(262143u))) DAT(275u, mat4(A(4293918720u), A(524287u), A(4292870144u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u), A(4290772992u), A(4194303u))) DAT(276u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(8388607u), A(4286578688u), A(8388607u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(277u, mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4160749568u), A(262143u), A(4026531840u), A(131071u), A(3758096384u), A(65535u))) DAT(278u, mat4(A(2147483648u), A(32767u), A(0u), A(8190u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(279u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(280u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(281u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(32736u), A(4227858432u), A(32767u), A(4294965248u), A(16383u))) DAT(282u, mat4(A(4294966272u), A(8191u), A(4294966784u), A(4095u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966784u), A(32767u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4294705152u), A(262143u))) DAT(283u, mat4(A(4292870144u), A(524287u), A(4290772992u), A(1048575u), A(4290772992u), A(1048575u), A(4290772992u), A(2097151u), A(4290772992u), A(2097151u), A(4290772992u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(284u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(285u, mat4(A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u))) DAT(286u, mat4(A(2147483648u), A(16383u), A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(287u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(288u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(289u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(28672u), A(0u), A(65472u), A(3758096384u), A(65535u), A(4043300864u), A(65535u))) DAT(290u, mat4(A(4294966272u), A(32767u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(65535u), A(4294963200u), A(131071u), A(4292870144u), A(262143u))) DAT(291u, mat4(A(4290772992u), A(524287u), A(4286578688u), A(1048575u), A(4286578688u), A(1048575u), A(4286578688u), A(2097151u), A(4286578688u), A(2097151u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4286578688u), A(4194303u))) DAT(292u, mat4(A(4286578688u), A(4194303u), A(4286578688u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u))) DAT(293u, mat4(A(4261412864u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(32767u))) DAT(294u, mat4(A(0u), A(16383u), A(0u), A(2040u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(295u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(296u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(297u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(24576u), A(0u), A(65264u), A(3221225472u), A(131071u), A(3758096384u), A(131071u))) DAT(298u, mat4(A(4034918400u), A(65535u), A(4060085248u), A(16383u), A(4194303488u), A(8191u), A(4227857920u), A(8191u), A(4294966784u), A(16383u), A(4294966272u), A(32767u), A(4294172672u), A(65535u), A(4278190080u), A(131071u))) DAT(299u, mat4(A(4278190080u), A(524287u), A(4278190080u), A(524287u), A(4278190080u), A(1048575u), A(4278190080u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(300u, mat4(A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(2097151u))) DAT(301u, mat4(A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(65535u), A(2147483648u), A(32767u))) DAT(302u, mat4(A(0u), A(8190u), A(0u), A(992u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(303u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(304u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(305u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(96u), A(0u), A(129528u), A(2147483648u), A(131071u), A(3221225472u), A(131071u))) DAT(306u, mat4(A(3758219264u), A(65535u), A(4028627968u), A(16383u), A(4030725120u), A(8191u), A(4030725632u), A(8191u), A(4162845696u), A(16383u), A(4161010688u), A(32767u), A(4227858432u), A(65535u), A(4227858432u), A(131071u))) DAT(307u, mat4(A(4261412864u), A(262143u), A(4261412864u), A(524287u), A(4261412864u), A(1048575u), A(4261412864u), A(1048575u), A(4261412864u), A(2097151u), A(4278190080u), A(2097151u), A(4278190080u), A(4194303u), A(4278190080u), A(4194303u))) DAT(308u, mat4(A(4278190080u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(2097151u))) DAT(309u, mat4(A(4227858432u), A(2097151u), A(4227858432u), A(1048575u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(262143u), A(3758096384u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u))) DAT(310u, mat4(A(0u), A(4092u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(311u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(312u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(313u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(131070u), A(3221225472u), A(131071u))) DAT(314u, mat4(A(3758096384u), A(65535u), A(3758096384u), A(32767u), A(4026660864u), A(8191u), A(4026661888u), A(8191u), A(4026563584u), A(16383u), A(4026531840u), A(16383u), A(4160749568u), A(65535u), A(4160749568u), A(131071u))) DAT(315u, mat4(A(4227858432u), A(262143u), A(4227858432u), A(524287u), A(4227858432u), A(1048575u), A(4227858432u), A(1048575u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(2097151u), A(4261412864u), A(4194303u))) DAT(316u, mat4(A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4261412864u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u))) DAT(317u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(1048575u), A(4026531840u), A(524287u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u))) DAT(318u, mat4(A(0u), A(2032u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(319u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(320u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(321u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(61944u), A(0u), A(65534u), A(2147483648u), A(65535u))) DAT(322u, mat4(A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(4026531840u), A(16383u), A(4026531840u), A(32767u), A(4026531840u), A(65535u))) DAT(323u, mat4(A(4160749568u), A(131071u), A(4160749568u), A(262143u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4227858432u), A(1048575u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u), A(4227858432u), A(2097151u))) DAT(324u, mat4(A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(4194303u), A(4227858432u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u))) DAT(325u, mat4(A(4160749568u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(524287u), A(3758096384u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(0u), A(16383u), A(0u), A(8188u))) DAT(326u, mat4(A(0u), A(256u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(327u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(328u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(329u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(29176u), A(0u), A(65532u), A(0u), A(65535u))) DAT(330u, mat4(A(3221225472u), A(65535u), A(3221225472u), A(32767u), A(3758096384u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u), A(4026531840u), A(65535u))) DAT(331u, mat4(A(4026531840u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4160749568u), A(524287u), A(4160749568u), A(1048575u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u))) DAT(332u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(1048575u))) DAT(333u, mat4(A(4026531840u), A(1048575u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(2147483648u), A(32767u), A(0u), A(16382u), A(0u), A(2032u))) DAT(334u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(335u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(336u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(337u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(240u), A(0u), A(32760u), A(0u), A(32766u))) DAT(338u, mat4(A(2147483648u), A(32767u), A(3221225472u), A(16383u), A(3221225472u), A(16383u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(8191u), A(3758096384u), A(16383u), A(3758096384u), A(32767u))) DAT(339u, mat4(A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(4026531840u), A(262143u), A(4026531840u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(2097151u))) DAT(340u, mat4(A(4160749568u), A(2097151u), A(4160749568u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u))) DAT(341u, mat4(A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(131071u), A(2147483648u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(384u))) DAT(342u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(343u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(344u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(345u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(15600u), A(0u), A(16380u))) DAT(346u, mat4(A(0u), A(16383u), A(2147483648u), A(16383u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(16383u))) DAT(347u, mat4(A(3758096384u), A(32767u), A(3758096384u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u), A(4026531840u), A(1048575u))) DAT(348u, mat4(A(4026531840u), A(1048575u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(2097151u), A(4026531840u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u))) DAT(349u, mat4(A(3221225472u), A(524287u), A(3221225472u), A(262143u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(2032u), A(0u), A(0u))) DAT(350u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(351u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(352u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(353u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(6144u), A(0u), A(16376u))) DAT(354u, mat4(A(0u), A(16382u), A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(3221225472u), A(8191u), A(3221225472u), A(4095u), A(3221225472u), A(4095u), A(3221225472u), A(8191u), A(3221225472u), A(8191u))) DAT(355u, mat4(A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3758096384u), A(131071u), A(3758096384u), A(262143u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(1048575u))) DAT(356u, mat4(A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(1048575u), A(3758096384u), A(524287u), A(3221225472u), A(524287u))) DAT(357u, mat4(A(3221225472u), A(524287u), A(2147483648u), A(262143u), A(0u), A(131071u), A(0u), A(65535u), A(0u), A(16380u), A(0u), A(4088u), A(0u), A(0u), A(0u), A(0u))) DAT(358u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(359u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(360u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(361u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(2048u), A(0u), A(7936u))) DAT(362u, mat4(A(0u), A(8188u), A(0u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(4095u), A(2147483648u), A(8191u))) DAT(363u, mat4(A(2147483648u), A(8191u), A(3221225472u), A(16383u), A(3221225472u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(524287u))) DAT(364u, mat4(A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3758096384u), A(524287u), A(3221225472u), A(524287u), A(3221225472u), A(262143u))) DAT(365u, mat4(A(2147483648u), A(262143u), A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(8184u), A(0u), A(960u), A(0u), A(0u), A(0u), A(0u))) DAT(366u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(367u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(368u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(369u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3584u))) DAT(370u, mat4(A(0u), A(8184u), A(0u), A(8190u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(0u), A(4095u), A(2147483648u), A(4095u))) DAT(371u, mat4(A(2147483648u), A(8191u), A(2147483648u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(3221225472u), A(65535u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u))) DAT(372u, mat4(A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3758096384u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u))) DAT(373u, mat4(A(2147483648u), A(131071u), A(0u), A(65535u), A(0u), A(32766u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(374u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(375u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(376u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(377u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1536u))) DAT(378u, mat4(A(0u), A(4064u), A(0u), A(4092u), A(0u), A(4094u), A(0u), A(4095u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u), A(0u), A(2047u))) DAT(379u, mat4(A(0u), A(4095u), A(0u), A(4095u), A(0u), A(8191u), A(2147483648u), A(16383u), A(2147483648u), A(32767u), A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(3221225472u), A(131071u))) DAT(380u, mat4(A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(262143u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(2147483648u), A(131071u))) DAT(381u, mat4(A(2147483648u), A(65535u), A(0u), A(32767u), A(0u), A(16380u), A(0u), A(4080u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(382u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(383u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(384u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(385u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(386u, mat4(A(0u), A(1920u), A(0u), A(4080u), A(0u), A(2044u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u), A(0u), A(2046u))) DAT(387u, mat4(A(0u), A(2046u), A(0u), A(4094u), A(0u), A(4094u), A(0u), A(8191u), A(0u), A(16383u), A(0u), A(32767u), A(2147483648u), A(32767u), A(2147483648u), A(65535u))) DAT(388u, mat4(A(2147483648u), A(65535u), A(2147483648u), A(65535u), A(2147483648u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(131071u), A(3221225472u), A(65535u), A(3221225472u), A(65535u), A(2147483648u), A(65535u))) DAT(389u, mat4(A(0u), A(32767u), A(0u), A(16382u), A(0u), A(4088u), A(0u), A(384u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(390u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(391u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(392u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(393u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(394u, mat4(A(0u), A(1792u), A(0u), A(1984u), A(0u), A(2032u), A(0u), A(2040u), A(0u), A(2044u), A(0u), A(1020u), A(0u), A(1016u), A(0u), A(1016u))) DAT(395u, mat4(A(0u), A(1020u), A(0u), A(2044u), A(0u), A(2044u), A(0u), A(4092u), A(0u), A(8190u), A(0u), A(16382u), A(0u), A(16382u), A(0u), A(32767u))) DAT(396u, mat4(A(0u), A(32767u), A(0u), A(32767u), A(0u), A(65535u), A(3221225472u), A(65535u), A(3758096384u), A(32767u), A(3758096384u), A(32767u), A(3221225472u), A(32767u), A(2147483648u), A(16383u))) DAT(397u, mat4(A(0u), A(16383u), A(0u), A(4092u), A(0u), A(448u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(398u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(399u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(400u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(401u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(402u, mat4(A(0u), A(0u), A(0u), A(768u), A(0u), A(960u), A(0u), A(1008u), A(0u), A(1008u), A(0u), A(496u), A(0u), A(496u), A(0u), A(496u))) DAT(403u, mat4(A(0u), A(496u), A(0u), A(496u), A(0u), A(496u), A(0u), A(1016u), A(0u), A(2040u), A(0u), A(4092u), A(0u), A(8188u), A(0u), A(16380u))) DAT(404u, mat4(A(0u), A(16380u), A(0u), A(16380u), A(0u), A(16376u), A(0u), A(16376u), A(1610612736u), A(16376u), A(3758096384u), A(16383u), A(3221225472u), A(8191u), A(2147483648u), A(4095u))) DAT(405u, mat4(A(0u), A(2047u), A(0u), A(248u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(406u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(407u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(408u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(409u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(410u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(128u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(411u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(192u), A(0u), A(992u), A(0u), A(2016u))) DAT(412u, mat4(A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(0u), A(2016u), A(1610612736u), A(992u), A(3758096384u), A(1008u), A(3758096384u), A(1009u), A(3221225472u), A(511u))) DAT(413u, mat4(A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(414u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(415u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(416u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(417u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(418u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(419u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(420u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(1610612736u), A(192u), A(3758096384u), A(480u), A(3221225472u), A(507u))) DAT(421u, mat4(A(2147483648u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(422u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(423u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(424u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(425u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(426u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(427u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(428u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(256u), A(3758096384u), A(448u), A(3221225472u), A(481u))) DAT(429u, mat4(A(2147483648u), A(511u), A(0u), A(60u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(430u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(431u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(432u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(433u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(434u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(435u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(436u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(768u), A(3221225472u), A(896u))) DAT(437u, mat4(A(3221225472u), A(1023u), A(0u), A(255u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(438u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(439u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(440u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(441u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(442u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(443u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(444u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(1073741824u), A(0u), A(3221225472u), A(768u))) DAT(445u, mat4(A(3221225472u), A(961u), A(2147483648u), A(1023u), A(0u), A(56u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(446u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(447u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(448u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(449u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(450u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(451u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(452u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(3221225472u), A(1536u))) DAT(453u, mat4(A(3221225472u), A(1793u), A(2147483648u), A(1023u), A(0u), A(511u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(454u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(455u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(456u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(457u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(458u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(459u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(460u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(461u, mat4(A(2147483648u), A(1536u), A(2147483648u), A(1905u), A(0u), A(1023u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(462u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(463u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(464u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(465u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(466u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(467u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(468u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(469u, mat4(A(2147483648u), A(1024u), A(2147483648u), A(1537u), A(2147483648u), A(2047u), A(0u), A(252u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(470u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(471u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(472u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(473u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(474u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(475u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(476u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(477u, mat4(A(0u), A(0u), A(0u), A(1537u), A(0u), A(1911u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(478u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(479u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(480u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(481u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(482u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(483u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(484u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(485u, mat4(A(0u), A(0u), A(0u), A(1026u), A(0u), A(1799u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(486u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(487u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(488u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(489u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(490u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(491u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(492u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(493u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(2046u), A(0u), A(1022u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(494u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(495u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(496u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(497u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(498u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(499u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(500u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(501u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(1020u), A(0u), A(1020u), A(0u), A(224u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(502u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(503u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(504u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(505u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(506u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(507u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(508u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(509u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(224u), A(0u), A(496u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(510u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u))) DAT(511u, mat4(A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u), A(0u)))\n#endif\n    \n    return mat4(0);\n}\n\n#endif\n\nuint getData(uint id)\n{\n    \n    int iz = min(iFrame, 0);\n    \n    return floatBitsToUint(unpackData(id)[(id/4u)%4u][id%4u]);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint id = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x);\n\n    uint data = getData(id);\n\n    \n    /*float x = float(data & 256u);\n    float y = float((data >> 8u) & 256u);\n    float z = float((data >> 16u) & 256u);\n    float w = float((data >> 24u) & 256u);\n\n    fragColor = vec4(x, y, z, w);*/\n    fragColor = vec4(uintBitsToFloat(data), 0,0,0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[886, 886, 912, 912, 1482], [1484, 1484, 1524, 1524, 1670], [1672, 1672, 1705, 1705, 1788]], "test": "untested"}
{"id": "cdKXzw", "name": "Max Drekker sphere", "author": "mrange", "description": "CC0: Max Drekker sphere\n/Inspired by this tweet: https://twitter.com/MaxDrekker/status/1644282440448450562?s=20\nCreated during a bus trip so the shading of the sphere isn't complete but\ngood enough for my standards\n", "tags": ["sphere"], "likes": 20, "viewed": 298, "published": 3, "date": "1680874832", "time_retrieved": "2024-07-30T18:01:53.788344", "image_code": "// CC0: Max Drekker sphere\n//  Inspired by this tweet: https://twitter.com/MaxDrekker/status/1644282440448450562?s=20\n//  Created during a bus trip so the shading of the sphere isn't complete but\n//  good enough for my standards\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)s\n\nconst vec2  BoxDim    = vec2(2.0/3.0);\nconst float SphereDim = 0.5;\nconst vec3  BoxCol    = vec3(0.033);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 sphere(vec3 col, vec2 p) {\n  float r = SphereDim;\n\n  float aa = 2.0/RESOLUTION.y;\n  float z2 = (r*r-dot(p, p));\n  if (z2 > 0.0) {\n    float z   = sqrt(z2);\n    vec3 cp   = vec3(p, z);\n    vec3 rd   = normalize(-vec3(p, 0.75));\n    vec3 cn   = normalize(cp);\n    vec3 cr   = reflect(rd, cn);\n    float fre = 1.0+dot(rd, cn);\n    fre = mix(0.125, 1.0, fre);\n\n    const vec3 lightDir0 = normalize(vec3(2.0, 2.5, 1.5));\n    const vec3 dcol0 = HSV2RGB(vec3(0.5, 0.5, 0.5));\n    const vec3 scol0 = HSV2RGB(vec3(0.66, 0.65, 8.0));\n    float cd0 = max(dot(lightDir0, cn), 0.0);\n    cd0 *= cd0;\n    cd0 *= cd0;\n    float cs0 = max(dot(lightDir0, cr), 0.0);\n\n    const vec3 lightDir1 = normalize(vec3(-2.0, 2.0, .75));\n    const vec3 dcol1 = HSV2RGB(vec3(0.8, 0.666, 0.5));\n    const vec3 scol1 = HSV2RGB(vec3(0.9, 0.75, 6.0));\n    float cd1 = max(dot(lightDir1, cn), 0.0);\n    cd1 *= cd1;\n    cd1 *= cd1;\n    float cs1 = max(dot(lightDir1, cr), 0.0);\n\n    const vec3 lightDir2 = normalize(vec3(1.0, -2.0, -3.));\n    const vec3 dcol2 = HSV2RGB(vec3(0.06, 0.95, 0.95));\n    const vec3 scol2 = HSV2RGB(vec3(0.06, 0.75, 8.0));\n    float cd2 = max(dot(lightDir2, cn), 0.0);\n    cd2 *= cd2;\n    cd2 *= cd2;\n    float cs2 = max(dot(lightDir2, cr), 0.0);\n\n    vec3 ccol = vec3(0.0);\n    ccol += mix(0.0, 1.0, cd0)*(dcol0+0.5*cn);\n    ccol += scol0*pow(cs0, 20.0)*fre;\n\n    ccol += mix(0.05, 1.0, cd1)*(dcol1+0.125*cn);\n    ccol += scol1*pow(cs1, 8.0)*fre;\n\n    ccol += mix(0.0, 1.0, cd2)*dcol2;\n    ccol += scol2*pow(cs2, 20.0)*fre;\n\n    ccol *= tanh(10.0*z);\n\n    float d = length(p)-r;\n    col = mix(col, ccol, smoothstep(aa, -aa, d+0.0));\n  }\n\n  return col;\n}\n\nvec3 bkg(vec3 col, vec2 p) {\n  return vec3(1.0);\n}\n\nvec3 pillar(vec3 col, vec2 p) {\n  vec2 n = normalize(vec2(1.0));\n  float d0 = dot(n, p);\n  float d1 = d0-dot(n, vec2(BoxDim));\n  float d2 = d0-dot(n, vec2(-BoxDim));\n  float d3 = dot(vec2(n.y, -n.x), p);\n  float du = max(max(d1, -d2), -d3);\n  float db = max(max(d0, -d2), -d3);\n  float aa = 2.0/RESOLUTION.y;\n  const float fo = 1.75;\n  vec3 bcol = mix(BoxCol, HSV2RGB(vec3(0.55, 0.0, 1.0)), clamp(-fo*(p.y+BoxDim.y), 0.0, 1.0));;\n  vec3 ucol = mix(BoxCol, HSV2RGB(vec3(0.6, 0.6, 0.5)), clamp(0.667*fo*(p.x-BoxDim.x), 0.0, 1.0));;\n  col = mix(col, ucol, smoothstep(aa, -aa, du));\n  col = mix(col, bcol, smoothstep(aa, -aa, db));\n\n  return col;\n}\n\nvec3 box(vec3 col, vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  float d = box(p, BoxDim);\n  col = mix(col, BoxCol, smoothstep(aa, -aa, d));\n  return col;\n}\nvec3 effect(vec2 p, vec2 pp) {\n  vec3 col = vec3(0.0);\n\n  col = bkg(col, p);\n  col = pillar(col, p);\n  col = box(col, p);\n  col = sphere(col, p);\n//  col *= smoothstep(1.75, 0.5, length(pp));\n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[609, 609, 631, 631, 777], [1072, 1190, 1217, 1217, 1293], [1295, 1395, 1414, 1414, 1501], [1503, 1610, 1636, 1636, 1820], [1822, 1822, 1853, 1853, 3472], [3474, 3474, 3502, 3502, 3524], [3526, 3526, 3557, 3557, 4170], [4172, 4172, 4200, 4200, 4325], [4326, 4326, 4356, 4356, 4578], [4579, 4579, 4636, 4636, 4810]], "test": "untested"}
{"id": "DsySRm", "name": "Fractal mosaic 38", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 21, "viewed": 356, "published": 3, "date": "1680836463", "time_retrieved": "2024-07-30T18:01:54.768723", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    //a -= .5;\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,.5)\n    ,\n    \n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        uv = (uv+t2)/scale;\n        t2 = triangle_wave(uv-.5);\n        uv = t2-triangle_wave(uv.yx);\n        \n        col.x =\n            max(abs(uv.y-uv.x*sign(t2.x-t2.y))/2.,col.x)\n            //max(max(fract(t2.y-t2.x+.5),fract(uv.y-uv.x+.5))/3.,col.x)\n            //max(max(abs(t2.y-t2.x),abs(uv.y*sign(uv.x)-uv.x))/3.,col.x)\n        ;\n        col.x =\n            //abs(col-(1.-col.x));\n            max(abs(col.x-(1.-col.x)),col.x/4.);\n    }\n    fragColor = vec4(vec3(col.x),1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a),8.); i++){\n        a += mod(floor(a/2.),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    */\n    \n    //float a1 = a;\n    //a += floor(a1/4.)*2.;\n    //a += floor(a1/8.)*3.;\n    //a += floor(a1/16.)*5.;\n    //a += floor(a1/32.)*7.;\n    \n    return\n        //mod(floor(a),b)\n        max(mod(floor(-a),b),mod(floor(a),b))\n        //abs(mod(floor(-a),b))\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 = 8.;\n  float tempo = s1;\n  tempo = pow(2.,fmod(time*tempo,3.));\n  time /= tempo/pow(2.,fmod(time/tempo,3.))*2.;\n  float s2 = tempo,\n  t=\n      time*tempo\n  ,\n  m1 =\n      fmod(t*tempo,s2)\n  ,\n  m3 =\n      (fmod(t,abs(s2*tempo-m1)+1.)-m1);\n  t /=\n      (1.+fmod(t*tempo/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  float a=\n      64.*(1.-sqrt(fract(t/s1)/1.25))*.2\n  ,\n  nb = time*tempo*pow(2.,floor((m3+m2)/2.)/5.+5.5);\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsySRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 76, 239], [241, 241, 298, 298, 1078]], "test": "untested"}
{"id": "ddyXRh", "name": "RayTracing Material Properties", "author": "Txoka", "description": "Raytracer with some material properties.\nClick and drag to move camera.\nModify variables at Common.", "tags": ["raytracing", "reflection", "light", "sphere", "lightning", "metal", "material"], "likes": 2, "viewed": 266, "published": 3, "date": "1680809085", "time_retrieved": "2024-07-30T18:01:55.607480", "image_code": "float ACES(float x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 ACES(vec3 x){\n    return vec3(ACES(x.r),ACES(x.g),ACES(x.b));\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    vec4 light=texelFetch(iChannel0,ivec2(U),0);\n    vec3 l=light.rgb/light.w;\n    O.rgb=pow(l,vec3(1./gamma));\n    #ifdef TONEMAP\n    O.rgb=ACES(O.rgb);\n    #endif\n    O.w=1.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 random_normal(inout uvec3 x){\n    vec3 theta = tau * hash(x);\n    vec3 rho = sqrt( -2. * log(hash(x)) );\n    return rho * cos(theta);\n}\n\nvec2 random_in_circle(inout uvec3 x){\n    vec2 r = hash(x).xy;\n    r.x*=tau;\n    return vec2(sin(r.x),cos(r.x))*sqrt(r.y);\n}\n\nvec3 point_in_sphere(inout uvec3 x){\n    return normalize(random_normal(x));\n}\n\nRay getRayFromCamera(Cam camera, vec2 screenPos, float dis, uvec3 seed, float dx, float dof) {\n    vec3 p = vec3(camera.dir.x,0,camera.dir.z);\n    vec3 right = normalize(cross(p,vec3(0,1,0)));\n    vec3 up = normalize(cross(right, camera.dir));\n\n    float tanFovHalf = tan(radians(camera.fov) * 0.5);\n    vec3 screenCenter = camera.pos + camera.dir * dis;\n    vec2 screenSize = vec2(2.0 * tanFovHalf, 2.0 * tanFovHalf) * dis;\n    \n    screenPos+=random_in_circle(seed)*dx;\n    screenPos*=screenSize;\n    \n    vec2 jitter=random_in_circle(seed)*dof;\n    \n    vec3 screenPosWorld = screenCenter +  (screenPos.y*up+screenPos.x*right);\n    vec3 startpos=camera.pos + jitter.x*up+jitter.y*right;\n    \n    vec3 rayDirection = normalize(screenPosWorld - startpos);\n    \n    \n    \n    Ray ray;\n    ray.ro = startpos;\n    ray.rd = rayDirection;\n\n    return ray;\n}\n\nHitInfo hit_sphere(Ray r, Sphere s, float n){\n\tvec3 rc = r.ro-s.center;\n\tfloat c = dot(rc, rc) - (s.radius*s.radius);\n\tfloat b = dot(r.rd, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - n*sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\tfloat dist = mix(-1.,t,st);\n    \n    vec3 pos = r.ro + dist * r.rd;\n    vec3 dir = r.rd;\n    vec3 normal = normalize(pos - s.center);\n    Material m = s.material;\n    \n    bool hit=false;\n    \n    if(dist>=0.)hit=true;\n    \n    return HitInfo(hit,pos,dir,normal,dist,m);\n}\n\nfloat dp = 1e-4;\nRay bounce(inout HitInfo h, inout uvec3 seed){\n    if(!h.hit)return Ray(h.position,h.direction);\n    vec3 p = h.position + h.normal * dp;\n    vec3 specular = reflect(h.direction,h.normal);\n    \n    vec3 diffuse = normalize(h.normal+point_in_sphere(seed));\n    //vec3 diffuse = point_in_sphere(seed);\n    //if(dot(diffuse,h.normal)<0.)diffuse=-diffuse;\n    \n    bool isSpecular = hash(seed).x<h.material.specularprob;\n    h.material.specularprob=isSpecular?1.:0.;\n    vec3 newdir;\n    if(isSpecular){\n        newdir=normalize(mix(diffuse,specular,h.material.specularsmoothness));\n    }else{\n        newdir = normalize(mix(diffuse,specular,h.material.smoothness));\n    }\n    return Ray(p,newdir);\n}\n\n\nHitInfo next_hit(Ray r){\n    HitInfo h=HitInfo(false,r.ro,r.rd,vec3(0),0.,Material(0.,vec3(1),vec3(1),1.,vec3(0.),0.,false));\n    float dis=1e38;\n    for(int i=0;i<N;i++){\n        HitInfo z=hit_sphere(r,list[i],1.);\n        \n        \n        //if(i==2)z.material.emission=vec3(sin(iTime)*0.5+0.5);\n        \n        \n        if(z.dis<dis && z.hit){\n            h=z;\n            dis=z.dis;\n        }\n    }\n    return h;\n}\n\nvec3 skylight(vec3 dir){\n    return pow(texture(iChannel1,dir,0.).rgb,vec3(gamma));\n}\n\nvec3 calc_light(Ray r, int bounces, inout uvec3 seed){\n    HitInfo h = HitInfo(true,vec3(0),vec3(0),vec3(0),0.,Material(0.,vec3(1),vec3(0),1.,vec3(0),0.,false));\n    int n=bounces+1;\n    \n    vec3 raycol=vec3(1.);\n    vec3 light=vec3(0.);\n    \n    while(h.hit){\n        n--;\n        if(n<0)break;\n        \n        light+=h.material.emission*raycol;\n\n        raycol*=h.material.specularprob==0.?h.material.color:h.material.specularcolor;\n\n        \n        h=next_hit(r);\n        \n        r=bounce(h,seed);\n    }\n    if(!h.hit)light+=skylight(r.rd) * raycol;\n    \n    return light;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    vec2 pos=(iMouse.xy*2.-R.xy)/R.xy*0.5*tau;\n    if(iMouse.x==0.&&iMouse.y==0.)pos=vec2(-.4,-.5);\n    \n    pos*=vec2(-1,1);\n    uvec3 seed=uvec3(U,iFrame);\n    \n    vec3 camdir=vec3(sin(pos.x)*cos(pos.y/2.),sin(pos.y/2.),cos(pos.x)*cos(pos.y/2.));\n    \n    Cam c=Cam(CAM_POS,normalize(camdir),FOV);\n\n    vec2 uv = (U*2.-R.xy)/R.y;\n    \n    \n    float dx=2./R.y;\n\n    \n    vec3 light=vec3(0);\n    \n    for(int i=0;i<RAYS;i++){\n        Ray r = getRayFromCamera(c,uv,focus_distance,seed,dx,dof_intensity);\n        light+=calc_light(r,8,seed);\n    }\n    light/=float(RAYS);\n    O.rgb=light;\n    O.w=1.;\n    \n    vec4 lastframe=texelFetch(iChannel0,ivec2(U),0);\n    #ifdef REFINE\n    if(iMouse.z>0.){\n        lastframe*=0.;\n    }\n    O=lastframe+O;\n    #else\n    O.rgb=O.rgb*0.1+lastframe.rgb*0.9;\n    O.w=1.;\n    #endif\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float gamma=2.2;\nconst float tau=8.*atan(1.);\nconst uint k = 1103515245U;\nint RAYS=16;\n\nfloat focus_distance=1.;\nfloat dof_intensity=0.035;\nfloat FOV=60.;\nvec3 CAM_POS=vec3(0);\n\n#define REFINE\n#define TONEMAP\n\n\nstruct Material{\n    float smoothness;\n    vec3 color;\n    vec3 emission;\n    float specularsmoothness;\n    vec3 specularcolor;\n    float specularprob;\n    bool finish;\n};\n\nstruct HitInfo{\n    bool hit;\n    vec3 position;\n    vec3 direction;\n    vec3 normal;\n    float dis;\n    Material material;\n};\n\nstruct Sphere{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nstruct Plane{\n    vec3 normal;\n    float pos;\n    Material material;\n};\n\nstruct Triangle{\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n    Material material;\n};\n\n\nstruct Ray{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Cam{\n    vec3 pos;\n    vec3 dir;\n    float fov;\n};\n\nvec3 hash( inout uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nconst Material tomato=Material(0.,vec3(1,0,0),vec3(0),0.85,vec3(0.6),0.3,false);\nconst Material lightsource=Material(0.,vec3(1),vec3(10),1.,vec3(0),0.,false);\nconst Material white_metal=Material(0.4,vec3(1),vec3(0),0.,vec3(0.),0.,false);\nconst Material white_mate=Material(0.,vec3(1),vec3(0),0.,vec3(0.),0.,false);\nconst Material blue_mate=Material(0.,vec3(0,0,1),vec3(0),0.,vec3(0.),0.,false);\nconst Material green_mate=Material(0.,vec3(0,1,0),vec3(0),0.,vec3(0.),0.,false);\nconst Material red_mate=Material(0.,vec3(1,0,0),vec3(0),0.,vec3(0.),0.,false);\nconst Material black_tomato=Material(0.,vec3(0),vec3(0),0.9,vec3(0.6),0.3,false);\nconst Material mirror=Material(1.,vec3(1),vec3(0),0.,vec3(0.),0.,false);\n\nconst int N=10;\nSphere list[N]=Sphere[N](\n    Sphere(vec3(0,0,1),0.3,tomato),\n    Sphere(vec3(1,0,2),1.,white_metal),\n    Sphere(vec3(1,-1,0),0.5,lightsource),\n    Sphere(vec3(-5,0,10),1.,tomato),\n    Sphere(vec3(0,0,1010),1000.,green_mate),\n    Sphere(vec3(0,0,-1010),1000.,green_mate),\n    Sphere(vec3(1010,0,0),1000.,red_mate),\n    Sphere(vec3(-1010,0,0),1000.,blue_mate),\n    Sphere(vec3(0,-1010,0),1000.,black_tomato),\n    Sphere(vec3(0,1010,0),1000.,black_tomato)\n);\n\n#define R iResolution", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddyXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 77, 263], [265, 265, 283, 283, 333], [335, 335, 375, 375, 554]], "test": "untested"}
{"id": "csySzh", "name": "3D Simplex", "author": "polaroid", "description": "Shader using ray-marching to display a simplex only with the linear equations of the 3D simplex.", "tags": ["raymarchingsimplex"], "likes": 1, "viewed": 222, "published": 3, "date": "1680787934", "time_retrieved": "2024-07-30T18:01:56.482141", "image_code": "#define LIGHT_BLUE (vec3(172., 216., 230.) / 255.)\n\nmat2 rot(float a){\n float c = cos(a);\n float s = sin(a);\n return mat2(c, s, -s, c);\n}\n\n// Half Space with this equation\n// a0*x + a1*y + a2*z <= a3\nfloat sdPlane (vec3 p, float a0, float a1, float a2, float a3) {\n    vec3 normal = normalize(vec3(a0,a1,a2));\n    float d = dot(normal,p) - a3;\n    return d;\n}\n\nfloat sdf(vec3 p){\n float d1 = sdPlane(p, -1., 0., 0., 0.);\n float d2 = sdPlane(p, 0., -1., 0., 0.);\n float d3 = sdPlane(p, 0., 0., -1., 0.);\n float d4 = sdPlane(p, 1., 0., 0., 200.);\n float d5 = sdPlane(p, 0., 1., 0., 300.);\n float d6 = sdPlane(p, 1., 1., 1., 400.);\n float d7 = sdPlane(p, 0., 1., 3., 600.);\n return max(max(max(max(max(max(d1,d2),d3),d4),d5),d6),d7);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd){\n float eps = 0.0001;\n float maxSteps = 32.;\n\n float t = 0.;\n for(float i = 0.; i < maxSteps; i++){\n float d = sdf(ro + rd * t);\n if(d < eps) {\n float f = i/(maxSteps-1.);\n return vec2(t, f);\n }\n t += d;\n }\n return vec2(-1.);\n}\n\nvoid mainImage(\nout vec4 fragColor,\nin vec2 fragCoord\n) {\n vec2 uv = fragCoord.xy/iResolution.xy;\n uv -= 0.5;\n uv.x *= iResolution.x/iResolution.y;\n\n // Define camera position (eye) and target position\n vec3 ro = vec3(700., 1000., 600.);\n ro.xz *= rot(iTime * 0.3);\n vec3 targetPos = vec3(0., 0., 0.);\n    \n // Calculate forward, up, and right vectors\n vec3 forward = normalize(ro - targetPos);\n vec3 up = vec3(0.0, 1.0, 0.0);\n vec3 right = normalize(cross(forward, up));\n up = cross(right, forward);\n \n vec3 rd = normalize(uv.x * right + uv.y * up - forward);\n vec3 col = vec3(0., 0., 0.);\n \n vec2 hit = raymarch(ro, rd);\n float t = hit.x;\n float f = hit.y;\n if(t > 0.){\n  // grayscale: darker if more iterations\n  col = vec3(1., 0., 0.) * (1. - f);\n } else {\n  col = vec3(0., 0., 0.);\n }\n \n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csySzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 70, 70, 137], [139, 200, 264, 264, 359], [361, 361, 379, 379, 732], [734, 734, 766, 766, 993], [995, 995, 1052, 1052, 1816]], "test": "untested"}
{"id": "dsyXzD", "name": "Matrix Determinant (Raymarch)", "author": "polaroid", "description": "I choose the matrix determinant as my sdf with RayMarching. It looks kind of cool.", "tags": ["raymarchingmatrix"], "likes": 0, "viewed": 173, "published": 3, "date": "1680787875", "time_retrieved": "2024-07-30T18:01:57.392707", "image_code": "mat2 rot(float a){\n float c = cos(a);\n float s = sin(a);\n return mat2(c, s, -s, c);\n}\n\n// calcul le determinant d'une matrice\n/* \n    | p.x p.z |\n    |         | = p.x - p.z * p.y\n    | p.y 1.0 |\n*/\nfloat sdDet(vec3 p) {\n return (p.x - p.z * p.y);\n}\n\nfloat sdf(vec3 p) {\n float d = sdDet(normalize(p));\n return d;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd){\n float eps = 0.0001;\n float maxSteps = 32.;\n\n float t = 0.;\n for(float i = 0.; i < maxSteps; i++){\n float d = sdf(ro + rd * t);\n if(d < eps) {\n float f = i/(maxSteps-1.);\n return vec2(t, f);\n }\n t += d;\n }\n return vec2(-1.);\n}\n\nvoid mainImage(\nout vec4 fragColor,\nin vec2 fragCoord\n) {\n vec2 uv = fragCoord.xy/iResolution.xy;\n uv -= 0.5;\n uv.x *= iResolution.x/iResolution.y;\n\n // Define camera position (eye) and target position\n vec3 ro = vec3(2., 2., 2.);\n // float time0 = abs(cos(iTime*0.1));\n // float time1 = -2. * (1.-time0) + 3. * time0;\n ro.yz *= rot(iTime);\n vec3 targetPos = vec3(0., 0., 0.);\n    \n // Calculate forward, up, and right vectors\n vec3 forward = normalize(ro - targetPos);\n vec3 up = vec3(0.0, 1.0, 0.0);\n vec3 right = normalize(cross(forward, up));\n up = cross(right, forward);\n\n vec3 rd = normalize(uv.x * right + uv.y * up - forward);\n vec3 col = vec3(0., 0., 0.);\n\n vec2 hit = raymarch(ro, rd);\n float t = hit.x;\n float f = hit.y;\n if(t > 0.){\n  // grayscale: darker if more iterations\n  col = vec3(1., 0., 0.) * (1. - f);\n } else {\n  col = vec3(0., 0., 0.);\n }\n\n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 85], [87, 199, 220, 220, 249], [251, 251, 270, 270, 315], [317, 317, 349, 349, 576], [578, 578, 635, 635, 1471]], "test": "untested"}
{"id": "mdyXRD", "name": "Crosshatched Pumpkin", "author": "space928", "description": "A little modification of one of my old shaders to add crosshatching.", "tags": ["3d", "raymarching", "sdf", "crosshatch", "toon"], "likes": 8, "viewed": 223, "published": 3, "date": "1680783015", "time_retrieved": "2024-07-30T18:01:58.177608", "image_code": "const int MARCHSTEPS = 128;\nconst float MAX_DIST = 32.;\nconst float EPSILON = 0.01;\nconst vec3 pos = vec3(0.,0.0,-2.5);\nconst vec3 posTime = vec3(0.,0.0,0.);\nconst vec3 lightDir = normalize(vec3(0.5,0.5,-0.9));\nconst float rotRate = .8;\nconst float hatchDensity = 30.;\nconst float hatchThickness = 0.15;\nconst float hatchThicknessMod = 0.2;\nconst float hatchSoftness = 0.3;\nconst float hatchSquiggle = 0.015;\nconst float hatchSquiggleSize = .07;\nconst float pi = 3.1415926535;\n\n//https://iquilezles.org/articles/smin\nvec2 sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n//https://www.shadertoy.com/view/clB3zc\n#define sfractN(x,w)   min( fract(x)/(1.-(w)), fract(-x)/(w) )\n\nfloat map(vec3 p)\n{\n    //Body\n    vec3 pa = p + vec3(0,sin(iTime*2.)*0.3,0.);\n    pa.y *= 1.1;\n    float angle = atan(pa.x, pa.z);\n    float centreDist = length(pa.xz);\n    float radMod = sin(angle*16.)*0.03;\n    radMod += sin(angle*120.)*0.001;\n    radMod *= (centreDist*centreDist);\n    radMod -= (smoothstep(1.2, -.8, centreDist))*0.5;\n    float d = sdSphere(pa, 1. + radMod);\n    \n    //Stem\n    //Domain bending from:\n    float radMod2 = sin(angle*9.)*0.03;\n    radMod2 += sin(angle*23.)*0.005;\n    radMod2 *= smoothstep(0.02, 0.1, centreDist*centreDist);\n    radMod2 += sin(-pa.x*12.)*0.05+sin(pa.y*5.-1.)*0.03+sin(pa.z*25.)*0.01;\n    d = sminCubic(d, sdVerticalCapsule(pa, 1.1, 0.15+radMod2), 0.1).x;//sminCubic();\n    \n    //Eyes\n    d = max(d, -sdTriPrism(vec3(abs(pa.x),pa.y,pa.z)-vec3(0.3,0.2,-1.), vec2(0.15, 1.5)));\n    \n    //Mouth\n    vec2 c = vec2(sin(0.5), cos(0.5));\n    d = min(d, sdCappedTorus(vec3(pa.x,-pa.y,pa.z)-vec3(0.,-0.2,-0.97), c, 0.35, 0.08));\n    \n    //Floor\n    d = min(d, p.y+.8 + (sfractN(p.x, 0.1) + sfractN(p.z, 0.1))*0.1);\n    \n    return d;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    \n    for( int i=0;i<MARCHSTEPS;i++ ) {\n        vec3 p = o + r * t;\n        \n        float d = map(p);\n        \n        if(t > MAX_DIST) {\n            t = -1.0;\n            break;\n        }\n        \n        t += d;\n    }\n    return t;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 rotY(float x)\n{\n    float sx = sin(x);\n    float cx = cos(x);\n    return mat3(cx, 0., sx,\n                0., 1., 0.,\n                -sx, 0., cx);\n}\n\n//Random number [0:1] without sine\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*pi*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n// From: https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nconst int hatchLevels = 5;\n\n#define line(x, t, s) smoothstep(t, t + s, abs(x * 2. - 1.))\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat hatch(float x, vec2 uv)\n{\n    float s = texture(iChannel0, uv * hatchSquiggleSize).r * 1.;\n    s += texture(iChannel0, uv * hatchSquiggleSize * 0.5).r * 1.;\n    s += texture(iChannel0, uv * hatchSquiggleSize * 0.25).r * 1.;\n    float s1 = texture(iChannel0, uv * hatchSquiggleSize + vec2(0.1236587, 0.6379)).r * 1.;\n    s1 += texture(iChannel0, uv * hatchSquiggleSize + vec2(0.1236587, -0.6379) * 0.5).r * 1.;\n    s1 += texture(iChannel0, uv * hatchSquiggleSize + vec2(-0.1236587, 0.6379) * 0.25).r * 1.;\n    \n    float t0 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 1.) * 2. - 1.) * hatchThicknessMod);\n    float t1 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 2.) * 2. - 1.) * hatchThicknessMod);\n    float t2 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 3.) * 2. - 1.) * hatchThicknessMod) * 2.;\n    float t3 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 4.) * 2. - 1.) * hatchThicknessMod) * 2.;\n    float t4 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 5.) * 2. - 1.) * hatchThicknessMod) * 2.;\n    \n    float h0 = 1.-line(fract((uv.x + uv.y + s * hatchSquiggle)*hatchDensity), t0, hatchSoftness);\n    float h1 = 1.-line(fract((uv.x - uv.y + s1 * hatchSquiggle)*hatchDensity), t1, hatchSoftness);\n    float h2 = 1.-line(fract((uv.x + uv.y + 0.125 + s * hatchSquiggle)*hatchDensity*2.), t2, hatchSoftness*2.);\n    float h3 = 1.-line(fract((uv.x - uv.y + 0.125 + s1 * hatchSquiggle)*hatchDensity*2.), t3, hatchSoftness*2.);\n    float h4 = 1.;\n    \n    float h = h0 * step(1./float(hatchLevels+1), x);\n    h += h1 * step(2./float(hatchLevels+1), x);\n    h += h2 * step(3./float(hatchLevels+1), x);\n    h += h3 * step(4./float(hatchLevels+1), x);\n    h += h4 * step(5./float(hatchLevels+1), x);\n    \n    return saturate(h);\n}\n\n// Fragpos, surface normal, ray direction, ray depth\nvec3 shadeGBuff(vec3 p, vec3 n, vec3 d, float t, vec2 uv)\n{\n    vec3 col = mix(vec3(0.8, 0.9, 1.), vec3(0.5, 0.6, 1.), abs(saturate(d.y*2.)));\n    if(t != -1. && t < MAX_DIST)\n    {\n        float fog = 1.0 / (1.0 + t * t * 0.05);\n        fog = smoothstep(0., 0.9, fog);\n        \n        vec3 ambient = vec3(0.1,0.1,0.15);\n        float ao = saturate(1.-pow(ambientOcclusion(p, n, .5, 0.3), 3.)*1.2);\n        vec3 light = (1.-hatch(ao+pow(1.-saturate(dot(lightDir, n) * 0.4 + 0.6), 1.5), uv)) * vec3(1., .5, .02);\n        float spec = (pow(saturate(dot(normalize(lightDir + d), n)), 2.8));\n        light += (1.-hatch(1.-saturate(spec*2.) + ao*2., uv)) * vec3(1., 0.8, 0.5);\n        \n        col = mix(col, ambient + light, fog);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 2.0))*rotY((iTime-10.)*rotRate);\n    vec3 o = pos*rotY((iTime-10.)*rotRate) + (iTime*posTime);\n    float t = trace(o, r);\n    vec3 p = (o+r*t);\n    vec3 nrm = estimateNormal(p);\n\n    vec3 c = shadeGBuff(p, nrm, r, t, uv);\n\n    vec3 dbg = vec3(hatch(uv.x*0.25 + 0.5, uv));\n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 517, 562, 562, 709], [711, 759, 829, 829, 969], [971, 1019, 1072, 1072, 1131], [1133, 1181, 1217, 1217, 1300], [1302, 1302, 1335, 1335, 1361], [1467, 1467, 1486, 1497, 2549], [2551, 2551, 2580, 2580, 2839], [2841, 2841, 2870, 2870, 3150], [3152, 3152, 3172, 3172, 3306], [3368, 3368, 3389, 3389, 3507], [3509, 3509, 3541, 3541, 3644], [3645, 3645, 3690, 3690, 3782], [3784, 3831, 3915, 3915, 4459], [4588, 4588, 4619, 4619, 6420], [6422, 6475, 6534, 6534, 7231], [7233, 7233, 7290, 7340, 7810]], "test": "untested"}
{"id": "msGXRD", "name": "Logarithmic spiral of spheres", "author": "mrange", "description": "CC0: Logarithmic spiral of spheres\nMeh, been struggling coming up with shaders that\nTwitter art came to the rescue and this inspired me:\nhttps://twitter.com/MaxDrekker/status/1643694297605103630?s=20\n\n", "tags": ["spiral"], "likes": 34, "viewed": 523, "published": 3, "date": "1680782276", "time_retrieved": "2024-07-30T18:01:59.007390", "image_code": "// CC0: Logarithmic spiral of spheres\n//  Meh, been struggling coming up with shaders that\n//  Twitter art came to the rescue and this inspired me:\n//  https://twitter.com/MaxDrekker/status/1643694297605103630?s=20\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(1.2);\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nfloat forward(float l) {\n  return exp2(ExpBy*l);\n}\n\nfloat reverse(float l) {\n  return log2(l)/ExpBy;\n}\n\nvec3 sphere(vec3 col, mat2 rot, vec3 bcol, vec2 p, float r, float aa) {\n  vec3 lightDir = normalize(vec3(1.0, 1.5, 2.0));\n  lightDir.xy *= rot;\n  float z2 = (r*r-dot(p, p));\n  vec3 rd = -normalize(vec3(p, 0.1));\n  if (z2 > 0.0) {\n    float z = sqrt(z2);\n    vec3 cp = vec3(p, z);\n    vec3 cn = normalize(cp);\n    vec3 cr = reflect(rd, cn);\n    float cd= max(dot(lightDir, cn), 0.0);\n    vec3 cspe = pow(max(dot(lightDir, cr), 0.0), 10.0)*tanh(8.0*(bcol))*0.5;\n    vec3 ccol = mix(0.2, 1.0, cd*cd)*bcol;\n    ccol += cspe;\n    float d = length(p)-r;\n    col = mix(col, ccol, smoothstep(0.0, -aa, d));\n  }\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 4.0/RESOLUTION.y;\n\n  float ltm = 0.75*TIME;\n  mat2 rot0 = ROT(-0.125*ltm); \n  p *= rot0;\n  float mtm = fract(ltm);\n  float ntm = floor(ltm);\n  float gd = dot(p, p);\n  float zz = forward(mtm);\n\n  vec2 p0 = p;\n  p0 /= zz;\n\n  float l0 = length(p0);\n  \n  float n0 = ceil(reverse(l0));\n  float r0 = forward(n0);\n  float r1 = forward(n0-1.0);\n  float r = (r0+r1)/2.0;\n  float w = r0-r1;\n  float nn = n0;\n  n0 -= ntm;\n\n  vec2 p1 = p0;\n  float reps = floor(TAU*r/(w));\n  mat2 rot1 = ROT(0.66*n0); \n  p1 *= rot1;\n  float m1 = modPolar(p1, reps)/reps;\n  p1.x -= r;\n  \n  vec3 ccol = (1.0+cos(0.85*vec3(0.0, 1.0, 2.0)+TAU*(m1)+0.5*n0))*0.5;\n  vec3 gcol = (1.5+cos(0.5*vec3(0.0, 1.0, 2.0) + 0.125*ltm))*0.005;\n  mat2 rot2 = ROT(TAU*m1);\n\n  vec3 col = vec3(0.0);\n  float fade = 0.5+0.5*cos(TAU*m1+0.33*ltm);\n  col = sphere(col, rot0*rot1*rot2, ccol*mix(0.25, 1.0, sqrt(fade)), p1, mix(0.125, 0.5, fade)*w, aa/zz);\n  col += gcol*vec3(0.25, 0.125, 1.0)/max(gd, 0.0015);\n  col -= 0.1*vec3(0.0, 1.0, 2.0).zyx*(length(pp)+0.25);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, p);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGXRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 427, 476, 476, 875], [877, 877, 901, 901, 927], [929, 929, 953, 953, 979], [981, 981, 1052, 1052, 1599], [1601, 1601, 1631, 1631, 2720], [2722, 2722, 2777, 2777, 2948]], "test": "untested"}
{"id": "DdySzW", "name": "A circle a day", "author": "Plento", "description": "Circles", "tags": ["2d", "mouse", "color", "pseudo3d"], "likes": 80, "viewed": 3869, "published": 3, "date": "1680765115", "time_retrieved": "2024-07-30T18:01:59.866094", "image_code": "// Cole Peterson (Plento)\n\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec3 col = vec3(0);\n\n    float n = 30.;\n    for(float i = n; i >= 0.; i--){\n        float r = (.7+.48*sin(i*0.5))*.3;\n        vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y; // -1 to 1 uvs\n                \n        uv *= (i*.005 + .08); // scale\n        uv *= rot(-i*.05); // rotate\n\t\tuv.y += iTime*.02; // translate\n        \n        if(iMouse.z>0.)uv-=m*.1; // mouse\n        \n        vec2 id = floor(uv*19.), ruv = fract(uv*19.)-.5; // cell id and repeat uv\n        \n        vec3 nc = .55+.3*cos(vec3(2.,3.,0.4)*(id.x+id.y+i*0.2 + iTime*.5)*3.); // pick color\n        float s = pow(abs(dot(ruv, .8*vec2(cos(iTime), sin(iTime))))*4.9, 6.0); // shiny\n        nc *= (s+.55); // shiny\n        nc *= ((n-i) / n); // distance fade\n\n    \tcol = mix(col, nc, ss(r, r - .015, length(ruv))); // main color\n        col *= ss(0.003, 0.008, abs(length(ruv) - r+.005)); // outlines\n    }\n        f = vec4(1.-exp(-col),1.0); // smooth clamp output\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdySzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 245, 245, 1172]], "test": "untested"}
{"id": "mdKXz1", "name": "Fractal labyrinth mosaic remix", "author": "jarble", "description": "A remix of my \"fractal labyrithic mosaic\" shader.", "tags": ["fractal", "music", "mosaic", "labyrinth", "rug"], "likes": 7, "viewed": 188, "published": 3, "date": "1680751134", "time_retrieved": "2024-07-30T18:02:00.684904", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = vec2(1.,.5);\n    return abs(fract((a+a2)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    bool t3 = false;\n    vec2 uv1=uv;\n    for(int k = 0; k < 6; k++){\n        //uv = uv.yx;\n        uv = triangle_wave(uv+.5)-triangle_wave(uv.yx);\n        //uv *= sign(uv.x);\n        col.x =\n            max(abs(uv.y-uv.x)/(1.5+sign(uv.x-uv.y)),col.x)\n            //max(abs(uv.y*sign(uv.x)+uv.x*sign(uv.y))/2.,col.x)\n        ;\n        //if(uv.x<0.)\n        col = abs(col-1.+col.x);\n        //if(uv.x>uv.y){uv=uv.yx;}\n        //uv -= floor(1.)/8.;\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //divide by prime numbers to get interesting rhythms\n    float a1 = a;\n    //a /= 1. + mod(floor(a1/3.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a*pow(2.,mod(floor(a/8./8.),2.)))),b)\n        //max(mod(floor(a+1.)*floor(a),b),mod(floor(a),b))\n        //max(mod(floor(a),b),mod(floor(a)*floor(a),b))\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n        //mod(mod(floor((a)),floor(1.+(a)/3.)),b)\n        //fmod(a,b) mod(floor(a) + floor(b*fract(((a)/b))),b)\n        //abs(mod(floor(a)*2.,(b)*2.)-mod(floor(a),b))\n        //floor(mod(floor(pow(b,mod(floor((a)*2.)/b/b,b))/b/b),b))\n        //floor(mod(floor(pow(b,mod(floor((a)*2.)/b/b,b))/b/b),b))\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  float tempo = 8.;\n  tempo *= pow(2.,fmod(time*tempo,3.));\n\n  time /= tempo;\n  //time *= (1.+fmod(time*2.,2.));\n  //time /= (1.+fmod(time/2.,2.));\n  \n  float s1 =\n      8.;\n  //for(int i = 0; i < 5; i++){ time += fmod(floor(time*s1),2.); }\n\n  //time += floor(time*4.)/4.;\n\n  float s2 = tempo,\n  t=\n      time*tempo\n      //time*2./pow(2.,fmod(time*2.,3.))\n      //time + mod(time,2.)\n      //time*2.+floor(time/2.)*2.\n  ,\n  m1 =\n      fmod(t*4.,s2)\n      //fmod(t*3.+mod(t,2.),s2)\n  ,\n  m3 =\n      (fmod(t,abs(s2*2.-m1)+1.)-m1);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  float a=\n      64.*(1.-sqrt(fract(t/s1)/1.25))*.2\n  ,\n\n  nb = time*tempo*pow(2.,floor((m3+m2)/2.)/5.+6.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      //vec2(fract(time*nb*.998/4.*m2*s1)*a,fract(time*nb/4.*m2)*a)\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKXz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 102], [104, 104, 161, 161, 918]], "test": "untested"}
{"id": "mdVXR1", "name": "Interstellar Tesseract", "author": "victorberland", "description": "Shader inspired by the Tesseract from Interstellar.", "tags": ["video", "distort", "stretch"], "likes": 2, "viewed": 173, "published": 3, "date": "1680742371", "time_retrieved": "2024-07-30T18:02:02.030309", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = -uv.y;\n\tuv.x += sin(uv.y*0.0)/10.0;\n\tvec4 color = texture(iChannel0, uv);\n\tfragColor = color;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 203]], "test": "untested"}
{"id": "dsVXRh", "name": "Randomly Rotating Reflective Cub", "author": "vipiao", "description": "Simple shader for camera control.\nUse WASD for translating the camera.\nUse arrow keys to rotate camera.\nHold C or V to increase or decrease translational velocity.\nHold R or T to zoom in and out.", "tags": ["raymarching", "reflection", "control", "infinite"], "likes": 1, "viewed": 252, "published": 3, "date": "1680731703", "time_retrieved": "2024-07-30T18:02:02.936883", "image_code": "# define MAX_NUM_STEPS 75\n# define SHAPE_CUBE 1 // Set to 1 for cubes, 0 for spheres\n# define RANDOM_ROTATION 1 // Set to 1 for random rotation, 0 for no rotation\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n    return length(pos-center) - radius;\n}\n\nfloat sdSphereWorld(in vec3 pos){\n    pos = mod(pos, 1.0);\n    return sdSphere(pos, vec3(0.5), 0.25);\n}\n\nvec3 normalSphereWorld(in vec3 pos){\n    float sd = sdSphereWorld(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n        sdSphereWorld(pos - e.xyy),\n        sdSphereWorld(pos - e.yxy),\n        sdSphereWorld(pos - e.yyx)\n    ));\n    return normal;\n}\n\nfloat sdBox(in vec3 pos, in vec3 center, in vec3 dimensions){\n    vec3 q = abs(pos - center) - dimensions;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec3 rotateVector(vec3 v, vec3 axis, float angle) {\n    return v * cos(angle) + cross(axis, v) * sin(angle) + axis * dot(axis, v) * (1.0 - cos(angle));\n}\n\nvec3 randomAxis(float seed) {\n    float phi = mod(seed * 1.618033988749895, 1.0) * 6.283185307179586;\n    float costheta = mod(seed * 2.718281828459045, 1.0) * 2.0 - 1.0;\n    float theta = acos(costheta);\n\n    float x = sin(theta) * cos(phi);\n    float y = sin(theta) * sin(phi);\n    float z = cos(theta);\n    return vec3(x, y, z);\n}\n\nfloat randomAngle(float seed) {\n    return mod(seed * 3.141592653589793, 1.0) * 6.283185307179586;\n}\n\nfloat sdBoxWorld(in vec3 pos){\n    vec3 cubeCenter = vec3(floor(pos.x) + 0.5, floor(pos.y) + 0.5, floor(pos.z) + 0.5);\n    pos = mod(pos, 1.0);\n    #if RANDOM_ROTATION\n        float seed = cubeCenter.x * 137.0 + cubeCenter.y * 89.0 + cubeCenter.z * 61.0;\n        vec3 axis = randomAxis(seed);\n        float angle = randomAngle(seed);\n        pos = rotateVector(pos - vec3(0.5), axis, angle) + vec3(0.5);\n    #endif\n    float soft = 0.025; // Soft edges.\n    float sd = sdBox(pos, vec3(0.5), vec3(0.125)) - soft;\n    float reduction = 0.90; // Reduce the min signed distance for rotations\n    return sd * reduction;\n}\n\n\nvec3 normalBoxWorld(in vec3 pos){\n    float sd = sdBoxWorld(pos);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = normalize(sd - vec3(\n        sdBoxWorld(pos - e.xyy),\n        sdBoxWorld(pos - e.yxy),\n        sdBoxWorld(pos - e.yyx)\n    ));\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz);\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    float zoom = texelFetch(iChannel0, ivec2(CAMERA_ZOOM, 0), 0).x;\n    vec3 viewDir = normalize(forward*0.8*zoom + right * uv.x + up * uv.y);\n    \n    // Calculate color.\n    vec3 color = vec3(0.1,0,0);\n    vec3 reflectionConstant = vec3(1.0);\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.0;\n    int maxNumSteps = MAX_NUM_STEPS;\n    int numSteps = 0;\n    float minDist = 0.001;\n    vec3 prevPos = pos;\n    float prevSD = 0.0;\n    float sd = 0.0;\n    for(; numSteps < maxNumSteps; numSteps++){\n        prevSD = sd;\n        #if SHAPE_CUBE\n            sd = sdBoxWorld(pos);\n        #else\n            sd = sdSphereWorld(pos);\n        #endif\n        if(sd < minDist){\n            // Collision with shape.\n            pos = mix(pos, prevPos, (minDist - sd) / (prevSD - sd));\n            \n            #if SHAPE_CUBE\n                vec3 normal = normalBoxWorld(pos);\n            #else\n                vec3 normal = normalSphereWorld(pos);\n            #endif\n            if(dot(dir, normal) < 0.0){\n                dir = reflect(dir, normal);\n                reflectionConstant *= 0.8;\n                if(mod(pos.x, 0.1) < 0.01 || mod(pos.y, 0.1) < 0.01 || mod(pos.z, 0.1) < 0.01){\n                    if(mod(pos.x, 2.0) < 1.0){\n                        reflectionConstant.x *= 0.4;\n                    }\n                    if(mod(pos.y, 2.0) < 1.0){\n                        reflectionConstant.y *= 0.4;\n                    }\n                    if(mod(pos.z, 2.0) < 1.0){\n                        reflectionConstant.z *= 0.4;\n                    }\n                }\n            }\n            //\n        }\n        prevPos = pos;\n        pos += normalize(dir) * sd;\n        dist += sd;\n        color += vec3(0.04,0.05,0.06) * sd * reflectionConstant;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// --Global variables.\n\n// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\nconst int KEY_T  = 84;\n\n//\nconst int PREVIOUS_TIME = 0;\n\nconst int CAMERA_POS = 2;\nconst int CAMERA_SENSITIVITY = 3;\nconst int CAMERA_DIRECTION = 4;\nconst int CAMERA_ZOOM = 5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // Accelerate.\n    float sensitivity = texelFetch(iChannel0, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.03;\n            prevColor.r = 0.03;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 1000.){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.00001){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Zoom.\n    float zoom = texelFetch(iChannel0, ivec2(CAMERA_ZOOM, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_ZOOM,0)){\n        if(zoom == 0.){\n            zoom = 1.0;\n            prevColor.r = 1.0;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_R,0), 0 ).x > 0.5){\n            prevColor.r *= 1.02;\n        }\n        if(texelFetch( iChannel1, ivec2(KEY_T,0), 0 ).x > 0.5){\n            prevColor.r /= 1.02;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(0,1,0);\n    }\n    forward = normalize(forward);\n    vec3 right = normalize(cross(forward, vec3(0,0,1)));\n    vec3 up = cross(right, forward);\n    if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION,0)){\n        bool arrowRight = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n        bool arrowLeft = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n        bool arrowUp = texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x > 0.5;\n        bool arrowDown = texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n        float rotationSensitivity = 0.018/zoom;\n        if(arrowRight){\n            forward = normalize(forward + right*rotationSensitivity);\n        }\n        if(arrowLeft){\n            forward = normalize(forward - right*rotationSensitivity);\n        }\n        if(arrowUp){\n            forward = normalize(forward + up*rotationSensitivity);\n        }\n        if(arrowDown){\n            forward = normalize(forward - up*rotationSensitivity);\n        }\n    \tvec3 right = normalize(cross(forward, vec3(0,0,1)));\n    \tvec3 up = cross(right, forward);\n        prevColor.xyz = normalize(forward);\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel1, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x > 0.5;\n        if(wDown){\n        \tprevColor.xyz += forward*sensitivity;\n        }\n        if(sDown){\n        \tprevColor.xyz -= forward*sensitivity;\n        }\n        if(dDown){\n        \tprevColor.xyz += right*sensitivity;\n        }\n        if(aDown){\n        \tprevColor.xyz -= right*sensitivity;\n        }\n        if(spaceDown){\n        \tprevColor.xyz += up*sensitivity;\n        }\n        if(shiftDown){\n        \tprevColor.xyz -= up*sensitivity;\n        }\n    }\n    \n    \n    \n    // Write data/color.\n    fragColor = prevColor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 225, 225, 267], [269, 269, 302, 302, 372], [374, 374, 410, 410, 650], [652, 652, 713, 713, 828], [830, 830, 881, 881, 983], [985, 985, 1014, 1014, 1318], [1320, 1320, 1351, 1351, 1420], [1422, 1422, 1452, 1452, 2038], [2041, 2041, 2074, 2074, 2302], [2304, 2304, 2361, 2361, 4633]], "test": "untested"}
{"id": "mdKSzh", "name": "Interspersed Textures", "author": "pr1ncess_emily", "description": "A shader which intersperses tiles of two different textures using noise.", "tags": ["pixel"], "likes": 0, "viewed": 121, "published": 3, "date": "1680729772", "time_retrieved": "2024-07-30T18:02:03.918259", "image_code": "#define COLUMNS 10\n#define ROWS 10\n#define CHANNEL_A 0u\n#define CHANNEL_B 1u\n\nuvec2 getGridCoord(vec2 uv) {\n    float unitWidth = iResolution.x / float(COLUMNS);\n    float unitHeight = iResolution.y / float(ROWS);\n    uint column = uint(uv.x / unitWidth);\n    uint row = uint(uv.y / unitHeight);\n    return uvec2(column, row);\n}\n\nuint getChannel(uvec2 coord) {\n    float level = texture(iChannel0, vec2(coord) / 10.0).x;\n    if (level > 0.5) {\n        return CHANNEL_A;\n    }\n    return CHANNEL_B;\n}\n\nvec3 getColor(vec2 uv, uint channel) {\n    if (channel == CHANNEL_A) {\n        return texture(iChannel1, uv).xyz;\n    }\n    return texture(iChannel2, uv).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uvec2 coord = getGridCoord(fragCoord);\n    uint channel = getChannel(coord);\n    vec3 col = getColor(uv, channel);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKSzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 107, 107, 328], [330, 330, 360, 360, 499], [501, 501, 539, 539, 661], [663, 663, 720, 770, 988]], "test": "untested"}
{"id": "DsVXz1", "name": "Symbolism", "author": "QuantumSuper", "description": "An auto-VJ with glyphs, colors, and relations - use with music in iChannel0.\n\nInspired by alro's Neon Love: https://www.shadertoy.com/view/WdK3Dz\n", "tags": ["2d", "music", "gender"], "likes": 10, "viewed": 419, "published": 3, "date": "1680724789", "time_retrieved": "2024-07-30T18:02:04.865727", "image_code": "// Symbolism 0.74.230405 by QuantumSuper\n// auto-vj with glyphs, colors, and relations\n// inspired by alro's Neon Love: https://www.shadertoy.com/view/WdK3Dz\n//\n// - use with music in iChannel0 -\n// \n\n#define PI 3.14159265359 \n#define aTime 2.133333*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=1;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 86-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(2,8,7,4); ffts /= vec4(2,3,3,21); //normalize\n    fft.x = step(.9,fft.x); //weaken weaker sounds, hard limit\n    //fft.yzw*=1.3;ffts*=1.3; //debug factor for VirtualDJ (?limiter related?)\n}\n\nmat2 rotM(float a){float c = cos(a), s = sin(a); return mat2(c,s,-s,c);}\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nvec2 getHeart(float t){ //source: https://mathworld.wolfram.com/HeartCurve.html\n    return vec2( 16.*sin(t)*sin(t)*sin(t), //x\n                 13.*cos(t) - 5.*cos(2.*t) - 2.*cos(3.*t) - cos(4.*t)+1.) //y + shift\n                 /50.; //scale factor\n}\n\nvec2 getEight(float t){ //source: https://mathworld.wolfram.com/Lemniscate.html\n    return .5*cos(t)/(1.+sin(t)*sin(t))*vec2(1.,sin(t))/1.2;\n}\n\nvec2 getHArrow(float t){ //three lines resembling half an arrow\n    t = mod(t,PI); //one way\n    return (t<.15*PI)? vec2(-.6,.67-sin(t-.15*PI))/3.5 : (t<.8*PI)? vec2(-cos(t),cos(t))/3.5 : vec2(sin(t)+.2,-.8)/3.5;\n}\n\nvec2 getCurve(float t){ //a curving line segment\n    t = fract(sin(t));\n    t = (t<.01||t>.99)? 42.:t; //fix edge cases\n    return vec2(.7*t,t*t)/4.;\n}\n\nfloat getRing(vec2 p){ //simple ring with radius 1 about 0,0\n    return abs(length(p)-1.); \n}\n\nfloat getLine(vec2 p, vec2 a, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return 4.*length( pa - ba*h ); //factor 4 for visual style\n}\n\nfloat lightUp(float dist){ //light around dist=0\n    return 6.*smoothstep(.025, .0, dist)+clamp(.00008/dist/dist,.0,1.)+(1.+fft.w)*.0001/dist; //combined semi-hard shape with semi-soft & soft glow\n}\n\nvec3 getCol(float id){ //color definitions\n    vec3 col = vec3(1.);\n    id *= (id<1.)? 16. : 1.; //indirect overload \n    \n    if (id<1. ){ //random for id==0.\n        id = hash21(42.123+iResolution.xy*.1*ceil(aTime/4.+1.));\n        col = vec3(id,fract(id*10.),fract(id*100.))*255.;}\n    else if (id<2. ) col = vec3(252,157,  0); //miami orange\n    else if (id<3. ) col = vec3( 26,246,138); //miami green\n    else if (id<4. ) col = vec3(244,  0,204); //vw pink2\n    else if (id<5. ) col = vec3( 30, 29,215); //vw blue2\n    else if (id<6. ) col = vec3(231, 15, 20); //arena red\n    else if (id<7. ) col = vec3(103,211,225); //arena blue\n    else if (id<8. ) col = vec3( 54, 52, 80); //light lilac\n    else if (id<9. ) col = vec3(254,159,167); //light rose\n    else if (id<10.) col = vec3( 30,248,236); //magic turquoise\n    else if (id<11.) col = vec3(155, 11, 15); //splatter red\n    else if (id<12.) col = vec3( 11, 45,100); //king blue\n    else if (id<13.) col = vec3(141,245,180); //nordic green\n    else if (id<14.) col = vec3(131, 58,187); //nordic violet\n    else if (id<15.) col = vec3(241,214,109); //bambus yellow\n    else if (id<16.) col = vec3(  0,142,124); //bambus green\n    \n    return clamp(col/255.+min(ffts.x,min(ffts.y,ffts.z))-ffts.xyz,.0,1.); //alter color by ffts.xyz\n}\n\nvec3 makeSym(vec2 p, float id){ //glyph definitions (lots of redundant code but individually tweakable), reference: https://seechangehappen.co.uk/gender-identity-pride-flags-glyphs-symbols-and-icons/\n    vec3 col = vec3(0);\n    id *= (abs(id)<1.)? (id<.0)? 8.:20. : 1.; //indirect overload \n    float cid1 = hash21(vec2(.123*ceil(aTime/8.), id+id)); //color 1\n    float cid2 = (id<.0)? hash21(vec2(.456*ceil(aTime/8.), id*id)) : 0.; //color 2\n    float t = aTime;\n    \n    if (id<-3.){ //heart, animated\n        for (float n=0.;n<33.;n++){ //apperance is framerate dependent, adjust loop length, t increment, and intensity respectively\n            t -= .05;  \n            col += getCol(cid1)*lightUp(length(p-getHeart(t)));\n            col += getCol(cid2)*lightUp(length(p-getHeart(t+PI)));\n        }\n    }\n    else if (id<-2.){ //polyheart, animated\n        float cid3 = hash21(vec2(.789*ceil(aTime/8.), id*id*id)); //color 3\n        for (float n=0.;n<33.;n++){\n            t -= .05;  \n            col += getCol(cid1)*lightUp(length(p-getHeart(t)));\n            col += getCol(cid2)*lightUp(length(p-getHeart(t+PI)));\n            col += getCol(cid3)*lightUp(length(p+vec2(.0,.03)-getEight(t)));\n        }\n    }\n    else if (id<-1.){ //arrow, animated\n        for (float n=0.;n<33.;n++){\n            t -= .03; \n            col += getCol(cid1)*lightUp(length(p-getHArrow(t)));\n            col += getCol(cid2)*lightUp(length(-p.yx-getHArrow(t+PI/4.)));\n        }\n    }\n    else if (id<0.){ //ace, animated\n        p.y -= .08;\n        for (float n=0.;n<33.;n++){ \n            t -= .05; \n            col += getCol(cid1)*lightUp(length(-p-getHeart(t)));\n            col += getCol(cid2)*lightUp(length(-p-getHeart(t+PI)));\n            col += getCol(cid1)*lightUp(length(p+vec2(.2,.45)-getCurve(t)));\n            col += getCol(cid2)*lightUp(length(vec2(-p.x+.2,p.y+.45)-getCurve(t+PI)));\n        }\n    }\n    else if (id<1.){ //female\n        p.y -= .12;\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(0.,-.25), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(.12,-.36)) ));\n    }\n    else if (id<2.){ //male\n        p.y += .08;\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.17), vec2(.37)) )+\n        lightUp( getLine( p, vec2(.22,.38), vec2(.38)) )+\n        lightUp( getLine( p, vec2(.38,.22), vec2(.38)) ));\n    }\n    else if (id<3.){ //androgyne\n        p.y += .1;\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(-.1,.33), vec2(.1,.33)) )+\n        lightUp( getLine( p, vec2(-.1,.42), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(.1,.42), vec2(.0,.5)) ));\n    }\n    else if (id<4.){ //agender\n        p.y += .1;\n        col = getCol(cid1)*1e2*(\n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(-.23,.0), vec2(.23,.0)) ));\n    }\n    else if (id<5.){ //neutrois\n        p.y += .1;\n        col = getCol(cid1)*1e2*(\n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.5)) ));\n    }\n    else if (id<6.){ //intergender\n        p.y -= .12;\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.2,-.14), vec2(.38,-.32)) )+\n        lightUp( getLine( p, vec2(.14,-.2), vec2(.32,-.38)) )+\n        lightUp( getLine( p, vec2(.24,-.3), vec2(.16,-.38)) )+\n        lightUp( getLine( p, vec2(.38,-.18), vec2(.38,-.32)) ));\n    }\n    else if (id<7.){ //transgender\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(0.,-.25), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(.12,-.36)) )+\n        lightUp( getLine( p, vec2(.17), vec2(.37)) )+\n        lightUp( getLine( p, vec2(.22,.38), vec2(.38)) )+\n        lightUp( getLine( p, vec2(.38,.22), vec2(.38)) )+\n        lightUp( getLine( p, vec2(-.17,.17), vec2(-.37,.37)) )+\n        lightUp( getLine( p, vec2(-.22,.38), vec2(-.38,.38)) )+\n        lightUp( getLine( p, vec2(-.38,.22), vec2(-.38,.38)) )+\n        lightUp( getLine( p, vec2(-.3,.18), vec2(-.18,.3)) ));\n    }\n    else if (id<8.){ //genderflux\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(0.,-.25), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(.12,-.36)) )+\n        lightUp( getLine( p, vec2(.17), vec2(.37)) )+\n        lightUp( getLine( p, vec2(.22,.38), vec2(.38)) )+\n        lightUp( getLine( p, vec2(.38,.22), vec2(.38)) )+\n        lightUp( getLine( p, vec2(-.17,.17), vec2(-.35,.35)) )+\n        lightUp( getLine( p, vec2(-.38,.25), vec2(-.17,.3)) )+\n        lightUp( getLine( p, vec2(-.3,.17), vec2(-.25,.38)) ));\n    }\n    else if (id<9.){ //third gender\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(-.25,.0), vec2(-.35,.0)) )+\n        lightUp( getLine( p, vec2(-.5,.1), vec2(-.5,-.1)) )+\n        lightUp( getLine( p, vec2(-.5,.1), vec2(-.35,.0)) )+\n        lightUp( getLine( p, vec2(-.35,.0), vec2(-.5,-.1)) ));\n    }\n    else if (id<10.){ //genderqueer\n        p.y += .08;\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.49)) )+\n        lightUp( getLine( p, vec2(.1,.31), vec2(-.1,.43)) )+\n        lightUp( getLine( p, vec2(.1,.43), vec2(-.1,.31)) ));\n    }\n    else if (id<11.){ //pangender\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.49)) )+\n        lightUp( getLine( p, vec2(.1,.31), vec2(-.1,.43)) )+\n        lightUp( getLine( p, vec2(.1,.43), vec2(-.1,.31)) )+\n        lightUp( getLine( p, vec2(-.23,.0), vec2(.23,.0)) )+    \n        lightUp( getLine( p, vec2(.0,-.24), vec2(.0,-.5)) )+\n        lightUp( getLine( p, vec2(-.1,-.33), vec2(.1,-.33)) )+\n        lightUp( getLine( p, vec2(-.1,-.42), vec2(.0,-.5)) )+\n        lightUp( getLine( p, vec2(.1,-.42), vec2(.0,-.5)) ));\n    }\n    else if (id<12.){ //epicene\n        col = getCol(cid1)*1e2*(\n        lightUp( getRing( 4.2*p) )+\n        lightUp( length(2.*p) )+\n        lightUp( getLine( p, vec2(-.235,.05), vec2(-.35,-.1)) )+\n        lightUp( getLine( p, vec2(.235,-.05), vec2(.35,.1)) ));\n    }\n    else if (id<13.){ //demimale\n        p.y += .08;\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.17), vec2(.38)) )+\n        lightUp( getLine( p, vec2(.22,.38), vec2(.38)) ));\n    }\n    else if (id<14.){ //demifemale\n        p.y -= .12;\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(0.,-.24), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(-.01,-.36)) ));\n    }\n    else if (id<15.){ //bigender female male\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(0.,-.25), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(.12,-.36)) )+\n        lightUp( getLine( p, vec2(.17), vec2(.37)) )+\n        lightUp( getLine( p, vec2(.22,.38), vec2(.38)) )+\n        lightUp( getLine( p, vec2(.38,.22), vec2(.38)) ));\n    }\n    else if (id<16.){ //bigender androgyne neutrois\n        p.y += .1;\n        col = getCol(cid1)*1e2*(\n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(.17,-.17), vec2(.37,-.37)) )+\n        lightUp( getLine( p, vec2(.22,-.38), vec2(.38,-.38)) )+\n        lightUp( getLine( p, vec2(.38,-.22), vec2(.38,-.38)) )+\n        lightUp( getLine( p, vec2(.3,-.18), vec2(.18,-.3)) ));\n    }\n    else if (id<17.){ //bigender third gender demimale\n        col = getCol(cid1)*1e2*( \n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(-.25,.0), vec2(-.35,.0)) )+\n        lightUp( getLine( p, vec2(-.5,.1), vec2(-.5,-.1)) )+\n        lightUp( getLine( p, vec2(-.5,.1), vec2(-.35,.0)) )+\n        lightUp( getLine( p, vec2(-.35,.0), vec2(-.5,-.1)) )+\n        lightUp( getLine( p, vec2(.17), vec2(.38)) )+\n        lightUp( getLine( p, vec2(.22,.38), vec2(.38)) ));\n    }\n    else if (id<18.){ //bigender agender demifemale\n        col = getCol(cid1)*1e2*(\n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(-.23,.0), vec2(.23,.0)) )+\n        lightUp( getLine( p, vec2(0.,-.24), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(-.01,-.36)) ));\n    }\n    else if (id<19.){ //genderfluid male female\n        p *= rotM(PI/6.);\n        col = getCol(cid1)*1e2*(\n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(-.235,.05), vec2(-.35,-.1)) )+\n        lightUp( getLine( p, vec2(.235,-.05), vec2(.35,.1)) )+\n        lightUp( getLine( p, vec2(0.,-.24), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(.12,-.36)) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(-.1,.42), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(.1,.42), vec2(.0,.5)) ));\n    }\n    else if (id<20.){ //genderfluid androgyne female\n        p *= rotM(PI/6.);\n        col = getCol(cid1)*1e2*(\n        lightUp( getRing( 4.2*p) )+\n        lightUp( getLine( p, vec2(-.235,.05), vec2(-.35,-.1)) )+\n        lightUp( getLine( p, vec2(.235,-.05), vec2(.35,.1)) )+\n        lightUp( getLine( p, vec2(0.,-.24), vec2(.0,-.49)) )+\n        lightUp( getLine( p, vec2(-.12,-.36), vec2(.12,-.36)) )+\n        lightUp( getLine( p, vec2(.0,.24), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(-.1,.33), vec2(.1,.33)) )+\n        lightUp( getLine( p, vec2(-.1,.42), vec2(.0,.5)) )+\n        lightUp( getLine( p, vec2(.1,.42), vec2(.0,.5)) ));\n    } //incomplete list of course\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    compressFft(); //initializes fft, ffts\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1\n   \n    // Symbol\n    float symId = hash21(vec2(ceil(aTime/8.))); //randomize symbol choice\n    symId *= (fract(aTime/8.)<.75)? -1. : 1.; //define ratio between animated and static symbols\n    vec3 col = (.4*ffts.w+fft.x) * makeSym(uv/(.7+.4*ffts.w),symId);   \n    \n    // Background\n    float vBar,\n          spect = 6.*clamp(texelFetch(iChannel0,ivec2(int(511.*abs(fragCoord.y/iResolution.y-1.)),0),0).x-2.*abs(fragCoord.x/iResolution.x-.5),0.,1.); //audio spectrum pattern \n    uv = abs(10.*sin(aTime/64.)*uv); //zoom motion   \n    for (float n=.0;n<3.;n++){ \n        vBar = abs(fract(uv.x)-(.1+.7*hash21(n*ceil(uv.xx)+floor(4.*aTime))))-.05*n; //vertical bars\n        col += smoothstep(fwidth(vBar), .0, vBar) * smoothstep(.8, 0., length(col)) * spect * fft.z * col;\n    }\n\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32959, "src": "https://soundcloud.com/apashe/apashe-good-news", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVXz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 326, 411, 1548], [1550, 1550, 1569, 1569, 1622], [1624, 1624, 1645, 1715, 1808], [1810, 1810, 1833, 1889, 2062], [2064, 2064, 2087, 2143, 2206], [2208, 2208, 2232, 2271, 2422], [2424, 2424, 2447, 2472, 2575], [2577, 2577, 2599, 2637, 2670], [2672, 2672, 2710, 2769, 2916], [2918, 2918, 2944, 2966, 3116], [3118, 3118, 3140, 3160, 4408], [4410, 4410, 4441, 4609, 14378], [14380, 14380, 14436, 14436, 15440]], "test": "untested"}
{"id": "dsGSzh", "name": "2.5D Column Shadows Thingy", "author": "SnoopethDuckDuck", "description": "Instructions:\n    CLICK the screen to draw columns\n    WASD to move\n    Q to change mode\n    hold SPACE to stop collisions\n    R to reset\n   \ninspired by this shader: https://www.shadertoy.com/view/cdKXzR", "tags": ["raymarching", "game", "interactive", "sdf", "shadows", "buffer"], "likes": 25, "viewed": 320, "published": 3, "date": "1680702911", "time_retrieved": "2024-07-30T18:02:05.973764", "image_code": "#define MAX_STEPS 36.\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    \n    ivec2 ipx = ivec2(px);\n    vec4 txP = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txD = cell(ch0, ivec2(1, 0)); // Other data\n    vec4 txB = cell(ch2, ipx);         // SDF\n\n    // Point position\n    vec2 p = txP.xy;\n\n    // Ray direction\n    vec2 rd = normalize(px - p);\n \n    // Total distance travelled\n    float d = 0.;\n    \n    float mode1 = mix(1., -1., step(1., txD.r));\n    float mode2 = step(2., txD.r);\n    \n    // Step count (in raymarching loop)\n    float c = MAX_STEPS;\n    \n    for (float i = 0.; i < MAX_STEPS; i++) {\n        // Distance to scene from p\n        float d0 = cell(ch2, ivec2(p)).r;\n             \n        // I can't explain this part,\n        // d0 = min(distance to scene, distance to pixel), and   \n        // a + abs(d0 - a) == d0 when d0 > a\n        float a = 0.22 * mode1 * length(px-p);\n        d0 = min(a + abs(d0 - a), length(p - px));\n\n        // Add noise to hide banding effect\n        d0 += (2. * hash12(floor(0.5 * p)) - 1.);\n        \n        // Adding to d0 when mode1 == -1. (when columns are visible)\n        // removes the wall/floor part\n        d0 += 5. * mode2;\n        \n        // Make columns taller and thicker (really cool)\n        // d0 -= 20.;\n        \n        // Move along ray direction by some amount\n        // (smaller increments give a nicer result)\n        p += 0.3 * d0 * rd;   \n        \n        // Increase total distance travelled\n        d += d0;\n\n        // Break if close to sdf boundary\n        if (d0 < 2.) { // || length(px - txP.xy) > 140.) \n            c = i + 1.;\n            break; \n        }\n    }\n    \n    vec3 col = vec3(exp(0.2 - 0.0015 * vec3(1,2,6) * c * c));\n    \n    // Border\n    float m =  min(px.x, res.x - px.x);\n    m = min(m, min(px.y, res.y - px.y));\n    col = mix(col, vec3(0.8, 0.8, 1), exp(-0.5 * m));\n    \n    // Nyan cat shadows\n    // float mx = clamp(length(col), 0., 1.);\n    // col *= mix(texture(ch1, vec2(1,4)*px/res).rgb, vec3(1), mx);\n    \n    // alternatively:\n    // col *= mix(texture(ch1, vec2(2,8)*px/res).rgb, vec3(1), 1.-pow(mx,10.));\n\n    // Foggier version\n    // col = vec3(exp(-0.002*d));\n    \n    // Overlay circles\n    // col += 0.5 * txB.b ;\n    \n    // Overlay normals\n    // vec2 n = norm(ch2, ipx);\n    // col.gb *= .5 + .5 * n;\n     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n\n// This buffer stores point information\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txP = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txQ = cell(ch0, ivec2(1, 0)); // Other data\n    vec4 txA = cell(ch0, ipx);         // This buffer\n    \n    // Initialize point on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) {\n        if (ipx == ivec2(0,0) || ipx == ivec2(0,1))        \n            txA = vec4(floor(0.5 * res), 0, 0);    \n        else if (ipx == ivec2(1,0))\n            txA = vec4(0, 0, 0, 0);\n    }\n    \n    float spd = 0.5;\n    if (ipx == ivec2(0, 0)) {\n        // Update velocity\n        txA.z += spd * (key_val(KEY_D) - key_val(KEY_A));\n        txA.w += spd * (key_val(KEY_W) - key_val(KEY_S));\n        txA.zw *= 0.95;\n        \n        // Old/New distance to buffer\n        float d0 = cell(ch2, ivec2(txA.xy)).r;          \n        float d1 = cell(ch2, ivec2(txA.xy + txA.zw)).r; \n        \n        // Normal\n        vec2 n = norm(ch2, ivec2(txA.xy));\n        \n        // If crossed boundary then push back\n        // (could use (-n.y,n.x) to slide along distances instead)\n        if (d0 > br && d1 < br && !key_down(KEY_SPACE)) \n            txA.zw = -n * length(txA.zw);\n        \n        // Update position\n        txA.xy += txA.zw;               \n    } \n    \n    // Save old position (unused?)\n    else if (ipx == ivec2(0, 1)) \n        txA = txP;\n        \n    // Other data (toggle mode)\n    else if (ipx == ivec2(1, 0)) {\n        // Could be improved but works fine\n        if (key_down(KEY_Q) && txA.g == 0.) {\n            txA.r = mod(txA.r + 1., 3.);\n            txA.g = 1.;\n        }\n        else if (!key_down(KEY_Q))\n            txA.g = 0.;            \n    }\n   \n   fragColor = txA;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define res iResolution.xy\n\n#define ss(a) smoothstep(-1., 1., a)\n\n// Ball radius\n#define br 2.\n\n// using: https://www.shadertoy.com/view/DscGRH\n#define key_val(key) texelFetch(KEYBOARD, ivec2(key, 0), 0).x\n#define key_down(key) (int(key_val(key)) == 1)\n#define KEY_RESET 82\n#define KEY_SPACE 32\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_Q 81\n#define KEY_E 69\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\n// from: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nvec4 cell(in sampler2D ch, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(ch, 0));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0);\n}\n\n// from: https://www.shadertoy.com/view/3tfcDM\nvec2 norm(in sampler2D ch, in ivec2 p) {\n    ivec3 e = ivec3(0, -1, 1);\n    return normalize(vec2(cell(ch, p-e.zx).r - cell(ch, p-e.yx).r,\n                          cell(ch, p-e.xz).r - cell(ch, p-e.xy).r));\n}", "buffer_b_code": "#define KEYBOARD iChannel1\n\n// This buffer stores sdf\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    vec4 txB = cell(ch2, ipx); // This buffer\n    \n    // Initialize distances on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) \n        txB = vec4(res.y ,0,0,0);   \n    \n    // Max radius of circles\n    float maxR = 20.;\n    \n    // Mouse position\n    vec2 ms = iMouse.xy;\n        \n    // Values at mouse\n    vec4 txR = cell(ch2, ivec2(ms));\n        \n    // If not inside sdf boundary, draw\n    if (txR.r > 0.) {        \n        // Red: distance field\n        float r = min(maxR, txR.r);\n        float d = length(px - ms) - r;\n        txB.r = smin(txB.r, d, 15.);\n        \n        // -- Green, blue, alpha are probably unused -- \n        \n        // Green: fade from centre of circles\n        float l = length(px - ms);\n        txB.g = max(txB.g, 1.-l / r);\n        \n        // Blue: random [0,1] value for each circle\n        float b = hash22(ms + iTime).x;\n        txB.b = mix(txB.b, b, ss(r-l));\n        \n        // Alpha: radius of circles\n        txB.a = mix(txB.a, l, ss(r-l));          \n    }\n    \n    fragColor = txB;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGSzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 73, 73, 2406]], "test": "untested"}
{"id": "ddGXRh", "name": "UV Transform Matrix", "author": "cambalamas", "description": "UV Transform Matrix", "tags": ["uv", "matrix", "transform"], "likes": 0, "viewed": 188, "published": 3, "date": "1680699838", "time_retrieved": "2024-07-30T18:02:06.744702", "image_code": "mat3 rst(float r, float f, vec2 t)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat3( c*f, s  , t.x , -s , c*f, t.y , 0 ,  0 ,  1  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    float t = iTime/5.0;\n    float s = sin(t);\n    float c = cos(t);\n    \n    float rot = radians(0.0);\n    float scl = 1.0;\n    vec2  pos = vec2(0.3, 0.0);\n    \n    mat3 m = rst(rot, scl, pos);\n    vec3 uv3 = vec3(uv,1.0);\n    \n#if 1\n    uv3 *= m;       // wtf? why yes?\n#else\n    uv3 = m * uv3;  // wtf? why not?\n#endif\n\n    uv = uv3.xy;\n    fragColor = vec4(texture(iChannel0,uv + 0.5));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 147], [149, 149, 206, 206, 650]], "test": "untested"}
{"id": "DdySRz", "name": "Distance estimated Julia", "author": "rucksack", "description": "It's all... a dream.", "tags": ["fractal", "julia"], "likes": 0, "viewed": 156, "published": 3, "date": "1680691223", "time_retrieved": "2024-07-30T18:02:07.508660", "image_code": "const int iterations = 50;\n\n// f_n(z) = f_n-1(z)^2 + c, f_0(z) = z\nvec2 next(vec2 z, vec2 c) {\n    float real = z.x * z.x - z.y * z.y + c.x;\n    float imag = 2. * z.x * z.y + c.y;\n    return vec2(real, imag);\n}\n\n// f'_n(z) = 2*f_n-1(z)*f'_n-1(z), f'_0(z) = 1\nvec2 derivative(vec2 z, vec2 dr) {\n    float real = z.x * dr.x - z.y * dr.y;\n    float imag = z.x * dr.y + z.y * dr.x;\n    return vec2(real, imag);\n}\n\nfloat map(vec2 z, vec2 c, out int i) {\n    i = 0;\n    vec2 dr = vec2(1, 0);\n    float d = 0.;\n    for (; i < iterations && length(z) < 2.*length(c); i++) {\n        z = next(z, c);\n        dr = derivative(z, dr);\n    }\n    return .5 * log(length(z)) * length(z)/length(dr);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float r = 0.7885;\n    float a = iTime + 2.88;\n    vec2 c = r * vec2(cos(a), sin(a));\n    //c = vec2(-0.4, 0.2);\n    \n    uv *= 3.*r; \n    int escape_time;\n    float d = map(uv, c, escape_time);\n    float f1 = (1. - .2*sqrt(d));\n    float f2 = sqrt(.4*abs(d));\n    float esc = float(10 + escape_time) / float(iterations);\n    vec3 col = esc * vec3(f2, 1, f1);\n\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdySRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 67, 94, 94, 210], [212, 259, 293, 293, 408], [410, 410, 448, 448, 684], [686, 686, 743, 743, 1202]], "test": "untested"}
{"id": "msVXzz", "name": "Desert Reflections 3", "author": "dr2", "description": "Reflecting saddle-shaped mirrors", "tags": ["mirror", "reflect", "desert", "pringle"], "likes": 12, "viewed": 180, "published": 3, "date": "1680684381", "time_retrieved": "2024-07-30T18:02:08.462110", "image_code": "// \"Desert Reflections 3\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nvec4 dateCur;\nvec3 sunDir, qHit, rPos;\nvec2 gId;\nfloat tCur, dstFar, hgSize, sRad, sAng;\nint idObj;\nbool isOcc;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SurfDf (vec3 p, float r)\n{  // (intersection of torus and cylinder)\n  float rt;\n  rt = 1.1 * r;\n  return max (abs (p.z) - rt, SmoothMax (abs (length (vec2 (length (vec2 (p.y, p.z - rt)) -\n     3. * rt, p.x)) - 2. * rt) - 0.01, length (p.xy) - r, 0.01));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= rPos;\n    q = p;\n    q.y -= -1.;\n    d = PrCylDf (q.xzy, 0.5, 2.);\n    DMINQ (1);\n    q.y -= 2.1 + sRad;\n    d = PrCylDf (q.xzy, 0.03, sRad + 0.1);\n    DMINQ (2);\n    q.xz = Rot2D (q.xz, sAng);\n    q.z += 0.2 * sRad;\n    d = SurfDf (q, sRad);\n    DMINQ (3);\n  }\n  return dMin;\n}\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nvoid SetGConf ()\n{\n  float h;\n  rPos.xz = 0.5 * hgSize * sin (2. * pi * Hashfv2 (17.1 * gId + 0.3) + vec2 (0.5 * pi, 0.));\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz);\n  h = Hashfv2 (19.1 * gId + 0.3);\n  isOcc = (abs (h - 0.5) < 0.45);\n  sRad = 3. + 0.5 * step (0.25, abs (h - 0.5));\n  sAng = (0.1 + 0.05 * h) * sign (2. * h - 1.) * tCur;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 col, vn;\n  float dFac, nDotL;\n  dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n  ro += dstObj * rd;\n  vn = ObjNf (ro);\n  if (idObj == 1) {\n    col = vec3 (0.7, 0.75, 0.8);\n    vn = VaryNf (16. * qHit, vn, 2. * dFac);\n  } else if (idObj == 2) {\n    col = vec3 (0.8, 0.8, 0.9);\n  } else if (idObj == 3) {\n    col = vec3 (0.9, 0.9, 1.);\n  }\n  nDotL = max (0., dot (vn, sunDir));\n  if (idObj == 2) nDotL *= nDotL;\n  col = col * (0.2 + 0.8 * nDotL) + 0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  col = mix (col, SkyBg (rd), pow (dstObj / dstFar, 4.));\n  return col;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dFac, f, sh;\n  dFac = 1. - smoothstep (0.15, 0.35, dstGrnd / dstFar);\n  ro += dstGrnd * rd;\n  vn = GrndNf (ro);\n  col = mix (vec3 (0.65, 0.5, 0.1), vec3 (0.9, 0.75, 0.4), smoothstep (1., 4., ro.y));\n  if (dFac > 0.) {\n    if (vn.y > 0.3) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.3, 0.8, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 4. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.95 + 0.05 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    gId = PixToHex (ro.xz / hgSize);\n    SetGConf ();\n    if (isOcc) col *= 0.8 + 0.2 * smoothstep (0.5, 0.7, length (ro.xz -\n       HexToPix (gId * hgSize) - rPos.xz));\n  }\n  sh = 1. - 0.6 * smoothstep (0.4, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.)));\n  col *= (0.2 + 0.1 * vn.y + 0.7 * sh * max (0., dot (vn, sunDir))) * (0.7 + 0.3 * dFac);\n  col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float dstGrnd, dstObj, dstObjO, nRef;\n  nRef = 0.;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n    if (k < 2 && dstObj < min (dstGrnd, dstFar) && idObj == 3 && length (qHit.xy) < 0.99 * sRad) {\n      ro += dstObj * rd;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.01 * rd;\n      ++ nRef;\n      if (k == 0) dstObjO = dstObj;\n    } else break;\n  }\n  if (min (dstObj, dstGrnd) < dstFar) col = (dstObj < dstGrnd) ? ObjCol (ro, rd, dstObj) :\n     GrndCol (ro, rd, dstGrnd);\n  else col = SkyCol (ro, rd);\n  col *= pow (0.8, nRef);\n  if (nRef == 1.) col = mix (col, SkyBg (rd), pow (dstObjO / dstFar, 4.));\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (2. * (v.z * a.x - v.x * a.z), -0.2 * pi, 0.2 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sunEl, sunAz, t, hSum, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 10., 36000.) + 30. * floor (dateCur.w / 7200.);\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  hgSize = 16.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 300.;\n  vuMat = StdVuMat (el, az);\n  t = 3. * tCur;\n  ro = TrackPath (t);\n  fpF = TrackPath (t + 1.);\n  fpB = TrackPath (t - 1.);\n  flMat = EvalOri ((fpF - fpB) / 2., fpF - 2. * ro + fpB);\n  hSum = 0.;\n  for (float k = 0.; k < 7.; k ++) hSum += GrndHt (TrackPath (t + 0.5 * (k - 1.)).xz);\n  ro.y = 4. + 8. * gr.hFac + hSum / 7.;\n  sunAz = 0.002 * 2. * pi * tCur;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunEl) * sin (sunAz + vec2 (0.5 * pi, 0.)), sin (sunEl)).xzy;\n  zmFac = 2.3;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = flMat * (vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv / vec2 (asp, 1.))) *\n       vec2 (asp, 1.), 1.)));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVXzz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[859, 859, 891, 932, 1120], [1122, 1122, 1144, 1144, 1528], [1530, 1530, 1553, 1553, 1809], [1811, 1811, 1829, 1829, 2161], [2163, 2163, 2196, 2196, 3434], [3436, 3436, 3457, 3457, 3712], [3714, 3714, 3748, 3748, 4228], [4230, 4230, 4252, 4252, 4391], [4393, 4393, 4418, 4418, 4797], [4799, 4799, 4843, 4843, 5042], [5044, 5044, 5066, 5066, 5160], [5162, 5162, 5194, 5194, 5524], [5526, 5526, 5572, 5572, 6165], [6167, 6167, 6215, 6215, 7132], [7134, 7134, 7169, 7169, 7879], [7881, 7881, 7912, 7912, 8181], [8183, 8183, 8209, 8209, 8322], [8324, 8324, 8380, 8380, 10067], [10069, 10069, 10111, 10111, 10162], [10164, 10164, 10186, 10186, 10224], [10226, 10226, 10271, 10271, 10363], [10365, 10365, 10410, 10410, 10448], [10450, 10450, 10474, 10474, 10704], [10706, 10706, 10730, 10730, 10790], [10792, 10792, 10822, 10822, 10935], [10937, 10937, 10973, 10973, 11179], [11213, 11213, 11237, 11237, 11297], [11299, 11299, 11323, 11323, 11435], [11437, 11437, 11462, 11462, 11648], [11650, 11650, 11671, 11671, 11826], [11828, 11828, 11857, 11857, 12069], [12071, 12071, 12110, 12110, 12362]], "test": "untested"}
{"id": "csVXzR", "name": "circular random tiling", "author": "ronwnor", "description": "once again porting a desmos into poorly written shadertoy for some of those effects\ntweet link: https://twitter.com/Pixelated_Donut/status/1643253675320655872?s=20\ngraph: https://www.desmos.com/calculator/2rmfalx3s0", "tags": ["tiling", "desmos"], "likes": 13, "viewed": 292, "published": 3, "date": "1680643270", "time_retrieved": "2024-07-30T18:02:09.321812", "image_code": "#define PI 3.1415926\n// le random\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\n// le rotate\nvec2 rot(vec2 uv, float a){\n    return vec2(uv.x*cos(a) - uv.y*sin(a), uv.y*cos(a) + uv.x*sin(a));\n}\n\n// 4 different tiles, selected by the choose variable\nfloat tile(vec2 xy, int choose){\n    float x = xy.x;\n    float y = xy.y;\n    \n    float tile = \n      choose == 0 \n    ? abs(sqrt((pow(abs(x+y)-2.,2.) + pow(x-y,2.))*.5)-1.)\n    : choose == 1\n    ? abs(sqrt((pow(abs(x-y)-2.,2.) + pow(x+y,2.))*.5)-1.)\n    : choose == 2\n    ? min(max(abs(x),.75-abs(y)),abs(y))\n    : min(max(abs(y),.75-abs(x)),abs(x));\n    \n    return max(tile, max(abs(.23*x),abs(.23*y)));\n}\n\nfloat f(float x, float y, int choose, float time){\n    return tile(\n        rot(mod(vec2(x,y)-1.,2.)-1., \n        .25*(PI + PI*tanh(15.*sin(time)))),\n        choose) < .25\n        ? 1.\n        : 0.;\n}\n\nvec3 f(vec3 x, vec3 y, int choose, float time){\n    return vec3(\n        f(x.x,y.x, choose, time),\n        f(x.y,y.y, choose, time),\n        f(x.z,y.z, choose, time));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 8.;\n    \n    float x = log2(length(uv)) - iTime*.25;\n    float y = atan(uv.y, uv.x)/PI;\n    x *= 5.;\n    y *= 24.;\n    y += 1.;\n    float temp = rand(round(vec2(x,y)*.5));\n    float time = iTime*.5 + 2.*PI*temp;\n    int random = int(4.*temp);\n\n    vec3 col = vec3(0.);\n    vec3 offset;\n    for(float i=0.; i<10.; ++i){\n        offset = i+vec3(-5, 0, 5);\n        col += .1*f(x-offset*.007, vec3(y), random, time + i*.002);\n    }\n    col += exp(.1-length(uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 34, 54, 54, 123], [124, 137, 164, 164, 237], [239, 293, 325, 325, 701], [703, 703, 753, 753, 903], [905, 905, 952, 952, 1074], [1076, 1076, 1130, 1180, 1768]], "test": "untested"}
{"id": "cdKXRR", "name": "TestForTestOfTest", "author": "overlapping", "description": "This shader is a test ", "tags": ["test"], "likes": 0, "viewed": 137, "published": 3, "date": "1680636474", "time_retrieved": "2024-07-30T18:02:10.100730", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv+.5;\n    vec4 webCam = texture(iChannel0,fract(uv*=mouse*.01));\n    // Time varying pixel color\n    vec2 col = 0.5 + 0.5*cos(uv);\n\n    // Output to screen\n    fragColor = normalize(webCam+=vec4(col,.234,0));\n    \n    \n    \n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 411]], "test": "untested"}
{"id": "ddySzz", "name": "floyd-steinberg tf potion", "author": "oatmealine", "description": "attempt at floyd-steinberg via recursive buffer gone wrong. messing around with the values is quite fun. look out for the division by zero dead pixels", "tags": ["2d", "dither", "palette", "floydsteinberg"], "likes": 0, "viewed": 287, "published": 3, "date": "1680631842", "time_retrieved": "2024-07-30T18:02:11.227716", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec4 buf = texture(iChannel0, fragCoord / iResolution.xy);\n  int idx = int(floor(buf.a * float(PALETTE_SIZE)));\n  fragColor = vec4(colors[idx], 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define SIMPLE_PALETTE\n\nfloat gray(vec3 color) {\n  return (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5;\n}\n\n#ifdef SIMPLE_PALETTE\nint getPalette(vec3 col) {\n  float g = clamp(gray(col), 0.0, 0.99);\n  return int(floor(g * float(PALETTE_SIZE)));\n}\n#else\nint getPalette(vec3 col) {\n  // comparasion\n  float minDist = 9e9;\n  int newCol;\n\n  for (int i = 0; i < PALETTE_SIZE; i++) {\n    vec3 compareCol = colors[i];\n\n    vec3 distVec = abs(col - compareCol);\n    float dist = (distVec.r + distVec.g + distVec.b) / 3.0;\n\n    if (dist < minDist) {\n      newCol = i;\n      minDist = dist;\n    }\n  }\n\n  return newCol;\n}\n#endif\n\nfloat fsin(float a) {\n  return sin(a) * 0.5 + 0.5;\n}\n\nvec3 hs(vec3 c, float s){\n  vec3 m=vec3(cos(s),s=sin(s)*.5774,-s);\n  return c*mat3(m+=(1.-m.x)/3.,m.zxy,m.yzx);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n\n  vec4 tex = texture(iChannel1, uv);\n  vec4 tex2 = texture(iChannel0, uv);\n  \n  float angle = iTime * 0.8 + uv.y * PI + uv.x * PI;\n  float amp = 2.0 + fsin(iTime * 1.7 + uv.y * PI + uv.x * PI) * 2.0;\n  \n  vec4 left = texture(iChannel0,     uv + dir(angle + PI,       amp) / iResolution.xy);\n  vec4 top = texture(iChannel0,      uv + dir(angle + -PI*0.5,  amp) / iResolution.xy);\n  vec4 topleft = texture(iChannel0,  uv + dir(angle + -PI*0.75, amp) / iResolution.xy);\n  vec4 topright = texture(iChannel0, uv + dir(angle + -PI*0.25, amp) / iResolution.xy);\n  \n  vec3 adjTex = tex.rgb +\n    (left.rgb     * 7./16. +\n    topright.rgb * 3./16. +\n    top.rgb      * 5./16. +\n    topleft.rgb  * 1./16.);\n\n  int colIdx = getPalette(adjTex);\n  vec3 col = colors[colIdx];\n  vec3 error = abs(tex.rgb - col);\n\n  fragColor = vec4(abs(error / (col + 0.02) / hs(1.0 - tex2.rgb, iTime * 0.2 - uv.y - uv.x) * 0.3), float(colIdx) / float(PALETTE_SIZE));\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926538\n\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\n#define PALETTE_SIZE 16\nvec3 colors[PALETTE_SIZE] = vec3[](\n  RGB(77,  0,   76 ),\n  RGB(143, 0,   118),\n  RGB(199, 0,   131),\n  RGB(245, 0,   120),\n  RGB(255, 71,  100),\n  RGB(255, 147, 147),\n  RGB(255, 213, 204),\n  RGB(255, 243, 240),\n  RGB(0,   7,   40 ),\n  RGB(0,   80,  96 ),\n  RGB(0,   187, 255),\n  RGB(7,   94,  0  ),\n  RGB(80,  199, 0  ),\n  RGB(136, 230, 86 ),\n  RGB(70, 20, 50),\n  RGB(145, 70, 100)\n);\n\nvec2 dir(float angle, float amp) {\n  return vec2(cos(angle) * amp, sin(angle) * amp);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddySzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 209]], "test": "untested"}
{"id": "dsyXzR", "name": "Colored blob (Optimized)", "author": "Peace", "description": "I am terrible at naming things, Here's some more exciting names: Psychedelic blobatron 3000; Chromatic amorphous mass; Variegated cellular agglomeration; Prismatic morphological anomaly; Rainbow-hued protoplasmic mass; Technicolor amoeboid entity).", "tags": ["gradient", "blob", "orb", "colored", "smooth"], "likes": 10, "viewed": 437, "published": 3, "date": "1680628788", "time_retrieved": "2024-07-30T18:02:12.169199", "image_code": "vec4 perm(vec4 x) { x = ((x * 34.0) + 1.0) * x; return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * 0.02439024);\n    vec4 o2 = fract(k4 * 0.02439024);\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat specular(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    return max(0.0, dot(normal, normalize(light_dir + ray_dir)));\n}\n\nvec4 getColor(vec2 uv, vec3 col, float seed, float min_res)\n{\n    vec3 p = vec3(uv, iTime * .5 + seed);\n    uv += noise(p * 0.7) * 0.35 - noise(-p * 1.2) * 0.2;\n    float l = length(uv);\n    vec3 n = normalize(vec3(uv, -1.0));\n    const vec3 light_dir = vec3(0.6666, 0.6666, -0.3333);\n    vec3 view_dir = -normalize(vec3(uv, 1.0));\n    float light = 0.35 * pow(specular(light_dir, view_dir, n), 16.0);\n    float m = smoothstep(1.0, 1.0 - 3.0 / min_res, l);\n    vec3 color = pow(max(0.0, 2.0 - sqrt(l)), 10.0) * col;\n    vec3 nc = abs(n + vec3(0, 0, 0.3));\n    col = normalize(col + pow(nc, vec3(7.0)) * vec3(7)) + col * 0.35;\n    color = mix(color, col, m) + light;\n    return vec4(color, m);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * 1.9;\n    vec4 col1 = getColor(uv * 0.98, vec3(1.0, 0.37, 1.0), 0.0, min_res);\n    vec4 col2 = getColor(uv, vec3(0.1, 0.55, 1.0), -612.734, min_res);\n    vec3 col = mix(col1.rgb, col2.rgb, clamp(0.5 + 0.5 * (col2.w - col1.w), 0.0, 1.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 94], [96, 96, 117, 117, 604], [606, 606, 665, 665, 733], [735, 735, 796, 796, 1429], [1431, 1431, 1486, 1486, 1873]], "test": "untested"}
{"id": "ddGXzR", "name": "Graphic Design Experiment 7", "author": "yasuo", "description": "truchet experiment", "tags": ["graphicdesign", "cineshader", "y2k"], "likes": 43, "viewed": 1967, "published": 3, "date": "1680626312", "time_retrieved": "2024-07-30T18:02:13.988335", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(3.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define R45(p) (( p + vec2(p.y,-p.x) ) *.707)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SymdirY(p) mod(floor(p).y,2.)*2.-1.\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat animateAarrow(vec2 p){\n    float dir = SymdirY(p);\n    p.y+=iTime*0.2*dir;    \n    p.y = mod(p.y,0.3)-0.15;\n    p*=Rot(radians(45.));\n    float d = abs(B(p,vec2(0.05)))-0.02;\n    return d;\n}\n\nfloat arrow(vec2 p){\n    float d = Tri(p,vec2(0.15));\n    p-=vec2(0.0,-0.1);\n    float d2 = Tri(p,vec2(0.12));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat pattern0(vec2 p, float dir, float n, float size){\n    float d = length(p)-size;\n    p*=Rot(radians(45.+iTime*dir*30.+(n*5.)));\n    float d2 = abs(length(p)-0.25)-0.05;\n    d2 = max(-(abs(p.x)-0.05),d2);\n    return min(d,d2);\n}\n\nfloat pattern1(vec2 p, float dir, float n){\n    p*=Rot(radians(-45.+iTime*dir*60.+(n*10.)));\n    vec2 prevP = p;\n    p = DF(p,4.);\n    p -= vec2(0.17);\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.001,0.03));\n    \n    p = prevP;\n    p = DF(p,2.);\n    p -= vec2(0.18);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.001,0.05));\n    \n    d = min(d,d2);\n    p = prevP;\n    \n    d2 = abs(length(p)-0.12)-0.04;\n    \n    p = DF(p,1.5);\n    p -= vec2(0.18);\n    p*=Rot(radians(45.));\n    d2 = max(-B(p,vec2(0.02,0.2)),d2);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat pattern2(vec2 p, float dir, float n){\n    p*=Rot(radians(-45.+iTime*dir*60.+(n*10.)));\n    float d = abs(length(p)-0.29)-0.001;\n    p.x = abs(p.x)-0.12;\n    float d2 = length(p)-0.07;\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat pattern3(vec2 p, float dir, float n){\n    p*=Rot(radians(-45.+iTime*dir*60.+(n*10.)));\n    vec2 prevP = p;\n    p = DF(p,2.);\n    p -= vec2(0.2);\n    p*=Rot(radians(45.));\n    float d = Tri(p,vec2(0.06));\n    \n    p = prevP;\n    p = DF(p,2.);\n    p -= vec2(0.1);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.001,0.03));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat pattern4(vec2 p, float dir, float n){\n    p*=Rot(radians(-45.+iTime*dir*60.+(n*10.)));\n    vec2 prevP = p;\n    p = DF(p,2.);\n    p -= vec2(0.1);\n    p*=Rot(radians(45.));\n    float d = B(p,vec2(0.001,0.15));\n    \n    p = prevP;\n    p = DF(p,2.);\n    p -= vec2(0.17);\n    float d2 = B(p,vec2(0.04));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.08));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat drawGraphics(vec2 p){\n    vec2 prevP = p;\n\n    p.y+=iTime*0.1;\n    p*=5.;\n    vec2 id = floor(p);\n    vec2 gr = fract(p)-0.5;\n    vec2 prevGr = gr;\n    \n    float n = random(id);\n    float d = 10.;\n    if(n<0.5){\n        if(n<0.25){\n            gr*=Rot(radians(90.));\n            prevGr*=Rot(radians(90.));\n        }\n    \n        gr-=vec2(0.49);\n        d = abs(length(gr)-0.49)-0.05;\n        gr = prevGr;\n\n        gr+=vec2(0.49);\n        float d2 = abs(length(gr)-0.49)-0.05;\n        d = min(d,d2);\n        \n        gr-=vec2(0.08);\n        gr*=Rot(radians(225.));\n\n        d2 = arrow(gr);\n        d = min(d,d2);\n         \n        gr = prevGr;\n        gr-=vec2(0.42);\n        gr*=Rot(radians(45.));\n\n        d2 = arrow(gr);\n        d = min(d,d2);\n        \n        gr = prevGr;\n        gr*=Rot(radians(-45.));\n        d2 = animateAarrow(gr);\n        d = min(d,d2);\n    } else {\n        float size = 0.05;\n        \n        float dir = (n>=0.75)?1.:-1.;\n        \n        if(n>=0.5 && n<0.6){\n            d = pattern0(gr,dir,n, size);\n        } else  if(n>=0.6 && n<0.7){\n            d = pattern1(gr,dir,n);\n        } else  if(n>=0.7 && n<0.8){\n             d = pattern2(gr,dir,n);\n        } else  if(n>=0.8 && n<0.9){\n            d = pattern3(gr,dir,n);\n        } else {\n            d = pattern4(gr,dir,n);\n        }\n        \n        gr = prevGr;\n        gr = abs(gr)-0.42;\n        gr*=Rot(radians(45.));\n\n        float d2 = arrow(gr);\n        d = min(d,d2);\n        \n        gr = prevGr;\n        if(n>=0.65){\n            d2 = length(gr-vec2(0.49,0.))-size;\n            d = min(d,d2);\n\n            gr = prevGr;\n            gr-=vec2(-0.365,0.);\n            gr*=Rot(radians(90.));\n\n            d2 = Tri(gr,vec2(size*2.5));\n            gr = prevGr;\n            d2 = min(B(gr-vec2(-0.49,0.0),vec2(0.05)),d2);\n            d = min(d,d2);\n        } else {\n            d2 = length(gr-vec2(-0.49,0.))-size;\n            d = min(d,d2);\n\n            gr = prevGr;\n            gr-=vec2(0.365,0.);\n            gr*=Rot(radians(-90.));\n\n            d2 = Tri(gr,vec2(size*2.5));\n            gr = prevGr;\n            d2 = min(B(gr-vec2(0.49,0.0),vec2(0.05)),d2);\n            d = min(d,d2);\n        }\n        \n        gr = prevGr;\n        gr.y = abs(gr.y)-0.49;\n        d2 = length(gr)-size;\n        d = min(d,d2);\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    float thick = 0.008;\n    float d = drawGraphics(p);\n    col = mix(col,vec3(1.),S(abs(d)-thick,-0.01));\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[468, 468, 491, 491, 564], [566, 566, 594, 594, 762], [764, 764, 784, 784, 910], [912, 912, 967, 967, 1144], [1146, 1146, 1189, 1189, 1717], [1719, 1719, 1762, 1762, 1953], [1955, 1955, 1998, 1998, 2326], [2328, 2328, 2371, 2371, 2763], [2765, 2765, 2792, 2792, 5084], [5087, 5087, 5144, 5144, 5380]], "test": "untested"}
{"id": "mstSWS", "name": "Voxel Mosque", "author": "thepinkpanzer", "description": "A proof of concept. I use Cubemap A to generate and store a 128x128x128 cube of PBR materials; this can be generated in frame 0 and stored indefinitely. I then march rays through and use some linear interpolation to find edges, which are then rendered.", "tags": ["cube", "voxel", "cubemap", "cubemapa"], "likes": 4, "viewed": 356, "published": 3, "date": "1680621107", "time_retrieved": "2024-07-30T18:02:15.143247", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw   = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bloom = texture(iChannel1, fragCoord/iResolution.xy)/BLOOMRADIUS; //(Division is to normalize the Gaussians)\n    // Combining. I use the tanh() to soften high-brightness regions; it's all down to taste here.\n    fragColor = (tanh(0.8*pow(raw,vec4(1.2)) + 0.4*bloom));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// Random generation functions.\nvoid Vines(vec3 pos, vec3 scale, float density, inout Material material)\n{\n    float fill = (texture(iChannel1, fract(pos*32.))-0.5).r\n                +(texture(iChannel1, fract(pos*21.))-0.5).g*2.;\n                +(texture(iChannel1, fract(pos*43.))-0.5).b*0.5;\n    fill = fill - (length((pos.xyz-vec3(0,0.5,0))*scale)) + density;\n    if (pos.y < 0.)\n    {\n        if (fill > 0.)\n        {\n            material = Material(fill, vec3(0.4,0.9,0.2), vec3(0), 0.7, 0.3);\n        }\n        else\n        {\n            material.fill = max(material.fill, fill);\n        }\n    }\n}\nfloat Random(float seed)\n{\n    seed *= (952.453-seed);\n    seed  = fract(seed);\n    seed *= (152.453-seed);\n    seed  = fract(seed);\n    return seed;\n}\nvoid Rock(float fill, vec3 worldPos, inout Material material)\n{\n    float seed = texture(iChannel1, fract(worldPos)).r;\n    if (fill > 0.)\n    {\n        fill*= 1.-0.2*Random(seed);\n    }\n    material = Material(fill, vec3(0.8, 0.6, 0.45)+(2.*Random(seed+1.)-1.)*vec3(0.1,0.08,0.04)+(2.*Random(seed+2.)-1.)*vec3(0.03,-0.01,0.), vec3(0.), 0.1, 0.1);\n}\nvoid Rock2(float fill, vec3 worldPos, inout Material material)\n{\n    float seed = texture(iChannel1, fract(worldPos)).r;\n    if (fill > 0.)\n    {\n        fill*= 1.-0.1*Random(seed);\n    }\n    material = Material(fill, vec3(1.0, 0.9, 0.75)+(2.*Random(seed+1.)-1.)*vec3(0.06,0.05,0.04)+(2.*Random(seed+2.)-1.)*vec3(0.03,-0.01,0.), vec3(0.), 0.1, 0.1);\n}\nvoid Orange(float fill, inout Material material)\n{\n    material = Material(fill, vec3(1.0, 0.35, 0.15), vec3(0.), 0.1, 0.1);\n}\nvoid Blue(float fill, inout Material material)\n{\n    material = Material(fill, vec3(0.2, 0.3, 1.0), vec3(0.), 0.1, 0.1);\n}\nvoid Gold(float fill, inout Material material)\n{\n    material = Material(fill, vec3(1.0,0.7,0.16), vec3(0.), 0.5,0.9);\n}\nMaterial BuildWorld(vec3 worldPos)\n{\n    /*\n    Returns the material as a function of position. Building the universe!\n    \n    Remember that the Material constructor is:\n    Material(fill, vec3(albedo), vec3(emission), smoothness, metallic)\n    \n    This only should run once, so you can make it as horrifically complicated as you want :)\n    */    \n    Material material = Material(-10., vec3(0), vec3(0), 0., 0.);\n    \n    float fill = -10.;\n    float newFill;\n    \n    // Background\n    float bumpFill = -min(worldPos.x+0.4, worldPos.z+0.4)*200.;\n    bumpFill+=  sin(worldPos.x*30.+10.)*sin(worldPos.z*30.+18.)*sin(worldPos.y*0.4+43.)*5.;\n    bumpFill+=  sin(worldPos.x*80.+62.)*sin(worldPos.z*80.+30.)*sin(worldPos.y*20.+25.)*2.0;\n    bumpFill+=  sin(worldPos.x*70.+25.)*sin(worldPos.z*70.+60.)*sin(worldPos.y*12.+58.)*1.6;\n    bumpFill+=  sin(worldPos.x*40.+41.)*sin(worldPos.z*40.+80.)*sin(worldPos.y*8.+46.)*1.2;\n    \n    float smoothFill = length(pow((0.5-worldPos), vec3(5.,0.1,5.)));\n    \n    newFill = (smoothFill-0.6)*(1.-smoothstep(-0.4, 0.1,worldPos.y));\n    newFill+= bumpFill        *(   smoothstep(-0.4, 0.1,worldPos.y))*(1.-smoothstep(0.1,0.5,worldPos.y));\n    newFill+= (smoothFill-0.9)*(   smoothstep(0.1,0.5,worldPos.y));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Rock(fill, worldPos, material);\n    }\n    \n    // Mosque main block\n    vec3 deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos     /= vec3(0.3, 0.25, 0.3);\n    deltaPos      = abs(deltaPos);\n    newFill = 0.8-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Rock2(fill, worldPos, material);\n    }\n    \n    // Mosque main dome\n    deltaPos = worldPos - vec3(0.05,-0.18,0.05);\n    newFill = 0.15-length(deltaPos);\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n\n    // Mosque main dome top orb\n    deltaPos = worldPos - vec3(0.05,-0.02,0.05);\n    newFill = 0.03-length(deltaPos);\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n    \n    // Mosque spire\n    deltaPos = worldPos - vec3(0.05,0.15,0.05);\n    newFill  = deltaPos.y < 0. ? 0.03+length(deltaPos.xz)/deltaPos.y : -10.;\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n    \n    // Mosque side blocks\n    deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    deltaPos     *= vec3(10., 4., 10.);\n    deltaPos      = abs(deltaPos);\n    newFill = 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Rock2(fill, worldPos, material);\n    }\n    \n    // Mosque side domes\n    deltaPos = worldPos - vec3(0.05,-0.15,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    newFill = 0.08-length(deltaPos);\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Gold(fill, material);\n    }\n    \n    // Mosque blue stripes\n    deltaPos      = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    deltaPos     *= vec3(10., 4., 10.);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.6, 0, 0);\n    deltaPos     *= vec3(10., 1.4, 0.9);\n    deltaPos      = abs(deltaPos);\n    newFill       = 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    \n    deltaPos      = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0.22,0,0.22);\n    deltaPos     *= vec3(10., 4., 10.);\n    deltaPos      = abs(deltaPos.zyx);\n    deltaPos     -= vec3(0.5, 0, 0);\n    deltaPos     *= vec3(10., 1.4, 0.9);\n    deltaPos      = abs(deltaPos);\n    newFill       = max(newFill, 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z)));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Blue(fill, material);\n    }\n    \n    // Mosque orange blocks\n    deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos);\n    deltaPos     -= vec3(0,0,0.22);\n    deltaPos     *= vec3(16., 7., 40.);\n    deltaPos      = abs(deltaPos);\n    newFill = 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z));\n    \n    deltaPos = worldPos - vec3(0.05,-0.4,0.05);\n    deltaPos      = abs(deltaPos.zyx);\n    deltaPos     -= vec3(0,0,0.22);\n    deltaPos     *= vec3(16., 7., 40.);\n    deltaPos      = abs(deltaPos);\n    newFill = max(newFill, 1.-max(deltaPos.x, max(deltaPos.y, deltaPos.z)));\n    if (newFill > fill)\n    {\n        fill = newFill;\n        Orange(fill, material);\n    }\n    \n    // Vines\n    Vines(worldPos+vec3(0.4,-0.5,0.2),   vec3(0.8,0.04 ,0.3), 0.04, material); \n    Vines(worldPos+vec3(0.4,-0.5,-0.2),  vec3(0.8,0.035,0.2), 0.04, material); \n    Vines(worldPos+vec3(-0.25,-0.5,0.4), vec3(0.3,0.04 ,0.8), 0.04, material); \n    Vines(worldPos+vec3( 0.1,-0.5,0.4),  vec3(0.2,0.03 ,0.8), 0.04, material); \n    \n    return material;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    /*\n    Finds the current voxel, finds what material it should be, generates said material, then stores it.\n    Not much to it.\n    */\n    if (iFrame == 0)\n    {\n        int page;\n        vec3 worldPos     = WorldPosFromCube(fragCoord, rayDir, page);\n        Material material = BuildWorld(worldPos);\n        if      (page == 1)\n        {\n            fragColor     = vec4(material.albedo, material.fill);\n        }\n        else if (page == 2)\n        {\n            fragColor     = vec4(material.emission, material.smoothness);\n        }\n        else if (page == 3)\n        {\n            fragColor     = vec4(vec3(0), material.metallic);\n        }\n    }\n    else\n    {\n        fragColor = texture(iChannel0, rayDir);\n    }\n}", "cube_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nSTEPDIST is the Buffer A (final rendering) step distance. The cubemap resolution is\n128x128x128, so ideally you want STEPDIST < 128 for fine details, but for most stuff\nyou can do lower resolution. Might encounter issues with normals though.\n\nSHADSTEPDIST is the Buffer B (shadow) step distance. Don't need very good resolution,\nbut it only runs once (in frame 1) so it's not affecting performance much.\n\nMAINLIGHTDIR is the main light (sun) direction.\n\nBLOOMRADIUS is the radius of the Gaussian blur used for bloom (Buffers C+D)\n\nBLOOMSKIP is how many pixels the Gaussian blur skips over (for performance). The total \nnumber of calculations is ~BLOOMRADIUS/BLOOMSKIP.\n\nFeel free to use anything here for whatever you want.\n*/\n#define STEPDIST    1./256.\n#define SHADSTEPDIST 1./64.\n#define MAINLIGHTDIR normalize(vec3(1.2,2.7,1))\n#define BLOOMRADIUS 40.\n#define BLOOMSKIP 2.\n\nvec3 WorldPosFromCube(vec2 fragCoord, vec3 rayDir, out int dataPage)\n{\n    /*\n    Function to be used (primarily) in Cube A. Converts the fragCoord and ray direction\n    into world position, while storing the Data Page on the side.\n    \n    Note that while the cubemap has 6 faces, there are only 3 data pages as two faces\n    are required to fill out the 128x128x128 cube.\n    */\n    vec3 ard = abs(rayDir);\n    float m  = max(ard.x, max(ard.y, ard.z));\n    int bigCoord = int(fragCoord.x) + 1024*int(fragCoord.y);\n    if      (m ==  rayDir.x)\n    {\n        dataPage = 1;\n    }\n    else if (m ==  rayDir.y)\n    {\n        dataPage = 2;\n    }\n    else if (m ==  rayDir.z)\n    {\n        dataPage = 3;\n    }\n    else if (m == -rayDir.x)\n    {\n        dataPage = 1;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.y)\n    {\n        dataPage = 2;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.z)\n    {\n        dataPage = 3;\n        bigCoord+= 1024*1024;\n    }\n    int x = (bigCoord        )%128;\n    int y = (bigCoord/128    )%128;\n    int z = (bigCoord/128/128)%128; // % is unnecessary but why not\n    return (vec3(x,y,z)+0.5)/128.-0.5;\n}\nvec3 RoundWorldPos(vec3 worldPos)\n{\n    worldPos += 0.5;\n    worldPos *= 128.;\n    worldPos  = round(worldPos);\n    return worldPos;\n}\nvec3 CubeFromWorldPos(vec3 worldPos, int dataPage)\n{\n    /*\n    The inverse of WorldPosFromCube (well, kind of). Converts world position into the\n    ray direction needed to read that voxel (on that Data Page). Not exactly the inverse \n    of WorldPosFromCube in that WPFC uses the frag coords as primary input, while CFWP\n    spits out the ray direction.\n    \n    Note: worldPos is the **ROUNDED** world position.\n    */\n    if (worldPos.x > 127. || worldPos.y > 127. || worldPos.z > 127.\n     || worldPos.x < 0.   || worldPos.y < 0.   || worldPos.z < 0.  )\n    {\n        return vec3(0);\n    }\n    else\n    {\n        int bigCoord = ((int(worldPos.z)*128+int(worldPos.y))*128+int(worldPos.x));\n        bigCoord -= int(worldPos.z+1.) > 64 ?   1024*1024 : 0;\n        dataPage += int(worldPos.z+1.) > 64 ?           3 : 0;\n        dataPage -= 1;\n        vec3 rgVex[6] = vec3[6](vec3( 0, 0,-1),vec3( 1, 0, 0),vec3( 1, 0, 0),vec3( 0, 0, 1),vec3( 1, 0, 0),vec3(-1, 0, 0));\n        vec3 upVex[6] = vec3[6](vec3( 0,-1, 0),vec3( 0, 0, 1),vec3( 0,-1, 0),vec3( 0,-1, 0),vec3( 0, 0,-1),vec3( 0,-1, 0));\n        vec3 fwVex[6] = vec3[6](vec3( 1, 0, 0),vec3( 0, 1, 0),vec3( 0, 0, 1),vec3(-1, 0, 0),vec3( 0,-1, 0),vec3( 0, 0,-1));\n        vec2 uvs      = (vec2(bigCoord % 1024, (bigCoord/1024)%1024) + 0.5)/1024.;\n        uvs           = 2.*uvs - 1.;\n        vec3 rayDir   = (rgVex[dataPage]*uvs.x + upVex[dataPage]*uvs.y);\n        rayDir       += (fwVex[dataPage]);\n        return normalize(rayDir);\n    }\n}\nstruct Material\n{\n    /*\n    Struct to store material data, describing how light reflects (or doesn't) \n    or is emitted by a given material.\n    \n    Stored as follows:\n    Page 1: vec4(albedo,               fill)\n    Page 2: vec4(emission,       smoothness)\n    Page 3: vec4(<free space>,     metallic)\n    \n    That free space could be used for encoding other material properties. Haven't\n    decided what to do with it yet, if anything.\n    */\n    float fill;      // Will probably be 1 or 0 for now, might improve in time.\n    vec3  albedo;    // Reflected color of material (<1)\n    vec3  emission;  // Emitted color of material (can be >1)\n    float smoothness;// How smooth the material appears\n    float metallic;  // How 'metallic' the material appears\n};\n\nvec4 PBR(Material material, vec3 normal, vec3 viewDir, float shadowAttenuation)\n{\n    /*\n    How to render a material to a color!\n    Can mess around as needed; this is just what I found works.\n    */\n    \n    // Lighting\n    vec4 mainLightCol = vec4(1.2,1.1,0.9,0.)*1.5;\n    vec4 skyCol       = vec4(0.4,0.5,0.8,0.)*0.8;\n    \n    // Converting stuff to vec4\n    vec4 albedo       = vec4(material.albedo,0);\n    vec4 emission     = vec4(material.emission,0);\n    \n    vec4 total        = emission;\n    \n    // Specular Power (-> inf as smoothness -> 1.)\n    float sp          = 10.*(1./(1.-material.smoothness)-1.);\n    \n    // Fresnel (boosts specular towards edges)\n    float fresnel     = sqrt(0.6+0.4*pow(1.-abs(dot(normal,      viewDir)),5.));\n    float sunFresnel  = sqrt(0.6+0.4*pow(1.-abs(dot(normal, MAINLIGHTDIR)),5.));\n    \n    // Light Strength (light intensity per unit area)\n    float ls          = max(0., dot(normal, MAINLIGHTDIR));\n    \n    // Reflection proximity (goes from 0 to -2)\n    float rp          = dot(reflect(viewDir, normal), MAINLIGHTDIR)-1.;\n    \n    vec4 diffuse      = (1.-material.smoothness*fresnel*material.smoothness*sunFresnel)\n                        *albedo*ls;\n    diffuse          *= mainLightCol*shadowAttenuation;\n    diffuse          +=  albedo*(1.+normal.y)*skyCol;\n    vec4 specular_nm  = (   material.smoothness*fresnel*material.smoothness*sunFresnel)\n                        *sqrt(sp/(1.+(rp*rp*sp*sp))) * vec4(1.)*ls;\n    specular_nm      *= mainLightCol*shadowAttenuation;\n    vec4 specular_met =  sqrt(sp/(1.+(rp*rp*sp*sp))) * albedo * sunFresnel*fresnel*3.*ls;\n    specular_met     *= mainLightCol*shadowAttenuation;\n    specular_met     += albedo * sunFresnel*fresnel*2.*(1.+normal.y)*skyCol;\n    \n    vec4 lightingComb = mix(diffuse + specular_nm, specular_met, material.metallic);\n    \n    total            += lightingComb;\n    return total;\n}", "buffer_a_code": "#define PI 3.1415926\n\nMaterial GetMaterial(vec3 worldPos)\n{\n    /*\n    Simple function to get the material of a particular voxel. Used for GetFill.\n    */\n    vec3 cubePos1 = CubeFromWorldPos(worldPos, 1);\n    vec3 cubePos2 = CubeFromWorldPos(worldPos, 2);\n    vec3 cubePos3 = CubeFromWorldPos(worldPos, 3);\n    vec4 p1, p2, p3;\n    if (length(cubePos1) >= 0.5)\n    {\n        p1  = texture(iChannel0, cubePos1);\n        p2  = texture(iChannel0, cubePos2);\n        p3  = texture(iChannel0, cubePos3);\n    }\n    else\n    {\n        p1 = vec4(0);\n        p2 = vec4(0);\n        p3 = vec4(0);\n    }\n    return Material(p1.a, p1.xyz, p2.xyz, p2.a, p3.a);\n}\n\nfloat GetFill(vec3 worldPos, out Material material, out vec3 fillGradient)\n{\n    /*\n    Gets the fill level of the current voxel, the gradient, and the material.\n    The fill level is calculated by finding the four nearest voxels, and interpolating\n    between them. The fill gradient is used as a proxy for the normal vector.\n    \n    The material is determined by finding which voxel of the four nearest ones the normal\n    is pointing most away from. If the current position is 'full', this voxel will \n    necessarily itself be full, so there can be no funny business with accidentally finding\n    empty voxels.\n    */\n    worldPos += 0.5;\n    worldPos *= 128.;\n    vec3 roundedWorldPos = round(worldPos);\n    vec3 deltaWorldPos   = worldPos - roundedWorldPos;\n    vec3 deltaNormalized = sign(sign(deltaWorldPos)+0.01); // Returns positive if zero (don't like 0)\n    \n    Material M0 = GetMaterial(roundedWorldPos);\n    Material Mx = GetMaterial(roundedWorldPos + deltaNormalized*vec3(1,0,0));\n    Material My = GetMaterial(roundedWorldPos + deltaNormalized*vec3(0,1,0));\n    Material Mz = GetMaterial(roundedWorldPos + deltaNormalized*vec3(0,0,1));\n    \n    fillGradient = vec3((Mx.fill-M0.fill), (My.fill-M0.fill), (Mz.fill-M0.fill))*deltaNormalized;\n    float fill   = M0.fill + dot(fillGradient, deltaWorldPos);\n    fillGradient/= 128.;\n    \n    vec3  g      = fillGradient*deltaNormalized;\n    float m      = max(0.,max(g.x, max(g.y, g.z)));\n    if      (g.x == m)\n    {\n        material = Mx;\n    }\n    else if (g.y == m)\n    {\n        material = My;\n    }\n    else if (g.z == m)\n    {\n        material = Mz;\n    }\n    else\n    {\n        material = M0;\n    }\n    \n    return fill;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    Main rendering. \n    First, I set up the camera stuff, determine the total depth through the cube, if I hit it \n    (that's what sorting the faces is for). \n    Next: the big loop! March through, if I land in a full voxel, I break.\n    I tried adding some binary searching to refine it more but it just ended up crashing everything\n    when I tried to compile :/\n    Once the loop is done, if it's hit something, it does the shadow check and PBR rendering.\n    Could make smooth shadows by sampling surrounding pixels in the texture, but I didn't.\n    */\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI  / 2. + 2.5*PI/2.;\n    float phi   = (iMouse.y  - iResolution.y) / iResolution.y * PI / 2.;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition      = -2.*iCameraFwd;\n    \n    float m = 1.2;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    // SORTING FACES\n    float distXP =  (0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYP =  (0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZP =  (0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    float distXM = (-0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYM = (-0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZM = (-0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    vec3 faceList[6] = vec3[6]( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n                                vec3(-1,0,0),vec3(0,-1,0),vec3(0,0,-1));\n\n    float distList[6] = float[6]( distXP, distYP, distZP,\n                                  distXM, distYM, distZM);\n    \n    for (int n = 0; n < 5; n++)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            if (distList[i] > distList[i+1])\n            {\n                vec3 c        = faceList[i];\n                faceList[i]   = faceList[i+1];\n                faceList[i+1] = c;\n                \n                float r       = distList[i];\n                distList[i]   = distList[i+1];\n                distList[i+1] = r;\n            }\n        }\n    }\n    \n    // PREP\n    fragColor = vec4(0.);\n    Material material;\n    vec3 fillGradient;\n    \n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    \n    // MARCHING\n    if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n    {\n        float oldFill       = 0.;\n        vec3 startPosition  = iCameraPosition + distList[2]*iViewDirection;\n        float newFill;\n        for (float d = 0.; d < distList[3] - distList[2]; d+= STEPDIST)\n        {\n            vec3 position = startPosition + iViewDirection*d;\n            newFill       = GetFill(position, material, fillGradient);\n            if (newFill > 0. && oldFill <= 0.)\n            {\n                hit = true;\n                #ifdef BINSTEPS\n                    float delta = 0.;\n                    for (float n = 1.; n < BINSTEPS; n--)\n                    {\n                        if (newFill > 0.)\n                        {\n                            delta -= 1./pow(2., n);\n                        }\n                        else\n                        {\n                            delta += 1./pow(2., n);\n                        }\n                        newFill = GetFill(position + delta*iViewDirection, material, fillGradient);\n                    }\n                    newFill = GetFill(position + (delta+pow(2., -BINSTEPS))*iViewDirection, material, fillGradient);\n                #endif\n                hitPos = position;\n                break;\n            }\n            oldFill       = newFill;\n        }\n    }\n    if (hit)\n    {\n        // SHADOWS\n        vec3 sCameraRight    = -normalize(cross( vec3(0,1,0), MAINLIGHTDIR));\n        vec3 sCameraUp       =  normalize(cross(sCameraRight, MAINLIGHTDIR));\n        vec2 shadowCoord     = vec2(dot(sCameraRight, hitPos), dot(sCameraUp, hitPos));\n        shadowCoord          = (shadowCoord/2.)+0.5;\n        float shadowDepth    = texture(iChannel1, shadowCoord).r;\n        vec3 sViewDirection  = -MAINLIGHTDIR;\n        float shadowBias     = 0.01;\n        float shadowAttenuation;\n        if (dot(sViewDirection, hitPos) < shadowDepth + shadowBias)\n        {\n            shadowAttenuation = 1.;\n        }\n        else\n        {\n            shadowAttenuation = 0.;\n        }\n        // PBR\n        fragColor     = PBR(material, normalize(-fillGradient), iViewDirection, shadowAttenuation);\n    }\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float GetFill(vec3 worldPos)\n{\n    // Simple version because shadows aren't very fancy, nobody needs e.g. normals.\n    worldPos += 0.5;\n    worldPos *= 128.;\n    worldPos = round(worldPos);\n    vec3 cubePos1 = CubeFromWorldPos(worldPos, 1);\n    if (length(cubePos1) >= 0.1)\n    {\n        return texture(iChannel0, cubePos1).a;\n    }\n    else\n    {\n        return 0.;\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n    Same as rendering in Buffer A, but shadows are done in frame 1 once the cubemap is finished.\n    Shadows don't need to be redone because the Sun isn't changing direction. Shadows are done \n    using an orthographic perspective, and then stored as a depth map. Overall, a bit simpler\n    than the main rendering.\n    Geometry is then calculated in Buffer A to determine whether the surface is in shadow or not.\n    */\n    if (iFrame == 1)\n    {\n        vec3 iCameraRight    = -normalize(cross( vec3(0,1,0), MAINLIGHTDIR));\n        vec3 iCameraUp       =  normalize(cross(iCameraRight, MAINLIGHTDIR));\n        vec2 screenCoord     = (fragCoord/iResolution.xy-0.5)*2.;\n        vec3 iCameraPosition = screenCoord.x*iCameraRight + screenCoord.y*iCameraUp;\n        vec3 iViewDirection  = -MAINLIGHTDIR;\n\n        // SORTING FACES\n        float distXP =  (0.5-iCameraPosition.x)/iViewDirection.x;\n        float distYP =  (0.5-iCameraPosition.y)/iViewDirection.y;\n        float distZP =  (0.5-iCameraPosition.z)/iViewDirection.z;\n\n        float distXM = (-0.5-iCameraPosition.x)/iViewDirection.x;\n        float distYM = (-0.5-iCameraPosition.y)/iViewDirection.y;\n        float distZM = (-0.5-iCameraPosition.z)/iViewDirection.z;\n\n        vec3 faceList[6] = vec3[6]( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n                                    vec3(-1,0,0),vec3(0,-1,0),vec3(0,0,-1));\n\n        float distList[6] = float[6]( distXP, distYP, distZP,\n                                      distXM, distYM, distZM);\n\n        for (int n = 0; n < 5; n++)\n        {\n            for (int i = 0; i < 5; i++)\n            {\n                if (distList[i] > distList[i+1])\n                {\n                    vec3 c        = faceList[i];\n                    faceList[i]   = faceList[i+1];\n                    faceList[i+1] = c;\n\n                    float r       = distList[i];\n                    distList[i]   = distList[i+1];\n                    distList[i+1] = r;\n                }\n            }\n        }\n\n        fragColor = vec4(10.);\n        Material material;\n        vec3 fillGradient;\n\n        bool hit = false;\n        if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n        {\n            float oldFill       = 0.;\n            vec3 startPosition  = iCameraPosition + distList[2]*iViewDirection;\n            float newFill;\n            for (float d = 0.; d < distList[3] - distList[2]; d+= SHADSTEPDIST)\n            {\n                vec3 position = startPosition + iViewDirection*d;\n                newFill       = GetFill(position);\n                if (newFill > 0.)\n                {\n                    fragColor = vec4((dot(position, iViewDirection)));\n                    break;\n                }\n                oldFill       = newFill;\n            }\n        }\n    }\n    else\n    {\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    }\n}", "buffer_b_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // BLOOM (Gaussian blur in x)\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS-0.5; x < BLOOMRADIUS+1.5; x+= BLOOMSKIP)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*pow(texture(iChannel0, (fragCoord+vec2(1,0)*x)/iResolution.xy),vec4(2.));\n    }\n    fragColor /= sqrt(BLOOMRADIUS);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // BLOOM (Gaussian blur in y)\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS-0.5; x < BLOOMRADIUS+1.5; x+= BLOOMSKIP)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*texture(iChannel0, (fragCoord+vec2(0,1)*x)/iResolution.xy);\n    }\n    fragColor /= sqrt(BLOOMRADIUS);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstSWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 399]], "test": "untested"}
{"id": "DsGSRz", "name": "uni_01", "author": "AHS1222", "description": "asdf", "tags": ["asdf"], "likes": 11, "viewed": 470, "published": 3, "date": "1680615673", "time_retrieved": "2024-07-30T18:02:16.117642", "image_code": "#define smt(a, b, t) smoothstep(a, b, t)\n\nvec3 hsv2rgb( vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat rand(vec2 v){\n    v = fract(v * vec2(70.26593, 1.6682));\n    v += dot(v, v+23.45);\n    return fract(v.x*v.y);\n}\n\nvec2 rand_2(vec2 v){\n    float n = rand(v);\n    return vec2(n, rand(v + n));\n}\n\nfloat dist_line(vec2 which, vec2 p1, vec2 p2){\n    float r = clamp(dot(which - p1, p2 - p1) / dot(p2 - p1, p2 - p1), .0, 1.);\n    return length((which - p1)-(p2 - p1)*r);\n}\n\nfloat drawline(vec2 which, vec2 p1, vec2 p2, float w){\n    float dis = dist_line(which, p1, p2);\n    return smoothstep(.015*w, .005*w, dis)*smt(.8, .0, distance(p1, p2)-.25);\n}\n\nvec2 Getpos(vec2 v){\n    vec2 p = rand_2(v);\n    return vec2(.5)+.4*vec2(cos(p.x*(iTime+5.)), sin(p.y*(iTime+5.)));\n}\n\nvec3 layer(vec2 uv, float w){\n    float m=.0;\n    \n    \n    vec2 fl_uv = floor(uv);\n    vec2 fr_uv = fract(uv);\n    \n    vec2 id = Getpos(fl_uv);\n    m = smoothstep(.08*w, .01*w, distance(fr_uv, id))*abs(sin((iTime+id.x)*4.));\n    \n    vec2 p[9];\n    int num = 0;\n    for(float i=-1.; i<=1.; i++){\n        for(float j=-1.; j<=1.; j++){\n            p[num++] = vec2(i,j)+Getpos(fl_uv + vec2(i,j));\n        }\n    }\n\n    for(int i=0; i<9; i++){\n    m += drawline(fr_uv, p[4], p[i], w);\n    }\n    m += drawline(fr_uv, p[1], p[3], w);\n    m += drawline(fr_uv, p[1], p[5], w);\n    m += drawline(fr_uv, p[3], p[7], w);\n    m += drawline(fr_uv, p[5], p[7], w);\n    return vec3(m);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float yy = uv.y;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= .5;\n    \n    float t = iTime*.1;\n    float rs = sin(2.*t);\n    float rc = cos(2.*t);\n    uv *= mat2(rc, -rs, rs, rc);\n    \n    float m = .0;\n    vec3 v3 = vec3(1.);\n    vec2 fl_uv = floor(uv);\n    vec2 fr_uv = fract(uv);\n    \n    vec2 id = Getpos(fl_uv);\n    vec3 col = vec3(.0);\n    \n    for(float i=.0; i<1.; i+=1./8.){\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        float al = smoothstep(.0, .8, z) * smoothstep(1., .8, z);\n        v3 = 0.5 + 0.5*cos(-1.2*z+iTime+uv.xyx+vec3(0,2,4));\n       col += layer(uv*size + i*27.385, 1.)*al*v3;\n       col += layer(uv*size + i*27.385, .4)*pow(al, 2.);\n    }\n    \n    //col *= smoothstep(1., .7, yy)*smoothstep(.0, .3, yy);\n    v3 = 0.5 + 0.5*cos(iTime-1.2+uv.xyx+vec3(0,2,4));\n    col += vec3(.8*yy)*.3*v3;\n    col += vec3(.2*(1.-yy))*.3*v3;\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 65, 65, 297], [299, 299, 318, 318, 416], [418, 418, 438, 438, 496], [498, 498, 544, 544, 670], [672, 672, 726, 726, 848], [850, 850, 870, 870, 967], [969, 969, 998, 998, 1642], [1645, 1645, 1702, 1702, 2683]], "test": "untested"}
{"id": "ddtXWl", "name": "PathRunner", "author": "ProCeeDor", "description": "proceedor shadertoy path tracing\nhttps://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/", "tags": ["pathtracing"], "likes": 3, "viewed": 191, "published": 3, "date": "1680593843", "time_retrieved": "2024-07-30T18:02:17.100015", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    // apply exposure (how long the shutter is open)\n    color *= c_exposure;\n\n    // convert unbounded HDR color range to SDR color range\n    color = ACESFilm(color);\n\n    // convert from linear to sRGB for display\n    color = LinearToSRGB(color);\n    \n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "uint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n} \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n// consine weighted sampling\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\nstruct Material\n{\n    float percentSpecular;\n    float roughness;\n    vec3 albedo;\n    vec3 specularColor;\n    vec3 emissive;\n};\nstruct SRayHitInfo\n{\n    float dist;\n    vec3  normal;\n    Material material;\n};\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\n\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{    \n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n        }\n\t}\n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    \n    // cieling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 15.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 15.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 15.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.1f, 0.7f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);            \n        }        \n    }\n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.9f, 0.5f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n        hitInfo.material.percentSpecular = 0.1f;\n        hitInfo.material.roughness = 0.2f;\n        hitInfo.material.specularColor = vec3(0.9f, 0.9f, 0.9f);        \n    } \n    \n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);   \n        hitInfo.material.percentSpecular = 0.3f;\n        hitInfo.material.roughness = 0.2;\n        hitInfo.material.specularColor = vec3(0.9f, 0.9f, 0.9f);        \n    }    \n    \n    // a ball which has blue diffuse but red specular. an example of a \"bad material\".\n    // a better lighting model wouldn't let you do this sort of thing\n\tif (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.0f, 0.0f, 1.0f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.percentSpecular = 0.5f;\n        hitInfo.material.roughness = 0.4f;\n        hitInfo.material.specularColor = vec3(1.0f, 0.0f, 0.0f);        \n    }\n    \n    // shiny green balls of varying roughnesses\n    {\n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);       \n        }     \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(0.3f, 1.0f, 0.3f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 0.7f;\n            hitInfo.material.roughness = 0.25f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(0.3f, 1.0f, 0.3f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 0.4f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(0.3f, 1.0f, 0.3f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 0.2f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }        \n        \n        if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(0.3f, 1.0f, 0.3f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 0.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }           \n    }\n}\n\nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    // initialize\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n     \n    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)\n    {\n        // shoot a ray out into the world\n        SRayHitInfo hitInfo;\n        hitInfo.dist = c_superFar;\n        TestSceneTrace(rayPos, rayDir, hitInfo);\n         \n        // if the ray missed, we are done\n        if (hitInfo.dist == c_superFar)\n        {\n            ret += SRGBToLinear(texture(iChannel1, rayDir).rgb) * throughput * c_skyboxBrightnessMultiplier;\n            // ret += texelFetch(iChannel1, ivec2( (rayDir.xy + vec2(1.0f,1.0f))/2.0f * iChannelResolution[1].xy), 0).xyz * throughput;\n            break;\n        }\n        \n        // update the ray position\n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;\n        \n        float doSpecular = RandomFloat01(rngState) < hitInfo.material.percentSpecular ? 1.0f : 0.f;\n        if(doSpecular == 1.0f)\n        { \n            rayDir = reflect(rayDir, hitInfo.normal);\n            ret += hitInfo.material.emissive * throughput;\n            throughput *= hitInfo.material.specularColor;\n            \n        }\n        else\n        {\n            // calculate new ray direction, in a cosine weighted hemisphere oriented at normal\n            rayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));  \n            ret += hitInfo.material.emissive * throughput;\n            throughput *= hitInfo.material.albedo; \n        }\n        \n        // Russian Roulette\n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if(RandomFloat01(rngState)>p)\n                break;\n            throughput *= 1.0/p;\n        }\n    }\n  \n    // return pixel color\n    return ret;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState))-0.5f;\n\n    vec3 rayPos = vec3(0.0f, 0.0f, 0.0f);\n    float cameraDistance = 1.0f/tan(c_FOVDegrees*0.5f*c_pi/180.f);\n    vec3 rayTarget = vec3(((fragCoord+jitter)/iResolution.xy)*2.0f-1.0f, cameraDistance); \n    rayTarget.y /= iResolution.x / iResolution.y;\n    //rayTarget.x *= iResolution.x/iResolution.y;\n    vec3 rayDir = normalize(rayTarget - rayPos);\n    vec3 camPos = vec3(0.0f, 0.0f, 0.f);\n    vec3 color = GetColorForRay(camPos, rayDir, rngState);\n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n \n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n \n    // show the result\n    fragColor = vec4(color, blend);\n}\n\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The minimunm distance a ray must travel before we consider an intersection.\n// This is to prevent a ray from intersecting a surface it just bounced off of.\nconst float c_minimumRayHitTime = 0.01f;\n\n// after a hit, it moves the ray this far along the normal away from a surface.\n// Helps prevent incorrect intersections when rays bounce off of objects.\nconst float c_rayPosNormalNudge = 0.01f;\n\n// the farthest we look for ray hits\nconst float c_superFar = 10000.0f;\n\n// camera FOV\nconst float c_FOVDegrees = 90.0f;\n\n// number of ray bounces allowed max\nconst int c_numBounces = 8;\n\n// a multiplier for the skybox brightness\nconst float c_skyboxBrightnessMultiplier = 2.0f;\n    \n// a pixel value multiplier of light before tone mapping and sRGB\nconst float c_exposure = 0.5f; \n\n// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.\nconst int c_numRendersPerFrame = 8;\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nconst float KEY_SPACE = 32.5/256.0;\n\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n\t);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtXWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 418]], "test": "untested"}
{"id": "ds3XWS", "name": "Balloonfest '86", "author": "Plento", "description": "balloons", "tags": ["3d", "raymarch", "blur", "radialblur", "balloons"], "likes": 17, "viewed": 328, "published": 3, "date": "1680576427", "time_retrieved": "2024-07-30T18:02:17.872949", "image_code": "#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv2 = u / R - 0.5;\n    vec4 bA = ch(iChannel0, u);\n    vec3 col = bA.xyz;\n    \n    const int nSamples = 40;\n    float pc = -(1.0 / float(nSamples - 1));\n    \n    vec3 sum = vec3(0);\n    for(int i = 0;i < 50; i++){\n        float scale = 1. + (float(i)* pc);\n        vec3 temp = pow(texture(iChannel0, uv2 * scale + 0.5).xyz, vec3(9.));\n        sum += temp * .65 * clamp(hash12(u + sin(iTime)), 0.5,0.6 ) * 1.5;\n    }\n    sum /= float(nSamples);\n    \n    col += sum*1.2;\n    col = pow(col, vec3(2.5));\n    //col.xyz = col.xzy;\n    col *= ss(.46508, .465, abs(uv.y));\n    f = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Raaaaymarch\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\nmat2 rot(float a) {return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nconst vec3 b = vec3(14., 18., 14.);\n\n// https://iquilezles.org/articles/distfunctions/\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - .1;\n}\n\nfloat line( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat balloon(vec3 p, vec3 id){\n    float h = .1*sin(p.y*.5);\n    float g = box(p - vec3(0., -2.8, 0.), vec3(.07));\n    float bal = length(p*vec3(1.15 + h, 0.9, 1.2 - h))-2.5;\n    return min(g, bal);\n}\n\n\nfloat map(vec3 rp){\n    float d = 999.;\n    vec3 p = rp - vec3(0., 0., 4.);\n    vec3 id = floor(p / b);\n    p = mod(p, b) - b*.5;\n    \n    p.y += cos(iTime*.4 + id.z*5. + id.x*3.) * 1.5;\n    p.x += sin(-iTime*.44 + id.z*2. + id.x*4.) * 1.4;\n    \n    return balloon(p, id);\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float d = 0.0, t = 0.0;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(d < 0.001 || t > 150.) break;\n        t += d * .75;\n    }\n    return t;\n}\n\nvec3 color(vec3 p, vec3 rd, vec3 n){\n    vec3 ref = reflect( rd, n );\n    float fres = ss(-.78, .78, dot(rd, n));\n    float dom = ss(-0.5, 0.5, ref.y);\n    vec3 lp = p+vec3(0., 7.0, -12.);\n    vec3 ld = normalize(lp-p);\n    \n    float dif = max(dot(n, ld), .3);\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 53.);\n    \n    vec3 id = floor(p / b);\n    \n    float k = id.x*3.+id.z*4.+id.y*5.;\n    vec3 objCol = .5+.95*cos(vec3(3., 2., 1.1)*k);\n  \n    vec3 col = .4*(objCol * dif) + .4*spec*vec3(1., 1., 1.);\n    col += fres*.6;\n    col += dom*.12;\n\n\treturn 1.-exp(-col*2.1);   \n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 1.5));\n    vec3 ro = vec3(5. + iTime*2., 9. , 0.);\n    rd.yz *= rot(-.42);\n    rd.xz *= rot(-.42);\n    rd.xy *= rot(.12);\n    \n    float t = march(ro, rd);\n    vec3 p = ro + rd*t;\n    vec3 n = normalize(normal(p) + .3*texture(iChannel0, p.yz*.2).xyz);\n    \n    vec3 col = color(p, rd, n);\n    \n    float fog = exp(-t*t*.00015);\n    col = mix(1.1*mix(vec3(.8, .9, .9), vec3(.51), rd.z), col, fog);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), t);\n}\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3XWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 137, 137, 254]], "test": "untested"}
{"id": "dscXDs", "name": "mandelbulb-pathtraced", "author": "graygoose", "description": "fractalssss\n\n#define MOUSE_ROTATE in Buffer A.\n#define SOBEL in Image for screenspace sobel filter.", "tags": ["fractal"], "likes": 2, "viewed": 250, "published": 3, "date": "1680564380", "time_retrieved": "2024-07-30T18:02:18.649871", "image_code": "//#define SOBEL\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#ifdef SOBEL\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n#else\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n#endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define MOUSE_ROTATE\n\n#define MAX_ITERATIONS 128\n#define BAILOUT 64.0\n#define POWER 8.0\n#define MINIMUM_RADIUS 0.1\n#define ITERATIONS_BEFORE_ESCAPE 256.0\n\n#define MAX_RAY_STEPS 128\n#define MAX_RAY_DIST 10.0\n#define MIN_RAY_DIST 0.001\n\n#define NORMAL_EPS 0.00001\n\n\n        \nvec4 fractal(vec3 z, mat3 rot) {\n    vec3 c = z;\n    float r = 0.0;\n    float dr = 1.0;\n    float trap = 0.0;\n\n\n    z *= rot;\n        \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(c);\n        if (r > BAILOUT) break;\n        \n        float theta = acos(c.z / r);\n        float phi = atan(c.y, c.x);\n        float p = POWER * theta;\n        float cp = cos(p);\n        float sp = sin(p);\n        float cp2 = cos(POWER * phi);\n        float sp2 = sin(POWER * phi);\n        \n        vec3 dz = vec3(\n            sp * cp2,\n            sp * sp2,\n            cp);\n        c = pow(r, POWER) * dz + z;\n        dr = POWER * pow(r, POWER - 1.0) * dr + 1.0;\n        \n        if (float(i) > ITERATIONS_BEFORE_ESCAPE) {\n            trap += log(r);\n        }\n    }\n    \n    float dist = 0.5 * log(r) * r / dr;\n    return vec4(c, dist);\n}\n\nvec3 estimateNormal(vec3 p, mat3 rot) {\n    const vec3 dx = vec3(NORMAL_EPS, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, NORMAL_EPS, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, NORMAL_EPS);\n    \n    return normalize(vec3(\n        fractal(p + dx, rot).w - fractal(p - dx, rot).w,\n        fractal(p + dy, rot).w - fractal(p - dy, rot).w,\n        fractal(p + dz, rot).w - fractal(p - dz, rot).w)\n    );\n}\n\n\nfloat traceRay(vec3 ro, vec3 rd, out vec3 hit, out vec3 normal, mat3 rot) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < MAX_RAY_STEPS; i++) {\n        hit = ro + rd * t;\n        d = (fractal(hit, rot)).w;\n        if (d < MIN_RAY_DIST) {\n            normal = estimateNormal(hit, rot);\n            return t;\n        }\n        t += d;\n        if (t > MAX_RAY_DIST) break;\n    }\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    vec3 ro = vec3(0.0, 0.0, 1.6);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n\n#ifdef MOUSE_ROTATE\n    vec2 mouse = iMouse.xy / iResolution.xy; \n    float theta = mouse.x * 10.0;\n#else\n    float theta = iTime * 0.1;\n#endif\n\n    mat3 rot = mat3(\n        vec3(cos(theta), 0.0, sin(theta)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(theta), 0.0, cos(theta)));\n\n    vec3 hit, normal;\n    float t = traceRay(ro * rot, rd * rot, hit, normal, rot);\n\n    if (t > 0.0) {\n        vec3 color = vec3(0.0);\n        vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));  \n\n        vec3 viewDir = normalize(-hit);\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        float specular = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n        color += vec3(0.102,0.373,0.706) * diffuse;\n        color += vec3(1.0) * specular;\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n", "buffer_a_inputs": [], "buffer_b_code": "/*vec4 Sample(vec2 uv)\n{\n    return texelFetch(iChannel0, ivec2(uv * iResolution.xy), 0);\n}\n\nvec4 average(vec2 uv)\n{\n    vec4 O = (\n        Sample(uv + vec2(0, 1)) +\n        Sample(uv + vec2(1, 0)) +\n        Sample(uv + vec2(1, 1))\n    ) * .33333;\n    O += Sample(uv);\n    O *= 0.5;\n    return O;\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = sobel(fragCoord.xy, iChannel0, iResolution.xy);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SOBEL_EDGE_COLOR vec4(0.929,0.200,0.231,.15)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.25, 0.95, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscXDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 72, 72, 226]], "test": "untested"}
{"id": "DslSW4", "name": "Gear test", "author": "Peace", "description": "Made this while learning about gears", "tags": ["gear"], "likes": 1, "viewed": 151, "published": 3, "date": "1680554228", "time_retrieved": "2024-07-30T18:02:19.612298", "image_code": "#define PI 3.14159265359\n\nconst int z = 12; // tooth number\nconst float pitch = (2.0 * PI) / float(z); // pitch\nconst float m = pitch / PI; // module\nconst float ha = m * 1.00; // addendum\nconst float hf = m * 1.25; // dedendum\nconst float h = ha + hf; // tooth height\nconst float c = m * 0.25; // tip and root clearence\nconst float hw = h - c; // working depth\nconst float d = m * float(z); // reference diameter\nconst float df = d - hf; // root diameter\nconst float da = d + ha; // tip diameter\nconst float a = radians(20.0); // pressure angle\nconst float w = 0.6; // tooth width\nconst float pf = 0.38 * m; // dedendum fillet radius\n\nvec3 gear(vec2 uv)\n{\n    float va = atan(uv.y, uv.x);\n    float angle = round(va / (2.0 * PI) * float(z)) * pitch;\n    vec2 dir = vec2(cos(angle), sin(angle));\n    float dis_x = distance(dir * length(uv), uv) / pitch;\n    float dis_y = length(uv);\n    \n    vec3 col = vec3(0);\n    \n    float ta = tan(a);\n    \n    if (dis_y <= df) // root\n    {\n        col = vec3(1);\n    }\n    else if (dis_y > df && dis_y <= d) // reference\n    {\n        float h = (dis_y - df) / (d - df);\n        col = vec3(smoothstep(dis_x - 16./iResolution.y, dis_x + 16./iResolution.y, (1.0 - h * ta + ta) * w));\n    }\n    else if (dis_y > d && dis_y <= da) // tip\n    {\n        float h = (dis_y - d) / (da - d);\n        col = vec3(smoothstep(dis_x - 16./iResolution.y, dis_x + 16./iResolution.y, (1.0 - h * ta) * w));\n    }\n    \n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= 2.5;\n    \n    vec3 col = vec3(0);\n    \n    col = gear(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DslSW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[636, 636, 656, 656, 1456], [1462, 1462, 1519, 1519, 1692]], "test": "untested"}
{"id": "DdtSDf", "name": "Gradient orb", "author": "Peace", "description": "Gradient orb", "tags": ["gradient", "orb"], "likes": 7, "viewed": 259, "published": 3, "date": "1680554172", "time_retrieved": "2024-07-30T18:02:20.391215", "image_code": "const uint MAX_RAY_MARCH_STEPS = 32u;\nconst float MAX_DISTANCE = 1.0;\nconst float SURFACE_DISTANCE = 0.01;\nconst float HALF_PI = 1.57079632679;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    Ray ray;\n    float fov;\n};\nCamera camera;\n\nstruct Hit\n{\n    float dist;\n    float min_dist;\n    vec3 point;\n    vec3 normal;\n};\n    \nfloat specularBlinnPhong(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    return max(0.0, dot(normal, normalize(light_dir + ray_dir)));\n}\n\nvec4 perm(vec4 x) { x = ((x * 34.0) + 1.0) * x; return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat fbm(vec3 p)\n{\n    return (noise(p * 1.4) + noise(p * 2.25 + 16.791) * 0.6 + noise(p * 3.375 - 31.613) * .35) * 0.6;\n}\n\nfloat SDF(vec3 point, float seed)\n{\n    return (dot(point, point) - 0.16 - fbm(vec3(point.xy, iTime * 0.25 + point.z) + seed) * 0.25) * 0.7;\n}\n\nHit raymarch(Ray ray, float seed)\n{\n    Hit hit;\n    hit.dist = 0.0;\n    hit.min_dist = MAX_DISTANCE;\n    hit.normal = vec3(0);\n    for (uint i = 0u; i < MAX_RAY_MARCH_STEPS; ++i)\n    {\n        hit.point = ray.pos + ray.dir * hit.dist; \n        float sdf = SDF(hit.point, seed);\n        hit.min_dist = min(hit.min_dist, sdf);\n        hit.dist += sdf;\n        if (hit.dist >= MAX_DISTANCE)\n            return hit;\n        if (abs(sdf) <= SURFACE_DISTANCE)\n        {\n            vec2 e = vec2(0.002, 0.0);\n            hit.normal = normalize(sdf - vec3(SDF(hit.point - e.xyy, seed), SDF(hit.point - e.yxy, seed), SDF(hit.point - e.yyx, seed)));\n            return hit;\n        }\n    }\n    \n    return hit;\n}\n\nvec4 getColor(Ray ray, vec3 color, float seed)\n{\n    vec3 col = vec3(0);\n    Hit hit = raymarch(ray, seed);\n    if (hit.normal != vec3(0))\n    {\n        vec3 n = abs(hit.normal + vec3(0, 0, 0.5));\n        col = normalize(color + n * n);\n        col += pow(specularBlinnPhong(normalize(vec3(100, 100, -100) - hit.point), normalize(camera.ray.pos - hit.point), hit.normal), 32.0) * 0.5;\n    }\n    else\n    {\n        col = vec3(pow(max(0.0, 1.0 - hit.min_dist), 16.0)) * color;\n        hit.dist = MAX_DISTANCE + 1.0 - max(0.0, 1.0 - hit.min_dist);\n    }\n    return vec4(col, hit.dist);\n}\n\n#define CMPSWAP(a, b) if (c[a].w > c[b].w) { vec4 temp = c[a]; c[a] = c[b]; c[b] = temp; }\n#define BLEND(a) if (c[a].w < MAX_DISTANCE) fragColor.rgb = mix(fragColor.rgb, c[a].rgb, 0.5);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;    \n    camera.fov = 90.0;\n    camera.ray.pos = vec3(0, 0, -1);\n    camera.ray.dir = vec3(0, 0, 1);\n    float fov = tan(HALF_PI - radians(camera.fov) * 0.5);\n    camera.ray.dir = normalize(vec3(uv, fov));\n    \n    vec4 c[] = vec4[](\n    getColor(camera.ray, vec3(1, 0.35, 1), 0.0)\n    ,getColor(camera.ray, vec3(0.1, 0.5, 1.0), 1000.612)\n    );\n    \n    CMPSWAP(0, 1)\n    \n    if (c[0].w >= MAX_DISTANCE)\n    {\n        fragColor = vec4(mix(c[0].rgb, c[1].rgb, 0.5), 1);\n        return;\n    }\n    \n    fragColor.rgb = c[0].rgb;\n    BLEND(1)\n    fragColor.rgb = sqrt(fragColor.rgb * 1.1 - .1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtSDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 412, 412, 480], [482, 482, 501, 501, 576], [578, 578, 599, 599, 1090], [1092, 1092, 1111, 1111, 1215], [1217, 1217, 1252, 1252, 1359], [1361, 1361, 1396, 1396, 2065], [2067, 2067, 2115, 2115, 2651]], "test": "untested"}
{"id": "DstXDX", "name": "ECB Block Test", "author": "MacLin", "description": "asdasd", "tags": ["asdadsd"], "likes": 0, "viewed": 205, "published": 3, "date": "1680513596", "time_retrieved": "2024-07-30T18:02:21.549120", "image_code": "// #define DEMO_FILTER_WEIGHT_USING_FUNCTION\n// #define DEMO_FILTER_WEIGHT_USING_CONSTANT\n// #define DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n// #define HIGH_DIMENSION_DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n#define ECBDEMO\n\n#ifdef DEMO_FILTER_WEIGHT_USING_FUNCTION\nconst float u_sigma = 1.0;\n\n///////////////////////////////////////////////////////////////////////////////////\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\nstruct Input\n{\n    float m[9];\n};\n\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.m[0] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.m[1] = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.m[2] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    \n    i.m[3] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    i.m[4] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.m[5] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n\n    i.m[6] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.m[7] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    i.m[8] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Filter1x1x3x3(out float ret, Input i)\n{\n    ret  = i.m[0] * Gaussian(-1.0f, -1.0f, u_sigma);\n    ret += i.m[1] * Gaussian( 0.0f, -1.0f, u_sigma);\n    ret += i.m[2] * Gaussian( 1.0f, -1.0f, u_sigma);\n\n    ret += i.m[3] * Gaussian(-1.0f,  0.0f, u_sigma);\n    ret += i.m[4] * Gaussian( 0.0f,  0.0f, u_sigma);\n    ret += i.m[5] * Gaussian( 1.0f,  0.0f, u_sigma);\n\n    ret += i.m[6] * Gaussian(-1.0f,  1.0f, u_sigma);\n    ret += i.m[7] * Gaussian( 0.0f,  1.0f, u_sigma);\n    ret += i.m[8] * Gaussian( 1.0f,  1.0f, u_sigma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    // -------------------------------------------\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n\n    // -------------------------------------------\n    // do filtering\n    float y = 0.0;  \n    Filter1x1x3x3(y, i);\n    \n    // -------------------------------------------\n    // output\n    fragColor = vec4(y, y, y, 0.6);\n}\n#endif\n\n\n#ifdef DEMO_FILTER_WEIGHT_USING_CONSTANT\n///////////////////////////////////////////////////////////////////////////////////\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\nstruct Input\n{\n    float m[9];\n};\n\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.m[0] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.m[1] = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.m[2] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    \n    i.m[3] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    i.m[4] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.m[5] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n\n    i.m[6] = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.m[7] = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    i.m[8] = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\n// -------------------------------------------\n// (1.0 / (2.0 * pi *sigma^2)) * exp( -(x^2+y^2) /(2*sigma^2) )\n// sigma = 1.0\n// 0.0585 0.0965 0.0585\n// 0.0965 0.1591 0.0965\n// 0.0585 0.0965 0.0585\n\n// sigma = 0.6\n// 0.0274 0.1102 0.0274\n// 0.1102 0.4420 0.1102         \n// 0.0274 0.1102 0.0274\n\n// 0.0274 0.1102 0.0274\n// 0.1102 0.4420 0.1102         \n// 0.0274 0.1102 0.0274\nvoid Filter1x1x3x3(out float ret, Input i)\n{\n    ret  = i.m[0] * 0.0274;\n    ret += i.m[1] * 0.1102;\n    ret += i.m[2] * 0.0274;\n\n    ret += i.m[3] * 0.1102;\n    ret += i.m[4] * 0.4420;\n    ret += i.m[5] * 0.1102;\n\n    ret += i.m[6] * 0.0274;\n    ret += i.m[7] * 0.1102;\n    ret += i.m[8] * 0.0274;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    // -------------------------------------------\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n\n    // -------------------------------------------\n    // do filtering\n    float y = 0.0;\n    Filter1x1x3x3(y, i);\n    \n    // -------------------------------------------\n    // output\n    fragColor = vec4(y, y, y, 1.0);\n}\n#endif\n\n\n#ifdef DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n///////////////////////////////////////////////////////////////////////////////////\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\nstruct Pixel3x3\n{\n    vec4 m0123;\n    vec4 m4567;\n    float m8;\n};\n\nstruct Input\n{\n    Pixel3x3 pixels;\n};\n\n\n// -------------------------------------------\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.pixels.m0123.r = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.g = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.pixels.m0123.b = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.a = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    \n    i.pixels.m4567.r = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.pixels.m4567.g = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n    i.pixels.m4567.b = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.pixels.m4567.a = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    \n    i.pixels.m8 = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Filter1x1x3x3(out float ret, Input i)\n{\n    ret =  dot(i.pixels.m0123, vec4(0.0274, 0.1102, 0.0274, 0.1102));\n    ret += dot(i.pixels.m4567, vec4(0.4420, 0.1102, 0.0274, 0.1102));\n    ret += i.pixels.m8 * 0.0274;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    // -------------------------------------------\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n\n    // -------------------------------------------\n    // do filtering\n    float y = 0.0;\n    Filter1x1x3x3(y, i);\n    \n    // -------------------------------------------\n    // output    \n    fragColor = vec4(y, y, y, 1.0);\n}\n#endif\n\n\n///////////////////////////////////////////////////////////////////////////////////\n#ifdef HIGH_DIMENSION_DEMO_FILTER_WEIGHT_USING_CONSTANT_USING_DOT_PRODUCT\n// -------------------------------------------\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\n//-------------------------------------------\nstruct Pixel3x3\n{\n    vec4 m0123;\n    vec4 m4567;\n    float m8;\n};\n\nstruct Pixel3x3x8\n{\n    Pixel3x3 m[8];\n};\n\nstruct Input\n{\n    Pixel3x3 pixels;\n};\n\nstruct Middle\n{\n    Pixel3x3x8 pixels;\n};\n\nstruct Output\n{\n    float pixels[8];\n};\n\n//-------------------------------------------\nPixel3x3x8 filters[8];\n\nvoid initPixel3x3SobelDx(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +0.0; f.m0123.b = -1.0; \n    f.m0123.a = +2.0; f.m4567.r = +0.0; f.m4567.g = -2.0;\n    f.m4567.b = +1.0; f.m4567.a = +0.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3SobelDy(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +2.0; f.m0123.b = +1.0;\n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = -1.0; f.m4567.a = -2.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Lap(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +1.0; f.m0123.b = +0.0; \n    f.m0123.a = +1.0; f.m4567.r = -4.0; f.m4567.g = +1.0;\n    f.m4567.b = +0.0; f.m4567.a = +1.0; f.m8      = +0.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Identity(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +1.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3Zero(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3x8(out Pixel3x3x8 f, float scale)\n{\n    //initPixel3x3SobelDx (f.m[0], scale);\n    //initPixel3x3SobelDy (f.m[1], scale);\n    //initPixel3x3Lap     (f.m[2], scale);\n    //initPixel3x3Identity(f.m[3], scale);\n    //initPixel3x3SobelDx (f.m[4], scale);\n    //initPixel3x3SobelDy (f.m[5], scale);\n    //initPixel3x3Lap     (f.m[6], scale);\n    //initPixel3x3Identity(f.m[7], scale);\n    \n    initPixel3x3Lap      (f.m[0], scale);\n    initPixel3x3Zero     (f.m[1], scale);\n    initPixel3x3Zero     (f.m[2], scale);\n    initPixel3x3Zero     (f.m[3], scale);\n    initPixel3x3Zero     (f.m[4], scale);\n    initPixel3x3Zero     (f.m[5], scale);\n    initPixel3x3Zero     (f.m[6], scale);\n    initPixel3x3Zero     (f.m[7], scale);    \n}\n\nvoid initFilters()\n{\n    initPixel3x3x8(filters[0], 1.0);\n    initPixel3x3x8(filters[1], 1.0);\n    initPixel3x3x8(filters[2], 1.0);\n    initPixel3x3x8(filters[3], 1.0);\n    initPixel3x3x8(filters[4], 1.0);\n    initPixel3x3x8(filters[5], 1.0);\n    initPixel3x3x8(filters[6], 1.0);\n    initPixel3x3x8(filters[7], 1.0);\n}\n\nPixel3x3 Pixel3x3Add(Pixel3x3 a, Pixel3x3 b)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = a.m0123 + b.m0123;\n    r.m4567 = a.m4567 + b.m4567;\n    r.m8    = a.m8    + b.m8;\n    \n    return r;\n}\n\nPixel3x3 Pixel3x3Sub(Pixel3x3 a, Pixel3x3 b)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = a.m0123 - b.m0123;\n    r.m4567 = a.m4567 - b.m4567;\n    r.m8    = a.m8    - b.m8;\n    \n    return r;\n}\n\nfloat Pixel3x3Conv(Pixel3x3 a, Pixel3x3 b)\n{\n    float r;\n    \n    r =  dot(a.m0123, b.m0123);\n    r += dot(a.m4567, b.m4567);\n    r += a.m8    * b.m8;\n    \n    return r;\n}\n\nPixel3x3 Pixel3x3Scale(Pixel3x3 p, float w)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = p.m0123 * w;\n    r.m4567 = p.m4567 * w;\n    r.m8    = p.m8    * w;\n    \n    return r;\n}\n\n// -------------------------------------------\nfloat Pixel3x3x8Conv(Pixel3x3x8 a, Pixel3x3x8 b)\n{\n    float r;\n    \n    r =  Pixel3x3Conv(a.m[0], b.m[0]);\n    r += Pixel3x3Conv(a.m[1], b.m[1]);\n    r += Pixel3x3Conv(a.m[2], b.m[2]);\n    r += Pixel3x3Conv(a.m[3], b.m[3]);\n    r += Pixel3x3Conv(a.m[4], b.m[4]);\n    r += Pixel3x3Conv(a.m[5], b.m[5]);\n    r += Pixel3x3Conv(a.m[6], b.m[6]);\n    r += Pixel3x3Conv(a.m[7], b.m[7]);\n    \n    return r;\n}\n\n// -------------------------------------------\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.pixels.m0123.r = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.g = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.pixels.m0123.b = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.a = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    \n    i.pixels.m4567.r = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.pixels.m4567.g = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n    i.pixels.m4567.b = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.pixels.m4567.a = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    \n    i.pixels.m8      = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Step1(out Middle m, Input i)\n{\n    m.pixels.m[0] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[1] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[2] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[3] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[4] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[5] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[6] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[7] = Pixel3x3Scale(i.pixels, 1.0f);\n}\n\nvoid Step2(out Output o, Middle m)\n{\n    o.pixels[0] = Pixel3x3x8Conv(m.pixels, filters[0]);\n    o.pixels[1] = Pixel3x3x8Conv(m.pixels, filters[1]);\n    o.pixels[2] = Pixel3x3x8Conv(m.pixels, filters[2]);\n    o.pixels[3] = Pixel3x3x8Conv(m.pixels, filters[3]);\n    o.pixels[4] = Pixel3x3x8Conv(m.pixels, filters[4]);\n    o.pixels[5] = Pixel3x3x8Conv(m.pixels, filters[5]);\n    o.pixels[6] = Pixel3x3x8Conv(m.pixels, filters[6]);\n    o.pixels[7] = Pixel3x3x8Conv(m.pixels, filters[7]);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    initFilters();\n   \n    ///////////////////////////\n    // prepare input\n    \n    Input i; \n    prepareInput(i, uv);\n    \n    Middle m;\n    Step1(m, i);\n    \n    Output o;\n    Step2(o, m);\n    \n    float y = o.pixels[0];\n    //float y = o.pixels[1];\n    //float y = o.pixels[2];\n    //float y = o.pixels[3];\n    //float y = o.pixels[4];\n    //float y = o.pixels[5];\n    //float y = o.pixels[6];\n    //float y = o.pixels[7];\n    //float y = o.pixels[8];\n    \n    fragColor = vec4(y);\n}\n\n#endif\n\n\n\n///////////////////////////////////////////////////////////////////////////////////\n#ifdef ECBDEMO\n// -------------------------------------------\nconst int   u_filterSize    = 15;  // must be odd\nconst int   u_halfFilterSize = u_filterSize / 2;\nconst float u_textureSize = 512.0;\nconst float u_texelSize = (1.0 / u_textureSize);\n\n//-------------------------------------------\nstruct Pixel3x3\n{\n    vec4 m0123;\n    vec4 m4567;\n    float m8;\n};\n\nstruct Pixel3x3x8\n{\n    Pixel3x3 m[8];\n};\n\nstruct Input\n{\n    Pixel3x3 pixels;\n};\n\nstruct Middle\n{\n    Pixel3x3x8 pixels;\n};\n\nstruct Output\n{\n    Pixel3x3 pixels[8];\n};\n\nstruct ECBBlock\n{\n    Pixel3x3x8 m[8];\n    \n    float reluSlope[8];\n};\n\nfloat PReLU(float x, float A)\n{\n    if(x < 0.0)\n        return A * x;\n    else\n        return x;\n}\n\n//-------------------------------------------\nECBBlock block;\n\nvoid initPixel3x3SobelDx(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +0.0; f.m0123.b = -1.0; \n    f.m0123.a = +2.0; f.m4567.r = +0.0; f.m4567.g = -2.0;\n    f.m4567.b = +1.0; f.m4567.a = +0.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3SobelDy(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +1.0; f.m0123.g = +2.0; f.m0123.b = +1.0;\n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = -1.0; f.m4567.a = -2.0; f.m8      = -1.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Lap(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +1.0; f.m0123.b = +0.0; \n    f.m0123.a = +1.0; f.m4567.r = -4.0; f.m4567.g = +1.0;\n    f.m4567.b = +0.0; f.m4567.a = +1.0; f.m8      = +0.0;\n    \n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;    \n}\n\nvoid initPixel3x3Identity(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +1.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3Zero(out Pixel3x3 f, float scale)\n{\n    f.m0123.r = +0.0; f.m0123.g = +0.0; f.m0123.b = +0.0; \n    f.m0123.a = +0.0; f.m4567.r = +0.0; f.m4567.g = +0.0;\n    f.m4567.b = +0.0; f.m4567.a = +0.0; f.m8      = +0.0;\n\n    f.m0123 *= scale;\n    f.m4567 *= scale;\n    f.m8    *= scale;\n}\n\nvoid initPixel3x3x8(out Pixel3x3x8 f, float scale)\n{\n    //initPixel3x3SobelDx (f.m[0], scale);\n    //initPixel3x3SobelDy (f.m[1], scale);\n    //initPixel3x3Lap     (f.m[2], scale);\n    //initPixel3x3Identity(f.m[3], scale);\n    //initPixel3x3SobelDx (f.m[4], scale);\n    //initPixel3x3SobelDy (f.m[5], scale);\n    //initPixel3x3Lap     (f.m[6], scale);\n    //initPixel3x3Identity(f.m[7], scale);\n    \n    initPixel3x3Lap       (f.m[0], scale);\n    initPixel3x3Zero      (f.m[1], scale);\n    initPixel3x3Zero      (f.m[2], scale);\n    initPixel3x3Zero      (f.m[3], scale);\n    initPixel3x3Zero      (f.m[4], scale);\n    initPixel3x3Zero      (f.m[5], scale);\n    initPixel3x3Zero      (f.m[6], scale);\n    initPixel3x3Zero      (f.m[7], scale);    \n}\n\nvoid initECBBlock()\n{\n    initPixel3x3x8(block.m[0], 1.0);\n    initPixel3x3x8(block.m[1], 1.0);\n    initPixel3x3x8(block.m[2], 1.0);\n    initPixel3x3x8(block.m[3], 1.0);\n    initPixel3x3x8(block.m[4], 1.0);\n    initPixel3x3x8(block.m[5], 1.0);\n    initPixel3x3x8(block.m[6], 1.0);\n    initPixel3x3x8(block.m[7], 1.0);\n    \n    block.reluSlope[0] = 0.02;\n    block.reluSlope[1] = 0.01;\n    block.reluSlope[2] = 0.02;\n    block.reluSlope[3] = 0.03;\n    block.reluSlope[4] = 0.02;\n    block.reluSlope[5] = 0.01;\n    block.reluSlope[6] = 0.02;\n    block.reluSlope[7] = 0.03;\n}\n\nfloat Pixel3x3Conv(Pixel3x3 a, Pixel3x3 b)\n{\n    float r;\n    \n    r =  dot(a.m0123, b.m0123);\n    r += dot(a.m4567, b.m4567);\n    r += a.m8    * b.m8;\n    \n    return r;\n}\n\nPixel3x3 Pixel3x3Scale(Pixel3x3 p, float w)\n{\n    Pixel3x3 r;\n    \n    r.m0123 = p.m0123 * w;\n    r.m4567 = p.m4567 * w;\n    r.m8    = p.m8    * w;\n    \n    return r;\n}\n\n// -------------------------------------------\nfloat Pixel3x3x8Conv(Pixel3x3x8 a, Pixel3x3x8 b)\n{\n    float r;\n    \n    r =  Pixel3x3Conv(a.m[0], b.m[0]);\n    r += Pixel3x3Conv(a.m[1], b.m[1]);\n    r += Pixel3x3Conv(a.m[2], b.m[2]);\n    r += Pixel3x3Conv(a.m[3], b.m[3]);\n    r += Pixel3x3Conv(a.m[4], b.m[4]);\n    r += Pixel3x3Conv(a.m[5], b.m[5]);\n    r += Pixel3x3Conv(a.m[6], b.m[6]);\n    r += Pixel3x3Conv(a.m[7], b.m[7]);\n    \n    return r;\n}\n\nfloat PReLU_Pixel3x3x8Conv(Pixel3x3x8 a, Pixel3x3x8 b, float A)\n{\n    return PReLU(Pixel3x3x8Conv(a, b), A);\n}\n\n// -------------------------------------------\nvoid prepareInput(out Input i, vec2 uv)\n{\n    i.pixels.m0123.r = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.g = RGB2Y(texture(iChannel0, uv + vec2(         0.0, -u_texelSize)).rgb);\n    i.pixels.m0123.b = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize, -u_texelSize)).rgb);\n    i.pixels.m0123.a = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,          0.0)).rgb);\n    \n    i.pixels.m4567.r = RGB2Y(texture(iChannel0, uv + vec2(         0.0,          0.0)).rgb);\n    i.pixels.m4567.g = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,          0.0)).rgb);\n    i.pixels.m4567.b = RGB2Y(texture(iChannel0, uv + vec2(-u_texelSize,  u_texelSize)).rgb);\n    i.pixels.m4567.a = RGB2Y(texture(iChannel0, uv + vec2(         0.0,  u_texelSize)).rgb);\n    \n    i.pixels.m8 = RGB2Y(texture(iChannel0, uv + vec2( u_texelSize,  u_texelSize)).rgb);\n}\n\nvoid Step1(out Middle m, Input i)\n{\n    m.pixels.m[0] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[1] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[2] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[3] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[4] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[5] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[6] = Pixel3x3Scale(i.pixels, 1.0f);\n    m.pixels.m[7] = Pixel3x3Scale(i.pixels, 1.0f);\n}\n\nvoid Step2(out Output o, Middle m)\n{\n    // o.pixels[0] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[0]), block.reluSlope[0]);\n    // o.pixels[1] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[1]), block.reluSlope[1]);\n    // o.pixels[2] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[2]), block.reluSlope[2]);\n    // o.pixels[3] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[3]), block.reluSlope[3]);\n    // o.pixels[4] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[4]), block.reluSlope[4]);\n    // o.pixels[5] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[5]), block.reluSlope[5]);\n    // o.pixels[6] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[6]), block.reluSlope[6]);\n    // o.pixels[7] = PReLU(Pixel3x3x8Conv(m.pixels, block.m[7]), block.reluSlope[7]);\n    \n    o.pixels[0].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[0], block.reluSlope[0]);\n    o.pixels[1].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[1], block.reluSlope[1]);\n    o.pixels[2].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[2], block.reluSlope[2]);\n    o.pixels[3].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[3], block.reluSlope[3]);\n    o.pixels[4].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[4], block.reluSlope[4]);\n    o.pixels[5].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[5], block.reluSlope[5]);\n    o.pixels[6].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[6], block.reluSlope[6]);\n    o.pixels[7].m0123.r = PReLU_Pixel3x3x8Conv(m.pixels, block.m[7], block.reluSlope[7]);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    initECBBlock();\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    ///////////////////////////\n    // prepare input\n    Input i;\n    prepareInput(i, uv);\n    \n    Middle m;\n    Step1(m, i);\n    \n    Output o;\n    Step2(o, m);\n    \n    float y = o.pixels[0].m0123.r;\n    //float y = o.pixels[1];\n    //float y = o.pixels[2];\n    //float y = o.pixels[3];\n    //float y = o.pixels[4];\n    //float y = o.pixels[5];\n    //float y = o.pixels[6];\n    //float y = o.pixels[7];\n    //float y = o.pixels[8];\n    fragColor = vec4(y);\n}\n\n#endif", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////////////////////////////////////////\n// Common Function\nfloat RGB2Y(vec3 rgb)\n{\n    return (dot(vec3( 0.2990,  0.5870,  0.114), rgb));\n}\n\nfloat RGB2U(vec3 rgb)\n{\n    return (dot(vec3(-0.1678, -0.3313,  0.5000), rgb));\n}\n\nfloat RGB2V(vec3 rgb)\n{\n    return (dot(vec3( 0.5000, -0.4187, -0.0813), rgb));\n}\n\nfloat Gaussian (float x, float y, float sigma)\n{\n    return (1.0 / (2.0 * 3.141592654 * sigma * sigma)) * exp(-(x * x + y * y) / (2.0 * sigma * sigma));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstXDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cs3XDf", "name": "isometric cake", "author": "charstiles", "description": "made for hex house's first birthday. uses a lot of SDF functions from https://mercury.sexy/hg_sdf/\nrounded cylinder and rounded cone function from https://iquilezles.org/articles/distfunctions/", "tags": ["cake", "isomentric"], "likes": 4, "viewed": 204, "published": 3, "date": "1680488582", "time_retrieved": "2024-07-30T18:02:22.408821", "image_code": "#define PI 3.141592\n\n//the following functions are from mercury.sexy/hg_sdf\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec3 fade(vec3 x) { return x * x * x * (x * (x * 6. - 15.) + 10.); }\n\nvec3 phash(vec3 p)\n{\n    p = fract(mat3(1.2989833, 7.8233198, 2.3562332,\n                   6.7598192, 3.4857334, 8.2837193,\n                   2.9175399, 2.9884245, 5.4987265) * p);\n    p = ((2384.2345 * p - 1324.3438) * p + 3884.2243) * p - 4921.2354;\n    return normalize(fract(p) * 2. - 1.);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat noise(vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float d000 = dot(phash(ip), fp);\n    float d001 = dot(phash(ip + vec3(0, 0, 1)), fp - vec3(0, 0, 1));\n    float d010 = dot(phash(ip + vec3(0, 1, 0)), fp - vec3(0, 1, 0));\n    float d011 = dot(phash(ip + vec3(0, 1, 1)), fp - vec3(0, 1, 1));\n    float d100 = dot(phash(ip + vec3(1, 0, 0)), fp - vec3(1, 0, 0));\n    float d101 = dot(phash(ip + vec3(1, 0, 1)), fp - vec3(1, 0, 1));\n    float d110 = dot(phash(ip + vec3(1, 1, 0)), fp - vec3(1, 1, 0));\n    float d111 = dot(phash(ip + vec3(1, 1, 1)), fp - vec3(1, 1, 1));\n    fp = fade(fp);\n    return mix(mix(mix(d000, d001, fp.z), mix(d010, d011, fp.z), fp.y),\n               mix(mix(d100, d101, fp.z), mix(d110, d111, fp.z), fp.y), fp.x);\n}\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n    vec2 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    p *= mod(c,vec2(2.))*2. - vec2(1);\n    p -= size/2.;\n    if (p.x > p.y) p.xy = p.yx;\n    return floor(c/2.);\n}\n\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n    vec2 halfsize = size*0.5;\n    vec2 c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    p *= mod(c,vec2(2.))*2. - vec2(1);\n    return c;\n}\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n    return max(max(v.x, v.y), max(v.z, v.w));\n}\n\n//end mercury functions\n\n// these 2 functions are from https://iquilezles.org/articles/distfunctions/\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}  \n\n\nfloat scene(vec3 pos){\n    \n   pR(pos.xz,sin(iTime/4.));\n   \n   vec2 id = pModMirror2(pos.xz,vec2(40,60));\n   \n    float r0 = 2.;\n   float cake0 = sdRoundedCylinder(pos + vec3(0,6,0), r0,r0,0.4);\n   float r1 = 1.5;\n   float cake1 = sdRoundedCylinder(pos + vec3(0,3,0), r1,r1,0.5);\n   float r2 = 1.;\n   float cake2 = sdRoundedCylinder(pos + vec3(0,0.5,0), r2,r2,0.4);\n   float r3= .1;\n   float cand0 = sdRoundedCylinder(pos + vec3(0,-1.3,0), r3,r3,0.4);\n    float light = sdRoundCone(pos + vec3(0,-2.1,0), 0.2,0.05,0.3 );\n    cand0 = min(light,cand0);\n    pModPolar(pos.xz,15.);\n    float decor = sdRoundCone(pos + vec3(-3.2,4.,0), 0.2,0.05,0.3 );\n     decor = min(decor, sdRoundCone(pos + vec3(-2.,1.,0), 0.2,0.05,0.3 ));\n     decor = min(decor, sdRoundCone(pos + vec3(-3.9,7,0), 0.2,0.05,0.3 ));\n    float s = 0.4;\n    float fl = smin(cand0,smin(cake2,smin(cake0,cake1,s),s),0.1);\n    return smin(decor,fl,0.1);\n}\n\n vec3 estimateNormal(vec3 p) {\n    float smallNumber = 0.002;\n    vec3 n = vec3(\n    scene(vec3(p.x + smallNumber, p.yz)) -\n    scene(vec3(p.x - smallNumber, p.yz)),\n    scene(vec3(p.x, p.y + smallNumber, p.z)) -\n    scene(vec3(p.x, p.y - smallNumber, p.z)),\n    scene(vec3(p.xy, p.z + smallNumber)) -\n    scene(vec3(p.xy, p.z - smallNumber)));\n    return normalize(n);\n}\n\n\n\nvec4 lighting(vec3 ray, vec2 id){\n    vec3 norm = estimateNormal(ray);\n    vec3 light= vec3(0,.0,0);\n    float dif = dot(norm, light);\n    vec4 retCol = vec4(dif) - rand(id);\n    vec3 lightRayDir = normalize(light-ray) ;\n    //retCol = min(vec4(traceShadow(ray, lightRayDir)),retCol);\n    return retCol + vec4(norm,1) + rand(vec2(ray.xy)) ;\n}\n\n\n\nvec4 trace(vec3 rayO, vec3 dir){\n\n    vec3 ray = rayO;\n    float dist = 0.;\n    float totalDist = 0.;\n    vec3 s;\n    vec4 bg = vec4(0);\n    for(int i =0; i< 32; ++i){\n        \n        dist = scene(ray);\n        totalDist+=dist;\n        ray += dist * dir ;\n        \n        if(dist < 0.01){\n            vec4 retCol = 1.-(vec4(totalDist)/5.);\n            retCol = lighting(ray, s.yz);// * retCol; \n            return retCol;\n        }\n        if(totalDist >5.){return bg;}\n    }\n     return bg;\n}\n\n\nvec3 getRdIsometric(inout vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 rd = normalize(\n        lookAt -\n        ro\n    );\n    \n    vec3 right = normalize(cross(vec3(0,1,0), rd));\n    vec3 up = normalize(cross(rd, right));\n    \n    float zoom = 10.;\n    ro += right*uv.x*zoom;\n    ro += up*uv.y*zoom;\n    return rd;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = -1. + 2. * uv;\n    uv.y -= 0.3;\n    uv.y*= iResolution.y/iResolution.x;\n    uv.y*= 1.2;\n    vec3 cam =vec3(1,0,1);\n    \n    vec3 lookAt = vec3(0,-1.,-1);\n    \n    \n    vec3 ro = vec3(0,-0,-3);\n   \n    vec3 dir = getRdIsometric(ro, lookAt, uv); \n\n    vec4 col = trace(ro, dir);\n    \n    fragColor = col.rrra ;//+ rand(v_texcoord.xy+time )*0.3; //texture2D(texture4, v_texcoord);//\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs3XDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 76, 96, 96, 166], [167, 167, 186, 186, 235], [237, 237, 257, 257, 534], [535, 535, 599, 599, 716], [717, 717, 758, 758, 842], [843, 843, 864, 864, 1604], [1605, 1667, 1708, 1708, 1908], [1910, 1910, 1953, 1953, 2123], [2124, 2124, 2156, 2156, 2201], [2202, 2315, 2365, 2365, 2785], [2786, 2786, 2811, 2811, 2830], [2831, 2831, 2856, 2856, 2875], [2876, 2876, 2912, 2912, 2940], [2941, 2981, 3001, 3001, 3029], [3031, 3031, 3051, 3051, 3089], [3091, 3091, 3111, 3111, 3159], [3186, 3263, 3321, 3383, 3662], [3664, 3700, 3728, 3728, 3815], [3820, 3820, 3842, 3842, 4734], [4737, 4737, 4766, 4766, 5107], [5111, 5111, 5144, 5144, 5453], [5457, 5457, 5489, 5489, 5952], [5955, 5955, 6012, 6012, 6268], [6269, 6269, 6326, 6376, 6812]], "test": "untested"}
{"id": "dd3SRB", "name": "Year of Truchets #007", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\ntaking the pattern from my last Raymarching shader and playing around with it.", "tags": ["2d", "truchettiles", "tiles"], "likes": 28, "viewed": 328, "published": 3, "date": "1680485626", "time_retrieved": "2024-07-30T18:02:23.230624", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #007\n    04/02/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\nfloat scale = 8.;\n\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453);}\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//@iq sdfs\nfloat box(vec2 p, vec2 a) {\n    vec2 q = abs(p)-a;\n    return length(max(q,0.)) + min(max(q.x,q.y),0.);\n}\n\nfloat ck = 0., d2 = 0.;\nvec2 g = vec2(0), id = vec2(0);\n\nfloat makeTile(vec2 uv){\n\n    id = floor(uv);\n    vec2 q = fract(uv)-.5;\n    g=q;\n    \n    ck = mod(id.x+id.y,2.)*2.-1.;\n    float hs = hash21(id);\n\n    float wd = .125+.065*sin(uv.x*.5+T*.75);\n    if(hs>.5) q.x=-q.x;\n    \n    vec2 sp = vec2(length(q-.5),length(q+.5));\n    vec2 p = sp.x<sp.y? q-.5 : q+.5;\n\n    // main pattern\n    float d = length(p)-.5;\n    d = abs(d)-wd;\n    \n    float c = min(length(q.x)-wd,length(q.y)-wd);\n    if (hs>.9) d = c;\n    \n    hs = fract(hs*413.372);\n    if (hs>.9) d = min(length(abs(q)-vec2(.5,0))-wd,length(q.x)-wd);\n    if (hs<.1) d = min(abs(length(q)-.3)-wd,max(c,-(length(q)-.3)));\n    \n    if(ck<.5 && hs>.925) d = min(length(q)-(wd*1.8),d);\n\n    d2 = abs(max(abs(q.x),abs(q.y))-.5)-.005;\n\n    return d;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec3 C = vec3(.1);\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    vec3 clr = mix(vec3(.0,.48,.64),vec3(1.,.5,.1),uv.x);\n    vec3 clx = mix(vec3(1,.5,0),vec3(1,.1,0),uv.x);\n    \n    uv*=scale;    \n    float px = fwidth(uv.x); \n    \n    uv*=rot(T*.035);\n    uv.x -= .25*T;\n\n    float d = makeTile(uv);\n    float hs = hash21(id);\n    float h2 = fract(hs*32.233);\n    \n    float b = box(g,vec2(.31))-.15;\n    float h = box(g,vec2(.28))-.13;\n    float s = smoothstep(.05+px,-px,b);\n    if(h2>.4) C = mix(C,C*.1,s);\n    \n    b = smoothstep(px,-px,b);\n    if(h2>.4) C = mix(C,ck>.5?clx:vec3(0.212,0.227,0.227),b);\n \n    h=max(h,clamp((g.y+.25)*.02,0.,1.));\n    h = smoothstep(px,-px,h);\n    if(h2>.4) C = mix(C,C+.25,h);\n        \n    d2 = smoothstep(px,-px,d2);\n    if(M.z>0.) C = mix(C,vec3(1.),d2);\n    \n    s = smoothstep(.075+px,-px,d);\n    C = mix(C,C*.3,s);\n\n    float d3 = smoothstep(px,-px,abs(d)-.01);\n    d = smoothstep(px,-px,d);\n    C = mix(C,clr,d);\n    C = mix(C,C*.1,d3);\n    \n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n\n\n    \n    \n        \n    \n        \n    \n        \n    \n        \n    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3SRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[385, 385, 407, 407, 468], [469, 469, 488, 488, 532], [534, 545, 572, 572, 650], [709, 709, 733, 733, 1456], [1458, 1458, 1499, 1499, 2536]], "test": "untested"}
{"id": "Dd3SWX", "name": "interpolating distance to points", "author": "jonasfrey", "description": "points", "tags": ["points"], "likes": 6, "viewed": 170, "published": 3, "date": "1680470617", "time_retrieved": "2024-07-30T18:02:24.086336", "image_code": "#define n_tau 6.2831\n\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc_nor = (fragCoord.xy - iResolution.xy*.5)/ iResolution.y;\n    o_fc_nor *= 2.;\n    float n_its = 6.;\n    float n_max = 0.8;\n    float n_rest = (1.-n_max) / (n_its-1.);\n    float n_per_it = 1./n_its;\n    float n = 0.;\n    float n_t = iTime * 1.;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n        float n_it_nor = n_it / n_its;\n        float n_radians = n_it_nor * n_tau;\n        float n_radius = 0.6;\n\n        vec2 o_p = vec2(\n            sin(n_radians)*n_radius,\n            cos(n_radians)*n_radius\n        );\n\n        float n_d = length(o_fc_nor - o_p);\n        // n_d = smoothstep(0.1, 0.090, n_d );\n        // n_d = 1.-n_d;\n        \n        // float n_factor = abs(fract(n_it_nor - n_t));\n        float b = float(int(n_it) == int(mod(n_t, n_its)));\n        float b2 = float(int(n_it) == int(mod(n_t+1., n_its)));//int(1.));//int(mod(iTime+1, n_its));\n        // float b2 = float(int(n_it) == int(fract(iTime+1.)*n_its)); \n\n        // b = float((n_it) == floor(f_n_rand(floor(iTime))*n_its)); \n        // b2 = float((n_it) == floor(f_n_rand(floor(iTime+1.))*n_its)); \n\n        // float n_factor = (sin(iTime)*.5+.5);\n        float n_factor = 1.- fract(n_t);\n\n        n += b * n_factor * n_d;\n        n += b2 * (1.-n_factor) * n_d;\n        // n = smoothstep(0.22, 0.02, n );\n\n        // n += n_d;\n        // n*= n_d;\n\n    }\n    n = smoothstep(0.33, 0.30, n);\n\n    // n = smoothstep(0.1, 0.090, n );\n\n    fragColor = vec4(sqrt(n));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3SWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 47, 47, 132], [134, 134, 191, 241, 1695]], "test": "untested"}
{"id": "dddSWB", "name": "interpolating two points", "author": "jonasfrey", "description": "interpolation", "tags": ["points"], "likes": 0, "viewed": 167, "published": 3, "date": "1680444961", "time_retrieved": "2024-07-30T18:02:24.851290", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc_nor = (fragCoord.xy - iResolution.xy*.5)/ iResolution.y;\n    float n1 = length(o_fc_nor - vec2(-0.2,0.));\n    float n2 = length(o_fc_nor - vec2(0.2,0.));\n    float n_factor = (sin(iTime)*0.5+.5);\n    float n = \n        (1.-n_factor)*n1 + \n        n_factor * n2;\n    float nss = smoothstep(0.2, 0.21, n);\n    fragColor = vec4(\n        nss\n    );\n    if(o_fc_nor.y < 0.){\n\n        fragColor = vec4(\n            n1, \n            0., \n            n2, \n            1.\n        );\n    }\n    float n1d = smoothstep(0.011, 0.01 , n1);\n    fragColor += vec4(n1d, 0., 0., 1.);\n    float n2d = smoothstep(0.011, 0.01 , n2);\n    fragColor += vec4(n2d, 0., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 776]], "test": "untested"}
{"id": "mdcSD2", "name": "billiard (GPT4) (wip)", "author": "valyagolev", "description": "billiard thing made more or less completely with gpt4. I mean it took me insane amount of energy to guide it but I avoided writing the code myself lol", "tags": ["3d", "ai", "billiard", "chatgpt", "gpt4"], "likes": 7, "viewed": 209, "published": 3, "date": "1680442100", "time_retrieved": "2024-07-30T18:02:25.911456", "image_code": "// Written using ChatGPT (GPT4)\n\n// Constants\nconst float tableWidth = 0.8;\nconst float tableHeight = 0.4;\nconst float ballRadius = 0.03;\n\n// Ball colors\nconst vec4 whiteBallColor = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 ballColor1 = vec4(0.8, 0.0, 0.0, 1.0);\nconst vec4 ballColor2 = vec4(0.0, 0.8, 0.0, 1.0);\nconst vec4 ballColor3 = vec4(0.0, 0.0, 0.8, 1.0);\n\n// Ball positions relative to the table (center of the table is at (0.5, 0.5))\nconst vec2 whiteBallInitialPosition = vec2(0.5 - 0.25 * tableWidth, 0.5);\nconst vec2 ballPosition1 = vec2(0.5 + 0.25 * tableWidth, 0.5);\nconst vec2 ballPosition2 = vec2(0.5 + 0.25 * tableWidth + ballRadius * 2.0, 0.5 + ballRadius * sqrt(3.0) / 2.0);\nconst vec2 ballPosition3 = vec2(0.5 + 0.25 * tableWidth - ballRadius * 2.0, 0.5 + ballRadius * sqrt(3.0) / 2.0);\n\n// Camera properties\nconst vec3 cameraPosition = vec3(0.5, 0.5, 1.5);\nconst vec3 cameraTarget = vec3(0.5, 0.5, 0.0);\nconst float cameraAngle = -0.2;\n\nconst float strikeTime = 1.0; // Time (in seconds) it takes for the cue to strike the ball\nconst float backOffTime = 0.2; // Time (in seconds) it takes for the cue to go back after the strike\nconst float whiteRollTime = 1.0;\nconst float ballsRollTime = 1.0;\n\nconst float totalTime = (strikeTime + backOffTime + whiteRollTime + ballsRollTime);\n\nvec2 whiteBallPosition()\n{\n    float t = mod(iTime, totalTime);\n    vec2 direction = normalize(ballPosition3 - whiteBallInitialPosition);\n\n    // White ball rolling after being hit\n    if (t >= (strikeTime + backOffTime) && t < (strikeTime + backOffTime + whiteRollTime))\n    {\n        float rollProgress = (t - (strikeTime + backOffTime)) / whiteRollTime;\n        vec2 newPosition = whiteBallInitialPosition + direction * rollProgress * (length(whiteBallInitialPosition - ballPosition3) - 2.0 * ballRadius);\n        return newPosition;\n    }\n    // White ball goes back a bit after the hit at a 30-degree angle\n    else if (t >= (strikeTime + backOffTime + whiteRollTime) && t < totalTime)\n    {\n        float backOffProgress = (t - (strikeTime + backOffTime + whiteRollTime)) / ballsRollTime;\n        vec2 backOffDirection = vec2(-direction.x * cos(radians(30.0)) - direction.y * sin(radians(30.0)), direction.x * sin(radians(30.0)) + direction.y * cos(radians(30.0)));\n        vec2 newPosition = (ballPosition3 - direction * 2.0 * ballRadius) + backOffDirection * backOffProgress * ballRadius * 2.0;\n        return newPosition;\n    }\n    // White ball remains in its initial position or at the end of the backoff motion\n    else\n    {\n        return whiteBallInitialPosition;\n    }\n}\n\nvec2 ballPosition3Updated()\n{\n    float t = mod(iTime, totalTime);\n\n    // Time intervals for the ball movement\n    float forwardTime = 0.1;\n    float backwardTime = 0.2;\n    float rollTime = ballsRollTime * 0.4;\n\n    vec2 direction = normalize(whiteBallInitialPosition - ballPosition3);\n\n    if (t >= (strikeTime + backOffTime + whiteRollTime) && t < (strikeTime + backOffTime + whiteRollTime + forwardTime))\n    {\n        float forwardProgress = (t - (strikeTime + backOffTime + whiteRollTime)) / forwardTime;\n        vec2 newPosition = ballPosition3 + direction * forwardProgress * ballRadius * 0.5;\n        return newPosition;\n    }\n    else if (t >= (strikeTime + backOffTime + whiteRollTime + forwardTime) && t < (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime))\n    {\n        vec2 forwardPosition = ballPosition3 + direction * ballRadius * 0.5;\n        float backwardProgress = (t - (strikeTime + backOffTime + whiteRollTime + forwardTime)) / backwardTime;\n        vec2 backwardDirection = vec2(direction.x * cos(radians(-20.0)) - direction.y * sin(radians(-20.0)), direction.x * sin(radians(-20.0)) + direction.y * cos(radians(-20.0)));\n        vec2 newPosition = forwardPosition + backwardDirection * backwardProgress * ballRadius;\n        return newPosition;\n    }\n    else if (t >= (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime) && t < (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime + rollTime))\n    {\n        vec2 backwardPosition = ballPosition3 + direction * ballRadius * 0.5 + vec2(direction.x * cos(radians(-50.0)) - direction.y * sin(radians(-20.0)), direction.x * sin(radians(-20.0)) + direction.y * cos(radians(-20.0))) * ballRadius;\n        float rollProgress = (t - (strikeTime + backOffTime + whiteRollTime + forwardTime + backwardTime)) / rollTime;\n        vec2 newPosition = backwardPosition - direction * rollProgress * ballRadius * 2.0;\n        return newPosition;\n    }\n    else\n    {\n        return ballPosition3;\n    }\n}\n\n\n\nfloat cueDist()\n{\n    float maxDist = 0.3; // Maximum distance the cue moves back before striking\n    float backOffDist = 0.01; // Distance the cue moves back after striking the ball\n\n    float t = mod(iTime, totalTime);\n\n    if (t < strikeTime)\n    {\n        return mix(maxDist, 0.0, t / strikeTime);\n    }\n    else if (t >= strikeTime)// + backOffTime)\n    {\n        return 0.01;\n    }\n    else\n    {\n        float backOffProgress = (t - strikeTime) / backOffTime;\n        return mix(0.01, backOffDist, backOffProgress);\n    }\n}\n\n\n\nvec4 drawBall(in vec2 uv, in vec2 ballCenter, in vec4 ballColor)\n{\n    // Calculate the distance from the center of the ball\n    float distanceToBall = length(uv - ballCenter);\n\n    // Check if the point is inside the ball\n    bool insideBall = distanceToBall <= ballRadius;\n\n    if (!insideBall)\n    {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n    // Calculate the z-coordinate of the point on the ball's surface\n    float z = sqrt(ballRadius * ballRadius - distanceToBall * distanceToBall);\n\n    // Calculate the surface normal (in 3D)\n    vec3 surfaceNormal = normalize(vec3(uv - ballCenter, z));\n\n    // Define the light source\n    vec3 lightPosition = vec3(0.5, 0.5, 1.0);\n    vec3 lightDirection = normalize(lightPosition - vec3(ballCenter, z));\n\n    // Calculate Lambertian shading\n    float lambert = max(dot(surfaceNormal, lightDirection), 0.0);\n\n    // Define ambient light\n    float ambient = 0.3;\n\n    // Calculate the final color\n    vec4 color = (ambient + lambert) * ballColor;\n\n    return color;\n}\n\n// Simple random function for creating the noise\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec4 drawTable(in vec2 uv)\n{\n    // Table color\n    vec4 tableColor = vec4(0.0, 0.5, 0.0, 1.0);\n\n    // Table border color\n    vec4 borderColor = vec4(0.6, 0.3, 0.0, 1.0);\n\n    // Table border size\n    float borderSize = 0.01;\n\n    // Check if the point is inside the table border\n    bool insideBorder = uv.x >= (0.5 - tableWidth / 2.0 - borderSize) && uv.x <= (0.5 + tableWidth / 2.0 + borderSize)\n                        && uv.y >= (0.5 - tableHeight / 2.0 - borderSize) && uv.y <= (0.5 + tableHeight / 2.0 + borderSize);\n\n    // Check if the point is inside the table\n    bool insideTable = uv.x >= (0.5 - tableWidth / 2.0) && uv.x <= (0.5 + tableWidth / 2.0)\n                       && uv.y >= (0.5 - tableHeight / 2.0) && uv.y <= (0.5 + tableHeight / 2.0);\n\n    // Calculate the color of the point\n    vec4 color = insideBorder ? (insideTable ? tableColor : borderColor) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Add baize texture to the table surface\n    if (insideTable)\n    {\n        float noise = rand(uv * 25.0);\n        color.rgb *= (1.0 - 0.1 * noise);\n    }\n\n    // Add shading to the borders\n    if (!insideTable && insideBorder)\n    {\n        vec2 borderNormal;\n        if (abs(uv.x - (0.5 - tableWidth / 2.0)) <= borderSize || abs(uv.x - (0.5 + tableWidth / 2.0)) <= borderSize)\n        {\n            borderNormal = vec2(1.0, 0.0);\n        }\n        else\n        {\n            borderNormal = vec2(0.0, 1.0);\n        }\n\n        vec2 lightDirection = normalize(vec2(0.5, 1.0) - uv);\n        float lambert = max(dot(borderNormal, lightDirection), 0.0);\n        color.rgb *= (0.4 + 0.6 * lambert);\n    }\n\n    return color;\n}\n\n\nvec2 project3DTo2D(in vec3 p)\n{\n    return p.xy;\n}\nvec4 drawCue(in vec2 uv, in float dist)\n{\n    // Calculate the direction from the white ball to the center of the triangle formed by the other three balls\n    vec2 triangleCenter = (ballPosition1 + ballPosition2 + ballPosition3) / 3.0;\n    vec2 direction = normalize(triangleCenter - whiteBallInitialPosition);\n\n    // Calculate the cue start and end positions\n    vec2 cueStart = whiteBallInitialPosition - direction * (ballRadius + dist);\n    vec2 cueEnd = cueStart - direction * (ballRadius * 15.0);\n\n    // Define the cue width\n    float cueWidth = 0.005;\n\n    // Calculate the distance from the point (uv) to the cue line\n    float distanceToCue = length((uv - cueStart) - dot(uv - cueStart, cueEnd - cueStart) / dot(cueEnd - cueStart, cueEnd - cueStart) * (cueEnd - cueStart));\n\n    // Check if the point is inside the cue\n    bool insideCue = distanceToCue <= cueWidth;\n\n    // Check if the point is between the start and end positions\n    bool betweenStartAndEnd = dot(uv - cueStart, cueEnd - cueStart) >= 0.0 && dot(uv - cueEnd, cueStart - cueEnd) >= 0.0;\n\n    // Calculate the color of the point\n    vec4 color = insideCue && betweenStartAndEnd ? vec4(1.0, 1.0, 1.0, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Add shading to the cue\n    if (insideCue && betweenStartAndEnd)\n    {\n        float shading = 0.5 + 0.5 * (1.0 - distanceToCue / cueWidth);\n        color.rgb *= shading;\n    }\n\n    // Calculate the shadow projection on the table\n    float shadowWidth = cueWidth * 3.0;\n    float shadowDistanceToCue = length((uv - cueStart) - dot(uv - cueStart, cueEnd - cueStart) / dot(cueEnd - cueStart, cueEnd - cueStart) * (cueEnd - cueStart)) - cueWidth;\n    bool insideShadow = shadowDistanceToCue <= shadowWidth && betweenStartAndEnd;\n\n    // Add the shadow over the table\n    if (insideShadow)\n    {\n        float shadowFactor = 1.0 - 0.3 * (1.0 - shadowDistanceToCue / shadowWidth);\n        color.rgb *= shadowFactor;\n    }\n\n    return color;\n}\n\nvec4 drawCueShadow(in vec2 uv, in float dist)\n{\n    // Calculate the direction from the white ball to the center of the triangle formed by the other three balls\n    vec2 triangleCenter = (ballPosition1 + ballPosition2 + ballPosition3) / 3.0;\n    vec2 direction = normalize(triangleCenter - whiteBallInitialPosition);\n\n    // Calculate the cue start and end positions\n    vec2 cueStart = whiteBallInitialPosition - direction * (ballRadius + dist);\n    vec2 cueEnd = cueStart - direction * (ballRadius * 15.0);\n\n    // Define the shadow width and offset\n    float shadowWidth = 0.008;\n    vec2 shadowOffset = vec2(0.002, -0.002);\n\n    // Calculate the distance from the point (uv) to the cue line\n    float distanceToShadow = length((uv - cueStart - shadowOffset) - dot(uv - cueStart - shadowOffset, cueEnd - cueStart) / dot(cueEnd - cueStart, cueEnd - cueStart) * (cueEnd - cueStart));\n\n    // Check if the point is inside the shadow\n    bool insideShadow = distanceToShadow <= shadowWidth;\n\n    // Check if the point is between the start and end positions\n    bool betweenStartAndEnd = dot(uv - cueStart - shadowOffset, cueEnd - cueStart) >= 0.0 && dot(uv - cueEnd - shadowOffset, cueStart - cueEnd) >= 0.0;\n\n    // Calculate the color of the point\n    vec4 color = insideShadow && betweenStartAndEnd ? vec4(0.0, 0.0, 0.0, 0.3) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    return color;\n}\n\nvec4 drawBallShadow(in vec2 uv, in vec2 ballPosition, in vec4 ballColor)\n{\n    // Define the shadow offset and size\n    vec2 shadowOffset = vec2(0.003, -0.003);\n    float shadowSize = ballRadius * 1.2;\n\n    // Calculate the distance from the point (uv) to the ball position\n    float distanceToShadow = length(uv - ballPosition - shadowOffset);\n\n    // Check if the point is inside the shadow\n    bool insideShadow = distanceToShadow <= shadowSize;\n\n    // Calculate the shadow intensity based on the distance to the shadow\n    float shadowIntensity = smoothstep(shadowSize, shadowSize * 0.9, distanceToShadow);\n\n    // Calculate the color of the point\n    vec4 color = insideShadow ? vec4(0.0, 0.0, 0.0, shadowIntensity * 0.5) : vec4(0.0, 0.0, 0.0, 0.0);\n\n    return color;\n}\n\nvec4 drawScene(in vec3 p)\n{\n    // Project the 3D point to 2D\n    vec2 uv = project3DTo2D(p);\n\n    // Draw the billiard table\n    vec4 color = drawTable(uv);\n\n    // Draw the white ball and its shadow\n    vec4 whiteBall = drawBall(uv, whiteBallPosition(), whiteBallColor);\n    vec4 whiteBallShadow = drawBallShadow(uv, whiteBallPosition(), whiteBallColor);\n    color = mix(color, whiteBallShadow, whiteBallShadow.a);\n\n    // Draw the other balls and their shadows\n    vec4 ball1 = drawBall(uv, ballPosition1, ballColor1);\n    vec4 ball1Shadow = drawBallShadow(uv, ballPosition1, ballColor1);\n    color = mix(color, ball1Shadow, ball1Shadow.a);\n\n    vec4 ball2 = drawBall(uv, ballPosition2, ballColor2);\n    vec4 ball2Shadow = drawBallShadow(uv, ballPosition2, ballColor2);\n    color = mix(color, ball2Shadow, ball2Shadow.a);\n\n    vec4 ball3 = drawBall(uv, ballPosition3Updated(), ballColor3);\n    vec4 ball3Shadow = drawBallShadow(uv, ballPosition3Updated(), ballColor3);\n    color = mix(color, ball3Shadow, ball3Shadow.a);\n\n    // Draw the cue and its shadow\n    vec4 cue = drawCue(uv, cueDist());\n    vec4 cueShadow = drawCueShadow(uv, cueDist());\n    color = mix(color, cueShadow, cueShadow.a);\n\n    // Combine the colors\n    color = mix(color, whiteBall, whiteBall.a);\n    color = mix(color, ball1, ball1.a);\n    color = mix(color, ball2, ball2.a);\n    color = mix(color, ball3, ball3.a);\n    color = mix(color, cue, cue.a);\n\n    return color;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Set up the camera\n    float angle = cameraAngle;\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec3 p = vec3(uv, 0.0);\n    p.xy = rotation * (p.xy - 0.5) + 0.5;\n    p += cameraPosition - cameraTarget;\n\n    // Draw the scene\n    vec4 color = drawScene(p);\n\n    // Output to screen\n    fragColor = color;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcSD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1296, 1296, 1322, 1322, 2582], [2584, 2584, 2613, 2613, 4605], [4609, 4609, 4626, 4626, 5139], [5143, 5143, 5209, 5267, 6162], [6164, 6213, 6233, 6233, 6302], [6304, 6304, 6332, 6351, 7934], [7937, 7937, 7968, 7968, 7987], [7988, 7988, 8029, 8142, 9942], [9944, 9944, 9991, 10104, 11320], [11322, 11322, 11396, 11437, 12098], [12100, 12100, 12127, 12161, 13549], [13555, 13555, 13610, 13660, 14048]], "test": "untested"}
{"id": "mdcXWj", "name": "cheap median filter", "author": "FabriceNeyret2", "description": "Use MIPmap to count prop of pixels below threshold in window,\nthen  iteratively adjust threshold so prop  50%.\nRight: windowed counting, local threshold mask\nclick+hold mouse.y to tune window size\n\nref median filter: https://www.shadertoy.com/view/msdSDB", "tags": ["filter", "gpmipmap"], "likes": 7, "viewed": 368, "published": 3, "date": "1680427235", "time_retrieved": "2024-07-30T18:02:26.807061", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = texture(iChannel0, u/R);               // show threshold (converging toward median )\n    if ( u.x/R.x > .75 )\n        O = texture(iChannel1, u/R );          // show local threshold mask\n    else if ( u.x/R.x > .5 )\n        O = textureLod(iChannel1, u/R, W );    // show windowed counting\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === adjust the value threshold towards the median\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = textureLod(iChannel1, u/R, W); // proportion of texture below threshold within window 2^W\n    \n    O = texture(iChannel0, u/R) * (1. + .1*(.5-O) ); // adjust threshold via relaxation\n\n    if (iFrame<1 || iMouse.w>0. ) O = vec4(.5);       // init\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === prepare the count of texture pixels below the buffA threshold \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = step(  texture(iChannel1, u/R),\n               texture(iChannel0, u/R)\n            // textureLod(iChannel0, u/R, W)\n            );\n}", "buffer_b_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//float W = 3.;\n#define W ( iMouse.z>0. ? 8.*iMouse.y/R.y : log2(R.y/45.) )\n\n#define R iResolution.xy\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcXWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 336]], "test": "untested"}
{"id": "DscXD2", "name": "cheap math morphology", "author": "FabriceNeyret2", "description": "average( I^big ) ^1/big  is a good approx of L30 and thus Linfinity = max.\nAnd MIPmap can be seen as an averaging engine  General Purpose MIPmap shaders ;-)\n\nmouse.y controls windowing.\n", "tags": ["filter", "gpmipmap", "mathematicalmorphology"], "likes": 11, "viewed": 307, "published": 3, "date": "1680424320", "time_retrieved": "2024-07-30T18:02:27.689701", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy;\n    float W = iMouse.z>0. ? 8.*iMouse.y/R.y : log2(R.y/45.);\n    O = fract(iTime/2.)<.5\n          ?     pow( textureLod(iChannel1, u/R, W ), vec4(1./30.) )\n          : 1.- pow( textureLod(iChannel2, u/R, W ), vec4(1./30.) );\n    O = sqrt(O); // sRGB encode\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === source =======================\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = texture(iChannel0, u/iResolution.xy);\n    O *= O;  // sRGB decode\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === for max ======================\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = pow( texture(iChannel0, u/iResolution.xy), vec4(30) );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// === for min ================\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = pow( 1. - texture(iChannel0, u/iResolution.xy), vec4(30.) );\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 327]], "test": "untested"}
{"id": "mdcSDB", "name": "Glowy orb", "author": "Peace", "description": "Glowing orb", "tags": ["orb", "glowing"], "likes": 30, "viewed": 739, "published": 3, "date": "1680378837", "time_retrieved": "2024-07-30T18:02:28.473605", "image_code": "#define MAX_RAY_MARCH_STEPS 32\n#define MAX_DISTANCE 4.0\n#define SURFACE_DISTANCE 0.002\n\nstruct Hit\n{\n    float dist;\n    float closest_dist;\n    vec3 p;\n};\n    \nfloat specularBlinnPhong(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    vec3 halfway = normalize(light_dir + ray_dir);\n    return max(0.0, dot(normal, halfway));\n}\n\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat SDF(vec3 point)\n{\n    vec3 p = vec3(point.xy, iTime * 0.3 + point.z);\n    float n = (noise(p) + noise(p * 2.0) * 0.5 + noise(p * 4.0) * 0.25) * 0.57;\n    return length(point) - 0.35 - n * 0.3;\n}\n\nvec3 getNormal(vec3 point)\n{\n    vec2 e = vec2(0.002, 0.0);\n    return normalize(SDF(point) - vec3(SDF(point - e.xyy), SDF(point - e.yxy), SDF(point - e.yyx)));\n}\n\nHit raymarch(vec3 p, vec3 d)\n{\n    Hit hit;\n    hit.closest_dist = MAX_DISTANCE;\n    for (int i = 0; i < MAX_RAY_MARCH_STEPS; ++i)\n    {\n        float sdf = SDF(p);\n        p += d * sdf; \n        hit.closest_dist = min(hit.closest_dist, sdf);\n        hit.dist += sdf;\n        if (hit.dist >= MAX_DISTANCE || abs(sdf) <= SURFACE_DISTANCE)\n            break; \n    }\n    \n    hit.p = p;\n    return hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = vec4(0, 0, 0, 1);\n    if (dot(uv, uv) > 1.0) return;\n    vec3 pos = vec3(0, 0, -1);\n    vec3 dir = normalize(vec3(uv, 1));\n    \n    Hit hit = raymarch(pos, dir);\n    fragColor = vec4(pow(max(0.0, 1.0 - hit.closest_dist), 32.0) * (max(0.0, dot(uv, vec2(0.707))) * vec3(0.3, 0.65, 1.0) + max(0.0, dot(uv, vec2(-0.707))) * vec3(0.6, 0.35, 1.0) + vec3(0.4, 0.5, 1.0)), max(0.0, hit.closest_dist));\n    if (hit.closest_dist >= SURFACE_DISTANCE)\n        return;\n    vec3 normal = getNormal(hit.p);\n\n    vec3 ray_dir = normalize(pos - hit.p);\n    float facing = max(0.0, sqrt(dot(normal, vec3(0.707, 0.707, 0))) * 1.5 - dot(normal, -dir));\n    fragColor = mix(vec4(0), vec4(0.3, 0.65, 1.0, 1.0), 0.75 * facing * facing * facing);\n    \n    facing = max(0.0, sqrt(dot(normal, vec3(-0.707, -0.707, 0))) * 1.5 - dot(normal, -dir));\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.6, 0.35, 1.0, 1.0), 0.75 * facing * facing * facing);\n    \n    facing = max(0.0, sqrt(dot(normal, vec3(0.0, 0.0, -1.0))) * 1.5 - dot(normal, -dir));\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.4, 0.5, 1.0, 1.0), 0.5 * facing * facing * facing);\n    \n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.4, 0.625, 1.0, 1.0), pow(specularBlinnPhong(normalize(vec3(600, 800, -500) - hit.p), ray_dir, normal), 12.0) * 1.0);\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.6, 0.5625, 1.0, 1.0), pow(specularBlinnPhong(normalize(vec3(-600, -800, -00) - hit.p), ray_dir, normal), 16.0) * 0.75);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.25));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcSDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 230, 230, 326], [328, 328, 348, 348, 393], [394, 394, 412, 412, 451], [453, 453, 474, 474, 965], [967, 967, 990, 990, 1167], [1169, 1169, 1197, 1197, 1331], [1333, 1333, 1363, 1363, 1734], [1736, 1736, 1791, 1791, 3435]], "test": "untested"}
{"id": "ddtSWB", "name": "ShaderBot Psychedelic", "author": "whimsy0000", "description": "ChatGPT 4 generated breathing, psychedelic closed eye visuals", "tags": ["psychedelic", "breathing"], "likes": 3, "viewed": 178, "published": 3, "date": "1680378692", "time_retrieved": "2024-07-30T18:02:29.288427", "image_code": "// Permutation for the noise function\nconst vec3[4] c_permutation = vec3[](\n    vec3(151,160,137), vec3(161,107, 47), vec3(202, 95, 33), vec3(217, 60, 44)\n);\n\nfloat fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat grad(int hash, float x, float y) {\n    int h = hash & 15;\n    float u = h < 8 ? x : y;\n    float v = h < 4 ? y : (h == 12 || h == 14 ? x : 0.0);\n    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n}\n\nfloat perlinNoise(vec2 p) {\n    vec2 P = floor(p);\n    vec2 f = fract(p);\n\n    float A = dot(c_permutation[int(P.x) & 3], c_permutation[int(P.y) & 3]);\n    float B = dot(c_permutation[int(P.x) & 3], c_permutation[int(P.y + 1.0) & 3]);\n    float C = dot(c_permutation[int(P.x + 1.0) & 3], c_permutation[int(P.y) & 3]);\n    float D = dot(c_permutation[int(P.x + 1.0) & 3], c_permutation[int(P.y + 1.0) & 3]);\n\n    vec2 u = vec2(fade(f.x), fade(f.y));\n\n    return mix(mix(grad(int(A), f.x, f.y),\n                   grad(int(B), f.x, f.y - 1.0),\n                   u.y),\n               mix(grad(int(C), f.x - 1.0, f.y),\n                   grad(int(D), f.x - 1.0, f.y - 1.0),\n                   u.y),\n               u.x) * 0.5 + 0.5;\n}\n\n// Shader code for shadertoy.com\n\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime * 0.1;\n    \n    vec2 p = uv * 10.0 + t;\n    float noise = perlinNoise(p);\n    \n    float breathe = sin(iTime * .2) * 0.5 + 1.0;\n    float scale =  6.0 * noise * breathe;\n    vec2 st = uv * scale;\n    \n    float angle = 2.0 * 3.14159 * noise * breathe;\n    vec2 rotateUv;\n    rotateUv.x = st.x * cos(angle) - st.y * sin(angle);\n    rotateUv.y = st.x * sin(angle) + st.y * cos(angle);\n    \n    float fractal = perlinNoise(rotateUv);\n    \n    vec3 color;\n    color.r = fractal;\n    color.g = fractal * 0.8;\n    color.b = fractal * 0.5;\n    \n    vec3 hsvColor = vec3(fractal + t * 0.1, 1.0, fractal);\n    vec3 rgbColor = hsv2rgb(hsvColor);\n    \n    fragColor = vec4(rgbColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 180, 180, 236], [238, 238, 278, 278, 452], [454, 454, 481, 481, 1184], [1221, 1221, 1243, 1243, 1412], [1414, 1414, 1469, 1469, 2214]], "test": "untested"}
{"id": "DstSWB", "name": "Water fall fork", "author": "ddinhddoong", "description": "based on https://www.shadertoy.com/view/4lcfDl", "tags": ["simulation", "water", "fluid"], "likes": 3, "viewed": 256, "published": 3, "date": "1680373802", "time_retrieved": "2024-07-30T18:02:30.056374", "image_code": "void mainImage( out vec4 C, in vec2 U )\n{   R = iResolution.xy;\n    vec4 data = T(U);\n\n    // density display\n    float d = data.w*3.;\n    vec4 cd = d*vec4(.1, .5, 1, 1);\n    \n    // velocity display\n    vec2 ve = data.xy*.1;\n    vec4 cv = vec4(ve.x, ve.y, 0, 1);\n    \n    // pressure display\n    float p = data.z;\n    vec4 cp = p*vec4(1, 1, 1, 1);\n    \n    \n    //C = cp;\n    //C = cv;\n    C = cd;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 data, in vec2 coord)\n{\n    R = iResolution.xy;\n\n    vec4 e = T(coord + vec2(1, 0)),\n         n = T(coord + vec2(0, 1)),\n         w = T(coord + vec2(-1, 0)),\n         s = T(coord + vec2(0, -1));\n\n    //advection\n    vec2 vu = T(coord - dt * T(coord).xy).xy;\n    data = T(coord - dt * vu);\n    \n    //test, max density = maxD;\n    float ww = max(w.w - maxD, 0.),\n          nn = max(n.w - maxD, 0.),\n          ee = max(e.w - maxD, 0.),\n          ss = max(s.w - maxD, 0.);\n    float sigma = (ww+nn+ee+ss)/4.;\n    if (data.w < maxD) data.w += sigma;\n    else\n    data.w -= sigma;\n    \n    float waterLevel = ceil(data.w - .2);\n    //pressure gradient\n    vec2 gp = vec2(e.z - w.z, n.z - s.z);\n\n    //density gradient\n    vec2 gw = vec2(e.w - w.w, n.w - s.w)*waterLevel;\n\n    //divergence\n    float div = (e.x - w.x + n.y - s.y)*waterLevel;\n    float p = (w.z + n.z + e.z + s.z) / 4.;\n    data.z = p + 0.01 * div;\n\n    //vorticity\n    vec2 vort = vec2(abs(n.z) - abs(s.z), abs(e.z) - abs(w.z));\n    vort *= VORTICITY_AMOUNT / length(vort + 1e-9) * (data.z);\n\n    //update velocity\n    float r = (1.+ 10.* data.w) * .1;\n    data.xy += r * k * gp - l * gw + vort;\n\n    //vertical gravity\n    if(data.w > 0.)\n    data.y -= r * g * (data.w + .1);\n\n    //spherical gravity\n    //data.xy -= r*g * data.w * normalize(coord.xy -  R*.5);\n\n    // dissipation\n    if (data.w < 0.001) data.z *= .998; //move slower in air\n    data.xyz *= .9998;\n    data.w *= 1.003;\n\n    //initial data\n    if (iFrame < 1)\n        data = vec4(0);\n\n    //obstacle\n    bool isWall = (coord.x < 1.|| coord.y < 1.|| coord.x > R.x - 1. || coord.y > R.y - 1.); //1px border\n    if (isWall ||\n       isBlock(vec2(0., 0.), vec2(.15, .5), coord) ||\n       isBlock(vec2(0., 0.), vec2(.35, .25), coord) ||\n       isBlock(.45 * vec2(1., 1.), .55 * vec2(1., 1.), coord))\n    {\n        data.xy *= 0.;\n        data.w *= .5;\n    }\n    //water source\n    if (length(coord - R * vec2(.0, .75)) < 8.)\n    {\n        data.x = 30.;\n        //data.y = 50.;\n        data.w = 1.;\n    }\n    // mouse interaction\n    if (length(coord - iMouse.xy) < 10. && iMouse.z > 0.)\n    {\n        //data.xy = (iMouse.xy - abs(iMouse.zw)) * 3.;\n        data.w = 1.;\n    }\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define k 20. //pressure diffuse\n#define l 7. //density diffuse\n#define dt .5\n#define g 2.5 // g = m*9.8\n#define t iTime\n#define maxD .5\n#define T(p) texture(iChannel0,(p)/iResolution.xy)\n#define T1(p) texture(iChannel1,(p)/iResolution.xy)\n#define T2(p) texture(iChannel2,(p)/iResolution.xy)\n\n//Recommended values between 0.03 and 0.2\n//higher values simulate lower viscosity fluids (think billowing smoke)\n#define VORTICITY_AMOUNT 0.03\n\nvec2 R;\n\nbool isBlock(vec2 startPoint, vec2 endPoint, vec2 coord)\n{\n    return (coord.x > startPoint.x * R.x && coord.y > startPoint.y * R.y &&\n            coord.x < endPoint.x * R.x && coord.y < endPoint.y * R.y);\n}", "buffer_b_code": "void mainImage(out vec4 data, in vec2 coord)\n{\n    R = iResolution.xy;\n    \n    vec4 e = T(coord + vec2(1, 0)),\n         n = T(coord + vec2(0, 1)),\n         w = T(coord + vec2(-1, 0)),\n         s = T(coord + vec2(0, -1));\n    \n\n    data = texture(iChannel0, coord/R);\n    if(data.w <= 0.0) data.z *= .99;\n    \n    //data.xy += (w.w*vec2(1, 0) + n.w*vec2(0, 1) + e.w*vec2(-1, 0) + s.w*vec2(0, -1))*2.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 data, in vec2 coord)\n{\n    R = iResolution.xy;\n\n    vec4 e = T(coord + vec2(1, 0)),\n         n = T(coord + vec2(0, 1)),\n         w = T(coord + vec2(-1, 0)),\n         s = T(coord + vec2(0, -1));\n    \n    data = T(coord);\n    //test, max density = maxD;\n    float ww = max(w.w - maxD, 0.),\n          nn = max(n.w - maxD, 0.),\n          ee = max(e.w - maxD, 0.),\n          ss = max(s.w - maxD, 0.);\n    float sigma = (ww+nn+ee+ss)/4.;\n    if (data.w < maxD) data.w += sigma;\n    else\n    data.w -= sigma;\n    \n    //divergence\n    float div = (e.x - w.x + n.y - s.y);\n    float p = (w.z + n.z + e.z + s.z) / 4.;\n    data.z = p + 0.01 * div;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 data, in vec2 coord)\n{\n    R = iResolution.xy;\n\n    vec4 e = T(coord + vec2(1, 0)),\n         n = T(coord + vec2(0, 1)),\n         w = T(coord + vec2(-1, 0)),\n         s = T(coord + vec2(0, -1));\n    \n    data = T(coord);\n    //test, max density = maxD;\n    float ww = max(w.w - maxD, 0.),\n          nn = max(n.w - maxD, 0.),\n          ee = max(e.w - maxD, 0.),\n          ss = max(s.w - maxD, 0.);\n    float sigma = (ww+nn+ee+ss)/4.;\n    if (data.w < maxD) data.w += sigma;\n    else\n    data.w -= sigma;\n    \n    //divergence\n    float div = (e.x - w.x + n.y - s.y);\n    float p = (w.z + n.z + e.z + s.z) / 4.;\n    data.z = p + 0.01 * div;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstSWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 400]], "test": "untested"}
{"id": "cdtXzs", "name": "Particle Swarm Optimization", "author": "paniq", "description": "global optimization over toroid [0,1] in 2D using https://en.wikipedia.org/wiki/Particle_swarm_optimization, demonstrated on different examples", "tags": ["2d", "vector", "library", "graphics"], "likes": 11, "viewed": 383, "published": 3, "date": "1680357444", "time_retrieved": "2024-07-30T18:02:31.329969", "image_code": "\n//////////////////////////////////////////////////////////\n\nvec3 viridis(float t) {\n    t = clamp(t, 0.0, 1.0);\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nvoid paint() {\n    //F = get_query().x;\n    float t = iTime;\n\n    set_source_rgb(viridis(loss(get_origin())));\n    //set_source_rgb(1.0, 1.0, 1.0);\n    clear();\n    \n    set_line_width_px(1.0);\n    set_source_rgb(1.0, 1.0, 1.0);\n    int g_i = 0;\n    for (int j = 0; j < N; ++j) {\n        vec4 data0 = texelFetch(iChannel0, ivec2(j, 0), 0);\n        vec4 data1 = texelFetch(iChannel0, ivec2(j, 1), 0);\n        g_i = floatBitsToInt(data1.w);\n        vec2 x = data0.xy*2.0-1.0;\n        vec2 p = data1.xy*2.0-1.0;\n        circle(x, 0.01);\n        circle(p, 0.02);\n        fill();\n    }\n    \n    vec4 data1 = texelFetch(iChannel0, ivec2(g_i, 1), 0);\n    vec2 p = data1.xy*2.0-1.0;\n    circle(p, 0.02);\n    set_source_rgb(1.0, 0.0, 0.0);\n    fill();\n    \n    set_source_rgb(0.0, 0.0, 0.0);\n    rectangle(-1.0,-1.0,2.0,2.0);\n    stroke();\n    \n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    example = iFrame / EXAMPLE_RATE;\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// switch every 10 seconds\n#define EXAMPLE_RATE (5*60)\n\nconst float pi = 3.141592653589793;\nconst float e = 2.718281828459045;\nconst int N = 20;\n\nfloat sdBox(vec2 p, vec2 s) {\n    vec2 d = abs(p) - s;\n    return min(max(d.x, d.y), 0.0) \n        + length(max(d,vec2(0.0)));\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    p = vec2(\n        c * p.x - s * p.y,\n        s * p.x + c * p.y\n        );\n}\n\nfloat srange (float a, float b, float r) {\n    return clamp(r - abs(a - b), 0.0, r);\n}\n\nfloat sdSmoothOr (float a, float b, float r) {\n    float e = srange(a, b, r);\n    return min(a, b) - (e * e * (0.25 / r));\n}    \n\nfloat map(vec2 p) {\n#if 0\n    float d0 = length(p) - 0.5;\n    float d1 = length(p + vec2(-0.25,0.0)) - 0.3;\n    float d2 = length(p + vec2(0.0, 0.65)) - 0.2;\n    return max(min(d0,d2), -d1);\n#else\n    float d2 = length(p - vec2(0.2)) - 0.3;\n    rotate(p, radians(30.0));\n    float d1 = sdBox(p - vec2(0.0,0.5), vec2(0.5));\n    rotate(p, radians(-35.0));\n    float d0 = sdBox(p, vec2(0.5));\n    return sdSmoothOr(d2,max(d0, -d1),0.2);\n#endif\n}\n\nfloat ackley(vec2 p) {\n    return -20.0*exp(-0.2*sqrt(0.5*dot(p,p))) - exp(0.5*(cos(2.0*pi*p.x) + cos(2.0*pi*p.y))) + e + 20.0;\n}\n\n// loss function at the bottom of this shader\n\n// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// transform current shape to isolines\nvoid stroke_isolines_preserve();\nvoid stroke_isolines_preserve(float r);\nvoid stroke_isolines_preserve(float r, float phase);\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        fract(vec4(position, query_position)*0.5+0.5)*2.0 - 1.0,\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nvec2 stroke_isolines_shape(float r, float phase) {\n    return abs(fract(_stack.shape/r-phase+0.5)-0.5)*r - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_isolines_preserve(float r, float phase) {\n    float w = stroke_isolines_shape(r, phase).x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke_isolines_preserve(float r) { stroke_isolines_preserve(r, 0.0); }\n\nvoid stroke_isolines_preserve() { stroke_isolines_preserve(0.1); }\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nfloat fractsub(float a, float b) {\n    return fract(a - b + 0.5) - 0.5;\n}\nvec2 fractsub(vec2 a, vec2 b) {\n    return fract(a - b + 0.5) - 0.5;\n}\nvec3 fractsub(vec3 a, vec3 b) {\n    return fract(a - b + 0.5) - 0.5;\n}\nvec4 fractsub(vec4 a, vec4 b) {\n    return fract(a - b + 0.5) - 0.5;\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(fractsub(o.xyxy*0.5, _stack.position*0.5)*2.0) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = fractsub(_stack.position*0.5, p.xyxy*0.5)*2.0;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n\n// random number generator library (https://www.shadertoy.com/view/ssGXDd)\n// by Leonard Ritter (@leonard_ritter)\n\n// based on https://www.shadertoy.com/view/MdcfDj\n// license: https://unlicense.org/\n\n// 2022/11/27: added support for hexagon sampling\n\n// comment out for faster but lower quality hashing\n#define RNGL_HIGH_QUALITY\n\nstruct Random { uint s0; uint s1; };\n\n// constructors; note that constructors are wilfully unique,\n// i.e. calling a different constructor with the same arguments will not\n// necessarily produce the same state.\nuint uhash(uint a, uint b);\nRandom seed(uint s) { return Random(s, uhash(0x1ef7c663u, s)); }\nRandom seed(uvec2 s) { return Random(s.y, uhash(s.x, s.y)); }\nRandom seed(Random a, uint b) { return Random(b, uhash(a.s1, b)); }\nRandom seed(Random a, uvec2 b) { return seed(a, uhash(b.x, b.y)); }\nRandom seed(Random a, uvec3 b) { return seed(a, uhash(uhash(b.x, b.y), b.z)); }\nRandom seed(Random a, uvec4 b) { return seed(a, uhash(uhash(b.x, b.y), uhash(b.z, b.w))); }\nRandom seed(uvec3 s) { return seed(seed(s.xy), s.z); }\nRandom seed(uvec4 s) { return seed(seed(s.xy), s.zw); }\nRandom seed(int s) { return seed(uint(s)); }\nRandom seed(ivec2 s) { return seed(uvec2(s)); }\nRandom seed(ivec3 s) { return seed(uvec3(s)); }\nRandom seed(ivec4 s) { return seed(uvec4(s)); }\nRandom seed(Random a, int b) { return seed(a, uint(b)); }\nRandom seed(Random a, ivec2 b) { return seed(a, uvec2(b)); }\nRandom seed(Random a, ivec3 b) { return seed(a, uvec3(b)); }\nRandom seed(Random a, ivec4 b) { return seed(a, uvec4(b)); }\nRandom seed(float s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec2 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec3 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec4 s) { return seed(floatBitsToUint(s)); }\nRandom seed(Random a, float b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec2 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec3 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec4 b) { return seed(a, floatBitsToUint(b)); }\n\n// fundamental functions to fetch a new random number\n// the last static call to the rng will be optimized out\nuint urandom(inout Random rng) {\n    uint last = rng.s1;\n    uint next = uhash(rng.s0, rng.s1);\n    rng.s0 = rng.s1; rng.s1 = next;\n    return last;\n}\nuvec2 urandom2(inout Random rng) { return uvec2(urandom(rng),urandom(rng)); }\nuvec3 urandom3(inout Random rng) { return uvec3(urandom2(rng),urandom(rng)); }\nuvec4 urandom4(inout Random rng) { return uvec4(urandom2(rng),urandom2(rng)); }\nint irandom(inout Random rng) { return int(urandom(rng)); }\nivec2 irandom2(inout Random rng) { return ivec2(urandom2(rng)); }\nivec3 irandom3(inout Random rng) { return ivec3(urandom3(rng)); }\nivec4 irandom4(inout Random rng) { return ivec4(urandom4(rng)); }\n\nfloat unorm(uint n);\nfloat random(inout Random rng) { return unorm(urandom(rng)); }\nvec2 random2(inout Random rng) { return vec2(random(rng),random(rng)); }\nvec3 random3(inout Random rng) { return vec3(random2(rng),random(rng)); }\nvec4 random4(inout Random rng) { return vec4(random2(rng),random2(rng)); }\n\n// ranged random value < maximum value\nint range(inout Random rng, int mn, int mx) { return mn + (irandom(rng) % (mx - mn)); }\nivec2 range(inout Random rng, ivec2 mn, ivec2 mx) { return mn + (irandom2(rng) % (mx - mn)); }\nivec3 range(inout Random rng, ivec3 mn, ivec3 mx) { return mn + (irandom3(rng) % (mx - mn)); }\nivec4 range(inout Random rng, ivec4 mn, ivec4 mx) { return mn + (irandom4(rng) % (mx - mn)); }\nuint range(inout Random rng, uint mn, uint mx) { return mn + (urandom(rng) % (mx - mn)); }\nuvec2 range(inout Random rng, uvec2 mn, uvec2 mx) { return mn + (urandom2(rng) % (mx - mn)); }\nuvec3 range(inout Random rng, uvec3 mn, uvec3 mx) { return mn + (urandom3(rng) % (mx - mn)); }\nuvec4 range(inout Random rng, uvec4 mn, uvec4 mx) { return mn + (urandom4(rng) % (mx - mn)); }\nfloat range(inout Random rng, float mn, float mx) { float x=random(rng); return mn*(1.0-x) + mx*x; }\nvec2 range(inout Random rng, vec2 mn, vec2 mx) { vec2 x=random2(rng); return mn*(1.0-x) + mx*x; }\nvec3 range(inout Random rng, vec3 mn, vec3 mx) { vec3 x=random3(rng); return mn*(1.0-x) + mx*x; }\nvec4 range(inout Random rng, vec4 mn, vec4 mx) { vec4 x=random4(rng); return mn*(1.0-x) + mx*x; }\n\n// marshalling functions for storage in image buffer and rng replay\nvec2 marshal(Random a) { return uintBitsToFloat(uvec2(a.s0,a.s1)); }\nRandom unmarshal(vec2 a) { uvec2 u = floatBitsToUint(a); return Random(u.x, u.y); }\n\n//// specific distributions\n\n// normal/gaussian distribution\n// see https://en.wikipedia.org/wiki/Normal_distribution\nfloat gaussian(inout Random rng, float mu, float sigma) {\n    vec2 q = random2(rng);\n    float g2rad = sqrt(-2.0 * (log(1.0 - q.y)));\n    float z = cos(q.x*6.28318530718) * g2rad;\n    return mu + z * sigma;\n}\n\n// triangular distribution\n// see https://en.wikipedia.org/wiki/Triangular_distribution\n// mode is a mixing argument in the range 0..1\nfloat triangular(inout Random rng, float low, float high, float mode) {\n    float u = random(rng);\n    if (u > mode) {\n        return high + (low - high) * (sqrt ((1.0 - u) * (1.0 - mode)));\n    } else {\n        return low + (high - low) * (sqrt (u * mode));\n    }\n}\nfloat triangular(inout Random rng, float low, float high) { return triangular(rng, low, high, 0.5); }\n\n// after https://www.shadertoy.com/view/4t2SDh\n// triangle distribution in the range -0.5 .. 1.5\nfloat triangle(inout Random rng) {\n    float u = random(rng);\n    float o = u * 2.0 - 1.0;\n    return max(-1.0, o / sqrt(abs(o))) - sign(o) + 0.5;\n}\n\n//// geometric & euclidean distributions\n\n// uniformly random point on the edge of a unit circle\n// produces 2d normal vector as well\nvec2 uniform_circle_edge (inout Random rng) {\n    float u = random(rng);\n    float phi = 6.28318530718*u;\n    return vec2(cos(phi),sin(phi));\n}\n\n// uniformly random point in unit circle\nvec2 uniform_circle_area (inout Random rng) {\n    return uniform_circle_edge(rng)*sqrt(random(rng));\n}\n\n// gaussian random point in unit circle\nvec2 gaussian_circle_area (inout Random rng, float k) {\n    return uniform_circle_edge(rng)*sqrt(-k*log(random(rng)));\n}\nvec2 gaussian_circle_area (inout Random rng) { return gaussian_circle_area(rng, 0.5); }\n\n// cartesian coordinates of a uniformly random point within a hexagon\nvec2 uniform_hexagon_area (inout Random rng, float phase) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    \n    const float sqrt3div4 = sqrt(3.0 / 4.0);\n    const float pidiv6 = 0.5235987755982988;\n    float r = sqrt3div4 / cos(mod(phi + phase, 2.0 * pidiv6) - pidiv6);\n\n    return vec2(cos(phi), sin(phi)) * r * sqrt(u.y);\n}\n\nvec2 uniform_hexagon_area (inout Random rng) {\n    return uniform_hexagon_area(rng, 1.5707963267948966);\n}\n\n// barycentric coordinates of a uniformly random point within a triangle\nvec3 uniform_triangle_area (inout Random rng) {\n    vec2 u = random2(rng);\n    if (u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    return vec3(u.x, u.y, 1.0-u.x-u.y);\n}\n\n// uniformly random on the surface of a sphere\n// produces normal vectors as well\nvec3 uniform_sphere_area (inout Random rng) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}\n\n// uniformly random within the volume of a sphere\nvec3 uniform_sphere_volume (inout Random rng) {\n    return uniform_sphere_area(rng) * pow(random(rng), 1.0/3.0);\n}\n\n// barycentric coordinates of a uniformly random point within a 3-simplex\n// based on \"Generating Random Points in a Tetrahedron\" by Rocchini et al\nvec4 uniform_simplex_volume (inout Random rng) {\n    vec3 u = random3(rng);\n    if(u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    if(u.y + u.z > 1.0) {\n        u.yz = vec2(1.0 - u.z, 1.0 - u.x - u.y);\n    } else if(u.x + u.y + u.z > 1.0) {\n        u.xz = vec2(1.0 - u.y - u.z, u.x + u.y + u.z - 1.0);\n    }\n    return vec4(1.0 - u.x - u.y - u.z, u); \n}\n\n// for differential evolution, in addition to index K, we need to draw three more\n// indices a,b,c for a list of N items, without any collisions between k,a,b,c.\n// this is the O(1) hardcoded fisher-yates shuffle for this situation.\nivec3 sample_k_3(inout Random rng, int N, int K) {\n    ivec3 t = range(rng, ivec3(1,2,3), ivec3(N));\n    int db = (t.y == t.x)?1:t.y;\n    int dc = (t.z == t.y)?((t.x != 2)?2:1):((t.z == t.x)?1:t.z);\n    return (K + ivec3(t.x, db, dc)) % N;\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// auxiliary functions from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// The Unreasonable Effectiveness of Quasirandom Sequences, by Martin Roberts\nfloat r1(float o, int i) {\n    return fract(o + float(i * 10368889)/exp2(24.0));\n}\nvec2 r2(vec2 o, int i) {\n    return fract(o + vec2(i * ivec2(12664745, 9560333))/exp2(24.0));\n}\nvec3 r3(vec3 o, int i) {\n    return fract(o + vec3(i * ivec3(13743434, 11258243, 9222443))/exp2(24.0));\n}\nvec4 r4(vec4 o, int i) {\n    return fract(o + vec4(i * ivec4(14372619, 12312662, 10547948, 9036162))/exp2(24.0));\n}\n\nfloat r1(int i) { return r1(0.5, i); }\nvec2 r2(int i) { return r2(vec2(0.5), i); }\nvec3 r3(int i) { return r3(vec3(0.5), i); }\nvec4 r4(int i) { return r4(vec4(0.5), i); }\n\n/////////////////////////////////////////////////////////////////////////\n\n// if it turns out that you are unhappy with the distribution or performance\n// it is possible to exchange this function without changing the interface\nuint uhash(uint a, uint b) { \n    uint x = ((a * 1597334673U) ^ (b * 3812015801U));\n#ifdef RNGL_HIGH_QUALITY\n    // from https://nullprogram.com/blog/2018/07/31/\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n#else\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n#endif\n    return x;\n}\nfloat unorm(uint n) { return float(n) * (1.0 / float(0xffffffffU)); }\n\n/////////////////////////////////////////////////////////////////////////\n\nint example = 0;\nfloat loss(vec2 p) {\n    switch(example % 4) {\n    case 0: {\n        float d = map(p);    \n        const float eps = 1e-5;\n        /*\n        vec2 g = vec2(\n            (map(p + vec2(eps, 0.0)) - map(p - vec2(eps, 0.0))) / (2.0*eps),\n            (map(p + vec2(0.0, eps)) - map(p - vec2(0.0, eps))) / (2.0*eps));    */\n        //g = normalize(g);\n        //return max(abs(g.x),abs(g.y));\n        return d+0.4;\n    }\n    case 1: {\n        p.x -= 0.3;\n        p *= 7.0;\n        float w1 = 1.0;\n        float w2 = 0.9;\n        return 0.003 * (1.0 + (w1*ackley(p - vec2(-0.8,0.0)*10.0) * ackley(p - vec2(0.8,0.0)*10.0)*w2));\n    }\n    case 2: {\n        return 0.5 + 0.3*step(0.0, length(p - vec2(0.8,-0.3)) - 0.02)*step(0.0, length(p - vec2(-0.3,0.8)) - 0.02) - step(length(p - vec2(-0.3,-0.8)) - 0.2, 0.0)*0.1;\n    }\n    case 3: {\n        Random rng = seed(ivec2((p*0.5+0.5)*80.0) + ivec2(12345,6789));\n        return tanh((1.2 + (random(rng)*2.0-1.0) + map(p))*1.0);\n    }\n    default: return 0.0;\n    }\n}\n", "buffer_a_code": "\nconst float CR = 0.9;\nfloat F = 0.8;\n\nfloat f(vec2 p) {\n    return loss(p*2.0 - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    example = iFrame / EXAMPLE_RATE;\n    const float phi_p = 1.0;\n    const float phi_g = 3.0;\n    const float w = 0.8;\n\n    ivec2 fc = ivec2(fragCoord);\n    if (fc.y >= 2)\n        return;\n    if (fc.x >= N)\n        return;\n    vec2 x; // current position\n    vec2 p; // best known position\n    vec2 v; // vector\n    float f_p; // f(p)\n    int g_i; // index of best neighbor\n    int i = fc.x;\n    float t = 1.0 / 60.0;\n    if ((iFrame % EXAMPLE_RATE) == 0) {\n        Random rng = seed(seed(iFrame), i);\n        x = random2(rng);\n        v = random2(rng)*2.0-1.0;\n        p = x;\n        f_p = f(p);\n        g_i = i;\n    } else {\n        Random rng = seed(seed(iFrame), i);\n        vec4 data0 = texelFetch(iChannel0, ivec2(i, 0), 0);\n        vec4 data1 = texelFetch(iChannel0, ivec2(i, 1), 0);\n        x = data0.xy; v = data0.zw;\n        p = data1.xy; f_p = data1.z; g_i = floatBitsToInt(data1.w);\n        float f_g = texelFetch(iChannel0, ivec2(g_i, 1), 0).z;\n        // update global optimum - in a compute shader, we could just use a shared variable\n        // here we'll just probe a random neighbor\n        {\n            int j = range(rng, 0, N);            \n            j = floatBitsToInt(texelFetch(iChannel0, ivec2(j, 1), 0).w);\n            vec3 dataj = texelFetch(iChannel0, ivec2(j, 1), 0).xyz;\n            if (dataj.z < f_g) {\n                g_i = j;\n                f_g = dataj.z;\n            }\n        }\n        vec2 g = texelFetch(iChannel0, ivec2(g_i, 1), 0).xy;\n        float r1 = random(rng);\n        float r2 = random(rng);\n        for (int d = 0; d < 2; ++d) {\n            v[d] = w * v[d] + phi_p * r1 * fractsub(p[d], x[d]) + phi_g * r2 * fractsub(g[d], x[d]);\n        }\n        x = fract(x + v);\n        float f_x = f(x);\n        if (f_x < f_p) {\n            f_p = f_x;\n            p = x;\n            if (f_p < f_g) {\n                f_g = f_p;\n                g_i = i;\n            }\n        }\n    }\n    if (fc.y == 0) {\n        fragColor = vec4(x, v);\n    } else {\n        fragColor = vec4(p, f_p, intBitsToFloat(g_i));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtXzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 84, 84, 767], [769, 769, 783, 808, 1606], [1668, 1668, 1725, 1725, 1848]], "test": "untested"}
{"id": "DtsGDN", "name": "Mandelbrot magic formula", "author": "kishimisu", "description": "Yet another mandelbrot renderer", "tags": ["fractal", "mandelbrot", "happy", "malicious", "april", "fools"], "likes": 15, "viewed": 490, "published": 3, "date": "1680355721", "time_retrieved": "2024-07-30T18:02:32.297382", "image_code": "/* \n    Straightforward method to calculate the Mandelbrot set without using\n    for/while loops by approximating the iteration count at a given point\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy))/iResolution.y;\n    p.x -= .5;\n    \n    vec3 color;\n    \n    // Magic formula\n    vec2 z = log(p*p+exp(p.x*p.x+p.y*p.y+0.247814));\n         z += 4.*((p.x*p.y-z.x*z.y)*1.618033+length(p-z));\n    \n    // Approximated iteration count\n    float i = dot(z,z)+log(2.*z.x*z.y);\n                                                                                                                                                                                                                                                                                              for (i=0., z*=i; i++<1e2; z=vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+p) { if(dot(z,z)>40.) { \n    // Smooth iteration count to avoid banding\n    float i_smoothed = i + 1.-log(log(dot(z,z)))/log(2.);\n    \n    // Colorize\n    color = cos(iTime+vec3(1,1.2,1.4)*sqrt(min(i_smoothed,40.)));\n                                                                                                                                                                                                                                                                                              break;}} // April Fools ;)\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsGDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 212, 212, 1447]], "test": "untested"}
{"id": "mstSzf", "name": "Glowing vortex", "author": "Peace", "description": "I made this for GUI button which will expand when hovered over.", "tags": ["vortex", "glowing"], "likes": 7, "viewed": 251, "published": 3, "date": "1680342733", "time_retrieved": "2024-07-30T18:02:33.318652", "image_code": "float vortex(vec2 x, float leaves, float spin, float phase) {\n    float p = smoothstep(0.0, 1.0, phase);\n    float r = length(x) - p;\n    float a = atan(x.y, x.x) + p;\n    return r - 1.0 + 0.1 * sin(leaves * (a + spin * r * r));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / mr;\n    float v = vortex(uv * 3.0, 8.0, 0.35, sin(iTime * 4.0));\n    float d = smoothstep(1.7, 0.0, v);\n    fragColor = vec4(vec3(0, 0.5, 1) * d - abs(v), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstSzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 230], [232, 232, 284, 284, 546]], "test": "untested"}
{"id": "Ds3SWB", "name": "Complex domain warping (cont'd)", "author": "eo", "description": "tan(VanDamme) is too funny\n\nKeys:\nm               - toggle magnitude levels\np                - toggle phase levels\ntab             - toggle video source\nmouse       - select quadrant\nl                 - lock mouse down", "tags": ["video", "warping", "complex", "contours"], "likes": 5, "viewed": 178, "published": 3, "date": "1680313203", "time_retrieved": "2024-07-30T18:02:34.253153", "image_code": "\n/*\nForked from https://shadertoy.com/view/clfSRM\n\nVisualizing complex functions:\n\n  \n       cos(z)        pow(z,z)    \n  \n       exp(z)         log(z)     \n  \n\nEach function takes in a complex value z (i.e. 2d coordinate xy) and\ncomputes a new complex value, usually different from the input.\nAt each input xy, the video is sampled using the computed xy,\ngiving a warping effect.\n\nPressing tab switches to a domain coloring view. For more info\nabout that, see \"Domain coloring w/ level curves\"\nhttps://shadertoy.com/view/clfSRM\n*/\n\n// Control appearance\n#define MAG_LEVELS 4\n#define PHASE_LEVELS 12\n#define LEVELS_CONTRAST 0.25\n#define ZOOM 0.5\n\n\nfloat get_level_scale(vec2 polar_mag_angle, bool enable_mag, bool enable_phase) {\n\n    /*\n    Calculates a scaling term used to darken the resulting image\n    in such a way that magnitude/phase contour lines appear,\n    acting a bit like polar coordinate grid-lines\n    */\n\n    // Set up the number of magnitude & phase levels\n    float mag_level = fract(float(MAG_LEVELS) * polar_mag_angle.x);\n    float phase_level = fract(float(PHASE_LEVELS) * polar_mag_angle.y);\n    \n    // Include mag/phase leveling, based on enabling inputs\n    mag_level = mix(1.0, mag_level, float(enable_mag));\n    phase_level = mix(1.0, phase_level, float(enable_phase));\n    float leveling = mag_level * phase_level;\n    \n    // Adjust scaling for better aesthetics\n    return (1.0 - LEVELS_CONTRAST) + LEVELS_CONTRAST * leveling;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Read keyboard\n    bool show_video = !get_key_toggle(iChannel0, KEY_tab);\n    bool show_mag_levels = !get_key_toggle(iChannel0, KEY_m);\n    bool show_phase_levels = !get_key_toggle(iChannel0, KEY_p);\n    bool hold_mouse = get_key_toggle(iChannel0, KEY_l);\n    \n    // For clarity, figure out which quadrant we're in\n    vec2 cartesian_xy = get_cartesian_coords(fragCoord.xy, iResolution);\n    float aspect = iResolution.x / iResolution.y;\n    bool is_right = cartesian_xy.x > 0.0;\n    bool is_top = cartesian_xy.y > 0.0;\n    bool top_left = !is_right && is_top;\n    bool top_right = is_right && is_top;\n    bool bot_left = !is_right && !is_top;\n    bool bot_right = is_right && !is_top;\n    \n    // Get a centered (-1 to +1) z coordinate for each of the 4 cells\n    vec2 cell_offset = vec2(aspect*(is_right ? 1.0:-1.0), is_top ? 1.0:-1.0);\n    vec2 cell_z = (2.0*cartesian_xy - cell_offset) / ZOOM;\n    \n    // Override quadrant rendering if the mouse is pressed\n    bool mouse_is_down = (iMouse.z > 0.0) || hold_mouse;\n    if (mouse_is_down){\n        cell_z = cartesian_xy / ZOOM;\n        bool m_is_right = iMouse.x > iResolution.x*0.5;\n        bool m_is_top = iMouse.y > iResolution.y*0.5;\n        top_left = !m_is_right && m_is_top;\n        top_right = m_is_right && m_is_top;\n        bot_left = !m_is_right && !m_is_top;\n        bot_right = m_is_right && !m_is_top;\n    }\n    \n    // Select one of the functions!\n    vec2 f_of_z = vec2(1);\n         if (top_left)     f_of_z = tan2d(cell_z);\n    else if (top_right)    f_of_z = pow2d(cell_z, cell_z);\n    else if (bot_left)     f_of_z = exp2d(cell_z);\n    else if (bot_right)    f_of_z = log2d(cell_z);\n    \n    // Calculate scaling for constant mag/phase level indicators\n    vec2 polar = get_polar(f_of_z);\n    float level_scale = get_level_scale(polar, show_mag_levels, show_phase_levels);   \n    \n    // Toggle video imagery vs. domain coloring image\n    vec3 out_rgb;   \n    if (show_video) {\n        out_rgb = sample_video_warped(iChannel1, f_of_z * ZOOM, iResolution);\n    } else {\n        vec3 phase_color = angle_to_rgb(polar.y);\n        out_rgb = phase_color * level_scale;\n    }\n    \n    // Add quadrant dividing lines\n    if (!mouse_is_down) {\n        float divider_line = smoothstep(0.0, 0.00001*iResolution.y, min(abs(cartesian_xy.x), abs(cartesian_xy.y)));\n        out_rgb *= 1.0 - LEVELS_CONTRAST*(1.0 - divider_line);\n    }\n    \n    fragColor = vec4(out_rgb, 1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// For clarity\n#define TWOPI 6.28318530718\n#define KEY_tab   9\n#define KEY_m    77\n#define KEY_p    80\n#define KEY_l    76\n#define is_near_zero(v) abs(v) < 0.0001\n\n\n// From iq:\n// https://www.shadertoy.com/view/ll2GD3\nvec3 angle_to_rgb(float num_0_to_1)\n{\n    vec3 brightness = vec3(0.6);\n    vec3 saturation = vec3(0.525);\n    vec3 rgb_phase = vec3(0.0, 0.33, 0.67);\n    return brightness + saturation * cos( TWOPI * (num_0_to_1 + rgb_phase) );\n}\n\n\n// -------------------------------------------------------------------------------\n// Sampling functions\n\nvec2 get_cartesian_coords(vec2 xy_px, vec3 res) {\n\n    /*\n    Maps xy 'pixel' coordinates (eg. fragCoord or iMouse)\n    into centered normalized cartesian (not stretched) coordinates.\n    Can think of the result as being 'graph paper' coordinates\n    - The center of the screen maps to (0, 0)\n    - The top of the screen has a y value of +1\n    - The bottom of the screen has a y value of -1\n    - The left & right edge x values will be -/+ the aspect ratio (ex: 16/9)\n    */\n\n    return (2.0*xy_px - res.xy) / res.y;\n}\n\nbool get_key_toggle(sampler2D keyboard_channel, int key_code) {\n    return bool(texelFetch(keyboard_channel, ivec2(key_code, 2), 0).x);\n}\n\nvec3 sample_video_warped(sampler2D channel, vec2 warp_uv, vec3 res) {\n\n    /*\n    Helper used to sample from videos using warped coordinates.\n    The coords are assumed to be calculated on a centered,\n    non-stretched coordinate system, which must be undone\n    to properly sample the video\n    */\n    \n    vec2 aspect_correction = vec2(res.y / res.x, 1.0);\n    vec2 sample_coords = 0.5 * (1.0 + warp_uv * aspect_correction);\n    return texture(channel, fract(sample_coords)).rgb;\n}\n\n\n// -------------------------------------------------------------------------------\n// Functions for complex number arthimetic\n\nvec2 mult2d(vec2 a, vec2 b) {\n\n    /*\n    Multiplication defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    \n    a*b = (ax + i*ay)*(bx + i*by)\n        = ax*bx + ax*i*by + i*ay*bx + i*ay*i*by\n        = ax*bx - ay*by + i*ax*by + i*ay*bx\n        = (ax*bx - ay*by) + i*(ax*by + ay*bx)\n    */\n    \n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);    \n}\n\nvec2 div2d(vec2 a, vec2 b) {\n\n    /*\n    Division defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    b' = bx - i*by  ->  (aka 'b conjugate')\n    \n    a   a   b'  ax + i*ay   bx - i*by \n     =  *  =  * \n    b   b   b'  bx + i*by   bx - i*by\n    \n        (ax*bx + ay*by) + i*(ay*bx - ax*by)\n      = \n                  bx*bx + by*by\n    */\n    \n    // Bail on divide-by-zero\n    if (is_near_zero(b.x) && is_near_zero(b.y)) {\n        return vec2(0,0);\n    }\n\n    float numer_real = a.x*b.x + a.y*b.y;\n    float numer_imag = a.y*b.x - a.x*b.y;\n    float denom = b.x*b.x + b.y*b.y;\n    \n    return vec2(numer_real, numer_imag)/denom;\n}\n\nvec2 exp2d(vec2 xy) {\n    float theta = atan(xy.y, xy.x);\n    return exp(xy.x)*vec2(cos(xy.y), sin(xy.y));\n}\n\nvec2 log2d(vec2 xy) {\n    // This is the natural log, aka ln\n    return vec2(log(length(xy)), atan(xy.y, xy.x));\n}\n\nvec2 sin2d(vec2 xy) {\n    vec2 iz = vec2(-xy.y, xy.x);\n    return div2d((exp2d(iz) - exp2d(-iz)), vec2(0,2));\n}\n\nvec2 cos2d(vec2 xy) {\n    vec2 iz = vec2(-xy.y, xy.x);\n    return 0.5*(exp2d(iz) + exp2d(-iz));\n}\n\nvec2 tan2d(vec2 xy) {\n    return div2d(sin2d(xy), cos2d(xy));\n}\n\nvec2 pow2d(vec2 xy, vec2 p) {\n\n    // Couldn't figure this one out on my own, it's from:\n    // https://mathworld.wolfram.com/ComplexExponentiation.html\n\n    // For convenience\n    float arg_z = atan(xy.y, xy.x);\n    float len_z = length(xy);\n    float len_zz = len_z*len_z;\n    \n    // For clarity\n    float arg_term = p.x*arg_z;\n    float ln_term = p.y*log(len_zz)*0.5;\n    float theta_term = arg_term + ln_term;\n    \n    float scale_term = pow(len_z, p.x) * exp(-p.y*arg_z);    \n    return scale_term * vec2(cos(theta_term), sin(theta_term));\n}\n\nvec2 get_polar(vec2 xy) {\n    \n    /*\n    Get polar coordinates from xy\n    Resulting magnitude is stored in .x, angle in .y\n    Note, the angle value is unitless, 0 to 1 (not radians!)\n    */\n\n    float magnitude = sqrt(length(xy));\n    float angle_minus_pi_to_pi = atan(-xy.y, xy.x);\n    float angle_norm = angle_minus_pi_to_pi/TWOPI;\n    \n    return vec2(magnitude, fract(angle_norm));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3SWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[972, 972, 1053, 1298, 1783], [1785, 1785, 1842, 1863, 4285]], "test": "untested"}
