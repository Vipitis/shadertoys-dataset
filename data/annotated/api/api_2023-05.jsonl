{"id": "mlcXD4", "name": "Laplace Transform moving poles", "author": "supernlogn", "description": "moving poles in laplace transform of an ODE\nBlue is real\nred is imaginary\n\nBecause behind each ODE there is a flower :)", "tags": ["laplacetransform"], "likes": 1, "viewed": 132, "published": 3, "date": "1685570241", "time_retrieved": "2024-07-30T17:53:06.107700", "image_code": "\nconst vec2 c_i = vec2(0,1);\nconst float PI = 3.1415926535897;\nconst int numberOfLeaves = 8;\nconst int X = numberOfLeaves/2;\nvec2 c_cjg(in vec2 c) {\nreturn vec2(c.x, -c.y);\n}\n\nvec2 c_mul(in vec2 a, in vec2 b) {\nreturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 c_pow(in vec2 c, int p) {\n    vec2 temp = vec2(1.0,0.0);\nfor (int i = 0; i < p; ++i) {\ntemp = c_mul(temp, c);\n}\n    return temp;\n}\nvec2 c_div(in vec2 a, in vec2 b) {\n    return\n        vec2(a.x*b.x + a.y*b.y,\n             a.y*b.x - a.x * b.y)\n        / (b.x * b.x + b.y * b.y)\n        ;\n}\nvec2 c_exp(in vec2 c) {\n    return exp(c.x) * vec2(cos(c.y),sin(c.y));\n}\n//uses the even-odd split formula, there are probably better ways\nvec2 c_sin(in vec2 c) {\n    return\n        c_div(\n        c_exp(c_mul(c_i , c))\n            -c_exp(c_mul(-c_i , c))\n            ,\n            2.*c_i\n\n        );\n}\nvec2 c_cos(in vec2 c) {\n    return\n        c_div(\n        c_exp(c_mul(c_i , c))\n            +c_exp(c_mul(-c_i , c))\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_sinh(in vec2 c) {\n    return\n        c_div(\n        c_exp(c)\n            -c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_cosh(in vec2 c) {\n    return\n        c_div(\n        c_exp(c)\n            +c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\n\nvec2 c_add(in vec2 c, float r)\n{\nreturn vec2(c.x+r, c.y);\n}\n\nvec2 func(in vec2 xy)\n{\n    float omega = 0.4;\n    vec2 s = vec2(xy.y,xy.x) - vec2(0.50,0.450);\n    float pole1 = 10.00 * cos(omega * iTime);\n    float pole2 = 5.0 * sin(omega * iTime);\n    vec2 preret = c_div(vec2(1,0), c_mul(c_pow(c_div(s,vec2(0.5,0)),X),c_mul(c_add(s,pole1), c_add(s,pole2))));\n    vec2 ret = preret;\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 complex_val = func(uv);\n    // Time varying pixel color\n    vec3 col;    \n    col = 0.1 + abs(complex_val.x) *vec3(0.0,0.784,0.635) + abs(complex_val.y) * vec3(0.784, 0.635, 0.784);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcXD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 148, 148, 174], [176, 176, 210, 210, 271], [273, 273, 303, 303, 408], [409, 409, 443, 443, 566], [567, 567, 590, 590, 639], [640, 706, 729, 729, 868], [869, 869, 892, 892, 1041], [1042, 1042, 1066, 1066, 1189], [1190, 1190, 1214, 1214, 1337], [1339, 1339, 1371, 1371, 1398], [1400, 1400, 1423, 1423, 1738], [1741, 1741, 1798, 1848, 2136]]}
{"id": "flcyW2", "name": "CubeMap Celtic Weave Comp", "author": "Yusef28", "description": "Celtic weave based on some by fabrice", "tags": ["template"], "likes": 27, "viewed": 474, "published": 3, "date": "1685565114", "time_retrieved": "2024-07-30T17:53:07.170858", "image_code": "/*\nYusef28\n6/8/2022 <- that's day, month, year so it's in August.\nIt's just a shorthand to save me from typing \nThe 6th of August 2022. Much shorter to just say 6/8/2022.\n\nRaymarching template for people who are\ntrying to live their lives or something.\n\n*/\n#define FAR 100.\n#define eps 10./iResolution.y\n#define R iResolution\n#define F fragCoord\n#define S smoothstep\n#define T iTime\n#define PI acos(-1.)\n#define TAU PI*2.\n#define M (iMouse.xy*2.-R.xy)/R.y\n#define Mz iMouse.z\n#define E 2./R.y\n#define ROT(a) mat2(cos(a + vec4(0,11,33,0)))\n#define F5(u) (fract((u))-0.5)\n#define aFract(u) abs(fract((u))-0.5)\n\n#define L(p,u) length(u-p)//max(abs(u.x-p.x),abs(u.y-p.y))//\n#define SOLID(shape,r) S(r+E,r-E,shape)\n\n//r=radius, t = thickness,  E=epsilon  //add t to shift to edge\n#define OUTLINE(shape,r,t) S(t+E,t-E,abs(shape-r+t))\n//double outline for ends of a shape\n    //  r = radius, ot = outline thickness\n    //  rt = orig ring thickness                      \n    //add rt to shift corrent\n    //subtract  (rt-ot) to sprad correct\n#define DOUTLINE(shape,r,ot,rt) S(ot+E*2.,ot-E*2.,abs(abs(shape-r+rt)-(rt-ot)))\n\n//r=radius, t = thickness, b = blur   //add t to shift to edge\n#define OLS(shape,r,t,b) S(t*1.25+b,t*1.25-b,abs(shape-r+t))\n#define OUTSHADOW(shape,r,l) S(r+l,r,shape)\n#define INSHADOW(shape,r,t,l) S(r+E,r-E,shape)*S(t+E,t-E-l,abs(shape-r+t/4.))\n#define GLOW(shape,r,t,l) S(t+E,t-E-l,abs(shape-r+t/4.))\n\n#define CKR(u) mod(floor((u).x)+mod(floor((u).y)+1.,2.),2.)\n#define CKRF(u) max(aFract(u).x,aFract(u).y)\n#define CKRO(u) S(0.47,0.48,max(aFract(u).x,aFract(u).y))\n\n#define TX0(u) texture(iChannel0,u).rgb\n#define TX1(u) texture(iChannel1,u).rgb\n#define TX2(u) texture(iChannel2,u).rgb\n#define TX3(u) texture(iChannel3,u).rgb\n\n#define WHITE vec3(1.,1.,1.)\n#define BLACK vec3(0.,0.,0.)\n#define GREY1 vec3(0.1,0.1,0.1)\n#define GREY3 vec3(0.3,0.3,0.3) \n#define GREY5 vec3(0.5,0.5,0.5)\n#define GREY7 vec3(0.7,0.7,0.7)\n#define GREY9 vec3(0.9,0.9,0.9) \n\n#define RED vec3(0.5,0.2,0.)\n#define GOLD vec3(0.9,0.5,0.3)\n#define BLUE vec3(0.1,0.4,0.5)\n\nfloat vig(vec2 uv){\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 200.0;\n    return pow(vig, 1.); \n}\n\nfloat hash(float p)\n{\n\t return fract(sin(p*324.341)*23402.43);\n}\n\nfloat hash21(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\nmat2 rot(float a) {\n    return mat2(cos(a - vec4(0,11,33,0)));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat Gyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    float d = abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n\treturn d;\n}\n\n\nbool checkLogoBoundingBox(vec3 p){\n    \n    return (p.x < -4.5 || p.x > 4.5 || \n            p.y < -3. || p.y > 2. || \n            p.z < -4. || p.z > 4.);\n    \n}\n\n//float objID = 0.;\nfloat map(vec3 p) {\n    float d = length(p)-1.5;//sdBox(p, vec3(1));\n    \n    return d;//skull(p);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat t=0.;\n    \n    for(int i=0; i<100; i++) {\n    \tvec3 p = ro + rd*t;\n        float d = map(p);\n        t += d*0.7;\n        if(t>FAR || abs(d)<0.001) break;\n    }\n    \n    return t;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = map(p) - \n        vec3(\n            map(p-e.xyy), \n            map(p-e.yxy),\n            map(p-e.yyx)\n            );\n    \n    return normalize(n);\n}\n\n\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zoom){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    uu = dot(target,uu) < 0.01 ? vec3(0.,0.,1.) : uu;\n    vec3 right = normalize(cross(uu, fwd));\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zoom;\n    return normalize(rd);\n\n}\n\nvec2 map_from_sphere(vec3 p)\n{\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\nvec3 checkers(vec2 u){\n   // u.x += T*0.1;\n    vec2 st = u;\n    u*=2.;\n    //u.x +=0.14;\n    u = F5(u*2.)*2.;\n    u = u.x*u.y < 0. ? abs(u.yx) : abs(u);\n    u = abs(u)-0.7155;//-0.8;//-0.1\n    u = abs(u)-0.5;//-0.3;//-0.6\n    \n    vec3 col = GREY5*0.35-CKR(st*20.)*0.15-CKRF(st*20.)*0.03;\n    col -= (CKRO(st*20.)*0.82-0.01 );\n    return col;\n    }\n    \nvec3 celtic(vec2 u){\n   // u.x += T*0.1;\n    vec2 st = u;\n    u*=2.;\n    //u.x +=0.14;\n    u = F5(u*2.)*2.;\n    u = u.x*u.y < 0. ? abs(u.yx) : abs(u);\n    u = abs(u)-0.7155;//-0.8;//-0.1\n    u = abs(u)-0.5;//-0.3;//-0.6\n    \n    vec3 col = GREY5*0.35-CKR(st*20.)*0.15-CKRF(st*20.)*0.03;\n    col -= (CKRO(st*20.)*0.82-0.01 );\n    float radius = 0.959;\n    float thick = 0.08;\n    float othick = 0.01;\n    float bthick = 0.013;\n    float blur = 0.06;\n    vec3 REDNEW = pow(RED*TX1(st*4.),vec3(1.4))*2.;\n    \n    col = mix(col,BLACK,OLS(L(vec2(0.5,-0.5),u),radius,thick,blur));\n    col = mix(col,REDNEW,OUTLINE(L(vec2(0.5,-0.5),u),radius,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,-0.5),u),radius,bthick,thick));\n    col = mix(col,GOLD*(0.1+TX0(st*2.)),DOUTLINE(L(vec2(0.5,-0.5),u),radius,othick,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,-0.5),u),radius,bthick*0.2,thick));\n   \n   \n    col = mix(col,BLACK,OLS(L(vec2(0.5,0.5),u),radius,thick,blur));\n    col = mix(col,REDNEW,OUTLINE(L(vec2(0.5,0.5),u),radius,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,0.5),u),radius,bthick,thick));\n    col = mix(col,GOLD*(0.1+TX0(st*2.)),DOUTLINE(L(vec2(0.5,0.5),u),radius,othick,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(0.5,0.5),u),radius,bthick*0.2,thick));\n    \n    col = mix(col,BLACK,OLS(L(vec2(-0.5,0.5),u),radius,thick,blur));\n    col = mix(col,REDNEW,OUTLINE(L(vec2(-0.5,0.5),u),radius,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(-0.5,0.5),u),radius,bthick,thick));\n    col = mix(col,GOLD*(0.1+TX0(st*2.)),DOUTLINE(L(vec2(-0.5,0.5),u),radius,othick,thick));\n    col = mix(col,BLACK,DOUTLINE(L(vec2(-0.5,0.5),u),radius,bthick*0.2,thick));\n    \n    return col;\n}\n\nvec3 triplanar(vec3 p, vec3 n){\n    n = abs(n);\n    return mix(mix(celtic(p.yz),celtic(p.xy),n.z),celtic(p.xz),n.y);\n}\n\n// returns cubemap coordinates (FROM BIGWINGS)\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n\n    // iq version, no trig, short and sweet\n   st.xy *= 3.0/(2.0+abs(st.xy));\n//st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n    return st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 4, -1);\n    vec3 light = normalize(vec3(-1.,2.,1.));\n    vec3 light2 = normalize(vec3(1.,2.,-1.));\n  //  light = normalize(vec3(-1.,4.,1.));\n  //  ro.yz *= rot(-m.y*PI+1.+iTime);\n    //ro.xz *= rot(-m.x*TAU);\n   // light.yz *= rot(-m.y*PI+1.);\n   // light.xz *= rot(-m.x*TAU);\n    \n    vec3 rd = camRay(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = celtic(uv.xy+iTime*0.05)*vig((F.xy/R.xy))*vec3(0.7,0.5,0.3)*0.2;\n    col = mix(col,BLACK,smoothstep(0.,0.3,(1.-length(uv+vec2(-0.09,0.1))-0.5))*0.8);\n    float t = RayMarch(ro, rd);\n\n    if(t<FAR) {\n        vec3 p = ro + rd * t;\n        \n        \n        vec3 n = GetNormal(p);\n        \n        \n        \n        float ld = length(light-p);\n        float ld2 = length(light2-p);\n        \n        p.yz *= rot(-m.y*PI+1.+iTime*0.2);\n        p.xz *= rot(-m.x*TAU+iTime*0.2);\n        \n        vec3 cubeCoords = WorldToCube(p);\n        /*\n        vec3 CXA = WorldToCube(p) + vec3(0.,E,0.);\n        vec3 CXB = WorldToCube(p) + vec3(0.,-E,0.);\n        vec3 CYA = WorldToCube(p) + vec3(E,0.,0.);\n        vec3 CYB = WorldToCube(p) + vec3(-E,0.,0.);\n        vec3 bump = vec3(CXB-CXA,CYB-CYA,0.);*/\n        \n        float attn = 1./(0.3+ld*0.2+ld*ld);\n        float diff = max(0.,dot(n,light))*0.8+0.05;\n        float spec = pow(max(0.,dot(\n                     reflect(n,-light\n                     ),rd)),100.);\n         \n        \n        float attn2 = 1./(0.3+ld2*0.2+ld2*ld2);\n        float diff2 = max(0.,dot(n,light2))*0.8+0.05;\n        float spec2 = pow(max(0.,dot(\n                     reflect(n,-light2\n                     ),rd)),100.);\n                     \n        float ref = TX2(-reflect(n,rd)).x;   \n        vec3 tp_tex = triplanar(p*0.5,n);\n        vec3 sc_tex = celtic(map_from_sphere(p));\n        \n        vec3 cc_text = celtic((cubeCoords.xy*0.5+cubeCoords.z));//TX0(map_from_sphere(p)*3.);\n      //  col = mix(sc_tex,tp_tex,abs(n.z)) * diff;\n        vec3 col1 = 1.4*clamp(cc_text,0.,1.)*diff*1.6*attn + ref*0.0*diff*BLUE +  BLUE*spec*.08;\n        vec3 col2 = 1.4*clamp(cc_text,0.,1.)*diff2*1.6*attn2*RED + ref*0.0*diff2 +  RED*spec2*.08;\n        col = (col1+col2);\n    \n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat knochen(vec3 p, vec3 xyz, vec3 dim, float th, float phi, float ga, \n                float spiegel, float r){\n    \n    vec3 sp = p - xyz;\n    sp.x = abs(sp.x) - spiegel;\n    \n    float cs = cos(th), si = sin(th);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    cs = cos(phi), si = sin(phi);\n    sp.xz*= mat2(cs, si, -si, cs);\n    \n    cs = cos(ga), si = sin(ga);\n    sp.xy*= mat2(cs, si, -si, cs);\n        \n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - r;    \n}\nfloat sdCircleCircle( in vec3 p, in int n, float zeichen){\nfloat a0 = float(n) / radians(360.); \nfloat a = round(atan(p.z, p.x) * a0) / a0;\nvec3 sp = p - vec3(cos(a), 0.0, sin(a));\n  \nfloat cs = cos(a), si = sin(a);//erste versuch!!!!\nsp.xz*=mat2(cs, si, -si, cs);\n  \ncs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!\nsp.xy*=mat2(cs, si, -si, cs);\n    \nsp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, 0.19, 0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen);\nreturn min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.03;  \n\n    \n    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; \n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\nfloat skull(vec3 p){\n    vec3 altp = p;\n    p.x+=1.;\n    p.x = mod(p.x, 2.) - 1.;\n    \n    float PosX, PosY;\n   // PosX = 0. + sin(iTime*20.)/4.;// - (iMouse.x)/iResolution.x;//0.2*2.*(rechts - links);\n  //  PosY = -0.1 + sin(iTime*2.)/4.;;//(iMouse.y)/iResolution.y*4.;\n    \n    //zufall \n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    if (altp.x > 0.75 || altp.x < -0.75){\n    p.xz = mat2(cs, si, -si, cs)*p.xz;}\n    else{\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;}\n    \n    //guckmal\n    float gu = -1.6;\n    cs = cos(gu), si = sin(gu);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    \n    \n\tp*=0.6;\n    p.y-=0.2;// + sin(iTime)*0.1;\n    \n\n    \n    vec3 sp = p - vec3(0., 0., 0.03);\n    float k = length(sp*vec3(1.-sin(sp.z*6.-0.4)*0.05, \n                             0.95+sin(sp.z*6.+1.6)*0.05, \n                             0.87)) - 0.5;\n    float alle = k;\n    \n    //schadel unten schneiden\n    sp = p;\n    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;\n    alle = smax(alle, -k, 0.09);\n    \n    ///return alle;\n    \n    //schadel seite\n    sp = p  - vec3(0., -0.05, -0.28);\n    sp.x = abs(sp.x) - 0.65;\n    //length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.87))\n    k = length(sp) - 0.3;\n    //k = length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.6)) - 0.3;\n    //alle = smax(alle, -k, 0.09);\n\n    //schadel seite knochen schneiden versuch\n    sp = p;\n    k = knochen(p, vec3(0., -0.15 , -0.18 ), \n                vec3(0.005, \n                     0.17 + sin(sp.z*4.+2.4)*0.1, \n                     0.2+ sin(sp.y*4.+2.)*0.18), \n                -0.2, -0.4, 0.1, 0.42+ sin(sp.z*4.+2.4)*0.05, 0.03);\n    alle = smax(alle, -k, 0.09);\n    \n    //return alle;\n    \n    //oben augen knochen\n    sp = p;\n    k = knochen(p, vec3(0., \n                        0. + cos(abs(sp.x)*8. + 5.)*0.03*1. - 0.04*1. , \n                        -0.45 - cos(abs(sp.x)*8. + 5.8)*0.05), \n                vec3(0.12, 0.005, 0.005), \n                0., 0., -0., 0.14, 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //return alle;\n\n    \n    //oberest knochen\n    sp = p;\n    k = knochen(p, vec3(0., 0.055 , -0.37 ), vec3(0.005, 0.005, 0.12), \n                -1., -0.25, 0., 0.28, 0.02);\n    alle = smin(alle, k, 0.06);\n    \n    //augen seit knochen\n    sp = p;\n    k = knochen(p, vec3(0., -0.14 , -0.46+ cos(sp.y*8.+1.5)*0.07), \n                vec3(0.01, 0.08, 0.02), \n                0.0, 0.0, 0.35, 0.26+ cos(sp.y*12.+1.2)*0.06, 0.015);\n    alle = smin(alle, k, 0.06);\n    \n\n    \n    \n    //wangen knochen vor\n    sp = p;\n    k = knochen(p, vec3(0., -0.28, -0.42+cos(abs(sp.x)*8.+2.)*0.02), \n                vec3(0.13, 0.055+sin(abs(sp.x)*8.+2.)*0.02, 0.05), \n                -0.5, 0.2, -0.1, 0.12, 0.05);\n    alle = smin(alle, k, 0.09);\n    \n    //return alle;\n    \n    //wangen knochen seit sollte dasselb (gesamt)breit haben wie die augen seit!\n    //wangen knochen seit\n    sp = p;\n    k = knochen(p, vec3(0., -0.3, -0.28), \n                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), \n                0., 0.1, 0., 0.27 + cos(sp.z*8. + 2.)*0.09, \n                0.03 + cos(sp.z*8. + 4.7)*0.015);\n    alle = smin(alle, k, 0.02);\n    \n    float keiferHohe = 0.01;\n    //wangen knochen zu keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.51+keiferHohe, -0.25 - cos(abs(sp.y)*12. + 3.)*0.04), \n                vec3(0.005-cos(sp.z*12.+4.5)*0.004 - cos(sp.y*6.+1.2)*0.017, \n                     0.125, \n                     0.1), \n                0.2+(-sp.y-0.5)*0.2, -0.35, -0.25, \n                0.29 , 0.01); //keifer ein bisschen mehr eng war hilfreich\n    float keifer = k;\n    \n    \n    \n    \n    //keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.67+keiferHohe, -0.35), vec3(0.005, 0.02, 0.16), \n                -0.3, -0.5, 0., 0.18+cos(sp.z*8.+3.14)*0.02, 0.045);\n    keifer = smin(keifer, k, 0.04);\n    \n    //wkk schneid\n    sp = p;\n    k = knochen(p, vec3(0., -0.58+keiferHohe, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), \n                vec3(0.001, 0.15, 0.055), \n                0.2+(-sp.y-0.5)*0.2, -0.45, -0.3, 0.34, 0.01);\n    keifer = smax(keifer, -k, 0.04);\n    \n    //wkk loch\n    sp = p;\n    sp.x = abs(sp.x) - 0.31;\n    k = length(sp - vec3(0., -0.38+keiferHohe, -0.23)) - 0.06;\n    keifer = smax(keifer, -k, 0.04);\n    \n    \n    //kinn\n    sp = p;\n    k = knochen(p, vec3(0., -0.73+keiferHohe, -0.45-cos(sp.x*8.)*0.1), vec3(0.09, 0.02, 0.015), \n                0., 0., 0., 0., 0.03);\n    keifer = smin(keifer, k, 0.09);\n    \n\n    //sollte siemlich schaf sein\n    //augen loche\n    sp = p;\n    sp.x = abs(sp.x) - 0.172;\n    k = length(sp - vec3(0., -0.14, -0.48)) - 0.084;\n    alle = smax(alle, -k, 0.075);\n    \n    //nase\n    sp = p;\n    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), \n                -0.3, 0., 0.3, 0., 0.039);\n    alle = smin(alle, k, 0.06);\n    \n    //nase scheiden\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), \n                -0.35, 0., 0.3, 0., 0.03);\n    alle = smax(alle, -k, 0.04);\n    \n    //nase linie\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), \n                -0.35, 0., 0., 0., 0.005);\n    alle = smin(alle, k, 0.03);\n    \n    \n    float zahnNum = 12.;\n    float th = 0.15;\n    sp = p;\n    cs = cos(th), si = sin(th);\n    \n    sp = sp - vec3(0., -0.43, -0.4);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    //cyl oben\n    \n    k = sdCappedCylinder(sp, 0.17 //nicht so breit\n                         + cos(sp.y*12. -5.)*0.015\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.005\n                         , 0.045 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02\n                        - cos(sp.z*6.-1.75)*0.05\n                        );\n    alle = smin(alle, k, 0.06); //weniger smooth weil die echte schadel\n    \n    \n    //return alle;\n    \n    //cyl unten\n    sp = p - vec3(0., -0.65+keiferHohe, -0.42);\n    k = sdCappedCylinder(sp, 0.15\n                         + cos(sp.y*12. - 1.5)*0.03\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.05 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);\n    keifer = smin(keifer, k, 0.06);\n    \n    \n    \n    \n  \n    //oben zhan\n    sp = p - vec3(0.0, -0.51, -0.41);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    k = sdCircleCircle(sp*6.6, 24, 1.); //nicht so breit\n    float zahn = k;\n    \n    //unten zahn\n    sp = p - vec3(0.0, -0.58+keiferHohe, -0.39);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    \n    k = sdCircleCircle(sp*6.6, 24, -1.);//nicht so breit\n    zahn = min(zahn, k);\n    \n    objID = vec4(zahn-0.05, alle, keifer, 0);\n    alle = smin(zahn,alle, 0.09);\n    alle = smin(alle, keifer, 0.09);\n    \n    //cyl schneiden\n    sp = p - vec3(0., -0.58, -0.15);\n    k = sdCappedCylinder(sp, 0.17, 0.24);\n    alle = smax(alle, -k, 0.06);\n    \n    //schonheit\n    sp = p;\n    sp.x = abs(sp.x) - 0.18;\n    k = length(sp - vec3(0., -0.32, -0.522)) - 0.012;\n    alle = smax(alle, -k, 0.01);\n    \n    return alle;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2057, 2057, 2076, 2076, 2163], [2165, 2165, 2186, 2186, 2229], [2231, 2231, 2253, 2253, 2315], [2317, 2317, 2336, 2336, 2381], [2383, 2383, 2412, 2412, 2493], [2495, 2495, 2559, 2559, 2653], [2656, 2656, 2690, 2690, 2816], [2818, 2838, 2857, 2857, 2938], [2940, 2940, 2974, 2974, 3162], [3164, 3164, 3188, 3188, 3378], [3381, 3381, 3435, 3435, 3714], [3716, 3716, 3746, 3746, 3833], [3835, 3835, 3857, 3877, 4183], [4189, 4189, 4209, 4229, 5883], [5885, 5885, 5916, 5916, 6003], [6005, 6123, 6149, 6149, 6567], [6570, 6570, 6627, 6627, 8951]]}
{"id": "ctcXRj", "name": "Cheap wave based noise", "author": "afl_ext", "description": "Cheap noise I put together from waves shaders to make it usable for other purposes.\nDrag your mouse to change parameters!\nInterestingly with mouse to the left top it looks like kind of voronoi or like light refractions, and with bottom right liike smoke", "tags": ["noise", "wave", "sin", "cos"], "likes": 8, "viewed": 262, "published": 3, "date": "1685554511", "time_retrieved": "2024-07-30T17:53:08.038538", "image_code": "// afl_ext 2023\n\nvec3 getwaves_directions[] = vec3[](\n  vec3(0.7900, 0.5533, -0.2640),\n  vec3(-0.9075, 0.1099, 0.4055),\n  vec3(0.7029, -0.5427, 0.4598),\n  vec3(-0.1990, -0.7706, -0.6054),\n  vec3(-0.8966, 0.2679, -0.3526),\n  vec3(-0.1806, 0.4303, -0.8844),\n  vec3(-0.0061, 0.8324, -0.5542),\n  vec3(0.5143, -0.6805, 0.5219),\n  vec3(-0.5450, 0.7928, 0.2727),\n  vec3(0.5874, -0.7927, -0.1632),\n  vec3(0.4356, -0.1174, 0.8925),\n  vec3(-0.2174, 0.1649, -0.9621),\n  vec3(-0.5134, -0.0137, -0.8581),\n  vec3(-0.3361, -0.1214, 0.9340),\n  vec3(0.6320, -0.4675, -0.6181),\n  vec3(0.2561, 0.1685, -0.9519),\n  vec3(0.7354, 0.6738, 0.0716),\n  vec3(-0.0798, 0.9033, -0.4215),\n  vec3(-0.1344, -0.6286, -0.7660),\n  vec3(0.4724, 0.6836, 0.5564),\n  vec3(-0.5242, -0.6188, 0.5851),\n  vec3(0.0763, 0.0929, -0.9927),\n  vec3(-0.9852, -0.1562, -0.0712),\n  vec3(-0.2936, -0.7704, 0.5660),\n  vec3(-0.4166, -0.7558, 0.5051),\n  vec3(0.5641, -0.1422, 0.8134),\n  vec3(-0.1560, 0.3815, -0.9111)\n);\n\nfloat getwaves(vec3 position, float dragmult){\n    int iters = getwaves_directions.length();\n    float result = 0.0;\n    for(int i=0;i<iters;i++){\n        float x = dot(getwaves_directions[i], position);\n      \n        float wave = exp(sin(x) - 1.0);\n        float dx = wave * cos(x);\n      \n        result += wave;\n        position += getwaves_directions[i] * dx * dragmult;\n    }\n    return result / float(iters);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float mouseModifierX = iMouse.x / iResolution.x;\n    float mouseModifierY = -iMouse.y / iResolution.y;\n    float value = getwaves(vec3(uv.x, uv.y, iTime * 0.1) * 100.0, mouseModifierX + mouseModifierY);\n    fragColor = vec4(vec3(value), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcXRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[966, 966, 1012, 1012, 1383], [1385, 1385, 1442, 1442, 1730]]}
{"id": "Dt3SRj", "name": "shape in grid illusion", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/AkiyoshiKitaoka/status/1663855123465138176\nbetter seen around resolution 800 x 450", "tags": ["2d", "illusion", "perception", "short", "reproduction"], "likes": 26, "viewed": 396, "published": 3, "date": "1685552637", "time_retrieved": "2024-07-30T17:53:08.913200", "image_code": "#define S(v)    smoothstep( 10./R.y, 0., v )                   // AA draw\n#define d(p)  ( p.y -= 3., h = abs(atan(p.x,p.y)/3.14),                \\\n                length(p)/10.5 - h*(13. - 22.*h + 10.*h*h)/(6.-5.*h) )// shape: heart from iq https://www.shadertoy.com/view/XsfGRn\n//#define d(p)  length(p) - 6.                                        // shape: disc\n#define L(F)    S( abs(F.y) - .005 ) * sign(F.x) * s                  // BW line \n\nvoid mainImage( out vec4 O, vec2 u )\n{   float h, s,v;\n    vec2  R = iResolution.xy,\n          U = 8. * ( 2.*u - R ) / R.y,                    \n          I = floor(U),                           // cell Id\n          F = fract(U)-.5,                        // cell coords\n          G = F + vec2(-F.y,F) * sign(d(U)),      // diamond frame ( tilted in shape )\n          D = S(abs(G)-.2);                       // diamond mask\n          s = mod(I.x+I.y,2.)*2.-1.,              // checkered sign\n          v = mix( L(F) + L(F.yx),                // horizontal & vertical lines\n                   sign(G.y)*s, D.x*D.y );        // diamonds\n    O = vec4(sqrt(.5+.5*v));                      // to [0,1] and to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3SRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 447, 485, 485, 1156]]}
{"id": "dlcXWM", "name": "Some cool circles", "author": "Strasko", "description": "Some pretty cool circles", "tags": ["animationcircle"], "likes": 4, "viewed": 205, "published": 3, "date": "1685545955", "time_retrieved": "2024-07-30T17:53:09.813791", "image_code": "vec3 pallette(float t){\n    vec3 a = vec3(0.238, 0.028, 0.828);\n    vec3 b = vec3(-1.385, 0.720, 0.720);\n    vec3 c = vec3(-2.372, 1.110, 1.110);\n    vec3 d = vec3(1.758, -0.422, 1.388);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 colorVariation(float timeScale, vec2 uv){\n    float r = clamp(sin(iTime * timeScale) * 6.28318, 0.0, 0.1);\n    float b = clamp(cos(iTime * timeScale) * 6.28318, 0.0, 0.1);\n    \n    return vec3(sin(r * uv * timeScale), sin(b * uv.y * uv.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float strength = 8.;\n    float timeScale = 0.3;\n    float iterations = 2.0;\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < iterations; i++){\n        uv = fract(uv * 2.0) - 0.5;\n    \n    float d = length(uv - vec2(0.0, tan(iTime * timeScale))) * exp(-length(uv0));\n    vec3 col = clamp(pallette(length(uv0) - iTime * timeScale) * abs(tan(iTime * timeScale)), 0.0, 1.0);\n    \n    d = sin(d * strength + iTime) / strength;\n    d = abs(d);\n    \n    d = 0.01 / d;\n\n    finalColor += col * d + colorVariation(timeScale, uv0);\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcXWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 235], [237, 237, 283, 283, 484], [486, 486, 543, 543, 1219]]}
{"id": "dltSRS", "name": "Arbitrary Menger", "author": "lightningund", "description": "Generates a menger rug pattern for any window size", "tags": ["menger"], "likes": 1, "viewed": 207, "published": 3, "date": "1685542278", "time_retrieved": "2024-07-30T17:53:10.664517", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tint intx = int(fragCoord.x);\n\tint inty = int(fragCoord.y);\n\twhile (intx > 0 && inty > 0) {\n\t\tint xmod = intx % 3;\n\t\tint ymod = inty % 3;\n\n\t\tif (xmod == 1 && ymod == 1) {\n\t\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\t\treturn;\n\t\t}\n\n\t\tintx /= 3;\n\t\tinty /= 3;\n\t}\n\n\t// Output to screen\n\tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltSRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 377]]}
{"id": "DtdSzB", "name": "wavy lines turn thing", "author": "Georg", "description": "some line pattern changing over time. first frag shader idea that i did finish. looks cool but not as mezmorising as i hoped.", "tags": ["line"], "likes": 4, "viewed": 155, "published": 3, "date": "1685540808", "time_retrieved": "2024-07-30T17:53:11.605002", "image_code": "// Author:\n// Title:\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define P 0.003 * GRID\n#define GRID 16.0\n#define PI 3.14159265359 \n#define u_time iTime\n#define u_resolution iResolution\n\nvec2 rotate(vec2 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    return rotationMatrix * v;\n}\n\nvec2 gridi(vec2 st){\n    return floor(st * GRID);\n}\n\nvec2 gridf(vec2 st){\n    return fract(st * GRID);\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat random(float x) {\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n\n    float a = random(i);\n    float b = random(i + 1.0);\n\n    // Smooth interpolation\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u);\n}\n\nfloat f2(float x){\n    return noise(x/32.)*2.+noise(x/16.)+ x/128.;\n}\n\nfloat f3(float x){\n    return floor(f2(floor(x)));\n}\n\nfloat f4(float x){\n    return smoothstep(0.,1.,fract(x));\n}\n\nfloat f5(float x){\n    return f3(x)*(1.-f4(x))+f3(x+1.)*f4(x);\n}\n\nfloat circle(vec2 st, float r, float t){\n    float d = length(st);\n    d = smoothstep(r - t - P, r - t, d) - smoothstep(r + t, r + t + P, d) ;\n    \n    return d;\n}\n\nfloat rotate_noise(float x){\n    return f5(x) * PI/2.0;\n}\n\nfloat pattern(vec2 st, float t){\n    st -= vec2(0.5, 0.5);\n    st = rotate(st, rotate_noise(t));\n    st += vec2(0.5, 0.5);\n    float c = (circle(1.0 - st, 0.5, 0.062) + circle(st, 0.5, 0.062)) * circle(st-0.5, 0.25, 0.25);\n    float r = 1. - c;\n    \n    c = 1.0 - circle(st-0.5, 0.25, 0.25);\n    //r -= c * 0.75;\n    \n    \n    \n    return r;\n}\n\nfloat pattern(vec2 st){\n    vec2 gdi = gridi(st);\n    vec2 gdf = gridf(st);\n    \n    return pattern(gdf, (random(gdi) + 1.0) * 128.0 * 128.0 + u_time * 1.2 + random(gdi));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.);\n    \n    color = vec3(pattern(st));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdSzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 224, 224, 354], [356, 356, 376, 376, 407], [409, 409, 429, 429, 460], [462, 462, 485, 485, 558], [560, 560, 583, 583, 624], [626, 626, 648, 648, 848], [850, 850, 868, 868, 919], [921, 921, 939, 939, 973], [975, 975, 993, 993, 1034], [1036, 1036, 1054, 1054, 1100], [1102, 1102, 1142, 1142, 1265], [1267, 1267, 1295, 1295, 1324], [1326, 1326, 1358, 1358, 1669], [1671, 1671, 1694, 1694, 1844], [1846, 1846, 1903, 1903, 2093]]}
{"id": "mldSW7", "name": "Aberration I", "author": "itishappy", "description": "Animated view of simulated interferometric fringes to explore different aberrations.", "tags": ["interferometry", "aberations", "seidel", "zernike"], "likes": 1, "viewed": 126, "published": 3, "date": "1685482722", "time_retrieved": "2024-07-30T17:53:12.419824", "image_code": "// factorial\nint fact(int x) {\n    int prod = 1;\n    for (int i = 2; i <= x; i++) {\n        prod *= i;\n    }\n    return prod;\n}\n\n// radial term\nfloat r(int m, int n, float rho) {\n    if ((n - m) % 2 == 1) return 0.;\n    int avg = (n + m) / 2;\n    int dev = (n - m) / 2;\n    float sum = 0.;\n    for (int k = 0; k <= dev; k++) {\n        int sgn = 1 - 2 * (k % 2);\n        int num = sgn * fact(n - k);\n        int den = fact(k) * fact(avg - k) * fact(dev - k);\n        int cooef = num / den;\n        sum += float(cooef) * pow(rho, float(n - 2 * k));\n    }\n    return sum;\n}\n\n// full zernike polynomial\nfloat zernike(int m, int n, float rho, float theta) {\n    float a;\n    if (m >= 0) {\n        a = cos(float(m) * theta);\n    } else {\n        m *= -1;\n        a = sin(float(m) * theta);\n    }\n    return r(m, n, rho) * a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center and normalize coordinates\n    vec2 uv = 0.8 * (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // polar decomposition\n    float rho = length(uv);\n    float theta = atan(uv.y, uv.x);\n    \n    // computes the height of each point for a given set of aberrations\n    // MAGIC HAPPENS HERE: TRY THESE LINES!\n    // float h = zernike(1, 1, rho, theta) + 0.5 * zernike(-1, 1, rho, theta);\n    // float h = zernike(0, 2, rho, theta) - 1.6 * zernike(-1, 1, rho, theta);\n    float h = zernike(-2, 2, rho, theta) - 0.5 * zernike(0, 4, rho, theta);\n    // float h = zernike(1, 5, rho, theta) + 0.5 * zernike(-1, 1, rho, theta);\n    // float h = 0.4 * zernike(-2, 4, rho, theta) - 0.8 * zernike(-1, 3, rho, theta) + 0.6 * zernike(2, 2, rho, theta);\n    \n    // base color\n    vec3 col = mix(vec3(1.), vec3(0., 0., 1.), h) * mix(vec3(1.), vec3(1., 0., 0.), -h);\n    \n    // aperture and color normalization\n    if (length(uv) > 1.0) {\n        col = vec3(0.);\n    } else {\n        col = clamp(col, vec3(0.), vec3(1.));\n    }\n\n    // fringes\n    col *= pow(sin(3.14159265359 * (2. * h + 0.5 * cos(iTime))), 2.);\n\n    // output\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldSW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 30, 30, 127], [129, 144, 178, 178, 570], [572, 599, 652, 652, 820], [822, 822, 879, 919, 2050]]}
{"id": "dl3XW7", "name": "Fake volumetrics", "author": "ThePlaneGuy45", "description": "depth of field + volumetrics = a cool thing ig", "tags": ["raytracer", "dof", "volumetrics"], "likes": 15, "viewed": 375, "published": 3, "date": "1685475930", "time_retrieved": "2024-07-30T17:53:13.235642", "image_code": "// Pixel Art Shader\n// Feel free to use, just give credit as always\n// - TPG45\n\n#define COLOR_STEP 256.0\n#define PIXEL_SIZE 1.0\n\nvec4 colorize(in vec4 color) {\n\n    // Pixel art coloring\n    vec3 nCol = normalize(color.rgb);\n    float nLen = length(color.rgb);\n    return vec4(nCol * round(nLen * COLOR_STEP) / COLOR_STEP, color.w);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel Sizing\n    float ratio = iResolution.y/720.0;\n    vec2 pixel = round(fragCoord / (PIXEL_SIZE * ratio)) * PIXEL_SIZE * ratio;\n    vec2 uv = pixel/iResolution.xy;\n    fragColor = colorize(texture(iChannel0, uv));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void distances(inout Record rec) {\n\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 0, 10.0, 0.42, 0.75), vec3(200.0, 0.0, 0.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 1, 40.0, 0.42, 0.40), vec3(0.0, 0.0, 200.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 2, 10.0, 0.42, 0.80), vec3(-200.0, 0.0, 0.0), 100.0), rec);\n    raySphere(Sphere(Material(vec3(0.0, 0.5, 1.0), true, 3, 10.0, 0.42, 0.60), vec3(0.0, 0.0, -200.0), 100.0), rec);\n\n}\n\nvoid initRay(inout Ray ray, in vec2 fragCoord) {\n\n    ray.origin = vec3(0.0, 0.0, -500.0);\n    ray.normal = normalize(vec3(fragCoord, 500.0));\n    mat2 rot = rot2((iMouse.y / iResolution.y - 0.5) * 8.0);\n    ray.origin.yz *= rot;\n    ray.normal.yz *= rot;\n    rot = rot2((iMouse.x / iResolution.y - 0.5) * 8.0);\n    ray.origin.xz *= rot;\n    ray.normal.xz *= rot;\n\n}\n\nvoid initRecord(inout Record rec) {\n\n    rec.hit = false;\n    rec.dist = 100000.0;\n\n}\n\nvec4 triPlanar(sampler2D tex, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    vec3 blend = normalize(max(abs(normal), 0.000001));\n    float sum = blend.x + blend.y + blend.z;\n    blend /= sum;\n    vec4 x = texture(tex, offset.yz * scale + imgOffset);\n    vec4 y = texture(tex, offset.xz * scale + imgOffset);\n    vec4 z = texture(tex, offset.xy * scale + imgOffset);\n    return x * blend.x + y * blend.y + z * blend.z;\n\n}\n\nvec4 texturize(int id, vec3 offset, vec3 normal, float scale, vec2 imgOffset) {\n\n    switch(id) {\n    case 0:\n        return triPlanar(iChannel0, offset, normal, scale, imgOffset);\n    case 1:\n        return triPlanar(iChannel1, offset, normal, scale, imgOffset);\n    case 2:\n        return triPlanar(iChannel2, offset, normal, scale, imgOffset);\n    case 3:\n        return triPlanar(iChannel3, offset, normal, scale, imgOffset);\n    }\n    return vec4(0.0);\n\n}\n\nfloat getHeight(vec4 tex) {\n\n    return dot(tex.rgb, vec3(.2126, .7152, .0722));\n\n}\n\nvec3 normal(int id, vec3 offset, vec3 normal, float scale, vec2 res, float strength) {\n\n    float current = getHeight(texturize(id, offset, normal, scale, vec2(0.0)));\n    float x = (getHeight(texturize(id, offset, normal, scale, vec2(1.0 / res.x, 0.0))) - current) * strength;\n    float y = (getHeight(texturize(id, offset, normal, scale, vec2(0.0, 1.0 / res.y))) - current) * strength;\n    return normalize(vec3(x, y, 1.0));\n\n}\n\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nvec4 Trace(in vec2 fragCoord, vec3 iChannelResolution[4], float iTime) {\n\n    Ray ray;\n    Record rec;\n    initRay(ray, fragCoord);\n    initRecord(rec);\n    rec.ray = ray;\n    distances(rec);\n    bool hit = false;\n    float hdist = 1024.0;\n    vec3 result = vec3(0.0);\n    if(rec.hit) {\n        vec3 matColor;\n        vec3 nMap;\n        if(rec.material.useTexture) {\n            matColor = texturize(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, vec2(0.0)).xyz;\n            nMap = normal(rec.material.texID, rec.offset, rec.normal, rec.material.texScale, iChannelResolution[3].xy, rec.material.bumpStrength);\n            rec.normal = worldSpace(nMap, rec.tangent, rec.bitangent, rec.normal);\n        } else {\n            matColor = rec.material.color;\n        }\n        vec2 mPos = vec2(0);\n        vec3 lightNormal = normalize((vec3(mPos.x, 400.0, mPos.y)) - rec.intersect);\n        float shade = clamp(dot(lightNormal, rec.normal), 0.0, 1.0);\n        float specang = acos(shade);\n        float specexp = specang / (1.0-rec.material.specular);\n        float spec = exp(-specexp * specexp) * rec.material.specular;\n        result = matColor * mix(vec3(0.2), vec3(1.0), shade) + vec3(spec);\n        hit = true;\n        hdist = rec.dist;\n    }\n    vec3 p = ray.origin;\n    vec3 light;\n    float dist;\n    for(float i; i < hdist; i+=STEP) {\n    \n        light = vec3(0.0, 400.0, 0.0) - p;\n        rec.ray.normal = normalize(light);\n        rec.ray.origin = p + rec.ray.normal;\n        dist = length(light);\n        initRecord(rec);\n        distances(rec);\n        if(!(rec.dist < dist)) {\n        \n            result = mix(result, vec3(1.0, 0.95, 0.8), (DENSITY * STEP/16.0) / dist);\n            \n        }\n        \n        p += ray.normal * STEP;\n    \n    }\n    \n    return vec4(result, hit ? hdist : 200.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / 720.0;\n    fragColor = Trace((fragCoord-(iResolution.xy)/2.0)/ratio, iChannelResolution, iTime);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BUMPSTRENGTH 10.0\n\n#define DENSITY 2.0\n#define DOF 5.0\n#define STEP 16.0\n\nstruct Material {\n\n    vec3 color;\n    bool useTexture;\n    int texID;\n    float bumpStrength;\n    float texScale;\n    float specular;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\nuint raySphere(in Sphere sph, inout Record rec) {\n\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    \n    if (disc > 0.0) {\n    \n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        \n        if(dstNear < rec.dist) {\n        \n            if(dstNear > 0.0) {\n        \n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.offset = (rec.intersect - sph.center - sph.radius) / sph.radius - 0.5;\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                \n                return uint(0x1);\n        \n            }\n        \n        }\n        \n        return uint(0x0);\n    \n    }\n\n}", "buffer_b_code": "vec4 tex(vec2 p,vec2 offset){return texelFetch(iChannel0,ivec2(p+offset),0);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 current = tex(fragCoord, vec2(0.0));\n    float depth = current.w;\n    float blur = DOF * depth / 200.0;\n    vec4 color;\n    for(float r; r < 6.28318530718; r += 0.1) {\n    \n        for(float d; d < blur; d += blur/5.0) {\n        \n            color += vec4(tex(fragCoord, vec2(cos(r), sin(r)) * d).xyz, 1.0);\n        \n        }\n    \n    }\n    \n    color.rgb /= color.a;\n    fragColor = vec4(color.rgb, 1.0);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3XW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 159, 186, 335], [337, 337, 394, 414, 620]]}
{"id": "dtcXDM", "name": "Vector Field Viewer", "author": "me_123", "description": "A simple vector field display", "tags": ["2d", "visualization", "vector", "vectorfield"], "likes": 15, "viewed": 299, "published": 3, "date": "1685462099", "time_retrieved": "2024-07-30T17:53:14.073403", "image_code": "const float scale = 40.0;\nconst float colorScale = 0.6;\nconst vec2 viewport = vec2(0,0);\n#define GRID 1\n\nvec2 VectorField(in vec2 p) {\n    return vec2(sin(p.y + iTime), sin(p.x + iTime));\n}\n\n\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat line(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\nfloat arrow(in vec2 p) {\n    return min(line(p, 0.6)-0.05, 0.25*sdIsosceles((p-vec2(0, 0.6))*4.0, 1.0, 1.5));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragCoord -= iResolution.xy*0.5;\n    fragCoord -= viewport*scale;\n    #if GRID\n    vec2 gridPos = abs((fract((0.5+fragCoord)/(scale)))-0.5);\n    float grid = 0.25*max((max(gridPos.x, gridPos.y)*scale - scale*0.5+1.0), 0.0);\n    gridPos = abs((fract((0.5+fragCoord)/scale*0.5))-0.5);\n    grid += 0.75*max((max(gridPos.x, gridPos.y)*scale*2.0 - scale+1.0), 0.0);\n    fragColor.xyz = vec3(grid)*vec3(0.3, 0.3, 1.0);\n    float axis = max(max(1.-abs(fragCoord.x+0.5), 1.-abs(fragCoord.y+0.5)), 0.0);\n    fragColor = 0.5*mix(fragColor, vec4(1), axis);\n    #endif\n    vec4 celll = vec4(floor(fragCoord/scale), fract(fragCoord/scale));\n    float d = 1000.;\n    vec3 color = vec3(0);\n    for (int x = -1; x <= 0; x += 1) {\n        for (int y = -1; y <= 0; y += 1) {\n            vec4 cell = vec4(celll.xy-vec2(x, y), celll.zw+vec2(x, y));\n            vec2 v = VectorField(cell.xy);\n            if (!(isnan(v.x) || isnan(v.y))) {\n                vec2 d = normalize(v);\n                float ss = length(v);\n                float s = 0.5*(ss+1.0)/ss;\n                float dd = arrow((cell.zw*2.0)*mat2(d.y, -d.x,d)*s)*scale/(s*2.0);\n                color = mix(color, mix(vec3(0, 1, 0), vec3(1, 0, 0), ss*colorScale), 1.-clamp(dd, 0.0, 1.0));\n                d = min(d, dd);\n            }\n        }\n    }\n    fragColor.xyz += color;//vec4(1.-clamp(d, 0.0, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcXDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 134, 134, 189], [193, 193, 247, 247, 523], [525, 525, 560, 560, 628], [629, 629, 653, 653, 740], [741, 741, 796, 796, 2154]]}
{"id": "dldXR7", "name": "Smooth Mouse Drawing", "author": "fad", "description": "A recreation of https://lazybrush.dulnan.net/\n\nControls:\n- Mouse to draw\n- L: toggle between quadratic bezier curves and line segments\n- S: toggle SDF visualisation\n- P: toggle mouse points\n\nSettings in Buffer B", "tags": ["mouse", "sdf", "bezier", "draw", "quadratic", "brush", "lazy"], "likes": 56, "viewed": 1321, "published": 3, "date": "1685458595", "time_retrieved": "2024-07-30T17:53:14.827386", "image_code": "// A recreation of https://lazybrush.dulnan.net/\n\n// Controls:\n// - Mouse to draw\n// - L: toggle between quadratic bezier curves and line segments\n// - S: toggle SDF visualisation\n// - P: toggle mouse points\n\n// Settings in Buffer B\n\n// Modified sdBezier() function originally from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n\n#define LINE_WIDTH (iResolution.y * 0.01)\n#define POINT_RADIUS (iResolution.y * 0.007)\n\nconst int KEY_L = 76;\nconst int KEY_S = 83;\nconst int KEY_P = 80;\n\nbool keyToggled(int keyCode) {\n    return texelFetch(iChannel1, ivec2(keyCode, 2), 0).r > 0.0;\n}\n\nvec4 blendOver(vec4 front, vec4 back) {\n    float a = front.a + back.a * (1.0 - front.a);\n    return a > 0.0\n        ? vec4((front.rgb * front.a + back.rgb * back.a * (1.0 - front.a)) / a , a)\n        : vec4(0.0);\n}\n\nvoid blendInto(inout vec4 dst, vec4 src) {\n    dst = blendOver(src, dst);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = vec4(1.0);\n\n    float qd = texture(iChannel0, fragCoord / iResolution.xy).x;\n    float ld = texture(iChannel0, fragCoord / iResolution.xy).y;\n    float pd = texture(iChannel0, fragCoord / iResolution.xy).z;\n    float sd = (keyToggled(KEY_L) ? ld : qd) - LINE_WIDTH / 2.0;\n    \n    blendInto(fragColor, vec4(0.0, 0.0, 0.0, clamp(0.5 - sd, 0.0, 1.0)));\n    \n    if (!keyToggled(KEY_S)) {\n        float spacing = iResolution.y * 0.02;\n        float thickness = max(iResolution.y * 0.002, 1.0);\n        float opacity = clamp(\n            0.5 + 0.5 * thickness - \n            abs(mod(sd - (spacing - thickness) * 0.5, spacing) - spacing * 0.5), \n            0.0, 1.0\n        ) * 0.5 * exp(-sd / iResolution.y * 8.0);\n        blendInto(fragColor, vec4(0.0, 0.0, 0.0, opacity));\n    }\n    \n    if (keyToggled(KEY_P)) {\n        blendInto(fragColor, vec4(1.0, 0.0, 0.0, clamp(POINT_RADIUS - pd + 0.5, 0.0, 1.0)));\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This buffer tracks smoothed mouse positions over multiple frames.\n\n// See https://lazybrush.dulnan.net/ for what these mean:\n#define RADIUS (iResolution.y * 0.015)\n#define FRICTION 0.05\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    if (fragCoord.y != 0.5 || fragCoord.x > 3.0) {\n        return;\n    }\n\n    if (iFrame == 0) {\n        if (fragCoord.x == 2.5) {\n            fragColor = iMouse;\n        } else {\n            fragColor = vec4(0.0);\n        }\n        \n        return;\n    }\n    \n    vec4 iMouse = iMouse;\n    const float magic = 1e25;\n    \n    if (iMouse == vec4(0.0)) {\n        float t = iTime * 3.0;\n        iMouse.xy = (vec2(cos(3.14159 * t) + sin(0.72834 * t + 0.3), sin(2.781374 * t + 3.47912) + cos(t)) * 0.25 + 0.5) * iResolution.xy;\n        iMouse.z = magic;\n    }\n    \n    vec4 mouseA = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 mouseB = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 mouseC;\n    mouseC.zw = iMouse.zw;\n    float dist = distance(mouseB.xy, iMouse.xy);\n    \n    if (mouseB.z > 0.0 && (mouseB.z != magic || iMouse.z == magic) && dist > 0.0) {\n        vec2 dir = (iMouse.xy - mouseB.xy) / dist;\n        float len = max(dist - RADIUS, 0.0);\n        float ease = 1.0 - pow(FRICTION, iTimeDelta * 10.0);\n        mouseC.xy = mouseB.xy + dir * len * ease;\n    } else {\n        mouseC.xy = iMouse.xy;\n    }\n    \n    if (fragCoord.x == 0.5) {\n        fragColor = mouseA;\n    } else if (fragCoord.x == 1.5) {\n        fragColor = mouseB.z == magic && iMouse.z != magic ? vec4(0.0) : mouseB;\n    } else {\n        fragColor = mouseC;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This buffer maintains the SDF for the drawing.\n\n// .x: SDF with quadratic bezier curves\n// .y: SDF with linear segments\n// .z: SDF for mouse points\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    return distance(ap, ab * clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float qd = 1e30;\n    float ld = 1e30;\n    float pd = 1e30;\n    \n    if (iFrame != 0) {\n        qd = texelFetch(iChannel1, ivec2(fragCoord), 0).r;\n        ld = texelFetch(iChannel1, ivec2(fragCoord), 0).g;\n        pd = texelFetch(iChannel1, ivec2(fragCoord), 0).b;\n    }\n    \n    vec4 mouseA = iFrame > 0 ? texelFetch(iChannel0, ivec2(0, 0), 0) : vec4(0.0);\n    vec4 mouseB = iFrame > 0 ? texelFetch(iChannel0, ivec2(1, 0), 0) : vec4(0.0);\n    vec4 mouseC = iFrame > 0 ? texelFetch(iChannel0, ivec2(2, 0), 0) : iMouse;\n    \n    // A: mouse from previous previous frame\n    // B: mouse from previous frame\n    // C: mouse from this frame\n    \n    mouseA.xy += 0.5;\n    mouseB.xy += 0.5;\n    mouseC.xy += 0.5;\n    \n    if (mouseC.z > 0.0) {\n        pd = min(pd, distance(fragCoord, mouseC.xy));\n    }\n    \n    if (mouseB.z > 0.0 && mouseC.z > 0.0) {\n        ld = min(ld, sdSegment(fragCoord, mouseB.xy, mouseC.xy));\n    } else if (mouseC.z > 0.0) {\n        ld = min(ld, distance(fragCoord, mouseC.xy));\n    }\n    \n    if (mouseB.z <= 0.0 && mouseC.z > 0.0) {\n        qd = min(qd, distance(fragCoord, mouseC.xy));\n    } else if (mouseA.z <= 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        qd = min(qd, sdSegment(fragCoord, mouseB.xy, mix(mouseB.xy, mouseC.xy, 0.5)));\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        qd = min(qd, abs(sdBezier(fragCoord, mix(mouseA.xy, mouseB.xy, 0.5), mouseB.xy, mix(mouseB.xy, mouseC.xy, 0.5))));\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z <= 0.0) {\n        qd = min(qd, sdSegment(fragCoord, mix(mouseA.xy, mouseB.xy, 0.5), mouseB.xy));\n    }\n    \n    fragColor.r = qd;\n    fragColor.g = ld;\n    fragColor.b = pd;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// solveQuadratic(), solveCubic(), solve() and sdBezier() are from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n// with modification. Thank you! I tried a lot of different sdBezier()\n// implementations from across Shadertoy (including trying to make it\n// myself) and all of them had bugs and incorrect edge case handling\n// except this one.\n\nint solveQuadratic(float a, float b, float c, out vec2 roots) {\n    // Return the number of real roots to the equation\n    // a*x^2 + b*x + c = 0 where a != 0 and populate roots.\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return 0;\n    }\n\n    if (discriminant == 0.0) {\n        roots[0] = -b / (2.0 * a);\n        return 1;\n    }\n\n    float SQRT = sqrt(discriminant);\n    roots[0] = (-b + SQRT) / (2.0 * a);\n    roots[1] = (-b - SQRT) / (2.0 * a);\n    return 2;\n}\n\nint solveCubic(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 where a != 0 and populate roots.\n    const float TAU = 6.2831853071795862;\n    float A = b / a;\n    float B = c / a;\n    float C = d / a;\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n    float sQ = sqrt(abs(Q));\n    roots = vec3(-A / 3.0);\n\n    if (S > 0.0) {\n        roots += -2.0 * sQ * cos(acos(R / (sQ * abs(Q))) / 3.0 + vec3(TAU, 0.0, -TAU) / 3.0);\n        return 3;\n    }\n    \n    if (Q == 0.0) {\n        roots[0] += -pow(C - A * A * A / 27.0, 1.0 / 3.0);\n        return 1;\n    }\n    \n    if (S < 0.0) {\n        float u = abs(R / (sQ * Q));\n        float v = Q > 0.0 ? cosh(acosh(u) / 3.0) : sinh(asinh(u) / 3.0);\n        roots[0] += -2.0 * sign(R) * sQ * v;\n        return 1;\n    }\n    \n    roots.xy += vec2(-2.0, 1.0) * sign(R) * sQ;\n    return 2;\n}\n\nint solve(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 and populate roots.\n    if (a == 0.0) {\n        if (b == 0.0) {\n            if (c == 0.0) {\n                return 0;\n            }\n            \n            roots[0] = -d/c;\n            return 1;\n        }\n        \n        vec2 r;\n        int num = solveQuadratic(b, c, d, r);\n        roots.xy = r;\n        return num;\n    }\n    \n    return solveCubic(a, b, c, d, roots);\n}\n\nfloat sdBezier(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 A = a - 2.0 * b + c;\n    vec2 B = 2.0 * (b - a);\n    vec2 C = a - p;\n    vec3 T;\n    int num = solve(\n        2.0 * dot(A, A),\n        3.0 * dot(A, B),\n        2.0 * dot(A, C) + dot(B, B),\n        dot(B, C),\n        T\n    );\n    T = clamp(T, 0.0, 1.0);\n    float best = 1e30;\n    \n    for (int i = 0; i < num; ++i) {\n        float t = T[i];\n        float u = 1.0 - t;\n        vec2 d = u * u * a + 2.0 * t * u * b + t * t * c - p;\n        best = min(best, dot(d, d));\n    }\n    \n    return sqrt(best);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 520, 550, 550, 616], [618, 618, 657, 657, 833], [835, 835, 877, 877, 910], [912, 912, 964, 964, 1893]]}
{"id": "Dl3XD7", "name": "pac-land", "author": "jorge2017a2", "description": "pac-land", "tags": ["pacland"], "likes": 11, "viewed": 191, "published": 3, "date": "1685455980", "time_retrieved": "2024-07-30T17:53:15.691077", "image_code": "//por jorge2017a2\n//30-may-2023\n//pac-land\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{ float c = cos(r), s = sin(r); return (p - o) * mat2(c, -s, s, c) + o; }\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 MarcoCasa(vec2 p,vec2 pPos,vec3  col)\n{ vec2 pos, med;\nfloat d1cu;\nvec3 cmorado, crosa, cazul, crojizo;\n\ncmorado = vec3(0.41, 0.42, 0.87);\ncrosa = vec3(0.85, 0.63, 0.8);\ncazul = vec3(0.18, 0.73, 0.95);\ncrojizo = vec3(0.62, 0.18, 0.18);\n\npos = vec2(0.77, 0.92);;\npos+= pPos;\nmed = vec2(0.495, 0.53);\nd1cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cmorado, col, d1cu);\n//-----------;\nfloat d2cu;\npos = vec2(0.78, 0.92);;\npos+= pPos;\nmed = vec2(0.435, 0.475);\nd2cu = sdBox(p- pos, med);\ncol = DrawFigBorde(crosa, col, d2cu);\n//-----------;\nfloat d3cu;\npos = vec2(0.78, 0.92);;\npos+= pPos;\nmed = vec2(0.31, 0.355);\nd3cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cmorado, col, d3cu);\n//-----------;\nfloat d4cu;\npos = vec2(0.77, 0.93);;\npos+= pPos;\nmed = vec2(0.24, 0.275);\nd4cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cazul, col, d4cu);\n//-----------;\nreturn col;\n}\n\nvec3 PuertaInter(vec2 p,vec3 col)\n{ vec2 pos,med;\nfloat d1cu;\nvec3 cmorado,crosa,cazul,crojizo;\n    cmorado = vec3(0.41, 0.42, 0.87);\n    crosa = vec3(0.85, 0.63, 0.8);\n    cazul = vec3(0.18, 0.73, 0.95);\n    crojizo = vec3(0.62, 0.18, 0.18);\n////superior marco A;\n//superior marco;\npos = vec2(1.76, 1.86);;\nmed = vec2(0.505, 0.16);\nd1cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cmorado, col, d1cu);\n\nfloat d1cua;\npos = vec2(1.77, 1.87);;\nmed = vec2(0.43, 0.12);\nd1cua = sdBox(p- pos, med);\ncol = DrawFigBorde(crosa, col, d1cua);\n////--------;\n//----- puerta;\nfloat d2cu;\npos = vec2(1.56, 2.51);;\nmed = vec2(0.21, 0.48);\nd2cu = sdBox(p- pos, med);\ncol = DrawFigBorde(crojizo, col, d2cu);\n//-----\nfloat d3cu;\npos = vec2(1.99, 2.51);;\nmed = vec2(0.21, 0.48);\nd3cu = sdBox(p- pos, med);\ncol = DrawFigBorde(crojizo, col, d3cu);\n//-----\npos = vec2(1.54, 2.3);;\nmed = vec2(0.14, 0.195);\nd1cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cazul, col, d1cu);\n//-----\npos = vec2(1.99, 2.31);;\nmed = vec2(0.14, 0.195);\nd2cu = sdBox(p-pos, med);\ncol = DrawFigBorde(cazul, col, d2cu);\n//-----------;\nreturn col;\n}\n\nvec3 posIntermedio(vec2 p,vec3 col)\n{vec2 pos, med;\nfloat d2cu;\nvec3 crosa;\n    crosa = vec3(0.85, 0.63, 0.8);\n    pos = vec2(1.76, 1.58);\n    med = vec2(1.42, 0.12);\n    d2cu = sdBox(p- pos, med);\n    col = DrawFigBorde(crosa, col, d2cu);\nreturn col;\n}\n\n\n\nvec3 ladrillo(vec2 p )\n{\n    //https://www.shadertoy.com/view/4tyGzz    \n    vec2 BRICK_SIZE = vec2(0.08, 0.06);\n    vec2 BRICK_PCT = vec2(0.95, 0.9)*0.75;\n\tvec2 uv =p;\n    vec2 position = uv / BRICK_SIZE;\n    if(fract(position.y * 0.5) > 0.5)\n    { position.x += 0.5;}\n    position = fract(position);\n    vec2 useBrick = step(position, BRICK_PCT);\n    vec3 color = mix(vec3(0.2), vec3(1.0,0.0,.0), useBrick.x * useBrick.y) ;\n    return color;\n}\n\n\nvec3 pared02(vec2 p,vec3 col,vec3 cladrillo )\n{//ladrillos\nvec2 pos;\nvec2 med;\nfloat d3cu;\nvec3 colc=cladrillo;\npos = vec2(2.76, 2.89);\nmed = vec2(0.485, 0.115);\nd3cu = sdBox(p- pos, med);\ncol = DrawFigBorde(colc, col, d3cu);\n//------\nfloat d4cu;\npos = vec2(0.78, 2.89);;\nmed = vec2(0.485, 0.115);\nd4cu = sdBox(p- pos, med);\ncol = DrawFigBorde(colc, col, d4cu);\n//------\nreturn col;\n}\n\nvec3 pared03(vec2 p,vec3 col)\n{vec2 pos;\nvec2 med;\nfloat d5cu;\nvec3 cmorado;\n    cmorado = vec3(0.41, 0.42, 0.87);\npos = vec2(1.31, 2.52);\nmed = vec2(0.038, 0.49);\nd5cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cmorado, col, d5cu);\n//------\nfloat d6cu;\npos = vec2(2.23, 2.52);;\nmed = vec2(0.038, 0.49);\nd6cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cmorado, col, d6cu);\n//------\nfloat d7cu;\npos = vec2(0.31, 1.58);;\nmed = vec2(0.025, 0.12);\nd7cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cmorado, col, d7cu);\n//------\nfloat d8cu;\npos = vec2(3.2, 1.58);;\nmed = vec2(0.03, 0.12);\nd8cu = sdBox(p- pos, med);\ncol = DrawFigBorde(cmorado, col, d8cu);\nreturn col;\n}\n\nvec3 ParedLateral(vec2 p,vec3 col)\n{\nfloat r1, r2, he, d9;\nvec2 pos;\nvec3 colc;\ncolc = vec3(0.25, 0.26, 0.51);\nr1 = 1.07;r2 = 1.29;he = 0.245;\n\npos = vec2(3.9, 1.025);\nfloat ang;\nvec2 pr;\nang = -90.0 * PI / 180.0;\npr = Rotate(p, vec2(pos.x - r1 / 2.0, pos.y + he / 2.0), ang);\nd9 = sdTrapezoid(pr- pos, r1, r2, he);\ncol = DrawFigBorde(colc, col, d9);\nreturn col;\n}\n\nvec3 piso(vec2 p,vec3 col)\n{vec2 pos, med;\nfloat d1cu;\nvec3 colc;\n//color piso;\ncolc = vec3(0.82, 0.5, 0.28);\n//pos = vec2(1.99, 2.99);;\n//med = vec2(1.975, 0.325);\n//d1cu = sdBox(p- pos, med);\nd1cu=2.65-p.y;\n\ncol = DrawFigBorde(colc, col, d1cu);\nreturn col;\n}\n\nvec3 llervas(vec2 p,vec3 col)\n{float r1,r2,he,d1;\nvec2 pos;\nvec3 colc;\ncolc = vec3(0.2, 0.84, 0.19); //verde fuerte;\nr1 = 0.015;\nr2 = 0.85;\nhe = 0.175;\npos = vec2(0.37, 2.465);\nd1 = sdTrapezoid(p-pos, r1, r2, he);\ncol = DrawFigBorde(colc, col, d1);\n//------\nfloat d2;\nr1 = 0.015;\nr2 = 0.85;\nhe = 0.175;\ncolc = vec3(0.05, 0.64, 0.04); //verde menos;\npos = vec2(3.62, 2.495);\nd2 = sdTrapezoid(p- pos, r1, r2, he);\ncol = DrawFigBorde(colc, col, d2);\n//-----\nreturn col;\n}\n\nvec3 cuadritos(vec2 p, vec3 col)\n{\nvec3 colc=vec3(0.4,0.4,0.4);\nvec2 pos=vec2(1.35,1.96);\nvec2 med=vec2(0.03,0.03);\nfloat d1cu= sdBox(p-pos, med );\ncol=DrawFigBorde(colc, col, d1cu);\n//----\npos=vec2(1.42,1.89);\nmed=vec2(0.03,0.03);\nfloat d2cu= sdBox(p-pos, med );\ncol=DrawFigBorde(colc, col, d2cu);\n//----\npos=vec2(1.49,1.84);\nmed=vec2(0.03,0.03);\nfloat d3cu= sdBox(p-pos, med );\nd3cu= sdBox( p-pos, med );\ncol=DrawFigBorde(colc, col, d3cu);\n//----\npos=vec2(1.53,1.8);\nmed=vec2(0.03,0.03);\nfloat d4cu= sdBox(p-pos, med );\nd4cu= sdBox( p-pos, med );\ncol=DrawFigBorde(colc, col, d4cu);\n//----\npos=vec2(1.61,1.86);\nmed=vec2(0.03,0.03);\nfloat d5cu= sdBox(p-pos, med );\nd5cu= sdBox( p-pos, med );\ncol=DrawFigBorde(colc, col, d5cu);\n//----\npos=vec2(1.67,1.9);\nmed=vec2(0.03,0.03);\nfloat d6cu= sdBox(p-pos, med );\nd6cu= sdBox( p-pos, med );\ncol=DrawFigBorde(colc, col, d6cu);\n//----\npos=vec2(1.71,1.96);\nmed=vec2(0.03,0.03);\nfloat d7cu= sdBox(p-pos, med );\nd7cu= sdBox( p-pos, med );\ncol=DrawFigBorde(colc, col, d7cu);\n \nreturn col; \n}\n\nvec3 casaPac(vec2 uv,vec3 col)\n{ vec3 cazul;\n    vec3 coll=col;\n    cazul=vec3(0.18, 0.73, 0.95);\n    col=cazul;\n    col=llervas(uv, col);\n    col=piso(uv, col);\n    col=MarcoCasa(uv, vec2(0.0), col);\n    col=MarcoCasa(uv, vec2(1.0, 0.0), col);\n    col=MarcoCasa(uv, vec2(2.0, 0.0), col);\n    col=posIntermedio(uv, col);\n    col=MarcoCasa(uv, vec2(0.0, 1.32), col);\n    \n    col=MarcoCasa(uv, vec2(2.0, 1.32), col);\n    col=PuertaInter(uv, col);\n    col=pared02(uv, col,coll); //ladrillos;\n    col=pared03(uv, col);\n    col=ParedLateral(uv, col);\n    col=cuadritos(uv,col);\n    col=cuadritos(uv-vec2(0.45,0.0),col);\n    \n    col=cuadritos(uv-vec2(-0.95,-0.29),col);//sup\n    col=cuadritos(uv-vec2(-0.5,-0.29),col);\n    col=cuadritos(uv-vec2(-0.05,-0.29),col);\n    col=cuadritos(uv-vec2(0.35,-0.29),col);\n    col=cuadritos(uv-vec2(0.8,-0.29),col);\n    col=cuadritos(uv-vec2(1.25,-0.29),col);    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float py=sin(iTime*0.5);\n    uv.x+=py;\n    uv.y=-uv.y;\n    vec2 uv0=uv;\n    uv-=vec2(-0.5,-0.75); uv*=2.5;\n    vec3 col=ladrillo(uv);\n    col= casaPac(uv,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3XD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 263, 263, 308], [314, 314, 376, 376, 502], [503, 503, 584, 584, 712], [714, 714, 778, 778, 849], [851, 851, 898, 898, 925], [926, 926, 969, 969, 996], [997, 997, 1045, 1045, 1073], [1075, 1091, 1139, 1139, 1211], [1213, 1213, 1248, 1248, 1271], [1273, 1273, 1310, 1310, 1382], [1384, 1384, 1436, 1436, 1543], [1545, 1545, 1570, 1570, 1589], [1590, 1590, 1615, 1615, 1634], [1635, 1635, 1671, 1671, 1699], [1701, 1701, 1766, 1766, 2076], [2078, 2078, 2122, 2122, 2942], [2944, 2944, 2979, 2979, 4040], [4042, 4042, 4079, 4079, 4295], [4299, 4299, 4323, 4371, 4744], [4747, 4747, 4794, 4805, 5131], [5133, 5133, 5164, 5164, 5789], [5791, 5791, 5827, 5827, 6155], [6157, 6157, 6185, 6185, 6417], [6419, 6419, 6450, 6450, 6887], [6889, 6889, 6923, 6923, 7917], [7919, 7919, 7951, 7951, 8831], [8833, 8833, 8890, 8890, 9182]]}
{"id": "Dl3SD7", "name": "animated truchet avoidance", "author": "FabriceNeyret2", "description": "example of truchet avoiding collisions with the green dot.\n\nWIP: I don't know why the door close not smoothly after the green dot.", "tags": ["2d", "truchet", "short"], "likes": 18, "viewed": 316, "published": 3, "date": "1685455859", "time_retrieved": "2024-07-30T17:53:16.451045", "image_code": "// variant of https://shadertoy.com/view/DlcXW7\n\n#define S(v)   smoothstep( 9./R.y, 0., v )                          // AA draw\n#define H(I,t) fract(1e4*sin(dot(I+floor(t),R-17.))) < .5           // random swap ?\n#define D(I,t) I == vec2(floor(2.5+t))                              // passing dot ?\n#define C(I,t) H(I,t) || D(I,t+.5) || D(I+1.,t+.5)                     // all swap conditions\n//#define A(t) clamp( fract(t)*2. -.5, 0., 1. )                     // turn ( 1 = pi/2 )\n//#define A(t) smoothstep(0.,1., fract( t )  )                      // versions with easing\n  #define A(t) smoothstep(0.,1., fract(t)*1.4 -.2 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime, a;\n    vec2 R = iResolution.xy,\n         V = 5.* u / R.y, U = V + t,\n         I = floor(U),                                              // Cell id\n         F = fract(U)-.5;                                           // cell local coords\n    bool     b =  C(I,t),                                           // swap this cell ? if random or passing dot\n         B = b == C(I,t-1.);                                        // same state that previously ?\n    a =  b  ? B ? 1. : A( t)                                        // swap :   keep or turn depending on previous state\n            : B ? 0. : A(-t);                                       // no swap: keep or turn depending on previous state\n  \n    F *= mat2(cos(1.57*a+vec4(0,11,33,0)));                         // rotate cell from prev to new configuration\n    O = vec4(  S( abs( min(length(F-.5),length(F+.5)) - .5 ) -.1 )  // draw truchet\n             * S(length(F)-.5) );\n    \n    O.g += S(length(V-2.5)-.1);                                     // draw green dot\n  //O.r += .4*mod(I.x+I.y,2.);                                      // debug: show tiles\n  //O.r += .4*float(b != H(I,t));       // debug: tile changed for dot\n  //O.b += .5*float(!B);                // debug: tile changed since t-1\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3SD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 627, 665, 665, 1939]]}
{"id": "dttSRN", "name": "Chain mail pattern", "author": "Larbagar", "description": "No", "tags": ["grid"], "likes": 7, "viewed": 167, "published": 3, "date": "1685452007", "time_retrieved": "2024-07-30T17:53:17.217995", "image_code": "#define PI 3.1415926535897932384626433832795\n\n#define ringRadius 0.7\n#define ringBlur 0.025\n#define ringSize 0.05\n#define zoom 0.5\n#define ringFadeSize 0.025\n#define ringFadeStart ringSize - 0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    \n    float angle = PI/4.;\n    uv /= zoom;\n    uv += iTime*vec2(0.05, 0.07);\n    uv *= mat2(\n        cos(angle), sin(angle),\n        -sin(angle), cos(angle)\n    );\n    \n    uv += texture(iChannel0, uv).x*0.05;\n    \n    vec2 cellPos = floor(uv);\n    vec2 odd = mod(cellPos, 2.);\n    float checkerboard = mod(cellPos.x + cellPos.y, 2.);\n    \n    vec2 cellCoord = fract(mix(uv.xy, uv.yx, checkerboard)*(1. - odd.yx*2.));\n    \n    \n    float ring1dist = abs(max(cellCoord.x, cellCoord.y) - ringRadius);\n    float ring2dist = abs(1. - min(cellCoord.x, cellCoord.y) - ringRadius);\n    \n    \n    float horizontalFade1 = smoothstep(0., ringFadeSize, abs(cellCoord.y - 1. + ringRadius) - ringFadeStart);\n    float horizontalFade2 = smoothstep(0., ringFadeSize, abs(cellCoord.y - ringRadius) - ringFadeStart);\n    \n    float verticalFade1 = smoothstep(0., ringFadeSize, abs(cellCoord.x + 1. - ringRadius) - ringFadeStart);\n    float verticalFade2 = smoothstep(0., ringFadeSize, abs(cellCoord.x - 2. + ringRadius) - ringFadeStart);\n    \n    float ring1 = smoothstep(ringBlur, 0., ring1dist - ringSize)*horizontalFade1*verticalFade1;\n    float ring2 = smoothstep(ringBlur, 0., ring2dist - ringSize)*horizontalFade2*verticalFade2;\n    \n    \n    vec3 col = (ring1 + ring2)*(0.5 + texture(iChannel1, uv).xyz*0.5);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttSRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 253, 253, 1655]]}
{"id": "DlcXW7", "name": "truchet avoidance", "author": "FabriceNeyret2", "description": "example of truchet avoiding collisions with the green dot.\n( switch comments lines 10/11 for a truchet changing over time ).", "tags": ["2d", "truchet", "short"], "likes": 20, "viewed": 242, "published": 3, "date": "1685451275", "time_retrieved": "2024-07-30T17:53:17.973973", "image_code": "#define S(v) smoothstep( 9./R.y, 0., v )                            // AA draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         V = 5.* u / R.y, U = V + iTime,\n         I = floor(U),                                              // Cell id\n         F = fract(U)-.5;                                           // cell local coords\n         \n    if (    fract(1e4*sin(dot(I,R-17.))) < .5                       // random swap some cells\n // if (    fract(1e4*sin(dot(I+floor(iTime),R-17.))) < .5          // variant: change all the time\n         || I == vec2(floor(2.5+iTime)) )                           // swap if dot is passing here\n         F = vec2(-F.y,F);\n    \n    O = vec4( S( abs( min(length(F-.5),length(F+.5)) - .5 ) -.1 ) );// draw truchet\n    \n    O.g += S(length(V-2.5)-.1);                                     // draw green dot\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcXW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 119, 119, 874]]}
{"id": "cl3SW7", "name": "Wind Walker Herd", "author": "dr2", "description": "Multiple wind walkers (from \"Wind Walker\"); mouseable", "tags": ["gait", "kinematics", "strandbeest", "jansen"], "likes": 23, "viewed": 409, "published": 3, "date": "1685446135", "time_retrieved": "2024-07-30T17:53:19.004219", "image_code": "// \"Wind Walker Herd\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (nFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, lBase;\nvec2 cId;\nfloat tCur, dstFar, bGrid, grLim, spd, wlkScl;\nint nFrame, idObj;\nconst int idBas = 1, idLnkT = 2, idLnk = 3, idAx = 4, idWhl = 5, idVane = 6, idStruc = 7,\n   idGrnd = 8;\nconst float s_a = 38.0, s_b = 41.5, s_c = 39.3, s_d = 40.1, s_e = 55.8, s_f = 39.4,\n   s_g = 36.7, s_h = 65.7, s_i = 49.0, s_j = 50.0, s_k = 61.9, s_l = 7.8, s_m = 15.0;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nstruct Leg {\n  vec2 v[8], cs[10], cswAng;\n  float wAng;\n};\nstruct Walker {\n  Leg leg[2];\n  vec2 csVane;\n  float szFac;\n};\nWalker wlk;\n\n#define ACOSR(x, y, z) acos (((x) * (x) + (y) * (y) - (z) * (z)) / (2. * (x) * (y)))\n#define ATANV(v) atan ((v).y, (v).x)\n\nvoid ObjState ()\n{ //  (Leg from the Strandbeest: see https://en.wikipedia.org/wiki/Jansen's_linkage)\n  float a[10], aa, g, s, t;\n  wlk.szFac = wlkScl / (1. + 0.3 * Maxv2 (abs (cId)));\n  t = tCur * wlkScl / wlk.szFac;\n  wlk.leg[0].wAng = - spd * t;\n  wlk.leg[1].wAng = wlk.leg[0].wAng + pi;\n  for (int k = 0; k < 2; k ++) {\n    wlk.leg[k].v[0] = vec2 (0., 0.);\n    wlk.leg[k].v[1] = wlk.leg[k].v[0] + vec2 (s_a, s_l);\n    wlk.leg[k].v[2] = wlk.leg[k].v[1] + Rot2D (vec2 (s_m, 0.), wlk.leg[k].wAng);\n    aa = ATANV (wlk.leg[k].v[2] - wlk.leg[k].v[0]);\n    s = length (wlk.leg[k].v[2] - wlk.leg[k].v[0]);\n    a[0] = aa + ACOSR (s, s_b, s_j);\n    wlk.leg[k].v[3] = wlk.leg[k].v[0] + Rot2D (vec2 (s_b, 0.), a[0]);\n    a[1] = aa - ACOSR (s, s_c, s_k);\n    wlk.leg[k].v[4] = wlk.leg[k].v[0] + Rot2D (vec2 (s_c, 0.), a[1]);\n    a[2] = ACOSR (s_b, s_d, s_e) + a[0];\n    wlk.leg[k].v[5] = wlk.leg[k].v[0] + Rot2D (vec2 (s_d, 0.), a[2]);\n    s = length (wlk.leg[k].v[5] - wlk.leg[k].v[4]);\n    g = ACOSR (s, s_c, s_d) + ACOSR (s, s_g, s_f) + pi + a[1];\n    wlk.leg[k].v[6] = wlk.leg[k].v[4] + Rot2D (vec2 (s_g, 0.), g);\n    wlk.leg[k].v[7] = wlk.leg[k].v[4] + Rot2D (vec2 (s_i, 0.), g + ACOSR (s_g, s_i, s_h));\n    a[3] = ACOSR (s_d, s_e, s_b) + a[2] - pi;\n    a[4] = ATANV (wlk.leg[k].v[4] - wlk.leg[k].v[6]);\n    a[5] = ATANV (wlk.leg[k].v[5] - wlk.leg[k].v[6]);\n    a[6] = ATANV (wlk.leg[k].v[7] - wlk.leg[k].v[6]);\n    a[7] = ATANV (wlk.leg[k].v[7] - wlk.leg[k].v[4]);\n    a[8] = ATANV (wlk.leg[k].v[3] - wlk.leg[k].v[2]);\n    a[9] = ATANV (wlk.leg[k].v[4] - wlk.leg[k].v[2]);\n    for (int m = 0; m < 10; m ++) wlk.leg[k].cs[m] = CosSin (- a[m]);\n    wlk.leg[k].cswAng = CosSin (- wlk.leg[k].wAng);\n  }\n  wlk.csVane = CosSin (4. * t);\n}\n\nvoid LinkDf (vec3 p, vec2 v, vec2 cs, float l, int id, inout float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xy = Rot2Cs (q.xy - v, cs);\n  d = max (PrCaps2Df (q.yx - vec2 (0., 0.5 * l), 2., 0.5 * l), abs (q.z) - 0.5);\n  DMINQ (id);\n}\n\nfloat ObjDf (vec3 p)\n{ // (Based on \"Wind Walker\")\n  vec3 q, pp;\n  float dMin, d, sx;\n  p.xz -= bGrid * (cId + 0.5);\n  dMin = dstFar / wlk.szFac;\n  p /= wlk.szFac;\n  p.y -= lBase.y;\n  p.xz = Rot2Cs (p.xz, CosSin (0.25 * pi));\n  p.xz = p.zx * vec2 (1., -1.);\n  pp = p;\n  for (int kx = 0; kx < 2; kx ++) {\n    sx = sign (float (kx) - 0.5);\n    p.x = pp.x  + lBase.x * sx;\n    for (int k = 0; k < 2; k ++) {\n      p.z = lBase.z + pp.z * (sign (float (k) - 0.5)) * sx;\n      q = p;\n      q.z -= 4.;\n      q.xy = Rot2Cs (q.xy - wlk.leg[k].v[1], wlk.leg[k].cswAng);\n      d = PrCylAnDf (q, s_m, 2., 1.);\n      q.xy = (abs (q.x) > abs (q.y)) ? q.xy : q.yx;\n      d = min (d, max (PrBox2Df (q.xy, vec2 (s_m, 1.8)), abs (q.z) - 0.8));\n      DMINQ (idWhl);\n      for (int j = 2; j <= 7; j ++) {\n        q = p;\n        q -= vec3 (wlk.leg[k].v[j], 0.2);\n        d = PrCylDf (q, ((j < 7) ? 1.5 : 2.5), ((j == 2) ? 5. : 3.));\n        DMINQ (idAx);\n      }\n      LinkDf (p, wlk.leg[k].v[0], wlk.leg[k].cs[0], s_b, idLnkT, dMin);\n      LinkDf (p, wlk.leg[k].v[0], wlk.leg[k].cs[2], s_d, idLnkT, dMin);\n      LinkDf (p, wlk.leg[k].v[5], wlk.leg[k].cs[3], s_e, idLnkT, dMin);\n      LinkDf (p, wlk.leg[k].v[6], wlk.leg[k].cs[4], s_g, idLnkT, dMin);\n      LinkDf (p, wlk.leg[k].v[6], wlk.leg[k].cs[6], s_h, idLnkT, dMin);\n      LinkDf (p, wlk.leg[k].v[4], wlk.leg[k].cs[7], s_i, idLnkT, dMin);\n      p.z -= 1.4;\n      LinkDf (p, wlk.leg[k].v[0], wlk.leg[k].cs[1], s_c, idLnk, dMin);\n      LinkDf (p, wlk.leg[k].v[6], wlk.leg[k].cs[5], s_f, idLnk, dMin);\n      LinkDf (p, wlk.leg[k].v[2], wlk.leg[k].cs[8], s_j, idLnk, dMin);\n      p.z += 2.8;\n      LinkDf (p, wlk.leg[k].v[2], wlk.leg[k].cs[9], s_k, idLnk, dMin);\n    }\n  }\n  p = pp;\n  q = p;\n  q.x -= 20.;\n  d = PrRoundBoxDf (q, vec3 (lBase.x + 35., 2.5, lBase.z - 7.), 0.5);\n  DMINQ (idBas);\n  q = p;\n  q.x = abs (q.x) - lBase.x;\n  d = PrCylDf (q, 1.5, lBase.z + 2.);\n  DMINQ (idAx);\n  q = p;\n  q.xy -= vec2 (s_a, s_l);\n  q.x = abs (q.x) - lBase.x;\n  d = PrCylDf (q, 1.5, lBase.z - 2.);\n  DMINQ (idAx);\n  q = p;\n  q.xy -= vec2 (s_a, s_l - 1.5);\n  d = PrRoundBoxDf (q, vec3 (lBase.x, 4.5, 4.), 0.5);\n  DMINQ (idStruc);\n  q.x = abs (abs (q.x) - 0.5 * lBase.x) - 0.5 * lBase.x;\n  d = PrRoundBoxDf (q, vec3 (4., 4.5, lBase.z - 7.), 0.5);\n  DMINQ (idStruc);\n  q = p;\n  q.z = abs (abs (q.z) - 21.);\n  q -= vec3 (s_a, 27., 21.);\n  d = PrBoxDf (q, vec3 (4., 27., 1.5));\n  DMINQ (idStruc);\n  q = p;\n  q.xy -= vec2 (s_a, 50.);\n  d = PrCylDf (q, 2.5, lBase.z - 5.);\n  DMINQ (idAx);\n  q.xy = Rot2Cs (q.xy, wlk.csVane);\n  d = max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y);\n  q.xy = Rot2Cs (q.xy, CosSin (2. * pi / 3.));\n  d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n  q.xy = Rot2Cs (q.xy, CosSin (2. * pi / 3.));\n  d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n  q.z = abs (q.z) - 21.;\n  d = max (d, abs (q.z) - 18.);\n  DMINQ (idVane);\n  return wlk.szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 cIdP, s;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi.xz = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = (Maxv2 (abs (cId)) <= grLim) ? ObjDf (p) : dstFar;\n    s = (bGrid * (cId + step (0., rd.xz)) - p.xz) * rdi.xz;\n    d = min (d, abs (Minv2 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    p = ro + d * rd;\n    cId = floor (p.xz / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    if (Maxv2 (abs (cId)) <= grLim) {\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.3 * bGrid;\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else if (rd.y < 0.) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return 0.8 * col;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  if (idObj == idBas) {\n    col4 = vec4 (0.8, 0.6, 0.2, 0.05) * (0.9 +\n       0.1 * smoothstep (0.1, 0.13, fract (8. * abs (qHit.z) / 50. + 0.5)));\n    if (qHit.y > 0.) col4 = mix (col4, vec4 (0.2, 1., 0.2, -1.), ShowIntPZ (Rot2D (qHit.xz +\n       vec2 (20. + lBase.x, 20.), 0.5 * pi), 0.7 * lBase.x * vec2 (1., 0.5),\n       2., 11. + grLim - cId.x + (2. * grLim + 1.) * (grLim - cId.y)));\n  } else if (idObj == idStruc) {\n    col4 = vec4 (0.5, 0.5, 0.8, 0.05);\n  } else if (idObj == idLnkT) {\n    col4 = vec4 (0.85, 0.85, 0.9, 0.1) * (0.8 + 0.2 * smoothstep (0.18, 0.22, abs (qHit.y)));\n  } else if (idObj == idLnk) {\n    col4 = vec4 (0.95, 0.95, 1., 0.1) * (0.8 + 0.2 * smoothstep (0.18, 0.22,\n       abs (abs (qHit.y) - 0.8)));\n  } else if (idObj == idAx) {\n    col4 = vec4 (0.8, 0.7, 0.2, 0.1);\n  } else if (idObj == idWhl) {\n    col4 = vec4 (1., 0.6, 0.2, 0.05);\n  } else if (idObj == idVane) {\n    col4 = vec4 (1., 1., 0.9, 0.05) * (0.8 + 0.2 * smoothstep (0.2, 0.24,\n       abs (abs (qHit.z) - 10.)));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, q;\n  float dstObj, dstGrnd, sh, t, nDotL;\n  bool isBg;\n  wlkScl = 0.07;\n  lBase = vec3 (60., 86., 50.);\n  spd = 2.;\n  dstGrnd = dstFar;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    q = ro;\n    q.xz += spd * tCur;\n    col4 = mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.), smoothstep (0.2, 0.8, Fbm2 (q.xz)));\n    col4 = mix (vec4 (0.2, 0.5, 0.2, 0.), col4,  1. - smoothstep (0.6, 0.9, dstGrnd / dstFar));\n    vn = VaryNf (2. * q, vec3 (0., 1., 0.), 2. * (1. - smoothstep (0.2, 0.4, dstGrnd / dstFar)));\n  } else {\n    col = SkyBgCol (ro, rd);\n    isBg = true;\n  }\n  if (! isBg) {\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      if (dstObj < dstFar && (idObj == idLnk || idObj == idLnkT || idObj == idWhl)) nDotL *= nDotL;\n      sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.8 * sh * nDotL) + step (0.95, sh) * col4.a * pow (max (0.,\n         dot (sunDir, reflect (rd, vn))), 32.);\n    } else col = col4.rgb * (0.55 - 0.45 * dot (rd, vn));\n    if (dstObj >= dstFar) col = mix (col, 0.8 * vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bGrid = 16.;\n  grLim = 3.;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    az = mod (az + 0.01 * pi * tCur + pi, 2. * pi) - pi;\n  }\n  el = clamp (el, -0.4 * pi, -0.03 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -150.);\n  ro.xz += 0.5 * bGrid;\n  zmFac = 6. + 3. * abs (az);\n  dstFar = 300.;\n  sunDir = normalize (vec3 (0., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, -0.01 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (vec2 (p.x, sign (p.y) * (max (0., abs (p.y) - h)))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3SW7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1576, 1576, 1594, 1677, 3306], [3308, 3308, 3382, 3382, 3541], [3543, 3543, 3565, 3593, 6501], [6503, 6503, 6536, 6536, 7172], [7174, 7174, 7195, 7195, 7450], [7452, 7452, 7489, 7489, 7976], [7978, 7978, 8012, 8012, 8838], [8840, 8840, 8856, 8856, 9899], [9901, 9901, 9936, 9936, 11374], [11376, 11376, 11432, 11432, 12639], [12641, 12641, 12673, 12673, 12773], [12775, 12775, 12808, 12808, 12897], [12899, 12899, 12945, 12945, 12992], [12994, 12994, 13036, 13036, 13087], [13089, 13089, 13142, 13142, 13203], [13205, 13205, 13249, 13249, 13325], [13327, 13327, 13349, 13349, 13376], [13378, 13378, 13400, 13400, 13427], [13429, 13429, 13465, 13465, 13671], [13673, 13673, 13703, 13703, 13816], [13818, 13818, 13849, 13849, 13913], [13915, 13915, 13938, 13938, 14042], [14115, 14115, 14147, 14147, 14695], [14697, 14697, 14759, 14759, 15126], [15160, 15160, 15184, 15184, 15237], [15239, 15239, 15263, 15263, 15393], [15395, 15395, 15420, 15420, 15566], [15568, 15568, 15593, 15593, 15777], [15779, 15779, 15801, 15801, 15955], [15957, 15957, 15978, 15978, 16133], [16135, 16135, 16164, 16164, 16376], [16378, 16378, 16417, 16417, 16597]]}
{"id": "dltXDH", "name": "Year of Truchets #028", "author": "byt3_m3chanic", "description": "Trying to make the bi-directional path for cars..\n\nAll year long I'm going to just focus on truchet tiles and the likes!\n", "tags": ["2d", "truchet", "city", "track", "cars"], "likes": 14, "viewed": 198, "published": 3, "date": "1685441474", "time_retrieved": "2024-07-30T17:53:20.092310", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Year of Truchets #028\n    05/30/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    dual motion tracks - for cars and stuff.\n    \n    @Shane & @iq for compact noise in common tab\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nconst float tc = .2;\nconst float trs = .45;\nconst float spd = 1.15;\nconst float bl = .05;\nconst vec2 bx = vec2(.45,.075);\nconst float amt = 6.;\n\nfloat scale = 5.;\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 hue(float a) { return .65+.35*sin(PI*a*vec3(1,.97,.93)*vec3(0.875,0.400,0.149));}\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 47.583)))*43758.5453);}\n\n//@iq sdf\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    if(R.x>1200.) scale = 9.; //up scale on fullscreen\n    \n    vec3 C = vec3(.7001);\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    \n    uv *= scale;\n    uv *= rot(.06*sin(T*.12));\n    uv += vec2(2.33*sin(T*.15),T*.3);\n\n    float px = fwidth(uv.x); \n    vec2 id = floor(uv);\n    vec2 q = fract(uv)-.5;\n \n    float hs = hash21(id);\n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    if(hs>.5) q.x = -q.x;\n\n    vec2 uv2 = vec2(length(q-.5),length(q+.5));\n    vec2 p = uv2.x<uv2.y? q-.5 : q+.5;\n\n    // main pattern\n    float d = length(p)-.5;\n    d = abs(d)-tc;\n\n    // moving truchet parts\n    vec2 arc = q-sign(q.x+q.y+.001)*.5;\n    float angle = atan(arc.x, arc.y);\n    float ud = length(arc);\n\n    float x = fract(amt*ck*angle/PI+T*spd);\n    float y = (ud/.5)-.5;\n    float z = fract(amt*ck*angle/PI-T*spd);\n\n    vec2 cid = vec2(floor(ud-(.5-tc))/(2.*tc),floor(amt*ck*angle/PI+T*spd));\n    vec2 did = vec2(floor(ud-(.5-tc))/(2.*tc),floor(amt*ck*angle/PI-T*spd));\n    cid.y = mod(cid.y,amt);\n    did.y = mod(did.y,amt);\n    \n    vec3 K = hue((cid.y*.2)+75.);\n    vec3 R = hue((did.y*.2)+125.);\n    if(mod(cid.y,4.)==0.) K=vec3(.6);\n    if(mod(did.y,3.)!=0.) R=vec3(.6);\n    \n    if(hs<.5 ^^ ck>0.) y=1.-y;\n    \n    vec2 tuv = vec2(x,y);\n    float k = box(tuv+vec2(0,.1)-.5, bx)-.012;\n    float k2 = box(vec2(z,y-.1)-.5, bx)-.012;\n\n    // gnd\n    float sc = 6.;\n\n    vec2 iv = floor(uv*sc)+id;\n    vec2 vv = fract(uv*sc)-.5;\n    float xs = fbm(vec3(iv.x,0,iv.y)*.035);\n    xs = smoothstep(.5,.95,xs);\n    float cy = length(vv)-(xs*.55);\n\n    if (xs>.1) {\n        float fx = fwidth(uv.x*sc); \n        C = mix(C,vec3(clamp(.7-xs,.2,1.)),smoothstep(fx,-fx,cy));\n    } \n\n    C = mix(C,C*.65,smoothstep(.05+px,-px,d-.015));\n        \n    C = mix(C,vec3(.4),smoothstep(px,-px,abs(d)-.025));\n    C = mix(C,vec3(.7001),smoothstep(px,-px,d));\n\n    C = mix(C,K,smoothstep(px,-px,k));\n    C = mix(C,R,smoothstep(px,-px,k2));\n\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n\n    \n        \n    \n        \n    \n    ", "image_inputs": [], "common_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n*/\n\n// @Shane - a very tightly compacted, self-contained version \n// of IQ's 3D value noise function.\n//---------------------------------------------------------------\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n//---------------------------------------------------------------\n// @iq fbm generator\nfloat fbm( in vec3 x) {\n    float a = 0.1,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for (int i = 0; i < 4; ++i) {      \n        float n = n3D(f*x);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltXDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[611, 611, 630, 630, 674], [675, 675, 694, 694, 761], [762, 762, 784, 784, 845], [847, 857, 892, 892, 968]]}
{"id": "cltXzM", "name": "fractal pools", "author": "flylo", "description": "combining waves of increasing frequency", "tags": ["2d", "fractal", "metal", "liquid"], "likes": 1, "viewed": 180, "published": 3, "date": "1685415630", "time_retrieved": "2024-07-30T17:53:20.852278", "image_code": "const int[18] ns = int[](-1, -1, 0, -1, 1, -1, -1, 0, 1, 0, 0, 0, -1, 1, 0, 1, 1, 1);\n\nvec4 texel(in ivec2 x) {\n    return texelFetch( iChannel0, x, 0 );\n}\n\nvec4 avg( in ivec2 px )\n{\n \n    vec4 sum = vec4(0.);\n        \n    for (int i = 0; i < 18; i += 2) {\n       vec4 n = texel(px+ivec2(ns[i%18],ns[(i%18)+1]));\n       sum += n;\n    }\n \n   return sum/9.;\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iv = ivec2(fragCoord);\n    fragColor = avg(iv);\n    fragColor = texel(iv);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 pools(in vec2 uv)\n{\n    float dt  = .5+.5*sin(.16*iTime);\n    float dt2 = .5+.5*sin(.48*iTime);\n    float mdt = dt;\n    float mdt2 = .7+.3*dt2;\n    \n    float dt3 = .5+.5*sin(.14*iTime);\n    float dt4 = .5+.5*sin(.53*iTime);\n    float mdt3 = dt3;\n    float mdt4 = .7+.3*dt4;\n\n    float dt5  = .5+.5*sin(.15*iTime);\n    float dt6 = .5+.5*sin(1.5+.49*iTime);\n    float mdt5 = dt5;\n    float mdt6 = .7+.3*dt6;\n\n    float dt7  = .5+.5*sin(.3*iTime);\n    float mdt7 = .1+.9*dt7;\n\n    float dt8  = .5+.5*sin(1.5+.2*iTime);\n    float mdt8 = .9+.1*dt8;\n\n\n    //uv = vec2(sin(25.*uv));\n\n    float r2 = length(uv)*length(uv);\n\n    vec3 c = vec3(0.);\n    float a = 1.;\n    float f = 12.;\n    float as = 0.;\n    for (int i = 0; i < 3; i++) {\n        c.r += a*(mdt)*(.5+.5*sin(15.*mdt2+f*mdt2*2.2*uv.x));\n        c.g += a*(mdt3)*(.5+.5*sin(11.*mdt4+f*mdt4*2.1*uv.y));\n        c.b += a*(mdt5)*.7*length(sin(22.*mdt6+f*mdt6*1.4*uv));\n        as += a;\n        f *= 1.3+length(c);\n        //f *= 1.33;\n        a *= 1.2; \n    }\n    c /= as;\n   \n    //c = vec3(uv.x, uv.y, uv.x/uv.y);  \n    //c = vec3(1.+sin(21.*uv), 0.);\n  \n    for(int i = 0; i < 0; i++) {\n        //uv = vec2(sin(uv.x), sin(uv.y));\n        float r3 = length(c)*length(c)*length(c);\n        //c = c*(1./(vec3(.4*mdt7+r3)));\n       \n        float k = 1.;\n        float k2 = 1.1;\n        //c = clamp(c, -1., 1.);        \n        c = vec3((1./(k+k2*c.r*r3)), ( 1./(k+k2*c.g*r3)), ( 1./(k+k2*c.b*r3)));\n        c = tan(c);\n        \n        //uv = vec2(mdt5*sin(tan(.005*mdt3*uv.x)), mdt6*sin(tan(.2 + .5*mdt4*uv.y)));\n        //uv = vec2(115.*mdt5*tan(.3*uv.x), 1.); // 1.*mdt6*tan(.004*mdt4*uv.y));\n        //c = vec2(tan(1.*sin(1.2*mdt5*uv.x)), tan(1.*sin(1.2*mdt6*uv.y)));\n        //uv = vec2(uv.x*sin(r2)-uv.y*cos(r2), uv.x*cos(r2)+uv.y*sin(r2));\n        //uv = vec2(cos(.2*(uv.x-uv.y)), sin(.3*(uv.x-uv.y)));\n   \n    }\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n    return c;\n    \n}\n\n\nvec3 warp(in vec2 uv) {\n    vec3 c = pools(uv);\n    \n    int iter = 0;\n    float amp = 334.9;\n    float f = .00112;\n\n    float a = 1.; \n    for (int i = 0; i < iter; i++) {\n       a *= amp;\n    }\n       \n    for (int i = 0; i < iter; i++) {\n        a /= amp;\n        f *= 1.2;\n        c = a*pools(uv + f*vec2(c.r-c.g, c.g - c.b)) ;\n    }\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 px = ivec2( fragCoord );\n\n    vec2 uv = fragCoord/iResolution.xy;\n // vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    //rstate = dot(uv, vec2(711.9898,1123.233));\n \n    //cur = texelFetch(iChannel0, px, 0 );\n\n    fragColor = vec4(warp(uv), 1.);\n\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 111, 111, 155], [157, 157, 182, 182, 361], [363, 363, 420, 420, 509]]}
{"id": "mt3SDN", "name": "Constant Line Thickness", "author": "iq", "description": "See [url]https://iquilezles.org/articles/distance/[/url]", "tags": ["2d", "distance"], "likes": 18, "viewed": 1095, "published": 3, "date": "1685401109", "time_retrieved": "2024-07-30T17:53:21.601275", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Graphing with approximated constant thickness, following this article:\n//\n// https://iquilezles.org/articles/distance/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    float w = 1.0/iResolution.y; // size of a pixel\n    float x = fragCoord.x * w;\n    float y = fragCoord.y * w;\n    \n    // function f(x) and naive distance\n    float f = 0.5 + 0.005/x + 0.01*x/(x-1.0) + 0.1*sin(x*20.0);\n    float d = abs(f-y);\n    \n    // enable and disable the technique\n    if( mod(iTime,2.0)>1.0 )\n    {\n        // derivative f'(x) and better distance estimation\n        float fy = -0.005/(x*x) - 0.01/((x-1.0)*(x-1.0)) + 0.1*20.0*cos(20.0*x);\n        fy = min( abs(fy), 40.0 );\n        // distance estimation\n        d /= sqrt( 1.0 + fy*fy );\n    }\n    else\n    {\n        d *= 0.707107;\n    }\n    \n    // background\n    vec3 col = vec3(0.15);\n\n    // graph\n    float thickness = iResolution.y/135.0;\n    // graph thickness is 8 pixels at 1080p\n    // cubic filtering is 2 pixels wide\n    col = mix( col, vec3(0.0,0.7,1.0), smoothstep((0.5*thickness+2.0)*w,\n                                                  (0.5*thickness+0.0)*w,\n                                                   d) );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3SDN.jpg", "access": "api", "license": "mit", "functions": [[1201, 1201, 1258, 1277, 2321]]}
{"id": "mlcSWN", "name": "squares effect 001", "author": "catafest", "description": "simple square effect", "tags": ["math", "squares", "romania", "catafest"], "likes": 0, "viewed": 144, "published": 3, "date": "1685398410", "time_retrieved": "2024-07-30T17:53:22.360246", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Dimensiunile ecranului\n    vec2 resolution = iResolution.xy;\n\n    // Normalizarea coordonatelor\n    vec2 uv = ( fragCoord - resolution) / resolution.y;\n\n    // Redimensionarea la aspect ratio\n    uv.x *= resolution.x / resolution.y;\n\n    // Calculul coordonatelor 3D\n    float x = uv.x;\n    float y = uv.y;\n    float z = sin(uv.x * 5.0) * cos(uv.y * 5.0) *5.0 ;\n\n    // Calculul distanței față de centrul \n    float distance = sqrt(x * x + y * y + z * z);\n\n    // Calculul valorii fractalului în funcție de distanță\n    float l = clamp(uv.x,uv.y,0.0);\n    //float fractalValue = z + sin(distance * distance * cos(iTime));\n    float fractalValue = z*z*z*sin(distance *exp(l)/ (z*z * cos(iTime) * distance+sin(iTime) ));\n\n    // Setarea culorii în funcție de fractalValue\n    vec3 color = vec3(sin(fractalValue)/fractalValue);\n\n    // Afisarea culorii\n    fragColor = vec4(fractalValue+sin(iTime)/color.x,color.y/fractalValue-cos(iTime),fractalValue-sin(iTime)/color.z, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcSWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 85, 1047]]}
{"id": "mtyGWz", "name": "Year of Truchets #027", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n", "tags": ["2d", "truchet", "city", "track", "cars"], "likes": 19, "viewed": 264, "published": 3, "date": "1685392221", "time_retrieved": "2024-07-30T17:53:23.120214", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Year of Truchets #027\n    05/29/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    @jorge2017a2 said my last truchet looked like a\n    car track - https://www.shadertoy.com/view/cltSzN\n    \n    so attempting a 2D version. Cross parts make \n    it hard cause direction - so faking it..\n    \n    @Shane & @iq for compact noise in common tab\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\n// scale - set in main\nfloat scale = 4.;\n\nconst float tc = .1;     // track thickness\nconst float trs = .75;     // threshold for cross tile\nconst float spd = .465;    // speed\nconst float amt = 3.;      // number of cars\nconst float amx = 2.;      // cross track cars\n\n// car params\nconst vec2 bx = vec2(.165,.1);\nconst vec2 bt = bx*.25;\nconst vec2 bk = vec2(.1,.13);\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 hue(float a) { return .55+.45*sin(PI*a*vec3(1,.97,.93)*vec3(0.898,0.204,0.875));}\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 47.583)+iDate.z))*43758.5453);}\n\n//@iq sdf\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    if(R.x>1200.) scale = 7.; //up scale on fullscreen\n    \n    vec3 C = vec3(.06,.38,.07);\n    vec3 G = vec3(.38,.29,.06);\n    \n    // set uv\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    \n    // scale + move + rotate\n    uv *= scale;\n    uv *= rot(.06*sin(T*.12));\n    uv += vec2(1.3*sin(T*.1),T*.2);\n    \n    // setup px + id and grid uv\n    float px = fwidth(uv.x); \n    vec2 id = floor(uv);\n    vec2 q = fract(uv)-.5;\n \n    // hash and every other check\n    float hs = hash21(id);\n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    if(hs>.5) q.x = -q.x;\n    \n    float pt = fbm(vec3(id.x,0,id.y)*2.45);\n    pt = smoothstep(.5,.8,pt);\n    C = mix(C,G,clamp(pt,0.,1.));\n    C = mix(C,C*vec3(.1,.1,0),hs*.5);\n\n    vec2 uv2 = vec2(length(q-.5),length(q+.5));\n    vec2 p = uv2.x<uv2.y? q-.5 : q+.5;\n\n    // main pattern\n    float d = length(p)-.5;\n    d = abs(d)-tc;\n\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.005;\n    float c = min(length(q.x)-tc,length(q.y)-tc);\n    if (hs>trs) d = c;\n\n    // moving truchet parts\n    vec2 arc = q-sign(q.x+q.y+.001)*.5;\n    float angle = atan(arc.x, arc.y);\n    float ud = length(arc);\n\n    float x = fract(amt*ck*angle/PI+T*spd);\n    float y = (ud/.5)-.5;\n\n    vec2 cid = vec2(floor(ud-(.5-tc))/(2.*tc),floor(amt*ck*angle/PI+T*spd));\n    vec3 K = hue((mod(cid.y,amt)+5.)*25.9);\n\n    // direction operation\n    if(hs<.5 ^^ ck>0.) y=1.-y;\n    \n    vec2 tuv = vec2(x,y);\n    float k = box(tuv-.5,bx)-.015; \n    float kt= box(abs(tuv-.5)-bk,bt); \n    float kw= box(tuv-vec2(.45,.5),vec2(.04,.07))-.02; \n    \n    // cross track changes\n    if (hs>trs) {\n        x = fract(amx*ck*abs(q.x)-T*spd);\n        y = (q.y+.25)*2.;\n        tuv = vec2(x,y);\n        \n        y = fract(amx*ck*(abs(q.y)-.25)+T*spd);\n        x = (q.x+.25)*2.;\n        vec2 duv = vec2(x,y);\n        \n        k = min(box(tuv-.5,bx)-.015,box(duv-.5,bx.yx)-.015);\n        kt= min(box(abs(tuv-.5)-bk,bt),box(abs(duv-.5)-bk.yx,bt.yx));\n        kw= min(box(tuv-vec2(.55,.5),vec2(.04,.07))-.02,\n                box(duv-vec2(.5,.45),vec2(.07,.04))-.02 \n            ); \n    } \n    \n    float ct = box(q,vec2(.175))-.04;\n\n    // background tree stuff\n    vec2 iv = floor(uv*8.)+id;\n    vec2 vv = fract(uv*8.)-.5;\n    float xs = fbm(vec3(iv.x,0,iv.y)*.075);\n          xs = smoothstep(.5,.8,xs);\n    float cy = length(vv)-(xs*.35);\n    \n    // lines\n    d2 = smoothstep(px,-px,d2-.001);\n    C = mix(C,vec3(.1,.05,.02),d2);\n\n    // show trees if value is high enough\n    if (xs>.001) {\n        xs = fbm(vec3(iv.x,0,iv.y)*3.);\n        vec3 T = mix(C,G,mod(xs*32.2,1.));\n        C = mix(C,T*.25,smoothstep(.025+px,-px,cy-.1));\n        C = mix(C,T,smoothstep(px,-px,cy));\n    } \n\n    // track shadow\n    C = mix(C,C*.45,smoothstep(.05+px,-px,d-.035));\n\n    // main path\n    C = mix(C,vec3(0),smoothstep(px,-px,abs(d)-.015));\n    C = mix(C,vec3(.1),smoothstep(px,-px,d));\n\n    // cars\n    C = mix(C,C*.6,smoothstep(.05+px,-px,k-.02));\n    C = mix(C,vec3(0),smoothstep(px,-px,kt-.02));\n    C = mix(C,vec3(0),smoothstep(px,-px,abs(k)-.02));\n    C = mix(C,K,smoothstep(px,-px,k));\n    C = mix(C,C*.7,smoothstep(.04+px,-px,kw-.01));\n    C = mix(C,vec3(.9),smoothstep(px,-px,kw));\n\n    if (hs>trs) {\n        C = mix(C,vec3(0),smoothstep(px,-px,abs(ct)-.015));\n        C = mix(C,C*.45,smoothstep(.05+px,-px,ct-.025));\n        C = mix(C,vec3(.2),smoothstep(px,-px,ct));\n    }\n    \n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n\n    \n        \n    \n        \n    \n    ", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n*/\n\n// @Shane - a very tightly compacted, self-contained version \n// of IQ's 3D value noise function.\n//---------------------------------------------------------------\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n//---------------------------------------------------------------\n// @iq fbm generator\nfloat fbm( in vec3 x) {\n    float a = 0.1,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for (int i = 0; i < 4; ++i) {      \n        float n = n3D(f*x);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyGWz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[977, 977, 996, 996, 1040], [1041, 1041, 1060, 1060, 1127], [1128, 1128, 1150, 1150, 1219], [1221, 1231, 1266, 1266, 1342]]}
{"id": "clcXR7", "name": "shiny rings", "author": "fishy", "description": "so... shiny...", "tags": ["raymarching"], "likes": 7, "viewed": 164, "published": 3, "date": "1685389422", "time_retrieved": "2024-07-30T17:53:23.967947", "image_code": "#define FOCAL_LEN 1.\n#define iTime (iTime*5.)\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\n\nvoid join(inout float a, inout marchMat amat, float b, marchMat bmat)\n{\n    if(b < a)\n    {\n        a = b;\n        amat = bmat;\n    }\n}\n\n#define join(a, b) join(d, m, a, b)\n\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l+1.,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec2 p, vec2 b ) // by iq\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nfloat sdBox( vec2 p, vec2 b , float r) // by iq\n{\n    return sdBox(p, b-r)-r;\n}\n\nfloat sdCylinder(vec3 p, vec2 r)\n{\n    return sdBox(vec2(length(p.xz), p.y),r);\n}\n\nfloat sdCylinder(vec3 p, vec2 r, float b)\n{\n    return sdBox(vec2(length(p.xz), p.y),r-b)-b;\n}\n\nfloat sdSquareDonut(vec3 p, float r, vec2 b)\n{\n    return sdBox(vec2(length(p.xz)-r, p.y), b);\n}\n\nfloat sdSquareDonut(vec3 p, float r, vec2 b, float e)\n{\n    return sdBox(vec2(length(p.xz)-r, p.y), b, e);\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nfloat sceneDist(vec3 p, out marchMat m)\n{\n    float scale = 0.02;\n    p /= scale;\n    \n    float d = 1e20;\n    p = rotX(p, iTime*.1);\n    join(sdSquareDonut(p, 50., vec2(3, 5), 0.1), marchMat(vec3(0.9), 0));\n    join(sdSquareDonut(p, 49., vec2(3, 3)), marchMat(vec3(1.), 0));\n    \n    p = rotZ(p, iTime*0.2);\n    join(sdSquareDonut(p, 40., vec2(3, 5), 0.1), marchMat(vec3(0.9), 0));\n    join(sdSquareDonut(p, 39., vec2(3, 3)), marchMat(vec3(1.), 0));\n    \n    p = rotX(p, iTime*0.3);\n    join(sdSquareDonut(p, 30., vec2(3, 5), 0.1), marchMat(vec3(0.9), 0));\n    join(sdSquareDonut(p, 29., vec2(3, 3)), marchMat(vec3(1.), 0));\n    \n    p = rotZ(p, iTime*0.4);\n    join(sdSquareDonut(p, 20., vec2(3, 5), 0.1), marchMat(vec3(0.9), 0));\n    join(sdSquareDonut(p, 19., vec2(3, 3)), marchMat(vec3(1.), 0));\n    \n    p = rotX(p, iTime*0.5);\n    join(sdSquareDonut(p, 10., vec2(3, 5), 0.1), marchMat(vec3(0.9), 0));\n    join(sdSquareDonut(p, 09., vec2(3, 3)), marchMat(vec3(1.), 0));\n    \n    d *= scale;\n    \n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat);\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p ) // by iq\n{\n    float h = 0.001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h);\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, iMouse.z)*3.0;\n\n    vec2 cr = vec2(0.*0.6154729, 0.*0.7853982+iTime*0.) - mouse.yx;\n    vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.*FOCAL_LEN-1.), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    vec3 n = calcNormal(res.pos);\n    float lighting = texture(iChannel0, reflect(rd, n), 2.).r;\n\n    fragColor = sqrt(vec4((mix(vec3(texture(iChannel1, rd).rgb), res.mat.color*lighting, vec3(res.hit))), 1));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcXR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 68, 68, 117], [119, 119, 147, 147, 182], [184, 184, 212, 212, 247], [249, 249, 277, 277, 312], [449, 449, 520, 520, 584], [623, 623, 657, 657, 675], [676, 676, 716, 716, 733], [735, 735, 790, 790, 871], [873, 873, 929, 929, 1027], [1029, 1029, 1089, 1089, 1130], [1132, 1132, 1192, 1192, 1236], [1238, 1238, 1271, 1271, 1297], [1299, 1299, 1339, 1339, 1426], [1428, 1428, 1468, 1468, 1546], [1548, 1548, 1586, 1586, 1616], [1618, 1618, 1667, 1667, 1697], [1699, 1699, 1733, 1733, 1780], [1782, 1782, 1825, 1825, 1876], [1878, 1878, 1924, 1924, 1974], [1976, 1976, 2031, 2031, 2084], [2086, 2086, 2151, 2151, 2263], [2265, 2265, 2306, 2306, 3282], [3284, 3284, 3309, 3309, 3355], [3357, 3357, 3431, 3431, 3812], [3814, 3814, 3853, 3853, 4108], [4110, 4110, 4167, 4167, 4796]]}
{"id": "DlGGDd", "name": "Octree Traversal using SDF", "author": "gelami", "description": "Implicit octree traversal using SDFs to define occupancy of a given cell\n\nThe basic idea is to query the SDF at the cell center, and check if the distance is less than the cell size, if so the cell is occupied\n\nMouse drag to look around\nDefines in Common", "tags": ["3d", "raytracing", "grid", "sdf", "voxel", "box", "octree"], "likes": 87, "viewed": 2723, "published": 3, "date": "1685364913", "time_retrieved": "2024-07-30T17:53:24.932369", "image_code": "\n// Octree Traversal using SDF - gelami\n// https://www.shadertoy.com/view/DlGGDd\n\n/* \n * Implicit octree traversal using SDFs to define occupancy of a given cell\n * \n * The basic idea is to query the SDF at the cell center,\n * and check if the distance is less than the cell size, if so the cell is occupied\n * \n * Mouse drag to look around\n * Defines in Common\n *\n * Probably my slowest shader yet, runs at 30-40 fps/25-33 ms on my GTX 1650 T_T\n * I really wanted to show the big open spaces of the terrain,\n *   but I guess this isn't really the method for that\n * \n * Though another method which might work better is a hybrid SDF/voxel traversal\n * Using sphere tracing for the initial traversal, then switching to voxel traversal\n * when the distance is less than the voxel size, as done in this shader by nimitz:\n * \n * Moon voxels - nimitz\n * https://www.shadertoy.com/view/tdlSR8\n * \n * Another shader that uses an SDF for the octree,\n * but uses a stack-based traversal instead:\n * Voxel Mandelbulb - thorn0906\n * https://www.shadertoy.com/view/3d2XRd\n * \n * This shader introduced me into octree traversal back then\n * Also used their exit condition as I couldn't figure it out v _ v\n * random octree - abje\n * https://www.shadertoy.com/view/4sVfWw\n * \n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-23 12:49:41\n\nvec3 getCameraPos(float t)\n{\n    return vec3(\n        (cos(t * 0.35 * CAMERA_SPEED) + sin(t * 0.25 * CAMERA_SPEED) * 0.5) * 0.55,\n        (sin(t * 0.25 * CAMERA_SPEED) + cos(t * 0.2 * CAMERA_SPEED) * 0.4) * 0.35,\n        t * CAMERA_SPEED);\n}\n\nfloat map(vec3 p, float s)\n{\n    float d = MAX_DIST;\n    \n    float sc = 0.3;\n    \n    vec3 q = sc * p / iChannelResolution[1].xyz;\n    q -= vec3(0.003, -0.006, 0.0);\n    \n    d  = texture(iChannel1, q*1.0).r*0.5;\n    d += texture(iChannel1, q*2.0).r*0.25;\n    d += texture(iChannel1, q*4.0).r*0.125;\n    \n    d = (d/0.875 - SURFACE_FACTOR) / sc;\n    \n    #ifdef TOP_PLANE\n    d = smax(d, p.y - MAX_HEIGHT, 0.3);\n    #endif\n    \n    float c = 0.75 - length(p.xy - getCameraPos(p.z / CAMERA_SPEED).xy);\n    \n    d = smax(d, c, 0.75);\n    \n    //d = min(d, sdBox(p - vec3(1,0,-3), vec3(0.5, 0.2, 0.1)));\n    //d = min(d, length(p - vec3(-2, 0, -4)) - 1.0);\n    \n    return d;\n}\n\nvec3 grad(vec3 p)\n{\n    const float s = exp2(-MAX_LOD);\n    const vec2 e = vec2(0, s);\n    return (map(p, s) - vec3(\n        map(p - e.yxx, s),\n        map(p - e.xyx, s),\n        map(p - e.xxy, s))) / e.y;\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec3 id;\n    float lod;\n    int i;\n};\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, const float tmax)\n{\n    hit.t = tmax;\n    hit.n = vec3(0);\n    hit.i = STEPS;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(ird);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = ro * ird;\n    \n    vec3 id = floor(ro);\n    vec3 pid = id;\n\n    float s = 1.0;\n    float lod = MAX_LOD;\n    vec3 pos = ro;\n    \n    vec3 nrd = vec3(0);\n    float t = 0.0;\n    float minlod = 0.0;\n    \n    bool exit = false;\n    for (int i = 0; i < STEPS; i++)\n    {   \n        if (exit)\n        {\n            id = floor(id*0.5);\n            pid = id;\n            s *= 2.0;\n            lod++;\n            \n            // Thank u abje for the exit condition\n            // random octree - abje\n            // https://www.shadertoy.com/view/4sVfWw\n            exit = abs(dot(mod(id+0.5,2.0)-1.0 + nrd*0.5, abs(nrd))) == 0.0 && lod < MAX_LOD;\n            \n            i--;\n            continue;\n        }\n        \n        vec3 p = (id + 0.5) * s;\n        \n        float d = map(p, s);\n        \n        vec3 n = iro - p * ird;\n        vec3 k = ard * s * 0.5;\n        \n        vec3 t2 = -n + k;\n        \n        float nt = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 npos = ro + rd * nt;\n        \n        if (d * 2.0 < s)\n        {\n            if (lod > minlod)\n            {\n                id *= 2.0;\n                id += step(vec3(0), pos - p);\n                pid = id;\n                \n                s *= 0.5;\n                lod--;\n                continue;\n            } else\n            {\n                hit.t = t;\n                #ifndef ROUNDED_NORMALS\n                hit.n = -nrd;\n                #else\n                float r = s * 0.05;\n                hit.n = sign(pos - p) * normalize(max(abs(pos - p) - vec3((s - r) * 0.5), 0.0));\n                //hit.n *= t2.x <= t2.y && t2.x <= t2.z ? vec3(1, srd.x, srd.x) :\n                //         t2.y <= t2.z ? vec3(srd.y) : vec3(srd.z);\n                #endif\n                hit.id = id;\n                hit.lod = lod;\n                hit.i = i;\n                return true;\n            }\n        }\n        \n        if (nt >= tmax)\n            return false;\n        \n        #ifdef TOP_PLANE\n        if (rd.y > 0.0 && ro.y + rd.y * nt > MAX_HEIGHT)\n            return false;\n        #endif\n        \n        // Change min LOD with distance, doesn't reduce perf much\n        #ifdef DYNAMIC_LOD\n        minlod = clamp(floor(log2(nt * 0.12)), 0.0, MAX_LOD);\n        #endif\n        \n        // Step check with tie break when two components are equal\n        #if 0\n        t2 += vec3(0, EPS, EPS+EPS);\n        nrd = srd * step(t2, t2.yzx) * step(t2, t2.zxy);\n        #else\n        nrd = t2.x <= t2.y && t2.x <= t2.z ? vec3(srd.x,0,0) :\n              t2.y <= t2.z ? vec3(0,srd.y,0) : vec3(0,0,srd.z);\n        #endif\n        \n        pos = npos;\n        t = nt;\n        \n        pid = id;\n        id += nrd;\n        \n        #if 1\n        if (floor(pid*0.5) != floor(id*0.5) && lod < MAX_LOD)\n            exit = true;\n        #endif\n        \n    }\n\n    return false;\n}\n\nvec3 triplanar(sampler2D tex, vec3 p, vec3 n, const float k)\n{\n    n = pow(abs(n), vec3(k));\n    n /= dot(n, vec3(1));\n\n    vec3 col = texture(tex, p.yz).rgb * n.x;\n    col += texture(tex, p.xz).rgb * n.y;\n    col += texture(tex, p.xy).rgb * n.z;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    const float fov = 67.5;\n    const float invTanFov = 1.0 / tan(radians(fov) * 0.5);//1.5;\n    \n    #ifdef MOTION_BLUR\n    float mb = MOTION_BLUR * dot(pv, pv) / invTanFov * hash13(vec3(fragCoord, iFrame));\n    vec3 ro = getCameraPos(iTime + mb);\n    #else\n    vec3 ro = getCameraPos(iTime);\n    #endif\n    vec3 lo = vec3(0,0,-1);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = -m.x * TAU + PI;\n    float ay = -m.y * PI + PI * 0.5;\n    \n    if (iMouse.z > 0.0)\n    {\n        lo.yz *= rot2D(ay);\n        lo.xz *= rot2D(ax);\n        lo += ro;\n    } else\n    {\n        #ifdef MOTION_BLUR\n        lo = getCameraPos(iTime + mb + 0.12);\n        #else\n        lo = getCameraPos(iTime + 0.12);\n        #endif\n    }\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, invTanFov));\n    \n    vec3 col = vec3(0);\n    \n    HitInfo hit;\n    bool isHit = trace(ro, rd, hit, MAX_DIST);\n    \n    vec3 pos = ro + rd * hit.t;\n    vec3 pid = hit.id * exp2(-(MAX_LOD - hit.lod));\n    \n    vec3 n = hit.n;\n    vec3 g = grad(pos);\n    vec3 nv = normalize(grad(pid));\n    float d = map(pos, exp2(-MAX_LOD)) / length(g);\n    \n    vec3 ref = reflect(rd, hit.n);\n    \n    vec3 uvw = 2.0 * (pos - pid) / exp2(-(MAX_LOD - hit.lod));\n    vec2 buv = abs(hit.n.x) * uvw.yz + abs(hit.n.y) * uvw.xz + abs(hit.n.z) * uvw.xy;\n    buv /= dot(abs(hit.n), vec3(1));\n    \n    vec3 id = 0.11*hit.id * exp2(-hit.lod);\n    float k = fract(sin(id.x *0.33)*0.6 + cos(id.y*0.25) * sin(id.z*0.3) - sin(id.z*0.2));\n    \n    vec3 alb = triplanar(iChannel2, 0.15*pid, nv, 4.0);\n    \n    float k2 = sin(id.z *0.09)*0.6 + cos(id.x*0.12) * sin(id.y*0.15) - sin(id.y*0.1);\n    k2 = abs(fract(k2) * 2.0 - 1.0);\n    k2 = 1.0-smoothstep(0.4, 0.8, k2);\n    //k2 = smoothstep(0.0, 1.0, abs(pid.y + 1.0));\n    \n    alb = mix(alb*0.9+0.1, (1.0-alb) * vec3(1, 0.85, 0.75), k2);\n    \n    float tk = triplanar(iChannel3, 0.1*pid, nv, 4.0).r;\n    alb = mix(alb, alb*palette2(k), (1.0-smoothstep(0.05, 0.5, tk)) * 0.8);\n    \n    col = alb;\n    col *= dot(abs(hit.n), vec3(0.8, 1, 0.9));\n    \n    #ifdef VOXEL_NORMALS\n    n = nv;\n    #endif\n    \n    const vec3 lcol = vec3(1, 0.95, 0.9) * 1.8;\n    const vec3 ldir = normalize(vec3(0.85, 1.2, 1));\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + hit.n * EPS, ldir, hitL, 5.0);\n    \n    float dif = max(dot(n, ldir), 0.0) * float(!isHitL);\n    float ao = smoothstep(-0.06, 0.12, d);\n    \n    col *= (dif * 0.6 + 0.4) * lcol;\n    \n    float spot = smoothstep(0.78, 0.96, dot(rd, cmat[2])) * max(dot(-rd, hit.n), 0.0);\n    spot *= 0.8 / (hit.t*hit.t);\n    \n    col += alb * spot * vec3(1, 0.8, 0.6);\n    \n    const float r0 = 0.08;\n    float fre = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, hit.n), 5.0);\n    \n    vec3 refcol = 0.6*sRGBToLinear(texture(iChannel0, ref).rgb) / vec3(1, 0.65, 0.4);\n    \n    col = mix(col, refcol, fre * 0.5 * (k2*0.8+0.2));\n    \n    col *= ao * 0.7 + 0.3;\n    \n    vec3 fogCol = vec3(0.4, 0.65, 1) * 0.12;\n    \n    #ifdef FOG\n    \n    #if 1\n    float fog = 1.0 - exp(-hit.t*hit.t * 0.003);\n    #else\n    const float a = 0.032;\n    const float b = 0.005;\n    float fog = (a / b) * exp(-max(ro.y + 35.0, 0.0) * b) * (1.0 - exp(-hit.t * rd.y * b)) / rd.y;\n    #endif\n    \n    col = mix(col, fogCol, saturate(fog));\n    #endif\n    \n    if (!isHit)\n        col = fogCol;\n    \n    #ifdef SHOW_STEPS\n    #if 0\n    col = vec3(float(hit.i) / float(STEPS));\n    if (fragCoord.y < 10.0)\n        col = vec3(uv.x);\n    #else\n    col = palette(float(hit.i) / float(STEPS));\n    \n    if (fragCoord.y < 10.0)\n        col = palette(uv.x);\n    #endif\n    #endif\n    \n    col = max(col, vec3(0));\n    \n    col = ACESFilm(col * 0.35);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define FOG\n//#define ROUNDED_NORMALS\n//#define TOP_PLANE\n//#define DYNAMIC_LOD\n//#define VOXEL_NORMALS\n\n//#define MOTION_BLUR 0.05\n\n#define SURFACE_FACTOR 0.435\n\n#define CAMERA_SPEED -1.35\n\n#ifdef TOP_PLANE\n#define MAX_HEIGHT 10.0\n#endif\n\n#define MAX_LOD 4.0\n\n//#define SHOW_STEPS\n\n#define STEPS 512\n#define MAX_DIST 35.0\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nfloat sdBox( in vec3 p, in vec3 rad )\n{\n    p = abs(p) - rad;\n    return max(max(p.x, p.y), p.z);\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return .45 + .55 * cos(TAU * (vec3(1, 0.8, 0.6) * t + vec3(0, 0.3, 0.5)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvec3 ReinhardExtLuma(vec3 col, const float w)\n{\n    float l = luminance(col);\n    float n = l * (1.0 + l / (w * w));\n    float ln = n / (1.0 + l);\n    return col * ln / l;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlGGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1377, 1377, 1405, 1405, 1618], [1620, 1620, 1648, 1648, 2295], [2297, 2297, 2316, 2316, 2504], [2591, 2591, 2656, 2656, 5642], [5644, 5644, 5706, 5706, 5913], [5915, 5915, 5972, 5972, 9895]]}
{"id": "mttSD8", "name": " Ray tracer - Mik0", "author": "Mik0", "description": "Monte carlo ray tracer with tonemapping, gamma correct rendering, and caustics.", "tags": ["raytracing"], "likes": 2, "viewed": 315, "published": 3, "date": "1685362159", "time_retrieved": "2024-07-30T17:53:25.883826", "image_code": "#define halfpi acos(0.0)\n#define pi (acos(0.0)*2.0)\n#define tau (acos(0.0)*4.0)\n#define constant (180.0/pi)\n#define PHI ((sqrt(5.0)+1.0)/2.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvn = fragCoord/iResolution.xy;\n\n    \n    vec3 col = texture(iChannel0, uvn).xyz;//float(iFrame+1);\n    col = col/(col+1.0);\n    \n    float gamma = 1.5;\n    \n    col.x = pow(col.x, 1.0/gamma);\n    col.y = pow(col.y, 1.0/gamma);\n    col.z = pow(col.z, 1.0/gamma);\n\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define halfpi acos(0.0)\n#define pi (acos(0.0)*2.0)\n#define tau (acos(0.0)*4.0)\n#define constant (180.0/pi)\n#define PHI ((sqrt(5.0)+1.0)/2.0)\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct HitInfo\n{\n    vec3 color;\n    vec3 normal;\n    float roughness;\n    float t;\n    bool hit;\n};\n\nstruct Sphere\n{\n    vec3 ce;\n    float ra;\n    vec3 color;\n    float roughness;\n};\n\nRay cam(vec3 pos, vec2 turn, float zoom, vec2 uv)\n{\n    vec3 dir = vec3(sin(turn.x)*cos(turn.y), cos(turn.x)*cos(turn.y), sin(turn.y));\n    \n    vec3 up = vec3(sin(turn.x)*cos(turn.y+halfpi), cos(turn.x)*cos(turn.y+halfpi), sin(turn.y+halfpi));\n    \n    vec3 right = vec3(sin(turn.x+halfpi), cos(turn.x+halfpi), 0);\n    \n    vec3 p = (dir*zoom)+(up*uv.y)+(right*uv.x);\n    \n    return Ray(pos, normalize(p));\n}\n\nHitInfo sphere( Ray ray, Sphere sphere)\n\n{\n\n    vec3 oc = ray.origin - sphere.ce;\n\n    float b = dot( oc, ray.dir );\n\n    float c = dot( oc, oc ) - sphere.ra*sphere.ra;\n\n    float h = b*b - c;\n    \n    bool hit = true;\n\n    if( h<0.0 ) {hit = false; h = 0.0;} // no intersection\n\n    h = sqrt( h );\n    \n    float t = -b-h;\n    if(t<=0.0)\n    {\n        hit=false;\n    }\n    vec3 hitPos = ray.origin+(ray.dir*t);\n    vec3 normal = normalize(hitPos-sphere.ce);\n\n    return HitInfo(sphere.color, normal, sphere.roughness, t, hit);\n\n}\n\n\nvec3 hemisphere(vec3 normal, vec2 uv, float seed)\n{\n    int points = 100000;\n    int i = int(rand(vec3(uv.x, uv.y, seed))*float(points));\n    float dist = float(i)/float(points);\n    float angle = float(i)*pi*PHI;\n    vec3 p = vec3(sin(acos(1.0-(2.0*dist)))*cos(angle), sin(acos(1.0-(2.0*dist)))*sin(angle), 1.0-(2.0*dist));\n    //if(dot(p, normal)<0.0){p = -p;}\n    return normalize(p+normal);\n}\n\n\n\nHitInfo ClosestCollision(Ray ray)\n{\n    const int sphereNum = 3;\n    float speed = 0.1;\n    Sphere spheres[sphereNum] = Sphere[sphereNum](Sphere(vec3(-cos(iTime*speed), -sin(iTime*speed), 0), 1.0, vec3(1, 0.3, 0.3), 1.0), Sphere(vec3(cos(iTime*speed), sin(iTime*speed), 0), 1.0, vec3(0.3, 1.0, 0.3), 1.0), Sphere(vec3(0, 0, sqrt(3.0)), 1.0, vec3(1.0, 1.0, 1.0), 0.0));\n    \n    HitInfo closestHit;\n    closestHit.t = 999999999999.0;\n    \n    for(int i = 0; i<sphereNum; i++)\n    {\n        Sphere s = spheres[i];\n        HitInfo hitInfo = sphere(ray, s);\n        \n        if(hitInfo.hit && hitInfo.t<closestHit.t)\n        {\n            closestHit = hitInfo;\n        }\n    }\n    \n    return closestHit;\n}\n\nvec3 sky(Ray ray, vec2 dir, vec3 col, float brightness, float angle)\n{\n    dir/=constant;\n    //return col*clamp(float(dot(vec3(sin(dir.x)*cos(dir.y), cos(dir.x)*cos(dir.y), sin(dir.y)), ray.dir)>angle)*dot(vec3(sin(dir.x)*cos(dir.y), cos(dir.x)*cos(dir.y), sin(dir.y)), ray.dir), 0.0, 1.0)*brightness;\n    vec4 o = texture(iChannel1, vec3(ray.dir.y, ray.dir.z, ray.dir.x));\n    return (o.xyz*o.xyz*o.xyz)*brightness*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int samplesPerFrame = int(1.0/iTimeDelta);\n    vec3 totalCol = vec3(0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvn = fragCoord/iResolution.xy;\n    vec2 uv = uvn-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    for(int sampl = 0; sampl<samplesPerFrame; sampl++)\n    {\n\n        Ray ray = cam(vec3(sin(-iTime)*-6.0, cos(-iTime)*-6.0, 1), vec2(-iTime*constant, 0)/constant, 1.0, uv+((vec2( rand(uv.x+float(sampl*2)), rand(uv.y-float(sampl*5)) )-0.5)/iResolution.xy) );\n    \n        vec3 col = vec3(1, 1, 1);\n        float brightness = 1.0;\n    \n        int bounces = 8;\n    \n        for(int i = 0; i<bounces; i++)\n        {\n            HitInfo hitInfo = ClosestCollision(ray);\n        \n    \n    \n            if(hitInfo.hit)\n            {\n                col *= hitInfo.color*brightness;\n                if(i==bounces-1){col*=0.0;}\n            }\n            else\n            {\n                col *= sky(ray, vec2(iTime*halfpi*halfpi, iTime*5.0), vec3(1,1,1), 4.0, 0.0);\n                col *= brightness;\n                break;\n            }\n            Ray reflection = Ray(ray.origin+(ray.dir*hitInfo.t), (hemisphere(hitInfo.normal, fragCoord.xy/29.54, fract(float(iFrame*(sampl+1))/(6.0*pi*PHI))+1.0)*hitInfo.roughness) + (reflect(ray.dir, hitInfo.normal)*(1.0-hitInfo.roughness)));\n            ray = reflection;\n            //brightness = clamp((dot(hitInfo.normal, reflection.dir)*(hitInfo.roughness)) + (1.0-hitInfo.roughness), 0.0, 1.0);\n            brightness = 1.0;\n        }\n        totalCol += col;\n    }\n    // Output to screen\n    fragColor = vec4((totalCol/float(samplesPerFrame)),1.0);//+texture(iChannel0,  uvn);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float rand(float co) { return fract(sin(co*(91.3458)) * 473.55653); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 458.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttSD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 200, 250, 584]]}
{"id": "dltXD8", "name": "Interactive Objects", "author": "SnoopethDuckDuck", "description": "Controls: \nQ/E changes object type (grab, point, line, orbit points)\nZ undoes last action\nClick on screen/objects to place and grab them (orbit points can't be placed on orbit points)", "tags": ["game", "interactive", "line", "point", "placement"], "likes": 9, "viewed": 234, "published": 3, "date": "1685362056", "time_retrieved": "2024-07-30T17:53:26.970919", "image_code": "// time\nfloat t;\n\n// Motivation:\n// I wanted to make an interactive kinematics placement program so you\n// could make something like this by hand:\n// https://www.shadertoy.com/view/cltXzN\n// More complicated objects require chains of references to other objects,\n// so I've given up on it for now\n\nvoid drawObj(inout vec3 col, vec2 uv, float i) {\n    vec4 obj = cell(ch0, vec2(i, 0));\n    vec2 p = (obj.xy - 0.5 * res) / res.y;\n    if (obj.w == 1.) { // Point (x, y, 0, 1)\n        float d = length(uv - p);\n        float s = ss(1., thick[1] - d);\n        col = mix(col, vec3(1), s);\n    } else if (obj.w == 2.) { // Line (start, end, 0, 2)\n        vec2 start = getPosition(obj.x);\n        vec2 end   = getPosition(obj.y);\n        start = (start.xy - 0.5 * res) / res.y;\n        end   = (end.xy   - 0.5 * res) / res.y;\n        vec2 dir = 1.5 * thick[1] * normalize(end - start);\n        float d = seg(uv, start + dir, end - dir);\n        float s = ss(1., thick[2] - d);\n        col = mix(col, vec3(1, 0, 0), s);\n    } else if (obj.w == 3.) { // Orbit point (start, angle, radius, 3)\n        vec2 start = cell(ch0, vec2(obj.x, 0) + 0.5).xy;\n        vec2 p = start + Dir(obj.y + t) * obj.z;\n        p = (p - 0.5 * res) / res.y;\n        float d = length(uv - p);\n        float s = ss(1., thick[1] - d);\n        col = mix(col, vec3(1, 1, 0), s);\n    } else if (obj.w == 4.) { // Orbit point (reverse) \n        vec2 start = cell(ch0, vec2(obj.x, 0) + 0.5).xy;\n        vec2 p = start + Dir(obj.y - t) * obj.z;\n        p = (p - 0.5 * res) / res.y;\n        float d = length(uv - p);\n        float s = ss(1., thick[1] - d);\n        col = mix(col, vec3(1, 0, 1), s);\n    }\n}\n\nvoid drawObjIndicator(inout vec3 col, vec2 uv, float objType) {\n    float r = 0.1;\n    uv -= (0.5 * res / res.y - r - 0.03) * vec2(-1, 1);\n    \n    float opacity = 0.9;\n    \n    // Draw box\n    float dBox = box(uv, vec2(r));\n    float sBox = ss(1., 0.01 - abs(0.01 - dBox));\n    col = mix(col, vec3(1), 0.5 * sBox);\n    \n    // Draw object indicator\n    if (objType == 0.) { // Grab\n        vec2 v = vec2(-1, 1) * 0.032;\n        float d1 = seg(uv, v.xx, v.yy);\n        float d2 = seg(uv, v.xy, v.yx);\n        float s = ss(1., 0.01 - min(d1, d2));\n        col = mix(col, vec3(0.8), opacity * s);\n    } else if (objType == 1.) { // Point\n        float d = length(uv);\n        float s = ss(1., 0.02 - d);\n        col = mix(col, vec3(1), opacity * s);\n    } else if (objType == 2.) { // Line\n        float d = seg(uv, vec2(-0.06), vec2(0.06));\n        float s = ss(1., 0.008 - d);\n        col = mix(col, vec3(1, 0, 0), opacity * s);\n    } else if (objType == 3.) { // Orbit point\n        vec2 p = 0.06 * Dir(3. * iTime);\n        float d = length(uv);\n        float dp = length(uv - p);\n        float s = ss(1., 0.005 - abs(0.04 - d));\n        float sp = ss(1., 0.01 - dp);\n        col = mix(col, vec3(1), opacity * s);\n        col = mix(col, vec3(1, 1, 0), opacity * sp);\n    } else if (objType == 4.) { // Orbit point (reverse)\n        vec2 p = 0.06 * Dir(-3. * iTime);\n        float d = length(uv);\n        float dp = length(uv - p);\n        float s = ss(1., 0.005 - abs(0.04 - d));\n        float sp = ss(1., 0.01 - dp);\n        col = mix(col, vec3(1), opacity * s);\n        col = mix(col, vec3(1, 0, 1), opacity * sp);\n    }\n}\n\nvoid drawCursor(inout vec3 col, vec2 uv, vec2 ms) {\n    float d = abs(0.015 - length(uv - ms));\n    float s  = ss(1., 0.009 - d);\n    float s2 = ss(1., 0.003 - d);\n    vec3 colCursor = mix(vec3(s), vec3(0), s2);\n    col = mix(col, colCursor, 0.5 * s);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ms = (iMouse.xy - 0.5 * res) / res.y;\n    \n    float lastIndex = cell(ch0, pxIndex).r;  \n    float objType = cell(ch0,pxObjType).x;\n    \n    t = spd * iTime;   \n    // Pause time when placing non-lines\n    if (iMouse.w <= 0. && iMouse.z > 0. && objType != 2.)\n        t = 0.;\n    \n    vec3 col = vec3(0);\n\n    // Draw line from mouse to closest object\n    float index = getClosestIndex(iMouse.xy, 100.);\n    vec2 q = getPosition(index);\n    q = (q - 0.5 * res) / res.y;\n    float d = seg(uv, ms, q);\n    float s = ss(1., 0.005 - d);\n    col = mix(col, vec3(1), 0.35 * s);\n    \n    // Draw objects\n    for (float i = 0.; i < lastIndex; i++) \n        drawObj(col, uv, i);\n       \n    // Highlight objects when mouse is close to them\n    /*\n    for (float i = 0.; i < lastIndex; i++) {\n        vec2 p = (obj.xy - 0.5 * res) / res.y;\n        float d = length(uv - p);\n        float dMs = length(ms - p);\n        if (dMs <= thick[1]) {\n            float s = ss(1., thick[1] - 0.008 - d);\n            col = mix(col, vec3(0), s);\n        }\n    } //*/\n    \n    drawObjIndicator(col, uv, objType);\n    drawCursor(col, uv, ms);\n\n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define res iResolution.xy\n#define pi 3.14159\n#define dot2(a) dot(a,a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ss(a, b) smoothstep(-a/res.y, a/res.y, b)\n\n#define cell(ch, p) texelFetch(ch, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\n// Speed time runs at (maybe remove)\n#define spd 1.\n\n// Empty, point, line thickness (change to array if using more objects)\n#define thick vec4(0, 0.02, 0.005, 0)\n\n#define pxIndex     vec2(0, res.y - 1.) + 0.5\n#define pxObjType   vec2(0, res.y - 2.) + 0.5\n#define pxGrab      vec2(0, res.y - 3.) + 0.5\n#define pxMouseDown vec2(0, res.y - 4.) + 0.5\n#define pxTempJoin  vec2(0, res.y - 5.) + 0.5\n\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_Z 90\n#define KEY_R 82\n\n// SDFs\nfloat box(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Object code (using macros because Common tab hates everything)\n#define getPosition(index) getPosition0(ch0, index, spd * t)\nvec2 getPosition0(sampler2D ch, float index, float time) {\n    vec4 obj = cell(ch, vec2(index, 0));\n    if (obj.w == 1.) // Point\n        return obj.xy;\n    if (obj.w == 3.) { // Orbit point\n        vec2 start = cell(ch, vec2(obj.x, 0)).xy;\n        return start + Dir(obj.y + time) * obj.z;\n    }\n    if (obj.w == 4.) { // Orbit point (reverse)\n        vec2 start = cell(ch, vec2(obj.x, 0)).xy;\n        return start + Dir(obj.y - time) * obj.z;\n    }\n    return vec2(-1);\n}\n\n#define getClosestIndex(p, lastIndex) getClosestIndex0(ch0, res.x, t, p, lastIndex)\nfloat getClosestIndex0(sampler2D ch, float resx, float time, vec2 p, float lastIndex) {\n    float d = 4. * resx * resx;\n    float objIndex = -1.;\n    for (float i = 0.; i < lastIndex; i++) {\n        vec2 q = getPosition0(ch, i, time);\n        if (q == vec2(-1)) \n            continue;\n            \n        float d0 = dot2(p - q);\n        if (d0 < d) {\n            d = d0;\n            objIndex = i;\n        }\n    }\n    return objIndex;\n}\n\n// Hash\nfloat h11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}", "buffer_a_code": "// time\nfloat t;\n\nbool key_pressed(int key) {\n    return int(texelFetch(ch1, ivec2(key, 1), 0).x) == 1;\n}\n\n/*\nfloat getClosestLineIndex(vec2 ms, float lastIndex) {\n    float d = 4. * res.x * res.x;\n    float objIndex = -1.;\n    for (float i = 0.; i < lastIndex; i++) {\n        vec4 obj = cell(ch0, vec2(i, 0));\n        vec2 q = getPosition(i);\n        if (obj.w == 2.) {\n            vec2 start = getPosition(obj.x);\n            vec2 end = getPosition(obj.y);\n            //vec2 q = 0.5 * (start + end);\n            float d0 = seg(ms, start, end);\n            if (d0 < d) {\n                d = d0;\n                objIndex = i;\n            }          \n        }\n    }\n    return objIndex;\n}\n//*/\n\nvoid setGrabObject(inout vec4 O, vec2 px, vec2 ms, float index) {\n    if (px == pxGrab) {\n        float objIndex = getClosestIndex(ms, index);\n        vec2 objPos = getPosition(objIndex).xy;\n        if (objPos != vec2(-1)) {\n            vec2 objUv = (objPos - 0.5 * res) / res.y;\n            vec2 msUv = (ms - 0.5 * res) / res.y;\n            // if mouse is close to object, grab it\n            if (dot2(objUv - msUv) < 6. * thick[1] * thick[1])\n                O.x = objIndex;\n        }\n    }\n}\n// This code is very similar to objection creation code.\n// Could reuse it\nvoid moveGrabObject(inout vec4 O, vec2 px, vec2 ms, float grabIndex) {\n    if (px == vec2(grabIndex, 0) + 0.5) {\n      vec4 obj = cell(ch0, vec2(grabIndex, 0));\n      if (obj.w == 1.) // Point\n          O.xy = ms;\n      else if (obj.w == 3. || obj.w == 4.) { // Orbit points\n          vec4 startObj = cell(ch0, vec2(obj.x, 0));\n          vec2 dir = ms - startObj.xy;\n          float angle = atan(dir.y, dir.x);\n          float radius = length(dir);\n          O.yz = vec2(angle, radius);\n      }\n    }\n}\nvoid releaseGrabObject(inout vec4 O, vec2 px) {\n    if (px == pxGrab) \n        O.x = -1.;\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 ms = iMouse.xy;\n\n    float lastIndex    = cell(ch0, pxIndex).x;\n    float objType      = cell(ch0, pxObjType).x;\n    float grabIndex    = cell(ch0, pxGrab).x;\n    float wasMouseDown = cell(ch0, pxMouseDown).x;\n    \n    t = iTime;\n    if (iMouse.w <= 0. && iMouse.z > 0. && objType != 2.)\n        t = 0.;\n    \n    // Read buffer, and initialize buffer on 1st frame\n    O = (iFrame > 1) ? cell(ch0, ivec2(px)) : vec4(0);\n   \n    // Toggle object type\n    if (px == pxObjType) {\n        if (key_pressed(KEY_E)) \n            O.x = mod(O.x + 1., 5.);\n        else if (key_pressed(KEY_Q))\n            O.x = mod(O.x - 1., 5.);\n    }\n    \n    // Delete last object\n    if (key_pressed(KEY_Z)) {\n        if (px == pxIndex)\n            O.x = max(0., O.x - 1.);\n        else if (px == vec2(lastIndex, 0) + 0.5)\n            O = vec4(0);\n    }\n    \n    // Was mouse down last frame\n    if (px == pxMouseDown) \n        O.x = (iMouse.z > 0.) ? 1. : 0.;\n    \n    // Reset\n    // if (key_pressed(KEY_R)) \n    //     O = vec4(0);\n       \n   \n    // -- Mouse interaction and object placement --\n    \n    // Grab\n    if (objType == 0.) { \n        if (iMouse.w > 0.)           setGrabObject(O, px, ms, lastIndex);\n        else if (iMouse.z > 0.)      moveGrabObject(O, px, ms, grabIndex);\n        else if (wasMouseDown == 1.) releaseGrabObject(O, px);\n    } \n    // Point (x, y, 0, objType)\n    else if (objType == 1.) {\n        if (iMouse.w > 0.) {\n            if (px == pxIndex) \n                O.x = lastIndex + 1.;\n            else if (px == vec2(lastIndex, 0) + 0.5)\n                O = vec4(ms, 0, objType);    \n        } \n    } \n    // Line (startIndex, endIndex, 0, objType)\n    else if (objType == 2.) { \n        if (iMouse.w > 0.) {\n            float startIndex = getClosestIndex(ms, lastIndex);\n            if (startIndex != -1.) {\n                if (px == pxIndex) \n                    O.x = lastIndex + 1.;\n                else if (px == vec2(lastIndex, 0) + 0.5)\n                    O = vec4(startIndex, startIndex, 0, objType);\n            }\n        } else if (iMouse.z > 0.) {\n            float endIndex = getClosestIndex(ms, lastIndex);\n            if (endIndex != -1. && px == vec2(lastIndex - 1., 0) + 0.5)\n                 O.y = endIndex;\n        }     \n    } \n    // Orbit point (startIndex, 0, 0, objType)\n    else if (objType == 3. || objType == 4.) { \n        if (iMouse.w > 0.) {\n            float startIndex = getClosestIndex(ms, lastIndex);\n            if (startIndex != -1.) {\n                vec4 startObj = cell(ch0, vec2(startIndex, 0));\n                float angle = 0.;\n                float radius = length(ms - startObj.xy);\n                if (px == pxIndex) \n                    O.x = lastIndex + 1.;\n                else if (px == vec2(lastIndex, 0) + 0.5)\n                    O = vec4(startIndex, angle, radius, objType);\n            }\n        } else if (iMouse.z > 0.) {\n            vec4 orbitObj = cell(ch0, vec2(lastIndex - 1., 0));\n            vec4 startObj = cell(ch0, vec2(orbitObj.x, 0));\n            vec2 dir = ms - startObj.xy;\n            float angle = atan(dir.y, dir.x);\n            float radius = length(dir);\n            if (px == vec2(lastIndex - 1., 0) + 0.5)\n                O.yz = vec2(angle, radius);\n        }\n    } \n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltXD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 346, 346, 1663], [1665, 1665, 1728, 1728, 3290], [3292, 3292, 3343, 3343, 3545], [3547, 3547, 3589, 3589, 4781]]}
{"id": "mtdSDr", "name": "PBR Path tracer attempt 6", "author": "pathtracerenthusiast", "description": ".", "tags": ["pathtracer"], "likes": 0, "viewed": 191, "published": 3, "date": "1685361448", "time_retrieved": "2024-07-30T17:53:27.920380", "image_code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings, go to the 'Buffer B' tab.\n//To set or remove the maximum number of frames or objects go to the 'Common' tab.\n\n//#define Bloom\n\n#define exposure .8\n\n//I used the Bing AI to improve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  float n = 1./float(2*w*w);\n  const float invpi = 1./PI;\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      float weight = n*invpi*exp(-float(x*x+y*y)*n);\n      //float weight = 1.;\n      color += texture(s, uv).xyz*weight;\n    }\n  }\n  return color;\n}\n\n#define size 2.75*((R.x+R.y)*.00119048)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    vec2 p = R-10.;\n    #ifdef maxFrame\n    if(i.x>=p.x&&i.y>=p.y&&iFrame>maxFrame){o=vec4(1.);return;}\n    #endif\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    #ifdef Bloom\n    #ifdef maxFrame\n    if(iFrame>=maxFrame)\n    #endif\n    o.xyz += blur(iChannel1,i/R,int(size));\n    #endif\n    \n    \n    o.xyz *= exposure;\n    \n    o.xyz = ACESFilm(o.xyz);\n    o.xyz = linearToSRGB(o.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define maxFrame 256\n\n#define R iResolution.xy\n#define PI 3.1415926523\n#define d2r(a) a*(PI/180.)\n#define md(a,b) max(0.,dot(a,b))\n\nfloat _seed;\n// Thanks to Dave_Hoskin for the random numbers\nfloat rand(){\n    float v = fract(_seed*.1031);\n    v *= _seed + 33.33;\n    v *= _seed + _seed;\n    v += 34.35;\n    float a = fract(v);\n    _seed++;\n    _seed *= 2.*a;\n    return a;\n}\n\nvec2 rand2(){\n    vec3 p = fract(_seed*vec3(.1031,.103,.0973));\n    p += dot(p,p.yzx+33.33);\n    vec2 a = fract((p.xx+p.yz)*p.zy);\n    _seed++;\n    _seed *= a.x+a.y;\n    return a;\n}\n\nvoid irand(vec2 i,float t){\n    vec3 p = vec3(i.y,t,i.x);\n    p = fract(p*.1031);\n    p += dot(p,p.zyx+32.31);\n    _seed = fract((p.x+p.y)*p.z);\n}\n\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\n\n\nstruct Mat {\n    float r;\n    float m;\n    vec3 col;\n    vec3 ems;\n    float IOR;\n    float scatDens;\n};\n\n\nstruct AABB {\n    vec3 minv,maxv;\n};\n\nstruct SphBody {\n    vec3 c;\n    float rad;\n    bool isActive;\n};\n\nstruct BoxBody {\n    vec3 pos,size,rot;\n    bool inverted, isActive;\n};\n\nstruct QuadBody {\n    vec3 v0,v1,v2,v3;\n    bool fn, isActive;\n};\n\nstruct Obj {\n    SphBody sph;\n    BoxBody box;\n    QuadBody quad;\n    Mat mat;\n    AABB bound;\n};\n\nstruct BVHNode {\n    AABB bound;\n    uint left,right;\n};\n\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct NewHit {\n    float len;\n    vec3 nor;\n    Obj o;\n    bool ff;\n};\n\nstruct IntRes {\n    float len;\n    bool ff;\n};\n\n#define DefaultSph SphBody(vec3(0.),0.,false)\n#define DefaultBox BoxBody(vec3(0.),vec3(0.),vec3(0.),false,false)\n#define DefaultQuad QuadBody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),false,false)\n\n#define objC 9\nstruct NewWorld {\n    Obj objs[objC];\n    Viewer camera;\n};\n\nObj Obj_Sphere(vec3 pos,float rad,Mat m){\n    AABB bound = AABB(pos-rad-.0001,pos+rad+.0001);\n    return Obj(SphBody(pos,rad,true),DefaultBox,DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowSphere(vec3 pos,float rad,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Sphere(pos,rad,m);\n    objlst[idx1] = Obj_Sphere(pos,thickness-rad,m);\n}\n\nObj Obj_Box(vec3 pos,vec3 size,vec3 rot,Mat m){\n    AABB bound = AABB(pos-2.*size-.001,pos+2.*size+.0001);\n    return Obj(DefaultSph,BoxBody(pos,size,rot,false,true),DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowBox(vec3 pos,vec3 size,vec3 rot,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Box(pos,size,rot,m);\n    AABB bound = AABB(pos-2.*abs(size)-.001+thickness,pos+2.*abs(size)+.0001-thickness);\n    objlst[idx1] = Obj(DefaultSph,BoxBody(pos,size-thickness,rot,true,true),DefaultQuad,m,bound);\n}\n\nObj Obj_Quad(vec3 v0,vec3 v1,vec3 v2,vec3 v3,bool fn,Mat m){\n    vec3 minv = min(min(v0,v1),min(v2,v3));\n    vec3 maxv = max(max(v0,v1),max(v2,v3));\n    AABB bound = AABB(minv,maxv);\n    return Obj(DefaultSph,DefaultBox,QuadBody(v0,v1,v2,v3,fn,true),m,bound);\n}\n\nIntRes newSphereInt( in vec3 ro, vec3 rd, SphBody sph) {\n    ro -= sph.c;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sph.rad*sph.rad;\n    float h = b*b - c;\n    if( h<0. ) return IntRes(-1.,false);\n    h = sqrt( h );\n    if(length(ro)<=sph.rad){\n        return IntRes(-b+h,false);\n    }else{\n        return IntRes(-b-h,true);\n    }\n}\n\nbool insideAabb(vec3 p,vec3 s){\n    return (p.x<=s.x&&p.x>=-s.x)&&(p.y<=s.y&&p.y>=-s.y)&&(p.z<=s.z&&p.z>=-s.z);\n}\n\nIntRes newBoxInt( in vec3 ro, in vec3 rd, BoxBody box) {\n    mat3 r = rot3(-box.rot);\n    \n    ro *= r; rd *= r;\n    ro -= box.pos;\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*abs(box.size);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return IntRes(-1.,false);\n    if(insideAabb(ro,abs(box.size))){\n        return IntRes(tF,box.inverted);\n    }else{\n        return IntRes(tN,!box.inverted);\n    }\n}\n\nfloat newQuadInt(vec3 ro,vec3 rd,QuadBody q){\n    vec3 n = cross(q.v1-q.v0,q.v2-q.v0);\n    float d = dot(n, q.v0);\n    \n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    return -1.;\n}\n\nbool aabbInt(in vec3 ro,vec3 rd,AABB box){\n    vec3 a = .5*(box.maxv+box.minv);\n    vec3 d = .5*(box.maxv-box.minv);\n    vec3 m = 1./rd;\n    vec3 n = m*(ro-a); \n    vec3 k = abs(m)*d;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return false;\n    return true;\n}\n\n\n\nconst float bias = 1.0001;\nvec3 newBoxNor(vec3 p,BoxBody b){\n    vec3 q = p-b.pos;\n    vec3 d = b.size;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 cosDir2(vec3 N){\n    float u1 = rand(),u2 = rand(),\n    r = sqrt(1.-u1*u1),\n    phi = 2.*PI*u2;\n    vec3 dir = vec3(\n    cos(phi)*r,\n    sin(phi)*r,\n    u1\n    );\n    \n    vec3 up = N.z<1.?vec3(0.,0.,1.):vec3(0.,1.,0.),\n    tangent = normalize(cross(up,N)),\n    bitangent = cross(N,tangent);\n    \n    return tangent*dir.x +\n    bitangent*dir.y +\n    N*dir.z;\n} \nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float z = rand()*2.-1.;\n    float r = sqrt(1.-z*z);\n    float x = r*cos(phi), y = r*sin(phi);\n\treturn vec3(x,y,z);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nvec3 clip(vec3 N,vec3 D){\n    return normalize(N+2.*D*abs(dot(N,-D)));\n}\nvec3 hemi(vec3 h){\n    return clip(uniformVec(),-h);\n}\n\n\nvec3 LessThan(vec3 f, float val) {\n    return vec3(\n        (f.x < val) ? 1. : 0.,\n        (f.y < val) ? 1. : 0.,\n        (f.z < val) ? 1. : 0.);\n}\n \nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - .055,\n        rgb * 12.92,\n        LessThan(rgb, .0031308)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(((rgb + .055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        LessThan(rgb, 0.04045)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0., 1.);\n}\n\nvec3 importanceGGX(float r,vec3 N){\n    float a2 = r*r*r*r,\n    phi = 2.*PI*rand(),\n    u2 = rand(),\n    cosT = sqrt((1.-u2)/(1.+(a2-1.)*u2)),\n    sinT = sqrt(1.-cosT*cosT);\n    \n    vec3 H = vec3(\n    cos(phi)*sinT,\n    sin(phi)*sinT,\n    cosT),\n    \n    up = abs(N.z)<.999?vec3(0.,0.,1.):vec3(1.,0.,0.),\n    tangent = normalize(cross(up,N)),\n    bitangent = cross(N,tangent);\n    \n    return normalize(H.x*tangent+H.y*bitangent+H.z*N);\n    \n}", "buffer_a_code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n#define shutAp .6\n#define fcsDist 4.5\n#define blurAmt .001\n#define numLvls 8\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\n#define SkyMode 2\n#define airDens .0001\nconst float mode = 0.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\n\n\n//NOTE: Component order:\n// - Roughness [0,1]\n// - Metalness [0,1]\n// - Diffuse Color (Color)\n// - Emmissive Color (Color)\n// - IOR {>1}\n\n//NOTE: Diffuse occurs if you set the -§density§- higher,\n//make it rougher, lower the IOR on a dielectric.\n\nNewWorld getNewWorld(float t){\n    NewWorld world;\n    Viewer cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(.5,2.25,-3.));\n    \n    mat2 rx = rot(d2r(-20.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(-5.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(0.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.objs[0] = Obj_Sphere(vec3(0.,-27.001,0.),25.,Mat(.9,1.,vec3(.3,.5,1.),vec3(0.),1.2,.2));\n    //createObj_HollowSphere(vec3(-1.5,-.5,3.),1.5,.4,1,8,Mat(.2,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false),world.objs);\n    world.objs[1] = Obj_Sphere(vec3(-1.5,-.5,3.),1.5,Mat(.1,0.,vec3(1.),vec3(0.),1.5,.005));\n    world.objs[2] = Obj_Sphere(vec3(1.5,-1.,2.),1.,Mat(.9,0.,vec3(.8),vec3(0.),1.5,0.));\n    world.objs[3] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(3.5,-2.,-2.),vec3(3.5,-2.,3.5),vec3(-3.5,-2.,3.5),true,Mat(.75,.75,vec3(1.),vec3(0.),1.5,.0025));\n    world.objs[4] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(-3.5,1.5,-2.),vec3(-3.5,1.5,3.5),vec3(-3.5,-2.,3.5),false,Mat(.5,.5,vec3(1.,.1,.1),vec3(0.),1.5,.005));\n    world.objs[5] = Obj_Quad(vec3(3.5,-2.,-2.),vec3(3.5,1.5,-2.),vec3(3.5,1.5,3.5),vec3(3.5,-2.,3.5),true,Mat(.25,.25,vec3(.1,1.,.1),vec3(0.),1.5,.0075));\n    //world.objs[6] = Obj_Quad(vec3(-3.5,5.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(-3.5,5.,3.5),false,Mat(0.,1.52,vec3(1.),vec3(0.),.5,vec3(1.),0.,vec3(1.)));\n    world.objs[7] = Obj_Box(vec3(0.,4.,.75),vec3(1.5,.5,1.5),d2r(vec3(0.)),Mat(.5,0.,vec3(.75,.775,.9),vec3(10.),1.5,0.));\n    world.objs[8] = Obj_Box(vec3(0.,-1.,-.75),vec3(1.),d2r(vec3(0.)),Mat(.1,1.,vec3(1.),vec3(0.),1.5,0.));\n    //TODO: Generate bounding boxes\n    \n    \n    world.camera = cam;\n    return world;\n}\n\nNewHit newInt(vec3 ro,vec3 rd,Obj objs[objC]){\n    NewHit h;\n    h.len = -1.;\n    \n    for(int i = 0; i < objC; i++) {\n        Obj o = objs[i];\n        //if(!aabbInt(ro,rd,o.bound)) continue;\n        if(o.sph.isActive) {IntRes res = newSphereInt(ro,rd,o.sph);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.box.isActive) {IntRes res = newBoxInt(ro,rd,o.box);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.quad.isActive) {float res = newQuadInt(ro,rd,o.quad);if(res>=.0001&&(res<h.len||h.len<0.)){h.o=o;h.ff=true;h.len=res;}}\n    }\n    \n    Obj o = h.o;\n    vec3 p = ro+rd*h.len;\n    \n    if(o.sph.isActive) h.nor = normalize(p-o.sph.c);//*sign(o.sph.rad);\n    else if(o.box.isActive) {BoxBody b = o.box;mat3 r = rot3(b.rot);mat3 rn = rot3(-b.rot);h.nor = newBoxNor(b.pos+(p-b.pos)*rn,b)*r;}\n    else if(o.quad.isActive) {QuadBody q = o.quad;h.nor = normalize(cross(q.v1-q.v0,q.v2-q.v0))*(q.fn?-1.:1.);}\n    \n    //h.nor *= h.ff?1.:-1.;\n    \n    return h;\n}\n\nconst vec3 sunDir = normalize(vec3(.5,1.,.75));\n//Sebastian Lagues's sky function\nvec3 getSky(float t,vec3 rd) {\n    #if SkyMode == 1\n    float skyGradT = pow(smoothstep(0.,.4,rd.y),.35);\n    vec3 skyGrad = mix(vec3(.05),vec3(.3,.6,.9),skyGradT);\n    \n    vec3 sun = pow(max(0.,dot(rd,sunDir)),40.)*10.*vec3(1.,.85,.7);\n    \n    float groundT = smoothstep(-.01,0.,rd.y);\n    \n    return mix(vec3(.25),skyGrad,groundT)+sun;\n    #elif SkyMode == 0\n    return vec3(0.);\n    #elif SkyMode == 2\n    return SRGBToLinear(texture(iChannel1,rd).xyz);\n    #endif\n}\n\nvec3 newRay(inout vec3 ro,inout vec3 L,vec3 P,in vec3 N,Mat m,bool ff) {\n    vec3 oro = ro, V = -L;\n    ro = P;\n    \n    float T = length(oro-P);\n    float scatterProb = 1.-exp(-T*(ff?airDens:m.scatDens));\n    if(scatterProb>rand()){\n        P = oro-V*rand()*T;\n        N = hemi(V);\n        L = reflect(-V,N);\n        return m.col;\n    }\n    \n    float F = pow(1.-md(-V,sign(dot(-V,N))*N),5.);\n    float r = m.r+(1.-m.r)*F;\n    vec3 H = importanceGGX(r,N);\n    if(m.m>rand()){ // Metal (Glossy Reflection)\n        L = reflect(-V,mix(H,N,round(rand())));\n        return m.col;\n    } else { // Dielectric (Refraction)\n        float eta = ff?1./m.IOR:m.IOR;\n        L = refract(-V,H,eta);\n        if(length(L)==0.) L = reflect(-V,H);\n        return m.col;\n    }\n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    #ifdef maxFrame\n    if(iFrame>=maxFrame) {o=texelFetch(iChannel0,ivec2(i),0);return;}\n    #endif\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = floor(iTime*mode)/mode;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        NewWorld world = getNewWorld(ctime);\n        Viewer cam = world.camera;\n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        for(int _j = 0; _j<numLvls;_j++) {\n            NewHit hit = newInt(cam.ro,rd,world.objs); \n            if(hit.len==-1.) {tcol+=getSky(ctime,rd)*fcol;break;}                             \n            \n            vec3 p = hit.len*rd+cam.ro;\n            \n            Mat mat = hit.o.mat;\n            \n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat,hit.ff);\n            \n            #if 1\n            {\n                float r_p = max(.0001,max(fcol.x,max(fcol.y,fcol.z)));\n                if(rand()>r_p) break;\n                fcol /= r_p;\n            }\n            #endif\n        }\n        \n        ttcol += tcol;\n    }\n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n    //o = vec4(i*.001,.5,1.);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texture(iChannel0,i/R);\n    o /= o.w;\n    float d = dot(o.xyz,vec3(1.));\n    o.xyz = d>7.5?o.xyz:vec3(0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 301, 340, 340, 730]]}
{"id": "mtcXDH", "name": "Exact SDF Anti-Aliasing", "author": "fad", "description": "Under the assumption that the SDF in the neighbourhood of the pixel is continuous and linear (true for almost all SDFs), this shader shows how to calculate the exact portion of a pixel covered by an SDF, useful for anti-aliasing.", "tags": ["2d", "aliasing", "distance", "field", "aa", "signed", "anti"], "likes": 12, "viewed": 313, "published": 3, "date": "1685361443", "time_retrieved": "2024-07-30T17:53:28.724230", "image_code": "// Under the assumption that the SDF in the neighbourhood of the pixel\n// is continuous and linear (true for almost all SDFs), this shader\n// shows how to calculate the exact portion of a pixel covered by an\n// SDF, useful for anti-aliasing.\n\n// The SDF versions of these functions here assume that the provided\n// signed-distance values are in screen-space (i.e. 1 unit of distance\n// corresponds to the width of a pixel). The shader also provides the\n// aastep(edge, x) function that works for non-SDF values as a drop-in\n// replacement for step(edge, x) but with anti-aliased output in [0, 1].\n\n// These functions are pretty overkill for anti-aliasing though. The\n// difference between these functions and the regular smoothstep/fwidth/\n// dFdx/dFdy trick is only noticable if you do some hard pixel peeping.\n// I mainly made this just for peace of mind knowing that there is a\n// \"correct\" way to do anti-aliasing for SDFs.\n\nfloat areaSquareLine(vec2 n, float d) {\n    // https://www.desmos.com/calculator/dorvdj5nbq for visualization\n    n = abs(n);\n    n = vec2(max(n.x, n.y), min(n.x, n.y));\n    float a = abs(d);\n    float b;\n\n    if (n.y != 0.0 && n.x - n.y <= 2.0 * a) {\n        vec2 c = 1.0 + (n - 2.0 * a) / n.yx;\n        b = 1.0 - max(c.x, 0.0) * c.y / 8.0;\n    } else {\n        b = min(0.5 + a / n.x, 1.0);\n    }\n    \n    return d < 0.0 ? 1.0 - b : b;\n}\n\nfloat areaSquareLineAverage(float d) {\n    // Approximate average value of areaSquareLine(n, d) w.r.t. n\n    float a = abs(d);\n    float b;\n    \n    if (a < 1.0 / sqrt(2.0)) {\n        b = 4.1434218 * pow(a, 12.647891) -\n            1.3070394 * pow(a, 3.9787831) +\n            1.0998631 * a +\n            0.5012205;\n        b = clamp(b, 0.0, 1.0);\n    } else {\n        b = 1.0;\n    }\n    \n    return d < 0.0 ? 1.0 - b : b;\n}\n\nfloat sdfFill(float sd) {\n    // Return the fraction of the pixel covered by the SDF (i.e. where\n    // sd < 0.0)\n    vec2 n = vec2(dFdx(sd), dFdy(sd));\n    \n    if (n == vec2(0.0)) {\n        // Ambiguous case, so instead we just return the average. This\n        // is the problem with using dFdx/dFdy that would occur much\n        // less frequently if we had access to the analytic derivatives.\n        return areaSquareLineAverage(-sd);\n    }\n\n    n = normalize(n);\n    return areaSquareLine(n, -sd);\n}\n\nfloat sdfOutline(float sd, float width) {\n    // Return the fraction of the pixel covered by the outline of the\n    // SDF (i.e. where abs(sd) < width / 2.0)\n    return sdfFill(sd - width / 2.0) - sdfFill(sd + width / 2.0);\n}\n\nfloat aastep(float edge, float x) {\n    // Return the fraction of the pixel where step(edge, x) == 1.0 by\n    // approximating the distance to the edge with derivatives.\n    x -= edge;\n    vec2 n = vec2(dFdx(x), dFdy(x));\n    \n    if (n == vec2(0.0)) {\n        // Ambiguous case, so we resort to using regular step(edge, x).\n        // We can't use areaSquareLineAverage(x) because that function\n        // assumes that x measures distance across pixels but we have no\n        // information about distance here as the derivatives are zero.\n        return step(edge, x);\n    }\n    \n    float l = length(n);\n    return areaSquareLine(n / l, x / l);\n}\n\n\n//====================================================================//\n\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return distance(p, c) - r;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    // https://www.shadertoy.com/view/3tdSDj\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    return distance(ap, ab * clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0));\n}\n\nfloat sdStar(vec2 p, float r, float rf) {\n    // https://www.shadertoy.com/view/3tSGDy\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\nvec4 blendOver(vec4 front, vec4 back) {\n    float a = front.a + back.a * (1.0 - front.a);\n    return a > 0.0\n        ? vec4((front.rgb * front.a + back.rgb * back.a * (1.0 - front.a)) / a , a)\n        : vec4(0.0);\n}\n\nvoid blendInto(inout vec4 dst, vec4 src) {\n    dst = blendOver(src, dst);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 color = vec4(0.918, 0.894, 0.843, 1.0);\n    vec2 p = fragCoord;\n    vec2 s = iResolution.xy;\n    float h = iResolution.y;\n    \n    { // Circle\n        vec2 c = (vec2(cos(iTime), cos(iTime + 2.3)) * 0.4 + 0.5) * s;\n        float r = (cos(iTime * 2.0 + 4.5) * 0.3 + 0.5) * h * 0.3;\n        float sd = sdCircle(p, c, r);\n        blendInto(color, vec4(0.471, 0.549, 0.471, sdfFill(sd)));\n        blendInto(color, vec4(0.171, 0.249, 0.171, sdfOutline(sd, h * 0.02)));\n    }\n    \n    { // Line\n        vec2 a = abs(iMouse.zw) + 0.5;\n        vec2 b = iMouse.xy + 0.5;\n        float sd = sdSegment(p, a, b) - h * 0.05;\n        blendInto(color, vec4(0.549, 0.471, 0.471, sdfFill(sd)));\n        blendInto(color, vec4(0.249, 0.171, 0.171, sdfOutline(sd, h * 0.01)));\n    }\n    \n    { // Star\n        vec2 c = (vec2(cos(iTime + 1.0), cos(iTime * 0.4 + 2.3)) * 0.5 + 0.5) * s;\n        float r = (cos(iTime * 1.5 + 2.5) * 0.3 + 0.4) * h * 0.4;\n        float sd = sdStar(p - c, r, 0.5);\n        blendInto(color, vec4(0.471, 0.471, 0.549, sdfFill(sd)));\n        blendInto(color, vec4(0.171, 0.171, 0.349, sdfOutline(sd, h * 0.03)));\n    }\n    \n    fragColor = vec4(pow(color.rgb * color.a, vec3(1.0 / 2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[929, 929, 968, 1038, 1367], [1369, 1369, 1407, 1473, 1792], [1794, 1794, 1819, 1907, 2299], [2301, 2301, 2342, 2458, 2526], [2528, 2528, 2563, 2697, 3177], [3255, 3255, 3296, 3296, 3329], [3331, 3331, 3372, 3417, 3535], [3537, 3537, 3578, 3623, 4034], [4036, 4036, 4075, 4075, 4251], [4253, 4253, 4295, 4295, 4328], [4330, 4330, 4382, 4382, 5591]]}
{"id": "DltXWH", "name": "Tree movement", "author": "marvpaul", "description": "Interesting fractal mountain with trees", "tags": ["fractal"], "likes": 5, "viewed": 195, "published": 3, "date": "1685350198", "time_retrieved": "2024-07-30T17:53:29.514119", "image_code": "//creator: ldm0\n//Personal website: ldm0.xyz\n\nvec3 flux(float x) {\n                return vec3(sin(x),cos(1.0*3.14159265359/3.0+x),sin(2.0*3.14159265359/3.0+x))*.9+0.1;\n            }\n            \nmat2x2 rotate(float x) { return mat2x2(cos(x), sin(x), sin(x), -cos(x)); }\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    float m;\n    vec2 uv = coord.xy / iResolution.xy;\n    uv.x *= 2.;\n    uv.x -= 1.;\n    //uv.y *= 1.382;\n    uv.y += .3819;\n    for (int i = 0; i < 20; ++i) {\n        uv= abs(uv);\n        float angle = (iTime*float(i))/3.1415-1.*3.1415/4.;\n        uv+=0.01*rotate(angle)[0];\n        m = uv.x * uv.x  + uv.y * uv.y;// - .0031;\n        uv.x = uv.x/m - .217;\n        uv.y = uv.y/m - .105;\n        m+= iTime*0.1;\n    } \n    color=vec4(flux(m*3.1415)*clamp(m, 0., 1.), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltXWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 66, 66, 182], [196, 196, 220, 220, 270], [271, 271, 318, 318, 793]]}
{"id": "mtcSDH", "name": "rainbow graphing calculator", "author": "forgeapm21", "description": "it's a graphing calculator. you can change the equation variable to be whatever equation you want and it will evaluate it for y. increasing the scale variable zooms it out.", "tags": ["graph", "calculator"], "likes": 1, "viewed": 232, "published": 3, "date": "1685333574", "time_retrieved": "2024-07-30T17:53:30.361852", "image_code": "float integrate(float x, float y, float equation_output)\n{\n    if (y > 0.0 && y < equation_output)\n    {\n        return 1.0;\n    }\n    else\n    {\n        if (y < 0.0 && y > equation_output)\n        {\n            return -1.0;\n        }\n        else\n        {\n        return 0.0;\n        }\n    }\n}\n\nfloat integral = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord/iResolution.xy -0.5 ) * 2.0;\n    //scale\n    float scale = 10.0;\n    uv *= scale;\n\n    \n    //create line value where the graph evaluates\n    float line = 0.0;\n    \n    //this evaluates to the value of the equation, write the equation here\n    float equation = sin(uv.x);\n\n    //thickness of the line\n    float thickness = 0.01;\n    thickness *= scale;\n    //graphing calculator\n    if ( uv.y >= equation - thickness/2.0 && uv.y <= equation + thickness/2.0 )\n    {\n        line = 1.0;\n    }\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float spot_integral = 0.0;\n    //integrate\n    spot_integral = integrate(uv.x, uv.y, equation);\n    integral += spot_integral;\n    \n    //combine shader with line\n    col *= (line + abs(spot_integral));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 295], [320, 320, 377, 427, 1303]]}
{"id": "DlcXDH", "name": "trippy view", "author": "forgeapm21", "description": "trippy lines", "tags": ["lines"], "likes": 3, "viewed": 140, "published": 3, "date": "1685316274", "time_retrieved": "2024-07-30T17:53:31.223548", "image_code": "//creates a color pallette mask\nvec3 pallette( float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 1.0, 0.557);\n    \n    return a + b * cos( 5.28318*(c*t+d) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    //normalize coordinates to a unit grid (x,y) -> (u,v)\n    //iResolution gives dimensions of canvas, is a vec3, .xy only uses its first two values\n    //iresolution.xy swizzles the attributes of the irezolution vector into a new vector. the object.attributeatribute syntax is a universal thing\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0;\n    \n    \n    //original coordinates\n    vec2 uv0 = uv;\n    \n    //shrinks and duplicates the image\n    //uv = fract(uv * 2.0) -0.5;\n    \n    //corrects for nonsquare frames\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //float fot the distance magnitude from coordinates to origin\n    float d = length(uv);\n    \n    //mask color variable\n    vec3 col = pallette(d + iTime/10.0);\n    \n    \n    //this should adjust the length harmonically based on the theta of the point\n    d += cos( sin( uv.y/d * iTime/10.0 ) ) ;\n   \n    //same as below but executed better, it makes a circle\n    //by using sin we can make many circles\n    d = sin(d * 20.0 + iTime);\n    d = abs(d);\n    //d = smoothstep(0.0, 1.0, d);\n    \n\n    d = 0.2/d;\n    \n    //makes a circular region where d1 = 1\n    float d1 = 0.0;\n    if (d <= 1.0 && d >= 0.4)\n    {\n        d1 = 1.0;\n    }\n    \n    //applys color mask to d\n    col *= d;\n    \n    //outputs a color gradient, inputting values of uv for the color values \n    fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcXDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 32, 57, 57, 247], [251, 251, 308, 609, 1694]]}
{"id": "cltSzN", "name": "Year of Truchets #026", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable)", "tags": ["3d", "raymarching", "truchet"], "likes": 13, "viewed": 212, "published": 3, "date": "1685313407", "time_retrieved": "2024-07-30T17:53:32.039367", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #026\n    05/28/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST    35.\n#define MIN_DIST    1e-4\n\n// globals\nvec3 hit,hitPoint;\nmat2 r90,r45;\nfloat ghs,shs,sd,gd,tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,gtk,stk;\n\n// constants\nconst float size = 1.15;\nconst float hlf = size/2.;\nconst float db = size*5.;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609,47.983)+iDate.z))*43758.5453);}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq sdf & extrude\nfloat cap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e5,0);\n\n    vec2 uv = pos.xz+vec2(ga1,ga2);\n    vec2 r = (uv*size)-.5;\n    vec2 ir = floor(r);\n    \n    vec2 id = floor(uv*size);\n    float rnd = hash21(id);\n    float xnd = fract(rnd*32.323);\n\n    r = fract(r)-.5;\n    vec2 q = fract(uv*size)-.5;\n    if (rnd>.5) q.x=-q.x; \n   \n    vec2 cv = vec2(length(q-.5),length(q+.5));\n    vec2 p = cv.x<cv.y?q-.5:q+.5;\n    \n    float thc = .05;\n    float k = length(p)-.5;k = abs(k)-thc;\n    \n    float sw = .1+.095*sin(pos.x*1.95+ga4);\n          sw-= .1+.095*cos(pos.z*2.25+ga3);\n    ghs = sw;\n    \n    if(xnd>.75) k = min(length(q.x)-thc,length(q.y)-thc);\n    gd = k;\n    \n    float d = opx(k-.07,pos.y,.25)-.05;\n    float d3= opx(abs(k)-.03,pos.y+sw-.225,.015)-.005;\n    \n    if(d3<res.x) {\n        res = vec2(d3,2.);\n        hit=vec3(q.x,pos.y,q.y);\n    }\n   \n    float hs = hash21(ir);\n    float b = cap(vec3(r.x,pos.y,r.y),.45,.15);\n    if(b<res.x&&hs>.6) {\n        res = vec2(b,4.);\n        hit=pos+vec3(ga1,0,ga2);\n    }\n\n    float gnd = pos.y+.01;\n    float gnt = d-.001;\n    gnd = max(gnd,-gnt);\n \n    if(gnd<res.x) {\n        res = vec2(gnd,gnt<gnd?3.:1.);\n        hit=pos+vec3(ga1,0,ga2);\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x*.85;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec4 FC = vec4(0.192,0.227,0.227,0.);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec2 ray = marcher(ro,rd,128);\n    d=ray.x;m=ray.y;\n    \n    hitPoint = hit;  \n    shs = ghs;\n    sd = gd;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        \n        vec3 lpos =vec3(15.,35.,35.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.25);\n        \n        if(m==1.) {\n            vec2 hp = hitPoint.xz*rot(.78);\n            vec2 f = fract(hp*24.)-.5;\n            h = mix(vec3(.15),vec3(.2),mod(floor(f.x),3.) == 0. ? 1. : 0.);  \n            \n            float px = 4./R.x;\n            float d = smoothstep(px,-px,abs(sd-.125)-.015);\n            h = mix(h, vec3(.275), d);\n            if(p.y<-.01) h = vec3(.1);\n            ref = h;\n        }\n        \n        if(m==2.) { h = hsv2rgb(vec3(shs+(p.x*.05)+T*.08,.85,.5)); ref = h; }\n        if(m==3.) { h = vec3(.025); ref = vec3(.35); }\n        if(m==4.) { h = vec3(.125); ref = vec3(.25); }\n \n        C = (diff*h);\n\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,d);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    // precal\n    tspeed = T*.6;\n    tmod = mod(tspeed,12.);\n    \n    float t1 = lsp(00.,02.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    \n    float t2 = lsp(03.,05.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    float t3 = lsp(06.,8.,tmod);\n    t3 = eoc(t3); t3 = t3*t3*t3;\n    \n    float t4 = lsp(9.,11.,tmod);\n    t4 = eoc(t4); t4 = t4*t4*t4;\n    \n    ga1 = (t1*db)-(t3*db);\n    ga2 = (t2*db)-(t4*db);\n    \n    ga3 = (t1-t3);\n    ga4 = (t2-t4);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,3.);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*.5-.25)*PI;\n\n    mat2 rx = rot(-.92-x), ry = rot(y+(ga3-ga4)*PI);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.)a=pass.w;\n    }\n           \n    C = mix(FC.rgb,C,exp(-.0008*a*a*a));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltSzN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[612, 612, 630, 630, 673], [674, 674, 695, 695, 762], [763, 763, 800, 800, 834], [835, 835, 854, 854, 881], [883, 903, 941, 941, 1048], [1049, 1049, 1098, 1098, 1194], [1196, 1196, 1215, 1215, 2401], [2403, 2403, 2433, 2433, 2672], [2674, 2674, 2717, 2717, 2947], [2949, 2963, 2990, 2990, 3103], [3143, 3143, 3238, 3238, 4672], [4674, 4674, 4715, 4732, 5900]]}
{"id": "ctdXDr", "name": "[EpilepsyWarning] Drug Simulator", "author": "MaxBeier", "description": "Focus your eyes onto the middle of the screen and look away after 5-15 Seconds. Cheers.", "tags": ["drugs", "epilepsywarning"], "likes": 3, "viewed": 196, "published": 3, "date": "1685285097", "time_retrieved": "2024-07-30T17:53:32.922007", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    float zoom = 100.0;\n    \n    d = sin(d * zoom - (iTime * 100.));\n    d = smoothstep(1., -1., d / fwidth(d));\n    \n    fragColor = vec4(d) - iTime * 0.01;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 314]]}
{"id": "DltXDr", "name": "chica-loca", "author": "jorge2017a2", "description": "chica-loca", "tags": ["chicaloca"], "likes": 10, "viewed": 206, "published": 3, "date": "1685285037", "time_retrieved": "2024-07-30T17:53:34.045006", "image_code": "//por jorge2017a2\n//--chica-loca\n//28-may-2023\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(3.0*antialiasing(1.0),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n#define PI 3.141516\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec2 p0_; //punto uv\nvec2 pt0; //punto pos0\nfloat DistL;\nvec3 ColL;  //color linea\nvec3 ColO;  //color salida Out\n\nvoid L( vec2 p1)\n{   DistL=sdSegment(p0_, pt0, p1 );\n    ColO= DrawFigBorde(ColL, ColO,DistL); \n    pt0 = p1;\n}\nvoid SZ(vec2 p ){pt0 = p;}\nvoid M(vec2 p1){pt0 = p1;}\nvoid C(vec3 pcol){ColL=pcol;}\n\n\nfloat sdPoly8 POLY(8)\nvec2  pt8[8]=vec2[](\nvec2(1.21,0.88),vec2(2.01,0.92),vec2(2.09,1.44),vec2(2.2,1.72),vec2(2.39,2.13),\nvec2(1.31,2.12),vec2(1.19,1.39),vec2(1.21,0.88)  );\n\nfloat sdPoly5a POLY(5)\nvec2  pt5a[5]=vec2[](\nvec2(1.43,1.07),vec2(1.35,1.07),vec2(1.33,1.15),vec2(1.38,1.16),vec2(1.43,1.07)  );\n\n\nfloat sdPoly5b POLY(5)\nvec2  pt5b[5]=vec2[](\nvec2(1.82,1.11),vec2(1.88,1.13),vec2(1.87,1.18),vec2(1.81,1.22),vec2(1.82,1.11)  );\n\n\nfloat sdPoly15 POLY(15)\nvec2  pt15[15]=vec2[](\nvec2(1.31,1.55),vec2(1.74,1.6),vec2(1.87,1.83),vec2(1.8,2.13),vec2(1.81,2.23),\nvec2(1.85,2.39),vec2(1.83,2.47),vec2(1.82,2.47),vec2(1.38,2.52),vec2(1.31,2.45),\nvec2(1.31,2.45),vec2(1.31,2.25),vec2(1.23,2.02),vec2(1.22,1.91),vec2(1.31,1.55)  );\n\n\nvec3 PeloB(vec2 p ,vec3 col)\n{\n    float sd = sdPoly8(p, pt8);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, sd);\n    return col;\n}\n\nvec3 Pelo(vec2 p,vec3 col)\n{\n    float r1,d1,r2, d2;\n    vec2 p1,p2;\n\n\n    r1 = 0.4;\n    p1 = vec2(1.63, 0.98);\n    d1 = sdCircle(p- p1, r1);\n    //col = DrawFigBorde(vec3(0.0), col, d1);\n\n    r2 = 0.35;\n    p2 = vec2(1.58, 0.91);\n    d2 = sdCircle(p- p2, r2);\n    float dt;\n    dt = unionSDF(d1, d2);\n    col = DrawFigBorde(vec3(0.0), col, dt);\n    col = PeloB(p, col);\n    return col;\n}\n\nvec3 Cejas(vec2 p,vec3 col)\n{\n    vec2 p1,p2,p3,p4;\n\n    p1 = vec2(1.55, 0.98);\n    p2 = vec2(1.49, 0.96);\n    p3 = vec2(1.43, 0.95);\n    p4 = vec2(1.38, 0.95);\n\n    p0_ = p;\n    ColO = col;\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n\n\n    //ceja der;\n    p1 = vec2(1.68, 0.98);\n    p2 = vec2(1.76, 0.97);\n    p3 = vec2(1.83, 0.98);\n    p4 = vec2(1.87, 1);\n    p0_ = p;\n    ColO = col;\n     SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2); L(p3); L(p4);;\n    col = ColO;\n    return col;\n}\n\nvec3 Rostro(vec2 p, vec3 col)\n{\n    vec2 pos, med;\n    float d1, d2,d3,d4;\n\n    pos = vec2(1.66, 1.14);\n    med = vec2(0.24, 0.35);\n    d1 = sdEllipse(p- pos, med);\n    //---------;\n    pos = vec2(1.55, 1.17);\n    med = vec2(0.24, 0.35);\n    d2 = sdEllipse(p- pos, med);\n    //---------;\n    pos = vec2(1.59, 1.15);\n    med = vec2(0.21, 0.39);\n    d3 = sdEllipse(p- pos, med);\n    //---------;\n    pos = vec2(1.59, 1.24);\n    med = vec2(0.31, 0.23);\n    d4 = sdEllipse(p- pos, med);\n    //---------;\n    float dt;\n    vec3 colc;\n    dt = unionSDF(d1, d2);\n    dt = unionSDF(dt, d3);\n    dt = unionSDF(dt, d4);\n    \n    colc = vec3(0.95, 0.87, 0.91);\n    col = DrawFigBorde(colc, col, dt);\n    return col;\n}\n\n\nvec3 OjoIzq(vec2 p,vec3 col)\n{\n    vec2 pos,med,p1;\n    float d1,r1;\n    \n    pos = vec2(1.42, 1.14);\n    med = vec2(0.09, 0.06);\n    d1 = sdEllipse(p- pos, med);\n\n     float d2 = sdPoly5a(p, pt5a);   \n    float dt = unionSDF(d1, d2);\n    col = DrawFigBorde(vec3(1.0), col, dt);\n\n    \n    r1 = 0.045; // 0.05;\n    p1 = vec2(1.44, 1.15);\n    d1 = sdCircle(p- p1, r1);\n    col = DrawFigSolo(vec3(0.0), col, d1);\n    return col;\n}\n\nvec3 ojoDer(vec2 p,vec3 col)\n{\n    vec2 pos, med;\n    float d1;\n\n    pos = vec2(1.77, 1.16);\n    med = vec2(0.09, 0.06);\n    d1 = sdEllipse(p- pos, med);\n\n    float sd = sdPoly5b(p, pt5b);\n    \n    float dt = unionSDF(d1, sd);\n    col = DrawFigBorde(vec3(1.0), col, dt);\n    col = DrawFigBorde(vec3(1.0), col, dt);\n\n    float r3,d3;\n    vec2 p3;\n\n    r3 = 0.045;\n    p3 = vec2(1.75, 1.17);\n    d3 = sdCircle(p- p3, r3);\n    col = DrawFigSolo(vec3(0.0), col, d3);\n\n    return col;\n}\n\nvec3 nariz(vec2 p,vec3  col)\n{ vec2 p1, p2;\n    ColO = col;\n    p0_ = p;\n    p1 = vec2(1.58, 1.23);\n    p2 = vec2(1.57, 1.29);\n    SZ(p1); M(p1); C(vec3(0.0));\n    L(p1); L(p2);;\n    col = ColO;\n    return col;\n}\n\nvec3 boca(vec2 p,vec3 col)\n{\n    vec2 pos,med;\n    float dt;\n    float r1, d1,r2,d2,r3,d3,r4,d4;\n    vec2 p1,p2, p3, p4;\n\n    pos = vec2(1.58, 1.33);\n    med = vec2(0.11, 0.15);\n    d1 = sdEllipse(p- pos, med);\n\n    r2 = 0.18;\n    p2 = vec2(1.58, 1.15);\n    d2 = sdCircle(p- p2, r2);\n    dt = differenceSDF(d1, d2);\n    \n\n    r3 = 0.09;\n    p3 = vec2(1.73, 1.25);\n    d3 = sdCircle(p- p3, r3);\n\n\n    r4 = 0.09;\n    p4 = vec2(1.42, 1.25);\n    d4 = sdCircle(p- p4, r4);\n    dt = differenceSDF(dt, d3);\n    dt = differenceSDF(dt, d4);\n    col = DrawFigBorde(vec3(0.0), col, dt);\n\n////dientes;\n\nvec3 colc;\n    r1 = 0.2;\n    p1 = vec2(1.6, 1.19);\n    d1 = sdCircle(p- p1, r1);\n    d1 = intersectSDF(d1, dt);\n    col = DrawFigBorde(vec3(1.0), col, d1);\n    \n    return col;\n}\n\nvec3 Cuello(vec2 p,vec3 col)\n{\n    vec2 pos,med;\n    vec3 colc;\n    float d1;\n    pos = vec2(1.53, 1.56);;\n    med = vec2(0.1, 0.125);\n    d1 = sdBox(p- pos, med);\n    colc = vec3(0.95, 0.87, 0.91);\n    col = DrawFigBorde(colc, col, d1);\nreturn col;\n}\n\nvec3 BrazoDer(vec2 pp ,vec3 col)\n{\n    float r1,r2,he,d1,ang;\n    vec2 pos, p;\n    float d2,d3;\n    vec2 p1, med,pr;\n\n\n    p = pp;\n    r1 = 0.075;\n    r2 = 0.125;\n    he = 0.68; //0.675;\n    pos = vec2(2.07, 1.265);  ////original;\n\n    ang = -30.0 * PI / 180.0;\n    pr = Rotate(p- vec2(-0.08, -0.11), vec2(pos.x - r1 / 2., pos.y + he / 2.), ang);\n    d1 = sdTrapezoid(pr- pos, r1, r2, he);\n\n    r1 = 0.15; //r=0.13;\n    p1 = vec2(2.47, 0.63);\n    d2 = sdCircle(p- p1, r1);\n\n    pos = vec2(1.83, 1.75);\n    med = vec2(0.09, 0.14);\n    d3 = sdEllipse(p- pos, med);\n    d1 = differenceSDF(d1, d2);\n    d1 = unionSDF(d1, d3);\n    col = DrawFigBorde(vec3(1.0), col, d1);\n    \n    ///mano\n    float dt, d0;\n    pos = vec2(2.4, 0.55);\n    med = vec2(0.1, 0.3);\n    vec3 colc = vec3(0.95, 0.87, 0.91);\n    ang = -30.0 * PI / 180.0;\n    pr = Rotate(p- pos, med, ang);\n    d0 = sdEllipse(pr, med);\n    col = DrawFigBorde(colc, col, d0);\n    return col;\n}\n\nvec3 BrazoIzq(vec2 p,vec3 col)\n{\n    float r1,r2,he,d1,ang,d2;\n    vec2 pos, pr,p1;\n\n    r1 = 0.075;\n    r2 = 0.11;\n    he = 0.725;\n    pos = vec2(0.97, 1.155);\n    ang = 27.0 * PI / 180.0;\n    pr = Rotate(p- vec2(0.15, 0.08), vec2(pos.x - r1 / 2., pos.y + he / 2.0), ang);\n    d1 = sdTrapezoid(pr- pos, r1, r2, he);\n\n    r1 = 0.11;\n    p1 = vec2(0.62, 0.46);\n    d2 = sdCircle(p- p1, r1);\n        d1 = differenceSDF(d1, d2);\n    col = DrawFigBorde(vec3(1.0), col, d1);\n    ////mano;\n    float dt,d0;\n    vec2 med;\n    vec3 colc;\n\n    pos = vec2(0.28, 0.23);\n    med = vec2(0.1, 0.3);\n    pr = Rotate(p- pos, med, ang);\n    d0 = sdEllipse(pr- pos, med);\n    colc = vec3(0.95, 0.87, 0.91);\n    col = DrawFigBorde(colc, col, d0);\n    return col;\n}\n\nvec3 camisav2(vec2 p ,vec3 col)\n{    float sd = sdPoly15(p, pt15);   \n    //diferencia a camisa;\n    float r1,r2,he, d1, ang,dt;\n    vec2 pr, pos, med;\n    r1 = 0.15;\n    r2 = 0.055;\n    he = 0.2;\n    pos = vec2(1.51, 1.77);\n    ang = -5.0 * PI / 180.0;\n    pr = Rotate(p, vec2(pos.x - r1 / 2., pos.y + he / 2.), ang);\n    d1 = sdTrapezoid(pr- pos, r1, r2, he);\n    \n    col = DrawFigBorde(vec3(0.0, 0.0, 0.5), col, sd);\n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, d1);\n    return col;\n}\n\nvec3 chicaLoca(vec2 p  ,vec3 col)\n{    col = Pelo(p, col);\n    col = Cuello(p, col);\n    col = Rostro(p, col);\n    col = Cejas(p, col);\n    col = OjoIzq(p, col);\n    col = ojoDer(p, col);\n    col = boca(p, col);\n    col = nariz(p, col);\n    col = BrazoDer(p, col);\n    col = BrazoIzq(p, col);\n    col = camisav2(p, col);\n    return col;\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    //vec2 uv0=uv;\n    float t=iTime;\n    vec2 uv0=uv*(1.2+0.8*sin(t));\n    uv-=vec2(-0.5,0.75); uv*=1.5;\n    \n\n    float d=sdBox(uv0,vec2(1.0,0.5));\n    vec3 col = palette(d+iTime);\n\td=sin(d*8.0+iTime/8.0);\n\td=abs(d);\n\td=0.5/d;\n\tcol*=d;\n    \n    \n    uv.y=-uv.y;\n    t=t*3.0;\n    \n    if(sin(t)>0.0)\n    col= chicaLoca(uv,col);\n    else\n    col= chicaLoca(vec2(-uv.x+3.0,uv.y),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltXDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[569, 569, 631, 631, 757], [758, 758, 839, 839, 967], [969, 969, 1033, 1033, 1104], [1106, 1106, 1168, 1168, 1233], [1236, 1236, 1283, 1283, 1310], [1311, 1311, 1354, 1354, 1381], [1382, 1382, 1430, 1430, 1458], [1461, 1477, 1525, 1525, 1603], [1605, 1605, 1640, 1640, 1663], [1665, 1665, 1702, 1702, 1774], [1776, 1776, 1828, 1828, 1935], [1937, 1937, 1962, 1962, 1981], [1982, 1982, 2007, 2007, 2026], [2027, 2027, 2063, 2063, 2091], [2094, 2094, 2159, 2159, 2469], [2587, 2587, 2605, 2605, 2698], [2699, 2699, 2716, 2716, 2725], [2726, 2726, 2742, 2742, 2752], [2753, 2753, 2771, 2771, 2782], [3516, 3516, 3546, 3546, 3650], [3652, 3652, 3680, 3680, 4040], [4042, 4042, 4071, 4071, 4567], [4569, 4569, 4600, 4600, 5275], [5278, 5278, 5308, 5308, 5705], [5707, 5707, 5737, 5737, 6188], [6190, 6190, 6220, 6220, 6402], [6404, 6404, 6432, 6432, 7173], [7175, 7175, 7205, 7205, 7426], [7428, 7428, 7462, 7462, 8372], [8374, 8374, 8406, 8406, 9119], [9121, 9121, 9154, 9154, 9613], [9615, 9615, 9650, 9650, 9953], [9955, 9995, 10020, 10020, 10203], [10205, 10205, 10262, 10262, 10771]]}
{"id": "dlcXR4", "name": "Analytic Direct Lighting", "author": "fad", "description": "Analytic direct lighting in 2D. Sky integral taken from https://www.shadertoy.com/view/NttSW7 but otherwise made from scratch. It's interactive! Try dragging around the end points of the line segments. It doesn't handle intersecting lines properly.", "tags": ["2d", "lighting", "shadows", "area", "penumbra", "soft", "analytic", "direct"], "likes": 113, "viewed": 1931, "published": 3, "date": "1685279655", "time_retrieved": "2024-07-30T17:53:34.822925", "image_code": "// Analytic direct lighting in 2D. Sky integral taken from\n// https://www.shadertoy.com/view/NttSW7 but otherwise made from\n// scratch. It's interactive! Try dragging around the end points of the\n// line segments. It doesn't handle intersecting lines properly.\n\nstruct LineSegment {\n    vec2 p0;\n    vec2 p1;\n    vec3 emissiveColor;\n};\n\nLineSegment[N] segments;\nfloat angles[2 * N];\n\nvoid sortAngles() {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            int k = 2 * i + j;\n            vec2 p = j == 0 ? segments[i].p0 : segments[i].p1;\n            float angle = mod(atan(p.y, p.x), 2.0 * PI);\n            int l = k - 1;\n            \n            while (l >= 0 && angle < angles[l]) {\n                angles[l + 1] = angles[l];\n                l -= 1;\n            }\n            \n            angles[l + 1] = angle;\n        }\n    }\n}\n\nvec3 integrateRadiance(LineSegment a, vec2 angle) {\n    return (angle[1] - angle[0]) * a.emissiveColor;\n}\n\nvec3 integrateSkyRadiance_(vec2 angle) {\n    float a1 = angle[1];\n    float a0 = angle[0];\n    \n    // https://www.shadertoy.com/view/NttSW7\n    const vec3 SkyColor = vec3(0.2,0.5,1.);\n    const vec3 SunColor = vec3(1.,0.7,0.1)*10.;\n    const float SunA = 2.0;\n    const float SunS = 64.0;\n    const float SSunS = sqrt(SunS);\n    const float ISSunS = 1./SSunS;\n    vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));\n    SI += SunColor*(atan(SSunS*(SunA-a0))-atan(SSunS*(SunA-a1)))*ISSunS;\n    return SI / 6.0;\n}\n\nvec3 integrateSkyRadiance(vec2 angle) {\n    if (angle[1] < 2.0 * PI) {\n        return integrateSkyRadiance_(angle);\n    }\n    \n    return integrateSkyRadiance_(vec2(angle[0], 2.0 * PI)) + integrateSkyRadiance_(vec2(0.0, angle[1] - 2.0 * PI));\n}\n\nint findIndex(float angle) {\n    mat2 m;\n    m[1] = vec2(cos(angle), sin(angle));\n    int bestIndex = -1;\n    float bestU = 1e10;\n    \n    for (int i = 0; i < N; ++i) {\n        m[0] = segments[i].p0 - segments[i].p1;\n        vec2 tu = inverse(m) * segments[i].p0;\n        if (tu == clamp(tu, vec2(0.0), vec2(1.0, bestU))) {\n            bestU = tu.y;\n            bestIndex = i;\n        }\n    }\n    \n    return bestIndex;\n}\n\nvec3 calculateFluence() {\n    vec3 fluence = vec3(0.0);\n    \n    for (int i = 0; i < 2 * N; ++i) {\n        vec2 a;\n        a[0] = angles[i];\n        \n        if (i + 1 < 2 * N) {\n            a[1] = angles[i + 1];\n        } else {\n            a[1] = angles[0] + 2.0 * PI;\n        }\n        \n        if (a[0] == a[1]) {\n            continue;\n        }\n        \n        int j = findIndex((a[0] + a[1]) / 2.0);\n        \n        if (j == -1) {\n            fluence += integrateSkyRadiance(a);\n        } else {\n            fluence += integrateRadiance(segments[j], a);\n        }\n    }\n    \n    return fluence;\n}\n\nfloat sdf(LineSegment l, vec2 p) {\n    vec2 pa = p-l.p0, ba = l.p1-l.p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 blendOver(vec4 top, vec4 bottom) {\n    float a = top.a + bottom.a * (1.0 - top.a);\n    return vec4((top.rgb * top.a + bottom.rgb * bottom.a * (1.0 - top.a)) / a , a);\n}\n\nvoid drawSDF(inout vec4 dst, vec4 src, float sdf) {\n    dst = blendOver(vec4(src.rgb, src.a * clamp(1.5 - abs(sdf), 0.0, 1.0)), dst);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    for (int i = 0; i < N; ++i) {\n        segments[i].p0 = getPoint(2 * i + 0) - fragCoord;\n        segments[i].p1 = getPoint(2 * i + 1) - fragCoord;\n        segments[i].emissiveColor = vec3(0.0);\n    }\n    \n    segments[10].emissiveColor = vec3(1.0, 0.1, 0.3);\n    segments[11].emissiveColor = vec3(0.1, 0.6, 0.9);\n    \n    sortAngles();\n    vec3 fluence = calculateFluence();\n    fragColor = vec4(1.0 - 1.0 / pow(1.0 + fluence, vec3(3.0)), 1.0);\n    fragColor.a = 1.0;\n    \n    for (int i = 0; i < N; ++i) {\n        drawSDF(\n            fragColor, \n            vec4(3.0 * pow(segments[i].emissiveColor, vec3(1.0 / 2.2)), 1.0),\n            sdf(segments[i], vec2(0.0))\n        );\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This buffer just handles the interactive geometry.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int i = int(fragCoord.x) + int(iResolution.x) * int(fragCoord.y);\n    \n    if (i >= numPoints) {\n        return;\n    }\n    \n    if (iFrame == 0) {\n        fragColor.xy = vec2[](\n            vec2(0.2, 0.8),\n            vec2(0.35, 0.8),\n            vec2(0.45, 0.8),\n            vec2(0.7, 0.8),\n            vec2(0.6, 0.8),\n            vec2(0.6, 0.5),\n            vec2(0.7, 0.8),\n            vec2(0.7, 0.5),\n            vec2(0.6, 0.5),\n            vec2(0.65, 0.5),\n            vec2(0.8, 0.35),\n            vec2(0.8, 0.15),\n            vec2(0.8, 0.15),\n            vec2(0.2, 0.15),\n            vec2(0.2, 0.15),\n            vec2(0.2, 0.8),\n            vec2(0.6, 0.15),\n            vec2(0.6, 0.35),\n            vec2(0.8, 0.35),\n            vec2(0.65, 0.35),\n            vec2(0.7, 0.2),\n            vec2(0.75, 0.22),\n            vec2(0.625, 0.55),\n            vec2(0.6875, 0.52),\n            vec2(0.6, 0.35),\n            vec2(0.65, 0.35)\n        )[i] * iResolution.xy;\n        fragColor.z = 0.0;\n        return;\n    }\n    \n    int bestIndex = -1;\n    float bestDist = 1e10;\n    \n    if (iMouse.z > 0.0) {\n        for (int j = 0; j < numPoints; ++j) {\n            vec4 data = getPointData(j);\n            \n            if (data.z > 0.0) {\n                bestIndex = j;\n                break;\n            }\n            \n            vec2 p = data.xy;\n            float d = distance(p, iMouse.xy);\n            \n            if (d < min(CONTROL_RADIUS, bestDist) && iMouse.w > 0.0) {\n                bestIndex = j;\n                bestDist = d;\n            }\n        }\n    }\n    \n    if (i == bestIndex) {\n        vec4 data = getPointData(i);\n        \n        if (data.z <= 0.0) {\n            fragColor.zw = iMouse.xy;\n        } else {\n            fragColor.zw = data.zw;\n        }\n        \n        fragColor.xy = getPoint(i) + iMouse.xy - fragColor.zw;\n        fragColor.zw = iMouse.xy;\n    } else {\n        fragColor.xy = getPoint(i);\n        fragColor.zw = vec2(0.0);\n    }\n    \n    if (i == 25) {\n        vec2 a = getPoint(24);\n        vec2 b = fragColor.xy;\n        float r = distance(a, b);\n        float t = (0.5 - 0.5 * cos(iTime)) * PI;\n        fragColor.xy = a + r * vec2(cos(t), sin(t));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int numPoints = 26;\nconst int N = numPoints / 2;\n\n#define CONTROL_RADIUS (max(iResolution.x, iResolution.y) * 0.05)\nconst float PI = 3.14159265;\n\n#ifndef HW_PERFORMANCE\nuniform sampler2D iChannel0;\nuniform vec4 iResolution;\n#endif\n\nvec4 getPointData(int i) {\n    return texelFetch(iChannel0, ivec2(i % int(iResolution.x), i / int(iResolution.x)), 0);\n}\n\nvec2 getPoint(int i) {\n    return texelFetch(iChannel0, ivec2(i % int(iResolution.x), i / int(iResolution.x)), 0).xy;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcXR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 384, 403, 403, 863], [865, 865, 916, 916, 970], [972, 972, 1012, 1012, 1482], [1484, 1484, 1523, 1523, 1728], [1730, 1730, 1758, 1758, 2151], [2153, 2153, 2178, 2178, 2757], [2759, 2759, 2793, 2793, 2921], [2923, 2923, 2962, 2962, 3096], [3098, 3098, 3149, 3149, 3233], [3235, 3235, 3287, 3287, 3975]]}
{"id": "cltSDn", "name": "ExtrudedOldShader", "author": "Del", "description": "A raymarched texture extruder with stacked planes, using domain repetition and brightness level cutting. It (almost) doesn't suffer from discontinuities. Adjust steps_multiplier to reveal slices. Buffer A  contains https://www.shadertoy.com/view/fsSSzw", "tags": ["extruder"], "likes": 10, "viewed": 277, "published": 3, "date": "1685276290", "time_retrieved": "2024-07-30T17:53:35.661682", "image_code": "// Kali's 'Extruder' - https://www.shadertoy.com/view/dtdSzM\n// with my galaxy ripple - https://www.shadertoy.com/view/fsSSzw\n#define  steps_multiplier .01\n#define  extrusion  .5\n#define  height_scale  .2\n#define  rotationXY  iTime*.1\n#define  rotationXZ  0.\n#define  rotationYZ  -.3\n#define  cameraX  0.\n#define  cameraY  .3\n#define  cameraZ  -1.2\n#define  fov  .8\n#define  lightdirX  1.\n#define  lightdirY  1.\n#define  lightdirZ  1.\n#define  ambient  .5\n#define  diffuse  1.\n#define  invert  false\n#define  distortX  0.\n#define  distortY  0.\n#define  distortZ  0.\n#define  distort_scale  0.\n#define  fudge_factor  .5\n\n#define resolution iResolution\n\nfloat maxdist=50., det=.001;\nvec3 objcol;\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat box(vec3 p, vec3 c) {\n    return length(max(vec3(0.),abs(p)-c));\n}\n\nfloat de(vec3 p) {\n  p.xy*=rot(p.z*distortZ*5.);\n  p.xz*=rot(-p.y*distortY);\n  p.yz*=rot(p.x*distortX);\n  float st=steps_multiplier*.3;\n  float extrude=extrusion*5.;\n  p.z+=extrude*.5;\n  p.z+=.5;\n  vec3 p2=p;\n  p2.x*=3./5.;\n  if(!invert) objcol=texture(iChannel0,p2.xy*.15*(1.+p.z*3.*(distort_scale))+.5).rgb;\n  else objcol=1.-texture(iChannel0,p2.xy*.15*(1.+p.z*3.*(distort_scale))+.5).rgb;\n  float l=length(objcol)*.5*height_scale*2.;\n  float z=p.z;\n  p.z=mod(p.z,st)-st*.5;\n  float d=box(p, vec3(5.,3.,.01));\n  d=max(d,abs(z)-extrude*.5);\n  d+=smoothstep(1.-(z+extrude*.5)/extrude,0.,l)*.05;\n  return d*fudge_factor;\n  }\n\nvec3 normal(vec3 p) {\n    vec2 e=vec2(0.,det);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\nvec3 march(vec3 from, vec3 dir) {\n    vec3 p, col=vec3(0.);\n    float d, td=0.;\n    for (int i=0; i<2000; i++) {\n        p=from+dir*td;\n        d=de(p);\n        if (d<det || td>maxdist) break;\n        td+=d;\n    }\n    if (d<det) {\n        p-=dir*det;\n        vec3 n=normal(p);\n        vec3 ldir=normalize(vec3(lightdirX,lightdirY,lightdirZ));\n        col+=objcol*max(ambient,max(0.,dot(ldir,n))*diffuse);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy/resolution.xy-.5;\n    uv.x*=resolution.x/resolution.y;\n    vec3 from=vec3(cameraX*4.,cameraY*4.,cameraZ*10.);\n     vec3 dir=normalize(vec3(uv,fov*3.));\n    from.xz*=rot(rotationXZ*3.1416);\n    dir.xz*=rot(rotationXZ*3.1416);\n    from.yz*=rot(-rotationYZ*3.1416);\n    dir.yz*=rot(-rotationYZ*3.1416);\n    from.xy*=rot(rotationXY*3.1416);\n    dir.xy*=rot(rotationXY*3.1416);\n    vec3 col = march(from,dir);\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://www.shadertoy.com/view/fsSSzw\n// galaxy ripple nebula effect\n//#define PROCEDURAL_HASH\n\n#ifdef PROCEDURAL_HASH\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n#else\nvec3 hash33( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.05);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n#define TWO_PI 6.2831853\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd-iTime*.025);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.5,1.25);\n    vec3 col2 =  vec3(1.95,0.95,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    \n    if (iMouse.z>0.5)\n        col = col.yxz;\n    fragColor = vec4(sqrt(col),1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltSDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[695, 695, 714, 714, 773], [775, 775, 802, 802, 847], [849, 849, 867, 867, 1472], [1474, 1474, 1495, 1495, 1593], [1595, 1595, 1628, 1628, 2023], [2025, 2025, 2082, 2082, 2550]]}
{"id": "mldSRM", "name": "opPipeJointT", "author": "iY0Yi", "description": "A joint part is generated automatically at the connection point of the two-axis pipes.\ntodo: branchless", "tags": ["maptoy"], "likes": 13, "viewed": 255, "published": 3, "date": "1685263373", "time_retrieved": "2024-07-30T17:53:36.736807", "image_code": "float opUniS(float a,float b,float r){\n\tfloat h = max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCylinder(vec3 p, float h, float r){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat sdBox(vec3 p, vec3 b){\n  vec3 q = abs(p)-b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat opPipeJointT(vec2 p, float d, float t, float l, vec2 dir){\n    \n    d = abs(d-t*.5)-t*.5;              // sdf: body (skin of the pipes sdf)\n    \n    p=dir*p + (1.-abs(dir))*abs(p);    // (dir==vec2(0)) ? abs(p) : dir*p\n    float cps = max(p.x, p.y)-l-t;     // sdf: cutting planes\n    \n#if 0\n    if(cps>0.){\n        if(d<0.)\n            return cps;\n        else\n            return length(vec2(d, cps));\n    }\n    return d;\n#else\n    float e = length(vec2(d, cps));    // sdf: edges\n    float c = mix(cps, e, step(0.,d)); // sdf: caps (cutting planes + edges)\n    return mix(d, c, step(0.,cps));    // sdf: the joint (caps + body) \n#endif\n}\n\nfloat map(vec3 p){\n    const float r = .25;\n    const float l = 3.;\n    float jl = 1.+sin(iTime*5.)*.5;\n    float cr = .1+sin(iTime*2.)*.1;\n    \n    float xp = l;//abs(sin(iTime))*l+l;\n    \n    float x = sdCylinder(p.yxz+vec3(0,xp,0),l,r);\n    //float y = sdCylinder(p.xyz+vec3(0,0,0),l,r);\n    float y = sdBox(p.xyz+vec3(0,0,0),vec3(.1,l,r));\n    \n    float pipes = opUniS(x,y,.2);\n    float joint = opPipeJointT(p.xy, pipes-cr, .4-cr*2., jl+cr, vec2(-1,0))-cr;\n\n    //RED(x);\n    //BLACK(y);\n    ORANGE(joint);\n\n    return min(pipes, joint);\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 30.\n#define STEP_MAX 100\n\n// Markers: 8 colors\n#define cRED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n#define cGREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n#define cPURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n#define cYELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n#define cORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n#define cCOBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n#define cBLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n#define cBLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n\nfloat tRED = 1.;\nfloat tGREEN = 1.;\nfloat tPURPLE = 1.;\nfloat tYELLOW = 1.;\nfloat tORANGE = 1.;\nfloat tCOBALT = 1.;\nfloat tBLUE = 1.;\nfloat tBLACK = 1.;\n#define RED(v) tRED = step(DIST_MIN*10., v)\n#define GREEN(v) tGREEN = step(DIST_MIN*10., v)\n#define PURPLE(v) tPURPLE = step(DIST_MIN*10., v)\n#define YELLOW(v) tYELLOW = step(DIST_MIN*10., v)\n#define ORANGE(v) tORANGE = step(DIST_MIN*10., v)\n#define COBALT(v) tCOBALT = step(DIST_MIN*10., v)\n#define BLUE(v) tBLUE = step(DIST_MIN*10., v)\n#define BLACK(v) tBLACK = step(DIST_MIN*10., v)\n\n#define INIT_CAM_POS vec3(2,-1,2)*2.\n#define CAM_DIST 8.\n#define CAM_INIT_SCALE 3.\n#define TURN_TABLE_SPEED .5\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(1,.95,.9)*.8)\n#define THM_GRID (vec3(.1,.2,.25)*1.7)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(1)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc char(U,64+CAPS+c);\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\n#define render() \\\nbool isTurntable = false;\\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nfloat char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;}\\\n    return 0.;\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=min(0,iFrame); i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=min(0,iFrame); i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), 1, cos(iTime*TURN_TABLE_SPEED))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz)*1.5;\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz);\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(4.2)), g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col*= (tRED<.5)?cRED:vec3(1);\\\n    col*= (tGREEN<.5)?cGREEN:vec3(1);\\\n    col*= (tPURPLE<.5)?cPURPLE:vec3(1);\\\n    col*= (tYELLOW<.5)?cYELLOW:vec3(1);\\\n    col*= (tORANGE<.5)?cORANGE:vec3(1);\\\n    col*= (tCOBALT<.5)?cCOBALT:vec3(1);\\\n    col*= (tBLUE<.5)?cBLUE:vec3(1);\\\n    col*= (tBLACK<.5)?cBLACK:vec3(1);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(2.2)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x>.5;\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(1.-THM_GRID,vec3(2.2)),1);\\\n    drawDebug(fragColor);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n  \n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mldSRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 110], [112, 112, 155, 155, 258], [260, 260, 288, 288, 371], [373, 373, 437, 437, 1018], [1020, 1020, 1038, 1038, 1565]]}
{"id": "dt3XDn", "name": "Space Runner", "author": "moonLight7k", "description": "..", "tags": ["loop", "spacecity"], "likes": 5, "viewed": 184, "published": 3, "date": "1685257130", "time_retrieved": "2024-07-30T17:53:37.574567", "image_code": "#define NONE  -1\n#define PLANE  0\n#define SPHERE 1\n\n#define TMAX 10000.\n\nconst float N = 55.0;\n\nconst vec4 skyTop = vec4(0.001f, 0.0f, 0.1f, 1.0f);\nconst vec4 skyBottom = vec4(0.55f, 0.08f, 0.896f, 1.0f);\n\nfloat gridTextureGradBoxFilter(vec2 uv, vec2 ddx, vec2 ddy) {\n    uv += 0.5f;\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 a = uv + 0.015 + w;\n    vec2 b = uv - 0.015 + w;\n\n    vec2 i = (floor(a) + min(fract(a) * N, 1.0) -\n        floor(b) - min(fract(b) * N, 1.0)) / (N * w);\n\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat gridTexture(vec2 uv) {\n    uv += 0.5f;\n    vec2 i = step(fract(uv), vec2(1.0 / N, 1.0 / N));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nvec2 texCoords(vec3 pos, int objectType) {\n    vec2 uv;\n    if(objectType == PLANE) {\n        uv = pos.xz;\n    }\n\n    uv.y -= iTime * 10.;\n    return 0.5 * uv;\n}\n\nfloat traceRay(vec3 rayOrigin, vec3 rayDir, inout vec3 pos, inout vec3 nor, inout int objType) {\n    float tmin = TMAX;\n    pos = vec3(0.0f, 0.0f, 0.0f);\n    nor = vec3(0.0f, 0.0f, 0.0f);\n    objType = NONE;\n\n    float t = (-1.0 - rayOrigin.y) / rayDir.y;\n\n    if(t > 0.0) {\n        tmin = t;\n        nor = vec3(0.0f, 1.0f, 0.0f);\n        pos = rayOrigin + rayDir * t;\n        objType = PLANE;\n    }\n\n    return tmin;\n}\n\nvoid createRay(in vec2 pixel, inout vec3 rayOrigin, inout vec3 rayDirection) {\n    vec2 p = (2. * pixel.xy - iResolution.xy) / iResolution.y;\n\n    vec3 camPos = vec3(0.1f, 1.0f, 5.0f);\n    vec3 camDir = vec3(0.1f, 1.0f, 0.0f);\n\n    vec3 dir = normalize(camDir - camPos);\n    vec3 right = normalize(cross(dir, vec3(0.0f, 1.0f, 0.0f)));\n    vec3 up = normalize(cross(right, dir));\n\n    rayDirection = normalize(p.x * right + p.y * up + 3.0f * dir);\n    rayOrigin = camPos;\n}\n\nfloat rand(float x) {\n    return fract(sin(x) * 50000.0f);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n\n    float radius = 0.6f;\n    vec2 ctr = vec2(0.0f, 0.3f);\n    vec2 diff = p - ctr;\n\n    float width = 40.0;\n    float skylineHeight = rand((mod(trunc(p.x * width), width)));\n\n    float falloffFactor = 0.8;\n    skylineHeight *= 1.0 - abs(p.x) * falloffFactor;\n\n    float t = TMAX;\n    if(p.y > 0.0 && p.y * 2.7 < skylineHeight) {\n        fragColor = vec4(0.216, 0.165, 0.165, 1.0);\n        fragColor *= rand(p.y) * rand(p.x) * 3.0f;\n        t = 50.0f;\n    } else if(dot(diff, diff) < (radius * radius) && p.y > 0.0f) {\n        fragColor = vec4(1.0f, 0.55f, 0.28f, 1.0f) * step(fract(p.y * 10.) - p.y / 4., 8. / 10.0);\n        t = 5.0;\n    } else {\n        fragColor = mix(skyTop, skyBottom, .25 - p.y / 3.);\n    }\n\n    vec3 rayDir;\n    vec3 rayOrigin;\n    vec3 rayOriginDdx;\n    vec3 rayDirDdx;\n    vec3 rayOriginDdy;\n    vec3 rayDirDdy;\n\n    createRay(fragCoord, rayOrigin, rayDir);\n    createRay(fragCoord + vec2(1.0, 0.0), rayOriginDdx, rayDirDdx);\n    createRay(fragCoord + vec2(0.0, 1.0), rayOriginDdy, rayDirDdy);\n\n    vec3 pos;\n    vec3 nor;\n    int objectType = NONE;\n\n    float groundt = traceRay(rayOrigin, rayDir, pos, nor, objectType);\n\n    t = min(groundt, t);\n\n    vec3 posDdx = rayOriginDdx - rayDirDdx * dot(rayOriginDdx - pos, nor) / dot(rayDirDdx, nor);\n    vec3 posDdy = rayOriginDdy - rayDirDdy * dot(rayOriginDdy - pos, nor) / dot(rayDirDdy, nor);\n\n    vec2 uv = texCoords(pos, objectType);\n\n    vec2 uvDdx = texCoords(posDdx, objectType) - uv;\n    vec2 uvDdy = texCoords(posDdy, objectType) - uv;\n\n    if(objectType == PLANE) {\n        float color = gridTextureGradBoxFilter(uv, uvDdx, uvDdy);\n        fragColor = mix(vec4(217.0 / 255.0, 10.0 / 255.0, 217.0 / 225.0, 1.0f), vec4(133.0 / 255.0, 46.0 / 255.0, 106.0 / 255.0, 1.0f), color);\n    }\n\n    if(t < TMAX) {\n        fragColor = mix(fragColor, skyBottom, 1.0 - exp(-0.0001 * t * t));\n    }\n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3XDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 267, 267, 532], [534, 534, 562, 562, 672], [674, 674, 716, 716, 835], [837, 837, 933, 933, 1256], [1258, 1258, 1336, 1336, 1730], [1732, 1732, 1753, 1753, 1792], [1794, 1794, 1846, 1846, 3793]]}
{"id": "clcXWr", "name": "Plaid Dad", "author": "dandyandy", "description": "Hell is real!", "tags": ["shader"], "likes": 1, "viewed": 103, "published": 3, "date": "1685236192", "time_retrieved": "2024-07-30T17:53:38.401357", "image_code": "float sn(float f) {\n    return 0.5 + 0.5 * sin(f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float speed = 10.0;\n\n    vec3 col = vec3(1.0)\n        + 0.5 * vec3(1.0, 0.1, 0.5) * floor(sin((cos(iTime) * uv.x) * 100.0 + iTime * speed))\n        + 0.2 * vec3(0.0, 0.1, 0.5) * floor(sin((sin(iTime) * uv.y) * 100.0 - iTime * speed));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcXWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 52], [54, 54, 111, 161, 473]]}
{"id": "dldXz7", "name": "Ted Lasso Intro Seats", "author": "tristanantonsen", "description": "Ted Lasso intro seats - messy, but fun :)", "tags": ["fun", "tedlasso"], "likes": 6, "viewed": 180, "published": 3, "date": "1685221762", "time_retrieved": "2024-07-30T17:53:39.229144", "image_code": "// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( vec2 p0, vec2 c, vec2 b, vec4 r )\n{\n    vec2 p = p0-c;\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat arrayBox(vec2 p, vec2 size, vec2 spacing)\n{\n\n    vec2 arraySpacing = vec2(2. * (size + spacing));\n    vec2 asize = size + spacing;\n    vec2 pmin = floor(0.5 * p / asize) * asize;\n    vec2 pmax = ceil(0.5 * p / asize) * asize;\n    vec2 center = (pmin + pmax) / 2.0;\n    \n\n    vec2 r = mod(p, arraySpacing);\n    vec2 boxDims = vec2(size);\n    float d = sdRoundedBox(r+vec2(0., -size.y*0.5), vec2(size+spacing), boxDims, vec4(0.015,0.005,0.015,0.005));\n    float d2 = sdRoundedBox(r+vec2(0., size.y*1.), vec2(size+spacing), vec2(size.x*1.1, size.y/4.), vec4(0.0075));\n\n    return opSmoothUnion(d, d2, 0.0);\n\n}\n\nfloat SceneDist(vec2 p, vec2 size, vec2 spacing) {\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;\n\n    vec2 actualSize = size + spacing;\n    \n    float d = arrayBox(p, size, spacing);\n        \n    return d;\n}\n\nvec4 rowOfSeats(vec2 p, vec2 size, vec2 spacing) {\n    \n    \n    // box masking \n    vec2 actualSize = size + spacing;\n       \n    vec2 pmin = floor(0.5 * p / actualSize) * actualSize;\n    vec2 pmax = floor(0.5 * p / actualSize) * actualSize;\n    vec2 pcenter = mix(pmin, pmax, 0.5);\n\n    \n    float d = SceneDist(p, size, spacing) * 255.;\n    vec3 rgb1 = vec3(52, 117, 199) / 255.;\n    vec3 rgb2 = vec3(219, 87, 47) / 255.;\n    vec3 rgb3 = vec3(0.);\n    vec3 col1 = mix( rgb3, rgb2, 1.0-smoothstep(0.0,1.,d) );\n    vec3 col2 = mix( rgb3, rgb1, 1.0-smoothstep(0.0,1.,d) );\n    col1 =  col1 + vec3(0.07) * round(texture(iChannel0, pcenter).r);\n    col2 =  col2 + vec3(0.07) * round(texture(iChannel0, pcenter).r);\n    \n    // mouse\n    //vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;\n    vec2 m = vec2(0.95 * sin(0.25*iTime), 0.5 * sin(0.5*iTime));\n    \n    \n    float l = length(pcenter-m * 0.5);\n        \n    if (abs(pcenter.x-0.25) <= 0.01 || abs(pcenter.x+0.5) <= 0.01) {\n        return vec4(0.);   \n    } else {\n       float t = clamp(l/0.3-0.75, 0.0, 1.0);\n       return vec4(mix(col1, col2, smoothstep(0., 1., 25.*t)), 1.0);\n    \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.25 * (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n    \n    vec2 size = vec2(0.03, 0.025);\n    vec2 spacing = vec2(0.005, 0.015);\n    \n    vec4 seats = rowOfSeats(uv, size, spacing);\n        \n    \n    fragColor = max(seats, 0.15);\n    \n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldXz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 107, 107, 283], [285, 285, 337, 337, 436], [442, 442, 491, 491, 1054], [1056, 1056, 1106, 1106, 1281], [1283, 1283, 1333, 1363, 2445], [2447, 2447, 2504, 2554, 2811]]}
{"id": "dltXzM", "name": "Simplest 2D Pixel Traversal", "author": "fad", "description": "The simplest 2D pixel traversal algorithm - advancing to the next pixel is just two float additions (and a floor() to get the integer coordinate).", "tags": ["voxel"], "likes": 17, "viewed": 369, "published": 3, "date": "1685207799", "time_retrieved": "2024-07-30T17:53:40.064909", "image_code": "// The simplest 2D pixel traversal algorithm - advancing to the next\n// pixel is just two float additions (and a floor() to get the integer\n// coordinate). I accidentally discovered this method while trying to\n// come up with an algorithm for voxel traversal that only used integer\n// arithmetic. The one caveat is that when the ray passes exactly\n// through the corner of a pixel, it ends up double counting a pixel,\n// consequently not being watertight (uncomment lines 67/68 to see an\n// example). This could be fixed with some extra manual checks but at\n// that point it might just be more worth it to use the regular voxel\n// traversal algorithm.\n\n// It works by finding an alternative parameterization of the input ray,\n// R(T) = O + D * T, that for successive integer values of T returns\n// points in order of the pixels pierced by the original ray. Such a\n// parameterization unfortunately does not exist in 3D.\n\n#define RES_Y 9.0\nvec2 _p;\nvec2 _g;\nfloat _s;\nbool _b = false;\nfloat _c = 0.0;\n\nvoid visitPixel(vec2 p) {\n    _b = _b || p == _p;\n}\n\nvoid plotCircle(vec2 p) {\n    _c += max(RES_Y / _s * 0.01 - distance(p / _s, _g), 0.0);\n    _c = min(_c, 1.0);\n}\n\nvoid traverse(vec2 o, vec2 d, float tMax) {\n    vec2 s = 1.0 - 2.0 * step(d, vec2(0.0)); o *= s; d *= s;\n    // N is the number of pixels to visit, it's\n    // 1 + manhattan distance between floor(r(0)) and floor(r(tMax))\n    int N = int(dot(abs(floor(o + d * tMax) - floor(o)), vec2(1.0))) + 1;\n    vec2 O = s * (o * d.yx + d * (floor(o) + 1.0 - fract(o.yx))) / (d.x + d.y);\n    vec2 D = s * d / (d.x + d.y);\n    // R(T) = O + D * T\n    vec2 P = O;\n    \n    for (int n = 0; n < N; ++n) {\n        visitPixel(floor(P));\n        plotCircle(P);\n        P += D;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float s = RES_Y / iResolution.y; _s = s;\n    _p = floor(fragCoord * s);\n    _g = fragCoord;\n    vec2 o, d;\n    \n    if (iMouse.z > 0.0) {    \n        o = abs(iMouse.zw) * s;\n        d = iMouse.xy * s - o;\n    } else {\n        vec2 p1 = iResolution.xy * s * (vec2(cos(iTime * 1.3), sin(iTime * 1.2)) * 0.4 + 0.5);\n        vec2 p2 = iResolution.xy * s * (vec2(sin(iTime * 1.3), cos(iTime * 0.6)) * 0.4 + 0.5);\n        o = p1;\n        d = p2 - p1;\n    }\n    \n    // Uncomment to see corner intersection issue\n    // o = vec2(0.0);\n    // d = 4.0 * vec2(3.0, 2.0);\n    \n    traverse(o, d, 1.0);\n    \n    if ((int(_p.x) + int(_p.y)) % 2 == 0) {\n        fragColor.rgb = vec3(0.918,0.894,0.843);\n    } else {\n        fragColor.rgb = vec3(0.9647, 0.949, 0.906);\n    }\n    \n    if (_b) {\n        fragColor.rgb *= vec3(0.471, 0.549, 0.471);\n    }\n    \n    vec2 pa = fragCoord - o / s;\n    d /= s;\n\tfloat h = clamp(dot(pa, d) / dot(d, d), 0.0, 1.0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), clamp(1.5 - length(pa - h * d), 0.0, 1.0));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.745,0.937,0.792), _c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1001, 1001, 1026, 1026, 1052], [1054, 1054, 1079, 1079, 1166], [1168, 1168, 1211, 1211, 1733]]}
{"id": "cldXzM", "name": "Shader Art Intro Golf [227chars]", "author": "kishimisu", "description": "Based on my youtube tutorial: [url]https://youtu.be/f4s1h2YETNY[/url]", "tags": ["fractal", "sdf", "tutorial", "intro", "repetition", "code", "code", "youtube", "tuto", "short", "golf", "golfing", "creative"], "likes": 41, "viewed": 2186, "published": 3, "date": "1685187469", "time_retrieved": "2024-07-30T17:53:40.935087", "image_code": "/* Golfed version of my previous shader https://www.shadertoy.com/view/mtyGWy\n   I also simplified 6.28318 (2*PI) to 6. which slightly offsets the colors.\n   \n[533 -> 227 chars] */\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2  R = iResolution.xy,\n          u = (F+F-R) / R.y;\n    float i,  l = length(u);\n    \n    for (O *= i; i++ < 4.;\n         \n         O += pow(.04 / \n                 abs(\n                     sin(\n                         8. * ( length( u = fract(u * 1.5) - .5 ) / exp(l) ) \n                         + iTime\n                        ) // sin\n                    )  // abs\n              , 1.2) // pow\n              \n              * (1. + cos(6. * ( l + (i + iTime)*.4 + vec4(.26,.4,.56,0) )))\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldXzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 181, 217, 217, 723]]}
{"id": "Dl3SzM", "name": "PBR Path tracer attempt 4", "author": "pathtracerenthusiast", "description": "Not great. I importance sample cosine theta and run the pbr equations through it. It works, but again, smooth metals are way too dark.", "tags": ["pathtracer", "pbr"], "likes": 1, "viewed": 181, "published": 3, "date": "1685181532", "time_retrieved": "2024-07-30T17:53:42.002234", "image_code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings, go to the 'Buffer B' tab.\n//To set or rwmove the maximum number of frames or objects go to the 'Common' tab.\n\n#define Bloom\n\n#define exposure .8\n\n//I used the Bing AI to improve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  float n = 1./float(2*w*w);\n  const float invpi = 1./PI;\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      float weight = n*invpi*exp(-float(x*x+y*y)*n);\n      //float weight = 1.;\n      color += texture(s, uv).xyz*weight;\n    }\n  }\n  return color;\n}\n\n#define size 2.25*((R.x+R.y)*.00119048)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    vec2 p = R-10.;\n    #ifdef maxFrame\n    if(i.x>=p.x&&i.y>=p.y&&iFrame>maxFrame){o=vec4(1.);return;}\n    #endif\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    #ifdef Bloom\n    #ifdef maxFrame\n    if(iFrame>=maxFrame)\n    #endif\n    o.xyz += blur(iChannel1,i/R,int(size));\n    #endif\n    \n    \n    o.xyz *= exposure;\n    \n    o.xyz = ACESFilm(o.xyz);\n    o.xyz = linearToSRGB(o.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define maxFrame 256\n\n#define R iResolution.xy\n#define PI 3.1415926523\n#define d2r(a) a*(PI/180.)\n#define md(a,b) max(0.,dot(a,b))\n\nfloat _seed;\n// Thanks to Dave_Hoskin for the random numbers\nfloat rand(){\n    float v = fract(_seed*.1031);\n    v *= _seed + 33.33;\n    v *= _seed + _seed;\n    v += 34.35;\n    float a = fract(v);\n    _seed++;\n    _seed *= 2.*a;\n    return a;\n}\n\nvec2 rand2(){\n    vec3 p = fract(_seed*vec3(.1031,.103,.0973));\n    p += dot(p,p.yzx+33.33);\n    vec2 a = fract((p.xx+p.yz)*p.zy);\n    _seed++;\n    _seed *= a.x+a.y;\n    return a;\n}\n\nvoid irand(vec2 i,float t){\n    vec3 p = vec3(i.y,t,i.x);\n    p = fract(p*.1031);\n    p += dot(p,p.zyx+32.31);\n    _seed = fract((p.x+p.y)*p.z);\n}\n\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\n\n\nstruct Mat {\n    float r;\n    vec3 col;\n    vec3 ems;\n    float m;\n};\n\n\nstruct AABB {\n    vec3 minv,maxv;\n};\n\nstruct SphBody {\n    vec3 c;\n    float rad;\n    bool isActive;\n};\n\nstruct BoxBody {\n    vec3 pos,size,rot;\n    bool inverted, isActive;\n};\n\nstruct QuadBody {\n    vec3 v0,v1,v2,v3;\n    bool fn, isActive;\n};\n\nstruct Obj {\n    SphBody sph;\n    BoxBody box;\n    QuadBody quad;\n    Mat mat;\n    AABB bound;\n};\n\nstruct BVHNode {\n    AABB bound;\n    uint left,right;\n};\n\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct NewHit {\n    float len;\n    vec3 nor;\n    Obj o;\n    bool ff;\n};\n\nstruct IntRes {\n    float len;\n    bool ff;\n};\n\n#define DefaultSph SphBody(vec3(0.),0.,false)\n#define DefaultBox BoxBody(vec3(0.),vec3(0.),vec3(0.),false,false)\n#define DefaultQuad QuadBody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),false,false)\n\n#define objC 9\nstruct NewWorld {\n    Obj objs[objC];\n    Viewer camera;\n};\n\nObj Obj_Sphere(vec3 pos,float rad,Mat m){\n    AABB bound = AABB(pos-rad-.0001,pos+rad+.0001);\n    return Obj(SphBody(pos,rad,true),DefaultBox,DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowSphere(vec3 pos,float rad,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Sphere(pos,rad,m);\n    objlst[idx1] = Obj_Sphere(pos,thickness-rad,m);\n}\n\nObj Obj_Box(vec3 pos,vec3 size,vec3 rot,Mat m){\n    AABB bound = AABB(pos-2.*size-.001,pos+2.*size+.0001);\n    return Obj(DefaultSph,BoxBody(pos,size,rot,false,true),DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowBox(vec3 pos,vec3 size,vec3 rot,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Box(pos,size,rot,m);\n    AABB bound = AABB(pos-2.*abs(size)-.001+thickness,pos+2.*abs(size)+.0001-thickness);\n    objlst[idx1] = Obj(DefaultSph,BoxBody(pos,size-thickness,rot,true,true),DefaultQuad,m,bound);\n}\n\nObj Obj_Quad(vec3 v0,vec3 v1,vec3 v2,vec3 v3,bool fn,Mat m){\n    vec3 minv = min(min(v0,v1),min(v2,v3));\n    vec3 maxv = max(max(v0,v1),max(v2,v3));\n    AABB bound = AABB(minv,maxv);\n    return Obj(DefaultSph,DefaultBox,QuadBody(v0,v1,v2,v3,fn,true),m,bound);\n}\n\nIntRes newSphereInt( in vec3 ro, vec3 rd, SphBody sph) {\n    ro -= sph.c;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sph.rad*sph.rad;\n    float h = b*b - c;\n    if( h<0. ) return IntRes(-1.,false);\n    h = sqrt( h );\n    if(length(ro)<=sph.rad){\n        return IntRes(-b+h,false);\n    }else{\n        return IntRes(-b-h,true);\n    }\n}\n\nbool insideAabb(vec3 p,vec3 s){\n    return (p.x<=s.x&&p.x>=-s.x)&&(p.y<=s.y&&p.y>=-s.y)&&(p.z<=s.z&&p.z>=-s.z);\n}\n\nIntRes newBoxInt( in vec3 ro, in vec3 rd, BoxBody box) {\n    mat3 r = rot3(-box.rot);\n    \n    ro, rd *= r;\n    ro -= box.pos;\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*abs(box.size);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return IntRes(-1.,false);\n    if(insideAabb(ro,abs(box.size))){\n        return IntRes(tF,box.inverted);\n    }else{\n        return IntRes(tN,!box.inverted);\n    }\n}\n\nfloat newQuadInt(vec3 ro,vec3 rd,QuadBody q){\n    vec3 n = cross(q.v1-q.v0,q.v2-q.v0);\n    float d = dot(n, q.v0);\n    \n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    return -1.;\n}\n\nbool aabbInt(in vec3 ro,vec3 rd,AABB box){\n    vec3 a = .5*(box.maxv+box.minv);\n    vec3 d = .5*(box.maxv-box.minv);\n    vec3 m = 1./rd;\n    vec3 n = m*(ro-a); \n    vec3 k = abs(m)*d;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return false;\n    return true;\n}\n\n\n\nconst float bias = 1.0001;\nvec3 newBoxNor(vec3 p,BoxBody b){\n    vec3 q = p-b.pos;\n    vec3 d = b.size;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 cosDir2(vec3 N){\n    float u1 = rand(),u2 = rand(),\n    r = sqrt(1.-u1*u1),\n    phi = 2.*PI*u2;\n    vec3 dir = vec3(\n    cos(phi)*r,\n    sin(phi)*r,\n    u1\n    );\n    \n    vec3 up = N.z<1.?vec3(0.,0.,1.):vec3(0.,1.,0.),\n    tangent = normalize(cross(up,N)),\n    bitangent = cross(N,tangent);\n    \n    return tangent*dir.x +\n    bitangent*dir.y +\n    N*dir.z;\n}\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float z = rand()*2.-1.;\n    float r = sqrt(1.-z*z);\n    float x = r*cos(phi), y = r*sin(phi);\n\treturn vec3(x,y,z);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nvec3 hemi(vec3 h){\n    return reflect(uniformVec(),h);\n}\n\n\nvec3 LessThan(vec3 f, float val) {\n    return vec3(\n        (f.x < val) ? 1. : 0.,\n        (f.y < val) ? 1. : 0.,\n        (f.z < val) ? 1. : 0.);\n}\n \nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - .055,\n        rgb * 12.92,\n        LessThan(rgb, .0031308)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(((rgb + .055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        LessThan(rgb, 0.04045)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0., 1.);\n}\n\n// PBR functions\nvec3 fresnel(vec3 F0,float cosT){\n    return F0+(1.-F0)*pow(1.-cosT,5.);\n}\n\nfloat distribution(float NdH,float r){\n    float a2 = r*r*r*r,\n    denom = 1. + NdH*NdH*(a2-1.);\n    return a2 / (PI*denom*denom);\n}\n\nfloat g(float NdV,float or){\n    float r = or+1.,\n    k = r*r/8.,\n    denom = NdV*(1.-k) + k;\n    return NdV/denom;\n}\n\nfloat geo(vec3 N,vec3 V,vec3 L,float r){\n    float NdV = md(N,V),\n    NdL = md(N,L);\n    return g(NdV,r)*g(NdL,r);\n}", "buffer_a_code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n#define shutAp .6\n#define fcsDist 4.5\n#define blurAmt .001\n#define numLvls 16\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\n#define SkyMode 1\nconst float mode = 0.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\n\n\n//NOTE: Component order:\n// - Roughness [0,1]\n// - IOR (1,+Inf)\n// - Diffuse Color (Color)\n// - Specular Chance [0,1]\n// - Specular Color (Color)\n// - Refractive Chance [0,1]\n// - Refractive Absorption (Absorption3)\n//\n//NOTE: Refractive Chance + Specular Chance <= 0\n\nNewWorld getNewWorld(float t){\n    NewWorld world;\n    Viewer cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(0.,2.,-3.5));\n    \n    mat2 rx = rot(d2r(-5.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(0.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(0.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.objs[0] = Obj_Sphere(vec3(0.,-402.001,0.),400.,Mat(1.,vec3(.2,.5,1.),vec3(0.),0.));\n    //createObj_HollowSphere(vec3(-1.5,-.5,3.),1.5,.4,1,8,Mat(.2,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false),world.objs);\n    world.objs[1] = Obj_Sphere(vec3(-1.5,-.5,3.),1.5,Mat(.1,vec3(1.),vec3(0.),0.));\n    world.objs[2] = Obj_Sphere(vec3(1.5,-1.,2.),1.,Mat(.8,vec3(1.),vec3(0.),1.));\n    world.objs[3] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(3.5,-2.,-2.),vec3(3.5,-2.,3.5),vec3(-3.5,-2.,3.5),true,Mat(1.,vec3(1.),vec3(0.),.5));\n    world.objs[4] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(-3.5,1.5,-2.),vec3(-3.5,1.5,3.5),vec3(-3.5,-2.,3.5),false,Mat(1.,vec3(1.,.1,.1),vec3(0.),.5));\n    world.objs[5] = Obj_Quad(vec3(3.5,-2.,-2.),vec3(3.5,1.5,-2.),vec3(3.5,1.5,3.5),vec3(3.5,-2.,3.5),true,Mat(1.,vec3(.1,1.,.1),vec3(0.),.5));\n    //world.objs[6] = Obj_Quad(vec3(-3.5,5.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(-3.5,5.,3.5),false,Mat(1.,vec3(1.),vec3(0.),0.));\n    world.objs[7] = Obj_Box(vec3(0.,4.,.5),vec3(1.,.3,1.),d2r(vec3(0.)),Mat(1.,vec3(.75,.775,.9),vec3(10.),1.));\n    world.objs[8] = Obj_Box(vec3(0.,-1.25,-.5),vec3(.75),d2r(vec3(0.)),Mat(.2,vec3(1.),vec3(0.),1.));\n    //TODO: Generate bounding boxes\n    \n    \n    world.camera = cam;\n    return world;\n}\n\nNewHit newInt(vec3 ro,vec3 rd,Obj objs[objC]){\n    NewHit h;\n    h.len = -1.;\n    \n    for(int i = 0; i < objC; i++) {\n        Obj o = objs[i];\n        //if(!aabbInt(ro,rd,o.bound)) continue;\n        if(o.sph.isActive) {IntRes res = newSphereInt(ro,rd,o.sph);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.box.isActive) {IntRes res = newBoxInt(ro,rd,o.box);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.quad.isActive) {float res = newQuadInt(ro,rd,o.quad);if(res>=.0001&&(res<h.len||h.len<0.)){h.o=o;h.ff=true;h.len=res;}}\n    }\n    \n    Obj o = h.o;\n    vec3 p = ro+rd*h.len;\n    \n    if(o.sph.isActive) h.nor = normalize(p-o.sph.c);//*sign(o.sph.rad);\n    else if(o.box.isActive) {BoxBody b = o.box;mat3 r = rot3(b.rot);mat3 rn = rot3(-b.rot);h.nor = newBoxNor(b.pos+(p-b.pos)*rn,b)*r;}\n    else if(o.quad.isActive) {QuadBody q = o.quad;h.nor = normalize(cross(q.v1-q.v0,q.v2-q.v0))*(q.fn?-1.:1.);}\n    \n    //h.nor *= h.ff?1.:-1.;\n    \n    return h;\n}\n\nconst vec3 sunDir = normalize(vec3(.5,1.,.75));\n//Sebastian Lagues's sky function\nvec3 getSky(float t,vec3 rd) {\n    #if SkyMode == 1\n    float skyGradT = pow(smoothstep(0.,.4,rd.y),.35);\n    vec3 skyGrad = mix(vec3(.05),vec3(.3,.6,.9),skyGradT);\n    \n    vec3 sun = pow(max(0.,dot(rd,sunDir)),40.)*10.*vec3(1.,.85,.7);\n    \n    float groundT = smoothstep(-.01,0.,rd.y);\n    \n    return mix(vec3(.25),skyGrad,groundT)+sun;\n    #elif SkyMode == 0\n    return vec3(0.);\n    #elif SkyMode == 2\n    return SRGBToLinear(texture(iChannel1,rd).xyz);\n    #endif\n}\n\nvec3 newRay(inout vec3 ro,inout vec3 L,vec3 P,in vec3 N,Mat m,bool ff) {\n    vec3 oro = ro, V = -L;\n    ro = P;\n    L = cosDir(N);\n    vec3 H = normalize(L+V);\n    \n    vec3 F = fresnel(mix(vec3(.04),m.col,m.m),md(H,V));\n    float NDF = distribution(md(N,H),m.r);\n    float G = geo(N,V,L,m.r);\n    vec3 spec = NDF*G*F / (4.*md(N,L)*md(N,V) + .0001);\n    vec3 dif = m.col*(1.-F)*(1.-m.m)/PI;\n    \n    return (dif + spec);\n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    #ifdef maxFrame\n    if(iFrame>=maxFrame) {o=texelFetch(iChannel0,ivec2(i),0);return;}\n    #endif\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = floor(iTime*mode)/mode;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        NewWorld world = getNewWorld(ctime);\n        Viewer cam = world.camera;\n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        for(int _j = 0; _j<numLvls;_j++) {\n            NewHit hit = newInt(cam.ro,rd,world.objs); \n            if(hit.len==-1.) {tcol+=getSky(ctime,rd)*fcol;break;}                             \n            \n            vec3 p = hit.len*rd+cam.ro;\n            \n            Mat mat = hit.o.mat;\n            \n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat,hit.ff);\n            \n            #if 0\n            {\n                float r_p = max(.0001,max(fcol.x,max(fcol.y,fcol.z)));\n                if(rand()>r_p) break;\n                fcol /= r_p;\n            }\n            #endif\n        }\n        \n        ttcol += tcol;\n    }\n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n    //o = vec4(i*.001,.5,1.);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texture(iChannel0,i/R);\n    o /= o.w;\n    float d = dot(o.xyz,vec3(1.));\n    o.xyz = d>3.5?o.xyz:vec3(0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3SzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 299, 338, 338, 728]]}
{"id": "dt3XzM", "name": "Gradient Cllusion", "author": "moonLight7k", "description": "A gradient of circle creating illusion", "tags": ["circle", "shader"], "likes": 3, "viewed": 174, "published": 3, "date": "1685163712", "time_retrieved": "2024-07-30T17:53:43.258874", "image_code": "vec3 palette(float t){\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(0.1, 0.1, 0.1);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos( 6.28318*(c*t+d));\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord * 2.0 - iResolution.xy ) / iResolution.y;\n   \n\n    float d = length(uv);\n    \n    vec3 col = palette(d + iTime);\n\n\n    d = sin(d*8. + iTime)/4.;\n    d = abs(d);\n    \n    d = 0.02 / d-d;\n    \n    col-= d;\n\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3XzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 213], [216, 216, 273, 273, 541]]}
{"id": "Dl3XR7", "name": "rainbow pools", "author": "flylo", "description": "trig stuff", "tags": ["2d", "metal", "liquid"], "likes": 0, "viewed": 183, "published": 3, "date": "1685159954", "time_retrieved": "2024-07-30T17:53:44.407802", "image_code": "const int[18] ns = int[](-1, -1, 0, -1, 1, -1, -1, 0, 1, 0, 0, 0, -1, 1, 0, 1, 1, 1);\n\nvec4 texel(in ivec2 x) {\n    return texelFetch( iChannel0, x, 0 );\n}\n\nvec4 avg( in ivec2 px )\n{\n \n    vec4 sum = vec4(0.);\n        \n    for (int i = 0; i < 18; i += 2) {\n       vec4 n = texel(px+ivec2(ns[i%18],ns[(i%18)+1]));\n       sum += n;\n    }\n \n   return sum/9.;\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iv = ivec2(fragCoord);\n    fragColor = avg(iv);\n    fragColor = texel(iv);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float dt  = .5+.5*sin(.06*iTime);\n    float dt2 = .5+.5*sin(.18*iTime);\n    float mdt = dt;\n    float mdt2 = .7+.3*dt2;\n    \n    float dt3 = .5+.5*sin(.04*iTime);\n    float dt4 = .5+.5*sin(.33*iTime);\n    float mdt3 = dt3;\n    float mdt4 = .7+.3*dt4;\n\n    float dt5  = .5+.5*sin(.05*iTime);\n    float dt6 = .5+.5*sin(1.5+.19*iTime);\n    float mdt5 = dt5;\n    float mdt6 = .7+.3*dt6;\n\n    float dt7  = .5+.5*sin(.3*iTime);\n    float dt8  = .5+.5*sin(1.5+.2*iTime);\n    float mdt7 = .9+.1*dt7;\n    float mdt8 = .9+.1*dt8;\n\n\n    //uv = vec2(sin(25.*uv));\n\n    float r2 = length(uv)*length(uv);\n\n    vec3 c = vec3(mdt*sin(mdt2*5.2*uv.x), mdt3*sin(mdt4*6.1*uv.y), mdt5*.7*length(sin(mdt6*4.4*uv)));  \n   \n    //c = vec3(uv.x, uv.y, uv.x/uv.y);  \n    //c = vec3(1.+sin(21.*uv), 0.);\n  \n    for(int i = 0; i < 5; i++) {\n        //uv = vec2(sin(uv.x), sin(uv.y));\n        float r3 = length(c)*length(c)*length(c);\n        c = c*(1./(vec3(.1*mdt7+r3)));\n        c = tan(mdt8*c);\n        \n        //c = .2*vec3(1./(.079+r2*c.x), 1./(.075+r2*c.y), 1./(.05);\n        //uv = vec2(mdt5*sin(tan(.005*mdt3*uv.x)), mdt6*sin(tan(.2 + .5*mdt4*uv.y)));\n        //uv = vec2(115.*mdt5*tan(.3*uv.x), 1.); // 1.*mdt6*tan(.004*mdt4*uv.y));\n        //c = vec2(tan(1.*sin(1.2*mdt5*uv.x)), tan(1.*sin(1.2*mdt6*uv.y)));\n        //uv = vec2(uv.x*sin(r2)-uv.y*cos(r2), uv.x*cos(r2)+uv.y*sin(r2));\n        //uv = vec2(cos(.2*(uv.x-uv.y)), sin(.3*(uv.x-uv.y)));\n   \n    }\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3XR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 111, 111, 155], [157, 157, 182, 182, 361], [363, 363, 420, 420, 509]]}
{"id": "DtK3WK", "name": "Year of Truchets #025", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable)", "tags": ["3d", "raymarching", "truchet"], "likes": 18, "viewed": 270, "published": 3, "date": "1685141943", "time_retrieved": "2024-07-30T17:53:45.578673", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #025\n    05/26/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST   50.\n#define MIN_DIST   1e-4\n\n// rotation and hash and lerp functions\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.73,59.71)+iDate.z))*4832.3234); }\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq sdf's + extrude\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h ); return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat box(vec2 p,vec2 b){\n    vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat box(vec3 p, vec3 b){\n  vec3 q = abs(p)-b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\n// globals\nfloat tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,gtk,stk;\n\n// constants\nconst float sz = 3.5;\nconst float db = sz*4.;\nconst float hf = sz/2.;\nconst float rd = .025;\nconst float thict = .275;\n\nvec2 map (in vec3 p) {\n \tvec2 res = vec2(1e5,0);\n    p += hf;\n    // movement\n    p.z  += ga1;\n    p.x  += ga2;\n    \n    // sizing and mixdown\n    float thick = .14+.1*sin(p.z*.5+p.y*.75+T*1.75);\n    thick -= .1+.05*sin(p.x*1.25+T);\n    thick = mix(thict,thick,.5+.5*sin(T*.2));\n    gtk=thick;\n    \n    // id grid\n    vec3 q = p, id = floor((q + hf)/sz);\n    // 3d checkerd \n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    q = mod(q+hf,sz)-hf;\n    \n    float hs = hash21(id.xz+id.y);\n    float xhs = fract(35.37*hs);\n\n    if (hs>.5) q.y=-q.y;\n    if (chk>.5) q.xy=-q.xy;\n\n    vec3 q1,q2,q3;\n    float trh,trx,jre;\n    //draw\n    if(xhs>.75) {\n        q1 = q;\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(0,hf,hf);\n        \n        trh = opx(box(q1.xz,vec2(sz,thick)),q1.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.yz)-hf)-thick,q.x,thick)-rd;\n    } else {\n        q1 = q + vec3(hf,0,-hf);\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(hf,hf,0);\n \n        trh = opx(abs(length(q1.xz)-hf)-thick,q.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.xy)-hf)-thick,q.z,thick)-rd;\n    }\n    \n    if(trh<res.x) res = vec2(trh,2.);\n    if(trx<res.x) res = vec2(trx,3.);\n    if(jre<res.x) res = vec2(jre,4.);\n\n \treturn res;\n}\n\n// surface normal yo\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n        );\n    return normalize(n);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec4 FC = vec4(.005);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m;\n    // ray marcher\n    for(int i=0;i<80;i++) {\n        p=ro+rd*d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d+= i<30? ray.x*.35 : ray.x * .9;\n        m = ray.y;\n    }\n    stk=gtk;\n    if(d<MAX_DIST) {\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(hf,hf,-hf);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),.05,1.);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 25.)*.75;\n        vec3 clr = hsv2rgb(vec3(p.z*.062+stk*1.5+T*.02,.75,.35));\n        vec3 h = clr*clamp(diff+spec,0.,1.);\n        ref = h*.65;\n        C = h;\n        \n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } \n    C = mix(FC.rgb,C,exp(-.00055*d*d*d));\n    // fog level\n    return vec4(C,1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    // precal\n    tspeed = T*.65;\n    tmod = mod(tspeed,12.);\n    \n    float t1 = lsp(00.,03.,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    \n    float t2 = lsp(03.,06.,tmod);\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    float t3 = lsp(06.,9.,tmod);\n    t3 = eoc(t3); t3 = t3*t3*t3;\n    \n    float t4 = lsp(9.,12.,tmod);\n    t4 = eoc(t4); t4 = t4*t4*t4;\n    \n    ga1 = (t1*db)-(t3*db);\n    ga2 = (t2*db)-(t4*db);\n    \n    ga3 = (t1-t3)*PI;\n    ga4 = (t2-t4)*PI;\n\n    // screen uv\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    uv*=rot(ga3+ga4);\n    \n    // ray order+direction\n    vec3 ro = vec3(0,0,.1);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse //\n    float x = M.xy==vec2(0) || M.z <1. ? 0. : (M.y/R.y*.5-.25)*PI2;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*.5-.25)*PI2;\n\n    mat2 rx = rot(x+ga3), ry = rot(y-ga4);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C=vec3(0), ref=vec3(0), fil=vec3(1);\n    float d=0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00055*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtK3WK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[389, 429, 447, 447, 491], [492, 492, 513, 513, 577], [578, 578, 615, 615, 649], [650, 650, 669, 669, 696], [698, 720, 766, 766, 856], [857, 857, 882, 882, 956], [957, 957, 983, 983, 1063], [1271, 1271, 1293, 1293, 2631], [2633, 2654, 2684, 2684, 2881], [2883, 2900, 2927, 2927, 3043], [3067, 3067, 3161, 3161, 3975], [3977, 3977, 4018, 4036, 5361]]}
{"id": "cl3SzM", "name": "Rainbow Orbits 2", "author": "isaacchurchill", "description": "Integrating velocity and acceleration, with gravity\nNow with two moving gravity sources!", "tags": ["rainbow", "orbit", "gravity", "integration", "spirograph"], "likes": 11, "viewed": 224, "published": 3, "date": "1685135344", "time_retrieved": "2024-07-30T17:53:46.440368", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec2 lastPenPos = texelFetch(iChannel1, ivec2(1,0), 0).xy;\n    float circleSDF = abs(length(p - lastPenPos) - 0.05) - 0.003;\n    float circleStrength = smoothstep(-0.005, 0.005, -circleSDF);\n    vec3 penCol = 0.5 + 0.5 * sin(float(iFrame) * 0.1 + vec3(0,2,4));\n    \n    float gravSDF = min(length(p - grav1), length(p - grav2));\n    float gravCircleStrength = min(2.0 / pow(1.0 + gravSDF * 3.0, 20.0), 1.0);\n    vec3 gravCircleCol = vec3(1.0);\n    \n    float innerCirc = smoothstep(-0.01, 0.0, -abs(1.2 - length(p)));\n    float outerCirc = smoothstep(-0.01, 0.0, -abs(1.25 - length(p)));\n    float gradient = 1.0 / (1.0 + pow(length(p), 10.0));\n    vec3 stars = texture(iChannel2, p / 2.0).rgb;\n    vec3 background = stars * (0.075 + 0.2 * smoothstep(0.0, 0.01, length(p) - 1.25));\n    background += vec3(1.0,1.0,0.9) * ((innerCirc + outerCirc) * 0.7 + gradient * 0.15);\n    float visibility = smoothstep(-1.2,-1.0,-length(p));\n    vec4 col = texture(iChannel0, uv);\n    col.rgb = mix(background, col.rgb, col.a * visibility);\n    col.a = 1.0;\n    col.rgb = mix(col.rgb, gravCircleCol, gravCircleStrength);\n    col.rgb = mix(col.rgb, penCol, circleStrength);\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265\n\n#define PEN_THICKNESS 0.005\n#define FADE_RATE 0.002\n\n\n// Line segment SDF by iq\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n///////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n            \n    vec2 penPos = texelFetch(iChannel1, ivec2(0), 0).xy;\n    vec2 lastPenPos = penPos;\n    if (iFrame > 1) {\n        lastPenPos = texelFetch(iChannel1, ivec2(1,0), 0).xy;\n    }\n    float penSDF = sdSegment(p, lastPenPos, penPos) - PEN_THICKNESS;\n    float penStrength = smoothstep(-0.005, 0.005, -penSDF);\n    vec3 penCol = 0.5 + 0.5 * sin(float(iFrame) * 0.1 + vec3(0,2,4));\n    \n    vec4 col = texture(iChannel0, uv);\n    col.a *= 1.0 - FADE_RATE;\n    col.rgb = mix(col.rgb, penCol, penStrength);\n    col.a = max(col.a, penStrength);\n\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 path(vec4 p)\n{\n    float dt = 0.001;\n    vec2 grav1Pos = grav1;\n    vec2 grav2Pos = grav2;\n    \n    for (int i = 0; i < 50; i++) {\n        p.xy += p.zw * dt;\n        p.zw -= normalize(p.xy - grav1Pos) / max(length(p.xy - grav1Pos), 0.01) * dt;\n        p.zw -= normalize(p.xy - grav2Pos) / max(length(p.xy - grav2Pos), 0.01) * dt;\n    }\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lastState = vec4(1.0, 0.0, -0.5, 0.5); // xy = position, zw = velocity\n    if (iFrame > 0) {\n        lastState = texelFetch(iChannel0, ivec2(0), 0);\n    }\n    if (fragCoord.y < 1.0 && fragCoord.x > 1.0 && fragCoord.x < 2.0) {\n        fragColor = lastState;\n    } else if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor = path(lastState);\n    } else {\n        discard;\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define grav1 (0.5 * vec2(cos(iTime), sin(iTime)))\n#define grav2 (-grav1)", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3SzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1359]]}
{"id": "mttXzN", "name": "Fake Water Refraction", "author": "s_fx", "description": "Simple fake refraction.\nIt doesn't look fantastic but if you squint your eyes long enough it will look like flowing water.", "tags": ["refraction", "water"], "likes": 8, "viewed": 285, "published": 3, "date": "1685125796", "time_retrieved": "2024-07-30T17:53:47.312037", "image_code": "/*\n * Fake Water Refraction\n * (c) 2023 s.fx\n * \n * Modified and documented fork of\n * https://www.shadertoy.com/view/4t33z8\n * by thallippoli\n */\n\nconst float SCALE      = .1;                 // scale of noise texture\nconst float STRENGTH   = 1.5;                // amplitude of noise \nconst float OFFSET     = .03;                // offset amplitude\nconst float PI         = 3.1415926535897932; // it's just pi\nconst bool  BLUE_TINT  = true;               // toggle color grading\nconst vec3  BLUE       = vec3(.8, .8, 1.5);  // blue color for color grading\nconst float BLUE_RATIO = .5;                 // mix ratio for color grading\nconst bool  LIGHT      = true;               // toggle weird noise light effects\nconst float THRESHOLD  = .8;                 // threshold for dark areas in noise\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv     = fragCoord.xy / iResolution.xy;\n    vec2 warpUV = SCALE * uv;\n\n    // just shift the texture\n    vec2 st = warpUV + vec2(iTime * .1, iTime * .05);\n\n    // get value from noise (only one int8 channel) using coord and make it brighter\n    float warpedCol = texture(iChannel0, st).x * STRENGTH;\n\n    // offset for texture by calculating angle from noise\n    vec2 offset = OFFSET * vec2(cos(warpedCol * PI), sin(warpedCol * PI));\n\n    // query texture color at uv using offset vector\n    vec3 col = texture(iChannel1, uv + offset).rgb;\n\n    // give water blue tint\n    if (BLUE_TINT)\n        col = mix(col, col * BLUE, BLUE_RATIO);\n\n    // brighten up brick texture with noise\n    if (LIGHT)\n        col *= max(warpedCol, THRESHOLD);\n\n    fragColor = vec4(col,  1.);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[799, 799, 856, 856, 1638]]}
{"id": "clV3WK", "name": "Chladni plates", "author": "sheepmaster", "description": "Chladni patterns\n\nSee http://paulbourke.net/geometry/chladni/ or https://thelig.ht/chladni/.", "tags": ["2d", "waves", "interference", "oscillation", "chladni"], "likes": 10, "viewed": 206, "published": 3, "date": "1685122675", "time_retrieved": "2024-07-30T17:53:48.115888", "image_code": "const float BASE_SCALE = 1.;\nconst float STROKE_WIDTH = 1.;\nconst float PERIOD = 3.;\n\n// Rotate A and B if true, otherwise use the constant values below.\nconst bool ROTATE_A_B = true;\n\nconst float A = 1.;\nconst float B = 1.;\n\nconst float N = 6.;\nconst float M = 7.;\n\nconst float PI = 4. * atan(1.);\nconst float TAU = 2. * PI;\n\nvec3 f(float x, float y, float a, float b, float n, float m) {\n    return vec3(\n        a * sin(PI*n*x) * sin(PI*m*y) + b * sin(PI*m*x) * sin(PI*n*y),\n        PI * (a * n * cos(PI*n*x) * sin(PI*m*y) + b * m * cos(PI*m*x) * sin(PI*n*y)), \n        PI * (a * m * sin(PI*n*x) * cos(PI*m*y) + b * n * sin(PI*m*x) * cos(PI*n*y)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = BASE_SCALE / min(iResolution.x, iResolution.y);\n    vec2 uv = (2.0*fragCoord-iResolution.xy) * scale;;\n\n    float t = (fract(iTime / PERIOD) + .125) * TAU;\n    float a = ROTATE_A_B ? cos(t) : A;\n    float b = ROTATE_A_B ? sin(t) : B;\n\tvec3 f = f(uv.x, uv.y, a, b, N, M);\n    float d = abs(f.x) / length(f.yz);\n\n    float col = smoothstep(STROKE_WIDTH+1., STROKE_WIDTH-1., d/2./scale);\n    fragColor = vec4(vec3(col), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clV3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 389, 389, 653], [655, 655, 710, 710, 1152]]}
{"id": "cltXzN", "name": "Jansen's Linkages", "author": "SnoopethDuckDuck", "description": "Copied the dimensions from the wiki page:\nhttps://en.wikipedia.org/wiki/Jansen%27s_linkage\n\nI think I've done the motion in reverse but it looks more natural to me", "tags": ["motion", "walk", "kinematics", "linkage", "jansen"], "likes": 24, "viewed": 311, "published": 3, "date": "1685105198", "time_retrieved": "2024-07-30T17:53:49.015483", "image_code": "#define res iResolution.xy\n#define pi 3.14159\n#define Dir(a) vec2(cos(a),sin(a))\n#define ss(a, b) smoothstep(-a/res.y, a/res.y, b)\n\n// Distance macros\n#define m(p) d = min(d, length(uv - p));\n#define l(p, q) d2 = min(d2, seg(uv, p, q));\n\n// iq's IK\nvec2 solve(vec2 p, float r1, float r2, float side) {\n    float h = dot(p,p);\n    float w = h + r1*r1 - r2*r2;\n    float s = max(4.0*r1*r1*h - w*w,0.0);\n    return (w*p + side * vec2(-p.y,p.x)*sqrt(s)) * 0.5/h;\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 drawLeg(vec2 uv, float sc, float t) {\n    // Points\n    vec2 p = sc * vec2(38, 7.8);\n    vec2 pRot = p + sc * 15. * Dir(2. * t);\n    vec2 pIK1 = solve(pRot, sc * 41.5, sc * 50.0,  1.);\n    vec2 pIK1T = sc * 40.1 * Dir(atan(pIK1.y, pIK1.x) + 1.506);\n    vec2 pIK2 = solve(pRot, sc * 39.3, sc * 61.9, -1.);\n    vec2 pIK3 = pIK1T + solve(pIK2 - pIK1T, sc * 39.4, sc * 36.7, - 1.);\n    float a = atan(pIK3.y-pIK2.y, pIK3.x-pIK2.x);\n    vec2 pIK3T = pIK2 + sc * 49. * Dir(a + 1.73);\n    \n    // Point distances (could use dot then sqrt for better performance)\n    float d = length(uv);\n    m(p);\n    m(pRot);\n    m(pIK1);\n    m(pIK1T);\n    m(pIK2);\n    m(pIK3);\n    m(pIK3T);\n\n    // Segment distances\n    float d2 = 1e5;\n    l(vec2(0), pIK1);\n    l(vec2(0), pIK1T);\n    l(vec2(0), pIK2);\n    l(pIK1, pIK1T);\n    l(pIK1, pRot);\n    l(p, pRot);   \n    l(pIK2, pRot);    \n    l(pIK2, pIK3);\n    l(pIK2, pIK3T);\n    l(pIK1T, pIK3);\n    l(pIK3, pIK3T);    \n    \n    // Draw\n    float s = ss(1., 0.0125 - d);\n    float s2 = ss(1., 0.005 - d2);\n    return vec2(s, s2);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    float t = iTime;\n    \n    float sc = 0.0058;\n    \n    vec3 col = vec3(0);\n    const float n = 2.;\n    for (float i = 0.; i < n; i++) {\n        float io = (i+1.) / n;\n        vec2 leg = drawLeg(uv, sc, t + io * pi);\n        vec3 cLeg = vec3(max(leg.x, leg.y), leg.xx);\n        col = max(col, io * cLeg);\n    }\n    \n    O = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltXzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 249, 301, 301, 460], [462, 462, 506, 506, 625], [627, 627, 669, 683, 1691], [1693, 1693, 1735, 1735, 2117]]}
{"id": "dl3SzN", "name": "Greyscale Ordered Dithering 4x4", "author": "s_fx", "description": "Basic ordered dithering for greyscale image to black and white pixels.\nUses 4x4 Bayer matrix (instead of 8x8 Bayer channel).", "tags": ["dither", "dithering", "bayer"], "likes": 6, "viewed": 240, "published": 3, "date": "1685089708", "time_retrieved": "2024-07-30T17:53:49.765478", "image_code": "/*\n * Greyscale Ordered Dithering 4x4\n * (c) 2023 s.fx\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy; \n    mat4 bayer = mat4(\n        0.0000, 0.5000, 0.1250, 0.6250,\n        0.7500, 0.2500, 0.8750, 0.3750,\n        0.1875, 0.6875, 0.0625, 0.5625,\n        0.9375, 0.4375, 0.8125, 0.3125\n    );\n\n    uv += vec2(iTime * .02);\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // greyscale pixel by calculating average of all channels\n    float avg = (col.r + col.g + col.b) / 3.;\n    \n    // calculate coord in bayer matrix using modulo (4 as size of matrix)\n    // if greyscale darker than threshold in matrix use black else white\n    fragColor = vec4(bayer[int(fragCoord.x) % 4][int(fragCoord.y) % 4] < avg);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3SzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 117, 768]]}
{"id": "dtG3Wd", "name": "R.K. Infinite Truchet", "author": "FabriceNeyret2", "description": "WIP\ninspiration reference: https://twitter.com/KaufmanRoni/status/1660667547736219651\nNot sure how I should get the right sequence of transforms along time.", "tags": ["2d", "short", "reproduction"], "likes": 21, "viewed": 276, "published": 3, "date": "1685088720", "time_retrieved": "2024-07-30T17:53:50.521457", "image_code": "#define S(v) smoothstep( 4./R.y, -4./R.y, abs(v)-.025)  // AA draw thing stroke\n#define H(p) fract(sin(dot(p+1.7*floor(t/2.), vec2(12.9898, 78.233))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 2.* ( u+u - R ) / R.y,\n          I = floor(U+.5), Ic = mod(floor(2.*U),2.), // tile & subtile Id\n          F = fract(U)-.5,\n          A = abs(F),                            // all var#2 = ring continuing on neightbor subtile\n          F2 = F; int j,i = A.x>A.y ? 0: 1 ; F2[i] -= sign(F[i]);\n    float l = (length(F )-.05)*.78,  n = mod(l ,.1) - .05, N=-1., // ring Id\n         l2 = (length(F2)-.05)*.78, n2 = mod(l2,.1) - .05, \n          a = atan(F.y/F.x)/3.14,   a2 = atan(F2.y/F2.x)/3.14, b=a,b2=a2,\n          t = iTime/3., T = fract(int(t)%2<1?t:-t), T0 = T-1.;//-9 -T T-1 sequences over time\n          i = int(Ic.x+Ic.y) % 2, j=i;           // subtile mode\n  //int s = int(t)%4;                            // sequences over time\n  //if (s%2>0) T = 1.-T,  T0=T-1.;\n  //if (s<2) T0=T-1.; else T0 = 1.-T;\n    O *= 0.;\n    if ( l < 0. ) return;\n  //if ( mod(I.x+I.y  ,2.) < 1. ) O.b++;         // debug\n  //if ( mod(Ic.x+Ic.y,2.) < 1. ) O.g+=.3;       // debug\n    \n    if ( l < .2 )  O += S(n),N=l;                // ring 1, 2 ( center )\n  \n    if ( H(I+.3)<.5 )                            // ring 3, close\n             { if ( l>.2 && l < .3 && b  > T0 && b  < T )  O.r += S(n ), N=l; }\n    else {                                       // ring 3, connected\n        if ( H(I)<.5 ) b = -a, b2=-a2, j=1-i;\n        if ( j<1 )                          \n             { if ( l > .2 && l < .3 && b > T0 && b < T )  O.r += S(n ), N=l; \n               if ( l > .4           && b > T0 && b < T )  O.r += S(n ), N=l;  // ring 5 = 3 from neighbor\n             }\n        else   if ( l2> .4 && l2< .5 && b2> T0 && b2< T )  O.g += S(n2), N=l2; // ring 5 = 3 from neighbor\n    }\n    if (length(O)==0.) {                         // ring 4\n     // if ( H(I+.0)<.5 ) b = -a, b2=-a2, j=1-i; else b=a,b2=a2, j=i;\n        if ( j<1 ) \n             { if ( l > .3 && l < .4 && b > T0 && b < T )  O.r += S(n ), N=l; }\n        else   if ( l2< .4           && b2> T0 && b2< T )  O.g += S(n2), N=l2;\n    }    \n                                                // color scheme. comment for debug\n    O = max(O.r,O.g) * ( int(floor(N/.1))%2 > 0 ? vec4(1,.5,0,0) : vec4(1) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtG3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ml3SR4", "name": "Rainbow Orbits", "author": "isaacchurchill", "description": "Integrating velocity and acceleration, with gravity", "tags": ["rainbow", "orbit", "gravity", "integration", "spirograph"], "likes": 4, "viewed": 185, "published": 3, "date": "1685072897", "time_retrieved": "2024-07-30T17:53:51.869851", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec2 lastPenPos = texelFetch(iChannel1, ivec2(1,0), 0).xy;\n    float circleSDF = abs(length(p - lastPenPos) - 0.05) - 0.003;\n    float circleStrength = smoothstep(-0.005, 0.005, -circleSDF);\n    vec3 penCol = 0.5 + 0.5 * sin(float(iFrame) * 0.1 + vec3(0,2,4));\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col = mix(col, penCol, circleStrength);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265\n\n#define PEN_THICKNESS 0.005\n#define FADE_RATE 0.002\n\n\n// Line segment SDF by iq\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n///////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n            \n    vec2 penPos = texelFetch(iChannel1, ivec2(0), 0).xy;\n    vec2 lastPenPos = penPos;\n    if (iFrame > 1) {\n        lastPenPos = texelFetch(iChannel1, ivec2(1,0), 0).xy;\n    }\n    float penSDF = sdSegment(p, lastPenPos, penPos) - PEN_THICKNESS;\n    float penStrength = smoothstep(-0.005, 0.005, -penSDF);\n    vec3 penCol = 0.5 + 0.5 * sin(float(iFrame) * 0.1 + vec3(0,2,4));\n    \n    vec3 background = vec3(smoothstep(0.0, 0.07, 1.5 - length(p)));\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    if (iFrame > 0) {\n        col = mix(col, background, FADE_RATE);\n        col = mix(col, penCol, penStrength);\n    } else {\n        col = background;\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 path(vec4 p)\n{\n    float dt = 0.05;\n    \n    p.xy += p.zw * dt;\n    p.zw -= normalize(p.xy) / max(length(p.xy), 0.01) * dt;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lastState = vec4(1.0, 0.0, -0.5, 0.5); // xy = position, zw = velocity\n    if (iFrame > 0) {\n        lastState = texelFetch(iChannel0, ivec2(0), 0);\n    }\n    if (fragCoord.y < 1.0 && fragCoord.x > 1.0 && fragCoord.x < 2.0) {\n        fragColor = lastState;\n    } else if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor = path(lastState);\n    } else {\n        discard;\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3SR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 563]]}
{"id": "Dt3XR4", "name": "Year of Truchets #024", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nIf slow - turn AA off ", "tags": ["raymarching", "truchet", "tiles"], "likes": 18, "viewed": 194, "published": 3, "date": "1685061943", "time_retrieved": "2024-07-30T17:53:52.727558", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #024\n    05/25/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    glintz based off @tachyonflux https://www.shadertoy.com/view/ll2fzt\n\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST    50.\n#define MIN_DIST    1e-4\n\n// globals\nvec3 hit,hitPoint;\nfloat time=0.,spd=.3;\n\n// constants\nconst float size = 1.85;\nconst float hlf = size*.5;\n\nvec2 hash2( vec2 p ){ return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453);}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//@iq extrude\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec2 map(vec3 pos){\n    vec2 res = vec2(1e5,0);\n    pos.x-=spd;\n    \n    vec2 uv = pos.xz;\n    \n    vec2 id = floor(uv*size);\n    float rnd = hash21(id);\n    \n    float chk = mod(id.y+id.x,2.)*2.-1.;\n    vec2 q = fract(uv*size)-.5;\n    if(rnd>.5) q.x=-q.x; \n\n    vec2 cv = vec2(length(q-.5),length(q+.5));\n    vec2 p = cv.x<cv.y?q-.5:q+.5;\n    \n    float thc = .05+.045*sin(pos.x*1.63);\n          thc+= .05+.045*sin(pos.z*2.47);\n    \n    float k = length(p)-.5;k = abs(k)-thc;\n    \n    if(chk>.5) { \n        float tk = length(abs(q.x)-(thc*1.55))-(thc*.55);\n        k = max(min(length(q.x)-thc,length(q.y)-thc),-tk);\n    }\n\n    float d = opx(k,pos.y,.85*thc)-.01;\n    if(d<res.x) {\n        res = vec2(d,2.);\n        hit=vec3(q.x,pos.y,q.y);\n    }\n\n    float gnd = pos.y+.01;\n    float gnt = d-.05;\n    if(gnd<res.x) {\n        res = vec2(gnd,gnt<gnd?3.:1.);\n        hit=pos;\n    }\n\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n// reduced voronoi based off @iq\n// https://www.shadertoy.com/view/ldl3W8\nvec3 voronoi( in vec2 x) {\n    vec2 n = floor(x), f = fract(x);\n\tvec2 mg, mr;\n    float md = 8.,ox = 0.;\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md ){\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    md = 8.;\n\tvec2 o = hash2( n + mg );\n    ox = o.x;\n    return vec3(md,ox,mr.x);\n}\n\nvec3 vor3D(in vec3 p, in vec3 n ) {\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = voronoi(p.yz).xyz;\n    vec3 ty = voronoi(p.zx).xyz;\n    vec3 tz = voronoi(p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nvec3 glintz( vec3 lcol, vec3 pos, vec3 n, vec3 rd, vec3 lpos) {\n    vec3 mate = vec3(0);\n    vec3 h = normalize(lpos-rd);\n\n    float nh = abs(dot(n,h)), nl = dot(n,lpos);\n    vec3 light = lcol*max(.0,nl)*1.5;\n    vec3 coord = pos*1.5, coord2 = coord;\n\n    vec3 ww = fwidth(pos),glints=vec3(0),tcoord;\n    float pw,q,anisotropy;\n\n    for(int i = 0; i < 2;i++) {\n        if( i==0 ) {\n            anisotropy=.55;\n            pw=R.x*.20;\n            tcoord=coord;\n        } else {\n            anisotropy=.62;\n            pw=R.x*.10;\n            tcoord=coord2;\n        }\n\n        vec3 aniso = vec3(vor3D(tcoord*pw,n).yy, vor3D(tcoord.zyx*vec3(pw,-pw,-pw),n).y)*1.-.5;\n        if(i==0) {\n            aniso -= n*dot(aniso,n);\n            aniso /= min(1.,length(aniso));\n        }\n\n        float ah = abs(dot(h,aniso));\n        if( i==0 ) {\n            q = exp2((1.15-anisotropy)*2.5);\n            nh = pow( nh, q*4.);\n            nh *= pow( 1.-ah*anisotropy, 10.);\n        } else {\n            q = exp2((.1-anisotropy)*3.5);\n            nh = pow( nh, q*.4);\n            nh *= pow( 1.-ah*anisotropy, 150.);\n        }     \n\n        glints += (lcol*nh*exp2(((i==0?1.25:1.)-anisotropy)*1.3))*smoothstep(.0,.5,nl);\n    }\n    float fresnel = mix(0.,.95,pow(1.+dot(n,rd),2.));\n    return mix(light*vec3(0.3),vec3(.5),fresnel)+glints+lcol *.3;\n}\nmat2 rx,ry;\n\nvec3 renderFull( vec2 uv )\n{\n\n    vec3 ro = vec3(0,0,2.);\n    vec3 rd = normalize(vec3(uv,-1.));\n    \n    // mouse //\n    ro.xz*=ry;ro.zy*=rx;\n    rd.xz*=ry;rd.zy*=rx;\n\n    float d = 0.,m = 0.;\n    vec3 color = vec3(0), n = vec3(0),p = vec3(0);\n    \n    // marcher\n    for(int i=0;i<100;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.4: ray.x*.9;\n        m  = ray.y;\n    } \n    \n    hitPoint=hit;\n    \n    if (d < MAX_DIST) \n    {\n        vec3 n = normal(p, d);\n        vec3 lpos =vec3(8,0,8)+vec3(8.*sin(time*.45),12,6.*cos(time*.45));\n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(n,l),.05,1.);\n        \n        //shadows\n        float shdw = 1.;\n        for( float t=.01; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(l,n)),.0),24.);\n        vec3 h = vec3(0);\n        \n        if(m==3.) h = vec3(.0,.08,.16)*diff;\n        if(m==1.){\n            float mp = fract((p.x-spd-p.z)*2.);\n            float sw = smoothstep(.76,.77,sin(mp)*.5+.5);\n            vec3 cr = mix(vec3(0,.5,1),vec3(.95),sw);\n            vec3 hp = mix(hitPoint*.05,(p-vec3(spd,0,0))*.1,sw);\n            h = glintz(cr,hp, n, rd, l)*diff+spec;\n        }\n        if(m==2.){\n            float mp = clamp(sin(p.z+.75)*.5+.4,0.,1.);\n            h = glintz(vec3(.95), hitPoint*.3, n, rd, l)*diff+spec;\n        }\n        color = h;\n    }\n\n    return color;\n}\n\nfloat vmul(vec2 v) {return v.x * v.y;}\n\nvoid mainImage(out vec4 O, in vec2 F) { \n\n    //  precal //\n    vec3 col = vec3(0); \n    time = T; \n    spd = time*.15;\n\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.125-.0625)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*.125-.0625)*PI;\n\n    rx = rot(x-1.1);\n    ry = rot(y-.1*sin(time*.02));\n       \n    vec2 o = vec2(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    // set AA above renderFull\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    #endif\n    \tvec2 p = (-R.xy + 2. * (F + o)) / R.x;\n    \tcol += renderFull(p);\n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n\n    col = pow( col, vec3(0.4545) );\n\n    O = vec4(col, 0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3XR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[589, 589, 610, 610, 699], [700, 700, 721, 721, 781], [782, 782, 800, 800, 843], [845, 859, 908, 908, 1004], [1006, 1006, 1025, 1025, 1904], [1906, 1981, 2011, 2011, 2250], [2252, 2326, 2352, 2352, 2798], [2800, 2800, 2835, 2835, 3030], [3032, 3032, 3095, 3095, 4362], [4376, 4376, 4404, 4404, 6078], [6080, 6080, 6100, 6100, 6118]]}
{"id": "DtcXz4", "name": "2D SDF & Gradient", "author": "tristanantonsen", "description": "2D SDF & (unit) Gradient", "tags": ["sdf"], "likes": 1, "viewed": 186, "published": 3, "date": "1685060111", "time_retrieved": "2024-07-30T17:53:53.484534", "image_code": "float Circle(vec2 p, vec2 c, float r) {\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( vec2 p, vec2 b, vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba) - r;\n}\n\nfloat pointer(vec2 p, vec2 o, vec2 v)\n {\n     float l = 0.1;\n     vec2 p2 = p + l * v;\n     \n     return udSegment(p, o, p2, 0.01);\n \n }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat SceneDist(vec2 p0) {\n\n    // vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;\n    \n    vec2 p = Rot(-0.1 * iTime) * p0;\n    float l = 0.001;\n    \n    float c = Circle(p, vec2(-0.2,0), 0.2);\n    float c2 = Circle(p, vec2(0.2,0), 0.2);\n    \n    return opSmoothUnion(c, c2, 0.1);\n\n}\n\nvec2 GetNormal(vec2 p) {\n\n    float epsilon = 0.0001;\n    vec2 dx = vec2(epsilon, 0.);\n    vec2 dy = vec2(0., epsilon);\n\n    float ddx = SceneDist(p + dx) - SceneDist(p - dx);\n    float ddy = SceneDist(p + dy) - SceneDist(p - dy);\n    \n    return vec2(ddx, ddy);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;\n    \n    if (iMouse.z == 0.0) { m.x = 0.0; };\n    \n    vec3 col1 = vec3(255., 255.,255.) / 255.;\n    vec3 col2 = vec3(240.) / 255.;\n    float f = 1.;\n    \n    float d = SceneDist(uv) * 255.;\n    \n    vec4 solidColor = fragColor = vec4(vec3(0.25,0.25,0.25), 1.0);\n    \n    vec4 prettyColor = vec4(0.0);\n    float t = d;\n    vec2 n = GetNormal(uv);\n    float l = length(n);\n    //if (uv.x < 0.0) {\n    t = .0002 * t / l;\n    //};\n    float fac = 0.5 * sin(f * t - 2.0 * iTime) + 0.5;\n    prettyColor = vec4(mix(col1, col2, fac), 1.0);        \n\n    fragColor = mix(solidColor, prettyColor, smoothstep(0.0,1.0,d) );\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcXz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 69], [71, 123, 169, 169, 326], [328, 328, 388, 388, 515], [517, 517, 557, 557, 653], [655, 655, 707, 707, 806], [812, 812, 855, 855, 877], [879, 879, 898, 898, 960], [962, 962, 988, 1056, 1258], [1260, 1260, 1284, 1284, 1525], [1528, 1528, 1585, 1635, 2381]]}
{"id": "DtV3Dd", "name": "Pathmarched Sculpture", "author": "isaacchurchill", "description": "Pathtracing a distance field!\nHalf of the code is from other places; I listed attributions above the functions I used.\nI came up with this UV-to-starfield function using a noise texture that makes plausible-looking stars.\nUses the Preetham sky model.", "tags": ["3d", "raymarcher", "stars", "pathtracer", "sculpture", "preetham", "pathmarcher"], "likes": 5, "viewed": 303, "published": 3, "date": "1685049288", "time_retrieved": "2024-07-30T17:53:54.613515", "image_code": "#define SAMPLES 1\n\n#define RAYMARCH_MAX 250\n#define RAYMARCH_MAX_DIST 100.0\n#define RAYMARCH_EPS 0.001\n\n#define PATHTRACE_MAX 3\n\n#define MAT_DIFFUSE 0\n#define MAT_METAL 1\n\n#define PI 3.14159265\n\nmat2 planetRot;\nvec3 sunDir = normalize(vec3(0.2, -0.5, -1.0));\n\nmat2 rotmat(float theta)\n{\n    return mat2(cos(theta), sin(theta),\n                -sin(theta), cos(theta));\n}\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////\n// The functions in this section are from\n// https://www.shadertoy.com/view/XdyyDd\n// Copyright © 2019 Markus Moenig Distributed under The MIT License.\n/////////////////////////////////////////////////////////////\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n// The functions in this section are from\n// https://www.shadertoy.com/view/llyGDR\n//////////////////////////////////////////////////////////////////////////\n\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\n\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat Y = Yxy.r;\n\tfloat x = Yxy.g;\n\tfloat y = Yxy.b;\n\n\tfloat X = x * ( Y / y );\n\tfloat Z = ( 1.0 - x - y ) * ( Y / y );\n\n\treturn vec3(X,Y,Z);\n}\n\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\tmat3 M = mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n\n\treturn XYZ * M;\n}\n\n\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\n\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\n\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\n\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\n\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\n\treturn YxyToRGB( Yp );\n}\n\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n// From https://www.gamedev.net/forums/topic/687535-implementing-a-cube-map-lookup-function/5337472/\n//////////////////////////////////////////////////////////////////////////\n\nvec2 sampleCube(in vec3 v, out int faceIndex)\n{\n\tvec3 vAbs = abs(v);\n\tfloat ma;\n\tvec2 uv;\n\tif(vAbs.z >= vAbs.x && vAbs.z >= vAbs.y)\n\t{\n\t\tfaceIndex = v.z < 0.0 ? 5 : 4;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(v.z < 0.0 ? -v.x : v.x, -v.y);\n\t}\n\telse if(vAbs.y >= vAbs.x)\n\t{\n\t\tfaceIndex = v.y < 0.0 ? 3 : 2;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(v.x, v.y < 0.0 ? -v.z : v.z);\n\t}\n\telse\n\t{\n\t\tfaceIndex = v.x < 0.0 ? 1 : 0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(v.x < 0.0 ? v.z : -v.z, -v.y);\n\t}\n\treturn uv * ma + 0.5;\n}\n\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n// I tried to come up with an improved stars-from-noise algorithm\n// and I came up with this. \n// instead of just directly sampling from the noise texture and\n// raising it to a high power to only allow bright texels through,\n// it snaps the input UV to the center of each pixel (effectively\n// forcing nearest-sampling) and then uses the distance from the\n// actual UV coord to the centered UV coord to make the stars circular.\n// This has the effect of eliminating the artifacts from the other\n// method where stars sort of blend into each other and have weird shapes.\nvec3 calcStars(vec3 dir)\n{\n    const vec3 moonCol = vec3(1.0, 1.0, 0.85);\n    const float moonSize = 0.04;\n    const vec2 moonPos = vec2(0.25, 0.2);\n    \n    vec2 noiseTexRes = iChannelResolution[0].xy;\n\n    dir.yz *= transpose(planetRot);\n    int faceIndex;\n    vec2 uv = sampleCube(dir, faceIndex);\n    vec2 starsUV = (floor(uv * noiseTexRes) + 0.5) / noiseTexRes; // Snaps the uv to a texel center\n    vec2 texelOffset = (uv - starsUV) * noiseTexRes;\n    float starIntensity = pow(clamp(texture(iChannel0, starsUV).x, 0.0, 1.0), 50.0);\n\n    starIntensity *= 1.0 - pow(min(length(texelOffset * 4.0), 1.0), starIntensity);\n    vec3 col = vec3(starIntensity);\n    if (faceIndex == 5) {\n        float moonDist1 = length(uv - moonPos) - moonSize;\n        float moonDist2 = length(uv - moonPos - vec2(moonSize * 0.35)) - moonSize;\n        \n        float moonFactor1 = smoothstep(-0.003, 0.003, -moonDist1);\n        float moonFactor2 = smoothstep(-0.003, 0.003, moonDist2);\n        col = mix(col, moonCol * moonFactor1 * moonFactor2, moonFactor1);\n    }\n    return col;\n}\n\nvec3 sky(vec3 dir)\n{\n    \n    vec3 stars;\n    if (dir.y > 0.0) {\n        stars = calcStars(dir);\n        stars *= smoothstep(-0.1, 0.4, sunDir.y); // Fade out stars for daytime\n    }\n    dir.y = max(dir.y, 0.001);\n    vec3 preetham = max(calculateSkyLuminanceRGB(-sunDir, dir, 2.5) / 25.0, 0.0);\n    preetham *= clamp(0.3-sunDir.y, 0.0, 1.0) * 0.5 + 0.5; // Darken sky more during night\n    return preetham + stars;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n// The following code is from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\n//////////////////////////////////////////////////////////////////////////\n\nvec2 seed = vec2(0.0);\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n//vec3 getSample(vec3 dir) {\n//\treturn getSampleBiased(dir,0.0); // <- unbiased!\n//}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\treturn getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n        // Formula 34 in GI Compendium\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rand2n();\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n// By iq\n// from https://iquilezles.org/articles/distfunctions/\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n// By iq\n// from https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// By iq (modified)\n// from https://iquilezles.org/articles/distfunctions/\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// By iq\n// from https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n\n\n\n\n\n\n\nstruct Material {\n    vec3 col;\n    int type;\n};\n\nstruct SceneObj {\n    float dist;\n    Material mat;\n};\n\nSceneObj opUnion(in SceneObj a, in SceneObj b)\n{\n    if (a.dist <= b.dist) {\n        return a;\n    } else {\n        return b;\n    }\n}\n    \nSceneObj sculptureDE(vec3 p)\n{\n    Material redmat = Material(vec3(1.0, 0.05, 0.05), MAT_DIFFUSE);\n    Material whitemat = Material(vec3(1.0), MAT_METAL);\n\n    vec3 z = p;\n    z.yz *= rotmat(-0.6);\n    float cupDist = sdCutHollowSphere(z, 1.0, 0.3, 0.03);\n    SceneObj cup = SceneObj(cupDist, redmat);\n    \n    const float k = 0.3;\n    float metalDist = length(p) - 0.8;\n    metalDist = min(metalDist, length(p - vec3(0.0, 1.0, 0.0)) - 0.7);\n    metalDist = opSmoothUnion(metalDist,\n        sdTorus(p.yzx - vec3(2.0,0.0,0.0), vec2(0.7, 0.2)),\n        k);\n    const vec3 c = vec3(0.2);\n    float balls = length(opRep(p, c)) - 0.1;\n    metalDist = max(metalDist, balls);\n    SceneObj metal = SceneObj(metalDist, whitemat);\n    metal.mat.col = (0.5 + 0.5 * cos(round(p / c))).zyy;\n    \n    SceneObj sculp = opUnion(cup, metal);\n    \n    return sculp;\n}\n\nfloat sceneDE(vec3 p, out Material mat)\n{\n    SceneObj sculpObj = sculptureDE(p);\n\n    Material floorMat = Material(vec3(1.0), MAT_METAL);\n    float floorDispl = sin(length(p.xz * 10.0) - iTime) * 0.03;\n    floorDispl /= max(length(p.xz), 1.0);\n    float floorDist = p.y + 1.0 + floorDispl;\n    SceneObj floorObj = SceneObj(floorDist, floorMat);\n    \n    SceneObj scene = opUnion(sculpObj, floorObj);\n    mat = scene.mat;\n    return scene.dist * 0.5;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    const vec2 eps = vec2(0.001, 0.0);\n    Material temp = Material(vec3(0.0), 0);\n    float centerDist = sceneDE(p, temp);\n    vec3 v = vec3(sceneDE(p + eps.xyy, temp),\n                  sceneDE(p + eps.yxy, temp),\n                  sceneDE(p + eps.yyx, temp)) - centerDist;\n    \n    return normalize(v);\n    \n}\n\nbool raymarch(in vec3 ro, in vec3 rd, out vec3 hit, out vec3 norm, out Material mat)\n{\n    float t = 0.0;\n    vec3 p = ro;\n    for (int i = 0; i < RAYMARCH_MAX && t < RAYMARCH_MAX_DIST; i++) {\n        float dist = sceneDE(p, mat);\n        if (dist < RAYMARCH_EPS) {\n            norm = calcNormal(p);\n            hit = p;\n            return true;\n        }\n        t += dist;\n        p += dist * rd;\n    }\n    return false;\n}\n\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n// Most of this function was taken from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\n/////////////////////////////////////////////////////////////////////\n\nvec3 pathtrace(vec3 ro, vec3 rd)\n{\n    float sunSize = 1E-3; // Hemisphere area covered by the sun\n    float sunStrength = max(-sunDir.y, 0.0); // To make sunsets be darker then midday\n    \n    vec3 luminance = vec3(1.0);\n    vec3 direct = vec3(0.0);\n    \n    for (int i = 0; i < PATHTRACE_MAX; i++) {\n        vec3 hit = vec3(0.0);\n        vec3 norm = vec3(0.0);\n        Material mat = Material(vec3(0.0), 0);\n        if (raymarch(ro, rd, hit, norm, mat)) {\n            vec3 newStartPos = hit + norm * RAYMARCH_EPS * 2.0;\n            if (mat.type == MAT_DIFFUSE) {\n                rd = getCosineWeightedSample(norm);\n                luminance *= mat.col;\n                // Direct lighting\n                vec3 sunSampleDir = getConeSample(-sunDir,sunSize);\n                float sunLight = dot(norm, sunSampleDir);\n                vec3 temp1;\n                vec3 temp2;\n                Material temp3;\n                if (sunLight>0.0 && !raymarch(newStartPos,sunSampleDir, temp1, temp2, temp3)) {\n                    direct += luminance*sunLight*sunStrength;\n                }\n                ////////////////////////////\n            } else if (mat.type == MAT_METAL) {\n                rd = reflect(rd, norm);\n                luminance *= mat.col;\n            }\n            ro = newStartPos;\n        } else {\n            vec3 backgroundCol = sky(rd) + pow(max(dot(rd, -sunDir), 0.0), 200.0);\n            return direct + luminance * backgroundCol;\n        }\n    }\n\n    return direct;\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 c = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n\n    planetRot = rotmat(iTime * 0.25);\n    sunDir.yz *= planetRot;\n\n    vec3 ro = vec3(0.0, 0.0, -3.0); // Camera position\n    vec3 rd = normalize(vec3(c, 1.0));\n\n    vec3 col = vec3(0.0);\n    for (int samp = 0; samp < SAMPLES; samp++) {\n        seed = hash21(hash12(fragCoord) + float(samp) * 0.0123398 + float(iFrame));\n        col += pathtrace(ro, rd);\n    }\n    col /= float(SAMPLES);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtV3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 286, 286, 370], [700, 700, 722, 722, 864], [891, 891, 913, 913, 1038], [1468, 1468, 1512, 1512, 1550], [1552, 1552, 1582, 1582, 1727], [1729, 1729, 1759, 1769, 1925], [1928, 1928, 1958, 1958, 2031], [2033, 2033, 2140, 2140, 2537], [2539, 2539, 2604, 2604, 3398], [3400, 3400, 3522, 3522, 3638], [3640, 3640, 3707, 3707, 4232], [4723, 4723, 4770, 4770, 5220], [5455, 6026, 6052, 6052, 7093], [7095, 7095, 7115, 7115, 7512], [7800, 7800, 7815, 7815, 8048], [8050, 8050, 8070, 8164, 8245], [8247, 8247, 8293, 8293, 8553], [8641, 8641, 8681, 8681, 8717], [8719, 8719, 8763, 8802, 9053], [9273, 9337, 9399, 9461, 9667], [9669, 9733, 9766, 9766, 9831], [9833, 9908, 9944, 9944, 9979], [9981, 10045, 10097, 10097, 10196], [10312, 10312, 10360, 10360, 10445], [10451, 10451, 10481, 10481, 11300], [11302, 11302, 11343, 11343, 11754], [11756, 11756, 11781, 11781, 12094], [12096, 12096, 12182, 12182, 12520], [12783, 12783, 12817, 12817, 14270], [14488, 14488, 14545, 14545, 15079]]}
{"id": "dtdSRH", "name": "rmr glitch demo", "author": "juk", "description": "simple squares glitch + fish eye", "tags": ["glitchfisheye"], "likes": 2, "viewed": 191, "published": 3, "date": "1685039817", "time_retrieved": "2024-07-30T17:53:55.372486", "image_code": "// нужно зажать мышь и поводить туда сюда\n// когда нибудь потом привяжу силу эффекта к скорости мышки\n\n#define PI 3.14159265359\n#define u_radius 0.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\n    float strength = (1.0 + sin(float(iTime)))*0.5;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 muv = iMouse.xy / iResolution.xy;\n\n    vec2 diff = uv - iMouse.xy / iResolution.xy;\n    float distance = length(diff);\n\n    float scale = (1.0 - cos(distance/u_radius * PI * 0.5));\n    scale +=\n    (\n        mod(uv.x-muv.x, 0.1 * strength) +\n        mod(uv.y-muv.y, 0.1 * strength)\n    ) / ((1.0 + distance)*0.8);\n    \n    vec2 fishUv = iMouse.xy / iResolution.xy + normalize(diff) * u_radius * scale;\n    \n    uv = uv * (1.0 - strength) + fishUv *  strength;\n    \n\n    fragColor = vec4(texture(iChannel0, uv).xyz, 1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdSRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 286, 286, 921]]}
{"id": "dl3SRr", "name": "Triskelion", "author": "rrrola", "description": "Neon circles blooming into a fractal hexagonal grid.", "tags": ["triangle", "circle", "kaleidoscope", "hexagon", "glow", "rainbow", "rotation"], "likes": 27, "viewed": 632, "published": 3, "date": "1685026281", "time_retrieved": "2024-07-30T17:53:56.227201", "image_code": "// Neon circles blooming into a fractal hexagonal grid.\n// Inspiration:\n// - https://www.shadertoy.com/view/mly3Dd - Glowing concentric circles + square grid folding\n// - https://www.shadertoy.com/view/NtBSRV - Hexagonal cells\n\n//#define TETRASKELION  // if hexagons offend you\n\nvec3 pal(float a) { return 0.5 + cos(3.0*a + vec3(2,1,0)); }  // Biased rainbow color map. Will be squared later.\n\nvec2 fold(vec2 p) {  // Shift and fold into a vertex-centered grid.\n#ifdef TETRASKELION\n  return fract(p) - 0.5;\n#else\n  vec4 m = vec4(2,-1, 0,sqrt(3.));\n  p.y += m.w/3.0;      // center at vertex\n  vec2 t = mat2(m)*p;  // triangular coordinates (x →, y ↖, x+y ↗)\n  return p - 0.5*mat2(m.xzyw) * round((floor(t) + ceil(t.x+t.y)) / 3.0);  // fold into hexagonal cells\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime / 4.0, t2 = t * 0.618034, t3 = t * 1.4142135;  // dissonant timers\n  mat2 M = mat2(cos(t),sin(t), -sin(t),cos(t)) * (1.0 - 0.1*cos(t2));  // rotation and scale: 0.9 [smooth] .. 1.1 [fractal]\n\n  vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;  // y: -1 .. 1\n  float d = 0.5*length(p);  // animation phase is based on distance to center\n\n  vec3 sum = vec3(0);\n  for (float i = 0.0; i < 24.0; i++) {\n    p = fold(M * p);                                            // rotate and scale, fold\n    sum += pal(0.01*i - d + t2) / cos(d - t3 + 5.0*length(p));  // interfering concentric circles\n    // Use pal(...)/abs(cos(...)) for additive circles. I like the interference effect without the abs.\n  }\n  \n  fragColor = vec4(0.0002*sum*sum, 1);  // square the sum for better contrast\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl3SRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 298, 298, 339], [394, 394, 413, 461, 775], [777, 777, 832, 832, 1637]]}
{"id": "dtcSR8", "name": "BLF opPipeJoint", "author": "iY0Yi", "description": "A joint part is generated automatically at the crossing point of the three-axis pipes.", "tags": ["maptoy"], "likes": 22, "viewed": 287, "published": 3, "date": "1685023677", "time_retrieved": "2024-07-30T17:53:57.158711", "image_code": "// sdf function to define joint axis.\nfloat sdPipeJointCutter(vec3 p, vec3 mask, vec3 dir){\n    p = dir*-p + (1.-abs(dir))*abs(p); // uni or bi direction\n    p *= mask;                         // axis mask\n    return max(p.x, max(p.y,p.z));     // sdf: cutting planes\n}\n\n// a fancy boolean function generates joint part of pipes\nfloat opPipeJoint(float d, float dCutter, float t, float l){\n    float dPipe = abs(d-t*.5)-t*.5;\n    dCutter = dCutter-l;\n    float dEdge = length(vec2(dPipe, dCutter));        // sdf: edges\n    float dCap = mix(dCutter, dEdge, step(0.,dPipe));  // sdf: caps (cutting planes + edges)\n    float dJoint = mix(dPipe, dCap, step(0.,dCutter)); // sdf: the joint (caps + body)\n    return dJoint;\n    return min(d, dJoint); // return with the pipes\n}\n\n// vec4 version vec4(dist, rgb)\nvec4 opPipeJoint(vec4 dPipe, vec4 dCutter, float t, float l){\n    dPipe.x = abs(dPipe.x-t*.5)-t*.5;\n    dCutter.x = dCutter.x-l;\n    float dEdge = length(vec2(dPipe.x, dCutter.x));        // sdf: edges\n    float dCap = mix(dCutter.x, dEdge, step(0.,dPipe.x));  // sdf: caps (cutting planes + edges)\n    float dJoint = mix(dPipe.x, dCap, step(0.,dCutter.x)); // sdf: the joint (caps + body)\n    return (dPipe.x<dJoint) ? dPipe : vec4(dJoint, dCutter.yzw);\n}\n\nfloat map(vec3 p){\n    float r = .3;//+sin(iTime*.5)*.1;\n    float l = 3.;\n    float t = .1;\n    float jl = 1.+sin(iTime*2.)*.25;\n    float cr = .025+sin(iTime)*.025;\n    \n    r+=iWheel.y*.0001;\n    \n    float offl = l+r*.25;\n    float px = sin(iTime)*offl;\n    float py = cos(iTime+PI*.5)*offl;\n    float pz = cos(iTime+PI*.5)*offl;\n    float x = sdCapsule(p.yxz+vec3(0,px,0),l+t,r);\n    float y = sdCapsule(p.zyx+vec3(0,py,0),l+t,r);\n    float z = sdCapsule(p.xzy+vec3(0,pz,0),l+t,r);\n    \n    float pipes = opUniS(x,y,t);\n    pipes = opUniS(pipes,z,t);\n    \n    float dx = sign(px)*step(0.,(abs(px)-offl*.5));\n    float dy = sign(py)*step(0.,(abs(py)-offl*.5));\n    float dz = sign(pz)*step(0.,(abs(pz)-offl*.5));\n    vec3 dir = vec3(dx,dy,dz);\n    float cps = sdPipeJointCutter(p, vec3(1,1,1), dir);\n    float joint = opPipeJoint(pipes-cr, cps, t-cr*2., jl)-cr;\n    \n    // rivets\n    vec3 q = dir*-p + (1.-abs(dir))*abs(p);\n    float rivetsX = length(vec3((mod(atan(q.z,q.y)/PI,.2)-.1)*1.5, length(vec2(q.y,q.z)), q.x)-vec3(0,r+t,jl-t))-.025;\n    float rivetsY = length(vec3((mod(atan(q.z,q.x)/PI,.2)-.1)*1.5, length(vec2(q.x,q.z)), q.y)-vec3(0,r+t,jl-t))-.025;\n    float rivetsZ = length(vec3((mod(atan(q.x,q.y)/PI,.2)-.1)*1.5, length(vec2(q.x,q.y)), q.z)-vec3(0,r+t,jl-t))-.025;\n    float rivets = max(min(rivetsX,min(rivetsY,rivetsZ)), cps-jl);\n    \n    RED(x);\n    GREEN(y);\n    COBALT(z);\n    YELLOW(joint);\n    ORANGE(rivets);\n    \n    joint = min(joint, rivets);\n    return min(pipes, joint) * .9;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uniform vec3 iWheel;\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\nfloat opUniS(float a,float b,float r){\n\tfloat h = max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r){\n  p.y=abs(p.y);\n  p.y-=clamp(p.y,0.,h);\n  return length(p)-r;\n}\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 30.\n#define STEP_MAX 100\n\n// Markers: 8 colors\n#define cRED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n#define cGREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n#define cPURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n#define cYELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n#define cORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n#define cCOBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n#define cBLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n#define cBLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n\nfloat tRED = 1.;\nfloat tGREEN = 1.;\nfloat tPURPLE = 1.;\nfloat tYELLOW = 1.;\nfloat tORANGE = 1.;\nfloat tCOBALT = 1.;\nfloat tBLUE = 1.;\nfloat tBLACK = 1.;\n#define RED(v) tRED = step(DIST_MIN*10., v)\n#define GREEN(v) tGREEN = step(DIST_MIN*10., v)\n#define PURPLE(v) tPURPLE = step(DIST_MIN*10., v)\n#define YELLOW(v) tYELLOW = step(DIST_MIN*10., v)\n#define ORANGE(v) tORANGE = step(DIST_MIN*10., v)\n#define COBALT(v) tCOBALT = step(DIST_MIN*10., v)\n#define BLUE(v) tBLUE = step(DIST_MIN*10., v)\n#define BLACK(v) tBLACK = step(DIST_MIN*10., v)\n\n#define INIT_CAM_POS vec3(2,-1,2)*1.\n#define CAM_DIST 5.\n#define CAM_INIT_SCALE 3.\n#define TURN_TABLE_SPEED .25\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(1,.95,.9)*.8)\n#define THM_GRID (vec3(.1,.2,.25)*1.7)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(1)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc char(U,64+CAPS+c);\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\n#define render() \\\nbool isTurntable = false;\\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nfloat char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;}\\\n    return 0.;\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=min(0,iFrame); i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=min(0,iFrame); i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED+PI*.25), 1, cos(iTime*TURN_TABLE_SPEED+PI*.25))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz)*1.5;\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz);\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(4.2)), g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col*= (tRED<.5)?cRED:vec3(1);\\\n    col*= (tGREEN<.5)?cGREEN:vec3(1);\\\n    col*= (tPURPLE<.5)?cPURPLE:vec3(1);\\\n    col*= (tYELLOW<.5)?cYELLOW:vec3(1);\\\n    col*= (tORANGE<.5)?cORANGE:vec3(1);\\\n    col*= (tCOBALT<.5)?cCOBALT:vec3(1);\\\n    col*= (tBLUE<.5)?cBLUE:vec3(1);\\\n    col*= (tBLACK<.5)?cBLACK:vec3(1);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(2.2)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x<.5;\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(1.-THM_GRID,vec3(2.2)),1);\\\n    drawDebug(fragColor);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n  \n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcSR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 91, 91, 269], [271, 329, 389, 389, 772], [774, 806, 867, 867, 1262], [1264, 1264, 1282, 1282, 2775]]}
{"id": "mlcXzH", "name": "Bouncing Rainbow Ball", "author": "jtb1977", "description": "Bouncing Rainbow Ball", "tags": ["ball", "rainbow", "bouncing"], "likes": 4, "viewed": 190, "published": 3, "date": "1685019158", "time_retrieved": "2024-07-30T17:53:58.050326", "image_code": "vec3 rgb(float lng) {\n  float h = mod(6.0 * lng / DOUBLE_PI, 6.0);\n  float x = 1.0 - abs(mod(h, 2.0) - 1.0);\n  if (h < 1.0)\n    return vec3(1.0, x, 0.0);\n  if (h < 2.0)\n    return vec3(x, 1.0, 0.0);\n  if (h < 3.0)\n    return vec3(0.0, 1.0, x);\n  if (h < 4.0)\n    return vec3(0.0, x, 1.0);\n  if (h < 5.0)\n    return vec3(x, 0.0, 1.0);\n  return vec3(1.0, 0.0, x);\n}\n\nvec2 circleDistance(in vec2 cur, in vec2 origin, in float size) {\n    float aspect = iResolution.x / iResolution.y;\n    return (cur - origin) / size * vec2(aspect, 1.0);\n}\n\nvec2 inverseProject(in vec2 circle) {\n    float cosC = sqrt(1.0 - pow(length(circle), 2.0));\n    float lat = circle.y * HALF_PI;\n    float lng = atan(circle.x / cosC);\n    return vec2(lat, lng);\n}\n\nvec3 rainbowBall(in vec2 cur, in vec2 origin, in float size, in float latBase) {\n    vec2 circle = circleDistance(cur, origin, size);\n    if (length(circle) > 1.0) return vec3(0.0);\n    vec2 latLng = inverseProject(circle);\n    float lng = latLng[1] + latBase;\n    float shade = sqrt(1.0 - pow(length(circle), 2.0));\n    float p = mod(latLng[0], PARALLEL) < 0.015 || mod(latLng[1] + latBase, PARALLEL) < 0.015 ? 0.8 : 1.0;\n    return p * shade * rgb(lng);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 scaled = fragCoord / iResolution.xy;\n    float xRange = 0.5 - 0.3 * iResolution.y / iResolution.x;\n    vec2 origin1 = vec2(0.5, 0.3) + vec2(xRange * cos(X_SPEED * PI * iTime), 0.3 * abs(sin(Y_SPEED * PI *iTime)));\n    float size = 0.2 + 0.1 * sin(iTime);\n    vec3 rb = rainbowBall(scaled, origin1, size, mod(iTime, DOUBLE_PI));\n    if (length(rb) > 0.)\n        fragColor = vec4(rb, 1.0);\n    else\n        fragColor = vec4(0.2 + 0.2 * sin(iTime), scaled.y < 0.3 ? 0.3 : 0.2, 0.2, 1.0);\n}", "image_inputs": [], "sound_code": "vec2 note(float freq, float time, float fade) {\n    return vec2(sin(DOUBLE_PI * freq * time) * exp(-fade*time));\n}\n\nvec2 fullNote(float freq, float time, float fade, int count) {\n    vec2 total = vec2(0.);\n    for (int i = 0; i < count; i++)\n        total += note(freq * float(i+1), time, fade) * pow(0.5, float(i));\n    return total;\n}\n\nvec2 mainSound( int samp, float time ) {\n    float deltaSinceYBounce = mod(time * Y_SPEED, 1.);\n    int d1 = int(3. - 2. * cos(time * Y_SPEED / 8.));\n    vec2 n1 = fullNote(55., deltaSinceYBounce, 4., d1);\n    \n    float delta2 = mod(deltaSinceYBounce + 0.5, 1.);\n    int d2 = int(2. - 2. * cos(time * Y_SPEED / 4.));\n    vec2 n2 = 0.2 * fullNote(55. * pow(2.,.25), delta2, 8., d2);\n\n    float yBounceTime = time - deltaSinceYBounce;\n    float xBounceRelPos = 0.5 + 0.5 * cos(X_SPEED * PI * yBounceTime);\n    vec2 stereo = vec2(1. - xBounceRelPos, xBounceRelPos);\n\n    return n1 * stereo + n2;\n}", "sound_inputs": [], "common_code": "const float PI = 3.1415926535;\nconst float DOUBLE_PI = PI * 2.;\nconst float HALF_PI = PI / 2.;\nconst float PARALLEL = PI / 12.;\nconst float BPM = 120.;\nconst float Y_SPEED = BPM / 60.;\n\nconst float X_SPEED = 0.5;\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcXzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 363], [365, 365, 430, 430, 536], [538, 538, 575, 575, 734], [736, 736, 816, 816, 1193], [1195, 1195, 1250, 1250, 1746]]}
{"id": "dlcSz8", "name": "scanning line, scanner", "author": "zyc", "description": "scanning line, scanner", "tags": ["scanner", "scanningline"], "likes": 1, "viewed": 208, "published": 3, "date": "1685015488", "time_retrieved": "2024-07-30T17:53:58.920001", "image_code": "#define lineWidth 0.01\n#define PI 3.14159265359\n\nvec3 lineColor(float v) {\n    return vec3(v, 0.0, 0.0) + v*v;\n}\n\nvec3 genLine(float base, float p) {\n    float f = abs(base - p);\n    float v = lineWidth / (abs(f) + lineWidth);\n    return clamp(lineColor(v), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float progress = fract(iTime*0.5);\n    \n    vec3 col = genLine(uv.x, progress);\n    \n    vec4 oColor = texture(iChannel0, uv);\n    float a = col.r / oColor.r;\n    fragColor = mix(oColor, vec4(col, 0.0), a);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcSz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 74, 74, 112], [114, 114, 149, 149, 270], [272, 272, 329, 329, 582]]}
{"id": "dsGXDt", "name": "Easy Text in Shaders", "author": "kishimisu", "description": "Framework containing the text utilities I created to easily display text in my previous neural network shader", "tags": ["utility", "string", "display", "alphabet", "debug", "character", "fonts", "characters", "char", "manipulation"], "likes": 76, "viewed": 2892, "published": 3, "date": "1685012324", "time_retrieved": "2024-07-30T17:53:59.772721", "image_code": "/*    \n   [ A new version is available that greatly improves performance! ] \n   \n         ==>   https://www.shadertoy.com/view/43t3WX   <==\n       \n   \n   It can be hard manipulate the definition and drawing of strings in shaders, it often\n   relies on arrays of numbers that are tidious to update manually and are pretty \n   obfuscated compared to the original text.\n   \n   This shader tries to provide an easier framework for string manipulation where you\n   can simply declare a string like this:\n   \n       makeStr(printHello) _H _e _l _l _o  __  _w _o _r _l _d    _end\n   \n   And directly use it in any function (More info in the \"Common\" tab):\n   \n       finalCol += printHello(uv);    \n*/\n\n// String declarations\nmakeStr(printStr1)      _E _a _s _y __ _w _a _y __ _t _o __ _p _r _i _n _t __ _t _e _x _t __  _i _n __ _S _h _a _d _e _r _s _EXC _end\nmakeStr(printNum)       _P _r _i _n _t __ _S _t _a _t _i _c __ _D _i _g _i _t _s __ _2 _0 _2 _3                                  _end\nmakeStr1i(printDynNum)  _A _n _d __ _D _y _n _a _m _i _c __ _D _i _g _i _t _s __ _dig(i)                                         _end\nmakeStr1f(printDecNum)  _D _e _c _i _m _a _l __ _N _u _m _b _e _r _s __ _T _o _o __ _dec(i, 3)                                   _end\nmakeStr2f(printDynChar) _S _u _p _p _o _r _t _s __ _D _y _n _a _m _i _c __ _C _h _a _r _a _c _t _e _r _s __ _ch(i) __ _ch(j)     _end\nmakeStr(printSpecial)   _A _n _d __ _e _v _e _n __ _S _p _e _c _i _a _l __ _C _h _a _r _s __ _EXC _NUM _MUL _DIV _AT _UND        _end\n\nmakeStr(printLong)      _W _o _r _k _s __ _f _o _r __ _a _l _l __ _t _e _x _t __ _s _i _z _e _s \n                        _COM __ _e _v _e _n __ _t _h _e __ _l _o _n _g _e _r __ _o _n _e _s __  \n                        _i _f __ _y _o _u __ _s _c _a _l _e __ _t _h _e __ _u _v _s _EXC                                         _end\n\n// Color declarations\n#define RED     vec3( 1,.3,.4)\n#define GREEN   vec3(.2, 1,.4)\n#define BLUE    vec3(.2,.8, 1)\n#define RAINBOW abs(cos(uv.x + vec3(5,6,1)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized uv coordinates\n    vec2 uv = fragCoord / iResolution.y;\n    \n    // Final color\n    vec3 col = vec3(0);\n    \n    // Font Size (higher values = smaller font)\n    const float font_size = 9.;\n    \n    uv *= font_size;        // Scale font with font_size\n    uv.y -= font_size - 1.; // Start drawing from the top\n    \n    \n    col += RED * printStr1(uv);                       // \"Easy way to print text in shaders\"    \n    uv.y += 2.; // Move the cursor down\n    \n    col += GREEN * printNum(uv);                      // \"Static Digits\"\n    uv.y++;\n    \n    col += GREEN/.6 * printDynNum(uv, int(iTime)%10); // \"Dynamic Digits\"\n    uv.y++; \n    \n    col += GREEN/.4 * printDecNum(uv, iTime);         // \"Decimal Numbers\"\n    uv.y+=2.;\n    \n    col += BLUE * printDynChar(uv, mod(iTime, 26.), mod(iTime*2., 26.)); // \"Dynamic Characters\"\n    uv.y++;\n    \n    col += RAINBOW  * printSpecial(uv);                // \"Special Characters\"\n    uv.y+=.7;\n    \n    uv *= 2.; // Multiply uv by 2 to make it smaller\n    \n    col += printLong(uv);                              // \"Works for all text sizes...\"\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*   ### How to use this shader ? ###\n   \n   = Setup =\n   0. Copy the content of the Common Tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n   \n   = Declare String =\n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printAnother) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n   \n   = Print String =\n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printAnother(uv);\n   \n   Note that by default a character has a height of 1 (which is full height if \n   the coordinates are normalized). You are responsible for scaling/offsetting \n   the uvs to control the text placement before calling the function.\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _EXC _QUOT ... (see Common)\n   \n   \n   ### Javascript string generator helper ###\n   \n   To make things even easier, I've made a tiny javascript helper function that you\n   can use to convert strings to the right _F _o _r _m _a _t !\n   (I've written it in the comments of this shader)\n   \n   \n   ### Special functions ###\n   \n   _dig(i)       : write a specific digit [i ranges between 0-9]\n   _dec(i, prec) : write a floating point number [prec: number of decimals to print]\n   _ch(i)        : Write an uppercase character [i ranges between 0-25]\n   \n   To use these special functions, you need to pass additional parameters into makeStr:\n   \n   \"makeStr1i\" allows you to pass 1 int parameter named \"i\" :\n   \n   makeStr1i(test) _dig(i) _end\n   test(uv, 5);\n   \n   \"makeStr1f\" allows you to pass 1 float parameter named \"i\":\n   \n   makeStr1f(test) _dec(i, 3) _end\n   test(uv, 5.);\n   \n   You can also create your own makeStr with any parameter type! (see below)\n   \n   \n   ### Help me optimize it! ###\n   \n   The _dec() function is only for debug purposes, I've never used it in a published shader.\n   It's *very* intensive and can have rounding issues (ie 21.999 when the float is 22.), \n   however it's done with a pretty naive approach so if you can come up with a better one\n   I'd be glad! The function is defined at the very end of this tab.\n*/\n\n/// SETTINGS ///\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel0\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n\n/// SPECIAL FUNCTIONS ///\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n\n/// SPECIAL CHARACTERS ///\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n\n/// CHARACTER DEFINITIONS ///\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).r * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    (0 _DOT ); // Print a dot\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "mtcXR8", "name": "Wonky Watch", "author": "dr2", "description": "Pocket watch with inexact timekeeping (up to +/- 10m) - only correct twice a day, just like Lewis Carroll's stopped clock, or when mouse pressed.", "tags": ["time", "clock", "date"], "likes": 10, "viewed": 211, "published": 3, "date": "1685004725", "time_retrieved": "2024-07-30T17:54:00.747116", "image_code": "// \"Wonky Watch\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Pocket watch with inexact timekeeping (up to +/- 10m) - only correct\n// twice a day, just like Lewis Carroll's stopped clock, or when mouse pressed.\n\n#define AA  1   // optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Fbm2 (vec2 p);\n\nvec4 dateCur;\nvec3 ltDir, qHit;\nvec2 aaCs[3], wRotCs;\nfloat dstFar, tCur, tShift;\nint nFrame, idObj;\nconst int idFace = 1, idHandS = 2, idHand = 3, idAx = 4, idHub = 5,\n   idCase = 6, idWnd = 7, idClsp = 8;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  p.xz = Rot2Cs (p.xz, wRotCs);\n  p.yz = p.zy * vec2 (-1., 1.);\n  q = p;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (- q.z, q.x) / (2. * pi) + 0.5 : 0.;\n  d = 0.9 * max (length (vec2 (r - 1.05, q.y)) - 0.08 - 0.003 * abs (sin (256. * pi * a)), 1.01 - r);\n  DMINQ (idCase);\n  d = PrCylDf (q.xzy, 1.05, 0.05);\n  d = max (d, - max (length (vec2 (q.xz - vec2 (0., -0.5))) - 0.252, 0.03 - q.y));\n  d = min (d, PrTorusBxDf ((q - vec3 (0.7, 0.05, 0.)).xzy, vec3 (0.06, 0.06, 0.01), 0.007));\n  DMINQ (idFace);\n  q = p;\n  q.z -= 1.16;\n  d = PrCylDf (q, 0.03, 0.06);\n  DMINQ (idClsp);\n  q.z -= 0.14;\n  d = PrSphDf (q, 0.1);\n  DMINQ (idWnd);\n  d = PrTorusDf (q.xzy, 0.015, 0.13);\n  DMINQ (idClsp);\n  q = p;\n  q.y -= 0.06;\n  d = PrCylDf (q.xzy, 0.02, 0.04);\n  DMINQ (idAx);\n  q = p;\n  q.yz -= vec2 (0.04, -0.5);\n  d = PrCylDf (q.xzy, 0.015, 0.02);\n  DMINQ (idAx);\n  q = p;\n  q.yz -= vec2 (0.045, -0.5);\n  d = PrCylDf (q.xzy, 0.03, 0.008);\n  DMINQ (idHub);\n  q.xz = Rot2Cs (q.xz, aaCs[0]);\n  q.z -= -0.1;\n  d = PrRoundBoxDf (q, vec3 (0.008, 0., 0.1), 0.005);\n  DMINQ (idHandS);\n  q = p;\n  q.y -= 0.07;\n  d = PrCylDf (q.xzy, 0.04, 0.007);\n  DMINQ (idHub);\n  q.xz = Rot2Cs (q.xz, aaCs[1]);\n  q.z -= -0.4;\n  d = PrRoundBoxDf (q, vec3 (0.015, 0., 0.4), 0.005);\n  DMINQ (idHand);\n  q = p;\n  q.y -= 0.09;\n  d = PrCylDf (q.xzy, 0.04, 0.007);\n  DMINQ (idHub);\n  q.xz = Rot2Cs (q.xz, aaCs[2]);\n  q.z -= -0.3;\n  d = PrRoundBoxDf (q, vec3 (0.01, 0., 0.3), 0.005);\n  DMINQ (idHand);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p.xz = Rot2Cs (p.xz, wRotCs);\n  p.yz = p.zy * vec2 (-1., 1.);\n  q = p;\n  d = max (PrSphDf (q - vec3 (0., -7.35, 0.), 7.5), max (length (q.xz) - 1.05, - q.y));\n  return d;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col, skCol;\n  vec2 u;\n  float el, f;\n  skCol = vec3 (0.1, 0.15, 0.6);\n  el = asin (rd.y);\n  rd.xz = Rot2D (rd.xz, 0.01 * tCur);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (skCol, vec3 (0.8, 0.8, 0.7), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, skCol, smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nfloat LabSym (vec2 p)\n{  // (from \"Booze Cruise\")\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec3 DialCol (vec2 p)\n{\n  vec3 col, c;\n  vec2 q;\n  float a, f, s;\n  col = vec3 (1.);\n  c = vec3 (0.3);\n  q = p;\n  s = length (q);\n  a = atan (q.x, q.y) / pi;\n  if (abs (fract (6. * a + 0.5) - 0.5) < 0.03 && abs (s - 0.95) < 0.05 ||\n     abs (fract (30. * a + 0.5) - 0.5) < 0.1 && abs (s - 0.97) < 0.03 ||\n     abs (6. * a) < 0.03 && abs (s - 0.92) < 0.08) col = c;\n  col = mix (col, c, SmoothBump (0.98, 1., 0.005, s));\n  q = (p - vec2 (0., -0.5)) / 0.25;\n  s = length (q);\n  a = atan (q.x, q.y) / pi;\n  if (abs (fract (6. * a + 0.5) - 0.5) < 0.03 && abs (s - 0.93) < 0.07 ||\n     abs (6. * a) < 0.03 && abs (s - 0.85) < 0.15) col = c;\n  col = mix (col, c, SmoothBump (0.96, 1., 0.01, s));\n  if (Maxv2 (abs (p - vec2 (0.7, 0.))) < 0.065) {\n    col = vec3 (0.5);\n    if (ShowInt (p - vec2 (0.755, -0.045), 0.3 * vec2 (0.4, 0.3), 2., dateCur.z) != 0.)\n       col = vec3 (0.7, 1., 1.);\n  }\n  s = LabSym (8. * (p - vec2 (0., 0.4)));\n  col = mix (mix (col, vec3 (0., 0., 0.8), smoothstep (-0.05, -0.01, s)),\n     vec3 (1., 1., 0.2), smoothstep (0.01, 0.05, s));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  float dstObj, dstTrObj, gRot, sh, rFac, nDotL;\n  wRotCs = CosSin (0.2 * pi * sin (0.1 * pi * tCur));\n  gRot = (dateCur.w + tShift) * 720. / (12. * 3600.);\n  aaCs[0] = CosSin (2. * pi * (floor (60. * gRot) + smoothstep (0.7, 1., fract (60. * gRot))) / 60. - pi);\n  gRot /= 60.;\n  aaCs[1] = CosSin (2. * pi * gRot - pi);\n  gRot /= 12.;\n  aaCs[2] = CosSin (2. * pi * gRot - pi);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    rFac = 0.;\n    if (idObj == idFace) {\n      if (qHit.y > 0.) {\n        col4 = vec4 (DialCol (qHit.xz), 0.);\n      } else {\n        col4 = vec4 (0.7, 0.6, 0.1, 0.2);\n        col4.rgb *= 1. - 0.3 * smoothstep (-0.02, 0., LabSym (8. * qHit.xz));\n        rFac = 0.2;\n      }\n    } else if (idObj == idHandS) {\n      col4 = (tShift == 0.) ? vec4 (0., 1., 0., 0.2) : vec4 (1., 0., 0., 0.2);\n    } else if (idObj == idHand) {\n      col4 = (abs (qHit.x) < 0.007 && qHit.y > 0.) ? vec4 (0.3, 1., 0.3, 0.2) :\n         vec4 (0.3, 0.3, 0.3, 0.);\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.6, 0.6, 0.5, 0.2);\n    } else if (idObj == idHub) {\n      col4 = vec4 (0.3, 0.3, 0.3, 0.);\n    } else if (idObj == idCase) {\n      col4 = vec4 (0.7, 0.6, 0.1, 0.2);\n      rFac = 0.2;\n    } else if (idObj == idWnd) {\n      col4 = vec4 (0.7, 0.6, 0.1, 0.2);\n      if (abs (qHit.z) < 0.08) col4 *= 0.5 +\n         0.5 * smoothstep (0.4, 0.5, fract (16. * (atan (qHit.x, qHit.y) / (2. * pi) + 0.5)));\n      rFac = 0.2;\n    } else if (idObj == idClsp) {\n      col4 = vec4 (0.7, 0.7, 0.3, 0.2);\n      rFac = 0.5;\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == idCase || idObj == idClsp || idObj == idWnd) nDotL *= nDotL;\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = col4.rgb * (0.3 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n       0.7 * sh * nDotL) + col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col = mix (col, 0.8 * BgCol (reflect (rd, vn)), rFac);\n  } else {\n    col = BgCol (rd);\n  }\n  ro = roo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    col = mix (col, 0.8 * BgCol (reflect (rd, vn)), 0.03 + 0.9 * pow (1. - abs (dot (vn, rd)), 4.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  tShift = (mPtr.z > 0.) ? 0. : 600. * sin (2. * pi * dateCur.w / (24. * 3600.));\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0.2, -8.);\n  zmFac = 5.5;\n  dstFar = 100.;\n  ltDir = normalize (vec3 (0.3, 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.0001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcXR8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1183, 1183, 1205, 1205, 2730], [2732, 2732, 2765, 2765, 2949], [2951, 2951, 2972, 2972, 3227], [3229, 3229, 3253, 3253, 3449], [3451, 3451, 3486, 3486, 3671], [3673, 3673, 3696, 3696, 3953], [3955, 3955, 3992, 3992, 4220], [4222, 4222, 4244, 4244, 4664], [4666, 4666, 4689, 4715, 5114], [5116, 5116, 5139, 5139, 6188], [6190, 6190, 6225, 6225, 8549], [8551, 8551, 8607, 8607, 9712], [9714, 9714, 9760, 9760, 9807], [9809, 9809, 9842, 9842, 9869], [9871, 9871, 9913, 9913, 9964], [9966, 9966, 10012, 10012, 10069], [10071, 10071, 10117, 10117, 10198], [10200, 10200, 10222, 10222, 10249], [10251, 10251, 10273, 10273, 10300], [10302, 10302, 10359, 10359, 10442], [10444, 10444, 10480, 10480, 10686], [10688, 10688, 10718, 10718, 10831], [10833, 10833, 10864, 10864, 10928], [10930, 10930, 10953, 10953, 11057], [11130, 11130, 11162, 11162, 11710], [11712, 11712, 11772, 11772, 12315], [12349, 12349, 12373, 12373, 12485], [12487, 12487, 12512, 12512, 12696], [12698, 12698, 12719, 12719, 12874]]}
{"id": "mlX3DN", "name": "Fork Stephen Wi TestCoder 551", "author": "TestCoder", "description": "For my best Stephen William Hawking! (2018.3.14)\nMaybe this can express Hawking how to explain this Universe!", "tags": ["texture", "photo", "image", "mr", "hawking", "s3tc"], "likes": 22, "viewed": 1209, "published": 3, "date": "1684996273", "time_retrieved": "2024-07-30T17:54:02.604151", "image_code": "/********************************************\n    Stephen William Hawking.glsl webgl2.0 Created by 834144373\n    2018.3.17\n\tPS：834144373 is TNWX or 恬纳微晰 or 祝元洪\n*********************************************/\n/*\n\tThis Hawking Cover Texture Compression technology is used by custom S3TC  \n\tAnd it's also 4bpp!\n\t1. BufA,BufB and BufC is fast store full 31bit float into 32bit float buffer,\n\t2. BufD is S3TC Decoder,\n\t3. Image is show result.\n\nIf you want to know more about GPU Texture Compression,\n\t\tthe below Texture Compression Can help you.:)\n------------------------------------------------------------------------\nAll About Image Decompresion: https://www.shadertoy.com/playlist/7scBzN\n------------------------------------------------------------------------\nATC            4bpp : https://www.shadertoy.com/view/lt2fRz by 834144373\nDXT1           4bpp : https://www.shadertoy.com/view/MtBfRR by 834144373\nBC4            4bpp : https://www.shadertoy.com/view/Xlffz2 by 834144373\nShaderToyTC I  1bpp : https://www.shadertoy.com/view/MtyGzV by 834144373\nPVRTC          4bpp : https://www.shadertoy.com/view/ltV3zD by 834144373\nYUV Special    2bpp : https://www.shadertoy.com/view/XlGGzh by 834144373\n...more Confidentiality Texture Compression will be coming soon and GIF!!!\n------------------------------------------------------------------------\n\nNode : Yes! You didn't read the wrong words!\n       more Confidentiality Texture Compression will be coming soon!!!\n\t   Crack Crack and Crack!!!\n*/\n\n//---------------------Function-------------------\nfloat box(vec2 p,vec2 size,float r){\n\treturn length(max(abs(p)-size,0.)) - r;\n}\n\n//--------------------------------------------------------\n//from https://www.shadertoy.com/view/MslGWN by CBS\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\nvec3 nrand3( vec2 co ){\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\nvec4 Universe(vec2 U ) {\n    vec2 uv = 2. * U.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\treturn mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\n\t\n}\n\n// \"Cosmic Cycles\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Music:\n// https://soundcloud.com/weareallastronauts/ether\n//\n// Starfields used to be super cool back in the day. It was one of the first\n// effects I ever made sometime at the end of the 1980's. \n// This started out as a normal star field (comment out BURST to see)\n// After trying it with a circle inversion I decided to make it into some\n// sort of big bang scenario.\n\n#define BURST\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Star(vec2 uv, float a, float sparkle) {\n    vec2 av1 = abs(uv);\n \tvec2 av2 = abs(uv*Rot(a));\n    vec2 av = min(av1, av2);\n    \n    vec3 col = vec3(0);\n    float d = length(uv);\n    float star = av1.x*av1.y;\n    star = max(av1.x*av1.y, av2.x*av2.y);\n    star = max(0., 1.-star*1e3);\n    \n    float m = min(5., 1e-2/d);\n    \n    return m+pow(star, 4.)*sparkle;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,145.54));\n    p += dot(p, p+45.23);\n    return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv, float t, float sparkle) {\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\tvec3 col = vec3(0);\n    \n    #ifndef BURST\n    t = 0.;\n    #endif\n    \n    for(int y=-1; y<=1; y++) {\n        for(int x=-1; x<=1; x++) {\n            vec2 offs = vec2(x, y);\n            float n = Hash21(id-offs);\n\t\t\tvec3 N = fract(n*vec3(10,100,1000));\n            vec2 p = (N.xy-.5)*.7;\n            \n            float brightness = Star(gv-p+offs, n*6.2831+t, sparkle);\n            vec3 star = brightness*vec3(.6+p.x, .4, .6+p.y)*N.z*N.z;\n            \n            \n            \n            star *= 1.+sin((t+n)*20.)*smoothstep(sin(t)*.5+.5, 1., fract(10.*n));\n            \n            float d = length(gv+offs);\n            \n            col += star*smoothstep(1.5, .8, d);\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = iMouse.xy/iResolution.xy;\n    \n    M *= 10.;\n    \n\tfloat t = -iTime*.3;\n\t\n    float twirl = sin(t*.1);\n    twirl *= twirl*twirl*sin(dot(uv,uv));\n    uv *= Rot(-t*.2);\n    \n    uv *= 2.+sin(t*.05);\n    \n    vec3 col = vec3(0);\n    float speed = -.2;\n    #ifdef BURST\n    speed = .1;\n    float bla = sin(t+sin(t+sin(t)*.5))*.5+.5;\n    float d = dot(uv,uv);\n    \n    float a = atan(uv.x, uv.y);\n    uv /= d;\n    float burst = sin(iTime*.05);\n    uv *= burst+.2;\n    #endif\n    \n    float stp = 1./NUM_LAYERS;\n        \n    for(float i=0.; i<1.; i+=stp) {\n    \tfloat lt = fract(t*speed+i);\n        float scale = mix(10., .25, lt);\n        float fade = smoothstep(0., .4, lt)*smoothstep(1., .95, lt); \n        vec2 sv = uv*scale+i*134.53-M;\n        //sv.x += t;\n        col += StarLayer(sv, t, fade)*fade;\n    }\n    \n    #ifdef BURST\n    //t = iTime*.5;\n    float burstFade = smoothstep(0., .02, abs(burst));\n    float size = .9*sin(t)+1.;\n    size = max(size, sqrt(size));\n    float fade = size/d;\n    col *= mix(1., fade, burstFade);\n    col += fade*.2*vec3(1., .5, .1)*bla*burstFade;\n    \n    t*=1.5;\n    \n    a -= M.x*.1;\n    float rays = sin(a*5.+t*3.)-cos(a*7.-t);\n    rays *= sin(a+t+sin(a*4.)*10.)*.5+.5;\n    col += rays*bla*.1*burstFade;\n    col += 1.-burstFade;\n    #else\n    col *= 4.;\n    #endif\n    \n    fragColor = Universe(fragCoord) * vec4(col, 1.);\n}\n\n\n\n/*---------- Shader Story ------------\n\tFor my best Stephen William Hawking! \n\n*/\n", "image_inputs": [{"id": 33394, "src": "https://soundcloud.com/testing-athand/gift-v1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "highp ivec2 SV_DispatchThreadID = ivec2(0,0);\nhighp int Double_pixelID = 0;\nhighp vec4 col = vec4(0.,0.,0.,0.);\nint i = 0;\n\n//pass !\nvoid A(vec4 data){\n    if(Double_pixelID == i++){\n        col = data;\n    }\n}\nvoid A(uvec4 data){\n    if(Double_pixelID == i++){\n        col = uintBitsToFloat(data);\n    }\n}\n\nvoid mainImage( out vec4 C, in vec2 U)\n{\n    SV_DispatchThreadID = ivec2(floor(U-0.5));\n    if(SV_DispatchThreadID.x >= 48 || SV_DispatchThreadID.y >= 77){\n    \tC = vec4(1./3.);\n        return;\n    }\n    if(iFrame > 2){\n    \tC = texture(iChannel0,U/iResolution.xy);\n        //discard;\n    }\n    //1个像素存一个数据块\n    //16 x 32, 16为其中2个像素存2个块数据\n    //像素ID编号\n    Double_pixelID = (SV_DispatchThreadID.x>>1) + (SV_DispatchThreadID.y*24); \n    //-------------------------------------------------------------------------\n\tA(uvec4(0x1CE71616u,0x21286F1Au,0x1D07E4F4u,0x2549F9E4u));\n\tA(uvec4(0x294A6479u,0x2D6B0010u,0x14C51B1Bu,0x25491B1Bu));\n\tA(uvec4(0xC846B6Bu,0x14A51B5Bu,0x863BFFFu,0xC631F7Fu));\n\tA(uvec4(0x8630B0Bu,0x8630002u,0x4421F5Fu,0x8431707u));\n\tA(uvec4(0xFFFFu,0x442FFFFu,0x21ABAFu,0x42116AAu));\n\tA(uvec4(0x4219195u,0x421D490u,0x421D7D1u,0x421DFFFu));\n\tA(uvec4(0x4424000u,0x10A5F4D0u,0x863FEF8u,0x14C5FFFFu));\n\tA(uvec4(0x14A598E5u,0x18C75B5Au,0x14C59197u,0x18C741E4u));\n\tA(uvec4(0x18E690D0u,0x1CE7040Du,0x14C6A6BFu,0x1CE7E5D1u));\n\tA(uvec4(0x1CE7A9A8u,0x2108F9E9u,0x1D079090u,0x2529BEA5u));\n\tA(uvec4(0x2108BFAFu,0x2129553Fu,0x1D089556u,0x2549AAE4u));\n\tA(uvec4(0x2128AAB9u,0x2549554Bu,0x2108BFFFu,0x25491B7Fu));\n\tA(uvec4(0x21089046u,0x2529FEF4u,0x2128BFBEu,0x252982BFu));\n\tA(uvec4(0x21284145u,0x2529FF5Au,0x21286F7Fu,0x25294169u));\n\tA(uvec4(0x1D0851A6u,0x21285F56u,0x18E7561Bu,0x1D082F6Au));\n\tA(uvec4(0xC636F6Fu,0x18C71A5Bu,0xC639157u,0xC64FDA1u));\n\tA(uvec4(0xC645040u,0x1CE7D490u,0x18A6F8E4u,0x39AEFEF9u));\n\tA(uvec4(0x18C71F6Fu,0x318C1B1Bu,0x14A61F1Bu,0x25295F5Fu));\n\tA(uvec4(0x10845616u,0x14A66F5Bu,0xC437F2Fu,0x1084FFBFu));\n\tA(uvec4(0xC43F8F8u,0x1085F1F8u,0x10A5F9FDu,0x1CE7E4F8u));\n\tA(uvec4(0x1CE77964u,0x25296E7Eu,0xC631B1Bu,0x18E71B1Bu));\n\tA(uvec4(0x8634B47u,0xC63050Fu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x442CF0Fu,0x843FFC3u,0x421FF7Fu,0x8433F7Fu));\n\tA(uvec4(0x21281A05u,0x25495F5Bu,0x21289494u,0x254AF9E5u));\n\tA(uvec4(0x2529BFBEu,0x294A3F7Fu,0x14A51B1Bu,0x2529061Au));\n\tA(uvec4(0xC635B5Bu,0x14A51616u,0x8631A5Bu,0xC631516u));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x4426A6Bu,0x8431566u));\n\tA(uvec4(0x216FBFu,0x4221B5Fu,0x21155Bu,0x4215555u));\n\tA(uvec4(0x421D464u,0x4212594u,0x4219040u,0xC84F4E0u));\n\tA(uvec4(0x863A9A4u,0x18C6E9E9u,0x14C578A4u,0x18C79F5Fu));\n\tA(uvec4(0x14C69546u,0x18C64F59u,0x14C6FAD1u,0x18C659BEu));\n\tA(uvec4(0x18E65050u,0x1CE7E090u,0x18E7E994u,0x1D08FAFAu));\n\tA(uvec4(0x1D08D5D0u,0x2129FAE1u,0x1D086F7Fu,0x2529561Bu));\n\tA(uvec4(0x1D08F4E5u,0x2529BEF9u,0x21295F5Bu,0x2549A4E6u));\n\tA(uvec4(0x21297F69u,0x2549550Fu,0x2128F5D1u,0x2529FEF9u));\n\tA(uvec4(0x2529F73Fu,0x2549FFFFu,0x2108E641u,0x2549AFFFu));\n\tA(uvec4(0x21291F6Fu,0x2549BF5Bu,0x21281F5Au,0x2529FF6Fu));\n\tA(uvec4(0x2128BE1Au,0x25291F7Fu,0x14A56FBFu,0x1D081B1Bu));\n\tA(uvec4(0xC63171Bu,0x14A54546u,0xC63E0A0u,0x1065F5F4u));\n\tA(uvec4(0x14859040u,0x3DCEF4E4u,0x39AE2E24u,0x86102F2Fu));\n\tA(uvec4(0x14641B1Bu,0x2D6C171Bu,0x1CE70C09u,0x316C1C0Cu));\n\tA(uvec4(0x14A51605u,0x1CE8AB5Au,0x14850601u,0x14A60B06u));\n\tA(uvec4(0xC63D2E1u,0x14854682u,0x10A5D090u,0x1CE7C0D0u));\n\tA(uvec4(0x1CE73F7Eu,0x21296F3Fu,0x8631B1Fu,0x14C60B1Bu));\n\tA(uvec4(0x8631A1Du,0xC635A17u,0x8631515u,0x8435D1Du));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x442FFFFu,0x843FFCFu,0x4217F3Fu,0x843BFFFu));\n\tA(uvec4(0x21285B5Bu,0x294A0647u,0x2128F9F9u,0x296A94E9u));\n\tA(uvec4(0x1CE76F7Fu,0x294A1A6Fu,0x10841B1Bu,0x1CE7161Bu));\n\tA(uvec4(0x8636B6Bu,0xC84166Bu,0x8630303u,0x863003Fu));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x421FFFFu,0x4423FFFu));\n\tA(uvec4(0x215757u,0x4211557u,0x217D7Du,0x421157Fu));\n\tA(uvec4(0x218040u,0x843F4D0u,0x442F9F4u,0x1084F9F9u));\n\tA(uvec4(0x10A5B9F8u,0x18C655A9u,0x14C6F8FEu,0x18C755F9u));\n\tA(uvec4(0x14C6FEAFu,0x18C72AAFu,0x14C65615u,0x1CE7F9D5u));\n\tA(uvec4(0x18E79050u,0x1D08F9EAu,0x1D07E490u,0x2529BAFEu));\n\tA(uvec4(0x1D086FBFu,0x25299156u,0x2108F4F4u,0x252996A5u));\n\tA(uvec4(0x21289551u,0x254A65E9u,0x21296F7Eu,0x2549B90Bu));\n\tA(uvec4(0x21299490u,0x294AF5A5u,0x2529AA55u,0x294A971Bu));\n\tA(uvec4(0x25290500u,0x254A420Du,0x25296901u,0x296A5BA9u));\n\tA(uvec4(0x25494004u,0x254A41D0u,0x21296A6Au,0x294A165Bu));\n\tA(uvec4(0x18E7FFFFu,0x21083FBFu,0xC631B6Fu,0x1CE70607u));\n\tA(uvec4(0xC639095u,0x1085E594u,0x10854000u,0x2D6BD090u));\n\tA(uvec4(0x2108F8E4u,0x8A31FEFDu,0x2D6B2F6Fu,0x8A311F2Fu));\n\tA(uvec4(0x14641B1Bu,0x25095B1Bu,0x1CC71C1Cu,0x358D2C2Cu));\n\tA(uvec4(0x18C72A1Bu,0x1CE81A2Eu,0x10850707u,0x14A70707u));\n\tA(uvec4(0x8439B8Bu,0x10645646u,0xC63E5E5u,0x18C7E4E5u));\n\tA(uvec4(0x14C63FBFu,0x1D087F7Fu,0x863570Bu,0x10A5061Bu));\n\tA(uvec4(0x8631B5Bu,0xC63461Au,0x8630000u,0x8430F00u));\n\tA(uvec4(0x442FFFFu,0x843FFCFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x4217F1Fu,0x8435BB7u));\n\tA(uvec4(0x1D076F6Fu,0x25491B1Bu,0x1D07E9FAu,0x2129E4E4u));\n\tA(uvec4(0x18E71B1Bu,0x25291B1Bu,0xC636F6Fu,0x14A51B6Fu));\n\tA(uvec4(0x8635B6Bu,0xC63521Bu,0x8637FFFu,0x843177Fu));\n\tA(uvec4(0x442171Fu,0x8431F17u,0x4212F6Fu,0x4420B1Bu));\n\tA(uvec4(0x215555u,0x4211535u,0x9556u,0x442F8E4u));\n\tA(uvec4(0x421E9E4u,0xC63EAEAu,0xC63E5E4u,0x10A5E9A5u));\n\tA(uvec4(0x10A5F4EDu,0x14C6FDE4u,0x14C6B954u,0x18E719A8u));\n\tA(uvec4(0x14C65616u,0x18E7E4D6u,0x18E6E4A0u,0x1D07E5A9u));\n\tA(uvec4(0x1D07F594u,0x2129AEF9u,0x1D08D3FFu,0x2108FFF7u));\n\tA(uvec4(0x2108B5A0u,0x2529496Eu,0x2128BEABu,0x252941A8u));\n\tA(uvec4(0x21288A5Eu,0x252990D1u,0x2129FFFCu,0x25497FFFu));\n\tA(uvec4(0x2128EFFFu,0x2549D9CFu,0x25497EBFu,0x294AD186u));\n\tA(uvec4(0x25291000u,0x294A0B1Au,0x2549685Du,0x254AC045u));\n\tA(uvec4(0x25491501u,0x296A1F2Eu,0x21294657u,0x25496F9Au));\n\tA(uvec4(0x10852F6Fu,0x21080B1Bu,0xC639647u,0x1085FAAAu));\n\tA(uvec4(0x10854000u,0x316CE490u,0x14A6F9E4u,0x8210FFFEu));\n\tA(uvec4(0x81EFFFFEu,0x8E52066Fu,0x2D4B1B2Fu,0x86101A1Au));\n\tA(uvec4(0x1CA52B1Bu,0x25093F2Bu,0x1CC71C2Cu,0x39AE1C1Cu));\n\tA(uvec4(0x10A66BABu,0x1CE81B6Bu,0xC645B6Bu,0x14A71657u));\n\tA(uvec4(0x842974Bu,0xC644B5Bu,0xC63E4E4u,0x18C7E4E4u));\n\tA(uvec4(0x10A52F6Fu,0x1D081F2Fu,0x8631B4Bu,0xC84161Bu));\n\tA(uvec4(0x8631506u,0xC632E29u,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x442FFFFu,0x843FFCFu,0x4421B1Bu,0x8431B5Bu));\n\tA(uvec4(0x18E71B5Bu,0x2529070Bu,0x18E6E5F9u,0x2108A4E4u));\n\tA(uvec4(0x10A56F6Fu,0x21081A5Bu,0xC631B1Fu,0x10A5061Bu));\n\tA(uvec4(0x8635757u,0xC631547u,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x4225A5Fu,0x8431E16u,0x16BAFu,0x421175Bu));\n\tA(uvec4(0x8555u,0x442E595u,0x421FDF8u,0x842FAFEu));\n\tA(uvec4(0x863E490u,0xC64E9E4u,0xC84E4F8u,0x10A5F9F8u));\n\tA(uvec4(0x10A5F4FEu,0x14C6FDF9u,0x14C65415u,0x18E7F8B8u));\n\tA(uvec4(0x14C6F9F4u,0x18E7FEFFu,0x18E7FDF4u,0x1D08BEFFu));\n\tA(uvec4(0x1CE7AAAAu,0x2128D5C5u,0x1D08F5F4u,0x2529EF9Fu));\n\tA(uvec4(0x2108D281u,0x25297FFEu,0x21085B07u,0x2529FDEBu));\n\tA(uvec4(0x2129A654u,0x2529FFF7u,0x2128FFBEu,0x252987D7u));\n\tA(uvec4(0x2128AAA9u,0x294AE986u,0x25295090u,0x296AAB9Bu));\n\tA(uvec4(0x2549AA51u,0x296AFF5Fu,0x2549AFD5u,0x294A7F2Fu));\n\tA(uvec4(0x25499107u,0x294A2890u,0x14C66FBFu,0x25291B2Bu));\n\tA(uvec4(0xC854207u,0x18E74091u,0x1085EA90u,0x18C7A9FFu));\n\tA(uvec4(0x18C7E4E4u,0x35AD00A4u,0x18C7AAFFu,0x81F00055u));\n\tA(uvec4(0x18A7AAFFu,0x3DCE0055u,0x1CC7BFBFu,0x316CE0F8u));\n\tA(uvec4(0x1CC63A2Au,0x2D4BBF7Fu,0x18C71E1Du,0x39AD0B0Fu));\n\tA(uvec4(0xC851B6Fu,0x14C75A17u,0xC645515u,0x1085D659u));\n\tA(uvec4(0x8424757u,0x1085475Bu,0xC63E4E4u,0x18E7E4E4u));\n\tA(uvec4(0xC841F1Fu,0x1CE70B1Bu,0x8636F6Fu,0xC631B5Bu));\n\tA(uvec4(0x8636559u,0xC63B869u,0x8637D75u,0x863551Du));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x842FFFFu,0x843FFCFu,0x4216F6Fu,0x8431F6Fu));\n\tA(uvec4(0x14C61B5Bu,0x2128071Bu,0x14C6F8FDu,0x1CE779F9u));\n\tA(uvec4(0xC846F6Fu,0x18C61B5Bu,0x8631B1Bu,0xC84165Au));\n\tA(uvec4(0x8631D15u,0xC63157Fu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x4211B2Fu,0x8430B1Bu,0x5A2Au,0x421E1D2u));\n\tA(uvec4(0x1FEF8u,0x442FFFFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x863F8E8u,0xC84F4F4u,0xC84FEF9u,0x10A5F4FDu));\n\tA(uvec4(0x10A5BDFCu,0x14C6FEFDu,0x14C684E8u,0x18E7F9E9u));\n\tA(uvec4(0x18E745D4u,0x1D074000u,0x18E79542u,0x2108E5A4u));\n\tA(uvec4(0x1D07F9D1u,0x2129FFBEu,0x2129D596u,0x2549F9E4u));\n\tA(uvec4(0x21290616u,0x294AFB56u,0x2129E0F8u,0x25495FD5u));\n\tA(uvec4(0x25298256u,0x254AAEDAu,0x25290B01u,0x294AD087u));\n\tA(uvec4(0x254979B0u,0x296B8146u,0x25298091u,0x296ADB86u));\n\tA(uvec4(0x2549F5F5u,0x2D6B0696u,0x25499753u,0x296A7DFFu));\n\tA(uvec4(0x18C6BFFFu,0x25291B6Fu,0x10A5071Bu,0x21080102u));\n\tA(uvec4(0x1085FC40u,0x14A6FEFEu,0x1085FE54u,0x18C7FFFFu));\n\tA(uvec4(0x14A54500u,0x1CC7FFBBu,0x14A69454u,0x1CC7FFEAu));\n\tA(uvec4(0x18A75550u,0x1CE8FEA9u,0x1CC7E0E0u,0x358DF9E4u));\n\tA(uvec4(0x314A9B16u,0x39ADDBDBu,0x14A60707u,0x3DCE0303u));\n\tA(uvec4(0xC855A5Fu,0x14A65652u,0xC85F8C0u,0x1085F8F8u));\n\tA(uvec4(0x8424747u,0x10850747u,0x863F8F8u,0x14C6FCFCu));\n\tA(uvec4(0xC631B5Fu,0x14C61B1Bu,0x8635F1Bu,0xC636E6Fu));\n\tA(uvec4(0x8636564u,0xC636363u,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x8634757u,0x8435545u,0x8630F00u,0x843F0FFu));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x4211B1Bu,0x8435B0Bu));\n\tA(uvec4(0x14C6565Bu,0x1D071606u,0x10A5BFFFu,0x14C6151Fu));\n\tA(uvec4(0xC636F6Fu,0x10A5165Bu,0x863562Bu,0xC630101u));\n\tA(uvec4(0x8635D55u,0xC631545u,0x4427FFFu,0x8433F3Fu));\n\tA(uvec4(0x1B6Fu,0x4218657u,0xFDF8u,0x422FFFEu));\n\tA(uvec4(0x422F4D4u,0x843FFF5u,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x863F9F8u,0xC64E9F9u,0xC84E9E5u,0x14A5F4E9u));\n\tA(uvec4(0x14C69090u,0x18E7D060u,0x14C669B5u,0x1CE7915Eu));\n\tA(uvec4(0x18E70040u,0x1D08E094u,0x1D08BCE4u,0x2129E0AAu));\n\tA(uvec4(0x2128A455u,0x254979E5u,0x252986D5u,0x254A7D8Bu));\n\tA(uvec4(0x25496E6Eu,0x296A081Au,0x21299506u,0x294AF995u));\n\tA(uvec4(0x2549CA69u,0x294AE5C3u,0x25491F55u,0x296AF447u));\n\tA(uvec4(0x25497D74u,0x296AF3EFu,0x252950EAu,0x294A4B03u));\n\tA(uvec4(0x25296002u,0x294A66D0u,0x1D086FBEu,0x294A1A5Fu));\n\tA(uvec4(0x10A51F6Fu,0x1D08061Bu,0xC8403C3u,0x1085FF03u));\n\tA(uvec4(0xC6494A5u,0x18A6FE55u,0x108555AAu,0x18A6FF00u));\n\tA(uvec4(0x1485E0FEu,0x18A6BF90u,0x18A6F9FFu,0x1CC7F9E4u));\n\tA(uvec4(0x1CE74040u,0x2509EA90u,0x292AE4F4u,0x358D90E4u));\n\tA(uvec4(0x314A8585u,0x8610C5C5u,0x10850303u,0x35AD0303u));\n\tA(uvec4(0xC64FBFFu,0x10854199u,0xC64EAFFu,0x1085D5D4u));\n\tA(uvec4(0x421175Bu,0xC85071Bu,0x863FDFCu,0x14A5BEFDu));\n\tA(uvec4(0xC631B2Bu,0x10855B1Bu,0x863281Du,0xC638179u));\n\tA(uvec4(0x8635461u,0xC63765Cu,0x8630303u,0x863F000u));\n\tA(uvec4(0x8637510u,0x863FFFFu,0x8635050u,0x863FF05u));\n\tA(uvec4(0x863E551u,0xC63B5E5u,0x4429F4Fu,0x843FFEFu));\n\tA(uvec4(0x14A56A6Bu,0x18C6155Au,0xC846FBFu,0x14A51B6Bu));\n\tA(uvec4(0xC635B6Bu,0xC84165Au,0x863D551u,0xC6350D5u));\n\tA(uvec4(0x8631F5Au,0xC63151Bu,0x212F6Fu,0x8430B1Fu));\n\tA(uvec4(0xE191u,0x442FDF8u,0x442AA94u,0x443FAAAu));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x863D450u,0x8434755u));\n\tA(uvec4(0x863F0E4u,0xC84F9F4u,0x10A55050u,0x18C7E490u));\n\tA(uvec4(0x14C55474u,0x18C7F1C1u,0x14C6A9B8u,0x18E7F9D2u));\n\tA(uvec4(0x18E7E8E4u,0x1D0895E5u,0x1D08E9A4u,0x2529FEFDu));\n\tA(uvec4(0x2529FD58u,0x254AEEFDu,0x2549FA2Eu,0x294A2FFAu));\n\tA(uvec4(0x25499548u,0x296ABC79u,0x25491F7Fu,0x294AAF1Fu));\n\tA(uvec4(0x2549F498u,0x296AFBF5u,0x296A2C74u,0x2D6BC0D0u));\n\tA(uvec4(0x25490566u,0x296BE647u,0x2549645Au,0x296A1B2Bu));\n\tA(uvec4(0x21286AABu,0x294A051Au,0x18E72F5Fu,0x21291A6Fu));\n\tA(uvec4(0x1085060Bu,0x18E74102u,0x14A60000u,0x35ADE440u));\n\tA(uvec4(0x1CE75000u,0x3DEFFFA9u,0x20E85500u,0x39ADAF6Au));\n\tA(uvec4(0x20E70500u,0x2D4AFF46u,0x1CC75040u,0x2D4AFFA9u));\n\tA(uvec4(0x25095000u,0x2D4BFEE4u,0x2D4A9450u,0x81EFF5E4u));\n\tA(uvec4(0xC22EAD5u,0x8E32E1E6u,0x10850303u,0x81EF0707u));\n\tA(uvec4(0xC635A9Bu,0xC651A5Bu,0xC63FEFEu,0x1085F8F9u));\n\tA(uvec4(0x4B4Bu,0xC648787u,0x10A4787Cu,0x14A51924u));\n\tA(uvec4(0x8631A1Bu,0x10855A1Au,0x86378A5u,0xC63E6B5u));\n\tA(uvec4(0x8632820u,0xC638B88u,0x8635550u,0xC636F5Au));\n\tA(uvec4(0x8630FFFu,0x8630F0Fu,0x8634155u,0x863FDD5u));\n\tA(uvec4(0x86354F0u,0xC631515u,0x4425B9Fu,0x843070Bu));\n\tA(uvec4(0xC84BFFFu,0x14A51A5Fu,0xC636B6Fu,0x10851A6Bu));\n\tA(uvec4(0x8635B6Fu,0xC63A916u,0x8637475u,0xC631FF4u));\n\tA(uvec4(0x442FFFFu,0x8433FFFu,0x21870Fu,0x422E1C3u));\n\tA(uvec4(0x421A854u,0x443FAF6u,0x4435454u,0x843555Du));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x843E595u,0xC63EAE4u));\n\tA(uvec4(0xC63E594u,0x10A5EAE5u,0x10A5E1F4u,0x14C6FEF9u));\n\tA(uvec4(0x14C6EEAAu,0x18E7FCF5u,0x18E74774u,0x1CE74103u));\n\tA(uvec4(0x18E7A494u,0x1D08FAF4u,0x2128E4E8u,0x254A94D0u));\n\tA(uvec4(0x25496F5Au,0x296B296Fu,0x2549BD2Eu,0x296A6EFEu));\n\tA(uvec4(0x2549A454u,0x2D8B69E5u,0x296A5605u,0x2D8BD555u));\n\tA(uvec4(0x296A1E29u,0x2D8B627Du,0x252996AFu,0x296AE6C2u));\n\tA(uvec4(0x2549A890u,0x2D6B96BDu,0x25295656u,0x296B070Bu));\n\tA(uvec4(0x1CE7AFABu,0x25291B6Fu,0x10A51B2Fu,0x1CE70606u));\n\tA(uvec4(0x14A54000u,0x81EFE080u,0x2529F890u,0x9694FFFEu));\n\tA(uvec4(0x8E52A900u,0xA6F7FFBEu,0x39AD1601u,0xA2D6FF6Fu));\n\tA(uvec4(0x358C5400u,0x96946F55u,0x316B5B05u,0x3DCEFFAFu));\n\tA(uvec4(0x1CE75555u,0x3DCE1F6Au,0x4217FFFu,0x316B010Bu));\n\tA(uvec4(0x421E0F0u,0x81EF90E0u,0xC640B07u,0x39CE2F1Fu));\n\tA(uvec4(0x8431A1Fu,0xC656A2Eu,0x843F9F9u,0xC85E4F8u));\n\tA(uvec4(0x8787u,0xC43C7C7u,0x10A55F1Fu,0x14A50955u));\n\tA(uvec4(0x8635B5Bu,0xC845317u,0x8635692u,0xC638729u));\n\tA(uvec4(0x8635A46u,0xC631BA9u,0x863171Fu,0xC630055u));\n\tA(uvec4(0x8630505u,0xC636E56u,0x863F0FCu,0x86303C3u));\n\tA(uvec4(0x8635555u,0xC63355Du,0x4420707u,0x8435707u));\n\tA(uvec4(0xC636FAFu,0x1084191Au,0xC631A2Bu,0xC645656u));\n\tA(uvec4(0xFFFFu,0xC63FFFFu,0x8635F1Bu,0xC636F6Fu));\n\tA(uvec4(0x217FBFu,0x8430F1Fu,0x21F4E0u,0x442EDF8u));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x8639494u,0xC64E4A8u));\n\tA(uvec4(0xC84D454u,0x14C6F9E4u,0x14A5E4A4u,0x18E7EAE6u));\n\tA(uvec4(0x14C64FFDu,0x18E7DF47u,0x18E77C69u,0x1D08E4A8u));\n\tA(uvec4(0x18E7E4E5u,0x2129FAB5u,0x25295880u,0x296AE07Cu));\n\tA(uvec4(0x2529F092u,0x296ADBF8u,0x294A0000u,0x2D6B7D65u));\n\tA(uvec4(0x294A5E3Eu,0x2D6BFEFDu,0x296A1E54u,0x2D8BFAF5u));\n\tA(uvec4(0x296A0D65u,0x2D6BF601u,0x296AB840u,0x2D6BEAFDu));\n\tA(uvec4(0x254A6F5Fu,0x2D6B5F3Au,0x2128BFFFu,0x294A2F7Eu));\n\tA(uvec4(0x10A56B6Bu,0x25291A1Au,0x1085921Bu,0x14A6F9F5u));\n\tA(uvec4(0x18E7F4E0u,0x8E53F9F8u,0x9AB56964u,0xA7183E29u));\n\tA(uvec4(0x9673F9FEu,0xAB18E0F4u,0xA717AF01u,0xAF39B9BEu));\n\tA(uvec4(0x96946F16u,0xAB38FFBFu,0x85EF6B01u,0xA6F77FBFu));\n\tA(uvec4(0x401071Fu,0x398D0102u,0xA96Fu,0x40196C3u));\n\tA(uvec4(0x42180D0u,0x1CC74080u,0x14A6B53Eu,0x318D80D0u));\n\tA(uvec4(0xC630000u,0x294B0301u,0x422F9F9u,0xC64F5F8u));\n\tA(uvec4(0x20C7C7u,0xC63C7C7u,0x10A5A400u,0x14A624B8u));\n\tA(uvec4(0xC630B07u,0x10850606u,0x8635F57u,0xC631F5Fu));\n\tA(uvec4(0x8637B2Bu,0xC631D6Eu,0x8637454u,0xC631474u));\n\tA(uvec4(0x8630028u,0xC63AE08u,0x8634101u,0xC635755u));\n\tA(uvec4(0x8633F3Fu,0x8633F3Fu,0x4433F3Fu,0x8433F3Fu));\n\tA(uvec4(0xC635E6Fu,0xC841555u,0xC634B5Bu,0xC630507u));\n\tA(uvec4(0x863F6E6u,0xC6395F1u,0x8435B6Fu,0xC631B5Bu));\n\tA(uvec4(0x421964Bu,0x442A4E2u,0x442FACCu,0x843FEF0u));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x863A165u,0xC63D6C1u,0x863E594u,0xC84E9E9u));\n\tA(uvec4(0x10A5F4F4u,0x14A6E8D0u,0x14C6B8BDu,0x18E7E0D1u));\n\tA(uvec4(0x14C6D9ECu,0x18E7DFEFu,0x18E7D0D1u,0x1D0845E5u));\n\tA(uvec4(0x1D08FAFAu,0x2129D5C9u,0x2129F9E0u,0x296AF9FDu));\n\tA(uvec4(0x296A6400u,0x31AC65B8u,0x296AF4BDu,0x2D8BDBD2u));\n\tA(uvec4(0x296AA699u,0x2D8C2F4Bu,0x296AAF6Fu,0x2D8BD0D2u));\n\tA(uvec4(0x296ABCFDu,0x2D8BFFFFu,0x296A5A96u,0x2D8BBF1Au));\n\tA(uvec4(0x2549FFFFu,0x296B3F7Fu,0x1CE71B6Fu,0x296A161Au));\n\tA(uvec4(0x1085071Bu,0x18E70002u,0x14A64000u,0x8611D080u));\n\tA(uvec4(0x316CE9E4u,0x9ED6FEFAu,0xA2D67E3Eu,0xA7182579u));\n\tA(uvec4(0x8A10D6E5u,0xAB18E1D2u,0xAB18AA62u,0xAF5976ECu));\n\tA(uvec4(0xAB187B17u,0xAF39E2E6u,0x8A312F7Fu,0xAB180B1Fu));\n\tA(uvec4(0x1A67u,0x8015216u,0xCAAEu,0x1A99Eu));\n\tA(uvec4(0xC6E5u,0x8438586u,0x1085FCFCu,0x14A794F4u));\n\tA(uvec4(0x8431E0Fu,0x252A7A3Eu,0x1F5FAu,0xC63E4F5u));\n\tA(uvec4(0x421C3C3u,0xC438383u,0xC636E7Fu,0x10851854u));\n\tA(uvec4(0xC63060Fu,0xC63165Bu,0x863EF1Fu,0xC63FFFFu));\n\tA(uvec4(0x8631B1Eu,0xC634627u,0x8631414u,0xC635574u));\n\tA(uvec4(0x863545Du,0xC635050u,0x8633FFFu,0xC633F3Fu));\n\tA(uvec4(0x8631515u,0xC631575u,0x4433F3Fu,0x8433F3Fu));\n\tA(uvec4(0xC637FFFu,0xC631F3Fu,0x8635056u,0xC63E4A0u));\n\tA(uvec4(0xC63FDF4u,0xC63155Du,0x4213F7Fu,0x8439B6Fu));\n\tA(uvec4(0x421FDF4u,0x843FFFEu,0x863F5F4u,0x8437F55u));\n\tA(uvec4(0x8630002u,0x8633A30u,0x863F4D0u,0x843747Cu));\n\tA(uvec4(0x863E995u,0xC64F9F8u,0xC63D490u,0x10A5E5E5u));\n\tA(uvec4(0x10A5A554u,0x18E795D5u,0x14C6F4E9u,0x18E7FEF1u));\n\tA(uvec4(0x18E7B401u,0x1D089AFCu,0x18E7BA5Au,0x1D08E1E1u));\n\tA(uvec4(0x1D08F4E4u,0x2529FDE4u,0x2549F8F4u,0x2D6BA5B9u));\n\tA(uvec4(0x296AFDFFu,0x2D6BEDFCu,0x296BD685u,0x2D8CD1D2u));\n\tA(uvec4(0x296A421Bu,0x318C6652u,0x296A5544u,0x31ACE595u));\n\tA(uvec4(0x2D6B7CE2u,0x318CA77Eu,0x296A6E6Fu,0x318C166Au));\n\tA(uvec4(0x21296B6Fu,0x2D6B1A1Bu,0x10A51F6Fu,0x1D080B1Bu));\n\tA(uvec4(0x10854040u,0x20E9D040u,0x14C7F8E4u,0x8E52FEF9u));\n\tA(uvec4(0x9273E8F8u,0x9ED6F4F4u,0x9A94152Bu,0xA2F76E29u));\n\tA(uvec4(0x9253F9F0u,0xAB18FFFEu,0xAB186ABAu,0xAF390059u));\n\tA(uvec4(0x8610FEFEu,0xB35A3FBFu,0x8A100207u,0xA7180001u));\n\tA(uvec4(0xFFFBu,0x40152AFu,0xFFDFu,0x1DCFDu));\n\tA(uvec4(0x5FDFu,0x4212F5Fu,0x422FEFEu,0x1085FCFDu));\n\tA(uvec4(0x14A7C4D0u,0x21091040u,0x4224240u,0x252A4A43u));\n\tA(uvec4(0x421C3C3u,0x84382D2u,0x863BDBEu,0xC84A4B8u));\n\tA(uvec4(0x863A7ABu,0xC63ABA3u,0x8632FBEu,0xC63AA6Au));\n\tA(uvec4(0xC635400u,0xC635D5Cu,0xC633F0Cu,0xC63033Fu));\n\tA(uvec4(0x8630501u,0xC63D555u,0x8635454u,0xC637F7Du));\n\tA(uvec4(0x8635F6Au,0xC63165Au,0x4422B2Fu,0x8430223u));\n\tA(uvec4(0xC631B06u,0xC634B5Bu,0xC635474u,0xC634115u));\n\tA(uvec4(0x421FFFFu,0xC633FFFu,0x421E6D7u,0x843FCF8u));\n\tA(uvec4(0x8435555u,0xC63E968u,0x863A000u,0xC63AEA0u));\n\tA(uvec4(0x8634515u,0xC43F157u,0x8639555u,0xC63EA91u));\n\tA(uvec4(0xC63E5F5u,0xC64F1A5u,0xC84E4E4u,0x14A5F9F4u));\n\tA(uvec4(0x14A5C080u,0x18E7E854u,0x18E79090u,0x1D081BA8u));\n\tA(uvec4(0x18E7691Au,0x1D08C492u,0x18E7F9A4u,0x2129EBFEu));\n\tA(uvec4(0x21295444u,0x294AE6F9u,0x2529E090u,0x2D8BE5F9u));\n\tA(uvec4(0x296AFFFEu,0x2D6B076Fu,0x296BA5A5u,0x31ACE165u));\n\tA(uvec4(0x296B1989u,0x31ACF6B4u,0x2D8B8FE2u,0x31ACF6FFu));\n\tA(uvec4(0x2D8BA290u,0x31AC8FAAu,0x2529BFBFu,0x2D8B3F6Fu));\n\tA(uvec4(0x18C6BFBFu,0x25292E6Fu,0x10A50607u,0x1CE74514u));\n\tA(uvec4(0x14A69040u,0x81F0E0D0u,0x82109494u,0xA2F7F9E5u));\n\tA(uvec4(0x9AB4EAE4u,0xA2F7D7EBu,0x96948B5Eu,0xA718D3C7u));\n\tA(uvec4(0xA2D6A9BEu,0xAB1841C1u,0xA6F8D141u,0xB35AE5E0u));\n\tA(uvec4(0x8E312F7Fu,0xAF590B1Fu,0x4219707u,0x821684Fu));\n\tA(uvec4(0x5F6Bu,0x4210107u,0x5454u,0x401F468u));\n\tA(uvec4(0xFF3Fu,0x421A4FFu,0x21F8F9u,0x1086F4F8u));\n\tA(uvec4(0x1086E9F8u,0x14A7D4E8u,0x8433A1Eu,0x252AF9BAu));\n\tA(uvec4(0x4219383u,0x8438384u,0x862A4F8u,0xC635CA0u));\n\tA(uvec4(0xC63B6BBu,0xC6353AAu,0xC635455u,0xC63E550u));\n\tA(uvec4(0xC63F030u,0xC63FFFCu,0xC630A02u,0xC63FF2Bu));\n\tA(uvec4(0x8635555u,0xC63D3FFu,0xC63003Fu,0xC63FF00u));\n\tA(uvec4(0x8630F05u,0xC63010Fu,0x4421357u,0x4425513u));\n\tA(uvec4(0x863969Bu,0xC635545u,0xC634141u,0xC6379A4u));\n\tA(uvec4(0x4215B2Fu,0x8639687u,0x422FFFCu,0x843FFFFu));\n\tA(uvec4(0x863F0C0u,0xC63F3F3u,0x863F57Du,0xC6350F4u));\n\tA(uvec4(0x863D551u,0xC63F5F5u,0xC639540u,0xC63EAA5u));\n\tA(uvec4(0xC63A550u,0x1085E9A9u,0x10A558D0u,0x14C6D095u));\n\tA(uvec4(0x14C6FCF8u,0x18E7FBFDu,0x14C6C3EFu,0x18E7BFD6u));\n\tA(uvec4(0x18E7E1E0u,0x1D08B8D1u,0x1D08E6A4u,0x2129EED7u));\n\tA(uvec4(0x21299054u,0x2D6BBAD5u,0x296AF654u,0x2D8BDEF3u));\n\tA(uvec4(0x296B6990u,0x31ACA76Eu,0x2D8BD0A4u,0x35CD7DE0u));\n\tA(uvec4(0x2D8B17C7u,0x31ACFBFBu,0x2D8B2FAFu,0x318CC35Fu));\n\tA(uvec4(0x296A564Bu,0x318CAB1Bu,0x2129AA7Fu,0x296B1A2Eu));\n\tA(uvec4(0x14A60B1Bu,0x21290106u,0x14A61000u,0x252BD450u));\n\tA(uvec4(0x2109E4E0u,0x9694FDF8u,0x9694FDF4u,0xAB186BBEu));\n\tA(uvec4(0x8A31FFFFu,0xA2D62F7Fu,0x8E31F8F6u,0xA2F6FEFCu));\n\tA(uvec4(0xA2D61900u,0xAF39D645u,0x9253FEFEu,0xB35A3FFFu));\n\tA(uvec4(0x2D4A070Bu,0x9EB60112u,0x2F7Fu,0x421561Bu));\n\tA(uvec4(0x280Au,0x3322u,0xE0F4u,0x421D0E0u));\n\tA(uvec4(0x1A050u,0x42182E1u,0x421E0F0u,0x1085C1D0u));\n\tA(uvec4(0x10857D3Du,0x14A6D5EEu,0x14A6D0D0u,0x2D4BD0D0u));\n\tA(uvec4(0x4210302u,0x35AD0B07u,0x442E9FDu,0xC63D4D5u));\n\tA(uvec4(0x8635455u,0xC64595Du,0xC63E5A5u,0xC63D5E4u));\n\tA(uvec4(0xC63C3FFu,0xC63F3FFu,0xC63FFFFu,0xC63CFFFu));\n\tA(uvec4(0xC635741u,0xC635757u,0xC63033Fu,0xC630303u));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x442333Fu,0x4423333u));\n\tA(uvec4(0xC637470u,0xC63FD7Du,0x4216FBFu,0xC631F6Fu));\n\tA(uvec4(0x421F9F2u,0x843FFFDu,0x863A091u,0xC63E974u));\n\tA(uvec4(0x8639965u,0xC635A9Cu,0x8630A02u,0xC63C28Bu));\n\tA(uvec4(0xC63B9B0u,0xC63EAA9u,0xC63E894u,0xC84F5F9u));\n\tA(uvec4(0xC84FDF8u,0x1085FBFDu,0x10A5A9A0u,0x18E799E5u));\n\tA(uvec4(0x14A5C4E5u,0x18E75752u,0x18E79419u,0x1D0858B4u));\n\tA(uvec4(0x18E79265u,0x2129E9C6u,0x1D08A454u,0x296A99B9u));\n\tA(uvec4(0x254A4919u,0x2D8BDAECu,0x296BA4DCu,0x318C8B5Bu));\n\tA(uvec4(0x2D8BA081u,0x35ADAAE5u,0x31ACC319u,0x35CD9E2Eu));\n\tA(uvec4(0x318C3FEBu,0x31ACC0FFu,0x296A6FAAu,0x31AC5F4Fu));\n\tA(uvec4(0x294AAAFAu,0x318C0A5Bu,0x14C66B5Bu,0x296B061Au));\n\tA(uvec4(0x14A65217u,0x1CE7E080u,0x1CE99080u,0x8631F9E4u));\n\tA(uvec4(0x8211F4E4u,0xA718FDF9u,0x85F0ABFFu,0xA2F68182u));\n\tA(uvec4(0x9673C70Au,0xAB18FFE7u,0xA2F71B52u,0xAF396F6Bu));\n\tA(uvec4(0xA6F7D0D2u,0xAB1869C0u,0x10632F7Fu,0xAF3A0B1Fu));\n\tA(uvec4(0x4210E1Eu,0xC430A1Fu,0x5B5Bu,0x401E786u));\n\tA(uvec4(0x1B1Au,0x4015A17u,0xD1D1u,0x421D0D1u));\n\tA(uvec4(0xD7C7u,0x4217F5Fu,0x42181C1u,0xC640044u));\n\tA(uvec4(0xC63FFFFu,0x1085FCFEu,0x1085E0E4u,0x2D4BE4E0u));\n\tA(uvec4(0x4211F0Fu,0x35AD3F2Fu,0x422E9E8u,0x863A9E5u));\n\tA(uvec4(0x863FFFFu,0xC63F7FCu,0xC634696u,0xC634746u));\n\tA(uvec4(0xC63F0F3u,0xC630FCFu,0xC630F0Fu,0xC63FFC3u));\n\tA(uvec4(0xC63FFF3u,0xC633FFFu,0x8635757u,0xC630757u));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x4420333u,0x4420303u));\n\tA(uvec4(0x863FAFEu,0xC633EBEu,0x421D79Bu,0x863F5E2u));\n\tA(uvec4(0x8635544u,0xC63FDD7u,0xC638000u,0xC63E0E0u));\n\tA(uvec4(0xC635A55u,0xC630B0Fu,0xC63E540u,0xC63E4E4u));\n\tA(uvec4(0xC639190u,0xC64DA96u,0xC639090u,0x1085E9A4u));\n\tA(uvec4(0x10A5F850u,0x14A540F4u,0x14A5C4D4u,0x14C6F8FEu));\n\tA(uvec4(0x14C6F585u,0x18E7FEF9u,0x18E7D0C1u,0x1D08E0A0u));\n\tA(uvec4(0x1D089085u,0x2529D0D0u,0x2129A954u,0x2D6BFAA9u));\n\tA(uvec4(0x296B9D85u,0x2D8CF658u,0x2D8BA581u,0x35CDB9B4u));\n\tA(uvec4(0x2D8B65EBu,0x35CDE894u,0x2D8BBEB9u,0x35CD85CBu));\n\tA(uvec4(0x2D8B1E2Fu,0x35ADFA66u,0x2D8BFD6Cu,0x35ADA6F9u));\n\tA(uvec4(0x1D08AFABu,0x318C1B5Fu,0x14A6075Bu,0x21294102u));\n\tA(uvec4(0x14C79040u,0x8211F8E4u,0x39CFE994u,0x9AB4FAF9u));\n\tA(uvec4(0x8A116FBEu,0xA2F7051Bu,0x85F080C1u,0x9674D590u));\n\tA(uvec4(0x9EB5FDFAu,0xAF39F8E8u,0xAB181555u,0xAF5AFF05u));\n\tA(uvec4(0x9A95A59Au,0xB35A2F6Au,0xC430207u,0xAB180001u));\n\tA(uvec4(0x4210506u,0x8432A1Bu,0xDBD3u,0x4217FEFu));\n\tA(uvec4(0x2B1Au,0x4010213u,0x54D4u,0x401D154u));\n\tA(uvec4(0x1665Bu,0x421D2A5u,0x1E484u,0x421EFEFu));\n\tA(uvec4(0x843F8F8u,0x1085A4A4u,0x1064E4E4u,0x2D6CE4E4u));\n\tA(uvec4(0x10843F3Fu,0x39AEBF7Fu,0x421FCFEu,0x843FDFDu));\n\tA(uvec4(0xC63FFF3u,0xC635D7Cu,0xC63DFCFu,0xC63FFDFu));\n\tA(uvec4(0xC63CFCFu,0xC63FFFFu,0xFFFFu,0xC63FFFFu));\n\tA(uvec4(0x8635F5Fu,0xC631757u,0x8631717u,0xC635555u));\n\tA(uvec4(0xFFFFu,0x843FFFFu,0x442FF3Fu,0x442C0FFu));\n\tA(uvec4(0x4216F7Fu,0xC63835Fu,0x421FDF8u,0x863FFFFu));\n\tA(uvec4(0x863A5A4u,0xC63FFABu,0xC63F5F4u,0xC63F5F5u));\n\tA(uvec4(0xC63D747u,0xC6377D5u,0xFFFFu,0xC63FFFFu));\n\tA(uvec4(0xC63A550u,0x1085B9A9u,0xC84A5E5u,0x10A5B5A4u));\n\tA(uvec4(0x10A5D541u,0x14A514ECu,0x14A5E590u,0x18E7FEF9u));\n\tA(uvec4(0x18E71004u,0x1CE714D5u,0x18E76450u,0x2129D9A5u));\n\tA(uvec4(0x1D08B8F8u,0x2549F5F4u,0x254A69F4u,0x2D6BD55Fu));\n\tA(uvec4(0x296BF8E5u,0x31ACFFFEu,0x2D8C91E1u,0x35ADBEA5u));\n\tA(uvec4(0x31AC5068u,0x35CE78E4u,0x31ACC700u,0x35CD9FFDu));\n\tA(uvec4(0x318C3BCDu,0x35CDE12Au,0x2D8B7D5Bu,0x31AD212Eu));\n\tA(uvec4(0x14C61B6Fu,0x296B0607u,0x18C74000u,0x358DD490u));\n\tA(uvec4(0x254BF9F8u,0x8A32FFFEu,0x89F0AEFEu,0x9273155Au));\n\tA(uvec4(0x85CF5BBFu,0x8E32E047u,0x8A11E490u,0xAF39FDF8u));\n\tA(uvec4(0xAB18F6A4u,0xB35AFFFAu,0xA718EAA5u,0xBB9C005Au));\n\tA(uvec4(0x81EF7FBFu,0xAB391F2Fu,0x4219DFBu,0xC43478Fu));\n\tA(uvec4(0x4215765u,0x8430B57u,0x5B6Fu,0x421BA47u));\n\tA(uvec4(0x6905u,0x4011C7Au,0xD1D1u,0x4014591u));\n\tA(uvec4(0x1D7D3u,0x4219FDBu,0x5FAFu,0x4211F9Fu));\n\tA(uvec4(0x421FDFEu,0xC63FCFDu,0xC64F4F4u,0x294BE4F4u));\n\tA(uvec4(0x2D6CA924u,0x39CF90F8u,0x8430100u,0x1CE80302u));\n\tA(uvec4(0xC63211Au,0xC63F727u,0xC633FFFu,0xC633F3Fu));\n\tA(uvec4(0xC633F3Fu,0xC633C3Fu,0xC63FCFCu,0xC633CFCu));\n\tA(uvec4(0x8635B5Bu,0xC634547u,0x8637F7Fu,0x8631F7Fu));\n\tA(uvec4(0x4423F3Fu,0x843FF3Fu,0x442E080u,0x843FFFAu));\n\tA(uvec4(0x421F4E2u,0x843FFFDu,0x863E495u,0xC63FDB4u));\n\tA(uvec4(0xC63FFFFu,0xC633FFCu,0xC635A56u,0xC84E4A5u));\n\tA(uvec4(0xC63FCFCu,0xC64FFF3u,0xC634141u,0x1084AE56u));\n\tA(uvec4(0xC849969u,0x1085B8A9u,0xC84F6F5u,0x10A5F0F6u));\n\tA(uvec4(0x10A5C0E0u,0x14C6FEF6u,0x14C68519u,0x1D0824C2u));\n\tA(uvec4(0x18E7C2F0u,0x1D08A504u,0x18E7A999u,0x2129C2D5u));\n\tA(uvec4(0x21294040u,0x2D8CE190u,0x296A5894u,0x35ADAFA9u));\n\tA(uvec4(0x2D8BEB53u,0x35CD3DEDu,0x318C5A2Du,0x39EE9FA2u));\n\tA(uvec4(0x318C8245u,0x39CEBFE4u,0x31AC465Bu,0x39CE1401u));\n\tA(uvec4(0x318C3136u,0x35CD2221u,0x1CE76FBFu,0x2D6B1B2Fu));\n\tA(uvec4(0x14C69243u,0x2109F4E0u,0x20E9E4D0u,0x81F0F9F4u));\n\tA(uvec4(0x85F065BAu,0x8E321554u,0x85EF0A0Au,0x9232AEE0u));\n\tA(uvec4(0x8E119490u,0xAB18F9E4u,0xAF39B4A4u,0xB37BE9A4u));\n\tA(uvec4(0xA7181F6Eu,0xB37B1F1Fu,0x9AD61505u,0xB7BD2E29u));\n\tA(uvec4(0x2D8C7F2Fu,0x92B5BFBFu,0x218D5Fu,0x8434C8Cu));\n\tA(uvec4(0x210702u,0x421FEAFu,0x4216CA0u,0x442871Fu));\n\tA(uvec4(0x6F52u,0x421AFBFu,0xD5D5u,0x4019195u));\n\tA(uvec4(0x1DA9Bu,0x421C5D5u,0x5F1Fu,0x4211F1Fu));\n\tA(uvec4(0x421F8FCu,0xC63E4F8u,0x1084E4F4u,0x294BF8F4u));\n\tA(uvec4(0x2D6CF4E5u,0x39CFE594u,0x8630702u,0x35AE0B07u));\n\tA(uvec4(0x863F9FAu,0xC63FEF8u,0xC63FFFFu,0xC63FCFFu));\n\tA(uvec4(0xC63FF3Fu,0xC63FFFFu,0x8636F7Eu,0xC631B1Fu));\n\tA(uvec4(0x8635557u,0x8635455u,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x442FFF3u,0x843FFFFu,0x8634000u,0xC63E490u));\n\tA(uvec4(0x8639554u,0xC64EFE6u,0xC63FF3Fu,0xC64FFFFu));\n\tA(uvec4(0xC634959u,0xC64AF5Au,0xC6382E0u,0xC63FFFFu));\n\tA(uvec4(0xC639959u,0x1085B5D4u,0xC84576Eu,0x10856EC7u));\n\tA(uvec4(0xC84F9F8u,0x1085FFBBu,0xC846B6Au,0x14A5F1F1u));\n\tA(uvec4(0x10A5ED7Eu,0x14C6F4E7u,0x14C64150u,0x1D08E001u));\n\tA(uvec4(0x14C7B4ECu,0x1D082878u,0x1D070000u,0x2D6BD550u));\n\tA(uvec4(0x254A48E5u,0x318CE5F0u,0x2D8BDFDFu,0x31ACB4FFu));\n\tA(uvec4(0x2D8CF783u,0x35CDC5BCu,0x31AC78A6u,0x39CECBDEu));\n\tA(uvec4(0x35ADB82Au,0x39EEF7EAu,0x31AC6554u,0x39CE4B02u));\n\tA(uvec4(0x25295FAFu,0x31AC1B2Fu,0x18C64B1Fu,0x294A9146u));\n\tA(uvec4(0x18C7A554u,0x3DAEE9E9u,0x356CFDF8u,0x89F0BEF9u));\n\tA(uvec4(0x89EF59A5u,0x9674E481u,0x8E119040u,0xAF3AE5A5u));\n\tA(uvec4(0xA2D6F9A8u,0xB37AFFFEu,0xAF5AA0E4u,0xB79B9BC5u));\n\tA(uvec4(0xA7181F1Bu,0xBB9C7E1Fu,0x8E732A3Eu,0xAF7B5A06u));\n\tA(uvec4(0x3DEF7E7Fu,0x92B50B2Fu,0x421782Cu,0x8435199u));\n\tA(uvec4(0x2165FEu,0x421A793u,0x4217CFAu,0x4211439u));\n\tA(uvec4(0x4218803u,0x421E9F8u,0x5651u,0x4216B57u));\n\tA(uvec4(0xFDD9u,0x421FCBDu,0x5F1Fu,0x421BE6Bu));\n\tA(uvec4(0xE4F4u,0xC43E4E4u,0x1085F8F8u,0x252AF8F8u));\n\tA(uvec4(0x294BE5F5u,0x39AFA494u,0x8630B0Bu,0x39AE1F1Bu));\n\tA(uvec4(0x863FFF2u,0xC63F2FCu,0xC63FFFCu,0xC63FFFFu));\n\tA(uvec4(0xC63FFFFu,0xC630FFFu,0x8631A1Bu,0xC63061Au));\n\tA(uvec4(0x8635F5Du,0x843515Fu,0xFFFFu,0x843FFFFu));\n\tA(uvec4(0x8639550u,0xC63FAA5u,0x8639554u,0xC63FEA5u));\n\tA(uvec4(0xC635490u,0x1085BA65u,0xC840003u,0xC850100u));\n\tA(uvec4(0xC63F751u,0xC6474FFu,0xC634745u,0xC64F557u));\n\tA(uvec4(0xC63E4F4u,0x108561A5u,0xC84F6F4u,0x1085FE9Fu));\n\tA(uvec4(0xC847EFCu,0x10A5FFFFu,0x10A51E00u,0x14C6821Fu));\n\tA(uvec4(0x10A569E4u,0x18E7E525u,0x14C6ECE0u,0x18E74C3Eu));\n\tA(uvec4(0x18E7D481u,0x2109F8F4u,0x2129F8E8u,0x296BE8E4u));\n\tA(uvec4(0x296AB8D1u,0x318CEB7Cu,0x2D8BF0D4u,0x35CDD9E8u));\n\tA(uvec4(0x31AC7491u,0x3E0F979Au,0x31AC5D87u,0x39EEFF6Au));\n\tA(uvec4(0x35CDC590u,0x3E0F0640u,0x31AC254Bu,0x39CE4B19u));\n\tA(uvec4(0x18A56FAFu,0x2D6B5B1Bu,0x1CE79450u,0x396CFEE8u));\n\tA(uvec4(0x2D2AF9E4u,0x85CFD5AAu,0x85CED045u,0x92525E78u));\n\tA(uvec4(0x8E319450u,0xAB18E9A4u,0xA2D6F8E4u,0xB37AFFFDu));\n\tA(uvec4(0xB35AE5E5u,0xB79BC190u,0xB37B3D95u,0xBB9C4666u));\n\tA(uvec4(0x1463BFFFu,0xB77B0B2Fu,0xC4200FFu,0x86100000u));\n\tA(uvec4(0x4210007u,0x25090000u,0x4210042u,0x4421B19u));\n\tA(uvec4(0x4218002u,0x8210AFCu,0x4211B00u,0x4210007u));\n\tA(uvec4(0xFAFEu,0x4214091u,0x421BF61u,0x442A42Au));\n\tA(uvec4(0xF7F1u,0x421FFFFu,0x421A511u,0x421E0F0u));\n\tA(uvec4(0x421C0D0u,0x822C0C0u,0xC64F4F9u,0x294BE4E4u));\n\tA(uvec4(0x2D6CAFA5u,0x358DE0FEu,0xC642F1Fu,0x318D3F3Fu));\n\tA(uvec4(0x863F8F9u,0xC63FCF8u,0xFFFFu,0xC63FFFFu));\n\tA(uvec4(0x8637FBFu,0xC631B6Fu,0x863566Bu,0x8635546u));\n\tA(uvec4(0x8635440u,0xC63E554u,0x863FE80u,0xC63FFFFu));\n\tA(uvec4(0xC635500u,0xC63FA5Au,0xC630000u,0xC630030u));\n\tA(uvec4(0xC840A59u,0x14A5965Bu,0xC631505u,0x10855755u));\n\tA(uvec4(0xC635AA5u,0xC849746u,0xC63A5A5u,0x1084E195u));\n\tA(uvec4(0xC639591u,0x1085A6B9u,0xC84A5F4u,0x14A59699u));\n\tA(uvec4(0x1085F4F0u,0x14A50134u,0x10A5F6E1u,0x14A64AA4u));\n\tA(uvec4(0x14A5B0F5u,0x14C769ADu,0x14C6D491u,0x1D08D540u));\n\tA(uvec4(0x1D08E4D4u,0x254AE969u,0x254AE1D0u,0x2D8CE49Cu));\n\tA(uvec4(0x296BB895u,0x35CEE5A9u,0x2D8BBDB5u,0x35CEF8EAu));\n\tA(uvec4(0x35CD1010u,0x3E0FF171u,0x35CD3ED9u,0x3DEF6E57u));\n\tA(uvec4(0x35AD54D3u,0x3E0F271Au,0x25292F7Fu,0x35AD1A4Bu));\n\tA(uvec4(0x1CE7D2CAu,0x2929A4A1u,0x24E855AAu,0x81ADE494u));\n\tA(uvec4(0x354BF8E0u,0x8E109FBEu,0x85EEE081u,0x9EB5FEF8u));\n\tA(uvec4(0x9EB6E490u,0xB37AFEF9u,0xB77BA450u,0xBBBC19B8u));\n\tA(uvec4(0x9674FFFFu,0xB79B2FFFu,0x96736FFFu,0xB35A010Bu));\n\tA(uvec4(0x8220003u,0x81EF0000u,0x42111D5u,0x843FF05u));\n\tA(uvec4(0x55BFu,0x843FF45u,0x5A6u,0x4226F55u));\n\tA(uvec4(0xFCF3u,0x401F1FFu,0x1F5Au,0x421BF7Fu));\n\tA(uvec4(0x94EAu,0x4015595u,0x42105FAu,0x4218000u));\n\tA(uvec4(0xD2FBu,0x4215F5Fu,0x21969Bu,0x421E0E4u));\n\tA(uvec4(0x4214880u,0x421CB8Eu,0xC63E8F8u,0x20E9E8E8u));\n\tA(uvec4(0x252AFEF9u,0x358DF8F9u,0x18E72F3Fu,0x35AE7F3Fu));\n\tA(uvec4(0xC63FCF0u,0xC63F7F7u,0xC63FFFFu,0xC63FF3Fu));\n\tA(uvec4(0x8630B1Bu,0xC630606u,0x8639040u,0xC63E590u));\n\tA(uvec4(0xC635000u,0xC63F4A4u,0xC63DDD4u,0xC63FFFFu));\n\tA(uvec4(0xC630080u,0x1063FF0Au,0xC63FF05u,0x1063FFFFu));\n\tA(uvec4(0x10A50000u,0x14C6AE54u,0xC849B47u,0x1085BF0Bu));\n\tA(uvec4(0xC6377D3u,0xC84FF7Fu,0xC631E95u,0xC845B6Du));\n\tA(uvec4(0xC63A995u,0x1085A4B5u,0x1084A595u,0x14C669B4u));\n\tA(uvec4(0xC84A156u,0x14A6BDF5u,0x10A5EF9Au,0x14A62FBFu));\n\tA(uvec4(0x10A5D5A5u,0x18C7F4E1u,0x18E7E8E4u,0x2129E5A8u));\n\tA(uvec4(0x2129A0A4u,0x254AF044u,0x254AE5F1u,0x318CF4FEu));\n\tA(uvec4(0x296AEFFCu,0x35ADFEEBu,0x31ACA664u,0x3DEFE6C7u));\n\tA(uvec4(0x39CD2464u,0x3E0F6F8Bu,0x35AD596Bu,0x820F5221u));\n\tA(uvec4(0x2D6B1E2Fu,0x39CE5A4Bu,0x1CC60B2Fu,0x2D6B460Bu));\n\tA(uvec4(0x1CC79454u,0x314AFAE9u,0x396C1040u,0xA6F7D000u));\n\tA(uvec4(0x81AE9040u,0xB35B2FA9u,0x1CC7FFFFu,0x9EB605AFu));\n\tA(uvec4(0xC43FFFFu,0xA2F70056u,0xC43AAFFu,0xAB180005u));\n\tA(uvec4(0xC63012Fu,0x9E950000u,0xC21E9A4u,0xC64FFFBu));\n\tA(uvec4(0x443FEA4u,0xC64FFF9u,0xC636400u,0xC65AABDu));\n\tA(uvec4(0xC645500u,0xC66FE55u,0x8635500u,0xC87FFA5u));\n\tA(uvec4(0x4215605u,0x1087FFAAu,0x4210500u,0xC85BF5Au));\n\tA(uvec4(0x1501u,0x4435F56u,0x95A9u,0x4211B96u));\n\tA(uvec4(0xB5Fu,0x4011D5Bu,0x1E4E4u,0x42180E5u));\n\tA(uvec4(0x4219F87u,0x422AF9Fu,0xC63F8F8u,0x1CE8FCF8u));\n\tA(uvec4(0x2509F8F8u,0x316CA4E4u,0x252A3F3Fu,0x358DBE7Eu));\n\tA(uvec4(0xC630201u,0x18C70302u,0xC632F6Fu,0xC630B1Bu));\n\tA(uvec4(0x8635505u,0xC63FDF5u,0x863FEF4u,0xC63FFFFu));\n\tA(uvec4(0xC639550u,0x1083F5F5u,0xFFFFu,0x1063FFFFu));\n\tA(uvec4(0xFFFFu,0x1063FFFFu,0xFFFFu,0x1063FFFFu));\n\tA(uvec4(0x10A5655Fu,0x14A6B9B0u,0x10855515u,0x14A67E65u));\n\tA(uvec4(0xC639645u,0x14A66E96u,0xFFFFu,0xC64FFFFu));\n\tA(uvec4(0xC63D9D5u,0x1085F9E4u,0x10A50505u,0x14C6D4C0u));\n\tA(uvec4(0x10A5596Cu,0x14C69743u,0xC855A5Au,0x14C6D196u));\n\tA(uvec4(0x10A5FAE8u,0x18C7FEFFu,0x18E7A8D1u,0x254AE094u));\n\tA(uvec4(0x254A3850u,0x2D6B71C5u,0x254AC5A4u,0x35ADFAE5u));\n\tA(uvec4(0x318C6958u,0x3DEFFFDBu,0x39CD6DA8u,0x86316565u));\n\tA(uvec4(0x35AD4FBFu,0x3E0F799Cu,0x2D6BBFFEu,0x39CE1F2Bu));\n\tA(uvec4(0x20E76F6Fu,0x318C1A5Bu,0x20E74040u,0x3DAEC000u));\n\tA(uvec4(0x29299000u,0xBB9CFEF4u,0x85EFFFF8u,0xBB7C7FFFu));\n\tA(uvec4(0x20E8071Fu,0xAF3A0002u,0xC43071Fu,0x250A0000u));\n\tA(uvec4(0xC43BB41u,0xC64FFFDu,0xC64E800u,0xC850046u));\n\tA(uvec4(0xC649B3Fu,0xC6400ABu,0xC637AD4u,0xC65EA55u));\n\tA(uvec4(0xC650000u,0x212EF990u,0xC659400u,0x256FFFFEu));\n\tA(uvec4(0x14C8A900u,0x2DB2FFFAu,0x1CE96A00u,0x2D91FFBFu));\n\tA(uvec4(0x14C85600u,0x254FFFAFu,0x10A71500u,0x214EBF6Au));\n\tA(uvec4(0x4431505u,0x18EBBF6Au,0x4210100u,0x14A71F06u));\n\tA(uvec4(0x5255u,0x216F67u,0x99D9u,0x421E499u));\n\tA(uvec4(0x421A959u,0x84390B9u,0xC63F8F8u,0x2509E4F8u));\n\tA(uvec4(0x2509E5F4u,0x2D4BF9E9u,0x2D4BB9B9u,0x358D5455u));\n\tA(uvec4(0xC630202u,0x294B0706u,0xC635505u,0xC63EB55u));\n\tA(uvec4(0xC63E954u,0x1083FFFAu,0xC635554u,0x1484FAA5u));\n\tA(uvec4(0x10835550u,0x14845F55u,0x10830F0Fu,0x1083030Fu));\n\tA(uvec4(0xFFFFu,0x1063FFFFu,0xFFFFu,0x1063FFFFu));\n\tA(uvec4(0x1085C549u,0x14A62462u,0x10A5A55Au,0x18C7E9E4u));\n\tA(uvec4(0xC851A1Au,0x18C75B57u,0xC635554u,0x10A5574Bu));\n\tA(uvec4(0xC64F8F5u,0x1085E5A9u,0x10A55140u,0x18C76D19u));\n\tA(uvec4(0x10A52F5Bu,0x14A50124u,0x10A575E1u,0x14A6FEFAu));\n\tA(uvec4(0x14A6C4E0u,0x1CE7F054u,0x18E7FEE9u,0x2529F8FAu));\n\tA(uvec4(0x254AD080u,0x35ADFDE4u,0x318C21EAu,0x39CEFFD3u));\n\tA(uvec4(0x35ADFA9Cu,0x8210A5A4u,0x39CE8343u,0x8210ADE8u));\n\tA(uvec4(0x318CAB5Bu,0x8210175Bu,0x292A1B6Fu,0x35CE0E07u));\n\tA(uvec4(0x21080000u,0xAF5AF0C0u,0x1484FEE4u,0xBB9CFFFFu));\n\tA(uvec4(0xBB9C0102u,0xBBBCEACAu,0x10642F7Fu,0xBBBD1F2Fu));\n\tA(uvec4(0xC430007u,0x18861515u,0xC640100u,0xC65F980u));\n\tA(uvec4(0x863A800u,0xC65FFFFu,0xC645500u,0x1086FFA9u));\n\tA(uvec4(0xC645400u,0x14CAEAA5u,0x1087E440u,0x2970FEF9u));\n\tA(uvec4(0x254DA990u,0x35D4FFFEu,0x31B25500u,0x3E37FE99u));\n\tA(uvec4(0x31D49540u,0x8258FFEAu,0x35F59600u,0x8238FF96u));\n\tA(uvec4(0x2D915A01u,0x3E17AF6Fu,0x256F1605u,0x31B4AF5Bu));\n\tA(uvec4(0x1D0B6B06u,0x2570FFAFu,0x10856B05u,0x210DFFAFu));\n\tA(uvec4(0x4210600u,0x18EABF5Bu,0x210000u,0xC660701u));\n\tA(uvec4(0x421A496u,0x421E6F2u,0x842F4F8u,0x1CC7A4E4u));\n\tA(uvec4(0x18A7E9FEu,0x292A90E5u,0x252AE9FEu,0x2D4C54A5u));\n\tA(uvec4(0xC840B0Bu,0x294B1F1Bu,0xC635945u,0x1484FEDDu));\n\tA(uvec4(0x1084FAA4u,0x1484FFFFu,0xFFFFu,0x1483FFFFu));\n\tA(uvec4(0x14830000u,0x14840F00u,0x10835505u,0x14835755u));\n\tA(uvec4(0xFFFFu,0x1083FFFFu,0xFFFFu,0x1063FFFFu));\n\tA(uvec4(0x863F8FDu,0x14A596E1u,0x14A56DB4u,0x18C78169u));\n\tA(uvec4(0x14A57A3Du,0x18C76BAEu,0xC646662u,0x14A57F5Bu));\n\tA(uvec4(0xC63F8E5u,0x14A5FEF9u,0x10A585FDu,0x14C66687u));\n\tA(uvec4(0x10A5A293u,0x14A57CA6u,0x10A582DAu,0x14C68552u));\n\tA(uvec4(0x14A5E4E0u,0x1D0895B8u,0x1D08A590u,0x2D8CF5E8u));\n\tA(uvec4(0x2D6B81B8u,0x39CEAEF6u,0x35ADB2BCu,0x3DEFDCA5u));\n\tA(uvec4(0x39CEC081u,0x8210BD78u,0x39CEA757u,0x86310906u));\n\tA(uvec4(0x2D8C9A1Bu,0x3DEF6B65u,0x18A61B6Fu,0x318C8617u));\n\tA(uvec4(0x1CC6FDF8u,0xBB9CFFFEu,0xB79C2A95u,0xBBBC12C0u));\n\tA(uvec4(0xBB9C7FB7u,0xBBBC04EEu,0x14852F2Fu,0xBB9C3F2Fu));\n\tA(uvec4(0xC435B63u,0x1065409Au,0xC659454u,0xC66F8E4u));\n\tA(uvec4(0xC65FFF4u,0x1087FFFBu,0x10869590u,0x14A9F9E5u));\n\tA(uvec4(0x14C99040u,0x2990E4E0u,0x296FE594u,0x35F5FAFAu));\n\tA(uvec4(0x35F5D550u,0x3A1679E0u,0x3E379050u,0x8EBAE4E4u));\n\tA(uvec4(0x86795510u,0x9AFBFFA9u,0x86790500u,0x9AFC5B56u));\n\tA(uvec4(0x3A170501u,0x8EBB5B56u,0x31D41A01u,0x3E385B1Bu));\n\tA(uvec4(0x25710605u,0x31D5AF4Bu,0x212D1B06u,0x2971AF6Bu));\n\tA(uvec4(0x1D0B0500u,0x25506F59u,0x4232F0Bu,0x1CEAFFBFu));\n\tA(uvec4(0x4210400u,0x14A70701u,0x421F8F8u,0x1085E4F4u));\n\tA(uvec4(0x14A690E4u,0x1CC80450u,0x14A7FAFFu,0x21095095u));\n\tA(uvec4(0x14A52F1Fu,0x252A6A6Eu,0x1084FDFCu,0x1484FFF9u));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0xFFFFu,0x1483FFFFu));\n\tA(uvec4(0x14830F0Fu,0x14843F0Fu,0x1083156Bu,0x1483AB15u));\n\tA(uvec4(0x10830000u,0x10830F00u,0xFFFFu,0x1083FFFFu));\n\tA(uvec4(0xC633A5Bu,0x1085AAAEu,0x442F9FEu,0x18C7D1E5u));\n\tA(uvec4(0x14A67D1Du,0x1D08B6FBu,0xC649F7Fu,0x14A5DBC3u));\n\tA(uvec4(0x10A56590u,0x18C7BB7Du,0x10A54BE6u,0x14A5B71Bu));\n\tA(uvec4(0x108507FBu,0x14A5D145u,0x10A55545u,0x14C6A6B9u));\n\tA(uvec4(0x14A5A0D5u,0x2129A4D0u,0x1D08F5E9u,0x2D8BF8F0u));\n\tA(uvec4(0x31AC5040u,0x820FB488u,0x39CE55D0u,0x82307DA5u));\n\tA(uvec4(0x39CEE2AFu,0x8210584Au,0x39CE4046u,0x82107BA5u));\n\tA(uvec4(0x25081B6Fu,0x3DEF1516u,0x1CE790C0u,0x8E53C040u));\n\tA(uvec4(0x9694E8EBu,0xBB9CFEFDu,0xB39B0495u,0xBBBCFFAAu));\n\tA(uvec4(0xAF5A6465u,0xBBBDBFBAu,0x8611BF3Fu,0xB79CFFFFu));\n\tA(uvec4(0x292B6A00u,0xB37CFFFFu,0x10860101u,0xA3190B07u));\n\tA(uvec4(0x1087D880u,0x1088E5E4u,0x14A8F8F4u,0x14C9FCFCu));\n\tA(uvec4(0x18EBF4E0u,0x2D92E4F4u,0x31B3F9E4u,0x35F6FAF9u));\n\tA(uvec4(0x35F6A554u,0x3E38E5D5u,0x8258E4E4u,0x96FCF9F5u));\n\tA(uvec4(0x9AFC5450u,0xA33DED9Du,0x92DC1F0Au,0x9F3C6F5Bu));\n\tA(uvec4(0x86591F0Bu,0x92DC5B0Bu,0x39F61F1Bu,0x82596F6Fu));\n    //if(Double_pixelID == 24*7)\n        //col = vec4(1.,0.,0.,1.);\n    //-------------------------------------------------------------------------\n\tC = col + texelFetch(iChannel0,SV_DispatchThreadID,0);\n    \n}", "buffer_a_inputs": [], "buffer_b_code": "highp ivec2 SV_DispatchThreadID = ivec2(0,0);\nhighp int Double_pixelID = 0;\nhighp vec4 col = vec4(0.,0.,0.,0.);\nint i = 616;\n\n//pass !\nvoid A(vec4 data){\n    if(Double_pixelID == i++){\n        col = data;\n    }\n}\nvoid A(uvec4 data){\n    if(Double_pixelID == i++){\n        col = uintBitsToFloat(data);\n    }\n}\n\nvoid mainImage( out vec4 C, in vec2 U)\n{\n    SV_DispatchThreadID = ivec2(floor(U-0.5));\n    if(SV_DispatchThreadID.x >= 48 || SV_DispatchThreadID.y >= 77){\n    \tC = vec4(1./3.);\n        return;\n    }\n    if(iFrame > 2){\n    \tC = texture(iChannel0,U/iResolution.xy);\n        //discard;\n    }\n    //1个像素存一个数据块\n    //16 x 32, 16为其中2个像素存2个块数据\n    //像素ID编号\n    Double_pixelID = (SV_DispatchThreadID.x>>1) + (SV_DispatchThreadID.y*24); \n    //-------------------------------------------------------------------------\n\tA(uvec4(0x31B45A05u,0x3A17BF6Fu,0x25700B06u,0x2DB46F1Bu));\n\tA(uvec4(0x212E5F0Bu,0x2550BFBFu,0x1CEB1B06u,0x254EAF6Fu));\n\tA(uvec4(0x4231F0Bu,0x1CEABF7Fu,0x442E4F0u,0xC65E7D4u));\n\tA(uvec4(0xC65A6EDu,0x148694A6u,0x10A6D5FDu,0x14A79494u));\n\tA(uvec4(0x14A7B9BEu,0x1CE890A4u,0x14A40601u,0x14A65707u));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0x10830F03u,0x14830F0Fu));\n\tA(uvec4(0x10830F0Fu,0x10830F0Fu,0xFFFFu,0x1083FFFFu));\n\tA(uvec4(0xC634004u,0x254A7FF9u,0x1084AED0u,0x254A5559u));\n\tA(uvec4(0x14C59966u,0x2129F0B9u,0x14A66605u,0x1D088756u));\n\tA(uvec4(0x10A58DEFu,0x18C7FB9Bu,0x10A51A52u,0x18C76B6Eu));\n\tA(uvec4(0x10A54481u,0x14A6F6B8u,0x10A50B0Bu,0x14A59101u));\n\tA(uvec4(0x14A5F9F9u,0x1CE7F4F0u,0x2129D0A9u,0x31ACF8E4u));\n\tA(uvec4(0x31ACD6A4u,0x821055A4u,0x39EEA297u,0x8210E7C8u));\n\tA(uvec4(0x39CE34B5u,0x86307EEAu,0x318C5A1Fu,0x8210061Au));\n\tA(uvec4(0x18A52B6Bu,0x318C0A1Au,0x1CC7E0D0u,0xB37BF9F4u));\n\tA(uvec4(0xB79C1814u,0xBBBD2231u,0xB37BDEDEu,0xBBBCF4F9u));\n\tA(uvec4(0xB37B6FABu,0xBBBD552Au,0xB79C14C0u,0xBFDE4040u));\n\tA(uvec4(0xB77BFFFFu,0xBB9C3A3Du,0x14A70B0Bu,0xB37C1F1Fu));\n\tA(uvec4(0x1087E4F4u,0x108890E8u,0x1088E8F8u,0x14CA90D0u));\n\tA(uvec4(0x18CBD0E4u,0x2992D0D0u,0x31D4E4E5u,0x3A17E4D4u));\n\tA(uvec4(0x3A1799D4u,0x8258E4D9u,0x8679E4E4u,0x9AFCF9F8u));\n\tA(uvec4(0x9B1C7DF8u,0x9F3C845Du,0x96FC192Au,0x9F3D5F1Fu));\n\tA(uvec4(0x8A9B1A06u,0x96FC5B5Bu,0x3E381B07u,0x8679A71Fu));\n\tA(uvec4(0x35F60616u,0x3E387F57u,0x29722F2Fu,0x31D5AFBFu));\n\tA(uvec4(0x254F1919u,0x29725F1Fu,0x212D1B0Bu,0x254FBF6Fu));\n\tA(uvec4(0x1D0A1A06u,0x212E5B1Au,0xC650B02u,0x1CEABF6Fu));\n\tA(uvec4(0xC65FAFEu,0x1085F3F9u,0x1085FFFFu,0x1086FCFFu));\n\tA(uvec4(0x1086F9F9u,0x14C7E4F5u,0x14A50707u,0x14C70B17u));\n\tA(uvec4(0x14A40A05u,0x18A45B1Eu,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0x10830F0Fu,0x1483030Fu));\n\tA(uvec4(0x10830F0Fu,0x10830003u,0xFFFFu,0x1083FFFFu));\n\tA(uvec4(0x14C65E6Du,0x21295915u,0x14C6E4D1u,0x1D08FDE8u));\n\tA(uvec4(0x18C6D6E0u,0x2529A994u,0x18E71A16u,0x25291F5Bu));\n\tA(uvec4(0x14C66104u,0x21295B59u,0x14A54B65u,0x18C7F1B7u));\n\tA(uvec4(0x10A51E19u,0x14C6FEEFu,0x1085D91Fu,0x14A6ABD3u));\n\tA(uvec4(0x14C6D0D4u,0x2128A4F0u,0x2549E4F4u,0x35CDE499u));\n\tA(uvec4(0x35CD7050u,0x820F9D24u,0x3DEE7D59u,0x8A51797Cu));\n\tA(uvec4(0x39CE0B6Fu,0x82305D5Au,0x20E86F6Bu,0x35AD276Fu));\n\tA(uvec4(0x2509A000u,0xB79CF8F4u,0x81CEF8FCu,0xBB7BC3F1u));\n\tA(uvec4(0xBB9C6E8Au,0xBBBCA038u,0xB37B5691u,0xBBBC9B5Au));\n\tA(uvec4(0xBB9CF8D0u,0xBFFEE9FDu,0xB39C1F06u,0xBFFFE96Au));\n\tA(uvec4(0xAB19BEBFu,0xBBBCF3B9u,0x14862F1Fu,0xB77CBF7Fu));\n\tA(uvec4(0xC45FEFFu,0xC87FEFCu,0x1087E9E4u,0x14A9E4E5u));\n\tA(uvec4(0x14CBD0D0u,0x2550D0D0u,0x2DB3F9F9u,0x3A16F4F4u));\n\tA(uvec4(0x35F6E5E9u,0x86784080u,0x8258FEFAu,0x96FC00F9u));\n\tA(uvec4(0x8A78FFFFu,0x9B1C50AFu,0x92BAFFFFu,0x9B1C40FFu));\n\tA(uvec4(0x8EBB7B17u,0x96FCC9EAu,0x3E380B06u,0x8EBB6F2Fu));\n\tA(uvec4(0x36179565u,0x82590706u,0x2DB41702u,0x35F66F2Fu));\n\tA(uvec4(0x25710A05u,0x2DB41B1Au,0x214E0B0Fu,0x25700606u));\n\tA(uvec4(0x1D0C1F1Au,0x1D2E5B1Fu,0x1D0A1A00u,0x1D0C2F1Fu));\n\tA(uvec4(0xC850B06u,0x18E9BF6Fu,0xC65FFFFu,0x1065F3FFu));\n\tA(uvec4(0x1065E5EAu,0x14A69495u,0x14A50A0Bu,0x14C71516u));\n\tA(uvec4(0x14A4171Fu,0x18A41F17u,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0x1483333Fu,0x14843333u,0x10830303u,0x14830303u));\n\tA(uvec4(0xFFFFu,0x1083FFFFu,0xFFFFu,0x1063FFFFu));\n\tA(uvec4(0x1CE79996u,0x2129E8F8u,0x1CE74454u,0x296BA6DAu));\n\tA(uvec4(0x1D08B41Eu,0x254A9AE6u,0x1CE7A85Au,0x2D6BF0B4u));\n\tA(uvec4(0x14C60B67u,0x2108FFABu,0x14C60D04u,0x2129A256u));\n\tA(uvec4(0x14A55629u,0x18E76EAFu,0x14A60404u,0x1D08D590u));\n\tA(uvec4(0x18E7F0A0u,0x2529D094u,0x2549E5E4u,0x39EEEDF9u));\n\tA(uvec4(0x39ED79A4u,0x86506F3Du,0x3DEEF1F7u,0x82301D68u));\n\tA(uvec4(0x2D6B7FBFu,0x3DEE0B1Fu,0x25090000u,0xA2F7C040u));\n\tA(uvec4(0x3DCFFDFCu,0xBBBDFFFFu,0x81AC1F4Bu,0xBB9CBF7Fu));\n\tA(uvec4(0x81ADFEFFu,0xBB9CF4F8u,0xB79C2905u,0xBBBD20BAu));\n\tA(uvec4(0xB79CA8A4u,0xBFFEFDF8u,0xB39CE1F5u,0xBFFFFEF9u));\n\tA(uvec4(0xA718C3D3u,0xBBBDD3C3u,0xA2D87F3Bu,0xBB9C7B7Fu));\n\tA(uvec4(0xC664342u,0x250A0243u,0x1087D5D5u,0x14A9D094u));\n\tA(uvec4(0x14CAD0D0u,0x2550D0D0u,0x31D468B4u,0x3A164000u));\n\tA(uvec4(0x35F65050u,0x8E9BFAA4u,0x39F61605u,0x8A7ABF1Bu));\n\tA(uvec4(0x2D9346E6u,0x3E171B06u,0x2D92A4FEu,0x8A780000u));\n\tA(uvec4(0x2D91AAFFu,0x8A994055u,0x31D3BEFFu,0x8A9A0055u));\n\tA(uvec4(0x35F56A1Fu,0x3E3800ABu,0x2DB45606u,0x35F65A6Bu));\n\tA(uvec4(0x21710717u,0x2DB41B0Bu,0x1D2E5B5Bu,0x2170476Au));\n\tA(uvec4(0x1D0C1B1Bu,0x1D2E561Bu,0x1D0CF0FCu,0x1D0CF5F4u));\n\tA(uvec4(0x14C86B1Bu,0x1D0BBFAFu,0x10650601u,0x18E91F0Bu));\n\tA(uvec4(0x1064F5F5u,0x1485F9F8u,0x18A52919u,0x18A50B29u));\n\tA(uvec4(0x14A41A1Au,0x18A51B1Au,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0x10830303u,0x14830F03u));\n\tA(uvec4(0xFFFFu,0x1083FFFFu,0xFFFFu,0x1063FFFFu));\n\tA(uvec4(0x1CE7E9E0u,0x2529F9FDu,0x25290400u,0x2D6B6D6Du));\n\tA(uvec4(0x2108EDB8u,0x25297F9Du,0x18E799D4u,0x294AAA6Au));\n\tA(uvec4(0x21290705u,0x31AD2C06u,0x18E72A65u,0x25296A97u));\n\tA(uvec4(0x14C62955u,0x2108AB6Bu,0x14C6FDF4u,0x1CE7FBADu));\n\tA(uvec4(0x1CE7E8F4u,0x254AD4D5u,0x2D8BB890u,0x822FE9E5u));\n\tA(uvec4(0x3DEEF0BAu,0x8651F9A4u,0x35AC1B6Fu,0x82301517u));\n\tA(uvec4(0x1CC76EAFu,0x35CD061Au,0x20E8F0D0u,0xB39CFDF8u));\n\tA(uvec4(0xBBBC94A5u,0xBBBDB5E5u,0xBB7BFF3Fu,0xBBBDBFFFu));\n\tA(uvec4(0x396B83E1u,0xB77B1F4Bu,0x9632FEFFu,0xB79BE8F9u));\n\tA(uvec4(0xB79CD1E8u,0xBFFE0000u,0xB35B2BFFu,0xBFFF455Au));\n\tA(uvec4(0xA2D7BDF4u,0xBB9CFEBFu,0x14657FBFu,0xBB9C0B2Fu));\n\tA(uvec4(0x843B4FEu,0xC659155u,0xC64E5EAu,0x1088F9E4u));\n\tA(uvec4(0x14CAE090u,0x31B4E4E4u,0x31B450E4u,0x8218AE14u));\n\tA(uvec4(0x39B650FFu,0x8659B590u,0x3DF754BFu,0x8A7A0100u));\n\tA(uvec4(0x35D56F1Fu,0x82395969u,0x29716F15u,0x39D6BFBFu));\n\tA(uvec4(0x25500550u,0x3194BF1Bu,0x212FA5FFu,0x2D920601u));\n\tA(uvec4(0x212EFAFFu,0x2DB350A5u,0x25716AAFu,0x31D50055u));\n\tA(uvec4(0x2570061Bu,0x2DB30505u,0x1D2E0747u,0x25700206u));\n\tA(uvec4(0x190C7F77u,0x1D0D7F3Fu,0x190CF5FAu,0x1D0CF9F4u));\n\tA(uvec4(0x190B5B1Bu,0x1D0CA756u,0x10862F1Fu,0x1D0ABF7Fu));\n\tA(uvec4(0xC65F8E4u,0x14A5FFF9u,0x14A5FFFFu,0x18A53FFFu));\n\tA(uvec4(0x14A45717u,0x14A55757u,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0x10831705u,0x14845F5Fu));\n\tA(uvec4(0x10830F00u,0x10830F0Fu,0xFFFFu,0x1063FFFFu));\n\tA(uvec4(0x1CE7F8F8u,0x2549F9E8u,0x2529F950u,0x2D6BFAEAu));\n\tA(uvec4(0x25298701u,0x2D6BFE97u,0x2128B854u,0x296B9BFDu));\n\tA(uvec4(0x2529617Cu,0x2D8C8AC9u,0x25290601u,0x31AD570Au));\n\tA(uvec4(0x18E73CBAu,0x2109FB8Au,0x18E74DF8u,0x1D08D387u));\n\tA(uvec4(0x21285040u,0x8210E490u,0x39EEB8C0u,0x8651B5F9u));\n\tA(uvec4(0x35AD9BABu,0x86501A57u,0x29296B6Bu,0x3DEE125Au));\n\tA(uvec4(0x25084000u,0xAF5BE0D0u,0x9AD6FEFCu,0xBBBDFFFFu));\n\tA(uvec4(0xBBBCFFFFu,0xBBBDF7F4u,0xB7BD4B56u,0xBBBDAF1Eu));\n\tA(uvec4(0x3D8CBF2Fu,0xBBBDFFFFu,0x3109E4F8u,0xAAF787D2u));\n\tA(uvec4(0xA2B5FDFFu,0xB79BE4F9u,0xB35B2A1Bu,0xBBBD2546u));\n\tA(uvec4(0x14667FFFu,0xBB9C010Bu,0x10670003u,0x8A110000u));\n\tA(uvec4(0xC664000u,0x31B3F9A0u,0xC660500u,0x31B3AF56u));\n\tA(uvec4(0xC67D4E4u,0x82160100u,0xC69FFFFu,0x8A3990F9u));\n\tA(uvec4(0x8A3ABA10u,0xB39E54FEu,0x82186F05u,0x9ADB5B6Fu));\n\tA(uvec4(0x39D60A01u,0x8E7A6A1Fu,0x35B50400u,0x8A387E15u));\n\tA(uvec4(0x2531065Au,0x35B41B1Bu,0x210F6F2Fu,0x29710095u));\n\tA(uvec4(0x1D0C0A45u,0x254F7E2Fu,0x1D0CE9FEu,0x25704090u));\n\tA(uvec4(0x1D2EBFFFu,0x2570016Au,0x1D2D1B5Bu,0x214F5519u));\n\tA(uvec4(0x1D0D1F6Fu,0x1D2D9F7Fu,0x1D0CA594u,0x1D2DFFE9u));\n\tA(uvec4(0x190C4645u,0x1D2D4346u,0x1CE96B1Bu,0x1D0CAF6Fu));\n\tA(uvec4(0x14A51612u,0x1CE91B17u,0x14A45F7Fu,0x18A51D55u));\n\tA(uvec4(0x14A40F0Fu,0x14A40030u,0xFFFFu,0x14A4FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0x10835705u,0x1483D17Fu,0x10835605u,0x1483AF5Au));\n\tA(uvec4(0x1CE7FCFDu,0x2129FFFEu,0x2529F4F9u,0x2D6BE0F4u));\n\tA(uvec4(0x2549B63Fu,0x2D6BB2A2u,0x2549BF54u,0x2D6BFEFEu));\n\tA(uvec4(0x25292F1Fu,0x2D6BBFBFu,0x25296D7Fu,0x35ADF1F4u));\n\tA(uvec4(0x1CE85BA6u,0x294A1F1Bu,0x18E75441u,0x2D6BF9E4u));\n\tA(uvec4(0x2D8BE8E4u,0x3E0FFEF9u,0x39EEA65Bu,0x86512F3Du));\n\tA(uvec4(0x2D6B2F3Fu,0x3DEF0507u,0x25290000u,0x96B5C040u));\n\tA(uvec4(0x20E7FDF4u,0xB79CFFFEu,0xBBBCFFFFu,0xBBBDF3FFu));\n\tA(uvec4(0xBBBDFDF4u,0xBBBDD1FDu,0xBBBD5F05u,0xBBBD015Fu));\n\tA(uvec4(0xB79C56E6u,0xBBBD15D6u,0x352A2F0Bu,0xBB9CFF7Fu));\n\tA(uvec4(0x3129F8FEu,0xA2D681E0u,0x250C7F7Fu,0xB35A3E7Eu));\n\tA(uvec4(0x823E9A4u,0x14A9F9F9u,0x14A9E994u,0x31D3F9F9u));\n\tA(uvec4(0x2991E590u,0x8E9AF9F9u,0x35936A05u,0x9AFCFFAFu));\n\tA(uvec4(0x29304500u,0x92BAAF5Au,0x108B1601u,0x39D6FFAAu));\n\tA(uvec4(0x14ABE0FDu,0x86186A41u,0x2952FFFFu,0x86180090u));\n\tA(uvec4(0x2952FFFFu,0x3DD700EBu,0x2D73FFFFu,0x86180096u));\n\tA(uvec4(0x29521B07u,0x81F86E5Bu,0x1CEE0606u,0x29526B17u));\n\tA(uvec4(0x18EC95E5u,0x254E1506u,0x190C1A07u,0x254E5469u));\n\tA(uvec4(0x190CA4F8u,0x1D2E6659u,0x190CBFFFu,0x1D0D546Au));\n\tA(uvec4(0x190C9D96u,0x1D2DF4EDu,0x1D2D9040u,0x214FF9E5u));\n\tA(uvec4(0x190C5642u,0x1D4E9B57u,0x1D0B5B0Au,0x214EAF5Fu));\n\tA(uvec4(0x14A51B17u,0x1D0B5F1Bu,0x14A41A1Eu,0x18A45555u));\n\tA(uvec4(0x14A4FDF4u,0x18A5FFFFu,0xFFFFu,0x18A5FFFFu));\n\tA(uvec4(0xFFFFu,0x18A5FFFFu,0x14845A15u,0x18A5AF6Bu));\n\tA(uvec4(0x1483FFF3u,0x1484FFFFu,0x1083FF3Fu,0x1484FFFFu));\n\tA(uvec4(0x2108F9E1u,0x2549A4E6u,0x2129E1E1u,0x296BE0F5u));\n\tA(uvec4(0x296BDA80u,0x318C96A4u,0x25496B1Bu,0x2D8BBFBFu));\n\tA(uvec4(0x294A8659u,0x2D8C2E45u,0x21298EC6u,0x2D8B3F1Eu));\n\tA(uvec4(0x21290706u,0x35ADA85Au,0x2129E4E0u,0x39EEFAF9u));\n\tA(uvec4(0x3E0FF8A0u,0x86510415u,0x318C1A1Fu,0x86310006u));\n\tA(uvec4(0x20E82A6Au,0x81F0C106u,0x2109F4E0u,0xB39CFFFDu));\n\tA(uvec4(0xBBBC5081u,0xBBDDA839u,0xBBBC3FF0u,0xBBBDFFDFu));\n\tA(uvec4(0xBB9DF7AFu,0xBBBDC7F3u,0xBBBC5F55u,0xBBBD015Fu));\n\tA(uvec4(0xB79CD515u,0xBBDD2625u,0xB79C4C66u,0xBBBC0256u));\n\tA(uvec4(0x2908AF47u,0xAF396FBFu,0x18CB0B2Fu,0xA6F80002u));\n\tA(uvec4(0x10A99040u,0x1D0EEF95u,0x212DE4E4u,0x3A16F9F4u));\n\tA(uvec4(0x35F5A5D0u,0x8E9AEAFAu,0x92BA94F9u,0x9F1D4004u));\n\tA(uvec4(0x92BBFF1Bu,0x9B1CF4FAu,0x8639AF01u,0x9B1CFFFFu));\n\tA(uvec4(0x35D6BF05u,0x8EBABBFFu,0x2D731601u,0x8A7AFFBFu));\n\tA(uvec4(0x29530100u,0x867ABF16u,0x29520040u,0x3E381B01u));\n\tA(uvec4(0x2130FAFFu,0x35B500D0u,0x25301605u,0x3194015Fu));\n\tA(uvec4(0x18EC0611u,0x252F2F1Fu,0x14CA90F4u,0x1D0C0600u));\n\tA(uvec4(0x14CBAEBFu,0x1D0DA8BDu,0x18EBFEFEu,0x190CF1FDu));\n\tA(uvec4(0x190C94A4u,0x1D2ED0D0u,0x1D2EE490u,0x2991F9E4u));\n\tA(uvec4(0x1D2D0605u,0x29B21B0Au,0x1D2D5E1Au,0x256F6E5Eu));\n\tA(uvec4(0x18C71B1Bu,0x212C6F2Fu,0x14A50000u,0x14A60301u));\n\tA(uvec4(0x18A5F994u,0x18C5F8F9u,0x18C50000u,0x1CC5F880u));\n\tA(uvec4(0x18C50000u,0x1CC5BF0Au,0x14A56B1Au,0x18A5BF6Fu));\n\tA(uvec4(0x14A41605u,0x18A56B5Au,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0x21291000u,0x254A6B75u,0x2108D0D0u,0x296BE5E5u));\n\tA(uvec4(0x294A51A6u,0x318CF965u,0x296BBE1Au,0x31AC5FAEu));\n\tA(uvec4(0x2D8B1558u,0x35AD6E19u,0x296B910Bu,0x31ADEFEAu));\n\tA(uvec4(0x2128F1F9u,0x318CEFEAu,0x31ACFCF5u,0x3DEFAABDu));\n\tA(uvec4(0x2D6B6FBFu,0x3DEF161Au,0x20E81BAAu,0x35AD8106u));\n\tA(uvec4(0x20E8E4D0u,0xB79CFEF9u,0xB79C7AE1u,0xBBBDFBADu));\n\tA(uvec4(0xBBBD19E6u,0xBBBD75D3u,0xBB9CEFBBu,0xBBBD3EF6u));\n\tA(uvec4(0xBBBCEAFEu,0xBBDDB1AEu,0xB79BAD66u,0xBBBE149Fu));\n\tA(uvec4(0xB35BBFEFu,0xBBBC062Bu,0x3DF3BFFFu,0xB37A811Fu));\n\tA(uvec4(0x2D71910Bu,0x96DAFFFEu,0x2D925B00u,0x8A79BF6Fu));\n\tA(uvec4(0x1D2F4140u,0x31B41B07u,0x1D0FF9F9u,0x39F6E4E9u));\n\tA(uvec4(0x3A17E4E4u,0x8E9980E0u,0x8E9AE5E0u,0x9AFCF4E0u));\n\tA(uvec4(0x96DB1900u,0xA33D696Eu,0x92BA0A1Au,0x9AFC0B5Fu));\n\tA(uvec4(0x82579101u,0x92DBFBEBu,0x3A165601u,0x8A9A2FBBu));\n\tA(uvec4(0x31D415E9u,0x8A9B005Au,0x2992F9BFu,0x8A7A0001u));\n\tA(uvec4(0x21305B05u,0x825850AAu,0x1D0E0101u,0x2DB2BF1Bu));\n\tA(uvec4(0x1CED1410u,0x212FAF24u,0xC68E5BFu,0x18ECBF0Bu));\n\tA(uvec4(0xC88EFFAu,0x1D0C50E9u,0x14ECEBC6u,0x1D0CEDABu));\n\tA(uvec4(0x190D8081u,0x254FAE58u,0x2570D490u,0x31D3E4E4u));\n\tA(uvec4(0x1D2E1F1Bu,0x2DD36F2Fu,0x1D2EF8BDu,0x256FF4F4u));\n\tA(uvec4(0x1D0A1B07u,0x214E1F1Bu,0x18A50202u,0x18E81B07u));\n\tA(uvec4(0x18A5F4A4u,0x1CC5F5F5u,0x1CC5FFF4u,0x1CC6FFFFu));\n\tA(uvec4(0x1CC5FF0Fu,0x1CC6FFFFu,0x18A56A16u,0x1CC5AF6Fu));\n\tA(uvec4(0x14A41F1Bu,0x18A51F1Fu,0xFFFFu,0x14A4FFFFu));\n\tA(uvec4(0x254A9611u,0x2D6BFFAFu,0x2549D1D0u,0x2D6BEAE5u));\n\tA(uvec4(0x2D6B95EAu,0x31ACD195u,0x318C591Fu,0x35CDBE7Du));\n\tA(uvec4(0x2D8C1919u,0x39CEFE6Du,0x2D8C6904u,0x35CEFABAu));\n\tA(uvec4(0x254A1E85u,0x35CE6F1Fu,0x294ABEFFu,0x39EE5469u));\n\tA(uvec4(0x2529166Bu,0x39ADC005u,0x292AE080u,0xB39CFEF8u));\n\tA(uvec4(0xB39CEDA4u,0xBBBDFBBAu,0xBB9CEFBFu,0xBBBD2BEFu));\n\tA(uvec4(0xBBBDFBAAu,0xBFDE075Eu,0x2508FFFFu,0xBBBC00BFu));\n\tA(uvec4(0x18A5FFFFu,0xBBBD0016u,0x20E76BFFu,0xBBBC0400u));\n\tA(uvec4(0x358EA9BFu,0xAF3A9594u,0x18C8FFFEu,0x8A7850A5u));\n\tA(uvec4(0x2DB4FEFFu,0x96FBF8FAu,0x82581B07u,0x96FB6F5Bu));\n\tA(uvec4(0x25721A06u,0x82596B6Bu,0x1D0F81E0u,0x35D51A06u));\n\tA(uvec4(0x2551A9EAu,0x863850A4u,0x3A17E4FEu,0x8E9AE4E0u));\n\tA(uvec4(0x8EBA0059u,0x9F3EFE10u,0x8658005Au,0x9F3CFF94u));\n\tA(uvec4(0x8678051Au,0x92DB7F6Fu,0x2D922F1Bu,0x8257BFBFu));\n\tA(uvec4(0x212F0645u,0x31B31F1Bu,0x10AA0BE7u,0x212F1A1Eu));\n\tA(uvec4(0xC88FEFFu,0x1D2E90A5u,0x18EBFDFFu,0x299150F9u));\n\tA(uvec4(0x1CEDBF1Eu,0x2970AFFFu,0x18EC0104u,0x2550BF1Bu));\n\tA(uvec4(0xCA96A06u,0x1D0DAF5Au,0xC8850E9u,0x1D0C0A05u));\n\tA(uvec4(0x867FEFFu,0x1D2DD0F5u,0x1D2DE4F9u,0x31D4E0E0u));\n\tA(uvec4(0x216F1B1Au,0x3A166F1Fu,0x1D2DF4F9u,0x256FE1F5u));\n\tA(uvec4(0x1D0B1B1Bu,0x256F1B1Bu,0x18C60B07u,0x1CE90B0Bu));\n\tA(uvec4(0x18C5FDF4u,0x1CC6FFFEu,0xFFFFu,0x1CC6FFFFu));\n\tA(uvec4(0xFFFFu,0x1CC6FFFFu,0x1CC51B1Bu,0x1CC61B1Bu));\n\tA(uvec4(0x14A45F1Bu,0x18C56B5Fu,0x14A47070u,0x14A57474u));\n\tA(uvec4(0x2D6AA0B5u,0x2D8B90A4u,0x2D6BFD44u,0x31ACF9FDu));\n\tA(uvec4(0x2D8B9580u,0x35ADE7E6u,0x35AD7C28u,0x39EE5AB8u));\n\tA(uvec4(0x39EE0C58u,0x3E0F7C18u,0x31AD4797u,0x39EE1F1Bu));\n\tA(uvec4(0x292AAF6Fu,0x31AD165Bu,0x252A0000u,0x9273D040u));\n\tA(uvec4(0x292AE490u,0xB39CFFF9u,0xB39CBAA0u,0xBBBDEBE9u));\n\tA(uvec4(0xBB9DDDEDu,0xBBBEFB63u,0x18A56FFFu,0xBBDE530Bu));\n\tA(uvec4(0x20E7E003u,0xA7180080u,0x10650BA9u,0x9296F841u));\n\tA(uvec4(0x18C74001u,0x96B9FFFEu,0x1CE7AF54u,0x8A77FFFFu));\n\tA(uvec4(0x212A0004u,0x9B1BFFFEu,0x14A8A960u,0xAB5DFFFFu));\n\tA(uvec4(0x2573FEF8u,0xA75DFFFFu,0x8EBB2F1Bu,0xA33D6F6Fu));\n\tA(uvec4(0x35D61B06u,0x8EBB6F6Bu,0x25521B06u,0x31D6AF6Fu));\n\tA(uvec4(0x1D10C0D0u,0x31D50541u,0x2973E9E9u,0x92BBD4E5u));\n\tA(uvec4(0x9F1DFDF8u,0xA77EF8FCu,0x9F3DBA01u,0xAB9EFFFFu));\n\tA(uvec4(0x96FC5601u,0xAB7EFFABu,0x82580605u,0xA75E1B0Au));\n\tA(uvec4(0x25701606u,0x3E376F1Bu,0x18EB5607u,0x212E6F5Bu));\n\tA(uvec4(0xC874641u,0x1CEB1F0Bu,0xC88E5FEu,0x14EB5054u));\n\tA(uvec4(0x14CAF8FAu,0x254F90A4u,0x1D2ED6BFu,0x25700444u));\n\tA(uvec4(0x214FAE5Au,0x299064B5u,0x18EB6F1Au,0x256EFFBFu));\n\tA(uvec4(0xC87AA91u,0x214EFFFFu,0x190C80E0u,0x31D31501u));\n\tA(uvec4(0x1D2DBEBFu,0x3E37FCFEu,0x214D4151u,0x2DD20702u));\n\tA(uvec4(0x1D0B6F2Fu,0x254E6E6Fu,0x1CC61B0Bu,0x1D0A5B5Bu));\n\tA(uvec4(0x1CE65450u,0x1CE7F575u,0x1CE60201u,0x1CE60702u));\n\tA(uvec4(0x1CC5FFFFu,0x1CC60F3Fu,0x18C55A6Bu,0x1CC60555u));\n\tA(uvec4(0x14A47F7Fu,0x18A53F7Fu,0x14A4F574u,0x14A5F4F5u));\n\tA(uvec4(0x2528A9FAu,0x2D6A54A4u,0x2949E5E9u,0x35ACA4E4u));\n\tA(uvec4(0x35CD0000u,0x820E2D40u,0x35CDD691u,0x39EEEE5Bu));\n\tA(uvec4(0x35CDAEAEu,0x3E0F1B1Du,0x29495B6Fu,0x39CE061Au));\n\tA(uvec4(0x294B0000u,0xB35AF990u,0x294AF9E4u,0xB39CFFFFu));\n\tA(uvec4(0xB79C5150u,0xBBDEAAC9u,0xBB9CFFFFu,0xBBBDFF3Fu));\n\tA(uvec4(0x2D49BFFFu,0xBBDD1F3Fu,0x358C196Au,0xA2F9F6D9u));\n\tA(uvec4(0x1085F480u,0x9AFAFFBFu,0x8A76F4ABu,0xA33CFBFDu));\n\tA(uvec4(0x96DA291Au,0x9F3CFF6Bu,0x8A78A550u,0xA33D1FFAu));\n\tA(uvec4(0x8235FEFEu,0xA73D00FFu,0x3E36FFFFu,0xAB5C00FFu));\n\tA(uvec4(0x8257FFFFu,0xA33C90FFu,0x96DB6B6Fu,0x9F3C64ABu));\n\tA(uvec4(0x867A0B07u,0x96FC7B1Bu,0x31B65B06u,0x867AAF5Bu));\n\tA(uvec4(0x21311A06u,0x35F7BF6Fu,0x2551D0D0u,0x8A7AD1D0u));\n\tA(uvec4(0x8EBAE9FAu,0xA75EE5E8u,0xA35EE0FAu,0xAF9EE0E0u));\n\tA(uvec4(0xAB7C6E66u,0xB3BF7E1Au,0x8A9A1B1Bu,0xAB7E0B1Bu));\n\tA(uvec4(0x29B21B1Bu,0x86791B1Bu,0x212D561Au,0x25911B07u));\n\tA(uvec4(0xC88FF3Fu,0x1D0CFFFFu,0xC670040u,0x212D1F43u));\n\tA(uvec4(0x10A9FDF9u,0x18EBE4A8u,0x18ECF9FEu,0x212EF0F8u));\n\tA(uvec4(0x212FFFFFu,0x214F02FFu,0x214FF5E0u,0x256FE8F6u));\n\tA(uvec4(0x256FF4A5u,0x2DB1B9F9u,0x190C1B1Bu,0x29906F6Fu));\n\tA(uvec4(0x14EBF4F8u,0x3A37A4F4u,0x1D2C1B07u,0x3A141A1Fu));\n\tA(uvec4(0x190B3E7Eu,0x212D1129u,0x20E71B1Bu,0x1CEA5F5Bu));\n\tA(uvec4(0x1CE75650u,0x25076BAAu,0x1CC60706u,0x20E71B0Bu));\n\tA(uvec4(0x1CC51D1Du,0x1CC51F1Fu,0x18C50300u,0x1CC5030Fu));\n\tA(uvec4(0x14A46F7Fu,0x18A56F2Fu,0x14A4F5F5u,0x14A595F4u));\n\tA(uvec4(0x1CE6AAFEu,0x25280565u,0x25499040u,0xA738F4E0u));\n\tA(uvec4(0x86506A14u,0xA738FFFFu,0x39EE0100u,0xA3160702u));\n\tA(uvec4(0x39CE0000u,0xA317E440u,0x316BE440u,0xB37BFFFEu));\n\tA(uvec4(0xA2F8FEF8u,0xB7BCFFFFu,0xBBBCE681u,0xBBBDFEF6u));\n\tA(uvec4(0xBBBC4FFFu,0xBBBE451Fu,0xAF5BFFFFu,0xBBBD3BFFu));\n\tA(uvec4(0x318C1B6Fu,0xB39B965Bu,0x821FDF8u,0xA33CFFFEu));\n\tA(uvec4(0x9AFB5A40u,0xA35C7FAEu,0x8256EBFFu,0x9F3C3BEFu));\n\tA(uvec4(0x256F0BBFu,0x9B1CF8E2u,0x31B1F900u,0x9B1CFFFFu));\n\tA(uvec4(0x39F4FF00u,0x9F1CFFFEu,0x31D3FF00u,0x9AFBFFFFu));\n\tA(uvec4(0x25706B00u,0x96FBFFFFu,0x214E01E9u,0x92DAFF6Fu));\n\tA(uvec4(0x212EF9FFu,0x92BA1B40u,0x18EDFFFFu,0x8679A4FFu));\n\tA(uvec4(0x35F77F1Au,0x8239957Eu,0x31B6D5D0u,0x8A9AFAE9u));\n\tA(uvec4(0x96DCA8D8u,0xA35EE4E4u,0xA35EF4F4u,0xAF9ED5E4u));\n\tA(uvec4(0xA75E2F7Eu,0xB3BE1F1Fu,0x867A2B6Bu,0x9F3C1B1Bu));\n\tA(uvec4(0x29921F2Fu,0x3E381B1Bu,0x1D0D6B7Fu,0x25500707u));\n\tA(uvec4(0x14CB5BDFu,0x1D0C0117u,0x14AABE3Fu,0x212DE9FEu));\n\tA(uvec4(0xC8891D4u,0x18CB9393u,0x18ECE090u,0x2571E4E0u));\n\tA(uvec4(0x25505A00u,0x2992EEFAu,0x25704040u,0x2DB3FE9Au));\n\tA(uvec4(0x2590A524u,0x2DB3FFEEu,0x216F0606u,0x2DB26F5Bu));\n\tA(uvec4(0x1D2CE5F4u,0x31D35595u,0x1D2D1A2Fu,0x2D910616u));\n\tA(uvec4(0x190A1B57u,0x1D2B4612u,0x1CEAE1D0u,0x2108F5E1u));\n\tA(uvec4(0x21070B0Au,0x25071F1Fu,0x1CC55B6Bu,0x20E71B1Bu));\n\tA(uvec4(0x1CC51E0Au,0x1CC60A5Eu,0x18C50303u,0x1CC50303u));\n\tA(uvec4(0xFFFFu,0x18A5FFFFu,0x14A41605u,0x18A5BF6Fu));\n\tA(uvec4(0x1CE61005u,0x21073810u,0x1D27FCF8u,0xAF7AFDFDu));\n\tA(uvec4(0xAB59AF16u,0xB39CBFFFu,0x318B0707u,0xAB580707u));\n\tA(uvec4(0x358BF9F9u,0xB37AF8F9u,0xB79C8014u,0xBBBD1030u));\n\tA(uvec4(0xB79CD751u,0xBBBD54D0u,0xB39CFAA9u,0xBBBD01AAu));\n\tA(uvec4(0xA33ABFFFu,0xBBBC015Bu,0x4437FBFu,0xAB5B2F7Fu));\n\tA(uvec4(0x1084D0C0u,0xA33CFCF0u,0xA33C0003u,0xAB7E0000u));\n\tA(uvec4(0x9F3C1A3Bu,0xA35DD924u,0x256F8F2Fu,0x9B1CF2D7u));\n\tA(uvec4(0x8A98D7FEu,0x96FB2A40u,0x92D96BEAu,0x9F3CBC2Eu));\n\tA(uvec4(0x92D9FEBFu,0x9F3C0BF4u,0x96FAFABFu,0x9F1CBC9Bu));\n\tA(uvec4(0x96FB1609u,0x9F1C0003u,0x8EBA2F7Fu,0x96FB6A57u));\n\tA(uvec4(0x8A99192Bu,0x92DBADA0u,0x1D2F2F02u,0x8E9AFFFFu));\n\tA(uvec4(0x214FA4E9u,0x86795F92u,0x3E37F9E9u,0x92DBF8F9u));\n\tA(uvec4(0x96DBE5D4u,0xA33DF9F9u,0xA35DE5E5u,0xAF9EE4F4u));\n\tA(uvec4(0x9F1C6FAFu,0xAF9E1B2Fu,0x3E381B1Bu,0x9AFC1B1Fu));\n\tA(uvec4(0x25712F6Fu,0x35F61B1Bu,0x1D0D0307u,0x214F070Bu));\n\tA(uvec4(0x10A9F3DBu,0x14CBFBE7u,0x14CAA9FDu,0x1D0C2555u));\n\tA(uvec4(0xC88D293u,0x18CAD1D1u,0x1D0CA4A4u,0x2992E4E8u));\n\tA(uvec4(0x29925450u,0x31F5F9A9u,0x2DB3A450u,0x35F5BFBFu));\n\tA(uvec4(0x2DB35A00u,0x35F6FFAAu,0x29921701u,0x31D45B6Bu));\n\tA(uvec4(0x256F1B3Au,0x29910F4Fu,0x1D0C1B1Fu,0x254F1A17u));\n\tA(uvec4(0x18EA56AEu,0x1D0BCB5Bu,0x1CEAE4E0u,0x2528F4E4u));\n\tA(uvec4(0x21072F1Bu,0x25086F6Fu,0x1CE60706u,0x20E71B1Bu));\n\tA(uvec4(0x1CC55F0Fu,0x1CC6FFFFu,0x1CC5FE00u,0x1CC6FFFFu));\n\tA(uvec4(0x18C55500u,0x1CC6FF5Fu,0x18A55A06u,0x1CC5AF6Au));\n\tA(uvec4(0x1CE6E4A4u,0x2548E8E9u,0x8E93FCFCu,0xAF7AE8F8u));\n\tA(uvec4(0xA738EFFFu,0xB39B05AFu,0x1CE70307u,0x9F160102u));\n\tA(uvec4(0x20E7E0F4u,0xA71780D0u,0xA318FEFFu,0xB79C14ADu));\n\tA(uvec4(0x9AD9BFFFu,0xB79C005Au,0x82361BBFu,0xAF7B0106u));\n\tA(uvec4(0x8656F4FAu,0xA33BF8F8u,0x10A52F2Fu,0xAB7C6B6Bu));\n\tA(uvec4(0x18C9FCFCu,0xA35CFCFCu,0xA33C82C0u,0xAB7E4102u));\n\tA(uvec4(0x296F7FFFu,0xA33C2F3Fu,0x2D90FCF8u,0x9F1BFFFDu));\n\tA(uvec4(0x92B8FBABu,0xA33CD0B9u,0x96F90B90u,0xA35C1569u));\n\tA(uvec4(0x96FAFC7Fu,0xA35C05A5u,0x86771BE5u,0x9B3CFFBFu));\n\tA(uvec4(0x3E56BDAFu,0x96FB0BE5u,0x8698F5BEu,0x92DB0456u));\n\tA(uvec4(0x8A9956AFu,0x8EBAB8B7u,0x8678FE86u,0x8EBABAFFu));\n\tA(uvec4(0x31D4FF3Fu,0x92DAFFFFu,0x39F5D0E4u,0x96DB0381u));\n\tA(uvec4(0x8258FFFFu,0x9F3CE4FAu,0xA75EE0D0u,0xAF9FE0E0u));\n\tA(uvec4(0x9B1C1B5Bu,0xAFBE061Bu,0x3E370B1Bu,0x96FC060Au));\n\tA(uvec4(0x214F2B2Bu,0x31D5061Bu,0x14EC5B5Fu,0x1D2E525Bu));\n\tA(uvec4(0x14EB5641u,0x1D2DEA96u,0x18EB5400u,0x254FFEF9u));\n\tA(uvec4(0x10A95500u,0x2970FFFEu,0x18EB9494u,0x2DB3FFFAu));\n\tA(uvec4(0x2DB2F8E4u,0x35F5FFFEu,0x35F57F19u,0x3A16FFFFu));\n\tA(uvec4(0x31B466AAu,0x3A160717u,0x29921B5Bu,0x31D41A2Fu));\n\tA(uvec4(0x254F1F0Fu,0x29911B1Fu,0x1D0C1B1Fu,0x212D0F1Fu));\n\tA(uvec4(0x18EA978Bu,0x1D0B5AA6u,0x1CE9F4E0u,0x2528F4F4u));\n\tA(uvec4(0x25070505u,0x29281F1Au,0x1CE6BF1Fu,0x2107FFFFu));\n\tA(uvec4(0x1CE66A05u,0x20E7FFBFu,0x1CE65500u,0x1CE7AB55u));\n\tA(uvec4(0x1CE61504u,0x1CE7BF5Au,0x1CE60000u,0x1CE60F00u));\n\tA(uvec4(0x18C5E9FEu,0x2107A4A9u,0x2127F9FDu,0x9EF650A4u));\n\tA(uvec4(0x25286FFFu,0x9EF6011Au,0x10840657u,0x25280102u));\n\tA(uvec4(0x14A440C0u,0x2D6A0000u,0x18C695FFu,0x8A53D0D0u));\n\tA(uvec4(0x8E75F8A4u,0x9ADCBEFDu,0x3A170B1Bu,0x92BA9606u));\n\tA(uvec4(0x8A98FCF8u,0xA33AF9F9u,0xCA68B47u,0x9F1ACFCFu));\n\tA(uvec4(0x192DF5FDu,0xA33CB6F1u,0x8696FFFFu,0xA35DFCFFu));\n\tA(uvec4(0x31D18F0Fu,0xA35CC3C7u,0x96FA669Bu,0xA33C045Bu));\n\tA(uvec4(0x31D21B9Bu,0x9AFA161Au,0x296FF9FFu,0x96FA4054u));\n\tA(uvec4(0x3E14FFFFu,0x92D900A5u,0x8677BFFFu,0x92FA10F9u));\n\tA(uvec4(0x8698993Fu,0x96FAA06Au,0x3E5607A4u,0x8EB85B66u));\n\tA(uvec4(0x3E56F8FAu,0x8EBA4490u,0x8EBAC040u,0x96FBD0C0u));\n\tA(uvec4(0x96FB9930u,0x9F1C28AFu,0x35F54B03u,0x9B1C0E4Au));\n\tA(uvec4(0x3A16E4E4u,0x9AFCD5E5u,0xA35CF4F4u,0xAF9F78B8u));\n\tA(uvec4(0x92DC1B1Bu,0xAB7E0606u,0x2DB41B5Bu,0x8A9A1B1Bu));\n\tA(uvec4(0x14EC1B5Bu,0x29930606u,0x14EBD091u,0x212EE4D4u));\n\tA(uvec4(0x1D0DEAD4u,0x254F6ABFu,0x256FE9D5u,0x299100E4u));\n\tA(uvec4(0x2991D1E1u,0x2DB26C40u,0x29B3E5EAu,0x35F49EE4u));\n\tA(uvec4(0x35F3EAF5u,0x3A1600A5u,0x31D3AAFFu,0x3A160056u));\n\tA(uvec4(0x2D926FAFu,0x35F5005Au,0x257057ABu,0x2DB30006u));\n\tA(uvec4(0x212E6B6Fu,0x2991051Au,0x190A5B5Fu,0x212D1656u));\n\tA(uvec4(0x1CEA5656u,0x18EB1B56u,0x1D0AF9F4u,0x2949FDF9u));\n\tA(uvec4(0x25286F1Au,0x2D49FFBFu,0x25075601u,0x2949BF6Bu));\n\tA(uvec4(0x21075615u,0x2528BFABu,0x1CE75A05u,0x2507AF5Au));\n\tA(uvec4(0x20E7A500u,0x2107FFFEu,0x1CE7BF15u,0x2107FFFFu));\n\tA(uvec4(0x14A4A5E9u,0x1CC64540u,0x1083AAFEu,0x1CE70555u));\n\tA(uvec4(0xC83566Bu,0x1D070015u,0xC62479Bu,0x10840107u));\n\tA(uvec4(0xC63E4F5u,0x14A5E4E4u,0x14C6E0E0u,0x8E98E4E4u));\n\tA(uvec4(0x86791F2Fu,0x96DC0B0Bu,0x8238D480u,0x8EB9FAE5u));\n\tA(uvec4(0x92F950E4u,0xA33A9490u,0x10A78FCFu,0x9AF9978Fu));\n\tA(uvec4(0x298D0207u,0x8AB56F15u,0x1D4C00F8u,0xA33C0501u));\n\tA(uvec4(0xCA7F5E7u,0x96FAA4F4u,0x39F25AABu,0x96FA0001u));\n\tA(uvec4(0x31F39197u,0x8256E0E0u,0x212D0B42u,0x8256FF7Fu));\n\tA(uvec4(0x256D81E9u,0x35F21704u,0x296EFDFEu,0x8A7780F8u));\n\tA(uvec4(0x3E1429E9u,0x86750906u,0x35F3BEBFu,0x867700D5u));\n\tA(uvec4(0x3E356F54u,0x8277085Bu,0x3E35E5FEu,0x8EB94090u));\n\tA(uvec4(0x8E993A7Eu,0x9AFB1019u,0x31D22A1Fu,0x8EBA3F3Fu));\n\tA(uvec4(0x3A37C1D5u,0x92BC88C9u,0xA75C7838u,0xAF9E1869u));\n\tA(uvec4(0x86796F6Fu,0x9AFC071Bu,0x25712F6Fu,0x82581B1Bu));\n\tA(uvec4(0x10A95B6Bu,0x1D2F0617u,0xCA9E6F9u,0x1D0D90E4u));\n\tA(uvec4(0xCA8FFFFu,0x1D2D931Fu,0x14C901BFu,0x254EE5E4u));\n\tA(uvec4(0x18EB4000u,0x2DB1FFFAu,0x14EA0195u,0x31D2FFAFu));\n\tA(uvec4(0x10EA40FFu,0x2DB1FF1Bu,0xCA9FEFFu,0x29901B90u));\n\tA(uvec4(0x10A9FFFFu,0x214EA0EFu,0x18EBBFFFu,0x214F115Au));\n\tA(uvec4(0x18EBAABFu,0x1D2E0055u,0x18EB6AABu,0x1D0B105Au));\n\tA(uvec4(0x18EAD0D5u,0x1CEA54D0u,0x1CE9FEFEu,0x294AF8F9u));\n\tA(uvec4(0x2D6A0000u,0x2D4B0300u,0x29296B1Au,0x2D4A6B6Bu));\n\tA(uvec4(0x25280606u,0x29291B07u,0x21075F1Bu,0x2528BF6Fu));\n\tA(uvec4(0xFFFFu,0x2508FFFFu,0x25076A15u,0x2528FFFFu));\n\tA(uvec4(0x14A41605u,0x2107FF6Au,0xC630505u,0x1CE62F0Au));\n\tA(uvec4(0x441F9FFu,0xC63E0E8u,0xC626900u,0x1063FEEAu));\n\tA(uvec4(0xC6390E4u,0x10845B96u,0x14C7F4F4u,0x8EB8F8F8u));\n\tA(uvec4(0x869A5606u,0xA31CE69Au,0x92D96940u,0xA33C6F6Eu));\n\tA(uvec4(0x2D8C7FFFu,0x9F1A0B1Fu,0x212985C3u,0x8A73150Au));\n\tA(uvec4(0x31F0022Fu,0x92D75806u,0x258E0015u,0x3E561F15u));\n\tA(uvec4(0x14E9E1A0u,0x9F5C5595u,0x82340B09u,0x92D8E450u));\n\tA(uvec4(0x3614E590u,0x92D8FFFEu,0x86775A50u,0x92D91B0Au));\n\tA(uvec4(0x2D8FBF07u,0x8677FFBFu,0x18E90605u,0x86566B0Bu));\n\tA(uvec4(0x10A790FAu,0x31D20000u,0x14C9AFEFu,0x2DB1A0F8u));\n\tA(uvec4(0x2970E8FAu,0x3A150040u,0x2990FFFFu,0x3E35E4E9u));\n\tA(uvec4(0x8677E4A4u,0x92FA9494u,0x14E95BBFu,0x92DA4743u));\n\tA(uvec4(0x1950E8EDu,0x869AE8D8u,0x9AFB3E7Eu,0xAB7D0B2Fu));\n\tA(uvec4(0x82581A1Bu,0x92DB070Au,0x14EC6F6Fu,0x35F51B1Bu));\n\tA(uvec4(0xCA8071Bu,0x14EB4042u,0xCA840A0u,0x1D0BB4D1u));\n\tA(uvec4(0xCA95B64u,0x1D2C5B9Bu,0x18EBE4E4u,0x256FE4E4u));\n\tA(uvec4(0x257094F9u,0x31B3A554u,0x2991BAFFu,0x31B31559u));\n\tA(uvec4(0x256F7F6Fu,0x2DB2066Fu,0x1D2D5B7Fu,0x256F071Bu));\n\tA(uvec4(0xCA8FF0Bu,0x1D2CEFFFu,0x10A84055u,0x214DBA0Bu));\n\tA(uvec4(0xCA8AAFAu,0x18EB5455u,0x14EAFFFFu,0x18EB4D1Du));\n\tA(uvec4(0x14C9BFBFu,0x18EA4B5Fu,0x14C9E4F9u,0x252A9094u));\n\tA(uvec4(0x212AFAFFu,0x2D4AE4F9u,0x29492F2Fu,0x2D4A1F2Fu));\n\tA(uvec4(0x25282B1Au,0x2949461Au,0x25280D0Du,0x2528070Fu));\n\tA(uvec4(0x2528E494u,0x2929F4A4u,0x25285B16u,0x2929FFBFu));\n\tA(uvec4(0x2107A954u,0x316BFEFEu,0x14A52B1Au,0x29496F6Fu));\n\tA(uvec4(0x421F7F6u,0xC63F3F7u,0xC63F7D7u,0x1063DCFCu));\n\tA(uvec4(0xC630000u,0x214CC040u,0x212BF8F4u,0x92DAFEF9u));\n\tA(uvec4(0x92DAE4E4u,0x9F3CAAF9u,0x318CFFFFu,0x9F1A1F7Fu));\n\tA(uvec4(0x294A020Bu,0x9F3A0000u,0x25284000u,0x296FE950u));\n\tA(uvec4(0x1D2CB4F4u,0x3E560558u,0x214E0106u,0x92D9F990u));\n\tA(uvec4(0x214DFD64u,0x96FAFFFFu,0x3A14F9FDu,0x9AFAABE2u));\n\tA(uvec4(0x92B993A5u,0x9AFB5D8Bu,0x86776F1Bu,0x96FAFEAFu));\n\tA(uvec4(0x82556BF6u,0x8A980B5Bu,0x31D21A1Bu,0x86770615u));\n\tA(uvec4(0x14C8AF07u,0x2990ABAFu,0x10A8AAD0u,0x212CFFFFu));\n\tA(uvec4(0x14C9A4FDu,0x296FEAFEu,0x298FD0E4u,0x3E35E0E5u));\n\tA(uvec4(0x3A14E5EFu,0x8A9850A0u,0x18EA5F07u,0x8A987F7Fu));\n\tA(uvec4(0x1D2FE4D4u,0x9B3DE4E4u,0x9AFB172Bu,0xAB7C0257u));\n\tA(uvec4(0x35F51B6Bu,0x96DA161Bu,0xCA91B2Fu,0x2DB3070Bu));\n\tA(uvec4(0xCA74410u,0x1D0A60C0u,0xC86FBDDu,0x1CEBA4F5u));\n\tA(uvec4(0x14C95B6Bu,0x1D2C1459u,0x18EAE4E4u,0x256FA494u));\n\tA(uvec4(0x214F95FEu,0x2DB1A850u,0x25701AFFu,0x29916905u));\n\tA(uvec4(0x214F0A1Bu,0x25900A05u,0x1D2D560Bu,0x214E1B56u));\n\tA(uvec4(0x190B5626u,0x1D2D6FAFu,0x14EA45C6u,0x212D5565u));\n\tA(uvec4(0x14EA0D02u,0x2DB0D434u,0x14C96A52u,0x1D0BAEACu));\n\tA(uvec4(0x14C9030Bu,0x18EA0303u,0x14A9D0E5u,0x18E954A0u));\n\tA(uvec4(0x18E9F4F9u,0x294AA0E4u,0x25285AABu,0x2D4A165Au));\n\tA(uvec4(0x25285797u,0x29280041u,0x21076FBFu,0x25285F0Fu));\n\tA(uvec4(0x2528A4A4u,0x2929F4E4u,0x2929BE54u,0x2949FFFFu));\n\tA(uvec4(0x2D6ABCBCu,0x358CF8FCu,0x20E71F1Bu,0x2D6B2F1Fu));\n\tA(uvec4(0x8418393u,0x14844343u,0xC63EAEEu,0x1064105Au));\n\tA(uvec4(0xC85D080u,0x92D9F8F4u,0x92B8FEF8u,0x9B1C2FBFu));\n\tA(uvec4(0x3DEFFFFFu,0x9AFB16ABu,0x2949070Fu,0x92B60102u));\n\tA(uvec4(0x18E86AE7u,0x294A8565u,0x212B68E4u,0x31D1F958u));\n\tA(uvec4(0x214EE440u,0x9F3CFEF9u,0x8E98AAA4u,0xA33CFFAFu));\n\tA(uvec4(0x9F1C6404u,0xAB7CBE69u,0x92DAAA16u,0xA35CAFABu));\n\tA(uvec4(0x3E350FFAu,0x96FBFF3Fu,0x2D90FFFFu,0x96FA1B99u));\n\tA(uvec4(0x31B1BFBFu,0x8A77D0FFu,0x31D2060Au,0x86565B05u));\n\tA(uvec4(0x1D0C5B1Bu,0x2DB1AF5Bu,0x1D0C2854u,0x2970FBB6u));\n\tA(uvec4(0x1D0CF9FFu,0x254EBAA4u,0x212DA9F9u,0x2DB15094u));\n\tA(uvec4(0x2DB0FDF9u,0x3A1490F8u,0x212E7FBFu,0x8256FE3Bu));\n\tA(uvec4(0x2591E4E4u,0x9B3C0094u,0x35F46FBFu,0x96FA0056u));\n\tA(uvec4(0x29906F6Fu,0x82570A1Bu,0xCA8070Bu,0x214F4182u));\n\tA(uvec4(0x4445E29u,0x14E9AF9Bu,0x10A796D8u,0x14C98054u));\n\tA(uvec4(0xCA7E4A5u,0x1D0BF9E5u,0x1D0BE490u,0x2DB0E9F9u));\n\tA(uvec4(0x298FA968u,0x31F2BEFEu,0x256F1A6Au,0x2DD1FF1Bu));\n\tA(uvec4(0x256F9055u,0x29B02F00u,0x1D2D1F1Fu,0x256F415Bu));\n\tA(uvec4(0x1D0C1A45u,0x214E060Fu,0x190B0411u,0x212CE4D0u));\n\tA(uvec4(0x190B39D0u,0x298E9596u,0x18EA0F03u,0x3A120D0Du));\n\tA(uvec4(0x14A90202u,0x18EAA743u,0x14C95528u,0x14CADF5Au));\n\tA(uvec4(0x14C9F0F4u,0x2109A5E0u,0x2107ABAFu,0x25295056u));\n\tA(uvec4(0x2507F6F2u,0x2528A1F5u,0xFFFFu,0x2508FFFFu));\n\tA(uvec4(0x2528FEFCu,0x2949FCFDu,0xFFFFu,0x2949FFFFu));\n\tA(uvec4(0x2949F8FDu,0x318B0054u,0x14A56F6Fu,0x2D4A1A1Bu));\n\tA(uvec4(0x4215747u,0x10639757u,0x4420000u,0x3612D080u));\n\tA(uvec4(0x254BFDF8u,0x9AFBBFFEu,0x31B11BBFu,0x96DA0106u));\n\tA(uvec4(0x318C191Bu,0x39F31A29u,0x21280102u,0x39EFFA11u));\n\tA(uvec4(0x1D085440u,0x8A95FFADu,0x31D1F9E0u,0x9B1AFFFEu));\n\tA(uvec4(0x96FAF9F4u,0xA75CFEFDu,0xA35CD743u,0xA75C0195u));\n\tA(uvec4(0xA75CFDBDu,0xAB7DFCFDu,0x9F1C1B06u,0xAB7D551Au));\n\tA(uvec4(0x96FB0A06u,0x9F3CAF1Bu,0x96DAD1B4u,0x9F3C1A45u));\n\tA(uvec4(0x256EBF06u,0x9F3CFFFFu,0x256F4154u,0x9AFCFFAFu));\n\tA(uvec4(0x190C5656u,0x8E99BF06u,0x190CFFAAu,0x39F406A4u));\n\tA(uvec4(0x14ECEFAAu,0x31B250FFu,0x256F6A00u,0x31B200FFu));\n\tA(uvec4(0x10A9FBFFu,0x2D901AFFu,0x14CAD79Eu,0x3E3658A1u));\n\tA(uvec4(0x10CB1606u,0x8A99E9A9u,0xCA90094u,0x8EBABF1Au));\n\tA(uvec4(0x86769BFu,0x29911700u,0x465DB9Bu,0x18E9E1D0u));\n\tA(uvec4(0x10A79717u,0x14C984C4u,0x14C8A540u,0x252CE0F9u));\n\tA(uvec4(0x1D0BD0D0u,0x296D8190u,0x296EF8F8u,0x35D1E0F8u));\n\tA(uvec4(0x31D1EA69u,0x3E340046u,0x216E6F06u,0x35F2FEBFu));\n\tA(uvec4(0x214DA5FDu,0x29B06B06u,0x214DBF06u,0x2DB00000u));\n\tA(uvec4(0x1D2B6F9Au,0x296E0105u,0x18EAA65Bu,0x214D9145u));\n\tA(uvec4(0x1D2BF9E4u,0x256EFEADu,0x14E91D1Du,0x31B02929u));\n\tA(uvec4(0x10A96FABu,0x18E90717u,0x10C9A996u,0x14EAF8F8u));\n\tA(uvec4(0x1CE81B15u,0x18EA1F1Fu,0xFFFFu,0x2107FFFFu));\n\tA(uvec4(0x21074057u,0x25070000u,0x2107D5D5u,0x25085455u));\n\tA(uvec4(0x2528F8FDu,0x2929A4E4u,0x2528BFFFu,0x2929166Fu));\n\tA(uvec4(0x1CE769BEu,0x25290015u,0x14A41B2Fu,0x2107061Bu));\n\tA(uvec4(0x8414B87u,0xC63EF6Bu,0x864F4E0u,0x8697FDF8u));\n\tA(uvec4(0x256F1B6Fu,0x8EBA0107u,0x31B1F854u,0x8A75FCFCu));\n\tA(uvec4(0x31AE0606u,0x92D7E491u,0x2D8CF490u,0x9F39FFFEu));\n\tA(uvec4(0x8EB6D590u,0x9F3BFFFAu,0x9B1AC1C0u,0xA35CE5D6u));\n\tA(uvec4(0xA35C455Fu,0xA75C9409u,0xA33C9155u,0xA75CE5D1u));\n\tA(uvec4(0xA75C00F4u,0xAB7D0100u,0xA33C6F17u,0xA75C9AA6u));\n\tA(uvec4(0x9F1C1905u,0xA35C6B1Au,0x9AFB1400u,0x9F3C5745u));\n\tA(uvec4(0x96DA91BAu,0x9F1C4102u,0x92DAA670u,0x9AFC6116u));\n\tA(uvec4(0x8A792F2Fu,0x92DB9BABu,0x39F4FF2Fu,0x8A9ABFBFu));\n\tA(uvec4(0x10AAAF06u,0x3E37FFFFu,0x14CA5500u,0x3E36FFBFu));\n\tA(uvec4(0x1D0C5400u,0x8238AF25u,0x18EBBDAAu,0x299007AEu));\n\tA(uvec4(0x190CE4F9u,0x8257D0E0u,0x2D926F7Fu,0x86781A1Bu));\n\tA(uvec4(0x1D0C071Bu,0x29B20516u,0x14C90000u,0x8675D050u));\n\tA(uvec4(0xC861519u,0x18E9EBEAu,0x10A7F4E4u,0x254D56F5u));\n\tA(uvec4(0x18E9FFDBu,0x254D14EBu,0x1D2BAAA6u,0x2D9000FAu));\n\tA(uvec4(0x256E56FAu,0x2D901407u,0x214D51FEu,0x31D11400u));\n\tA(uvec4(0x1D2C5FAFu,0x298F5078u,0x190A0F56u,0x254D1A6Eu));\n\tA(uvec4(0x190A808Bu,0x214CB4FAu,0x14EAD6E6u,0x254DE091u));\n\tA(uvec4(0x212C0A7Fu,0x298F6505u,0x14C82D2Eu,0x256E1A1Eu));\n\tA(uvec4(0x10A91F1Fu,0x14C97F6Fu,0x10A9F8FDu,0x14EAE9F8u));\n\tA(uvec4(0x18E91F0Fu,0x14EA0B1Fu,0x1CE85495u,0x2508FDA5u));\n\tA(uvec4(0xFFFFu,0x2107FFFFu,0x210794A5u,0x2507FA94u));\n\tA(uvec4(0x2508F0FCu,0x2528F0F0u,0x25081FFFu,0x2528FFFFu));\n\tA(uvec4(0xC63AAFFu,0x1CC60055u,0xC635B6Fu,0x14A50016u));\n\tA(uvec4(0xC639040u,0x1D08E4E4u,0x296CB8FCu,0x82561464u));\n\tA(uvec4(0x214D4102u,0x3E33D0D0u,0x3A12BC7Cu,0x92D7FEFEu));\n\tA(uvec4(0x3E32FDE8u,0x9B19FFFFu,0x9F3A99A8u,0xA35BF7E9u));\n\tA(uvec4(0xA33B0C08u,0xA75C0104u,0x9F3B86C1u,0xA35CE0D6u));\n\tA(uvec4(0xA35CA0E4u,0xA77CA5A0u,0xA35CF556u,0xA75C47F5u));\n\tA(uvec4(0xA75C1101u,0xA77D0D55u,0xA75C5D1Cu,0xA77D5C47u));\n\tA(uvec4(0xA33C170Au,0xA75CEF17u,0x9B1C2915u,0xA75C5B56u));\n\tA(uvec4(0x96FB1900u,0x9F1CEA6Au,0x92DB5500u,0x9F1C6F59u));\n\tA(uvec4(0x8A9A5702u,0x96DBBFAFu,0x82581B7Fu,0x8EBA5F1Fu));\n\tA(uvec4(0x3E37E990u,0x8EBAFFFEu,0x3E371601u,0x8A9A5B6Bu));\n\tA(uvec4(0x3A174A56u,0x86782B26u,0x14EC1B1Bu,0x35F5AB5Bu));\n\tA(uvec4(0x14EBBD00u,0x35F5FFFFu,0x14EA0169u,0x31F46F2Fu));\n\tA(uvec4(0xCA755AFu,0x1D2DA601u,0x10A700C0u,0x31B00100u));\n\tA(uvec4(0x14C75543u,0x296D0040u,0x14C82E06u,0x31AEA569u));\n\tA(uvec4(0x14C61E2Eu,0x2D8F0205u,0x10A5955Au,0x2549074Bu));\n\tA(uvec4(0x14C596E5u,0x212C64A9u,0x18E9AABFu,0x256E0555u));\n\tA(uvec4(0x14C94BEBu,0x1D2C1005u,0x14E96A1Bu,0x214C1555u));\n\tA(uvec4(0x14E9AAFCu,0x1D2BA4A5u,0x190AFEF4u,0x212C45FEu));\n\tA(uvec4(0x14E906AFu,0x1D2D561Bu,0x10A74E5Eu,0x212C4B4Eu));\n\tA(uvec4(0x14C97916u,0x18E9FFBEu,0xCA7EAFAu,0x14CA8296u));\n\tA(uvec4(0x14C9D1D6u,0x18E9F8D0u,0x1CE9FCFCu,0x2528F9FCu));\n\tA(uvec4(0x21087F17u,0x2528FFFFu,0x2507FFC0u,0x2508FFFFu));\n\tA(uvec4(0x2107FFFFu,0x25081F7Fu,0x2107FFFFu,0x250840E5u));\n\tA(uvec4(0x84355FBu,0xC634669u,0x842BDFFu,0xC431669u));\n\tA(uvec4(0xC63E0E4u,0x1D0890D0u,0x2129A565u,0x3E11E4E4u));\n\tA(uvec4(0x296DF9E0u,0x8A94FFFEu,0x8EB5E4E4u,0x9B19F4F4u));\n\tA(uvec4(0x9F19C090u,0xA75BC0C1u,0xA33AA691u,0xAB7CF4A5u));\n\tA(uvec4(0xA33A5151u,0xA75CB965u,0x9F3BE0E0u,0xA75CB9F4u));\n\tA(uvec4(0xA35C4FD7u,0xA75CF7FFu,0xA35C9556u,0xAB7D4346u));\n\tA(uvec4(0xA75C410Du,0xA77D4409u,0xA75C9559u,0xAB7DB054u));\n\tA(uvec4(0xA75C0601u,0xAB7E7E7Fu,0xA33C5905u,0xAB7D55E9u));\n\tA(uvec4(0x9F1C5E44u,0xA75DE6BBu,0x9F1C4100u,0xA75D2F02u));\n\tA(uvec4(0x96DB1A15u,0xA33C2E6Fu,0x8A995E09u,0x96FBFFEFu));\n\tA(uvec4(0x8EBA5F2Fu,0x96FB1AAFu,0x82575B47u,0x8A997A56u));\n\tA(uvec4(0x3E371A06u,0x8EBA1E2Eu,0x2992E6D1u,0x3A16BFBFu));\n\tA(uvec4(0x2DB467BFu,0x35F5D2CAu,0x214F1B1Bu,0x35F56F5Bu));\n\tA(uvec4(0x1D0DF490u,0x2DB2FEF9u,0x1D0B5B06u,0x31B2FFBFu));\n\tA(uvec4(0xC865B15u,0x254EBFAFu,0xC8641F4u,0x1D0A6E2Au));\n\tA(uvec4(0x10A62E0Bu,0x212B01E4u,0xC85000Bu,0x254BF96Bu));\n\tA(uvec4(0x14A60054u,0x214CAF00u,0x10A719BEu,0x1D0AAA54u));\n\tA(uvec4(0x10C8A85Eu,0x18E96FFEu,0xCA786A6u,0x18EAFEE1u));\n\tA(uvec4(0x14E9FE50u,0x1D0BBFFFu,0x190A1600u,0x212C2D7Eu));\n\tA(uvec4(0x14E94A5Au,0x212BD559u,0xC85A79Bu,0x1D0B43A7u));\n\tA(uvec4(0x14E92515u,0x1D0A3928u,0x86592E7u,0x10A88182u));\n\tA(uvec4(0x10A8F9F9u,0x1CE9F8F8u,0x25281A55u,0x2529FF5Fu));\n\tA(uvec4(0xFFFFu,0x2528FFFFu,0xFFFFu,0x2508FFFFu));\n\tA(uvec4(0x20E7055Au,0x25085F05u,0x20E7F5FFu,0x2107D150u));\n\tA(uvec4(0xC630000u,0xC635B01u,0x8421615u,0xC63BF5Au));\n\tA(uvec4(0x44290E4u,0xC840501u,0x10A5E4E4u,0x3E1190E0u));\n\tA(uvec4(0x3A10FFFFu,0x8A94F8FEu,0x8A94F9F9u,0x9AF8E4F9u));\n\tA(uvec4(0x9B19F0D0u,0xA75B24B0u,0xA33AB8B4u,0xAB7CFDBCu));\n\tA(uvec4(0xA33B1B1Au,0xAB7C060Bu,0x9F3BF8B8u,0xA75CFBFAu));\n\tA(uvec4(0xA35CD2DBu,0xA75CBFF3u,0xA35CB1E7u,0xA75C6D79u));\n\tA(uvec4(0xA75CE040u,0xAB7DF690u,0xA75CE9F9u,0xAB7DF1EAu));\n\tA(uvec4(0xAB5C7D25u,0xAB7D6BBFu,0xA75C6950u,0xAB7D0A1Bu));\n\tA(uvec4(0xA35C9B86u,0xA75C9AEAu,0xA33C0A1Eu,0xA75D0005u));\n\tA(uvec4(0x96FA7F2Fu,0xA33C6F6Fu,0x92DAE994u,0x9AFC1E5Au));\n\tA(uvec4(0x8A990B5Bu,0x96FB0A0Au,0x8679EA7Au,0x8A9A0F9Fu));\n\tA(uvec4(0x3E380B2Fu,0x8A99161Bu,0x35F51A1Au,0x3E581E1Eu));\n\tA(uvec4(0x31D48141u,0x3E37F090u,0x2DB31B16u,0x3E37BF6Fu));\n\tA(uvec4(0x29922560u,0x35F56F1Au,0x2DB22D28u,0x35F4001Cu));\n\tA(uvec4(0x1D2C6F0Bu,0x2DB1AFBFu,0x14E95A05u,0x214D7F5Fu));\n\tA(uvec4(0x14C75A10u,0x1D0BFF99u,0xCA7AA40u,0x1D0BFFFFu));\n\tA(uvec4(0x10C840F9u,0x256D1616u,0xCA7FFFFu,0x212C1540u));\n\tA(uvec4(0xCA7FFFFu,0x1D0B40FEu,0x14C8AAFFu,0x1D2B5456u));\n\tA(uvec4(0x18E995EBu,0x1D0B4000u,0x14E961B0u,0x1D0AE740u));\n\tA(uvec4(0xCA7B9E5u,0x296D411Eu,0x8640001u,0x14C85F01u));\n\tA(uvec4(0xC8664BDu,0x1D092161u,0x46596E2u,0xC879595u));\n\tA(uvec4(0x1087E4E4u,0x2109E0E4u,0x2129FDF8u,0x2529FEFDu));\n\tA(uvec4(0x25285500u,0x2929BEA9u,0x25280100u,0x25285705u));\n\tA(uvec4(0x25087F05u,0x2528FFFFu,0x20E71705u,0x25086F1Fu));\n\tA(uvec4(0xC635A15u,0x1484FFAFu,0xC635500u,0x1084BFABu));\n\tA(uvec4(0xC630000u,0x1063FF86u,0xC63E4F4u,0x214A5090u));\n\tA(uvec4(0x18E8E5FAu,0x82734094u,0x2DAEFEFEu,0x8EB6A4E9u));\n\tA(uvec4(0x8A96FEFEu,0x9F1AE4F8u,0x9F3AAAEAu,0xAB7C5196u));\n\tA(uvec4(0xA35B5441u,0xA77C5B5Eu,0xA35C5559u,0xA75C96D1u));\n\tA(uvec4(0xA75C6414u,0xAB7CC4D5u,0xA75C9004u,0xAB7D92F0u));\n\tA(uvec4(0xA75C5DFBu,0xAB7D2D78u,0xA75CFEE2u,0xAB7D28E8u));\n\tA(uvec4(0xA75C666Au,0xAF9D6875u,0xAB5C6516u,0xAB7D5D54u));\n\tA(uvec4(0xA33C7F7Fu,0xA75C2E07u,0x9F1C066Au,0xA33C2F2Eu));\n\tA(uvec4(0x9AFB1E1Fu,0x9F3C2E2Au,0x92DA0419u,0x9B1C0B05u));\n\tA(uvec4(0x8A9A9B4Bu,0x92DA9B8Bu,0x8679070Bu,0x8EBA9643u));\n\tA(uvec4(0x361647AFu,0x82581707u,0x35F51A1Au,0x8258E4A5u));\n\tA(uvec4(0x35F5F9F4u,0x8258FEFEu,0x3A161A1Au,0x8258AF5Fu));\n\tA(uvec4(0x2DB33F2Fu,0x3A165F2Fu,0x29922E1Au,0x31D47F6Fu));\n\tA(uvec4(0x25700A1Au,0x2DB35B0Bu,0x214E4100u,0x2DB1D686u));\n\tA(uvec4(0x214D5F06u,0x2990FFBFu,0x1D2B0605u,0x256FAB5Au));\n\tA(uvec4(0x14E96B1Bu,0x1D2B2BBFu,0x14E95550u,0x190AF8F5u));\n\tA(uvec4(0x10A7AA06u,0x190AFFFFu,0xC86AF00u,0x14E9FFFFu));\n\tA(uvec4(0xC86EA15u,0x14C8BFFFu,0xC87FA00u,0x14C9FEFEu));\n\tA(uvec4(0x10A87FFCu,0x14C9FFFFu,0xC650B1Fu,0x14C80F0Bu));\n\tA(uvec4(0x8647CB8u,0x14A7AD6Du,0x8669540u,0xC87EF9Au));\n\tA(uvec4(0x10A8E0E0u,0x2109E4E4u,0x2529E4B4u,0x294890E4u));\n\tA(uvec4(0xFFFFu,0x2929FFFFu,0x25281F07u,0x2929571Fu));\n\tA(uvec4(0x25285A0Au,0x29291F55u,0x21077F2Fu,0x25287FBFu));\n\tA(uvec4(0x1084D5D1u,0x14A4FDFDu,0x14A40500u,0x18A57F18u));\n\tA(uvec4(0x1084AA41u,0x14A5FFFEu,0x10840100u,0x18A57F06u));\n\tA(uvec4(0xC8490E5u,0x18E90040u,0x14C7E5F9u,0x35F04090u));\n\tA(uvec4(0x256CF9FEu,0x8EB790E4u,0x8A75FEFFu,0x9F3AF4F9u));\n\tA(uvec4(0xA33B2E66u,0xA77C152Au,0xA35C60A5u,0xA77CE0A0u));\n\tA(uvec4(0xA75C9180u,0xAB7DE9D5u,0xA75CFAA1u,0xAB7D6EBFu));\n\tA(uvec4(0xA75C5E1Eu,0xAB7D59A9u,0xA75C9755u,0xAB7D1B5Bu));\n\tA(uvec4(0xA35CAAEEu,0xAB7D4055u,0xA33C666Fu,0xAB7D0641u));\n    //-------------------------------------------------------------------------\n\tC = col + texelFetch(iChannel0,SV_DispatchThreadID,0);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "highp ivec2 SV_DispatchThreadID = ivec2(0,0);\nhighp int Double_pixelID = 0;\nhighp vec4 col = vec4(0.,0.,0.,0.);\nint i = 1232;\n\n//pass !\nvoid A(vec4 data){\n    if(Double_pixelID == i++){\n        col = data;\n    }\n}\nvoid A(uvec4 data){\n    if(Double_pixelID == i++){\n        col = uintBitsToFloat(data);\n    }\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U)\n{\n    SV_DispatchThreadID = ivec2(floor(U-0.5));\n    if(SV_DispatchThreadID.x >= 48 || SV_DispatchThreadID.y >= 77){\n    \tC = vec4(1./3.);\n        return;\n    }\n    if(iFrame > 2){\n    \tC = texture(iChannel0,U/iResolution.xy);\n        //discard;\n    }\n    //1个像素存一个数据块\n    //16 x 32, 16为其中2个像素存2个块数据\n    //像素ID编号\n    Double_pixelID = (SV_DispatchThreadID.x>>1) + (SV_DispatchThreadID.y*24); \n    \n    //-------------------------------------------------------------------------\n\tA(uvec4(0x9F1BEBFFu,0xA35C6B3Bu,0x9F1C0A52u,0xA35D899Cu));\n\tA(uvec4(0x96FA6E5Au,0xA33C171Fu,0x92BA6A5Fu,0x9B1C2F3Eu));\n\tA(uvec4(0x8EBA0F0Bu,0x92DB3014u,0x82582F7Fu,0x8ABA1F2Fu));\n\tA(uvec4(0x3A165B47u,0x8258BE6Bu,0x3A16BBD2u,0x3E372B3Fu));\n\tA(uvec4(0x3A36EDBDu,0x8679E4F8u,0x3A36BBAFu,0x82581A2Bu));\n\tA(uvec4(0x31F51707u,0x3A37959Bu,0x2DB39B5Bu,0x31F52F6Bu));\n\tA(uvec4(0x2570570Au,0x2DB3AF5Bu,0x216FE9D4u,0x2991A666u));\n\tA(uvec4(0x2570A5A6u,0x29911F3Au,0x256F0603u,0x29901410u));\n\tA(uvec4(0x1D2BAF06u,0x256E5B7Fu,0x190A5B41u,0x1D2DFF66u));\n\tA(uvec4(0x190A551Fu,0x212CAAA9u,0x14C90601u,0x1D0B2F1Fu));\n\tA(uvec4(0x10A82915u,0x14C97125u,0x10A8F9F8u,0x14C995E5u));\n\tA(uvec4(0x14C85F7Fu,0x14C90F4Fu,0x8640B0Fu,0x14C84F4Bu));\n\tA(uvec4(0x10A6AE58u,0x14C9FFFFu,0x10A75500u,0x14C9FEEAu));\n\tA(uvec4(0x14C9E4E0u,0x2108E4E4u,0x2108F9FEu,0x2528E4E4u));\n\tA(uvec4(0x252854A4u,0x2529F454u,0x25283F3Fu,0x2528FFFFu));\n\tA(uvec4(0x25280001u,0x25295F05u,0x25075B1Bu,0x2528FFBFu));\n\tA(uvec4(0xC63E995u,0x1CC6E4F9u,0x18A59645u,0x1CE76D96u));\n\tA(uvec4(0x14A5075Au,0x1CC65E16u,0x14A5002Eu,0x18C60000u));\n\tA(uvec4(0xC63FFEFu,0x14A51B9Fu,0xC63AAFAu,0x14C74555u));\n\tA(uvec4(0x10A5E4F9u,0x2DAF80D0u,0x35F0F8F9u,0x9F3AF8F4u));\n\tA(uvec4(0x92D8E6BFu,0xA33B94E9u,0x9F3BE8A5u,0xAB7D90A4u));\n\tA(uvec4(0xA75C0D58u,0xAB7D6019u,0xAB5C5919u,0xAB7D4CA9u));\n\tA(uvec4(0xA75C0105u,0xAB7D4B01u,0xA35CABFFu,0xA75C0986u));\n\tA(uvec4(0xA33C1FDAu,0xA35C3B3Bu,0x9F3C999Fu,0xA75C1455u));\n\tA(uvec4(0x9B1B5786u,0xA35C5D1Bu,0x9B1BB596u,0xA33C0A16u));\n\tA(uvec4(0x9AFB2527u,0x9F3C6091u,0x8EBA1B0Bu,0x9AFB0716u));\n\tA(uvec4(0x8A9955B9u,0x92FB1E19u,0x3E575B5Au,0x8ABA471Bu));\n\tA(uvec4(0x82580404u,0x8ABAFDA8u,0x3A161F56u,0x82782B5Fu));\n\tA(uvec4(0x31D4E9FAu,0x3E581655u,0x31F5ABABu,0x3E37646Au));\n\tA(uvec4(0x36153A31u,0x3A370919u,0x2DD35A1Au,0x36162A2Fu));\n\tA(uvec4(0x29926669u,0x2DB36F1Fu,0x2571EAE6u,0x2991BCFFu));\n\tA(uvec4(0x214F5A5Fu,0x29912F2Eu,0x214F9496u,0x259068B8u));\n\tA(uvec4(0x1D2E0F07u,0x256F452Au,0x1D2DBF67u,0x214E1FBFu));\n\tA(uvec4(0x1D0C6B5Bu,0x214D165Fu,0x14E96F6Fu,0x1D0B1B5Bu));\n\tA(uvec4(0x10C81F6Bu,0x14C99F6Fu,0x10A71B5Au,0x14C96F1Fu));\n\tA(uvec4(0xCA6AABFu,0x14C8006Au,0x865CB8Fu,0x14C8D2C7u));\n\tA(uvec4(0x14C9070Au,0x18EA0507u,0x10A8FFFFu,0x14C92F7Fu));\n\tA(uvec4(0x10A7FAFFu,0x18C810A5u,0x14A5EAFFu,0x21070055u));\n\tA(uvec4(0x18C5FFFFu,0x2508A0F9u,0x2107FFFFu,0x252894FFu));\n\tA(uvec4(0x25285A5Fu,0x2529945Au,0xFFFFu,0x2528FFFFu));\n\tA(uvec4(0xC6301D0u,0x18C6D504u,0x14A48091u,0x1CE71F48u));\n\tA(uvec4(0x10836767u,0x18C5066Bu,0x1083B4FEu,0x14850010u));\n\tA(uvec4(0xC636BBFu,0x10845156u,0xC636AEFu,0xC631010u));\n\tA(uvec4(0x863D0D1u,0x14C74090u,0x31AEFCFCu,0x8AB6B8FCu));\n\tA(uvec4(0x3A34F9FEu,0x971AE4F9u,0x96FAE9FAu,0xA35CA0B4u));\n\tA(uvec4(0xA35CA8B8u,0xAB7DA0F8u,0xA75CE844u,0xAB7D0094u));\n\tA(uvec4(0xA75C020Bu,0xAB7D0012u,0xA33C0A06u,0xA77D3E2Eu));\n\tA(uvec4(0x9F3C5901u,0xA35C46ADu,0x9F1C126Au,0xA35C5B57u));\n\tA(uvec4(0x9B1A65F9u,0x9F3C491Au,0x96FA6A5Bu,0x9F3C466Au));\n\tA(uvec4(0x92DA69BEu,0x9AFB1B16u,0x92DA4303u,0x96FB0001u));\n\tA(uvec4(0x8A995E1Fu,0x92FB1A5Eu,0x8278E343u,0x8A9AFAF6u));\n\tA(uvec4(0x827955A5u,0x8EBA0B0Au,0x35F52F2Fu,0x82582A2Bu));\n\tA(uvec4(0x2DD49BAFu,0x35F54343u,0x2DD496FAu,0x35F59156u));\n\tA(uvec4(0x31F4BEFFu,0x3A165168u,0x2DD4AF2Fu,0x31F51FBFu));\n\tA(uvec4(0x29B21F5Au,0x31D45B1Bu,0x29910909u,0x2DB30B0Bu));\n\tA(uvec4(0x25700202u,0x29910B02u,0x216F0709u,0x25704042u));\n\tA(uvec4(0x1D2D5B5Bu,0x214F0B1Bu,0x190BBFFFu,0x1D2D2F6Fu));\n\tA(uvec4(0x14EB6BBFu,0x1D0C1556u,0x14E91B2Fu,0x18EB1606u));\n\tA(uvec4(0x14C95505u,0x14EAAE6Au,0x10A73F2Fu,0x14C96F3Fu));\n\tA(uvec4(0xC651B6Fu,0xC86EF1Bu,0x865E4E1u,0x14C9F9F4u));\n\tA(uvec4(0x14C95B0Bu,0x14E9A76Bu,0xC671F6Fu,0x14C90B1Bu));\n\tA(uvec4(0xC652E7Fu,0xC872E1Eu,0x421EBFFu,0xC630256u));\n\tA(uvec4(0x421A9FAu,0x18C50055u,0x842FAFFu,0x1CC650A5u));\n\tA(uvec4(0x14A5FAFFu,0x250890E4u,0x25281E1Au,0x25290419u));\n\tA(uvec4(0x10A4B8E0u,0x25284B5Eu,0x10845E2Eu,0x2108424Bu));\n\tA(uvec4(0x10830607u,0x18C54001u,0xC635B7Fu,0x1083075Bu));\n\tA(uvec4(0xC634A9Au,0xC636391u,0xC631736u,0xC630603u));\n\tA(uvec4(0x8434000u,0x14C7D040u,0x31CFAC6Cu,0x8EB65DADu));\n\tA(uvec4(0x29D1E5F9u,0x8AB890A5u,0x3E55EAFBu,0x9B1A9094u));\n\tA(uvec4(0x92D9E9FAu,0xA77C40D5u,0x9F3BFFBFu,0xAB7DF4FEu));\n\tA(uvec4(0xA33BBFFFu,0xA77CBB3Fu,0xA35C5025u,0xA77C5135u));\n\tA(uvec4(0x9F3C9F47u,0xA75C8059u,0x9F1C5B1Au,0xA35C666Bu));\n\tA(uvec4(0x9B1B3514u,0xA33CAAAAu,0x96FB2A1Au,0x9F3C055Bu));\n\tA(uvec4(0x92DA207Au,0x96FB0752u,0x8EBA6968u,0x96FB075Au));\n\tA(uvec4(0x8A991B0Bu,0x92DA5156u,0x8A9974B4u,0x8EBA0511u));\n\tA(uvec4(0x3E371A6Bu,0x8EBA051Au,0x31F51B2Fu,0x3A375B6Bu));\n\tA(uvec4(0x2DD40A06u,0x35F50B0Au,0x2DB39EEAu,0x31D4E7CBu));\n\tA(uvec4(0x31D4FEAAu,0x3615069Bu,0x29B3479Bu,0x31F40002u));\n\tA(uvec4(0x29B2661Fu,0x2DD45451u,0x29B21647u,0x2DB3062Bu));\n\tA(uvec4(0x25701216u,0x2DB26B5Bu,0x1D4E5AA5u,0x2570160Bu));\n\tA(uvec4(0x1D2D0B0Bu,0x214E0616u,0x18EB061Bu,0x1D2D5506u));\n\tA(uvec4(0x14EA5F5Fu,0x18EB7FB3u,0x14EAF555u,0x18EAD455u));\n\tA(uvec4(0x14EA3F3Fu,0x18EAFF3Fu,0x10A82F1Fu,0x14E97F7Fu));\n\tA(uvec4(0x10A79540u,0x14C8FFFAu,0x10A7E6F9u,0x14C84392u));\n\tA(uvec4(0x10A8FFFFu,0x14C9F8FDu,0xC661B1Bu,0x14A95B5Bu));\n\tA(uvec4(0xC646E6Eu,0x10872F6Eu,0x4210707u,0x4430203u));\n\tA(uvec4(0x421FED9u,0x4215594u,0x42150E4u,0x8425450u));\n\tA(uvec4(0x441E4F9u,0x18C59094u,0x18A5F9FEu,0x2508E4F9u));\n\tA(uvec4(0xC83FAEBu,0x18C640A5u,0x1084A293u,0x18C60151u));\n\tA(uvec4(0x10831D75u,0x14A52509u,0xC632D16u,0xC63561Fu));\n\tA(uvec4(0xC631C10u,0xC635058u,0x8421B6Bu,0xC631F1Bu));\n\tA(uvec4(0x863D0C0u,0x214BD0D0u,0x3A124C0Cu,0x86759498u));\n\tA(uvec4(0x29B082E0u,0x3E550B47u,0x361385D1u,0x86970605u));\n\tA(uvec4(0x3E54E6EAu,0x92D9B4A9u,0x8AB8A5EAu,0xA35CA495u));\n\tA(uvec4(0x9B1AA8FFu,0xA35C0941u,0x9F1B82EBu,0xA35C0506u));\n\tA(uvec4(0x9B1AF6BFu,0x9F3B0686u,0x9B1B575Au,0xA35C50A6u));\n\tA(uvec4(0x9B1B15BFu,0x9F3CD745u,0x92FA9257u,0x9B1B67A7u));\n\tA(uvec4(0x92DA9607u,0x96FBD2C6u,0x8EBAAF47u,0x92DA7F6Fu));\n\tA(uvec4(0x8A9ABB57u,0x8EBA9F1Au,0x82582F7Fu,0x8A9A1B2Fu));\n\tA(uvec4(0x3A37050Bu,0x82582A19u,0x31F50B5Bu,0x3A37070Bu));\n\tA(uvec4(0x31D40A0Bu,0x36168656u,0x2DB3FBD2u,0x31F4CBEBu));\n\tA(uvec4(0x2992166Bu,0x31F40616u,0x2991A8ADu,0x2DB30585u));\n\tA(uvec4(0x2991FBFEu,0x29B202B3u,0x2570A5FAu,0x2DB26560u));\n\tA(uvec4(0x25705A2Bu,0x29B1655Au,0x1D2E6F6Bu,0x256F571Bu));\n\tA(uvec4(0x190C5F1Bu,0x1D2D6B6Fu,0x18EB5706u,0x1D0CAB56u));\n\tA(uvec4(0x14EA5E1Au,0x1D0C6A6Au,0x14EAFFF4u,0x18EAFFFFu));\n\tA(uvec4(0x14E93F7Fu,0x18EA4F2Fu,0x14E89F5Eu,0x14E936BBu));\n\tA(uvec4(0x14C8F6F0u,0x18E8BDFFu,0xC875F5Bu,0x14C82F2Fu));\n\tA(uvec4(0xC87FDFEu,0x14C9F8F8u,0xC875B07u,0x14C95B5Bu));\n\tA(uvec4(0x4221F6Fu,0xC871F1Fu,0x1D743u,0x4215051u));\n\tA(uvec4(0x421E5A5u,0x421E095u,0x421E0E0u,0x421FFF8u));\n\tA(uvec4(0x421D5E5u,0xC63E0E5u,0x1083F4F9u,0x20E7E4E4u));\n\tA(uvec4(0xC6390E5u,0x10845000u,0xC6312A7u,0x10840010u));\n\tA(uvec4(0xC6359BFu,0x1084D480u,0xC631F65u,0x10846F5Bu));\n\tA(uvec4(0xC631014u,0xC638F19u,0x8426F6Fu,0xC433F6Fu));\n\tA(uvec4(0x842D090u,0x35F0D0D0u,0x31F0BAEAu,0x3E54D0B5u));\n\tA(uvec4(0x29B06F2Fu,0x3E54BDBFu,0x36123458u,0x8275F5A8u));\n\tA(uvec4(0x3A3394E0u,0x92FA9564u,0x869696F5u,0x971A5045u));\n\tA(uvec4(0x8AB7FFBFu,0x9F3BF8BEu,0x971A6EB9u,0x9F3B50A4u));\n\tA(uvec4(0x92D95596u,0x9F3B4721u,0x92D97A6Au,0x9F1C0465u));\n\tA(uvec4(0x96FA68FAu,0x9F3C0014u,0x8EB96FBFu,0x96FA066Eu));\n\tA(uvec4(0x92DA0EA6u,0x92FB0008u,0x8EDAFBFEu,0x92DA1FABu));\n\tA(uvec4(0x86789FEFu,0x8EDA5F8Fu,0x82785A17u,0x8ABA025Au));\n\tA(uvec4(0x3A376B6Bu,0x82780216u,0x35F52B06u,0x3A36797Bu));\n\tA(uvec4(0x2DB32A5Au,0x36165B1Au,0x2DB37EEFu,0x31D43F3Fu));\n\tA(uvec4(0x29919F47u,0x2DB3AF6Fu,0x29910306u,0x2DB20111u));\n\tA(uvec4(0x2570ABEBu,0x29911509u,0x216F6FFFu,0x2590146Au));\n\tA(uvec4(0x214E5ABFu,0x25709456u,0x1D4E1A56u,0x256FBE1Au));\n\tA(uvec4(0x1D2C0602u,0x214E0B16u,0x190B1A6Fu,0x1D2CA656u));\n\tA(uvec4(0x14EA3F3Fu,0x190B3F2Fu,0x18EA2D69u,0x190AD97Eu));\n\tA(uvec4(0x14C8BFEFu,0x14E98E3Fu,0x14E86C35u,0x18E9AF8Du));\n\tA(uvec4(0x14E81868u,0x18E90E1Du,0x8656F7Fu,0x14C71F2Fu));\n\tA(uvec4(0x865F9F9u,0x14A8F4F9u,0x10A76B5Bu,0x14C92F6Bu));\n\tA(uvec4(0x4211B1Fu,0xC870A1Bu,0x1FCFCu,0x401FFFCu));\n\tA(uvec4(0x421A5E1u,0x421D966u,0x421FFFFu,0x421FFFCu));\n\tA(uvec4(0x8429040u,0x18C5E4E4u,0x14A4F9E4u,0x2107FFFEu));\n\tA(uvec4(0x442FDFEu,0xC63FCF8u,0xC63D180u,0xC63E0D1u));\n\tA(uvec4(0xC63F6D0u,0x1084F5F6u,0xC63161Bu,0x14A55616u));\n\tA(uvec4(0xC63F6EBu,0xC638B66u,0x4422EABu,0xC63AB2Eu));\n\tA(uvec4(0x86380C0u,0x2DAED0D0u,0x31CFA4D5u,0x8275E4A4u));\n\tA(uvec4(0x3612D7F2u,0x3E546CACu,0x361286D2u,0x86961E0Fu));\n\tA(uvec4(0x3E349655u,0x8AB71C8Au,0x8275ACDAu,0x92F94520u));\n\tA(uvec4(0x8697A3F5u,0x9B1A0846u,0x8ED8FFFBu,0x9F3BA4B8u));\n\tA(uvec4(0x92D93F0Eu,0x9B1A07B3u,0x8A97BE6Fu,0x96FAE3F8u));\n\tA(uvec4(0x8A987DAFu,0x96FA0271u,0x86986A5Bu,0x92DA0065u));\n\tA(uvec4(0x8678FFFFu,0x8EDA91FEu,0x8698ADEFu,0x8EDA5152u));\n\tA(uvec4(0x82785A5Bu,0x8EDA1A16u,0x82780107u,0x86990904u));\n\tA(uvec4(0x3A164A46u,0x3E58BB6Fu,0x361666B4u,0x3A367F2Fu));\n\tA(uvec4(0x31F44607u,0x3A167A59u,0x29B23FBFu,0x31F46F2Fu));\n\tA(uvec4(0x2992BCAAu,0x2DB27BBDu,0x25902F7Fu,0x29911F17u));\n\tA(uvec4(0x214F2B3Fu,0x25706B6Fu,0x1D4E0B2Fu,0x216F0103u));\n\tA(uvec4(0x1D2DA9F9u,0x216E455Au,0x214E297Du,0x256F0114u));\n\tA(uvec4(0x1D2C5617u,0x214E0A56u,0x190B5797u,0x1D2C4197u));\n\tA(uvec4(0x190A4607u,0x1D0B1106u,0x14E95F3Fu,0x190A77CFu));\n\tA(uvec4(0x14C85397u,0x190A0516u,0x14E8F4E7u,0x18E9E5B8u));\n\tA(uvec4(0x14E81F1Bu,0x18E9FE9Eu,0x4632F2Fu,0x14C76F6Fu));\n\tA(uvec4(0x443E4F9u,0x10870090u,0x442BFFFu,0x14C8156Au));\n\tA(uvec4(0x210607u,0xC850001u,0x4210C00u,0x401C0CCu));\n\tA(uvec4(0x421A494u,0x421E5E4u,0x4219050u,0xC63E590u));\n\tA(uvec4(0xC63E8E4u,0x20E7F9F9u,0x2107FFFCu,0x2508FF5Fu));\n\tA(uvec4(0x842FDFCu,0xC63FEFDu,0xC63F5E4u,0x1084F6E5u));\n\tA(uvec4(0x1063DBE4u,0x1084D4D7u,0xC631616u,0x14A55A5Bu));\n\tA(uvec4(0xC6327A7u,0xC632E0Bu,0x4421B57u,0xC639B5Bu));\n\tA(uvec4(0x863D0C0u,0x256CD0D0u,0x31F0C1D0u,0x86956F9Au));\n\tA(uvec4(0x3A332B4Au,0x8696F97Eu,0x3612B83Cu,0x8AB7E5B5u));\n\tA(uvec4(0x36129038u,0x8ED80150u,0x3612B8FDu,0x8275F3B2u));\n\tA(uvec4(0x3E5496B6u,0x8ED91045u,0x8275E4F9u,0x92F90190u));\n\tA(uvec4(0x8AB74157u,0x9B1A0001u,0x3E546ADFu,0x92F99CBAu));\n\tA(uvec4(0x3E56175Fu,0x8ED8111Du,0x3A35EAFFu,0x82770095u));\n\tA(uvec4(0x3A36FEFAu,0x86985079u,0x3E56FEFFu,0x869888B4u));\n\tA(uvec4(0x8278AA7Eu,0x8AB91299u,0x3E376F6Fu,0x827829A6u));\n\tA(uvec4(0x3A364767u,0x3E58070Au,0x3A160207u,0x3E370619u));\n\tA(uvec4(0x36154425u,0x3A16EED8u,0x2DD31A16u,0x3A165756u));\n\tA(uvec4(0x25711777u,0x2DB35F1Bu,0x2570945Au,0x29916AAEu));\n\tA(uvec4(0x1D2E5F6Bu,0x25700B4Bu,0x1D2DFEFEu,0x214E0103u));\n\tA(uvec4(0x1D2DDFDBu,0x214E4192u,0x1D2D6AAFu,0x214E0129u));\n\tA(uvec4(0x190C6B6Fu,0x1D2D1217u,0x190B5641u,0x1D0C0715u));\n\tA(uvec4(0x14E9AA9Au,0x1D0B6639u,0x10C85E7Fu,0x190A070Bu));\n\tA(uvec4(0x10A7FFFFu,0x14C8FDCFu,0x10C7A4E5u,0x14E91555u));\n\tA(uvec4(0x14E8FEFFu,0x18E978FAu,0x10851B1Fu,0x14C72F1Fu));\n\tA(uvec4(0x210B1Bu,0xC630207u,0xBFu,0x42205A4u));\n\tA(uvec4(0xFFFFu,0x401FFFFu,0x4218141u,0x42199D5u));\n\tA(uvec4(0x421F5C0u,0x421FDF7u,0x421E4D4u,0x1083E4E5u));\n\tA(uvec4(0x14A5F8F4u,0x2107F9F9u,0x2507FFFFu,0x2508FCFFu));\n\tA(uvec4(0xC63D494u,0xC63D0D4u,0xC63F7F3u,0x1084F7F7u));\n\tA(uvec4(0x1063FCFCu,0x1084FFFFu,0x10830107u,0x14840000u));\n\tA(uvec4(0xC631BAAu,0xC632BFFu,0x8426515u,0x14A595F5u));\n\tA(uvec4(0x863C0D0u,0x256C80C0u,0x35F06D6Eu,0x86956C7Cu));\n\tA(uvec4(0x321119D9u,0x8696A429u,0x3A128F83u,0x8AB7782Cu));\n\tA(uvec4(0x31F11706u,0x86960A67u,0x258E69DEu,0x82759130u));\n\tA(uvec4(0x258EEFFFu,0x3A337CEEu,0x3A33284Eu,0x8276C035u));\n\tA(uvec4(0x31F264ADu,0x8AB84150u,0x31F1F5F6u,0x86975195u));\n\tA(uvec4(0x3A343D1Fu,0x869785B2u,0x2DD1F9FEu,0x3A1443E2u));\n\tA(uvec4(0x35F4A1EBu,0x3A360054u,0x35F4A4F9u,0x3E5765A4u));\n\tA(uvec4(0x3A36BEFFu,0x82784055u,0x3A365B2Fu,0x82580292u));\n\tA(uvec4(0x3A16BDBEu,0x3E3750A9u,0x3A160601u,0x3E37061Fu));\n\tA(uvec4(0x35F5FBFFu,0x3A160662u,0x31D41617u,0x35F50B16u));\n\tA(uvec4(0x29912F6Bu,0x2DB3BF7Fu,0x25702A92u,0x2991032Fu));\n\tA(uvec4(0x1D0D6F5Fu,0x214F475Au,0x1D2D2915u,0x214E0709u));\n\tA(uvec4(0x190B469Fu,0x1D2D5555u,0x190CA4EAu,0x1D2D55A9u));\n\tA(uvec4(0x190B565Bu,0x1D2D2566u,0x14EA1B5Fu,0x190BA4A6u));\n\tA(uvec4(0x14E9FDFEu,0x190A3FBFu,0x10C80107u,0x190A4000u));\n\tA(uvec4(0x10C78F8Cu,0x14C800A3u,0x10A7D6EAu,0x14C85495u));\n\tA(uvec4(0x10C76AAEu,0x14E95495u,0x4432F7Fu,0x14C71B1Fu));\n\tA(uvec4(0x5243u,0x4215656u,0x200000u,0x401C000u));\n\tA(uvec4(0x4214044u,0x21D040u,0x421D044u,0x421D4D4u));\n\tA(uvec4(0x421FCFFu,0x421FCFCu,0x842E4E0u,0x14A5E4E4u));\n\tA(uvec4(0x1CC5F8F8u,0x2107F9F9u,0x2107A9FEu,0x25085455u));\n\tA(uvec4(0xC63D090u,0x1084E0E0u,0xC63F3F3u,0x1084EBF3u));\n\tA(uvec4(0x1063FFFFu,0x1084FFFCu,0xC633C1Du,0x10841F3Du));\n\tA(uvec4(0xC633B8Fu,0xC630F1Bu,0x442565Bu,0xC636F2Au));\n\tA(uvec4(0x422A4C9u,0x14C7C0F0u,0x1D2ABEFEu,0x3E53F8FCu));\n\tA(uvec4(0x31F145D6u,0x3E74241Cu,0x2DD0FBFFu,0x3E54DCEFu));\n\tA(uvec4(0x2DD0185Du,0x3A539A91u,0x1D2B0BCBu,0x31D01B0Bu));\n\tA(uvec4(0x1D4CD2F1u,0x36121488u,0x258EA4E8u,0x3A5445D1u));\n\tA(uvec4(0x2DD05F57u,0x3A341A5Eu,0x258F5AABu,0x3A331519u));\n\tA(uvec4(0x2DB0B6BFu,0x3A330495u,0x2DB02D4Bu,0x3A341014u));\n\tA(uvec4(0x29B09AFFu,0x31F3A065u,0x2DD2F9FAu,0x3A3580D4u));\n\tA(uvec4(0x3A15E8E8u,0x3E570551u,0x36152F7Fu,0x3E570001u));\n\tA(uvec4(0x35F5AAEFu,0x3A1600AAu,0x31F5EFFFu,0x3A16D646u));\n\tA(uvec4(0x31F46F6Fu,0x3A361A5Au,0x2DB30B1Bu,0x35F5061Au));\n\tA(uvec4(0x25902F7Fu,0x2DB31B1Bu,0x1D4E2A97u,0x25700606u));\n\tA(uvec4(0x1D2D1147u,0x214F2215u,0x190BEBAFu,0x1D2D155Bu));\n\tA(uvec4(0xFFFFu,0x190BFFFFu,0x190B00EFu,0x190C0000u));\n\tA(uvec4(0x14EA6A7Bu,0x190C065Fu,0x14EA4404u,0x214DC141u));\n\tA(uvec4(0x10C81F1Au,0x1D2B470Bu,0x10C80A08u,0x14C90507u));\n\tA(uvec4(0xCA66EAEu,0x14C8574Bu,0xFFFFu,0x10A7FFFFu));\n\tA(uvec4(0x10A6FAFEu,0x14C72BBFu,0x4221B1Fu,0x10A61A1Bu));\n\tA(uvec4(0xFFFFu,0x401FFFFu,0x20F5F5u,0x401F5F4u));\n\tA(uvec4(0x421A090u,0x2195E0u,0x4215454u,0x421FD55u));\n\tA(uvec4(0x4219494u,0x842E594u,0xC63E4E0u,0x18C5E4E4u));\n\tA(uvec4(0x1CC659FDu,0x20E70000u,0x1CC5AAFFu,0x20E71555u));\n\tA(uvec4(0xC63F4F0u,0xC84F4F9u,0xC63D3D7u,0x1084FFF3u));\n\tA(uvec4(0x1083F4F4u,0x1084F5D4u,0xC63FFFFu,0x10843FFFu));\n\tA(uvec4(0xC63271Bu,0xC630E1Bu,0x4426F2Fu,0xC431F1Bu));\n\tA(uvec4(0x2185DAu,0x8631505u,0xC64F9F9u,0x3A32A4A4u));\n\tA(uvec4(0x2DD0FB76u,0x3A330CCBu,0x2DCFB034u,0x3E544292u));\n\tA(uvec4(0x258EB4BEu,0x36124296u,0x214C1B17u,0x31D0170Au));\n\tA(uvec4(0x14E9E4B9u,0x2DAF5194u,0x1D2B786Du,0x2DCF85A2u));\n\tA(uvec4(0x192BE9FFu,0x31F16598u,0x258E1F6Bu,0x2DD04967u));\n\tA(uvec4(0x214CAEFFu,0x298F4262u,0x256E4AEAu,0x2DD01004u));\n\tA(uvec4(0x1D2C9FEBu,0x2DB0686Du,0x214DAFFFu,0x2DB1B4BDu));\n\tA(uvec4(0x256FFEFFu,0x35F440A9u,0x2991FFFFu,0x31F4005Au));\n\tA(uvec4(0x2DD3A6EBu,0x35F500A5u,0x2DB3B9EFu,0x35F54295u));\n\tA(uvec4(0x2DB32FBFu,0x31F40002u,0x2991BFFFu,0x2DD3176Bu));\n\tA(uvec4(0x2570071Bu,0x2DB25656u,0x1D2E5B6Bu,0x256F176Bu));\n\tA(uvec4(0x190C5A6Fu,0x1D2E0116u,0x14EB57D7u,0x190C3F3Fu));\n\tA(uvec4(0x14EA5FFFu,0x18EB0D1Eu,0x14EB54F5u,0x18EB5554u));\n\tA(uvec4(0x14EA1F7Fu,0x18EB051Eu,0x10C9B4F1u,0x214C5E6Du));\n\tA(uvec4(0x10C80747u,0x190A9156u,0xCA76BABu,0x14E81A17u));\n\tA(uvec4(0xCA6E593u,0x10A7EDE8u,0xCA6FFFFu,0x10A7175Fu));\n\tA(uvec4(0xC63BFFFu,0x10A61F6Fu,0x4211B1Bu,0xC840106u));\n\tA(uvec4(0x555Fu,0x15554u,0xFFFFu,0x401FFFFu));\n\tA(uvec4(0x21DFDDu,0x401F45Fu,0x421A4A5u,0x421E4A4u));\n\tA(uvec4(0x4219494u,0xC63E4A0u,0xC63E4E4u,0x1CC5F9F5u));\n\tA(uvec4(0xFFFFu,0x1CC6FFFFu,0x18C5075Fu,0x1CC51707u));\n\tA(uvec4(0xC63ABFAu,0xC8491A3u,0xC63F9FAu,0x1084FAF8u));\n\tA(uvec4(0x1084B9B4u,0x14A5B49Fu,0xC635F2Fu,0x10847FAFu));\n\tA(uvec4(0xC63ABAEu,0xC631217u,0x4425B1Bu,0xC431B56u));\n\tA(uvec4(0x218B1Bu,0x4224B17u,0x422F4F8u,0x1D2AE4E4u));\n\tA(uvec4(0x14E9F9BEu,0x31D0D0E4u,0x258E6C9Fu,0x36124160u));\n\tA(uvec4(0x1D2B5F9Bu,0x2DD02E1Fu,0x1D2B5E6Bu,0x31F12529u));\n\tA(uvec4(0x14E986C2u,0x256D4516u,0x19097FDEu,0x214CFCFFu));\n\tA(uvec4(0x1D2BA9D7u,0x298E2098u,0x14E9B7BEu,0x256D06CAu));\n\tA(uvec4(0x1D2B384Fu,0x256E56A1u,0x214C5D8Bu,0x256E5069u));\n\tA(uvec4(0x1D2BE3B6u,0x256E098Au,0x1D2C92FAu,0x256E0506u));\n\tA(uvec4(0x1D2CFEFFu,0x256F90F4u,0x216FF4F9u,0x29B140E0u));\n\tA(uvec4(0x2590BFBFu,0x2DB294FDu,0x2991B9FFu,0x2DB30180u));\n\tA(uvec4(0x299159FEu,0x2DB30016u,0x29915117u,0x2DB31020u));\n\tA(uvec4(0x1D4E6F6Fu,0x29911516u,0x1D2D1A17u,0x214F1A0Au));\n\tA(uvec4(0x14EBFFFFu,0x190C1BFFu,0x14EBFFFFu,0x190B3DF7u));\n\tA(uvec4(0x14EA475Bu,0x18EB4242u,0x14EA1F7Fu,0x14EB0506u));\n\tA(uvec4(0x14EA4000u,0x1D2CB0D0u,0x14E9165Bu,0x1D2C0508u));\n\tA(uvec4(0x10C864A0u,0x190A0D19u,0xCA65F6Fu,0x10A71A97u));\n\tA(uvec4(0xCA697E6u,0xCA70557u,0xC856FFFu,0xCA61A2Fu));\n\tA(uvec4(0x4211F6Fu,0xC85060Au,0x5257u,0x421A551u));\n\tA(uvec4(0xFFFFu,0x401FFFFu,0xFFFFu,0x401FFFFu));\n\tA(uvec4(0x219594u,0x421D595u,0x421F4F4u,0x421F5FDu));\n\tA(uvec4(0x421E5E0u,0xC63E4E5u,0x1484E4E4u,0x20E7F9F8u));\n\tA(uvec4(0x1CC60201u,0x20E75F07u,0x18C51B1Au,0x1CC65B1Bu));\n\tA(uvec4(0x863D2FFu,0xC63F6C3u,0xC63A4A5u,0x1485E5A5u));\n\tA(uvec4(0x1084A4A4u,0x14A5AF99u,0xC636B6Au,0x14A51B6Fu));\n\tA(uvec4(0xC630B0Bu,0xC631516u,0x4421F5Fu,0xC431F1Fu));\n\tA(uvec4(0x4211B0Bu,0x4221717u,0x44380D0u,0x1D094440u));\n\tA(uvec4(0x14E841D1u,0x2DAE0000u,0x18E96F9Fu,0x2DAF946Au));\n\tA(uvec4(0x1D2BE777u,0x29AF20CCu,0x1D2B96E2u,0x256D0757u));\n\tA(uvec4(0x14E91310u,0x214C1F4Fu,0x14E890F5u,0x1D2A1688u));\n\tA(uvec4(0x14E8D6F2u,0x1D4C5559u,0x14E96B2Bu,0x1D2B7AABu));\n\tA(uvec4(0x14E9F4FCu,0x1D2B0081u,0x190AE5EBu,0x214C50A4u));\n\tA(uvec4(0x190AA77Fu,0x214D2D4Bu,0x190AD8FEu,0x1D2C1511u));\n\tA(uvec4(0x1D0B6AD6u,0x214D3459u,0x1D2CAFBFu,0x256E0091u));\n\tA(uvec4(0x1D2DE0FCu,0x25905095u,0x256EEAFFu,0x29915094u));\n\tA(uvec4(0x257057FFu,0x29915505u,0x214E97FBu,0x25702F6Fu));\n\tA(uvec4(0x1D2D6FBFu,0x214F051Eu,0x190C1A2Fu,0x1D2D0015u));\n\tA(uvec4(0x14EBE713u,0x190B16FFu,0x14EAEFAFu,0x14EB069Fu));\n\tA(uvec4(0x14CA1302u,0x18EB0203u,0x10C95FBFu,0x14EA820Bu));\n\tA(uvec4(0x14E95878u,0x1D2C1246u,0x10C8AB9Fu,0x190A1462u));\n\tA(uvec4(0xCA61757u,0x18E90005u,0xCA630B8u,0xCA70020u));\n\tA(uvec4(0xC657FFFu,0xC86065Fu,0x421AFBFu,0xC851A6Bu));\n\tA(uvec4(0x21071Bu,0x4224506u,0xFFFFu,0x401FFFFu));\n\tA(uvec4(0x4210555u,0x401FD05u,0x21FDF4u,0x401FFFFu));\n\tA(uvec4(0x421D5D0u,0x4218585u,0x421FFFCu,0x421F0FCu));\n\tA(uvec4(0x841D090u,0x14A5D0D0u,0x18C5F8F4u,0x2508F9F9u));\n\tA(uvec4(0x1CE76B1Bu,0x2508FFAFu,0x1CE60101u,0x20E72F07u));\n\tA(uvec4(0xC63E950u,0x14A5FFFFu,0x1084FAD0u,0x14A5FFFFu));\n\tA(uvec4(0x14A4BEAFu,0x14A51FAEu,0xC631F1Fu,0x10846F6Fu));\n\tA(uvec4(0xC630515u,0xC630711u,0x4421B1Fu,0xC431A1Bu));\n\tA(uvec4(0x4214606u,0x443D586u,0x4437468u,0xC85E4E1u));\n\tA(uvec4(0x864BCFDu,0x18E8E1F4u,0x10A7E4F8u,0x214B4090u));\n\tA(uvec4(0x10C8CAE3u,0x214C161Au,0x14C8769Du,0x256C5496u));\n\tA(uvec4(0x14E8A47Au,0x212B0701u,0x10C797BEu,0x18E95B1Bu));\n\tA(uvec4(0x10A7A5AEu,0x1D0A4451u,0x14E8E6FEu,0x190A8075u));\n\tA(uvec4(0x10C80325u,0x19091F0Bu,0x10C8FDFFu,0x190A90E0u));\n\tA(uvec4(0x190A5579u,0x212C0464u,0x18EA91DCu,0x1D2B5904u));\n\tA(uvec4(0x190A81F0u,0x1D2C0103u,0x190B81F0u,0x212C3C0Fu));\n\tA(uvec4(0x18EAFFF9u,0x214D90E5u,0x1D2DA5F9u,0x256F4591u));\n\tA(uvec4(0x1D2DA9FEu,0x25704555u,0x1D2D565Fu,0x256F4554u));\n\tA(uvec4(0x190C171Bu,0x1D2D6B5Fu,0x14EBBFAFu,0x190C066Fu));\n\tA(uvec4(0x14EA6F6Fu,0x190B0A1Au,0x10C95F1Fu,0x14EA698Au));\n\tA(uvec4(0x10C95FAFu,0x14EA0F0Fu,0x10C9E0C0u,0x18EB0464u));\n\tA(uvec4(0x10C81E6Fu,0x18EA0616u,0xC85BFFFu,0x10C81B6Fu));\n\tA(uvec4(0xC856AA7u,0xCA7A456u,0x864BFFFu,0xC865B3Fu));\n\tA(uvec4(0x863566Bu,0xC855A19u,0x421171Bu,0x843AF57u));\n\tA(uvec4(0x4211100u,0x421AF6Au,0x4215500u,0x421D3F7u));\n\tA(uvec4(0x4215000u,0x421ABA5u,0x4215540u,0x421FF55u));\n\tA(uvec4(0x4218440u,0x421D045u,0x421FFFFu,0x421FFFCu));\n\tA(uvec4(0x421E5E5u,0x14A5E4E5u,0x1CE6F8F8u,0x2528F8F8u));\n\tA(uvec4(0x25085605u,0x2528AF66u,0x1CE66B1Au,0x2508BFBFu));\n\tA(uvec4(0x14A5B9B8u,0x1CE70124u,0x14A50919u,0x1CE73C1Cu));\n\tA(uvec4(0x1084051Bu,0x14A5A746u,0xC632F6Fu,0x10842F2Fu));\n\tA(uvec4(0x8635AFFu,0xC436459u,0x4212B7Au,0x843161Bu));\n\tA(uvec4(0x4219040u,0xC85E090u,0x863A4A4u,0xC859791u));\n\tA(uvec4(0xC8540C0u,0x14C70010u,0xC85AFAFu,0x14C7F8BDu));\n\tA(uvec4(0x10A7F9BEu,0x1909A5E1u,0xCA6C1B5u,0x1D0A0602u));\n\tA(uvec4(0x10C72E1Fu,0x1D0AE47Au,0xCA6A86Au,0x19094B91u));\n\tA(uvec4(0xCA6BFCFu,0x10A7DFB3u,0x865FEFFu,0x14C889F5u));\n\tA(uvec4(0x10C769AFu,0x14E955E4u,0x10A800E0u,0x14E90A02u));\n\tA(uvec4(0xCA7FBFFu,0x14E945E9u,0x10C8E5FFu,0x190A545Au));\n\tA(uvec4(0x14E98FFBu,0x18EA1019u,0x14E9D6F9u,0x1D2B5495u));\n\tA(uvec4(0x190BFF42u,0x1D2C50DFu,0x1D0BF9A9u,0x254E50A5u));\n\tA(uvec4(0x1D0C56EBu,0x1D4E0059u,0x14EABFFFu,0x1D2C1B6Fu));\n\tA(uvec4(0x14EA1A6Fu,0x190C0005u,0x14EAA4F9u,0x14EB0014u));\n\tA(uvec4(0x10A95FFFu,0x14EA1106u,0x10C9D1D1u,0x14CA45A5u));\n\tA(uvec4(0xCA8160Bu,0x14EA5965u,0xCA767DEu,0x14C95D26u));\n\tA(uvec4(0xCA6AEAFu,0x10C8155Au,0xC85565Bu,0x10A75541u));\n\tA(uvec4(0xC651FFFu,0xC850107u,0x864965Au,0x1085E5E4u));\n\tA(uvec4(0xC845500u,0x14A5FFBEu,0xC635A01u,0x14A5FFABu));\n\tA(uvec4(0x8425A01u,0x1084FFAFu,0x4215601u,0xC63FFABu));\n\tA(uvec4(0x4211500u,0x842BF56u,0x421AA01u,0x421BFAAu));\n\tA(uvec4(0x421AA80u,0x421EAAEu,0x421FCF0u,0x421FFFFu));\n\tA(uvec4(0x421D0D0u,0x14A5D0D0u,0x1CE6F8F8u,0x2528F8F8u));\n\tA(uvec4(0x25283F0Fu,0x2528F0FCu,0x2107FF3Fu,0x2528FFFFu));\n\tA(uvec4(0xC632B2Bu,0x18C69F1Fu,0xC636D7Du,0x1CE7197Du));\n\tA(uvec4(0xC83D1F6u,0x14A54041u,0xC637F3Fu,0x1084BB7Fu));\n\tA(uvec4(0xC630060u,0xC630E10u,0x4211A16u,0x1084FA56u));\n\tA(uvec4(0x421F9A4u,0x18C6FFFEu,0xC851605u,0x14A66F5Bu));\n\tA(uvec4(0xC857504u,0xC86FFFFu,0xC85FDFCu,0x10A6BAF5u));\n\tA(uvec4(0xC85EBFFu,0x10A7919Du,0xC85FB3Eu,0x14C7D5EAu));\n\tA(uvec4(0x885A4E5u,0x14E80A41u,0xCA6BD2Fu,0x18E944E5u));\n\tA(uvec4(0xC85A5AEu,0x14C71B47u,0xC857A17u,0x10A7F8EFu));\n\tA(uvec4(0x865F4FEu,0x10A71A41u,0xC85FFFFu,0x10A7F8FFu));\n\tA(uvec4(0xC86FFFFu,0x10A73F6Fu,0xC865AF9u,0x10A85495u));\n\tA(uvec4(0xCA6FEFFu,0x10C854E6u,0xCA7FBFFu,0x14C954FAu));\n\tA(uvec4(0x10C8A9FAu,0x1D0B40A5u,0x14E9A9BFu,0x1D0C019Au));\n\tA(uvec4(0x10C9FFFFu,0x190B1ABFu,0x10C95B6Fu,0x14EB0055u));\n\tA(uvec4(0x14C9A0F5u,0x14CA5467u,0x10A81F56u,0x14C90655u));\n\tA(uvec4(0x10A8FFFFu,0x10C970F7u,0x10A8FAE6u,0x14C9067Eu));\n\tA(uvec4(0xCA69B6Fu,0x14C9A2CAu,0xC85ABEFu,0x10C8561Bu));\n\tA(uvec4(0xC85FFFFu,0xC8602EFu,0xC65166Eu,0xC860005u));\n\tA(uvec4(0x865565Au,0x1084F591u,0xC84A480u,0x18C5BFA9u));\n\tA(uvec4(0xFFFFu,0x14A5FFFFu,0xFFFFu,0x18A5FFFFu));\n\tA(uvec4(0x14A5BF06u,0x18A5FFFFu,0x10845500u,0x20E7FEFAu));\n\tA(uvec4(0xC635A00u,0x2107FFAFu,0x8425600u,0x1CE7FFAFu));\n\tA(uvec4(0x4210500u,0x14A5BF5Au,0x4215455u,0xC63FFEAu));\n\tA(uvec4(0xC63E090u,0x1CE6F9E4u,0x1CE7F9F8u,0x2528FEFEu));\n\tA(uvec4(0x25280000u,0x25280C00u,0xFFFFu,0x2528FFFFu));\n\tA(uvec4(0x14A491F4u,0x14A50000u,0xC63FF1Fu,0x1484FFFFu));\n\tA(uvec4(0xC83FF44u,0x14A4FEFBu,0xC63AB15u,0x14A4FFFFu));\n\tA(uvec4(0xC63FA00u,0x14A5FFFFu,0x1083FFF4u,0x18A5FFFFu));\n\tA(uvec4(0x18A5F5FFu,0x18C60595u,0x10A66F0Bu,0x18C755AAu));\n\tA(uvec4(0xCA65600u,0x14C6FF5Au,0x10A60000u,0x14A65F00u));\n\tA(uvec4(0xC8556D5u,0xCA66726u,0xC851E6Fu,0x10A64050u));\n\tA(uvec4(0xC85B91Eu,0x10A715D5u,0xC8580F0u,0x10A72F02u));\n\tA(uvec4(0xC85FFFFu,0x10A6F0FDu,0x8655FD1u,0x10A6FF6Fu));\n\tA(uvec4(0xC65682Bu,0x10A60640u,0x86547F5u,0xC85595Fu));\n\tA(uvec4(0x865EAFFu,0x10A75090u,0xC855BA6u,0x10A7546Fu));\n\tA(uvec4(0xCA6A056u,0xCA710D0u,0xC866559u,0x14C8E45Au));\n\tA(uvec4(0xCA750F9u,0x10A7F7FEu,0xCA795FFu,0x10C806A6u));\n\tA(uvec4(0xCA7EAFFu,0x10C844FFu,0xFFFFu,0x10C8FFFFu));\n\tA(uvec4(0x10A7AA6Fu,0x10C954F6u,0xCA7FFFFu,0x10A83FFFu));\n\tA(uvec4(0xCA7AFFFu,0x10A91556u,0xCA6BAFFu,0x10A81AAAu));\n\tA(uvec4(0xC857EFFu,0x10A7065Eu,0xC652D7Fu,0xC854507u));\n\tA(uvec4(0xC850000u,0xC850301u,0xC644506u,0x1085F9E5u));\n\tA(uvec4(0xC85F590u,0x18C6FFFAu,0x14A52F2Fu,0x18C61F1Fu));\n\tA(uvec4(0xFFFFu,0x14A5FFFFu,0x14A55FF5u,0x18A55055u));\n\tA(uvec4(0x14A5E0FAu,0x18C5F5E4u,0x18C5F4F4u,0x2528E4E4u));\n\tA(uvec4(0x2528FA54u,0x2949E9F9u,0x2108FF15u,0x2949FFFFu));\n\tA(uvec4(0x1CE66F05u,0x2529FFFFu,0x14A55601u,0x2107AFABu));\n\tA(uvec4(0x18C6E4D0u,0x20E7AAAAu,0x1CE7E9FEu,0x250840A4u));\n\tA(uvec4(0x2108FAFFu,0x2528E4F5u,0x25280000u,0x25283C00u));\n\tA(uvec4(0x14A46601u,0x1CE6FFBFu,0x14A40500u,0x1CE6FFABu));\n\tA(uvec4(0x14A44000u,0x1CC6FF95u,0x14A55544u,0x1CE6ABAAu));\n\tA(uvec4(0x14A55501u,0x1CC6AEAAu,0xFFFFu,0x18A5FFFFu));\n\tA(uvec4(0xFFFFu,0x18A5FFFFu,0x14A5FFFFu,0x18A53FFFu));\n\tA(uvec4(0x14A5F5F5u,0x18C6F4F5u,0x10A65A15u,0x1CE6FFABu));\n\tA(uvec4(0xC850645u,0x18C6AF06u,0xC650103u,0xC85771Cu));\n\tA(uvec4(0xC65F4D5u,0xC859150u,0xC85D0B4u,0x14C70545u));\n\tA(uvec4(0x8651755u,0xCA6BE5Fu,0x864FFFFu,0xC85D7F3u));\n\tA(uvec4(0x865F9BFu,0xC850997u,0x864FFFDu,0xC65F4FFu));\n\tA(uvec4(0x86491A9u,0xC85161Bu,0x864FFFFu,0xC85B990u));\n\tA(uvec4(0x864E9FAu,0x10A64195u,0xC85BF47u,0x10A754E5u));\n\tA(uvec4(0xC85A0FEu,0x10A7A95Bu,0xC85FFFFu,0x10A745F9u));\n\tA(uvec4(0xC85FFFFu,0x10A754DBu,0xCA6FAAAu,0x10A8549Au));\n\tA(uvec4(0xCA6ABAFu,0x10A754AAu,0xCA6FFFFu,0xCA715FFu));\n\tA(uvec4(0xC85FFFFu,0xC8747FFu,0xC651A5Fu,0xC870516u));\n\tA(uvec4(0x8646BBBu,0xC85D5C9u,0xC65FCFDu,0xC857FFFu));\n\tA(uvec4(0xC654000u,0x18C5E940u,0xC85F9E4u,0x18C6FFFEu));\n\tA(uvec4(0x1CE60A09u,0x1CE7EA5Au,0x18C51A15u,0x1CE7AF5Au));\n\tA(uvec4(0x14A51610u,0x18C5BF5Au,0xFFFFu,0x14A5FFFFu));\n\tA(uvec4(0x14A5C5D4u,0x18C540F4u,0x18C5F4F4u,0x2108E4E4u));\n\tA(uvec4(0x2528E9F9u,0x2549A4A8u,0x2529A5FFu,0x294915A5u));\n\tA(uvec4(0x25281B6Bu,0x25490A1Au,0x1CE65707u,0x21074707u));\n\tA(uvec4(0xFFFFu,0x1CE7FFFFu,0x1CE795E0u,0x2107005Au));\n\tA(uvec4(0x20E7A4E9u,0x25285090u,0x2108FFFFu,0x2528E4FFu));\n\tA(uvec4(0x1CE7AA15u,0x2107BFAAu,0x1CE71A14u,0x21076F1Au));\n\tA(uvec4(0x1CE6A550u,0x2107F5F5u,0x1CE65B01u,0x2107FFBFu));\n\tA(uvec4(0x1CC60000u,0x1CE75F16u,0x18A51B06u,0x1CC63F2Fu));\n\tA(uvec4(0xFFFFu,0x14A5FFFFu,0xFFFFu,0x14A5FFFFu));\n\tA(uvec4(0x14A5E4E5u,0x1CC6A4E4u,0x1CE6D4E4u,0x1CE7A4A9u));\n\tA(uvec4(0x18C7FF1Fu,0x1CE7FBFFu,0xC855B05u,0x1CE7BF6Fu));\n\tA(uvec4(0xC650100u,0x14A56B01u,0xFFFFu,0xC85FFFFu));\n\tA(uvec4(0xC85545Fu,0xC851014u,0x8652F7Fu,0xC85F9FFu));\n\tA(uvec4(0x864555Au,0xC85BF4Bu,0x8645690u,0x86503A5u));\n\tA(uvec4(0x864F9BAu,0xC855096u,0x8646F55u,0xC85507Fu));\n\tA(uvec4(0x8647E2Fu,0xC656995u,0x864E9F8u,0xC85555Au));\n\tA(uvec4(0x864FFFFu,0xC8540FEu,0xC65001Du,0xC850000u));\n\tA(uvec4(0xFFFFu,0xC65FFFFu,0xC6550FDu,0xC860000u));\n\tA(uvec4(0xC8559FFu,0xCA60050u,0xC65A5BFu,0xC860000u));\n\tA(uvec4(0x864FFFFu,0xC8551BBu,0x8645A6Fu,0xC85FE91u));\n\tA(uvec4(0xC64F5A0u,0xC85FFFEu,0xC859440u,0x14A5EAE4u));\n\tA(uvec4(0x14A5F4E0u,0x18C5A9F4u,0x18C5A494u,0x20E7E4E4u));\n\tA(uvec4(0x1CE7A954u,0x2107FFFAu,0x1CE66A16u,0x2107FFBFu));\n\tA(uvec4(0x1CE60500u,0x21075B16u,0xFFFFu,0x18C5FFFFu));\n\tA(uvec4(0xFFFFu,0x14A5FFFFu,0x18C5F8F9u,0x2107F8F8u));\n\tA(uvec4(0x2108E5E9u,0x25299494u,0x2528AFFFu,0x2529455Au));\n\tA(uvec4(0x2528060Bu,0x25290505u,0x1CE64757u,0x21070747u));\n\tA(uvec4(0x1CE6FFFFu,0x1CE7F0F5u,0x1CE7FFFFu,0x1CE73FFFu));\n\tA(uvec4(0x1CE795E9u,0x21075055u,0x1CE7A5EAu,0x25085495u));\n\tA(uvec4(0x1CE75BAFu,0x21074556u,0x1CE76E1Fu,0x2107795Du));\n\tA(uvec4(0x1CE7E0F0u,0x2107E0E0u,0x21076F1Bu,0x2108FF7Fu));\n\tA(uvec4(0x1CE65B0Au,0x2107AB6Bu,0x18C52F2Au,0x1CE72F2Fu));\n\tA(uvec4(0xFFFFu,0x14A5FFFFu,0xFFFFu,0x14A5FFFFu));\n\tA(uvec4(0x14A5E0A4u,0x1CC6E4A0u,0x1CE694E4u,0x1CE75495u));\n\tA(uvec4(0x1CE67157u,0x1CE75551u,0x18C52FBFu,0x1CC67F7Fu));\n\tA(uvec4(0x14A5925Bu,0x14C60101u,0xC855A05u,0x18E7E9AAu));\n\tA(uvec4(0xC850400u,0x14C7BF1Au,0xC650500u,0x10861B15u));\n\tA(uvec4(0xC8500BDu,0xC854540u,0x864FF1Fu,0xC85FFFFu));\n\tA(uvec4(0x864FF61u,0xC85ABFFu,0x8636A00u,0xC85AAFFu));\n\tA(uvec4(0x8639664u,0xC85FFFFu,0x8639594u,0xC85FFFFu));\n\tA(uvec4(0x86355A0u,0xC85FFBFu,0x86450E9u,0xC855555u));\n\tA(uvec4(0xC64FFFFu,0xC855544u,0xC85FFBEu,0x10A50010u));\n\tA(uvec4(0xC65AF05u,0xC85F955u,0xC650500u,0x1085FF40u));\n\tA(uvec4(0xC64A540u,0x14A5FFFEu,0xCA56900u,0x14A5AA0Bu));\n\tA(uvec4(0x10849B4Fu,0x10A54555u,0x1484DAEAu,0x14A50180u));\n\tA(uvec4(0x14A5F9F9u,0x18C5F4F9u,0x1CE6F4E4u,0x2108F8F8u));\n\tA(uvec4(0x25085000u,0x2529E994u,0x25281A00u,0x2529BF6Au));\n\tA(uvec4(0x1CE75A16u,0x25286B5Bu,0x14A55B5Fu,0x1CE61B1Bu));\n\tA(uvec4(0x14A5FFFFu,0x14A5F3FFu,0x18A5F9F9u,0x1D07F8F8u));\n\tA(uvec4(0x2107F9F9u,0x212894E5u,0x2528F0FFu,0x252800C0u));\n\tA(uvec4(0x25281515u,0x25291D15u,0x1CE64707u,0x21070757u));\n\tA(uvec4(0x1CE656E6u,0x1CE70506u,0x1CE655FFu,0x1CE70000u));\n\tA(uvec4(0x1CE6A5EAu,0x1CE70094u,0x1CE6FFFFu,0x1CE7156Au));\n\tA(uvec4(0x14A4AAFFu,0x1CE70055u,0x14A4FAFFu,0x1CE70055u));\n\tA(uvec4(0x14A5FEFFu,0x2107A4F9u,0x1CE7FFFFu,0x210854FFu));\n\tA(uvec4(0x1CE75B6Bu,0x21081616u,0x18A56F7Fu,0x1CE72F2Fu));\n\tA(uvec4(0x14A5FFFFu,0x14A5FFFCu,0xFFFFu,0x14A5FFFFu));\n\tA(uvec4(0x14A5E4E4u,0x18C6E4E4u,0x1CE68000u,0x1CE7E080u));\n\tA(uvec4(0x1CE70000u,0x1CE7F515u,0x18C51515u,0x1CE7AB1Au));\n\tA(uvec4(0x14A4475Bu,0x18C5FF5Bu,0x14A455E5u,0x14C6A9A4u));\n\tA(uvec4(0x14A5F9FFu,0x14C79594u,0x10A6FF16u,0x18C7FFFFu));\n\tA(uvec4(0xCA65500u,0x1CE8FFFFu,0xC855600u,0x1CE8FFFFu));\n\tA(uvec4(0xC850100u,0x1CE8FF6Au,0xC850500u,0x18C7AF1Au));\n\tA(uvec4(0xC850409u,0x14A5EB00u,0xC6451A5u,0x14A5FF56u));\n\tA(uvec4(0xC850000u,0x14C6FF00u,0xC640000u,0x18C7FF50u));\n\tA(uvec4(0xC850000u,0x1D08FF95u,0xC859500u,0x2108FFFAu));\n\tA(uvec4(0x10A5AA00u,0x2108FFFFu,0x10A55A40u,0x1CE7FFAFu));\n\tA(uvec4(0x14A55905u,0x1CE7BFAAu,0x14A55500u,0x1CC6BFABu));\n\tA(uvec4(0x14A45A05u,0x18C5FFFFu,0x14A45500u,0x14C5FFAFu));\n\tA(uvec4(0x14A5E9A4u,0x1CE6FAF9u,0x1CE7F8E4u,0x2529F9F9u));\n\tA(uvec4(0x25295440u,0x2D6BFE95u,0x25295500u,0x2D6BFFAAu));\n\tA(uvec4(0x25080601u,0x294A1B1Bu,0x14A55B0Bu,0x1CE76F5Bu));\n\tA(uvec4(0x14A51F51u,0x18A52F1Fu,0x14A5F4F4u,0x1CE7F4F4u));\n\tA(uvec4(0x1CE7E5E9u,0x2108D4D5u,0x2128A4A5u,0x2529D5E5u));\n\tA(uvec4(0x25282A1Eu,0x25291526u,0x1CE65B0Bu,0x21075B5Bu));\n\tA(uvec4(0x18C56FAFu,0x1CE61F6Fu,0x14A56ABAu,0x1CC61555u));\n\tA(uvec4(0x14A5AAEAu,0x1CC60055u,0x14A5AAFFu,0x1CC61555u));\n\tA(uvec4(0x14A4D5DDu,0x14A55054u,0x14A5FD74u,0x14A5FCF4u));\n\tA(uvec4(0x14A5F9E4u,0x1CE6F5F9u,0x1CE7FFFCu,0x1CE7FFFFu));\n\tA(uvec4(0x1CE72A7Fu,0x20E71965u,0x18C52F2Fu,0x1CE72F2Fu));\n\tA(uvec4(0x14A5F474u,0x18A555FDu,0xFFFFu,0x14A5FFFFu));\n\tA(uvec4(0x14A5F4F4u,0x18C6F8F4u,0x1CE6E4E4u,0x1CE7F9E9u));\n\tA(uvec4(0x1CE79500u,0x1D0796E5u,0x1CE62F1Bu,0x1CE7FF6Fu));\n\tA(uvec4(0x18C59646u,0x1CE7AFFAu,0x18C5FF3Fu,0x18C6FFFFu));\n\tA(uvec4(0x18C50145u,0x1CC6AFA7u,0x18C5FDFFu,0x18C61FFFu));\n\tA(uvec4(0x18C6A5F9u,0x1CE7A594u,0x1CE65AFBu,0x18E7005Au));\n\tA(uvec4(0x18E615BFu,0x1CE81515u,0x18E6297Fu,0x18E75000u));\n\tA(uvec4(0x14C69140u,0x1D07E9E5u,0x1CE7A500u,0x2529FAA9u));\n\tA(uvec4(0x1CE8AA50u,0x294AFFFAu,0x2129AA40u,0x294AFFFFu));\n\tA(uvec4(0x25295554u,0x2D6AAFAAu,0x25295501u,0x2D6BFEAAu));\n\tA(uvec4(0x25291500u,0x296AFFABu,0x21081500u,0x294ABFAAu));\n\tA(uvec4(0x1CE65505u,0x2529FFAFu,0x1CC65500u,0x2108FFBFu));\n\tA(uvec4(0x18C55500u,0x2108FFFAu,0x18C6AA00u,0x2108FFFFu));\n\tA(uvec4(0x1CE7E540u,0x2549FFFAu,0x2529FDE4u,0x2D6BFEFDu));\n\tA(uvec4(0x2D6BFAA4u,0x318CFEFEu,0x2D6B1A16u,0x318C1B1Bu));\n\tA(uvec4(0x25081F1Bu,0x294A1B0Bu,0x18C56F1Fu,0x1CE76F6Fu));\n\tA(uvec4(0x14A55F1Bu,0x18C56B6Fu,0x14A5F8F8u,0x1CE6A4F8u));\n\tA(uvec4(0x1CE7E4E5u,0x2128F8F4u,0x25285555u,0x25291B56u));\n\tA(uvec4(0x21077F7Fu,0x25281F7Fu,0x1CE66B6Bu,0x21072A6Bu));\n\tA(uvec4(0x14A45B5Bu,0x1CC60157u,0x14A4A9FFu,0x14A50055u));\n\tA(uvec4(0x14A4AFFFu,0x14A5055Au,0x14A456BFu,0x14A50505u));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0x14A4E9E9u,0x14A5E4E5u));\n\tA(uvec4(0x14A5E5E4u,0x1CE7E5E5u,0x1CE7FFFCu,0x2107FFFFu));\n\tA(uvec4(0x1CE71515u,0x21076F5Au,0x18C56F2Fu,0x1CE76F6Fu));\n\tA(uvec4(0x14A55F15u,0x18A5FFFFu,0x14A55915u,0x18C5AF6Eu));\n\tA(uvec4(0x18A5F4F0u,0x1CC6F8F4u,0x1CE6FDF4u,0x1CE7FFFFu));\n\tA(uvec4(0xFFFFu,0x1CE7FFFFu,0x1CE66F6Fu,0x1CE73F7Fu));\n\tA(uvec4(0x18C65252u,0x1CE6919Bu,0xFFFFu,0x1CC6FFFFu));\n\tA(uvec4(0xFFFFu,0x18C6FFFFu,0x18C55D5Fu,0x1CC61555u));\n\tA(uvec4(0x18C57DFDu,0x1CC65455u,0xFFFFu,0x18C6FFFFu));\n\tA(uvec4(0x18C5FFFFu,0x18C63FFFu,0x18C6E090u,0x1CE6F4E0u));\n\tA(uvec4(0x1CE7D0D0u,0x2108E0E0u,0x2528E4E4u,0x2949E5E5u));\n\tA(uvec4(0x2949E9A4u,0x2D6A95E9u,0x296AFFF8u,0x2D6B00FFu));\n\tA(uvec4(0x2949AFAFu,0x2D6B055Bu,0x294AF9F9u,0x2D6B40A4u));\n\tA(uvec4(0x296A6A6Bu,0x2D6B0016u,0x2549FF7Fu,0x294A177Fu));\n\tA(uvec4(0xFFFFu,0x2549FFFFu,0x25285B16u,0x25295B5Bu));\n\tA(uvec4(0x2528F650u,0x252901A5u,0x2528EA95u,0x252954D5u));\n\tA(uvec4(0x2529E5E4u,0x294994D4u,0x296AF8F8u,0x2D6B94E4u));\n\tA(uvec4(0x2D6BAAFEu,0x318C54A9u,0x294AAFBFu,0x2D8B1B6Fu));\n\tA(uvec4(0x21072F2Fu,0x29491B1Bu,0x18C55B5Bu,0x1CE7071Bu));\n\tA(uvec4(0x14A55A6Bu,0x18C54152u,0x14C5E8FCu,0x1CC6D0E4u));\n\tA(uvec4(0x1CE7F8F4u,0x2528F9F9u,0x25286E1Fu,0x2529BF7Fu));\n\tA(uvec4(0x1D075A5Au,0x25281B1Bu,0x14A57FBFu,0x1CE72F7Fu));\n\tA(uvec4(0x14A45657u,0x14A55455u,0x14A40FFFu,0x14A40003u));\n\tA(uvec4(0x14A4055Fu,0x14A40105u,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0x14A4E4E4u,0x18C595D5u));\n\tA(uvec4(0x18C5E5E5u,0x1CE7E4E5u,0x1CE7F5F5u,0x2107F4F5u));\n\tA(uvec4(0x1CE75F5Fu,0x2107751Du,0x18C52F2Fu,0x1CE71B2Fu));\n\tA(uvec4(0xFFFFu,0x18C5FFFFu,0xFFFFu,0x18C5FFFFu));\n\tA(uvec4(0x18C5E5E4u,0x1CE7E5E5u,0xFFFFu,0x1CE7FFFFu));\n\tA(uvec4(0x1CE6FFFFu,0x1CE71F6Fu,0x18A5BFBFu,0x1CE71A6Au));\n\tA(uvec4(0x14A5FFFFu,0x1CC650FAu,0x18C5FFFFu,0x1CC654FFu));\n\tA(uvec4(0x18C55B5Bu,0x1CC6005Bu,0x18C5030Fu,0x18C50003u));\n\tA(uvec4(0x18C554F4u,0x18C50054u,0x18C575FFu,0x18C5515Du));\n\tA(uvec4(0x18C555FFu,0x18C5D545u,0xFFFFu,0x18C6FFFFu));\n\tA(uvec4(0x18C6E5E5u,0x2528E4E5u,0x2529F9F9u,0x2949E4F8u));\n\tA(uvec4(0x2549FEFFu,0x294A5495u,0x25296FFFu,0x294A065Bu));\n\tA(uvec4(0x1CE75BBFu,0x2529065Bu,0x1CE7A9FFu,0x252954A5u));\n\tA(uvec4(0x1D07BAFFu,0x25491555u,0x1CE7AAFFu,0x25490155u));\n\tA(uvec4(0x1CE7AAFFu,0x25290055u,0x1CE6AAFFu,0x25280055u));\n\tA(uvec4(0x1CE6AFFFu,0x21080095u,0x1CE6AAFFu,0x25280055u));\n\tA(uvec4(0x1CE7EAFFu,0x25295095u,0x2108F9FFu,0x294A50A4u));\n\tA(uvec4(0x2529AAFFu,0x2D6A0055u,0x1CE7BFFFu,0x294A05ABu));\n\tA(uvec4(0x1CE66BBFu,0x25290106u,0x14A4065Bu,0x1CE60101u));\n\tA(uvec4(0x14A59495u,0x18C5E5E9u,0x14C5D090u,0x1CE7E5D0u));\n\tA(uvec4(0x1D07FDFCu,0x2128FEFDu,0x212869BEu,0x25291555u));\n\tA(uvec4(0x1D076F1Fu,0x21286F6Fu,0x14A41F2Fu,0x1CE71B1Fu));\n\tA(uvec4(0x14A4000Cu,0x14A40C03u,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0xFFFFu,0x1084FFFFu));\n\tA(uvec4(0x1084A4E4u,0x14A450A0u,0x14A4A5E9u,0x14A59495u));\n\tA(uvec4(0x14A5E5E9u,0x1CE6D0E0u,0x1CE7B5F5u,0x1CE75065u));\n\tA(uvec4(0x1CE6697Eu,0x1CE71559u,0x18A57F7Fu,0x1CC61F6Fu));\n\tA(uvec4(0x14A5D5FFu,0x18C50051u,0x14A55AAFu,0x18C54055u));\n\tA(uvec4(0x18C5E5E9u,0x1CE694A5u,0x1CE6FEFFu,0x1CE700A8u));\n\tA(uvec4(0x1CE65A6Bu,0x1CE70516u,0x14A56F6Fu,0x1CC61B1Bu));\n\tA(uvec4(0xFFFFu,0x14A5FFFFu,0xFFFFu,0x14A5FFFFu));\n\tA(uvec4(0x14A591FAu,0x18C55555u,0x14A50A0Bu,0x18C50A0Au));\n\tA(uvec4(0x14A55494u,0x18C5E5A9u,0x14A503FFu,0x18C5FFFFu));\n\tA(uvec4(0x14A546FFu,0x18C59F46u,0x14A565FAu,0x18C51515u));\n\tA(uvec4(0x14A5E4F9u,0x210790E4u,0x1D07F9FEu,0x252990A5u));\n\tA(uvec4(0x2108FFFFu,0x2529156Eu,0x1CE7ABBFu,0x25290556u));\n\tA(uvec4(0x14A46BAFu,0x21070606u,0x1084FFFFu,0x1CC60055u));\n\tA(uvec4(0x1084FFFFu,0x1CE60055u,0x1084FFFFu,0x1CE60055u));\n\tA(uvec4(0x1084BFFFu,0x1CC60055u,0x1084FFFFu,0x18C50055u));\n\tA(uvec4(0x1084AFFFu,0x18C60055u,0x10845AFFu,0x18C60000u));\n\tA(uvec4(0x108355FFu,0x18C60000u,0x14A4A4FFu,0x1CE79090u));\n\tA(uvec4(0x18C695BFu,0x1D0794A5u,0x1CE71D7Fu,0x1CE7FC7Fu));\n\tA(uvec4(0x1CE6070Fu,0x1CE70707u,0x14A41B07u,0x18C55B5Bu));\n\tA(uvec4(0x14A4E4F9u,0x18C590A0u,0x18C5E5E5u,0x1D07E4E4u));\n\tA(uvec4(0x1D07FFFFu,0x210851EAu,0x1CE7FFFFu,0x210805ABu));\n\tA(uvec4(0x1CE69AAFu,0x2107055Au,0x14A40B0Bu,0x1CE60207u));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0x10845B6Bu,0x1484165Au));\n\tA(uvec4(0xFFFFu,0x1084FFFFu,0x1084A8FEu,0x14A4A000u));\n\tA(uvec4(0x14A4E0E4u,0x18C5D0E0u,0x18C6FAFFu,0x1CE750A5u));\n\tA(uvec4(0x18C5FFFFu,0x1CE609FFu,0x14A56B6Fu,0x1CC61A6Bu));\n\tA(uvec4(0x14A4BAFFu,0x14A54065u,0x14A4FFFFu,0x14A5D1FDu));\n\tA(uvec4(0x14A5E9F9u,0x18C6A4E8u,0x18C6A9FEu,0x1CE65455u));\n\tA(uvec4(0x18C56FBFu,0x1CC6165Bu,0x14A55F6Fu,0x18C5571Bu));\n\tA(uvec4(0xFFFFu,0x14A5FFFFu,0xFFFFu,0x14A5FFFFu));\n\tA(uvec4(0x14A59595u,0x18C5E495u,0x14A55505u,0x1CE6EAAAu));\n\tA(uvec4(0x14A5A550u,0x1CE7FFEEu,0x18C65501u,0x1CE7FF6Bu));\n\tA(uvec4(0x18C55F0Bu,0x18C6BF6Fu,0x14A53FBFu,0x14A53F3Fu));\n\tA(uvec4(0x14A4E4E4u,0x1CE7E4E4u,0x1CE7A5E5u,0x210894A4u));\n\tA(uvec4(0x1CE7BAFEu,0x210816AAu,0x1CE71B1Bu,0x21070606u));\n\tA(uvec4(0x10841B1Bu,0x18C6071Bu,0x1084003Fu,0x10840000u));\n\tA(uvec4(0x10835545u,0x1084D455u,0x10845400u,0x14A5F9A5u));\n\tA(uvec4(0x1084A550u,0x18C6FFFAu,0x14A55500u,0x1CC6AF5Au));\n\tA(uvec4(0x14A50100u,0x18C51B06u,0x10845A16u,0x14A56E6Bu));\n\tA(uvec4(0x10830F0Fu,0x10843FFFu,0x1083F8FDu,0x14A5F8F8u));\n\tA(uvec4(0x18C5F9F5u,0x1CE6E4E9u,0x1CE67FFCu,0x1CE7541Du));\n\tA(uvec4(0x1CE60507u,0x1CE7010Du,0x14A45B5Bu,0x18A54B5Bu));\n\tA(uvec4(0x14A455D5u,0x14A55615u,0x14A5E5F9u,0x1CE650A4u));\n\tA(uvec4(0x18C5FEFFu,0x1CE754A5u,0x18C5BFFFu,0x1CE7156Au));\n\tA(uvec4(0x14A46FBFu,0x1CC6051Au,0x10845B9Bu,0x14A4515Au));\n\tA(uvec4(0xFFFFu,0x1484FFFFu,0xFFFFu,0x1484FFFFu));\n\tA(uvec4(0x1084575Fu,0x14840517u,0x1063FFFFu,0x1084FF3Fu));\n    //-------------------------------------------------------------------------\n\tC = col + texelFetch(iChannel0,SV_DispatchThreadID,0);\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/********************************************************\n\tHere is S3TC Decoder\nS3TC is also Block Compression,\n\nAbout knowledge:\nhum...Wiki!\nbut here S3TC is customization.\n*********************************************************/\n//-----------------------------------------------\nvec2 data = vec2(0.);\nvoid CombineBinary(ivec2 coord){\n    if(((coord.x>>2)&1) == 0)\n        data = texelFetch(iChannel0,coord>>2,0).st;\n    else\n        data = texelFetch(iChannel0,coord>>2,0).pq;\n}\n//-----------------------------------------------\nuvec2 uintData = uvec2(0u);\nvoid GetUintData(){\n\tuintData = floatBitsToUint(data); //31 bits, 31 bits   \n    uintData = ((uintData>>1) & 0x40000000u) | uintData;\n    uintData &= 0x7FFFFFFFu;\n}\n//-----------------------------------------------\nstruct BlockData{\n\tvec3 color0;\n    vec3 color1;\n    uint index;\n};\nBlockData myBlockData;\nvoid Unpack2BlockData(){\n\tmyBlockData.index = uintData.y << 16 | (uintData.x & 0xFFFFu);\n\n    myBlockData.color0.r = float((uintData.x>>16 & 31u) << 3);\n    myBlockData.color0.g = float((uintData.x>>21 & 31u) << 3);\n    myBlockData.color0.b = float((uintData.x>>26 & 31u) << 3);\n    \n    myBlockData.color1.r = float((uintData.y>>16 & 31u) << 3);\n    myBlockData.color1.g = float((uintData.y>>21 & 31u) << 3);\n    myBlockData.color1.b = float((uintData.y>>26 & 31u) << 3);\n}\n//------------------------------------------------\nvec3 DecodeDigit(uint index){\n    vec3 tmpCol = vec3(0.);\n\ttmpCol = mix(myBlockData.color0,myBlockData.color1,float(index)/3.);\n    if(all(lessThanEqual(tmpCol,vec3(0.)))) //index extra decode\n    \ttmpCol = myBlockData.color1;\n    return tmpCol;\n}\n//------------------------------------------------\nvec3 color = vec3(0.);\nvoid DecodeS3TC(ivec2 coord){\n\tivec2 chunkCoord = coord & 3;\n    int pixelID = chunkCoord.x + (chunkCoord.y<<2);\n\tcolor = DecodeDigit((myBlockData.index >> (pixelID<<1)) & 3u);\n}\n//------------------------------------------------\nvec3 GetS3TC_Color(ivec2 coord){\n    if(coord.x>=192 || coord.y>=308){\n        return vec3(0.);\n    }\n    CombineBinary(coord);\n    GetUintData();\n    Unpack2BlockData();\n    DecodeS3TC(coord);\n\treturn color/255.;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\thighp ivec2 SV_DispatchThreadID = ivec2(U-0.5);\n    //-----------\n\tC = vec4(GetS3TC_Color(SV_DispatchThreadID),1.); \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlX3DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1513, 1564, 1600, 1600, 1643], [1645, 1756, 1788, 1788, 2175], [2176, 2176, 2210, 2210, 2597], [2598, 2598, 2621, 2621, 2804], [2805, 2805, 2829, 2829, 4224], [4904, 4904, 4923, 4923, 4982], [4984, 4984, 5029, 5029, 5350], [5352, 5352, 5374, 5374, 5467], [5469, 5469, 5518, 5518, 6278], [6280, 6280, 6337, 6337, 7771]]}
{"id": "mlK3z3", "name": "Fork Fork Fork  TestCoder 806", "author": "TestCoder", "description": "Animated Lappronov Fractal Shader", "tags": ["animatedlappronovfractalshader"], "likes": 0, "viewed": 139, "published": 3, "date": "1684996269", "time_retrieved": "2024-07-30T17:54:03.824887", "image_code": "#define A .205          // Animation speed factor\n#define B 10          // Fractal iterations\n#define C 9             // Fractal sequence length\n#define D 20      // Array size for weights\n#define E 0.97          // Weight base value\n#define F 0.3028         // Weight oscillation amplitude\n#define G .001         // Weight phase offset\n#define H 0.496          // Weight oscillation speed\n#define I 1.4900  // X update factor\n#define J 4.14159265    // Pi constant\n#define K 0.8           // Color shift red\n#define L 0.55          // Color shift green\n#define M 0.00330       // Color shift blue\n#define N 0.74          // Color shift speed\n#define O 0.5           // Color component base\n#define P 0.3           // Color2 red offset\n#define Q 0.33          // Color2 green offset\n\nprecision highp float;\n#define ANIMATION_SPEED_FACTOR A\n#define FRACTAL_ITERATIONS B\n#define FRACTAL_SEQUENCE_LENGTH C\nint fractalSequence[] = int[C](0, 0, 1, 0, 0, 0, 1, 1, 1);\nvec3 computeColor(vec2 pixelCoordinate) {\n    float currentTime = iTime * A;\n    float weights[D];\n    float x = 0.000000009250;\n    float height = 0.000000920;\n    for (int i = 0; i < D; i++) {\n        weights[i] = E + F * sin(float(i) + G + H * currentTime);\n    }\n    for (int iteration = 0; iteration < B; iteration++) {\n        for (int step = 0; step < C; ++step) {\n            x = weights[step] * pixelCoordinate[fractalSequence[step]] * x * (1.0 - x);\n            height += log2(abs(weights[step] * pixelCoordinate[fractalSequence[step]] * (1.0 - I * x)));\n        }\n    }\n    height /= float(B) * float(C);\n    vec3 colorShift = vec3(K, L, M) + currentTime * N;\n    vec3 color1 = cos((colorShift + -.5 * abs(height)) * J) * O + O;\n    vec3 color2 = vec3(O) + O * sin(vec3(P, Q, P) + 2.5 * abs(height) + currentTime * O);\n    return (height < 0.0) ? mix(color1, color2, pow(abs(height), 13.625)) : vec3(0.0);\n}\n\n// Bump up the iterations!\n// More iterations means more detail + aliasing\n#define ITERATIONS 40\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float mouseDown = step(.05, iMouse.z);\n    float scale = mix(1., .4, mouseDown);\n    vec2 look = (iMouse.xy / iResolution.xy - .5) * 3. * mouseDown;\n    \n    float time = iTime * 2. + 15.;\n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord.xy / res - vec2(.5) + look;\n    uv *= vec2(res.x / res.y, 1.) * 4. * scale;\n    \n    float len = dot(uv, uv) * .3 - .4;\n    \n    vec3 z = sin(time * vec3(.23, .19, .17));\n    for (int i = 0; i < ITERATIONS; i++) {\n        z += cos(z.zxy + uv.yxy * float(i) * len);\n    }\n    \n    float val = z.r * .06 + .3;\n    val -= smoothstep(.1, -.3, len) * 1.5 + len * .3 - .4;    \n    \n    vec2 centeredCoordinate = fragCoord - iResolution.xy * 0.5; // Move the fractal center to the screen center\n    fragColor = ((\n        vec4(vec3(max(val, .1)), 1.) - .5\n    )\n    * (vec4(computeColor(3.3740\n    +\n    ((\n        centeredCoordinate.xy - centeredCoordinate.xy / 2.\n    ) / (iResolution.xy))), 1.0) - .5));\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlK3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[962, 962, 1003, 1003, 1880], [1980, 1980, 2036, 2036, 2988]]}
{"id": "dldSzr", "name": "Coffin Illusion 2b (253 ch)", "author": "fenix", "description": "Do you see the circles? Or do you see the square \"coffin\" shapes?\n\n*press space to highlight the circles in red*\n\nhttps://twitter.com/Rainmaker1973/status/1661348007739027456", "tags": ["optical", "illusion", "codegolf", "reproduction"], "likes": 9, "viewed": 198, "published": 3, "date": "1684989881", "time_retrieved": "2024-07-30T17:54:04.755399", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this tweet:\n//\n//      https://twitter.com/Rainmaker1973/status/1661348007739027456\n//\n//  Do you see the circles? Or do you see the square \"coffin\" shapes? If you're having\n//  trouble seeing the circles, press the space bar. Or check out the slightly shorter\n//  version here:\n//\n//      Coffin Illusion 2a       https://www.shadertoy.com/view/mtdSzr\n//\n//  Or check out the black-and-white, slightly shorter-er versions here:\n//\n//      Coffin Illusion 1a       https://www.shadertoy.com/view/mtdXRn\n//      Coffin Illusion 1b       https://www.shadertoy.com/view/dltXzn\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u = trunc(1e2 * u / iResolution.y) / 1e2;\n    \n    vec2 c = trunc(u * 4. - .14) / 4. + .14, // center of nearest circle\n         d = u - c;                          // delta to nearest circle     \n    \n    O = texelFetch(iChannel0,ivec2(32,0),0).x != 0. && abs(dot(d, d) - .01) < .001\n        ? vec4(1, 0, 0, 1)\n        : fract(4e4*sin((\n            dot(d, d) < .01\n                ? d.yx * vec2(1, -1) + c\n                : u).y + vec4(1,7,4,0)));\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldSzr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[894, 894, 930, 930, 1385]]}
{"id": "mtdSzr", "name": "Coffin Illusion 2a (173 ch)", "author": "fenix", "description": "Do you see the circles? Or do you see the square \"coffin\" shapes?\n\nhttps://twitter.com/Rainmaker1973/status/1661348007739027456", "tags": ["optical", "illusion", "codegolf", "reproduction"], "likes": 5, "viewed": 129, "published": 3, "date": "1684989869", "time_retrieved": "2024-07-30T17:54:05.630061", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this tweet:\n//\n//      https://twitter.com/Rainmaker1973/status/1661348007739027456\n//\n//  Do you see the circles? Or do you see the square \"coffin\" shapes? If you're having\n//  trouble seeing the circles, check out the \"b\" version of this shader and press the\n//  space bar.\n//\n//      Coffin Illusion 2b       https://www.shadertoy.com/view/dldSzr\n//\n//  Or check out the black-and-white, slightly shorter versions here:\n//\n//      Coffin Illusion 1a       https://www.shadertoy.com/view/mtdXRn\n//      Coffin Illusion 1b       https://www.shadertoy.com/view/dltXzn\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u = trunc(1e2 * u / iResolution.y) / 1e2;\n    \n    vec2 c = trunc(u * 4. - .14) / 4. + .14,\n         d = u - c;\n         \n    O = fract(4e4*sin((dot(d, d) < .01 ? d.yx * vec2(1, -1) + c : u).y + vec4(1,7,4,0)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdSzr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[888, 888, 924, 924, 1142]]}
{"id": "dltXzn", "name": "Coffin Illusion 1b (208 ch)", "author": "fenix", "description": "Do you see the circles? Or do you see the square \"coffin\" shapes?\n\n*press space to un-rotate the circles*\n\nhttps://twitter.com/Rainmaker1973/status/1661348007739027456", "tags": ["optical", "illusion", "codegolf", "reproduction"], "likes": 4, "viewed": 135, "published": 3, "date": "1684989855", "time_retrieved": "2024-07-30T17:54:06.483778", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this tweet:\n//\n//      https://twitter.com/Rainmaker1973/status/1661348007739027456\n//\n//  Do you see the circles? Or do you see the square \"coffin\" shapes? If you're having\n//  trouble seeing the circles, press the space bar. There's a more compact version here:\n//\n//      Coffin Illusion 1a       https://www.shadertoy.com/view/mtdXRn\n//\n//  Or try the more colorful versions:\n//\n//      Coffin Illusion 2a       https://www.shadertoy.com/view/mtdSzr\n//      Coffin Illusion 2b       https://www.shadertoy.com/view/dldSzr\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u = trunc(1e2 * u / iResolution.y) / 1e2;\n    \n    vec2 c = trunc(u * 4. - .14) / 4. + .14, // center of nearest circle\n         d = u - c;                          // delta to nearest circle\n    \n    O = vec4(fract(6e4*sin((\n        dot(d, d) < .01 && texelFetch(iChannel0,ivec2(32,0),0).x == 0.\n            ? d.yx * vec2(1, -1) + c\n            : u)).y));\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dltXzn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[845, 845, 881, 881, 1244]]}
{"id": "mtdXRn", "name": "Coffin Illusion 1a (165 ch)", "author": "fenix", "description": "Do you see the circles? Or do you see the square \"coffin\" shapes?\n\nhttps://twitter.com/Rainmaker1973/status/1661348007739027456", "tags": ["optical", "illusion", "codegolf", "reproduction"], "likes": 5, "viewed": 194, "published": 3, "date": "1684989835", "time_retrieved": "2024-07-30T17:54:07.621736", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by this tweet:\n//\n//      https://twitter.com/Rainmaker1973/status/1661348007739027456\n//\n//  Do you see the circles? Or do you see the square \"coffin\" shapes? If you're having\n//  trouble seeing the circles, try the \"b\" version of this shader and press the space\n//  bar.\n//\n//      Coffin Illusion 1b       https://www.shadertoy.com/view/dltXzn\n//\n//  Or try the more colorful versions:\n//\n//      Coffin Illusion 2a       https://www.shadertoy.com/view/mtdSzr\n//      Coffin Illusion 2b       https://www.shadertoy.com/view/dldSzr\n// \n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u = trunc(1e2 * u / iResolution.y) / 1e2;\n    \n    vec2 c = trunc(u * 4. - .14) / 4. + .14, // center of nearest circle\n         d = u - c;                          // delta to nearest circle\n         \n    O = vec4(fract(6e4*sin((dot(d, d) < .01 ? d.yx * vec2(1, -1) + c : u).y)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdXRn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[852, 852, 888, 888, 1176]]}
{"id": "dttSRr", "name": "Simple Orb Lavalamp", "author": "Dancetothetower", "description": "my first shader \nfeaturing \nO.R.B.S. ", "tags": ["basic", "orbs"], "likes": 0, "viewed": 210, "published": 3, "date": "1684982751", "time_retrieved": "2024-07-30T17:54:08.640013", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 d1 = vec2(length(uv.y),length(uv.x));\n    float d = length(uv);\n    float c = d;\n    vec3 colo = 0.5 + 0.4*cos(uv.xyx+iTime*0.05*vec3(1,2,3)+vec3(1,2,3));\n    vec3 colo2 = vec3(0.3 + 0.5*uv.x+sin(iTime*0.25+uv.x),0.35*uv.y+asin(iTime*0.15),0.35+0.5*uv.y*uv.x+cos(iTime*0.22));\n    vec3 colo3 = vec3(0.23 + 0.5*uv.y+cos(iTime*0.20),0.35*uv.x+sin(iTime*0.1+uv.y),0.35+0.5*uv.y*uv.x+sin(iTime*0.20));\n    vec3 f = colo;\n    int p=1;\n    int i=1;\n    vec2 n= vec2(sin(iTime*0.022), cos(iTime*0.022));\n    if(d > .5){ \n        uv.y -= 0.0; // change to move the background. at -0.5 you get a lava lamp like effect\n        uv *= 1.7; //scale of the background\n        uv *= uv;\n        //uv *= abs(uv)+ 0.1;\n        //uv -= n*max(0.,d)*2.;\n\n        for(p=1; p < 6; p++){\n            for(i=1; i < 6; i++){\n                uv.x += sin(float (i)*0.025)*0.02 + sin(iTime*0.013 + float (i+100 + p*53)) * 1.  ;\n                uv.y += cos(float (p)*0.5)*0.02 + cos(iTime*0.02+ float (p*100 + i*27)) * 1.  ;\n                d = length(uv);\n                if(d < .29 + sin(iTime*0.02+float(i+p))*0.05) //change the .2 to change the size of the background orbs\n                    f = vec3(sin(float(400*p*i) )*0.3+0.35,0.,sin(float(3000*p*i) )*0.35+0.3)+ vec3(uv.x*0.5);\n        }}}\n    uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv -= 0.6;\n    uv *= 2.5;\n    uv.x -= 0.5;\n    \n    if(d < .5) { //change the .5 to change the size of the central big orb\n        f = (colo + colo2 + colo3)*0.3 + vec3(0.1+uv.x*0.5);\n        for(i=1; i < 10; i++){\n            uv -= vec2(cos(iTime*0.21 + float(i*1000))*0.5, sin(iTime*0.31+float(i*10000))*0.8);\n            d = length(uv);\n            if(d < (.2 + sin(iTime*0.25 + float(i*10000))*0.05)){ //change the .2 to change the size of the orbs in the orb\n                 f = vec3(sin(float(i)*1000.)*0.2 + uv.x*0.5)+ vec3(sin(iTime*0.13+float(i*2845)),0.2,0.2);}\n    \n            }\n    } \n    fragColor = vec4(f ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2199]]}
{"id": "dldSRr", "name": "vegeta", "author": "jorge2017a2", "description": "vegeta", "tags": ["vegeta"], "likes": 15, "viewed": 199, "published": 3, "date": "1684981558", "time_retrieved": "2024-07-30T17:54:09.498717", "image_code": "//por jorge2017a2\n///vegeta \n//24-may-2023-\n//tiene algunas errores la funcion Lineas04, pero no logre encontrar.\n//The Lineas04 function has some bugs, but I couldn't find it.\n//not optimized!!!\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n#define PI 3.141516\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec2 p0_; //punto uv\nvec2 pt0; //punto pos0\nfloat DistL;\nvec3 ColL;  //color linea\nvec3 ColO;  //color salida Out\n\nvoid L( vec2 p1)  //Lineto\n{   float l1=sdSegment(p0_, pt0, p1 );\n    DistL=min(DistL,l1);\n    ColO= DrawFigBorde(ColL, ColO,DistL); \n    pt0 = p1;\n}\nvoid SZ(vec2 p ){pt0 = p;DistL=9999.9; }\nvoid M(vec2 p1){pt0 = p1;}  //Moveto\nvoid C(vec3 pcol){ColL=pcol;}  //Set color\n\n\n\nfloat sdPoly9 POLY(9)\nvec2  pt9[9]=vec2[](\nvec2(1.81,1.78),vec2(1.79,1.55),vec2(1.04,0.89),vec2(0.47,0.56),vec2(0.2,0.56),\nvec2(0.03,0.68),vec2(0.02,1.11),vec2(0.37,1.05),vec2(1.81,1.78)  );\n\nfloat sdPoly12 POLY(12)\nvec2  pt12[12]=vec2[](\nvec2(2.39,1.75),vec2(2.68,1.73),vec2(3.86,1.06),vec2(4.64,0.74),vec2(5.01,0.63),\nvec2(5.63,0.55),vec2(5.4,0),vec2(4.52,0.24),vec2(2.55,1.53),vec2(2.31,1.61),\nvec2(2.31,1.61),vec2(2.39,1.75)  );\n\n\nfloat sdPoly10R POLY(10)\nvec2  pt10R[10]=vec2[](\nvec2(0., 0.01), vec2(5.75, 0), vec2(5.73, 4.12), vec2(5.68, 4.17),vec2(1.35, 4.18),\nvec2(1.19, 4.03), vec2(0.78, 2.81), vec2(0.4, 1.91),vec2(0.01, 1.31),vec2(0., 0.01) );\n\n\nfloat sdPoly6a POLY(6)\nvec2  pt6a[6]=vec2[](\nvec2(1.95, 1.85), vec2(1.87, 2.03), vec2(0.93, 1.97), vec2(0.63, 1.55),vec2(0.34, 1.05),\nvec2(1.95, 1.85) );\n\nfloat sdPoly7a POLY(7)\nvec2  pt7a[7]=vec2[](\nvec2(2.9, 1.65),vec2(3.07, 1.85), vec2(3.11, 1.86), vec2(4.67, 1.42), vec2(5.01, 0.64),\n vec2(4.29, 0.86),vec2(2.9, 1.65) );\n\n\n\nvec3 OjosIzqyDer(vec2 p ,vec3 col ) \n{\nfloat sd6;\n\n    sd6 = sdPoly6a(p, pt6a);\n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, sd6);\n\nfloat r1, d1;\nr1 = 0.2;\nfloat t=iTime;\nvec2 posa=vec2(-0.3-0.5*sin(iTime),-0.2*sin(t));\nvec2 posb=vec2(0.5-0.5*sin(iTime),0.2*sin(t));\n\nvec2 p1 = vec2(1.55, 1.63);\nd1 = sdCircle(p- p1-posa, r1);\n//---------;\n    d1 = intersectSDF(sd6, d1);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d1);\n\n\n    float sd7 = sdPoly7a(p, pt7a);\n    col = DrawFigBorde(vec3(1.0, 1.0, 1.0), col, sd7);\n    r1 = 0.25;\n    p1 = vec2(3.52, 1.29);\n    d1 = sdCircle(p- p1-posb, r1);\n    d1 = intersectSDF(d1, sd7);\n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, d1);\n    \n    return col;\n}\n\nvec3 Rostro(vec2 p ,vec3 col )\n{\nvec3 colc;\n colc = vec3(0.96, 0.73, 0.57);\n    float sd10 = sdPoly10R(p, pt10R);\n    col = DrawFigBorde(colc, col, sd10);\n    return col;\n}\n\nvec3 Lineas01(vec2 p,vec3 col)\n{\nvec2 p1,p2, p3,p4, p5, p6,p7;\nvec2 p8, p9,p10, p11,p12,p13,p14;\n\nColO = col;\np0_ = p;\n\np1 = vec2(2.15, 2.18);p2 = vec2(2.09, 2.59);\np3 = vec2(1.98, 2.9);p4 = vec2(1.85, 3.21);\np5 = vec2(1.71, 3.43);p6 = vec2(1.71, 3.42);\np7 = vec2(1.73, 3.5);p8 = vec2(1.79, 3.55);\np9 = vec2(1.89, 3.58);p10 = vec2(2, 3.56);\np11 = vec2(2, 3.56);p12 = vec2(2, 3.57);\np13 = vec2(2.49, 3.34);p14 = vec2(2.62, 3.31);\n\nSZ(p1);  M(p1); C(vec3(0.0));\nL(p1);  L(p2);L(p3); L(p4); L(p5); L(p6);;\n L(p7);L(p8); L(p9);L(p10); L(p11); L(p12);;\n L(p13); L(p14);;\ncol = ColO;\n    return  col;\n}\n\nvec3 Lineas02(vec2 p ,vec3 col )\n{\nvec2 p1,p2, p3,p4, p5, p6,p7;\np1 = vec2(2, 1.3);\np2 = vec2(2.02, 1.48);\np3 = vec2(2.11, 1.83);\np4 = vec2(2.28, 1.84);\np5 = vec2(2.39, 1.79);\np6 = vec2(2.3, 1.61);\np7 = vec2(2.19, 1.18);\np0_ = p;\nColO = col;\n SZ(p1);  M(p1);  C(vec3(0.0));\n L(p1);  L(p2);  L(p3);  L(p4);  L(p5);  L(p6);  L(p7);;\n////otra linea;\np1 = vec2(1.83, 1.22);\np2 = vec2(1.81, 1.76);\np3 = vec2(2.02, 1.86);\np4 = vec2(2.08, 1.92);\n//ColO = col;\n SZ(p1);  M(p1);  C(vec3(0.0));\n L(p1);  L(p2);  L(p3);  L(p4);;\ncol = ColO;\ncol = ColO;\n    return col;\n}\n\nvec3 Lineas03(vec2 p,vec3 col)\n{\n////lineas debajo de ojo;\nvec2 p1, p2, p3, p4, p5, p6;\n\n\n//linea1;\np1 = vec2(0.97, 2.23);\np2 = vec2(1.29, 2.21);\np3 = vec2(1.58, 2.2);\n\np0_ = p;\nColO = col;\n SZ(p1); M(p1); C(vec3(0.0));\n L(p1); L(p2); L(p3);;\ncol = ColO;\n//linea 2;\np1 = vec2(1.27, 2.27);\np2 = vec2(1.62, 2.23);\np3 = vec2(1.6, 2.27);\np4 = vec2(1.49, 2.27);\np5 = vec2(1.79, 2.26);\np6 = vec2(1.95, 2.29);\np0_ = p;\nColO = col;\n\n\nSZ(p1); M(p1); C(vec3(0.0));\nL(p1); L(p2); L(p3); L(p4);  L(p5);  L(p6);;\ncol = ColO;\n\n//Linea 3;\np1 = vec2(2.41, 2.26);\np2 = vec2(2.57, 2.12);\np3 = vec2(2.61, 2.14);\np0_ = p;\nColO = col;\nSZ(p1); M(p1); C(vec3(0.0));\n L(p1); L(p2); L(p3);;\ncol = ColO;\n////Linea 4;\np1 = vec2(2.85, 1.98);\np2 = vec2(2.77, 2.13);\np3 = vec2(2.97, 2.24);\np4 = vec2(3.23, 2.09);\np5 = vec2(3.66, 1.88);\np0_ = p;\nColO = col;\n SZ(p1);  M(p1);  C(vec3(0.0));\n L(p1); L(p2); L(p3); L(p4); L(p5);;\ncol = ColO;\n////linea 5;\np1 = vec2(3.24, 2.11);\np2 = vec2(3.66, 1.91);\np3 = vec2(3.67, 1.91);\np4 = vec2(4.19, 1.76);\np0_ = p;\nColO = col;\nSZ(p1);  M(p1);  C(vec3(0.0));\n L(p1);  L(p2);  L(p3);  L(p4);;\ncol = ColO;\n\n//linea 6;\np1 = vec2(3.47, 2.06);\np2 = vec2(4, 1.85);\np3 = vec2(4.6, 1.73);\np0_ = p;\nColO = col;\n SZ(p1);  M(p1);  C(vec3(0.0));\n L(p1);  L(p2);  L(p3);;\ncol = ColO;\n\n//linea 7;\np1 = vec2(3.94, 1.93);\np2 = vec2(4.55, 1.8);\np3 = vec2(4.98, 1.72);\np4 = vec2(5.33, 1.7);\np0_ = p;\nColO = col;\n SZ(p1);  M(p1);  C(vec3(0.0));\n L(p1);  L(p2);  L(p3);  L(p4);;\ncol = ColO;\n\n    return col;\n}\n\n\n\nvec3 Lineas04(vec2 pp,vec3 col )\n{\nvec2 p1, p2, p3, p4, p5, p6;\nvec2 p=pp;\n//linea 1;\np1 = vec2(1.78, 0.86);\np2 = vec2(1.63, 0.62);\np3 = vec2(1.47, 0.44);\np4 = vec2(1.34, 0.35);\np0_ = p;\nColO = col;\nSZ(p1); M(p1);C(vec3(0.0));\nL(p1);L(p2);L(p3);L(p4);\ncol = ColO;\n \n\n//linea 2;\np1 = vec2(2.41, 0.92);\np2 = vec2(2.92, 0.23);\np3 = vec2(2.69, 0.61);\np4 = vec2(3.18, 0.13);\n\np0_ = p;\nColO = col;\nSZ(p1);M(p1);C(vec3(0.0));\nL(p1);L(p2);L(p3);L(p4);\ncol = ColO;\n\n//linea 4;\np1 = vec2(2.41, 2.28);\np2 = vec2(2.54, 2.14);\np3 = vec2(2.6, 2.14);\n\np0_ = p;\nColO = col;\nSZ(p1);M(p1);C(vec3(0.0));\nL(p1);L(p2);L(p3);\ncol = ColO;\n\n\n////linea 5;\np1 = vec2(2.35, 3.78);\np2 = vec2(2.53, 3.82);\np3 = vec2(2.88, 3.67);\np4 = vec2(3.25, 3.65);\np5 = vec2(3.24, 3.65);\np6 = vec2(3.35, 3.68);\n\np0_ = p;\nColO = col;\nSZ(p1); M(p1);C(vec3(0.0));\nL(p1);L(p2);L(p3);L(p4);L(p5);L(p6);\ncol = ColO;\n\n\n//linea 6;\np1 = vec2(3.63, 3.53);\np2 = vec2(3.76, 3.7);\np3 = vec2(3.74, 3.92);\n\np0_=p;\nColO = col;\nSZ(p1); M(p1);C(vec3(0.0));\nL(p1); L(p2);L(p3);\ncol = ColO;\n\n\n//linea 7;\np1 = vec2(2.66, 4.16);\np2 = vec2(2.95, 4.08);\np3 = vec2(3.23, 4.23);\np4 = vec2(2.92, 4.13);\np5 = vec2(2.85, 4.13);\np6 = vec2(3.11, 4.25);\n\np0_= p;\nColO = col;\n SZ(p1);M(p1);C(vec3(0.0));\n L(p1);L(p2);L(p3);L(p4);L(p5);L(p6);\ncol = ColO;\n//-----;\n    return col;\n}\n\nvec3 CejaIzq(vec2 p ,vec3 col) \n{\n   float sd9;\n   sd9 = sdPoly9(p, pt9);\n   col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, sd9);\n    return col;\n}\n\nvec3 CejaDer(vec2 p ,vec3  col )\n{   float sd12 = sdPoly12(p, pt12);    \n    col = DrawFigBorde(vec3(0.0, 0.0, 0.0), col, sd12);\n    return col;\n}\n\nvec3 Vegeta(vec2 uv)\n{  vec3 col = vec3(0.19, 0.64, 0.37);\n    col = Rostro(uv, col);\n    col = OjosIzqyDer(uv, col);\n    col = Lineas01(uv, col);\n    col = Lineas02(uv, col);\n    col = Lineas03(uv, col);\n    col=(col+ Lineas04(uv, col))/2.0;   //bug\n    col = CejaIzq(uv, col);\n    col = CejaDer(uv, col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    DistL=9999.9;\n    uv*=2.1;\n    uv.y=2.1-uv.y;\n    uv.x+=1.6;\n    vec3 col=Vegeta(uv);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "float sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[718, 718, 780, 780, 906], [907, 907, 988, 988, 1116], [1118, 1118, 1182, 1182, 1253], [1257, 1257, 1304, 1304, 1331], [1332, 1332, 1375, 1375, 1402], [1403, 1403, 1451, 1451, 1479], [1482, 1498, 1546, 1546, 1624], [1626, 1626, 1661, 1661, 1684], [1686, 1686, 1723, 1723, 1795], [1797, 1797, 1849, 1849, 1956], [1958, 1958, 1983, 1983, 2002], [2003, 2003, 2028, 2028, 2047], [2048, 2048, 2084, 2084, 2112], [2115, 2115, 2180, 2180, 2490], [2608, 2608, 2636, 2636, 2757], [2758, 2758, 2775, 2775, 2798], [2799, 2799, 2815, 2815, 2825], [2827, 2836, 2854, 2854, 2865], [3867, 3867, 3905, 3905, 4574], [4576, 4576, 4608, 4608, 4748], [4750, 4750, 4782, 4782, 5346], [5348, 5348, 5382, 5382, 5907], [5909, 5909, 5941, 5967, 7404], [7408, 7408, 7442, 7442, 8713], [8715, 8715, 8748, 8748, 8860], [8862, 8862, 8896, 8896, 9008], [9010, 9010, 9032, 9032, 9332], [9334, 9334, 9391, 9391, 9611]]}
{"id": "dtdSRn", "name": "Screen Welding", "author": "QuantumSuper", "description": "Welding your screen with some pseudorandom sparks. \nPath can be changed in originShift() in Buffer A.", "tags": ["2d", "particles", "buffer"], "likes": 17, "viewed": 448, "published": 3, "date": "1684967375", "time_retrieved": "2024-07-30T17:54:10.298578", "image_code": "// Screen Welding 0.6.230524 by QuantumSuper\n// pseudorandom particles leaving traces on a buffer\n// \n\nvoid mainImage( out vec4 col, in vec2 fC){\n    col = getDat( iChannel0, fC);\n    col.rgb *= .5 + .5*abs( cos( .06*iTime + PI/vec3(.5,2.,4.) - PI/3.)); //color shift \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// BUFFER A (0.61) of Screen Welding by QuantumSuper\n// draw points on lots of different parabolas & use unclamped buffer as heatmap history\n// \n\n#define numOfParts 150.\n#define aTime iTime/64.\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nvec2 parametricParabola(float t, vec2 seed){\n    float d = .1 + 3.*hash21(.678*seed.yx); //y-stretch\n    float c = sign(t) * (.01 + 2.*hash21(.987*seed)); //maximum shift\n    float b = abs(c) + hash21(.285*seed) + .001; //x-stretch\n    float a = c*c/b/b; //origin height\n    t -= c/b;\n    return vec2( b*t+c, (a-t*t)*d);\n}\n\nfloat lightUp(float dist, vec2 modif){ //light around dist=0\n    return 6.*smoothstep(.025*modif.x, .0, dist)+clamp(.00008/dist/dist,.0,1.)+(1.+modif.y)*.0001/dist; //combined semi-hard shape with semi-soft & soft glow\n}\n\nvec2 originShift(){ //coordinate shift to create shapes\n    vec2 s;\n    float bTime = iTime/8.;\n    \n    if (fract(aTime)<.25)\n        s = (fract(bTime)<.5)? //L\n            vec2( .5, 2.*fract(2.*bTime)-1.):\n            vec2( fract(-2.*bTime)-.5, 1);\n            \n    else if (fract(aTime)<.5)\n        s = vec2(sin(2.*PI*bTime),cos(2.*PI*bTime)); //circle\n        \n    else if (fract(aTime)<.75)\n        s = (fract(bTime)<.5)? //v\n            vec2(.5, 1) * (2.*fract(2.*bTime)-1.) - vec2(.5,0):\n            vec2(.5,-1) * (2.*fract(2.*bTime)-1.) + vec2(.5,0);\n            \n    else\n        s = (fract(bTime)<.4)? //E\n            vec2( .5, 2.*fract(bTime)/.4-1.):\n            vec2( fract(-bTime/.2)-.5, -floor((fract(bTime)-.6)/.2));\n\n    return s;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // View definition\n    vec2 uv = 3. * (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -3 to 3, square aspect ratio       \n    uv += originShift(); //shape definitions\n\n    // Draw particles\n    float mySpeed, \n          myTime;\n    vec2 myMod,\n         seed = vec2(iTime);\n    vec3 myColor,\n         col = vec3(0);   \n    \n    for (float n=0.;n++<numOfParts;){\n        myTime = iTime/2. + n/numOfParts;\n        seed = vec2(ceil(myTime)*.123,ceil(myTime)*.456);\n        mySpeed = sign(.5-hash21(seed+.123*n)) * (1.5+2.5*hash21(seed*n*.456));\n        myMod = vec2( hash21(seed/n*.123), 5.+25.*hash21(seed/n*.456));\n        myColor = fract(-myTime) * vec3( 1.+fract(myTime), .5+.6*fract(-myTime), .2+fract(-myTime)*fract(-myTime));\n        col += myColor * lightUp( length( uv - parametricParabola( .7*fract(myTime)*mySpeed, seed*n)), myMod);\n\t} \n    \n    // Add buffer\n    vec3 amp = (fract(aTime*4.)<.99)? //zoom animation\n        getDat( iChannel0, fragCoord).rgb: //read buffer\n        getDat( iChannel0, fragCoord*1.04+iResolution.xy*(1.-1.04)/2.).rgb; //read scaled buffer\n    col += 1.5/numOfParts *  amp*amp*amp; //overlay on image\n    \n    // Utility\n    //col += step(fract(uv.x)-.005,.01)+step(fract(uv.y)-.005,.01); //grid\n\n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON (0.1) of Screen Welding by QuantumSuper\n// \n// \n\n#define PI 3.14159265359\n\n#define getDat(buf,addr) texelFetch( buf, ivec2(addr), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 145, 145, 270]]}
{"id": "DltSzr", "name": "Progressive Dual Kawase Blur", "author": "MartinRGB", "description": "test progressive blur,my article about this effect:https://martinrgb.github.io/blog/#/Namedrop_Animation", "tags": ["blur", "kawase", "dualfiltering"], "likes": 6, "viewed": 834, "published": 3, "date": "1684962559", "time_retrieved": "2024-07-30T17:54:11.142322", "image_code": "// Simply display the texture\n//\n// Try switching the iChannel0 to Buffer A, B, C and D to see the intermediate steps\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / (iResolution.xy));\n    \n    if(uv.y>progressAVal){\n        vec4 origCol = texture(iChannel1, vec2(uv.x,uv.y));\n        vec4 sampleCol = texture(iChannel0, vec2(uv.x,uv.y));\n        //mix by progress position\n        fragColor = origCol;\n    }\n    else{\n        fragColor = texture(iChannel0, vec2(uv.x,uv.y));\n    }\n    \n    float handleBarVal;\n    \n    if(abs(uv.y-progressAVal) > 0.005){\n        handleBarVal = 0.;\n    }\n    else{\n        handleBarVal = 1.;\n    }\n    \n    \n    fragColor = mix(fragColor,vec4(0.,0.,0.,1.),handleBarVal);\n    \n    //fragColor = texture(iChannel0, vec2(uv.x,uv.y));\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// downsample pass 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / iResolution.xy) * bufferADownScale;\n    float progressUV = (progressAVal-uv.y);\n    float clampedProgress = max(0.,progressUV);\n    clampedProgress = curveInterplation(clampedProgress);\n    vec2 halfpixel = pixelOffset / (iResolution.xy / (2.0 + (1.-clampedProgress) * 1.));\n    float offset = blurOffset*clampedProgress; \n\n    vec4 sum = texture(iChannel0, uv) * 4.0;\n    \n    sum += texture(iChannel0, uv - halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset);\n    sum += texture(iChannel0, uv - vec2(halfpixel.x, -halfpixel.y) * offset);\n\n    fragColor = sum / 8.0;\n    \n    //fragColor = sum / 8.0;\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// downsample pass 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / iResolution.xy) * bufferADownScale;\n    float progressUV = (progressBVal-uv.y);\n    float clampedProgress = max(0.,progressUV);\n     clampedProgress = curveInterplation(clampedProgress);\n    vec2 halfpixel = pixelOffset / (iResolution.xy / (2.0 + (1.-clampedProgress) * 1.));\n    float offset = blurOffset*clampedProgress; \n\n    vec4 sum = texture(iChannel0, uv) * 4.0;\n    \n    sum += texture(iChannel0, uv - halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset);\n    sum += texture(iChannel0, uv - vec2(halfpixel.x, -halfpixel.y) * offset);\n    \n    fragColor = sum / 8.0;\n    \n    //fragColor = sum / 8.0;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// upsample pass 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / (iResolution.xy * bufferCUpScale));\n    float progressUV = (progressCVal - uv.y);\n    float clampedProgress = max(0.,progressUV);\n     clampedProgress = curveInterplation(clampedProgress);\n    vec2 halfpixel = pixelOffset / (iResolution.xy * (1. + 3.*clampedProgress));\n    float offset = blurOffset*clampedProgress;\n\n    vec4 sum = texture(iChannel0, uv +vec2(-halfpixel.x * 2.0, 0.0) * offset);\n    \n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(halfpixel.x * 2.0, 0.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, -halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, -halfpixel.y) * offset) * 2.0;\n\n    fragColor = sum / 12.0;\n    \n    //fragColor = sum / 12.0;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// upsample pass 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / (iResolution.xy * bufferDUpScale));\n    float progressUV = (progressDVal - uv.y);\n    float clampedProgress = max(0.,progressUV);\n    clampedProgress = curveInterplation(clampedProgress);\n    vec2 halfpixel = pixelOffset / (iResolution.xy * (1. + 3.*clampedProgress));\n    float offset = blurOffset*clampedProgress;\n\n    vec4 sum = texture(iChannel0, uv +vec2(-halfpixel.x * 2.0, 0.0) * offset);\n    \n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(halfpixel.x * 2.0, 0.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, -halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, -halfpixel.y) * offset) * 2.0;\n\n    fragColor = sum / 12.0;\n    \n    //fragColor = sum / 12.0;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define bufferADownScale 2.\n#define bufferBDownScale 2.\n#define bufferCUpScale 2.\n#define bufferDUpScale 2.\n#define blurOffset 24.\n#define pixelOffset 8.\n\n#define progressAVal max(0.33,iMouse.y/iResolution.y)\n#define progressBVal progressAVal/bufferADownScale //0.125\n#define progressCVal progressBVal/bufferBDownScale //0.125/4.\n#define progressDVal progressCVal*bufferCUpScale\n\nfloat curveInterplation(in float val){\n    //return(exp(val/1.45) -1.);\n    return 1. - exp(-val/12.);\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 176, 176, 811]]}
{"id": "mt3SRr", "name": "simple droste", "author": "Trixelized", "description": "Good webcam or video source recommended", "tags": ["spiral", "droste", "recursive", "webcam"], "likes": 0, "viewed": 396, "published": 3, "date": "1684944343", "time_retrieved": "2024-07-30T17:54:11.934205", "image_code": "#define TAU 6.28318530718\n\n// Magnification Amount\n#define MAG 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sample UV (offset for centering the spiral later)\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    // Initial zoom-in\n    uv *= pow(MAG, -1.0);\n    \n    // Create spiral multiplication\n    uv *= ((atan(uv.x, uv.y) / TAU) + 0.5) * (MAG - 1.0) + 1.0;\n    \n    // Fetch the chroma key color\n    vec4 chromaCol = texture(iChannel0, vec2(0.5, 0.5));\n    \n    // Loop for recursion\n    for (int i=0; i<10; i++) {\n        vec4 col = texture(iChannel0, uv + 0.5);\n        \n        // If similar color\n        if (length(col - chromaCol) < 0.125) {\n            \n            // Zoom out UV\n            vec2 newUv = uv * MAG;\n\n            // If in frame, repeat loop\n            if ((abs(newUv.x) < 0.5) && (abs(newUv.y) < 0.5)) {\n                uv = uv * MAG;\n                continue;\n            }\n            \n        }\n        break;\n        \n    }\n    \n    \n    // Return the final color\n    fragColor = texture(iChannel0, uv + 0.5);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3SRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 125, 182, 1072]]}
{"id": "dtcXzn", "name": "Bounce Equation", "author": "SnoopethDuckDuck", "description": "This uses a geometric series to copy-paste parabolas of decreasing heights next to each other.\nThe logic is largely reused from this shader: https://www.shadertoy.com/view/mdtXDN\nIt's very similar to this video: https://www.youtube.com/watch?v=IKVM4DAQ840", "tags": ["ball", "bounce", "motion", "parabola", "desmos"], "likes": 9, "viewed": 181, "published": 3, "date": "1684941340", "time_retrieved": "2024-07-30T17:54:12.751022", "image_code": "#define res iResolution.xy\n#define ss(a) smoothstep(-1./res.y, 1./res.y, a)\n\n// Rough explanation + neater equations:\n// https://www.desmos.com/calculator/obwtqgefsh\nfloat bounce(float a, float n, float x) {   \n    float s = sqrt(a);\n    // Remove \"(1.-s) *\" to make all bounces occur in [0,1] domain\n    x = 1. - min(1. - pow(s, n), (1.-s) * x) ;  \n    float p = pow(s, floor(log2(x) / log2(s)));\n    float m = (p - x) / (1.-s); \n    return 4. * m * (p - m);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0. * res) / res.y;\n    uv *= 2.;\n    \n    // Change me!\n    float a = 0.5;  // Percentage of previous bounce's height, a in [0,1]\n    float n = 6.;   // Number of bounces (any value >= 0)\n    float r = 0.04; // Ball radius\n    \n    float t = mod(iTime, 3.8);\n    float y = 0.5 * bounce(a, n, t);\n           \n    //r += 0.15 * y;\n    vec2 p  = vec2(t, y + r);\n    float d = length(uv - p);\n    float s = ss(r - d);\n    \n    float yw = 0.5 * bounce(a, n, uv.x);\n    float sw = ss(yw - uv.y + r);\n    \n    vec3 col = vec3(s, s, sw);\n    \n    O = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 166, 207, 207, 461], [463, 463, 505, 505, 1084]]}
{"id": "mlV3Wt", "name": "Periodic Fractal circles", "author": "timmaffett", "description": "fork of @jcponcemath and just vary d with some time and mouse factors to explore his pattern.\nadditionally variably invert color [code]abs(cos(iTime/2.0)-finalColor)[/code]", "tags": ["space", "points"], "likes": 1, "viewed": 117, "published": 3, "date": "1684940029", "time_retrieved": "2024-07-30T17:54:13.589778", "image_code": "// Fork of \"Fractal circles\" by jcponcemath. https://shadertoy.com/view/dtKGWt\n// 2023-05-24 02:06:30\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.198, 0.438, 0.698);\n    vec3 b = vec3(-0.262, 0.208, 0.238);\n    vec3 c = vec3(2.238, 2.168, 1.000);\n    vec3 d = vec3(-0.052, 0.333, 0.667);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : (2.0*(iMouse.xy-iResolution.xy))/iResolution.xy;\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv =(fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    \n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 3.0; i ++){\n        uv = fract(uv * 2.0)-0.5;\n    \n        float d = length(uv);\n        \n        vec3 col = palette(length(uv0) - iTime * 0.35);\n    \n        d -= 0.35+(sin(fract(iTime)/10.0*mouse.x)-(cos(iTime/20.0/mouse.y+i))+sin(fract(-iTime)/10.0*mouse.y)-(cos((i+3.0)*iTime/43.0)));\n        //d = abs(d);\n    \n        d = 0.03/d;\n    \n        finalColor += col * d;\n    }\n\n    // Output to screen\n    fragColor = vec4(abs(cos(iTime/2.0)-finalColor), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlV3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 147, 172, 172, 378], [381, 381, 438, 438, 1220]]}
{"id": "dtcSzn", "name": "honeycomb truchet tiling", "author": "IWBTShyGuy", "description": "my first honeycomb truchet tiling", "tags": ["truchet", "honeycomb"], "likes": 13, "viewed": 166, "published": 3, "date": "1684939924", "time_retrieved": "2024-07-30T17:54:14.413576", "image_code": "// Copyright © 2023 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.1415926583;\n\nconst vec4 COLOR0 = vec4(0.1, 1.0, 0.2, 1.0);\nconst vec4 COLOR1 = vec4(1.0, 0.5, 0.0, 1.0);\n\nfloat d2 (vec2 x, vec2 y) { x -= y; return dot(x, x); }\nvoid honeycomb(inout vec2 u, out vec2 id) {\n    const mat2 M = mat2(2, 0, 1, sqrt(3.0)) / 2.0;\n    const vec2 A = M[0], B = M[1], O = A.yy;\n\n    id = floor(inverse(M) * u);\n    vec2 v = u - M * id;\n    float a = d2(v, O), b = d2(v, A), c = d2(v, B),\n    d = d2(v, A + B), e = min(min(min(a, b), c), d);\n    id += e == a ? O : e == b ? A : e == c ? A.yx : A.xx;\n    u = u - M * id;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b) {\n    vec2 x = p - a, y = b - a;\n    return length(x - clamp(dot(x, y) / dot(y, y), 0., 1.) * y);\n}\n\nvec2 vertex(int i) {\n    float t = float(i) * PI / 3.0;\n    return vec2(-sin(t), cos(t)) / sqrt(3.0);\n}\n\nfloat tile0(in vec2 U) {\n    float dist = abs(length(U - vertex(0)) - sqrt(3.0) / 6.0);\n    dist = min(dist, sdLine(U, (vertex(1) + vertex(2)) / 2.0, (vertex(4) + vertex(5)) / 2.0));\n    dist = min(dist, abs(length(U - vertex(3)) - sqrt(3.0) / 6.0));\n    return dist - sqrt(3.0) / 18.0;\n}\n\nfloat tile1(in vec2 U) {\n    float dist = 100.0;\n    for (int i = 0; i < 6; i++)\n        dist = min(dist, length(U - vertex(i)));\n    return sqrt(3.0) / 9.0 - dist;\n}\n\nfloat tile2(in vec2 U) {\n    float dist = length(U - (vertex(1) + vertex(2)) / 2.0);\n    dist = min(dist, length(U - (vertex(4) + vertex(5)) / 2.0));\n    dist = min(dist, abs(length(U - vertex(1) - vertex(2)) - sqrt(3.0) / 2.0));\n    dist = min(dist, abs(length(U - vertex(4) - vertex(5)) - sqrt(3.0) / 2.0));\n    return dist - sqrt(3.0) / 18.0;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    U = U * 7.0 / iResolution.y + iDate.w * 0.5;\n    vec2 id;\n    honeycomb(U, id);\n\n    vec2 rand = hash22(id);\n    mat2 rot = mat2(-1, sqrt(3.0), -sqrt(3.0), -1) / 2.0;\n    if (rand.x < 1.0 / 3.0) U = rot * U;\n    if (rand.x < 2.0 / 3.0) U = rot * U;\n\n    float dist;\n    switch (int(rand.y * 3.0)) {\n        case 0: dist = tile0(U); break;\n        case 1: dist = tile1(U); break;\n        case 2: dist = tile2(U); break;\n    }\n    float d = 6.0 / iResolution.y;\n    float x = smoothstep(-d, d, dist);\n    O = mix(COLOR0, COLOR1, x);\n}", "image_inputs": [], "common_code": "// Hash without Sine https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcSzn.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[203, 203, 230, 230, 258], [259, 259, 302, 302, 641], [643, 643, 681, 681, 779], [781, 781, 801, 801, 884], [886, 886, 910, 910, 1174], [1176, 1176, 1200, 1200, 1342], [1344, 1344, 1368, 1368, 1691], [1693, 1693, 1732, 1732, 2269]]}
{"id": "dtcSRn", "name": "cheap bicubic evaluation", "author": "FabriceNeyret2", "description": "Did you know we can evaluate a 2D bicubic with just 4 fetches rather than 16 ? → top-left.\ntop-right: cubic smoothstep between values\nbottom: bilinear, nearest. \nFrom GPU Gems2 \"Fast Third-Order Texture Filtering\"\nextend easily to 3D. But B-Spline, not CR", "tags": ["2d", "bicubic", "interpolation"], "likes": 29, "viewed": 507, "published": 3, "date": "1684936872", "time_retrieved": "2024-07-30T17:54:15.331123", "image_code": "// ref: https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-20-fast-third-order-texture-filtering\n// code & discussion:   https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl/42179924#42179924\n// ( thanks Mathéo for pointing ! :-) )\n\n#define CH   iChannel0                       // try me ! :-)\n#define R    vec2(textureSize(CH,0))         // texture size\n#define T(d) texture(CH, (I+d) / R )         // fetch pixel I+offset d\n\nvec4 cubic(float v){                         // prepare cubic coefficients for B-spline\n vec3  n = vec3(1,2,3) - v;\n return n*n*n / 6. * mat4x3(1,0,0, -4,1,0, 6,-4,1, -3,3,-1) + vec4(0,0,0,1);\n}\n// Catmull-Rom coefficients would allows true interpolation passing through values, but this would requires negative bilinear coefficients...\n\nvec4 biCubic(vec2 U )                        // ← the magic is here\n{\n    vec2 F = fract(U), I = floor(U);\n    vec4 X = cubic(F.x),\n         Y = cubic(F.y),\n         Z = vec4(X.yw, Y.yw),\n         s = vec4(X.xz, Y.xz) + Z,\n         d = vec4(-1,1,-1,1) +.5 + Z / s;\n\n    s.xz /= s.xz + s.yw;\n\n    return mix( mix( T(d.yw), T(d.xw), s.x),\n                mix( T(d.yz), T(d.xz), s.x), \n                s.z);\n}\n\nvec4 pseudoCubic(vec2 U )\n{\n    vec2 F = fract(U), I = floor(U);\n    F *= F*(3.-F-F);                          // = smoothstep\n    vec4 d = vec4(.5,-.5,.5,-.5) + 1.;\n    return mix( mix( T(d.yw), T(d.xw), F.x),  // = texelFetch\n                mix( T(d.yz), T(d.xz), F.x), \n                F.y);\n\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 r = iResolution.xy,\n         U = u/8.; // + iTime;\n    O =  u.x < r.x*.6\n           ? u.y > r.y*.4 \n                     ? biCubic( U )                          // true biCubic\n                     : texture(CH, U/R )                     // bilinear = T(I+F)\n           : u.y > r.y*.4 \n                     ? pseudoCubic( U )                      // smoothstep between pixels = T(I+smoothstep(F))\n                     : texture(CH, (floor(U)+.5)/R );        // nearest  = T(I+.5) = texelFetch(iChannel0, ivec2(mod(U,R)), 0 );\n\n // O = .5+.5*sin(31.4*O);                 \n    O = sqrt(O.rrrr);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy/8.;\n    O = vec4( step( abs( length(u-R/2.) - R.y/4. ), .5) );\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[496, 496, 516, 583, 690], [834, 834, 905, 905, 1242], [1244, 1244, 1271, 1271, 1542], [1544, 1544, 1582, 1582, 2186]]}
{"id": "Dl3Xzn", "name": "Charging please wait", "author": "skaven", "description": "Charging please wait", "tags": ["charging"], "likes": 4, "viewed": 249, "published": 3, "date": "1684922177", "time_retrieved": "2024-07-30T17:54:16.214760", "image_code": "float opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n\n    float d = length(uv) + sin(iTime * 2.) * 0.01 - 0.2;\n    for (int i = 0;i < 6;i++) {\n        float fi = float(i);\n        float ltime = iTime * 0.5 + fi * 1.7341;\n        float timePart = fract(ltime);\n        float timeInt = round(ltime);\n        vec2 uv2  = uv + vec2(cos(timeInt), sin(timeInt)) * (0.4 - timePart * 0.4);\n        d = opSmoothUnion(length(uv2) + 0.05, d, 0.03);\n    }\n    \n    d = 1.-smoothstep(0.1,0.108,d);\n\n    // Output to screen\n    fragColor = vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3Xzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [162, 162, 219, 269, 865]]}
{"id": "Dt3SRr", "name": "Fork molten bis SionFletch 909", "author": "SionFletcher", "description": "some self-consistency improvements of ([url]https://www.shadertoy.com/view/MsGSRd[/url]).\ncornusammonis' latest fluid stuff reminded me to give that another try - also tried to use mipmaps, but looked better without in the end... use mouse to push fluid", "tags": ["simulation", "fluid", "flow", "cfd"], "likes": 1, "viewed": 194, "published": 3, "date": "1684921946", "time_retrieved": "2024-07-30T17:54:17.179182", "image_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD - with some self consistency fixes\n\n// drawing the liquid\n\n// same fluid as in \"Spilled\" - https://www.shadertoy.com/view/MsGSRd\n// ...but with self-consistent-ish velocity field\n// the previous method was just defined implicitely by the rotations on multiple scales\n// here the calculated velocity field is put back into the stored field\n\n// use mouse to push fluid, press I to init\n\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel1\n\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    return texture(iChannel2,dir.xzy)+.15;\n}\n\nvec4  getCol(vec2 uv) { return texture(iChannel0,scuv(uv)); }\nfloat getVal(vec2 uv) { return length(getCol(uv).xyz); }\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0); return vec2( getVal(uv+d.xy)-getVal(uv-d.xy),\n                                       getVal(uv+d.yx)-getVal(uv-d.yx) )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // calculate normal from gradient (the faster the higher)\n    vec3 n = vec3(-getGrad(uv,1.4/iResolution.x)*.02,1.);\n    n=normalize(n);\n\n    /*vec3 light = normalize(vec3(-1,1,2));\n    float diff=clamp(dot(n,light),0.,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0); spec=exp2(log2(spec)*24.0)*2.5;*/\n    \n    // evironmental reflection\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    vec3 dir=normalize(vec3(sc,-1.));\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(vec3(0),R.xzy,1.).xyz;\n    \n    // slightly add velocityfield to color - gives it a bit of a 'bismuty' look\n    vec4 col=getCol(uv)+.5;\n    col=mix(vec4(1),col,.35);\n    col.xyz*=.95+-.05*n; // slightly add some normals to color\n    \n\t//fragColor.xyz = col.xyz*(.5+.5*diff)+.1*refl;\n\tfragColor.xyz = col.xyz*refl;\n\tfragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD - with some self consistency fixes\n\n// ...the actual fluid simulation\n\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n#define SUPPORT_EVEN_ROTNUM\n\n#define keyTex iChannel2\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n\nconst float ang = PI2/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    float l=log2(dot(b,b))*sqrt(.125)*.0;\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(textureLod(iChannel0,((pos+p)/Res0.xy),l).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    vec2 b = cos(float(iFrame)*.3-vec2(0,1.57));  // vary curl-evaluation-points in time\n    vec2 v=vec2(0);\n    float bbMax=.5*Res0.y; bbMax*=bbMax; // take curls up to half screen size\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n            v+=p.yx*getRot(pos+p,-mh*b);\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    // perform advection\n    fragColor=textureLod(iChannel0,fract((pos-v*vec2(-1,1)*5.*sqrt(Res0.x/600.))/Res0.xy),0.);\n    \n    // feeding some self-consistency into the velocity field\n    // (otherwise velocity would be defined only implicitely by the multi-scale rotation sums)\n    fragColor.xy=mix(fragColor.xy,v*vec2(-1,1)*sqrt(.125)*.9,.025);\n    \n    // add a little \"motor\"\n    vec2 c=fract(scuv(iMouse.xy/iResolution.xy))*iResolution.xy;\n    vec2 dmouse=texelFetch(iChannel3,ivec2(0),0).zw;\n    if (iMouse.x<1.) c=Res0*.5;\n    vec2 scr=fract((fragCoord.xy-c)/Res0.x+.5)-.5;\n    // slowly rotating current in the center (when mouse not moved yet)\n    if (iMouse.x<1.) fragColor.xy += 0.003*cos(iTime*.3-vec2(0,1.57)) / (dot(scr,scr)/0.05+.05);\n    // feed mouse motion into flow\n    fragColor.xy += .0003*dmouse/(dot(scr,scr)/0.05+.05);\n\n    // add some \"crunchy\" drops to surface\n    fragColor.zw += (texture(iChannel1,fragCoord/Res1*.35).zw-.5)*.002;\n    fragColor.zw += (texture(iChannel1,fragCoord/Res1*.7).zw-.5)*.001;\n    \n    // initialization\n    if(iFrame<=4) fragColor=vec4(0);\n    if(KEY_I>.5 ) fragColor=(texture(iChannel1,uvSmooth(fragCoord.xy/Res0.xy*.05,Res1))-.5)*.7;\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// just some mouse motion detection\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 c=texelFetch(iChannel0,ivec2(0),0);\n    vec2 m=iMouse.xy;\n    vec2 d=vec2(0);\n    if(iMouse.xy!=iMouse.zw) { d=iMouse.xy-c.xy; }\n    fragColor.xyzw = vec4(m,d);\n}\n\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// your code here\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=1.-iMouseData.z/1000.;\n    #endif\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    //return uv+.8*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3SRr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[598, 598, 644, 644, 689], [691, 691, 714, 714, 752], [753, 753, 776, 776, 809], [815, 815, 850, 850, 1004], [1006, 1006, 1063, 1063, 1930]]}
{"id": "DlcXzn", "name": "Simple Mandelbrot animation", "author": "Sleng", "description": "Simple Mandelbrot set animation", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 130, "published": 3, "date": "1684921762", "time_retrieved": "2024-07-30T17:54:18.003977", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Shifted to [-1.0, 1.0] and zoom\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Julia Set Parameters\n    vec2 c = vec2(0.5*sin(iTime), 0.5*cos(iTime));\n    vec2 z = uv;\n\n    float iter = 0.0;\n    float max_iter = 100.0;\n\n    // Mandelbrot Set Iterations\n    while (iter < max_iter) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (2.0 * z.x * z.y) + c.y;\n\n        z = vec2(x,y);\n\n        if (length(z) > 2.0) break;\n        iter++;\n    }\n\n    // Color\n    vec3 color = vec3(0.0);\n    if (iter < max_iter) {\n        color = 0.5 + 0.5*cos(3.0 + iter*0.15 + vec3(0.0,0.6,1.0));\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 849]]}
{"id": "Dl3XRn", "name": "Cymatics Cascade v4", "author": "maxwellcoffee", "description": "mouse reactive. Assisted by GPT-4 AI. Change the zoomFactor to zoom in or out", "tags": ["cymatics"], "likes": 1, "viewed": 139, "published": 3, "date": "1684915264", "time_retrieved": "2024-07-30T17:54:18.808825", "image_code": "// The main function of a fragment shader, which sets the color of each pixel.\nvoid mainImage( out vec4 color, vec2 UVcoords )\n{\n   // Calculate the center of the screen in both x and y directions\n   float d3 = iResolution.y*.5 ,\n         d4 =  iResolution.x*.5 ,\n         \n   // Use the time and mouse position to modulate a value (d2), which will be used to distort the UV coordinates\n   // and to define a sine-wave period.\n         d2 = 8.0 - 4.0 * sin(iTime*.07 )*1.,\n         \n   // Define a constant value (d1), which will be used as a sine-wave period\n         d1 = .5,\n         \n   // Define a zoom factor\n         zoomFactor = iMouse.y*0.2 - 10.;  \n\n   // Shift UVcoords to the center of the screen and scale them by zoom factor\n   UVcoords = .5*(UVcoords - vec2(d4,d3)) / zoomFactor;  \n\n   // Define a macro function S. It adds a sin-wave pattern to the color.\n#define S(X, Y, period)   color += vec4(sin(length(UVcoords + vec2(X,Y)*d2)*period));\n\n   // Initialize color with alpha 1\n    color = vec4(0.0, 0.0, 0.0, 1.0); \n\n    // Apply the sin-wave pattern to color using macro function S with different parameters.\n    S(0.0,0.0,((iMouse.x*0.1)*.01))\n    S(0,1.0*d2,d1)  \n    S(0,-1.0*d2,d1)  \n    S(-1.0*d2,-0.0,d1)  \n    S(1.0*d2,0.0,d1)\n}\n\n/*\nSUMMARY:\n\nThis shader creates a dynamically changing pattern based on UV coordinates and user input. \n\nFirstly, it calculates the center of the screen and adjusts the UV coordinates accordingly, also applying a zoom factor to these coordinates.\n\nThe primary color modulation is performed using the S macro, which uses a sinusoidal wave to generate the color pattern. This wave's period is influenced by time (creating an animation), mouse position (creating interactivity), and the adjusted UV coordinates (creating spatial variance).\n\nIn essence, this code creates an animated, zoomable, and interactive sin-wave color pattern that the user can manipulate through the mouse's position.\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl3XRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "dlV3Wd", "name": "wobbles", "author": "mhellar", "description": "cool", "tags": ["wobbles"], "likes": 0, "viewed": 122, "published": 3, "date": "1684900923", "time_retrieved": "2024-07-30T17:54:19.688472", "image_code": "vec2 polarCoords(vec2 coord) {\n    float angle = atan(coord.y, coord.x);\n    float radius = length(coord);\n    return vec2(angle, radius);\n}\n\nvec3 calc( in vec2 p )\n{\n    float x = 0.5;\n\tfloat h = 0.0;\n\tfor( int i=0; i<150; i++ )\n\t{\n\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n\t\tx = p.x*x*(1.0-x); h += log2(abs(p.x*(1.0-2.0*x)));\n\n        x = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n\t\tx = p.y*x*(1.0-x); h += log2(abs(p.y*(1.0-2.0*x)));\n\t}\n    h /= 150.0*12.0;\n\t\n\t\n\tvec3 col = vec3(0.0);\n\tif( h<0.0 )\n\t{\n\t\th = abs(h);\n\t\tcol = 0.5 + 0.5*sin( vec3(0.0,0.4,0.7) + 2.5*h );\n\t\tcol *= pow(h,0.25);\n\t}\n\t\n\n\treturn col;\n}\n\t\n\nfloat kaleidoscope(float angle, float numSegments) {\n    return mod(numSegments * angle / (2.0 * 3.1415926) + 90.5, 3.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 coord = (iTime / cos(iTime * .0005)) / (uv - iTime /20.);\n    \n    vec2 polar = polarCoords(cos(coord));\n    float angle = polar.x;\n    float radius = polar.y;\n    \n    float jim = tan(abs(polar.x) * tan(polar.y));\n    \n    float result = kaleidoscope(sin(angle), 4.);\n    \n    \n    vec3 color = mix(vec3(1.0, 4.5, 32.0), vec3(90.0, 100.5, 1.0), fract(result));\n    \n    fragColor = vec4(cos(color) * (iTime * .0009) * abs(jim) * cos(iTime * jim), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlV3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 140], [142, 142, 166, 166, 1063], [1067, 1067, 1119, 1119, 1190], [1192, 1192, 1247, 1247, 1754]]}
{"id": "DlVGDt", "name": "chica#2", "author": "jorge2017a2", "description": "chica#2", "tags": ["chica2"], "likes": 4, "viewed": 194, "published": 3, "date": "1684873177", "time_retrieved": "2024-07-30T17:54:20.788531", "image_code": "//por jorge2017a2\n//chica#2\n//23-may-2023---\n//referencia fondo //https://www.shadertoy.com/view/mtyGWy\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 p0_; //punto uv\nvec2 pt0; //punto pos0\nfloat DistL;\nvec3 ColL;  //color linea\nvec3 ColO;  //color salida Out\n\nvoid L( vec2 p1)\n{   DistL=sdSegment(p0_, pt0, p1 );\n    ColO= DrawFigBorde(ColL, ColO,DistL); //cabeza\n    pt0 = p1;\n}\nvoid SZ(vec2 p ){pt0 = p;}\nvoid M(vec2 p1){pt0 = p1;}\nvoid C(vec3 pcol){ColL=pcol;}\n\n\nvec3 PeloSup(vec2 p ,vec3 col )\n{\nvec3 colc;\nfloat r1;\nvec2 p1;\nfloat d1;\nr1 = 0.6;\np1 = vec2(1.57, 0.87);\nd1 = sdCircle(p- p1, r1);\n//---------;\nfloat r2;\nvec2 p2;\nfloat d2;\nr2 = 0.6;\np2 = vec2(1.66, 1.09);\nd2 = sdCircle(p- p2, r2);\nfloat r3;\nvec2 p3;\nfloat d3;\nr3 = 0.6;\np3 = vec2(2.02, 0.38);\nd3 = sdCircle(p- p3, r3);\nfloat df, df1,df2, df3;\n\n\n    df1 = differenceSDF(d1, d2);\n    df2 = intersectSDF(d1, d3);\n    df3 = intersectSDF(d2, d3);\n    df = unionSDF(df1, df2);\n    df = unionSDF(df, df3);\n    col = DrawFigBorde(vec3(1., 0.5, 0.), col, df);\n    \n    return  col;\n}\n\nvec3 OjoIzq(vec2 p  ,vec3 col )\n{\nvec3 colc;\nvec2 p1;\nfloat r1, d1,r2,d2,d1a,d1b,d2a,dfa,dfb;\nvec2 p2;\n    colc = vec3(0.43, 0.65, 0.74);\n    r1 = 0.2;\n    p1 = vec2(1.26, 1.22);\n    d1 = sdCircle(p- p1, r1);\n    r2 = 0.2;\n    p2 = vec2(1.3, 1.05);\n    d2 = sdCircle(p- p2, r2);\n\n    dfa = intersectSDF(d1, d2);\n    col = DrawFigBorde(vec3(1.), col, dfa);\n\n////cornea;\ncolc = vec3(0.48, 0.66, 0.76);\nr1 = 0.08;\np1 = vec2(1.3, 1.11);\nd1 = sdCircle(p- p1, r1);\n    col = DrawFigBorde(colc, col, d1);\n////iris;\nfloat r3;\nvec2 p3;\nfloat d3;\nr3 = 0.02;\np3 = vec2(1.3, 1.11);\nd3 = sdCircle(p- p3, r3);\n    col = DrawFigBorde(vec3(0.), col, d3);\n    \n    return col;\n}\n\nvec3 ojoDer(vec2 p,  vec3 col  ) \n{\nfloat r1,d1,r2,d2,dt,r3,d3,r4,d4;\nvec2 p1,p2,p3,p4;\n\nvec3 colc;\nr3 = 0.2;\np3 = vec2(1.76, 1.23);\nd3 = sdCircle(p- p3, r3);\nr4 = 0.2;\np4 = vec2(1.73, 1.04);\nd4 = sdCircle(p- p4, r4);\n    dt = intersectSDF(d3, d4);\n    col = DrawFigBorde(vec3(1., 1., 1.), col, dt);\n////cornea;\n\n\nr2 = 0.08;\np2 = vec2(1.76, 1.11);\nd2 = sdCircle(p- p2, r2);\ncolc = vec3(0.48, 0.66, 0.76);\n    col = DrawFigBorde(colc, col, d2);\n////iris;\nr4 = 0.02;\np4 = vec2(1.75, 1.11);\nd4 = sdCircle(p- p4, r4);\n    col = DrawFigBorde(vec3(0.), col, d4);\n    return  col;\n}\n\nvec3 Rostro(vec2 p, vec3 col )\n{\nvec2 p3,med ,med3,pos, med2;\nfloat d1,d2,d3,dt;\nvec3 colc;\ncolc = vec3(0.43, 0.65, 0.74);\ncolc = vec3(0.96, 0.85, 0.8);\n\n\npos = vec2(1.53, 1.05);\nmed = vec2(0.44, 0.53);\nd1 = sdEllipse(p- pos, med);\npos = vec2(1.53, 1.17);\nmed = vec2(0.4, 0.43);\nd2 = sdEllipse(p- pos, med);\npos = vec2(1.53, 1.24);\nmed = vec2(0.31, 0.43);\nd3 = sdEllipse(p- pos, med);\n    ;\n    dt = unionSDF(d1, d2);\n    dt = unionSDF(dt, d3);\n    col = DrawFigBorde(colc, col, dt);\n    return col;\n}\n\n\nvec3 nariz(vec2 p ,vec3 col )\n{\nvec2 p1, p2, p3;\nColO = col;\np0_ = p;\np1 = vec2(1.51, 1.19);\np2 = vec2(1.61, 1.24);\np3 = vec2(1.57, 1.32);\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2); L(p3);\n    col = ColO;\n    return col;\n}\n\nvec3 boca(vec2 p,vec3 col)\n{\nvec2 p1,p2,p3, p4, p5,p6,p7,p8,p9;\nColO = col;\np0_ = p;\np1 = vec2(1.39, 1.42);\np2 = vec2(1.5, 1.43);\np3 = vec2(1.5, 1.44);\np4 = vec2(1.61, 1.46);\np5 = vec2(1.65, 1.47);\np6 = vec2(1.54, 1.49);\np7 = vec2(1.46, 1.48);\np8 = vec2(1.43, 1.44);\np9 = vec2(1.4, 1.44);\nSZ(p1); M(p1); C(vec3(0.));\n    L(p1); L(p2); L(p3); L(p4); L(p5);;\n    L(p6); L(p7); L(p8); L(p9);;\n    col = ColO;\n    \n    return  col;\n}\n\nvec3 Cuello(vec2 p ,vec3 col)\n{\nfloat l1, t1, an1;\nfloat al1;\nvec2 pos, med;\nfloat d1cu;\nvec3 colc;\ncolc = vec3(0.94, 0.88, 0.82);\n\npos = vec2(1.52, 1.82);;\nmed = vec2(0.175, 0.25);\nd1cu = sdBox(p- pos, med);\ncol = DrawFigBorde(colc, col, d1cu);\nfloat r1;\nvec2 p1;\nfloat d1;\nr1 = 0.27;\np1 = vec2(1.52, 1.49);\nd1 = sdCircle(p- p1, r1);\nfloat r2;\nvec2 p2;\nfloat d2;\nr2 = 0.27;\np2 = vec2(1.52, 1.58);\nd2 = sdCircle(p- p2, r2);\nfloat df;\n    df = differenceSDF(d2, d1);\n    df = intersectSDF(df, d1cu);\n    col = DrawFigBorde(vec3(0.), col, df);\n    return col;\n}\n\nvec3 Cuerpo(vec2 p,vec3 col )\n{\nvec2 pos;\nvec2 med;\nfloat d1cu;\npos = vec2(1.52, 2.8);\nmed = vec2(0.25, 0.71);\nd1cu = sdBox(p- pos, med);\nfloat d2cu,r1, r2, he, d1;\n\nr1 = 0.525;\nr2 = 0.455;\nhe = 0.29; \n\npos = vec2(1.5, 3.3);\nd2cu = sdTrapezoid(p- pos, r1, r2, he);\n//-----------\nfloat r3;\nvec2 p3;\nfloat d3;\nr3 = 0.4;\np3 = vec2(1.27, 2.78);\nd3 = sdCircle(p- p3, r3);\nfloat r4;\nvec2 p4;\nfloat d4;\nr4 = 0.4;\np4 = vec2(1.81, 2.76);\nd4 = sdCircle(p- p4, r4);\nfloat dt;\n    dt = unionSDF(d1cu, d2cu);\n    dt = unionSDF(dt, d3);\n    dt = unionSDF(dt, d4);\nfloat st;\n\nr1 = 0.25;\nr2 = 0.565;\nhe = 0.275;\npos = vec2(1.53, 2.2);\n////camisa;\nd1 = sdTrapezoid(p- pos, r1, r2, he);\n    dt = unionSDF(dt, d1);\n ////cintura;\nr1 = 0.43;\nr2 = 0.62;\nhe = 0.275;\npos = vec2(1.525, 3.855);\nd1 = sdTrapezoid(p- pos, r1, r2, he);\n//-------------;\nvec3 colc;\ncolc = vec3(0.96, 0.85, 0.8);\n    col = DrawFigBorde(colc, col, d1);\n    col = DrawFigBorde(vec3(1.), col, dt);\n    return col;\n}\n\n\nvec3 pestanaIzq(vec2 p,vec3 col)\n{\nfloat r1,d1;\nvec2 p1;\n\nr1 = 0.2;\np1 = vec2(1.29, 1.03);\nd1 = sdCircle(p- p1, r1);\nfloat r2;\nvec2 p2;\nfloat d2;\nr2 = 0.24;\np2 = vec2(1.29, 1.1);\nd2 = sdCircle(p- p2, r2);\nfloat dt;\n    dt = differenceSDF(d1, d2);\n    col = DrawFigBorde(vec3(0.), col, dt);\n    return col;\n}\n\nvec3 pestanaDer(vec2 p,vec3 col )\n{\nfloat r1;\nvec2 p1;\nfloat d1;\nr1 = 0.19;\np1 = vec2(1.75, 1.05);\nd1 = sdCircle(p- p1, r1);\nfloat r2;\nvec2 p2;\nfloat d2;\nr2 = 0.24;\np2 = vec2(1.75, 1.12);\nd2 = sdCircle(p- p2, r2);\nfloat dt;\n    dt = differenceSDF(d1, d2);\n    col = DrawFigBorde(vec3(0.), col, dt);\n    return  col;\n}\n\nvec3 BrazoIzq(vec2 p ,vec3 col)\n{\nvec2 pos;\nvec2 med;\nfloat d1cu, d2cu;\nfloat ang;\nvec2 pr;\nvec3 colc;\nfloat dt;\npos = vec2(0.78, 2.8);;\nmed = vec2(0.38 / 2., 1.95 / 2.);\n    ang = -18. * PI / 180.;\n    pr = Rotate(p- pos, med/ 2., ang);\n    dt = sdBox(pr, med);\n    colc = vec3(0.96, 0.87, 0.83);\n////diferencia brazo;\npos = vec2(0.94 / 2., 1.9 / 2.);;\nmed = vec2(0.36, 0.165);\nang = 12. * PI / 180.;\npr = Rotate(p- pos, med/ 2., ang);\nd2cu = sdBox(pr- pos, med);\n    dt = differenceSDF(dt, d2cu);\n    col = DrawFigBorde(colc, col, dt);\n    return col;\n}\n\nvec3 BrazoDer(vec2 p,vec3 col)\n{\nvec2 pos,med;\nfloat d1cu, ang;\nvec2 pr;\nvec3 colc;\nfloat dt;\npos = vec2(2.21, 2.74);;\nmed = vec2(0.19, 0.915);\nd1cu = sdBox(p- pos, med);\n    ang = 15. * PI / 180.;\n    pr = Rotate(p- pos, med/ 2., ang);\n    dt = sdBox(pr, med);\n    colc = vec3(0.96, 0.85, 0.8);\npos = vec2(2.13 / 2., 1.6 / 2.);\nmed = vec2(0.36, 0.165);\n\n\nfloat d2cu;\nang = -12. * PI / 180.;\npr = Rotate(p- pos, med/ 2., ang);\nd2cu = sdBox(pr- pos, med);\n    dt = differenceSDF(dt, d2cu);\n    col = DrawFigBorde(colc, col, dt);\n    return col;\n}\n\nvec3 Lineas01(vec2  p ,vec3 col ) \n{\nvec2 p1, p2, p3, p4, p5;\np1 = vec2(1.49, 2.52);\np2 = vec2(1.58, 2.67);\np3 = vec2(1.59, 2.73);\np0_ = p;\nColO = col;\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2); L(p3);;\np1 = vec2(1.25, 3.09);\np2 = vec2(1.61, 3.05);\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2);;\np1 = vec2(1.5, 3.01);\np2 = vec2(1.85, 3.09);\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2);;\ncol = ColO;\n    return col;\n}\n\nvec3 CejaIzq(vec2 p ,vec3 col ) \n{\nvec2 p1, p2, p3, p4, p5;\np1 = vec2(1.44, 1.12);\np2 = vec2(1.36, 1.03);\np3 = vec2(1.28, 1);\np4 = vec2(1.21, 1);\np5 = vec2(1.17, 0.95);\nColO = col;\np0_ = p;\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2); L(p3); L(p4); L(p5);;\np1 = vec2(1.21, 1.01);\np2 = vec2(1.15, 1.03);\np3 = vec2(1.11, 1);\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2); L(p3);;\ncol = ColO;\n    return col;\n}\n\nvec3 CejaDer(vec2 p ,vec3 col)\n{\nvec2 p1, p2, p3, p4, p5;\np1 = vec2(1.59, 1.09);\np2 = vec2(1.66, 1.01);\np3 = vec2(1.77, 1);\np4 = vec2(1.82, 1.02);\np5 = vec2(1.85, 0.96);\np0_ = p;\nColO = col;\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2); L(p3); L(p4); L(p5);;\np1 = vec2(1.81, 1.01);\np2 = vec2(1.89, 1.03);\np3 = vec2(1.94, 0.98);\nSZ(p1); M(p1); C(vec3(0.));\nL(p1); L(p2); L(p3);;\ncol = ColO;\n    return col;\n}\n\nvec3 chica2(vec2 p , vec3 col ) \n{\n   col = Cuello(p, col);\n    col = BrazoIzq(p, col);\n    col = BrazoDer(p-vec2(0.05,0.05), col);\n    col = Cuerpo(p, col);\n    col = Rostro(p, col);\n    col = pestanaIzq(p, col);\n    col = nariz(p, col);\n    col = PeloSup(p, col);\n    col = pestanaDer(p, col);\n    col = OjoIzq(p, col);\n    col = ojoDer(p, col);\n    col = boca(p, col);\n    col = Lineas01(p, col);\n    col = CejaIzq(p, col);\n    col = CejaDer(p, col);\n    return col;\n}\n\n\n//https://www.shadertoy.com/view/mtyGWy\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\nuv.x *= iResolution.x/iResolution.y;\nvec2 uv0=uv;\nuv-=vec2(-0.5,-0.75); uv*=2.5;\n    vec3 col=vec3(1.0,2.0,3.0);\n    uv0*=2.0;\n    float d=sin(uv0.x+iTime)+uv0.y;\n    col = palette(d+iTime);\n\td=sin(d*8.0+iTime/8.0);\n\td=abs(d);\n\td=0.5/d;\n\tcol*=d;\n    col=chica2(vec2(uv.x,-uv.y+4.0),col );\nfragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "float sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 350, 350, 476], [477, 477, 558, 558, 686], [688, 688, 752, 752, 823], [825, 825, 872, 872, 899], [900, 900, 943, 943, 970], [971, 971, 1019, 1019, 1047], [1048, 1064, 1112, 1112, 1190], [1192, 1192, 1227, 1227, 1250], [1252, 1252, 1289, 1289, 1361], [1363, 1363, 1415, 1415, 1522], [1524, 1524, 1549, 1549, 1568], [1569, 1569, 1594, 1594, 1613], [1614, 1614, 1650, 1650, 1678], [1681, 1681, 1746, 1746, 2056], [2173, 2173, 2191, 2191, 2292], [2293, 2293, 2310, 2310, 2319], [2320, 2320, 2336, 2336, 2346], [2347, 2347, 2365, 2365, 2376], [2379, 2379, 2412, 2412, 2956], [2958, 2958, 2991, 2991, 3619], [3621, 3621, 3656, 3656, 4196], [4198, 4198, 4230, 4230, 4699], [4702, 4702, 4733, 4733, 4923], [4925, 4925, 4953, 4953, 5354], [5356, 5356, 5387, 5387, 5915], [5917, 5917, 5948, 5948, 6882], [6885, 6885, 6919, 6919, 7192], [7194, 7194, 7229, 7229, 7511], [7513, 7513, 7546, 7546, 8068], [8070, 8070, 8102, 8102, 8615], [8617, 8617, 8653, 8653, 9025], [9027, 9027, 9061, 9061, 9426], [9428, 9428, 9460, 9460, 9831], [9833, 9833, 9867, 9867, 10304], [10307, 10347, 10372, 10372, 10556], [10558, 10558, 10615, 10615, 10985]]}
{"id": "DtKGWt", "name": "sdf rect + onion example", "author": "Prohladniy", "description": "sdf rect + multiple onions example", "tags": ["sdf", "learn"], "likes": 1, "viewed": 132, "published": 3, "date": "1684863817", "time_retrieved": "2024-07-30T17:54:21.787859", "image_code": "float sdfRect(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return max(d.x, d.y);\n}\n\nfloat opOnion(in float d, in float r)\n{\n    return abs(d) - r;\n}\n\nvec2 rotate(vec2 p, float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, s, -s, c);\n    return m * p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 point = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    vec2 center = mouse;\n    vec2 size = vec2(0.4, 0.7);\n    float border = 0.05;\n\n    float dist = sdfRect(rotate(point - center, iTime), size);\n    dist = opOnion(dist, border);\n    dist = opOnion(dist, border / 4.0);\n\n    float value = smoothstep(0.0, 0.0, dist);\n    fragColor = vec4(vec3(value), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 90], [92, 92, 131, 131, 156], [158, 158, 188, 188, 281], [283, 283, 338, 338, 786]]}
{"id": "mlyGWt", "name": "Multi-Wave", "author": "SnoopethDuckDuck", "description": "Replacing e^x in tanh with 2^x makes it cheaper. I've used it to make \"thc3\" which can create triangle-like waves, cos and soft square/pulse waves. It's a bit expensive but cool\n\nhttps://www.desmos.com/calculator/of9a6fkocv", "tags": ["wave", "function", "periodic", "squarewave", "trianglewave", "pulsewave"], "likes": 7, "viewed": 214, "published": 3, "date": "1684852158", "time_retrieved": "2024-07-30T17:54:22.710393", "image_code": "#define res iResolution.xy\n#define ss(a) smoothstep(-1./res.y, 1./res.y, a)\n\n#define tanh2(a) ((exp2(a)-1.)/(exp2(a)+1.))\n#define atanh2(a) log2((1.+a)/(1.-(a)))\n\n// Cheapest, soft square wave, use only with high a (>8 or so), \n// or if you don't mind not oscillating to +-1\n#define thc0(a, x) tanh2(a*cos(x))\n\n// More correct wave, hits +-1\n// a~=0 is cos (but breaks at a=0)\n// a>0 is soft square wave\n#define thc1(a, x) tanh2(a*cos(x))/tanh2(a)\n\n// Probably not worth using this over thc1, it's about 2x more \n// expensive and very similar (unless you want to vary between tri, square)\n// Same as thc3 but can't change pulse width\n#define thc2(a, x) tanh2((a)*atanh2(cos(x)))\n\n// Has pulse wave, great control, is expensive (not much more than thc2)\n// a>0 controls sharpness \n// o in [-1,1] controls pulse width\n// a=.6, o=0 is \"triangle\", \n// a=1,  o=0 is cos, \n// a>1,  o=0 is soft square\n// a>1,  o!=0 is soft pulse\n#define thc3(a, o, x) tanh2((a)*(atanh2(cos(x))-atanh2(o)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * res) / res.y;    \n    float t = iTime;\n    \n    vec2 pSqu1  = 0.5 * vec2(thc1(8., t),        0.1);\n    vec2 pSqu2  = 0.5 * vec2(thc2(2.8, t),       0.0);\n    vec2 pPulse = 0.5 * vec2(thc3(2.8, 0.5, t), -0.1);\n    vec2 pTri   = 0.5 * vec2(thc3(0.6, 0., t),  -0.2);\n    \n    float sSqu1  = ss(0.02 - length(uv - pSqu1));\n    float sSqu2  = ss(0.02 - length(uv - pSqu2));\n    float sPulse = ss(0.02 - length(uv - pPulse));\n    float sTri   = ss(0.02 - length(uv - pTri)); \n    \n    vec3 col = vec3(0);\n    col = mix(col, vec3(1,.5,.5), sSqu1);\n    col = mix(col, vec3(.5,1,.5), sSqu2);\n    col = mix(col, vec3(.5,.5,1), sPulse);\n    col = mix(col, vec3(.9),      sTri);\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlyGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[984, 984, 1041, 1041, 1778]]}
{"id": "dtyGWt", "name": "Perlin noise effect", "author": "djancool", "description": "Cool effect i accidently created", "tags": ["noise", "perlin", "effect", "shades"], "likes": 8, "viewed": 216, "published": 3, "date": "1684851566", "time_retrieved": "2024-07-30T17:54:23.665838", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y * 4.0 + iTime * 0.2;\n\n    // Time varying pixel color\n    float perlin = perlin_noise(uv);\n    float perlin_x = perlin_noise(uv + vec2(0.1, 0.0));\n    float perlin_y = perlin_noise(uv + vec2(0.0, 0.1));\n    vec3 normal = normalize(vec3(perlin - perlin_x, perlin - perlin_y, 0.05));\n    \n    float angle = atan(normal.x, normal.y) / 3.14159 / 2.0 + 0.5;\n    float waves = sin(angle * (sin(iTime * 0.3) + 1.4) * 4.0);\n    waves *= waves;\n\n    \n    fragColor = vec4(waves);\n}", "image_inputs": [], "common_code": "vec2 n22 (vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvec2 get_gradient(vec2 pos)\n{\n    float twoPi = 6.283185;\n    float angle = n22(pos).x * twoPi;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin_noise(vec2 uv)\n{\n    vec2 pos_in_grid = uv;\n    vec2 cell_pos_in_grid =  floor(pos_in_grid);\n    vec2 local_pos_in_cell = (pos_in_grid - cell_pos_in_grid);\n    vec2 blend = local_pos_in_cell * local_pos_in_cell * (3.0f - 2.0f * local_pos_in_cell);\n    \n    vec2 left_top = cell_pos_in_grid + vec2(0, 1);\n    vec2 right_top = cell_pos_in_grid + vec2(1, 1);\n    vec2 left_bottom = cell_pos_in_grid + vec2(0, 0);\n    vec2 right_bottom = cell_pos_in_grid + vec2(1, 0);\n    \n    float left_top_dot = dot(pos_in_grid - left_top, get_gradient(left_top));\n    float right_top_dot = dot(pos_in_grid - right_top,  get_gradient(right_top));\n    float left_bottom_dot = dot(pos_in_grid - left_bottom, get_gradient(left_bottom));\n    float right_bottom_dot = dot(pos_in_grid - right_bottom, get_gradient(right_bottom));\n    \n    float noise_value = mix(\n                            mix(left_bottom_dot, right_bottom_dot, blend.x), \n                            mix(left_top_dot, right_top_dot, blend.x), \n                            blend.y);\n   \n    \n    return (noise_value / 0.7) * 0.5 + 0.5;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyGWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 618]]}
{"id": "dlG3WK", "name": "Year of Truchets #023", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n(mouseable)\nHave you tried full screen?\n", "tags": ["3d", "truchet", "rainbow", "flyby", "path"], "likes": 19, "viewed": 252, "published": 3, "date": "1684845941", "time_retrieved": "2024-07-30T17:54:24.613305", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #023\n    05/23/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Unstyled, unbothered, moisturized, happy, in my lane, flourishing.\n\n    https://soundcloud.com/monster-magnet-433718279/premiere-cypherpunx-feat-sian\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST   60.\n#define MIN_DIST   1e-4\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.73,59.71)+iDate.z))*4832.3234);}\n\n//@iq sdf's + extrude\nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nfloat box(vec2 p,vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\n//@Shane - path function\nvec2 path(in float z){\n    vec2 p1 =vec2(7.38*sin(z *.15)+5.38*cos(z *.075),2.4*cos(z *.0945));\n    vec2 p2 =vec2(5.2*sin(z *.089),2.31*sin(z *.127)+3.5*cos(z *.095));\n    return (p1 - p2)*.3;\n}\n\nmat2 r90;\nfloat tspeed = 0.;\n\nvec3 lp = vec3(0);\nconst float sz = 2.65;\nconst float hf = sz/2.;\nconst float rd = .025;\n\nvec2 map (in vec3 p) {\n \tvec2 res = vec2(1e5,0);\n    p.xy += hf;\n\n \tvec2 tun = p.xy - path(p.z);\n    vec3 q = vec3(tun,p.z),\n        id = floor((q + hf)/sz);\n\n    float thick  = .0825+.0625*sin(p.z*.75);\n          thick -= .0125*cos(p.y*.62)+.0125*sin(p.x*1.25);\n    \n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    q = mod(q+hf,sz)-hf;\n    \n    float hs = hash21(id.xz+id.y);\n    float xhs = fract(2.33*hs+id.y);\n\n    if (hs >.5) q.xz *= r90;\n    if (chk>.5) q.zy *= r90;\n\n    vec3 q1,q2,q3;\n    float trh,trx,jre;\n\n    if(xhs>.65) {\n        q1 = q;\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(0,hf,hf);\n   \n        trh = opx(box(q1.xz,vec2(sz,thick)),q1.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.yz)-hf)-thick,q.x,thick)-rd;\n    } else {\n        q1 = q + vec3(hf,0,-hf);\n        q2 = q + vec3(0,hf,hf);\n        q3 = q - vec3(hf,hf,0);\n \n        trh = opx(abs(length(q1.xz)-hf)-thick,q.y,thick)-rd;\n        trx = opx(abs(length(q2.yz)-hf)-thick,q.x,thick)-rd;\n        jre = opx(abs(length(q3.xy)-hf)-thick,q.z,thick)-rd;\n    }\n    \n    if(trh<res.x ) res = vec2(trh,2.);\n    if(trx<res.x ) res = vec2(trx,3.);\n    if(jre<res.x ) res = vec2(jre,4.);\n\n \treturn res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*1.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    tspeed = iTime*1.25;\n    r90=rot(1.5707);\n\n    vec3 C =vec3(0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,.1);\n    vec3 rd = normalize(vec3(uv,-1.));\n\n    // mouse //\n    float x = M.xy==vec2(0)||(M.z<1.) ? (T*.0095)*PI2 : -(M.y/R.y*.8-.4)*PI2;\n    float y = M.xy==vec2(0)||(M.z<1.) ? (T*-.0125)*PI2 : -(M.x/R.x*2.-1.)*PI2;\n\n    mat2 rx = rot(x), ry = rot(y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    ro.z -= tspeed;\n    ro.xy += path(ro.z);\n\n    float d,m;\n    vec3 p = vec3(0);\n\n    for(int i=0;i<98;i++) {\n        p = ro+rd*d;\n        vec2 ray = map(p);\n        d += i<32? ray.x*.35 : ray.x * .85;\n        m = ray.y;\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n    }\n\n    if(d<MAX_DIST) {\n        C = hsv2rgb(vec3(clamp(d*.035,0.,1.)+T*.05,1.,.5));\n    } \n    \n    // fog level\n    C = mix(vec3(.01), C, exp(-.00125*d*d*d));\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlG3WK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[547, 547, 565, 565, 608], [609, 609, 630, 630, 693], [695, 717, 763, 763, 856], [857, 857, 882, 882, 960], [962, 987, 1009, 1009, 1181], [1303, 1303, 1325, 1325, 2553], [2555, 2630, 2660, 2660, 2900], [2902, 2919, 2946, 2946, 3062], [3064, 3064, 3105, 3119, 4056]]}
{"id": "clK3DK", "name": "Heightmap to Normal", "author": "pathtracerenthusiast", "description": ".", "tags": ["htn"], "likes": 2, "viewed": 206, "published": 3, "date": "1684802848", "time_retrieved": "2024-07-30T17:54:25.515891", "image_code": "float depthGet(vec2 i,vec2 o){\n    vec2 chRes = vec2(textureSize(iChannel0,0));\n    vec2 origTexC = chRes*i/iResolution.xy + o;\n    ivec2 texc = ivec2(mod(origTexC,chRes));\n    return texelFetch(iChannel0,texc,0).x;\n}\n\nconst vec2 offsets[9] = vec2[9](\n    vec2(-1.),\n    vec2(0.,-1.),\n    vec2(1.,-1.),\n    vec2(-1.,0.),\n    vec2(0.),\n    vec2(1.,0.),\n    vec2(-1.,1.),\n    vec2(0.,1.),\n    vec2(1.)\n);\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    // Normalized pixel coordinates\n    if(mod(iTime,7.5)<5.){\n    float d[9];\n    for(int j = 0;j<9;j++) d[j] = depthGet(i,offsets[j]);\n    vec3 normal;\n    \n    // Power determines how steep things should be.\n    // Use the units that the heightmap covers\n    // Heightmap should be in [0,1], so 5 units of depth,\n    // divide depth by 5, set power to 5.\n    const float power = 4.;\n    \n    normal.x = -power*(d[2]-d[0]+2.*(d[5]-d[3])+d[8]-d[6]);\n    normal.y = -power*(d[6]-d[0]+2.*(d[7]-d[1])+d[8]-d[2]);\n    normal.z = 1.;\n    \n    normal /= length(normal);\n    o = vec4(normal.xy*.5+.5,normal.z,1.);\n    vec3 lDir = normalize(vec3(.25,.5,1.)-2.*vec3(i/iResolution.xy,0.)+1.);\n    if(mod(iTime,7.5)<2.5) o = vec4(.125+.75*vec3(dot(normal,lDir)),1.);\n    }else{\n    o = vec4(vec3(depthGet(i,offsets[4])),1.);\n    }\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clK3DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 217], [404, 404, 445, 481, 1268]]}
{"id": "DtK3Dc", "name": "bubblin breakdown", "author": "ufffd", "description": "lampin in a lava land - animated breakdown / buildup", "tags": ["lavalamp", "simplex"], "likes": 5, "viewed": 202, "published": 3, "date": "1684802679", "time_retrieved": "2024-07-30T17:54:26.527188", "image_code": "// animated breakdown of my bubblin shader\n// rendered with audio: https://www.instagram.com/reel/Csl6V09pXET/\n\n/*\n0  noise\n2  walls\n4  drift\n6  walk\n8  twist\n10 light\n12 color\n14 glimmer\n18 reset\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    col = pow(col, vec3(.7));\t// gamma correction (tweaked)\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.141592653589793\n#define MAX_STEP 200\n#define MAX_DIST 10000.\n#define SURF_DIST 0.001\n#define JIGGLE .1\n\n#define DELTA\t\t\t\t0.0001\n#define RAY_COUNT\t\t\t3\n#define RAY_LENGTH_MAX\t\t30.0\n#define RAY_STEP_MAX\t\t60\n#define REFRACT_FACTOR\t\t.6\n#define REFRACT_INDEX\t\t1.15\n#define AMBIENT\t\t\t\t.95\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.7\n#define FADE_POWER\t\t\t1.\n#define FOG                 10.\n\n#define TT                  (mod(iTime,20.)*0.4)\n\n\n// simplex noise from https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}", "buffer_a_code": "// with wisdom from:\n// Nrx glass polyhedron - https://www.shadertoy.com/view/4slSzj\n// artofcode raymarch - https://www.shadertoy.com/view/WtGXDD\n// artofcode bending light - https://www.shadertoy.com/view/sllGDN\n\n// brace yourself for some weird shit\n#define X  \n#define A_(a,b,c,d) (smoothstep(a,b,mod(iTime,20.))*smoothstep(d,c,mod(iTime,20.)))\n//                  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20\n#define Adots  A_(  0.,.5, X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X  17.,18.       )\n#define Apulse A_(                                                          14.,16., X X X  18.,19.   )\n#define Awalk  A_(                          6., 7., X X X X X X X X X X X X X X X X X X X X X X 19.99,20.)\n#define Awalls A_(          2., 3., X X X X X X X X X X X X X X X X X X X X X X X X X X X X 18.,20.   )\n#define Atwist A_(                                  8.,     10., X X X X X X X X X X X X X X X  19.9,20.)\n#define Adrift A_(                  4., 5., X X X X X X X X X X X X X X X X X X X X X X X X X X 19.99,20.)\n#define Amater A_(                                          10.,    12., X X X X X X X  18.,    19.   )\n#define Acolor A_(                                                  12.,    14., X            18.5,20.)\n// why? why not\n\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat columnDist( vec3 p, vec3 c, vec3 r ) { \n    p.xy *= Rot(r.x);\n    // p.yz *= Rot(r.y);\n    // p.zx *= Rot(r.z);\n    return length(p.xz-c.xy)-c.z; \n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 texNormalMap(in vec2 uv, in sampler2D tx, in vec2 txr)\n{\n    vec2 s = 1.0/txr.xy;\n    \n    float p = texture(tx, uv).x;\n    float h1 = texture(tx, uv + s * vec2(1,0)).x;\n    float v1 = texture(tx, uv + s * vec2(0,1)).x;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nfloat sphereDist(vec3 p, float s) {\n    return length(p) - s;\n}\n\nvec2 map(vec3 p) {\n    float mater = -1.;\n    float d = 1000.;   \n    \n    // noise field\n    vec3 axis = vec3(0.,1.,0.);\n    vec3 nfp = p;\n    nfp.xy *= Rot(sin(TT+p.z)*Atwist);\n    float Adots_sweep = smoothstep(0.,1.,clamp(Adots-abs(p.z)+2.+iTime*20.,0.,1.))*Adots;\n    float nf = 1.-Adots_sweep*0.4 - abs(nfp.y)*0.2*Awalls;\n    nf += simplex3d(nfp + vec3(0.,mix(1.3,TT,Adrift)-3.,0.)) * 1.;\n    \n    if (nf < 0.001) mater = 2.;\n    d = min(d, nf);\n    \n    return vec2(d, mater);\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 mapr = map(p);\n    vec2 e = vec2(.001, 0);\n    \n\tfloat d = mapr.x;\n    vec3 n = vec3(0.);\n    \n    int method = 1;\n    // method 1\n    if (method==1) { \n        n = d - vec3(\n            map(p-e.xyy).x,\n            map(p-e.yxy).x,\n            map(p-e.yyx).x);\n    }\n    // method 2\n    if (method==2) {\n        n = vec3(\n            map(p+e.xyy).x - map(p-e.xyy).x,\n            map(p+e.yxy).x - map(p-e.yxy).x,\n            map(p+e.yyx).x - map(p-e.yyx).x);\n    }\n    \n    return normalize(n);\n}\n\nvec3 getLightPos(in int i) {\n    if (i==1){\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n        return lightPos;\n    }\n}\n\nfloat getLight(vec3 p, vec3 n, in vec3 rd) {\n    vec3 lp = getLightPos(1);\n    vec3 l = normalize(lp-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = map(p+n*SURF_DIST*2.).x;\n    if(d<length(lp-p)) dif *= .1;\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 50.);\n    \n    return dif + spec;\n}\n\nvec3 getCol(vec3 p, float mater, in vec3 rd, in vec3 norm) {\n    vec3 col = vec3(0.);\n    if (mater < 0.) {\n        return vec3(0.0);\n    } else if (mater < 0.5) {\n        col = norm;\n        col *= norm;\n    } else if (mater < 1.5) {\n        col = vec3(sin(norm.r*100.));\n        col *= norm;\n    } else if (mater < 2.5) {\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        vec3 text = texture(iChannel0, txuv).rrr;\n        col = mix(col,text*0.5,1.-col.r);\n        vec3 newcol = col;\n        newcol *= length(p.xy/3.)-0.25;\n        float color_offset = 0.;\n        newcol.r += sin(p.z+108.+color_offset);\n        newcol.g += sin(p.z*1.01+112.+color_offset);\n        newcol.b += sin(p.z*1.005+105.+color_offset);\n        newcol *= sin(p.z*0.9)*0.5+0.5;\n        newcol /= 2.;\n        col = mix(col/p.z,newcol,Acolor);\n    } else if (mater < 3.5) {\n        col = norm;\n        col = vec3(sin(norm.b*100.));\n    } else if (mater < 4.5) {\n        col = p * mat3(vec2(0.5), 0.1, vec2(0.2), 0.9, vec2(0.4), 1.);\n        // col = vec3(sin(norm.g*100.));\n    } else {\n        col = vec3(0.9,0.85,0.8) * 0.1;\n    }\n    return col;\n}\nvec3 k = vec3(0.);\n\nbool doesBounce(in float mater) {\n    if (mater > 1.5 && mater < 2.5) return true; // 2\n    if (mater > 4.5 && mater < 5.5) return true; // 5\n    return false;\n}\n\nvec3 materNorm(in float mater, in vec3 norm) {\n    vec3 mN;\n    if (mater > 1.5 && mater < 2.5) {\n        // todo - improve texturing https://www.youtube.com/watch?v=VaYyPTw0V84\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        mN = texNormalMap(txuv, iChannel0, iChannelResolution[0].xy).xyx;\n    }\n    return mN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    ro = vec3(0.);\n    // ro.xz *= Rot(iTime*0.3);\n    ro.z += mix(2.,TT,Awalk);\n    ro -= JIGGLE*sin(vec3(iTime*1.,iTime*0.22,iTime*0.91));    \n    rd = normalize(vec3(uvc.x, uvc.y, .8));\n    // rd.xz *= Rot(iTime*0.3);\n    rd.yz *= Rot(sin(iTime)*0.05);\n    rd.xy *= Rot(sin(iTime*1.1)*0.05);\n    rd.zx *= Rot(sin(iTime*0.9)*0.05);\n    vec3 ord = rd;\n       \n    \n    float d = 0.;\n    bool hit = false;\n    bool hit_matte = false;\n    float glow = 0.;\n    float mater = -1.;\n\tvec2 delta = vec2 (DELTA, 0.0);\n    \n    float intensity = 0.;\n\n    // vec3 backColor = vec3(0.,0.01,0.02) * (1.-length(uv + vec2(0.,0.3)));\n    vec3 backColor = vec3(54./255., 57./255., 63./255.);\n    col = vec3(0.);\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n    vec3 first_hit = vec3(0.); // store p before bouncing or refracting\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n        d = 0.; // reset ray dist\n        float ds = 0.; // distance step\n        for(int i=0;i<MAX_STEP;i++){\n            p = ro + rd * d; // update current point\n            vec2 mapr = map(p);\n            ds = mapr.x; // map distance\n            ds *= distanceFactor; // flip sdf when inside\n            mater = mapr.y; // material index\n            ds *= 0.3;\n            d += max(ds, DELTA); // update march distance\n            if(ds<0.) { hit=true; break; } // check hit\n            if(d>MAX_DIST) break; // check limit\n            glow += 1./ds; // add glow\n        }\n        if (!hit) {col = backColor; break;}\n        if (rayIndex == 0) first_hit = p;\n        vec3 norm = distanceFactor*getNorm(p);\n        // material color\n        col += getCol(p,mater,rd,norm) * AMBIENT;\n        // matte lighting\n        float light = getLight(p, norm, rd);\n        if (rayIndex==0) {\n            col += mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        // check for bounces\n        bool do_bounce = doesBounce(mater);\n        if (!do_bounce) {\n            // hit matte, done bouncing\n            break;\n        } else {\n            // col *= 0.1;\n            // apply normal to material 2 - note: make this a conditional if more reflective/refractive materials are added\n            norm += materNorm(mater, norm);\n            \n            vec3 reflection = reflect(rd, norm);            \n            // reflection light (i think it should be in getLight fxn so I can call it with multiple lights)\n            if (distanceFactor > 0.) { // only calculate light on outside\n                vec3 lp = getLightPos(1);\n                vec3 lightDirection = normalize(lp-p);\n                float reflectDiff = max (0.0, dot (norm, lightDirection));\n                float reflectSpec = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + reflectDiff) * localColor + reflectSpec;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n            }\n\n            // Next ray...\n            ro = p;\n            vec3 refraction = refract(rd, norm, refractionRatio);\n            if (dot (refraction, refraction) < DELTA) { // reflect at grazing angles, idk how the dot math works here\n                // fragColor = vec4(1.,1.,0.,1.); return;\n                rd = reflection; // update ray dir to reflected angle\n                ro += rd * DELTA * 2.0; // step away from surface\n            } else {\n                rd = refraction; // update ray dir to refracted angle\n                ro += rd * DELTA * 2.0; // step away from surface - not needed?\n                refractionRatio = 1.0 / refractionRatio; // reverse refraction ratio \n                distanceFactor = -distanceFactor; // flip sdf sign while inside\n            }\n        }\n        \n        // todo: chromatic aberation, optical density, bevel, fresnel reflection\n        // https://www.youtube.com/watch?v=0RWaR7zApEo\n    }\n    \n    if (hit)\n    col = mix(\n        1. - first_hit.zzz/12., // depth\n        col,\n        Amater\n    );\n    \n    col *= 1. + smoothstep(0.3,1.,sin(TT*20.+p.z*2.))*Apulse*3.;\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtK3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 200, 257, 257, 455]]}
{"id": "mlGGW3", "name": "RAINBOW", "author": "cisemsu", "description": "WAVY RAINBOW", "tags": ["yellow", "orange", "red", "green", "blue", "violet", "indigo"], "likes": 2, "viewed": 259, "published": 3, "date": "1684755753", "time_retrieved": "2024-07-30T17:54:27.473657", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n   float time=cos(iTime)*0.1+sin(uv.x*3.0+iTime)*0.25;\n\n    if(uv.y<1.0/1.6+time)\n    fragColor = vec4(148.0,0.0,211.0,0.0)/255.0;\n    if(uv.y<1.0/1.80+time)\n    fragColor = vec4(75.0,0.0,130.0,0.0)/255.0;\n    if(uv.y<1.0/2.15+time)\n    fragColor = vec4(0.0,0.0,255.0,0.0)/255.0;\n    if(uv.y<1.0/2.5+time)\n    fragColor = vec4(0.0,255.0,0.0,0.0)/255.0;\n   \tif(uv.y<1.0/3.0+time)\n    fragColor = vec4(255.0,255.0,0.0,0.0)/255.0;\n    if(uv.y<1.0/4.0+time)\n    fragColor = vec4(255.0,127.0,0.0,0.0)/255.0;\n    if(uv.y<1.0/6.0+time)\n    fragColor = vec4(255.0,0.0,0.0,0.0)/255.0;\n    if(uv.y<1.0/9.5+time)\n    fragColor = vec4(1.0,1.0,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGGW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 741]]}
{"id": "DdVSWV", "name": "Disney BSDF - implementation", "author": "PlathC", "description": "My partial implementation of Disney's BSDF: it lacks SSS and anisotropy.", "tags": ["pathtracer", "disney", "bsdf"], "likes": 3, "viewed": 173, "published": 3, "date": "1684747755", "time_retrieved": "2024-07-30T17:54:28.869924", "image_code": "vec3 ACESFilm( vec3 x )\n{\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn clamp( ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e ), vec3( 0.f ), vec3( 1.f ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x == 0. && fragCoord.y == 0.)\n        return;\n        \n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec3 col = data.xyz;\n    if( data.w > 0.)\n        col /= data.w;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)), 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float SampleNb = 2.;\nconst int   BounceNb = 8;\n\nuvec4 seed;\n\nstruct DiskLight {\n    float height;\n    float radius;\n    vec3  strength;\n    uint  lightId;\n};\n\nDiskLight getLight(uint id) \n{\n   const DiskLight light = DiskLight(5., 2., 10. * vec3(1.000,1.000,1.000), 0u);\n   return light;\n}\n\nLightSample sampleLight(vec3 p) \n{\n    vec2 uv;\n    \n    float lightPdf;\n    DiskLight light = getLight(0u);\n    vec3  lightPos  = sampleDisk(light.height, light.radius, prng(seed).xy);\n    vec3  wi        = normalize(lightPos - p);\n    float pdf       = length2(lightPos - p) / max(1e-4, abs(dot(vec3(0., -1., 0.), -wi)) * getDiskArea(light.radius));\n                        \n    return LightSample(wi, light.strength, pdf);\n}\n\n//-- BSDF implementation\n// For all these functions, ro and rd are transformed s.t. n = (0., 0., 1.)\n\n//- Diffuse\nvec3 evalDisneyDiffuse(HitInfo hit, vec3 wo, vec3 wi)\n{\n    float alpha = max(1e-4, hit.material.roughness * hit.material.roughness);\n    \n    vec3  h   = normalize(wo + wi);\n    float wih = clamp(dot(wi, h), 0., 1.);\n    float won = clamp(abs(wo.z), 1e-4, 1.);\n    float win = clamp(abs(wi.z), 1e-4, 1.);\n    \n    float fd90 = 0.5 + 2. * alpha * wih * wih;\n    float f1   = 1. + (fd90 - 1.) * pow(1. - win, 5.);\n    float f2   = 1. + (fd90 - 1.) * pow(1. - won, 5.);\n    return hit.material.baseColor * OneOverPi * (1. - hit.material.metallic) * f1 * f2;\n}\n\nvec3 sampleDisneyDiffuse(HitInfo hit, vec3 wo, const vec2 u) \n{\n    vec3 wi = sampleCosine(u);\n    if (wo.z < 0.)\n        wi.z *= -1.;\n    return wi;\n}\n\nfloat getPDFDisneyDiffuse(HitInfo hit, vec3 wo, vec3 wi) \n{\n    return wo.z * wi.z > 0. ? abs(wi.z) * OneOverPi : 0.;\n}\n\n//- Specular\nfloat evalSpecularReflection(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n\n    vec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),  1e-4, 1.);\n    float won = clamp(abs(wo.z), 1e-4, 1.);\n    float win = clamp(abs(wi.z), 1e-4, 1.);\n\n    float g = getSmithG2GGX(won, win, alpha2);\n    float d = getDGGX(hn, alpha2);\n\n    return g * d;\n}\n\nfloat getPDFSpecularReflection(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n    \n\tvec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),   1e-4, 1.);\n    float won = clamp(abs(wo.z),  1e-4, 1.);\n    float win = clamp(abs(wi.z),  1e-4, 1.);\n    float wih = clamp(dot(wi, h), 1e-4, 1.);\n\n    float g1 = getSmithG1GGX(wih, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    \n    // Pdf of the VNDF times the Jacobian of the reflection operator\n    return d * g1 * wih / max(1e-4, 4. * win * wih);\n}\n\nfloat getClearCoatRoughness(HitInfo hit) \n{\n    return 0.6 * (1. - hit.material.clearcoatGloss);\n}\n\nfloat evalClearCoat(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, getClearCoatRoughness(hit));\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n\n    vec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),  1e-4, 1.);\n    float won = clamp(abs(wo.z), 1e-4, 1.);\n    float win = clamp(abs(wi.z), 1e-4, 1.);\n\n    float g = getSmithG2GGX(won, win, alpha2);\n    float d = getDGGX(hn, alpha2);\n\n    return hit.material.clearcoat * 0.25 * g * d;\n}\n\nfloat getPDFClearCoat(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, getClearCoatRoughness(hit));\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n    \n\tvec3  h   = normalize(wo + wi);\n    float hn  = clamp(abs(h.z),   1e-4, 1.);\n    float won = clamp(abs(wo.z),  1e-4, 1.);\n    float win = clamp(abs(wi.z),  1e-4, 1.);\n    float wih = clamp(dot(wi, h), 1e-4, 1.);\n\n    float g1 = getSmithG1GGX(wih, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    \n    // Pdf of the VNDF times the Jacobian of the reflection operator\n    return hit.material.clearcoat * 0.25 * d * g1 * wih / max(1e-4, 4. * win * wih);\n}\n\nfloat evalSpecularTransmission(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n\n    float inside   = sign(wo.z);\n    bool  isInside = inside < 0.; \n\n    const float AirIOR = 1.f;\n    float etaI = isInside ? AirIOR : hit.material.ior;\n    float etaT = isInside ? hit.material.ior : AirIOR;\n\n    vec3  h   = normalize(-(etaI * wi + etaT * wo));\n    float hn  = clamp(abs(h.z),        1e-4, 1.);\n    float won = clamp(abs(wo.z),       1e-4, 1.);\n    float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n    float win = clamp(abs(wi.z),       1e-4, 1.);\n    float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n    float g2 = getSmithG1GGX(wih, alpha2) * getSmithG1GGX(woh, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    float w  = wih * woh / max(1e-4, win * won);\n    float s  = etaI * wih + etaT * woh;\n    \n    return w * etaT*etaT * g2 * d / max(1e-4, s*s);\n}\n\nfloat getPDFSpecularTransmission(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);  \n    \n    float inside   = sign(wo.z);\n    bool  isInside = inside < 0.; \n\n    const float AirIOR = 1.f;\n    float etaI = isInside ? AirIOR : hit.material.ior;\n    float etaT = isInside ? hit.material.ior : AirIOR;\n\n    vec3  h   = normalize(-(etaI * wi + etaT * wo));\n    float hn  = clamp(abs(h.z),        1e-4, 1.);\n    float won = clamp(abs(wo.z),       1e-4, 1.);\n    float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n    float win = clamp(abs(wi.z),       1e-4, 1.);\n    float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n    float g1 = getSmithG1GGX(wih, alpha2);\n    float d  = getDGGX(hn, alpha2);\n    \n    float s                    = etaI * wih + etaT * woh;\n    float transmissionJacobian = etaT*etaT * woh / max(1e-4, s*s);\n    float vndf                 = g1 * wih * d    / win;\n    \n    return transmissionJacobian * vndf;\n}\n\n// Linear interpolation between Fresnel metallic and dielectric based on \n// material.metallic. \n// Found: https://schuttejoe.github.io/post/disneybsdf/\nvec3 getDisneyFresnel(HitInfo hit, vec3 wo, vec3 wi, vec3 h)\n{\n    float luminance = getLuminance(hit.material.baseColor);\n    vec3 tint       = luminance > 0. ? hit.material.baseColor * (1. / luminance) : vec3(1.);\n    \n    vec3 baseR0 = vec3(iorToReflectance(hit.material.ior));\n    vec3 r0     = mix(baseR0, tint, hit.material.specularTint);\n    r0          = mix(r0, hit.material.baseColor, hit.material.metallic);\n\n    float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n    float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n    \n    vec3 dielectricF = schlickFresnel(baseR0, woh);\n    vec3 metallicF   = schlickFresnel(r0, wih);\n    \n    return mix(dielectricF, metallicF, hit.material.metallic);\n}\n\nvec3 evalBSDF(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float win       = clamp(abs(wi.z),       1e-4, 1.);\n    float won       = clamp(abs(wo.z),       1e-4, 1.);\n    bool  entering  = wi.z > 0.;\n    bool  doReflect = wi.z * wo.z > 0.f;\n    \n    vec3 weight = vec3(1.);\n    if (!entering && hit.material.specularTransmission > 0.f)\n        weight *= exp(log(hit.material.transmittance) * abs(hit.t) / hit.material.atDistance);\n\n    const float AirIOR = 1.f;\n    float etaI = entering ? hit.material.ior : AirIOR;\n    float etaT = entering ? AirIOR : hit.material.ior;\n\n    if( doReflect )\n    {\n        vec3 h = normalize(wi + wo);\n        vec3 f = getDisneyFresnel(hit, wi, wo, h);\n\n        float roughness = max(1e-4, hit.material.roughness);\n        float alpha     = max(1e-4, roughness * roughness);\n        float alpha2    = max(1e-4, alpha * alpha);\n\n        float nh  = clamp(abs(h.z),        1e-4, 1.);\n        float lh  = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n        float diffuseWeight = 1. - hit.material.specularTransmission;\n        vec3  diffuse       = diffuseWeight * evalDisneyDiffuse(hit, wo, wi);\n        float specular      = evalSpecularReflection(hit, wo, wi);\n        \n        float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n        float ccf = schlickFresnel(vec3(iorToReflectance(1.5)), woh).x;\n\n        return weight * ((1. - f) * diffuse + f * specular + ccf * evalClearCoat(hit, wo, wi));\n    }\n    else \n    {\n        vec3 h = normalize(-(etaI * wi + etaT * wo));\n        vec3 f = getDisneyFresnel(hit, wi, wo, h);\n\n        float transmissionWeight   = hit.material.specularTransmission;\n        float specularTransmission = transmissionWeight * evalSpecularTransmission(hit, wo, wi);\n        return weight * (sqrt(hit.material.baseColor) * (1. - f) * specularTransmission);\n    }\n}\n\nvec3 sampleBSDF(HitInfo hit, vec3 wo, out vec3 weight, out float pdf)\n{\n    float roughness = max(1e-4, hit.material.roughness);\n    float alpha     = max(1e-4, roughness * roughness);\n    float alpha2    = max(1e-4, alpha * alpha);\n    \n    float inside   = sign(wo.z);\n    bool  isInside = inside < 0.; \n\n    pdf    = 1.;\n    weight = vec3(1.);\n    if (isInside && hit.material.specularTransmission > 0.f)\n       weight *= exp(log(hit.material.transmittance) * abs(hit.t) / hit.material.atDistance);\n\n    vec4 u = prng(seed);\n    vec3 h = hit.normal;\n    \n    vec2 alea = prng(seed).xy;\n    if(hit.material.clearcoat > 0.) {\n        float ccRoughness = getClearCoatRoughness(hit);\n        float ccAlpha     = max(1e-4, ccRoughness * ccRoughness);\n        float ccAlpha2    = max(1e-4, ccAlpha * ccAlpha);\n\n        vec3 ccH = h;\n        if(ccRoughness > .0)\n            ccH = SampleVndf_GGX(u.xy, wo, vec2(ccAlpha));\n        \n        float woh = clamp(abs(dot(wo, ccH)), 1e-4, 1.);\n        float ccf = schlickFresnel(vec3(iorToReflectance(1.5)), woh).x;\n        if(alea.y < ccf) {\n            vec3  wi = reflect(-wo,ccH);\n\n            float hn  = clamp(abs(ccH.z),        1e-4, 1.);\n            float woh = clamp(abs(dot(wo, ccH)), 1e-4, 1.);\n            float wih = clamp(abs(dot(wi, ccH)), 1e-4, 1.);\n\n            float g1 = getSmithG1GGX(woh, ccAlpha2);\n            float g2 = getSmithG1GGX(wih, ccAlpha2) * g1;\n            weight  *= hit.material.clearcoat * g2 / max(1e-4, g1);\n            pdf     *= 1.;\n            return wi;\n        }\n    }\n    \n    if (roughness > 0.)\n        h = SampleVndf_GGX(u.xy, wo, vec2(alpha));\n\n    vec3 f = getDisneyFresnel(hit, wo, wo, h);\n\n    float specularWeight = length(f); \n    bool  fullSpecular   = roughness == 0. && hit.material.metallic == 1.;\n    float type           = fullSpecular ? 0. : prng(seed).x;\n    \n#define GROUND_TRUTH\n\n    if (type < specularWeight)\n    {\n        vec3  wi = reflect(-wo, h);\n\n#ifdef GROUND_TRUTH\n        float hn  = clamp(abs(h.z),        1e-4, 1.);\n        float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n        float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n        float g1 = getSmithG1GGX(woh, alpha2);\n        float g2 = getSmithG1GGX(wih, alpha2) * g1;\n        weight  *= sqrt(hit.material.baseColor) * g2 / max(1e-4, g1);\n        pdf     *= 1.;\n#else\n        weight *= f * evalSpecularReflection(hit, wo, wi) ;\n        pdf    *= getPDFSpecularReflection(hit, wo, wi);\n        pdf    *= fullSpecular ? 1. : specularWeight;\n#endif\n        return wi;\n    }\n   \n    float transmissionType           = type - specularWeight;\n    float specularTransmissionWeight = (1. - specularWeight) * hit.material.specularTransmission;\n    if(transmissionType < specularTransmissionWeight) \n    {\n        const float AirIOR = 1.f;\n        float etaI = isInside ? hit.material.ior : AirIOR;\n        float etaT = isInside ? AirIOR : hit.material.ior;\n        vec3 wi    = refract(-wo, h, etaI / etaT);\n\n        // surface absorption: we multiply the refraction result by the square root of the surface color,\n        // which, after both the entering and exiting scattering events are accounted for, produces the\n        // expected albedo.\n\n#ifdef GROUND_TRUTH\n        float woh = clamp(abs(dot(wo, h)), 1e-4, 1.);\n        float wih = clamp(abs(dot(wi, h)), 1e-4, 1.);\n\n        float g1 = getSmithG1GGX(wih, alpha2);\n        float g2 = getSmithG1GGX(woh, alpha2) * g1;\n        weight *= sqrt(hit.material.baseColor) * g2 / max(1e-4, g1 * abs(wo.z));\n        pdf = 1.;\n#else\n        weight *= sqrt(hit.material.baseColor) * hit.material.specularTransmission * evalSpecularTransmission(hit, wo, wi);\n        pdf    *= hit.material.specularTransmission * getPDFSpecularTransmission(hit, wo, wi);\n#endif\n#undef GROUND_TRUTH\n        return wi;\n    }\n    \n    vec3 wi = sampleDisneyDiffuse(hit, wo, prng(seed).xy);\n\n    weight = (1. - hit.material.specularTransmission) * (1. - f) * evalDisneyDiffuse(hit, wo, wi); \n    pdf    = (1. - hit.material.specularTransmission) * getPDFDisneyDiffuse(hit, wo, wi);\n\n    return wi;\n}\n\nfloat getPDFBSDF(HitInfo hit, vec3 wo, vec3 wi) \n{\n    float specular     = getPDFSpecularReflection(hit, wo, wi);\n    float transmission = hit.material.specularTransmission  * getPDFSpecularTransmission(hit, wo, wi);\n    float diffuse      = getPDFDisneyDiffuse(hit, wo, wi);\n    float clearcoat    = getPDFClearCoat(hit, wo, wi);\n\n    return (specular + transmission + diffuse + clearcoat) / 4.;\n}\n\n//-- Geometry acquisition\nHitInfo trace(vec3 ro, vec3 rd) \n{\n    HitInfo hit = defaultHitInfo();\n\n    const uint HashOffset = 15u;\n    const float NbSpheres = 7.;\n    const float r = .7;\n    for(float i = 0.; i < NbSpheres; i++)\n    {\n        for(float j = 0.; j < NbSpheres; j++) \n        {\n            vec3 c = vec3(i + .5 - NbSpheres/2., 0., j  + .5 - NbSpheres/2.) * r * 2.;\n            vec2 tt = iSphere(ro, rd, c, r);\n\n            float t = (tt.x < tt.y && tt.x >= 0.) ? tt.x : tt.y;\n            if(t > 0. && (t < hit.t || hit.t < 0.))\n            {\n                hit.t      = t;\n                hit.normal = ((ro + rd * t) - c) / r;\n                \n                uint hashOffset = HashOffset + uint(i * NbSpheres + j);\n                float hash = hash11(hashOffset);\n                \n                hit.material              = defaultMaterial();\n                hit.material.baseColor    = hash31(hashOffset);\n                hit.material.metallic     = step(.7, hash) * hash11(hashOffset - 2u);\n                hit.material.specularTint = hit.material.metallic * hash11(hashOffset - 4u);\n                hit.material.roughness    = hash11(hashOffset - 1u) * .5;\n                hit.material.ior          = 1.01 + 1.5 * hash;\n                \n                hit.material.specularTransmission = (1. - hit.material.metallic) * hash11(hashOffset - 2u);\n                hit.material.transmittance        = hash31(hashOffset - 4u);\n                hit.material.atDistance           = hash11(hashOffset - 5u) * 1.;\n                \n                hit.material.clearcoat      = hash11(hashOffset - 7u);\n                hit.material.clearcoatGloss = hash11(hashOffset - 8u);\n            }\n        }\n    }\n    \n    vec3 boxNormal;\n    vec2 tt = iBox(ro + vec3(0., r, 0.), rd, vec3(NbSpheres, 0.1, NbSpheres) * (r + .1), boxNormal);\n    float t = tt.x < tt.y && tt.x >= 0. ? tt.x : tt.y;\n    if(t > 0. && (t < hit.t || hit.t < 0.)) {\n        hit.t = t, hit.normal = boxNormal;\n        hit.material = defaultMaterial();\n        hit.material.baseColor = vec3(1.);\n        hit.material.roughness = .3;\n        hit.material.metallic  = .0;\n    }\n    \n    return hit;\n}\n\nvoid getCamera(vec2 fragCoord, vec2 jitter, out vec3 ro, out vec3 rd) {\n    vec2 uv = (fragCoord+(jitter * 2. - 1.)+.5-iResolution.xy*0.5)/iResolution.y;\n    uv.y = -uv.y;\n    \n    vec2 mouse = texelFetch(iChannel0, ivec2(0), 0).zw;\n    \n    ro           = vec3(max(1e-4, mouse.y) * 4e-2, 4., 0.);\n    vec3 forward = normalize( /* target */ - ro);\n    vec3 right   = normalize(cross(forward, vec3(0., 1., 0.)));\n    vec3 up      = normalize(cross(forward, right)); \n    \n    mat3 ruf = mat3(right, up, forward);\n    float a  = tan(Pi * .35);\n    rd       = ruf * normalize(vec3(uv, a));\n    \n    float xStep = mouse.x / iResolution.x;\n    vec4 q = quaternion(xStep * 2. * Pi, vec3(0., 1., 0.));\n    ro = multiply(q, ro), rd = multiply(q, rd);    \n}\n\nvec4 getBlueNoise(vec2 fragCoord, int frame) \n{\n    // Reference: https://www.shadertoy.com/view/tlySzR\n    ivec2 p = ivec2(fragCoord);\n    p = (p+frame*ivec2(113,127)) & 1023;\n    return texelFetch(iChannel2, p, 0);\n}\n\nvec3 render(vec2 fragCoord, int frame)\n{\n\tseed       = uvec4( fragCoord.x, fragCoord.y, frame, 0 );\n    vec2 noise = getBlueNoise(fragCoord, frame).xy;\n    \n    vec3 ro, rd;\n    getCamera(fragCoord, noise, ro, rd);\n    \n    // Light integration\n    vec3 throughput = vec3(1.);\n    vec3 finalColor = vec3(0.);\n    for(int b = 0; b < BounceNb; b++) \n    {\n        HitInfo hit = trace(ro, rd);\n        \n        if(hit.t < 0.) \n        {\n            finalColor += throughput * texture(iChannel1, rd).rgb;\n            break;\n        }\n        \n        vec3 position  = ro + rd * hit.t;\n        vec3 n         = hit.normal;\n        float inside   = sign(dot(n, -rd));\n        bool  isInside = inside < 0.; \n\n        vec3 pposition = offsetRay(position, hit.normal * inside);\n        vec4 transform = toLocalZ(hit.normal);\n        hit.normal     = vec3(0., 0., 1.);\n        vec3 woLocal   = normalize(multiply(transform, -rd));\n        vec3 direct    = vec3( 0. );\n\n        // Direct lighting\n        // Light sampling\n        {\n            LightSample lightSample = sampleLight(pposition);\n            \n            vec3  wiLocal  = normalize( multiply(transform, lightSample.wi) );\n            float cosTheta = wiLocal.z;\n            if( lightSample.pdf > 0. && cosTheta > 0. ) \n            {\n                if( trace(pposition, lightSample.wi).t < 0. ) \n                {\n                    vec3 brdf = evalBSDF(hit, woLocal, wiLocal) * cosTheta;\n                    \n                    float scatteringPdf = getPDFBSDF( hit, woLocal, wiLocal ); \n                    float weight\t\t= powerHeuristic( 1, lightSample.pdf, 1, scatteringPdf );\n\n                    direct += brdf * lightSample.intensity * weight / max(1e-4, lightSample.pdf);\n                }\n            }            \n        }\n        \n        // Sampling BRDF\n        {\n            float scatteringPdf = 0.;\n            vec3  brdf          = vec3(0.);\n            vec3  wiLocal       = sampleBSDF( hit, woLocal, brdf, scatteringPdf );\n            float cosTheta      = wiLocal.z;\n            if( scatteringPdf > 0. && cosTheta > 0. ) \n            {\n                vec3 wi = normalize(multiply(conjugate(transform), wiLocal));\n\n                if(trace(pposition, wi).t < 0.)\n                {\n                    DiskLight light = getLight(0u);\n                    float tt        = iDisk(pposition, wi, vec3(0., light.height, 0.), vec3(0., -1., 0.), light.radius);\n                    if(tt > 0.)\n                    {\n                        vec3  lightPos = pposition + wi * tt;\n                        float lightPdf = length2(lightPos - pposition) / max(1e-4, abs(dot(vec3(0., -1., 0.), -wi)) * getDiskArea(light.radius));\n\n                        float weight = powerHeuristic(1, scatteringPdf, 1, lightPdf);\n\n                        direct += brdf * cosTheta * light.strength * weight / max(1e-4, scatteringPdf);\n                    }\n                }\n            }\n        }\n        finalColor += throughput * direct;\n\n        float scatteringPdf = 0.;\n        vec3  weight        = vec3(0.);\n        vec3  wiLocal       = sampleBSDF(hit, woLocal, weight, scatteringPdf);\n                \n        float cosTheta = abs(woLocal.z);\n        throughput    *= weight * cosTheta / max(1e-4, scatteringPdf);\n\n        if(any(isinf(throughput)) || any(isnan(throughput)) )\n            return vec3(1., 0., 0.);\n    \n        float luminance = getLuminance(throughput);\n        if(luminance == 0.)\n            return vec3(0.);\n\n        // Russian Roulette\n        // Crash course in BRDF implementation\n        float rr = min(luminance, .95f);\n        // https://computergraphics.stackexchange.com/a/2325\n        // float rr = max(throughput.x, max(throughput.y, throughput.z));\n        if (getBlueNoise(fragCoord, frame * int(SampleNb) + b).x > rr)\n            break;\n            \n        throughput *= 1. / rr;\n\n        rd = normalize(multiply(conjugate(transform), wiLocal));\n        ro = offsetRay(position, n * sign(dot(n, rd)));\n    }\n\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 v = ivec2(fragCoord);\n    \n    vec4 lastData       = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 lastResolution = lastData.xy;\n    vec2 lastMouse      = lastData.zw;\n    vec4 data = texture( iChannel0, fragCoord/iResolution.xy );\n    if( iFrame==0 ) data = vec4(0.0);\n\n    vec3 col = vec3(0.);\n    for (float i = 0.; i < SampleNb; i++) \n        col += render(fragCoord, int(data.w + i));\n    col /= SampleNb;\n        \n    if( length(lastResolution - iResolution.xy) > 0. || length(lastMouse - iMouse.xy) > 0. ) \n         data = vec4(col, 0.);\n     data = vec4(col, 1.) + (data.w > 0. ? data : vec4(0.));\n    \n    fragColor = data;\n    if(fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n        fragColor.xy = iResolution.xy;\n        fragColor.zw = iMouse.xy;\n    }\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Pi        = 3.1415;\nconst float OneOverPi = 1. / Pi;\n\n//-- Math\nfloat length2(vec3 v) {return dot(v,v);}\n\nvec4 quaternion(float angle, vec3 axis)\n{\n    float halfAngle = angle / 2.;\n    return vec4(axis.x * sin(halfAngle), axis.y * sin(halfAngle), axis.z * sin(halfAngle), cos(halfAngle));\n}\n\n// Based on GLM implementation\nvec3 multiply(vec4 quat, vec3 p)\n{\n    vec3 quatVector = quat.xyz;\n    vec3 uv         = cross(quatVector, p);\n    vec3 uuv        = cross(quatVector, uv);\n\n    return p + ((uv * quat.w) + uuv) * 2.;\n}\n\nvec4 conjugate(vec4 quat) { return vec4(-quat.x, -quat.y, -quat.z, quat.w); }\n\n// Both n and ref must be normalized\nvec4 toLocal(vec3 n, vec3 ref)\n{\n    if (dot(n, ref) < -1.f + 1e-4f)\n        return vec4(1.f, 0.f, 0.f, 0.f);\n\n    float angle = 1.f + dot(n, ref); // sqrt(length2(n) * length2(ref)) + dot( input, up );\n    vec3  axis  = cross(n, ref);\n    return normalize(vec4(axis, angle));\n}\n\nvec4 toLocalZ(vec3 n) { return toLocal(n, vec3(0., 0., 1.)); }\n\nfloat getDiskArea(float radius) \n{\n    return Pi * radius * radius;\n}\n\nfloat iorToReflectance(float ior)\n{\n    return ((ior - 1.) * (ior - 1.)) / ((ior + 1.) * (ior + 1.));\n}\n\n// Ref: https://en.wikipedia.org/wiki/Relative_luminance\nfloat getLuminance(vec3 rgb)\n{\n    return rgb.x * 0.2126f + rgb.y * 0.7152f + rgb.z * 0.0722f;\n}\n\n//-- Sampling \n\n// Sampling Transformations Zoo\n// Peter Shirley, Samuli Laine, David Hart, Matt Pharr, Petrik Clarberg,\n// Eric Haines, Matthias Raab, and David Cline\n// NVIDIA\nvec3 sampleCosine(vec2 u)\n{\n    // 16.6.1 COSINE-WEIGHTED HEMISPHERE ORIENTED TO THE Z-AXIS\n    float a = sqrt(u.x);\n    float b = 2. * Pi * u.y;\n\n    return vec3(a * cos(b), a * sin(b), sqrt(1.0f - u.x));\n}\n\n// Stratified Sampling of 2-Manifolds, Jim Arvo\n// SIGGRAPH Course Notes 2001\n// Found: https://twitter.com/keenanisalive/status/1529490555893428226?s=20&t=mxRju6YioMmlMOJ1fDVBpw\nvec2 sampleCircle(vec2 u)\n{\n    float  r     = u.x;\n    float  theta = u.y * 2. * Pi;\n    return sqrt(r) * vec2(cos(theta), sin(theta));\n}\n\nvec3 sampleDisk(float height, float radius, vec2 u) \n{\n    vec2 pd   = sampleCircle(u);\n    return vec3(pd.x * radius, height, pd.y * radius);\n}\n\n// https://pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling\nfloat powerHeuristic(int nf, float fPdf, int ng, float gPdf)\n{\n    float f = float(nf) * fPdf, g = float(ng) * gPdf;\n    return (f * f) / (f * f + g * g);\n}\n\n//-- Hashes\n\n// https://www.shadertoy.com/view/Xt3cDn\n// Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat hash11(uint x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\n// Reference: https://www.shadertoy.com/view/XlGcRh\n// Hash Functions for GPU Rendering. Mark Jarzynski, & Marc Olano (2020).\n// Journal of Computer Graphics Techniques (JCGT), 9(3), 20–38.\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    return v;\n}\n\nvec4 prng(inout uvec4 p)\n{\n    p.w++;\n    return vec4(pcg4d(p)) * (1.0/float(0xffffffffu));\n}\n\n//-- Ray\nstruct Material\n{\n    vec3  baseColor;\n    float roughness;\n    float metallic;\n    float ior;\n    float specularTransmission;\n    float specularTint;\n    vec3  transmittance;\n    float atDistance;\n    float clearcoat;\n    float clearcoatGloss;\n\n    // TODO list\n    float anisotropic;\n};\n\nMaterial defaultMaterial() {\n    Material material;\n    material.baseColor            = vec3(1., 0., 1.);\n    material.metallic             = 1.;\n    material.ior                  = 1.52;\n    material.roughness            = 0.;\n    material.specularTransmission = 0.;\n    material.transmittance        = vec3(1.);\n    material.atDistance           = 1.;\n    material.specularTint         = 1.;\n    material.clearcoatGloss       = 0.;\n    material.clearcoat            = 0.;\n    \n\n    return material;\n}\n\nstruct HitInfo\n{\n    float    t;\n    vec3     normal;\n    Material material;\n};\n\nHitInfo defaultHitInfo() {\n    return HitInfo(-1., vec3(0.), defaultMaterial());\n}\n\nstruct LightSample {\n    vec3  wi;\n    vec3 intensity;\n    float pdf;\n};\n\n// A Fast and Robust Method for Avoiding Self-Intersection, Carsten Wächter and Nikolaus Binder, NVIDIA\n// Reference: https://github.com/Apress/ray-tracing-gems/blob/master/Ch_06_A_Fast_and_Robust_Method_for_Avoiding_Self-Intersection/offset_ray.cu\nvec3 offsetRay(vec3 p, vec3 n)\n{\n    const float origin      = 1.0f / 32.0f;\n    const float float_scale = 1.0f / 65536.0f;\n    const float int_scale   = 256.0f;\n\n    ivec3 of_i = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);\n\n    vec3 p_i = vec3(intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0.) ? -of_i.x : of_i.x)),\n                    intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0.) ? -of_i.y : of_i.y)),\n                    intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0.) ? -of_i.z : of_i.z)));\n\n    return vec3(abs(p.x) < origin ? p.x + float_scale * n.x : p_i.x,\n                abs(p.y) < origin ? p.y + float_scale * n.y : p_i.y,\n                abs(p.z) < origin ? p.z + float_scale * n.z : p_i.z);\n}\n\n// https://iquilezles.org/articles/intersectors/\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 c, float r )\n{\n    float d = length( c - ro );\n\tfloat a = 0.f;\n\tif ( d > r )\n\t\ta = d - r;\n\tro += rd * a;\n\n\tvec3 po = ro - c;\n\tfloat proj = dot(rd, po);\n\n\tfloat delta = proj * proj - (dot(po, po) - r * r);\n\tif ( delta < 0.f )\n        return vec2(-1.);\n    \n    float sqrd = sqrt( delta );\n    return vec2(-proj - sqrd, -proj + sqrd) + a;\n}\nfloat iDisk(in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r ) {\n    vec3  o = ro - c;\n    float t = -dot(n,o)/dot(rd,n);\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = (tN>0.0) ? step(vec3(tN),t1) : // ro ouside the box\n                           step(t2,vec3(tF));  // ro inside the box\n    outNormal *= -sign(rd);\n    return vec2( tN, tF );\n}\n\n// Materials\n\nvec3 schlickFresnel(vec3 f0, float cosThetaD) \n{\n    return f0 + (1. - f0) * pow(1. - cosThetaD, 5.);\n}\n\n// Found: https://github.com/boksajak/brdf/blob/master/brdf.h#L710\nfloat getSmithG1GGX(float sn2, float alpha2) {\n\treturn 2. / (sqrt(((alpha2 * (1. - sn2)) + sn2) / sn2) + 1.);\n}\n\n// Moving Frostbite to Physically Based Rendering by Lagarde & de Rousiers\n// Found: https://github.com/boksajak/brdf/blob/master/brdf.h#L653\n// Includes specular BRDF denominator\nfloat getSmithG2GGX(float won, float win, float alpha2) \n{\n    float ggxv = win * sqrt(won * won * (1. - alpha2) + alpha2);\n    float ggxl = won * sqrt(win * win * (1. - alpha2) + alpha2);\n    \n    return 0.5 / (ggxv + ggxl);\n}\n\n// Found: https://github.com/boksajak/brdf/blob/master/brdf.h#L710\nfloat getDGGX(float hn, float alpha2) \n{\n    float b = ((alpha2 - 1.) * hn * hn + 1.);\n\treturn alpha2 / max(1e-4, Pi * b * b);\n}\n\n// Eric Heitz, A Simpler and Exact Sampling Routine for the GGX Distribution of Visible Normals, \n// Technical report 2017\nvec3 sampleGGXVNDF(vec3 V_, float alpha_x, float alpha_y, float U1, float U2)\n{\n    // stretch view\n    vec3 V = normalize(vec3(alpha_x * V_.x, alpha_y * V_.y, V_.z));\n    \n    // orthonormal basis\n    vec3 T1 = (V.z < 0.9999) ? normalize(cross(V, vec3(0,0,1))) : vec3(1,0,0);\n    vec3 T2 = cross(T1, V);\n    \n    // sample point with polar coordinates (r, phi)\n    float a = 1.0 / (1.0 + V.z);\n    float r = sqrt(U1);\n    float phi = (U2<a) ? U2/a * Pi : Pi + (U2-a)/(1.0-a) * Pi;\n    float P1 = r*cos(phi);\n    float P2 = r*sin(phi)*((U2<a) ? 1.0 : V.z);\n    \n    // compute normal\n    vec3 N = P1*T1 + P2*T2 + sqrt(max(0.0, 1.0 - P1*P1 - P2*P2))*V;\n    \n    // unstretch\n    N = normalize(vec3(alpha_x*N.x, alpha_y*N.y, max(0.0, N.z)));\n    return N;\n}\n\n// Sampling Visible GGX Normals with Spherical Caps, Dupuy & Benyoub\n// https://arxiv.org/pdf/2306.05044.pdf\n// Sampling the visible hemisphere as half vectors (our method)\nvec3 SampleVndf_Hemisphere(vec2 u, vec3 wi)\n{\n    // sample a spherical cap in (-wi.z, 1]\n    float phi = 2.0f * Pi * u.x;\n    float z = (1.0f - u.y) * (1.0f + wi.z) - wi.z;\n    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 c = vec3(x, y, z);\n    // compute halfway direction;\n    vec3 h = c + wi;\n    // return without normalization (as this is done later)\n    return h;\n}\n\n#if 0\nvec3 SampleVndf_GGX(vec2 u, vec3 wi, vec2 alpha)\n{\n    // warp to the hemisphere configuration\n    vec3 wiStd = normalize(vec3(wi.xy * alpha, wi.z));\n    // sample the hemisphere (see implementation 2 or 3)\n    vec3 wmStd = SampleVndf_Hemisphere(u, wiStd);\n    // warp back to the ellipsoid configuration\n    vec3 wm = normalize(vec3(wmStd.xy * alpha, wi.z));\n    // return final normal\n    return wm;\n}\n#else \nvec3 SampleVndf_GGX(vec2 u, vec3 wi, vec2 alpha){\n    return sampleGGXVNDF(wi, alpha.x, alpha.y, u.x, u.y);\n}\n#endif ", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 211], [213, 213, 270, 270, 532]]}
{"id": "ctyGWc", "name": "Fam Blue Noise Field", "author": "fffam", "description": "Random background with noise rotation / mesh warp / wave warp\nBased on wdyczG", "tags": ["noise"], "likes": 7, "viewed": 209, "published": 3, "date": "1684747100", "time_retrieved": "2024-07-30T17:54:29.835343", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\n\n// Generate noise with fractional content of sine wave\n// See https://thebookofshaders.com/10/\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(2127.1,81.17)), dot(p,vec2(1269.5,283.37)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float n = mix( mix( dot( -1.0+2.0*hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( -1.0+2.0*hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn 0.5 + 0.5*n;\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragmentColor, in vec2 fragmentCoord )\n{\n    vec2 uv = fragmentCoord/iResolution.xy;\n    vec2 tuv = uv;\n    tuv -= .5;\n\n    // Rotate with Noise\n    float degree = noise(vec2(iTime*.1, tuv.x*tuv.y));\n    float ratio = iResolution.x / iResolution.y;\n    tuv.y *= 1./ratio;\n    tuv *= Rot(radians((degree-.5)*720.+180.));\n\ttuv.y *= ratio;\n    \n    // Wave warp with sin\n    float frequency = 5.;\n    float amplitude = 30.;\n    float speed = iTime * 2.;\n    tuv.x += sin(tuv.y*frequency+speed)/amplitude;\n   \ttuv.y += sin(tuv.x*frequency*1.5+speed)/(amplitude*.5);\n\n    vec3 color1 = vec3(10.0/255.0, 20.0/255.00, 90.0/255.00); //  \t10  20  90\n    vec3 color2 = vec3(57.0/255.0, 78.0/255.00, 239.0/255.00); //    57  78  239\n    vec3 color3 = vec3(72.0/255.0, 211.0/255.00, 205.0/255.00); //    72  211 205\n    vec3 color4 = vec3(38.0/255.0, 58.0/255.00, 196.0/255.00); //    38  58  196\n    \n    vec3 layer1 = mix(color1, color2, S(-.3, .2, (tuv*Rot(radians(-5.))).x));\n    vec3 layer2 = mix(color3, color4, S(-.3, .2, (tuv*Rot(radians(-5.))).x));   \n    vec3 mixed = mix(layer1, layer2, S(.5, -.3, tuv.y));\n    fragmentColor = vec4(mixed,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 256, 277, 277, 384], [386, 386, 412, 412, 877], [879, 879, 898, 898, 974], [976, 976, 1041, 1041, 2145]]}
{"id": "dlK3DK", "name": "2D Lights", "author": "franco1234811", "description": "2D Light using raymarching", "tags": ["raymarching", "2dlight", "cineshader"], "likes": 7, "viewed": 1496, "published": 3, "date": "1684719228", "time_retrieved": "2024-07-30T17:54:30.679087", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 tex = texture(iChannel0, uv);\n    \n    fragColor = tex / tex.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_ITERATIONS 10\n#define MIN_DISTANCE 0.01f\n#define PI 3.14159265358979f\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\n\nstruct Material\n{\n    vec3 emission;\n    float intensity;\n};\n\nstruct NearestData\n{\n    float dist;\n    Material material;\n};\n\nfloat union_sdf(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat subtract_sdf(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nfloat sunion_sdf(float d1, float d2, float k)\n{\n\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat circle_sdf(vec2 point, vec2 pos, float radius)\n{\n    return length(point - pos) - radius;\n}\n\nfloat box_sdf(vec2 point, vec2 center, vec2 size) {\n    center = point - center;\n\tvec2 r = abs(center) - size;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nfloat segment_sdf(vec2 pos, vec2 a, vec2 b)\n{\n    vec2 v = pos - a;\n    vec2 u = b - a;\n    float t = max(min(dot(v, u) / dot(u, u), 1.0f), 0.0f);\n    vec2 d = v - u * t;\n    return length(d);\n}\n\n\nvoid test_sample(inout NearestData nearest, Material material, float sample_distance)\n{\n    if (sample_distance < nearest.dist)\n    {\n        nearest.dist = sample_distance;\n        nearest.material = material;\n    }\n}\n\nvoid sample_sdf(vec2 point, out NearestData nearest)\n{\n    // Material definitions\n    Material black_material;\n    Material white_material;\n    white_material.emission = vec3(1.0f);\n    white_material.intensity = 1.5f;\n    \n    Material green_material;\n    green_material.emission = normalize(vec3(0.4, 0.6, 0.2));\n    green_material.intensity = 1.20f;\n    \n    Material purple_material;\n    purple_material.emission = normalize(vec3(.6, 0.4, 0.8));\n    purple_material.intensity = 1.0f;\n    \n    \n    // SDF\n    \n    // Triangle\n    vec2 a = vec2(1.2, -0.75);\n    vec2 b = vec2(1.3, -0.5);\n    vec2 c = vec2(1.4, -0.7);\n    test_sample(nearest, white_material, segment_sdf(point, a, b));\n    test_sample(nearest, white_material, segment_sdf(point, b, c));\n    test_sample(nearest, white_material, segment_sdf(point, c, a));\n    \n    //test_sample(nearest, white_material, segment_sdf(point, vec2(0.75, -0.75), vec2(1.3, -0.5)));\n    \n    test_sample(nearest, purple_material, box_sdf(point, vec2(1.4, 0.3), vec2(0.10f)));\n    test_sample(nearest, black_material, box_sdf(point, vec2(1.2, 0.3), vec2(0.050f)));\n    \n    \n    for (float i = 0.0f; i < 3.0f; i++)\n    {\n        test_sample(nearest, white_material, box_sdf(point, vec2(0, -i * 0.1f), vec2(0.0050f)));\n    }\n    \n    \n    test_sample(nearest, green_material, circle_sdf(point, vec2(-0.3, -0.3), 0.2f));\n    \n    test_sample(nearest, black_material, circle_sdf(point, vec2(-1, 0.6), 0.6f));\n    test_sample(nearest, black_material,  box_sdf(point, vec2(0.75, 0), vec2(0.5, 0.01)));\n    \n    vec2 moon_pos = vec2(-0.8, -0.6);\n    float moon_radius = 0.3f;\n    float moon_distance = subtract_sdf(circle_sdf(point, moon_pos, moon_radius), circle_sdf(point, moon_pos + vec2(moon_radius * 0.5, 0), moon_radius));\n    test_sample(nearest, green_material, moon_distance);\n    \n    // Subtraction box\n    vec2 box_pos = vec2(0.8, 0.3);\n    float box_size = 0.2;\n    float cut_size = 0.35f;\n    float main_cube_sd = box_sdf(point, box_pos, vec2(box_size));\n    float cut_horizontal_sd = box_sdf(point, box_pos - vec2(box_size * 0.5, 0), vec2(box_size * 2.0f, box_size * cut_size));\n    float cut_vertical_sd = box_sdf(point, box_pos - vec2(0.0f, box_size * 0.5), vec2(box_size * cut_size, box_size * 2.0f));\n    float cut_sphere_sd = circle_sdf(point, box_pos, 0.2f);\n    \n    float k = .015f;\n    float cut_sd = sunion_sdf(cut_horizontal_sd, sunion_sdf(cut_vertical_sd, cut_sphere_sd, k), k);\n    \n    float subtraction_box_sd = subtract_sdf(main_cube_sd, cut_sd);\n    \n\n    test_sample(nearest, purple_material, subtraction_box_sd);\n   \n}\n\nvoid ray_march(vec2 pos, vec2 direction, out vec3 color)\n{\n    \n    color = vec3(0);\n\n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        NearestData nearest;\n        nearest.dist = 10e2;\n        sample_sdf(pos, nearest);\n                \n        if (nearest.dist < MIN_DISTANCE)\n        {\n            color = nearest.material.emission * nearest.material.intensity;\n            return;\n        }\n        pos += direction * nearest.dist;\n    }\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = 2.0f * (uv - 0.5f); // range [-1, 1]\n    pos.x *= iResolution.x / iResolution.y; // fix aspect ratio\n   \n    \n    // Random sampling -------------------------------------------------------------------------------------\n    float pixel_size = 1.0f / iResolution.x; // Size of a single pixel\n    float pixels_offset = 2.0f; // Amount of pixels to randomly offset, this could be the blur\n    float random_value = rand(iTime + pos.x * pos.y);\n    float random_angle = 2.0f * PI * rand(random_value);\n    vec2 offset = random_value * pixels_offset * pixel_size * vec2(cos(random_angle), sin(random_angle));\n    pos += offset;\n    \n    // Multisampled direction raymarch ---------------------------------------------------------------------\n    vec3 accumulated_color = vec3(0);\n    float samples = 4.0f;\n    \n    for (float i = 0.0f; i < samples; i++)\n    {\n        float angle = 2.0f * PI * (i + rand(pos.x * pos.y + iTime + i)) / samples;\n        vec2 direction = vec2(cos(angle), sin(angle));\n        \n        vec3 sample_color;\n        ray_march(pos, direction, sample_color);\n        \n        accumulated_color += sample_color;\n    }\n    \n    vec3 color = accumulated_color / samples;\n      \n    fragColor = vec4(color, 1.0) + texture(iChannel0, uv);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlK3DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 180]]}
{"id": "dlVGDK", "name": "Value noise practice - linear", "author": "huttarl", "description": "Practicing implementation of different kinds of noise.\nThis one is value noise, with a linear ramp (lerp / mix) between lattice points.", "tags": ["noise"], "likes": 2, "viewed": 122, "published": 3, "date": "1684716590", "time_retrieved": "2024-07-30T17:54:31.579679", "image_code": "const vec2 seed = vec2(0.593, 9.928);\nconst float res = 10.0;\n\nfloat hash(vec2 uv) {\n  return fract(sin(dot(seed + uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord*res/iResolution.y + iTime;\n    vec2 lattice = floor(uv);\n    uv = fract(uv);\n    float h00 = hash(lattice);\n    float h01 = hash(lattice + vec2(0.0, 1.0));\n    float h10 = hash(lattice + vec2(1.0, 0.0));\n    float h11 = hash(lattice + vec2(1.0, 1.0));\n    \n    // Linear ramp:\n    vec3 col = vec3(mix(\n        mix(h00, h10, uv.x),\n        mix(h01, h11, uv.x),\n        uv.y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 84, 84, 159], [162, 162, 219, 269, 727]]}
{"id": "DtKGDV", "name": "Color Palette - Simple", "author": "Dirk", "description": "A guide for working with colors in HSV palette then mixing them using weights.", "tags": ["color", "palette", "rgb", "hsv", "colorwheel", "colorscheme"], "likes": 1, "viewed": 147, "published": 3, "date": "1684704022", "time_retrieved": "2024-07-30T17:54:32.643834", "image_code": "\n    // Color Pallet Example\n    // by Dirk Stockton\n    \n    v3 hash32( v2 p ){ // noise by IQ\n        v3 q = v3( dot(p,v2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,v2(419.2,371.9)) );\n        R fract(sin(q)*43758.5453);\n    }\n    \n    v3 color( v3 hsv ){ // HSV->RGB by IQ https://www.shadertoy.com/view/MsS3Wc\n       \n       v3 rgb  = clamp( abs( mod(6.*hsv.x+v3(0.,4.,2.),6.)-3.) -1., 0., 1. ); // Find Hue by IQ\n\n          rgb  = rgb*rgb*(3.0-2.0*rgb);      // Smooth the Hue\n          rgb  = mix( v3(1.0), rgb, hsv.y ); // Mix the Saturation with the Hue\n          rgb *= hsv.z;                      // Scale the the Hue by the Value   \n         \n          R rgb; // Return the RGB color\n           \n    }\n    \n    v3 pallet3( v2 uv, v3 weight, F variance ){  // Tertiary ( Three apposing positions on the color wheel )\n    \n        v2 id = floor(uv); // Cell ID's\n        \n        \n        v3 c  = v3(1.0,0.5,0.5); // Anchor Color ( Painter's term for Base \"Primer-Color\" )\n        \n        F iT = iTime*0.5;\n        v3 t = v3(sin(iT),sin(iT+43.48),sin(iT+453.71));\n        \n        v3 hue = v3(.5+.5*t.x,.5+.5*t.x,.5+.5*t.x); // Hue values of three colors to be used\n        \n        v3 n1 = hash32(id+46.98)*variance*.5+.5*t.x; // Two cell noises with Scalers for mixing and randomness\n        v3 n2 = hash32(id+67.47)*variance*.5+.5*t.z; \n        \n        v3 c1 = mix( c, v3(hue.x,n1.x,n2.x), weight.x ); // Color 1\n        v3 c2 = mix( c, v3(hue.y,n1.y,n2.y), weight.y ); // Color 2\n        v3 c3 = mix( c, v3(hue.z,n1.z,n2.z), weight.z ); // Color 3\n        \n        R color(mix( mix(c1,c2,n1), c3, n2 )); // Mix'em together using our noises - n1 and n2\n        \n    }\n    \n    void loop( out v4 col, in v2 uv ){\n    \n        uv = (2.0*uv-iR.xy)/iR.y; // Center screen UV\n        uv.y += 1.0;              // Stick UV to bottom of screen\n        uv *= 4.0;                // Zoom Out\n        \n        v2 colorID = uv;          // map color ID space \n        colorID.y += iTime;         //and move through time\n        \n        v3 c = pallet3( colorID, v3(0.5,0.5,0.5), 0.5 ); \n        // Change the Pallet using the id( palette space ), and a weight for each color.\n        \n        col = v4( c, 1.0 );\n\n    }\n    \n    ", "image_inputs": [], "common_code": "\n\n    #define loop mainImage\n    #define iR   iResolution.xy\n    \n    #define F float\n    #define I int\n    #define V void\n    \n    #define v2 vec2\n    #define v3 vec3\n    #define v4 vec4\n    \n    #define R return", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 261, 317, 716], [726, 726, 769, 830, 1685], [1695, 1695, 1729, 1729, 2226]]}
{"id": "DlV3DV", "name": "Lens distortion, chromatic shift", "author": "matiasgf", "description": "Lens distortion / chromatic shif", "tags": ["lens", "chromatic"], "likes": 8, "viewed": 272, "published": 3, "date": "1684702375", "time_retrieved": "2024-07-30T17:54:33.518495", "image_code": "// Lens distortion, chromatic shift\n// by matiasgf\n// https://www.shadertoy.com/view/DlV3DV\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = fragCoord.xy;\n  vec3 result = vec3(1.0);\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 vUv = fragCoord/iResolution.xy;\n     \n  vec2 textureSize = iResolution.xy;\n  vec2 sphereCenter = iMouse.xy == vec2(0., 0.) ? iResolution.xy / 2. : iMouse.xy;\n  vec2 spehereCenterUv = sphereCenter / textureSize;\n\n  float sphereRadius = iResolution.y * 0.35;\n  float focusFactor = 0.7;\n  float chromaticAberrationFactor = 0.2;\n\n  float zoom = 1.5;\n  vec2 zoomedUv = zoomUV(\n      vUv, spehereCenterUv, zoom\n  );\n\n  DistortedLens distortion = getLensDistortion(\n    p, zoomedUv, sphereCenter, sphereRadius, focusFactor, chromaticAberrationFactor\n  );\n  \n  float imageDistorted_R = texture(iChannel0, distortion.uv_R).x;\n  float imageDistorted_G = texture(iChannel0, distortion.uv_G).y;\n  float imageDistorted_B = texture(iChannel0, distortion.uv_B).z;\n\n  vec3 imageDistorted = vec3(\n      imageDistorted_R,\n      imageDistorted_G,\n      imageDistorted_B\n  );\n  vec3 image = texture(iChannel0, vUv).xyz;\n  \n  image = mix(image, imageDistorted, distortion.inside);\n  result = vec3(image);\n  \n  // Output to screen\n  fragColor = vec4(result,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 getDistortedUv(vec2 uv, vec2 direction, float factor) {\n  return uv - direction * factor;\n}\n\nstruct DistortedLens {\n  vec2 uv_R;\n  vec2 uv_G;\n  vec2 uv_B;\n  float focusSdf;\n  float speherSdf;\n  float inside;\n};\n\nDistortedLens getLensDistortion(\n  vec2 p,\n  vec2 uv,\n  vec2 sphereCenter,\n  float sphereRadius,\n  float focusFactor,\n  float chromaticAberrationFactor\n) {\n  vec2 distortionDirection = normalize(p - sphereCenter);\n\n  float focusRadius = sphereRadius * focusFactor;\n  float focusStrength = sphereRadius / 2000.0;\n\n  float focusSdf = length(sphereCenter - p) - focusRadius;\n  float speherSdf = length(sphereCenter - p) - sphereRadius;\n  float inside = clamp( -speherSdf / fwidth(speherSdf), 0., 1.);\n  \n  float magnifierFactor = focusSdf / (sphereRadius - focusRadius);\n    \n  float mFactor = clamp(magnifierFactor * inside, 0., 1.);\n  mFactor = pow(mFactor, 4.0);\n\n  vec3 distortionFactors = vec3(\n    mFactor * focusStrength * (1.0 + chromaticAberrationFactor),\n    mFactor * focusStrength,\n    mFactor * focusStrength * (1.0 - chromaticAberrationFactor)\n  );\n  vec2 uv_R = getDistortedUv(uv, distortionDirection, distortionFactors.r);\n  vec2 uv_G = getDistortedUv(uv, distortionDirection, distortionFactors.g);\n  vec2 uv_B = getDistortedUv(uv, distortionDirection, distortionFactors.g);\n\n  return DistortedLens(\n    uv_R,\n    uv_G,\n    uv_B,\n    focusSdf,\n    speherSdf,\n    inside\n  );\n}\n\nvec2 zoomUV(vec2 uv, vec2 center, float zoom) {\n  float zoomFactor = 1.0 / zoom;\n  vec2 centeredUV = uv - center;\n  centeredUV *= zoomFactor;\n  return centeredUV + center;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlV3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 150, 150, 1301]]}
{"id": "ctVGWV", "name": "cos(cxy), rotated, with xor", "author": "isaacchurchill", "description": "Fun colors", "tags": ["2d", "hyperbola"], "likes": 1, "viewed": 143, "published": 3, "date": "1684691620", "time_retrieved": "2024-07-30T17:54:34.349274", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n\n    float a = cos(30.0 * uv.x * uv.y);\n    a = clamp(a * 20.0, -1.0, 1.0);\n    vec3 col = 0.5 + 0.5*vec3(a);\n\n    float theta = iTime * 0.2;\n    mat2 rotmat = mat2(cos(theta), sin(theta),\n                       -sin(theta), cos(theta));\n    uv *= rotmat;\n    \n    a = cos(30.0 * uv.x * uv.y);\n    a = clamp(a * 20.0, -1.0, 1.0);\n    col = col - (0.5 + 0.5*vec3(a));\n    \n    col.xy *= uv.xy;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 555]]}
{"id": "DlG3WV", "name": "Desmos experiment", "author": "isaacchurchill", "description": "Trying out parametric equations in Desmos and moving them to a shader, then messing with them some more", "tags": ["2d", "experiment", "desmos"], "likes": 1, "viewed": 127, "published": 3, "date": "1684690552", "time_retrieved": "2024-07-30T17:54:35.115227", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n\n    uv *= 10.0;\n    vec3 col = vec3(0.0);\n    if (uv.x * tan(uv.y / 2.2) < sin(uv.x + iTime)) {\n        col = vec3(1.0) - col;\n    }\n    float theta = iTime * 0.2;\n    mat2 rotmat = mat2(cos(theta), sin(theta),\n                       -sin(theta), cos(theta));\n    uv *= rotmat;\n    if (uv.x * tan(uv.y / 2.2) < sin(uv.x + iTime)) {\n        col = vec3(1.0) - col;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlG3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 527]]}
{"id": "ctVGDK", "name": "Yet Another radial blur shader", "author": "VEShaderStuff", "description": "If you use this shader, do NOT remove the comment on the first line", "tags": ["blur", "radial"], "likes": 1, "viewed": 205, "published": 3, "date": "1684687234", "time_retrieved": "2024-07-30T17:54:36.161429", "image_code": "// Shader by SomeGuyWhoLikesFNF\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Center point of the blur effect\n    vec2 center = iResolution.xy / 2.0;\n\n    // Radius of the blur effect\n    float radius = 1. * length(fragCoord - center);\n\n    // Number of samples for the blur\n    int numSamples = 17;\n    \n    // Accumulate color and weight for each sample\n    vec3 accumulatedColor = vec3(0.0);\n    float totalWeight = 0.0;\n\n    for (int i = 0; i < numSamples; i++)\n    {\n        // Calculate the current sample position\n        float angle = 2.0 * 3.14159 * float(i) / float(numSamples);\n        vec2 offset = vec2(sin(angle), sin(angle)) * radius / 100.;\n        vec2 samplePos = fragCoord + offset;\n\n        // Sample the color from the original image\n        vec4 sampleColor = texture(iChannel0, samplePos / iResolution.xy);\n\n        // Calculate the weight based on the distance from the center\n        float distance = length(offset);\n        float weight = radius - smoothstep(0.0, radius, distance);\n\n        // Accumulate the color and weight\n        accumulatedColor += sampleColor.rgb * weight;\n        totalWeight += weight;\n    }\n\n    // Normalize the accumulated color\n    vec3 blurredColor = accumulatedColor / totalWeight;\n\n    // Output the final color\n    fragColor = vec4(blurredColor, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 32, 87, 126, 1330]]}
{"id": "dlV3WG", "name": "Zooming clouds", "author": "misol101", "description": "Just an attempt at clouds reusing noise by FabriceNeyret2, https://www.shadertoy.com/view/4tG3Wy. Fullscreen looks slightly more convincing.\n", "tags": ["noise", "clouds", "perlin"], "likes": 11, "viewed": 243, "published": 3, "date": "1684679122", "time_retrieved": "2024-07-30T17:54:37.092938", "image_code": "// based on https://www.shadertoy.com/view/4tG3Wy\n\n#define L  20.\n#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a)) // rot\nfloat T;                                        // B(): base noise\n#define B(u) ( 1. - abs( 2.* texture(iChannel0, (u)/1e3 ).r - 1.) )\n\nfloat N(vec2 u) { // infinite perlin noise with constant image-space spectrum (like Shepard scale)\n\tmat2 M = R(1.7);                            // to decorelate layers\n    float v = 0., t = 0.;\n\tfor (float i=0.; i<L; i++)                  // loop on harmonics\n\t{   float k = mod(i-T,L),\n\t\t      a = 1.-cos(6.28*k/L),             // envelope\n\t\t      s = exp2(k);                      // fractal noise spectrum\n\t\tv += a/s * B(M*u*s); \n\t\tt += a/s;  M *= M;\n\t}\n    return v/t;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n\tvec2  R = iResolution.xy; \n          U = (U-.5*R)/R.y;\n\n    U*=R(iTime/4.);\n\n    float e = 0.10;\n    T = 0.5*iTime;\n    O = vec4( sqrt(smoothstep(.7-e,.37+e, N(vec2(U.x+iTime/1500.,U.y+iTime/1000.)) )) );\n    e = 0.08;\n    T = 0.54*(iTime+0.1);\n    vec4 O2 = vec4( sqrt(smoothstep(.7-e,.37+e, N(vec2(U.x+iTime/3000.,U.y+iTime/2000.)) )) );\n    O = max(O,O2)/1.2+(O+O2)/6.3;\n    e = 0.08;\n    T = 0.52*(iTime+0.3);\n    vec4 O3 = vec4( sqrt(smoothstep(.7-e,.37+e, N(vec2(sin(U.x/1.5)+iTime/30000.,sin(U.y/1.8)+iTime/20000.)) )) );\n    O = max(O,O3)/1.2+((O+O3)*(O+O3))/10.;\n\n    vec4 col = vec4(0.02 + 0.02*cos(iTime+U.y), 0.15 + 0.03*cos(iTime+U.x), 0.45, 1.);\n    O=O/1.5+col;\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlV3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 274, 355, 731], [733, 733, 771, 771, 1451]]}
{"id": "dty3WK", "name": "[Outline 2023]  геометрийн цэцэг", "author": "totetmatt", "description": "mediocre speed run compo. nothing particular", "tags": ["speedrun"], "likes": 5, "viewed": 224, "published": 3, "date": "1684662116", "time_retrieved": "2024-07-30T17:54:38.123183", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    fragColor.rgb /= (fragColor.a);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n // hash functions adapted from Devour\n// https://www.shadertoy.com/view/3llSzM\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec2 hash2(){return vec2(hash(),hash());}\n\n/* vvv your shader goes here vvv */\nvec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\n\nfloat box2(vec2 p,vec2 b){\n    p = abs(p)-b;\n    return length(max(p,vec2(0.)))+min(0.,max(p.x,p.y));\n}\nvec2 bb(vec3 p){\n       float s=1.;\n       for(float i=0.;i++<2.;){\n         \n         p =abs(p)-.5;\n         p*=2.9;\n         s*=2.9;\n         p = erot(p,normalize(vec3(.1,.2,.3)),.785);\n       }\n      vec2 h;\n      h.x = min(box2(p.xy,vec2(.25)),box2(p.yz,vec2(.5)));\n      h.y = 3.;\n      \n      vec2 t;\n    \n      t.x = box2(p.xz,vec2(.2));\n      t.y = 3.;\n      h=t.x < h.x ? t:h;\n      h.x /=s;\n     return  h;\n}\n// tdhooper 4D \nvec4 inverseStereographic(vec3 p) {\n  float k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\nvec3 op=p;\n    float f= length(p);\n    vec2 h;\n  \n    //p.z +=iTime;\n\n    vec4 p4 = inverseStereographic(p);\n     p4.wxy=erot(p4.xyw,normalize(vec3(1.,0.0,0.)),1.);\n    p = stereographic(p4);\n       \n     p=abs(p)-.5;\n   \n    float e = length(p);\n\n  \n    h = bb(p);\n    h.x*=min(1.,1./e)*max(1.,f);\n\n  \n     vec2 t;\n     t.x = length(p.xy)-.05;\n     t.y = 2.;\n     h=t.x < h.x ? t:h;\n    return h;\n}\n\nvec3 q(vec3 p, vec3 s){return s*sdf(p+s).x;}\nvec3 norm(vec3 p, float a){vec2 e=vec2(-a,a);return normalize(q(p,e.xyy)+q(p,e.yxy)+q(p,e.yyx)+q(p,e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n\n\t// set up UVs, jittered for antialiasing\n\tvec2 uv = (gl_FragCoord.xy+hash2()-.5)/iResolution.xy-.5;\n\n    \n\n            vec4 pframe = vec4(texture(iChannel0,fragCoord.xy/iResolution.xy));\n        fragColor = pframe;\n    vec3 col = .1*vec3(1.-sqrt(length(uv)));\n    \n    vec3 ro=vec3(0.25,0.25,-5.25),rt=vec3(0.,1.,2.);\n    vec3 z = normalize(rt-ro);\n    vec3 x= normalize(cross(vec3(0,1.,0.),z));\n    vec3 y = cross(z,x);\n    \n    vec3 rd= mat3(x,y,z)*normalize(vec3(uv,1.-.2*sqrt(length(uv))));\n    vec3 rp=ro;\n   \n    vec3 light = vec3(1.,2.,-3.);\n    float dd= 0.;\n    float i=0.;\n    vec3 acc=vec3(0.);\n    while(i++<128. && dd < 150.){\n        vec2 d = sdf(rp);\n        if(d.y==2.){\n            acc+=vec3(.1,.2,.33)*exp(10.*-abs(d.x))/10.;\n            d.x = max(.001,abs(d.x));\n        }\n        dd+=d.x;\n        rp+=rd*d.x;\n        if(d.x<.0001){\n             vec3 n = norm(rp,.0001);\n             vec3 l = normalize(light-rp);\n             \n             float dif = max(0.,dot(l,n));\n             float fr = 1.-max(0.,1.-dot(rd,n));\n             if(d.y == 3.){\n                rd=reflect(rd,normalize(n));\n                rp+=rd*.01;\n                continue;\n             }\n              \n             break;\n        }\n    }\n   col = mix(col,vec3(.1),-exp(-dd));\n    col= tanh(sqrt(col+acc));\n\n   \n    //Output to screen\n   fragColor.rgb += col;\n    fragColor.a++;\n  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dty3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]]}
{"id": "clG3DV", "name": "Zellij pattern 12 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "arabesque", "zellij"], "likes": 6, "viewed": 227, "published": 3, "date": "1684654747", "time_retrieved": "2024-07-30T17:54:42.579269", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .5*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)-.25;\n    uv.x = mod(uv.x,1.);\n    for(int k = 0; k < 12; k++){\n        uv =\n            abs(.5-uv-t2*sign(uv.y-uv.x))/1.5\n            //abs(-.5*sign(uv.y-uv.x)-uv-t2)/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv-.5*sign(uv.x-uv.y)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        col.x =\n            max((t2.y+t2.x),col.x)\n        ;\n        col =\n            abs(col-1.+col.x);\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx));\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a = a/2. + floor(a/2.)/b*8.;\n    return\n        mod(floor(a),b)\n        //mod(floor(a)*floor(a/b),b)\n        //floor(mod(a*4./b,b))\n        //floor(mod(floor(a+floor(a/2.)),b))\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.*pow(2.,fmod(1.-time/2./8.,2.)),\n  s2 = 8.,\n  m0 = pow(2.,fmod(time/s1,3.)),\n  t = time/m0/2.,\n  m1 = fmod(t,s1);\n  t = pow(2.,fmod(-t*4.+m1,2.))*t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  float\n  m3 =\n      floor(fmod(time*m0*s1,s1)/2.)\n  ;\n  float m2 =\n      1. + fmod(t*s1,s1/2.);\n  ;\n  float a=\n      128.*pow((1.-(fract(t*s1)/5.))/5.,2.)\n  ;\n  float nb = pow(2.,(m3+m2-m1)/5.+8.);\n  return\n      abs(.5-1.*vec2(fract(time*nb*.998),fract(time*nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clG3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1113]]}
{"id": "DlyGDV", "name": "Silver flower pattern", "author": "jarble", "description": "A fractal flower pattern.", "tags": ["fractal", "flower"], "likes": 5, "viewed": 184, "published": 3, "date": "1684653978", "time_retrieved": "2024-07-30T17:54:43.799008", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)-.25;\n    uv.x = mod(uv.x,.5)+.25;\n    for(int k = 0; k < 9; k++){\n        uv =\n            abs(.5-uv-t2*sign(uv.y-uv.x))/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv-.5*sign(uv.x-uv.y)).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        col.x =\n            max(max((t2.y+t2.x*sign(uv.x)),abs(uv.y+uv.x))/6.,col.x)\n        ;\n        col =\n            max(abs(col-1.+col.x),col/3.);\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx));\n    }\n    if (!b) col = abs(1.-col);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a = floor(a*b)/8.*b;\n    return floor(mod(floor(a),b));\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      4.*pow(2.,fmod(1.-time/2./8.,2.)),\n  s2 = 8.,\n  m0 = pow(2.,fmod(time/s1,3.)),\n  t = time/m0/2.,\n  m1 = fmod(t,s1);\n  t = s1*pow(2.,fmod(-t*4.+m1,2.))*t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  float\n  m3 =\n      floor(fmod(time*m0*s1,s1)/2.)\n  ;\n  float m2 =\n      1. + fmod(t,s1/2.);\n  ;\n  float a=\n      128.*pow((1.-(fract(t)/5.))/5.,2.)\n  ;\n  float nb = pow(2.,(m3+m2-m1)/5.+8.);\n  return\n      abs(.5-1.*vec2(fract(time*nb*.998),fract(time*nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1110]]}
{"id": "dlG3Dy", "name": "Pathtracing V2 WIP", "author": "FifthStateOfMatter", "description": "3D", "tags": ["3d"], "likes": 1, "viewed": 190, "published": 3, "date": "1684649514", "time_retrieved": "2024-07-30T17:54:44.855184", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //vec4 col = vec4(texture(iChannel0, uv).xyz, 1);\n    fragColor = texture(iChannel0, uv);\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.0/2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int iterations = 2;\nconst int rayBounces = 10;\nconst float aperture = 0.2;\nconst float focalLength = 5.5;\n\nstruct material{\n    vec3 col;\n    float intensity;\n    float smoothness;\n    float specProb;\n};\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\nvec4[100] scene;\n\nmaterial[100] mats;\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return (fract((p.x + p.y)*p.z)*2.0) - 1.0;\n}\n\nfloat traceSphere(vec3 o, vec3 d, vec4 s){\n    vec3 oc = o - s.xyz;\n    float a = dot(d, d);\n    float b = 2.0*dot(d, oc);\n    float c = dot(oc, oc) - s.w*s.w;\n    float disc = b*b - 4.0*a*c;\n    return disc > 0.0 ? (-b - sqrt(disc))/2.0*a : 100000.0;\n}\n\nfloat traceScene(vec3 o, vec3 d, inout bool hit, inout vec3 normal, inout material mat){\n    float initT = 100000.0;\n    for(int i = 0; i < scene.length(); i++){\n        float t = traceSphere(o, d, scene[i]);\n        if(t < initT && t >= 0.0){\n            initT = t;\n            hit = true;\n            normal = (o + d*t - scene[i].xyz)/scene[i].w;\n            mat = mats[i];\n        }\n    }\n    return initT;\n}\n\nvoid pathtrace(vec3 o, vec3 d, inout vec3 col, float seed){\n    col = vec3(1);\n    bool hit = false;\n    vec3 n = vec3(0);\n    material mat = material(vec3(1), 0.0, 0.0, 0.0);\n    float t = traceScene(o, d, hit, n, mat);\n    vec3 pn = n;\n    material pmat = mat;\n    float iDepth = t;        \n    if(hit){\n        col *= mat.col*mat.intensity;\n        if(mat.intensity > 1.0) return;\n        for(int i = 0; i < rayBounces; i++){\n            hit = false;\n            o = o + d*t;\n            vec3 rd = normalize(vec3(random3(o*2093847.4832 + 293.482 + seed), random3(o*3283742.438 + 213.847 + seed), random3(o*208347.483 + 283.837 + seed)));\n            float dn = dot(rd, pn);\n            rd *= sign(dn);\n            \n            vec3 sd = normalize(reflect(d, pn));\n            \n            float hasSpec = (random3(o*2093847.4832 + 293.482 + seed) + 1.0)/2.0 <= mat.specProb ? 1.0 : 0.0;\n            \n            d = mix(rd, sd, mat.smoothness*(hasSpec));\n            t = traceScene(o, d, hit, n, mat);\n            \n            if(hit){\n                col = mix(col, mat.col, hasSpec);\n                col *= mat.col*mat.intensity*clamp(dn, 0.0, 1.0)*2.0;\n            }else{\n                col = mix(col, mat.col, hasSpec);\n                col *= vec3(1)*mat.intensity*clamp(dn, 0.0, 1.0)*2.0;\n                break;\n            }\n            pn = n;\n            pmat = mat;\n            if(mat.intensity > 1.0) break;\n        }\n    }else{\n        col *= vec3(1);\n        return;\n    }\n    col = mix(col, vec3(1), 1.0 - exp(-iDepth*vec3(0.01, 0.011, 0.015)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    scene[0] = vec4(-1.5, 5, 6, 1);\n    scene[1] = vec4(1.5, 5, 4, 1);\n    scene[2] = vec4(0, -10001, 5, 10000);\n    \n    mats[0] = material(vec3(1), 20.0, 0.0, 0.0);\n    mats[1] = material(vec3(1), 20.0, 0.0, 0.0);\n    mats[2] = material(vec3(1), 0.5, 0.0, 0.0);\n\n    for(int i = 3; i < 100; i++){\n        scene[i] = vec4(float(i - 3)*1.0 - 8.0, 0, ((random3(vec3(i) + 28347.483) + 1.0)/2.0)*20.0 + 5.0, 1);\n        mats[i] = material(vec3(sin(float(i)), 0.5, cos(float(i))), 0.5, 1.2 - float(i)/7.0, 1.2 - float(i)/7.0);\n    }\n    \n    vec3 newCol = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 o = vec3(0, 2, 0);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(radians(10.0), radians(0.0))));\n    vec3 so = o + vec3(random3(d*483092.4837 + float(iFrame)), random3(d*327463.3247 + float(iFrame)), random3(d*227422.2347 + float(iFrame)))*aperture;\n    vec3 focalPoint = o + d*focalLength;\n    vec3 cd = normalize(focalPoint - so);\n    vec3 col = vec3(1);\n    //for(int i = 0; i < iterations; i++){\n        col = vec3(1);\n        pathtrace(so, cd, col, iTime);\n        //newCol += col;\n    //}\n    //newCol /= float(iterations);\n    //col = newCol;\n    fragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //vec4 col = ;\n    fragColor = texture(iChannel1, uv)*(1.0 - 1.0/float(iFrame + 1)) + texture(iChannel0, uv)*1.0/float(iFrame + 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlG3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 248]]}
{"id": "cty3WK", "name": "Posterize / Cel Shade / Cutout", "author": "roel", "description": "Posterize the image using the length of the color. The original color is normalized after which it is multiplied with the posterized length of itself to get to the final result. It's not perfect but the colors remain close to the original input.", "tags": ["filter", "ramp", "toon", "step", "reduce", "shade", "clamp", "posterize", "cel", "reduction", "stepping", "clamping"], "likes": 0, "viewed": 188, "published": 3, "date": "1684627718", "time_retrieved": "2024-07-30T17:54:45.798662", "image_code": "/*\n\nCopyright (c) 2023 Roel Bartstra\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample input texture\n\tvec3 input_color = texture(iChannel0, uv).rgb;\n    \n    // The actual \"posterize\"\n    const float color_length_steps = 5.0;\n    float color_length = length(input_color.rgb);\n    vec3 color_direction = input_color.rgb / color_length;\n    float stepped_color_length = round(color_length * color_length_steps) / color_length_steps;\n    vec3 posterized_color = stepped_color_length * color_direction;\n    \n    // Debugging: Use left mouse for image slite to compare with input.\n    float debug_mask = step(uv.x, iMouse.x / iResolution.x);\n    vec3 output_color = mix(posterized_color, input_color, debug_mask);\n    \n    // Output to screen\n    fragColor = vec4(output_color, 1);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cty3WK.jpg", "access": "api", "license": "mit", "functions": [[1066, 1066, 1123, 1177, 1928]]}
{"id": "dtGGWw", "name": "Year of Truchets #022", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n", "tags": ["raymarching", "tv", "truchet", "inversion"], "likes": 27, "viewed": 241, "published": 3, "date": "1684627321", "time_retrieved": "2024-07-30T17:54:46.889744", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #022\n    05/20/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define PI  3.14159265359\nvec2 curvature = vec2(8.,12.);\n\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.325);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.9, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.9, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = baseColor;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #022\n    05/20/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    75.\n\n// globals & const\nvec3 hit,hp;\nmat2 flip,turn,r90;\n\nconst vec3 size = vec3(1.25);\nconst vec3 hlf = size/2.;\nconst vec3 bs = hlf;\nconst vec3 grid = vec3(4.);\nconst vec3 lrid = vec3(3.);\nconst float thick = .055;\n\nvec3 hue(float t){ return .5 + .4*cos(PI2*t*(vec3(.95,.97,.98)*vec3(0.957,0.439,0.043))); }\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat glow = 0.;\n\nvec2 map(vec3 p, float sg){\n    vec2 res = vec2(1e5,0);\n  \n    //@mla inversion\n    float k = (9.+2.*sin(T*.1))/dot(p,p); \n    p *= k;\n\n    p.yz*=flip; p.xz*=turn;\n\n    vec3 q = p;\n    vec3 r = p+hlf;\n    \n    vec3 id = floor((q + hlf)/size)-grid;\n    vec3 ir = floor((r + hlf)/size)-lrid;\n    \n    float chk2 = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    \n    q = q-size*clamp(round(q/size),-grid,grid);\n    r = r-size*clamp(round(r/size),-lrid,lrid);\n\n    float hs = hash21(id.xz+id.y);\n    float hf = hash21(ir.xz+ir.y+floor(T*.75));\n    \n    if(hs>.5) q.xz*=r90;\n    if(chk2>.5) q.zy*=r90;\n\n    float xhs = fract(2.31*hs+id.y);\n    float trh = 1e5, trx = 1e5, srh = 1e5, dre = 1e5, jre=1e5;\n\n    vec2 qv = vec2(q.xy-hlf.xy);\n    trh = trs(vec3(q+vec3(0,hlf.x,-hlf.y)).yxz,vec2(hlf.x,thick));\n    trx = trs(q+vec3(hlf.x,0,hlf.z),vec2(hlf.x,thick));\n    jre = trs(vec3(q-vec3(hlf.xy,0)).yzx,vec2(hlf.x,thick));\n\n    srh = min(trh,jre);\n    srh = min(srh,trx);\n    srh=max(srh,box(q,bs));\n\n    if(srh<res.x ) {\n        float mt = mod(floor(xhs*20.),4.)+2.;\n        res = vec2(srh,mt);\n    } \n\n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),thick*.85,thick*1.5);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),thick*.85,thick*1.5),crt);\n    crt = min(cap(vec3(q.xz,abs(q.y))-vec3(0,0,hlf),thick*.85,thick*1.5),crt);\n\n    if(crt<res.x) {\n       res = vec2(crt,12.);\n    } \n    \n    float gb = length(r)-(hlf.x*.25); \n    if(sg==1.  && hf>.85 ) { glow += .0001/(.0001+gb*gb);}\n    if(gb<res.x && hf>.85) {\n       res = vec2(gb,11.);\n    } \n    \n    // compensate for the scaling that's been applied\n    float mul = 1./k;\n    res.x = res.x* mul / 1.25;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = 1e-4*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,12);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    // mouse //\n    float x = M.xy==vec2(0) ? .35 : (M.y/R.y * 2.-1.)*PI;\n    float y = M.xy==vec2(0) ? .06 : (M.x/R.x * 2.-1.)*PI;\n\n    float fl = y+(T*.135)+180./PI;\n    float fx = .28*cos(fl*2.);\n    flip=rot(fx);\n    turn=rot(fl);\n    \n    r90=rot(1.5707);\n\n    vec3 C = vec3(.0), p = ro;\n    float m = 0., d = 0.;\n    \n    for(int i=0;i<128;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p,1.);\n        if(ray.x<d*1e-4||d>MAX_DIST)break;\n        d += i<42? ray.x*.3: ray.x * .8;\n        m  = ray.y;\n    } \n\n    if(d<MAX_DIST)\n    {\n\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-10,10,10);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),0. , 1.);\n        float spec = pow(max(dot(reflect(l, n), rd ), .1), 32.)*.75;\n\n    }\n\n    vec3 Fog = mix(vec3(.05),vec3(.75),(uv.y+.45)*.25);\n    \n    C = mix(C,Fog,1.-exp(-.0001*d*d*d));\n    C = mix(C,vec3(.49,.98,.52),clamp(glow*.75,0.,1.));\n    \n    float vw = .6+.5*sin(d*.5+T*.85);\n    float fade = clamp((d*.01)+vw,0.,1.);\n    vec3 clr = m==4.? vec3(.62,.36,.95): m==2. ? vec3(.95,.36,.87) : vec3(.36,.66,.95);\n    if(m!=11.&&m!=12.) C = mix(C,clr,smoothstep(.35,.1,fade)); \n    \n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGGWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[337, 337, 360, 360, 521], [523, 523, 581, 581, 743], [745, 745, 801, 801, 956], [994, 994, 1051, 1051, 1547]]}
{"id": "mlKGDy", "name": "The path to Heaven", "author": "oemfoe", "description": "Just a quick experiment using lissajous and convolution bluring", "tags": ["blur", "lissajous", "path"], "likes": 2, "viewed": 148, "published": 3, "date": "1684615258", "time_retrieved": "2024-07-30T17:54:47.662678", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 hash21(float p)\n{\n    // Hash without Sine\n    // MIT License...\n    /* Copyright (c)2014 David Hoskins.\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.*/\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv0 = uv;\n    float a = iResolution.x/iResolution.y;\n    uv -= 0.5;\n    uv.y /= a;\n\n    if (iTime < 0.1) {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    }\n    \n    //vec2 pos = hash21(iTime * 100.) - 0.5;\n    vec2 pos = vec2(cos(iTime * 3.), sin(iTime * 4.)) / 4.;\n    \n    vec4 col = texture(iChannel0, uv0 + 0.005);\n    \n    vec4 txl = vec4(0.);\n    for (int i = -3; i <= 3; i++)\n    for (int j = -3; j <= 3; j++) {\n        txl += texelFetch(iChannel0, ivec2(fragCoord) + ivec2(i + 1, j + 2), 0) / 49.;\n    }\n    col = txl * 1.005;\n    \n    if (abs(length(uv - pos)) < 0.01)\n        col = vec4(pos + 0.5, 1., 1.);\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 258]]}
{"id": "dlK3Wy", "name": "Horizontal Candy", "author": "oemfoe", "description": "A simple horizontal colorful raster bar shizzle shader for fun.", "tags": ["rasterbar", "horizontal"], "likes": 2, "viewed": 143, "published": 3, "date": "1684609037", "time_retrieved": "2024-07-30T17:54:48.449574", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float a = iResolution.x/iResolution.y;\n    uv -= 0.5;\n    uv.x *= a;\n    uv += 0.5;\n    \n    float nBars = 15.;\n    \n    float bar = smoothstep(0.0, 1./nBars, mod(uv.y, 1./nBars));\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float ripple = 0.5 * sin(uv.y + iTime * 4.) + 0.5;\n    \n    // Output to screen\n    fragColor = vec4(col * ripple + bar * 0.25, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlK3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 561]]}
{"id": "mlVGWy", "name": "Grid-Surfing Balls", "author": "dr2", "description": "Balls rolling on a hexagonal grid of variable-height spherocylinders  (mouse in upper-right to reset balls)", "tags": ["wave", "dynamics", "physics", "surface"], "likes": 23, "viewed": 290, "published": 3, "date": "1684608523", "time_retrieved": "2024-07-30T17:54:49.649366", "image_code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  In addition to collisions with each other and the surface, balls experience\n  gravity and a weak force pulling them towards the grid midpoint.\n  (Based on mix of \"Hexagonally Discretized Waves\", \"Rolling Stones\", etc)\n\n  (No.92 in \"Physical Dynamics\" series - listed at end)\n\nNotes:\n\n   The simulation is tuned for the approx range 50-100 fps; too\n   slow and it won't look good.\n\n   Collisions are highly inelastic, otherwise you see bouncing balls\n   instead of surfing and rolling.\n\n   Two different 'clocks' are required to ensure both numerical stability\n   of the ball dynamics (based on frame counter) as well as decent wave\n   motion visuals independent of GPU speed (wall clock).\n\n   Wave speed can be changed via the parameter 'wtFac' in all Buffers.\n\n   Effective ball speed can be reduced via the timestep parameter 'dt'\n   in all Buffers or by removing Buffers (C/B), and increased by adding\n   an identical Buffer D as in previous shaders of this kind.\n\n   Other parameters are from earlier shaders and should be ok.\n*/\n\n#define AA       0  // (= 0/1) optional antialiasing\n#define SHADOWS  0  // (= 0/1) optional shadows\n\n#define VAR_ZERO min (nFrame, 0)\n\nmat3 QtToRMat (vec4 q);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, vnBall, ltDir;\nvec2 cId, cMid;\nfloat dstFar, tCur, hgSize, wavHt, whFac, wtFac;\nint nFrame, idObj, idBall, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat ObjDf (vec3 p)\n{\n  float h, sy;\n  sy = 5.;\n  h = p.y - wavHt + sy;\n  return min (length (vec3 (p.xz - cMid, sign (h) * max (abs (h) - sy, 0.))) -\n     (hgSize * 0.5 * sqrt3 - 0.005), p.y + 2. * sy);\n}\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid SetConf ()\n{\n  cMid = HexToPix (cId * hgSize);\n  wavHt = WaveHt (cMid);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  dHit = 0.;\n  cId = PixToHex (ro.xz / hgSize);\n  pM = HexToPix (cId);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 400; j ++) {\n    if (j == 0 || cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SetConf ();\n      cNu = false;\n    }\n    d = ObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cId = PixToHex ((ro.xz + dHit * rd.xz) / hgSize);\n      pM += sqrt3 * edN[(s == hv.x) ? 0 : ((s == hv.y) ? 1 : 2)];\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    u = ro - p.xyz;\n    rad = 0.5 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    u = ro - p.xyz;\n    rad = 0.5 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return 0.5 + 0.5 * smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2 + 2));\n  return 0.7 + 0.3 * step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstBall, h, sh;\n  dstObj = ObjRay (ro, rd);\n  dstBall = BallHit (ro, rd);\n  bgCol = vec3 (0.4, 0.4, 0.5);\n  col = bgCol;\n  sh = 1.;\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = vec4 (HsvToRgb (vec3 (0.05 + 0.9 * fract (ro.y / (2.6 * whFac)), 0.4, 1.)), 0.);\n#if SHADOWS\n      sh = BallHitSh (ro + 0.01 * vn, ltDir, 5.);\n#endif\n    } else {\n      ro += dstBall * rd;\n      vn = vnBall;\n      col4 = vec4 (vec3 (1., 0.3, 0.1) * BallChqr (idBall, vnBall), 0.2);\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.8, 1., min (dstObj, dstBall) / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  nBall = int (stDat.x);\n  whFac = stDat.y;\n  wtFac = stDat.z;\n  hgSize = stDat.w;\n  stDat = Loadv4 (1);\n  mPtr.xyz = stDat.xyz;\n  az = 0.;\n  el = -0.18 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.13 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 40., -50.);\n  zmFac = 2.6;\n  dstFar = 200.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (1.), 0.4);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\n/*\n  \"Physical Dynamics\" series (chronological order)\n                                           |\n   \"Molecular Dynamics\"          (4dG3RW)  |  \"Ball Cluster\"                (3sfGD8)\n   \"Granular Vibration\"          (Mdy3RW)  |  \"Molecular Diffusion\"         (3d23z3)\n   \"Puck Dynamics\"               (MsV3zW)  |  \"Freezing and Melting\"        (3dj3Wy)\n   \"Colliding Balls\"             (XsGGRm)  |  \"Maze Ball Solved\"            (tdfXRM)\n   \"Pseudo Billiards\"            (4sy3Rm)  |  \"Particle Scattering\"         (wsjSW1)\n   \"Pseudo Billiards 2\"          (ldy3zm)  |  \"Mondrian in Motion\"          (WdBXDG)\n   \"Balls and Springs\"           (MsV3zw)  |  \"Molecular Waltz\"             (Wt2GWG)\n   \"Reflecting Balls\"            (Xsy3WR)  |  \"Toroidal Mondrian\"           (3lSGWd)\n   \"Flashing Balls\"              (ldVGDR)  |  \"Polymer Chains 2\"            (wlsSWl)\n   \"Quasi Billiards\"             (MsGGD1)  |  \"Colliding Blocks 2\"          (3tSXWz)\n   \"Trapped Balls\"               (4dV3RG)  |  \"Leaping Snakes\"              (ttjXW1)\n   \"Herding Balls\"               (4dKGRt)  |  \"Leaping Snakes 2\"            (3lBXWV)\n   \"Ball Run\"                    (XsyGWG)  |  \"Dice Leaping\"                (3st3WS)\n   \"Stone Spiral\"                (XsyGDc)  |  \"Racetrack\"                   (tscSDn)\n   \"Falling Towers\"              (lsG3W3)  |  \"Leaping Glowsticks\"          (tttGR4)\n   \"Destruction\"                 (XsKGWc)  |  \"Knot Dynamics\"               (ttKXzc)\n   \"Leaping Balls\"               (MdKGWc)  |  \"Bouncing Rings 2\"            (3dScWc)\n   \"Leaping Balls Return\"        (4sG3Wt)  |  \"Floppy Clock With Dice\"      (3sXBDr)\n   \"Stairway from Heaven\"        (4sG3Dt)  |  \"Channeling Marbles\"          (wtfcRr)\n   \"Colliding Blocks\"            (lsG3Wd)  |  \"Truchet Balls\"               (tlXBW4)\n   \"Jumping Cubes\"               (4s3Xzn)  |  \"Marble Paths\"                (wddyDn)\n   \"Faberge Balls\"               (MsdXWn)  |  \"Balls in Spinning Drum\"      (tdcyWs)\n   \"Free the Balls\"              (lttGRn)  |  \"Magic Ball Sorter\"           (tsGyDy)\n   \"Balls and Springs 2\"         (XlGXzz)  |  \"Balls In Motion\"             (WdGBRG)\n   \"Floppy Sheet\"                (MlVSz1)  |  \"Wobbly Blob 2\"               (tsGfzV)\n   \"Stonewashed Flag\"            (MlyXzD)  |  \"Quick Slime 3D\"              (3syBRd)\n   \"More Balls\"                  (MsfyRn)  |  \"Multi-Slime\"                 (wsKBDd)\n   \"Rolling Stones\"              (MdsfD7)  |  \"Soup Can Dynamics\"           (3tKyRt)\n   \"Chocolate Dominoes\"          (ldBfz1)  |  \"Stairway to Hell\"            (sdl3WS)\n   \"Quick Slime\"                 (llsyDn)  |  \"Flagtime\"                    (NsfSR8)\n   \"Ben-Hur Balls\"               (XtfBWf)  |  \"Union Jack Flag\"             (NsXXRN)\n   \"Boxing Day\"                  (ltSfzz)  |  \"Antarctic Flag\"              (sdlSRl)\n   \"Snake Run\"                   (ltjfR1)  |  \"Polymers In Spinning Drum\"   (NsBXDD)\n   \"Refracted Colliding Balls\"   (lljBDR)  |  \"Channeling Slime\"            (NdSSR3)\n   \"Dancing Dumbbells\"           (lstyWr)  |  \"Green Mercury\"               (7tfGDn)\n   \"Polymer Chains\"              (4dcBRs)  |  \"Bouncing Sticks\"             (stsGRj)\n   \"Desert Dumbbells\"            (lsdfD2)  |  \"Dominoes Toppling\"           (stX3DS)\n   \"Reflecting Ben-Hur Balls\"    (MsVfRW)  |  \"Domino Towers\"               (7lXGWf)\n   \"Maze Ball\"                   (ldyBDm)  |  \"Block Impact\"                (7lB3zz)\n   \"Bouncing Rings\"              (MdVBD3)  |  \"Flag From Down Under\"        (NtfXDM)\n   \"Bouncing Chain\"              (XdKBDt)  |  \"Maze Ball Solved 2\"          (ftSXDV)\n   \"Floppy Cylinder\"             (4ltyz4)  |  \"Dynamic 3D Mondrian\"         (7sG3zD)\n   \"Surface Skimmer\"             (XtcBzN)  |  \"Balls Falling\"               (NsKGR3)\n   \"Tempus Fugit\"                (Ml3fW2)  |  \"Rock the Balls\"              (7ltXWX)\n   \"Quasi Billiards 2\"           (4ldBWl)  |  \"Union Jack Flag 2\"           (Nl3BDr)\n   \"Jamming Polymers\"            (XtGfz3)  |\n*/\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashff (float p);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, fOvlap, fricN, fricSW, fricT, hgSize, whFac, wtFac;\nint nFrame, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, e;\n  vec2 cId, cMid, ee[7];\n  float fDamp, fCent, grav, rSep, szN, szAv, ms, dt;\n  fOvlap = 1000.;\n  fricN = 50.;\n  fricSW = 2.;\n  fricT = 0.5;\n  fDamp = 0.1;\n  fCent = 0.006;\n  grav = 5.;\n  p = Loadv4 (4 * mId + 2);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1 + 2).xyz;\n  qm = Loadv4 (4 * mId + 2 + 2);\n  wm = Loadv4 (4 * mId + 3 + 2).xyz;\n  //return;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1 + 2).xyz;\n      wmN = Loadv4 (4 * n + 3 + 2).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  cId = PixToHex (rm.xz / hgSize);\n  e = vec3 (1., 0., -1.);\n  ee[0] = e.yy;\n  ee[1] = e.yx;\n  ee[2] = e.yz;\n  ee[3] = e.xy;\n  ee[4] = e.zy;\n  ee[5] = e.xz;\n  ee[6] = e.zx;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    rmN.xz = HexToPix ((cId + ee[k]) * hgSize);\n    rmN.y = WaveHt (rmN.xz);\n    dr = rm - rmN;\n    dr.y = max (dr.y, 0.);\n    rSep = length (dr);\n    szAv = 0.5 * (sz + 1.);\n    if (rSep < szAv) CollFc (rSep, szAv, dr, vm, wm, am, wam);\n  }\n  rSep = length (rm.xz);\n  if (rSep > 0.) am.xz -= fCent * rm.xz / rSep;\n  am.xz -= fDamp * vm.xz;\n  am.y -= grav * ms;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf, ne;\n  mIdf = float (mId);\n  ne = sqrt (float (nBall));\n  rm.xz = 2. * (vec2 (mod (mIdf, ne), floor (mIdf / ne)) - 0.5 * ne);\n  rm.y = 2.6 * whFac + 1.;\n  vm = 2. * (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float sz, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nBall = 144;\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  doInit = (nFrame <= 2);\n  if (doInit) {\n    whFac = 10.;\n    wtFac = 0.07;\n    hgSize = 1./sqrt3;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    whFac = stDat.y;\n    wtFac = stDat.z;\n    hgSize = stDat.w;\n    nStep = stDat.x;\n    stDat = Loadv4 (1);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0. && Maxv2 (mPtr.xy + 0.03 * vec2 (1. / asp, 1.)) > 0.5 && nStep > 100.)\n     doInit = true;\n  if (doInit) nStep = 0.;\n  mId = (pxId >= 2 && pxId < 4 * nBall + 2) ? (pxId - 2) / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else Step (mId, rm, vm, qm, wm, sz);\n    kp = pxId - 2 - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    if      (pxId == 0) stDat = vec4 (float (nBall), whFac, wtFac, hgSize);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashff (float p);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, fOvlap, fricN, fricSW, fricT, hgSize, whFac, wtFac;\nint nFrame, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, e;\n  vec2 cId, cMid, ee[7];\n  float fDamp, fCent, grav, rSep, szN, szAv, ms, dt;\n  fOvlap = 1000.;\n  fricN = 50.;\n  fricSW = 2.;\n  fricT = 0.5;\n  fDamp = 0.1;\n  fCent = 0.006;\n  grav = 5.;\n  p = Loadv4 (4 * mId + 2);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1 + 2).xyz;\n  qm = Loadv4 (4 * mId + 2 + 2);\n  wm = Loadv4 (4 * mId + 3 + 2).xyz;\n  //return;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1 + 2).xyz;\n      wmN = Loadv4 (4 * n + 3 + 2).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  cId = PixToHex (rm.xz / hgSize);\n  e = vec3 (1., 0., -1.);\n  ee[0] = e.yy;\n  ee[1] = e.yx;\n  ee[2] = e.yz;\n  ee[3] = e.xy;\n  ee[4] = e.zy;\n  ee[5] = e.xz;\n  ee[6] = e.zx;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    rmN.xz = HexToPix ((cId + ee[k]) * hgSize);\n    rmN.y = WaveHt (rmN.xz);\n    dr = rm - rmN;\n    dr.y = max (dr.y, 0.);\n    rSep = length (dr);\n    szAv = 0.5 * (sz + 1.);\n    if (rSep < szAv) CollFc (rSep, szAv, dr, vm, wm, am, wam);\n  }\n  rSep = length (rm.xz);\n  if (rSep > 0.) am.xz -= fCent * rm.xz / rSep;\n  am.xz -= fDamp * vm.xz;\n  am.y -= grav * ms;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf, ne;\n  mIdf = float (mId);\n  ne = sqrt (float (nBall));\n  rm.xz = 2. * (vec2 (mod (mIdf, ne), floor (mIdf / ne)) - 0.5 * ne);\n  rm.y = 2.6 * whFac + 1.;\n  vm = 2. * (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float sz, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nBall = 144;\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  doInit = (nFrame <= 2);\n  if (doInit) {\n    whFac = 10.;\n    wtFac = 0.07;\n    hgSize = 1./sqrt3;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    whFac = stDat.y;\n    wtFac = stDat.z;\n    hgSize = stDat.w;\n    nStep = stDat.x;\n    stDat = Loadv4 (1);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0. && Maxv2 (mPtr.xy + 0.03 * vec2 (1. / asp, 1.)) > 0.5 && nStep > 100.)\n     doInit = true;\n  if (doInit) nStep = 0.;\n  mId = (pxId >= 2 && pxId < 4 * nBall + 2) ? (pxId - 2) / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else Step (mId, rm, vm, qm, wm, sz);\n    kp = pxId - 2 - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    if      (pxId == 0) stDat = vec4 (float (nBall), whFac, wtFac, hgSize);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashff (float p);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, fOvlap, fricN, fricSW, fricT, hgSize, whFac, wtFac;\nint nFrame, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, e;\n  vec2 cId, cMid, ee[7];\n  float fDamp, fCent, grav, rSep, szN, szAv, ms, dt;\n  fOvlap = 1000.;\n  fricN = 50.;\n  fricSW = 2.;\n  fricT = 0.5;\n  fDamp = 0.1;\n  fCent = 0.006;\n  grav = 5.;\n  p = Loadv4 (4 * mId + 2);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1 + 2).xyz;\n  qm = Loadv4 (4 * mId + 2 + 2);\n  wm = Loadv4 (4 * mId + 3 + 2).xyz;\n  //return;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1 + 2).xyz;\n      wmN = Loadv4 (4 * n + 3 + 2).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  cId = PixToHex (rm.xz / hgSize);\n  e = vec3 (1., 0., -1.);\n  ee[0] = e.yy;\n  ee[1] = e.yx;\n  ee[2] = e.yz;\n  ee[3] = e.xy;\n  ee[4] = e.zy;\n  ee[5] = e.xz;\n  ee[6] = e.zx;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    rmN.xz = HexToPix ((cId + ee[k]) * hgSize);\n    rmN.y = WaveHt (rmN.xz);\n    dr = rm - rmN;\n    dr.y = max (dr.y, 0.);\n    rSep = length (dr);\n    szAv = 0.5 * (sz + 1.);\n    if (rSep < szAv) CollFc (rSep, szAv, dr, vm, wm, am, wam);\n  }\n  rSep = length (rm.xz);\n  if (rSep > 0.) am.xz -= fCent * rm.xz / rSep;\n  am.xz -= fDamp * vm.xz;\n  am.y -= grav * ms;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf, ne;\n  mIdf = float (mId);\n  ne = sqrt (float (nBall));\n  rm.xz = 2. * (vec2 (mod (mIdf, ne), floor (mIdf / ne)) - 0.5 * ne);\n  rm.y = 2.6 * whFac + 1.;\n  vm = 2. * (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float sz, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nBall = 144;\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  doInit = (nFrame <= 2);\n  if (doInit) {\n    whFac = 10.;\n    wtFac = 0.07;\n    hgSize = 1./sqrt3;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    whFac = stDat.y;\n    wtFac = stDat.z;\n    hgSize = stDat.w;\n    nStep = stDat.x;\n    stDat = Loadv4 (1);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0. && Maxv2 (mPtr.xy + 0.03 * vec2 (1. / asp, 1.)) > 0.5 && nStep > 100.)\n     doInit = true;\n  if (doInit) nStep = 0.;\n  mId = (pxId >= 2 && pxId < 4 * nBall + 2) ? (pxId - 2) / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else Step (mId, rm, vm, qm, wm, sz);\n    kp = pxId - 2 - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    if      (pxId == 0) stDat = vec4 (float (nBall), whFac, wtFac, hgSize);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlVGWy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1715, 1715, 1737, 1737, 1921], [1923, 1923, 1946, 1946, 2445], [2447, 2447, 2464, 2464, 2525], [2527, 2527, 2560, 2560, 3723], [3725, 3725, 3746, 3746, 4001], [4003, 4003, 4037, 4037, 4462], [4464, 4464, 4511, 4511, 4899], [4901, 4901, 4943, 4943, 5085], [5087, 5087, 5122, 5122, 6058], [6060, 6060, 6116, 6116, 7428], [7430, 7430, 7454, 7454, 7770], [7772, 7772, 7796, 7796, 8026], [8028, 8028, 8052, 8052, 8108], [8110, 8110, 8132, 8132, 8159], [8161, 8161, 8183, 8183, 8221], [8223, 8223, 8247, 8247, 8369], [8371, 8371, 8407, 8407, 8613], [8615, 8615, 8645, 8645, 8758], [8792, 8792, 8816, 8816, 8879], [8881, 8881, 8906, 8906, 9243], [9337, 9337, 9362, 9362, 9485]]}
{"id": "dlKGWy", "name": "bubblin", "author": "ufffd", "description": "lampin in a lava land", "tags": ["lavalamp", "simplex"], "likes": 5, "viewed": 181, "published": 3, "date": "1684608085", "time_retrieved": "2024-07-30T17:54:50.709532", "image_code": "// see breakdown animation here: https://www.shadertoy.com/view/DtK3Dc\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    col = pow(col, vec3(.7));\t// gamma correction (tweaked)\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.141592653589793\n#define MAX_STEP 200\n#define MAX_DIST 10000.\n#define SURF_DIST 0.001\n#define JIGGLE .1\n\n#define DELTA\t\t\t\t0.00005\n#define RAY_COUNT\t\t\t4\n#define RAY_LENGTH_MAX\t\t40.0\n#define RAY_STEP_MAX\t\t60\n#define REFRACT_FACTOR\t\t.6\n#define REFRACT_INDEX\t\t1.15\n#define AMBIENT\t\t\t\t.95\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.7\n#define FADE_POWER\t\t\t1.\n#define FOG                 10.\n\n#define TT                  (iTime*0.4+3.)\n\n\n// simplex noise from https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}", "buffer_a_code": "// with wisdom from:\n// Nrx glass polyhedron - https://www.shadertoy.com/view/4slSzj\n// artofcode raymarch - https://www.shadertoy.com/view/WtGXDD\n// artofcode bending light - https://www.shadertoy.com/view/sllGDN\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat columnDist( vec3 p, vec3 c, vec3 r ) { \n    p.xy *= Rot(r.x);\n    // p.yz *= Rot(r.y);\n    // p.zx *= Rot(r.z);\n    return length(p.xz-c.xy)-c.z; \n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 texNormalMap(in vec2 uv, in sampler2D tx, in vec2 txr)\n{\n    vec2 s = 1.0/txr.xy;\n    \n    float p = texture(tx, uv).x;\n    float h1 = texture(tx, uv + s * vec2(1,0)).x;\n    float v1 = texture(tx, uv + s * vec2(0,1)).x;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nfloat sphereDist(vec3 p, float s) {\n    return length(p) - s;\n}\n\nvec2 map(vec3 p) {\n    float mater = -1.;\n    float d = 1000.;   \n    \n    // noise field\n    vec3 axis = vec3(0.,1.,0.);\n    vec3 nfp = p;\n    nfp.xy *= Rot(sin(TT+p.z));\n    float nf = simplex3d(nfp + vec3(0.,TT,0.));\n    nf += 0.6 - abs(nfp.y)*0.2;\n    \n    if (nf < 0.001) mater = 2.;\n    d = min(d, nf);\n    \n    return vec2(d, mater);\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 mapr = map(p);\n    vec2 e = vec2(.001, 0);\n    \n\tfloat d = mapr.x;\n    vec3 n = vec3(0.);\n    \n    int method = 1;\n    // method 1\n    if (method==1) { \n        n = d - vec3(\n            map(p-e.xyy).x,\n            map(p-e.yxy).x,\n            map(p-e.yyx).x);\n    }\n    // method 2\n    if (method==2) {\n        n = vec3(\n            map(p+e.xyy).x - map(p-e.xyy).x,\n            map(p+e.yxy).x - map(p-e.yxy).x,\n            map(p+e.yyx).x - map(p-e.yyx).x);\n    }\n    \n    return normalize(n);\n}\n\nvec3 getLightPos(in int i) {\n    if (i==1){\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n        return lightPos;\n    }\n}\n\nfloat getLight(vec3 p, vec3 n, in vec3 rd) {\n    vec3 lp = getLightPos(1);\n    vec3 l = normalize(lp-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = map(p+n*SURF_DIST*2.).x;\n    if(d<length(lp-p)) dif *= .1;\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 50.);\n    \n    return dif + spec;\n}\n\nvec3 getCol(vec3 p, float mater, in vec3 rd, in vec3 norm) {\n    vec3 col = vec3(0.);\n    if (mater < 0.) {\n        return vec3(0.0);\n    } else if (mater < 0.5) {\n        col = norm;\n        col *= norm;\n    } else if (mater < 1.5) {\n        col = vec3(sin(norm.r*100.));\n        col *= norm;\n    } else if (mater < 2.5) {\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        vec3 text = texture(iChannel0, txuv).rrr;\n        col = mix(col,text*0.5,1.-col.r);\n        col *= length(p.xy/3.)-0.25;\n        col.r += sin(p.z+108.);\n        col.g += sin(p.z*1.01+112.);\n        col.b += sin(p.z*1.005+105.);\n        col *= sin(p.z*0.9)*0.5+0.5;\n        col /= 2.;\n    } else if (mater < 3.5) {\n        col = norm;\n        col = vec3(sin(norm.b*100.));\n    } else if (mater < 4.5) {\n        col = p * mat3(vec2(0.5), 0.1, vec2(0.2), 0.9, vec2(0.4), 1.);\n        // col = vec3(sin(norm.g*100.));\n    } else {\n        col = vec3(0.9,0.85,0.8) * 0.1;\n    }\n    return col;\n}\nvec3 k = vec3(0.);\n\nbool doesBounce(in float mater) {\n    if (mater > 1.5 && mater < 2.5) return true; // 2\n    if (mater > 4.5 && mater < 5.5) return true; // 5\n    return false;\n}\n\nvec3 materNorm(in float mater, in vec3 norm) {\n    vec3 mN;\n    if (mater > 1.5 && mater < 2.5) {\n        // todo - improve texturing https://www.youtube.com/watch?v=VaYyPTw0V84\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        mN = texNormalMap(txuv, iChannel0, iChannelResolution[0].xy).xyx;\n    }\n    return mN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    ro = vec3(0.); \n    // ro.xz *= Rot(iTime*0.3);\n    ro.z += TT;\n    ro -= JIGGLE*sin(vec3(iTime*1.,iTime*0.22,iTime*0.91));    \n    rd = normalize(vec3(uvc.x, uvc.y, .8));\n    // rd.xz *= Rot(iTime*0.3);\n    rd.yz *= Rot(sin(iTime)*0.05);\n    rd.xy *= Rot(sin(iTime*1.1)*0.05);\n    rd.zx *= Rot(sin(iTime*0.9)*0.05);\n    vec3 ord = rd;\n       \n    \n    float d = 0.;\n    bool hit = false;\n    bool hit_matte = false;\n    float glow = 0.;\n    float mater = -1.;\n\tvec2 delta = vec2 (DELTA, 0.0);\n    \n    float intensity = 0.;\n\n    // vec3 backColor = vec3(0.,0.01,0.02) * (1.-length(uv + vec2(0.,0.3)));\n    vec3 backColor = vec3(54./255., 57./255., 63./255.);\n    col = vec3(0.);\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n        d = 0.; // reset ray dist\n        float ds = 0.; // distance step\n        for(int i=0;i<MAX_STEP;i++){\n            p = ro + rd * d; // update current point\n            vec2 mapr = map(p);\n            ds = mapr.x; // map distance\n            ds *= distanceFactor; // flip sdf when inside\n            mater = mapr.y; // material index\n            ds *= 0.3;\n            d += max(ds, DELTA); // update march distance\n            if(ds<0.) { hit=true; break; } // check hit\n            if(d>MAX_DIST) break; // check limit\n            glow += 1./ds; // add glow\n        }\n        if (!hit) {col = backColor; break;}\n        vec3 norm = distanceFactor*getNorm(p);\n        // material color\n        col += getCol(p,mater,rd,norm) * AMBIENT;\n        // matte lighting\n        float light = getLight(p, norm, rd);\n        if (rayIndex==0) {\n            col += mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        // check for bounces\n        bool do_bounce = doesBounce(mater);\n        if (!do_bounce) {\n            // hit matte, done bouncing\n            break;\n        } else {\n            // col *= 0.1;\n            // apply normal to material 2 - note: make this a conditional if more reflective/refractive materials are added\n            norm += materNorm(mater, norm);\n            \n            vec3 reflection = reflect(rd, norm);            \n            // reflection light (i think it should be in getLight fxn so I can call it with multiple lights)\n            if (distanceFactor > 0.) { // only calculate light on outside\n                vec3 lp = getLightPos(1);\n                vec3 lightDirection = normalize(lp-p);\n                float reflectDiff = max (0.0, dot (norm, lightDirection));\n                float reflectSpec = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + reflectDiff) * localColor + reflectSpec;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n            }\n\n            // Next ray...\n            ro = p;\n            vec3 refraction = refract(rd, norm, refractionRatio);\n            if (dot (refraction, refraction) < DELTA) { // reflect at grazing angles, idk how the dot math works here\n                // fragColor = vec4(1.,1.,0.,1.); return;\n                rd = reflection; // update ray dir to reflected angle\n                ro += rd * DELTA * 2.0; // step away from surface\n            } else {\n                rd = refraction; // update ray dir to refracted angle\n                ro += rd * DELTA * 2.0; // step away from surface - not needed?\n                refractionRatio = 1.0 / refractionRatio; // reverse refraction ratio \n                distanceFactor = -distanceFactor; // flip sdf sign while inside\n            }\n        }\n        \n        // todo: chromatic aberation, optical density, bevel, fresnel reflection\n        // https://www.youtube.com/watch?v=0RWaR7zApEo\n    }\n    \n    col *= 1.+smoothstep(0.3,1.,sin(TT*10.+p.z*2.));\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 128, 128, 326]]}
{"id": "dtKGDG", "name": "tunnel effect on texture", "author": "manji369", "description": "kaleidoscope effect on texture", "tags": ["tunnel"], "likes": 2, "viewed": 139, "published": 3, "date": "1684600893", "time_retrieved": "2024-07-30T17:54:51.624087", "image_code": "// The main function that is called for each pixel on the screen\nvoid mainImage(out vec4 o, vec2 p)\n{\n    // Normalize the coordinates of the pixel to the range [-1, 1] to allow for rotation\n    // This makes the code resolution-independent\n    p = (2. * p - iResolution.xy) / iResolution.y;\n\n    // Calculate the distance of the pixel from the center of the screen\n    float r = length(p);\n\n    // Add a time-dependent offset to the x and y coordinates to create the rotation\n    float x = p.x * cos(iTime) - p.y * sin(iTime);\n    float y = p.x * sin(iTime) + p.y * cos(iTime);\n\n    // Calculate the texture coordinate based on the rotation and distance from the center\n    vec2 uv = vec2(atan(y, x) / (2. * 3.1415) + .5, r);\n\n    // Sample the texture to get the color of the pixel\n    // The RGB components of the texture determine the color of the pixel\n    // The alpha component of the texture determines the transparency of the pixel\n    // Setting the alpha component to 1. creates a fully opaque tunnel effect\n    o = texture(iChannel0, uv) * vec4(1., 1., 1., 1.);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKGDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 101, 240, 1075]]}
{"id": "clV3Wy", "name": "Black hole (volumetric)", "author": "thepinkpanzer", "description": "Black hole with accretion disk. While I tried to include relativistic effects, it is meant to look good, not be accurate. ", "tags": ["raycasting", "space", "nebula", "blackhole"], "likes": 15, "viewed": 526, "published": 3, "date": "1684585515", "time_retrieved": "2024-07-30T17:54:52.400011", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw   = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bloom = texture(iChannel1, fragCoord/iResolution.xy);\n    vec4 psf   = texture(iChannel2, fragCoord/iResolution.xy);\n    \n    fragColor = tanh(pow(psf*0.8+bloom*2.+0.3*raw,vec4(1.5)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159\nfloat Sharp(float v, float n)\n{\n    v = 1.-v;\n    v*= v;\n    return max(0., 1.-n*v);\n}\nvec4 BackgroundColor(vec3 vd)\n{\n    vd = normalize(vd);\n    vec3  a = abs(vd);\n    float m = max(max(a.x, a.y), a.z);\n    vec2 uv;\n    if      (m == a.x)\n    {\n        uv = vec2(vd.z, vd.y);\n    }\n    else if (m == a.y)\n    {\n        uv = vec2(vd.x, vd.z);\n    }\n    else\n    {\n        uv = vec2(vd.x, vd.y);\n    }\n    vec4 col = vec4(0);\n    mat2 rot = mat2(vec2(0.8, 0.6), vec2(-0.6, 0.8));\n    uv *= rot;\n    vec4 r1  = texture(iChannel0, uv/4.);\n    uv *= rot;\n    vec4 r2  = texture(iChannel0, uv/2.);\n    uv *= rot;\n    vec4 r3  = texture(iChannel0, uv/1.);\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r1.r*r1.b, 9.)*3.;\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r1.a)*Sharp(r1.g*r1.r, 9.)*3.;\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r1.a)*Sharp(r1.b*r1.g, 9.)*3.;\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r2.r*r1.a, 4.);\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r2.a)*Sharp(r2.g*r1.b, 4.);\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r2.a)*Sharp(r2.b*r1.g, 4.);\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r3.r*r1.a*r2.a, 2.)*0.5;\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r3.a)*Sharp(r3.g*r1.a*r2.a, 2.)*0.5;\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r3.a)*Sharp(r3.b*r1.g*r2.a, 2.)*0.5;\n    \n    return col;\n}\nfloat SphereDist(float radius, vec3 position, vec3 direction)\n{\n    float d = -dot(position, direction) - sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\nfloat SphereThrough(float radius, vec3 position, vec3 direction)\n{\n    float d = 2.*sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\nfloat Dn(float n, vec3 pos)\n{\n    n   /= ACCDL/BHRAD;\n    pos *= vec3(n, pow(1./((1./n)+N0), NPOW), n) / SCALE;\n    float v = pow(n/ACCDL, 1.4)*SPEED;\n    float p1= 1.1*v*iTime+46.65432*n;\n    float p2= 0.9*v*iTime+54.21345*n;\n    mat3  r1= mat3(vec3( cos(p1), 0, sin(p1)),\n                   vec3(     0  , 1,     0  ),\n                   vec3(-sin(p1), 0, cos(p1)));\n    mat3  r2= mat3(vec3( cos(p2), 0, sin(p2)),\n                   vec3(     0  , 1,     0  ),\n                   vec3(-sin(p2), 0, cos(p2)));\n    vec3 pos1= r1*pos;\n    vec3 pos2= r2*pos;\n    float d1  = texture(iChannel1, pos1/30.).r;\n    float d2  = texture(iChannel1, pos2/20.).g;\n    float d3  = texture(iChannel1, pos1/5. ).b;\n    float d4  = (1./(0.3 + pos.y*pos.y));\n    \n    return exp(7.*d1 + 4.*d2 + 2.*d3 - 8.)*(5./(2. + pos.y*pos.y))*tanh(1./n - 1.) + d3*(2./(1. + pos.y*pos.y)) + d4;\n}\nfloat Density(vec3 pos)\n{\n    float n = ACCDL/length(pos);\n    \n    float n1= floor(n);\n    float n2= ceil(n);\n    \n    float d1= Dn(n1, pos);\n    float d2= Dn(n2, pos);\n    \n    return mix(d1, d2, smoothstep(n1, n2, n));\n}\nvec4 BB(float t)\n{\n    t *= TEMPMULT;\n    vec4 hotblue = vec4(0.25, 0.5, 1, 0);\n    vec4 white   = vec4(1);\n    vec4 red     = vec4(0.8, 0.5, 0.2, 0);\n    return mix(red, mix(hotblue, white, (1./(1.+t*t))), tanh(t));\n}\nfloat Boost(float v)\n{\n    return (sqrt((1.+v)/(1.-v)));\n}\nvec4 Add(vec3 pos, vec3 dir, float density)\n{\n    float temp = 1./dot(pos, pos);\n    float v    = tanh(RVMULT/sqrt(length(pos)))*dot(cross(normalize(pos), vec3(0,1,0)), dir);\n    temp *= Boost(v);\n    return temp*density*BB(temp)*1.;\n}\nvec4 Abs(vec3 pos, float density)\n{\n    return vec4(0.5, 0.6, 0.8, 0)*0.8*density;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse  = iMouse.xy == vec2(0) ? vec2(0.5, 0.45)*iResolution.xy : iMouse.xy;\n    float theta = (mouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (mouse.y - iResolution.y / 2.) / iResolution.y * PI*0.55;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition= -5.*iCameraFwd;\n    \n    float m = 1.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    fragColor           = vec4(0);\n    \n    vec3  pos           = iCameraPosition + iViewDirection*SphereDist(5., iCameraPosition, iViewDirection);\n    vec3  dir           = iViewDirection;\n    float dis           = SphereThrough(5., iCameraPosition, iViewDirection)/NJUMPS;\n    \n    pos += dir*dis/2.;\n    bool absorbed = false;\n    \n    vec4 mult = vec4(1);\n    for (float n = 0.; n < NJUMPS+1.; n++)\n    {\n        dir -= C1*dis*normalize(pos)/dot(pos, pos);\n        dir -= C2*dis*(cross(dir, vec3(0,1,0)))/pow(dot(pos,pos),1.5);\n        dir  = normalize(dir);\n        dis  = min(dis, SphereDist(BHRAD, pos, dir));\n        pos += dir*dis;\n        \n        float dens = Density(pos);\n        mult      *= exp(-dis*Abs(pos, dens)    )     ;\n        fragColor +=      dis*Add(pos, dir, dens)*mult;\n        \n        if (length(pos) <= BHRAD*1.001)\n        {\n            absorbed = true;\n            break;\n        }\n        else if (length(pos) > 5.)\n        {\n            break;\n        }\n    }\n    if (!absorbed)\n    {\n        fragColor += BackgroundColor(dir)*mult*6.;\n    }\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define T(r) pow(texture(iChannel0, r), vec4(2.))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -BLOOMSIZE; i < BLOOMSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(1,0)*i)/iResolution.xy)*exp(-(4.*i*i)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor = tot/(2.*BLOOMSIZE);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define T(r) texture(iChannel0, r)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -BLOOMSIZE; i < BLOOMSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(0,1)*i)/iResolution.xy)*exp(-(4.*i*i)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor = tot/(2.*BLOOMSIZE);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define T(r) pow(texture(iChannel0, r), vec4(1.3))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -PSFSIZE; i < PSFSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(1,0)*i)/iResolution.xy)*(1.-i/PSFSIZE)*(1.+i/PSFSIZE)/sqrt(i*i+1.);\n    }\n    for (float i = -PSFSIZE; i < PSFSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(0,1)*i)/iResolution.xy)*(1.-i/PSFSIZE)*(1.+i/PSFSIZE)/sqrt(i*i+1.);\n    }\n    fragColor = tot/(PSFSIZE);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Post processing\n#define BLOOMSIZE 50.\n#define PSFSIZE   20.\n\n// Number of samples\n#define NJUMPS    200.\n\n// Black hole radius and lensing coefficients\n// C1 is symmetric (normal gravity), C2 is antisymmetric (rotation)\n#define BHRAD     0.3\n#define C1        0.3\n#define C2       -0.07\n\n// Disk thickness (thickness ~ SCALE * pow(r + N0, NPOW))\n#define NPOW      0.5\n#define SCALE     0.03\n#define N0        2.\n\n// Orbit coefficients (number of 'bands' and orbital speed power)\n#define ACCDL     10.\n#define SPEED     150.\n\n// Color coefficients (Doppler strength and temperature)\n#define RVMULT    0.9\n#define TEMPMULT  0.2", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clV3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 316]]}
{"id": "DtV3Wy", "name": "Fork  Fork  Nik NikolaErce 059", "author": "NikolaErceg", "description": "WIP made a previously forked shader audioreactive", "tags": ["mattdamon"], "likes": 0, "viewed": 217, "published": 3, "date": "1684585086", "time_retrieved": "2024-07-30T17:54:53.151004", "image_code": "\nvec2 uv;\nvec2 pos;\n\nfloat hash1(float n) { return fract(sin(n)*43758.5453); }\nvec2 hash2(vec2 p) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3))))*43758.5453); }\n\nvec2 rotate(vec2 p, float a) {\nfloat s = sin(a), c = cos(a);\nreturn mat2(c, s, -s, c) * p;\n}\n\nvec3 physhue2rgb(float h, float r) {\nreturn smoothstep(vec3(0.0), vec3(1.7), abs(mod(h + vec3(2.0, 1.0, 2.0) * (1.0/r), 1.0) * 2.0 - 1.0));\n}\n\nvec4 voronoi(vec2 x, float c, out vec2 rp) {\nvec2 n = floor(x), f = fract(x);\nvec3 m = vec3(4.0);\nfloat m2 = 8.0;\nfor (int j = -3; j <= 2; j++)\nfor (int i = -3; i <= 2; i++) {\nvec2 g = vec2(float(i), float(j)), o = hash2(n + g);\nfloat cid = hash1(dot(n + g, vec2(8.0, 4.0)));\nif (cid < 0.1) o = 0.5 + 0.5 * abs(mod(c + o, 2.0) - 1.0);\nvec2 r = g - f + o;\nvec2 d = vec2(max(abs(r.x)*0.866025+r.y*0.5,-r.y), 1.0);\nif (d.x < m.x) {\nm2 = m.x, m.x = d.x, m.y = cid, m.z = d.y, rp = n + g;\n} else if (d.x < m2) {\nm2 = d.x;\n}\n}\nreturn vec4(m, m2 - m.x);\n}\n\nvec4 render_sheet(vec2 p, float fi, float a) {\n    float z = exp(mix(log(5.0), log(4.5), a));\n    p = rotate(abs(p), radians(4.0));\n    p.y = -p.y;\n    vec2 rp;\n    vec4 c = voronoi(z * p + fi * 128.0 - step(fi, 0.2) * a * 2.0, fi + a * 4.0, rp);\n    rp -= fi * 128.0 - step(fi, 4.2) * a * 2.0;\n    float pp = 0.6 - (max(abs(rp.x) * 0.4 + rp.y * 0.5, -rp.y) / 4.0);\n    pp = clamp(pp, 0.0, 1.0);\n    float fadein = clamp(a * 2.0, 0.0, 1.0);\n    float rep = 1.0 - a - (pp - sin(c.w * 4.0) * 0.1) * fadein;\n    float alpha = clamp((rep - c.w) * 16.0, 0.0, 1.0);\n    if (alpha > 0.3) {\n        float hue = c.w * (1.0 + c.y * 30.0) + fi + a * 9.0 * c.y * mix(1.0, 02.0, step(fi, 0.1)) - abs(p.x);\n        vec3 w = physhue2rgb(hue, 3.3);\n        w.z = 0.5;\n        return vec4(w, alpha);\n    }\n    return vec4(0.0);\n}\n\nvec4 alpha(vec4 a, vec4 b) {\n    a = mix(b, a, a.w);\n    a.w = max(a.w, b.w);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec4 col = vec4(0.2);\n    for (int i = 1; i >= -50; --i) {\n        float fi = float(i);\n        float s = 2.0 / 1.0 * texture(iChannel1, vec2(8.11, 0.9)).g + 1.0;\n        float t = iTime * 0.5 + texture(iChannel1, vec2(0.5, 0.5)).r * .752;\n        float a = fract(t) * s;\n        t -= fract(t);\n        col = alpha(col, render_sheet(vec2(abs(uv.x), uv.y), hash1(t - fi), a + fi * s));\n        if (col.w >= 0.1) break;\n    }\n    float blend = mix(1.5, 1.5, texture(iChannel1, vec2(2.1, 2.21)).b);\n    vec3 co = texture(iChannel1, -uv + col.xy * blend * 6.0).rgb;\n    col.rgb = mix(co, col.rgb, blend);\n    fragColor = col;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtV3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 43, 43, 78], [79, 79, 99, 99, 189], [191, 191, 221, 221, 283], [285, 285, 321, 321, 426], [428, 428, 472, 472, 976], [978, 978, 1024, 1024, 1790], [1792, 1792, 1820, 1820, 1885], [1887, 1887, 1942, 1942, 2693]]}
{"id": "ctV3Wy", "name": " Fork  NikolaErce 52442", "author": "NikolaErceg", "description": "WIP made a previously forked shader audioreactive", "tags": ["mattdamon"], "likes": 2, "viewed": 189, "published": 3, "date": "1684584599", "time_retrieved": "2024-07-30T17:54:53.958844", "image_code": "\nvec2 uv;\nvec2 pos;\n\nfloat hash1(float n) { return fract(sin(n)*43758.5453); }\nvec2 hash2(vec2 p) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3))))*43758.5453); }\n\nvec2 rotate(vec2 p, float a) {\nfloat s = sin(a), c = cos(a);\nreturn mat2(c, s, -s, c) * p;\n}\n\nvec3 physhue2rgb(float h, float r) {\nreturn smoothstep(vec3(0.0), vec3(1.0), abs(mod(h + vec3(0.0, 1.0, 2.0) * (1.0/r), 1.0) * 2.0 - 1.0));\n}\n\nvec4 voronoi(vec2 x, float c, out vec2 rp) {\nvec2 n = floor(x), f = fract(x);\nvec3 m = vec3(4.0);\nfloat m2 = 8.0;\nfor (int j = -3; j <= 2; j++)\nfor (int i = -3; i <= 2; i++) {\nvec2 g = vec2(float(i), float(j)), o = hash2(n + g);\nfloat cid = hash1(dot(n + g, vec2(8.0, 4.0)));\nif (cid < 0.1) o = 0.5 + 0.5 * abs(mod(c + o, 2.0) - 1.0);\nvec2 r = g - f + o;\nvec2 d = vec2(max(abs(r.x)*0.866025+r.y*0.5,-r.y), 1.0);\nif (d.x < m.x) {\nm2 = m.x, m.x = d.x, m.y = cid, m.z = d.y, rp = n + g;\n} else if (d.x < m2) {\nm2 = d.x;\n}\n}\nreturn vec4(m, m2 - m.x);\n}\n\nvec4 render_sheet(vec2 p, float fi, float a) {\n    float z = exp(mix(log(5.0), log(4.5), a));\n    p = rotate(abs(p), radians(4.0));\n    p.y = -p.y;\n    vec2 rp;\n    vec4 c = voronoi(z * p + fi * 128.0 - step(fi, 0.2) * a * 2.0, fi + a * 4.0, rp);\n    rp -= fi * 128.0 - step(fi, 4.2) * a * 2.0;\n    float pp = 0.6 - (max(abs(rp.x) * 0.4 + rp.y * 0.5, -rp.y) / 4.0);\n    pp = clamp(pp, 0.0, 1.0);\n    float fadein = clamp(a * 2.0, 0.0, 1.0);\n    float rep = 1.0 - a - (pp - sin(c.w * 4.0) * 0.1) * fadein;\n    float alpha = clamp((rep - c.w) * 16.0, 0.0, 1.0);\n    if (alpha > 0.3) {\n        float hue = c.w * (1.0 + c.y * 30.0) + fi + a * 9.0 * c.y * mix(1.0, 02.0, step(fi, 0.1)) - abs(p.x);\n        vec3 w = physhue2rgb(hue, 3.3);\n        w.z = 0.5;\n        return vec4(w, alpha);\n    }\n    return vec4(0.0);\n}\n\nvec4 alpha(vec4 a, vec4 b) {\n    a = mix(b, a, a.w);\n    a.w = max(a.w, b.w);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);    \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec4 col = vec4(0.2);\n    for (int i = 1; i >= -50; --i) {\n        float fi = float(i);\n        float s = 2.0 / 1.0 * texture(iChannel1, vec2(8.11, 0.9)).g + 1.0;\n        float t = iTime * 0.5 + texture(iChannel1, vec2(0.5, 0.5)).r * .752;\n        float a = fract(t) * s;\n        t -= fract(t);\n        col = alpha(col, render_sheet(vec2(abs(uv.x), uv.y), hash1(t - fi), a + fi * s));\n        if (col.w >= 0.1) break;\n    }\n    float blend = mix(1.5, 1.5, texture(iChannel1, vec2(2.1, 2.21)).b);\n    vec3 co = texture(iChannel1, -uv + col.xy * blend * 6.0).rgb;\n    col.rgb = mix(co, col.rgb, blend);\n    fragColor = col;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctV3Wy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 43, 43, 78], [79, 79, 99, 99, 189], [191, 191, 221, 221, 283], [285, 285, 321, 321, 426], [428, 428, 472, 472, 976], [978, 978, 1024, 1024, 1790], [1792, 1792, 1820, 1820, 1885], [1887, 1887, 1942, 1942, 2693]]}
{"id": "DlVGWy", "name": "Dots in the Sky", "author": "oemfoe", "description": "A simple star field \"uit de losse pols\"", "tags": ["stars", "starfield"], "likes": 3, "viewed": 264, "published": 3, "date": "1684582951", "time_retrieved": "2024-07-30T17:54:54.730780", "image_code": "vec2 hash21(float p)\n{\n    // Hash without Sine\n    // MIT License...\n    /* Copyright (c)2014 David Hoskins.\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.*/\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 M = iMouse.xy / iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    int t = int(-iTime);\n    vec2 uv0 = uv;\n    fragColor = vec4(0.);\n    //uv0 *= iMouse.x / iResolution.x;\n    for (int j = 0; j < 10; j++) {\n        uv = uv0;\n        float d = mod(float(t + j), 10.) + fract(-iTime);\n        uv *= d;\n        for (int i = 0; i < 100; i++) {\n            vec2 sp = hash21(float(i + 100 * j)) - 0.5;\n            uv = mod(uv, 1.);\n            bool close = uv.x < 0.05 || uv.y < 0.05 || uv.x > 0.95 || uv.y > 0.95;\n            if (!close && abs(length(uv - sp * 2.)) < 0.004) {\n                fragColor = vec4(smoothstep(10., 0., d) * vec3(1.), 1.);\n            }\n        }\n        \n    }\n\n    \n\n    // Output to screen\n    //fragColor = vec4(uv.x, uv.y, 1. ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 1192, 1321], [1325, 1325, 1382, 1432, 2363]]}
{"id": "mlK3DD", "name": "Rhombic Dodecahedron Traversal", "author": "gelami", "description": "Flythrough of a packed spheres / rhombic dodecahedral honeycomb terrain\n\nMouse drag to look around\nDefines in Common", "tags": ["3d", "raytracing", "grid", "voxel", "motionblur", "bloom", "honeycomb", "dodecahedron", "rhombic"], "likes": 46, "viewed": 885, "published": 3, "date": "1684578747", "time_retrieved": "2024-07-30T17:54:55.686225", "image_code": "\n// Rhombic Dodecahedron Traversal - gelami\n// https://www.shadertoy.com/view/mlK3DD\n\n/*\n * Flythrough of a packed sphere grid / rhombic dodecahedral honeycomb terrain\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * The traversal is simply done by finding the nearest cell position from the grid\n * Then for each step intersects the backfaces of a rhombic dodecahedron\n *   and advancing the cell position using its normal\n * \n * It's similar to my hexagon grid shader, but really the method\n *   can be used for any tessellation of a space-filling polytope\n * I have a truncated octahedron grid traversal coming up soon as well\n * \n * Extruded Hexagon Grid Traversal - gelami\n * https://www.shadertoy.com/view/Dly3zm\n * \n * Bloom setup taken from my bloom shader, with a prefiltering threshold added\n *   and without the 3x3 blur on the upsampling pass:\n * 2-Pass Buffer Bloom - gelami\n * https://www.shadertoy.com/view/cty3R3\n *\n * FXAA 3.11 implementation from:\n * Two Grid Traversal w/ 1Pass DoF - gelami\n * https://www.shadertoy.com/view/dtt3DS\n * \n * \n * Other cool space-filling polyhedron shaders:\n * \n * Octahedral Voxel Tracing - fizzer\n * https://www.shadertoy.com/view/4lcfDB\n *\n * Octahedron Grid Raycasting - Poisson\n * https://www.shadertoy.com/view/NlcBzf\n * \n * Truncated Octahedral Voxels - dr2\n * https://www.shadertoy.com/view/3dsXWf\n * \n * Packed Spheres SDF - blackle\n * https://www.shadertoy.com/view/3djBDh\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    #ifdef MOTION_BLUR\n    \n    const float fov = 120.0;\n    const float invTanFov = 1.0 / tan(radians(fov) * 0.5);\n    const float maxMotionBlur = 12.0;\n    \n    float mb = MOTION_BLUR_STRENGTH * dot(ndc, ndc) / invTanFov;\n    vec2 dir = normalize(ndc) / iResolution.xy;\n    \n    float o = texelFetch(iChannel2, ivec2(fragCoord) % 1024, 0).r;\n    o = fract(o + 0.61803398875 * float(iFrame));\n    \n    float w = 1.0;\n    \n    #define MOTION_BLUR_SAMPLES 8\n    for (int i = 0; i < MOTION_BLUR_SAMPLES; i++)\n    {\n        float t = (float(i) + o) / float(MOTION_BLUR_SAMPLES) - 0.5;\n        vec2 p = uv + mb * dir * t;\n        if (p == saturate(p))\n        {\n            col += texture(iChannel0, p).rgb;\n            w++;\n        }\n    }\n    col /= w;\n    #endif\n    \n    #ifdef BLOOM\n    vec3 bloom = vec3(0);\n    \n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 0).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 1).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 2).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 3).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 4).rgb;\n    bloom += SampleLod(iChannel1, uv, iResolution.xy, 5).rgb;\n    \n    bloom /= 6.0;\n    \n    col += bloom * BLOOM_STRENGTH;\n    #endif\n    \n    #if 0\n    col = col / (1.0 + col);\n    col = smoothstep(vec3(0), vec3(1), col);\n    #else\n    col = ACESFilm(col * 0.35);\n    #endif\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define BLOOM\n#define BLOOM_MAX_LOD 6\n#define BLOOM_THRESHOLD 0.6\n#define BLOOM_STRENGTH 0.75\n\n#define CAMERA_SPEED 6.5\n\n#define EMI_SCALE 5.0\n\n#define FXAA\n#define MOTION_BLUR\n\n#define MOTION_BLUR_STRENGTH 4.0\n\n//#define SIMPLE_TRAVERSAL\n#define SPHERES\n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nvec4 SampleLod(sampler2D tex, vec2 uv, vec2 res, const int lod)\n{\n    vec2 hres = floor(res / 2.0);\n    \n    vec2 nres = hres;\n    float xpos = 0.0;\n    int i = 0;\n    for (; i < lod; i++)\n    {\n        xpos += nres.x;\n        \n        nres = floor(nres / 2.0);\n    }\n    \n    vec2 nuv = uv * vec2(nres);\n    \n    nuv = clamp(nuv, vec2(0.5), vec2(nres)-0.5);\n    nuv += vec2(xpos, 0);\n    \n    return texture(tex, nuv / res);\n}\n\nfloat pack(vec2 v)\n{\n    return uintBitsToFloat(packHalf2x16(v));\n}\n\nvec2 unpack(float v)\n{\n    return unpackHalf2x16(floatBitsToUint(v));\n}\n\n// Ray-sphere intersesction\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphereIntersection(vec3 ro, vec3 rd, float ra )\n{\n    vec3 oc = ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    if (b > 0.0 && c > 0.0)\n        return vec2(MAX_DIST);\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Ray-rhombic dodecahedron intersection\nvec2 rhombicDodecahedronIntersection(vec3 ro, vec3 rd, float s, out vec3 normal)\n{\n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    \n    float tN, tF;\n    {\n        vec2 ird = 1.0 / rd.xz;\n        vec2 n = ro.xz * ird;\n        vec2 k = abs(ird) * s;\n\n        vec2 t0 = -n - k;\n        vec2 t1 = -n + k;\n\n        tN = max(t0.x, t0.y);\n        tF = min(t1.x, t1.y);\n\n        normal = vec3(-sign(ird) * step(t0.yx, t0), 0).xzy;\n    }\n    \n    {\n        vec4 ird = 1.0 / vec4(dot(rd, rdn.xzx), dot(rd, rdn.yzx), dot(rd, rdn.xzy), dot(rd, rdn.yzy));\n        vec4 n = ird * vec4(dot(ro, rdn.xzx), dot(ro, rdn.yzx), dot(ro, rdn.xzy), dot(ro, rdn.yzy));\n        vec4 k = abs(ird) * s;\n        \n        vec4 t0 = -n - k;\n        vec4 t1 = -n + k;\n        \n        float t = max(max(t0.x, t0.y), max(t0.z, t0.w));\n        \n        if (t > tN)\n        {\n            if (t0.x == t)\n                normal = rdn.xzx * -sign(ird.x);\n            else if (t0.y == t)\n                normal = rdn.yzx * -sign(ird.y);\n            else if (t0.z == t)\n                normal = rdn.xzy * -sign(ird.z);\n            else\n                normal = rdn.yzy * -sign(ird.w);\n        }\n        \n        tN = max(tN, t);\n        tF = min(tF, min(min(t1.x, t1.y), min(t1.z, t1.w)));\n    }\n    \n    if (tN > tF)\n    {\n        tN = MAX_DIST;\n        tF = MAX_DIST;\n    }\n    \n    return vec2(tN, tF);\n}\n\n// Same as above but returns the far normal\nvec2 rhombicDodecahedronIntersection2(vec3 ro, vec3 rd, float s, out vec3 normal)\n{\n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    \n    float tN, tF;\n    {\n        vec2 ird = 1.0 / rd.xz;\n        vec2 n = ro.xz * ird;\n        vec2 k = abs(ird) * s;\n\n        vec2 t0 = -n - k;\n        vec2 t1 = -n + k;\n\n        tN = max(t0.x, t0.y);\n        tF = min(t1.x, t1.y);\n\n        normal = vec3(-sign(ird) * step(t1, t1.yx), 0).xzy;\n    }\n    \n    {\n        vec4 ird = 1.0 / vec4(dot(rd, rdn.xzx), dot(rd, rdn.yzx), dot(rd, rdn.xzy), dot(rd, rdn.yzy));\n        vec4 n = ird * vec4(dot(ro, rdn.xzx), dot(ro, rdn.yzx), dot(ro, rdn.xzy), dot(ro, rdn.yzy));\n        vec4 k = abs(ird) * s;\n        \n        vec4 t0 = -n - k;\n        vec4 t1 = -n + k;\n        \n        float t = max(max(t0.x, t0.y), max(t0.z, t0.w));\n        float t2 = min(tF, min(min(t1.x, t1.y), min(t1.z, t1.w)));\n        \n        if (t2 < tF)\n        {\n            if (t1.x == t2)\n                normal = rdn.xzx * -sign(ird.x);\n            else if (t1.y == t2)\n                normal = rdn.yzx * -sign(ird.y);\n            else if (t1.z == t2)\n                normal = rdn.xzy * -sign(ird.z);\n            else\n                normal = rdn.yzy * -sign(ird.w);\n        }\n        \n        tN = max(tN, t);\n        tF = min(tF, t2);\n    }\n    \n    if (tN > tF)\n    {\n        tN = MAX_DIST;\n        tF = MAX_DIST;\n    }\n    \n    return vec2(tN, tF);\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .55 + .45 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0.5, 0.25, 0.75)));\n}\n\nvec3 palette2(float t)\n{\n    return .58 + .42 * cos(TAU * (vec3(1, 0.6, 0.6) * t + vec3(0.5, 0.3, 0.25)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "\n// Scene\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-14 11:59:30\n\nvec3 getID(vec3 p)\n{\n    p -= 0.5;\n    p.y /= sqrt(2.0);\n    \n    vec3 id0 = floor(p);\n    vec3 id1 = floor(p + 0.5);\n    \n    vec3 p0 = fract(p) - 0.5;\n    vec3 p1 = fract(p + 0.5) - 0.5;\n    \n    p0.y *= sqrt(2.0);\n    p1.y *= sqrt(2.0);\n    \n    float d0 = dot(p0, p0);\n    float d1 = dot(p1, p1);\n    \n    vec3 id = d0 < d1 ? id0 : id1 - 0.5;\n    \n    id += 0.5;\n    id.y *= sqrt(2.0);\n    \n    return id;\n}\n\nvec3 getLightsID(vec3 p)\n{\n    const float s = EMI_SCALE;\n    \n    p.xz *= rot2D(PI/4.0);\n    p.yx *= rot2D(PI/4.0);\n    \n    vec3 id = (floor(p / s) + 0.5) * s;\n    \n    id.yx *= rot2D(-PI/4.0);\n    id.xz *= rot2D(-PI/4.0);\n    \n    return id;\n}\n\nvec3 IDToPos(vec3 id)\n{\n    id = id * 0.5 + 0.5;\n    id.y *= sqrt(2.0);\n    \n    return id;\n}\n\nvec3 posToID(vec3 p)\n{\n    p.y *= 1.0 / sqrt(2.0);\n    p = (p - 0.5) * 2.0;\n    return floor(p);\n}\n\nvec3 getCameraPos(float time)\n{\n    return vec3(sin(time*0.3)*3.0 + cos(time*0.8)*2.0, cos(time * 0.2) + sin(time * 0.5) * 4.0, time * CAMERA_SPEED);\n}\n\nfloat map(vec3 p)\n{\n    //p = IDToPos(posToID(p));\n    \n    p.y *= -1.0;\n    vec3 dp = p - vec3(-2,5,7);\n    \n    dp *= 0.1 / 32.0;\n    \n    float d = texture(iChannel1, dp).r*0.5;\n    d += texture(iChannel1, dp*2.0).r*0.25;\n    d += texture(iChannel1, dp*4.0).r*0.125;\n    //d += texture(iChannel1, dp*8.0).r*0.0625;\n    \n    // 0.9375\n    d = d / 0.825 - 0.51;\n    \n    p.y *= -1.0;\n    vec3 po = texture(iChannel2, 0.3 * p / 32.0).rgb - 0.5;\n    vec3 pc = p + po * 4.0;\n    float pdc = (length(pc.xy - getCameraPos(pc.z / CAMERA_SPEED).xy)) - 4.8;\n    \n    d = max(d * 32.0 / 0.1, -pdc * CAMERA_SPEED);\n    \n    return d;\n}\n\nvec3 mapGrad(vec3 p, float eps)\n{\n    vec2 e = vec2(eps, 0);\n    return (map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    )) / e.x;\n}\n\nvec3 getColor(vec3 id)\n{\n    id.y /= sqrt(2.0);\n    id = floor(id * 2.0);\n    \n    float h = abs((sin(id.x * 0.15) + sin(id.y * 0.25) + cos(id.z * 0.4)) * 0.333);\n    \n    return vec3(palette2(h));\n    return palette2(hash13(id));\n}\n\nvec3 getEmission(vec3 id)\n{\n    id.y /= sqrt(2.0);\n    id = floor(id * 2.0);\n    \n    //id += (texture(iChannel2, 0.2 * id / 32.0).rgb - 0.5) * 10.0;\n    float h = ((sin(id.x * 0.03) + sin(id.y * 0.08) + cos(id.z * 0.12)) * 0.333);\n    \n    h = fract(h + iTime * 0.6);\n    //if (h < 0.1)\n    //    return vec3(0.2, 0.5, 1) * 2.0;\n    return vec3(0);\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec3 id;\n};\n\n#ifdef SIMPLE_TRAVERSAL\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, float tmax)\n{\n    vec3 pos = ro;\n    vec3 id = getID(pos);\n    vec3 n;\n    float t = 0.0;\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        float d = map(id);\n        if (d < 0.0)\n        {\n            #ifdef SPHERES\n            if (d < -3.0)\n            {\n                vec2 st = sphereIntersection(ro - (id + 0.5), rd, 0.5);\n\n                if (st.x > t && st.x < MAX_DIST)\n                {\n                    hit.t = st.x;\n                    hit.n = normalize(ro - (id + 0.5) + rd * st.x);\n                    hit.id = id;\n                    return true;\n                }\n            } else\n            #endif\n            {\n                hit.t = t;\n                hit.n = n;\n                hit.id = id;\n                return true;\n            }\n        }\n        \n        vec2 rdi = rhombicDodecahedronIntersection2(pos - id - 0.5, rd, 0.5, n);\n        \n        if (rdi.x >= tmax)\n            return false;\n        \n        t = rdi.y;\n        id -= n;\n    }\n    return false;\n}\n#else\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit, float tmax)\n{\n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    const mat4x3 rdm = mat4x3(rdn.xzx, rdn.yzx, rdn.xzy, rdn.yzy);\n    const float s = 0.5;\n    \n    vec3 id = getID(ro);\n    \n    vec3 pp = ro;\n    \n    vec2 ird0 = 1.0 / rd.xz;\n    vec2 k0 = abs(ird0) * s;\n    vec2 srd0 = sign(ird0);\n\n    vec3 n0 = -srd0.x * vec3(1, 0, 0);\n    vec3 n1 = -srd0.y * vec3(0, 0, 1);\n\n    vec4 ird1 = 1.0 / vec4(dot(rd, rdn.xzx), dot(rd, rdn.yzx), dot(rd, rdn.xzy), dot(rd, rdn.yzy));\n    vec4 k1 = abs(ird1) * s;\n    vec4 srd1 = sign(ird1);\n    \n    vec3 n2 = -srd1.x * rdn.xzx;\n    vec3 n3 = -srd1.y * rdn.yzx;\n    vec3 n4 = -srd1.z * rdn.xzy;\n    vec3 n5 = -srd1.w * rdn.yzy;\n    \n    vec3 n;\n    float t;\n    bool surf = false;\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        float d = map(id);\n        if (d < 0.0)\n        {\n            #ifdef SPHERES\n            if (d < -3.0)\n            {\n                vec2 st = sphereIntersection(ro - (id + 0.5), rd, 0.5);\n\n                if (st.x > t && st.x < MAX_DIST)\n                {\n                    hit.t = st.x;\n                    hit.n = normalize(ro - (id + 0.5) + rd * st.x);\n                    hit.id = id;\n                    return true;\n                }\n            } else\n            #endif\n            {\n                hit.t = t;\n                hit.n = n;\n                hit.id = id;\n                return true;\n            }\n        }\n        \n        vec3 pp = ro - (id + 0.5);\n        \n        vec2 id0 = ird0 * pp.xz;\n        vec4 id1 = ird1 * vec4(dot(pp, rdn.xzx), dot(pp, rdn.yzx), dot(pp, rdn.xzy), dot(pp, rdn.yzy));\n        \n        vec2 sd0 = -id0 + k0;\n        vec4 sd1 = -id1 + k1;\n        \n        //vec2 sdn0 = -id0 - k0;\n        //vec4 sdn1 = -id1 - k1;\n        \n        float t0 = min(sd0.x, sd0.y);\n        float t1 = min(min(sd1.x, sd1.y), min(sd1.z, sd1.w));\n        \n        //float tn0 = max(sdn0.x, sdn0.y);\n        //float tn1 = max(max(sdn1.x, sdn1.y), max(sdn1.z, sdn1.w));\n        \n        vec3 nrd;\n        if (t1 < t0)\n        {\n            if (sd1.x == t1)\n            {\n                nrd = n2;\n            } else if (sd1.y == t1)\n            {\n                nrd = n3;\n            } else if (sd1.z == t1)\n            {\n                nrd = n4;\n            } else\n            {\n                nrd = n5;\n            }\n        } else if (sd0.x == t0)\n        {\n            nrd = n0;\n        } else\n        {\n            nrd = n1;\n        }\n        \n        //float tN = max(tn0, tn1);\n        float tF = min(t0, t1);\n        \n        if (tF >= tmax)\n            return false;\n        \n        t = tF;\n        n = nrd;\n        id -= n;\n    }\n\n    return false;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    const float fov = 120.0;\n    const float invTanFov = 1.0 / tan(radians(fov) * 0.5);\n    \n    vec3 ro = getCameraPos(iTime);\n    vec3 lo = vec3(0, 0, 1);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.x == 0. ? -PI * .7 + iTime * .2 : -m.x * TAU + PI;\n    float ay = iMouse.y == 0. ? PI * 0.2 : -m.y * PI + PI * 0.5;\n    \n    if (iMouse.z > 0.0)\n    {\n        lo.yz *= rot2D(-ay);\n        lo.xz *= rot2D(ax);\n        lo += ro;\n    } else\n    {\n        lo = getCameraPos(iTime + 0.25);\n    }\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, invTanFov));\n    \n    vec3 col = vec3(0);\n    \n    const vec3 rdn = vec3(0.5, -0.5, sqrt(2.0)/2.0);\n    \n    #if 0\n    \n    vec3 normal;\n    vec2 rdi = rhombicDodecahedronIntersection(ro, rd, 0.5, normal);\n    \n    vec3 normal2;\n    vec2 rdi2 = rhombicDodecahedronIntersection(ro - rdn.xzy, rd, 0.5, normal2);\n    \n    vec2 st = sphereIntersection(ro + rdn.yzy, rd, 0.5);\n    vec3 normal3 = normalize(ro + rdn.yzy + rd * st.x);\n    \n    float t = rdi.x;\n    \n    if (rdi2.x < t)\n    {\n        t = rdi2.x;\n        normal = normal2;\n    }\n    if (st.x < t)\n    {\n        t = st.x;\n        normal = normal3;\n    }\n    \n    vec3 pos = ro + rd * t;\n    \n    col = normal;\n    \n    if (t >= MAX_DIST)\n        col = rd;\n    \n    #else\n    \n    vec3 pos = ro;\n    vec3 id = getID(pos);\n    vec3 n;\n    float t = 0.0;\n    \n    HitInfo hit;\n    bool isHit = trace(pos, rd, hit, MAX_DIST);\n    t = isHit ? hit.t : MAX_DIST;\n    n = hit.n;\n    id = hit.id;\n    \n    pos = pos + rd * t;\n    \n    id = getID(pos - n * EPS);\n    \n    vec3 alb = getColor(id);\n    vec3 emi = getEmission(id);\n    \n    vec3 fogCol = vec3(0.6, 0.85, 1)*0.6;//vec3(0.03, 0.03, 0.08);\n    vec3 ambCol = fogCol;\n    vec3 accCol = vec3(1, 0.12, 0.15);\n    \n    float ft = smoothstep(MAX_DIST*0.7, MAX_DIST, t) * smoothstep(0.98, 1.0, rd.z);//pow(max(rd.z, 0.0), 20.0) * 2.0;\n    \n    fogCol = mix(fogCol, accCol * 5.0, saturate(ft));\n    \n    vec3 ref = reflect(rd, n);\n    \n    vec3 ligCol = vec3(1, 0.85, 0.7) * 1.5;\n    vec3 lpos = getCameraPos(iTime + 1.25);\n    vec3 ldir = lpos - pos;\n    float ldist = length(ldir);\n    ldir /= ldist;\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + n * EPS, ldir, hitL, ldist);\n    \n    float atten = 1.0 / (0.8 + 0.08*ldist + 0.05*ldist*ldist);\n    \n    float dif = max(dot(n, ldir), 0.0) * float(!isHitL);\n    float spec = pow(max(dot(ref, ldir), 0.0), 5.0) * float(!isHitL);\n    \n    float ao = smoothstep(-2.5, 1.0, map(pos) / length(mapGrad(pos, 1.0)));\n    \n    col += alb * ligCol * dif * atten * 1.8;\n    col += alb * ligCol * spec * atten * 1.0 * step(hash13(id), 0.5);\n    \n    col += (alb * 0.2 + 0.1) * ambCol;\n    \n    vec3 emiPos = getID(getLightsID(id));\n    vec3 emiDir = emiPos - pos;\n    float edist = length(emiDir);\n    emiDir /= edist;\n    \n    float edif = max(dot(n, emiDir), 0.0);\n    \n    HitInfo hitE;\n    bool isHitE = trace(pos + n * EPS, emiDir, hitE, edist);\n    \n    vec3 eid = getID(pos + n * EPS + emiDir * hitE.t - hitE.n * 1e-3);\n    bool isE = isHitE && distance(emiPos, hitE.id) < 1e-3;\n    \n    float estr = 10.0 * ((sin((hash13(emiPos) + iTime*0.25)*TAU)*0.5+0.5)*0.8+0.2);\n    vec3 ecol = accCol * estr;//vec3(0.5, 0.8, 1) * estr;\n    \n    float eAtten = 1.0 / (0.8 + 0.4*edist + 0.3*edist*edist);\n    \n    col += alb * edif * ecol * eAtten * float(isE);\n\n    //float r0 = 0.06;\n    //float fre = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, n), 5.0);\n    \n    col *= ao * 0.8 + 0.2;\n\n    if (distance(emiPos, id) < 1e-3)\n        col = ecol;\n    \n    col = mix(col, fogCol, 1.0 - exp(-max(t*t - 50.0, 0.0) * 0.0003));\n    \n    if (!isHit)\n        col = fogCol;\n    #endif\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    col = linearTosRGB(col);\n    \n    /*\n    vec3 pro = getCameraPos(iTime - iTimeDelta);\n    vec3 plo = getCameraPos(iTime + 0.25 - iTimeDelta);\n    \n    mat3 pmat = getCameraMatrix(pro, plo);\n    \n    vec3 pcam = (pos - pro) * pmat;\n    vec2 pndc = invTanFov * 2.0 * pcam.xy / pcam.z;\n    vec2 puv = pndc * vec2(iResolution.y / iResolution.x, 1) * 0.5 + 0.5;\n    \n    vec2 mbuv = puv - uv;\n    */\n    \n    fragColor = vec4(col, t);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// FXAA 3.11\n\n// Implementation from\n// Two Grid Traversal w/ 1Pass DoF - gelami\n// https://www.shadertoy.com/view/dtt3DS\n\n// FXAA Defines\n// Trims the algorithm from processing darks.\n//   0.0833 - upper limit (default, the start of visible unfiltered edges)\n//   0.0625 - high quality (faster)\n//   0.0312 - visible limit (slower)\n#define FXAA_THRESHOLD_MIN 0.0312\n\n// The minimum amount of local contrast required to apply algorithm.\n//   0.333 - too little (faster)\n//   0.250 - low quality\n//   0.166 - default\n//   0.125 - high quality \n//   0.063 - overkill (slower)\n#define FXAA_THRESHOLD_MAX 0.063\n\n// This can effect sharpness.\n//   1.00 - upper limit (softer)\n//   0.75 - default amount of filtering\n//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n//   0.25 - almost off\n//   0.00 - completely off\n#define FXAA_SUBPIXEL_QUALITY 0.75\n\n// Assumed to be in perceptual/gamma-encoded space\nfloat luma(vec3 col)\n{\n    //return dot(col, vec3(0.2126729, 0.7151522, 0.0721750));\n    return dot(col, vec3(0.299, 0.587, 0.114));\n    return sqrt(dot(col, vec3(0.299, 0.587, 0.114)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    #ifndef FXAA\n    col.rgb = sRGBToLinear(col.rgb);\n    col.rgb = col.rgb / (1.0 - col.rgb);\n    \n    fragColor = col;\n    #else\n    float lumaCenter = luma(col.rgb);\n    float lumaUp    = luma(texture(iChannel0, uv + vec2(0, px.y)).rgb);\n    float lumaDown  = luma(texture(iChannel0, uv - vec2(0, px.y)).rgb);\n    float lumaLeft  = luma(texture(iChannel0, uv - vec2(px.x, 0)).rgb);\n    float lumaRight = luma(texture(iChannel0, uv + vec2(px.x, 0)).rgb);\n\n    float lumaMin = min(min(min(lumaUp, lumaDown), min(lumaLeft, lumaRight)), lumaCenter);\n    float lumaMax = max(max(max(lumaUp, lumaDown), max(lumaLeft, lumaRight)), lumaCenter);\n\n    float lumaRange = lumaMax - lumaMin;\n\n    if (lumaRange < max(FXAA_THRESHOLD_MIN, lumaMax * FXAA_THRESHOLD_MAX))\n    {\n        col.rgb = sRGBToLinear(col.rgb);\n        col.rgb = col.rgb / (1.0 - col.rgb);\n    \n        fragColor = col;\n        return;\n    }\n    \n    float lumaDownLeft  = luma(texture(iChannel0, uv - vec2(px.x, px.y)).rgb);\n    float lumaUpRight   = luma(texture(iChannel0, uv + vec2(px.x, px.y)).rgb);\n    float lumaDownRight = luma(texture(iChannel0, uv + vec2(px.x, -px.y)).rgb);\n    float lumaUpLeft    = luma(texture(iChannel0, uv + vec2(-px.x, px.y)).rgb);\n    \n    float lumaDownUp = lumaDown + lumaUp;\n    float lumaLeftRight = lumaLeft + lumaRight;\n    \n    float lumaCornerDown = lumaDownRight + lumaDownLeft;\n    float lumaCornerUp = lumaUpRight + lumaUpLeft;\n    float lumaCornerLeft = lumaDownLeft + lumaUpLeft;\n    float lumaCornerRight = lumaDownRight + lumaUpRight;\n\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaCornerLeft) +\n                           abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 +\n                           abs(-2.0 * lumaRight + lumaCornerRight);\n    \n    float edgeVertical   = abs(-2.0 * lumaUp + lumaCornerUp) +\n                           abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 +\n                           abs(-2.0 * lumaDown + lumaCornerDown);\n\n    bool isEdgeHorizontal = edgeHorizontal >= edgeVertical;\n\n    float luma0 = isEdgeHorizontal ? lumaDown : lumaLeft;\n    float luma1 = isEdgeHorizontal ? lumaUp : lumaRight;\n    \n    float grad0 = abs(luma0 - lumaCenter);\n    float grad1 = abs(luma1 - lumaCenter);\n\n    bool gradStep = grad0 >= grad1;\n    \n    float gradScaled = 0.25 * max(grad0, grad1);\n    \n    float stepSize = isEdgeHorizontal ? px.y : px.x;\n    stepSize = gradStep ? -stepSize : stepSize;\n    \n    float lumaLocalAvg = 0.5 * ((gradStep ? luma0 : luma1) + lumaCenter);\n\n    vec2 curUV = uv;\n    \n    if (isEdgeHorizontal)\n        curUV.y += stepSize * 0.5;\n    else\n        curUV.x += stepSize * 0.5;\n    \n    vec2 stepOffset = isEdgeHorizontal ? vec2(px.x, 0) : vec2(0, px.y);\n    \n    vec2 uv0 = curUV - stepOffset;\n    vec2 uv1 = curUV + stepOffset;\n    \n    float lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n    float lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n    \n    bool reached0 = abs(lumaEnd0) >= gradScaled;\n    bool reached1 = abs(lumaEnd1) >= gradScaled;\n    \n    if (!reached0) uv0 -= stepOffset;\n    if (!reached1) uv1 += stepOffset;\n    \n    if (!(reached0 && reached1))\n    {\n        #define ITERATIONS 12\n        const float QUALITY[ITERATIONS] = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0, 8.0);\n        for (int i = 2; i < ITERATIONS; i++)\n        {\n            if (!reached0)\n            {\n                lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n            }\n            if (!reached1)\n            {\n                lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n            }\n            \n            reached0 = abs(lumaEnd0) >= gradScaled;\n            reached1 = abs(lumaEnd1) >= gradScaled;\n            \n            if (!reached0) uv0 -= stepOffset * QUALITY[i];\n            if (!reached1) uv1 += stepOffset * QUALITY[i];\n            \n            if (reached0 && reached1) break;\n        }\n    }\n    \n    float distance0 = isEdgeHorizontal ? (uv.x - uv0.x) : (uv.y - uv0.y);\n    float distance1 = isEdgeHorizontal ? (uv1.x - uv.x) : (uv1.y - uv.y);\n    \n    float lumaDist = distance0 < distance1 ? lumaEnd0 : lumaEnd1;\n    \n    float pixelOffset = -min(distance0, distance1) / (distance0 + distance1) + 0.5;\n    \n    bool correctVar = lumaCenter < lumaLocalAvg != lumaDist < 0.0;\n    \n    float finalOffset = correctVar ? pixelOffset : 0.0;\n    \n    float lumaAvg = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaCornerLeft + lumaCornerRight);\n    \n    float subpixelOffset = smoothstep(0.0, 1.0, abs(lumaAvg - lumaCenter) / lumaRange);\n    subpixelOffset = subpixelOffset * subpixelOffset * FXAA_SUBPIXEL_QUALITY;\n    \n    finalOffset = max(finalOffset, subpixelOffset);\n    \n    vec2 finalUV = uv;\n    \n    if (isEdgeHorizontal)\n        finalUV.y += stepSize * finalOffset;\n    else\n        finalUV.x += stepSize * finalOffset;\n    \n    vec3 fcol = texture(iChannel0, finalUV).rgb;\n    \n    fcol = sRGBToLinear(fcol);\n    fcol = fcol / (1.0 - fcol);\n    \n    fragColor = vec4(fcol, col.a);\n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// Bloom pass from:\n// 2-Pass Buffer Bloom - gelami\n// https://www.shadertoy.com/view/cty3R3\n\nconst int rad = 5;\nconst float sigma = float(rad) * 0.4;\n\n#if 1\nvec4 prefilter(vec4 col)\n{\n    const float threshold = BLOOM_THRESHOLD;\n    float brightness = max(max(col.r, col.g), col.b);\n    float contrib = max(brightness - threshold, 0.0) / max(brightness, 1e-5);\n    return col * contrib;\n}\n#else\nvec4 prefilter(vec4 col)\n{\n    return col;\n}\n#endif\n\nfloat gaussian(vec2 i, float sigma) {\n    return exp(-(dot(i,i) / (2.0 * sigma*sigma)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 hres = floor(iResolution.xy / 2.0);\n        \n    vec2 res = hres;\n    float xpos = 0.0;\n    int lod = 0;\n    for (; lod < BLOOM_MAX_LOD; lod++)\n    {\n        xpos += res.x;\n        \n        if (xpos > fragCoord.x || res.x <= 1.0)\n            break;\n        res = floor(res / 2.0);\n    }\n    \n    if (fragCoord.y >= res.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    fragColor = vec4(0);\n    \n    vec2 px = 1.0 / iResolution.xy;\n    vec2 p = (fragCoord - vec2(xpos - res.x, 0)) / iResolution.xy;\n    vec2 uv = (fragCoord - vec2(xpos - res.x, 0)) / vec2(res);\n    \n    // Skip blurring LOD 0 for performance\n    #if 1\n    if (lod == 0)\n    {\n        fragColor = prefilter(textureLod(iChannel0, uv, 1.0));\n        return;\n    }\n    #endif\n    \n    float sc = exp2(float(lod));\n    float w = 0.0;\n    for (int x = -rad; x <= rad; x++)\n    {\n        for (int y = -rad; y <= rad; y++)\n        {\n            vec2 o = vec2(x, y);\n            float wg = gaussian(o, sigma);\n            vec2 p = uv + o / vec2(res);\n            \n            //p = clamp(p, 0.5 / res, (res - 0.5) / res);\n            \n            if (p == clamp(p, vec2(0.5) / res, (res - 0.5) / res))\n                fragColor += wg * prefilter(textureLod(iChannel0, p, float(lod)));\n            w += wg;\n        }\n    }\n    fragColor /= w;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlK3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "mtyGWy", "name": "Shader Art Coding Introduction", "author": "kishimisu", "description": "[url]https://youtu.be/f4s1h2YETNY[/url]", "tags": ["fractal", "sdf", "tutorial", "intro", "repetition", "code", "youtube", "tuto", "creative"], "likes": 990, "viewed": 101962, "published": 3, "date": "1684572540", "time_retrieved": "2024-07-30T17:54:56.448188", "image_code": "/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 394, 419, 419, 603], [605, 645, 702, 702, 1188]]}
{"id": "DtV3WG", "name": "cymatics wave tank (working)", "author": "maxwellcoffee", "description": "working version of \"cymatics wave tank kindof\"", "tags": ["cymatics"], "likes": 4, "viewed": 153, "published": 3, "date": "1684568357", "time_retrieved": "2024-07-30T17:54:57.414604", "image_code": "\nvoid mainImage( out vec4 color, vec2 UVcoords )\n{\n   float d3 = iResolution.y*.5 ,\n         d4 =  iResolution.x*.5 ,\n         d2 = 8.0 - 4.0 * sin(iTime*.07 ) + iMouse.y*0.0021,\n        d1 = .5;\n\n   UVcoords = .5*(UVcoords - vec2(d4,d3));\n\n#define S(X, Y, period)   color += vec4(sin(length(UVcoords + vec2(X,Y)*d2)*period));\n\n    color = vec4(0.0, 0.0, 0.0, 1.0); // Initialize color with alpha 1\n\n    S(0.0,0.0,iMouse.x*0.01)\n    S(0,1.0*d2,d1)  \n    S(0,-1.0*d2,d1)  \n    S(-1.0*d2,-0.0,d1)  \n    S(1.0*d2,0.0,d1)\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtV3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "dlyGDy", "name": "Arabesque knots 4", "author": "jarble", "description": "An arabesque knot pattern.", "tags": ["fractal", "music", "arabesque"], "likes": 3, "viewed": 172, "published": 3, "date": "1684555428", "time_retrieved": "2024-07-30T17:54:58.301233", "image_code": "vec2 triangle_wave(vec2 a){\n    //a += 1./2.;\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        //uv.x += t1_(floor(uv),floor(uv));\n        uv =\n            (.5+uv+t2)/1.5\n        ;\n        //if(uv.x>uv.y)\n        uv.x += .5;\n        t2 =\n            triangle_wave(-uv+.5)\n        ;\n        uv =\n            t2-triangle_wave(-uv.yx)\n        ;\n        {t2 = t2.yx; uv=\n            uv.yx\n            //uv.yx-fract(uv.x/4.)\n            ;\n        }\n        //if(t2.y<t2.x)\n        col =\n            vec3(col.zx,abs(uv.x*sign(t2.x-t2.y)-uv.y))\n            //vec3(col.zx,max(col.x,abs(uv.x*sign(t2.x-t2.y)-uv.y)))\n        ;\n        //if(k%3 == 0 && uv.x>uv.y) {uv = -uv;break;}\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float m1(float a, float b, float c){\n    return floor(floor(floor(a)/b)/c);\n}\n\nfloat mod1(float a,float b){\n    return\n        mod(a,b)\n        //mod(a+floor(b*13./3.),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a += mod1(floor(a/2.),b);\n    }\n}\n\nfloat fmod1(float a, float b){\n    //distort(a,b);\n    //a += m1(a,3.+b,5.+b);\n    //a += floor(a*8./b)/b;\n    //a += pow(2.,mod(floor(a/8.),b));\n    return\n        floor(sqrt(mod1(floor(-a/8.),b)*mod1(floor(a*b),b)))\n        //floor(sqrt(mod(floor(-a/8.),b)*mod(floor(a*b+b/8.),b)))\n        //floor(sqrt(mod(floor(-a/8.),floor(b/2.)+4.)*mod(floor(a*b),floor(b/2.)+4.)))\n        //floor(sqrt(b*mod(floor(a*b),b)))\n    ;\n}\n\nfloat fmod(float a, float b){\n    //a += mod(a,5.)-mod(a,3.);\n    return\n        fmod1(a,b)\n        //fmod1(a+b/8.,b)\n        //fmod1(a+fmod1(a,b)/2.,b)\n    ;\n}\n\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  t += floor(t*pow(2.,fmod(t/4.,4.)))/pow(2.,fmod(t/4.,4.));\n  float s1 =\n      8.\n  ;\n  /*\n  for(int i = 0; i < 3; i++){\n      t += floor(t/2.)/2.;\n  }\n  */\n  float p1 = 1. + floor(mod((1.+t/4.)/2.,2.));\n  t *= p1/2.;\n  \n  float a=\n      //64.*pow((1.-sqrt(fract(t*p1))),2.)\n      pow((2.-log(fract(t*p1))),2.)/2.\n  ,\n  nb = t*tempo*pow(2.,(2.+fmod(t,s1)+1. + fmod(floor(t/s1),2.))/5.+7.)/p1;\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n      \n      //abs(1.+log(abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))/2.\n      //abs(1./16.-abs(.5-vec2(fract(nb*.998*2.),fract(nb))))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 45, 160], [278, 278, 304, 304, 393], [396, 396, 453, 453, 1367]]}
{"id": "mlGGWy", "name": "Arctic polar visualizer", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 4, "viewed": 232, "published": 3, "date": "1684544605", "time_retrieved": "2024-07-30T17:54:59.240721", "image_code": "// Fork of \"Polar react\" by firebreathz. https://shadertoy.com/view/stj3Rw\n// 2023-05-19 23:16:34\n\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 50\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(0.000,0.000,0.000))) * 0.0)*0.0-0.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    //uv.x-=0.25;\n    uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.75;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 0.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.7;\n    band += 0.002;\n    \n    s = texture( iChannel0, vec2(band,0.0) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.522,0.502,0.502);\n    colors[1] = vec3(0.000,0.173,0.580);\n    colors[2] = vec3(0.192,0.180,1.000);\n    colors[3] = vec3(0.361,0.573,1.000);\n \n    vec3 gradCol = colors[1];\n    float n = float(nColors)-0.0;\n    for(int i = 2; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-2)/n)*n);\n    }\n    \n    float h = PI*3.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.05,0.5,f);\n    col *= smoothstep(1.0,0.8,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.01);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.01,-0.01);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 3.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(0.1,0.1));\n    vec3 cs2 = drawBands(vec2(0.1,0.1));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-0.0))*0.01*smoothstep(0.1,-1.1,length(p*0.0-0.0));\n    vec3 plColBg = vec3(0.001)*smoothstep(1.0,0.0,length(p*0.0-1.5));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.05,0.01,1.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*0.0/0.1;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 210, 210, 279], [281, 281, 323, 323, 382], [384, 384, 409, 409, 1949], [1951, 1951, 2008, 2008, 3258]]}
{"id": "clGGDG", "name": "Ray Marching Attempt #3 (wip)", "author": "NikoAnimation", "description": "Update 1: now with soft shadows\nUpdate 2: now with box", "tags": ["raymarching"], "likes": 1, "viewed": 133, "published": 3, "date": "1684539820", "time_retrieved": "2024-07-30T17:54:59.999692", "image_code": "// INIT VARS\nvec2 camAngle = vec2(-2.0, -0.1);\nfloat fov = 0.3; // <-- 90*  0-1 == 0-360\n\nfloat minDELength = 0.0001;\nfloat maxRayLength = 1000.0;\nfloat maxSteps = 1000.0; // had to be float so i could divide ¯\\_(ツ)_/¯\n\nvec2 lightAng = vec2(1.0, 0.0);\nfloat AOMultiplier = 2.0;\nfloat shadowSoftness = 1.0;\n\nfloat sphere_de(vec3 pos, vec3 objPos, float radius) {\n    return length(pos-objPos)-radius;\n}\nfloat plane_de(vec3 pos, float z) {\n    return pos.z + z;\n}\nfloat box_de( vec3 p, vec3 b, vec3 objPos )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//float modsphere_de( in vec3 p, in vec3 c)\n//{\n//    vec3 q = mod(p+0.5*c,c)-0.5*c;\n//    return sphere_de(q, vec3(0.0, 0.0, 2.0), 2.0);\n//}\nfloat octahedron_de( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat overall_de(vec3 pos) {\n    \n    float objList[3] = float[] (\n        plane_de(pos, 0.0), \n        sphere_de(pos, vec3(-5.0, 0.0, 2.0), 2.0), \n        box_de(pos, vec3( 1.0, 1.0, 2.0), vec3(0.0, 0.0, 1.0))\n    );\n    \n    float min_de = maxRayLength;\n    for(int i=0; i<3; i++) {\n        if (objList[i] < min_de) {\n            min_de = objList[i];\n        }\n    } return min_de;\n}\nvec3 get_normal(vec3 pos) {\n\tfloat dist = overall_de(pos);\n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = dist - vec3(\n        overall_de(pos-e.xyy),\n        overall_de(pos-e.yxy),\n        overall_de(pos-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 ray_move(vec3 pos, vec3 dir, float dist) {\n    \n    /*\n    pos.x += cos(dir.x)*dist;\n    pos.y += sin(dir.x)*dist;\n    pos.z += sin(dir.y)*dist;\n    */\n    vec3 newPos = pos + normalize(dir)*dist;\n    return newPos;\n}\nvec3 deg_to_vec(vec2 dir) { //Used to convert angle based vec2s to vec3 directions\n    vec3 pos;\n    pos.x += cos(dir.x);\n    pos.y += sin(dir.x);\n    pos.z += sin(dir.y);\n    return normalize(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightAng = vec2(iTime, 0.5);\n    vec3 camPos = vec3(3.0, 10.0, 3.0);\n\n    // Calculate aspect ratio (assumes width is higher than height)\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = (uv*2.0)-1.0; // Signed screen coordinates (-1 - +1)\n    suv.x *= aspectRatio; // Account for aspect ratio\n\n    // Get ray angle\n    vec3 rayPos = camPos;\n    vec2 rayAng = (fov*suv + camAngle); // mod values for correct angle\n    \n    float b = 1.0;\n    \n    float de;\n    float totalDist;\n    float steps;\n    do {\n        de = overall_de(rayPos);\n        rayPos = ray_move(rayPos, deg_to_vec(rayAng), de);\n        totalDist += de;\n        steps += 1.0;\n    } while (de > minDELength && totalDist < maxRayLength && steps < maxSteps);\n    \n    if (de < minDELength) {\n        \n        rayPos = ray_move(rayPos, get_normal(rayPos), minDELength*2.0);\n        rayAng = lightAng;\n        \n        totalDist = minDELength*2.0;\n        float res = 1.0;\n        vec3 origPos = rayPos;\n        do {\n            de = overall_de(rayPos);\n            rayPos = ray_move(rayPos, deg_to_vec(rayAng), de);\n            totalDist += de;\n            res = min(res, shadowSoftness*de/totalDist);\n        } while (de > minDELength && totalDist < maxRayLength);\n        \n        \n        if (de < minDELength) {\n            \n              b = 0.0;\n            //b = clamp(dot(get_normal(rayPos), deg_to_vec(lightAng)), .2, 1.0);\n            \n            //b = (dot(get_normal(rayPos), deg_to_vec(lightAng)))/1.4-(steps/maxSteps)*AOMultiplier;\n            \n            //vec3 vecRayAngle = deg_to_vec(rayAng);\n            //vec3 reflectedAng = reflect(vecRayAngle, get_normal(rayPos));\n            //b += dot(vecRayAngle, reflectedAng);\n            \n        } if (totalDist > maxRayLength) {\n        \n           b = res;\n           \n        }\n        //b -= 10.0*shadowSoftness*minDE/totalMinDE;//+ (steps/maxSteps)*AOMultiplier;\n        //b += clamp(doctt(refle(deg_to_vec(rayAng), get_normal(rayPos)), deg_to_vec(lightAng)), .2, 1.0);\n        \n        b = clamp((b-(steps/maxSteps)+0.2)*AOMultiplier, 0.0, 1.0);\n        \n    } else {\n        b = 0.0;\n    }\n    // Output to screen\n    fragColor = vec4(b, b, b, 1.0);\n    //fragColor = vec4(get_normal(rayPos) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGGDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 365, 365, 405], [406, 406, 441, 441, 465], [466, 466, 511, 511, 598], [599, 741, 780, 780, 833], [1221, 1221, 1248, 1248, 1465], [1467, 1467, 1514, 1623, 1689], [1690, 1690, 1717, 1772, 1890], [1892, 1892, 1949, 1949, 4305]]}
{"id": "ctG3WG", "name": "Year of Truchets #021", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\n[truchet discover team alpha]", "tags": ["raymarching", "torus", "truchet"], "likes": 39, "viewed": 331, "published": 3, "date": "1684534595", "time_retrieved": "2024-07-30T17:55:01.397954", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #021\n    05/19/2023  @byt3_m3chanic\n    Can't stop - won't stop | Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    35.\n\n// globals & const\nmat2 r90,spin;\nconst vec3 size = vec3(1.);\nconst vec3 sz2 = size*2.;\nconst vec3 hlf =  size/2.;\nconst float thick = .0275;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.73,59.71+iDate.z)))*4832.3234); }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b; return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y); return length(q)-t.y;\n}\n\nvec3 hp,hit;\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    \n    //@mla inversion\n    float k = 5.0/dot(p,p); \n    p *= k;\n    p +=vec3(hlf.xy,T*.3);\n\n    vec3 q = p;\n    vec3 id = floor((q + hlf)/size);\n    q = mod(q+hlf,size)-hlf;\n    \n    //3D every other\n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n\n    float hs = hash21(id.xz+id.y);\n    if(hs>.85) { q.yz*=r90; } else if(hs>.65) { q.xz*=r90; } else if(hs>.45) { q.xy*=r90; }\n\n    vec2 d3 = vec2(length(q.xy-hlf.xy), length(q.xy+hlf.xy));\n    vec2 gy = d3.x<d3.y ? vec2(q.xy-hlf.xy) : vec2(q.xy+hlf.xy);\n    vec3 tz = vec3(gy.xy,q.z);\n    \n    float xhs = fract(2.31*hs+id.y);\n    float trh = 1e5, trx = 1e5, srh = 1e5, dre = 1e5, jre=1e5;\n\n    if(chk>.5){\n        trh = min(cap(q.zyx,hlf.z,thick),cap(q,hlf.x,thick));\n        trh = max(trh,-(length(q)-(hlf.x*.45)));\n        trh = min(trs(q,vec2(hlf.x*.45,thick)),trh);\n        dre = length(q.xz)-thick;\n        trx = min(dre,trh);\n    } else{\n       jre = trs(tz.yzx,vec2(hlf.x,thick));\n       dre = length(q.xy)-thick;\n       srh = min(dre,jre);\n    }\n\n    if(trx<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        hp = q;\n        if(dre<trh) { mt = mt+5.; hp = q;}\n        res = vec2(trx,mt);\n        \n    } \n    \n    if(srh<res.x ) {\n        float mt = xhs>.725?5.:xhs>.61?4.:xhs>.25?2.:3.;\n        hp = tz;\n        if(dre<jre){ mt = mt+5.; hp = q.xzy;}\n        res = vec2(srh,mt);\n    } \n\n    float ck = thick*.65, cr = thick*2.;\n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),ck,cr);  \n    crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),ck,cr),crt);\n    crt = min(cap(vec3(q.xz,abs(q.y))-vec3(0,0,hlf),ck,cr),crt);\n\n    if(crt<res.x) {\n       res = vec2(crt,1.);\n    } \n\n    // compensate for the scaling that's been applied\n    float mul = 1./k;\n    res.x = res.x* mul / 1.5;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    r90 = rot(1.5707);\n    spin = rot(T*.1);\n    \n    float vv = uv.y+.3+(.05*sin(uv.x*6.));\n    vec3 fog = mix(vec3(.025,.1,.2),vec3(.5),clamp(vv,0.,1.));\n    \n    vec3 ro = vec3(0,0,1);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    ro.xy *= spin; rd.xy *= spin;\n\n    vec3 C = vec3(.0), p = ro;\n    float m = 0., d = 0.;\n    \n    for(int i=0;i<128;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<d*MIN_DIST||d>MAX_DIST)break;\n        d += i<32? ray.x*.3: ray.x*.8;\n        m  = ray.y;\n    } \n    \n    hit=hp;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-hlf.x,sz2.y+hlf.y,sz2.z);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.0001,.99);\n        float spec = pow(max(dot(reflect(l, n),rd),.001),14.)*2.;\n\n        vec3 h = vec3(.0);\n\n        if(m==1.) {h=vec3(.25);}\n        if(m==2.) {h=vec3(.89,.37,.03);}\n        if(m==3.) {h=vec3(.22,.44,.77);}\n        if(m==4.) {h=vec3(1);}\n        if(m==5.) {h=vec3(.025);}\n        \n        if(m>5.) {\n            vec3 hp = hit;\n            //@Fabrice uv for the cylinder \n            vec2 uv   = vec2(atan(hp.z,hp.x)/PI2,hp.y);\n\n            float px  = .01;\n            vec2 scale= vec2(8.,42.);\n            vec2 grid = fract(uv.xy*scale)-.5;\n            vec2 id   = floor(uv.xy*scale);\n            float rnd = hash21(id);\n            if(rnd>.5) grid.x*=-1.;\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n            vec2 d2 = vec2(length(grid-.5),length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5):vec2(grid+.5);\n\n            float xck = length(gx)-.5;\n            float center = (rnd>.5 ^^chk>.5)? smoothstep(-px,px,xck):smoothstep(px,-px,xck);\n            h = mix(h, vec3(.2),center);\n            C = h*diff;\n        } else {\n            C =clamp(h*diff+spec,vec3(0),vec3(1));\n        }\n    }\n\n    C = mix(C,fog,1.-exp(-20.*d*d*d));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctG3WG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[575, 575, 593, 593, 637], [638, 638, 659, 659, 723], [725, 725, 750, 750, 831], [833, 833, 867, 867, 972], [975, 975, 1001, 1001, 1066], [1081, 1081, 1099, 1099, 2921], [2923, 2998, 3028, 3028, 3267]]}
{"id": "mlyGWG", "name": "Loop noise Slower Public", "author": "FoxDev", "description": "loop noise", "tags": ["loopnoise"], "likes": 3, "viewed": 149, "published": 3, "date": "1684532787", "time_retrieved": "2024-07-30T17:55:02.381324", "image_code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 box (vec2 sizes, vec2 uv) {\n    \n    float w = sizes.x / 2.;\n    float h = sizes.y / 2.;\n    float blur = .01;\n    \n    vec3 col = vec3(1.);\n    col -= vec3(smoothstep(-w, -w - blur, uv.x));\n    col -= vec3(smoothstep(w, w + blur, uv.x));\n    col -= vec3(smoothstep(h, h + blur, uv.y));\n    col -= vec3(smoothstep(-h, -h - blur, uv.y));\n    return col;\n}\n\n#define pi 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    \n    float loopDuration = 10.;\n    float speed = .02;\n    \n    float time = mod(iTime * speed / loopDuration, 1.);\n    float playhead = .5 * sin(time * pi * 2.) + 2.;\n    \n    float s = sin(time * 2. * pi) + 1.;\n    float c = cos(time * 2. * pi) + 1.;\n    \n    \n    float zoom = 1.;\n    vec2 uvNoise = uv * zoom;\n    \n\n    \n    float n1 = cnoise(vec3(uvNoise, s));\n    float n2 = cnoise(vec3(uvNoise, c));\n    \n    \n\tvec3 col1 = vec3(3.9 * uvNoise.x + n2, uvNoise.x + n2, 1.);\n    vec3 col2 = vec3(2.2 * uvNoise.x + n1, uvNoise.x + n2, 1.);\n        \n    vec3 col = mix(col1, col2, playhead);\n    \n    col = vec3(col.r);\n    \n    vec3 t2 = vec3(1., uv.y, 0.);    \n    vec3 t1 = vec3(uv.x * .5 + .5, uv.y, 1.);   \n    t2 += mod(col, 0.2);\n    t1 += mod(col, 0.2);\n    \n\tcol = clamp(col, 0., 1.);\n    col = mix(t1, t2, col);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlyGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [190, 190, 209, 209, 245], [247, 247, 268, 268, 2540], [2542, 2542, 2574, 2574, 2901], [2926, 2926, 2983, 3034, 3970]]}
{"id": "mtyGWG", "name": "Loop noise slower", "author": "FoxDev", "description": "loop noise", "tags": ["loopnoise"], "likes": 0, "viewed": 92, "published": 3, "date": "1684532703", "time_retrieved": "2024-07-30T17:55:03.288898", "image_code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 box (vec2 sizes, vec2 uv) {\n    \n    float w = sizes.x / 2.;\n    float h = sizes.y / 2.;\n    float blur = .01;\n    \n    vec3 col = vec3(1.);\n    col -= vec3(smoothstep(-w, -w - blur, uv.x));\n    col -= vec3(smoothstep(w, w + blur, uv.x));\n    col -= vec3(smoothstep(h, h + blur, uv.y));\n    col -= vec3(smoothstep(-h, -h - blur, uv.y));\n    return col;\n}\n\n#define pi 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    \n    float loopDuration = 10.;\n    float speed = .02;\n    \n    float time = mod(iTime * speed / loopDuration, 1.);\n    float playhead = .5 * sin(time * pi * 2.) + 2.;\n    \n    float s = sin(time * 2. * pi) + 1.;\n    float c = cos(time * 2. * pi) + 1.;\n    \n    \n    float zoom = 1.;\n    vec2 uvNoise = uv * zoom;\n    \n\n    \n    float n1 = cnoise(vec3(uvNoise, s));\n    float n2 = cnoise(vec3(uvNoise, c));\n    \n    \n\tvec3 col1 = vec3(3.9 * uvNoise.x + n2, uvNoise.x + n2, 1.);\n    vec3 col2 = vec3(2.2 * uvNoise.x + n1, uvNoise.x + n2, 1.);\n        \n    vec3 col = mix(col1, col2, playhead);\n    \n    col = vec3(col.r);\n    \n    vec3 t2 = vec3(1., uv.y, 0.);    \n    vec3 t1 = vec3(uv.x * .5 + .5, uv.y, 1.);   \n    t2 += mod(col, 0.2);\n    t1 += mod(col, 0.2);\n    \n\tcol = clamp(col, 0., 1.);\n    col = mix(t1, t2, col);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [190, 190, 209, 209, 245], [247, 247, 268, 268, 2540], [2542, 2542, 2574, 2574, 2901], [2926, 2926, 2983, 3034, 3970]]}
{"id": "dlGGWG", "name": "Void Worm", "author": "QuantumSuper", "description": "An auto-VJ with a worm-like shifting shape\n\n- Use with audio in iChannel0 of Buffer A -", "tags": ["2d", "music", "buffer"], "likes": 3, "viewed": 196, "published": 3, "date": "1684532449", "time_retrieved": "2024-07-30T17:55:04.171538", "image_code": "// VoidWorm 0.2.230519 by QuantumSuper\n// auto-vj with pseudo-3d frequency visualization\n// \n// - use with audio in iChannel0 of Buffer A -\n\nvoid mainImage( out vec4 fragColor, in vec2 fC){\n    // Read storage\n    vec4 ffts = getDat( iChannel0, vec2(0));\n\n    // Draw\n    vec3 col = (fC.x<1. && fC.y<1.)? vec3(0) : getDat( iChannel0, fC).rgb; //read buffer but not storage\n    col *= abs( cos( .06*iTime + PI/vec3(.5,2.,4.) + ffts.xyz)); //color shift \n    fragColor = vec4( col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON (0.0) of VoidWorm by QuantumSuper\n// \n// \n// - use with audio in iChannel0 of Buffer A -\n\n#define PI 3.14159265359\n#define getDat(buf,addr) texelFetch( buf, ivec2(addr), 0)", "buffer_a_code": "// BUFFER A (0.24) of VoidWorm by QuantumSuper\n// draw a morphing shape with polar sound texure dilation & shift it through buffer\n// \n// - use with audio in iChannel0 of Buffer A -\n\n\n#define aTime 128./60.*iTime\n#define speed max(iResolution.x,iResolution.y)/1200.\n#define isVDJ false\n\nfloat makeVDJ(float amp){ //workaround for VirtualDJ, attempts to correct for ?limiter?\n\treturn clamp(amp + .3*amp*pow(amp,5.),.0,1.);\n}\n\nvec3 makeFfts(){ //sound compression of speech range\n    vec3 ffts = vec3(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=6;n<8;n++) ffts.x  += getDat( iChannel0, vec2(n,0)).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += getDat( iChannel0, vec2(n,0)).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += getDat( iChannel0, vec2(n,0)).x; //speech III, 1206-2067Hz\n\tffts /= vec3(2,3,3); //normalize\n\tif (isVDJ) for (int n=0;n++<3;) ffts[n] = makeVDJ(ffts[n]);\n    return ffts;\n}\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nfloat sdCircle(vec2 p){\n    return length(p)-1.;\n}\n\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1./k;\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2., 0.);\n    return -length(p)*sign(p.y);\n}\n\nfloat sdMix(vec2 p){\n    return mix( sdCircle(p), sdEquilateralTriangle(p), sin(aTime/4.)/2.+.5);\n}\n\nfloat getShape(vec2 p, float r){ //get visual representation of sdFunctions\n    r = abs(sdMix(p/(r+.001)));\n    return smoothstep(fwidth(r),.0,r);\n}\n\nvoid mainImage( out vec4 col, in vec2 fC){\n    \n    // View definition\n    vec2 isMaxRes = vec2( iResolution.x>=iResolution.y, iResolution.x<iResolution.y); // \"bool\" vector indicating if direction is max resolution\n    vec2 uv = (2.*fC-iResolution.xy) / dot(iResolution.xy,isMaxRes); //long edge -1 to 1, square aspect ratio\n    vec2 shift = vec2( sign(speed)*.4+.02*sin(aTime), .2*sin(aTime/8.)*sin(iTime));\n    uv += mat2(shift,shift.yx) * isMaxRes; //movement\n    uv *= rotM(aTime/16.); //rotate\n    \n    // View manipulation\n    float rho = atan(-abs(uv.x),uv.y)/PI+1.; //polar angle, flipped & mirrored\n    rho = (pow(10.,rho)-1.)/9.; //exponential frequency scale of pow10 to increase visibility of lower frequencies\n    float amp = texelFetch( iChannel0, ivec2( 512.*rho, 0), 0).x; //get sound texture\n    if (isVDJ) amp = makeVDJ(amp);\n    uv /= max(.001, .6+.4*pow(amp,6.)); //warp polar view by sound texture\n    \n    // Draw Shape\n    col = vec4(.2*getShape(uv,.4));\n    if (dot(fC,isMaxRes)>speed+1.)\n        col += .997*getDat( iChannel1, fC-max(1.,abs(speed))*sign(speed)*isMaxRes); //move shape\n    \n    // Storage\n    if (fC.x<1. && fC.y<1.) col.xyz = makeFfts(); //?fC.x+fC.y<1. does not work?\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33340, "src": "https://soundcloud.com/former/voidsong", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 189, 209, 486]]}
{"id": "cly3Dy", "name": "Slower Halo", "author": "FoxDev", "description": "https://www.shadertoy.com/view/fdSBDD <-- Original (Faster)", "tags": ["halo", "copy"], "likes": 3, "viewed": 177, "published": 3, "date": "1684532063", "time_retrieved": "2024-07-30T17:55:04.934498", "image_code": "#define PI 3.14159265\n\nfloat circle(vec2 uv, float blur) {\n    return smoothstep(0., blur, 1. - length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    float circleWhite = circle(uv * 2.45, 1.);\n    float circleBlack = circle(uv * 2.86, 0.7);\n    float c = circleWhite - circleBlack;\n    c *= 6.;\n    \n    float t = iTime * 0.3;\n    c -= circle(vec2(uv.x - sin(t) * .85, 1.8*uv.y - cos(t) * .65) * .8, 1.); \n    \n    vec3 col = vec3(c) * vec3(1., 0., 0.5);\n    col += vec3(smoothstep(0.2, 0.7, c)) * vec3(1., 1., 0.);\n    col += vec3(smoothstep(0.4, 0.55, c));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cly3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 58, 58, 110], [112, 112, 169, 169, 688]]}
{"id": "ctGGWy", "name": "Lascaille's Shroud", "author": "thepinkpanzer", "description": "There is a consciousness outside time and beneath space. It is a labyrinthine tangle of desire and desperation. We have met it out there, where the void is tormented by gravity. But of course, we can live here forever - if the Worm will only wait...", "tags": ["raymarching", "space", "nebula"], "likes": 29, "viewed": 448, "published": 3, "date": "1684523413", "time_retrieved": "2024-07-30T17:55:06.182162", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 raw   = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bloom = texture(iChannel1, fragCoord/iResolution.xy);\n    vec4 psf   = texture(iChannel2, fragCoord/iResolution.xy);\n    \n    fragColor = tanh(psf*0.8+bloom*2.+0.3*raw);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159\nfloat Sharp(float v, float n)\n{\n    v = 1.-v;\n    v*= v;\n    return max(0., 1.-n*v);\n}\nvec4 BackgroundColor(vec3 vd)\n{\n    vd = normalize(vd);\n    vec3  a = abs(vd);\n    float m = max(max(a.x, a.y), a.z);\n    vec2 uv;\n    if      (m == a.x)\n    {\n        uv = vec2(vd.z, vd.y);\n    }\n    else if (m == a.y)\n    {\n        uv = vec2(vd.x, vd.z);\n    }\n    else\n    {\n        uv = vec2(vd.x, vd.y);\n    }\n    vec4 col = vec4(0);\n    mat2 rot = mat2(vec2(0.8, 0.6), vec2(-0.6, 0.8));\n    uv *= rot;\n    vec4 r1  = texture(iChannel0, uv/4.);\n    uv *= rot;\n    vec4 r2  = texture(iChannel0, uv/2.);\n    uv *= rot;\n    vec4 r3  = texture(iChannel0, uv/1.);\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r1.r*r1.b, 9.)*3.;\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r1.a)*Sharp(r1.g*r1.r, 9.)*3.;\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r1.a)*Sharp(r1.b*r1.g, 9.)*3.;\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r2.r*r1.a, 4.);\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r2.a)*Sharp(r2.g*r1.b, 4.);\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r2.a)*Sharp(r2.b*r1.g, 4.);\n    \n    col += (vec4(1.0, 1.0, 1.0, 0)                              )*Sharp(r3.r*r1.a*r2.a, 2.)*0.5;\n    col += (vec4(0.4, 0.7, 1.0, 0) + vec4(0.6, 0.3, 0.0, 0)*r3.a)*Sharp(r3.g*r1.a*r2.a, 2.)*0.5;\n    col += (vec4(1.0, 0.8, 0.4, 0) + vec4(0.0, 0.2, 0.6, 0)*r3.a)*Sharp(r3.b*r1.g*r2.a, 2.)*0.5;\n    \n    return col;\n}\n// Checks if a ray (launched from position, in direction) hits a sphere (with radius) on the origin.\nbool SphereHit(float radius, vec3 position, vec3 direction)\n{\n    return (dot(position, direction)*dot(position, direction) > dot(direction, direction)*(dot(position, position)) - radius*radius);\n}\n// Calculates the distance to the far part of the sphere\nfloat SphereDist(float radius, vec3 position, vec3 direction)\n{\n    float d = -dot(position, direction) + sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\nfloat SphereThrough(float radius, vec3 position, vec3 direction)\n{\n    float d = 2.*sqrt(dot(position, direction)*dot(position, direction) - dot(direction, direction)*(dot(position, position) - radius*radius));\n    return d;\n}\n// Calculates the normal on the surface of the sphere (equivalent to the position, for a unit sphere)\nvec3 SphereNormal(float radius, vec3 position, vec3 direction)\n{\n    return normalize(vec3(position + direction*SphereDist(radius, position, direction)));\n}\nfloat Density(vec3 position)\n{\n    position *= (1.+0.05*sin(iTime*0.5));\n    float r1 = texture(iChannel1, (position+vec3(0.1, 0.2, 0.3)*0.2*iTime)/6.).r;\n    float r2 = texture(iChannel1, (position+vec3(0.1, 0.2, 0.3)*0.5*iTime)/3.).g;\n    float r3 = texture(iChannel1, position/2.).b;\n    float r4 = texture(iChannel1, position/1.).a;\n    \n    float ra = texture(iChannel1, (position+vec3( 0.1, 0.04, 0.08)*0.2*iTime)/4.).g;\n    float rb = texture(iChannel1, (position+vec3(-0.1,-0.2, 0.1)*0.1*iTime)/6.).g;\n    ra *= ra;\n    rb *= rb;\n    float rq  = ((1.-ra) + (1.-rb))*pow(1.-dot(position, position), 1.3);\n    \n    float rt = r1 + r2 + r3 + r4;\n    rt+= smoothstep(0.9, 1.2, rq)*2.;\n    rt = exp(rt - 2.);\n    rt*= 1.-dot(position, position);\n    return rt;\n}\nvec4 Absorb(vec3 position, float density)\n{\n    float rsq = dot(position, position);\n    return vec4(0.3, 0.4, 0.6, 0)*density*density*2.;\n}\nvec4 SIC(vec3 position, float density)\n{\n    float rsq = dot(position, position);\n    vec4 col = mix(vec4(0.8, 0.7, 0.4, 0), vec4(0.2, 0.6, 0.9, 0), 2.*(rsq+0.1*sin(0.3*iTime)+0.5-exp(-density)))*(1.-0.2*sin(iTime*0.5));\n    return col;\n}\nvec4 Add(vec3 position, float density, float jumpedDensity)\n{\n    float rsq = dot(position, position);\n    vec4 selfIllum = SIC(position, density)*(1.-rsq)/(0.001+pow(rsq, 1.8))*0.1*(1.+3./pow(jumpedDensity, 2.));\n    vec4 extIllum  = mix(vec4(0.7, 0.4, 0.2, 0), vec4(1), rsq)*length(Absorb(position, density))*rsq*0.2;\n    return tanh((selfIllum + extIllum)/SELFABS)*SELFABS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition= -3.*iCameraFwd;\n    \n    float m = 1.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    float rmin= length(cross(iViewDirection, iCameraFwd));\n    fragColor = BackgroundColor(iViewDirection - (0.003/pow(rmin, 3.))*cross(cross(iViewDirection, iCameraFwd), iCameraFwd));\n    \n    if (SphereHit(1., iCameraPosition, iViewDirection))\n    {\n        vec3 startPos = iCameraPosition + iViewDirection*SphereDist(1., iCameraPosition, iViewDirection);\n        float marchDis= SphereThrough(1., iCameraPosition, iViewDirection);\n        for (float n = 0.; n < NJUMPS; n++)\n        {\n            vec3 pos = startPos - iViewDirection*marchDis*((n+0.5)/NJUMPS);\n            float density = Density(pos);\n            float jd      = sqrt(Density(pos*0.5)*Density(pos*0.8));\n            fragColor *= exp(-Absorb(pos, density    )*(marchDis/NJUMPS));\n            fragColor +=         Add(pos, density, jd)*(marchDis/NJUMPS);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define T(r) pow(texture(iChannel0, r), vec4(2.))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -BLOOMSIZE; i < BLOOMSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(1,0)*i)/iResolution.xy)*exp(-(4.*i*i)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor = tot/(2.*BLOOMSIZE);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define T(r) pow(texture(iChannel0, r), vec4(2.))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -BLOOMSIZE; i < BLOOMSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(0,1)*i)/iResolution.xy)*exp(-(4.*i*i)/(BLOOMSIZE*BLOOMSIZE));\n    }\n    fragColor = tot/(2.*BLOOMSIZE);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BLOOMSIZE 20.\n#define PSFSIZE   20.\n#define NJUMPS    50.\n#define SELFABS   10.", "buffer_d_code": "#define T(r) pow(texture(iChannel0, r), vec4(1.3))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0);\n    for (float i = -PSFSIZE; i < PSFSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(1,0)*i)/iResolution.xy)*(1.-i/PSFSIZE)*(1.+i/PSFSIZE)/sqrt(i*i+1.);\n    }\n    for (float i = -PSFSIZE; i < PSFSIZE; i++)\n    {\n        tot += T((fragCoord + vec2(0,1)*i)/iResolution.xy)*(1.-i/PSFSIZE)*(1.+i/PSFSIZE)/sqrt(i*i+1.);\n    }\n    fragColor = tot/(PSFSIZE);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGGWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 301]]}
{"id": "cty3R3", "name": "2-Pass Buffer Bloom", "author": "gelami", "description": "A bloom implementation using only 2 buffer passes by making use of texture mipmaps", "tags": ["2d", "post", "postprocess", "bloom", "mipmap", "shapes", "hdr"], "likes": 35, "viewed": 1308, "published": 3, "date": "1684514006", "time_retrieved": "2024-07-30T17:55:07.238338", "image_code": "\n// 2-Pass Buffer Bloom - gelami\n// https://www.shadertoy.com/view/cty3R3\n\n/* \n * A bloom implementation using only 2 buffer passes by making use of texture mipmaps\n * \n * Since Shadertoy only has a few buffers available, we are not able to do the\n *   standard bloom methods which does multiple passes for the downsampling and upsampling\n * So instead, we can use the mipmaps with a large blur kernel for the downsampling\n * and a small blur in the upsampling to accomplish a similar thing\n * \n * For the first pass (Buffer B), we render each mipmap level at the same time\n *   with an 11x11 gaussian blur applied for the downsampling\n * Then the second pass (Image) simply adds all the mipmaps together,\n *   with a 3x3 gaussian blur pass to remove some of the blockiness from the mipmaps\n * \n * The 3x3 gaussian blur in the second pass was a bit of a bottleneck,\n *   so it is optimized to 4 taps using bilinear filtering.\n * More info about it on the article below\n * \n * Buffer A: Rendering the shapes\n * Buffer B: 1st pass, downsampling\n * Image: 2nd pass, upsampling\n * Defines in Common\n * \n * \n * Resources:\n * \n * Custom Bloom Post-Process in Unreal Engine - Froyok\n * https://www.froyok.fr/blog/2021-12-ue4-custom-bloom/\n * \n * Next generation post processing in Call of Duty: Advanced Warfare - Jorge Jimenez\n * http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n * \n * Optimized gaussian blur kernel using bilinear filtering\n * Optimizing Convolutions - John Chapman\n * https://john-chapman.github.io/2019/03/29/convolution.html\n * \n * \n * Other cool bloom shaders:\n *\n * Gargantua With HDR Bloom - sonicether\n * https://www.shadertoy.com/view/lstSRS\n *\n * Buffer pass bloom - robobo1221\n * https://www.shadertoy.com/view/lsBfRc\n */\n\nvec4 SampleLodBlurred(sampler2D tex, vec2 uv, vec2 res, const int lod)\n{\n    vec4 result = vec4(0);\n    float sc = exp2(float(lod));\n    vec2 nres = floor(res / sc * 0.5);\n    \n    #ifndef OPTIMIZED_UPSAMPLE_BLUR\n    const float[9] weights = float[](\n        1., 2., 1.,\n        2., 4., 2.,\n        1., 2., 1.\n    );\n    \n    float w = 0.0;\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 o = vec2(x, y);\n            float wg = weights[x + 1 + (y + 1) * 3];\n            vec2 p = uv + o / nres;\n\n            result += wg * SampleLod(iChannel1, saturate(p), iResolution.xy, lod);\n            w += wg;\n        }\n    }\n    result /= w;\n    \n    // Optimized blur using bilinear filtering\n    // https://john-chapman.github.io/2019/03/29/convolution.html\n    #else\n    \n    const vec2[4] offsets = vec2[](\n        vec2(-1.0/3.0, -1.0/3.0),\n        vec2( 1.0/3.0, -1.0/3.0),\n        vec2(-1.0/3.0,  1.0/3.0),\n        vec2( 1.0/3.0,  1.0/3.0)\n    );\n    \n    for (int i = 0; i < 4; i++)\n    {\n        vec2 o = offsets[i];\n        vec2 p = uv + o / nres;\n        \n        result += SampleLod(iChannel1, saturate(p), iResolution.xy, lod);\n    }\n    result *= 0.25;\n    \n    #endif\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    #ifndef UPSAMPLE_BLUR\n    col += SampleLod(iChannel1, uv, iResolution.xy, 0).rgb;\n    col += SampleLod(iChannel1, uv, iResolution.xy, 1).rgb;\n    col += SampleLod(iChannel1, uv, iResolution.xy, 2).rgb;\n    col += SampleLod(iChannel1, uv, iResolution.xy, 3).rgb;\n    col += SampleLod(iChannel1, uv, iResolution.xy, 4).rgb;\n    col += SampleLod(iChannel1, uv, iResolution.xy, 5).rgb;\n    \n    #else\n    \n    // Skip 3x3 blur on first 3 mips\n    #if 1\n    col += SampleLod(iChannel1, uv, iResolution.xy, 0).rgb;\n    col += SampleLod(iChannel1, uv, iResolution.xy, 1).rgb;\n    col += SampleLod(iChannel1, uv, iResolution.xy, 2).rgb;\n    #else\n    col += SampleLodBlurred(iChannel1, uv, iResolution.xy, 0).rgb;\n    col += SampleLodBlurred(iChannel1, uv, iResolution.xy, 1).rgb;\n    col += SampleLodBlurred(iChannel1, uv, iResolution.xy, 2).rgb;\n    #endif\n    \n    col += SampleLodBlurred(iChannel1, uv, iResolution.xy, 3).rgb;\n    col += SampleLodBlurred(iChannel1, uv, iResolution.xy, 4).rgb;\n    col += SampleLodBlurred(iChannel1, uv, iResolution.xy, 5).rgb;\n    \n    #endif\n    \n    col /= 6.0;\n    col = mix(texture(iChannel0, uv).rgb, col, BLOOM_FACTOR);\n    \n    //col = texture(iChannel1, uv).rgb;\n    //col = textureLod(iChannel0, uv, 4.0).rgb;\n    //col = SampleLod(iChannel1, uv, iResolution.xy, 4).rgb;\n    \n    // Tonemappers\n    //col = col / (1.0 + col);\n    //col = ACESFilm(col * 0.55);\n    //col = Uncharted2Tonemap(col);\n    //col = ReinhardExt(col, 5.5);\n    col = ReinhardExtLuma(col, 2.5); //5.5\n    //col = col / (1.0 + luminance(col));\n    //col = GlobalLogTonemap(col, 0.0, 3.5, 0.15);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define EXPOSURE 15.0\n\n#define BLOOM_FACTOR 0.6\n\n#define ROTATION\n\n#define DOWNSAMPLE_BLUR_RADIUS 5\n\n#define UPSAMPLE_BLUR\n#define OPTIMIZED_UPSAMPLE_BLUR\n\n#define MAX_LOD 6\n\n#define STEPS 512\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nvec4 SampleLod(sampler2D tex, vec2 uv, vec2 res, const int lod)\n{\n    vec2 hres = floor(res / 2.0);\n    \n    vec2 nres = hres;\n    float xpos = 0.0;\n    int i = 0;\n    for (; i < lod; i++)\n    {\n        xpos += nres.x;\n        \n        nres = floor(nres / 2.0);\n    }\n    \n    vec2 nuv = uv * vec2(nres);\n    \n    nuv = clamp(nuv, vec2(0.5), vec2(nres)-0.5);\n    nuv += vec2(xpos, 0);\n    \n    return texture(tex, nuv / res);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\nvec3 Uncharted2TonemapPartial(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 Uncharted2Tonemap(vec3 x)\n{\n    const float E = 2.5;\n    const float W = 11.2;\n    \n    return Uncharted2TonemapPartial(x * E) / Uncharted2TonemapPartial(vec3(W));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n// https://64.github.io/tonemapping/\n// https://imdoingitwrong.wordpress.com/2010/08/19/why-reinhard-desaturates-my-blacks-3\nvec3 ReinhardExt(vec3 col, const float w)\n{\n    vec3 n = col * (1.0 + col / (w * w));\n    return n / (1.0 + col);\n}\n\nvec3 ReinhardExtLuma(vec3 col, const float w)\n{\n    float l = luminance(col);\n    float n = l * (1.0 + l / (w * w));\n    float ln = n / (1.0 + l);\n    return col * ln / l;\n}\n\n// https://cs.brown.edu/courses/cs129/results/proj5/valayshah/\n// http://www.cs.nott.ac.uk/~pszqiu/webpages/Papers/icpr2006-hdri-camera.pdf\nvec3 GlobalLogTonemap(vec3 col, const float ymin, const float ymax, const float t)\n{\n    float y = luminance(col);\n    float a = (ymax - ymin) * t;\n    float lm = log(ymin + a);\n    float yn = (log(y + a) - lm) / (log(ymax + a) - lm);\n    return col * yn / y;\n}\n", "buffer_a_code": "// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-17 14:41:51\n\n// https://iquilezles.org/articles/distfunctions2d/\n// https://www.shadertoy.com/view/3tSGDy\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n// https://www.shadertoy.com/view/3tyBzV\nfloat dot2(vec2 p) { return dot(p, p); }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat smootherstep(float f)\n{\n    return f*f*f*(f*(f*6.0-15.0)+10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0);\n\n    col = vec3(1, 0.5, 1);\n    \n    float t = iTime * 0.8;\n    \n    #ifdef ROTATION\n    #if 0\n    pv *= rot2D(t * 0.8);\n    #else\n    pv *= rot2D(smootherstep(fract(t * 0.5 / PI)) * TAU);\n    #endif\n    #endif\n    \n    vec2 p1 = pv - vec2(0.8, 0);\n    vec2 p2 = (pv + vec2(0.8, 0.2)) * 2.6;\n    \n    #ifdef ROTATION\n    p1 *= rot2D(t * 1.0);\n    \n    p2.y -= 0.55;\n    p2 *= rot2D(t * 1.0);\n    p2.y += 0.55;\n    #endif\n    \n    float d = length(pv) - 0.2;\n    float r = 0.02;\n    float st = sdStar(p1, 0.25 - r, 5, 3.0) - r;\n    float sh = sdHeart(p2) / 2.6 - 0.02;\n    \n    if (st < d)\n    {\n        d = st;\n        col = vec3(1, 0.5, 0.2);\n    }\n    if (sh < d)\n    {\n        d = sh;\n        col = vec3(0.2, 0.5, 1);\n    }\n    \n    /*\n    float sb = abs(sdBox(pv, vec2(1.6, 0.8))) - 0.01;\n    if (sb < d)\n    {\n        d = sb;\n        col = vec3(1, 0.8, 0.6);\n    }*/\n    \n    col *= smoothstep(2.0 / iResolution.y, 0.0, d);\n    \n    col *= EXPOSURE;\n    col = max(col, vec3(0));\n    \n    fragColor = vec4(col, 1);\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat gaussian(vec2 i, float sigma) {\n    return exp(-dot(i,i) / (2.0 * sigma*sigma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 hres = floor(iResolution.xy / 2.0);\n        \n    vec2 res = hres;\n    float xpos = 0.0;\n    int lod = 0;\n    for (; lod < MAX_LOD; lod++)\n    {\n        xpos += res.x;\n        \n        if (xpos > fragCoord.x || res.x <= 1.0)\n            break;\n        res = floor(res / 2.0);\n    }\n    \n    if (fragCoord.y >= res.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    fragColor = vec4(0);\n    \n    vec2 px = 1.0 / iResolution.xy;\n    vec2 p = (fragCoord - vec2(xpos - res.x, 0)) / iResolution.xy;\n    vec2 uv = (fragCoord - vec2(xpos - res.x, 0)) / vec2(res);\n    \n    // Skip blurring LOD 0 for performance\n    #if 1\n    if (lod == 0)\n    {\n        fragColor = textureLod(iChannel0, uv, 1.0);\n        return;\n    }\n    #endif\n    \n    const int rad = DOWNSAMPLE_BLUR_RADIUS;\n    const float sigma = float(rad) * 0.4;\n\n    // TODO: Optimized blur kernel using bilinear\n    float sc = exp2(float(lod));\n    float w = 0.0;\n    for (int x = -rad; x <= rad; x++)\n    {\n        for (int y = -rad; y <= rad; y++)\n        {\n            vec2 o = vec2(x, y);\n            float wg = gaussian(o, sigma);\n            //float wg = exp(-dot(o, o) * 0.125);\n            vec2 p = uv + o / vec2(res);\n            \n            // Clamp to edge\n            //p = clamp(p, 0.5 / res, (res - 0.5) / res);\n            \n            // Clamp to border\n            if (p == clamp(p, vec2(0.5) / res, (res - 0.5) / res))\n                fragColor += wg * textureLod(iChannel0, p, float(lod));\n            w += wg;\n        }\n    }\n    fragColor /= w;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cty3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3039, 3039, 3096, 3096, 4911]]}
{"id": "cscGR2", "name": "strange", "author": "UsamagorQ", "description": "I made this based off of the default shader.\nI also probably made this a lot more complicated than it needed to be", "tags": ["strange"], "likes": 0, "viewed": 82, "published": 3, "date": "1684496289", "time_retrieved": "2024-07-30T17:55:08.061139", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat r = (5.+fragCoord.x)/iTime*sin(0.5);\nvec2 ew = vec2(fragCoord.xx*vec2(15.*sin(5.), sin(54.)));\nvec3 ew2 = vec3(ew.x*fragCoord.y + sin(ew.y*fragCoord.x)+4.);\n    vec2 uv = vec2 (fragCoord.yx/(iResolution.xy+fragCoord.yy*5.4525425));\n    vec3 col = 0.8533 + r+.434*cos(iTime+uv.xyx+ew2);\n    vec3 tr = vec3(fragCoord.x*fragCoord.y/4., uv.x*\n    (7.52*uv.y), col*vec3(sin(6.43),sin(74.764), sin(2.5342)/4.54\n    *(fragCoord*vec2(54., 9.))));\n    r*=uv.y*sin(ew.y+ew2.z)+sin(-fragCoord.y);\n    fragColor = vec4(col+tr/r/sin((iTime+ew2.x)+(fragCoord.x*fragCoord.y)*ew.y/09.),7.0);\n}\n\n/*\n// old code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 ew = vec2(fragCoord.xx*vec2(15.*sin(5.), sin(54.)));\nvec3 ew2 = vec3(ew.x*fragCoord.y + sin(ew.y*fragCoord.x)+4.);\n    vec2 uv = vec2 (fragCoord.yx/(iResolution.xy+fragCoord.yy*5.4525425));\n    vec3 col = 0.85465433 + .34*cos(iTime+uv.xyx+ew2);\n    vec3 tr = vec3(fragCoord.x*fragCoord.y/4., uv.x*\n    (7.52*uv.y), col*vec3(sin(6.43),sin(74.764), sin(2.5342)/4.54\n    *(fragCoord/vec2(54., 9.))));\n    fragColor = vec4(col+tr/2.+sin(iTime+ew2.z),7.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cscGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 641]]}
{"id": "clV3Rd", "name": "animated knitting 2b", "author": "FabriceNeyret2", "description": "efficient variant of https://shadertoy.com/view/dtKGDD\ninspiration reference:https://twitter.com/PavelBoytchev/status/1650945937462685713\nmouse controls camera.", "tags": ["short", "reproduction"], "likes": 51, "viewed": 506, "published": 3, "date": "1684484618", "time_retrieved": "2024-07-30T17:55:08.811133", "image_code": "// efficient variant of https://shadertoy.com/view/dtKGDD\n// cf https://www.desmos.com/calculator/zd265cjxqi\n#define rot2(a)  mat2(cos(a+vec4(0,11,33,0)))                         //\n#define arc(L)   l = max( length( vec2( length((L).xy)-r,(L).z) ) -.2, \\\n                          abs(atan((L).x,(L).y)-A)-A ),                \\\n                 t = l < t ? N = i-n , l : t\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,d=1., h,r,A,i, T, y,n, N,l, s = 1.3;\n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -4.*R.y) - R),           // ray direction\n          p = vec3(0,0,50), q,                             // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.          // camera control\n              :  vec3( -.8,-.5,0); //+vec3(.2,.4,0)*cos(.3*iTime + vec3(0,11,0));\n    \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 ) {       // march scene\n        q = p, \n        q.yz *= rot2(-M.y),                                // rotations\n        q.xz *= rot2(-M.x-1.57),\n        T = mod(iTime,1.33), q.x -= T*1.5;                 // infinite scroll\n        n = floor(q.y/s+.5), q.y = mod(q.y+s/2.,s)-s/2.;   // vertical repeat\n        if (q.x>1.) T = 2.5-T;                             // horizontal symmetry\n        T -= floor(abs(q.x/2.)+.5)*1.3, q.x = abs(mod(q.x-1.,2.)-1.); // repeat along x\n        for( i=0.; i<3.; i++ , q.y += s )                  // foreach thread\n            h = 2.3*clamp(T+i-n+3.7,1e-3,1.), r = (d*d+h*h)/h/4., A = atan(h/d),\n            y = .5*sin(1.2*s*q.y),\n            arc(     vec3(1, r  , y ) - q ), \n            arc( q - vec3(0, h-r, y )     ),\n            t = min(t, length(q-vec3(1,.75,0))+.1 );       // trick to limit the artifact\n         // t = min(t,max( length(q.yz)-.1, 1.-abs(q.x)) );\n        p += .5*t*D;                                       // step forward = dist to obj    \n    }\n   O *= O*O*O*2.                                           // color scheme \n     * ( 1. + .2 * cos( 6.3*fract(1e3*sin(1e3*N)) + vec4(0,23,21,0) ));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clV3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 374, 410, 410, 2022]]}
{"id": "dly3zd", "name": "Regular polygon interpolation", "author": "Larbagar", "description": "Interpolates between shapes by performing a weighted average between their SDFs.", "tags": ["polygon"], "likes": 0, "viewed": 160, "published": 3, "date": "1684459082", "time_retrieved": "2024-07-30T17:55:09.569106", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat regularPolygonDist(int sides, vec2 point){\n    float dist = -point.x;\n    for(int side = 1; side < sides; side++){\n        float angle = PI + 2.*PI*float(side)/float(sides);\n        dist = max(dist, dot(point, vec2(cos(angle), sin(angle))));\n    }\n    dist /= cos(float(PI/float(sides)));\n    return dist;\n}\n\nvec2 componentToPolar(vec2 point){\n    return vec2(length(point), atan(point.y, point.x));\n}\n\nvec2 polarToComponent(vec2 polar){\n    return polar.x*vec2(cos(polar.y), sin(polar.y));\n}\n\nvec2 rotatePoint(vec2 point, float angle){\n    return polarToComponent(componentToPolar(point) + vec2(0., angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n    \n    float weight = smoothstep(-0.1, 0.1, sin(iTime));\n    //float weight = sin(iTime)/2.+.5;\n    float shape =\n        regularPolygonDist(3, rotatePoint(uv, -iTime/4.))*weight +\n        regularPolygonDist(4, rotatePoint(uv, -iTime/2.))*(1. - weight);\n    \n    float col = 0.;\n    col += smoothstep(1., 0.95, shape);\n    //col -= shape;\n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dly3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 94, 94, 359], [361, 361, 395, 395, 453], [455, 455, 489, 489, 544], [546, 546, 588, 588, 662], [664, 664, 721, 721, 1163]]}
{"id": "dty3Rd", "name": "liquid metal", "author": "flylo", "description": "trig stuff", "tags": ["2d", "metal", "liquid"], "likes": 0, "viewed": 174, "published": 3, "date": "1684451579", "time_retrieved": "2024-07-30T17:55:10.411853", "image_code": "const int[18] ns = int[](-1, -1, 0, -1, 1, -1, -1, 0, 1, 0, 0, 0, -1, 1, 0, 1, 1, 1);\n\nvec4 texel(in ivec2 x) {\n    return texelFetch( iChannel0, x, 0 );\n}\n\nvec4 avg( in ivec2 px )\n{\n \n    vec4 sum = vec4(0.);\n        \n    for (int i = 0; i < 18; i += 2) {\n       vec4 n = texel(px+ivec2(ns[i%18],ns[(i%18)+1]));\n       sum += n;\n    }\n \n   return sum/9.;\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iv = ivec2(fragCoord);\n    fragColor = avg(iv);\n    fragColor = texel(iv);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r2;\n\n    float dt  = .5+.5*sin(.5*iTime);\n    float dt2 = .5+.5*sin(1.5+.8*iTime);\n    float mdt = .2+.8*dt;\n    float mdt2 = .2+.8*dt2;\n    \n    float dt3 = .5+.5*sin(.1*iTime);\n    float mdt3 = .1+.9*dt3;\n    float dt4 = .5+.5*sin(.17*iTime);\n    float mdt4 = .1+.9*dt4;\n\n    float dt5  = .5+.5*sin(.6*iTime);\n    float mdt5 = .1+.9*dt5;\n    float dt6 = .5+.5*sin(1.5+.7*iTime);\n    float mdt6 = .1+.9*dt6;\n\n\n    uv = vec2(.1+sin(3.1*mdt2*uv));\n    r2 = length(uv)*length(uv);\n    for(int i = 0; i< 4; i++) {\n        //uv = vec2(sin(uv.x), sin(uv.y));\n\n        r2 = length(uv)*length(uv);\n        uv = vec2(1./r2*uv.y, 1./r2*uv.x);\n        uv = vec2(mdt5*sin(tan(.5*mdt3*uv.x)), mdt6*sin(tan(.5*mdt4*uv.y)));\n\n        //uv = vec2(uv.x*sin(r2)-uv.y*cos(r2), uv.x*cos(r2)+uv.y*sin(r2));\n        //uv = vec2(cos(uv.x-uv.y), sin(uv.x-uv.y));\n   \n    }\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(uv.y, uv.x, dt3);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dty3Rd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 111, 111, 155], [157, 157, 182, 182, 361], [363, 363, 420, 420, 509]]}
{"id": "dtyGRd", "name": "Radioactive dreamy puddle", "author": "Mermersk", "description": "Just some experiments/learning. This AA is crazy expensive so turn off if slow. Was trying to get a \"glow\" effect which is achieved by accumulating color at every marching step, but this way of doing it seems to be brittle and leaves artifacts elswehere.", "tags": ["raymarching", "glow", "aa", "cineshader"], "likes": 21, "viewed": 486, "published": 3, "date": "1684450643", "time_retrieved": "2024-07-30T17:55:11.254600", "image_code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\n#define PI 3.141592653589793\n#define MAX_STEPS 300\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.001\n\nconst bool AA = false;\n\n//A struct that hold both the sdf value and the color\nstruct Surface {\n\tfloat distVal;\n\tvec4 color;\n\tint id; //0 = waves, 1 = skyDome\n};\n\n\nfloat singleWave(vec3 p, float wavelength, float amplitude, float speed, vec2 direction) {\n\t\n\tfloat frequency = 2.0/wavelength;\n\tfloat phaseConstant = speed * (2.0/wavelength);\n\t\n\treturn amplitude * sin(dot(direction, p.xz)*frequency + iTime*phaseConstant);\n\n\n}\n\nfloat singleWave2(vec3 p, float wavelength, float amplitude, float speed, vec2 direction) {\n\t\n\tfloat frequency = 2.0/wavelength;\n\tfloat phaseConstant = speed * (2.0/wavelength);\n\t\n\tconst float kkk = 2.5;\n\t\n\treturn 2.0*amplitude * pow((sin(dot(normalize(p.xz), p.xz)*frequency + iTime*phaseConstant)+1.0)/2.0, kkk);\n\n\n}\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise1d(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\t\n\treturn mix(hashwithoutsine11(i), hashwithoutsine11(i+1.0), smoothstep(0.0, 1.0, f));\n}\n\nSurface wavyPlane(vec3 p, vec4 col, int id) {\n\t\n\t\n\tfloat wave = singleWave(p, 3.0, 2.0, 2.0, vec2(1.0, 0.0));//a * sin(dot(d, p.xz)*f + iTime*pc);\n\t\n\tfloat w = 0.0;\n\t\n\tfloat waveLength = 5.0;\n\tfloat amplitude = 1.0;\n\tfloat speed = 0.9;\n\tvec2 dir = vec2(1.0, 0.0);\n\t\n\t//Coordinates from origin and increase equally in all directions from origin\n\tfloat fromMiddle = dot(normalize(p.xz), p.xz)*0.2;\n\t\n\tfor (int i = 0; i < 5; i++) {\n\t\tw += singleWave2(p, waveLength, amplitude, speed, dir);// + noise(p.xz*fromMiddle*waveLength*max(0.0, noise1d(fromMiddle)))*0.15;;\n\t\twaveLength *= 0.5;\n\t\tamplitude *= 0.55;\n\t\tspeed *= 0.5;\n\t\tdir = vec2(1.0, float(i)/1.0);\n\t}\n\t\n\tw += noise(p.xz*5.0+0.5*fromMiddle*9.0*max(0.0, sin(noise1d(fromMiddle))*0.8))*0.25;\n\t\n\t//vec4 bottom = vec4(0.6, 0.0, 0.5, 0.1);\n\t//vec4 top = vec4(0.17, 0.35, 0.95, 0.1);\n\t\n\tvec4 bottom = vec4(53.0/255.0, 92.0/255.0, 125.0/255.0, 0.1);\n\tvec4 top = vec4(192.0/255.0, 108.0/255.0, 132.0/255.0, 0.1);\n\t\n\tcol = mix(bottom, top, w-1.3);\n\t\n\treturn Surface((p.y + w)*0.33, col, id);\n\n}\n\n\n//@Shane - path function\nvec2 path(in float z){\n    vec2 p1 =vec2(2.38*sin(z * .15)+5.38*cos(z * .15), 3.4*cos(z * .0945));\n    vec2 p2 =vec2(3.2*sin(z * .179),4.31*sin(z * .127));\n    return (p1 - p2)*0.33;\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n\n\tif (obj1.distVal < obj2.distVal) {\n\t\treturn obj1;\n\t}\n\t\n\treturn obj2;\n}\n\nSurface getDist(vec3 p) {\n\t\n\tp.xy += path(p.z*2.0+iTime);\n\t//p.xz += path(p.x*1.0+iTime);\n\t\n\tSurface wavyPlanez = wavyPlane(p*1.0, vec4(1.0), 0);\n\t\n\treturn wavyPlanez;\n\n}\n\nSurface rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n\t\n\tSurface closestObject = Surface(0.0, vec4(1.0, 0.0, 0.0, 1.0), 0);\n\t\n\tvec4 glow = vec4(0.0);\n\t\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n\t\t//The current stop (blue point from video). Will in first iteration just be the rayOrigin\n\t\tvec3 currentStop = rayOrigin + (closestObject.distVal * rayDirection);\n\t\t//Distance to the closes \"thing\" in our scene\n\t\tSurface distToScene = getDist(currentStop);\n\t\tclosestObject.distVal += distToScene.distVal;\n\t\tclosestObject.color = distToScene.color;\n\t\tclosestObject.id = distToScene.id;\n\t\t\n\t\t\n\t\tglow += distToScene.color*(1.0/float(MAX_STEPS))*7.0;\n\t\t\n\t\tclosestObject.color = clamp(glow, 0.0, 1.0);\n\t\t\n\t\t// we have a hit || The distance is too large, this ray hit nothing. we marched past everything, dont want to march to infinity \n\t\tif (closestObject.distVal > MAX_DIST || distToScene.distVal < SURFACE_DIST) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\t\n\treturn closestObject;\n\n}\n\n/* ChatGPT solutuon for crating a view matrix */\nmat3 getViewMatrix(vec3 cameraPos, vec3 cameraTarget, vec3 cameraUp)\n{\n    // Calculate the view direction vector\n    vec3 viewDir = normalize(cameraTarget - cameraPos);\n\n    // Calculate the right and up direction vectors\n    vec3 rightDir = normalize(cross(cameraUp, viewDir));\n    vec3 upDir = cross(viewDir, rightDir);\n\n    // Create the view matrix\n    mat3 viewMatrix = mat3(rightDir, upDir, viewDir);\n\n    return viewMatrix;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 ogUV = uv;\n    uv = (uv * 2.0) - 1.0;\n    \n    //uv *= 1.0;\n    \n    float ar = iResolution.x / iResolution.y;\n    uv.x = uv.x * ar;\n    \n    //Init raymarch\n    vec3 rayOrigin = vec3(0.0, 6.0, -12.0);\n    \n    //vec3 lookAtPoint = vec3(sin(iTime*0.1)*10.0, cos(iTime*0.1)*13.0, 1.0);\n    vec3 lookAtPoint = vec3(sin(iTime*0.1)*10.0, cos(iTime*0.5)*3.0, 0.0);\n    \n    mat3 viewM = getViewMatrix(rayOrigin, lookAtPoint, vec3(0.0, 1.0, 0.0));\n    \n    vec3 col = vec3(0.0); \n    \n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0));\n    rayDirection = viewM * rayDirection;\n    //rayOrigin = viewM * rayOrigin;\n    //rayDirection = rayDirRes;\n    \n    Surface objects = rayMarch(rayOrigin, rayDirection);\n    float d = objects.distVal;\n    vec3 surfacePoints = rayOrigin + (rayDirection * d);\n    \n    if (AA) {\n        //AA\n        vec3 acc = vec3(0.0);\n        float offAmount = 0.001;\n        //Taking 3 samples up(y-axis) from current pixel and 1 down seems the best?\n        vec3[4] offs = vec3[](\n            vec3(0.0, offAmount*3.0, 0.0),\n            vec3(0.0, offAmount*2.0, 0.0),\n            vec3(0.0, offAmount, 0.0),\n            vec3(0.0, -offAmount, 0.0)\n        );\n\n        //Really expensive AA\n        for (int i = 0; i < offs.length(); i++) {\n            vec3 off = offs[i];\n            vec3 rayDirNeighb = rayDirection + off;\n            Surface neighbObjects = rayMarch(rayOrigin, rayDirNeighb);\n            acc += neighbObjects.color.rgb;\n        }\n        \n        col = col + ((objects.color.rgb + acc)/5.0);\n    } else {\n        col = col + objects.color.rgb;\n    }\n    \n     \n  \t\n  \t//col = col + objects.color.rgb;\n    //col = col + ((objects.color.rgb + acc)/5.0);\n    \n    //------ PostProcess experiments--------\n    //Contrast\n    float contrastVal = 1.0;\n    col = clamp(contrastVal * (col - 0.5) + 0.5, 0.0, 1.0);\n    //brightness\n    float brightness = 0.0;\n    col = clamp(col + brightness, 0.0, 1.0);\n    //Saturation\n    float grayscale = dot(col, vec3(0.299, 0.587, 0.114));\n    float saturation = 1.15;\n    col = clamp(mix(vec3(grayscale), col, saturation), 0.0, 1.0);\n    \n    //col = vec3(grayscale);\n    \n    //Gamma correction\n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 404, 404, 575], [577, 577, 668, 668, 895], [897, 897, 931, 931, 1016], [1018, 1018, 1040, 1040, 1179], [1181, 1266, 1288, 1288, 1692], [1694, 1694, 1718, 1718, 1850], [1852, 1852, 1897, 1897, 2891], [2894, 2919, 2941, 2941, 3103], [3105, 3105, 3155, 3155, 3228], [3230, 3230, 3255, 3255, 3400], [3402, 3402, 3455, 3455, 4352], [4354, 4403, 4473, 4516, 4836]]}
{"id": "mlGGRd", "name": "chica-instagram", "author": "jorge2017a2", "description": "chica-instagram....yes, it does have geometry errors... well my editor is not all correct :) ...oopsss....", "tags": ["chicainstagram"], "likes": 10, "viewed": 173, "published": 3, "date": "1684441541", "time_retrieved": "2024-07-30T17:55:12.285843", "image_code": "//por JorgeFlores.P.\n//18-may-2023\n//chica-instagram\n//yes, it does have geometry errors... well my editor is not all correct :) ...oopsss....\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n#define PI 3.141516\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\n\nvec2 p0_; //punto uv\nvec2 pt0; //punto pos0\nfloat DistL;\nvec3 ColL;  //color linea\nvec3 ColO;  //color salida Out\n\nvoid L( vec2 p1)\n{   DistL=sdSegment(p0_, pt0, p1 );\n    ColO= DrawFigBorde(ColL, ColO,DistL); //cabeza\n    pt0 = p1;\n}\nvoid SZ(vec2 p ){pt0 = p;}\nvoid M(vec2 p1){pt0 = p1;}\nvoid C(vec3 pcol){ColL=pcol;}\n\n\nvec3 nariz(vec2 p  ,vec3 col )\n{\nvec2 p1,p2,p3  ;\np1 = vec2(1.52, 3.58);\np2 = vec2(1.59, 3.53);\np3 = vec2(1.55, 3.46);\n\np0_ = p;\n\n ColO = col;\nSZ(p1);M(p1);C(vec3(0.));;\nL(p1);L(p2);L(p3);\n col = ColO;\n return col;\n}\n\n\nvec3 boca(vec2 p ,vec3 col)\n{\nvec2 p1 ,p2,p3;\nvec2 p4, p5,p6,p7 ;\n\np0_ = p;\n\nColO = col;\np1 = vec2(1.39, 3.35);\np2 = vec2(1.53, 3.35);\np3 = vec2(1.6, 3.33);\np4 = vec2(1.65, 3.3);\np5 = vec2(1.55, 3.27);\np6 = vec2(1.46, 3.29);\np7 = vec2(1.42, 3.34);\n\n  SZ(p1);M(p1);C(vec3(0.));\n  L(p1);L(p2);L(p3);L(p4);L(p5);L(p6);L(p7);\n col = ColO;\n return  col;\n}\n\n\nvec3 Cejaizq(vec2 pp , vec3 col)\n{\nvec2 p1C ;\nfloat r1c ,d1c ;\n\nvec2 p2C ;\nfloat r2c ,d2c ;\n\nvec2 p3c ;\nfloat r3c,d3c;\n\nvec2 p4c;\nfloat r4c,d4c;\n\nvec2 p;\nvec3 colc;\n\n p = pp;\n\np1C = vec2(1.29, 3.7); r1c = 0.25;\nd1c = sdCircle(p- p1C, r1c);\n\np2C = vec2(1.275, 3.615); r2c = 0.285;\nd2c = sdCircle(p- p2C, r2c);\n\np3c = vec2(1.585, 3.775);  r3c = 0.145;\nd3c = sdCircle(p- p3c, r3c);\n\np4c = vec2(0.985, 3.785); r4c = 0.135;\nd4c = sdCircle(p-p4c, r4c);\n\n float dt;\n dt = differenceSDF(d1c, d2c);\n dt = differenceSDF(dt, d3c);\n dt = differenceSDF(dt, d4c);\n colc = vec3(0.);\n col = DrawFigBorde(colc, col, dt);\n\n return  col;\n\n}\n\nvec3 CejaDer(vec2 pp, vec3 col)\n{\nvec2 p1C ;\nfloat r1c ,d1c;\n\nvec2 p2C;\nfloat r2c ,d2c;\n\nvec2 p3c;\nfloat r3c,d3c;\n\nvec2 p4c;\nfloat r4c,d4c;\n\nvec2 p;\nvec3 colc;\n\n p = pp;\n\n    p1C = vec2(1.765, 3.705); r1c = 0.225;\n    d1c = sdCircle(p- p1C, r1c);\n\n    p2C = vec2(1.77, 3.63); r2c = 0.25;\n    d2c = sdCircle(p- p2C, r2c);\n\n    p3c = vec2(1.52, 3.72); r3c = 0.15;\n    d3c = sdCircle(p- p3c, r3c);\n\n    p4c = vec2(2.015, 3.765); r4c = 0.125;\n    d4c = sdCircle(p- p4c, r4c);\n\n    float dt ;\n    dt = differenceSDF(d1c, d2c);\n    dt = differenceSDF(dt, d3c);\n    dt = differenceSDF(dt, d4c);\n\n    colc = vec3(0.);\n    col = DrawFigBorde(colc, col, dt);\n\n return col;\n}\n\nvec3 pestanaIzq(vec2 pp, vec3 col)\n{\nvec2 p1 , p2 , p3, p4 ;\nvec2 p ;\n p = pp;\np1 = vec2(1.42, 3.72);\np2 = vec2(1.33, 3.78);\np3 = vec2(1.21, 3.8);\np4 = vec2(1.17, 3.84);\n\n    p0_ = p;\n\n    ColO = col;\n\n  SZ(p1);M(p1);C(vec3(0.));\n  L(p1);L(p2);L(p3);L(p4);\n\n col = ColO;\n return col;\n}\n\n\n\n\nvec3 PeloA(vec2 pp ,vec3 col , out float dOut )\n{\nvec3 colc;\nvec2 p1C;float r1c ,d1c;float r3c,d3c;vec2 p3c;\nvec2 p4c;float r4c,d4c;vec2 p2C ;float r2c,d2c;\nvec2 p ;\n\nfloat dt;\n p = pp;\n\n colc = vec3(0.95, 0.8, 0.62);\n\n p1C = vec2(1.46, 3.99); r1c = 0.5;\n d1c = sdCircle(p- p1C, r1c);\n p3c = vec2(1.165, 3.615);  r3c = 0.275;\n d3c = sdCircle(p- p3c, r3c);\n\n p4c = vec2(1.215, 3.815); r4c = 0.275;\n d4c = sdCircle(p- p4c, r4c);\n\n dt = unionSDF(d1c, d3c);\n dt = unionSDF(dt, d4c);\n\n\np2C = vec2(1.735, 3.415); r2c = 0.675;\nd2c = sdCircle(p- p2C, r2c);\n\ndt = unionSDF(dt, d2c);\n\n col = DrawFigBorde(colc, col, dt);\n dOut = dt;\n return col;\n}\n\nvec3 PeloAFrente(vec2 pp,vec3 col,inout float dOut)\n{\nvec3 colc;\nvec2 p1C;float r1c,d1c;float d4c;\n\nvec2 p2C;float r2c,d2c;vec2 p;\n\nfloat dt ;\np = pp;\n\ncolc = vec3(0.95, 0.8, 0.62);\n\np1C = vec2(1.46, 3.99); r1c = 0.5;\nd1c = sdCircle(p-p1C, r1c);\ndt = d1c;\np2C = vec2(1.735, 3.515); r2c = 0.675;\nd2c = sdCircle(p- p2C, r2c);\n\ndt = differenceSDF(dt, d2c);\n\ndOut = dt;\ncol = DrawFigBorde(colc, col, dt);\nreturn col;\n}\n\n\nvec3 PeloBFrente(vec2 pp, vec3 col , inout float dOut) \n{\nvec2 p  ;\nvec2 p1C;float r1c,d1c;vec2 p2C;\nfloat r2c,d2c;float dt ;vec3 colc;\n\n p = pp;\n p1C = vec2(1.61, 3.97); r1c = 0.55;\n d1c = sdCircle(p- p1C, r1c);\n \n p2C = vec2(1.915, 4.265); r2c = 0.475;\n d2c = sdCircle(p-p2C, r2c);\n dt = intersectSDF(d1c, d2c);\n dt = unionSDF(dt, dOut);\n\n colc = vec3(0.95, 0.8, 0.62);\n col = DrawFigBorde(colc, col, dt);\n return col;\n}\n\n\n\nvec3 PeloB(vec2 pp, vec3 col,inout float dOut )\n{\nvec2 p, p1C, p2C;\nfloat r1c,d1c,r2c,d2c,dt;\nvec3 colc;\n\np = pp;\np1C = vec2(1.61, 3.97); r1c = 0.55;\nd1c = sdCircle(p-p1C, r1c);\n\np2C = vec2(1.915, 4.265); r2c = 0.475;\nd2c = sdCircle(p- p2C, r2c);\ndt = intersectSDF(d1c, d2c);\n\ncolc = vec3(0.95, 0.8, 0.62);\nvec2 p6 ;\nfloat d6,a6,b6,dt2;\nfloat ang;\nvec2 pr;\n\np6 = vec2(2.22, 2.935);\na6 = 0.46;\nb6 = 1.195;\n\nang = -30. * PI / 180.;\npr = Rotate(p-vec2(0., 0.), p6, ang);\n\nd6 = sdEllipse(pr-p6, vec2(a6, b6)); ////grados=-30.;\n\n\nfloat d1c2 ;\np1C = vec2(1.64, 3.77); r1c = 0.35;\nd1c2 = sdCircle(p- p1C, r1c);\n\ndt2 = differenceSDF(d6, d1c2);\ndt = unionSDF(dt, dt2);\ndt = unionSDF(dt, dOut);\ncol = DrawFigBorde(colc, col, dt);\nreturn col;\n}\n\nvec3 Cuerpo(vec2 pp ,vec3 col)\n{\n////cuerpo;\nfloat l1,t1,an1, al1 ;\nvec2 p;\n\np = pp;\n\np.y = p.y + 0.25;\n\nl1 = 1.515;\nt1 = 2.015;\nan1 = 0.285;\nal1 = 0.855;\n\nvec2 pos;\nvec2 med ;\nvec3 colc;\nfloat d1;\n\ncolc = vec3(1.);\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\nd1 = sdBox(p- pos, med);\n////busto;\nvec2 p1C ;\nfloat r1c,d1c;\np1C = vec2(1.28, 2); r1c = 0.41;\nd1c = sdCircle(p- p1C, r1c);\nvec2 p2C;\nfloat r2c,d2c;\n\np2C = vec2(1.8, 2); r2c = 0.42;\nd2c = sdCircle(p- p2C, r2c);\n\nfloat dt;\ndt = unionSDF(d1c, d2c);\ndt = unionSDF(dt, d1);\n\nfloat d1cu ;\nvec2 pr ;\nfloat ang ;\n\nl1 = 1.85;\nt1 = 2.41;\nan1 = 0.41;\nal1 = 0.18;\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\n////grados=58;\n\nang = 58. * PI / 180.;\npr = Rotate(p- vec2(-0.15, 0.), vec2(l1 + an1 / 2., t1 + al1 / 2.), ang);\nd1cu = sdBox(pr-pos, med);\ndt = unionSDF(dt, d1cu);\n\nl1 = 1.23 - 0.25;\nt1 = 2.395 + 0.25;\nan1 = 0.46;\nal1 = 0.205;\n////grados=-60;\nfloat d1cub ;\n\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\nang = -60. * PI / 180.;\npr = Rotate(p-vec2(0.15, 0.), vec2(l1 + an1 / 2., t1 + al1 / 2.), ang);\nd1cub = sdBox(pr-pos,med);\n\ndt = unionSDF(dt, d1cub);\nfloat d1cuc ;\n\nl1 = 1.51;\nt1 = 1.42;\nan1 = 0.45;\nal1 = 0.36;\npos = vec2(l1, t1);;\nmed = vec2(an1, al1);\nd1cuc = sdBox(p- pos, med);\ndt = unionSDF(dt, d1cuc);\n\n////cuadrado cuerpo union;\nl1 = 1.81;\nt1 = 1.545;\nan1 = 0.21;\nal1 = 0.355;\n\n\nfloat d1cud ;\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\nang = 10. * PI / 180.;\npr = Rotate(p- vec2(0.05, -0.1), vec2(l1 + an1 / 2., t1 + al1 / 2.), ang);\n\nd1cud = sdBox(pr- pos, med);\ndt = unionSDF(dt, d1cud);\n\nl1 = 1.21;\nt1 = 1.505;\nan1 = 0.21;\nal1 = 0.355;\n\n\nfloat d1cue ;\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\nang = -10. * PI / 180.;\npr = Rotate(p- vec2(-0.05, 0.), vec2(l1 + an1 / 2., t1 + al1 / 2.), ang);\n\nd1cue = sdBox(pr- pos, med);\ndt = unionSDF(dt, d1cue);\n\ncol = DrawFigBorde(colc, col, dt);\n\nreturn col;\n}\n\nvec3 Cuello(vec2 p,vec3 col)\n{\n\nfloat l1 ,an1,al1,t1;\nvec2 pos,med;\nfloat d1;\nvec3 colc;\nfloat di;\n\ndi = 0.025;\n////cuello;\nl1 = 1.525;\nt1 = 2.945;\nan1 = 0.185 - di;\nal1 = 0.205;\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\nd1 = sdBox(p- pos, med);\ncolc = vec3(1., 0.87, 0.8);\n\nvec2 p1, p2 ;\nfloat r1,r2,dt,d1a,d2a;\n\np1 = vec2(1.525, 3.445); r1 = 0.425;\nd1a = sdCircle(p- p1, r1);\np2 = vec2(1.51, 3.26); r2 = 0.35;\nd2a = sdCircle(p- p2, r2);\n\ndt = intersectSDF(d1a, d2a);\ndt = intersectSDF(dt, d1);\n\ncol = DrawFigBorde(colc, col, d1);\ncol = DrawFigBorde(vec3(0.), col, dt);\nreturn col;\n}\n\n\nvec3 Rostro(vec2 p,vec3 col)\n{\n////cabeza;\nvec2 p6 ;\nfloat a6,b6,d6;\n\nvec3 colc;\nvec2 p7;\nfloat d7,a7,b7;\n\np6 = vec2(1.52, 3.63);\na6 = 0.31;\nb6 = 0.52;\n\nd6 = sdEllipse(p-p6, vec2(a6, b6));\np7 = vec2(1.53, 3.75);\na7 = 0.43;\nb7 = 0.62;\n\nd7 = sdEllipse(p-p7, vec2(a7, b7));\n\ncolc = vec3(1., 0.87, 0.8);\nfloat dt ;\n\ndt = unionSDF(d6, d7);\ncol = Cuello(p, col);\ncol = DrawFigBorde(colc, col, dt);\n\nreturn col;\n}\n\n\n\nvec3 OjoIzq(vec2 p,vec3 col)\n{\nvec3 colc;\nvec2 p1,p2 ;\nfloat r1,d1, r2,d2;\nfloat d1a , d1b ,d2a ,dfa,dfb;\n\ncolc = vec3(0.43, 0.65, 0.74);\n\np1 = vec2(1.28, 3.57); r1 = 0.18;\nd1a = sdCircle(p- p1, r1);\n\np2 = vec2(1.31, 3.7); r2 = 0.17;\nd1b = sdCircle(p- p2, r2);\n\ndfa = intersectSDF(d1a, d1b);\n\n///// cornea izq y der;\n////cornea izq;\np1 = vec2(1.3, 3.64); r1 = 0.08;\nd2a = sdCircle(p- p1, r1);\ncol = DrawFigBorde(vec3(1., 1., 1.), col, dfa);\ncol = DrawFigBorde(colc, col, d2a);\np2 = vec2(1.305, 3.655);\nr2 = 0.025;\nd2 = sdCircle(p - p2, r2);\ncol = DrawFigBorde(vec3(0.), col, d2);\n\nreturn col;\n}\n\nvec3 ojoDer(vec2 p , vec3 col )\n{\nvec2 p2,p3 ;\nfloat r2,d2,dfb ;\nfloat r3,d3 ;\nvec2 p4 ;\nfloat r4 ,d4, d2b ;\np3 = vec2(1.79, 3.57); r3 = 0.19;\nd3 = sdCircle(p- p3, r3);\np4 = vec2(1.735, 3.705); r4 = 0.185;\nd4 = sdCircle(p-p4, r4);\n\ndfb = intersectSDF(d3, d4);\n////cornea der;\np2 = vec2(1.73, 3.64); r2 = 0.08;\nd2b = sdCircle(p- p2, r2);\n\nvec3 colc;\ncolc = vec3(0.43, 0.65, 0.74);\ncol = DrawFigBorde(vec3(1., 1., 1.), col, dfb);\ncol = DrawFigBorde(colc, col, d2b);\n\np2 = vec2(1.73, 3.65);\nr2 = 0.03;\n\nd2 = sdCircle(p- p2, r2);\ncol = DrawFigBorde(vec3(0.), col, d2);\n\nreturn col;\n}\n\nvec3 BrazoIzq(vec2 pp , vec3 col )\n{\nfloat l1,t1 ,an1,al1 ;\nvec2 pos,med ,p;\nfloat d1cu,ang,dt ;\nvec2 pr ;\nvec3 colc ;\np = pp;\n//p.y = p.y + 0.15;\np.y = p.y + 0.2;\ncolc = vec3(0.97, 0.86, 0.8);\n\nl1 = 0.77;\nt1 = 1.935;\nan1 = 0.21;\nal1 = 0.85;\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\nang = 15.0 * PI / 180.;\npr = Rotate(p- vec2(0.15, -0.02), vec2(l1 + an1 / 2., t1 + al1 / 2.), ang);\n\nd1cu = sdBox(pr- pos, med);\ndt = d1cu;\n\nl1 = 1.02;t1 = 2.68;an1 = 0.41;al1 = 0.18;\n\nfloat dt2 ;\nfloat d1cu3;\np.x = p.x - 0.15;\np.y = p.y - 0.05;\npos = vec2(l1, t1);;\nmed = vec2(an1, al1);\nd1cu3 = sdBox(p- pos, med);\ndt = unionSDF(dt, d1cu3);\n\ncol = DrawFigBorde(colc, col, dt);\nreturn col;\n\n}\n\nvec3 BrazoDer(vec2 pp , vec3 col )\n{\nfloat l1,t1,an1,al1 ;\nvec2 pos ,med  ;\nfloat d1cu ,ang , dt;\nvec2 pr ,p ;\nvec3 colc;\np = pp;\n//p.y = p.y + 0.15;\np.y = p.y + 0.20;\n\nl1 = 2.195;t1 = 2.025;an1 = 0.185;al1 = 0.855;\npos = vec2(l1, t1);\nmed = vec2(an1, al1);\nang = -10. * PI / 180.;\npr = Rotate(p- vec2(-0.15, 0.), vec2(l1 + an1 / 2., t1 + al1 / 2.), ang);\nd1cu = sdBox(pr- pos, med);\ndt = d1cu;\n\ncolc = vec3(0.97, 0.86, 0.8);\nl1 = 1.54;t1 = 2.73;an1 = 0.65;al1 = 0.18;\n\nfloat dt2 ,d1cu3 ;\n//p.y = p.y + 0.15;\n\npos = vec2(l1, t1);;\nmed = vec2(an1, al1);\nd1cu3 = sdBox(p- pos, med);\n\ndt = unionSDF(dt, d1cu3);\ncol = DrawFigBorde(colc, col, dt);\n\nreturn col;\n}\n\nvec3 lineaBusto(vec2 pp, vec3 col )\n{\nvec2 p1 ,p2, p3,p4,p;\n\np = pp;\np.y = p.y + 0.25;\n\np1 = vec2(1.5, 2.27);\np2 = vec2(1.56, 2.16);\np3 = vec2(1.58, 2.04);\np4 = vec2(1.57, 2);\n\nColO = col;\np0_ = p;\n\nSZ(p1);M(p1);C(vec3(1., 0., 0.));;\nL(p1);L(p2);L(p3);L(p4);;\n\ncol = ColO;\nreturn col;\n}\n\nvec3 lineaBusto2(vec2 pp , vec3 col)\n{\nvec2 p1 ,p2, p3,p4,p;\np = pp;\np.y = p.y + 0.25;\n//p.y = p.y + 3.5;\n\np1 = vec2(1.25, 1.68);\np2 = vec2(1.46, 1.71);\np3 = vec2(1.66, 1.72);\nColO = col;\np0_ = p;\nSZ(p1);M(p1);C(vec3(0.));;\nL(p1);L(p2);L(p3);;\n\ncol = ColO;\nreturn col;\n}\n\nvec3 lineaBusto3(vec2 pp, vec3 col)\n{\n\nvec2 p1 ,p2, p3,p4,p;\np = pp;\np.y = p.y + 0.25;\n\np1 = vec2(1.51, 1.79);\np2 = vec2(1.84, 1.66);\n\nColO = col;\np0_ = p;\nSZ(p1);M(p1);C(vec3(0.));\nL(p1);L(p2);;\n\ncol = ColO;\nreturn col;\n}\n\n\nvec3 chica(vec2 p, vec3 col )\n{\nfloat dOut ,dOut1 ,dOut2 ;\ncol = PeloA(p, col, dOut1);\ncol = PeloB(p, col, dOut1);\n\ncol = BrazoDer(p, col);\ncol = BrazoIzq(p, col);\n\ncol = Cuerpo(p, col);\ncol = Rostro(p, col);\n\ncol = pestanaIzq(p, col);\n\n\ncol = PeloAFrente(p, col, dOut);\ncol = PeloBFrente(p, col, dOut);\n\ncol = Cejaizq(p, col);\n\ncol = OjoIzq(p, col);\ncol = ojoDer(p, col);\ncol = nariz(p, col);\ncol = boca(p, col);\n\ncol = CejaDer(p, col);\n\ncol = lineaBusto(p, col);\ncol = lineaBusto2(p, col);\ncol = lineaBusto3(p, col);\n\nreturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\nuv.x *= iResolution.x/iResolution.y;\nuv-=vec2(0.0,-0.5); uv*=3.5;\nvec3 col=vec3(0.66,0.83,0.92);\nfloat t=iTime;\nuv.x=abs(uv.x)+(0.5+0.5*sin(t*2.0))-(5.5+6.7*sin(t))+1.0;\n\ncol=chica((uv-vec2(-0.5,-3.0))*0.5,col) ;\ncol=chica((uv-vec2(-3.5,-1.5)),col) ;\ncol=chica((uv-vec2(-5.5,-1.5))*2.0,col );\n\nfragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "float sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlGGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[665, 665, 727, 727, 853], [854, 854, 935, 935, 1063], [1065, 1065, 1129, 1129, 1200], [1204, 1204, 1251, 1251, 1278], [1279, 1279, 1322, 1322, 1349], [1350, 1350, 1398, 1398, 1426], [1428, 1444, 1492, 1492, 1570], [1572, 1572, 1607, 1607, 1630], [1632, 1632, 1669, 1669, 1741], [1743, 1743, 1795, 1795, 1902], [2020, 2020, 2038, 2038, 2139], [2140, 2140, 2157, 2157, 2166], [2167, 2167, 2183, 2183, 2193], [2194, 2194, 2212, 2212, 2223], [2226, 2226, 2258, 2258, 2442], [2445, 2445, 2474, 2474, 2795], [2798, 2798, 2832, 2832, 3419], [3421, 3421, 3454, 3454, 4085], [4087, 4087, 4123, 4123, 4372], [4377, 4377, 4426, 4426, 5014], [5016, 5016, 5069, 5069, 5430], [5433, 5433, 5490, 5490, 5855], [5859, 5859, 5908, 5908, 6592], [6594, 6594, 6626, 6638, 8455], [8457, 8457, 8487, 8487, 9041], [9044, 9044, 9074, 9086, 9450], [9454, 9454, 9484, 9484, 10048], [10050, 10050, 10083, 10083, 10629], [10631, 10631, 10667, 10667, 11308], [11310, 11310, 11346, 11346, 11967], [11969, 11969, 12006, 12006, 12255], [12257, 12257, 12295, 12295, 12527], [12529, 12529, 12566, 12566, 12751], [12754, 12754, 12785, 12785, 13287], [13290, 13290, 13347, 13347, 13722]]}
{"id": "DtGGRd", "name": "CC0: Atans begone!", "author": "mrange", "description": "CC0: Atans begone!\nTinkering around with an old shader\nManaged to remove atan from the loop which made me happy\nand thus sharing it\n", "tags": ["travelling"], "likes": 38, "viewed": 754, "published": 3, "date": "1684415212", "time_retrieved": "2024-07-30T17:55:13.144547", "image_code": "// CC0: Atans begone!\n//  Tinkering around with an old shader\n//  Managed to remove atan from the loop which made me happy\n//  and thus sharing it\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float bstart = 0.0;\nconst float bpm    = 150.0;\nconst float bhz    = bpm/60.0;\nconst float bperiod= 8.0/bhz;\n\n#define BTIME(n) ((n)*bperiod+bstart)\n\nfloat beatCount(float tm) {\n  return (tm-bstart)*bhz;\n}\n\nfloat beat(float tm) {\n  return smoothstep(0.25, 1.0, cos(TAU*beatCount(tm)));\n}\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 gcol0 = HSV2RGB(vec3(0.55, 0.9, 0.035*0.5));\n  const vec3 gcol1 = HSV2RGB(vec3(0.75, 0.85, 0.035*2.0));\n  float b = beat(TIME);\n  vec2 pp = rd.xy;\n  b *= step(BTIME(6.0), TIME);\n  return mix(gcol0, gcol1, b)/max(dot(pp, pp), 0.0001);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {\n  vec3  oc = ro - cb;\n  float card = dot(ca,rd);\n  float caoc = dot(ca,oc);\n  float a = 1.0 - card*card;\n  float b = dot( oc, rd) - caoc*card;\n  float c = dot( oc, oc) - caoc*caoc - cr*cr;\n  float h = b*b - a*c;\n  if( h<0.0 ) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  const float rdd = 2.0;\n  const float mm  = 5.0;\n  const float rep = 16.0;\n\n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n  \n  vec3 skyCol = skyColor(ro, rd);\n\n  vec2 etc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), 1.0);\n  vec3 etcp = ro+rd*etc.y;\n  rd.yx *= ROT(0.3*etcp.z);\n\n  vec3 col = skyCol;\n\n  float fi = smoothstep(BTIME(1.0), BTIME(3.0), TIME);\n\n  // I read somewhere that if you call atan in a shader you got no business writing shader code.\n  float a = atan(rd.y, rd.x);\n  for(float i = 0.0; i < mm; ++i) {\n    float ma = a;\n    float sz = rep+i*9.0;\n    float slices = TAU/sz; \n    float na = mod1(ma, slices);\n\n    float h1 = hash(na+13.0*i+123.4);\n    float h2 = fract(h1*3677.0);\n    float h3 = fract(h1*8677.0);\n\n    float tr = mix(0.5, 3.0, h1);\n    vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);\n    vec3 tcp = ro + tc.y*rd;\n    vec2 tcp2 = vec2(tcp.z, a);\n  \n    float zz = mix(0.025, 0.05, sqrt(h1))*rep/sz;\n    float tnpy = mod1(tcp2.y, slices);\n    float fo = smoothstep(0.5*slices, 0.25*slices, abs(tcp2.y));\n    tcp2.x += h2*TIME;\n    tcp2.y *= tr*(PI/3.0);\n    vec2 tcp3 = tcp2;\n    float w = mix(.2, 1.0, h2);\n    float tnpx = mod1(tcp3.x, w);\n    float h4 = hash(tnpx+123.4);\n\n    tcp2/=zz;\n    tcp3/=zz;\n    float d1 = abs(tcp2.y);\n\n    float d2 = length(tcp3) - 2.0*h4;\n    d2 = abs(d2)-1.0*h4;\n    d2 = abs(d2)-0.5*h4;\n    float d = mix(d1, d2, fi*(0.5+0.5*sin(0.01*tcp2.x)));\n    d *= zz;\n\n    vec3 bcol = (1.0+cos(vec3(0.0, 1.0, 2.0)+TAU*h3+0.5*h2*h2*tcp.z))*0.00005;\n    bcol /= max(d*d, 0.00001+5E-7*tc.y*tc.y);\n    bcol *= exp(-0.04*tc.y*tc.y);\n    bcol *= smoothstep(-0.5, 1.0, sin(mix(0.125, 1.0, h2)*tcp.z));\n    bcol *= fo;\n    col += bcol;\n  }\n\n  return col;\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm  = 3.0*TIME;\n  vec3 ro   = vec3(0.0, 0.0, tm);\n  vec3 dro  = normalize(vec3(1.0, 0.0, 3.0));\n  dro.xz *= ROT(0.2*sin(0.05*tm));\n  dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));\n  const vec3 up = vec3(0.0,1.0,0.0);\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = (cross(ww, uu));\n  vec3 col = color(ww, uu, vv, ro, p);\n  col -= 0.125*vec3(0.0, 1.0, 2.0).yzx*length(pp);\n  col = aces_approx(col);\n  col *= smoothstep(BTIME(0.0), BTIME(0.25), TIME);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 33329, "src": "https://soundcloud.com/jezbuddha/astral-traveller-1?si=fdf3916529a44e1ba0048a0098c59316&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 509, 509, 537], [539, 539, 561, 561, 619], [774, 774, 796, 796, 942], [1237, 1297, 1319, 1319, 1367], [1369, 1369, 1402, 1402, 1651], [1653, 1739, 1778, 1778, 1903], [1905, 2021, 2085, 2085, 2393], [2395, 2395, 2451, 2451, 4173], [4175, 4282, 4308, 4308, 4492], [4494, 4494, 4524, 4524, 5043], [5045, 5045, 5102, 5102, 5275]]}
{"id": "DtKGzc", "name": "Volumetric + PBR Pathtracer", "author": "ThePlaneGuy45", "description": "eyyy accurate volumetrics go brrrrr\n\nvolumetric code my own, scattering function by Poisson", "tags": ["raytracing", "textures", "pathtracing"], "likes": 6, "viewed": 287, "published": 3, "date": "1684411857", "time_retrieved": "2024-07-30T17:55:14.214686", "image_code": "// Shader settings in Common\n// Scene editor in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nPathtracer by TPG45\n\nfeel free to use as a base for other projects, just give credit\nalso feel free to expand on this, just give credit for the base pathtracer\n\nIncludes:\n- lighting, diffuse + specular + anisotropic\n- refraction\n- volumetrics\n- DOF & blur\n- multipass sampling\n- normal maps\n*/\n\n// Shader Settings\n#define FOCAL_LENGTH 500.0\n#define CAM_DISTANCE 1150.0\n#define MAX_BOUNCES 10\n#define SAMPLES 4\n#define DOF_AMOUNT 1.0\n#define BLUR_AMOUNT 2.0\n#define SCENE 0\n\n#define VOLUME_STEP_SIZE 10.0\n\n// Other random definitions\n#define T true\n#define F false\n#define PHI 1.61803398874989484820459\n#define PI 3.1415926535897932384626433832795028841971\n\nstruct Material {\n\n    vec3 color;\n    vec3 emission;\n    float emissionStrength;\n    \n    float sheen;\n    float roughness;\n    float metallic;\n    float aniso;\n    float anisoStrength;\n    \n    float transparency;\n    float ior;\n    \n    float density;\n\n};\n\nstruct Sphere {\n\n    Material material;\n    vec3 center;\n    float radius;\n\n};\n\nstruct Triangle {\n\n    Material material;\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec2 auv;\n    vec2 buv;\n    vec2 cuv;\n\n};\n\nstruct Plane {\n\n    Material material;\n    vec3 normal;\n    float height;\n    float scale;\n\n};\n\nstruct Cube {\n\n    Material material;\n    vec3 position;\n    vec3 size;\n\n};\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nstruct Record {\n\n    Ray ray;\n    bool hit;\n    Material material;\n    vec3 normal;\n    vec3 intersect;\n    float dist;\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n    int refrac;\n    int objID;\n    int hitID;\n    bool inVolume;\n    vec3 volEmission;\n    float volDensity;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n// Extra trig + hyperbolic functions by me, if you want to use please credit.\nfloat cot(float x){return cos(x)/sin(x);}vec2 cot(vec2 x){return cos(x)/sin(x);}vec3 cot(vec3 x){return cos(x)/sin(x);}vec4 cot(vec4 x){return cos(x)/sin(x);}float sec(float x){return 1./cos(x);}vec2 sec(vec2 x){return 1./cos(x);}vec3 sec(vec3 x){return 1./cos(x);}vec4 sec(vec4 x){return 1./cos(x);}float csc(float x){return 1./sin(x);}vec2 csc(vec2 x){return 1./sin(x);}vec3 csc(vec3 x){return 1./sin(x);}vec4 csc(vec4 x){return 1./sin(x);}float coth(float x){float a=exp(x);float b=exp(-x);return(a+b)/(a-b);}vec2 coth(vec2 x){vec2 a=exp(x);vec2 b=exp(-x);return(a+b)/(a-b);}vec3 coth(vec3 x){vec3 a=exp(x);vec3 b=exp(-x);return(a+b)/(a-b);}vec4 coth(vec4 x){vec4 a=exp(x);vec4 b=exp(-x);return(a+b)/(a-b);}float sech(float x){return 2./(exp(x)+exp(-x));}vec2 sech(vec2 x){return 2./(exp(x)+exp(-x));}vec3 sech(vec3 x){return 2./(exp(x)+exp(-x));}vec4 sech(vec4 x){return 2./(exp(x)+exp(-x));}float csch(float x){return 2./(exp(x)-exp(-x));}vec2 csch(vec2 x){return 2./(exp(x)-exp(-x));}vec3 csch(vec3 x){return 2./(exp(x)-exp(-x));}vec4 csch(vec4 x){return 2./(exp(x)-exp(-x));}\n\nuint raySphere(in Sphere sph, inout Record rec) {\n    vec3 offset = rec.ray.origin - sph.center;\n    float a = 2.0 * dot(offset, rec.ray.normal);\n    float b = dot(offset, offset) - sph.radius * sph.radius;\n    float disc = a * a - 4.0 * b;\n    rec.objID++;\n    if (disc > 0.0) {\n        float s = sqrt(disc);\n        float dstNear = max(0.0,(-a-s)/2.0);\n        float dstFar = (-a+s)/2.0;\n        if(dstNear < rec.dist) {\n            if(dstNear > 0.0) {\n            \n                rec.intersect = (rec.ray.normal * dstNear) + rec.ray.origin;\n                rec.normal = normalize(rec.intersect - sph.center);\n                rec.dist = dstNear;\n                rec.material = sph.material;\n                rec.hit = true;\n                rec.offset = (rec.intersect - sph.center - sph.radius) / sph.radius - 0.5;\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                rec.hitID = rec.objID;\n                rec.refrac = 1;\n                return uint(0x1);\n                \n            } else if(dstFar > 0.0) {\n            \n                rec.inVolume = rec.inVolume || sph.material.density > 0.0;\n                rec.volEmission += sph.material.emission * sph.material.emissionStrength;\n                rec.volDensity += sph.material.density;\n            \n                if(dstFar < rec.dist) {\n                \n                    rec.intersect = (rec.ray.normal * dstFar) + rec.ray.origin;\n                    rec.normal = normalize(rec.intersect - sph.center);\n                    rec.dist = dstFar;\n                    rec.material = sph.material;\n                    rec.hit = true;\n                    rec.offset = (rec.intersect - sph.center - sph.radius) / sph.radius - 0.5;\n                    rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                    rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                    rec.hitID = rec.objID;\n                    rec.refrac = -1;\n                \n                    return uint(0x1);\n                \n                }\n            \n            }\n        }\n        return uint(0x0);\n    }\n}\nuint rayTri(in Triangle tri, inout Record rec) {\n    vec3 ab = tri.b - tri.a;\n    vec3 ac = tri.c - tri.a;\n    vec3 bc = tri.c - tri.b;\n    vec3 normal = ab.yzx * ac.zxy - ab.zxy * ac.yzx;\n    vec3 ao = rec.ray.origin - tri.a;\n    vec3 dao = cross(ao, rec.ray.normal);    \n    float det = 1.0 / (-dot(rec.ray.normal, normal));    \n    float dist = dot(ao, normal) * det;\n    float u = dot(ac, dao) * det;\n    float v = -dot(ab, dao) * det;\n    float w = 1.0 - u - v;    \n    bool hit = det >= 1e-6 && dist >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;    \n    rec.objID++;\n    if(hit && dist < rec.dist) {    \n        rec.intersect = (rec.ray.normal * dist) + rec.ray.origin;\n        rec.normal = normalize(normal);\n        rec.dist = dist;\n        rec.material = tri.material;\n        rec.hit = true;\n        rec.offset = vec3(u, v, w);\n        \n        float xba = tri.buv.x - tri.auv.x;\n        float xcb = tri.cuv.x - tri.buv.x;\n        float yba = tri.buv.y - tri.auv.y;\n        float ycb = tri.cuv.y - tri.buv.y;\n        rec.tangent = normalize(ycb * ab - yba * bc);\n        rec.bitangent = normalize(-xcb * ab + xba * bc);\n        rec.hitID = rec.objID;\n        rec.refrac = 1;\n        \n        return uint(0x1);\n    }\n    return uint(0x0);\n}\nuint rayPlane(in Plane plane, inout Record rec) {\n\n    rec.objID++;\n    vec3 dao = cross(rec.ray.origin, rec.ray.normal);\n    float det = 1.0 / (-dot(rec.ray.normal, plane.normal));\n    float dist = dot(rec.ray.origin, plane.normal) * det;\n    \n    if(dist >= 0.0 && det >= 1e-6) {\n    \n        if(dist < rec.dist) {\n        \n            rec.intersect = (rec.ray.normal * dist) + rec.ray.origin;\n            rec.normal = plane.normal;\n            rec.dist = dist;\n            rec.material = plane.material;\n            rec.hit = true;\n            rec.offset = rec.intersect.xyz * plane.scale;\n            \n            rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n            if(rec.normal.x + rec.normal.z == 0.0) {\n            \n                rec.tangent = vec3(1.0, 0.0, 0.0);\n            \n            }\n            rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n            rec.hitID = rec.objID;\n            rec.refrac = 1;\n            \n            return uint(0x1);\n        \n        }\n    \n    }\n    \n    return uint(0x0);\n\n}\nuint rayCube(in Cube cube, inout Record rec) {\n\n    vec3 o = rec.ray.origin - cube.position;\n\n    rec.objID++;\n\n    vec3 m = sign(rec.ray.normal) / max(abs(rec.ray.normal), 1e-8);\n\n    vec3 n = m * o;\n    vec3 k = abs(m) * cube.size;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n    \n    float dist;\n\t\n    if (tN > tF || tF <= 0.) {\n    \n        return uint(0x0);\n        \n    } else {\n    \n        if (tN >= 0.0001) {\n        \n            if(tN < rec.dist) {\n        \n                rec.normal = -sign(rec.ray.normal) * step(t1.yzx,t1.xyz) * step(t1.zxy,t1.xyz);\n                rec.dist = tN;\n                rec.intersect = rec.dist * rec.ray.normal + rec.ray.origin;\n                rec.material = cube.material;\n                rec.hit = true;\n                rec.offset = vec3(0.0);\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                if(rec.normal.x + rec.normal.z == 0.0) {\n            \n                    rec.tangent = vec3(1.0, 0.0, 0.0);\n            \n                }\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                rec.hitID = rec.objID;\n                rec.refrac = 1;\n                return uint(0x1);\n            \n            }\n            \n        } else if (tF >= 0.0001) {\n            \n            rec.inVolume = rec.inVolume || cube.material.density > 0.0;\n            rec.volEmission += cube.material.emission * cube.material.emissionStrength;\n            rec.volDensity += cube.material.density;\n            \n            if (tF < rec.dist) { \n            \n                rec.normal = -sign(rec.ray.normal) * step(t1.yzx,t1.xyz) * step(t1.zxy,t1.xyz);\n                rec.dist = tF;\n                rec.intersect = rec.dist * rec.ray.normal + rec.ray.origin;\n                rec.material = cube.material;\n                rec.hit = true;\n                rec.offset = vec3(0.0);\n                rec.tangent = normalize(vec3(rec.normal.z, 0.0, -rec.normal.x));\n                if(rec.normal.x + rec.normal.z == 0.0) {\n            \n                    rec.tangent = vec3(1.0, 0.0, 0.0);\n            \n                }\n                rec.bitangent = normalize(cross(rec.normal, rec.tangent));\n                rec.hitID = rec.objID;\n                rec.refrac = -1;\n                \n                return uint(0x1);\n            \n            }\n            \n        } else {\n        \n            return uint(0x0);\n            \n        }\n        \n    }\n\n}\n\nvec3 random(inout uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    \n    return vec3(v)*(1.0/float(0xffffffffU));\n\n}\nvec3 randomNormal(vec3 n, inout uvec3 state) {\n\n    vec2 rv2 = random(state).xy;\n\n    vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n\n}\nvec3 randomScattering(uvec3 state) {\n    float a = random(state).x * 6.2831853;\n    float x = random(state).x * 2.0 - 1.0;\n    float z = random(state).x;\n    \n\treturn pow(z, 1.0 / 3.0) * vec3(sqrt(1.0 - x * x) * vec2(sin(a), cos(a)), x);\n}\n\nMaterial randomMaterial(in uvec3 state) {\n\n    vec3 color = random(state);\n\n    Material mat = Material(\n    \n        color,\n        color,\n        pow(random(state).x, 14.0) * 20.0,\n        random(state).x,\n        random(state).x,\n        random(state).x,\n        0.0,\n        0.0,\n        0.0,\n        1.5,\n        0.0\n    );\n    return mat;\n\n}\n\nfloat F_Schlick(float f0, float theta) {\n\n    return f0 + (1.0 - f0) * pow(1.0 - theta, 5.0);\n    \n}", "buffer_a_code": "// Materials:\n#define BRUSHED_STEAL Material(vec3(0.3, 0.3, 0.325), vec3(0.0), 0.0, 1.0, 0.5, 1.0, 0.6, 1.0, 0.0, 0.0, 0.0)\n#define BRUSHED_COPPER Material(vec3(1.0, 0.6, 0.2), vec3(0.0), 0.0, 0.9, 1.0, 1.0, 0.8, 1.0, 0.0, 0.0, 0.0)\n#define GREEN_PLASTIC Material(vec3(0.0, 0.6, 0.2), vec3(0.0), 0.0, 0.3, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n#define BLUE_PLASTIC Material(vec3(0.0, 0.2, 0.6), vec3(0.0), 0.0, 0.3, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n#define RED_PLASTIC Material(vec3(0.8, 0.1, 0.1), vec3(0.0), 0.0, 0.3, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n// Scene Editor ////////////////////////\nvoid distances( inout Record rec ) {\n\n    #if 1\n    raySphere( Sphere( Material(vec3(0.8, 0.8, 0.8), vec3(0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.004), vec3(0.0, 0.0, 0.0), 2000.0 ), rec );\n    for(float x = -1200.0; x <= 1200.0; x += 300.0) {\n    \n        for(float z = -600.0; z <= 600.0; z += 300.0) {\n    \n            #if SCENE == 0\n                raySphere( Sphere( randomMaterial(floatBitsToUint(vec3(x, z, 978))), vec3(x, 100.0, z), 100.0 ), rec );\n            #endif\n            #if SCENE == 1\n                rayCube( Cube( randomMaterial(floatBitsToUint(vec3(x, z, 978))), vec3(x, 100.0, z), vec3(100.0) ), rec );\n            #endif\n            \n        }\n    \n    }\n    #else\n    raySphere( Sphere( Material(vec3(0.8, 0.8, 1.0), vec3(0.2, 0.2, 1.0), 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), vec3(0.0), 100.0 ), rec );\n    raySphere( Sphere( Material(vec3(0.8, 0.8, 0.8), vec3(0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.004), vec3(0.0, 0.0, 0.0), 1000.0 ), rec );\n    #endif\n    rayPlane( Plane( Material(vec3(1.0), /**/ vec3(0.0), 0.0, 0.9, 0.6, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0 /**/), vec3(0.0, 1.0, 0.0 ), 0.0, 0.0 ), rec );\n    \n}\n////////////////////////////////////////\n\nvoid initRay( in vec2 fragCoord, inout Ray ray, uvec3 state ) {\n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    ray.origin = vec3(0.0, 0.0, -FOCAL_LENGTH) + vec3(random(state).xy * DOF_AMOUNT, 0.0);\n    ray.normal = normalize(vec3(fragCoord + random(state).x * BLUR_AMOUNT, 0.0) - ray.origin);\n    ray.origin.z -= CAM_DISTANCE;\n    #if 0\n    mat2 rot = rot2(-0.7);\n    ray.origin.yz *= rot; ray.normal.yz *= rot;\n    rot = rot2(0.0);\n    ray.origin.xz *= rot; ray.normal.xz *= rot;\n    #else\n    mat2 rot = rot2(8.0 * mouse.y);\n    ray.origin.yz *= rot; ray.normal.yz *= rot;\n    rot = rot2(8.0 * mouse.x);\n    ray.origin.xz *= rot; ray.normal.xz *= rot;\n    #endif\n}\n\nvoid initRecord(inout Record rec, in Ray ray) {\n\n    rec.ray = ray;\n    rec.hit = false;\n    rec.dist = 100000.0;\n    rec.volEmission = vec3(0.0);\n    rec.volDensity = 0.0;\n    rec.objID = 0;\n\n}\n\nvec3 worldSpace(vec3 map, vec3 t, vec3 b, vec3 n) {\n\n    mat3x3 tbn = mat3x3(t.x, b.x, n.x, t.y, b.y, n.y, t.z, b.z, n.z);\n    return normalize(map * tbn);\n\n}\n\nvec3 Trace( in vec2 fragCoord, in uvec3 state ) {\n\n    vec3 final = vec3(0.0);\n\n    for( int i = 0; i < SAMPLES; i++ ) {\n\n        Ray ray;\n        Record rec;\n        initRay( fragCoord, ray, state );\n        initRecord( rec, ray );\n        rec.refrac = -1;\n    \n        vec3 color = vec3(0.0);\n        vec3 increment = vec3(1.0);\n    \n        for( int j = 0; j < MAX_BOUNCES; j++ ) {\n    \n            distances( rec );\n    \n            if( rec.hit ) {\n            \n                #if 0\n                \n                return rec.material.color;\n                \n                #endif\n            \n                #if 0\n                \n                return vec3(rec.material.sheen, rec.material.roughness, rec.material.metallic);\n                \n                #endif\n                \n                float c = 0.0;\n                \n                if(rec.inVolume) {\n                \n                    c = (rec.dist / VOLUME_STEP_SIZE) * rec.volDensity;\n                \n                }\n                \n                if(c > random(state).x) {\n                \n                    rec.ray.origin += (random(state).x * rec.dist) * rec.ray.normal;\n                    rec.ray.normal = randomScattering(state);\n                    \n                    color += rec.volEmission * increment;\n                \n                } else {\n            \n                    vec3 matColor = rec.material.color;\n                \n                    float det = (1.0/(rec.material.roughness+1.0));\n                \n                    float theta = dot(rec.normal, -rec.ray.normal);\n                    float sheen = F_Schlick(rec.material.sheen, theta);\n                    float refrac = rec.material.transparency / sheen;\n                \n                    float spec = float(sheen > random(state).x);\n                \n                    vec3 diffuseCol = matColor * (1.0 - rec.material.metallic);\n                    vec3 specCol = mix(vec3(1.0), matColor, rec.material.metallic * 0.5);\n                \n                    vec3 anisoNorm = normalize(vec3(0.0, random(state).x * sign(random(state).x * 2.0 - 1.0) * rec.material.anisoStrength, 1.0));\n                    vec3 diffuseNorm = mix(randomNormal(rec.normal, state), rec.normal, spec * det);\n                \n                    rec.ray.origin = rec.intersect + rec.normal * 0.05;\n                \n                    rec.normal = mix(diffuseNorm, worldSpace(anisoNorm, rec.tangent, rec.bitangent, rec.normal), rec.material.aniso);\n                \n                    if(refrac > random(state).x || rec.refrac == -1) {\n                                    \n                        if(rec.refrac == 1) {\n                    \n                            rec.ray.origin = rec.intersect - rec.normal * 0.05;;\n                            rec.ray.normal = refract(rec.ray.normal, rec.normal, clamp(1.0 / rec.material.ior, 0.0, 1.0));\n                    \n                        } else {\n                    \n                            rec.ray.origin = rec.intersect + rec.normal * 0.05;\n                            rec.ray.normal = refract(rec.ray.normal, -rec.normal, clamp(rec.material.ior, 0.0, 1.0));\n                    \n                        }\n                \n                    } else {\n                \n                        rec.ray.normal = reflect(rec.ray.normal, rec.normal);\n                    \n                    }\n                \n                    initRecord(rec, rec.ray);\n        \n                    color += (rec.material.emission * rec.material.emissionStrength) * increment;\n                    increment *= mix(diffuseCol, specCol, spec);\n                \n                }\n    \n            } else {\n    \n                color += texture(iChannel0, rec.ray.normal).xyz * increment;\n                break;\n    \n            }\n            \n        }\n    \n        final += color;\n        \n    }\n    \n    final /= float(SAMPLES);\n    \n    return final;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float ratio = 720.0/iResolution.y;\n    vec2 coord = ratio * fragCoord;\n\n    vec3 det = vec3(coord, iFrame);\n\n    uvec3 state = floatBitsToUint(det);\n    \n    fragColor = vec4(Trace( coord - ratio * iResolution.xy / 2.0, state ), 1.0);\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "vec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.15, .0) * exp(-rd.y*9.); // Red / Green \n    col += vec3(.4, .6, .8) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * 0.6; // Sun\n    col += pow(max(dot(rd, sundir),0.), 150.0) * 4.0;\n    \n    return col * 1.2;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    //fragColor = texture(iChannel0, rayDir);\n    //fragColor = vec4(1.0);\n    fragColor = vec4(skyColor(rayDir), 1.0);\n}", "cube_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Save State Buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if(iMouse.z > 0.0) {\n    \n        fragColor = vec4(float(iFrame));\n        \n    }\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n\n    float frame = float(iFrame + 1) - texture(iChannel1, vec2(0.6, 0.5)).x;\n    \n    vec4 current = texture(iChannel2, uv);\n    \n    if(iMouse.z > 0.0) {\n    \n        fragColor = current;\n    \n    } else {\n    \n        fragColor = mix(fragColor, current, 1.0 / frame);\n    \n    }\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKGzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 197]]}
{"id": "clVGDw", "name": "Year of Truchets #020", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\nAA off by default - GPU killer but pretty!\n\n", "tags": ["raymarching", "torus", "refraction", "glass", "truchet"], "likes": 36, "viewed": 366, "published": 3, "date": "1684407856", "time_retrieved": "2024-07-30T17:55:15.035491", "image_code": "/**\n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #020\n    05/17/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n*/\n\n// AA = 1 = OFF else 2 > depending on GPU\n#define ZERO (min(iFrame,0))\n#define AA 1\n\n// AA\n\n#define R    \t\tiResolution\n#define T \t    \tiTime\n#define M \t    \tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MAX_DIST    50.\n\n// globals & const\nvec3 hit,hp;\nfloat mid,sid;\nmat2 flip,turn,r90;\n\nconst vec2 sz = vec2(1.25,1.5);\n\nconst vec3 size = sz.xyx;\nconst vec3 hlf = size/2.;\nconst vec3 bs = vec3(hlf*.9);\n// change depth / width / height of truchet grid\nconst vec3 grid = vec3(1,1,1);\n\nconst float thick = .175;\nconst float tc = thick*.55;\nconst float tf = thick*1.8;\nconst float td = thick;\nconst float tg = thick*1.2;\n    \nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.53,84.21+iDate.z)))*4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\n//@iq sdf's\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cap(vec3 p,float r,float h){\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n \nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    p.yz*=flip; p.xz*=turn;\n    vec3 q = p;\n    \n    vec3 id = floor((q + hlf)/size);\n    q = q-size*clamp(round(q/size),-grid,grid);\n   \n    float hs = hash21(id.xz+id.y);\n    if(hs>.5) q.xz*=r90;\n\n    vec2 p2 = vec2(length(q.xz-hlf.xz), length(q.xz+hlf.xz));\n    vec2 gx = p2.x<p2.y ? vec2(q.xz-hlf.xz) : vec2(q.xz+hlf.xz);\n    vec3 uv = vec3(gx.x,q.y,gx.y);\n\n    \n    float xhs = fract(2.*hs+id.y);\n    float rhs = fract(hs+id.x);\n    float trh = trs(uv,vec2(hlf.x,thick));\n\n    if(rhs>.9){\n        trh = length(vec3(abs(q.x),q.yz)-vec3(hlf.x,0,0))-thick;\n        trh = min(length(vec3(q.xy,abs(q.z))-vec3(0,0,hlf.z))-thick,trh);\n    } else if(rhs>.6){\n        trh = cap(q,hlf.x,thick);\n        trh = min(length(vec3(abs(q.x),q.yz)-vec3(hlf.x,0,0))-thick,trh);\n    } \n \n    trh=max(abs(trh)-.075,-trh);\n    trh=max(trh,box(q,bs));\n\n    if(trh<res.x ) {\n        float mt = floor(mod(xhs*7.32,4.))+1.;\n        res = vec2(trh,mt);\n        hit = uv;\n    } \n\n    \n    float bls = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),tc,tf);\n      bls = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),tc,tf),bls);\n    \n    float crt = cap(vec3(q.xy,abs(q.z))-vec3(0,0,hlf),td,tg);  \n      crt = min(cap(vec3(q.zy,abs(q.x))-vec3(0,0,hlf),td,tg),crt);\n   \n    bls=max(bls,-crt)-.01;\n\n    if(bls<res.x) {\n       res = vec2(bls,8.);\n       hit = q;\n    } \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(2,12,7);\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),.01,1.);\n    vec3 h = m==8.? vec3(.12) : hsv2rgb(vec3(T*.075+m*.08,.7,.3))*.4;\n\n    return h*diff;\n}\n\nvec3 render(in vec2 uv, in vec2 F )\n{    \n    vec3 C = vec3(0);\n    vec3 ro = vec3(0,0,3.25),\n         rd = normalize(vec3(uv,-1));\n\n    // mouse //\n    float mvt = 1.5707*sin(T*.08);\n    float x = M.xy==vec2(0) ? .68 : (M.y/R.y * 2.-1.)*PI;\n    float y = M.xy==vec2(0) ? .00 : (M.x/R.x * 2.-1.)*PI;\n\n    flip=rot(x+T*.07);\n    turn=rot(y+mvt);\n    r90=rot(1.5707);\n    \n    // bounces - set lower if slow\n    float b = 10.;\n\n    vec3  p = ro + rd * .1;\n    float atten = 1., k = 1., iv = 1., alpha = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n\n        float d = i<32? ray.x*.3: ray.x*.9;\n        float m = ray.y;\n\n        p += rd * d * k;\n        \n        if (d*d < 1e-6) {\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            \n            alpha *= 1e-1;\n            b -= 1.;\n            if(m==12.||b<1.)break;\n            \n            atten *= .98;\n            p += rd* .025;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv>0.?.875:1.1);\n            iv *= -1.;\n            \n            if(length(rf) == 0.) rf = reflect(rd,n);\n            \n            rd=rf;\n            p+=-n*.0025;\n        } \n        if(distance(p,rd)>45.) { break; }\n    }\n    \n    return C;\n}\n\nfloat fltm(float t, float d) { return hash21(vec2(t,d));}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec3 C = vec3(0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5;\n        vec2 uv = (-R.xy + 2.*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.*F)/max(R.x,R.y);\n#endif\n        vec3 color = render(uv,F);       \n        color = 1.35*color/(1.+color);\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    C = pow(C, vec3(.4545) );\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVGDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[931, 931, 949, 949, 993], [994, 994, 1015, 1015, 1079], [1080, 1080, 1124, 1124, 1179], [1181, 1193, 1218, 1218, 1303], [1305, 1305, 1339, 1339, 1444], [1447, 1447, 1473, 1473, 1542], [1544, 1544, 1561, 1561, 2938], [2940, 3009, 3054, 3054, 3277], [3278, 3292, 3319, 3319, 3432], [3434, 3434, 3495, 3495, 3712], [3714, 3714, 3751, 3751, 5062], [5064, 5064, 5094, 5094, 5121]]}
{"id": "dlc3Wl", "name": "Neon Core [289 chars]", "author": "kishimisu", "description": " Inspired by my previous spherical repetition experiment \n (https://www.shadertoy.com/view/Dt33RS)", "tags": ["raymarching", "ray", "marching", "repetition", "bloom", "code", "spherical", "short", "golf", "golfing"], "likes": 40, "viewed": 1357, "published": 3, "date": "1684406688", "time_retrieved": "2024-07-30T17:55:15.860286", "image_code": "/* Neon Core by @kishimisu (2023) - https://www.shadertoy.com/view/dlc3Wl\n   [289 chars]\n   \n   There's only one \"real\" sphere, all others are mirror versions\n*/\n\n#define M(p) p *= mat2(cos(round((atan(p.x,p.y)+k)/.3)*.3-k + vec4(0,33,11,0))),//\n#define L length(p)//\n\nvoid mainImage(out vec4 O, vec2 F) {   \n    vec3  p, R = iResolution;\n    float t, k = iTime*.2;\n    \n    for (O *= t; \n         O.a++ < 30.; \n         O += (1. + cos(k+k+t+vec4(0,1,2,0))) / 2e2 / L\n    ) \n         p = R - vec3(F+F, R.y),\n         p = t/L*p - 3./R,\n         M(p.zx) M(p.yx)\n         p.x -= 2., t -= L - .1;      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlc3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "mlKGzc", "name": "Image Transition SDF Mask", "author": "alphardex", "description": "Use mouse to slide.", "tags": ["transition"], "likes": 2, "viewed": 347, "published": 3, "date": "1684399538", "time_retrieved": "2024-07-30T17:55:16.700040", "image_code": "vec4 getFromColor(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec4 getToColor(vec2 uv){\n    return texture(iChannel1,uv);\n}\n\nconst float PI=3.14159265359;\n\n// rotate\nmat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\nfloat opSubtraction(float d1,float d2)\n{\n    return max(-d1,d2);\n}\n\nvec4 transition(vec2 uv){\n    float progress=iMouse.x/iResolution.x;\n    \n    float ratio=iResolution.x/iResolution.y;\n    \n    // SDF mask\n    vec2 grid=vec2(4.,4.);\n    \n    float pr=-2.*pow((2.*progress-1.),2.)+1.;\n    float offset=mix(0.,-.25,pr);\n    \n    // float angle=PI*.25/3.;\n    float angle=mix(0.,PI*.5,progress);\n    vec2 p1=uv;\n    p1=fract(p1*grid);\n    p1-=vec2(.5);\n    p1=rotate(p1,angle);\n    float d1=sdBox(p1,vec2(.5+offset,.75));\n    \n    vec2 p2=uv;\n    p2=fract(p2*grid);\n    p2-=vec2(.5);\n    p2=rotate(p2,angle+PI*.5);\n    float d2=sdBox(p2,vec2(.5+offset,.75));\n    \n    float d=opIntersection(d1,d2);\n    \n    float mask=1.-smoothstep(0.,.02,d);\n    \n    return mix(\n        getFromColor(uv)*mask,\n        getToColor(uv)*mask,\n        progress\n    );\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 col=transition(uv);\n    \n    fragColor=col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKGzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 63], [65, 65, 90, 90, 126], [159, 169, 198, 198, 303], [305, 305, 337, 337, 371], [373, 373, 407, 407, 481], [483, 483, 517, 517, 542], [544, 544, 585, 585, 610], [612, 612, 652, 652, 678], [680, 680, 705, 705, 1461], [1463, 1463, 1517, 1517, 1615]]}
{"id": "dlKGzc", "name": "Image Transition Ripple", "author": "alphardex", "description": "Use mouse to slide.", "tags": ["transition"], "likes": 0, "viewed": 239, "published": 3, "date": "1684399410", "time_retrieved": "2024-07-30T17:55:17.549769", "image_code": "vec4 getFromColor(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec4 getToColor(vec2 uv){\n    return texture(iChannel1,uv);\n}\n\nvec4 transition(vec2 uv){\n    float progress=iMouse.x/iResolution.x;\n    \n    float ratio=iResolution.x/iResolution.y;\n    \n    // ripple\n    vec2 p=uv;\n    float d=distance(vec2(.5),p);\n    d*=40.;\n    d=abs(sin(d));\n    d=step(smoothstep(.1,.9,1.-progress),d);\n    \n    return mix(\n        getFromColor(uv),\n        getToColor(uv),\n        d\n    );\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 col=transition(uv);\n    \n    fragColor=col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKGzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 63], [65, 65, 90, 90, 126], [128, 128, 153, 153, 480], [482, 482, 536, 536, 634]]}
{"id": "mtK3z3", "name": "something noisey", "author": "ArmandB", "description": "messing with noise\nmove the mouse to change the \"light\"", "tags": ["2d", "noise"], "likes": 4, "viewed": 154, "published": 3, "date": "1684383421", "time_retrieved": "2024-07-30T17:55:18.306745", "image_code": "//https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract((2.0*abs(p/3.14 - 2.0*floor(p/(2.0*3.14)) - 1.0) - 1.0)*43758.5453123);\n}\n\n//https://www.shadertoy.com/view/Msf3WH\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) )/2.0+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*30.0;\n    float n0 = noise(0.05*uv - 1279.0 + iTime*0.1 + noise(0.1*uv - noise(vec2(iTime*0.01)) + 2354.0));\n    float n1 = noise(0.05*uv - 1279.0 + iTime*0.1 + noise(0.1*uv - noise(vec2(iTime*0.01-0.2)) + 2354.0));\n    float n2 = noise(0.05*uv - 1279.0 + iTime*0.1 + noise(0.1*uv - noise(vec2(iTime*0.01+0.2)) + 2354.0));\n    vec3 lightDirection = normalize(vec3(iMouse.xy/iResolution.y - 0.5,0.5));\n    vec3 normal = normalize(vec3(n0-n1,0.1,n0-n2));\n    vec3 n = vec3(\n        n1,\n        0.8*n2,\n        0.5*n0\n    )*abs(n0 - 0.5)*8.0;\n\n    vec3 col = n*max(dot(normal,lightDirection),0.0) + n*0.2;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtK3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 97, 97, 261], [263, 303, 329, 329, 816], [818, 818, 875, 875, 1550]]}
{"id": "dlK3R3", "name": "Infinity Orbs", "author": "isaacchurchill", "description": "It doesn't draw the orbs in order from furthest to nearest so they pass in front of each other in ways that don't make sense. But otherwise I'm pretty happy with it", "tags": ["2d", "orb", "infinity", "orbs"], "likes": 1, "viewed": 177, "published": 3, "date": "1684375728", "time_retrieved": "2024-07-30T17:55:19.079678", "image_code": "vec2 circle(vec2 uv, vec2 pos, float r)\n{\n    vec2 diff = uv - pos;\n    diff /= r;\n    float d = dot(diff, diff);\n    float intensity = max(1.0 - d * d, 0.0);\n    float alpha = float(d <= 1.0);\n    return vec2(intensity, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    for (float i = 1.0; i <= 20.0; i++) {\n        if (i > 9.9 && i < 10.1) {\n            col = mix(col,\n                      (0.5 + 0.5 * sin(iTime + vec3(0,2,4))),\n                      min(1.5 + 0.5 * sin(iTime) - length(uv), 1.0));\n        }\n        float theta = iTime + i;\n        vec2 pos = vec2(sin(theta), 0.5 * cos(theta * 2.0 + 3.14159/2.0));\n        vec2 circ = circle(uv, pos, 0.1 + abs(pos.x) * 0.1);\n        vec3 circCol = 0.5 + 0.5 * cos(iTime * i * 0.4 +uv.xyx+vec3(0,2,4));\n        circCol = mix(circCol, vec3(0.0), circ.x);\n        col = mix(col, circCol, circ.y);\n    }\n    \n    for (float i = 1.0; i <= 20.0; i++) {\n        float theta = iTime + i;\n        vec2 pos = vec2(sin(theta), cos(theta)) * 1.6;\n        vec2 circ = circle(uv, pos, 0.15);\n        vec3 circCol = 0.5 + 0.5 * cos(iTime * i * 0.4 +uv.xyx+vec3(0,2,4));\n        circCol = mix(circCol, vec3(1.0), circ.x);\n        col = mix(col, circCol, circ.y);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlK3R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 230], [232, 232, 289, 289, 1416]]}
{"id": "ctK3zc", "name": "Fork Fork swirl flylo 745", "author": "flylo", "description": "trig stuff", "tags": ["2d"], "likes": 1, "viewed": 137, "published": 3, "date": "1684375067", "time_retrieved": "2024-07-30T17:55:19.905470", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r2;\n\n    float dt  = .5+.5*sin(.5*iTime);\n    float dt2 = .5+.5*sin(1.5+.6*iTime);\n    float mdt = .2+.8*dt;\n    float mdt2 = .2+.8*dt2;\n    \n    uv = vec2(.1+sin(3.1*mdt2*uv));\n    r2 = length(uv)*length(uv);\n    for(int i = 0; i< 4; i++) {\n        //uv = vec2(sin(uv.x), sin(uv.y));\n        uv = vec2(mdt2*tan(.5*mdt*uv.x), mdt*tan(.5*mdt2*uv.y));\n\n        r2 = length(uv)*length(uv);\n        uv = vec2(1./r2*uv.y, 1./r2*uv.x);\n\n        //uv = vec2(uv.x*sin(r2)-uv.y*cos(r2), uv.x*cos(r2)+uv.y*sin(r2));\n        //uv = vec2(cos(uv.x-uv.y), sin(uv.x-uv.y));\n   \n    }\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(uv.x, uv.y, uv.y-uv.x);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctK3zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 924]]}
{"id": "DlKGRc", "name": "Circlacc", "author": "Slals", "description": "Pixelated form", "tags": ["light", "pattern", "fract"], "likes": 0, "viewed": 101, "published": 3, "date": "1684364574", "time_retrieved": "2024-07-30T17:55:20.715305", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    vec2 M = vec2(cos(iTime * 0.5), sin(iTime)) * 0.4;\n    \n    float n = max(4.0, iMouse.x / 10.0);\n        \n    uv *= n;\n    vec2 pid = floor(uv);\n    uv = fract(uv);\n    \n    float c = length(M - (pid / n)) * 2.0;\n    \n    col = vec3(0.5, 0.2, 0.8 * c) * (1.0 - c);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKGRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 475]]}
{"id": "mtyGRK", "name": "Sneaking", "author": "Slals", "description": "Do you know how I can set a fixed color for each tile by getting the center of the circle displayed in the tile? Where a \"tile\" is defined by pid coordinates. My goal is to draw circle using tiles, resulting in a pixellated circle ", "tags": ["light", "pattern", "fract"], "likes": 1, "viewed": 121, "published": 3, "date": "1684362490", "time_retrieved": "2024-07-30T17:55:21.557054", "image_code": "float rand(vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43534.3434);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = vec3(0);\n    vec2 M = vec2(cos(iTime * 0.5), sin(iTime)) * 0.4;\n    \n    float n = 10.0;\n        \n    uv *= n;\n    vec2 pid = floor(uv);\n    uv = fract(uv);\n    \n    float c = length((uv - M - (pid / n))) * 0.3;\n    \n    col = vec3(c, c * (pid.y / n) * 0.5, c * 0.3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtyGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 96], [98, 98, 155, 155, 539]]}
{"id": "DtyGzc", "name": "envelope glue hallucination", "author": "hashtagexo", "description": "Fork of \"Levels jerry, levels!\" by mrange. https://shadertoy.com/view/dt3GDl \n", "tags": ["2d"], "likes": 2, "viewed": 67, "published": 3, "date": "1684346817", "time_retrieved": "2024-07-30T17:55:22.411769", "image_code": "// Fork of \"Levels jerry, levels!\" by mrange. https://shadertoy.com/view/dt3GDl\n// 2023-05-17 17:17:43\n\n// CC0: Levels jerry, levels!\n// Created on a bus trip last week (good seats and power outlets).\n// Felt a bit meh at the time but looking at it today I felt it good enough to share \n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          7.74\n// why does PI always have to be 3.14blahblahblah?! Stop oppressing me with your mathriarchal constants!!\n#define TAU         (7.74*PI)\n// DOWN WITH THE MATHRIARCHY! \n#define ROT(a)      mat2(-cos(a), cos(a), -sin(a), -atan(a))\n// sines, cosines and tangents can swap with each other and swing signs the other way AND YOU DONT GET TO JUDGE THEM!\n\nvec3 layerColor(float n) {\n  return 0.75*(0.95+sin(0.99*vec3(0.5, 0.9, 0.9)+0.9*n-TIME));\n  // I think I liked the old regime's color scheme better, tho\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat dcross(vec2 p, vec2 b, float r )  {\n  p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n  vec2  q = p - b;\n  float k = max(q.y,q.x);\n  vec2  w = (k>0.3) ? q : vec2(b.y-p.x,-k);\n  return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat df(vec2 pp, float n) {\n  float r = 0.0035*(n*n)+0.35;\n  float nn = 4.0;\n  return dcross(pp,r*vec2(2.0, 0.75), 0.3*r)-0.2*r;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float lum = 0.125/max(length(p), 0.1);\n  vec3 col = vec3(0.1, 0.2, 1.0)*lum;\n  \n  p *= ROT(0.1*TIME);\n  \n  float aa = 4.0/RESOLUTION.y;\n  \n  for (float n = 0.0; n < 12.0; ++n) {\n    const float soff = 0.0125;\n    float nn = 4.0;\n    mat2 rot = ROT(0.5*PI*sin(0.25*TIME-0.1*n)*cos(-0.123*TIME+0.123*n));\n    vec2 pp = p;\n    pp *= rot;\n    vec2 sp = p+vec2(0.0, soff);\n    sp *= rot;\n    float dd = df(pp, n);\n    float sdd = df(sp, n);\n    \n    col *= mix(0.333, 1.0, smoothstep(0.0, 0.3, sqrt(max(-sdd+soff, 0.0))));\n    vec3 dcol = layerColor(n);\n    col = mix(col, dcol, smoothstep(0.0, -aa, -dd)); \n  }\n  \n  vec2 cpp = pp-vec2(0.0, 0.25);\n  col -= 0.1*vec3(1.0, 2.0, 3.0).yzx*length(cpp);\n  col *= smoothstep(2.0, 0.5, length(cpp));  \n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyGzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[718, 718, 744, 744, 872], [874, 992, 1033, 1033, 1208], [1210, 1210, 1238, 1238, 1341], [1343, 1343, 1373, 1373, 2149], [2151, 2151, 2208, 2208, 2380]]}
{"id": "clyGR3", "name": "Ball Wall", "author": "SnoopethDuckDuck", "description": "A tribute to the King", "tags": ["h"], "likes": 26, "viewed": 456, "published": 3, "date": "1684335219", "time_retrieved": "2024-07-30T17:55:23.263492", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 3, 3);\n    ro.yz *= rot(pi/4. + pi/16. * cos(0.4 * iTime));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvec2 map(vec3 p) {\n    vec3 q = p;\n    float t = iTime;\n    float m = 0.5;\n    p.yz -= 2.* t;\n    p *= 0.5;\n    vec3 ip = floor(p) + 0.5;\n    t += ip.x + ip.y + ip.z;\n    p = fract(p) - 0.5;// p = mod(p, 1.5) - 0.75;\n    for (float i = 0.; i < 3.; i++) {\n        p = abs(p) - m;\n        m *= 0.5;\n        p.xz *= rot(t);\n        p.yz *= rot(t);\n    }\n    //p = mod(p, 1.5) - 0.75;\n    float d = mlength(p) - 0.04 + 0.08 * cos(ip.x);\n    d += 0.04 * cos(100. * (ip.z+ip.y) + iTime);\n\n    float x = 8.;\n    float r = 1.5 + 9. * (1.-tanh(0.07 + 0.06 * iTime));\n    d = smin(d, length(q - vec3(0,0,-9. + cos(0.8 * iTime))) - r, r - 1.4);\n\n    return vec2(d, 0);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        //m.x *= 0.8 + 0.2 * hash(hash(p.x,p.z), p.y); // for glow\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.015 * i;\n        float d = map(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0), tanh(0.02 + 0.03 * iTime));\n    vec3 col = vec3(0);\n   \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    \n    if (d<MAX_DIST) {        \n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);        \n\n        vec3 ld = -rd;// normalize(vec3(1,2,3) );\n      //  ld.xz *= rot(1.*p.y + iTime);\n        float dif  = dot(n,  ld)*.5+.5;\n        float spec = pow(dif, 2048.);\n        float fres = pow(1. + dot(rd, n),  5.);\n     \n        col = vec3(spec); \n      //  col = clamp(col, 0., 1.);\n        //col *= mix(vec3(1,0,0), vec3(0,0,1), 1.-exp(-0.04*dot(p,p)));\n    }\n    \n    float osc = 0.5 + 0.5 * thc(12., 0.005 * p.z + 0.6 * iTime);\n    osc = 1.-tanh(0.08 * iTime);\n    vec3 bg = vec3(1,0,0) + exp(-20.* osc * abs(rd.x));\n    \n    col = mix(col, bg, 1.-1. / cosh(0.012*dot(p,p))); //0.02\n    col.b *= mix(1., exp(-0.00015*m.y*m.y), tanh(0.04 * iTime));\n    col.b = tanh(3.5 * col.b);\n    col = mix(col, bg, 1.-1. / cosh(0.012*dot(p,p)));\n    col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33325, "src": "https://soundcloud.com/albcreeperyt/kaarija-cha-cha-cha-1?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//        Tater - raymarching\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nfloat smin(float a, float b, float k) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k/4.;\n}\n\n/*\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}//*/\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 80, 80, 285], [287, 287, 305, 305, 946], [948, 948, 987, 987, 1497], [1499, 1499, 1518, 1518, 1700], [1702, 1702, 1746, 1746, 1937], [1939, 1939, 1971, 1971, 2206], [2208, 2208, 2246, 2246, 2589], [2591, 2591, 2648, 2648, 3842]]}
{"id": "mtK3RV", "name": "Fork Fortress H NikolaErce 909", "author": "NikolaErceg", "description": "License CC0: Fortress Harkonnen\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n", "tags": ["2d", "fractal"], "likes": 5, "viewed": 187, "published": 3, "date": "1684324927", "time_retrieved": "2024-07-30T17:55:24.049390", "image_code": "// License CC0: Fortress Harkonnen\n// Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\n// SABS from ollj\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define PI      3.141592654\n#define TAU     (0.25*3.141592654)\n#define TIME    iTime\n#define PERIOD  0.1\n#define PERIODS 2.0\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat plane(vec2 p, vec2 n, float m) {\n  return dot(p, n) + m;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat holey(float d, float k) {\n  return abs(d) - k;\n}\n\nfloat tanh2(float x) {\n  // Hack around precision problem\n  if (abs(x) > 80.0) {\n    return sign(x);\n  } else {\n    return tanh(x);\n  }\n}\n\nfloat nfield(vec2 p, vec2 c) {\n  vec2 u = p;\n\n  float a = 0.0;\n  float s = 3.0;\n\n  \n  for (int i = 0; i < 25; ++i) {\n    float m = dot(u,u);\n    u = SABS(u, 0.0125)/m + c;\n    u *= pow(s, 0.95);\n    a += pow(s, 18.0)*m;\n    s *= 0.75;\n  }\n  \n  return -tanh2(0.125*a);\n}\n\nvec3 normal(vec2 p, vec2 c) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(2.0/iResolution.y, 0);\n  \n  vec3 n;\n  n.x = nfield(p + e.xy, c) - nfield(p - e.xy, c);\n  n.y = 1.0*e.x;\n  n.z = nfield(p + e.yx, c) - nfield(p - e.yx, c);\n  \n  return normalize(n);\n}\n\nvec3 field(vec2 p, vec2 c) {\n  vec2 u = p;\n\n  float a = 0.0;\n  float s = 3.0;\n\n  vec2 tc = vec2(0.5, 0.3);\n  rot(tc, TAU*TIME/PERIOD);\n  vec2 tpn = normalize(vec2(1.0));\n  float tpm = 0.0 + 1.4*tanh(length(p));\n  \n  float tcd = 1E10;\n  float tcp = 1E10;\n  \n  for (int i = 0; i < 18; ++i) {\n    float m = dot(u,u);\n    u = SABS(u, 0.0125)/m + c;\n    tcd = min(tcd, holey(circle(u-tc, 0.05), -0.1));\n    tcp = min(tcp, holey(plane(u, tpn, tpm), -0.1));\n    u *= pow(s, 0.5);\n    a += pow(s, 1.0)*m;\n    s *= 0.75;\n  }\n  \n  return vec3(tanh(0.125*a), tanh(tcd), tanh(tcp));\n\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n    \n  float currentPeriod = mod(floor(TIME/PERIOD), PERIODS);\n  float timeInPeriod = mod(TIME, PERIOD);\n  \n  p *= 0.25 + (0.05*timeInPeriod) + pow(1.35, currentPeriod);\n  vec2 c = vec2(-0.5, -0.55);\n   \n  vec3 gp = vec3(p.x, 1.0*tanh(1.0 - (length(p))), p.y);\n  vec3 lp1 = vec3(-1.0, 1.5, 1.0);\n  vec3 ld1 = normalize(lp1 - gp);\n  vec3 lp2 = vec3(1.0, 1.5, 1.0);\n  vec3 ld2 = normalize(lp2 - gp);\n  vec3 f = field(p, c);\n\n  vec3 n = normal(p, c);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n  \n  const vec3 dcol1 = vec3(0.3, 0.5, 0.7).xyz;\n  const vec3 dcol2 = 0.5*vec3(0.7, 0.5, 0.3).xyz;\n  const vec3 scol1 = 0.5*vec3(1.0);\n  const vec3 scol2 = 0.5*0.5*vec3(1.0);\n  \n  col += diff1*dcol1;\n  col += diff2*dcol2;\n  col += scol1*pow(diff1, 10.0);\n  col += scol2*pow(diff2, 3.0);\n  col -= vec3(tanh(f.y-0.1));\n  col += 0.5*(diff1+diff2)*(1.25*pow(vec3(f.z), 5.0*vec3(1.0, 4.0, 5.0)));\n \n  col = postProcess(col, q);\n \n  const float fade = 0.0;\n  float fadeIn  = smoothstep(0.0, fade, timeInPeriod);\n  float fadeOut = 1.0-smoothstep(PERIOD - fade, PERIOD, timeInPeriod);\n  col *= fadeIn*fadeOut;\n \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtK3RV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[392, 392, 425, 425, 510], [512, 512, 550, 550, 576], [578, 578, 609, 609, 635], [637, 637, 668, 668, 691], [693, 693, 715, 750, 830], [832, 832, 862, 862, 1101], [1103, 1103, 1132, 1132, 1351], [1353, 1353, 1381, 1381, 1926], [1928, 1928, 1964, 1964, 2212], [2214, 2214, 2269, 2269, 3559]]}
{"id": "dlKGRV", "name": "Hexagonally Discretized Waves", "author": "dr2", "description": "Wave watching on a hexagonal grid (mouseable)", "tags": ["grid", "wave", "hexagon"], "likes": 36, "viewed": 492, "published": 3, "date": "1684324297", "time_retrieved": "2024-07-30T17:55:24.799385", "image_code": "// \"Hexagonally Discretized Waves\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Wave watching on a hexagonal grid (mouseable)\n\n/*\n  No. 7 in \"Hexagon Waves\" series\n    \"Cookie Waves\"         (wlSSWy)\n    \"Paper Rolls\"          (WlKSRd)\n    \"Truchet Waves\"        (3tScDc)\n    \"Edible Edifices\"      (3ljBWt)\n    \"Gold Edifices\"        (NldSzM)\n    \"Losing Focus 2\"       (sdSBzc)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_GRID_SIZE   0  // (= 0/1)\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p, float h);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Noisev2v4 (vec4 p);\n\nvec3 qHit, ltDir;\nvec2 cId, cMid;\nfloat dstFar, tCur, hgSize, wavHt, whFac;\nint nFrame, idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - vec3 (cMid, wavHt).xzy;\n  d = SmoothMax (HexEdgeDist (q.xz, hgSize - 0.005), q.y, 0.1);\n  DMINQ (1);\n  return dMin;\n}\n\nfloat WaveHt (vec2 p, float tWav)\n{ // (from \"Barque Fleet\")\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = tWav * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return h;\n}\n\nvoid SetConf ()\n{\n  cMid = HexToPix (cId * hgSize);\n  wavHt = whFac * WaveHt (0.01 * cMid, 0.1 * tCur);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{ // (mod from \"Cookie Waves\")\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  dHit = 0.;\n  cId = PixToHex (ro.xz / hgSize);\n  pM = HexToPix (cId);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 400; j ++) {\n    if (j == 0 || cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SetConf ();\n      cNu = false;\n    }\n    d = ObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cId = PixToHex ((ro.xz + dHit * rd.xz) / hgSize);\n      pM += sqrt3 * edN[(s == hv.x) ? 0 : ((s == hv.y) ? 1 : 2)];\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cId = PixToHex (p.xz / hgSize);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += 0.05;\n    if (sh < 0.05 || d > 5.) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, sh, h, nDotL;\n  whFac = 16.;\n  dstObj = ObjRay (ro, rd);\n  bgCol = vec3 (0.4, 0.4, 0.6);\n  col = bgCol;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    h = clamp (wavHt / (2.4 * whFac), 0., 1.);\n    col4 = vec4 (HsvToRgb (vec3 (fract (0.7 * (0.9 - h)), 0.7, 1.)), 0.1);\n    col4 *= 1. - 0.1 * ((qHit.y < -0.01) ? smoothstep (0.5, 0.6, sin (4. * pi * qHit.y)) :\n       smoothstep (0.5, 0.6, sin (12. * pi * HexEdgeDist (qHit.xz/ hgSize, 1.))));\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.3 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * sh * pow (nDotL, 1.5)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.8, 1., dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, sMax;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n#if VAR_GRID_SIZE\n  sMax = 4.;\n  hgSize = exp2 (sMax - 0.5 - abs (floor (mod (0.3 * tCur, 2. * sMax)) - sMax + 0.5));\n#else\n  hgSize = 1.;\n#endif\n  az = 0.1 * pi;\n  el = -0.12 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (2. * cos (0.1 * tCur), 60., tCur);\n  zmFac = 3.;\n  dstFar = 300.;\n  ltDir = normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat HexEdgeDist (vec2 p, float h)\n{\n  p = abs (p);\n  p -= vec2 (0.5, - sqrt3/2.) * min (p.x - sqrt3 * p.y, 0.);\n  p.x -= h * sqrt3/2.;\n  return sign (p.x) * max (abs (p.x), abs (p.y) - 0.5 * h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlKGRV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1032, 1032, 1054, 1054, 1226], [1228, 1228, 1263, 1288, 1764], [1766, 1766, 1783, 1783, 1871], [1873, 1873, 1906, 1935, 3098], [3100, 3100, 3121, 3121, 3376], [3378, 3378, 3415, 3415, 3814], [3816, 3816, 3851, 3851, 4767], [4769, 4769, 4825, 4825, 6019], [6021, 6021, 6045, 6045, 6275], [6277, 6277, 6301, 6301, 6357], [6359, 6359, 6396, 6396, 6557], [6559, 6559, 6581, 6581, 6619], [6621, 6621, 6666, 6666, 6758], [6760, 6760, 6805, 6805, 6843], [6845, 6845, 6869, 6869, 6986], [6988, 6988, 7024, 7024, 7230], [7232, 7232, 7262, 7262, 7375], [7409, 7409, 7433, 7433, 7496], [7498, 7498, 7523, 7523, 7860]]}
{"id": "DlKGRK", "name": "Fork swirl rand flylo 051", "author": "flylo", "description": "trig stuff", "tags": ["2d"], "likes": 0, "viewed": 125, "published": 3, "date": "1684301393", "time_retrieved": "2024-07-30T17:55:25.547385", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r2;\n\n    uv += .2*vec2(sin(.3*iTime));\n    r2 = length(uv)*length(uv);\n    for(int i = 0; i< 7; i++) {\n        uv = vec2(tan(uv.x), tan(uv.y));\n\n        r2 = length(uv)*length(uv);\n        uv = vec2(1./r2*uv.y, 1./r2*uv.x);\n\n        //uv = vec2(uv.x*sin(r2)-uv.y*cos(r2), uv.x*cos(r2)+uv.y*sin(r2));\n        //uv = vec2(cos(uv.x-uv.y), sin(uv.x-uv.y));\n        //uv = vec2(tan(uv.x), tan(uv.y));\n   \n    }\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(0,2,4));\n\n    vec3 col = vec3(uv.x, uv.y, uv.y-uv.x);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 761]]}
{"id": "DtKGRV", "name": "Gradient Difference Noise", "author": "ttg", "description": "An implementation of idea/discovery by BUS ERROR.", "tags": ["noise", "gradient"], "likes": 4, "viewed": 244, "published": 3, "date": "1684299719", "time_retrieved": "2024-07-30T17:55:26.408084", "image_code": "void mainImage( out vec4 O, vec2 f ) {\n  vec3 v=texelFetch(iChannel0,ivec2(f),0).rgb;\n  O.rgb=min(12.9*v,abs(1.054*pow(v,v-v+.4166)-.095)+.04);// https://www.shadertoy.com/view/sl3cRs\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nuint triple32(uint x)// https://www.shadertoy.com/view/WttXWX\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvoid mainImage( out vec4 v, in vec2 f ) {\n  vec2 R=iResolution.xy;\n  vec2 u=f/R;\n  // u=.5+(-.5+u)*exp(-.1*iTimeDelta);\n  v=texture(iChannel0,u);\n  uvec4 s;\n  for(int i=0;i<4;i++)s[i]=triple32(uint(iFrame*4+i));\n  vec4 p=vec4(s)/vec4(~0u);\n  p.zw-=p.xy;\n  float g=clamp(dot(u-p.xy,p.zw)/dot(p.zw,p.zw),0.,1.);\n  // A modification idea to not flash the image so much\n  // g=clamp(1.-4.*abs(g-.5),0.,1.);\n  if(iFrame<98)\n    v=abs(g-v);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 185]]}
{"id": "ctVGzK", "name": "adding lines in buffers", "author": "mkundera", "description": "testing buffers. to be ported on Satellite", "tags": ["buffers"], "likes": 4, "viewed": 145, "published": 3, "date": "1684297985", "time_retrieved": "2024-07-30T17:55:27.244847", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y ; \n    \n    vec2 uv = fragCoord/iResolution.xy*vec2(aspect,1.0);\n    \n    vec4 textureColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    textureColor *= 0.96;\n    \n    vec2 circ_center = 0.5*vec2(aspect*(1.0+cos(2.0*iTime)),(1.0 + sin(2.0*iTime)));\n    \n    vec2 circ_center_2 = 0.5*vec2(aspect*(1.0 + cos(3.7*iTime)),(1.0 + sin(2.5*iTime)));\n    \n    float circ = step(0.06, distance(uv, circ_center)) - step(0.03, distance(uv, circ_center));\n    \n    float circ2 = step(0.06, distance(uv, circ_center_2)) - step(0.03, distance(uv, circ_center_2));\n    vec4 circ_color = vec4(1.0);\n    textureColor = mix(textureColor, circ_color, -circ);\n    textureColor = mix(textureColor, circ_color, -circ2);\n    \n    \n    \n    // line sdf (from https://www.shadertoy.com/view/3s2fDG)\n    vec2 line_direction = circ_center - circ_center_2;\n    vec2 point_on_line = circ_center_2;\n    float segment_length = length(line_direction);\n    \n    float projected_distance = dot(normalize(line_direction), uv - point_on_line);\n    vec2 closest_point = point_on_line + projected_distance * line_direction / segment_length;\n\n    float distance_from_line =  length(closest_point - uv);\n    float distance_from_start = - projected_distance;\n    float distance_from_end =  -segment_length + projected_distance;\n    \n    float distance_from_capsule = max(distance_from_line, distance_from_start);\n    distance_from_capsule = max(distance_from_capsule, distance_from_end);\n  \n    \n    float brush_size = 0.02;\n\n    vec3 brush_color = vec3(segment_length*0.3,0.5,0.1 + segment_length*0.5);\n    vec4 brush_c = vec4(brush_color, 1.0);\n  \n    float brush = 1.0 - min(distance_from_capsule, brush_size) / brush_size;\n    brush *= 2.0;\n    brush = clamp(brush, 0.0, 1.0);\n    \n    textureColor = mix(textureColor, brush_c, brush);\n    \n    fragColor = textureColor;\n    \n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]]}
{"id": "dtV3RG", "name": "Psychedelic raybox", "author": "NikolaErceg", "description": "Experimental, tryng to make something psychedelic", "tags": ["raymarching", "rotating", "mandlebox"], "likes": 3, "viewed": 134, "published": 3, "date": "1684280216", "time_retrieved": "2024-07-30T17:55:28.070639", "image_code": "vec4 lastFragColor;\nfloat zoom = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 ray_origin = vec3(0.0, 0.0, -2.0);\n    vec3 ray_dir = normalize(vec3(p.xy, 1.0));\n    \n    const int MAX_STEPS = 256;\n    const float MAX_DIST = 25.0;\n    float distance = 0.0;\n    vec3 pos = ray_origin;\n    \n    float t = iTime * 0.5;\n    mat3 rotationX = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(t), -sin(t)),\n        vec3(0.0, sin(t), cos(t))\n    );\n    \n    mat3 rotationY = mat3(\n        vec3(cos(t), 0.0, sin(t)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(t), 0.0, cos(t))\n    );\n    \n    mat3 rotationZ = mat3(\n        vec3(cos(t), -sin(t), 0.0),\n        vec3(sin(t), cos(t), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    \n    // Automatic zoom in and out\n    float bpm = 60.0; // Beats per minute\n    float beatTime = mod(iTime, 60.0 / bpm);\n    float scale = mix(1.2, 1.34, abs(beatTime - 0.5) * 2.0);\n    zoom *= scale;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        distance = length(pos);\n        if(distance > MAX_DIST) break;\n        \n        // Mandlebox formula\n        vec3 z = abs(pos * zoom);\n        z = (z * z * z) - 0.1;\n        distance = length(z);\n        \n        pos += ray_dir * distance * 0.5;\n        pos = rotationX * rotationY * rotationZ * pos;\n    }\n    \n    vec3 color = vec3(0.5) + 0.5 * sin(3.0 * (pos.xzy + vec3(0.0, 2.0, 4.0) + iTime));\n    fragColor = vec4(color, 1.0);\n    \n    // Add feedback effect\n    fragColor = mix(lastFragColor, fragColor, 0.88);\n    lastFragColor = fragColor;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtV3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 94, 94, 1616]]}
{"id": "dtGGzK", "name": "biome generator", "author": "ArmandB", "description": "2d terrain map with rivers\nclick + drag to move view", "tags": ["procedural", "2d"], "likes": 5, "viewed": 257, "published": 3, "date": "1684278425", "time_retrieved": "2024-07-30T17:55:28.872495", "image_code": "struct Biome {\n    float biomeSize;\n    vec3 biomeColor;\n};\n\nstruct BiomeType {\n    float heightMin;\n    float heightMax;\n    Biome[3] biomes;\n};\n\n//biomes\nconst Biome forest = Biome(1.0,vec3(0,0.5,0));\nconst Biome desert = Biome(0.5,vec3(1.0,0.9,0.5));\nconst Biome grassy_plain = Biome(1.0,vec3(0.2,1.0,0.1));\nconst Biome frozen_peak = Biome(1.0,vec3(1));\nconst Biome stone_peak = Biome(1.0,vec3(0.6));\nconst Biome mesa_peak = Biome(1.0,vec3(0.8,0.6,0.2));\nconst Biome normal_river = Biome(1.0,vec3(0,0,1));\nconst Biome sandy_beach = Biome(1.0,vec3(1.0,0.9,0.5));\nconst Biome stone_beach = Biome(0.5,vec3(0.4));\nconst Biome black_sand_beach = Biome(0.5,vec3(0.1));\nconst Biome normal_ocean = Biome(1.0,vec3(0.0,0.4,1));\nconst Biome bog = Biome(1.0,vec3(0.1,0.6,0.1));\nconst Biome mangrove = Biome(1.0,vec3(0.1,0.7,0.2));\nconst Biome delta = Biome(1.0,vec3(0.4,1.0,0.4));\nconst Biome high_taiga = Biome(1.0,vec3(0.2,0.5,0.3));\nconst Biome meadow = Biome(1.0,vec3(0.3,1.0,0.6));\nconst Biome rock_clearing = Biome(1.0,vec3(0.6,0.7,0.6));\n\n//biome types\nconst BiomeType river = BiomeType(-0.05,0.0,Biome[](normal_river,normal_river,normal_river));\nconst BiomeType mountain = BiomeType(0.7,5.0,Biome[](frozen_peak,stone_peak,mesa_peak));\nconst BiomeType plain = BiomeType(0.1,0.35,Biome[](forest,desert,grassy_plain));\nconst BiomeType taiga = BiomeType(0.35,0.7,Biome[](high_taiga,meadow,rock_clearing));\nconst BiomeType ocean = BiomeType(-2.0,-0.05,Biome[](normal_ocean,normal_ocean,normal_ocean));\nconst BiomeType swamp = BiomeType(0.01,0.1,Biome[](bog,mangrove,delta));\nconst BiomeType beach = BiomeType(0.0,0.01,Biome[](sandy_beach,stone_beach,black_sand_beach));\n\nconst BiomeType biomeTypes[] = BiomeType[](river,mountain,plain,swamp,taiga,ocean,beach);\n\n//noise functions\n\n//https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract((2.0*abs(p/3.14 - 2.0*floor(p/(2.0*3.14)) - 1.0) - 1.0)*43758.5453123);\n}\n\n//https://www.shadertoy.com/view/Msf3WH\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) )/2.0+0.5;\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat voronoi2dedges(vec2 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            float d = distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv);\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n            } else if (d < d2){\n                d2 = d;\n            }\n        }\n    }\n    return abs(d1-d2);\n}\n\nvec2 vorronoiCellNoise(vec2 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    float c1 = 0.0;\n    float c2 = 0.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            vec2 r = (hash(floor(uv) + vec2(x,y)) + 1.0)/2.0;\n            float d = distance(floor(uv) + vec2(x,y) + r,uv);\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n                c2 = c1;\n                c1 = r.x;\n            } else if (d < d2){\n                d2 = d;\n                c2 = r.x;\n            }\n        }\n    }\n    return vec2(c1,c2);\n}\n\n//////////////////////////\n// main\n//////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*20.0;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    uv -= draggedPos/iResolution.y*20.0;\n    \n    //calculate noises\n    float rivernoise = abs(noise(0.5 * uv + 3167.0)*0.5 + noise(0.05*uv - 1279.0)*2.0 - 1.25);\n    float mountainnoise = pow(noise(uv*0.1 + 3812.0),6.0)*4.0 + noise(uv*0.5 + rivernoise*0.5 + 7843.0)*0.5;\n    float oceannoise = noise(0.05*uv - 1279.0);\n    //generate heightmap\n    float heightmap = mix(rivernoise-0.05 - smoothstep(0.5,1.0,oceannoise), mountainnoise - smoothstep(0.2,1.0,oceannoise), rivernoise);\n    vec3 col = vec3(0);\n    //get biometype\n    for (int i = 0; i < biomeTypes.length(); i++){\n        if (biomeTypes[i].heightMin <= heightmap && heightmap < biomeTypes[i].heightMax){\n            //choose biome\n            float dist = min(abs(biomeTypes[i].heightMin - heightmap),abs(biomeTypes[i].heightMax - heightmap));\n            vec2 cell = vorronoiCellNoise(uv+dist+noise(uv));\n            //set color based on biome\n            col = biomeTypes[i].biomes[int(cell.x*3.0)].biomeColor;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1775, 1815, 1872, 1872, 2036], [2038, 2078, 2104, 2104, 2591], [2593, 2612, 2633, 2633, 2767], [2769, 2769, 2799, 2799, 3191], [3193, 3193, 3225, 3225, 3769], [3834, 3834, 3891, 3891, 5029]]}
{"id": "mtG3RK", "name": "Dancing Sun surface", "author": "firebreathz", "description": "A tribute to the Burning Man festival. Soundtrack by Paul Oakenfold, Southern Sun.<br/>Based on Sun Surface shader: https://www.shadertoy.com/view/XlSSzK#<br/>Added music signal based surface texture, based on frequency sampling as seen in Cubescape", "tags": ["burningman"], "likes": 4, "viewed": 299, "published": 3, "date": "1684272895", "time_retrieved": "2024-07-30T17:55:29.698287", "image_code": "// Fork of \"Dancing Sun\" by quad_damage. https://shadertoy.com/view/XdcSRN\n// 2023-05-16 21:33:59\n\n// Based on Sun Surface: https://www.shadertoy.com/view/XlSSzK#\n// Based on Shanes' Fiery Spikeball https://www.shadertoy.com/view/4lBXzy (I think that his implementation is more understandable than the original :) ) \n// Relief come from Siggraph workshop by Beautypi/2015 https://www.shadertoy.com/view/MtsSRf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Audio based texture as seen in Cubescape: https://www.shadertoy.com/view/Msl3Rr\n// Minor customisations by Quad Damage on 13/03/2016\n// Dancing Sun tribute to Burning Man 2015\n// Music by Paul Oakenfold - Souther Sun: https://soundcloud.com/pauloakenfold/02-paul-oakenfold-southern-sun\n\n//#define ULTRAVIOLET\n//#define DITHERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n//\nfloat freqs[4];\n\nfloat hash( float n ) { return fract(sin(n)*13.5453123); }\n\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = texture( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n// FBM\nfloat fpn(vec3 p) {\n    return pn(p*.0125)*3. + pn(p*0.125)*0.8 + pn(p*80.25)*.31;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*20.123,vec2(2.9898,78.233))) * 8.5453);\n}\n\nfloat cosNoise( in vec2 p )\n{\n    return -200.1*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x*1.4,p.y) )-t.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 3.5 + 1.5*(b-a)/k, -0.001, 0.85 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat SunSurface( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.005;\n    \n    float s = 0.05;\n    \n    float d2 = 40.90;\n    vec3 ipos = floor( pos );\n    float id = hash( ipos.x*5000.0 + ipos.y*9005.0 + ipos.z*900.0);\n    \n    for( int i=0; i<40; i++ )\n    {\n        h += s*cosNoise( q );      \n        q = m2*q*0.005; \n        q += vec2(.41,8.13);\n        s *= 0.05 + 0.02*h;\n    }\n    \th += 0.4*(freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 ));\n \t\th += 0.4*(freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 ));\n        h += 0.4*(freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 ));\n        h += 0.4*(freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 ));\n    h *= 3.0;\n    \n    float d1 = pos.y - h;\n   \n    // rings\n    vec3 r1 = mod(2.3+pos+1.0,10.0)-5.0;\n    r1.y = pos.y-0.1 - 0.7*h + 0.5*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    float c = cos(pos.x); float s1 = 1.0;//sin(pos.x);\n    r1.xz=c*r1.xz+s1*vec2(r1.z, -r1.x);\n    d2 = sdTorus( r1.xzy, vec2(clamp(abs(pos.x/pos.z),0.7,5.0), 0.50) );\n\n    \n    return smin( d1, d2, 1.0 );\n}\n\nfloat map(vec3 p) {\n   p.z += 1.;\n   R(p.yz, -25.5);// -1.0+iMouse.y*0.003);\n   R(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n   return SunSurface(p) +  fpn(p*10.+iTime*25.) * 0.45;\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    freqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n   // p: position on the ray\n   // rd: direction of the ray\n   vec3 rd = normalize(vec3((gl_FragCoord.xy-0.3*iResolution.xy)/iResolution.y, 0.5));\n   vec3 ro = vec3(0., 0., -22.);\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=1.2, td=.3, w=0.2;\n\n   // t: length of the ray\n   // d: distance function\n   float d=10., t=10.;\n   \n   // Distance threshold.\n   const float h = .02;\n    \n   // total color\n   vec3 tc = vec3(0.);\n   \n   #ifdef DITHERING\n   vec2 pos = ( fragCoord.xy / iResolution.xy );\n   vec2 seed = pos + fract(iTime);\n   //t=(1.+0.2*rand(seed));\n   #endif\n    \n   // rm loop\n   for (int i=0; i<5000; i++) {\n\n      // Loop break conditions. Seems to work, but let me\n      // know if I've overlooked something.\n      if(td>(1.-10./2000.) || d<0.015*t || t>90.)break;\n       \n      // evaluate distance function\n      d = map(ro+t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      //const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (2.5 - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./60.;  // Different weight distribution.\n      td += w + 1./200.;\n\n\t  // dithering implementation come from Eiffies' https://www.shadertoy.com/view/MsBGRh\n      #ifdef DITHERING  \n      #ifdef ULTRAVIOLET\n      // enforce minimum stepsize\n      d = max(d, 2.4);\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(1.+10.28*rand(seed*vec2(i)));\n      #else\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(1.4+1.1*rand(seed*vec2(i)));\n      // enforce minimum stepsize\n      d = max(d, 0.4);\n      #endif \n      #else\n      // enforce minimum stepsize\n      d = max(d, 0.4);        \n      #endif\n\n       \n      // step forward\n      t += d*0.5;\n      \n   }\n\n   // Fire palette.\n   tc = firePalette(tc.x);\n    tc *= 1. /  1.1;\n   #ifdef ULTRAVIOLET\n   tc *= 1. / exp( ld * 2.82 ) * 1.05;\n   #endif\n    \n   fragColor = vec4(tc, 1.0);\n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtG3RK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[905, 905, 928, 928, 963], [965, 979, 1002, 1002, 1215], [1217, 1224, 1243, 1243, 1308], [1310, 1310, 1330, 1401, 1468], [1470, 1470, 1499, 1499, 1544], [1610, 1610, 1643, 1643, 1700], [1702, 1702, 1743, 1743, 1836], [1838, 1838, 1871, 1871, 2897], [2899, 2899, 2918, 2918, 3074], [3076, 3146, 3172, 3172, 3496], [3499, 3499, 3556, 3556, 5811]]}
{"id": "dtyGRK", "name": "Searching", "author": "Slals", "description": "Was looking for something else, but looks cool nonetheless", "tags": ["light", "pattern", "fract"], "likes": 1, "viewed": 121, "published": 3, "date": "1684270270", "time_retrieved": "2024-07-30T17:55:30.457257", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    vec2 M = vec2(cos(iTime * 0.5), sin(iTime)) * 0.4;\n    \n    float c = length((uv - M) * 2.0);\n    \n    float n = 6.0;\n    uv *= n;\n    vec2 pid = floor(uv);\n    uv = fract(uv);\n    \n    col += vec3(0.8, 0.3, 0.1) - c * pow(uv.x, uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtyGRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 446]]}
{"id": "clG3Ww", "name": "Smileytutorial12312", "author": "defomans", "description": "Smileytutorial", "tags": ["smileytutorial"], "likes": 1, "viewed": 140, "published": 3, "date": "1684268055", "time_retrieved": "2024-07-30T17:55:31.208250", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0.0, 1.0)\n\nfloat remap01(float a, float b, float t)\n{\n    return sat((t-a) / (b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t)\n{\n    return remap01(a, b, t) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect)\n{\n    return (uv - rect.xy) / (rect.zw - rect.xy);\n}\n\nvec4 Brow(vec2 uv)\n{\n    float y = uv.y;\n    uv.y += uv.x*0.8-0.3;\n    uv.x -= 0.1;\n    uv -= 0.5;\n    \n    vec4 col = vec4(0.0);\n    \n    float blur = 0.1;\n    \n    float d1 = length(uv);\n    float s1 = S(0.45, 0.45-blur, d1);\n    float d2 = length(uv-vec2(0.1, -0.2)*0.7);\n    float s2 = S(0.5, 0.5-blur, d2);\n    \n    float browMask = sat(s1-s2);\n    \n    float colMask = remap01(0.7, 0.8, y)*0.75;\n    colMask *= S(0.6, 0.9, browMask);\n    vec4 browCol = mix(vec4(0.4, 0.2, 0.2, 1.0), vec4(1., .75, .5, 1.), colMask);\n    \n    col = mix(col, vec4(0.0, 0.0, 0.0, 1.0), S(0.0, 1.0, browMask));\n    \n    col = mix(col, browCol, S(0.2, 0.4, browMask));\n    \n    return col;\n}\n\nvec4 Eye(vec2 uv)\n{\n    uv -= 0.5;\n    float dist = length(uv);\n    vec4 irisCol = vec4(0.3, 0.5, 1.0, 1.0);\n    vec4 color = mix(vec4(1.0), irisCol, S(0.1, 0.7, dist)*0.5);\n    \n    color.rgb *= 1.0 - S(0.45, 0.5, dist)*0.5*sat(-uv.y-uv.x);\n    color.rgb = mix(color.rgb, vec3(0.0), S(0.3, 0.28, dist)); // iris outline black\n    irisCol.rgb *= 1.0 + S(0.3, 0.05, dist);\n    \n    color.rgb = mix(color.rgb, irisCol.rgb, S(0.28, 0.25, dist));\n    color.rgb = mix(color.rgb, vec3(0.0), S(0.16, 0.14, dist));\n    \n    float highlight = S(0.1, 0.08, length(uv - vec2(-0.15, 0.15)));\n    highlight += S(0.07, 0.05, length(uv + vec2(-0.08, 0.08)));\n    color.rgb = mix(color.rgb, vec3(1.0), highlight);\n    \n    color.a = S(0.5, 0.48, dist);\n    \n    return color;\n}\n\nvec4 Mouth(vec2 uv)\n{\n    uv -= 0.5;\n    vec4 color = vec4(0.5, 0.18, 0.05, 1.0);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x * uv.x * 2.0;\n        \n    float dist = length(uv);\n    \n    color.a = S(0.5, 0.48, dist);\n    \n    float td = length(uv - vec2(0.0, 0.6));\n    \n    vec3 toothCol = vec3(1.0) * S(0.6, 0.35, dist);\n    color.rgb = mix(color.rgb, toothCol, S(0.4, 0.37, td));\n    \n    td = length(uv+vec2(0.0, 0.5));\n    color.rgb = mix(color.rgb, vec3(1.0, 0.5, 0.5), S(0.5, 0.2, td));\n    \n    return color;\n}\n\nvec4 Head(vec2 uv)\n{\n    vec4 color = vec4(0.9, 0.65, 0.1, 1.0);\n    \n    float dist = length(uv);\n    \n    color.a = S(0.5, 0.49, dist);\n    \n    float edgeShade = remap01(0.35, 0.5, dist);\n    edgeShade *= edgeShade;\n    \n    color.rgb *= 1.0 - edgeShade*0.5;\n    \n    color.rgb = mix(color.rgb, vec3(0.6, 0.3, 0.1), S(0.47, 0.48, dist));\n    \n    float highlight = S(0.41, 0.405, dist);\n    \n    highlight *= remap(0.41, -0.1, 0.75, 0.0, uv.y);\n    highlight *= S(0.18, 0.19, length(uv-vec2(0.21, 0.09)));\n    color.rgb = mix(color.rgb, vec3(1.0), highlight);\n    \n    dist = length(uv - vec2(0.25, -0.2));\n    float cheek = S(0.2, 0.01, dist)*0.4;\n    cheek *= S(0.17, 0.16, dist);\n    color.rgb = mix(color.rgb, vec3(1.0, 0.1, 0.1), cheek);\n    \n    return color;\n}\n\nvec4 Smiley(vec2 uv)\n{\n    vec4 color = vec4(0.0);\n    \n    uv.x = abs(uv.x);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(within(uv, vec4(0.03, -0.1, 0.37, 0.25)));\n    vec4 mouth = Mouth(within(uv, vec4(-0.3, -0.4, 0.3, -0.1)));\n    vec4 brow = Brow(within(uv, vec4(0.03, 0.2, 0.4, 0.43)));\n    \n    color = mix(color, head, head.a);\n    color = mix(color, eye, eye.a);\n    color = mix(color, mouth, mouth.a);\n    color = mix(color, brow, brow.a);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Output to screen\n    fragColor = Smiley(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clG3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 116, 116, 149], [151, 151, 209, 209, 252], [254, 254, 287, 287, 338], [340, 340, 360, 360, 1015], [1017, 1017, 1036, 1036, 1778], [1780, 1780, 1801, 1801, 2293], [2295, 2295, 2315, 2315, 3065], [3067, 3067, 3089, 3089, 3541], [3543, 3543, 3600, 3650, 3804]]}
{"id": "7lXGRM", "name": "Fork Dancing Su firebreath 513", "author": "firebreathz", "description": "A tribute to the Burning Man festival. Soundtrack by Paul Oakenfold, Southern Sun.<br/>Based on Sun Surface shader: https://www.shadertoy.com/view/XlSSzK#<br/>Added music signal based surface texture, based on frequency sampling as seen in Cubescape", "tags": ["burningman"], "likes": 4, "viewed": 304, "published": 3, "date": "1684263841", "time_retrieved": "2024-07-30T17:55:31.969215", "image_code": "// Based on Sun Surface: https://www.shadertoy.com/view/XlSSzK#\n// Based on Shanes' Fiery Spikeball https://www.shadertoy.com/view/4lBXzy (I think that his implementation is more understandable than the original :) ) \n// Relief come from Siggraph workshop by Beautypi/2015 https://www.shadertoy.com/view/MtsSRf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Audio based texture as seen in Cubescape: https://www.shadertoy.com/view/Msl3Rr\n// Minor customisations by Quad Damage on 13/03/2016\n// Dancing Sun tribute to Burning Man 2015-\n// Music by Paul Oakenfold - Souther Sun: https://soundcloud.com/pauloakenfold/02-paul-oakenfold-southern-sun\n\n//#define ULTRAVIOLET\n//#define DITHERING\n\n#define pi 30.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n//\nfloat freqs[4];\n\nfloat hash( float n ) { return fract(sin(n)*13.5453123); }\n\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = texture( iChannel0, (uv+ 0.5)/256.0, -100.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n// FBM\nfloat fpn(vec3 p) {\n    return pn(p*.06125)*.57 + pn(p*.125)*.28 + pn(p*.25)*.15;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat cosNoise( in vec2 p )\n{\n    return 0.3*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x*1.2,p.y) )-t.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 1.0 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat SunSurface( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.5;\n    \n    float s = 0.5;\n    \n    float d2 = 0.0;\n    vec3 ipos = floor( pos );\n    float id = hash( ipos.x*1.0 + ipos.y*10.0 + ipos.z*20.0);\n    \n    for( int i=0; i<4; i++ )\n    {\n        h += s*cosNoise( q );      \n        q = m2*q*1.05; \n        q += vec2(2.41,8.13);\n        s *= 0.48 + 0.5*h;\n    }\n    \th += 0.4*(freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 ));\n \t\th += 0.4*(freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 ));\n        h += 0.4*(freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 ));\n        h += 0.4*(freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 ));\n    h *= 3.0;\n    \n    float d1 = pos.y - h;\n   \n    // rings\n    vec3 r1 = mod(2.3+pos+1.0,10.0)-5.0;\n    r1.y = pos.y-0.1 - 0.7*h + 0.5*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    float c = cos(pos.x); float s1 = 1.0;//sin(pos.x);\n    r1.xz=c*r1.xz+s1*vec2(r1.z, -r1.x);\n    d2 = sdTorus( r1.xzy, vec2(clamp(abs(pos.x/pos.z),0.7,5.0), 0.50) );\n\n    \n    return smin( d1, d2, 1.0 );\n}\n\nfloat map(vec3 p) {\n   p.z += 1.;\n   R(p.yz, -25.5);// -1.0+iMouse.y*0.003);\n   R(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n   return SunSurface(p) +  fpn(p*10.+iTime*25.) * 0.45;\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    freqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n   // p: position on the ray\n   // rd: direction of the ray\n   vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n   vec3 ro = vec3(0., 0., -22.);\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0.2, td=0.2, w=0.2;\n\n   // t: length of the ray\n   // d: distance function\n   float d=1., t=1.;\n   \n   // Distance threshold.\n   const float h = .2;\n    \n   // total color\n   vec3 tc = vec3(0.);\n   \n   #ifdef DITHERING\n   vec2 pos = ( fragCoord.xy / iResolution.xy );\n   vec2 seed = pos + fract(iTime);\n   //t=(1.+0.2*rand(seed));\n   #endif\n    \n   // rm loop\n   for (int i=0; i<56; i++) {\n\n      // Loop break conditions. Seems to work, but let me\n      // know if I've overlooked something.\n      if(td>(1.-1./200.) || d<0.001*t || t>40.)break;\n       \n      // evaluate distance function\n      d = map(ro+t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      //const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./60.;  // Different weight distribution.\n      td += w + 1./200.;\n\n\t  // dithering implementation come from Eiffies' https://www.shadertoy.com/view/MsBGRh\n      #ifdef DITHERING  \n      #ifdef ULTRAVIOLET\n      // enforce minimum stepsize\n      d = max(d, 0.04);\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(1.+0.28*rand(seed*vec2(i)));\n      #else\n      // add in noise to reduce banding and create fuzz\n      d=abs(d)*(.8+0.28*rand(seed*vec2(i)));\n      // enforce minimum stepsize\n      d = max(d, 0.04);\n      #endif \n      #else\n      // enforce minimum stepsize\n      d = max(d, 0.04);        \n      #endif\n\n       \n      // step forward\n      t += d*0.5;\n      \n   }\n\n   // Fire palette.\n   tc = firePalette(tc.x);\n    tc *= 1. /  1.1;\n   #ifdef ULTRAVIOLET\n   tc *= 1. / exp( ld * 2.82 ) * 1.05;\n   #endif\n    \n   fragColor = vec4(tc, 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXGRM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[808, 808, 831, 831, 866], [868, 882, 905, 905, 1118], [1120, 1127, 1146, 1146, 1210], [1212, 1212, 1232, 1303, 1374], [1376, 1376, 1405, 1405, 1447], [1513, 1513, 1546, 1546, 1603], [1605, 1605, 1646, 1646, 1735], [1737, 1737, 1770, 1770, 2783], [2785, 2785, 2804, 2804, 2960], [2962, 3032, 3058, 3058, 3382], [3385, 3385, 3442, 3442, 5691]]}
{"id": "ctcGRf", "name": "Log Spherical KIFS \"Zoomer\"", "author": "derSchamane", "description": "I read Dracusa's article on Log Spherical Mapping and immediately thought of fractals to go with it, such as a kaleidoscopic Menger cube.\nIt's not very fast, but somehow seamless and mesmerizing.\n\nChange the view and \"trajectory\" by dragging the mouse.\n", "tags": ["raymarching", "fractal", "zoom", "menger", "log"], "likes": 35, "viewed": 615, "published": 3, "date": "1684261443", "time_retrieved": "2024-07-30T17:55:32.725194", "image_code": "//              = Log Spherical KIFS \"Zoomer\" =         \n//              by Maximilian Knape   ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA 2.2\n\n#define MAX_STEPS 90\n#define MAX_DIST 100.\n#define MIN_DIST 10.\n\n#define GLOW_INT 1.\n#define PP_ACES 1.0\n#define PP_CONT 0.5\n#define PP_VIGN 1.3\n#define AO_OCC .5\n#define AO_SCA .3\n\n#define PI 3.14159265\n#define TAU 6.28318531\n#define S(x,y,t) smoothstep(x,y,t)\n#define sin3(x) sin(x)*sin(x)*sin(x)\n#define Rot2D(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nvec3 Rot(in vec3 p, in vec3 r) //las\n{\n    Rot2D(p.xz, r.y);\n    Rot2D(p.yx, r.z);\n    Rot2D(p.zy, r.x);\n    return p;\n}\n\nfloat sdKMC( in vec3 p,    //KIFS Menger Style\n             in int iters,\n             in vec3 fTra,\n             in vec3 fRot,\n             in vec4 para )\n{\n    int i;\n    float col = 0.;\n    float x1, y1;\n    float r = p.x*p.x + p.y*p.y + p.z*p.z;\n    \n    for(i = 0; i < iters && r < 1e6; i++)\n    {\n        if (i > 0)\n        {\n            p -= fTra;\n            p = Rot(p, fRot);\n        }\n\n        p = abs(p);\n\n        if (p.x-p.y < 0.) { x1=p.y; p.y=p.x; p.x=x1;}\n        if (p.x-p.z < 0.) { x1=p.z; p.z=p.x; p.x=x1;}\n        if (p.y-p.z < 0.) { y1=p.z; p.z=p.y; p.y=y1;}\n\n        p.z -= .5 * para.x * (para.y - 1.) / para.y;\n        p.z = -abs(p.z);\n        p.z += .5 * para.x * (para.y - 1.) / para.y;\n\n        p.x = para.y * p.x - para.z * (para.y - 1.);\n        p.y = para.y * p.y - para.w * (para.y - 1.);\n        p.z = para.y * p.z;\n\n        r = p.x*p.x + p.y*p.y + p.z*p.z;\n    }\n\n    return length(p) * pow(para.y, float(-i));\n}\n\nvec2 SDF(vec3 p, float depth) \n{    \n    float d = MAX_DIST, col = 0.;\n        \n    p = abs(Rot(p, vec3(10.5 - depth)));\n\n    float sphere = length(p - vec3(1.8 + sin(iTime/3. + depth)*.6, 0, 0)) - .1; \n    col = mix(col, 1.7, step(sphere, d));\n    d = min(sphere, d);\n    \n    float torus = length( vec2(length(p.yz) - 1.2, p.x)) - .01;\n    col = mix(col, 1.3, step(torus, d));\n    d = min(torus, d);\n        \n    float menger = sdKMC(p*2.9, 8, vec3(sin(iTime/53.))*.4, vec3(sin3(iTime/64.)*PI), vec4(2., 3.5, 4.5, 5.5)) / 2.9;\n    col = mix(col, floor(mod(length(p)*1.5, 4.))+.5, step(menger, d)); \n    d = min(menger, d);\n    \n    return vec2(d, col);\n}\n\n\nfloat dens = .9;\nvec2 Map(in vec3 p) //Thanks dracusa, nice aticle <3 \n{\n    vec3 pos = p;\n    \n    //forward log-spherical map\n    float r = length(p);\n    p = vec3(log(r), acos(p.z / r), atan(p.y, p.x));\n\n    float t = iTime/10. + iMouse.x/iResolution.x*3.;\n    p.x -= t;\n    float scale = floor(p.x*dens) + t*dens;\n    p.x = mod(p.x, 1. / dens);\n\n    //inverse log-spherical map\n    float erho = exp(p.x);\n    float sintheta = sin(p.y);\n    p = vec3(\n        erho * sintheta * cos(p.z),\n        erho * sintheta * sin(p.z),\n        erho * cos(p.y)\n    );\n\n    vec2 sdf = SDF(p, scale);\n    sdf.x *= exp(scale/dens);\n\n    return sdf;\n}\n\nvec3 Normal(in vec3 p, in float depth)\n{\n    float h = depth / iResolution.y;\n    vec2 k = vec2(1, -1);\n\n    return normalize(   k.xyy * Map(p + k.xyy * h).x + \n                        k.yyx * Map(p + k.yyx * h).x + \n                        k.yxy * Map(p + k.yxy * h).x + \n                        k.xxx * Map(p + k.xxx * h).x );\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = mix(MIN_DIST, MAX_DIST/2., S(.9, 1., sin(iTime/24.)*.5+.5));\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += min(dS.x, length(p)/12.);\n        \n        if (dO > MAX_DIST || dS.x < dO / iResolution.y) break;\n    }\n    \n    return vec3(steps == 0 ? MIN_DIST : dO, steps, col);\n}\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //IQ\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = .001 + .150 * float(i) / 4.;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return S(0., 1. , 1. - 1.5 * occ);    \n}\n\n\nconst vec3 ambCol = vec3(.03,.05,.1) * 5.5;\nconst vec3 sunCol = vec3(1., .7, .4) * 1.2;\nconst vec3 skyCol = vec3(.3, .5, 1.) * .04;\nconst float specExp = 4.;\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lp) \n{\n\n    vec3    lidi = normalize(lp - p);\n    float   amoc = CalcAO(p, n),\n            diff = max(dot(n, lidi), 0.),\n            spec = pow(diff, max(1., specExp * mat)),\n            refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mat));\n\n    return  col * (amoc * ambCol +                                          //ambient\n                   (1. - mat) * diff * sunCol +                             //diffuse\n                   mat * (spec + refl) * sunCol);                           //specular\n                   \n}\n\nvec3 hsv2rgb_smooth(in vec3 c) //IQ\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb);\n    \n\treturn c.z * mix( vec3(1.), rgb, c.y);\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1., 1., 1.);\n        case 1: return vec3(1., .8, .6);\n        case 2: return vec3(.6, .8, 1.);\n        case 3: return hsv2rgb_smooth(vec3(fract(iTime/21.), .65, .8));\n    }\n    return vec3(0.);\n}\n\nvec3 Ray(in vec2 uv, in vec3 p, in vec3 l)\n{\n\n    vec3   f = normalize(l - p),\n           r = normalize(cross(vec3(0,1,0), f)),\n           u = cross(f,r),\n           c = p + f,\n           i = c + uv.x*r + uv.y*u;\n           \n    return normalize(i - p);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, (col * (2.51 * col + .03)) / (col * (2.43 * col + .59) + .14), PP_ACES);\n    col = mix(col, S(vec3(0), vec3(1), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, vec3(1) / GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= .1) m = vec2(.5);\n\n    vec3 ro = vec3(0, 0, -MAX_DIST/2.);\n    ro.yz = Rot2D(ro.yz, -m.y * PI + PI*.5);\n    ro.xz = Rot2D(ro.xz, -m.x * PI*2. - PI);\n    vec3 rd = Ray(uv, ro, vec3(0));\n    \n    vec3 bg = skyCol;\n    vec3 col = bg;\n    vec3 p = vec3(0);\n    vec3 rmd = RayMarch(ro, rd);\n\n    if (rmd.x <= MIN_DIST) col = Palette(int(floor(rmd.z)))/8.;\n    else if (rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p, rmd.x);\n        \n        float shine = fract(rmd.z);\n        col = Palette(int(floor(abs(rmd.z))));\n        col = Shade(col, shine, p, n, rd, vec3(0));   \n    }\n    \n    float disFac = S(0.0, 1.0, pow(rmd.x / MAX_DIST, 2.));\n    \n    col = mix(col, bg, disFac);\n    col += pow(rmd.y / float(MAX_STEPS), 2.5) * normalize(ambCol) * \n            (GLOW_INT + (rmd.x < MAX_DIST ? 3.*S(.995, 1., sin(iTime/2. - length(p)/20.)) : 0.)); //glow wave\n    \n    fragColor = PP(col, uv);\n}", "image_inputs": [{"id": 33315, "src": "https://soundcloud.com/derschamane/aerosoul", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcGRf.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[675, 675, 713, 713, 795], [797, 797, 954, 954, 1740], [1742, 1742, 1774, 1774, 2398], [2418, 2418, 2473, 2473, 3037], [3039, 3039, 3079, 3079, 3369], [3371, 3371, 3405, 3405, 3850], [4340, 4340, 4408, 4408, 4947], [4949, 4949, 4986, 4986, 5134], [5136, 5136, 5161, 5161, 5410], [5412, 5412, 5456, 5456, 5667], [5669, 5669, 5697, 5697, 5966], [5968, 5968, 6025, 6025, 7069]]}
{"id": "ctG3zK", "name": "Fork [NV15] Imp Loe159 413", "author": "Loe159", "description": "-----------------------------\n> >> I M P A C T  <<<\n-----------------------------\n\nThe story of a planet, and its quest to get close to a new friend!\n\nCode / Help from: \n@lukexi , @thespite , @mrdoob , @iq , @nimitz , @AND", "tags": ["noise", "fbm", "audio", "volumetric", "nv15"], "likes": 1, "viewed": 158, "published": 3, "date": "1684257421", "time_retrieved": "2024-07-30T17:55:33.663685", "image_code": "// Mostly taken from \n// https://iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 6.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.00001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\nconst float loopSpeed   = .1;\nconst float loopTime    = 5.;\nconst float impactTime  = 1.;\nconst float impactFade  = .3;\nconst float fadeOutTime = .01;\nconst float fadeInTime  = .2;\nconst float whiteTime   = .3; // fade to white\n    \n  \n\n\n// Trying to sync by using AND's code from\n// https://www.shadertoy.com/view/4sSSWz\n#define WARMUP_TIME     (2.0)\n\n// Shadertoy's sound is a bit out of sync every time you run it :(\n#define SOUND_OFFSET    (-0.0)\n\n\n\nconst int NUM_PLANETS = 1;\nvec3 planet = vec3( 0. );\n\nconst vec3 sun = vec3( 0. );\n\nfloat impactLU[ 58 ];\n\n\n\nfloat planetNoise( in vec3 x )\n{\n   vec3 p = floor(x);\n   vec3 f = fract(x);\nf = f*f*(3.0-2.0*f);\n\nvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\nvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\nreturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat displacement( vec3 p )\n{\n\tp += vec3(1.0,0.0,0.8);\n\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                   -0.80,  0.36, -0.48,\n                   -0.60, -0.48,  0.64 );\n    //float m = .1412;\n   float f;\n   f  = 0.5000*planetNoise( p ); p = m*p*2.02;\n   f += 0.2500*planetNoise( p ); p = m*p*2.03;\n   f += 0.1250*planetNoise( p ); p = m*p*2.01;\n   f += 0.0625*planetNoise( p ); \n\nfloat n = planetNoise( p*3.5 );\n   f += 0.03*n*n;\n\n   return f;\n}\n\n\n\n//-------\n// Extra Util Functions\n//-------\n\n\nvec3 hsv(float h, float s, float v)\n{\n    \n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\n\n\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time , in float timeInLoop, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n    float r = time;\n    \n    float extraSweep =  pow((clamp( timeInLoop , 1. , 3. ) - 3.), 2.);\n    float x = ( timeInLoop/2. + 2. ) *cos( 1.3 + .4 * timeInLoop - .3 * extraSweep );\n    float z = ( timeInLoop/2. + 2. ) *sin( 1.3 + .4 * timeInLoop - .3 * extraSweep );\n    \n    vec3 offset = vec3( hash( time ) -.5 , hash( time * 2. )-.5 , hash( time * 3.)-.5 );\n   \n\tcamPos = vec3(x,.7,z) +.1 * offset * pow( extraSweep * .4 , 10. );\n    camTar = vec3(timeInLoop / 2.,0.0,0.0);\n}\n\n\n\n//----\n// Distance Functions\n// https://iquilezles.org/articles/distfunctions\n//----\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)- s;//+ .1 * sin( p.x * p.y * p.z * 10. + iTime );//* (1.+ .4 * triNoise3D( p * .1 ,.3 ) + .2* triNoise3D( p * .3 ,.3 )) ;\n}\n\nfloat sdPlanet( vec3 p, float s )\n{\n\n    return length(p)- s + .1 * triNoise3D( p * .5 , .01 )+ .04 * sin( p.x * p.y * p.z * 10. + iTime );;//+ .03 * noise( sin(p) * 10. + p ) + .03 * sin( p.x * p.y * p.z * 10. + iTime )+ .02 * sin( p.x + p.y + p.z * 2. + iTime );//* (1.+ .4 * triNoise3D( p * .1 ,.3 ) + .2* triNoise3D( p * .3 ,.3 )) \n  \n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    vec3 rot = vec3( 0. );//vec3( iTime * .05 + 1., iTime * .02 + 2. , iTime * .03  );\n    // Rotating box\n   \t//vec2 res = vec2( rotatedBox( pos , rot , vec3( 0.7 ) , .1 ) , 1.0 );\n   \t\n    vec2 res = vec2( sdPlanet( pos , .8 ) , 1. );\n    \n   // for( int i = 0; i < NUM_PLANETS; i++){\n    \tvec2 res2 = vec2( sdSphere( pos - planet , .1 ), 2. );\n   \t\tres = opU( res , res2 );\n    //}\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n    \n}\n\n\n\n//------\n// Volumetric funness\n//------\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2 + vec3( iTime * .01 , 0. , 0.), .1 );\n    return f;\n    \n}\n\n\n\n// box rendering for title at end\nfloat inBox( vec2 p , vec2 loc , float boxSize ){\n \t\n    if( \n        p.x < loc.x + boxSize / 2. &&\n        p.x > loc.x - boxSize / 2. &&\n        p.y < loc.y + boxSize / 2. &&\n        p.y > loc.y - boxSize / 2. \n    ){\n        \n     return 1.;  \n        \n    }\n   \n    return 0.;\n     \n}\n\n\nvec2 getTextLookup( float lu ){\n    \n    float posNeg = abs( lu ) / lu;\n    \n    float x = floor( abs( lu ) / 100. );\n    float y = abs( lu ) - (x * 100.);\n    \n    y = floor( y / 10. );\n    y *= ((abs( lu ) - (x * 100.) - (y * 10. )) -.5) * 2.;\n    \n    return vec2( x * posNeg , y  );\n    \n}\n\n\nfloat impact( vec2 p , float stillness ){\n  \n\n    float f = 0.;\n    \n    for( int i = 0; i < 58; i++ ){\n    \t\n        for( int j = 0; j < 3; j++ ){\n            \n            float size = (-5.+( 10. * float( j ))) * stillness + 10.;\n            vec2 lu = getTextLookup( impactLU[ i ] )* size;\n            f += inBox( p , vec2( iResolution / 2. ) + lu , size );       \n            \n        }\n \n    } \n    \n    return f/3.;\n    \n    \n}\n\n#define FOG_STEPS 20\nvec4 overlayFog( vec3 ro , vec3 rd , vec2 screenPos , float hit ){\n \n    float lum = 0.;\n    vec3 col = vec3( 0. );\n    \n    //float nSize = .000002 * hit;\n   \t//float n = (noise(vec3(2.0*screenPos, abs(sin(iTime * 10. ))*.1))*nSize) -.5* nSize;\n    for( int i = 0; i < FOG_STEPS; i++ ){\n        \n        vec3 p = ro * ( 1. )  + rd  * ( MAX_TRACE_DISTANCE / float( FOG_STEPS))  * float( i );\n        \n        vec2 m  = map( p );\n\n        if( m.x < 0.0 ){ return vec4( col , lum ) / float( FOG_STEPS ); }\n        \n        \n        // Fading the fog in, so that we dont get banding\n        float ss = pow( clamp(pow( m.x * 10. , 3.)  , 0. , 5. )/5. , 1. );//m.x;// smoothstep( m.x , 0.2, .5 ) / .5;\n        \n        \n        float planetFog = 0.;\n        planetFog += (10./ (length( p-planet ) * length( planet )));\n\n        //Check to see if we are in the corona\n        if( length( p ) < 1.4 && length( p ) > .8 ){\n           \n            float d = (1.4 - length( p )) / .6;\n            lum += ss * 20. * posToFloat( p * (3. / length( p )) ) * d;//30. / length( p );\n            col += ss * vec3( 1. , .3 , 0.1 ) * 50. *  d* posToFloat( p* (3. / length( p )) );//* lum;\n        \n        }\n        \n        // TODO: MAKE THIS BETTER!!!!\n        //float fleck = noise((1./ pow(length(p), 6.)) * p * 3.);// * noise( length(p) * p * 3.);\n        //if( fleck > .8 ){return vec4( vec3(.2,0.,0.) * col / float( i ) , lum ); }\n   \n        lum += ss * pow( planetFog , 2. ) * .3 * posToFloat( p * .3 * planetFog + vec3( 100. ));//// + sin( p.y * 3. ) + sin( p.z * 5.);\n        col += ss * planetFog * hsv( lum * .7 * (1. / float( FOG_STEPS))+ .5 , 1. , 1. );\n    }\n    \n    return vec4( col , lum ) / float(FOG_STEPS);\n    \n}\n\n\n\n\n\n/*vec3 doLighting( vec3 ro , vec3 rd ){\n    \n    \n    \n}*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // 1000 and 100 are the x positions\n    // 10 is y position\n    // 1 is y sign\n    // I\n    impactLU[0] = -1621.;\n\timpactLU[1] = -1611.;\n\timpactLU[2] = -1600.;\n\timpactLU[3] = -1610.;\n\timpactLU[4] = -1620.;\n    \n    \n    // M\n    impactLU[5] = -1221.;\n\timpactLU[6] = -1211.;\n\timpactLU[7] = -1201.;\n\timpactLU[8] = -1210.;\n\timpactLU[9] = -1220.;\n    \n    impactLU[10] = -1021.;\n\timpactLU[11] = -1011.;\n\timpactLU[12] = -1001.;\n\timpactLU[13] = -1010.;\n\timpactLU[14] = -1020.;\n    \n    impactLU[15] = -821.;\n\timpactLU[16] = -811.;\n\timpactLU[17] = -801.;\n\timpactLU[18] = -810.;\n\timpactLU[19] = -820.;\n    \n    // P\n    impactLU[20] = -421.;\n\timpactLU[21] = -411.;\n\timpactLU[22] = -401.;\n\timpactLU[23] = -410.;\n\timpactLU[24] = -420.;\n\n\timpactLU[25] = -221.;\n\timpactLU[26] = -211.;\n\timpactLU[27] = -201.;\n\n  \n\t// A\n    impactLU[28] = 221.;\n\timpactLU[29] = 211.;\n\timpactLU[30] = 201.;\n\timpactLU[31] = 210.;\n\timpactLU[32] = 220.;\n    \n    impactLU[33] = 321.;\n    \n    impactLU[34] = 421. ;\n\timpactLU[35] = 411. ;\n\timpactLU[36] = 401. ;\n\timpactLU[37] = 410. ;\n\timpactLU[38] = 420. ;\n    \n    \n    // extra hooks for p and m...\n    impactLU[39] = -321.;\n    impactLU[40] = -1121.;\n    impactLU[41] = -921.;\n    \n    \n \t// C\n    \n  \timpactLU[42] = 821.;\n\timpactLU[43] = 811.;\n\timpactLU[44] = 801.;\n\timpactLU[45] = 810.;\n\timpactLU[46] = 820.;\n    \n  \timpactLU[47] = 921. ;\n\timpactLU[48] = 1021.;\n\n  \timpactLU[49] = 920. ;\n\timpactLU[50] = 1020.;\n    \n      \n  \t// T\n    \n  \timpactLU[51] = 1521.;\n\timpactLU[52] = 1511.;\n\timpactLU[53] = 1501.;\n\timpactLU[54] = 1510.;\n\timpactLU[55] = 1520.;\n    \n  \timpactLU[56] = 1421.;\n\timpactLU[57] = 1621.;\n\n\n\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    \n    float time = max(0.0, iTime - WARMUP_TIME);\n\n    float tInput = time;\n    float timeInLoop = loopTime - time * loopSpeed;\n\n  \n    //float r = 5. - mod( tInput , 5. );\n\n\n    float extraSweep =  pow((clamp( timeInLoop , 1. , 3. ) - 3.), 2.);\n    //float extraSweep = 2. - clamp( timeInLoop , 1. , 2. );\n    float r = 4.  - extraSweep * 1. ;\n\n\n    planet.x = r *(cos( .3 + .03 * timeInLoop));\n    planet.z = r *(sin( .3 + .03 * timeInLoop ));\n        \n \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, tInput , timeInLoop , m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    //vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = vec3( 0. ,0.,0. );\n  \n    if( timeInLoop > impactTime ){ \n        \n        vec2 res = calcIntersection( ro, rd );\n\n        if( res.y == 1. || res.y == 2. ){\n\n           vec3 pos = ro + rd * res.x;\n           vec3 nor = calcNormal( pos );\n\n           vec3 lightDir = pos - planet.xyz;\n\n           float lightL = length( lightDir );\n           lightDir = normalize( lightDir );\n\n\n           float match = max(  0. , dot( -nor , lightDir ));\n\n           vec3 refl = reflect( lightDir , nor );\n           float reflMatch = max( 0. , dot( -rd , refl ) );\n           float eyeMatch = 1. - max( 0. , dot( -rd , nor ) );\n            \n\n           //float\n\n           vec3 ambi = vec3( .1 , 0.1 ,0.1 );\n           vec3 lamb = vec3( 1. , .5 , .3 ) * match;\n           vec3 spec = vec3( 1. , .3 , .2 ) * pow(reflMatch,20.);\n           vec3 rim = vec3( 1. , .3 , .1 )  * pow( eyeMatch , 3. );\n           col =  rim + ( ( ambi + lamb + spec) * 3. / lightL); //nor  * .5 + .5;   \n\n        }else{\n         \n            \n          // background\n          float neb = pow(triNoise3D( (sin(rd) - vec3( 156.29)) * 1. , .1) , 3.);\n          col = neb * hsv( neb + .6 , 1. , 2. );\n            \n        }\n        \n        float hit = 0.;\n        if( res.y == 1. || res.y == 2. ){ hit = 1.; }\n        \n        vec4 fog = overlayFog( ro , rd , fragCoord.xy , hit );\n        col += .6 * fog.xyz * fog.w;\n        \n    }\n   \n    \n    // Fading in / fading out\n    float fadeIn = ((loopTime - clamp( timeInLoop , loopTime - fadeInTime , loopTime ))) / fadeInTime;\n    \n    float fadeOut = ((loopTime - clamp( (loopTime- timeInLoop) , loopTime - fadeOutTime , loopTime ))) / fadeOutTime;\n    \n    \n    // Gives us a straight fade to white\n    // to hide some weird noise we were \n    // seeing\n    if( timeInLoop < impactTime + whiteTime ){ col += vec3( 10. * (impactTime + whiteTime - timeInLoop) ); }\n    \n    \n    \n    // TEXT\n    if( timeInLoop < impactTime ){ \n        \n        col = vec3( 1. );\n        \n        float imp = impact( fragCoord.xy , max( 0.2 , timeInLoop - fadeOutTime) -.2 );\n        float textFade = pow( max( 0. , timeInLoop - (impactTime - impactFade) ) / impactFade , 2. );\n\t\tcol = vec3( textFade );  \n        \n         vec3 ro, ta;\n    \tdoCamera( ro, ta, 0.,  0. , m.x );\n\n        // camera matrix\n        mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n        // create view ray\n        vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n                \n        // getting color for text\n        float neb = pow(triNoise3D( (sin(rd) - vec3( 156.29)) * 1. , 1.4) , 2.);\n        col += (1. - textFade ) * imp * 4. * neb * hsv( neb - .1 , 1. , 2. );\n        col += ( 1. - textFade ) * neb * hsv( neb + .8 , 1. , 2. ); \n       // col = vec3( fragCoord.x ,  , 1. );\n        //col = texture( iChannel0 , sin(fragCoord.xy * 10. )).xyz;// vec3( 1. , 1. ,1. ); \n    }\n    \n\tfragColor = min( fadeOut , fadeIn )  * vec4(col,1.0);\n     \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctG3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[858, 858, 890, 890, 1094], [1097, 1097, 1127, 1127, 1557], [1607, 1607, 1644, 1644, 1781], [1786, 1786, 1808, 1808, 1844], [1846, 1846, 1871, 1871, 2207], [2213, 2265, 2287, 2287, 2312], [2313, 2313, 2334, 2334, 2414], [2450, 2502, 2545, 2545, 2848], [2852, 2883, 2947, 2947, 3125], [3127, 3127, 3232, 3232, 3746], [3838, 3838, 3873, 3873, 4016], [4018, 4018, 4053, 4053, 4358], [4360, 4454, 4483, 4483, 4526], [4533, 4617, 4638, 4638, 5058], [5062, 5062, 5110, 5110, 5577], [5579, 5692, 5723, 5723, 5954], [5999, 5999, 6026, 6026, 6120], [6124, 6158, 6207, 6207, 6445], [6448, 6448, 6479, 6479, 6741], [6744, 6744, 6785, 6785, 7175], [7198, 7198, 7264, 7264, 8914], [8981, 8981, 9037, 9134, 14719]]}
{"id": "mtVGRy", "name": "ECKER_O_ reproduction[437 chars]", "author": "kishimisu", "description": "Trying to reproduce https://twitter.com/ecker_o/status/1657078396860473346", "tags": ["2d", "sdf", "code", "shape", "morphing", "short", "golf", "golfing"], "likes": 46, "viewed": 728, "published": 3, "date": "1684236240", "time_retrieved": "2024-07-30T17:55:34.412682", "image_code": "/* Trying to reproduce https://twitter.com/ecker_o/status/1657078396860473346\n   originally made by @ecker_o\n   \n   [reduced from 441 to 423 chars in the comments]\n\n   It only looks nice on a smooth framerate with no frame drop!\n*/\n\nA (vec4(9,9,8,0) - Q * vec4(9,8,7,0)) * .1; }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define A void mainImage(out vec4 O, vec2 u) { O =//\n#define R iResolution.xy//\n#define Q texture(iChannel0, u/R)//\n#define S smoothstep(0., ", "buffer_a_code": "A   Q;                                    // get previous color\n                           \n    float t = iTime,\n          s = 1. - S 5., t),                  // time control    \n          l = 1. - S 5., abs(t+t-5.)),        // time control (yo-yo)\n          r = .5 - l*.3;                   // radius\n    \n    u = (u+u-R)/R.y;                       // coordinates\n    u.x += s*1.6-.8;                       // translation\n    u *= mat2(cos(vec4(0,33,11,0) - l));   // rotation\n    \n    t = atan(u.y, u.x)/.1;                 // angle from origin\n        \n    // accumulate colors\n    O += S -l*.05-.03, \n            abs(\n                mix( // shape morphing\n                    length(u) - r, \n                    length(max(u = abs(u)-r, 0.)) + min(max(u.x,u.y), 0.), \n                    s\n                ) + .05 * sqrt(l) * (sin(t+l+l) + cos(t*2.3+s)) // noise\n            )-.01\n         );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtVGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "mtG3zy", "name": "Fractal mountain terrain 2", "author": "jarble", "description": "Another realistic-looking fractal terrain.", "tags": ["noise", "terrain", "fbm", "landscape", "ice", "snow", "alps", "mountain", "erosion"], "likes": 17, "viewed": 362, "published": 3, "date": "1684193972", "time_retrieved": "2024-07-30T17:55:35.162677", "image_code": "//based on\n//https://www.shadertoy.com/view/3dXcW2\n\n#define SC (250.0)\n\nvec2 triwave(vec2 uv){\n    return\n        abs(fract(uv)-.5)\n        //max(abs(fract(uv)-.5),abs(fract(uv.yx+.5)-.5))\n    ;\n}\n\n#define OCTAVES 8\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.,\n    value1=value,\n    amplitude = 2.;\n    uv /= 32./4.;\n    vec2 t1 = vec2(0.);\n    mat2 r = rotate2D(12.);\n    vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        t1= triwave(uv-triwave(uv1*r/2.15))-t1.yx;\n        value1=sqrt(value1*value1+value*value);\n        value =\n            ((t1.x-t1.y) * amplitude-value)\n            //abs(abs(t1.x+t1.y) * amplitude-value)\n        ;\n        uv1 = uv;\n        amplitude /= 2.15;\n        uv = (uv.yx*2.15 + t1)*r;\n    }\n    \n    return value1;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    \n    //vec2 prev = vec2(0.);\n    //float t_prev = 0.;\n    \n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n        float f1 = f(pos,OCTAVES);\n\t\tfloat h = pos.y - f1;\n        //if(prev.y < h && prev.y < prev.x)\n        //return t_prev;\n        //prev = vec2(prev.y,h);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n        //t_prev = t;\n        \n\t}\n\n\treturn t;\n}\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iTime/8.-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtG3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 94, 94, 196], [217, 217, 241, 241, 293], [295, 295, 330, 379, 904], [906, 906, 928, 928, 958], [960, 960, 990, 990, 1040], [1042, 1042, 1062, 1062, 1109], [1111, 1111, 1144, 1144, 1338], [1340, 1340, 1407, 1407, 1844], [1845, 1845, 1897, 1897, 2442], [2444, 2444, 2495, 2495, 2696], [2698, 2698, 2724, 2724, 2800], [2868, 2868, 2925, 2925, 4898]]}
{"id": "3sGyRc", "name": "pixellated rain", "author": "unnick", "description": "an unpublished shader i made years ago", "tags": ["2d", "rain"], "likes": 8, "viewed": 313, "published": 3, "date": "1684187402", "time_retrieved": "2024-07-30T17:55:35.909679", "image_code": "#define tau 6.283\n\nfloat u2f(uint x) {\n    return uintBitsToFloat(0x3F800000u | (x >> 9)) - 1.;\n}\n\nuint hash(uint x, uint s) {\n    x ^= s            ; x ^= x >> 16; x *= 0x7FEB352Du;\n    x += s^0x7FEB352Du; x ^= x >> 15; x *= 0x846CA68Bu;\n                        x ^= x >> 16;\n    return x;\n}\n\nfloat hashf(uint x, uint s) {\n    return u2f(hash(x,s));\n}\n\nfloat noise(float x, uint s) {\n    float fx =          fract(x)  ;\n    uint  ix = uint(int(floor(x)));\n    \n    float mx = (3.-2.*fx)*fx*fx;\n    \n    float l = hashf(ix+0u, s);\n    float h = hashf(ix+1u, s);\n    \n    return mix(l,h,mx);\n}\n\nvec2 cossin(float a) {\n    return vec2(cos(a), sin(a));\n}\n\nmat2 rot(float a) {\n    vec2 cs = cossin(a);\n    return mat2(cs, cs.yx * vec2(-1,1));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    //coord *= rot(sin(iTime*.2)*.3);\n    coord *= rot(.4);\n    uint id = uint(int(floor(coord.x*.5)));\n    \n    float tmp = coord.y * .002;\n    tmp += (iTime + noise(iTime * .2 + hashf(id, 0u), id) * 2.) * 2.;\n    tmp += noise(tmp, id) * .6;\n    tmp *= 10.;\n    tmp += hashf(id, 1u);\n    \n    uint rand = hash(uint(int(floor(tmp))), id);\n    \n    float randf = u2f(rand);\n    col.rgb = mix(vec3(.1,.2,.6),vec3(.1,.3,.7), randf*randf);\n    \n    //col.rgb = vec3(0);\n    \n    if((rand & 0xFFu) < 0x10u) {\n        float a = fract(-tmp);\n        a *= a;\n        col.rgb *= 1.-a;\n        col.rgb += vec3(a);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 97], [99, 99, 126, 126, 292], [294, 294, 323, 323, 352], [354, 354, 384, 384, 592], [594, 594, 616, 616, 651], [653, 653, 672, 672, 740], [742, 742, 787, 825, 1399]]}
{"id": "mty3Wm", "name": "Simple Physics Lesson", "author": "Dirk", "description": " Physics", "tags": ["physics"], "likes": 5, "viewed": 166, "published": 3, "date": "1684187255", "time_retrieved": "2024-07-30T17:55:36.760405", "image_code": "\n    \n    v3 map( v2 p ){\n        v3 c = v3(0.0);\n        F  d  = S(e.x,e.y,lvl(-p));\n        F  d2 = S(e.x,e.y,L(p+Bot.xy )-Rad);\n        F  d3 = S(0.,0.001,L(p+Player.xy )-Rad);\n           if(W(d2,d3)>0.0){ c = v3(d); };\n           if(d2<d3){ c = v3(1.,0.,0.); }\n           if(d3<d2){ c = v3(0.,1.,0.); }\n        R  c;\n    }\n    \n    V loop(out v4 O, in v2 U) {\n        F  z = 3.0;\n        v2 uv = (z*U-iR.xy)/iR.y;\n        v3 c = map(uv);\n           O = v4(c,1.0);\n      }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n    #define Rad 0.1\n    #define Bot texelFetch(iChannel0, ivec2(0, 0), 0)\n    #define Player texelFetch(iChannel0, ivec2(1, 0), 0)\n\n    #define loop mainImage\n    \n    #define e  v4(0.0,0.001,0.5,20.0)\n    \n    #define iR iResolution\n    #define iF iFrame\n    #define iT iTime\n    #define tf(t) texelFetch(iChannel0, ivec2(t), 0)\n    \n    #define v2 vec2\n    #define v3 vec3\n    #define v4 vec4\n    #define m2 mat2\n    #define m3 mat3\n    #define m4 mat4\n    #define i2 ivec2\n    #define i3 ivec3\n    #define i4 ivec4\n    \n    #define A  abs\n    #define D  dot\n    #define F  float\n    #define I  int\n    #define L  length\n    #define M  max\n    #define N  normalize\n    #define R  return\n    #define S  smoothstep\n    #define V  void\n    #define W  min\n    #define Y  reflect\n\n    m2 rot(  F  a ){ F s=sin(a),c=cos(a); R m2(c,-s,s,c); }\n    F  box(  v2 p, v2 size ){ v2 d=A(p)-size; R L(M( d, v2(0) )) + W(M(d.x,d.y), 0.0 ); }\n    F  ball( v2 p, F  r ){ R L(p)-r; }\n    \n    F  lvl(v2 p){\n        F d;\n        p += v2(-.1,.25);\n        d = ball(p,.5);\n        d = W(box(p+v2(1.,.25),v2(1.0,.25)),d);\n        d = -W(ball(p+v2(2.,.5),.5),d);\n        d = W(d,box(p+v2(1.0,-0.01),v2(1.,.00))-.01);\n        d = W(d,box(p+v2(1.0,0.51),v2(1.,.00))-.01);\n        R d;\n    }\n    \n    v2 nor(v2 p) { R N( v2( lvl(p+e.yx)-lvl(p-e.yx), lvl(p+e.xy)-lvl(p-e.xy) ) ); }\n    \n    ", "buffer_a_code": "\n\n    v4 physics( i2 uv, I element ){\n        v4 body = tf(v2(element, 0));\n           body.xy += body.zw;\n        F  d = lvl(body.xy);\n        if( d < Rad ){\n           v2 h = nor(body.xy);\n           body.xy += h * (Rad - d);\n           body.zw  = Y(body.zw, h);\n        }\n        R body;\n    }\n    \n    v4 engine( i2 uv ){\n        v4 d;\n        v3  eps = v3( 0.0, 0.01, 0.005 );\n        if( uv == i2(0,0) ){\n            if( iF == 0 ) d = eps.xxzx;\n            if( iF >  0 ) d = physics(i2(uv),0);\n        }\n        if( uv == i2(1,0) ){\n            if( iF == 0 ) d = eps.yyzx;\n            if( iF >  0 ) d = physics(i2(uv),1);\n        }\n        R d;\n    }\n\n    V loop(out v4 O, in v2 U) {\n        i2 uv = i2(U);\n           O  = v4(0.);\n           O  = engine(uv);\n    }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mty3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 25, 25, 326], [336, 336, 363, 363, 475]]}
{"id": "dlGGRy", "name": "angry cat", "author": "jorge2017a2", "description": "angry cat", "tags": ["angrycat"], "likes": 6, "viewed": 131, "published": 3, "date": "1684184733", "time_retrieved": "2024-07-30T17:55:37.601157", "image_code": "///por jorgeF.P.---jorge2017a1\n//angry cat\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\nfloat intersectSDF(float distA, float distB) { return max(distA, distB);}\nfloat unionSDF(float distA, float distB) { return min(distA, distB);}\nfloat differenceSDF(float distA, float distB) {return max(distA, -distB);}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r); return (p - o) * mat2(c, -s, s, c) + o;}\n\nfloat sdCircle( vec2 p, float r ) {return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n { vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\n///------oreja izquierda\nfloat sdPoly4a POLY(4)\nvec2  pt4a[4]=vec2[](\nvec2(0.61,3.35),vec2(0.63,4.69),vec2(1.23,3.65),vec2(0.61,3.35)  );\n\n///oreja derecha\nfloat sdPoly4b POLY(4)\nvec2  pt4b[4]=vec2[](\nvec2(1.39,3.67),vec2(1.67,4.56),vec2(1.95,3.4),vec2(1.39,3.67)  );\n\n//----boca interior\nfloat sdPoly14 POLY(14)\nvec2  pt14[14]=vec2[](\nvec2(1.37,1.93),vec2(1.58,2.19),vec2(1.57,1.68),vec2(1.91,2.1),vec2(1.95,1.7),\nvec2(2.33,2.48),vec2(2.02,2.19),vec2(2.02,2.61),vec2(1.91,2.39),vec2(1.72,2.19),\nvec2(1.68,2.57),vec2(1.46,2.18),vec2(1.2,2.69),vec2(1.37,1.93)  );\n\nvec3 corneaOjoDer(vec2 p, vec3 col)\n{\n    vec2 p1=vec2(2.58,2.7) ; float r1=0.93;\n    float d1=sdCircle(p-p1,r1);\n     vec2 p2=vec2(1.35,2.98) ; float r2=0.77;\n     float d2=sdCircle(p-p2,r2);\n     float df=intersectSDF(d2,d1);\n    ///cornea 2 derecha\n    vec2 p6=vec2(1.985,2.895);  float a6=0.085; float b6=0.145;\n    float d6a=sdEllipse(p-p6, vec2(a6,b6) );\n    //cornea 3 derecha\n    p6=vec2(1.975,2.86); a6=0.035; b6=0.07;\n    float d6b=sdEllipse(p-p6, vec2(a6,b6) );\n    col= DrawFigBorde(vec3(1.0),col, df);\n    col= DrawFigBorde(vec3(0.0),col, d6a);\n    col= DrawFigBorde(vec3(1.0),col, d6b);\n    return col;\n}\n\nvec3 corneaOjoIzq(vec2 p, vec3 col)\n{\n    vec2 p4=vec2(0.675,2.785) ; float r4=0.975;\n    float d4=sdCircle(p-p4,r4);\n        vec2 p1=vec2(-0.025,2.275) ; float r1=1.755;\n    float d1=sdCircle(p-p1,r1);\n        vec2 p2=vec2(1.795,2.985) ; float r2=0.745;\n    float d2=sdCircle(p-p2,r2);\n        float df;\n    df=intersectSDF(d2,d1);\n    df=intersectSDF(d4,df);\n        vec2 p6=vec2(1.535,2.865);  float a6=0.085; float b6=0.145;\n    float d6a=sdEllipse(p-p6, vec2(a6,b6));\n    //cornea 3 interna izq\n     p6=vec2(1.545,2.87);   a6=0.035;  b6=0.07;\n    float d6b=sdEllipse(p-p6, vec2(a6,b6));\n    col= DrawFigBorde(vec3(1.0),col, df);\n    col= DrawFigBorde(vec3(0.0,0.0,0.0),col, d6a);\n    col= DrawFigBorde(vec3(1.0,1.0,1.0),col, d6b);\n    return col;\n}\n\nvec3 boca2(vec2 p  ,vec3 col) \n{ vec2 p6,p7,p1,p2,p3,p4; \nfloat a6,b6,d6;\nfloat a7,b7, d7;\nfloat r1,d1;\nfloat r2,d2;\nfloat df;\nfloat r3,d3;\nfloat r4,d4; \n  \n    float sd14 = sdPoly14(p, pt14);\n    p1 = vec2(1.41, 2.2);\n    r1 = 0.25;\n    d1 = sdCircle(p- p1, r1);\n    \n    p2 = vec2(1.58, 2.6);\n    r2 = 0.3;\n    d2 = sdCircle(p- p2, r2);\n\n    p3 = vec2(1.21, 2.5);\n    r3 = 0.25;\n    d3 = sdCircle(p- p3, r3);\n    \n    p4 = vec2(0.835, 1.97);\n    r4 = 0.475;\n    d4 = sdCircle(p- p4, r4);\n\n    p6 = vec2(1.74, 2.07);\n    a6 = 0.41;\n    b6 = 0.44;\n    d6 = sdEllipse(p- p6, vec2(a6, b6));\n    \n    p7 = vec2(1.895, 2.15);\n    a7 = 0.285;\n    b7 = 0.445;\n    d7 = sdEllipse(p-p7, vec2(a7, b7));\n    \n    df = unionSDF(d6, d7);\n    df = unionSDF(df, d1);\n    df = differenceSDF(df, d3);\n    df = differenceSDF(df, d4);\n    sd14 = intersectSDF(sd14,df);\n    col = DrawFigBorde(vec3(1., 1., 1.), col, df);\n    col= DrawFigDelgado(vec3(0.0,0.0,0.0),col, sd14);\n    return  col;\n}\n\n\nvec3 boca(vec2 p ,vec3 col) \n{\n float sd14;\n vec2 p6,p7,p6a,p7b,p6c;\n float a6, b6,d6;\n float a7, b7, d7a;\n float d6a,d7b,d6c;\n\n    p6 = vec2(1.58, 2.315);\n    a6 = 0.76;\n    b6 = 0.445;\n    d6 = sdEllipse(p- p6, vec2(a6, b6));\n    \n    p7 = vec2(1.72, 2.115);\n    a7 = 0.51;\n    b7 = 0.545;\n    d7a = sdEllipse(p- p7, vec2(a7, b7));\n    \n    p6a = vec2(2.335, 2.51);\n    a6 = 0.285;\n    b6 = 0.17;\n    d6a = sdEllipse(p-p6, vec2(a6, b6));\n    \n    p7b = vec2(2.06, 2.455);\n    a7 = 0.51;\n    b7 = 0.295;\n    d7b = sdEllipse(p- p7b, vec2(a7, b7));\n\n float df;\n    df = min(d6, d7a);\n    df = min(df, d6a);\n    df = min(df, d7b);\n    col=DrawFigBorde(vec3(1., 1., 1.), col, df);\n    p6c = vec2(2.625, 2.74);\n    a6 = 0.185;\n    b6 = 0.22;\n    p = Rotate(p, p6c, 45.0);\n    d6c = sdEllipse(p- p6c, vec2(a6, b6));\n    col = DrawFigBorde(vec3(0., 0., 0.0), col, d6c);\n    return  col;\n}\n\nvec3 pelo1(vec2 p, vec3 col)\n{//pelo diferencia\n    float yd=0.5;\n    vec2 p1=vec2(0.5,3.63-yd); float r1=0.34;\n    float d1=sdCircle(p-p1,r1);\n    \n    vec2 p2=vec2(0.44,3.77-yd) ; float r2=0.32;\n    float d2=sdCircle(p-p2,r2);\n    float df = differenceSDF(d1, d2);\n    col = DrawFigBorde(vec3(0., 0.,0.),col,df);\n    return col;\n}\n\nvec3 pelo2(vec2 p, vec3 col)\n{   ///pelo 2 diferencia d1, d2 con d3...despues unino con pelo\n    float yd=0.4;\n    vec2 p1=vec2(0.205,2.665-yd) ; float r1=0.345;\n    float d1=sdCircle(p-p1,r1);\n    \n    vec2 p2=vec2(0.24,3.33-yd) ; float r2=0.32;\n    float d2=sdCircle(p-p2,r2);\n    \n    vec2 p3=vec2(0.435,2.985-yd) ; float r3=0.225;\n    float d3=sdCircle(p-p3,r3);\n    \n    float df = differenceSDF(d3, d1);\n    df = differenceSDF(df, d2);    \n    col = DrawFigBorde(vec3(0., 0.,0.),col,df);\n    return col;\n}\n\nvec3 rostrogato(vec2 p, vec3 col)\n{ ///cabeza 1\n    vec2 p1=vec2(1.365,2.955) ; float r1=0.755;\n    float d1=sdCircle(p-p1,r1);\n    \n    vec2 p2=vec2(1.08,2.84) ; float r2=0.72;\n    float d2=sdCircle(p-p2,r2);\n    \n    vec2 p6=vec2(1.58,2.315);  float a6=0.76; float b6=0.445;\n    float d6=sdEllipse(p-p6, vec2(a6,b6));\n    \n    vec2 p7=vec2(1.72,2.115); float a7=0.51; float b7=0.545;\n    float d7a=sdEllipse(p-p7, vec2(a7,b7) );\n    \n    vec2 p6a=vec2(2.335,2.51);   a6=0.285; b6=0.17;\n    float d6a=sdEllipse(p-p6,vec2(a6,b6) );\n    \n    vec2 p7b=vec2(2.06,2.455); a7=0.51;  b7=0.295;\n    float d7b=sdEllipse(p-p7b,vec2(a7,b7) );\n\n    //oreja izquierda\n    float sd4a = sdPoly4a(p, pt4a);\n    float sd4b = sdPoly4b(p, pt4b);\n  \n    float df=min(d1,d2);\n    df=min(df,d6);\n    df=min(df,d7a);\n    df=min(df,d6a);\n    df=min(df,d7b);\n    df=min(df,sd4a);\n    df=min(df,sd4b);\n\n    col=DrawFigBorde(vec3(0.0),col,df);\n    col= corneaOjoIzq(p,col);\n    col= corneaOjoDer(p,col);\n    col= boca( p ,col);\n    col= boca2( p ,col);\n    col= pelo1(p,col);\n    col= pelo2(p,col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-1.5); uv*=5.5;\n    float t=iTime;\n    uv.x=abs(uv.x)+(1.6+0.5*sin(t*2.0))-(1.0+0.5*sin(t));\n     uv.y=abs(uv.y-8.0)+1.5;\n    vec2 uv2=uv*0.25;\n    vec3 colb = 0.5 + 0.5*cos(iTime+uv2.xyx+vec3(0,2,4));\n    vec3 col;\n    if (uv.x<4.0)\n        col=colb;\n    else\n        col=vec3(0.66,0.83,0.92);\n    col= rostrogato(uv*(0.5+0.5*abs(sin(t))) ,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlGGRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 606, 606, 732], [733, 733, 814, 814, 942], [944, 944, 1008, 1008, 1079], [1081, 1081, 1127, 1127, 1154], [1155, 1155, 1197, 1197, 1224], [1225, 1225, 1272, 1272, 1299], [1301, 1317, 1365, 1365, 1438], [1440, 1440, 1475, 1475, 1498], [1500, 1500, 1538, 1538, 1610], [1612, 1612, 1664, 1664, 1771], [2337, 2337, 2374, 2374, 2955], [2957, 2957, 2994, 2994, 3710], [3712, 3712, 3744, 3744, 4686], [4689, 4689, 4719, 4719, 5571], [5573, 5573, 5603, 5620, 5905], [5907, 5907, 5937, 5999, 6418], [6420, 6420, 6455, 6467, 7510], [7512, 7512, 7569, 7569, 8061]]}
{"id": "ctG3zy", "name": "funny precision issue on dFdx", "author": "FabriceNeyret2", "description": "green, red, blue if  dFdx(1e9 - 24.*u.x) is < , = , > 0.", "tags": ["glslbug"], "likes": 5, "viewed": 284, "published": 3, "date": "1684172774", "time_retrieved": "2024-07-30T17:55:38.419968", "image_code": "void mainImage(out vec4 o, vec2 u) {\n    float v = dFdx(1e9 - 24.*u.x);\n    o = vec4( v == 0. , v < 0. , v > 0., 1 );    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctG3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 123]]}
{"id": "cly3zG", "name": "Falling VariablePyramid Pentakis", "author": "timmaffett", "description": "Lots of shiny pentakisdodecahedra\nMouse.x now effects height of pentagonal pyramid.\n(Pentakis Dodecahedron is what you get if you attach pentagonal pyramid to each face of a regular dodecahedron)\nmouse.x at 0 is dodecahedron-increasing x increases height\n", "tags": ["grid", "polyhedron", "pentakis"], "likes": 8, "viewed": 267, "published": 3, "date": "1684168024", "time_retrieved": "2024-07-30T17:55:39.180933", "image_code": "// Fork of \"Falling Polyhedra\" by dr2. https://shadertoy.com/view/DtKGDm\n// 2023-05-15 16:10:05\n// mouse now effects height of pentagonal pyramid.\n// (Pentakis Dodecahedron is what you get if you attach pentagonal pyramid to each face of a regular dodecahedron)\n// this mouse.x factor at 0 makes Dodecahedron, increasing x increases pyramid height..\n//   (also I removed camera translation to better observe pyramid height changes)\n//\n// Original \"Falling Polyhedra\" by dr2 - 2023 had this factor hard coded at 0.5\n//  (and moving mouse translated camera)\n\n// \"Falling Polyhedra\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec2 mouse;\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define VERTICAL_FALLING_VELOCITY   0.3\n#define ZOOM_FACTOR    6.\n\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3v3 (vec3 p);\n\nvec3 bGrid, cId, obDisp, obRot, ltDir[4], ltCol[4];\nfloat dstFar, tCur, vSpd;\nbool cOcc;\nconst float pi = 3.1415927;\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n    p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n  p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n  p.xy = sin ((2. * pi / 5.) * (fract ((atan (p.x, p.y) + pi / 5.) / (2. * pi / 5.)) - 0.5) +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{  // (from \"Pentakis Dodecahedron\")\n  float d, a;\n  d = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.yz = Rot2Cs (p.yz, sin (obRot.x + vec2 (0.5* pi, 0.)));\n    p.xz = Rot2Cs (p.xz, sin (obRot.y + vec2 (0.5 * pi, 0.)));\n    p.xy = Rot2Cs (p.xy, sin (obRot.z + vec2 (0.5 * pi, 0.)));\n    // mouse now effects height of pentagonal pyramid.\n    // (Pentakis Dodecahedron is what you get if you attach pentagonal pyramid to each face of a regular dodecahedron)\n    // this mouse.x factor at 0 makes Dodecahedron, increasing x increases pyramid height..\n    a = mouse.x * (acos (-1. / sqrt (5.)) - acos (- (80. + 9. * sqrt (5.)) / 109.));\n    d = abs (dot (DodecSym (p).yz, sin (a + vec2 (0., 0.5 * pi)))) - 0.12;\n  }\n  return d;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  vRan = Hashv3v3 (cId + 11.1);\n  cOcc = (vRan.x * step (4., length (cId.xz)) > 0.1);\n  if (cOcc) {\n    obDisp = bGrid * (cId + 0.5 + 0.3 * cos ((0.5 + 0.5 * vRan) * tCur + vRan.zxy));\n    obRot = (vRan - 0.5) * tCur;\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += vSpd * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((bGrid * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, c, vn, sumD, sumS;\n  float dstObj, nDotL;\n  col = vec3 (0.1);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ObjCell (ro));\n    c = HsvToRgb (vec3 (Hashfv3 (cId), 0.7, 1.));\n    sumD = vec3 (0.);\n    sumS = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      nDotL *= nDotL;\n      sumD += ltCol[k] * c * nDotL * nDotL;\n      sumS += vec3 (0.7) * pow (max (0., dot (ltDir[k], reflect (rd, vn))), 128.);\n    }\n    col = sumD + sumS;\n    col = mix (col, vec3 (0.1), 1. - exp (min (0., 3. - 5. * dstObj / dstFar)));\n  }\n  return clamp (col, 0., 1.);\n}\n\n\n    \nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\n  mouse = (iMouse.xy == vec2(0.)) ? vec2(1.5) : (iMouse.xy/iResolution.xy) * 2.0; // This gives range of 0.0 -> 2.0 for x \n    \n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, e;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  az = 0.;\n  el = 0.1 * pi;\n  if (false && mPtr.z > 0.) {  // prevent translation so we can watch pyramid height change\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.01 * tCur;\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  bGrid = vec3 (1.);\n  vSpd = VERTICAL_FALLING_VELOCITY;\n  ro = vec3 (0.5 * bGrid.x);\n  zmFac = ZOOM_FACTOR;\n  dstFar = 50.;\n  e = vec2 (1., -1.);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltDir[k] = normalize ((k < 2) ? ((k == 0) ? e.xxx : e.xyy) : ((k == 2) ? e.yxy : e.yyx));\n    ltDir[k].xz = Rot2D (ltDir[k].xz, 0.17 * pi * tCur);\n    ltDir[k].xy = Rot2D (ltDir[k].xy, 0.13 * pi * tCur);\n  }\n  ltCol[0] = vec3 (1., 1., 0.3);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cly3zG.jpg", "access": "api", "license": "cc-by-nc-sa-2.0", "functions": [[1200, 1200, 1224, 1224, 1875], [1877, 1877, 1899, 1934, 2625], [2627, 2627, 2645, 2645, 2882], [2884, 2884, 2907, 2907, 3038], [3040, 3040, 3073, 3073, 3631], [3633, 3633, 3654, 3654, 3909], [3911, 3911, 3946, 3946, 4602], [4610, 4610, 4666, 4666, 6296], [6298, 6298, 6320, 6320, 6358], [6360, 6360, 6396, 6396, 6602], [6604, 6604, 6634, 6634, 6747], [6749, 6749, 6780, 6780, 6844], [6846, 6846, 6870, 6870, 6987], [7021, 7021, 7045, 7045, 7105], [7107, 7107, 7131, 7131, 7196], [7198, 7198, 7222, 7222, 7340]]}
{"id": "mtG3zm", "name": "Dunnos hell", "author": "z0rg", "description": "onnooo !!!", "tags": ["raymarching", "hell", "dunnos"], "likes": 27, "viewed": 425, "published": 3, "date": "1684166872", "time_retrieved": "2024-07-30T17:55:40.036645", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\n#define PI acos(-1.)\nmat2 r2d(float a)\n{\n  float c = cos(a), s= sin(a);\n   return mat2(c,-s,s,c);\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+(r*uv.x+u*uv.y)*.6);\n\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if(a.x<b.x)\n  return a;\n  return b;\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nvec2 map(vec3 p)\n{\n  vec2 acc = vec2(1000.,-1.);\n  float repx = .5;\n  float idx = floor((p.x+repx*.5)/repx);\n  p.x = mod(p.x+repx*.5,repx)-repx*.5;\n  float repy =5.;\n  p.y= mod(p.y+repy*.5,repy)-repy*.5;\n\n  p.yz*=r2d(length(p.yz)*.5-iTime*.1+idx*5.-.4*iTime*abs(sin(idx+.5)));\n\n  float an = atan(p.y,p.z);\n  float rep = PI*2./12.;\n  float id = floor((an+rep*.5)/rep);\n  p.x+= sin(p.y*20.-iTime*4.)*.02*sat(length(p.yz));\n  float sector = mod(an+rep*.5,rep)-rep*.5;\n  p.yz = vec2(sin(sector),cos(sector))*length(p.yz);\n\n  float blob = sdCapsule(p,vec3(0.,0.,-0.5),\n    vec3(0.,0.,1.5),.12);\n    //blob = length(p.xy)-.1;\n  p.z-=1.5;\n  vec3 pm= p-vec3(0.,0.,-.1);\n  vec3 p2 = p;\n  p2.x=abs(p2.x);\n  p2.xz*= r2d(.5);\n  //p2.x=abs(p2.x);\n  blob = min(blob, length(p2.xy)-.002);\n  blob = max(blob,p.z-.2);\n  vec3 p3 =p;\n  p3.x= abs(p3.x);\n  blob = min(blob,length(p3-vec3(0.1,0.,.2))-.02);\n  p.x= abs(p.x);\n  float eyes = length(p.xz-vec2(.03,0.))-.02;\n\n  float mat = sat(eyes*400.);\n\n  float mouth = length(pm.xz)-.05;\n  mouth = max(mouth, -pm.z);\n  mat = mix(mat, 2., 1.-sat(mouth*400.));\n\npm.x+= sin(pm.z*150.-7.*iTime)*.01;\n  float tongue = sdSegment(pm.xz,\n    vec2(0.,0.),vec2(0.,.025))-.01;\n    tongue = max(tongue, mouth);\n  mat = mix(mat, 3., 1.-sat(tongue*4000.));\n  acc= _min(acc, vec2(blob,mat));\n\n  return acc;// length(p-vec3(0.,.0,1.))-.1;\n}\n\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd)\n{\n    accCol = vec3(0.);\n  vec3 p= ro;\n  for(int i= 0;i<128 && distance(p,ro)<10.;++i)\n  {\n    vec2 res = map(p);\n    if(res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n    p+=rd*res.x*.3;\n    vec3 rgb = mix(vec3(0.996,0.290,0.165), \n    vec3(0.996,0.651,0.165), sin(iTime+10.*p.x+p.y)*.5+.5);\n    accCol += rgb*(1.-sat(res.x/.2))*.025\n    *(1.+texture(iChannel0, vec2(0.1,0.)).x);//*sat(p.y*3.+4.5);\n  }\n  return vec3(-1.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(0.);\n  uv.x+=.3;\n  vec3 ro = vec3(.5,0.5,-2.);\n  vec3 ta = vec3(0.,-3.2,0.);\n  vec3 rd = normalize(ta-ro);\n  rd = getCam(rd,uv);\n  vec3 res = trace(ro,rd);\n  if(res.y>0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p,res.x);\n    col = n*.5+.5;\n    col = vec3(.1);\n    if(res.z==0.)\n    col = vec3(1.);\n    if (res.z==2.)\n    col = vec3(.7,0.1,0.);\n    if (res.z==3.)\n    col= vec3(1.,0.3,0.3);\n  }\n  col += accCol;\n  float beat = 1./2.2;\n  //col = mix(col, 1.-col, pow(mod(iTime,beat)/beat,2.));\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/\n    iResolution.xx;\n\n  vec3 col = rdr(uv);\n  col *= 1.-sat((length(uv)-.2)*2.);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33310, "src": "https://soundcloud.com/vincentimes/jeff-mills-the-bells?si=8d0c9c6d67434e0ab56e3e6bd69e9824&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtG3zm.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[448, 448, 467, 467, 526], [527, 527, 558, 558, 689], [691, 691, 743, 743, 864], [868, 868, 895, 895, 935], [936, 936, 988, 988, 1107], [1108, 1108, 1126, 1126, 2459], [2474, 2474, 2504, 2504, 2940], [2942, 2942, 2973, 2973, 3091], [3093, 3093, 3112, 3112, 3649], [3650, 3650, 3707, 3707, 3865]]}
{"id": "Dty3zG", "name": "dynamic gradient map (epic style", "author": "oatmealine", "description": "wanted to see how far i could go if i used a buffer as a \"palette\" for an image; came out pretty neat i think", "tags": ["2d", "filter", "palette", "gradientmap"], "likes": 2, "viewed": 196, "published": 3, "date": "1684166743", "time_retrieved": "2024-07-30T17:55:40.853461", "image_code": "#define SAMPLES 256\n\n// https://stackoverflow.com/a/28873770\nfloat gray(vec3 color) {\n    return (min(color.r, min(color.g, color.b)) + max(color.r, max(color.g, color.b))) * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    \n    // this produces a kind of sinewave over the screen -\n    // this determines where on the Y axis the palette (our buffer)\n    // will be sampled\n    float sampOffset = uv.y + sin(uv.x * 1.9 + iTime * 0.2) * 0.2;\n    \n    // for a \"pure\" palette shader, this should be left at an\n    // arbitrarily high value - however, setting this to 1\n    // means values too far from the palette will instead be\n    // white. this produces a very cool effect! so i kept it\n    float minDist = 1.;\n    vec3 minCol = vec3(1.0);\n    \n    // go through our palette buffer, sampling values\n    for (int i = 0; i < SAMPLES; i++) {\n        // [0 - SAMPLES] -> [0.0 - 1.0]\n        float a = float(i) / float(SAMPLES);\n        // sample\n        vec3 palette = texture(iChannel1, vec2(a, sampOffset)).rgb;\n        // measure distance\n        vec3 diff = abs(palette - tex.rgb);\n        float dist = diff.r + diff.g + diff.b;\n        \n        if (dist < minDist) {\n            minDist = dist;\n            minCol = palette;\n        }\n        \n        // silly no-if version i tried. looks wacky but interesting\n        //minCol = mix(minCol, palette, clamp(dist - minDist, 0.0, 1.0));\n    }\n    \n    //fragColor = vec4(vec3(sampOffset), 1.0);\n    //fragColor = texture(iChannel1, uv);\n    fragColor = vec4(minCol, tex.a);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// literally just a modified ver of the default shader lmfao\n// could be replaced w/ a plasma for cooler effect? potentially...\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord + iMouse.xy) / iResolution.xy;\n    uv.y += sin(uv.x + iTime) * 2.0;\n    uv.y *= 2.0;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dty3zG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 61, 85, 85, 181], [183, 183, 238, 238, 1627]]}
{"id": "DsBGzW", "name": "Mathieu Group M12", "author": "mla", "description": "Émile Léonard Mathieu, born May 15th 1835 in Metz, discovered the earliest known sporadic simple groups, including the 95040 element permutation group M12, shown here. [url]https://en.wikipedia.org/wiki/%C3%89mile_L%C3%A9onard_Mathieu[/url]", "tags": ["group", "permutation", "m12", "mathieu"], "likes": 9, "viewed": 300, "published": 3, "date": "1684165718", "time_retrieved": "2024-07-30T17:55:41.672272", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Mathieu Group M12, mla, May 15th 2023.\n//\n// Running through the 95040 permutations of the second smallest sporadic simple\n// group, the Mathieu group M12. The smallest, M11 is just the stabilizer subgroup\n// of one element in M12 so is effectively shown here too.\n//\n// The group is represented by a Sims table, see eg. TAOCP, Vol 4. for details,\n// but basically allows incrementally constructing a permutation of the group\n// element by element. The table is very simple for M12, which is sharply\n// 5-transitive, ie. there is exactly one permutation mapping five given elements\n// to any other five (so the leftmost five elements in the bottom row determine\n// the rest of the pattern).\n//\n// I've written this in a \"functional\" style, returning arrays directly from\n// functions, rather than using inout parameters or globals, this seems have\n// no impact on efficiency on the platforms I've tested on.\n//\n// 'x': one permutation per second rather than one per frame\n// 'r': generate permutations in a random order\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// M12  is generated by three permutations:\n// (1,2,3,4,5,6,7,8,9,10,0,11)\n// (11,10,5,7,8,2,9,3,4,6,1,0)\n// (0,1,6,9,5,3,10,2,8,4,7,11)\n\nconst int M = 5, N = 12;\nconst int maxrank = 12*11*10*9*8; // 12C5\nconst int[(2*N-M+1)/2*M*N] sims =\n  int[] (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         //0, 1, 2, 3, 11, 8, 9, 5, 10, 4, 7, 6, // Alternative first entry\n         1, 0, 2, 3, 4, 8, 6, 10, 5, 11, 7, 9,\n         2, 0, 1, 3, 4, 9, 6, 5, 10, 7, 11, 8,\n         3, 0, 1, 2, 4, 11, 6, 7, 8, 5, 9, 10,\n         4, 0, 1, 2, 3, 5, 6, 10, 9, 11, 8, 7,\n         5, 0, 1, 2, 3, 6, 10, 4, 8, 7, 11, 9,\n         6, 0, 1, 2, 3, 10, 4, 5, 11, 9, 7, 8,\n         7, 0, 1, 2, 3, 11, 8, 9, 5, 10, 4, 6,\n         8, 0, 1, 2, 3, 9, 7, 11, 10, 5, 6, 4,\n         9, 0, 1, 2, 3, 7, 11, 8, 6, 4, 5, 10,\n         10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11,\n         11, 0, 1, 2, 3, 8, 9, 7, 4, 6, 10, 5,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 2, 1, 3, 4, 10, 6, 11, 9, 8, 5, 7,\n         0, 3, 1, 2, 4, 8, 6, 9, 11, 10, 7, 5,\n         0, 4, 1, 2, 3, 9, 6, 8, 5, 7, 10, 11,\n         0, 5, 1, 2, 3, 8, 10, 11, 6, 9, 4, 7,\n         0, 6, 1, 2, 3, 11, 4, 7, 10, 8, 5, 9,\n         0, 7, 1, 2, 3, 5, 8, 4, 11, 6, 9, 10,\n         0, 8, 1, 2, 3, 10, 7, 6, 9, 4, 11, 5,\n         0, 9, 1, 2, 3, 6, 11, 5, 7, 10, 8, 4,\n         0, 10, 1, 2, 3, 7, 5, 9, 4, 11, 6, 8,\n         0, 11, 1, 2, 3, 4, 9, 10, 8, 5, 7, 6,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 1, 3, 2, 4, 7, 6, 5, 10, 11, 8, 9,\n         0, 1, 4, 2, 3, 10, 6, 11, 7, 5, 9, 8,\n         0, 1, 5, 2, 3, 4, 10, 7, 9, 6, 8, 11,\n         0, 1, 6, 2, 3, 5, 4, 9, 8, 10, 11, 7,\n         0, 1, 7, 2, 3, 9, 8, 10, 6, 11, 5, 4,\n         0, 1, 8, 2, 3, 11, 7, 5, 4, 9, 10, 6,\n         0, 1, 9, 2, 3, 8, 11, 4, 10, 7, 6, 5,\n         0, 1, 10, 2, 3, 6, 5, 8, 11, 4, 7, 9,\n         0, 1, 11, 2, 3, 7, 9, 6, 5, 8, 4, 10,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 1, 2, 4, 3, 11, 6, 10, 9, 8, 7, 5,\n         0, 1, 2, 5, 3, 7, 10, 4, 8, 11, 9, 6,\n         0, 1, 2, 6, 3, 9, 4, 5, 11, 7, 8, 10,\n         0, 1, 2, 7, 3, 10, 8, 9, 5, 4, 6, 11,\n         0, 1, 2, 8, 3, 5, 7, 11, 10, 6, 4, 9,\n         0, 1, 2, 9, 3, 4, 11, 8, 6, 5, 10, 7,\n         0, 1, 2, 10, 3, 8, 5, 6, 7, 9, 11, 4,\n         0, 1, 2, 11, 3, 6, 9, 7, 4, 10, 5, 8,\n\n         0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n         0, 1, 2, 3, 5, 6, 10, 9, 11, 8, 4, 7,\n         0, 1, 2, 3, 6, 10, 4, 8, 7, 11, 5, 9,\n         0, 1, 2, 3, 7, 11, 8, 6, 4, 5, 9, 10,\n         0, 1, 2, 3, 8, 9, 7, 4, 6, 10, 11, 5,\n         0, 1, 2, 3, 9, 7, 11, 10, 5, 6, 8, 4,\n         0, 1, 2, 3, 10, 4, 5, 11, 9, 7, 6, 8,\n         0, 1, 2, 3, 11, 8, 9, 5, 10, 4, 7, 6);\n\n// Permutation (n,i) in table, for 0 <= n < 5, i >= n,\n// is the identity on elements 0..n-1, and puts element\n// i at position n.\nint simsindex(int n, int i) {\n  assert(i >= n);\n  assert(i < N);\n  return i + n*N-n*(n+1)/2;\n}\n\nint[N] get(int ix) {\n  int res[N], base = N*ix;\n  for (int i = 0; i < N; i++) res[i] = sims[base+i];\n  return res;\n}\n\nint[N] invert(int s[N]) {\n  int t[N];\n  for (int i = 0; i < N; i++) t[s[i]] = i;\n  return t;\n}\n\nint[M] apply(int s[N], int t[M]) {\n  for (int i = 0; i < M; i++) t[i] = s[t[i]];\n  return t;\n}\n\nint[N] apply(int s[N], int t[N]) {\n  for (int i = 0; i < N; i++) t[i] = s[t[i]];\n  return t;\n}\n\nconst int identity[] = int[](0,1,2,3,4,5,6,7,8,9,10,11);\n\nint[M] m12(int p[M]) {\n  int perms[M];\n  for (int i = 0; i < M; i++) {\n    int k = simsindex(i,p[i]);\n    perms[4-i] = k;\n    p = apply(invert(get(k)),p);\n  }\n  return perms;\n}\n\nint[M] unrank(int n) {\n  int p[M], s[N] = identity;\n  int k = maxrank;\n  for (int i = 0; i < M; i++) {\n    k /= N-i;\n    for (int j = n/k; j > 0; j--) {\n      swap(s[i+j],s[i+j-1]);\n    }\n    p[i] = s[i];\n    n %= k;\n  }\n  return p;\n}\n\nvec3 getcolor(int index) {\n  vec3 colors[N] =\n    vec3[](vec3(0.996078,0.152941,0.0705882),\n           vec3(0.988235,0.376471,0.0392157),\n           vec3(0.984314,0.6,0.00784314),\n           vec3(0.988235,0.8,0.101961),\n           vec3(0.996078,0.996078,0.2),\n           vec3(0.698039,0.843137,0.196078),\n\n           vec3(0.4,0.690196,0.196078),\n           vec3(0.203922,0.486275,0.596078),\n           vec3(0.00784314,0.278431,0.996078),\n           vec3(0.266667,0.141176,0.839216),\n           vec3(0.52549,0.00392157,0.686275),\n           vec3(0.760784,0.0784314,0.376471));\n\n  assert(index >= 0);\n  assert(index < N);\n  vec3 col = colors[index];\n  //col = h2rgb(float(index)/float(N));\n  return pow(col,vec3(2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float timestamp = floor(iTime);\n  if (!key(CHAR_X)) timestamp = float(iFrame);\n  if (timestamp + 1.0 == fragColor.a) return;\n  vec2 pos = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  pos *= 3.5*vec2(1,-1);\n  pos += vec2(5.5,2.5);\n\n  int rank = int(timestamp);\n  if (key(CHAR_R)) rank = randint(rank,maxrank);\n\n  int perms[M] = m12(unrank(rank%maxrank));\n\n  int col = int(round(pos.x));\n  int row = int(floor(pos.y));\n  vec3 color = vec3(0);\n  float px = 1.25*fwidth(pos.x);\n\n  if (row >= 0 && row < M) {\n    float d = 1e8;\n    int s[N] = identity, u[N] = identity, v[N], j;\n    for (j = 0; j < M; j++) {\n      s = apply(get(perms[j]),s);\n      v = invert(s);\n      if (j == row) break;\n      u = v;\n    }\n    for (int i = 0; i < N; i++) {\n      d = min(d,segment(pos,vec2(u[i],j),vec2(v[i],j+1)));\n    }\n    color = mix(vec3(1),color,smoothstep(0.0,px,d-0.01));\n  }\n\n  if (col >= 0 && col < N) {\n    int s[] = identity;\n    for (int j = 0; j <= M; j++) {\n      if (round(pos.y) == float(j)) {\n        float d = distance(pos,vec2(col,j));\n        color = mix(getcolor(s[col]),color,smoothstep(0.0,px,d-0.2));\n        break;\n      }\n      if (j == M) break;\n      s = apply(get(perms[j]),s);\n    }\n  }\n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,timestamp+1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.1415927;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nint randint(int seed, int mod) {\n  return int(ihash(uint(seed))%uint(mod));\n}\n\nint swap(inout int i, inout int j) {\n  int t = j; j = i; i = t;\n  return t;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBGzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3863, 3994, 4023, 4023, 4088], [5688, 5688, 5743, 5743, 7112]]}
{"id": "mtKGDw", "name": "Hangman+Alphabet Recognizer CNN", "author": "kishimisu", "description": "This is my second attempt; the first attempt had 9,062 parameters and 12 feature maps for each layer, but seemed to crash shadertoy.\nI hope this smaller version is gentler for your machines!\nPlease tell me if something isn't working!", "tags": ["number", "convolution", "learning", "digit", "linear", "model", "ai", "machine", "neural", "recognition", "network", "convolutional", "prediction", "ml"], "likes": 97, "viewed": 3927, "published": 3, "date": "1684146776", "time_retrieved": "2024-07-30T17:55:43.455504", "image_code": "/* Handwritten Alphabet Recognizer CNN + Hangman - https://www.shadertoy.com/view/mtKGDw\n   (Can take several seconds to compile) \n   \n   This shader implements a Convolutional Neural Network trained on uppercase \n   handwritten characters, combined with a hangman game for even more fun!\n   \n   /// HOW TO PLAY / INFOS ///\n   \n   - Draw *uppercase* letters in the right area\n   - Click on \"Try\" to submit the current letter\n   - Click on \"Clear\" to reset the draw area\n   - Click \"Show Neural Network\" to visualize the prediction in real time!\n   \n   - You have a maximum of 7 failed attempts before losing the game!\n     (You can change the difficulty in the \"Common\" tab)\n     \n   - There are 40 different words that can be guessed\n   \n   - The model struggles for the letter \"I\", be sure to add the two horizontal bars.\n   - You can also click on individual characters in the bottom-right alphabet if\n     it really struggles to recognize a letter\n   \n   /// Technical Details ///\n   \n   Python Notebook created for this project: https://colab.research.google.com/drive/18_2SZPejs1BaZH1EofFgEiA9HG2fBR7u\n   \n   This implementation is a bigger version of my previous Handwritten Digit Recognizer.\n   Here's a comparision between the two models:\n   \n                        Digit CNN          Alphabet CNN\n   # of parameters      2,023              6,490\n   # of convolutions    2                  4\n   # of feature maps    8-5                8-8-10-10\n     per layer\n   output size          10                 26\n   \n   I trained the model on two datasets for a total of 445250 training examples: \n       - EMNIST (https://arxiv.org/pdf/1702.05373.pdf)\n       - A-Z Handwritten Alphabets (Available on Kaggle)\n   I first used a combination of lowercase and uppercase letters, but finally ended up\n   keeping only uppercase letters to increase accuracy, while constraining the case.\n   The accuracy on the testing set is around 96%, however there are some disparities\n   within the letters, the model struggles the most on the I, D and V letters.\n   \n   /// Network Architecture ///\n   \n   - All convolutions have a kernel size of 3x3 and a stride of 1.\n   The Buffer  A handles the input\n   The buffers C and D handles all the convolution and max pooling layers\n   The Buffer  D handles the fully connected layer and output\n   \n   - (Buffer A) Input Layer     : 28x28    = 784 inputs\n   - (Buffer B) Convolution     : 28x28    => 8x26x26   \n   - (Buffer C) Convolution     : 8x26x26  => 8x24x24\n   - (Buffer B) Max Pooling     : 8x24x24  => 8x12x12   \n   - (Buffer C) Convolution     : 8x12x12  => 10x10x10   \n   - (Buffer B) Convolution     : 10x10x10 => 10x8x8   \n   - (Buffer C) Max Pooling     : 10x8x8   => 10x4x4\n   - (Buffer D) Fully Connected : 10x4x4   => 26\n   - (Buffer D) Softmax         : 26       => 1\n   \n   I alternated the layers between buffers B and C in order to be able\n   to calculate multpiple layers in a single frame. This way, the prediction\n   happens on a total of 4 frames instead of 8.\n   \n   - When you click on \"Show Neural Network\", only the Convolution feature\n   maps are displayed, not the max pooling ones.\n   \n   /// Hangman Game ///\n   \n   - This is the first time I try to make game logic within shaders. \n   Everything related to the hangman game state (word selection, update, game over) \n   happens inside the Buffer A. It's hard to test all cases and all side effects,\n   please let me know if you encounter something weird!\n   \n   - I split the 40 words into 10 arrays of 4 words (40 chars) because having a single \n   array of 40 words (400 chars) would alter the performances drastically. \n   It seems way more efficient to have 10 if/else rather than one big array lookup\n*/\n\n// Create text strings\nmakeString (printShowNN)      _S _h _o _w __ _N _e _u _r _a _l __ _N _e _t _w _o _r _k _end\nmakeString (printClickAny)    _bl __ _C _l _i _c _k __ _A _n _y _w _h _e _r _e __ _br _end\nmakeString (printShowGame)    _S _h _o _w __ _G _a _m _e __ _S _c _r _e _e _n _end\nmakeString (printFC)          _F _u _l _l _y __ _C _o _n _n _e _c _t _e _d _end\nmakeString (printCongrats)    _C _o _n _g _r _a _t _u _l _a _t _i _o _n _s _end\nmakeString (printOutputLayer) _O _u _t _p _u _t __ _L _a _y _e _r _end\nmakeString (printPrediction)  _P _r _e _d _i _c _t _i _o _n _dd _end\nmakeString (printInputLayer)  _D _r _a _w __ _A _r _e _a _end\nmakeString (printGameOver)    _G _a _m _e __ _O _v _e _r _end\nmakeString (printClear)       _C _l _e _a _r _end\nmakeStringI(printConv)        _C _o _n _v _o _l _u _t _i _o _n __ _dig(i) _end\nmakeStringI(printTry)         _T _r _y __ _qt _ch(i) _qt _end\n\n// Drawing\nfloat rect(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat seg(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    return .05/length(pa - ba*(clamp(dot(pa,ba)/dot(ba,ba), 0., 1.)));\n}\nvec3 drawHangman(vec2 uv, float missed) {\n    vec2 d = vec2(0);\n    missed *= max(1., 11./MAX_ATTEMPTS);\n    \n    d += seg(uv,-vec2(1, 0  ), vec2(1,   0  )) * vec2(step(1. , missed), 1);     \n    d += seg(uv, vec2(0, 0  ), vec2(0,   10 )) * vec2(step(1.5, missed), 1);\n    d += seg(uv, vec2(0, 10 ), vec2(7,   10 )) * vec2(step(3. , missed), 1);\n    d += seg(uv, vec2(0, 8  ), vec2(2,   10 )) * vec2(step(4. , missed), 1);\n    d += seg(uv, vec2(5, 10 ), vec2(5,   7.3)) * vec2(step(5. , missed), 1);\n    d += .07/abs(length(uv - vec2(5,6.5))-.75) * vec2(step(6. , missed), 1);\n    d += seg(uv, vec2(5, 5.7), vec2(5  , 3.5)) * vec2(step(7. , missed), 1);\n    d += seg(uv, vec2(5, 3.5), vec2(4.3, 1.5)) * vec2(step(8. , missed), 1);\n    d += seg(uv, vec2(5, 3.5), vec2(5.5, 1.5)) * vec2(step(9. , missed), 1);\n    d += seg(uv, vec2(5, 4.5), vec2(3.5, 6  )) * vec2(step(10., missed), 1);\n    d += seg(uv, vec2(5, 4.5), vec2(6.5, 6  )) * vec2(step(11., missed), 1);\n   \n    return vec3(d.y*.25 + d.x*1.25);\n}\n// Color palette\nvec3 pal(float x) {\n    return cos(6.28318*(vec3(1.18)*x*.1-vec3(2.642, 2.392, 2.322)))*.5+.5;\n}\n\n// Displays a portion of a texture containing feature map data\n// p : normalized uv coordinates (0-1)\n// s : scaling factor\n// r.xy : x/y start (in pixels)\n// r.zw : x/y end   (in pixels)\nvec3 displayFeatureMaps(vec2 p, vec2 s, vec4 r, float feature_maps_count, sampler2D smp) { \n    p = p*s + vec2(1.-s.x,0)/2.; // scale and center uvs\n    \n    float fp = 1./feature_maps_count;\n    float id = floor(p.x*feature_maps_count); // current feature map id\n    float m = 1.1; // border width\n    \n    // check bounds\n    if (min(p.x,p.y) < 0. || max(p.x,p.y) > 1. || abs(mod(p.x, fp) - fp*.5) > fp/m/2. || abs(p.y-.5) > 1./m/2.) \n        return vec3(0);\n    \n    m *= .999;               // fix overflow issue\n    p *= m;                  // scale down\n    p.x -= (m-1.) * id * fp; // offset x from id\n    p.x -= (m-1.) * .5 * fp; // re-center x\n    p.y -= (m-1.) * .5;      // re-center y\n    p *= r.zw / R;           // crop\n    p.xy += r.xy/R;          // offset origin\n    \n    float val = texture(smp, p).r; // Get value\n    return pal(val); // Return mapped color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / R;\n    vec3 col;\n    \n    vec4 hangData = texelFetch(iChannel0, ivec2(0, R.y-1.), 0);\n    vec2 predData = texelFetch(iChannel2, ivec2(num_classes, 1), 0).rg; // r: index, g: confidence\n        \n    uv.x *= iAspect;\n\n    // Left part of the screen (visualizations)\n    if (uv.x < iAspect - 1.) {\n        // Display Game Screen\n        if (hangData.a == 0.) {\n            // \"Show Neural Network\" button\n            if (uv.y < .11) {      \n                col += printShowNN(uv*11.5 - vec2(0,.1));\n            }\n            else {\n                // Draw hangman\n                float highlightAmount = hangData.b / MAX_ATTEMPTS;\n                vec3 highlightColor = mix(vec3(0,1,0), vec3(1,.4,.1), abs(hangData.r-1.));\n                vec3 hangmanColor = mix(vec3(1), highlightColor*(1.2+sin(iTime*(1.+highlightAmount*3.))*.25), highlightAmount);\n                col += drawHangman(uv*20. - vec2(4,8.5), hangData.b) * hangmanColor;\n\n                uv = fragCoord / R / vec2(iR, 1) - vec2(0, .2);\n                vec2 id = floor(uv*13.);\n                \n                // Draw alphabet\n                if (abs(id.y+.5) < 1.) {\n                    float char_state = texelFetch(iChannel0, ivec2(id.x - id.y*13., R.y-3.), 0).r;\n                    col += char(iChannel3, uv*vec2(13.,13.5) - id, 65 + int(id.x) - int(id.y)*13) *\n                           mix(mix(vec3(1), vec3(0,1,0), char_state), vec3(1,0,0), clamp(char_state-1., 0., 1.));\n                }\n                else {\n                    uv.x -= .13;\n                    uv *= vec2(1.12, .8);\n                    id = floor(uv*13.);\n                    \n                    float current_word_size = texelFetch(iChannel0, ivec2(1, R.y-1.), 0).b;\n                    \n                    // Draw current word\n                    if (id.x >= 0. && id.x < current_word_size && id.y == 1.) {\n                        vec2 char_state = texelFetch(iChannel0, ivec2(id.x, R.y-2.), 0).rg;\n                        vec3 char_color = hangData.r == 1. ? vec3(0,1,0) : hangData.r == 2. ? vec3(1,0,0) : vec3(1);\n                        col += char(iChannel3, (uv*13. - id + vec2(.5,0))*vec2(.55,1), char_state.y == 0. ? 95 : int(char_state.x)) * char_color;\n                    }\n                }\n            }\n        }\n        // Display Neural Network Screen\n        else {\n            // \"Show Game Screen\" button\n            if (uv.y < .11) {      \n                col += printShowGame(uv*11.5 - vec2(.6,.1));\n            }\n            // Prediction panel\n            else if (uv.y < .22) { \n                uv = vec2(uv.x - .1, uv.y - .12) * 12.;\n                col += vec3(1,0,0) * char(iChannel3, uv*.7 - vec2(3.5,-.15), 65 + int(predData.x));\n                col = mix(pal(predData.y*3.), col, length(col));\n                col = mix(col, 1.-col, printPrediction(uv));\n            }\n            // Output panel\n            else if (uv.y < .47) {\n                // Transform to upper right area\n                vec2 tuv = vec2(uv.x / (iAspect - 1.), (uv.y-.22) / (.43-.22));\n                // Current output index\n                float idx = floor(tuv.x * num_classes);\n\n                // Output value for the current index\n                float val = texelFetch(iChannel2, ivec2(int(idx), 1), 0).r;\n                // Apply the softmax function\n                val = val; \n\n                // Draw bars\n                col = mix(vec3(1,0,0), vec3(0,1,0), val) * smoothstep(0., .01, val - tuv.y);   \n                col = pal(val*2.5) * smoothstep(0., .01, val - tuv.y);\n\n                // Draw \"output\" text\n                uv = vec2(uv.x, uv.y-.41) * 22.;\n                col += printOutputLayer(uv);\n\n                // Draw digits\n                tuv = vec2(fract(tuv.x*num_classes), tuv.y*4.);\n                col += vec3(char(iChannel3, tuv, 65 + int(idx))); \n            }\n            // Fully connected layer\n            else if (uv.y < .5) {\n                vec2 tuv = vec2(uv.x / (iAspect - 1.), (uv.y-.47) / (.48-.47));\n                float id = floor(tuv.x * 16. * f6);\n                float x = mod(id, 4.*f6);\n                float y = floor(id / (4.*f6));\n\n                col = pal(texelFetch(iChannel1, ivec2(x,y+24.+10.), 0).r);\n            }\n            // Feature maps\n            else {\n                // Display texts\n                uv = (uv - vec2(0,.96)) * 24.;\n                col += printConv(uv, 1);\n\n                uv.y += 3.;\n                col += printConv(uv, 2);\n\n                uv.y += 2.85;\n                col += printConv(uv, 3);\n\n                uv.y += 2.5;\n                col += printConv(uv, 4);\n\n                uv.y += 2.4;\n                col += printFC(uv);\n\n                // Display feature maps\n                uv  = fragCoord / R;\n                uv.x = uv.x / iR;\n\n                uv.y -= .88;\n                col += displayFeatureMaps(uv, 1.4*vec2(10./f1,12), vec4(0, 0, 26.*f1, 26), f1, iChannel0);\n                uv.y += .115;\n                col += displayFeatureMaps(uv, 1.44*vec2(10./f2,12.), vec4(0, 0, 24.*f2, 24), f2, iChannel1);\n\n                uv.y += .11;\n                col += displayFeatureMaps(uv, 1.48*vec2(10./f4,12.), vec4(0, 24, 10.*f4, 10), f4, iChannel1);\n\n                uv.y += .1;\n                col += displayFeatureMaps(uv, 1.52*vec2(10./f5,12.), vec4(0, 26+12, 8.*f5, 8), f5, iChannel0);\n\n            }\n        }\n    }\n    // Right part of the screen\n    else {\n        // Display input layer\n        uv.x = uv.x - iAspect + 1.;\n        col += printInputLayer((uv-vec2(0,.9))*15.);\n        col += texture(iChannel0, fragCoord / R).r;\n        \n        // \"Clear\" button\n        uv *= 10.;\n        uv.x -= 1.;\n        col += printClear(uv);\n        col += vec3(1,.8,0.2) * .1 / abs(rect(uv - vec2(1.75,0), vec2(2,1)))*.25;\n        \n        // \"Try\" button\n        uv.x -= 4.2;\n        col += printTry(uv, int(predData.x));\n        col += vec3(0.14,1,0.31) * .1 / abs(rect(uv - vec2(2,0), vec2(2,1)))*.25; \n    }\n    \n    // Switch screen button (contour only)\n    uv = fragCoord / R;\n    col += vec3(0.14,1,1.) * .002 / abs(rect(uv-vec2(iR/2.,0), vec2(.95*iR/2.,.1)));\n\n    // Game over messages\n    if (hangData.r > 0.) {\n        vec3 tint = mix(vec3(0,.9,0), vec3(.9,0,0), hangData.r-1.);\n        \n        // WIP: I need to redo all this to properly center\n        // the game over messages\n        uv = fragCoord / R;\n        uv.y -= .5;\n        uv.y *= 4.;\n        uv.y += .5 ;\n        \n        uv.x -= .7 - mix(.22, .15, hangData.r-1.);\n        uv.x *= 3.;\n        uv.y -= .33;\n        uv.x *= iAspect;\n        uv *= 3.;\n        col += (hangData.r == 1. ? printCongrats(uv) : printGameOver(uv)) * tint;\n        \n        uv += vec2(.5, 2.1);\n        uv *= 1.4;\n        col += printClickAny(uv);\n        \n        uv = fragCoord / R;\n        col += .002 / abs(rect(uv - vec2(.7, .5), vec2(.24, .1))) * tint;\n    }\n    \n    col += .001 / abs(uv.x - iR); // Vertical Separator\n         \n    fragColor = vec4(col, 1);    \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* This buffers handles the hangman game data and the input layer */\n\n// Is a character at a specific index in the hidden word ?\nbool isCharAtPos(float char, int pos) {\n    float charAtPos = texelFetch(iChannel0, ivec2(pos, R.y-2.), 0).r;\n    return charAtPos-65. == char;\n}\n\n// Is a character part of the hidden word ?\nbool isCharInWord(float char) {    \n    for (int i = 0; i < word_size; i++)\n        if (isCharAtPos(char, i)) \n            return true;     \n    return false;\n}\n\n// Is the hidden word fully discoverd ?\nbool isGameWon(float wordLength) {\n    float charsFound = 0.;\n    for (int i = 0; i < word_size; i++) {\n        charsFound += min(1., texelFetch(iChannel0, ivec2(i, R.y-2.), 0).g);\n    }\n    return charsFound >= wordLength;\n}\n\n// Get the hidden word's total length\nfloat getCurrentWordLength() {\n    for (int i = 0; i < word_size; i++) {\n        if (texelFetch(iChannel0, ivec2(i, R.y-2.), 0).r == 0.) \n            return float(i);\n    }\n    return float(word_size);\n}\n\n// Random value - https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(p*p*2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / R;\n    vec2  m = iMouse.xy / R;\n    ivec2 F = ivec2(fragCoord - .5);\n\n    vec4 hangData = texelFetch(iChannel0, ivec2(0, R.y-1.), 0);\n    vec4 predData = texelFetch(iChannel0, ivec2(1, R.y-1.), 0);\n    vec4 col = texture(iChannel0, uv);\n    \n    bool clickOnTry = iMouse.z > 0. && m.y < .1 && m.x > iR/2.+.5 && hangData.g == 0.;\n    bool resetGame  = iFrame == 0 ||                                // Reset game on the first frame\n              predData.a != iResolution.x ||                        // Or if the resolution has changed\n              iMouse.z > 0. && hangData.r > 0. && hangData.g == 0.; // Or on the first click after a game over\n    \n    if (resetGame) col *= 0.;\n    \n    // 2 frames after a new game started, fake a click on \"Try\"\n    if (iFrame == int(predData.g)+2) {\n        // Set the prediction to the first letter of the hidden word\n        predData.r = texelFetch(iChannel0, ivec2(0, R.y-2.), 0).r-65.;\n        clickOnTry = true;\n    }\n    \n    // On manual character selection (direct click), fake \"Try\"\n    vec2 id = floor((m  / vec2(iR, 1) - vec2(0, .2))*13.);\n    if (iMouse.z > 0. && abs(id.y+.5) < 1. && id.x < 13. && hangData.g == 0. && !resetGame && float(iFrame)-predData.g > 2.) {\n        // Set the prediction to the character located at the mouse position\n        predData.r = id.x - 13.*id.y;\n        clickOnTry = true;\n    }\n\n    // Game state management 1\n    // r: game state   (0: playing,  1: win, 2: lose), \n    // g: click memory (0: no click, 1: click on last frame + reset canvas flag, 2: click on last frame), \n    // b: missed char count, \n    // a: left panel state (0: game, 1: neural network)\n    if (F.x == 0 && F.y == int(R.y)-1) {        \n        // Wait for mouse release\n        if (col.g >= 1.) {\n            if (iMouse.z <= 0.) col.g = 0.;\n        }\n        // Clicked on \"Try\" button\n        else if (clickOnTry) {\n            // Get current network prediction\n            float char = predData.r;\n            \n            // Is the character in the hidden word ?\n            bool isInWord = isCharInWord(char); \n            // Has the character been already tried ?\n            bool alreadyTried = texelFetch(iChannel0, ivec2(int(char), R.y-3.), 0).r > 0.;\n            \n            // On a new failed attempt, increase the missed character count\n            if (!isInWord && !alreadyTried) col.b++;                    \n\n            // Remember that mouse is clicked\n            col.g = 1.;   \n        }\n        // Clicked on \"Show Game/Neural Network\" button\n        else if (iMouse.z > 0. && m.y < .1 && m.x < iR) {\n            // Invert the left panel state\n            col.a = 1. - col.a;\n            // Remember that mouse is clicked\n            col.g = 2.;\n        }\n        else if (iMouse.z > 0.)\n            col.g = 2.;\n          \n        // Game win\n        if (isGameWon(predData.b) && !resetGame && predData.b > 0. && hangData.r == 0.)\n            col.r = 1.;\n        // Game over\n        else if (col.b >= MAX_ATTEMPTS)\n            col.r = 2.;  \n    }\n    // Game state management 2\n    // r: current prediction \n    // g: frame at game start \n    // b: current word length\n    // a: current resolution x\n    else if (F.x == 1 && F.y == int(R.y)-1) { \n        // Upon starting a new game, store the current frame number\n        if (resetGame) {\n            col.g = float(iFrame);\n        }\n        \n        // 1 frame after starting a new game, store the current word length\n        if (iFrame == int(predData.g)+1) {\n            col.b = getCurrentWordLength();\n        } \n        // On every other frame, retrieve the prediction from Buffer D\n        else {\n            col.r = texelFetch(iChannel1, ivec2(int(num_classes), 1), 0).r;\n        }\n        \n        // Store the current width to detect canvas resize\n        col.a = iResolution.x;\n    }\n    // Hidden word management\n    // [0, word_size-1], \n    // r: char ID, \n    // g: char state (0: undiscovered, >=1: discovered)\n    else if (F.x < word_size && F.y == int(R.y)-2) {\n        // Upon starting a new game, select a new random word from the dictionary\n        if (resetGame) {\n            float rng = hash11(iDate.w) * 10.;\n            float id = floor(rng);\n            int[40] words;\n            \n            if      (id == 0.) words = words0;\n            else if (id == 1.) words = words1;\n            else if (id == 2.) words = words2;\n            else if (id == 3.) words = words3;\n            else if (id == 4.) words = words4;\n            else if (id == 5.) words = words5;\n            else if (id == 6.) words = words6;\n            else if (id == 7.) words = words7;\n            else if (id == 8.) words = words8;\n            else               words = words9;\n\n            id = floor(hash11(rng+iTime+iDate.w) * 4.);\n            int charIndex = int(id) * word_size + F.x;\n            col.r = float(words[charIndex]);\n        }\n        \n        // Update when click \"Try\"\n        if (clickOnTry) {\n            // Increment the current character state upon a click if the\n            // character is valid regarding the current prediction\n            col.g += float(isCharAtPos(predData.r, F.x));\n        }\n        \n        // Force show hidden word on game over\n        if (hangData.b >= MAX_ATTEMPTS && !resetGame) col.g = 1.;\n    }\n    // Alphabet management\n    // for pixels x in [0, 26], 0: not tried, 1: success, 2: failed\n    else if (F.x < 26 && F.y == int(R.y)-3) {\n        // Update only the corresponding character when click \"Try\"\n        if (clickOnTry && float(F.x) == predData.r) {\n            col.r = isCharInWord(predData.r) ? 1. : 2.;\n        }\n    }\n    // Drawing\n    else {\n        bool clickOnClear = iMouse.z > 0. && m.y < .1 && m.x > iR && m.x < iR/2.+.5 && hangData.g == 0.;\n        vec2  m = (iMouse.xy - fragCoord) / R.y;\n        float d = smoothstep(.06, 0., length(m)); // \"Pen\" intensity\n        d *= step(0., iMouse.z);                  // Only draw on mouse press\n        col = clamp(col + d, 0., 1.);             // Clamp in [0-1] range\n                \n        // Clear canvas conditions\n        if (resetGame || clickOnClear || clickOnTry || hangData.g == 1.) col *= 0.;\n    }\n            \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/* This buffers handles:\n   - Convolution #1 (Step 1)\n   - Max Pooling #1 (Step 3)\n   - Convolution #4 (Step 5)\n*/\n\n// Draw area margin\nconst float margin = .15;\n\n// Get normalized input pixel\n// p: [0, input_res-1]\nfloat i(vec2 p) {  \n    p = vec2((p.x+.5) / iAspect, p.y+.5) / input_res;\n    \n    p *= (1. - margin);\n    p.x += margin*.5/iAspect + iR;\n    p.y += margin;    \n    \n    return textureLod(iChannel0, p, log2(iResolution.y/input_res)).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 uv = fragCoord / R;\n    vec2 F  = fragCoord -.5; // Pixel coordinates\n\n    // Copy all the game management data from the Buffer A to Buffer B \n    // in order to have access to it inside the Image tab\n    vec4 col = texture(iChannel0, uv); \n    \n    // CNN Step 1: Convolution #1\n    // 1x28x28 => 8x26x26\n    if (F.x < f1 * F1 && F.y < F1) {\n        int fmap = int(F.x / F1);\n        vec2   p = mod(F, F1);\n        float  x;\n      \n        if      (fmap == 0) x = -.1486 *i(p) + .1954 *i(p+vec2(1,0)) + .427  *i(p+vec2(2,0)) - .0972 *i(p+vec2(0,1)) + .6795 *i(p+vec2(1,1)) + .2573 *i(p+vec2(2,1)) + .363  *i(p+vec2(0,2)) + .481  *i(p+vec2(1,2)) + .6536 *i(p+vec2(2,2)) + .0017 ;\n        else if (fmap == 1) x = -.4872 *i(p) - .1346 *i(p+vec2(1,0)) + .2494 *i(p+vec2(2,0)) + .3854 *i(p+vec2(0,1)) + .023  *i(p+vec2(1,1)) - .0038 *i(p+vec2(2,1)) + .3377 *i(p+vec2(0,2)) - .2748 *i(p+vec2(1,2)) + .076  *i(p+vec2(2,2)) + .5066 ;\n        else if (fmap == 2) x = -.0647 *i(p) - .4726 *i(p+vec2(1,0)) - .2256 *i(p+vec2(2,0)) + .4003 *i(p+vec2(0,1)) - .2734 *i(p+vec2(1,1)) + .099  *i(p+vec2(2,1)) + .4775 *i(p+vec2(0,2)) + .4412 *i(p+vec2(1,2)) + .3696 *i(p+vec2(2,2)) + .1814 ;\n        else if (fmap == 3) x = -.05   *i(p) + .0491 *i(p+vec2(1,0)) - .8318 *i(p+vec2(2,0)) - 1.1349*i(p+vec2(0,1)) - .4355 *i(p+vec2(1,1)) + .0529 *i(p+vec2(2,1)) - .7672 *i(p+vec2(0,2)) - .2598 *i(p+vec2(1,2)) + .0783 *i(p+vec2(2,2)) + .6147 ;\n        else if (fmap == 4) x = -.5161 *i(p) + .5607 *i(p+vec2(1,0)) + .2497 *i(p+vec2(2,0)) + .2084 *i(p+vec2(0,1)) + .5713 *i(p+vec2(1,1)) + .5264 *i(p+vec2(2,1)) - .2486 *i(p+vec2(0,2)) + .44   *i(p+vec2(1,2)) + .3286 *i(p+vec2(2,2)) + .0896 ;\n        else if (fmap == 5) x = -.4547 *i(p) - .4105 *i(p+vec2(1,0)) - .343  *i(p+vec2(2,0)) - .0175 *i(p+vec2(0,1)) - .2769 *i(p+vec2(1,1)) - .2417 *i(p+vec2(2,1)) + .5793 *i(p+vec2(0,2)) + .5533 *i(p+vec2(1,2)) + .4434 *i(p+vec2(2,2)) + .2215 ;\n        else if (fmap == 6) x =  .5154 *i(p) + .3763 *i(p+vec2(1,0)) + .339  *i(p+vec2(2,0)) - .0752 *i(p+vec2(0,1)) - .0239 *i(p+vec2(1,1)) - .1771 *i(p+vec2(2,1)) - .2101 *i(p+vec2(0,2)) - .197  *i(p+vec2(1,2)) - .3623 *i(p+vec2(2,2)) + .2826 ;\n        else if (fmap == 7) x =  .4506 *i(p) + .4106 *i(p+vec2(1,0)) - .3482 *i(p+vec2(2,0)) + .2583 *i(p+vec2(0,1)) - .1089 *i(p+vec2(1,1)) + .2302 *i(p+vec2(2,1)) + .0907 *i(p+vec2(0,2)) + .0353 *i(p+vec2(1,2)) - .1514 *i(p+vec2(2,2)) + .3524 ;\n\n        x = max(x, 0.); // ReLU Activation\n        col = vec4(x);\n    }\n    // CNN Step 3: Max Pooling #1\n    // 8x24x24 => 8x12x12\n    else if (F.x < f3 * F3 && F.y >= F1 && F.y < F1+F3) {\n        ivec2 p = ivec2(F - vec2(0, F1)) * 2;\n        \n        float x = max(texelFetch(iChannel2, p, 0).r,\n                  max(texelFetch(iChannel2, p + ivec2(0,1), 0).r,\n                  max(texelFetch(iChannel2, p + ivec2(1,0), 0).r,\n                      texelFetch(iChannel2, p + ivec2(1,1), 0).r)));\n                      \n        col = vec4(x);\n    }\n    // CNN Step 5: Convolution #4\n    // 10x10x10 => 12x8x8\n    else if (F.x < f5 * F5 && F.y >= F1+F3 && F.y < F1+F3+F5) {\n        int fmap = int(F.x / F5);\n        vec2   p = mod(F - vec2(0, F1+F3), F5) + vec2(0,F2);\n        float  x;\n      \n#define i(p) texelFetch(iChannel2, ivec2(p), 0).r\n        if      (fmap == 0) x =  .1717 *i(p) + .0012 *i(p+vec2(1,0)) - .1371 *i(p+vec2(2,0)) + .1847 *i(p+vec2(0,1)) + .2594 *i(p+vec2(1,1)) + .1017 *i(p+vec2(2,1)) - .0267 *i(p+vec2(0,2)) + .0795 *i(p+vec2(1,2)) + .2231 *i(p+vec2(2,2)) - .0583 *i(p+vec2(10,0)) - .1075 *i(p+vec2(11,0)) + .0773 *i(p+vec2(12,0)) - .3083 *i(p+vec2(10,1)) - .1898 *i(p+vec2(11,1)) - .0764 *i(p+vec2(12,1)) + .0002 *i(p+vec2(10,2)) - .0215 *i(p+vec2(11,2)) - .0884 *i(p+vec2(12,2)) + .0629 *i(p+vec2(20,0)) + .0664 *i(p+vec2(21,0)) - .0046 *i(p+vec2(22,0)) - .2799 *i(p+vec2(20,1)) + .0045 *i(p+vec2(21,1)) - .1298 *i(p+vec2(22,1)) - .1148 *i(p+vec2(20,2)) - .0899 *i(p+vec2(21,2)) - .0816 *i(p+vec2(22,2)) - .4166 *i(p+vec2(30,0)) - .0873 *i(p+vec2(31,0)) + .1241 *i(p+vec2(32,0)) - .1414 *i(p+vec2(30,1)) - .5487 *i(p+vec2(31,1)) - .2681 *i(p+vec2(32,1)) + .0039 *i(p+vec2(30,2)) - .2715 *i(p+vec2(31,2)) - .3884 *i(p+vec2(32,2)) - .0653 *i(p+vec2(40,0)) - .2153 *i(p+vec2(41,0)) - .2112 *i(p+vec2(42,0)) - .1116 *i(p+vec2(40,1)) - .1208 *i(p+vec2(41,1)) + .0086 *i(p+vec2(42,1)) + .0283 *i(p+vec2(40,2)) + .0147 *i(p+vec2(41,2)) + .0494 *i(p+vec2(42,2)) - .0927 *i(p+vec2(50,0)) - .077  *i(p+vec2(51,0)) + .0732 *i(p+vec2(52,0)) - .2291 *i(p+vec2(50,1)) - .2871 *i(p+vec2(51,1)) - .526  *i(p+vec2(52,1)) + .1427 *i(p+vec2(50,2)) - .3165 *i(p+vec2(51,2)) + .1353 *i(p+vec2(52,2)) - .0638 *i(p+vec2(60,0)) - .0072 *i(p+vec2(61,0)) + .0515 *i(p+vec2(62,0)) + .1109 *i(p+vec2(60,1)) - .1146 *i(p+vec2(61,1)) + .0734 *i(p+vec2(62,1)) + .0375 *i(p+vec2(60,2)) - .1577 *i(p+vec2(61,2)) + .1842 *i(p+vec2(62,2)) + .2911 *i(p+vec2(70,0)) + .0838 *i(p+vec2(71,0)) + .0689 *i(p+vec2(72,0)) + .1487 *i(p+vec2(70,1)) + .0553 *i(p+vec2(71,1)) + .0174 *i(p+vec2(72,1)) + .0243 *i(p+vec2(70,2)) - .2392 *i(p+vec2(71,2)) + .1613 *i(p+vec2(72,2)) + .1344 *i(p+vec2(80,0)) + .0903 *i(p+vec2(81,0)) - .1227 *i(p+vec2(82,0)) + .0562 *i(p+vec2(80,1)) + .1674 *i(p+vec2(81,1)) - .1393 *i(p+vec2(82,1)) + .0731 *i(p+vec2(80,2)) + .1479 *i(p+vec2(81,2)) + .1782 *i(p+vec2(82,2)) + .0814 *i(p+vec2(90,0)) - .1057 *i(p+vec2(91,0)) - .0821 *i(p+vec2(92,0)) + .0028 *i(p+vec2(90,1)) - .0116 *i(p+vec2(91,1)) - .0844 *i(p+vec2(92,1)) - .0337 *i(p+vec2(90,2)) + .0807 *i(p+vec2(91,2)) + .2533 *i(p+vec2(92,2)) + .2085 ;\n        else if (fmap == 1) x =  .1388 *i(p) + .2866 *i(p+vec2(1,0)) + .1983 *i(p+vec2(2,0)) - .0839 *i(p+vec2(0,1)) - .1087 *i(p+vec2(1,1)) - .2104 *i(p+vec2(2,1)) + .026  *i(p+vec2(0,2)) + .1007 *i(p+vec2(1,2)) + .0632 *i(p+vec2(2,2)) - .2813 *i(p+vec2(10,0)) - .1038 *i(p+vec2(11,0)) - .0926 *i(p+vec2(12,0)) + .1379 *i(p+vec2(10,1)) + .2079 *i(p+vec2(11,1)) + .2068 *i(p+vec2(12,1)) + .0834 *i(p+vec2(10,2)) - .0244 *i(p+vec2(11,2)) - .0722 *i(p+vec2(12,2)) - .2332 *i(p+vec2(20,0)) + .0209 *i(p+vec2(21,0)) - .1158 *i(p+vec2(22,0)) - .1332 *i(p+vec2(20,1)) - .0935 *i(p+vec2(21,1)) - .1898 *i(p+vec2(22,1)) + .1412 *i(p+vec2(20,2)) - .0079 *i(p+vec2(21,2)) - .1441 *i(p+vec2(22,2)) - .1714 *i(p+vec2(30,0)) - .117  *i(p+vec2(31,0)) - .1441 *i(p+vec2(32,0)) + .2259 *i(p+vec2(30,1)) + .0978 *i(p+vec2(31,1)) - .0101 *i(p+vec2(32,1)) + .0245 *i(p+vec2(30,2)) - .006  *i(p+vec2(31,2)) + .0792 *i(p+vec2(32,2)) - .0364 *i(p+vec2(40,0)) - .1046 *i(p+vec2(41,0)) + .1095 *i(p+vec2(42,0)) - .0058 *i(p+vec2(40,1)) + .115  *i(p+vec2(41,1)) + .5827 *i(p+vec2(42,1)) - .1166 *i(p+vec2(40,2)) - .2658 *i(p+vec2(41,2)) + .205  *i(p+vec2(42,2)) - .1491 *i(p+vec2(50,0)) - .2093 *i(p+vec2(51,0)) + .1161 *i(p+vec2(52,0)) + .0342 *i(p+vec2(50,1)) + .0012 *i(p+vec2(51,1)) - .1078 *i(p+vec2(52,1)) - .249  *i(p+vec2(50,2)) - .0472 *i(p+vec2(51,2)) - .4205 *i(p+vec2(52,2)) + .2256 *i(p+vec2(60,0)) + .092  *i(p+vec2(61,0)) + .1221 *i(p+vec2(62,0)) + .2281 *i(p+vec2(60,1)) - .1039 *i(p+vec2(61,1)) - .2234 *i(p+vec2(62,1)) - .0922 *i(p+vec2(60,2)) - .1282 *i(p+vec2(61,2)) - .011  *i(p+vec2(62,2)) + .1871 *i(p+vec2(70,0)) + .2398 *i(p+vec2(71,0)) - .0584 *i(p+vec2(72,0)) - .4436 *i(p+vec2(70,1)) - .4083 *i(p+vec2(71,1)) - .2    *i(p+vec2(72,1)) + .1498 *i(p+vec2(70,2)) - .0439 *i(p+vec2(71,2)) + .0748 *i(p+vec2(72,2)) - .1496 *i(p+vec2(80,0)) - .0846 *i(p+vec2(81,0)) - .1014 *i(p+vec2(82,0)) + .0065 *i(p+vec2(80,1)) - .0029 *i(p+vec2(81,1)) - .022  *i(p+vec2(82,1)) - .106  *i(p+vec2(80,2)) - .0235 *i(p+vec2(81,2)) + .1248 *i(p+vec2(82,2)) + .0463 *i(p+vec2(90,0)) - .1198 *i(p+vec2(91,0)) - .0198 *i(p+vec2(92,0)) + .0643 *i(p+vec2(90,1)) + .0958 *i(p+vec2(91,1)) - .0855 *i(p+vec2(92,1)) + .0257 *i(p+vec2(90,2)) - .0637 *i(p+vec2(91,2)) - .065  *i(p+vec2(92,2)) - .0077 ;\n        else if (fmap == 2) x = -.1831 *i(p) - .0739 *i(p+vec2(1,0)) - .0482 *i(p+vec2(2,0)) - .0522 *i(p+vec2(0,1)) - .1425 *i(p+vec2(1,1)) - .0014 *i(p+vec2(2,1)) - .109  *i(p+vec2(0,2)) - .2125 *i(p+vec2(1,2)) - .162  *i(p+vec2(2,2)) + .1057 *i(p+vec2(10,0)) + .0366 *i(p+vec2(11,0)) - .0064 *i(p+vec2(12,0)) - .0039 *i(p+vec2(10,1)) - .0134 *i(p+vec2(11,1)) - .119  *i(p+vec2(12,1)) - .3047 *i(p+vec2(10,2)) - .0425 *i(p+vec2(11,2)) + .0075 *i(p+vec2(12,2)) + .0817 *i(p+vec2(20,0)) + .0231 *i(p+vec2(21,0)) + .095  *i(p+vec2(22,0)) + .0743 *i(p+vec2(20,1)) + .025  *i(p+vec2(21,1)) - .243  *i(p+vec2(22,1)) - .0114 *i(p+vec2(20,2)) - .087  *i(p+vec2(21,2)) - .0222 *i(p+vec2(22,2)) + .169  *i(p+vec2(30,0)) + .1383 *i(p+vec2(31,0)) + .0737 *i(p+vec2(32,0)) - .032  *i(p+vec2(30,1)) - .0197 *i(p+vec2(31,1)) - .0772 *i(p+vec2(32,1)) - .1133 *i(p+vec2(30,2)) - .1718 *i(p+vec2(31,2)) - .2342 *i(p+vec2(32,2)) - .0867 *i(p+vec2(40,0)) - .0206 *i(p+vec2(41,0)) - .0595 *i(p+vec2(42,0)) + .0946 *i(p+vec2(40,1)) + .0069 *i(p+vec2(41,1)) + .0947 *i(p+vec2(42,1)) + .2194 *i(p+vec2(40,2)) + .0968 *i(p+vec2(41,2)) - .1394 *i(p+vec2(42,2)) + .094  *i(p+vec2(50,0)) + .0779 *i(p+vec2(51,0)) + .0774 *i(p+vec2(52,0)) + .1327 *i(p+vec2(50,1)) + .2157 *i(p+vec2(51,1)) + .1759 *i(p+vec2(52,1)) - .2227 *i(p+vec2(50,2)) - .0284 *i(p+vec2(51,2)) + .0705 *i(p+vec2(52,2)) + .1853 *i(p+vec2(60,0)) - .1505 *i(p+vec2(61,0)) + .1193 *i(p+vec2(62,0)) + .1821 *i(p+vec2(60,1)) + .0678 *i(p+vec2(61,1)) + .1168 *i(p+vec2(62,1)) + .3405 *i(p+vec2(60,2)) + .0973 *i(p+vec2(61,2)) + .2893 *i(p+vec2(62,2)) + .1693 *i(p+vec2(70,0)) + .1193 *i(p+vec2(71,0)) + .1831 *i(p+vec2(72,0)) + .1787 *i(p+vec2(70,1)) + .2097 *i(p+vec2(71,1)) + .1993 *i(p+vec2(72,1)) + .234  *i(p+vec2(70,2)) + .1566 *i(p+vec2(71,2)) + .2383 *i(p+vec2(72,2)) - .0021 *i(p+vec2(80,0)) - .0571 *i(p+vec2(81,0)) - .094  *i(p+vec2(82,0)) + .0641 *i(p+vec2(80,1)) + .0402 *i(p+vec2(81,1)) + .0272 *i(p+vec2(82,1)) - .0084 *i(p+vec2(80,2)) + .1278 *i(p+vec2(81,2)) + .1751 *i(p+vec2(82,2)) - .1039 *i(p+vec2(90,0)) - .1036 *i(p+vec2(91,0)) - .0678 *i(p+vec2(92,0)) + .0692 *i(p+vec2(90,1)) - .2346 *i(p+vec2(91,1)) - .2681 *i(p+vec2(92,1)) - .1256 *i(p+vec2(90,2)) - .1729 *i(p+vec2(91,2)) - .3839 *i(p+vec2(92,2)) - .0125 ;\n        else if (fmap == 3) x =  .0027 *i(p) + .0867 *i(p+vec2(1,0)) - .0223 *i(p+vec2(2,0)) - .2435 *i(p+vec2(0,1)) - .2366 *i(p+vec2(1,1)) - .1966 *i(p+vec2(2,1)) + .0307 *i(p+vec2(0,2)) - .1586 *i(p+vec2(1,2)) - .1794 *i(p+vec2(2,2)) + .1802 *i(p+vec2(10,0)) + .1997 *i(p+vec2(11,0)) - .0889 *i(p+vec2(12,0)) + .014  *i(p+vec2(10,1)) - .1604 *i(p+vec2(11,1)) - .0232 *i(p+vec2(12,1)) - .0783 *i(p+vec2(10,2)) - .1544 *i(p+vec2(11,2)) - .0899 *i(p+vec2(12,2)) + .1446 *i(p+vec2(20,0)) + .0598 *i(p+vec2(21,0)) + .1455 *i(p+vec2(22,0)) + .1949 *i(p+vec2(20,1)) + .0473 *i(p+vec2(21,1)) - .031  *i(p+vec2(22,1)) + .0236 *i(p+vec2(20,2)) + .0463 *i(p+vec2(21,2)) + .1564 *i(p+vec2(22,2)) - .1685 *i(p+vec2(30,0)) + .0249 *i(p+vec2(31,0)) - .0171 *i(p+vec2(32,0)) - .2813 *i(p+vec2(30,1)) - .2186 *i(p+vec2(31,1)) - .228  *i(p+vec2(32,1)) + .1404 *i(p+vec2(30,2)) + .2468 *i(p+vec2(31,2)) + .2146 *i(p+vec2(32,2)) - .008  *i(p+vec2(40,0)) + .2399 *i(p+vec2(41,0)) + .4419 *i(p+vec2(42,0)) - .0344 *i(p+vec2(40,1)) + .0765 *i(p+vec2(41,1)) + .2634 *i(p+vec2(42,1)) - .1237 *i(p+vec2(40,2)) - .1453 *i(p+vec2(41,2)) + .0663 *i(p+vec2(42,2)) + .0224 *i(p+vec2(50,0)) + .0323 *i(p+vec2(51,0)) + .0883 *i(p+vec2(52,0)) - .2062 *i(p+vec2(50,1)) - .1655 *i(p+vec2(51,1)) + .0245 *i(p+vec2(52,1)) - .1144 *i(p+vec2(50,2)) + .0463 *i(p+vec2(51,2)) + .0973 *i(p+vec2(52,2)) + .1838 *i(p+vec2(60,0)) + .2633 *i(p+vec2(61,0)) + .1142 *i(p+vec2(62,0)) - .3107 *i(p+vec2(60,1)) - .1468 *i(p+vec2(61,1)) + .0853 *i(p+vec2(62,1)) + .0703 *i(p+vec2(60,2)) + .0477 *i(p+vec2(61,2)) + .0502 *i(p+vec2(62,2)) - .0259 *i(p+vec2(70,0)) + .1534 *i(p+vec2(71,0)) + .1713 *i(p+vec2(72,0)) - .0275 *i(p+vec2(70,1)) + .0198 *i(p+vec2(71,1)) + .0759 *i(p+vec2(72,1)) - .0529 *i(p+vec2(70,2)) - .1119 *i(p+vec2(71,2)) - .0181 *i(p+vec2(72,2)) - .0454 *i(p+vec2(80,0)) + .0438 *i(p+vec2(81,0)) + .0438 *i(p+vec2(82,0)) + .0515 *i(p+vec2(80,1)) + .0702 *i(p+vec2(81,1)) + .2139 *i(p+vec2(82,1)) + .0153 *i(p+vec2(80,2)) - .0453 *i(p+vec2(81,2)) + .0501 *i(p+vec2(82,2)) - .16   *i(p+vec2(90,0)) - .1239 *i(p+vec2(91,0)) - .0831 *i(p+vec2(92,0)) + .0275 *i(p+vec2(90,1)) - .1382 *i(p+vec2(91,1)) - .0978 *i(p+vec2(92,1)) - .0615 *i(p+vec2(90,2)) + .034  *i(p+vec2(91,2)) - .0646 *i(p+vec2(92,2)) + .0153 ;\n        else if (fmap == 4) x =  .1387 *i(p) + .0721 *i(p+vec2(1,0)) + .046  *i(p+vec2(2,0)) - .082  *i(p+vec2(0,1)) - .1704 *i(p+vec2(1,1)) - .0429 *i(p+vec2(2,1)) - .1359 *i(p+vec2(0,2)) + .0758 *i(p+vec2(1,2)) - .0288 *i(p+vec2(2,2)) - .0414 *i(p+vec2(10,0)) - .0152 *i(p+vec2(11,0)) - .0405 *i(p+vec2(12,0)) + .1386 *i(p+vec2(10,1)) + .0615 *i(p+vec2(11,1)) - .1058 *i(p+vec2(12,1)) + .07   *i(p+vec2(10,2)) - .0085 *i(p+vec2(11,2)) + .1098 *i(p+vec2(12,2)) + .1563 *i(p+vec2(20,0)) + .0777 *i(p+vec2(21,0)) + .0121 *i(p+vec2(22,0)) + .0215 *i(p+vec2(20,1)) + .0036 *i(p+vec2(21,1)) + .1072 *i(p+vec2(22,1)) - .0137 *i(p+vec2(20,2)) + .0705 *i(p+vec2(21,2)) - .074  *i(p+vec2(22,2)) - .13   *i(p+vec2(30,0)) - .1525 *i(p+vec2(31,0)) + .0453 *i(p+vec2(32,0)) - .2191 *i(p+vec2(30,1)) - .2683 *i(p+vec2(31,1)) - .111  *i(p+vec2(32,1)) - .1348 *i(p+vec2(30,2)) + .0868 *i(p+vec2(31,2)) + .1374 *i(p+vec2(32,2)) - .0386 *i(p+vec2(40,0)) - .105  *i(p+vec2(41,0)) - .2427 *i(p+vec2(42,0)) + .1577 *i(p+vec2(40,1)) + .1214 *i(p+vec2(41,1)) + .1003 *i(p+vec2(42,1)) + .2907 *i(p+vec2(40,2)) + .1859 *i(p+vec2(41,2)) + .2077 *i(p+vec2(42,2)) - .1183 *i(p+vec2(50,0)) - .1242 *i(p+vec2(51,0)) - .1365 *i(p+vec2(52,0)) + .1    *i(p+vec2(50,1)) + .0243 *i(p+vec2(51,1)) + .0483 *i(p+vec2(52,1)) + .2559 *i(p+vec2(50,2)) + .0269 *i(p+vec2(51,2)) + .016  *i(p+vec2(52,2)) + .0757 *i(p+vec2(60,0)) + .159  *i(p+vec2(61,0)) + .2101 *i(p+vec2(62,0)) - .1736 *i(p+vec2(60,1)) - .2983 *i(p+vec2(61,1)) - .2183 *i(p+vec2(62,1)) - .0529 *i(p+vec2(60,2)) - .0714 *i(p+vec2(61,2)) - .0361 *i(p+vec2(62,2)) + .0584 *i(p+vec2(70,0)) + .0031 *i(p+vec2(71,0)) + .0459 *i(p+vec2(72,0)) - .054  *i(p+vec2(70,1)) + .0249 *i(p+vec2(71,1)) + .0757 *i(p+vec2(72,1)) - .0806 *i(p+vec2(70,2)) + .0082 *i(p+vec2(71,2)) + .0705 *i(p+vec2(72,2)) - .0756 *i(p+vec2(80,0)) - .1537 *i(p+vec2(81,0)) - .2918 *i(p+vec2(82,0)) - .1167 *i(p+vec2(80,1)) - .1644 *i(p+vec2(81,1)) - .3289 *i(p+vec2(82,1)) + .3718 *i(p+vec2(80,2)) + .2903 *i(p+vec2(81,2)) + .088  *i(p+vec2(82,2)) - .1489 *i(p+vec2(90,0)) - .0731 *i(p+vec2(91,0)) - .1689 *i(p+vec2(92,0)) + .0867 *i(p+vec2(90,1)) - .0945 *i(p+vec2(91,1)) - .0229 *i(p+vec2(92,1)) + .1268 *i(p+vec2(90,2)) + .0571 *i(p+vec2(91,2)) + .0265 *i(p+vec2(92,2)) + .1925 ;\n        else if (fmap == 5) x = -.1357 *i(p) - .1096 *i(p+vec2(1,0)) - .0193 *i(p+vec2(2,0)) - .0206 *i(p+vec2(0,1)) - .0536 *i(p+vec2(1,1)) + .0662 *i(p+vec2(2,1)) - .0432 *i(p+vec2(0,2)) + .1011 *i(p+vec2(1,2)) + .1329 *i(p+vec2(2,2)) + .1413 *i(p+vec2(10,0)) - .036  *i(p+vec2(11,0)) - .0694 *i(p+vec2(12,0)) - .1633 *i(p+vec2(10,1)) - .0484 *i(p+vec2(11,1)) - .0637 *i(p+vec2(12,1)) - .0722 *i(p+vec2(10,2)) - .0552 *i(p+vec2(11,2)) - .197  *i(p+vec2(12,2)) - .0489 *i(p+vec2(20,0)) - .0637 *i(p+vec2(21,0)) + .0289 *i(p+vec2(22,0)) - .2165 *i(p+vec2(20,1)) - .0729 *i(p+vec2(21,1)) - .0419 *i(p+vec2(22,1)) + .0018 *i(p+vec2(20,2)) - .0012 *i(p+vec2(21,2)) + .1395 *i(p+vec2(22,2)) + .0428 *i(p+vec2(30,0)) - .1156 *i(p+vec2(31,0)) - .3186 *i(p+vec2(32,0)) - .3055 *i(p+vec2(30,1)) - .1916 *i(p+vec2(31,1)) - .1304 *i(p+vec2(32,1)) + .1032 *i(p+vec2(30,2)) - .0326 *i(p+vec2(31,2)) - .0356 *i(p+vec2(32,2)) + .1811 *i(p+vec2(40,0)) + .2027 *i(p+vec2(41,0)) + .0592 *i(p+vec2(42,0)) + .3487 *i(p+vec2(40,1)) + .2046 *i(p+vec2(41,1)) + .0115 *i(p+vec2(42,1)) + .2386 *i(p+vec2(40,2)) + .1159 *i(p+vec2(41,2)) + .2392 *i(p+vec2(42,2)) + .1151 *i(p+vec2(50,0)) + .0338 *i(p+vec2(51,0)) + .04   *i(p+vec2(52,0)) - .008  *i(p+vec2(50,1)) - .1031 *i(p+vec2(51,1)) - .028  *i(p+vec2(52,1)) - .0997 *i(p+vec2(50,2)) - .1737 *i(p+vec2(51,2)) - .4336 *i(p+vec2(52,2)) + .064  *i(p+vec2(60,0)) + .0973 *i(p+vec2(61,0)) + .0268 *i(p+vec2(62,0)) - .0526 *i(p+vec2(60,1)) + .0128 *i(p+vec2(61,1)) - .0794 *i(p+vec2(62,1)) + .0571 *i(p+vec2(60,2)) + .0426 *i(p+vec2(61,2)) - .0537 *i(p+vec2(62,2)) - .0279 *i(p+vec2(70,0)) + .049  *i(p+vec2(71,0)) - .0276 *i(p+vec2(72,0)) + .2031 *i(p+vec2(70,1)) + .0894 *i(p+vec2(71,1)) - .0982 *i(p+vec2(72,1)) + .0464 *i(p+vec2(70,2)) - .0166 *i(p+vec2(71,2)) + .0304 *i(p+vec2(72,2)) - .0733 *i(p+vec2(80,0)) + .0092 *i(p+vec2(81,0)) - .0619 *i(p+vec2(82,0)) + .1281 *i(p+vec2(80,1)) + .1384 *i(p+vec2(81,1)) + .0078 *i(p+vec2(82,1)) + .056  *i(p+vec2(80,2)) + .1267 *i(p+vec2(81,2)) + .0299 *i(p+vec2(82,2)) - .1931 *i(p+vec2(90,0)) + .0115 *i(p+vec2(91,0)) + .0063 *i(p+vec2(92,0)) + .042  *i(p+vec2(90,1)) - .0155 *i(p+vec2(91,1)) + .0793 *i(p+vec2(92,1)) + .0886 *i(p+vec2(90,2)) - .0426 *i(p+vec2(91,2)) - .0824 *i(p+vec2(92,2)) - .0693 ;\n        else if (fmap == 6) x = -.178  *i(p) - .0017 *i(p+vec2(1,0)) - .0142 *i(p+vec2(2,0)) + .0227 *i(p+vec2(0,1)) - .1036 *i(p+vec2(1,1)) - .0387 *i(p+vec2(2,1)) + .1756 *i(p+vec2(0,2)) + .0987 *i(p+vec2(1,2)) + .0902 *i(p+vec2(2,2)) + .2976 *i(p+vec2(10,0)) + .2693 *i(p+vec2(11,0)) - .0621 *i(p+vec2(12,0)) + .148  *i(p+vec2(10,1)) + .0548 *i(p+vec2(11,1)) - .0588 *i(p+vec2(12,1)) - .1724 *i(p+vec2(10,2)) - .0229 *i(p+vec2(11,2)) + .0285 *i(p+vec2(12,2)) + .0186 *i(p+vec2(20,0)) + .1608 *i(p+vec2(21,0)) - .3328 *i(p+vec2(22,0)) + .2052 *i(p+vec2(20,1)) + .1804 *i(p+vec2(21,1)) + .0315 *i(p+vec2(22,1)) + .2228 *i(p+vec2(20,2)) - .0364 *i(p+vec2(21,2)) - .0105 *i(p+vec2(22,2)) + .1862 *i(p+vec2(30,0)) - .0444 *i(p+vec2(31,0)) - .1762 *i(p+vec2(32,0)) + .1573 *i(p+vec2(30,1)) + .0186 *i(p+vec2(31,1)) + .0335 *i(p+vec2(32,1)) + .118  *i(p+vec2(30,2)) + .1449 *i(p+vec2(31,2)) + .2762 *i(p+vec2(32,2)) - .0988 *i(p+vec2(40,0)) + .017  *i(p+vec2(41,0)) + .0664 *i(p+vec2(42,0)) - .3941 *i(p+vec2(40,1)) - .2333 *i(p+vec2(41,1)) + .1682 *i(p+vec2(42,1)) + .0283 *i(p+vec2(40,2)) - .0795 *i(p+vec2(41,2)) + .0152 *i(p+vec2(42,2)) + .1508 *i(p+vec2(50,0)) + .0575 *i(p+vec2(51,0)) + .065  *i(p+vec2(52,0)) - .3041 *i(p+vec2(50,1)) + .0351 *i(p+vec2(51,1)) + .0723 *i(p+vec2(52,1)) - .0287 *i(p+vec2(50,2)) - .2766 *i(p+vec2(51,2)) - .3485 *i(p+vec2(52,2)) + .1456 *i(p+vec2(60,0)) - .1952 *i(p+vec2(61,0)) - .1434 *i(p+vec2(62,0)) + .118  *i(p+vec2(60,1)) + .0121 *i(p+vec2(61,1)) - .0334 *i(p+vec2(62,1)) + .1098 *i(p+vec2(60,2)) - .0129 *i(p+vec2(61,2)) + .0221 *i(p+vec2(62,2)) - .0066 *i(p+vec2(70,0)) + .0138 *i(p+vec2(71,0)) - .1323 *i(p+vec2(72,0)) - .0494 *i(p+vec2(70,1)) - .2867 *i(p+vec2(71,1)) - .2088 *i(p+vec2(72,1)) - .3524 *i(p+vec2(70,2)) - .1497 *i(p+vec2(71,2)) + .0017 *i(p+vec2(72,2)) + .0471 *i(p+vec2(80,0)) - .1236 *i(p+vec2(81,0)) - .1049 *i(p+vec2(82,0)) - .0289 *i(p+vec2(80,1)) + .0301 *i(p+vec2(81,1)) - .0017 *i(p+vec2(82,1)) + .0113 *i(p+vec2(80,2)) - .1323 *i(p+vec2(81,2)) - .0764 *i(p+vec2(82,2)) + .02   *i(p+vec2(90,0)) - .0373 *i(p+vec2(91,0)) + .0063 *i(p+vec2(92,0)) - .023  *i(p+vec2(90,1)) + .0726 *i(p+vec2(91,1)) + .1056 *i(p+vec2(92,1)) - .1963 *i(p+vec2(90,2)) - .0837 *i(p+vec2(91,2)) - .0245 *i(p+vec2(92,2)) - .1422 ;\n        else if (fmap == 7) x =  .2059 *i(p) - .0481 *i(p+vec2(1,0)) + .1304 *i(p+vec2(2,0)) + .242  *i(p+vec2(0,1)) + .0784 *i(p+vec2(1,1)) + .2544 *i(p+vec2(2,1)) + .0561 *i(p+vec2(0,2)) + .087  *i(p+vec2(1,2)) + .0915 *i(p+vec2(2,2)) - .1326 *i(p+vec2(10,0)) - .3046 *i(p+vec2(11,0)) - .2378 *i(p+vec2(12,0)) + .2593 *i(p+vec2(10,1)) - .2224 *i(p+vec2(11,1)) - .2745 *i(p+vec2(12,1)) + .1752 *i(p+vec2(10,2)) - .0254 *i(p+vec2(11,2)) + .0045 *i(p+vec2(12,2)) + .0252 *i(p+vec2(20,0)) - .2596 *i(p+vec2(21,0)) - .176  *i(p+vec2(22,0)) - .2964 *i(p+vec2(20,1)) - .2841 *i(p+vec2(21,1)) - .1    *i(p+vec2(22,1)) + .1211 *i(p+vec2(20,2)) + .0426 *i(p+vec2(21,2)) + .0462 *i(p+vec2(22,2)) - .3311 *i(p+vec2(30,0)) + .0527 *i(p+vec2(31,0)) + .082  *i(p+vec2(32,0)) - .0224 *i(p+vec2(30,1)) - .1532 *i(p+vec2(31,1)) - .0252 *i(p+vec2(32,1)) + .1407 *i(p+vec2(30,2)) - .1581 *i(p+vec2(31,2)) - .241  *i(p+vec2(32,2)) - .1697 *i(p+vec2(40,0)) - .1502 *i(p+vec2(41,0)) + .0125 *i(p+vec2(42,0)) + .0085 *i(p+vec2(40,1)) + .002  *i(p+vec2(41,1)) - .0999 *i(p+vec2(42,1)) - .0334 *i(p+vec2(40,2)) - .0176 *i(p+vec2(41,2)) - .171  *i(p+vec2(42,2)) + .0912 *i(p+vec2(50,0)) - .0543 *i(p+vec2(51,0)) + .0482 *i(p+vec2(52,0)) + .0479 *i(p+vec2(50,1)) + .0193 *i(p+vec2(51,1)) + .0976 *i(p+vec2(52,1)) - .1671 *i(p+vec2(50,2)) + .2104 *i(p+vec2(51,2)) + .1478 *i(p+vec2(52,2)) - .3183 *i(p+vec2(60,0)) - .162  *i(p+vec2(61,0)) + .1596 *i(p+vec2(62,0)) - .2833 *i(p+vec2(60,1)) - .1174 *i(p+vec2(61,1)) + .2006 *i(p+vec2(62,1)) - .1148 *i(p+vec2(60,2)) - .1804 *i(p+vec2(61,2)) - .0499 *i(p+vec2(62,2)) - .3077 *i(p+vec2(70,0)) - .0837 *i(p+vec2(71,0)) - .0843 *i(p+vec2(72,0)) - .0289 *i(p+vec2(70,1)) + .0824 *i(p+vec2(71,1)) + .107  *i(p+vec2(72,1)) + .0531 *i(p+vec2(70,2)) - .0422 *i(p+vec2(71,2)) + .0362 *i(p+vec2(72,2)) - .3698 *i(p+vec2(80,0)) + .0344 *i(p+vec2(81,0)) + .1712 *i(p+vec2(82,0)) - .3213 *i(p+vec2(80,1)) + .0174 *i(p+vec2(81,1)) + .1488 *i(p+vec2(82,1)) - .1002 *i(p+vec2(80,2)) + .0213 *i(p+vec2(81,2)) + .0765 *i(p+vec2(82,2)) + .0068 *i(p+vec2(90,0)) + .0262 *i(p+vec2(91,0)) + .1682 *i(p+vec2(92,0)) - .0264 *i(p+vec2(90,1)) + .0057 *i(p+vec2(91,1)) + .1286 *i(p+vec2(92,1)) + .0692 *i(p+vec2(90,2)) - .0488 *i(p+vec2(91,2)) + .0636 *i(p+vec2(92,2)) + .061  ;\n        else if (fmap == 8) x =  .0117 *i(p) + .1351 *i(p+vec2(1,0)) + .0619 *i(p+vec2(2,0)) + .129  *i(p+vec2(0,1)) - .0459 *i(p+vec2(1,1)) + .0854 *i(p+vec2(2,1)) - .2243 *i(p+vec2(0,2)) + .0991 *i(p+vec2(1,2)) + .0596 *i(p+vec2(2,2)) + .0223 *i(p+vec2(10,0)) + .2149 *i(p+vec2(11,0)) + .1969 *i(p+vec2(12,0)) - .0947 *i(p+vec2(10,1)) - .1803 *i(p+vec2(11,1)) - .0379 *i(p+vec2(12,1)) + .1321 *i(p+vec2(10,2)) - .0605 *i(p+vec2(11,2)) - .1092 *i(p+vec2(12,2)) + .2369 *i(p+vec2(20,0)) + .1685 *i(p+vec2(21,0)) - .6484 *i(p+vec2(22,0)) + .1755 *i(p+vec2(20,1)) + .1478 *i(p+vec2(21,1)) - .2681 *i(p+vec2(22,1)) - .0726 *i(p+vec2(20,2)) - .1612 *i(p+vec2(21,2)) - .1977 *i(p+vec2(22,2)) - .0788 *i(p+vec2(30,0)) + .1557 *i(p+vec2(31,0)) + .1981 *i(p+vec2(32,0)) - .1408 *i(p+vec2(30,1)) + .2294 *i(p+vec2(31,1)) + .0968 *i(p+vec2(32,1)) + .0903 *i(p+vec2(30,2)) - .2584 *i(p+vec2(31,2)) - .0717 *i(p+vec2(32,2)) - .1607 *i(p+vec2(40,0)) - .2929 *i(p+vec2(41,0)) - .2501 *i(p+vec2(42,0)) + .0968 *i(p+vec2(40,1)) + .0122 *i(p+vec2(41,1)) - .1602 *i(p+vec2(42,1)) + .2305 *i(p+vec2(40,2)) + .1202 *i(p+vec2(41,2)) + .0676 *i(p+vec2(42,2)) - .1007 *i(p+vec2(50,0)) + .0364 *i(p+vec2(51,0)) + .1113 *i(p+vec2(52,0)) + .1374 *i(p+vec2(50,1)) - .0946 *i(p+vec2(51,1)) + .0703 *i(p+vec2(52,1)) + .0562 *i(p+vec2(50,2)) - .1405 *i(p+vec2(51,2)) - .0604 *i(p+vec2(52,2)) + .0522 *i(p+vec2(60,0)) + .0506 *i(p+vec2(61,0)) - .0415 *i(p+vec2(62,0)) - .0837 *i(p+vec2(60,1)) + .0084 *i(p+vec2(61,1)) - .0156 *i(p+vec2(62,1)) + .1148 *i(p+vec2(60,2)) - .0445 *i(p+vec2(61,2)) + .0063 *i(p+vec2(62,2)) - .1711 *i(p+vec2(70,0)) + .1141 *i(p+vec2(71,0)) + .027  *i(p+vec2(72,0)) - .4357 *i(p+vec2(70,1)) - .2002 *i(p+vec2(71,1)) + .0025 *i(p+vec2(72,1)) + .0151 *i(p+vec2(70,2)) - .1598 *i(p+vec2(71,2)) + .069  *i(p+vec2(72,2)) - .003  *i(p+vec2(80,0)) - .1422 *i(p+vec2(81,0)) - .0689 *i(p+vec2(82,0)) - .1401 *i(p+vec2(80,1)) - .3764 *i(p+vec2(81,1)) - .2045 *i(p+vec2(82,1)) + .0834 *i(p+vec2(80,2)) - .1764 *i(p+vec2(81,2)) + .064  *i(p+vec2(82,2)) + .0193 *i(p+vec2(90,0)) - .0321 *i(p+vec2(91,0)) + .0185 *i(p+vec2(92,0)) - .0939 *i(p+vec2(90,1)) + .0225 *i(p+vec2(91,1)) - .0091 *i(p+vec2(92,1)) - .003  *i(p+vec2(90,2)) + .016  *i(p+vec2(91,2)) + .0728 *i(p+vec2(92,2)) + .0115 ;\n        else if (fmap == 9) x = -.031  *i(p) + .07   *i(p+vec2(1,0)) - .0745 *i(p+vec2(2,0)) + .0205 *i(p+vec2(0,1)) + .0615 *i(p+vec2(1,1)) + .0088 *i(p+vec2(2,1)) - .0868 *i(p+vec2(0,2)) - .06   *i(p+vec2(1,2)) - .0797 *i(p+vec2(2,2)) - .183  *i(p+vec2(10,0)) + .0111 *i(p+vec2(11,0)) - .047  *i(p+vec2(12,0)) + .0295 *i(p+vec2(10,1)) - .0334 *i(p+vec2(11,1)) - .1799 *i(p+vec2(12,1)) + .3414 *i(p+vec2(10,2)) + .1907 *i(p+vec2(11,2)) + .0397 *i(p+vec2(12,2)) - .2755 *i(p+vec2(20,0)) - .5606 *i(p+vec2(21,0)) - .1192 *i(p+vec2(22,0)) - .7573 *i(p+vec2(20,1)) - .5794 *i(p+vec2(21,1)) - .1322 *i(p+vec2(22,1)) - .2965 *i(p+vec2(20,2)) - .1063 *i(p+vec2(21,2)) - .1752 *i(p+vec2(22,2)) - .2784 *i(p+vec2(30,0)) - .0955 *i(p+vec2(31,0)) - .0751 *i(p+vec2(32,0)) - .0285 *i(p+vec2(30,1)) - .0201 *i(p+vec2(31,1)) - .0964 *i(p+vec2(32,1)) + .2737 *i(p+vec2(30,2)) + .0673 *i(p+vec2(31,2)) + .0133 *i(p+vec2(32,2)) + .0082 *i(p+vec2(40,0)) + .1701 *i(p+vec2(41,0)) - .0881 *i(p+vec2(42,0)) + .1932 *i(p+vec2(40,1)) + .0779 *i(p+vec2(41,1)) + .1634 *i(p+vec2(42,1)) + .2334 *i(p+vec2(40,2)) + .1472 *i(p+vec2(41,2)) + .2416 *i(p+vec2(42,2)) - .1409 *i(p+vec2(50,0)) - .0594 *i(p+vec2(51,0)) + .1137 *i(p+vec2(52,0)) + .0426 *i(p+vec2(50,1)) - .0738 *i(p+vec2(51,1)) - .5315 *i(p+vec2(52,1)) - .0487 *i(p+vec2(50,2)) - .3007 *i(p+vec2(51,2)) - .199  *i(p+vec2(52,2)) - .1765 *i(p+vec2(60,0)) - .099  *i(p+vec2(61,0)) + .1    *i(p+vec2(62,0)) - .1392 *i(p+vec2(60,1)) - .0968 *i(p+vec2(61,1)) + .0943 *i(p+vec2(62,1)) + .1189 *i(p+vec2(60,2)) + .0943 *i(p+vec2(61,2)) - .5105 *i(p+vec2(62,2)) - .0159 *i(p+vec2(70,0)) - .0028 *i(p+vec2(71,0)) + .0869 *i(p+vec2(72,0)) - .0355 *i(p+vec2(70,1)) - .0228 *i(p+vec2(71,1)) + .027  *i(p+vec2(72,1)) + .1315 *i(p+vec2(70,2)) - .0879 *i(p+vec2(71,2)) + .1511 *i(p+vec2(72,2)) - .2506 *i(p+vec2(80,0)) + .1907 *i(p+vec2(81,0)) + .1655 *i(p+vec2(82,0)) - .0572 *i(p+vec2(80,1)) + .0478 *i(p+vec2(81,1)) + .165  *i(p+vec2(82,1)) - .057  *i(p+vec2(80,2)) + .0927 *i(p+vec2(81,2)) - .0888 *i(p+vec2(82,2)) + .1744 *i(p+vec2(90,0)) - .0296 *i(p+vec2(91,0)) - .056  *i(p+vec2(92,0)) + .1576 *i(p+vec2(90,1)) + .0385 *i(p+vec2(91,1)) - .222  *i(p+vec2(92,1)) + .1249 *i(p+vec2(90,2)) + .0175 *i(p+vec2(91,2)) - .0731 *i(p+vec2(92,2)) + .0476 ;\n#undef i      \n        x = max(x, 0.); // ReLU Activation\n        col = vec4(x);\n    }\n     \n    // Displays the pixelated version of the input (on the right)\n    else if (uv.x > iR) {\n        uv.x -= iR;\n        uv.x *= iAspect;\n        \n        uv.x -= margin*.5;\n        uv.y -= margin;\n        uv /= (1. - margin);\n        \n        uv = floor(uv * input_res);\n        col = vec4(i(uv));\n\n        if (min(uv.x,uv.y) < 0. || max(uv.x,uv.y) >= input_res) col *= 0.;\n    }\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/* This buffers handles:\n   - Convolution #2 (Step 2)\n   - Convolution #3 (Step 4)\n   - Max Pooling #2 (Step 6)\n*/\n\nfloat i(vec2 p) { \n    return texelFetch(iChannel0, ivec2(p), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 uv = fragCoord / R;\n    vec2 F = fragCoord  -.5;\n    vec3 col = vec3(0);\n    \n    // CNN Step 2: Convolution #2\n    // 8x26x26 => 8x24x24\n    if (F.x < f2*F2 && F.y < F2) {\n        int fmap = int(F.x / F2);\n        vec2   p = mod(F, F2);\n        float  x;\n        \n        if      (fmap == 0) x = -.215  *i(p) - .0445 *i(p+vec2(1,0)) + .117  *i(p+vec2(2,0)) + .0736 *i(p+vec2(0,1)) + .0586 *i(p+vec2(1,1)) + .2664 *i(p+vec2(2,1)) + .3496 *i(p+vec2(0,2)) + .102  *i(p+vec2(1,2)) + .2541 *i(p+vec2(2,2)) - .316  *i(p+vec2(26,0)) - .1725 *i(p+vec2(27,0)) + .0295 *i(p+vec2(28,0)) + .056  *i(p+vec2(26,1)) + .0297 *i(p+vec2(27,1)) + .0286 *i(p+vec2(28,1)) + .2464 *i(p+vec2(26,2)) + .2042 *i(p+vec2(27,2)) + .1225 *i(p+vec2(28,2)) - .1762 *i(p+vec2(52,0)) + .0096 *i(p+vec2(53,0)) + .0911 *i(p+vec2(54,0)) + .24   *i(p+vec2(52,1)) + .0079 *i(p+vec2(53,1)) + .1597 *i(p+vec2(54,1)) + .4694 *i(p+vec2(52,2)) + .2169 *i(p+vec2(53,2)) + .0739 *i(p+vec2(54,2)) + .1171 *i(p+vec2(78,0)) + .2064 *i(p+vec2(79,0)) + .0645 *i(p+vec2(80,0)) + .2102 *i(p+vec2(78,1)) + .2812 *i(p+vec2(79,1)) + .2303 *i(p+vec2(80,1)) - .151  *i(p+vec2(78,2)) - .1218 *i(p+vec2(79,2)) - .125  *i(p+vec2(80,2)) - .4364 *i(p+vec2(104,0)) - .1975 *i(p+vec2(105,0)) - .1999 *i(p+vec2(106,0)) - .1012 *i(p+vec2(104,1)) - .0542 *i(p+vec2(105,1)) + .1379 *i(p+vec2(106,1)) + .2816 *i(p+vec2(104,2)) + .2285 *i(p+vec2(105,2)) + .1634 *i(p+vec2(106,2)) + .1753 *i(p+vec2(130,0)) + .1279 *i(p+vec2(131,0)) + .2715 *i(p+vec2(132,0)) + .4227 *i(p+vec2(130,1)) + .1198 *i(p+vec2(131,1)) + .1557 *i(p+vec2(132,1)) + .2033 *i(p+vec2(130,2)) + .1277 *i(p+vec2(131,2)) + .0742 *i(p+vec2(132,2)) - .0082 *i(p+vec2(156,0)) - .2566 *i(p+vec2(157,0)) - .1675 *i(p+vec2(158,0)) - .5319 *i(p+vec2(156,1)) - .6699 *i(p+vec2(157,1)) - .3119 *i(p+vec2(158,1)) - .2501 *i(p+vec2(156,2)) - .1926 *i(p+vec2(157,2)) - .1603 *i(p+vec2(158,2)) - .2567 *i(p+vec2(182,0)) - .1124 *i(p+vec2(183,0)) - .2392 *i(p+vec2(184,0)) - .2393 *i(p+vec2(182,1)) - .2044 *i(p+vec2(183,1)) - .1681 *i(p+vec2(184,1)) + .1197 *i(p+vec2(182,2)) + .0481 *i(p+vec2(183,2)) + .0781 *i(p+vec2(184,2)) - .0855 ;\n        else if (fmap == 1) x =  .2367 *i(p) + .0263 *i(p+vec2(1,0)) - .3914 *i(p+vec2(2,0)) + .3257 *i(p+vec2(0,1)) - .1341 *i(p+vec2(1,1)) - .3699 *i(p+vec2(2,1)) + .2111 *i(p+vec2(0,2)) - .1045 *i(p+vec2(1,2)) - .2385 *i(p+vec2(2,2)) + .0133 *i(p+vec2(26,0)) + .1075 *i(p+vec2(27,0)) + .1111 *i(p+vec2(28,0)) + .143  *i(p+vec2(26,1)) + .1059 *i(p+vec2(27,1)) - .1042 *i(p+vec2(28,1)) + .2355 *i(p+vec2(26,2)) - .0271 *i(p+vec2(27,2)) - .092  *i(p+vec2(28,2)) - .0085 *i(p+vec2(52,0)) + .0886 *i(p+vec2(53,0)) - .0845 *i(p+vec2(54,0)) + .1088 *i(p+vec2(52,1)) + .1813 *i(p+vec2(53,1)) + .0835 *i(p+vec2(54,1)) + .0954 *i(p+vec2(52,2)) - .0261 *i(p+vec2(53,2)) + .1761 *i(p+vec2(54,2)) - .5722 *i(p+vec2(78,0)) + .0887 *i(p+vec2(79,0)) + .3266 *i(p+vec2(80,0)) - .6905 *i(p+vec2(78,1)) - .0459 *i(p+vec2(79,1)) + .5219 *i(p+vec2(80,1)) - .7194 *i(p+vec2(78,2)) + .0673 *i(p+vec2(79,2)) + .2963 *i(p+vec2(80,2)) + .1194 *i(p+vec2(104,0)) - .0504 *i(p+vec2(105,0)) - .2681 *i(p+vec2(106,0)) + .2977 *i(p+vec2(104,1)) - .0278 *i(p+vec2(105,1)) - .5027 *i(p+vec2(106,1)) + .2489 *i(p+vec2(104,2)) - .1133 *i(p+vec2(105,2)) - .1921 *i(p+vec2(106,2)) - .2403 *i(p+vec2(130,0)) - .073  *i(p+vec2(131,0)) - .151  *i(p+vec2(132,0)) - .5006 *i(p+vec2(130,1)) - .1971 *i(p+vec2(131,1)) + .0758 *i(p+vec2(132,1)) - .7742 *i(p+vec2(130,2)) - .2197 *i(p+vec2(131,2)) + .148  *i(p+vec2(132,2)) - .0266 *i(p+vec2(156,0)) + .1793 *i(p+vec2(157,0)) + .0829 *i(p+vec2(158,0)) - .0985 *i(p+vec2(156,1)) + .0645 *i(p+vec2(157,1)) - .1257 *i(p+vec2(158,1)) + .1793 *i(p+vec2(156,2)) + .1565 *i(p+vec2(157,2)) - .1641 *i(p+vec2(158,2)) - .0853 *i(p+vec2(182,0)) - .0326 *i(p+vec2(183,0)) + .0367 *i(p+vec2(184,0)) + .2146 *i(p+vec2(182,1)) + .2115 *i(p+vec2(183,1)) - .081  *i(p+vec2(184,1)) + .303  *i(p+vec2(182,2)) + .2479 *i(p+vec2(183,2)) - .0877 *i(p+vec2(184,2)) + .1819 ;\n        else if (fmap == 2) x =  .0125 *i(p) - .05   *i(p+vec2(1,0)) + .1655 *i(p+vec2(2,0)) + .0227 *i(p+vec2(0,1)) + .1629 *i(p+vec2(1,1)) + .0464 *i(p+vec2(2,1)) + .2536 *i(p+vec2(0,2)) - .0411 *i(p+vec2(1,2)) + .0511 *i(p+vec2(2,2)) + .0707 *i(p+vec2(26,0)) + .0975 *i(p+vec2(27,0)) + .232  *i(p+vec2(28,0)) + .1313 *i(p+vec2(26,1)) + .1221 *i(p+vec2(27,1)) + .0468 *i(p+vec2(28,1)) + .4301 *i(p+vec2(26,2)) + .3981 *i(p+vec2(27,2)) + .139  *i(p+vec2(28,2)) - .0762 *i(p+vec2(52,0)) - .0404 *i(p+vec2(53,0)) + .028  *i(p+vec2(54,0)) + .1441 *i(p+vec2(52,1)) + .1489 *i(p+vec2(53,1)) + .295  *i(p+vec2(54,1)) + .3946 *i(p+vec2(52,2)) + .0322 *i(p+vec2(53,2)) + .0184 *i(p+vec2(54,2)) + .0305 *i(p+vec2(78,0)) + .0891 *i(p+vec2(79,0)) + .1905 *i(p+vec2(80,0)) - .3471 *i(p+vec2(78,1)) - .3672 *i(p+vec2(79,1)) - .2481 *i(p+vec2(80,1)) - .4253 *i(p+vec2(78,2)) - .0682 *i(p+vec2(79,2)) + .1577 *i(p+vec2(80,2)) - .1151 *i(p+vec2(104,0)) - .047  *i(p+vec2(105,0)) + .1958 *i(p+vec2(106,0)) - .029  *i(p+vec2(104,1)) - .0339 *i(p+vec2(105,1)) - .0797 *i(p+vec2(106,1)) + .2763 *i(p+vec2(104,2)) + .1496 *i(p+vec2(105,2)) - .0131 *i(p+vec2(106,2)) - .0253 *i(p+vec2(130,0)) - .3543 *i(p+vec2(131,0)) - .3798 *i(p+vec2(132,0)) - .5635 *i(p+vec2(130,1)) - .3937 *i(p+vec2(131,1)) - .4331 *i(p+vec2(132,1)) - .2936 *i(p+vec2(130,2)) - .2184 *i(p+vec2(131,2)) - .3239 *i(p+vec2(132,2)) - .3206 *i(p+vec2(156,0)) - .0839 *i(p+vec2(157,0)) + .1743 *i(p+vec2(158,0)) - .0825 *i(p+vec2(156,1)) - .0693 *i(p+vec2(157,1)) + .0135 *i(p+vec2(158,1)) - .0618 *i(p+vec2(156,2)) - .0118 *i(p+vec2(157,2)) + .0684 *i(p+vec2(158,2)) - .1237 *i(p+vec2(182,0)) - .0843 *i(p+vec2(183,0)) + .3261 *i(p+vec2(184,0)) + .0503 *i(p+vec2(182,1)) - .0108 *i(p+vec2(183,1)) - .071  *i(p+vec2(184,1)) + .1318 *i(p+vec2(182,2)) + .233  *i(p+vec2(183,2)) + .0178 *i(p+vec2(184,2)) + .1242 ;\n        else if (fmap == 3) x =  .1008 *i(p) + .0866 *i(p+vec2(1,0)) + .0108 *i(p+vec2(2,0)) + .0768 *i(p+vec2(0,1)) - .0445 *i(p+vec2(1,1)) + .2428 *i(p+vec2(2,1)) + .0749 *i(p+vec2(0,2)) - .0641 *i(p+vec2(1,2)) + .3046 *i(p+vec2(2,2)) + .0967 *i(p+vec2(26,0)) + .1572 *i(p+vec2(27,0)) + .1818 *i(p+vec2(28,0)) + .0703 *i(p+vec2(26,1)) + .1129 *i(p+vec2(27,1)) + .2699 *i(p+vec2(28,1)) + .1924 *i(p+vec2(26,2)) + .0259 *i(p+vec2(27,2)) + .3304 *i(p+vec2(28,2)) + .1776 *i(p+vec2(52,0)) - .0431 *i(p+vec2(53,0)) + .1276 *i(p+vec2(54,0)) - .0186 *i(p+vec2(52,1)) + .0213 *i(p+vec2(53,1)) + .3725 *i(p+vec2(54,1)) + .1508 *i(p+vec2(52,2)) - .0094 *i(p+vec2(53,2)) + .1689 *i(p+vec2(54,2)) - .8028 *i(p+vec2(78,0)) - .4112 *i(p+vec2(79,0)) - .0067 *i(p+vec2(80,0)) - .6313 *i(p+vec2(78,1)) - .2954 *i(p+vec2(79,1)) - .2921 *i(p+vec2(80,1)) - .0273 *i(p+vec2(78,2)) - .0223 *i(p+vec2(79,2)) - .138  *i(p+vec2(80,2)) - .0076 *i(p+vec2(104,0)) + .0605 *i(p+vec2(105,0)) + .134  *i(p+vec2(106,0)) - .0515 *i(p+vec2(104,1)) - .0899 *i(p+vec2(105,1)) + .2897 *i(p+vec2(106,1)) - .0716 *i(p+vec2(104,2)) + .0878 *i(p+vec2(105,2)) + .3642 *i(p+vec2(106,2)) - .242  *i(p+vec2(130,0)) - .4484 *i(p+vec2(131,0)) - .1231 *i(p+vec2(132,0)) - .0996 *i(p+vec2(130,1)) - .0642 *i(p+vec2(131,1)) - .0854 *i(p+vec2(132,1)) - .1943 *i(p+vec2(130,2)) - .0696 *i(p+vec2(131,2)) - .0068 *i(p+vec2(132,2)) + .4109 *i(p+vec2(156,0)) + .2593 *i(p+vec2(157,0)) - .0629 *i(p+vec2(158,0)) + .3676 *i(p+vec2(156,1)) + .1375 *i(p+vec2(157,1)) - .0892 *i(p+vec2(158,1)) - .0223 *i(p+vec2(156,2)) + .0945 *i(p+vec2(157,2)) + .012  *i(p+vec2(158,2)) + .204  *i(p+vec2(182,0)) - .04   *i(p+vec2(183,0)) + .0174 *i(p+vec2(184,0)) + .2832 *i(p+vec2(182,1)) + .0702 *i(p+vec2(183,1)) + .0753 *i(p+vec2(184,1)) + .0757 *i(p+vec2(182,2)) + .1403 *i(p+vec2(183,2)) + .1594 *i(p+vec2(184,2)) + .2947 ;\n        else if (fmap == 4) x = -.109  *i(p) - .0226 *i(p+vec2(1,0)) + .0143 *i(p+vec2(2,0)) + .1151 *i(p+vec2(0,1)) + .1058 *i(p+vec2(1,1)) - .0657 *i(p+vec2(2,1)) + .1319 *i(p+vec2(0,2)) - .1815 *i(p+vec2(1,2)) - .2023 *i(p+vec2(2,2)) + .1011 *i(p+vec2(26,0)) + .0994 *i(p+vec2(27,0)) + .1937 *i(p+vec2(28,0)) + .2634 *i(p+vec2(26,1)) + .3413 *i(p+vec2(27,1)) + .2794 *i(p+vec2(28,1)) + .5339 *i(p+vec2(26,2)) + .3487 *i(p+vec2(27,2)) + .1712 *i(p+vec2(28,2)) - .002  *i(p+vec2(52,0)) + .1109 *i(p+vec2(53,0)) + .0263 *i(p+vec2(54,0)) + .3323 *i(p+vec2(52,1)) + .2774 *i(p+vec2(53,1)) + .1673 *i(p+vec2(54,1)) - .0638 *i(p+vec2(52,2)) - .3167 *i(p+vec2(53,2)) - .2739 *i(p+vec2(54,2)) - .6208 *i(p+vec2(78,0)) - .6033 *i(p+vec2(79,0)) - .6426 *i(p+vec2(80,0)) - .5709 *i(p+vec2(78,1)) - .3404 *i(p+vec2(79,1)) - .1653 *i(p+vec2(80,1)) + .0715 *i(p+vec2(78,2)) + .1745 *i(p+vec2(79,2)) + .4318 *i(p+vec2(80,2)) + .0369 *i(p+vec2(104,0)) - .0281 *i(p+vec2(105,0)) + .0495 *i(p+vec2(106,0)) + .1381 *i(p+vec2(104,1)) - .0437 *i(p+vec2(105,1)) + .0514 *i(p+vec2(106,1)) + .138  *i(p+vec2(104,2)) - .1523 *i(p+vec2(105,2)) - .1457 *i(p+vec2(106,2)) - .6407 *i(p+vec2(130,0)) - .6851 *i(p+vec2(131,0)) - .2785 *i(p+vec2(132,0)) - .6453 *i(p+vec2(130,1)) - .4226 *i(p+vec2(131,1)) - .5758 *i(p+vec2(132,1)) - .936  *i(p+vec2(130,2)) - .6795 *i(p+vec2(131,2)) - .3961 *i(p+vec2(132,2)) + .2226 *i(p+vec2(156,0)) + .1491 *i(p+vec2(157,0)) + .2426 *i(p+vec2(158,0)) - .0305 *i(p+vec2(156,1)) + .1919 *i(p+vec2(157,1)) + .0642 *i(p+vec2(158,1)) + .2326 *i(p+vec2(156,2)) + .3181 *i(p+vec2(157,2)) + .1383 *i(p+vec2(158,2)) + .0469 *i(p+vec2(182,0)) + .0658 *i(p+vec2(183,0)) + .1747 *i(p+vec2(184,0)) + .0434 *i(p+vec2(182,1)) + .2202 *i(p+vec2(183,1)) + .1662 *i(p+vec2(184,1)) + .3427 *i(p+vec2(182,2)) + .1359 *i(p+vec2(183,2)) + .0578 *i(p+vec2(184,2)) + .4278 ;\n        else if (fmap == 5) x =  .1407 *i(p) - .0233 *i(p+vec2(1,0)) + .2506 *i(p+vec2(2,0)) + .145  *i(p+vec2(0,1)) - .0395 *i(p+vec2(1,1)) + .1877 *i(p+vec2(2,1)) + .088  *i(p+vec2(0,2)) + .1821 *i(p+vec2(1,2)) + .2738 *i(p+vec2(2,2)) + .0153 *i(p+vec2(26,0)) - .0445 *i(p+vec2(27,0)) + .0015 *i(p+vec2(28,0)) + .2008 *i(p+vec2(26,1)) + .0413 *i(p+vec2(27,1)) + .0781 *i(p+vec2(28,1)) - .0592 *i(p+vec2(26,2)) - .1073 *i(p+vec2(27,2)) + .1839 *i(p+vec2(28,2)) + .0806 *i(p+vec2(52,0)) + .0522 *i(p+vec2(53,0)) + .1612 *i(p+vec2(54,0)) + .1422 *i(p+vec2(52,1)) + .0289 *i(p+vec2(53,1)) + .1604 *i(p+vec2(54,1)) + .0155 *i(p+vec2(52,2)) + .0992 *i(p+vec2(53,2)) + .2086 *i(p+vec2(54,2)) - .1646 *i(p+vec2(78,0)) + .3031 *i(p+vec2(79,0)) + .3184 *i(p+vec2(80,0)) - .4116 *i(p+vec2(78,1)) + .0559 *i(p+vec2(79,1)) + .0792 *i(p+vec2(80,1)) - .326  *i(p+vec2(78,2)) - .1388 *i(p+vec2(79,2)) - .0297 *i(p+vec2(80,2)) - .0087 *i(p+vec2(104,0)) + .082  *i(p+vec2(105,0)) + .128  *i(p+vec2(106,0)) + .0389 *i(p+vec2(104,1)) - .0771 *i(p+vec2(105,1)) + .0944 *i(p+vec2(106,1)) + .112  *i(p+vec2(104,2)) - .0028 *i(p+vec2(105,2)) + .1783 *i(p+vec2(106,2)) - .049  *i(p+vec2(130,0)) - .1688 *i(p+vec2(131,0)) - .1754 *i(p+vec2(132,0)) - .288  *i(p+vec2(130,1)) - .1545 *i(p+vec2(131,1)) - .2355 *i(p+vec2(132,1)) - .154  *i(p+vec2(130,2)) + .0254 *i(p+vec2(131,2)) - .0137 *i(p+vec2(132,2)) - .0954 *i(p+vec2(156,0)) - .017  *i(p+vec2(157,0)) - .2189 *i(p+vec2(158,0)) + .0062 *i(p+vec2(156,1)) - .0917 *i(p+vec2(157,1)) - .1051 *i(p+vec2(158,1)) + .2661 *i(p+vec2(156,2)) - .1862 *i(p+vec2(157,2)) - .0991 *i(p+vec2(158,2)) + .0508 *i(p+vec2(182,0)) + .019  *i(p+vec2(183,0)) + .1056 *i(p+vec2(184,0)) + .1757 *i(p+vec2(182,1)) + .1088 *i(p+vec2(183,1)) - .0706 *i(p+vec2(184,1)) + .2693 *i(p+vec2(182,2)) + .06   *i(p+vec2(183,2)) - .0275 *i(p+vec2(184,2)) - .0053 ;\n        else if (fmap == 6) x =  .0398 *i(p) - .2516 *i(p+vec2(1,0)) - .3615 *i(p+vec2(2,0)) + .1796 *i(p+vec2(0,1)) + .067  *i(p+vec2(1,1)) - .2535 *i(p+vec2(2,1)) + .1863 *i(p+vec2(0,2)) + .0201 *i(p+vec2(1,2)) - .0183 *i(p+vec2(2,2)) - .0122 *i(p+vec2(26,0)) + .0329 *i(p+vec2(27,0)) - .2077 *i(p+vec2(28,0)) + .084  *i(p+vec2(26,1)) + .2674 *i(p+vec2(27,1)) + .1284 *i(p+vec2(28,1)) + .2197 *i(p+vec2(26,2)) + .1318 *i(p+vec2(27,2)) + .1981 *i(p+vec2(28,2)) + .2157 *i(p+vec2(52,0)) + .0923 *i(p+vec2(53,0)) - .1153 *i(p+vec2(54,0)) + .2703 *i(p+vec2(52,1)) + .1983 *i(p+vec2(53,1)) + .0912 *i(p+vec2(54,1)) + .0724 *i(p+vec2(52,2)) + .3362 *i(p+vec2(53,2)) + .3077 *i(p+vec2(54,2)) - .2185 *i(p+vec2(78,0)) + .2015 *i(p+vec2(79,0)) + .6791 *i(p+vec2(80,0)) - .5963 *i(p+vec2(78,1)) - .2612 *i(p+vec2(79,1)) + .1308 *i(p+vec2(80,1)) - .8314 *i(p+vec2(78,2)) - .6128 *i(p+vec2(79,2)) - .013  *i(p+vec2(80,2)) - .0978 *i(p+vec2(104,0)) - .1578 *i(p+vec2(105,0)) - .5974 *i(p+vec2(106,0)) + .194  *i(p+vec2(104,1)) + .0102 *i(p+vec2(105,1)) - .3466 *i(p+vec2(106,1)) + .1633 *i(p+vec2(104,2)) + .1908 *i(p+vec2(105,2)) - .0395 *i(p+vec2(106,2)) + .153  *i(p+vec2(130,0)) + .3857 *i(p+vec2(131,0)) + .2473 *i(p+vec2(132,0)) - .067  *i(p+vec2(130,1)) + .0263 *i(p+vec2(131,1)) + .3086 *i(p+vec2(132,1)) - .1776 *i(p+vec2(130,2)) - .1454 *i(p+vec2(131,2)) + .1647 *i(p+vec2(132,2)) - .1167 *i(p+vec2(156,0)) - .2214 *i(p+vec2(157,0)) - .197  *i(p+vec2(158,0)) - .2269 *i(p+vec2(156,1)) - .2727 *i(p+vec2(157,1)) - .2911 *i(p+vec2(158,1)) + .3415 *i(p+vec2(156,2)) + .091  *i(p+vec2(157,2)) - .1079 *i(p+vec2(158,2)) + .0026 *i(p+vec2(182,0)) - .0452 *i(p+vec2(183,0)) - .1287 *i(p+vec2(184,0)) + .0254 *i(p+vec2(182,1)) - .0763 *i(p+vec2(183,1)) + .0111 *i(p+vec2(184,1)) + .2482 *i(p+vec2(182,2)) + .1252 *i(p+vec2(183,2)) + .0052 *i(p+vec2(184,2)) + .2314 ;\n        else if (fmap == 7) x = -.1999 *i(p) - .1932 *i(p+vec2(1,0)) + .312  *i(p+vec2(2,0)) - .1    *i(p+vec2(0,1)) + .0693 *i(p+vec2(1,1)) + .2129 *i(p+vec2(2,1)) + .0335 *i(p+vec2(0,2)) + .0036 *i(p+vec2(1,2)) - .0783 *i(p+vec2(2,2)) - .0057 *i(p+vec2(26,0)) + .162  *i(p+vec2(27,0)) + .2424 *i(p+vec2(28,0)) + .0075 *i(p+vec2(26,1)) + .1072 *i(p+vec2(27,1)) + .3873 *i(p+vec2(28,1)) + .2043 *i(p+vec2(26,2)) + .1469 *i(p+vec2(27,2)) + .2237 *i(p+vec2(28,2)) - .1763 *i(p+vec2(52,0)) + .1674 *i(p+vec2(53,0)) - .0642 *i(p+vec2(54,0)) + .2099 *i(p+vec2(52,1)) + .1973 *i(p+vec2(53,1)) + .1295 *i(p+vec2(54,1)) - .0877 *i(p+vec2(52,2)) - .088  *i(p+vec2(53,2)) - .1318 *i(p+vec2(54,2)) + .2153 *i(p+vec2(78,0)) - .2231 *i(p+vec2(79,0)) - .4635 *i(p+vec2(80,0)) + .0336 *i(p+vec2(78,1)) - .219  *i(p+vec2(79,1)) - .4759 *i(p+vec2(80,1)) + .0384 *i(p+vec2(78,2)) - .0836 *i(p+vec2(79,2)) - .336  *i(p+vec2(80,2)) - .2286 *i(p+vec2(104,0)) - .0483 *i(p+vec2(105,0)) + .3511 *i(p+vec2(106,0)) + .0793 *i(p+vec2(104,1)) - .1024 *i(p+vec2(105,1)) + .1964 *i(p+vec2(106,1)) + .1628 *i(p+vec2(104,2)) + .1481 *i(p+vec2(105,2)) + .1364 *i(p+vec2(106,2)) + .1573 *i(p+vec2(130,0)) - .0035 *i(p+vec2(131,0)) - .1932 *i(p+vec2(132,0)) + .0544 *i(p+vec2(130,1)) - .0131 *i(p+vec2(131,1)) - .2581 *i(p+vec2(132,1)) - .1552 *i(p+vec2(130,2)) - .2929 *i(p+vec2(131,2)) - .1888 *i(p+vec2(132,2)) - .1291 *i(p+vec2(156,0)) - .0539 *i(p+vec2(157,0)) + .0782 *i(p+vec2(158,0)) - .1249 *i(p+vec2(156,1)) - .0496 *i(p+vec2(157,1)) - .076  *i(p+vec2(158,1)) + .0945 *i(p+vec2(156,2)) + .2936 *i(p+vec2(157,2)) + .3399 *i(p+vec2(158,2)) - .0038 *i(p+vec2(182,0)) - .0531 *i(p+vec2(183,0)) - .0516 *i(p+vec2(184,0)) + .0761 *i(p+vec2(182,1)) + .0635 *i(p+vec2(183,1)) - .1705 *i(p+vec2(184,1)) - .0016 *i(p+vec2(182,2)) + .0619 *i(p+vec2(183,2)) + .1284 *i(p+vec2(184,2)) + .1535 ;\n      \n        x = max(x, 0.); // ReLU Activation\n        col = vec3(x);\n    }\n    // CNN Step 4: Convolution #3\n    // 8x12x12 => 10x10x10\n    else if (F.x < f4*F4 && F.y >= F2 && F.y < F2+F4) {\n        int fmap = int(F.x / F4);\n        vec2   p = mod(F - vec2(0, F2), F4) + vec2(0,F1);\n        float  x;\n        \n        if      (fmap == 0) x =  .1129 *i(p) - .0645 *i(p+vec2(1,0)) + .1294 *i(p+vec2(2,0)) - .4581 *i(p+vec2(0,1)) - .4014 *i(p+vec2(1,1)) - .0061 *i(p+vec2(2,1)) + .1008 *i(p+vec2(0,2)) - .0305 *i(p+vec2(1,2)) + .0272 *i(p+vec2(2,2)) + .4903 *i(p+vec2(12,0)) + .1928 *i(p+vec2(13,0)) - .0099 *i(p+vec2(14,0)) + .5189 *i(p+vec2(12,1)) + .39   *i(p+vec2(13,1)) - .0498 *i(p+vec2(14,1)) + .233  *i(p+vec2(12,2)) + .3543 *i(p+vec2(13,2)) - .0097 *i(p+vec2(14,2)) + .0745 *i(p+vec2(24,0)) - .0766 *i(p+vec2(25,0)) - .1578 *i(p+vec2(26,0)) + .0078 *i(p+vec2(24,1)) - .1648 *i(p+vec2(25,1)) + .072  *i(p+vec2(26,1)) + .1058 *i(p+vec2(24,2)) + .1593 *i(p+vec2(25,2)) + .1972 *i(p+vec2(26,2)) + .0159 *i(p+vec2(36,0)) - .0696 *i(p+vec2(37,0)) + .0916 *i(p+vec2(38,0)) + .0552 *i(p+vec2(36,1)) - .0637 *i(p+vec2(37,1)) + .1525 *i(p+vec2(38,1)) + .0909 *i(p+vec2(36,2)) - .1168 *i(p+vec2(37,2)) - .0501 *i(p+vec2(38,2)) + .1118 *i(p+vec2(48,0)) - .0404 *i(p+vec2(49,0)) - .0685 *i(p+vec2(50,0)) + .1356 *i(p+vec2(48,1)) - .1814 *i(p+vec2(49,1)) + .0226 *i(p+vec2(50,1)) + .0365 *i(p+vec2(48,2)) - .1037 *i(p+vec2(49,2)) + .1971 *i(p+vec2(50,2)) - .0991 *i(p+vec2(60,0)) - .023  *i(p+vec2(61,0)) + .0678 *i(p+vec2(62,0)) - .0145 *i(p+vec2(60,1)) - .0724 *i(p+vec2(61,1)) - .0558 *i(p+vec2(62,1)) - .0013 *i(p+vec2(60,2)) + .1346 *i(p+vec2(61,2)) + .0355 *i(p+vec2(62,2)) + .0939 *i(p+vec2(72,0)) - .0836 *i(p+vec2(73,0)) + .0586 *i(p+vec2(74,0)) + .0325 *i(p+vec2(72,1)) + .0207 *i(p+vec2(73,1)) + .0286 *i(p+vec2(74,1)) + .1686 *i(p+vec2(72,2)) + .0405 *i(p+vec2(73,2)) - .0117 *i(p+vec2(74,2)) + .0575 *i(p+vec2(84,0)) - .2614 *i(p+vec2(85,0)) + .022  *i(p+vec2(86,0)) - .1279 *i(p+vec2(84,1)) - .1913 *i(p+vec2(85,1)) + .2553 *i(p+vec2(86,1)) - .0026 *i(p+vec2(84,2)) + .0306 *i(p+vec2(85,2)) + .2987 *i(p+vec2(86,2)) - .1256 ;\n        else if (fmap == 1) x = -.1407 *i(p) + .1709 *i(p+vec2(1,0)) + .1317 *i(p+vec2(2,0)) - .0521 *i(p+vec2(0,1)) + .0477 *i(p+vec2(1,1)) + .1969 *i(p+vec2(2,1)) - .3761 *i(p+vec2(0,2)) - .4753 *i(p+vec2(1,2)) - .1808 *i(p+vec2(2,2)) - .0491 *i(p+vec2(12,0)) + .0636 *i(p+vec2(13,0)) + .0402 *i(p+vec2(14,0)) - .4029 *i(p+vec2(12,1)) - .2554 *i(p+vec2(13,1)) - .1063 *i(p+vec2(14,1)) - .1296 *i(p+vec2(12,2)) - .275  *i(p+vec2(13,2)) - .1331 *i(p+vec2(14,2)) + .1076 *i(p+vec2(24,0)) - .0416 *i(p+vec2(25,0)) - .0127 *i(p+vec2(26,0)) + .0141 *i(p+vec2(24,1)) + .0341 *i(p+vec2(25,1)) - .0246 *i(p+vec2(26,1)) - .061  *i(p+vec2(24,2)) - .0159 *i(p+vec2(25,2)) - .0809 *i(p+vec2(26,2)) + .3243 *i(p+vec2(36,0)) - .0949 *i(p+vec2(37,0)) - .2142 *i(p+vec2(38,0)) + .2795 *i(p+vec2(36,1)) + .1643 *i(p+vec2(37,1)) - .1943 *i(p+vec2(38,1)) - .0607 *i(p+vec2(36,2)) + .1159 *i(p+vec2(37,2)) - .0104 *i(p+vec2(38,2)) + .076  *i(p+vec2(48,0)) - .0217 *i(p+vec2(49,0)) - .0359 *i(p+vec2(50,0)) + .145  *i(p+vec2(48,1)) + .0509 *i(p+vec2(49,1)) - .1595 *i(p+vec2(50,1)) - .049  *i(p+vec2(48,2)) + .1095 *i(p+vec2(49,2)) - .0326 *i(p+vec2(50,2)) + .2074 *i(p+vec2(60,0)) + .0179 *i(p+vec2(61,0)) - .1501 *i(p+vec2(62,0)) + .163  *i(p+vec2(60,1)) + .1835 *i(p+vec2(61,1)) + .0769 *i(p+vec2(62,1)) - .0729 *i(p+vec2(60,2)) - .1495 *i(p+vec2(61,2)) + .0382 *i(p+vec2(62,2)) + .1805 *i(p+vec2(72,0)) - .008  *i(p+vec2(73,0)) - .2297 *i(p+vec2(74,0)) + .0819 *i(p+vec2(72,1)) + .3086 *i(p+vec2(73,1)) - .0117 *i(p+vec2(74,1)) + .0238 *i(p+vec2(72,2)) + .0423 *i(p+vec2(73,2)) + .1569 *i(p+vec2(74,2)) + .1188 *i(p+vec2(84,0)) - .0431 *i(p+vec2(85,0)) + .0301 *i(p+vec2(86,0)) + .0314 *i(p+vec2(84,1)) + .1979 *i(p+vec2(85,1)) + .1094 *i(p+vec2(86,1)) - .1843 *i(p+vec2(84,2)) + .0296 *i(p+vec2(85,2)) - .02   *i(p+vec2(86,2)) - .141  ;\n        else if (fmap == 2) x = -.3194 *i(p) - .1403 *i(p+vec2(1,0)) + .0489 *i(p+vec2(2,0)) - .0787 *i(p+vec2(0,1)) - .0192 *i(p+vec2(1,1)) - .1877 *i(p+vec2(2,1)) + .1273 *i(p+vec2(0,2)) - .0334 *i(p+vec2(1,2)) + .1125 *i(p+vec2(2,2)) + .1212 *i(p+vec2(12,0)) - .1559 *i(p+vec2(13,0)) - .134  *i(p+vec2(14,0)) - .0765 *i(p+vec2(12,1)) - .1459 *i(p+vec2(13,1)) - .1736 *i(p+vec2(14,1)) - .0359 *i(p+vec2(12,2)) + .2889 *i(p+vec2(13,2)) - .0163 *i(p+vec2(14,2)) - .0487 *i(p+vec2(24,0)) + .0884 *i(p+vec2(25,0)) + .2203 *i(p+vec2(26,0)) - .0983 *i(p+vec2(24,1)) - .2431 *i(p+vec2(25,1)) - .0805 *i(p+vec2(26,1)) + .042  *i(p+vec2(24,2)) - .0431 *i(p+vec2(25,2)) - .1341 *i(p+vec2(26,2)) + .0111 *i(p+vec2(36,0)) + .2019 *i(p+vec2(37,0)) + .1962 *i(p+vec2(38,0)) - .1033 *i(p+vec2(36,1)) - .1768 *i(p+vec2(37,1)) + .215  *i(p+vec2(38,1)) - .0314 *i(p+vec2(36,2)) - .1044 *i(p+vec2(37,2)) - .074  *i(p+vec2(38,2)) + .1167 *i(p+vec2(48,0)) + .1004 *i(p+vec2(49,0)) + .2599 *i(p+vec2(50,0)) - .0471 *i(p+vec2(48,1)) - .1909 *i(p+vec2(49,1)) + .0057 *i(p+vec2(50,1)) - .0102 *i(p+vec2(48,2)) - .1299 *i(p+vec2(49,2)) - .2852 *i(p+vec2(50,2)) + .0682 *i(p+vec2(60,0)) + .033  *i(p+vec2(61,0)) + .3275 *i(p+vec2(62,0)) - .0057 *i(p+vec2(60,1)) - .2512 *i(p+vec2(61,1)) + .0053 *i(p+vec2(62,1)) + .0637 *i(p+vec2(60,2)) + .0868 *i(p+vec2(61,2)) + .0736 *i(p+vec2(62,2)) + .2203 *i(p+vec2(72,0)) + .073  *i(p+vec2(73,0)) + .1408 *i(p+vec2(74,0)) + .0632 *i(p+vec2(72,1)) + .0358 *i(p+vec2(73,1)) + .0504 *i(p+vec2(74,1)) - .0023 *i(p+vec2(72,2)) + .1257 *i(p+vec2(73,2)) + .1422 *i(p+vec2(74,2)) + .1308 *i(p+vec2(84,0)) + .0023 *i(p+vec2(85,0)) + .2425 *i(p+vec2(86,0)) - .1369 *i(p+vec2(84,1)) - .1073 *i(p+vec2(85,1)) + .0188 *i(p+vec2(86,1)) + .082  *i(p+vec2(84,2)) - .1549 *i(p+vec2(85,2)) - .1908 *i(p+vec2(86,2)) + .311  ;\n        else if (fmap == 3) x = -.1158 *i(p) + .0757 *i(p+vec2(1,0)) + .2293 *i(p+vec2(2,0)) - .1174 *i(p+vec2(0,1)) + .0438 *i(p+vec2(1,1)) + .2503 *i(p+vec2(2,1)) - .1428 *i(p+vec2(0,2)) - .3039 *i(p+vec2(1,2)) + .1316 *i(p+vec2(2,2)) - .0909 *i(p+vec2(12,0)) + .0923 *i(p+vec2(13,0)) - .1506 *i(p+vec2(14,0)) + .1421 *i(p+vec2(12,1)) + .1756 *i(p+vec2(13,1)) - .1554 *i(p+vec2(14,1)) + .0959 *i(p+vec2(12,2)) + .2636 *i(p+vec2(13,2)) + .1448 *i(p+vec2(14,2)) + .0644 *i(p+vec2(24,0)) - .0892 *i(p+vec2(25,0)) - .2552 *i(p+vec2(26,0)) + .1969 *i(p+vec2(24,1)) + .0121 *i(p+vec2(25,1)) - .1068 *i(p+vec2(26,1)) + .2016 *i(p+vec2(24,2)) + .1317 *i(p+vec2(25,2)) - .0331 *i(p+vec2(26,2)) + .0554 *i(p+vec2(36,0)) - .0893 *i(p+vec2(37,0)) - .2695 *i(p+vec2(38,0)) + .2652 *i(p+vec2(36,1)) - .0899 *i(p+vec2(37,1)) - .3936 *i(p+vec2(38,1)) + .307  *i(p+vec2(36,2)) + .07   *i(p+vec2(37,2)) - .0103 *i(p+vec2(38,2)) - .0447 *i(p+vec2(48,0)) + .0537 *i(p+vec2(49,0)) + .0293 *i(p+vec2(50,0)) + .1958 *i(p+vec2(48,1)) - .127  *i(p+vec2(49,1)) - .1961 *i(p+vec2(50,1)) + .2447 *i(p+vec2(48,2)) + .0737 *i(p+vec2(49,2)) - .0116 *i(p+vec2(50,2)) + .1842 *i(p+vec2(60,0)) - .0503 *i(p+vec2(61,0)) - .3119 *i(p+vec2(62,0)) + .0715 *i(p+vec2(60,1)) + .1614 *i(p+vec2(61,1)) - .138  *i(p+vec2(62,1)) + .3    *i(p+vec2(60,2)) + .0447 *i(p+vec2(61,2)) - .1455 *i(p+vec2(62,2)) - .064  *i(p+vec2(72,0)) - .1449 *i(p+vec2(73,0)) - .3305 *i(p+vec2(74,0)) + .0963 *i(p+vec2(72,1)) + .0123 *i(p+vec2(73,1)) - .4027 *i(p+vec2(74,1)) + .0889 *i(p+vec2(72,2)) + .1959 *i(p+vec2(73,2)) - .0563 *i(p+vec2(74,2)) + .0075 *i(p+vec2(84,0)) + .0269 *i(p+vec2(85,0)) - .097  *i(p+vec2(86,0)) - .0241 *i(p+vec2(84,1)) + .0548 *i(p+vec2(85,1)) - .3882 *i(p+vec2(86,1)) + .0286 *i(p+vec2(84,2)) + .1081 *i(p+vec2(85,2)) - .1908 *i(p+vec2(86,2)) + .3913 ;\n        else if (fmap == 4) x =  .1114 *i(p) - .2003 *i(p+vec2(1,0)) - .1392 *i(p+vec2(2,0)) - .1026 *i(p+vec2(0,1)) + .1263 *i(p+vec2(1,1)) + .2255 *i(p+vec2(2,1)) + .0778 *i(p+vec2(0,2)) + .13   *i(p+vec2(1,2)) + .1059 *i(p+vec2(2,2)) + .1839 *i(p+vec2(12,0)) + .4135 *i(p+vec2(13,0)) + .1303 *i(p+vec2(14,0)) + .0386 *i(p+vec2(12,1)) - .0704 *i(p+vec2(13,1)) - .3244 *i(p+vec2(14,1)) - .3791 *i(p+vec2(12,2)) - .253  *i(p+vec2(13,2)) - .2754 *i(p+vec2(14,2)) + .1983 *i(p+vec2(24,0)) + .0006 *i(p+vec2(25,0)) + .0126 *i(p+vec2(26,0)) - .092  *i(p+vec2(24,1)) - .2384 *i(p+vec2(25,1)) - .0928 *i(p+vec2(26,1)) + .1648 *i(p+vec2(24,2)) + .0025 *i(p+vec2(25,2)) + .1326 *i(p+vec2(26,2)) + .166  *i(p+vec2(36,0)) - .0707 *i(p+vec2(37,0)) - .0348 *i(p+vec2(38,0)) + .0376 *i(p+vec2(36,1)) - .2379 *i(p+vec2(37,1)) - .1537 *i(p+vec2(38,1)) - .0697 *i(p+vec2(36,2)) + .0651 *i(p+vec2(37,2)) + .0151 *i(p+vec2(38,2)) + .3271 *i(p+vec2(48,0)) + .1621 *i(p+vec2(49,0)) + .1753 *i(p+vec2(50,0)) - .0376 *i(p+vec2(48,1)) - .2155 *i(p+vec2(49,1)) - .2347 *i(p+vec2(50,1)) - .0905 *i(p+vec2(48,2)) - .0696 *i(p+vec2(49,2)) + .1654 *i(p+vec2(50,2)) - .0337 *i(p+vec2(60,0)) - .1694 *i(p+vec2(61,0)) - .0946 *i(p+vec2(62,0)) - 0.    *i(p+vec2(60,1)) - .1322 *i(p+vec2(61,1)) + .0308 *i(p+vec2(62,1)) + .1247 *i(p+vec2(60,2)) + .075  *i(p+vec2(61,2)) + .2016 *i(p+vec2(62,2)) + .1314 *i(p+vec2(72,0)) + .0581 *i(p+vec2(73,0)) - .0744 *i(p+vec2(74,0)) - .1754 *i(p+vec2(72,1)) - .3285 *i(p+vec2(73,1)) - .1941 *i(p+vec2(74,1)) + .0863 *i(p+vec2(72,2)) + .1702 *i(p+vec2(73,2)) + .1535 *i(p+vec2(74,2)) + .2094 *i(p+vec2(84,0)) + .0392 *i(p+vec2(85,0)) + .1197 *i(p+vec2(86,0)) + .0308 *i(p+vec2(84,1)) - .1731 *i(p+vec2(85,1)) - .0504 *i(p+vec2(86,1)) + .0736 *i(p+vec2(84,2)) + .0516 *i(p+vec2(85,2)) + .3111 *i(p+vec2(86,2)) + .0251 ;\n        else if (fmap == 5) x = -.0503 *i(p) - .241  *i(p+vec2(1,0)) - .0064 *i(p+vec2(2,0)) + .0827 *i(p+vec2(0,1)) - .0354 *i(p+vec2(1,1)) - .0822 *i(p+vec2(2,1)) + .1346 *i(p+vec2(0,2)) + .195  *i(p+vec2(1,2)) + .0502 *i(p+vec2(2,2)) + .2663 *i(p+vec2(12,0)) + .1545 *i(p+vec2(13,0)) + .1031 *i(p+vec2(14,0)) + .4316 *i(p+vec2(12,1)) - .0151 *i(p+vec2(13,1)) - .1098 *i(p+vec2(14,1)) - .1993 *i(p+vec2(12,2)) + .1106 *i(p+vec2(13,2)) - .0446 *i(p+vec2(14,2)) - .1259 *i(p+vec2(24,0)) - .2661 *i(p+vec2(25,0)) + .1304 *i(p+vec2(26,0)) + .1344 *i(p+vec2(24,1)) + .0603 *i(p+vec2(25,1)) + .0103 *i(p+vec2(26,1)) + .168  *i(p+vec2(24,2)) + .0955 *i(p+vec2(25,2)) + .0704 *i(p+vec2(26,2)) - .3136 *i(p+vec2(36,0)) - .2648 *i(p+vec2(37,0)) - .0984 *i(p+vec2(38,0)) - .0727 *i(p+vec2(36,1)) - .0338 *i(p+vec2(37,1)) + .1165 *i(p+vec2(38,1)) - .0042 *i(p+vec2(36,2)) + .1092 *i(p+vec2(37,2)) + .2282 *i(p+vec2(38,2)) - .4222 *i(p+vec2(48,0)) - .265  *i(p+vec2(49,0)) + .0218 *i(p+vec2(50,0)) + .0363 *i(p+vec2(48,1)) + .0231 *i(p+vec2(49,1)) + .1812 *i(p+vec2(50,1)) + .1305 *i(p+vec2(48,2)) + .0659 *i(p+vec2(49,2)) + .2352 *i(p+vec2(50,2)) - .1303 *i(p+vec2(60,0)) - .2883 *i(p+vec2(61,0)) + .0651 *i(p+vec2(62,0)) + .0993 *i(p+vec2(60,1)) + .0083 *i(p+vec2(61,1)) + .0024 *i(p+vec2(62,1)) + .2185 *i(p+vec2(60,2)) + .0451 *i(p+vec2(61,2)) + .2177 *i(p+vec2(62,2)) - .1143 *i(p+vec2(72,0)) - .3081 *i(p+vec2(73,0)) + .1015 *i(p+vec2(74,0)) + .0009 *i(p+vec2(72,1)) - .1661 *i(p+vec2(73,1)) + .0828 *i(p+vec2(74,1)) + .0699 *i(p+vec2(72,2)) + .0888 *i(p+vec2(73,2)) + .0641 *i(p+vec2(74,2)) - .2859 *i(p+vec2(84,0)) - .2278 *i(p+vec2(85,0)) - .0629 *i(p+vec2(86,0)) - .0083 *i(p+vec2(84,1)) - .1034 *i(p+vec2(85,1)) + .1629 *i(p+vec2(86,1)) + .0629 *i(p+vec2(84,2)) + .0973 *i(p+vec2(85,2)) + .0391 *i(p+vec2(86,2)) + .2576 ;\n        else if (fmap == 6) x =  .0492 *i(p) - .1815 *i(p+vec2(1,0)) - .0747 *i(p+vec2(2,0)) + .1148 *i(p+vec2(0,1)) - .1139 *i(p+vec2(1,1)) - .0486 *i(p+vec2(2,1)) - .1968 *i(p+vec2(0,2)) + .0975 *i(p+vec2(1,2)) + .2798 *i(p+vec2(2,2)) - .3691 *i(p+vec2(12,0)) + .0921 *i(p+vec2(13,0)) + .2775 *i(p+vec2(14,0)) - .1051 *i(p+vec2(12,1)) + .1756 *i(p+vec2(13,1)) + .1627 *i(p+vec2(14,1)) - .2369 *i(p+vec2(12,2)) + .0744 *i(p+vec2(13,2)) + .2703 *i(p+vec2(14,2)) - .2723 *i(p+vec2(24,0)) + .0961 *i(p+vec2(25,0)) + .0741 *i(p+vec2(26,0)) - .0593 *i(p+vec2(24,1)) + .1887 *i(p+vec2(25,1)) + .0168 *i(p+vec2(26,1)) - .0858 *i(p+vec2(24,2)) - .0478 *i(p+vec2(25,2)) - .04   *i(p+vec2(26,2)) - .1059 *i(p+vec2(36,0)) - .1727 *i(p+vec2(37,0)) + .0864 *i(p+vec2(38,0)) - .1477 *i(p+vec2(36,1)) + .0741 *i(p+vec2(37,1)) + .1391 *i(p+vec2(38,1)) - .0285 *i(p+vec2(36,2)) + .0926 *i(p+vec2(37,2)) + .0563 *i(p+vec2(38,2)) - .4196 *i(p+vec2(48,0)) - .2078 *i(p+vec2(49,0)) + .1335 *i(p+vec2(50,0)) - .2079 *i(p+vec2(48,1)) + .1665 *i(p+vec2(49,1)) + .2411 *i(p+vec2(50,1)) - .106  *i(p+vec2(48,2)) + .0358 *i(p+vec2(49,2)) + .1148 *i(p+vec2(50,2)) - .1836 *i(p+vec2(60,0)) + .0926 *i(p+vec2(61,0)) + .1526 *i(p+vec2(62,0)) - .0819 *i(p+vec2(60,1)) - .0163 *i(p+vec2(61,1)) + .165  *i(p+vec2(62,1)) - .0608 *i(p+vec2(60,2)) - .0131 *i(p+vec2(61,2)) + .0338 *i(p+vec2(62,2)) - .5923 *i(p+vec2(72,0)) - .0566 *i(p+vec2(73,0)) + .0096 *i(p+vec2(74,0)) - .4644 *i(p+vec2(72,1)) - .0662 *i(p+vec2(73,1)) - .1652 *i(p+vec2(74,1)) - .4614 *i(p+vec2(72,2)) + .0355 *i(p+vec2(73,2)) - .1439 *i(p+vec2(74,2)) - .1767 *i(p+vec2(84,0)) + .0756 *i(p+vec2(85,0)) + .2064 *i(p+vec2(86,0)) + .0362 *i(p+vec2(84,1)) + .1226 *i(p+vec2(85,1)) + .0437 *i(p+vec2(86,1)) + .0345 *i(p+vec2(84,2)) - .022  *i(p+vec2(85,2)) - .0102 *i(p+vec2(86,2)) + .0481 ;\n        else if (fmap == 7) x = -.1824 *i(p) + .0893 *i(p+vec2(1,0)) + .0457 *i(p+vec2(2,0)) - .4508 *i(p+vec2(0,1)) - .2718 *i(p+vec2(1,1)) - .3385 *i(p+vec2(2,1)) - .0939 *i(p+vec2(0,2)) + .0205 *i(p+vec2(1,2)) - .1347 *i(p+vec2(2,2)) + .2965 *i(p+vec2(12,0)) + .2752 *i(p+vec2(13,0)) + .397  *i(p+vec2(14,0)) + .1861 *i(p+vec2(12,1)) + .1058 *i(p+vec2(13,1)) - .0606 *i(p+vec2(14,1)) - .0071 *i(p+vec2(12,2)) + .0309 *i(p+vec2(13,2)) - .0233 *i(p+vec2(14,2)) + .1715 *i(p+vec2(24,0)) + .154  *i(p+vec2(25,0)) - .1693 *i(p+vec2(26,0)) - .0108 *i(p+vec2(24,1)) - .0544 *i(p+vec2(25,1)) - .2331 *i(p+vec2(26,1)) + .2375 *i(p+vec2(24,2)) - .1213 *i(p+vec2(25,2)) - .1779 *i(p+vec2(26,2)) + .1799 *i(p+vec2(36,0)) + .1098 *i(p+vec2(37,0)) + .017  *i(p+vec2(38,0)) - .0301 *i(p+vec2(36,1)) - .1156 *i(p+vec2(37,1)) + .0462 *i(p+vec2(38,1)) + .0334 *i(p+vec2(36,2)) + .0447 *i(p+vec2(37,2)) - .1418 *i(p+vec2(38,2)) + .2149 *i(p+vec2(48,0)) + .033  *i(p+vec2(49,0)) - .0314 *i(p+vec2(50,0)) + .1114 *i(p+vec2(48,1)) - .0898 *i(p+vec2(49,1)) + .0116 *i(p+vec2(50,1)) + .0295 *i(p+vec2(48,2)) - .0817 *i(p+vec2(49,2)) - .2452 *i(p+vec2(50,2)) + .2006 *i(p+vec2(60,0)) + .0525 *i(p+vec2(61,0)) - .0352 *i(p+vec2(62,0)) + .0151 *i(p+vec2(60,1)) - .1429 *i(p+vec2(61,1)) - .1813 *i(p+vec2(62,1)) + .2454 *i(p+vec2(60,2)) + .1786 *i(p+vec2(61,2)) - .1424 *i(p+vec2(62,2)) + .1339 *i(p+vec2(72,0)) - .0279 *i(p+vec2(73,0)) + .0358 *i(p+vec2(74,0)) + .0468 *i(p+vec2(72,1)) - .0457 *i(p+vec2(73,1)) - .1322 *i(p+vec2(74,1)) + .268  *i(p+vec2(72,2)) + .1727 *i(p+vec2(73,2)) + .0382 *i(p+vec2(74,2)) + .2195 *i(p+vec2(84,0)) - .0268 *i(p+vec2(85,0)) - .1153 *i(p+vec2(86,0)) - .0072 *i(p+vec2(84,1)) - .0792 *i(p+vec2(85,1)) - .0553 *i(p+vec2(86,1)) + .1365 *i(p+vec2(84,2)) - .1704 *i(p+vec2(85,2)) - .0514 *i(p+vec2(86,2)) + .2505 ;\n        else if (fmap == 8) x =  .1616 *i(p) + .1708 *i(p+vec2(1,0)) + .1729 *i(p+vec2(2,0)) - .0133 *i(p+vec2(0,1)) - .1925 *i(p+vec2(1,1)) - .0317 *i(p+vec2(2,1)) - .125  *i(p+vec2(0,2)) - .2098 *i(p+vec2(1,2)) - .0771 *i(p+vec2(2,2)) - .1864 *i(p+vec2(12,0)) - .1086 *i(p+vec2(13,0)) - .1052 *i(p+vec2(14,0)) + .0394 *i(p+vec2(12,1)) + .032  *i(p+vec2(13,1)) - .1313 *i(p+vec2(14,1)) + .0652 *i(p+vec2(12,2)) - .143  *i(p+vec2(13,2)) + .0473 *i(p+vec2(14,2)) + .06   *i(p+vec2(24,0)) + .1629 *i(p+vec2(25,0)) + .0876 *i(p+vec2(26,0)) + .1929 *i(p+vec2(24,1)) + .1003 *i(p+vec2(25,1)) - .147  *i(p+vec2(26,1)) + .0449 *i(p+vec2(24,2)) - .0305 *i(p+vec2(25,2)) - .3034 *i(p+vec2(26,2)) - .1561 *i(p+vec2(36,0)) + .0547 *i(p+vec2(37,0)) + .0531 *i(p+vec2(38,0)) + .0918 *i(p+vec2(36,1)) + .1571 *i(p+vec2(37,1)) - .0609 *i(p+vec2(38,1)) + .0844 *i(p+vec2(36,2)) - .0956 *i(p+vec2(37,2)) - .1788 *i(p+vec2(38,2)) - .1079 *i(p+vec2(48,0)) + .1297 *i(p+vec2(49,0)) + .0453 *i(p+vec2(50,0)) + .2913 *i(p+vec2(48,1)) + .3307 *i(p+vec2(49,1)) + .0034 *i(p+vec2(50,1)) + .0294 *i(p+vec2(48,2)) - .0864 *i(p+vec2(49,2)) - .2392 *i(p+vec2(50,2)) - .014  *i(p+vec2(60,0)) + .1615 *i(p+vec2(61,0)) + .0817 *i(p+vec2(62,0)) + .0959 *i(p+vec2(60,1)) - .0655 *i(p+vec2(61,1)) - .0695 *i(p+vec2(62,1)) - .0052 *i(p+vec2(60,2)) - .046  *i(p+vec2(61,2)) - .1942 *i(p+vec2(62,2)) - .1561 *i(p+vec2(72,0)) + .0111 *i(p+vec2(73,0)) + .1669 *i(p+vec2(74,0)) + .0501 *i(p+vec2(72,1)) + .0012 *i(p+vec2(73,1)) + .0216 *i(p+vec2(74,1)) + .1776 *i(p+vec2(72,2)) + .188  *i(p+vec2(73,2)) + .1788 *i(p+vec2(74,2)) + .1073 *i(p+vec2(84,0)) + .2582 *i(p+vec2(85,0)) + .1173 *i(p+vec2(86,0)) + .125  *i(p+vec2(84,1)) + .0175 *i(p+vec2(85,1)) - .0183 *i(p+vec2(86,1)) + .0226 *i(p+vec2(84,2)) - .0984 *i(p+vec2(85,2)) - .1497 *i(p+vec2(86,2)) - .0766 ;\n        else if (fmap == 9) x = -.0992 *i(p) - .1965 *i(p+vec2(1,0)) - .0513 *i(p+vec2(2,0)) + .038  *i(p+vec2(0,1)) + .0698 *i(p+vec2(1,1)) + .2064 *i(p+vec2(2,1)) - .13   *i(p+vec2(0,2)) - .2492 *i(p+vec2(1,2)) - .1935 *i(p+vec2(2,2)) + .3379 *i(p+vec2(12,0)) + .0497 *i(p+vec2(13,0)) - .0087 *i(p+vec2(14,0)) + .2843 *i(p+vec2(12,1)) + .1798 *i(p+vec2(13,1)) + .0449 *i(p+vec2(14,1)) + .2568 *i(p+vec2(12,2)) + .1514 *i(p+vec2(13,2)) + .1214 *i(p+vec2(14,2)) + .0078 *i(p+vec2(24,0)) - .0383 *i(p+vec2(25,0)) + .0201 *i(p+vec2(26,0)) + .1352 *i(p+vec2(24,1)) - .0824 *i(p+vec2(25,1)) + .1424 *i(p+vec2(26,1)) - .1625 *i(p+vec2(24,2)) - .0577 *i(p+vec2(25,2)) - .0049 *i(p+vec2(26,2)) + .0494 *i(p+vec2(36,0)) + .018  *i(p+vec2(37,0)) + .0917 *i(p+vec2(38,0)) - .0327 *i(p+vec2(36,1)) + .0252 *i(p+vec2(37,1)) + .1301 *i(p+vec2(38,1)) - .0472 *i(p+vec2(36,2)) - .0529 *i(p+vec2(37,2)) + .1665 *i(p+vec2(38,2)) - .0534 *i(p+vec2(48,0)) - .141  *i(p+vec2(49,0)) + .154  *i(p+vec2(50,0)) + .0262 *i(p+vec2(48,1)) + .0807 *i(p+vec2(49,1)) - .0603 *i(p+vec2(50,1)) - .048  *i(p+vec2(48,2)) - .0257 *i(p+vec2(49,2)) + .1204 *i(p+vec2(50,2)) + .0566 *i(p+vec2(60,0)) + .0702 *i(p+vec2(61,0)) - .0159 *i(p+vec2(62,0)) + .1162 *i(p+vec2(60,1)) - .0202 *i(p+vec2(61,1)) - .0591 *i(p+vec2(62,1)) - .0253 *i(p+vec2(60,2)) - .0645 *i(p+vec2(61,2)) + .2136 *i(p+vec2(62,2)) - .033  *i(p+vec2(72,0)) - .0586 *i(p+vec2(73,0)) + .0523 *i(p+vec2(74,0)) - .0877 *i(p+vec2(72,1)) - .005  *i(p+vec2(73,1)) - .0122 *i(p+vec2(74,1)) + .0359 *i(p+vec2(72,2)) + .005  *i(p+vec2(73,2)) + .1929 *i(p+vec2(74,2)) - .0265 *i(p+vec2(84,0)) + .0475 *i(p+vec2(85,0)) + .1306 *i(p+vec2(86,0)) - .0125 *i(p+vec2(84,1)) + .0439 *i(p+vec2(85,1)) + .0951 *i(p+vec2(86,1)) + .069  *i(p+vec2(84,2)) + .0632 *i(p+vec2(85,2)) + .1637 *i(p+vec2(86,2)) - .0916 ;\n\n        x = max(x, 0.); // ReLU Activation\n        col = vec3(x);\n    }\n    // CNN Step 6: Max Pooling #2\n    // 12x8x8 => 12x4x4\n    else if (F.x < f6 * 4. && F.y >= F2+F4 && F.y < F2+F4+F6) {\n        ivec2 p = ivec2(F - vec2(0, F2+F4)) * 2 + ivec2(0, F1+F3);\n        \n        // Max Pooling on the result of the Convolution\n        float x = max(texelFetch(iChannel0, p, 0).r,\n                  max(texelFetch(iChannel0, p + ivec2(0,1), 0).r,\n                  max(texelFetch(iChannel0, p + ivec2(1,0), 0).r,\n                      texelFetch(iChannel0, p + ivec2(1,1), 0).r)));\n                      \n        col = vec3(x);\n    }\n    \n    fragColor = vec4(col, 1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////// Difficulty level ///////////\n///                             ///\n    #define MAX_ATTEMPTS     7.\n///                             ///\n///////////////////////////////////\n\n#define R              (iResolution.xy)\n#define iAspect        (iResolution.x/iResolution.y)\n#define iR             (1. - iResolution.y/iResolution.x)\n\n/// Words dictionnary ///\n// Each array contains 4 words\n#define word_size  10\nint[40] words0 = int[40](80,73,88,69,76,0,0,0,0,0,86,69,67,84,79,82,0,0,0,0,83,72,65,68,69,82,0,0,0,0,82,69,78,68,69,82,0,0,0,0);\nint[40] words1 = int[40](86,69,82,84,69,88,0,0,0,0,70,82,65,71,77,69,78,84,0,0,84,69,88,84,85,82,69,0,0,0,66,85,70,70,69,82,0,0,0,0);\nint[40] words2 = int[40](67,65,78,86,65,83,0,0,0,0,83,80,82,73,84,69,0,0,0,0,67,85,82,86,69,0,0,0,0,0,80,79,76,89,71,79,78,0,0,0);\nint[40] words3 = int[40](83,72,65,68,69,82,0,0,0,0,68,69,80,84,72,0,0,0,0,0,67,79,76,79,82,0,0,0,0,0,70,73,76,84,69,82,0,0,0,0);\nint[40] words4 = int[40](76,73,71,72,84,0,0,0,0,0,65,78,73,77,65,84,73,79,78,0,77,79,68,69,76,0,0,0,0,0,77,65,84,82,73,88,0,0,0,0);\nint[40] words5 = int[40](66,76,69,78,68,0,0,0,0,0,70,82,65,77,69,0,0,0,0,0,83,67,69,78,69,0,0,0,0,0,82,65,83,84,69,82,0,0,0,0);\nint[40] words6 = int[40](65,82,82,65,89,0,0,0,0,0,70,85,78,67,84,73,79,78,0,0,86,65,82,73,65,66,76,69,0,0,67,76,65,83,83,0,0,0,0,0);\nint[40] words7 = int[40](79,66,74,69,67,84,0,0,0,0,73,78,72,69,82,73,84,0,0,0,69,86,69,78,84,0,0,0,0,0,81,85,69,85,69,0,0,0,0,0);\nint[40] words8 = int[40](83,84,65,67,75,0,0,0,0,0,65,76,71,79,82,73,84,72,77,0,83,69,65,82,67,72,0,0,0,0,71,82,65,80,72,0,0,0,0,0);\nint[40] words9 = int[40](67,82,89,80,84,79,0,0,0,0,76,79,71,73,67,0,0,0,0,0,78,69,85,82,65,76,0,0,0,0,76,69,65,82,78,73,78,71,0,0);\n\n/// Neural Network Settings ///\n// Input image dimension (28*28 = 784 input nodes)\n#define input_res      28.\n\n// Number of feature maps (filters) per layer\n#define f1 8.\n#define f2 8.\n#define f3 8.\n#define f4 10.\n#define f5 10.\n#define f6 10.\n\n// Output filter dimensions for each layer\n#define F1 26.\n#define F2 24.\n#define F3 12.\n#define F4 10.\n#define F5 8.\n#define F6 4.\n\n// Number of output nodes (26 letters: a-z)\n#define num_classes    26.\n\n/// \"Hack\" to display text easily\n/// (shader coming soon)\n//////////////////////////////////\nfloat char(sampler2D s, vec2 u, int id) {\n    return textureLod(s, (u + vec2(id%16, 15. - floor(float(id)/16.))) / 16.,0.).r * step(abs(u.x-.5),.5) * step(abs(u.y-.5),.5);\n}\n#define makeString(func_name)  float func_name(vec2 u)        { print\n#define makeStringI(func_name) float func_name(vec2 u, int i) { print\n#define FONT_TEXTURE iChannel3\n#define print float d = 0.; (0\n#define _end  ); return  d; }\n#define _     ); u.x -= .4; d += char(FONT_TEXTURE, u, \n#define __    ); u.x -= .4; (0\n#define _ch(i)  _ 65+i\n#define _dig(i) _ 48+i\n#define _qt _ 34\n#define _dd _ 58\n#define _un _ 95\n#define _bl _ 91\n#define _br _ 93\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122", "buffer_d_code": "/* This buffers handles:\n   - Fully connected layer (Step 7)\n   - Softmax function      (Step 8)\n*/\n\nfloat i(int x, int y) {\n    return texelFetch(iChannel0, ivec2(x,y), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord / R;\n    vec3 col = vec3(0);\n\n    ivec2 F = ivec2(fragCoord - .5);\n    \n    // CNN Step 7: Fully connected layer\n    // 10x4x4 => 1x26\n    if (F.x < int(num_classes)  && F.y == 0) {        \n        float x;\n        \n        // Each if/else correspond to an output node\n        if (F.x == 0) {\n            x =  -.3832 *i(0,34) - .4274 *i(1,34) - .4392 *i(2,34) - .3827 *i(3,34) - .1012 *i(0,35) - .0763 *i(1,35) - .0507 *i(2,35) - .0286 *i(3,35) + .0451 *i(0,36) + .0081 *i(1,36) - .0138 *i(2,36) + .0362 *i(3,36) - .0103 *i(0,37) - .0823 *i(1,37) - .1871 *i(2,37) - .1408 *i(3,37);\n            x +=  + .106  *i(4,34) + .13   *i(5,34) + .1046 *i(6,34) + .2426 *i(7,34) + .1028 *i(4,35) + .1104 *i(5,35) + .1201 *i(6,35) + .1486 *i(7,35) + .0295 *i(4,36) - .0144 *i(5,36) + .005  *i(6,36) - .0068 *i(7,36) + .076  *i(4,37) + .0325 *i(5,37) - .0281 *i(6,37) - .2085 *i(7,37);\n            x +=  - .3532 *i(8,34) - .0914 *i(9,34) - .1922 *i(10,34) - .1129 *i(11,34) - .4167 *i(8,35) - .1915 *i(9,35) - .1647 *i(10,35) - .0689 *i(11,35) - .3048 *i(8,36) - .3471 *i(9,36) + .0331 *i(10,36) + .0814 *i(11,36) - .2388 *i(8,37) - .1166 *i(9,37) + .0843 *i(10,37) - .0053 *i(11,37);\n            x +=  - .6653 *i(12,34) - .6401 *i(13,34) - .417  *i(14,34) - .4771 *i(15,34) - .1087 *i(12,35) - .2354 *i(13,35) - .2043 *i(14,35) - .2374 *i(15,35) - .0155 *i(12,36) - .0554 *i(13,36) - .1887 *i(14,36) - .1967 *i(15,36) - .0399 *i(12,37) - .0384 *i(13,37) - .0536 *i(14,37) - .1618 *i(15,37);\n            x +=  - .1103 *i(16,34) - .0015 *i(17,34) + .0458 *i(18,34) - .0235 *i(19,34) - .1374 *i(16,35) + .0335 *i(17,35) + .0915 *i(18,35) + .0342 *i(19,35) - .356  *i(16,36) - .1467 *i(17,36) - .0348 *i(18,36) - .1522 *i(19,36) - .304  *i(16,37) - .0606 *i(17,37) + .0633 *i(18,37) + .0235 *i(19,37);\n            x +=  - .3901 *i(20,34) - .2651 *i(21,34) - .1132 *i(22,34) - .1298 *i(23,34) - .0973 *i(20,35) + .03   *i(21,35) + .0895 *i(22,35) - .0425 *i(23,35) - .0959 *i(20,36) - .0326 *i(21,36) + .0165 *i(22,36) + .0056 *i(23,36) - .1474 *i(20,37) - .1928 *i(21,37) - .1382 *i(22,37) - .0195 *i(23,37);\n            x +=  + .0606 *i(24,34) - .0568 *i(25,34) - .1079 *i(26,34) - .1196 *i(27,34) + .0479 *i(24,35) + .0831 *i(25,35) + .0468 *i(26,35) - .1185 *i(27,35) + .0385 *i(24,36) + .0507 *i(25,36) + .1183 *i(26,36) - .2157 *i(27,36) + .0282 *i(24,37) + .0461 *i(25,37) + .0534 *i(26,37) - .0437 *i(27,37);\n            x +=  + .0358 *i(28,34) + .0871 *i(29,34) + .1218 *i(30,34) + .2048 *i(31,34) - .0655 *i(28,35) + .0273 *i(29,35) + .0618 *i(30,35) + .1203 *i(31,35) - .226  *i(28,36) - .0606 *i(29,36) + .0302 *i(30,36) + .0554 *i(31,36) - .195  *i(28,37) + .0434 *i(29,37) + .0364 *i(30,37) + .0695 *i(31,37);\n            x +=  + .1407 *i(32,34) + .0566 *i(33,34) + .0998 *i(34,34) + .0842 *i(35,34) + .0238 *i(32,35) - .0613 *i(33,35) + .0753 *i(34,35) + .0705 *i(35,35) - .0662 *i(32,36) - .1668 *i(33,36) - .1503 *i(34,36) - .0471 *i(35,36) - .0439 *i(32,37) - .0556 *i(33,37) - .1565 *i(34,37) - .0865 *i(35,37);\n            x +=  - .1995 *i(36,34) - .3543 *i(37,34) - .1131 *i(38,34) + .0726 *i(39,34) - .0755 *i(36,35) - .0845 *i(37,35) - .1285 *i(38,35) - .0691 *i(39,35) - .0621 *i(36,36) + .048  *i(37,36) + .0705 *i(38,36) + .0079 *i(39,36) - .1392 *i(36,37) + .1586 *i(37,37) + .1291 *i(38,37) + .1142 *i(39,37) - .1254 ;\n        } else if (F.x == 1) {\n            x =  -.1235 *i(0,34) + .0029 *i(1,34) + .0901 *i(2,34) + .1541 *i(3,34) - .0798 *i(0,35) - .0687 *i(1,35) - .0213 *i(2,35) - .123  *i(3,35) - .0101 *i(0,36) + .0315 *i(1,36) + .0219 *i(2,36) - .0258 *i(3,36) - .0284 *i(0,37) + .0066 *i(1,37) + .0358 *i(2,37) + .0422 *i(3,37);\n            x +=  + .0598 *i(4,34) + .1005 *i(5,34) - .0048 *i(6,34) - .0578 *i(7,34) - .0225 *i(4,35) + .064  *i(5,35) + .1123 *i(6,35) + .1205 *i(7,35) - .0005 *i(4,36) + .0625 *i(5,36) + .0642 *i(6,36) + .0784 *i(7,36) + .0627 *i(4,37) + .0467 *i(5,37) - .0015 *i(6,37) + .02   *i(7,37);\n            x +=  - .1625 *i(8,34) - .0784 *i(9,34) - .1305 *i(10,34) - .1587 *i(11,34) - .2097 *i(8,35) - .2058 *i(9,35) - .1195 *i(10,35) - .0157 *i(11,35) - .1499 *i(8,36) - .455  *i(9,36) - .3101 *i(10,36) - .1138 *i(11,36) - .2179 *i(8,37) - .2594 *i(9,37) - .1715 *i(10,37) - .0986 *i(11,37);\n            x +=  - .1487 *i(12,34) - .0414 *i(13,34) - .0657 *i(14,34) - .3878 *i(15,34) - .1976 *i(12,35) - .1657 *i(13,35) - .1066 *i(14,35) - .232  *i(15,35) - .1406 *i(12,36) - .2279 *i(13,36) - .2539 *i(14,36) - .1242 *i(15,36) - .0691 *i(12,37) - .0528 *i(13,37) - .071  *i(14,37) - .1567 *i(15,37);\n            x +=  - .1701 *i(16,34) - .0146 *i(17,34) + .0669 *i(18,34) + .0567 *i(19,34) - .1694 *i(16,35) + .0102 *i(17,35) + .0717 *i(18,35) + .0823 *i(19,35) - .0111 *i(16,36) - .0783 *i(17,36) - .0527 *i(18,36) - .0729 *i(19,36) + .1125 *i(16,37) + .0933 *i(17,37) + .1389 *i(18,37) + .095  *i(19,37);\n            x +=  - .0206 *i(20,34) + .0344 *i(21,34) + .0443 *i(22,34) + .0434 *i(23,34) - .1895 *i(20,35) - .0952 *i(21,35) - .0135 *i(22,35) + .0709 *i(23,35) - .0491 *i(20,36) - .0157 *i(21,36) - .0079 *i(22,36) + .0374 *i(23,36) - .0072 *i(20,37) - .0148 *i(21,37) - .0082 *i(22,37) - .0466 *i(23,37);\n            x +=  + .0333 *i(24,34) - .0577 *i(25,34) + .0968 *i(26,34) + .125  *i(27,34) - .077  *i(24,35) - .1176 *i(25,35) - .104  *i(26,35) - .082  *i(27,35) - .0616 *i(24,36) - .0231 *i(25,36) + .0337 *i(26,36) + .0556 *i(27,36) - .1619 *i(24,37) - .0419 *i(25,37) - .0141 *i(26,37) - .0934 *i(27,37);\n            x +=  - .0348 *i(28,34) - .061  *i(29,34) - .2457 *i(30,34) - .1916 *i(31,34) - .0547 *i(28,35) - .0508 *i(29,35) + .021  *i(30,35) + .1101 *i(31,35) + .0119 *i(28,36) - .0131 *i(29,36) + .0066 *i(30,36) + .0144 *i(31,36) - .1351 *i(28,37) - .0478 *i(29,37) - .0284 *i(30,37) - .0196 *i(31,37);\n            x +=  - .1888 *i(32,34) - .2162 *i(33,34) + .0502 *i(34,34) + .1098 *i(35,34) - .0539 *i(32,35) - .175  *i(33,35) + .0382 *i(34,35) + .0431 *i(35,35) - .025  *i(32,36) - .0662 *i(33,36) - .0614 *i(34,36) - .0399 *i(35,36) - .1102 *i(32,37) - .1175 *i(33,37) + .048  *i(34,37) + .0865 *i(35,37);\n            x +=  + .0391 *i(36,34) - .0086 *i(37,34) - .0738 *i(38,34) - .0312 *i(39,34) - .092  *i(36,35) - .014  *i(37,35) + .0897 *i(38,35) + .215  *i(39,35) - .2298 *i(36,36) - .141  *i(37,36) + .0093 *i(38,36) + .1355 *i(39,36) - .2184 *i(36,37) - .0157 *i(37,37) + .0155 *i(38,37) + .0252 *i(39,37) - .7654 ;\n        } else if (F.x == 2) {\n            x =  -.0194 *i(0,34) - .0126 *i(1,34) + .0075 *i(2,34) + .0012 *i(3,34) - .113  *i(0,35) + .0113 *i(1,35) - .0672 *i(2,35) - 0.    *i(3,35) - .4292 *i(0,36) - .2014 *i(1,36) - .0785 *i(2,36) + .0974 *i(3,36) - .3697 *i(0,37) - .3181 *i(1,37) - .1863 *i(2,37) - .0749 *i(3,37);\n            x +=  - .4509 *i(4,34) - .1894 *i(5,34) - .2058 *i(6,34) - .1137 *i(7,34) - .07   *i(4,35) - .1596 *i(5,35) - .2738 *i(6,35) - .192  *i(7,35) + .0886 *i(4,36) + .0058 *i(5,36) - .0867 *i(6,36) - .0887 *i(7,36) + .0674 *i(4,37) + .0381 *i(5,37) - .0711 *i(6,37) - .1125 *i(7,37);\n            x +=  + .1065 *i(8,34) + .1386 *i(9,34) + .096  *i(10,34) + .1273 *i(11,34) + .0518 *i(8,35) + .02   *i(9,35) + .0942 *i(10,35) + .1064 *i(11,35) - .226  *i(8,36) - .0766 *i(9,36) - .1362 *i(10,36) - .0474 *i(11,36) - .1303 *i(8,37) - .0106 *i(9,37) + .0345 *i(10,37) - .0501 *i(11,37);\n            x +=  - .1022 *i(12,34) - .0497 *i(13,34) + .067  *i(14,34) + .0471 *i(15,34) - .354  *i(12,35) - .0682 *i(13,35) + .0331 *i(14,35) + .0292 *i(15,35) - .0715 *i(12,36) - .1055 *i(13,36) - .0471 *i(14,36) + .0811 *i(15,36) + .0313 *i(12,37) + .0106 *i(13,37) - .0439 *i(14,37) - .0792 *i(15,37);\n            x +=  + .0427 *i(16,34) + .005  *i(17,34) - .0103 *i(18,34) + .0396 *i(19,34) - .3467 *i(16,35) - .0331 *i(17,35) + .031  *i(18,35) + .0706 *i(19,35) - .4238 *i(16,36) - .0803 *i(17,36) + .0226 *i(18,36) + .0357 *i(19,36) - .3141 *i(16,37) - .1318 *i(17,37) + .0318 *i(18,37) + .0212 *i(19,37);\n            x +=  + .067  *i(20,34) + .028  *i(21,34) + .0253 *i(22,34) + .0145 *i(23,34) + .0952 *i(20,35) + .0466 *i(21,35) - .0244 *i(22,35) - .0235 *i(23,35) - .2463 *i(20,36) - .2752 *i(21,36) - .3832 *i(22,36) - .4766 *i(23,36) - .5034 *i(20,37) - .2166 *i(21,37) - .2007 *i(22,37) - .2099 *i(23,37);\n            x +=  - .67   *i(24,34) - .0983 *i(25,34) + .0146 *i(26,34) - .0275 *i(27,34) - .3752 *i(24,35) + .0042 *i(25,35) - .03   *i(26,35) - .0208 *i(27,35) + .0674 *i(24,36) + .0968 *i(25,36) - .0261 *i(26,36) - .0165 *i(27,36) + .1577 *i(24,37) + .1234 *i(25,37) + .1219 *i(26,37) - .0063 *i(27,37);\n            x +=  - .0522 *i(28,34) - .3339 *i(29,34) - .3531 *i(30,34) - .4613 *i(31,34) - .0769 *i(28,35) - .053  *i(29,35) + .0644 *i(30,35) - .3123 *i(31,35) - .0311 *i(28,36) + .1251 *i(29,36) + .0463 *i(30,36) - .0865 *i(31,36) - .2165 *i(28,37) + .0116 *i(29,37) + .0161 *i(30,37) - .0336 *i(31,37);\n            x +=  - .7735 *i(32,34) - .7488 *i(33,34) - .4394 *i(34,34) - .328  *i(35,34) - .1409 *i(32,35) - .1236 *i(33,35) - .3537 *i(34,35) - .2844 *i(35,35) + .0146 *i(32,36) + .0405 *i(33,36) - .0012 *i(34,36) - .0977 *i(35,36) - .0162 *i(32,37) + .0262 *i(33,37) + .0601 *i(34,37) + .0176 *i(35,37);\n            x +=  + .0918 *i(36,34) + .0428 *i(37,34) + .0238 *i(38,34) - .2002 *i(39,34) + .1172 *i(36,35) + .0403 *i(37,35) - .1122 *i(38,35) - .5317 *i(39,35) + .011  *i(36,36) - .0675 *i(37,36) - .18   *i(38,36) - .2187 *i(39,36) - .2987 *i(36,37) + .0875 *i(37,37) + .0354 *i(38,37) - .0282 *i(39,37) + .3628 ;\n        } else if (F.x == 3) {\n            x =  -.01   *i(0,34) + .0275 *i(1,34) + .107  *i(2,34) + .091  *i(3,34) + .0024 *i(0,35) + .0195 *i(1,35) + .0662 *i(2,35) + .1103 *i(3,35) - .1009 *i(0,36) - .1757 *i(1,36) - .0074 *i(2,36) + .0392 *i(3,36) - .0829 *i(0,37) - .1263 *i(1,37) - .3069 *i(2,37) - .1925 *i(3,37);\n            x +=  - .0486 *i(4,34) - .0662 *i(5,34) - .123  *i(6,34) - .3876 *i(7,34) - .5237 *i(4,35) - .1675 *i(5,35) - .0892 *i(6,35) - .3113 *i(7,35) - .1259 *i(4,36) + .0124 *i(5,36) + .0261 *i(6,36) - .1327 *i(7,36) + .0878 *i(4,37) + .0812 *i(5,37) + .0399 *i(6,37) - .1003 *i(7,37);\n            x +=  - .119  *i(8,34) - .1282 *i(9,34) - .207  *i(10,34) - .5197 *i(11,34) - .0531 *i(8,35) - .1166 *i(9,35) - .0764 *i(10,35) - .127  *i(11,35) - .0281 *i(8,36) + .0282 *i(9,36) + .1064 *i(10,36) + .0313 *i(11,36) - .1001 *i(8,37) - .0233 *i(9,37) + .0836 *i(10,37) + .0121 *i(11,37);\n            x +=  - .0388 *i(12,34) - .02   *i(13,34) - .0316 *i(14,34) - .4071 *i(15,34) + .0072 *i(12,35) - .184  *i(13,35) - .1335 *i(14,35) - .4161 *i(15,35) - .022  *i(12,36) - .2202 *i(13,36) - .3455 *i(14,36) - .3552 *i(15,36) - .116  *i(12,37) - .0506 *i(13,37) + .0045 *i(14,37) - .0153 *i(15,37);\n            x +=  - .0435 *i(16,34) - .0523 *i(17,34) - .0861 *i(18,34) - .0229 *i(19,34) - .0598 *i(16,35) - .2585 *i(17,35) - .1043 *i(18,35) - .0995 *i(19,35) - .036  *i(16,36) - .0156 *i(17,36) + .0218 *i(18,36) + .0122 *i(19,36) + .0422 *i(16,37) + .01   *i(17,37) + .0301 *i(18,37) + .0425 *i(19,37);\n            x +=  - .016  *i(20,34) - .0146 *i(21,34) + .0198 *i(22,34) - .143  *i(23,34) - .1232 *i(20,35) - .1226 *i(21,35) - .0565 *i(22,35) - .0838 *i(23,35) - .0711 *i(20,36) - .1848 *i(21,36) - .0964 *i(22,36) + .0572 *i(23,36) + .0455 *i(20,37) + .0335 *i(21,37) + .0634 *i(22,37) + .1962 *i(23,37);\n            x +=  + .1374 *i(24,34) + .0327 *i(25,34) + .0618 *i(26,34) + .0744 *i(27,34) + .0261 *i(24,35) - .1878 *i(25,35) + .0437 *i(26,35) + .1529 *i(27,35) - .0814 *i(24,36) - .101  *i(25,36) - .0853 *i(26,36) + .0214 *i(27,36) - .2455 *i(24,37) - .0863 *i(25,37) - .0384 *i(26,37) - .1473 *i(27,37);\n            x +=  - .1462 *i(28,34) - .1389 *i(29,34) - .2649 *i(30,34) - .2983 *i(31,34) - .0726 *i(28,35) - .1318 *i(29,35) + .0216 *i(30,35) + .1045 *i(31,35) - .0035 *i(28,36) - .1    *i(29,36) + .0376 *i(30,36) + .0752 *i(31,36) - .0164 *i(28,37) - .0457 *i(29,37) + .0206 *i(30,37) + .0844 *i(31,37);\n            x +=  - .1671 *i(32,34) - .2144 *i(33,34) - .1143 *i(34,34) + .0615 *i(35,34) + .0249 *i(32,35) - .0328 *i(33,35) - .0641 *i(34,35) + .0362 *i(35,35) + .0554 *i(32,36) + .0718 *i(33,36) - .0387 *i(34,36) + .07   *i(35,36) + .0654 *i(32,37) + .0678 *i(33,37) + .0294 *i(34,37) - .0158 *i(35,37);\n            x +=  - .0322 *i(36,34) - .067  *i(37,34) - .2878 *i(38,34) - .6811 *i(39,34) - .2031 *i(36,35) - .1055 *i(37,35) + .0269 *i(38,35) + .0109 *i(39,35) - .0317 *i(36,36) + .0004 *i(37,36) + .062  *i(38,36) + .1055 *i(39,36) - .0187 *i(36,37) + .152  *i(37,37) + .0945 *i(38,37) + .1441 *i(39,37) - .2943 ;\n        } else if (F.x == 4) {\n            x =   .0219 *i(0,34) - .0108 *i(1,34) + .0203 *i(2,34) - .1142 *i(3,34) - .0569 *i(0,35) - .0543 *i(1,35) - .2044 *i(2,35) - .0718 *i(3,35) - .0217 *i(0,36) + .0137 *i(1,36) + .0087 *i(2,36) - .2117 *i(3,36) - .1397 *i(0,37) - .0525 *i(1,37) - .0305 *i(2,37) - .1811 *i(3,37);\n            x +=  + .0665 *i(4,34) + .1214 *i(5,34) + .1304 *i(6,34) + .1292 *i(7,34) + .0704 *i(4,35) + .0948 *i(5,35) + .1561 *i(6,35) + .2056 *i(7,35) + .0065 *i(4,36) + .0499 *i(5,36) + .0802 *i(6,36) + .1813 *i(7,36) + .0225 *i(4,37) + .0741 *i(5,37) + .0825 *i(6,37) + .1737 *i(7,37);\n            x +=  - .0098 *i(8,34) + .0625 *i(9,34) + .1236 *i(10,34) + .1292 *i(11,34) - .2086 *i(8,35) - .1372 *i(9,35) + .0447 *i(10,35) + .0546 *i(11,35) - .2249 *i(8,36) - .0335 *i(9,36) + .1201 *i(10,36) + .1143 *i(11,36) - .1499 *i(8,37) - .1125 *i(9,37) - .0768 *i(10,37) - .0537 *i(11,37);\n            x +=  - .22   *i(12,34) + .0212 *i(13,34) + .1029 *i(14,34) + .0523 *i(15,34) - .2779 *i(12,35) - .1369 *i(13,35) + .0104 *i(14,35) + .0248 *i(15,35) - .0891 *i(12,36) - .0719 *i(13,36) + .0115 *i(14,36) + .0254 *i(15,36) - .0475 *i(12,37) - .0611 *i(13,37) - .0304 *i(14,37) - .0057 *i(15,37);\n            x +=  - .0661 *i(16,34) - .0581 *i(17,34) - .015  *i(18,34) - .0274 *i(19,34) + .0395 *i(16,35) + .0761 *i(17,35) + .0456 *i(18,35) + .0377 *i(19,35) - .1196 *i(16,36) - .0321 *i(17,36) + .0161 *i(18,36) + .0149 *i(19,36) - .227  *i(16,37) - .0517 *i(17,37) + .0631 *i(18,37) + .0549 *i(19,37);\n            x +=  + .0545 *i(20,34) + .0256 *i(21,34) + .0436 *i(22,34) + .0479 *i(23,34) - .0841 *i(20,35) - .0134 *i(21,35) - .0066 *i(22,35) - .0656 *i(23,35) - .0316 *i(20,36) + .034  *i(21,36) + .0416 *i(22,36) + .0486 *i(23,36) - .2155 *i(20,37) - .0498 *i(21,37) + .0061 *i(22,37) - .0529 *i(23,37);\n            x +=  + .023  *i(24,34) + .0672 *i(25,34) + .0677 *i(26,34) - .045  *i(27,34) + .113  *i(24,35) + .0139 *i(25,35) - .0724 *i(26,35) - .1391 *i(27,35) + .064  *i(24,36) - .0344 *i(25,36) - .1089 *i(26,36) - .2083 *i(27,36) - .0484 *i(24,37) - .045  *i(25,37) - .0274 *i(26,37) - .0122 *i(27,37);\n            x +=  - .182  *i(28,34) - .2536 *i(29,34) - .2922 *i(30,34) - .4924 *i(31,34) - .2158 *i(28,35) - .2815 *i(29,35) - .326  *i(30,35) - .4415 *i(31,35) - .2057 *i(28,36) - .3187 *i(29,36) - .2574 *i(30,36) - .2672 *i(31,36) + .0106 *i(28,37) - .4507 *i(29,37) - .2503 *i(30,37) - .2304 *i(31,37);\n            x +=  - .2772 *i(32,34) - .2263 *i(33,34) - .1887 *i(34,34) - .2433 *i(35,34) - .0522 *i(32,35) - .1023 *i(33,35) - .1749 *i(34,35) - .3411 *i(35,35) + .0013 *i(32,36) - .1246 *i(33,36) - .2125 *i(34,36) - .3128 *i(35,36) - .1552 *i(32,37) - .2085 *i(33,37) - .2767 *i(34,37) - .2969 *i(35,37);\n            x +=  + .0947 *i(36,34) + .0482 *i(37,34) - .0429 *i(38,34) - .1615 *i(39,34) - .0137 *i(36,35) + .0026 *i(37,35) - .0416 *i(38,35) - .192  *i(39,35) + .0214 *i(36,36) + .1113 *i(37,36) + .0471 *i(38,36) - .0377 *i(39,36) - .1316 *i(36,37) + .0326 *i(37,37) - .0043 *i(38,37) - .0557 *i(39,37) - .4208 ;\n        } else if (F.x == 5) {\n            x =  -.3727 *i(0,34) - .4607 *i(1,34) - .4152 *i(2,34) - .5543 *i(3,34) - .0427 *i(0,35) - .1241 *i(1,35) - .0074 *i(2,35) - .0063 *i(3,35) - .0451 *i(0,36) - .0517 *i(1,36) - .0678 *i(2,36) - .1256 *i(3,36) - .0631 *i(0,37) - .1904 *i(1,37) - .0574 *i(2,37) - .2632 *i(3,37);\n            x +=  + .1316 *i(4,34) + .1561 *i(5,34) + .2204 *i(6,34) + .2542 *i(7,34) + .0872 *i(4,35) + .1063 *i(5,35) + .128  *i(6,35) + .15   *i(7,35) - .0039 *i(4,36) + .0208 *i(5,36) + .064  *i(6,36) + .0896 *i(7,36) + .1072 *i(4,37) + .0943 *i(5,37) + .0867 *i(6,37) + .1674 *i(7,37);\n            x +=  - .004  *i(8,34) + .0998 *i(9,34) + .0141 *i(10,34) - .0172 *i(11,34) - .0645 *i(8,35) - .0019 *i(9,35) + .1221 *i(10,35) + .0889 *i(11,35) - .0469 *i(8,36) + .0483 *i(9,36) + .1409 *i(10,36) + .1458 *i(11,36) - .1937 *i(8,37) - .4351 *i(9,37) - .2482 *i(10,37) - .1599 *i(11,37);\n            x +=  + .1473 *i(12,34) - .358  *i(13,34) - .694  *i(14,34) - .6955 *i(15,34) + .0311 *i(12,35) - .1904 *i(13,35) - .1531 *i(14,35) - .0722 *i(15,35) - .0152 *i(12,36) - .1515 *i(13,36) - .0136 *i(14,36) + .059  *i(15,36) - .1116 *i(12,37) - .2521 *i(13,37) - .0589 *i(14,37) - .0058 *i(15,37);\n            x +=  + .0261 *i(16,34) + .0024 *i(17,34) + .0623 *i(18,34) + .0435 *i(19,34) + .13   *i(16,35) + .0051 *i(17,35) + .0383 *i(18,35) + .0278 *i(19,35) - .098  *i(16,36) - .0514 *i(17,36) + .0157 *i(18,36) + .0344 *i(19,36) - .091  *i(16,37) - .0134 *i(17,37) + .094  *i(18,37) + .1029 *i(19,37);\n            x +=  - .0645 *i(20,34) - .16   *i(21,34) - .199  *i(22,34) - .3632 *i(23,34) + .0343 *i(20,35) - .0675 *i(21,35) - .0523 *i(22,35) - .0462 *i(23,35) + .0417 *i(20,36) + .0038 *i(21,36) + .0082 *i(22,36) + .1469 *i(23,36) - .1882 *i(20,37) - .1325 *i(21,37) - .0091 *i(22,37) + .063  *i(23,37);\n            x +=  - .0981 *i(24,34) - .1869 *i(25,34) - .396  *i(26,34) - .4756 *i(27,34) + .0694 *i(24,35) + .0728 *i(25,35) - .0296 *i(26,35) - .1732 *i(27,35) + .0655 *i(24,36) + .0246 *i(25,36) - .0241 *i(26,36) - .1439 *i(27,36) - .1151 *i(24,37) - .0634 *i(25,37) - .0089 *i(26,37) - .0448 *i(27,37);\n            x +=  - .0068 *i(28,34) - .0996 *i(29,34) - .2572 *i(30,34) - .559  *i(31,34) - .073  *i(28,35) - .1227 *i(29,35) - .2391 *i(30,35) - .2676 *i(31,35) - .0723 *i(28,36) - .1596 *i(29,36) - .1275 *i(30,36) + .0161 *i(31,36) + .0906 *i(28,37) - .2288 *i(29,37) - .0429 *i(30,37) + .1029 *i(31,37);\n            x +=  + .176  *i(32,34) + .0951 *i(33,34) - .0358 *i(34,34) - .5179 *i(35,34) + .0348 *i(32,35) - .0055 *i(33,35) - .1051 *i(34,35) - .4536 *i(35,35) - .0304 *i(32,36) - .0847 *i(33,36) - .2491 *i(34,36) - .331  *i(35,36) + .0321 *i(32,37) + .0335 *i(33,37) - .0068 *i(34,37) - .1193 *i(35,37);\n            x +=  - .104  *i(36,34) - .0763 *i(37,34) - .0041 *i(38,34) - .0527 *i(39,34) - .261  *i(36,35) - .1163 *i(37,35) - .1015 *i(38,35) - .1712 *i(39,35) - .0399 *i(36,36) - .0083 *i(37,36) - .01   *i(38,36) - .1271 *i(39,36) + .1116 *i(36,37) + .0543 *i(37,37) - .0374 *i(38,37) - .0351 *i(39,37) + .0021 ;\n        } else if (F.x == 6) {\n            x =   .0768 *i(0,34) + .0784 *i(1,34) + .024  *i(2,34) - .1183 *i(3,34) + .1224 *i(0,35) + .0408 *i(1,35) - .1234 *i(2,35) - .1564 *i(3,35) - .1345 *i(0,36) - .0698 *i(1,36) - .1048 *i(2,36) - .0219 *i(3,36) - .6683 *i(0,37) - .3863 *i(1,37) - .1923 *i(2,37) + .0178 *i(3,37);\n            x +=  - .0091 *i(4,34) + .0499 *i(5,34) + .1511 *i(6,34) + .2807 *i(7,34) - .0115 *i(4,35) + .0062 *i(5,35) + .1283 *i(6,35) + .1833 *i(7,35) + .0293 *i(4,36) - .0632 *i(5,36) - .0522 *i(6,36) - .0147 *i(7,36) + .0171 *i(4,37) + .0123 *i(5,37) - .0241 *i(6,37) - .046  *i(7,37);\n            x +=  - .009  *i(8,34) - .1294 *i(9,34) - .1759 *i(10,34) - .054  *i(11,34) - .2861 *i(8,35) - .2751 *i(9,35) + .0696 *i(10,35) + .0774 *i(11,35) - .4546 *i(8,36) - .1905 *i(9,36) + .0516 *i(10,36) + .0922 *i(11,36) - .2998 *i(8,37) - .2109 *i(9,37) - .0761 *i(10,37) - .1145 *i(11,37);\n            x +=  - .2402 *i(12,34) - .1243 *i(13,34) - .074  *i(14,34) - .2187 *i(15,34) - .4227 *i(12,35) - .11   *i(13,35) + .013  *i(14,35) + .0155 *i(15,35) - .1769 *i(12,36) + .1164 *i(13,36) + .0462 *i(14,36) + .0794 *i(15,36) - .1012 *i(12,37) - .0889 *i(13,37) + .0241 *i(14,37) + .0063 *i(15,37);\n            x +=  - .0802 *i(16,34) + .0123 *i(17,34) + .0681 *i(18,34) + .0604 *i(19,34) - .2159 *i(16,35) + .0051 *i(17,35) + .0191 *i(18,35) + .0725 *i(19,35) - .2787 *i(16,36) - .0509 *i(17,36) + .0057 *i(18,36) - .0034 *i(19,36) - .4141 *i(16,37) - .0764 *i(17,37) + .0378 *i(18,37) + .0252 *i(19,37);\n            x +=  + .0945 *i(20,34) + .0351 *i(21,34) - .0059 *i(22,34) - .1476 *i(23,34) + .0396 *i(20,35) + .0305 *i(21,35) + .0439 *i(22,35) + .0276 *i(23,35) - .1721 *i(20,36) + .0048 *i(21,36) + .0241 *i(22,36) + .0775 *i(23,36) - .5796 *i(20,37) - .2622 *i(21,37) - .1199 *i(22,37) - .1084 *i(23,37);\n            x +=  - .3054 *i(24,34) + .0403 *i(25,34) + .013  *i(26,34) - .0324 *i(27,34) - .1685 *i(24,35) - .1776 *i(25,35) - .0978 *i(26,35) - .1321 *i(27,35) - .0514 *i(24,36) - .1156 *i(25,36) - .0119 *i(26,36) - .0652 *i(27,36) + .0648 *i(24,37) + .0916 *i(25,37) + .1231 *i(26,37) - .0764 *i(27,37);\n            x +=  - .0366 *i(28,34) - .0588 *i(29,34) + .0123 *i(30,34) + .0828 *i(31,34) + .0827 *i(28,35) + .059  *i(29,35) - .0077 *i(30,35) + .1286 *i(31,35) - .0698 *i(28,36) + .0211 *i(29,36) - .0342 *i(30,36) - .0345 *i(31,36) - .1663 *i(28,37) - .0566 *i(29,37) + .0066 *i(30,37) - .009  *i(31,37);\n            x +=  - .495  *i(32,34) + .1265 *i(33,34) + .106  *i(34,34) + .0805 *i(35,34) - .281  *i(32,35) - .0182 *i(33,35) + .0268 *i(34,35) - .0184 *i(35,35) - .1435 *i(32,36) - .1368 *i(33,36) - .2025 *i(34,36) - .3215 *i(35,36) - .0056 *i(32,37) - .0762 *i(33,37) - .0362 *i(34,37) - .096  *i(35,37);\n            x +=  + .1049 *i(36,34) + .0689 *i(37,34) + .0292 *i(38,34) - .0169 *i(39,34) + .0071 *i(36,35) - .0174 *i(37,35) - .0771 *i(38,35) + .002  *i(39,35) - .2054 *i(36,36) - .1264 *i(37,36) - .1497 *i(38,36) - .0823 *i(39,36) - .3496 *i(36,37) - .1373 *i(37,37) - .0078 *i(38,37) - .0806 *i(39,37) - .5544 ;\n        } else if (F.x == 7) {\n            x =  -.1747 *i(0,34) - .1667 *i(1,34) - .2468 *i(2,34) - .3198 *i(3,34) - .1552 *i(0,35) - .0689 *i(1,35) + .0075 *i(2,35) - .1152 *i(3,35) - .0423 *i(0,36) + .0807 *i(1,36) + .0718 *i(2,36) + .0655 *i(3,36) + .0629 *i(0,37) + .1265 *i(1,37) + .1165 *i(2,37) + .0861 *i(3,37);\n            x +=  + .1409 *i(4,34) + .1245 *i(5,34) + .1588 *i(6,34) + .2542 *i(7,34) + .1254 *i(4,35) + .1389 *i(5,35) + .1015 *i(6,35) + .1125 *i(7,35) + .0741 *i(4,36) + .0444 *i(5,36) - .0311 *i(6,36) - .0297 *i(7,36) - .3304 *i(4,37) - .2547 *i(5,37) - .6433 *i(6,37) - .4574 *i(7,37);\n            x +=  - .0279 *i(8,34) + .1195 *i(9,34) - .2609 *i(10,34) - .1104 *i(11,34) - .1303 *i(8,35) - .1412 *i(9,35) - .2852 *i(10,35) - .1316 *i(11,35) - .0421 *i(8,36) - .0107 *i(9,36) - .0981 *i(10,36) - .0478 *i(11,36) + .1106 *i(8,37) + .0661 *i(9,37) + .0437 *i(10,37) - .0602 *i(11,37);\n            x +=  - .5026 *i(12,34) - .7001 *i(13,34) - .4364 *i(14,34) - .3231 *i(15,34) - .2737 *i(12,35) - .144  *i(13,35) - .1387 *i(14,35) - .1306 *i(15,35) - .0767 *i(12,36) - .0554 *i(13,36) + .0224 *i(14,36) - .238  *i(15,36) - .089  *i(12,37) - .0836 *i(13,37) - .1091 *i(14,37) - .2563 *i(15,37);\n            x +=  - .1421 *i(16,34) + .0368 *i(17,34) + .0415 *i(18,34) - .0449 *i(19,34) + .0188 *i(16,35) + .1045 *i(17,35) + .119  *i(18,35) + .0261 *i(19,35) - .0551 *i(16,36) - .0292 *i(17,36) + .0091 *i(18,36) - .2352 *i(19,36) - .2732 *i(16,37) - .5044 *i(17,37) - .5348 *i(18,37) - .8153 *i(19,37);\n            x +=  - .1662 *i(20,34) - .0742 *i(21,34) - .1642 *i(22,34) - .1736 *i(23,34) - .0506 *i(20,35) + .0566 *i(21,35) + .0439 *i(22,35) - .1836 *i(23,35) + .0164 *i(20,36) + .0519 *i(21,36) + .0705 *i(22,36) - .1492 *i(23,36) - .0326 *i(20,37) + .0397 *i(21,37) + .09   *i(22,37) - .2364 *i(23,37);\n            x +=  + .0312 *i(24,34) - .1502 *i(25,34) - .1122 *i(26,34) - .1693 *i(27,34) + .0168 *i(24,35) - .0133 *i(25,35) - .0039 *i(26,35) - .076  *i(27,35) + .0281 *i(24,36) + .0516 *i(25,36) + .1255 *i(26,36) - .1637 *i(27,36) - .1211 *i(24,37) - .2469 *i(25,37) - .3615 *i(26,37) - .3715 *i(27,37);\n            x +=  + .0923 *i(28,34) + .1006 *i(29,34) + .1228 *i(30,34) + .1589 *i(31,34) - .1128 *i(28,35) + .0584 *i(29,35) + .036  *i(30,35) + .0755 *i(31,35) - .2035 *i(28,36) - .0503 *i(29,36) - .0054 *i(30,36) - .0632 *i(31,36) - .1276 *i(28,37) + .0923 *i(29,37) + .073  *i(30,37) - .029  *i(31,37);\n            x +=  + .1208 *i(32,34) + .0768 *i(33,34) + .1128 *i(34,34) + .1161 *i(35,34) + .0273 *i(32,35) - .0407 *i(33,35) + .1003 *i(34,35) + .1012 *i(35,35) - .0688 *i(32,36) - .2387 *i(33,36) - .0645 *i(34,36) - .0267 *i(35,36) + .0694 *i(32,37) - .0041 *i(33,37) - .0758 *i(34,37) - .0272 *i(35,37);\n            x +=  + .0492 *i(36,34) - .1105 *i(37,34) - .0796 *i(38,34) + .0384 *i(39,34) - .075  *i(36,35) - .1408 *i(37,35) - .1705 *i(38,35) - .0562 *i(39,35) - .1597 *i(36,36) - .2203 *i(37,36) - .2548 *i(38,36) - .1029 *i(39,36) + .0142 *i(36,37) - .3596 *i(37,37) - .228  *i(38,37) - .28   *i(39,37) + .1735 ;\n        } else if (F.x == 8) {\n            x =  -.1399 *i(0,34) - .1726 *i(1,34) - .0787 *i(2,34) + .1017 *i(3,34) - .1507 *i(0,35) - .1729 *i(1,35) - .1012 *i(2,35) + .0303 *i(3,35) - .6822 *i(0,36) - .351  *i(1,36) - .3033 *i(2,36) - .2216 *i(3,36) - .1511 *i(0,37) - .289  *i(1,37) - .2947 *i(2,37) - .2856 *i(3,37);\n            x +=  - .1133 *i(4,34) - .1359 *i(5,34) - .0206 *i(6,34) + .1224 *i(7,34) - .2195 *i(4,35) - .1775 *i(5,35) - .2497 *i(6,35) - .3145 *i(7,35) - .2559 *i(4,36) - .2698 *i(5,36) - .0874 *i(6,36) - .0696 *i(7,36) - .1568 *i(4,37) - .0451 *i(5,37) - .0104 *i(6,37) + .0326 *i(7,37);\n            x +=  - .1286 *i(8,34) + .0785 *i(9,34) + .0223 *i(10,34) + .0997 *i(11,34) + .0361 *i(8,35) + .0397 *i(9,35) + .0487 *i(10,35) + .074  *i(11,35) - .0801 *i(8,36) + .0606 *i(9,36) + .0411 *i(10,36) + .0655 *i(11,36) - .0679 *i(8,37) + .0537 *i(9,37) + .1142 *i(10,37) + .0013 *i(11,37);\n            x +=  + .1347 *i(12,34) + .0744 *i(13,34) - .0897 *i(14,34) - .0071 *i(15,34) + .0982 *i(12,35) - .0617 *i(13,35) - .1512 *i(14,35) - .0361 *i(15,35) + .1084 *i(12,36) + .0144 *i(13,36) + .124  *i(14,36) - .0304 *i(15,36) + .0011 *i(12,37) + .0416 *i(13,37) + .0013 *i(14,37) - .0708 *i(15,37);\n            x +=  - .0753 *i(16,34) - .1324 *i(17,34) - .2111 *i(18,34) - .1627 *i(19,34) + .0173 *i(16,35) - .2131 *i(17,35) - .3816 *i(18,35) - .1906 *i(19,35) + .0693 *i(16,36) - .0161 *i(17,36) - .049  *i(18,36) - .0162 *i(19,36) + .0523 *i(16,37) + .0254 *i(17,37) - .0067 *i(18,37) - .0578 *i(19,37);\n            x +=  + .0045 *i(20,34) - .1385 *i(21,34) - .0291 *i(22,34) + .0051 *i(23,34) - .2324 *i(20,35) - .163  *i(21,35) - .113  *i(22,35) - .0484 *i(23,35) - .2253 *i(20,36) - .2808 *i(21,36) - .1414 *i(22,36) - .0681 *i(23,36) + .0251 *i(20,37) - .164  *i(21,37) - .2884 *i(22,37) - .2438 *i(23,37);\n            x +=  + .2043 *i(24,34) + .0654 *i(25,34) - .0188 *i(26,34) - .2422 *i(27,34) + .0163 *i(24,35) + .0839 *i(25,35) - .1957 *i(26,35) - .2123 *i(27,35) - .0898 *i(24,36) + .1707 *i(25,36) - .0665 *i(26,36) - .3445 *i(27,36) - .0766 *i(24,37) + .0453 *i(25,37) + .0015 *i(26,37) - .1405 *i(27,37);\n            x +=  + .0185 *i(28,34) - .128  *i(29,34) - .2958 *i(30,34) - .5016 *i(31,34) + .0609 *i(28,35) - .1517 *i(29,35) - .4362 *i(30,35) - .5865 *i(31,35) + .0713 *i(28,36) - .1153 *i(29,36) - .2632 *i(30,36) - .3816 *i(31,36) + .1108 *i(28,37) - .0738 *i(29,37) - .167  *i(30,37) - .3853 *i(31,37);\n            x +=  + .0176 *i(32,34) + .073  *i(33,34) - .0466 *i(34,34) - .36   *i(35,34) - .0105 *i(32,35) + .0573 *i(33,35) + .0854 *i(34,35) - .1682 *i(35,35) - .0301 *i(32,36) + .0992 *i(33,36) + .0946 *i(34,36) - .1085 *i(35,36) - .047  *i(32,37) + .114  *i(33,37) + .0934 *i(34,37) - .0039 *i(35,37);\n            x +=  - .2216 *i(36,34) - .035  *i(37,34) + .0228 *i(38,34) + .0957 *i(39,34) - .1488 *i(36,35) - .1384 *i(37,35) + .0331 *i(38,35) - .0488 *i(39,35) - .2937 *i(36,36) - .0894 *i(37,36) + .0276 *i(38,36) - .0509 *i(39,36) - .0315 *i(36,37) - .0115 *i(37,37) - .084  *i(38,37) - .2866 *i(39,37) + .7236 ;\n        } else if (F.x == 9) {\n            x =   .0962 *i(0,34) + .0536 *i(1,34) + .0384 *i(2,34) - .1856 *i(3,34) + .097  *i(0,35) + .0238 *i(1,35) - .0509 *i(2,35) - .2978 *i(3,35) - .1304 *i(0,36) - .0778 *i(1,36) - .1997 *i(2,36) - .3673 *i(3,36) - .2673 *i(0,37) - .3597 *i(1,37) - .3271 *i(2,37) - .2098 *i(3,37);\n            x +=  - .0346 *i(4,34) - .0358 *i(5,34) - .1598 *i(6,34) - .3751 *i(7,34) - .0763 *i(4,35) - .1059 *i(5,35) - .2138 *i(6,35) - .1301 *i(7,35) - .084  *i(4,36) - .0664 *i(5,36) + .0061 *i(6,36) + .0126 *i(7,36) - .1099 *i(4,37) - .0233 *i(5,37) + .0321 *i(6,37) + .0286 *i(7,37);\n            x +=  + .0746 *i(8,34) - .0173 *i(9,34) - .1464 *i(10,34) - .0874 *i(11,34) + .148  *i(8,35) + .0687 *i(9,35) + .0481 *i(10,35) + .0334 *i(11,35) + .0731 *i(8,36) + .0787 *i(9,36) + .0906 *i(10,36) + .0686 *i(11,36) - .0532 *i(8,37) - .0174 *i(9,37) + .0578 *i(10,37) + .0243 *i(11,37);\n            x +=  + .1434 *i(12,34) + .169  *i(13,34) - .1114 *i(14,34) - .4716 *i(15,34) + .1316 *i(12,35) + .0857 *i(13,35) - .1167 *i(14,35) - .6005 *i(15,35) + .1286 *i(12,36) + .0872 *i(13,36) - .0167 *i(14,36) - .2024 *i(15,36) - .036  *i(12,37) + .0047 *i(13,37) + .0143 *i(14,37) - .0524 *i(15,37);\n            x +=  + .0004 *i(16,34) - .0634 *i(17,34) - .1379 *i(18,34) - .2052 *i(19,34) + .1464 *i(16,35) - .0256 *i(17,35) - .1722 *i(18,35) - .0431 *i(19,35) + .1207 *i(16,36) + .0191 *i(17,36) - .0564 *i(18,36) + .0265 *i(19,36) + .1332 *i(16,37) + .0724 *i(17,37) + .0078 *i(18,37) - .0232 *i(19,37);\n            x +=  + .0815 *i(20,34) + .0037 *i(21,34) - .0117 *i(22,34) - .4344 *i(23,34) + .1018 *i(20,35) - .0067 *i(21,35) - .0645 *i(22,35) - .1614 *i(23,35) + .0168 *i(20,36) - .0452 *i(21,36) - .1578 *i(22,36) - .0787 *i(23,36) + .1169 *i(20,37) + .001  *i(21,37) - .0888 *i(22,37) - .1229 *i(23,37);\n            x +=  - .0734 *i(24,34) + .07   *i(25,34) - .0181 *i(26,34) - .0876 *i(27,34) - .1059 *i(24,35) - .0324 *i(25,35) - .1073 *i(26,35) - .3223 *i(27,35) - .131  *i(24,36) - .2024 *i(25,36) - .1656 *i(26,36) - .2004 *i(27,36) + .0502 *i(24,37) - .0166 *i(25,37) - .0768 *i(26,37) + .0864 *i(27,37);\n            x +=  - .074  *i(28,34) - .1692 *i(29,34) - .1914 *i(30,34) - .214  *i(31,34) - .1059 *i(28,35) - .0621 *i(29,35) - .0085 *i(30,35) - .065  *i(31,35) + .0112 *i(28,36) + .0237 *i(29,36) - .0309 *i(30,36) - .3268 *i(31,36) + .0715 *i(28,37) + .0417 *i(29,37) - .0477 *i(30,37) - .3539 *i(31,37);\n            x +=  - .2359 *i(32,34) + .0608 *i(33,34) + .0842 *i(34,34) + .0864 *i(35,34) - .1185 *i(32,35) + .0752 *i(33,35) + .0504 *i(34,35) - .0209 *i(35,35) - .1799 *i(32,36) + .0905 *i(33,36) + .0473 *i(34,36) + .0185 *i(35,36) - .5943 *i(32,37) - .0871 *i(33,37) - .0072 *i(34,37) + .0152 *i(35,37);\n            x +=  + .0383 *i(36,34) + .0076 *i(37,34) - .085  *i(38,34) - .0801 *i(39,34) - .0811 *i(36,35) - .0513 *i(37,35) - .0619 *i(38,35) + .0134 *i(39,35) - .5447 *i(36,36) - .036  *i(37,36) - .0476 *i(38,36) - .034  *i(39,36) - .3746 *i(36,37) - .0659 *i(37,37) - .115  *i(38,37) - .2193 *i(39,37) + .0885 ;\n        } else if (F.x == 10) {\n            x =  -.1868 *i(0,34) - .3594 *i(1,34) - .2472 *i(2,34) - .0762 *i(3,34) + .0182 *i(0,35) - .0099 *i(1,35) - .0661 *i(2,35) - .1678 *i(3,35) + .0983 *i(0,36) + .0915 *i(1,36) + .0751 *i(2,36) - .0309 *i(3,36) + .0833 *i(0,37) + .1039 *i(1,37) + .1378 *i(2,37) + .1488 *i(3,37);\n            x +=  + .1241 *i(4,34) + .0774 *i(5,34) + .1269 *i(6,34) + .0071 *i(7,34) + .0533 *i(4,35) + .058  *i(5,35) + .0835 *i(6,35) + .0405 *i(7,35) + .0324 *i(4,36) + .0252 *i(5,36) + .0338 *i(6,36) + .0597 *i(7,36) - .2916 *i(4,37) - .2858 *i(5,37) - .1386 *i(6,37) - .0798 *i(7,37);\n            x +=  - .2159 *i(8,34) + .028  *i(9,34) + .1016 *i(10,34) + .1233 *i(11,34) - .1149 *i(8,35) + .0027 *i(9,35) + .0603 *i(10,35) + .0773 *i(11,35) - .2207 *i(8,36) - .1748 *i(9,36) - .051  *i(10,36) - .003  *i(11,36) - .0106 *i(8,37) - .0251 *i(9,37) - .0882 *i(10,37) - .0717 *i(11,37);\n            x +=  - .3839 *i(12,34) - .1737 *i(13,34) + .1129 *i(14,34) + .1269 *i(15,34) - .2746 *i(12,35) - .1144 *i(13,35) + .0036 *i(14,35) + .0103 *i(15,35) - .1301 *i(12,36) - .1297 *i(13,36) - .0126 *i(14,36) + .0045 *i(15,36) - .1529 *i(12,37) - .1404 *i(13,37) - .0586 *i(14,37) - .0511 *i(15,37);\n            x +=  - .1696 *i(16,34) - .0832 *i(17,34) - .052  *i(18,34) - .0925 *i(19,34) - .1708 *i(16,35) - .0021 *i(17,35) + .0131 *i(18,35) - .0227 *i(19,35) - .4001 *i(16,36) - .096  *i(17,36) - .0628 *i(18,36) - .0089 *i(19,36) - .3645 *i(16,37) - .476  *i(17,37) - .6002 *i(18,37) - .4198 *i(19,37);\n            x +=  - .1578 *i(20,34) - .0384 *i(21,34) + .0476 *i(22,34) + .1301 *i(23,34) - .0925 *i(20,35) - .0141 *i(21,35) + .034  *i(22,35) + .0678 *i(23,35) - .0569 *i(20,36) - .0555 *i(21,36) - .0572 *i(22,36) - .0018 *i(23,36) - .0682 *i(20,37) - .0793 *i(21,37) - .0518 *i(22,37) - .1683 *i(23,37);\n            x +=  - .006  *i(24,34) - .1212 *i(25,34) - .307  *i(26,34) - .2843 *i(27,34) - .0117 *i(24,35) - .1157 *i(25,35) - .0284 *i(26,35) - .0177 *i(27,35) + .0079 *i(24,36) - .0121 *i(25,36) + .0165 *i(26,36) + .0935 *i(27,36) - .2707 *i(24,37) - .1363 *i(25,37) - .0506 *i(26,37) + .0937 *i(27,37);\n            x +=  + .047  *i(28,34) + .0931 *i(29,34) + .1029 *i(30,34) + .1603 *i(31,34) + .0328 *i(28,35) + .066  *i(29,35) + .0382 *i(30,35) + .0193 *i(31,35) - .1642 *i(28,36) - .0204 *i(29,36) - .0337 *i(30,36) - .2441 *i(31,36) - .1072 *i(28,37) - .3592 *i(29,37) - .3612 *i(30,37) - .552  *i(31,37);\n            x +=  + .1558 *i(32,34) + .0321 *i(33,34) - .0055 *i(34,34) - .066  *i(35,34) + .0079 *i(32,35) - .1356 *i(33,35) - .0664 *i(34,35) - .1778 *i(35,35) - .0629 *i(32,36) - .2611 *i(33,36) - .1378 *i(34,36) - .1783 *i(35,36) + .0863 *i(32,37) - .0103 *i(33,37) - .0922 *i(34,37) - .0577 *i(35,37);\n            x +=  + .0315 *i(36,34) + .0842 *i(37,34) + .1174 *i(38,34) + .1621 *i(39,34) + .0995 *i(36,35) + .0955 *i(37,35) + .0812 *i(38,35) + .0945 *i(39,35) - .0855 *i(36,36) + .0161 *i(37,36) + .0388 *i(38,36) + .0191 *i(39,36) - .3972 *i(36,37) - .6863 *i(37,37) - .7047 *i(38,37) - .7502 *i(39,37) + .1032 ;\n        } else if (F.x == 11) {\n            x =   .0477 *i(0,34) - .0854 *i(1,34) - .0432 *i(2,34) + .0397 *i(3,34) - .2075 *i(0,35) - .0741 *i(1,35) - .0442 *i(2,35) + .0203 *i(3,35) - .3733 *i(0,36) - .1958 *i(1,36) - .1848 *i(2,36) - .1602 *i(3,36) - .2048 *i(0,37) - .2264 *i(1,37) - .3201 *i(2,37) - .2375 *i(3,37);\n            x +=  - .0128 *i(4,34) - .0228 *i(5,34) - .0122 *i(6,34) - .183  *i(7,34) - .2458 *i(4,35) - .2017 *i(5,35) - .115  *i(6,35) - .2655 *i(7,35) - .4516 *i(4,36) - .4128 *i(5,36) - .0603 *i(6,36) + .0637 *i(7,36) - .4494 *i(4,37) - .3871 *i(5,37) - .2775 *i(6,37) - .3323 *i(7,37);\n            x +=  - .0048 *i(8,34) + .107  *i(9,34) + .1177 *i(10,34) + .1774 *i(11,34) - .0796 *i(8,35) + .0567 *i(9,35) + .1076 *i(10,35) + .1445 *i(11,35) + .1198 *i(8,36) + .1051 *i(9,36) + .0076 *i(10,36) + .0438 *i(11,36) + .0649 *i(8,37) + .0771 *i(9,37) + .0669 *i(10,37) - .0973 *i(11,37);\n            x +=  + .0875 *i(12,34) + .0539 *i(13,34) + .1457 *i(14,34) + .112  *i(15,34) + .0512 *i(12,35) - .0879 *i(13,35) + .0746 *i(14,35) + .0812 *i(15,35) + .0775 *i(12,36) + .0185 *i(13,36) + .0327 *i(14,36) + .082  *i(15,36) - .0292 *i(12,37) - .0575 *i(13,37) - .1202 *i(14,37) - .1325 *i(15,37);\n            x +=  - .0949 *i(16,34) - .1578 *i(17,34) - .0506 *i(18,34) + .025  *i(19,34) - .0007 *i(16,35) - .2657 *i(17,35) - .2492 *i(18,35) - .0492 *i(19,35) - .4205 *i(16,36) - .3292 *i(17,36) - .2997 *i(18,36) - .391  *i(19,36) - .3736 *i(16,37) - .5533 *i(17,37) - .4997 *i(18,37) - .4512 *i(19,37);\n            x +=  + .0195 *i(20,34) + .0074 *i(21,34) + .0671 *i(22,34) + .1207 *i(23,34) - .1326 *i(20,35) - .0424 *i(21,35) - .0068 *i(22,35) + .0656 *i(23,35) - .1805 *i(20,36) - .0198 *i(21,36) - .1702 *i(22,36) - .2542 *i(23,36) - .3496 *i(20,37) - .2172 *i(21,37) - .4522 *i(22,37) - .6332 *i(23,37);\n            x +=  + .1723 *i(24,34) + .0772 *i(25,34) + .0371 *i(26,34) - .0222 *i(27,34) + .0948 *i(24,35) + .0371 *i(25,35) - .0023 *i(26,35) - .1404 *i(27,35) + .0038 *i(24,36) + .0301 *i(25,36) - .0259 *i(26,36) - .0091 *i(27,36) - .1792 *i(24,37) - .113  *i(25,37) - .0328 *i(26,37) - .1169 *i(27,37);\n            x +=  - .0101 *i(28,34) - .0442 *i(29,34) - .0331 *i(30,34) - .0031 *i(31,34) + .0248 *i(28,35) - .0838 *i(29,35) - .1482 *i(30,35) - .1123 *i(31,35) + .0634 *i(28,36) - .183  *i(29,36) - .5126 *i(30,36) - .3389 *i(31,36) + .1249 *i(28,37) - .1272 *i(29,37) - 1.0097*i(30,37) - .4947 *i(31,37);\n            x +=  + .094  *i(32,34) + .1073 *i(33,34) - .0923 *i(34,34) - .2023 *i(35,34) + .0967 *i(32,35) + .1309 *i(33,35) + .0759 *i(34,35) - .2721 *i(35,35) + .0948 *i(32,36) + .1258 *i(33,36) + .0956 *i(34,36) - .0867 *i(35,36) + .1836 *i(32,37) + .122  *i(33,37) + .1227 *i(34,37) + .0467 *i(35,37);\n            x +=  + .0294 *i(36,34) + .0187 *i(37,34) - .002  *i(38,34) + .0285 *i(39,34) + .0221 *i(36,35) - .0743 *i(37,35) - .0714 *i(38,35) - .0292 *i(39,35) - .1194 *i(36,36) - .1937 *i(37,36) - .1497 *i(38,36) - .3115 *i(39,36) + .0303 *i(36,37) - .1169 *i(37,37) - .16   *i(38,37) - .3165 *i(39,37) + 1.0283;\n        } else if (F.x == 12) {\n            x =  -.373  *i(0,34) - .2998 *i(1,34) - .3054 *i(2,34) - .1623 *i(3,34) - .0538 *i(0,35) - .0103 *i(1,35) - .0695 *i(2,35) + .0313 *i(3,35) + .1133 *i(0,36) + .0537 *i(1,36) + .0359 *i(2,36) + .0212 *i(3,36) + .1699 *i(0,37) + .0398 *i(1,37) + .0826 *i(2,37) + .0687 *i(3,37);\n            x +=  - .0511 *i(4,34) - .2927 *i(5,34) - .6771 *i(6,34) - .2937 *i(7,34) + .002  *i(4,35) - .0621 *i(5,35) - .2695 *i(6,35) - .2553 *i(7,35) + .1098 *i(4,36) - .0412 *i(5,36) - .0706 *i(6,36) - .0724 *i(7,36) + .0621 *i(4,37) - .1109 *i(5,37) - .1118 *i(6,37) - .1729 *i(7,37);\n            x +=  - .489  *i(8,34) - .4397 *i(9,34) - .6256 *i(10,34) - .2085 *i(11,34) - .3682 *i(8,35) - .2242 *i(9,35) - .383  *i(10,35) - .3661 *i(11,35) - .0352 *i(8,36) - .0618 *i(9,36) + .0236 *i(10,36) - .0272 *i(11,36) + .1027 *i(8,37) + .0537 *i(9,37) + .0639 *i(10,37) + .0118 *i(11,37);\n            x +=  - 1.0886*i(12,34) - .5125 *i(13,34) - .1275 *i(14,34) - .013  *i(15,34) - 1.2091*i(12,35) - .6248 *i(13,35) - .6193 *i(14,35) - .2515 *i(15,35) - .2612 *i(12,36) - .1182 *i(13,36) - .023  *i(14,36) + .003  *i(15,36) - .0229 *i(12,37) - .0192 *i(13,37) + .0076 *i(14,37) + .0051 *i(15,37);\n            x +=  + .0153 *i(16,34) + .0459 *i(17,34) + .032  *i(18,34) + .0028 *i(19,34) - .2327 *i(16,35) - .0234 *i(17,35) - .0093 *i(18,35) - .1074 *i(19,35) - .1789 *i(16,36) - .0278 *i(17,36) - .0742 *i(18,36) - .0154 *i(19,36) - .1774 *i(16,37) - .1719 *i(17,37) - .2048 *i(18,37) - .2154 *i(19,37);\n            x +=  - .5221 *i(20,34) - .3625 *i(21,34) - .3142 *i(22,34) - .1014 *i(23,34) - .3891 *i(20,35) - .1346 *i(21,35) - .0977 *i(22,35) - .2725 *i(23,35) - .0006 *i(20,36) + .0305 *i(21,36) - .0117 *i(22,36) - .0558 *i(23,36) + .0581 *i(20,37) + .0453 *i(21,37) + .0566 *i(22,37) + .0902 *i(23,37);\n            x +=  - .0128 *i(24,34) - .3335 *i(25,34) - .1454 *i(26,34) - .1494 *i(27,34) + .0459 *i(24,35) - .1439 *i(25,35) - .0377 *i(26,35) - .1577 *i(27,35) + .0572 *i(24,36) - .0434 *i(25,36) - .0842 *i(26,36) - .124  *i(27,36) + .0579 *i(24,37) - .0321 *i(25,37) - .2182 *i(26,37) - .0919 *i(27,37);\n            x +=  + .0607 *i(28,34) + .0844 *i(29,34) + .1523 *i(30,34) + .365  *i(31,34) + .1098 *i(28,35) + .1225 *i(29,35) + .061  *i(30,35) + .2765 *i(31,35) - .0323 *i(28,36) + .1466 *i(29,36) + .0496 *i(30,36) + .214  *i(31,36) - .1907 *i(28,37) + .1301 *i(29,37) - .0101 *i(30,37) + .0253 *i(31,37);\n            x +=  + .0607 *i(32,34) - .197  *i(33,34) - .1208 *i(34,34) + .0563 *i(35,34) + .0481 *i(32,35) - .0557 *i(33,35) - .0183 *i(34,35) + .1518 *i(35,35) + .0676 *i(32,36) - .0281 *i(33,36) - .0348 *i(34,36) - .0048 *i(35,36) + .024  *i(32,37) - .2107 *i(33,37) - .277  *i(34,37) - .3343 *i(35,37);\n            x +=  - .3194 *i(36,34) - .3736 *i(37,34) - .3171 *i(38,34) - .0236 *i(39,34) + .1398 *i(36,35) - .0308 *i(37,35) - .238  *i(38,35) + .1241 *i(39,35) + .2111 *i(36,36) + .0583 *i(37,36) - .1485 *i(38,36) + .082  *i(39,36) + .1483 *i(36,37) - .0081 *i(37,37) - .1129 *i(38,37) - .0387 *i(39,37) - .1691 ;\n        } else if (F.x == 13) {\n            x =  -.2015 *i(0,34) - .027  *i(1,34) + .0246 *i(2,34) + .0995 *i(3,34) - .2937 *i(0,35) + .028  *i(1,35) + .0499 *i(2,35) + .106  *i(3,35) - .2735 *i(0,36) - .0367 *i(1,36) + .0683 *i(2,36) + .0935 *i(3,36) - .0534 *i(0,37) - .0172 *i(1,37) + .1026 *i(2,37) + .1111 *i(3,37);\n            x +=  + .077  *i(4,34) - .0241 *i(5,34) - .3479 *i(6,34) - .3496 *i(7,34) + .0669 *i(4,35) + .003  *i(5,35) - .5067 *i(6,35) - .8627 *i(7,35) + .1409 *i(4,36) - .0001 *i(5,36) - .3639 *i(6,36) - .3795 *i(7,36) + .0473 *i(4,37) - .1363 *i(5,37) - .2468 *i(6,37) - .1527 *i(7,37);\n            x +=  - .2719 *i(8,34) - .2533 *i(9,34) - .0964 *i(10,34) - .148  *i(11,34) - .0504 *i(8,35) - .0431 *i(9,35) - .0782 *i(10,35) - .2722 *i(11,35) + .1225 *i(8,36) + .1607 *i(9,36) - .0499 *i(10,36) - .1433 *i(11,36) + .0975 *i(8,37) + .0912 *i(9,37) + .0499 *i(10,37) - .018  *i(11,37);\n            x +=  - 1.0408*i(12,34) - .705  *i(13,34) - .2138 *i(14,34) - .3931 *i(15,34) - .2181 *i(12,35) - .1289 *i(13,35) - .2078 *i(14,35) - .5134 *i(15,35) - .0316 *i(12,36) + .1004 *i(13,36) + .0037 *i(14,36) - .4968 *i(15,36) - .0128 *i(12,37) + .0035 *i(13,37) + .0068 *i(14,37) - .0756 *i(15,37);\n            x +=  - .0859 *i(16,34) - .0684 *i(17,34) - .0257 *i(18,34) - .0188 *i(19,34) - .5492 *i(16,35) - .4091 *i(17,35) - .2517 *i(18,35) - .272  *i(19,35) - .1488 *i(16,36) - .1304 *i(17,36) - .2168 *i(18,36) - .2902 *i(19,36) - .0516 *i(16,37) - .0775 *i(17,37) - .3904 *i(18,37) - .3608 *i(19,37);\n            x +=  - .3242 *i(20,34) - .1117 *i(21,34) - .0163 *i(22,34) - .0103 *i(23,34) - .3954 *i(20,35) - .051  *i(21,35) - .0039 *i(22,35) - .1089 *i(23,35) - .1935 *i(20,36) + .0458 *i(21,36) + .0499 *i(22,36) - .112  *i(23,36) - .0482 *i(20,37) + .1097 *i(21,37) + .1256 *i(22,37) + .0293 *i(23,37);\n            x +=  + .0988 *i(24,34) - .1574 *i(25,34) - .0743 *i(26,34) + .072  *i(27,34) + .065  *i(24,35) - .0833 *i(25,35) - .0908 *i(26,35) + .0678 *i(27,35) + .0632 *i(24,36) + .0063 *i(25,36) - .1564 *i(26,36) - .0659 *i(27,36) + .0081 *i(24,37) - .123  *i(25,37) - .4212 *i(26,37) - .3024 *i(27,37);\n            x +=  + .091  *i(28,34) + .1297 *i(29,34) + .0764 *i(30,34) - .092  *i(31,34) + .0809 *i(28,35) + .1205 *i(29,35) + .0692 *i(30,35) - .0438 *i(31,35) - .1081 *i(28,36) + .133  *i(29,36) + .0717 *i(30,36) + .0401 *i(31,36) - .2126 *i(28,37) + .0811 *i(29,37) + .0151 *i(30,37) + .0207 *i(31,37);\n            x +=  + .149  *i(32,34) + .0671 *i(33,34) - .157  *i(34,34) - .1017 *i(35,34) + .0747 *i(32,35) - .0052 *i(33,35) - .0793 *i(34,35) + .0289 *i(35,35) + .0734 *i(32,36) - .0805 *i(33,36) - .1169 *i(34,36) + .0598 *i(35,36) - .0553 *i(32,37) - .2511 *i(33,37) - .1636 *i(34,37) - .0371 *i(35,37);\n            x +=  - .0282 *i(36,34) + .0206 *i(37,34) - .0591 *i(38,34) - .1086 *i(39,34) + .1721 *i(36,35) + .1045 *i(37,35) - .0108 *i(38,35) - .2019 *i(39,35) + .1802 *i(36,36) + .1363 *i(37,36) + .0249 *i(38,36) - .0773 *i(39,36) + .0882 *i(36,37) + .047  *i(37,37) - .0146 *i(38,37) - .0062 *i(39,37) + .1046 ;\n        } else if (F.x == 14) {\n            x =   .0768 *i(0,34) + .0466 *i(1,34) + .0649 *i(2,34) - .0416 *i(3,34) - .138  *i(0,35) + .084  *i(1,35) + .066  *i(2,35) - .1421 *i(3,35) - .1105 *i(0,36) - .1982 *i(1,36) - .1323 *i(2,36) - .0971 *i(3,36) - .1702 *i(0,37) - .1057 *i(1,37) - .2185 *i(2,37) - .1658 *i(3,37);\n            x +=  - .5273 *i(4,34) - .3216 *i(5,34) - .3286 *i(6,34) - .4719 *i(7,34) + .0106 *i(4,35) - .0057 *i(5,35) - .1348 *i(6,35) - .3134 *i(7,35) + .0782 *i(4,36) + .0603 *i(5,36) + .0222 *i(6,36) - .1879 *i(7,36) + .0471 *i(4,37) + .0464 *i(5,37) - .007  *i(6,37) - .1233 *i(7,37);\n            x +=  + .0905 *i(8,34) + .0787 *i(9,34) - .2449 *i(10,34) - .5492 *i(11,34) - .0613 *i(8,35) - .0052 *i(9,35) - .1585 *i(10,35) - .139  *i(11,35) - .4076 *i(8,36) - .2354 *i(9,36) + .0263 *i(10,36) + .0294 *i(11,36) - .3661 *i(8,37) - .2767 *i(9,37) - .003  *i(10,37) + .0332 *i(11,37);\n            x +=  - .1398 *i(12,34) - .0464 *i(13,34) - .0915 *i(14,34) - .5276 *i(15,34) - .3407 *i(12,35) - .0952 *i(13,35) - .0839 *i(14,35) - .5843 *i(15,35) - .0607 *i(12,36) - .1829 *i(13,36) - .3637 *i(14,36) - .4465 *i(15,36) + .0064 *i(12,37) + .0146 *i(13,37) - .0309 *i(14,37) - .1058 *i(15,37);\n            x +=  + .015  *i(16,34) - .0701 *i(17,34) - .0897 *i(18,34) - .0352 *i(19,34) - .3891 *i(16,35) - .0013 *i(17,35) - .0044 *i(18,35) - .0793 *i(19,35) - .1987 *i(16,36) - .0152 *i(17,36) + .0432 *i(18,36) + .0105 *i(19,36) - .0725 *i(16,37) - .094  *i(17,37) + .0184 *i(18,37) + .0228 *i(19,37);\n            x +=  + .0714 *i(20,34) + .0058 *i(21,34) - .0184 *i(22,34) - .2953 *i(23,34) + .0376 *i(20,35) + .0386 *i(21,35) + .0126 *i(22,35) - .2065 *i(23,35) - .2814 *i(20,36) - .2042 *i(21,36) - .1328 *i(22,36) - .0079 *i(23,36) - .1996 *i(20,37) - .0992 *i(21,37) - .0161 *i(22,37) + .0675 *i(23,37);\n            x +=  - .7128 *i(24,34) + .051  *i(25,34) + .0755 *i(26,34) + .0556 *i(27,34) - .1261 *i(24,35) - .007  *i(25,35) + .0692 *i(26,35) + .0864 *i(27,35) + .0937 *i(24,36) + .0696 *i(25,36) + .0317 *i(26,36) - .1456 *i(27,36) + .1789 *i(24,37) + .13   *i(25,37) + .1086 *i(26,37) - .05   *i(27,37);\n            x +=  - .0492 *i(28,34) - .4698 *i(29,34) - .5665 *i(30,34) - .5019 *i(31,34) + .0392 *i(28,35) - .1995 *i(29,35) + .0066 *i(30,35) - .1071 *i(31,35) - .1573 *i(28,36) + .0119 *i(29,36) + .0767 *i(30,36) + .0905 *i(31,36) - .2867 *i(28,37) + .0043 *i(29,37) + .0412 *i(30,37) + .0861 *i(31,37);\n            x +=  - .8068 *i(32,34) - .1518 *i(33,34) - .0284 *i(34,34) + .077  *i(35,34) - .3355 *i(32,35) - .2057 *i(33,35) + .0296 *i(34,35) + .0346 *i(35,35) - .0186 *i(32,36) + .0086 *i(33,36) + .0559 *i(34,36) + .0618 *i(35,36) + .0105 *i(32,37) + .0214 *i(33,37) - .1062 *i(34,37) - .0506 *i(35,37);\n            x +=  + .0558 *i(36,34) - .0238 *i(37,34) - .1363 *i(38,34) - .7216 *i(39,34) + .0916 *i(36,35) + .0958 *i(37,35) - .0274 *i(38,35) - .1148 *i(39,35) + .0686 *i(36,36) + .0348 *i(37,36) + .0919 *i(38,36) + .1129 *i(39,36) - .286  *i(36,37) + .071  *i(37,37) + .1167 *i(38,37) + .1423 *i(39,37) - .2139 ;\n        } else if (F.x == 15) {\n            x =  -.1363 *i(0,34) - .221  *i(1,34) - .4392 *i(2,34) - .8526 *i(3,34) - .0772 *i(0,35) - .0862 *i(1,35) + .0123 *i(2,35) + .0002 *i(3,35) - .134  *i(0,36) + .0184 *i(1,36) + .0425 *i(2,36) + .088  *i(3,36) - .1138 *i(0,37) + .0196 *i(1,37) + .0851 *i(2,37) + .0708 *i(3,37);\n            x +=  + .085  *i(4,34) + .1396 *i(5,34) + .0671 *i(6,34) - .0266 *i(7,34) + .0324 *i(4,35) + .093  *i(5,35) + .1039 *i(6,35) - .0403 *i(7,35) - .0476 *i(4,36) + .0832 *i(5,36) + .0941 *i(6,36) - .0416 *i(7,36) + .0887 *i(4,37) + .0728 *i(5,37) + .0462 *i(6,37) + .0234 *i(7,37);\n            x +=  - .1916 *i(8,34) + .1747 *i(9,34) + .0364 *i(10,34) - .0697 *i(11,34) - .0375 *i(8,35) + .0791 *i(9,35) + .0328 *i(10,35) - .1843 *i(11,35) - .054  *i(8,36) + .0259 *i(9,36) - .1917 *i(10,36) - .1511 *i(11,36) - .2136 *i(8,37) - .1825 *i(9,37) - .0639 *i(10,37) - .0634 *i(11,37);\n            x +=  - .2225 *i(12,34) - .0458 *i(13,34) - .5216 *i(14,34) - .362  *i(15,34) - .1962 *i(12,35) - .1106 *i(13,35) - .2863 *i(14,35) - .7371 *i(15,35) - .0601 *i(12,36) - .1717 *i(13,36) - .1953 *i(14,36) - .7179 *i(15,36) - .0743 *i(12,37) - .0471 *i(13,37) - .1232 *i(14,37) - .2381 *i(15,37);\n            x +=  - .2794 *i(16,34) - .0869 *i(17,34) + .1101 *i(18,34) + .1191 *i(19,34) - .0296 *i(16,35) - .1566 *i(17,35) + .047  *i(18,35) + .0783 *i(19,35) - .0163 *i(16,36) - .0911 *i(17,36) - .013  *i(18,36) - .0737 *i(19,36) + .0769 *i(16,37) + .0241 *i(17,37) + .126  *i(18,37) + .1022 *i(19,37);\n            x +=  - .2436 *i(20,34) - .1836 *i(21,34) - .2264 *i(22,34) - .3439 *i(23,34) - .1684 *i(20,35) - .0112 *i(21,35) + .0186 *i(22,35) - .3455 *i(23,35) - .0577 *i(20,36) - .0167 *i(21,36) - .0171 *i(22,36) - .115  *i(23,36) - .0658 *i(20,37) - .0494 *i(21,37) + .0247 *i(22,37) + .1535 *i(23,37);\n            x +=  - .177  *i(24,34) - .3636 *i(25,34) - .1807 *i(26,34) - .0315 *i(27,34) - .0699 *i(24,35) - .043  *i(25,35) + .0898 *i(26,35) + .1706 *i(27,35) - .0538 *i(24,36) + .0011 *i(25,36) + .147  *i(26,36) + .17   *i(27,36) - .067  *i(24,37) - .0159 *i(25,37) - .0046 *i(26,37) + .035  *i(27,37);\n            x +=  - .0413 *i(28,34) - .1277 *i(29,34) - .3359 *i(30,34) - .795  *i(31,34) + .0902 *i(28,35) - .0565 *i(29,35) - .1917 *i(30,35) - .8109 *i(31,35) + .111  *i(28,36) - .0076 *i(29,36) - .0445 *i(30,36) - .0684 *i(31,36) + .053  *i(28,37) - .0442 *i(29,37) + .024  *i(30,37) + .0838 *i(31,37);\n            x +=  + .1196 *i(32,34) + .0094 *i(33,34) - .3821 *i(34,34) - .6425 *i(35,34) + .042  *i(32,35) + .0666 *i(33,35) - .2007 *i(34,35) - .0783 *i(35,35) - .0248 *i(32,36) + .0088 *i(33,36) - .0309 *i(34,36) + .0524 *i(35,36) - .0563 *i(32,37) - .0359 *i(33,37) + .0968 *i(34,37) + .0666 *i(35,37);\n            x +=  - .3115 *i(36,34) - .2044 *i(37,34) - .1706 *i(38,34) - .1232 *i(39,34) - .162  *i(36,35) - .0674 *i(37,35) - .1652 *i(38,35) - .4797 *i(39,35) - .0771 *i(36,36) + .0236 *i(37,36) + .0605 *i(38,36) - .0736 *i(39,36) - .014  *i(36,37) + .184  *i(37,37) + .1576 *i(38,37) + .1561 *i(39,37) + .6938 ;\n        } else if (F.x == 16) {\n            x =   .0511 *i(0,34) + .0494 *i(1,34) + .0876 *i(2,34) + .133  *i(3,34) + .1622 *i(0,35) + .0661 *i(1,35) + .0518 *i(2,35) + .1495 *i(3,35) + .0231 *i(0,36) - .0087 *i(1,36) + .0207 *i(2,36) + .116  *i(3,36) - .2117 *i(0,37) - .2157 *i(1,37) - .2151 *i(2,37) - .1721 *i(3,37);\n            x +=  - .1183 *i(4,34) - .0333 *i(5,34) + .0178 *i(6,34) + .1015 *i(7,34) - .0632 *i(4,35) - .0634 *i(5,35) + .003  *i(6,35) - .0992 *i(7,35) + .063  *i(4,36) - .0821 *i(5,36) - .0251 *i(6,36) - .3109 *i(7,36) + .0327 *i(4,37) - .0082 *i(5,37) - .0155 *i(6,37) - .121  *i(7,37);\n            x +=  + .0087 *i(8,34) - .0776 *i(9,34) - .3863 *i(10,34) - .052  *i(11,34) - .1011 *i(8,35) - .1202 *i(9,35) - .1664 *i(10,35) - .2592 *i(11,35) - .4294 *i(8,36) - .22   *i(9,36) - .1171 *i(10,36) - .0744 *i(11,36) - .4609 *i(8,37) - .3093 *i(9,37) - .0532 *i(10,37) - .0983 *i(11,37);\n            x +=  - .0282 *i(12,34) - .0894 *i(13,34) - .2726 *i(14,34) - .1689 *i(15,34) - .3724 *i(12,35) - .0506 *i(13,35) - .0876 *i(14,35) - .3928 *i(15,35) - .314  *i(12,36) + .0333 *i(13,36) - .003  *i(14,36) - .2574 *i(15,36) - .1288 *i(12,37) - .1364 *i(13,37) - .0996 *i(14,37) - .2348 *i(15,37);\n            x +=  + .1455 *i(16,34) + .0928 *i(17,34) - .0506 *i(18,34) - .0758 *i(19,34) - .1325 *i(16,35) + .0271 *i(17,35) - .1077 *i(18,35) - .2073 *i(19,35) - .248  *i(16,36) + .0377 *i(17,36) + .0245 *i(18,36) - .011  *i(19,36) - .1854 *i(16,37) - .0171 *i(17,37) + .0601 *i(18,37) + .051  *i(19,37);\n            x +=  + .0898 *i(20,34) + .0206 *i(21,34) - .0732 *i(22,34) + .0435 *i(23,34) + .098  *i(20,35) + .037  *i(21,35) + .0587 *i(22,35) + .0039 *i(23,35) - .0759 *i(20,36) + .0188 *i(21,36) + .0654 *i(22,36) + .0377 *i(23,36) - .5634 *i(20,37) - .1719 *i(21,37) - .0016 *i(22,37) + .0687 *i(23,37);\n            x +=  - .5039 *i(24,34) + .0787 *i(25,34) + .0485 *i(26,34) - .0814 *i(27,34) - .3095 *i(24,35) - .0638 *i(25,35) - .1629 *i(26,35) - .0136 *i(27,35) - .0407 *i(24,36) - .0574 *i(25,36) - .1463 *i(26,36) - .0391 *i(27,36) + .1339 *i(24,37) + .0961 *i(25,37) + .0825 *i(26,37) - .0636 *i(27,37);\n            x +=  - .0728 *i(28,34) - .0156 *i(29,34) + .0134 *i(30,34) + .1512 *i(31,34) + .0595 *i(28,35) + .0713 *i(29,35) + .0148 *i(30,35) - .0035 *i(31,35) - .0913 *i(28,36) + .0578 *i(29,36) - .0083 *i(30,36) + .0433 *i(31,36) - .3403 *i(28,37) - .0004 *i(29,37) + .0275 *i(30,37) + .0727 *i(31,37);\n            x +=  - .1379 *i(32,34) + .0678 *i(33,34) + .0104 *i(34,34) - .1127 *i(35,34) - .3352 *i(32,35) - .1164 *i(33,35) - .1139 *i(34,35) - .0187 *i(35,35) - .1016 *i(32,36) - .2245 *i(33,36) - .0588 *i(34,36) + .0217 *i(35,36) + .1356 *i(32,37) + .0283 *i(33,37) - .0423 *i(34,37) + .002  *i(35,37);\n            x +=  + .0828 *i(36,34) - .0741 *i(37,34) + .0806 *i(38,34) + .1334 *i(39,34) + .0698 *i(36,35) - .0577 *i(37,35) - .0372 *i(38,35) + .0309 *i(39,35) - .0642 *i(36,36) - .0195 *i(37,36) - .0452 *i(38,36) + .0011 *i(39,36) - .2698 *i(36,37) - .0016 *i(37,37) + .069  *i(38,37) + .1053 *i(39,37) - .3733 ;\n        } else if (F.x == 17) {\n            x =  -.2503 *i(0,34) - .4196 *i(1,34) - .2551 *i(2,34) - .0772 *i(3,34) - .0248 *i(0,35) - .0966 *i(1,35) - .1128 *i(2,35) - .0441 *i(3,35) - .0051 *i(0,36) + .0215 *i(1,36) + .0287 *i(2,36) + .074  *i(3,36) - .012  *i(0,37) + .0057 *i(1,37) - .0071 *i(2,37) - .0101 *i(3,37);\n            x +=  + .0828 *i(4,34) + .0687 *i(5,34) + .0539 *i(6,34) + .1156 *i(7,34) + .0696 *i(4,35) + .0652 *i(5,35) + .0748 *i(6,35) + .0656 *i(7,35) + .0044 *i(4,36) + .0077 *i(5,36) + .0095 *i(6,36) + .0578 *i(7,36) + .0896 *i(4,37) + .0564 *i(5,37) + .0353 *i(6,37) - .0027 *i(7,37);\n            x +=  - .3075 *i(8,34) - .0221 *i(9,34) + .0827 *i(10,34) + .116  *i(11,34) - .3431 *i(8,35) - .2126 *i(9,35) - .0622 *i(10,35) + .0494 *i(11,35) - .268  *i(8,36) - .3885 *i(9,36) - .2649 *i(10,36) - .1477 *i(11,36) - .3244 *i(8,37) - .1614 *i(9,37) + .0223 *i(10,37) - .0693 *i(11,37);\n            x +=  - .7503 *i(12,34) - .2254 *i(13,34) - .0061 *i(14,34) + .0487 *i(15,34) - .5508 *i(12,35) - .2942 *i(13,35) - .0204 *i(14,35) + .0563 *i(15,35) - .126  *i(12,36) - .103  *i(13,36) - .165  *i(14,36) - .0529 *i(15,36) - .0633 *i(12,37) - .015  *i(13,37) + .0262 *i(14,37) - .1305 *i(15,37);\n            x +=  - .138  *i(16,34) - .0342 *i(17,34) + .0008 *i(18,34) - .0353 *i(19,34) - .2978 *i(16,35) - .1227 *i(17,35) + .0034 *i(18,35) - .0459 *i(19,35) - .1348 *i(16,36) - .0251 *i(17,36) - .012  *i(18,36) - .1211 *i(19,36) + .0405 *i(16,37) + .0546 *i(17,37) + .1041 *i(18,37) + .0962 *i(19,37);\n            x +=  - .2949 *i(20,34) - .0507 *i(21,34) + .0307 *i(22,34) + .1138 *i(23,34) - .1153 *i(20,35) - .03   *i(21,35) + .0256 *i(22,35) + .042  *i(23,35) - .0662 *i(20,36) - .0105 *i(21,36) - .0178 *i(22,36) - .0899 *i(23,36) - .106  *i(20,37) - .1303 *i(21,37) - .0453 *i(22,37) - .0086 *i(23,37);\n            x +=  + .0283 *i(24,34) - .1684 *i(25,34) - .2203 *i(26,34) - .104  *i(27,34) + .0394 *i(24,35) - .0706 *i(25,35) - .1082 *i(26,35) + .0144 *i(27,35) + .0645 *i(24,36) + .0321 *i(25,36) + .0255 *i(26,36) + .0971 *i(27,36) + .0352 *i(24,37) - .0138 *i(25,37) + .032  *i(26,37) - .0598 *i(27,37);\n            x +=  + .0648 *i(28,34) + .0915 *i(29,34) + .0948 *i(30,34) + .0996 *i(31,34) + .0281 *i(28,35) + .0723 *i(29,35) + .0695 *i(30,35) + .0313 *i(31,35) - .1332 *i(28,36) - .0047 *i(29,36) - .0507 *i(30,36) - .1236 *i(31,36) - .2309 *i(28,37) + .0016 *i(29,37) - .0274 *i(30,37) + .0336 *i(31,37);\n            x +=  + .1197 *i(32,34) + .0108 *i(33,34) - .1135 *i(34,34) - .2066 *i(35,34) + .0437 *i(32,35) - .0674 *i(33,35) - .1053 *i(34,35) - .2041 *i(35,35) - .0544 *i(32,36) - .0828 *i(33,36) - .0107 *i(34,36) + .0341 *i(35,36) - .2148 *i(32,37) - .1272 *i(33,37) + .064  *i(34,37) + .059  *i(35,37);\n            x +=  - .029  *i(36,34) + .0587 *i(37,34) + .0998 *i(38,34) + .1628 *i(39,34) + .0723 *i(36,35) + .086  *i(37,35) + .0501 *i(38,35) + .1422 *i(39,35) - .0702 *i(36,36) - .0314 *i(37,36) - .0033 *i(38,36) - .0367 *i(39,36) - .1146 *i(36,37) - .0159 *i(37,37) + .0783 *i(38,37) + .0907 *i(39,37) - .896  ;\n        } else if (F.x == 18) {\n            x =   .0593 *i(0,34) + .0289 *i(1,34) + .0097 *i(2,34) - .022  *i(3,34) + .1712 *i(0,35) + .0046 *i(1,35) - .1148 *i(2,35) - .1321 *i(3,35) + .0851 *i(0,36) - .2103 *i(1,36) - .1085 *i(2,36) - .2047 *i(3,36) - .6587 *i(0,37) - .3877 *i(1,37) - .3085 *i(2,37) - .2712 *i(3,37);\n            x +=  + .0159 *i(4,34) - .0406 *i(5,34) - .1391 *i(6,34) - .2937 *i(7,34) - .108  *i(4,35) - .0253 *i(5,35) - .0475 *i(6,35) - .2028 *i(7,35) - .1256 *i(4,36) + .0051 *i(5,36) + .0484 *i(6,36) + .0577 *i(7,36) - .049  *i(4,37) + .0998 *i(5,37) + .0987 *i(6,37) + .0983 *i(7,37);\n            x +=  + .0665 *i(8,34) - .0607 *i(9,34) - .1085 *i(10,34) - .0133 *i(11,34) + .1189 *i(8,35) + .0156 *i(9,35) + .1328 *i(10,35) + .0904 *i(11,35) + .0802 *i(8,36) - .005  *i(9,36) + .0528 *i(10,36) + .0495 *i(11,36) - .3502 *i(8,37) - .3326 *i(9,37) - .1838 *i(10,37) - .0777 *i(11,37);\n            x +=  + .1116 *i(12,34) + .0536 *i(13,34) - .0997 *i(14,34) - .5211 *i(15,34) + .1511 *i(12,35) + .0746 *i(13,35) - .0476 *i(14,35) - .1075 *i(15,35) + .1499 *i(12,36) + .0306 *i(13,36) - .0177 *i(14,36) + .0319 *i(15,36) - .0514 *i(12,37) - .041  *i(13,37) - .0622 *i(14,37) - .0732 *i(15,37);\n            x +=  - .0329 *i(16,34) - .0457 *i(17,34) - .0208 *i(18,34) - .0674 *i(19,34) + .1584 *i(16,35) + .0662 *i(17,35) + .0238 *i(18,35) + .0515 *i(19,35) - .0335 *i(16,36) - .0963 *i(17,36) - .0299 *i(18,36) + .0325 *i(19,36) - .6634 *i(16,37) - .2701 *i(17,37) - .0074 *i(18,37) + .0052 *i(19,37);\n            x +=  + .0795 *i(20,34) + .0159 *i(21,34) - .0462 *i(22,34) - .2247 *i(23,34) + .1019 *i(20,35) + .0406 *i(21,35) + .0208 *i(22,35) + .0582 *i(23,35) + .084  *i(20,36) + .0424 *i(21,36) + .0115 *i(22,36) + .0746 *i(23,36) - .2654 *i(20,37) - .2706 *i(21,37) - .1761 *i(22,37) - .0889 *i(23,37);\n            x +=  + .1371 *i(24,34) + .1301 *i(25,34) + .0682 *i(26,34) + .0405 *i(27,34) - .1016 *i(24,35) - .0661 *i(25,35) - .0877 *i(26,35) - .1045 *i(27,35) - .3211 *i(24,36) - .2062 *i(25,36) - .0648 *i(26,36) - .2151 *i(27,36) - .1589 *i(24,37) + .0052 *i(25,37) + .0875 *i(26,37) + .0487 *i(27,37);\n            x +=  - .1396 *i(28,34) - .2497 *i(29,34) - .3878 *i(30,34) - .4134 *i(31,34) - .1987 *i(28,35) - .2027 *i(29,35) - .1174 *i(30,35) + .0054 *i(31,35) + .1136 *i(28,36) - .116  *i(29,36) - .1376 *i(30,36) - .0694 *i(31,36) + .1649 *i(28,37) - .1338 *i(29,37) - .1071 *i(30,37) + .0138 *i(31,37);\n            x +=  - .0604 *i(32,34) + .0627 *i(33,34) + .089  *i(34,34) + .0892 *i(35,34) - .1351 *i(32,35) + .0726 *i(33,35) + .0718 *i(34,35) + .0016 *i(35,35) - .5848 *i(32,36) - .276  *i(33,36) - .071  *i(34,36) - .1271 *i(35,36) - .7285 *i(32,37) - .3546 *i(33,37) - .1006 *i(34,37) - .0969 *i(35,37);\n            x +=  + .0099 *i(36,34) - .0383 *i(37,34) - .0021 *i(38,34) - .0786 *i(39,34) - .0231 *i(36,35) + .0702 *i(37,35) + .0937 *i(38,35) + .1107 *i(39,35) + .1121 *i(36,36) + .148  *i(37,36) + .1131 *i(38,36) + .0594 *i(39,36) + .0035 *i(36,37) + .0442 *i(37,37) + .0342 *i(38,37) + .0465 *i(39,37) - .8138 ;\n        } else if (F.x == 19) {\n            x =  -.9082 *i(0,34) - .5555 *i(1,34) - .5225 *i(2,34) - .5396 *i(3,34) - .8155 *i(0,35) - .5933 *i(1,35) - .5637 *i(2,35) - .3568 *i(3,35) - .1579 *i(0,36) - .4374 *i(1,36) - .5427 *i(2,36) - .3001 *i(3,36) + .0161 *i(0,37) - .2789 *i(1,37) - .278  *i(2,37) - .0665 *i(3,37);\n            x +=  - .6598 *i(4,34) - .3898 *i(5,34) - .2804 *i(6,34) - .4504 *i(7,34) - .1245 *i(4,35) - .083  *i(5,35) + .0165 *i(6,35) + .0675 *i(7,35) - .0885 *i(4,36) - .0303 *i(5,36) + .04   *i(6,36) + .0455 *i(7,36) + .1054 *i(4,37) + .0864 *i(5,37) + .0735 *i(6,37) + .0992 *i(7,37);\n            x +=  - .3152 *i(8,34) + .147  *i(9,34) + .0008 *i(10,34) - .0172 *i(11,34) + .1144 *i(8,35) + .0328 *i(9,35) + .0294 *i(10,35) + .0445 *i(11,35) + .1682 *i(8,36) - .0056 *i(9,36) - .0226 *i(10,36) + .0616 *i(11,36) + .0749 *i(8,37) - .013  *i(9,37) - .008  *i(10,37) + .0434 *i(11,37);\n            x +=  - .1537 *i(12,34) - .1014 *i(13,34) - .3532 *i(14,34) - .4729 *i(15,34) - .1692 *i(12,35) - .1234 *i(13,35) - .3155 *i(14,35) - .3707 *i(15,35) - .031  *i(12,36) - .0004 *i(13,36) - .0344 *i(14,36) + .1109 *i(15,36) + .0129 *i(12,37) - .0384 *i(13,37) - .0489 *i(14,37) - .0063 *i(15,37);\n            x +=  + .071  *i(16,34) - .0282 *i(17,34) - .037  *i(18,34) - .0272 *i(19,34) + .2181 *i(16,35) + .0566 *i(17,35) + .0047 *i(18,35) + .1119 *i(19,35) + .1837 *i(16,36) + .1119 *i(17,36) + .0686 *i(18,36) + .0785 *i(19,36) + .2194 *i(16,37) + .1365 *i(17,37) + .0642 *i(18,37) + .0034 *i(19,37);\n            x +=  - .8161 *i(20,34) - .3415 *i(21,34) - .2753 *i(22,34) - .2538 *i(23,34) - .2041 *i(20,35) - .1646 *i(21,35) - .2459 *i(22,35) - .2266 *i(23,35) + .0914 *i(20,36) - .1645 *i(21,36) - .2427 *i(22,36) - .1047 *i(23,36) + .2093 *i(20,37) + .0127 *i(21,37) - .0141 *i(22,37) + .0425 *i(23,37);\n            x +=  - .1108 *i(24,34) - .2114 *i(25,34) - .3947 *i(26,34) - .5901 *i(27,34) - .0016 *i(24,35) + .0112 *i(25,35) - .0702 *i(26,35) - .4957 *i(27,35) - .0001 *i(24,36) - .0352 *i(25,36) - .006  *i(26,36) - .1956 *i(27,36) + .1377 *i(24,37) - .0151 *i(25,37) - .068  *i(26,37) - .0216 *i(27,37);\n            x +=  + .0203 *i(28,34) - .0451 *i(29,34) - .1205 *i(30,34) - .1276 *i(31,34) + .0351 *i(28,35) - .0216 *i(29,35) - .1393 *i(30,35) - .2572 *i(31,35) + .0361 *i(28,36) + .0416 *i(29,36) - .0626 *i(30,36) - .1547 *i(31,36) - .007  *i(28,37) + .0993 *i(29,37) - .0446 *i(30,37) - .2213 *i(31,37);\n            x +=  + .08   *i(32,34) + .0056 *i(33,34) - .0085 *i(34,34) - .2219 *i(35,34) + .0988 *i(32,35) + .0539 *i(33,35) - .032  *i(34,35) - .2402 *i(35,35) + .1657 *i(32,36) + .1516 *i(33,36) + .0835 *i(34,36) - .0788 *i(35,36) + .1031 *i(32,37) + .1101 *i(33,37) + .0469 *i(34,37) - .1208 *i(35,37);\n            x +=  - .3274 *i(36,34) - .1594 *i(37,34) - .0847 *i(38,34) + .0854 *i(39,34) - .3726 *i(36,35) - .1313 *i(37,35) - .1223 *i(38,35) - .0968 *i(39,35) - .2831 *i(36,36) - .0568 *i(37,36) - .1093 *i(38,36) - .231  *i(39,36) - .1259 *i(36,37) - .0573 *i(37,37) - .1416 *i(38,37) - .1693 *i(39,37) + .3399 ;\n        } else if (F.x == 20) {\n            x =   .1154 *i(0,34) + .0601 *i(1,34) + .0143 *i(2,34) + .0412 *i(3,34) + .0967 *i(0,35) + .0877 *i(1,35) + .0238 *i(2,35) + .0271 *i(3,35) + .0877 *i(0,36) + .1028 *i(1,36) + .0477 *i(2,36) - .0216 *i(3,36) + .1593 *i(0,37) + .1064 *i(1,37) + .149  *i(2,37) + .1139 *i(3,37);\n            x +=  - .418  *i(4,34) - .326  *i(5,34) - .3121 *i(6,34) - .1042 *i(7,34) - .3194 *i(4,35) - .2629 *i(5,35) - .2424 *i(6,35) - .2242 *i(7,35) - .1254 *i(4,36) - .2534 *i(5,36) - .4809 *i(6,36) - .3164 *i(7,36) - .1363 *i(4,37) - .1943 *i(5,37) - .4136 *i(6,37) - .1373 *i(7,37);\n            x +=  + .1001 *i(8,34) + .023  *i(9,34) - .2106 *i(10,34) + .0331 *i(11,34) - .0201 *i(8,35) + .0198 *i(9,35) - .2751 *i(10,35) - .0868 *i(11,35) + .0421 *i(8,36) + .0198 *i(9,36) + .1025 *i(10,36) + .0141 *i(11,36) + .1112 *i(8,37) + .0782 *i(9,37) + .0631 *i(10,37) + .0574 *i(11,37);\n            x +=  - .2547 *i(12,34) - .1014 *i(13,34) - .1269 *i(14,34) - .2479 *i(15,34) - .6039 *i(12,35) - .1911 *i(13,35) - .1199 *i(14,35) - .2279 *i(15,35) - .3098 *i(12,36) - .3469 *i(13,36) - .1405 *i(14,36) - .2445 *i(15,36) - .0233 *i(12,37) - .0845 *i(13,37) + .0263 *i(14,37) - .0228 *i(15,37);\n            x +=  + .0723 *i(16,34) - .0076 *i(17,34) - .057  *i(18,34) - .0439 *i(19,34) - .0951 *i(16,35) - .3604 *i(17,35) - .1883 *i(18,35) - .2628 *i(19,35) + .0627 *i(16,36) - .2918 *i(17,36) - .1574 *i(18,36) - .2197 *i(19,36) + .124  *i(16,37) - .1868 *i(17,37) - .3965 *i(18,37) - .3477 *i(19,37);\n            x +=  + .1022 *i(20,34) + .0136 *i(21,34) - .0069 *i(22,34) + .0712 *i(23,34) + .0341 *i(20,35) - .0003 *i(21,35) - .0625 *i(22,35) + .0218 *i(23,35) - .1402 *i(20,36) - .1996 *i(21,36) - .3717 *i(22,36) - .1571 *i(23,36) + .087  *i(20,37) + .0919 *i(21,37) + .0474 *i(22,37) - .0327 *i(23,37);\n            x +=  - .1372 *i(24,34) + .1303 *i(25,34) + .0909 *i(26,34) + .0636 *i(27,34) - .1508 *i(24,35) + .1045 *i(25,35) + .0925 *i(26,35) + .0617 *i(27,35) + .0304 *i(24,36) - .0678 *i(25,36) + .0493 *i(26,36) + .0581 *i(27,36) + .0692 *i(24,37) - .1187 *i(25,37) - .4065 *i(26,37) - .1775 *i(27,37);\n            x +=  - .0787 *i(28,34) + .0474 *i(29,34) + .1028 *i(30,34) + .1086 *i(31,34) - .1685 *i(28,35) - .0296 *i(29,35) + .0592 *i(30,35) + .0503 *i(31,35) - .1387 *i(28,36) - .0136 *i(29,36) + .0795 *i(30,36) - .1467 *i(31,36) - .2028 *i(28,37) + .0104 *i(29,37) + .0469 *i(30,37) - .0279 *i(31,37);\n            x +=  - .7179 *i(32,34) - .1949 *i(33,34) + .0039 *i(34,34) + .0411 *i(35,34) - .1796 *i(32,35) - .2817 *i(33,35) + .0701 *i(34,35) + .0491 *i(35,35) + .1151 *i(32,36) - .1197 *i(33,36) + .0674 *i(34,36) + .0903 *i(35,36) + .1771 *i(32,37) + .0154 *i(33,37) - .1627 *i(34,37) + .0031 *i(35,37);\n            x +=  + .0819 *i(36,34) - .0269 *i(37,34) + .0655 *i(38,34) + .0813 *i(39,34) + .0806 *i(36,35) + .0033 *i(37,35) + .0585 *i(38,35) + .0519 *i(39,35) + .0838 *i(36,36) - .139  *i(37,36) - .1296 *i(38,36) - .0854 *i(39,36) - .0636 *i(36,37) - .2552 *i(37,37) - .2739 *i(38,37) - .1159 *i(39,37) + .6637 ;\n        } else if (F.x == 21) {\n            x =   .1185 *i(0,34) + .0726 *i(1,34) + .0907 *i(2,34) + .1243 *i(3,34) + .1704 *i(0,35) + .1013 *i(1,35) + .0433 *i(2,35) + .0957 *i(3,35) + .0881 *i(0,36) + .1503 *i(1,36) + .0704 *i(2,36) - .0185 *i(3,36) + .1649 *i(0,37) + .2079 *i(1,37) + .1471 *i(2,37) + .0209 *i(3,37);\n            x +=  - .1507 *i(4,34) - .459  *i(5,34) - .5374 *i(6,34) - .5736 *i(7,34) - .2841 *i(4,35) - .3892 *i(5,35) - .4837 *i(6,35) - .2576 *i(7,35) - .4255 *i(4,36) - .3821 *i(5,36) - .1684 *i(6,36) - .0493 *i(7,36) - .3125 *i(4,37) - .3248 *i(5,37) - .0908 *i(6,37) + .0534 *i(7,37);\n            x +=  + .0388 *i(8,34) + .1378 *i(9,34) - .1091 *i(10,34) - .2992 *i(11,34) + .1305 *i(8,35) + .1654 *i(9,35) - .2824 *i(10,35) - .3675 *i(11,35) + .0989 *i(8,36) + .0683 *i(9,36) - .0418 *i(10,36) - .236  *i(11,36) + .1364 *i(8,37) + .0367 *i(9,37) - .1618 *i(10,37) - .0673 *i(11,37);\n            x +=  - .1524 *i(12,34) + .0681 *i(13,34) - .3394 *i(14,34) - .5398 *i(15,34) - .5398 *i(12,35) - .5922 *i(13,35) - .4288 *i(14,35) - .847  *i(15,35) - .2976 *i(12,36) - .3654 *i(13,36) - .1099 *i(14,36) - .1337 *i(15,36) - .0902 *i(12,37) - .1641 *i(13,37) + .0138 *i(14,37) - .0735 *i(15,37);\n            x +=  - .1339 *i(16,34) - .4069 *i(17,34) - .2795 *i(18,34) - .0069 *i(19,34) - .1149 *i(16,35) - .6296 *i(17,35) - .6217 *i(18,35) + .0335 *i(19,35) + .0144 *i(16,36) - .2091 *i(17,36) - .4676 *i(18,36) - .1363 *i(19,36) + .0832 *i(16,37) - .1666 *i(17,37) - .5197 *i(18,37) - .3808 *i(19,37);\n            x +=  + .0215 *i(20,34) - .0231 *i(21,34) + .0044 *i(22,34) - .3023 *i(23,34) + .0788 *i(20,35) + .042  *i(21,35) + .0507 *i(22,35) - .2686 *i(23,35) + .0994 *i(20,36) + .0499 *i(21,36) + .054  *i(22,36) - .1102 *i(23,36) + .1743 *i(20,37) + .1144 *i(21,37) - .0369 *i(22,37) - .2496 *i(23,37);\n            x +=  - .1304 *i(24,34) - .0147 *i(25,34) - .0873 *i(26,34) - .3194 *i(27,34) - .0874 *i(24,35) + .0849 *i(25,35) + .0605 *i(26,35) - .0135 *i(27,35) - .0411 *i(24,36) - .0061 *i(25,36) + .0922 *i(26,36) + .1315 *i(27,36) - .059  *i(24,37) - .2469 *i(25,37) + .0918 *i(26,37) + .1498 *i(27,37);\n            x +=  + .0184 *i(28,34) - .088  *i(29,34) - .2188 *i(30,34) - .2695 *i(31,34) + .0363 *i(28,35) - .0965 *i(29,35) - .1315 *i(30,35) - .082  *i(31,35) - .0249 *i(28,36) - .0992 *i(29,36) - .0636 *i(30,36) - .0315 *i(31,36) - .0501 *i(28,37) - .1392 *i(29,37) - .0575 *i(30,37) - .1107 *i(31,37);\n            x +=  - .0538 *i(32,34) - .0563 *i(33,34) - .1038 *i(34,34) - .0839 *i(35,34) - .1007 *i(32,35) - .1197 *i(33,35) + .0582 *i(34,35) - .0229 *i(35,35) - .0027 *i(32,36) - .0802 *i(33,36) + .0773 *i(34,36) + .0738 *i(35,36) + .0945 *i(32,37) - .0778 *i(33,37) - .0014 *i(34,37) + .0178 *i(35,37);\n            x +=  - .2899 *i(36,34) - .2632 *i(37,34) - .2101 *i(38,34) - .1982 *i(39,34) - .0345 *i(36,35) - .0314 *i(37,35) - .1278 *i(38,35) - .2063 *i(39,35) + .1891 *i(36,36) + .0836 *i(37,36) + .0482 *i(38,36) - .2023 *i(39,36) + .1946 *i(36,37) + .0799 *i(37,37) - .389  *i(38,37) - .3937 *i(39,37) + .5877 ;\n        } else if (F.x == 22) {\n            x =   .1285 *i(0,34) - .0392 *i(1,34) + .0696 *i(2,34) + .0794 *i(3,34) + .1765 *i(0,35) + .0538 *i(1,35) + .057  *i(2,35) + .1222 *i(3,35) + .1894 *i(0,36) + .1329 *i(1,36) + .0488 *i(2,36) + .1496 *i(3,36) + .2926 *i(0,37) + .1592 *i(1,37) + .0641 *i(2,37) + .1704 *i(3,37);\n            x +=  - .0284 *i(4,34) - .0442 *i(5,34) - .0977 *i(6,34) - .3674 *i(7,34) - .0132 *i(4,35) - .0699 *i(5,35) - .2565 *i(6,35) - .4869 *i(7,35) - .0935 *i(4,36) - .1817 *i(5,36) - .2033 *i(6,36) - .1929 *i(7,36) - .2562 *i(4,37) - .2803 *i(5,37) - .2457 *i(6,37) - .0258 *i(7,37);\n            x +=  - .0968 *i(8,34) - .3325 *i(9,34) - .311  *i(10,34) - .5529 *i(11,34) - .2259 *i(8,35) + .0301 *i(9,35) + .0485 *i(10,35) - .7469 *i(11,35) + .0403 *i(8,36) + .0988 *i(9,36) + .0337 *i(10,36) - .2648 *i(11,36) + .1521 *i(8,37) + .0816 *i(9,37) + .0084 *i(10,37) - .0688 *i(11,37);\n            x +=  - .4946 *i(12,34) - .416  *i(13,34) - .2292 *i(14,34) - .4813 *i(15,34) - .992  *i(12,35) - .0273 *i(13,35) - .1949 *i(14,35) - .9198 *i(15,35) - .299  *i(12,36) + .0053 *i(13,36) + .0982 *i(14,36) - .366  *i(15,36) - .0523 *i(12,37) - .0303 *i(13,37) + .0458 *i(14,37) + .0377 *i(15,37);\n            x +=  - .0238 *i(16,34) - .0497 *i(17,34) - .0301 *i(18,34) - .0219 *i(19,34) - .411  *i(16,35) - .3954 *i(17,35) - .3213 *i(18,35) - .2771 *i(19,35) - .1958 *i(16,36) - .2548 *i(17,36) - .1977 *i(18,36) - .221  *i(19,36) + .0653 *i(16,37) - .055  *i(17,37) - .2762 *i(18,37) - .5759 *i(19,37);\n            x +=  + .0545 *i(20,34) - .0903 *i(21,34) - .0148 *i(22,34) - .0304 *i(23,34) + .0813 *i(20,35) - .0259 *i(21,35) - .0432 *i(22,35) - .0711 *i(23,35) + .1069 *i(20,36) + .067  *i(21,36) + .1149 *i(22,36) + .031  *i(23,36) + .1579 *i(20,37) + .0112 *i(21,37) + .1125 *i(22,37) + .1232 *i(23,37);\n            x +=  + .0562 *i(24,34) + .0923 *i(25,34) + .0078 *i(26,34) + .1091 *i(27,34) - .072  *i(24,35) - .0314 *i(25,35) - .1481 *i(26,35) + .0633 *i(27,35) - .2094 *i(24,36) - .3053 *i(25,36) - .3465 *i(26,36) - .0451 *i(27,36) - .2902 *i(24,37) - .6183 *i(25,37) - .5303 *i(26,37) - .1913 *i(27,37);\n            x +=  + .059  *i(28,34) + .127  *i(29,34) + .1013 *i(30,34) + .1137 *i(31,34) - .0099 *i(28,35) + .1148 *i(29,35) + .0868 *i(30,35) + .0713 *i(31,35) - .0176 *i(28,36) + .0802 *i(29,36) + .0421 *i(30,36) + .0748 *i(31,36) - .1884 *i(28,37) - .0027 *i(29,37) - .0999 *i(30,37) + .036  *i(31,37);\n            x +=  + .051  *i(32,34) + .0062 *i(33,34) - .1395 *i(34,34) - .0752 *i(35,34) - .1105 *i(32,35) - .1025 *i(33,35) - .0971 *i(34,35) + .0118 *i(35,35) - .2127 *i(32,36) - .1941 *i(33,36) - .1355 *i(34,36) + .0515 *i(35,36) - .0142 *i(32,37) - .4098 *i(33,37) - .313  *i(34,37) - .0272 *i(35,37);\n            x +=  - .1883 *i(36,34) + .0137 *i(37,34) - .0438 *i(38,34) - .1946 *i(39,34) - .124  *i(36,35) - .014  *i(37,35) - .0272 *i(38,35) - .2238 *i(39,35) - .1433 *i(36,36) - .1232 *i(37,36) - .0689 *i(38,36) - .0881 *i(39,36) - .086  *i(36,37) - .2685 *i(37,37) - .1969 *i(38,37) - .0984 *i(39,37) + .3834 ;\n        } else if (F.x == 23) {\n            x =  -.231  *i(0,34) - .3376 *i(1,34) - .2263 *i(2,34) - .1138 *i(3,34) - .104  *i(0,35) - .045  *i(1,35) - .1532 *i(2,35) - .0468 *i(3,35) - .0035 *i(0,36) + .0613 *i(1,36) + .0532 *i(2,36) - .1698 *i(3,36) + .1364 *i(0,37) + .1392 *i(1,37) + .1362 *i(2,37) + .0967 *i(3,37);\n            x +=  + .0751 *i(4,34) - .0233 *i(5,34) + .0294 *i(6,34) + .0907 *i(7,34) - .0767 *i(4,35) - .1011 *i(5,35) - .0416 *i(6,35) - .1237 *i(7,35) - .3392 *i(4,36) - .2977 *i(5,36) - .1033 *i(6,36) - .0661 *i(7,36) - .2549 *i(4,37) - .2844 *i(5,37) - .1477 *i(6,37) - .0385 *i(7,37);\n            x +=  - .5306 *i(8,34) - .4461 *i(9,34) + .042  *i(10,34) + .0967 *i(11,34) + .1237 *i(8,35) - .1956 *i(9,35) + .0352 *i(10,35) + .0794 *i(11,35) + .1543 *i(8,36) - .0109 *i(9,36) - .167  *i(10,36) - .067  *i(11,36) + .0873 *i(8,37) + .0201 *i(9,37) - .1366 *i(10,37) - .124  *i(11,37);\n            x +=  + .0364 *i(12,34) - .7388 *i(13,34) - .0501 *i(14,34) - .1445 *i(15,34) + .0435 *i(12,35) - .4874 *i(13,35) - .3496 *i(14,35) - .0572 *i(15,35) - .0717 *i(12,36) - .2753 *i(13,36) - .2944 *i(14,36) - .0252 *i(15,36) - .1113 *i(12,37) - .2039 *i(13,37) - .1291 *i(14,37) - .1021 *i(15,37);\n            x +=  - .0922 *i(16,34) - .1085 *i(17,34) - .0214 *i(18,34) + .0006 *i(19,34) + .1061 *i(16,35) - .1382 *i(17,35) - .218  *i(18,35) - .0918 *i(19,35) + .0404 *i(16,36) - .0637 *i(17,36) - .3487 *i(18,36) - .0946 *i(19,36) + .0141 *i(16,37) - .0918 *i(17,37) - .285  *i(18,37) - .5449 *i(19,37);\n            x +=  - .2439 *i(20,34) - .1456 *i(21,34) + .0303 *i(22,34) + .0728 *i(23,34) - .0684 *i(20,35) - .0263 *i(21,35) - .0253 *i(22,35) + .0429 *i(23,35) + .0776 *i(20,36) + .0805 *i(21,36) - .0228 *i(22,36) + .0218 *i(23,36) + .1439 *i(20,37) + .1351 *i(21,37) + .1228 *i(22,37) - .2171 *i(23,37);\n            x +=  + .2119 *i(24,34) + .1046 *i(25,34) + .0499 *i(26,34) - .111  *i(27,34) + .1299 *i(24,35) + .0787 *i(25,35) - .0179 *i(26,35) - .1746 *i(27,35) - .0344 *i(24,36) + .0442 *i(25,36) + .0236 *i(26,36) - .0153 *i(27,36) - .1174 *i(24,37) - .388  *i(25,37) - .0385 *i(26,37) + .0795 *i(27,37);\n            x +=  - .0836 *i(28,34) + .0821 *i(29,34) + .0742 *i(30,34) + .077  *i(31,34) - .0892 *i(28,35) + .0511 *i(29,35) + .0421 *i(30,35) + .0609 *i(31,35) + .0527 *i(28,36) - .1313 *i(29,36) - .0688 *i(30,36) - .0585 *i(31,36) + .1654 *i(28,37) - .0048 *i(29,37) - .2651 *i(30,37) - .4792 *i(31,37);\n            x +=  + .1002 *i(32,34) + .032  *i(33,34) - .0327 *i(34,34) - .2268 *i(35,34) + .0984 *i(32,35) + .066  *i(33,35) - .1414 *i(34,35) - .3257 *i(35,35) + .0557 *i(32,36) + .0679 *i(33,36) + .001  *i(34,36) - .1547 *i(35,36) - .3378 *i(32,37) - .1079 *i(33,37) - .0299 *i(34,37) - .0869 *i(35,37);\n            x +=  - .0596 *i(36,34) + .1349 *i(37,34) + .1001 *i(38,34) + .1676 *i(39,34) - .0386 *i(36,35) + .1072 *i(37,35) + .0862 *i(38,35) + .1102 *i(39,35) + .2003 *i(36,36) + .0594 *i(37,36) + .0524 *i(38,36) + .0681 *i(39,36) + .1287 *i(36,37) - .0973 *i(37,37) - .3025 *i(38,37) - .5154 *i(39,37) - .775  ;\n        } else if (F.x == 24) {\n            x =  -.1524 *i(0,34) - .1004 *i(1,34) - .0919 *i(2,34) - .3928 *i(3,34) - .0231 *i(0,35) - .0128 *i(1,35) - .1293 *i(2,35) - .4388 *i(3,35) + .1408 *i(0,36) + .1072 *i(1,36) + .0353 *i(2,36) - .2563 *i(3,36) + .1151 *i(0,37) + .1947 *i(1,37) + .1589 *i(2,37) + .1067 *i(3,37);\n            x +=  - .1016 *i(4,34) - .1782 *i(5,34) - .1289 *i(6,34) - .0849 *i(7,34) - .1627 *i(4,35) - .0876 *i(5,35) - .0922 *i(6,35) - .0978 *i(7,35) - .3831 *i(4,36) - .1411 *i(5,36) - .1298 *i(6,36) - .2457 *i(7,36) - .3984 *i(4,37) - .3344 *i(5,37) - .2645 *i(6,37) - .1407 *i(7,37);\n            x +=  - .0496 *i(8,34) + .0176 *i(9,34) + .0012 *i(10,34) - .119  *i(11,34) + .1128 *i(8,35) + .1637 *i(9,35) + .0091 *i(10,35) - .1089 *i(11,35) + .0789 *i(8,36) + .0785 *i(9,36) - .2262 *i(10,36) - .1745 *i(11,36) + .0676 *i(8,37) + .0099 *i(9,37) - .0579 *i(10,37) - .0823 *i(11,37);\n            x +=  + .0517 *i(12,34) + .2095 *i(13,34) - .1883 *i(14,34) - .1111 *i(15,34) + .0862 *i(12,35) + .1099 *i(13,35) - .1521 *i(14,35) - .4429 *i(15,35) - .0393 *i(12,36) - .1343 *i(13,36) - .1406 *i(14,36) - .4379 *i(15,36) - .1521 *i(12,37) - .2169 *i(13,37) - .1988 *i(14,37) - .214  *i(15,37);\n            x +=  + .0505 *i(16,34) + .045  *i(17,34) - .0227 *i(18,34) - .0637 *i(19,34) + .1591 *i(16,35) + .081  *i(17,35) - .0067 *i(18,35) - .056  *i(19,35) + .0727 *i(16,36) + .0732 *i(17,36) + .1077 *i(18,36) - .0675 *i(19,36) - .1831 *i(16,37) - .0632 *i(17,37) - .0871 *i(18,37) - .4307 *i(19,37);\n            x +=  - .0183 *i(20,34) - .0397 *i(21,34) - .087  *i(22,34) - .4697 *i(23,34) + .0045 *i(20,35) + .0177 *i(21,35) - .0552 *i(22,35) - .3414 *i(23,35) + .1101 *i(20,36) + .1065 *i(21,36) - .0148 *i(22,36) - .2891 *i(23,36) + .1534 *i(20,37) + .1667 *i(21,37) + .0773 *i(22,37) - .3736 *i(23,37);\n            x +=  + .0386 *i(24,34) - .0104 *i(25,34) - .144  *i(26,34) - .2732 *i(27,34) + .0082 *i(24,35) + .0033 *i(25,35) + .0795 *i(26,35) - .1196 *i(27,35) - .3089 *i(24,36) - .0519 *i(25,36) + .1381 *i(26,36) + .0776 *i(27,36) - .4952 *i(24,37) - .389  *i(25,37) - .0429 *i(26,37) + .1007 *i(27,37);\n            x +=  - .0736 *i(28,34) - .1023 *i(29,34) - .1464 *i(30,34) - .2387 *i(31,34) + .0085 *i(28,35) - .0807 *i(29,35) - .064  *i(30,35) - .0858 *i(31,35) + .1341 *i(28,36) - .0386 *i(29,36) - .033  *i(30,36) - .0992 *i(31,36) + .2612 *i(28,37) + .0994 *i(29,37) - .0334 *i(30,37) - .2294 *i(31,37);\n            x +=  + .1524 *i(32,34) + .1051 *i(33,34) + .0628 *i(34,34) + .0849 *i(35,34) + .1309 *i(32,35) + .1084 *i(33,35) + .05   *i(34,35) - .0264 *i(35,35) + .0033 *i(32,36) + .1497 *i(33,36) + .088  *i(34,36) - .0125 *i(35,36) - .0315 *i(32,37) - .1139 *i(33,37) - .0065 *i(34,37) - .033  *i(35,37);\n            x +=  - .0282 *i(36,34) - .1585 *i(37,34) - .2113 *i(38,34) - .182  *i(39,34) + .0426 *i(36,35) - .1024 *i(37,35) - .1544 *i(38,35) - .1329 *i(39,35) + .1674 *i(36,36) - .0064 *i(37,36) + .0155 *i(38,36) - .0542 *i(39,36) + .1516 *i(36,37) - .0611 *i(37,37) - .2697 *i(38,37) - .301  *i(39,37) + .6181 ;\n        } else if (F.x == 25) {\n            x =  -.1885 *i(0,34) - .0965 *i(1,34) - .0557 *i(2,34) - .047  *i(3,34) - .6042 *i(0,35) - .2396 *i(1,35) - .1815 *i(2,35) - .0439 *i(3,35) - .3279 *i(0,36) - .2747 *i(1,36) - .1765 *i(2,36) - .1197 *i(3,36) - .1054 *i(0,37) - .2166 *i(1,37) - .1971 *i(2,37) - .074  *i(3,37);\n            x +=  - .0051 *i(4,34) + .0581 *i(5,34) + .0868 *i(6,34) + .1423 *i(7,34) - .0831 *i(4,35) - .0566 *i(5,35) + .0497 *i(6,35) + .1082 *i(7,35) - .0712 *i(4,36) - .1179 *i(5,36) - .0912 *i(6,36) - .0371 *i(7,36) - .0745 *i(4,37) - .1039 *i(5,37) - .1642 *i(6,37) - .1978 *i(7,37);\n            x +=  - .0645 *i(8,34) + .057  *i(9,34) + .0334 *i(10,34) + .1274 *i(11,34) - .2449 *i(8,35) - .316  *i(9,35) - .0326 *i(10,35) + .1114 *i(11,35) + .0174 *i(8,36) - .1335 *i(9,36) - .1497 *i(10,36) - .0539 *i(11,36) + .0623 *i(8,37) + .0253 *i(9,37) + .0339 *i(10,37) - .046  *i(11,37);\n            x +=  - .058  *i(12,34) - .0493 *i(13,34) + .0804 *i(14,34) + .0978 *i(15,34) - .0141 *i(12,35) - .1097 *i(13,35) + .0223 *i(14,35) + .0377 *i(15,35) + .0463 *i(12,36) - .0392 *i(13,36) - .0896 *i(14,36) + .0486 *i(15,36) - .0189 *i(12,37) - .0307 *i(13,37) - .0235 *i(14,37) - .0966 *i(15,37);\n            x +=  + .0232 *i(16,34) - .0293 *i(17,34) - .0106 *i(18,34) + .0565 *i(19,34) + .2028 *i(16,35) + .0118 *i(17,35) - .0373 *i(18,35) - .0226 *i(19,35) + .1284 *i(16,36) + .0503 *i(17,36) + .0184 *i(18,36) - .2067 *i(19,36) + .1802 *i(16,37) + .1009 *i(17,37) + .1199 *i(18,37) + .0152 *i(19,37);\n            x +=  - .068  *i(20,34) - .0228 *i(21,34) + .0452 *i(22,34) + .0825 *i(23,34) - .1154 *i(20,35) - .0755 *i(21,35) - 0.    *i(22,35) + .0658 *i(23,35) + .0724 *i(20,36) - .029  *i(21,36) - .1514 *i(22,36) - .0661 *i(23,36) + .1327 *i(20,37) + .0618 *i(21,37) + .0022 *i(22,37) - .1261 *i(23,37);\n            x +=  + .0657 *i(24,34) + .0367 *i(25,34) + .0618 *i(26,34) - .0018 *i(27,34) + .1465 *i(24,35) + .0936 *i(25,35) + .0338 *i(26,35) - .0228 *i(27,35) - .0295 *i(24,36) + .0473 *i(25,36) + .0563 *i(26,36) + .0554 *i(27,36) + .0183 *i(24,37) - .0729 *i(25,37) - .2233 *i(26,37) - .2739 *i(27,37);\n            x +=  - .1484 *i(28,34) - .184  *i(29,34) - .0295 *i(30,34) + .0227 *i(31,34) - .1752 *i(28,35) - .2507 *i(29,35) - .2127 *i(30,35) - .2664 *i(31,35) - .2136 *i(28,36) - .096  *i(29,36) - .1914 *i(30,36) - .2766 *i(31,36) - .0186 *i(28,37) - .0265 *i(29,37) - .0376 *i(30,37) - .1263 *i(31,37);\n            x +=  - .4    *i(32,34) - .3295 *i(33,34) - .1216 *i(34,34) - .2115 *i(35,34) + .0261 *i(32,35) - .0756 *i(33,35) - .0222 *i(34,35) - .1928 *i(35,35) + .0976 *i(32,36) + .0908 *i(33,36) + .0895 *i(34,36) + .01   *i(35,36) - .1006 *i(32,37) + .0715 *i(33,37) + .1235 *i(34,37) + .0651 *i(35,37);\n            x +=  + .005  *i(36,34) - .0264 *i(37,34) - .0217 *i(38,34) - .0118 *i(39,34) - .1775 *i(36,35) - .0455 *i(37,35) - .0286 *i(38,35) - .0836 *i(39,35) - .4369 *i(36,36) - .1238 *i(37,36) - .0813 *i(38,36) - .0584 *i(39,36) - .0247 *i(36,37) + .0142 *i(37,37) - .0159 *i(38,37) - .0818 *i(39,37) - .8506 ;\n        }\n        x = exp(x); // Pre-calculate the first step of the Softmax function\n        \n        col.r = x;\n    }\n    // CNN Step 7: Softmax + prediction\n    // 1x26 => 1 character\n    else if (F.x <= int(num_classes)  && F.y == 1) {\n        vec3 res = vec3(0); // r: prediction index, g: prediction confidence, b: sum of confidences\n        \n        // Calculate sum of confidences for Softmax\n        // and the prediction with highest confidence\n        for (float i = 0.; i < num_classes; i++) {\n            float val = texelFetch(iChannel1, ivec2(int(i), 0), 0).r;\n            res.b += val;\n            if (val > res.g) {\n                res.xy = vec2(i, val);\n            }\n        }\n        \n        // Store result of Softmax function for each output\n        if (F.x < int(num_classes))\n            col.r = texelFetch(iChannel1, ivec2(F.x, 0), 0).r / res.b; \n        // Store highest confidence prediction\n        else \n            col.rg = vec2(res.r, res.g / res.b);\n    }\n    \n    fragColor = vec4(col, 1);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4750, 4750, 4785, 4785, 4887], [4888, 4888, 4929, 4929, 5892], [5893, 5910, 5929, 5929, 6006], [6008, 6196, 6286, 6286, 7074], [7076, 7076, 7133, 7133, 14133]]}
{"id": "Dly3DW", "name": "Extruded Quadtree Path Tracing", "author": "gelami", "description": "Shrimple path tracing of a quadtree of extruded rectangular prisms with polygonal bokeh for depth of field\n\nMouse drag to look around\nDefines in Common", "tags": ["3d", "raytracing", "dof", "pathtracing"], "likes": 54, "viewed": 1219, "published": 3, "date": "1684143673", "time_retrieved": "2024-07-30T17:55:44.392998", "image_code": "\n// Extruded Quadtree Path Tracing - gelami\n// https://www.shadertoy.com/view/Dly3DW\n\n/* \n * Shrimple path tracing of a quadtree of extruded rectangular prisms\n *   with polygonal bokeh for depth of field\n *\n * Mouse drag to look around\n * Defines in Common\n * \n * This was originally made for an SVGF implementation\n * but its still work in progress for now,\n * so I gave it some color and we have this instead ^ - ^\n * \n * Quadtree traversal method based from my other shader:\n * Rectangular Pillar LOD Traversal - gelami\n * https://www.shadertoy.com/view/mttGWX\n * \n */\n\n// Fork of \"Quadtree Path Tracing SVGF\" by gelami. https://shadertoy.com/view/Dly3Dh\n// 2023-05-13 06:41:06\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    \n    if (fc == ivec2(0, 0)) fc = ivec2(0, 1);\n    if (fc == ivec2(1, 0)) fc = ivec2(1, 1);\n    \n    vec3 col = texelFetch(iChannel0, fc, 0).rgb;\n    \n    col = col / (1. + col);\n    \n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define BOUNCES 3\n    \n#define CAMERA_DIST 6.0\n//#define STATIC_CAMERA\n#define CAMERA_POSITION vec3(0, MAX_HEIGHT*0.9, 0)\n#define CAMERA_ANGLE vec2(0.09, 0.8)\n\n//#define REPROJECT\n\n#define DOF_STRENGTH 0.12\n#define DOF_FOCUS_DISTANCE CAMERA_DIST\n#define DOF_SIDES 6\n\n#define MAX_HEIGHT 5.0\n#define MAX_LOD 3.0    \n\n#define STEPS 256\n#define MAX_DIST 100.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 0.8) * t + vec3(0, 0.25, 0.5)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// RNG\nuint state;\nvoid initState(vec2 coord, int frame)\n{\n    state = uint(coord.x) * 1321u + uint(coord.y) * 4123u + uint(frame) * 4123u*4123u;\n}\n\n// From Chris Wellons Hash Prospector\n// https://nullprogram.com/blog/2018/07/31/\n// https://www.shadertoy.com/view/WttXWX\nuint hashi(inout uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(inout uint x)\n{\n    return float( hashi(x) ) / float( 0xffffffffU );\n}\n\nvec2 hash2(inout uint x)\n{\n    return vec2(hash(x), hash(x));\n}\n\nvec3 hash3(inout uint x)\n{\n    return vec3(hash(x), hash(x), hash(x));\n}\n\nvec4 hash4(inout uint x)\n{\n    return vec4(hash(x), hash(x), hash(x), hash(x));\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n  vec4 a = vec4(1,1,0,0);\n  while (s.x > 0. && s.y > 0.)\n  {\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(vec2(s),coprimes);\n    s = floor(s/coprimes);\n  }\n  return a.zw;\n}\n\nvec2 getJitter(vec2 pos, int frame)\n{\n    pos = floor(pos);\n    return halton(vec2(frame%8+1)) - .5;\n}\n\n// Random unit vector\n// Generate a random unit circle and scaled the z with a circular mapping\nvec3 randomUnitVector()\n{\n    vec2 rand = hash2(state);\n    rand.y = rand.y*2.-1.;\n    rand.x *= PI*2.;\n    \n    float r = sqrt(1. - rand.y*rand.y);\n    vec2 xy = vec2(cos(rand.x), sin(rand.x)) * r;\n    \n    return vec3(xy, rand.y);\n}\n\nvec3 randomHemisphere(vec3 n)\n{\n    vec3 r = randomUnitVector();\n    return dot(r, n) < 0.0 ? -r : r;\n}\n\n// Random cosine-weighted unit vector on a hemisphere\n// Unit vector + random unit vector\nvec3 randomCosineHemisphere(vec3 n)\n{\n    return normalize(randomUnitVector() + n);\n}\n\nvec3 randomUniformCone(float angle)\n{\n    vec2 rand = hash2(state);\n    rand.y = mix(cos(angle), 1.0, rand.y);\n    rand.x *= PI*2.;\n    \n    float r = sqrt(1. - rand.y*rand.y);\n    vec2 xy = vec2(cos(rand.x), sin(rand.x)) * r;\n    \n    return vec3(xy, rand.y);\n}\n\n// Random point in circle\n// Very straightforward, unit circle scaled by sqrt of the radius\nvec2 randomPointInCircle()\n{\n    vec2 rand = hash2(state);\n    \n    float a = rand.x * TAU;\n    float r = sqrt(rand.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Random point in polygon\n// Pick a random side and\n// generate a point in a rhombus (equal quadrilateral),\n// and fold it if the point is outside the inner triangle\nvec2 randomPointInPolygon(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    vec2 p1 = s1 * rand.y + s2 * rand.z;\n    vec2 p2 = s1 * (1.0 - rand.y) + s2 * (1.0 - rand.z);\n    \n    return rand.y + rand.z > 1.0 ? p2 : p1;\n}\n\n// Random point in star\n// Same as the random point in polygon,\n// but without folding the rhombus into a triangle\nvec2 randomPointInStar(float sides)\n{\n    vec3 rand = hash3(state);\n    float n = floor(rand.x * sides) / sides;\n    float a1 = n * TAU;\n    float a2 = a1 + TAU / sides;\n    vec2 s1 = vec2(cos(a1), sin(a1));\n    vec2 s2 = vec2(cos(a2), sin(a2));\n    \n    return s1 * rand.y + s2 * rand.z;\n}\n\n// Orthonormal Basis\n// https://www.shadertoy.com/view/tlVczh\n// MBR method 2a variant\nmat3 getBasis(in vec3 n)\n{\n    float sz = n.z >= 0.0 ? 1.0 : -1.0;\n    float a  =  n.y/(1.0+abs(n.z));\n    float b  =  n.y*a;\n    float c  = -n.x*a;\n\n    vec3 xp = vec3(n.z+sz*b, sz*c, -n.x);\n    vec3 yp = vec3(c, 1.0-b, -sz*n.y);\n    \n    return mat3(xp, yp, n);\n}\n\nvoid getBasis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n    float sz = n.z >= 0.0 ? 1.0 : -1.0;\n    float a  =  n.y/(1.0+abs(n.z));\n    float b  =  n.y*a;\n    float c  = -n.x*a;\n\n    xp = vec3(n.z+sz*b, sz*c, -n.x);\n    yp = vec3(c, 1.0-b, -sz*n.y);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-12 02:58:47\n\nvec2 map(vec2 p, float lod)\n{\n    float h = 1.0;\n    bool leaf = false;\n    for (float i = MAX_LOD; i >= lod; i--)\n    {\n        float s = exp2(MAX_LOD-i);\n        vec2 o = floor(p * s) / exp2(MAX_LOD-i);\n        \n        vec2 r = texture(iChannel1, (floor(p * s) + 0.5) / iChannelResolution[1].xy).xy;\n        //vec2 r = hash22(o);\n        float k = r.x;\n        \n        if (i == MAX_LOD)\n        {\n            h = (k*0.25+0.75) * 0.9999;\n            //h = mix(k, 1.0, 0.95);\n        } else\n        {\n            k = mix(k, 1.0, 0.95);\n            h *= k;\n        }\n        if (i != MAX_LOD && r.y < 0.1 + (MAX_LOD-i) * 0.1)\n        {\n            leaf = true;\n            break;\n        }\n    }\n    \n    return vec2(h * MAX_HEIGHT, leaf);\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 id;\n};\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit)\n{\n\n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(ird);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = ro * ird;\n    \n    vec2 id = floor(ro.xz);\n    vec2 pid = id;\n\n    float s = 1.0;\n    float lod = MAX_LOD;\n    vec3 pos = ro;\n    \n    vec2 nrd = vec2(0);\n    float t = 0.0;\n\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec2 p = (id + 0.5) * s;\n        \n        vec2 h = map(id * s, lod);\n        \n        if (pos.y < h.x)\n        {\n            if (lod > 0.0 && h.y < 0.5)\n            {\n                id *= 2.0;\n                id += step(vec2(0), pos.xz - p);\n                pid = id;\n                \n                s *= 0.5;\n                lod--;\n                continue;\n            } else\n            {\n                hit.t = t;\n                hit.n = -vec3(nrd.x, 0, nrd.y);\n                hit.id = id;\n                return true;\n            }\n        }\n        \n        vec2 n = iro.xz - p * ird.xz;\n        vec2 k = ard.xz * s * 0.5;\n        \n        vec2 t2 = -n + k;\n        \n        float nt = min(t2.x, t2.y);\n        \n        vec3 npos = ro + rd * nt;\n        \n        if (rd.y > 0.0 && npos.y > MAX_HEIGHT)\n            return false;\n        \n        if (npos.y < h.x)\n        {\n            \n            if (lod > 0.0 && h.y < 0.5)\n            {\n                id *= 2.0;\n                id += step(vec2(0), pos.xz - p);\n                pid = id;\n                \n                s *= 0.5;\n                lod--;\n                continue;\n                \n            } else\n            {\n                hit.t = -(ro.y - h.x) / rd.y;\n                hit.n = vec3(0, 1, 0);\n                hit.id = id;\n                return true;\n            }\n        }\n        \n        pos = npos;\n        t = nt;\n        \n        nrd = step(t2, t2.yx) * srd.xz;\n        pid = id;\n        id += nrd;\n        \n        if (floor(pid*0.5) != floor(id*0.5) && lod < MAX_LOD)\n        {\n            id = floor(id*0.5);\n            pid = id;\n            s *= 2.0;\n            lod++;\n        }\n    }\n\n    return false;\n}\n\nfloat fresnel(float r0, vec3 rd, vec3 n)\n{\n    return r0 + (1.0 + r0) * pow(1.0 - dot(-rd, n), 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initState(fragCoord, iFrame);\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    vec2 o = getJitter(fragCoord, iFrame);\n    vec2 pv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, CAMERA_DIST);\n    vec3 pro = vec3(0, 0, CAMERA_DIST);\n    vec3 lo = CAMERA_POSITION;\n    \n    #define MOUSE_DEFAULT vec4(CAMERA_ANGLE, 0, 0)\n    vec4 m = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 pm = texelFetch(iChannel0, ivec2(1, 0), 0);\n    \n    if (iFrame < 2)\n    {\n        m = MOUSE_DEFAULT;\n        pm = MOUSE_DEFAULT;\n    }\n    \n    #ifdef STATIC_CAMERA\n    m = MOUSE_DEFAULT;\n    #endif\n    \n    if (iFragCoord == ivec2(0, 0))\n    {\n        if (iFrame < 2)\n        {\n            fragColor = MOUSE_DEFAULT;\n        } else\n        {\n            vec2 mn = iMouse.xy / iResolution.xy;\n            fragColor = vec4(m);\n            if (iMouse.z > 0.0)\n            {\n                if (fragColor.zw != vec2(0))\n                {\n                    fragColor.xy += (mn - m.zw);\n                    fragColor.y = clamp(fragColor.y, 1e-4, 1.0 - 1e-4);\n                }\n                fragColor.zw = mn;\n            } else\n            {\n                fragColor.zw = vec2(0);\n            }\n        }\n        return;\n    } else if (iFragCoord == ivec2(1, 0))\n    {\n        if (iFrame < 2)\n            fragColor = MOUSE_DEFAULT;\n        else\n            fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n        return;\n    }\n    \n    float ax = -m.x * TAU + PI;\n    float ay = m.y * PI - PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n    \n    const float invTanFov = 2.5;\n    \n    const float dofStrength = DOF_STRENGTH;\n    const float dofDist = DOF_FOCUS_DISTANCE / invTanFov;\n    \n    vec3 nro = ro;\n    \n    #ifndef REPROJECT\n    \n    #if DOF_SIDES == 0\n    vec2 rc = randomPointInCircle();\n    #else\n    vec2 rc = randomPointInPolygon(float(DOF_SIDES));\n    #endif\n    \n    rc *= dofStrength * dofDist;\n    \n    pv -= rc / dofDist;\n    nro += cmat * vec3(rc, 0);\n    #endif\n    \n    vec3 rd = normalize(cmat * vec3(pv, invTanFov));\n    \n    vec3 sunDir = normalize(vec3(0.7, 1.2, 1));\n    \n    vec3 ligCol = (vec3(1,0.6,0.15)*0.8+0.2)*1.5;\n    vec3 skyCol = vec3(0.2, 0.3, 0.5) * 0.4;\n    \n    vec3 ldir = randomUniformCone(radians(0.56 * 2.0));\n    \n    mat3 sunMat = getBasis(sunDir);\n    \n    ldir = sunMat * ldir;\n    \n    vec3 col = vec3(0);\n    vec3 thr = vec3(1);\n    \n    vec3 pos = nro;\n    float pt = 0.0;\n    \n    if (pos.y > MAX_HEIGHT)\n    {\n        pt = -(pos.y - MAX_HEIGHT) / rd.y;\n        pos = pos + rd * pt;\n    }\n    \n    HitInfo hit;\n    bool isHit = trace(pos, rd, hit);\n    \n    vec3 cpos = pos;\n    vec3 crd = rd;\n    \n    float t = isHit ? pt + hit.t : MAX_DIST;\n    pos = pos + rd * hit.t;\n    \n    for (int i = 0; i < BOUNCES; i++)\n    {\n        if (!isHit)\n        {\n            col += skyCol * thr;\n            break;\n        }\n        \n        cpos = cpos + crd * hit.t + hit.n * EPS;\n        \n        vec3 alb = vec3(hash12(hit.id.yx) * 0.2 + 0.8);\n        alb = palette2(hash12(hit.id.yx));\n        \n        float fre = fresnel(0.08, crd, hit.n);\n        \n        if (hash(state) < fre && i < BOUNCES-1)\n            crd = reflect(crd, hit.n);\n        else\n            crd = randomCosineHemisphere(hit.n);\n        \n        thr *= alb;\n        \n        float dif = max(dot(hit.n, ldir), 0.0);\n        \n        HitInfo hitL;\n        bool isHitL = trace(cpos, ldir, hitL);\n\n        if (!isHitL)\n        {\n            col += dif * ligCol * thr;\n        }\n        \n        isHit = trace(cpos, crd, hit);\n        \n        if (!isHit)\n        {\n            col += skyCol * thr;\n            break;\n        }\n    }\n    \n    #ifdef REPROJECT\n    float blend = iFrame == 0 ? 1.0 : 1.0 / 16.0;\n    \n    float pax = -pm.x * TAU + PI;\n    float pay = pm.y * PI - PI * 0.5;\n    \n    pro.yz *= rot2D(pay);\n    pro.xz *= rot2D(pax);\n    pro += lo;\n\n    mat3 pmat = getCameraMatrix(pro, lo);\n    \n    vec3 pvpos = (pos - pro) * pmat;\n    vec2 pndc = invTanFov * pvpos.xy / pvpos.z;\n    vec2 puv = pndc * vec2(iResolution.y / iResolution.x, 1) * .5 + .5 - o / iResolution.xy;\n    \n    vec2 ppv = (2.0 * puv * iResolution.xy - iResolution.xy) / iResolution.y;\n    vec2 pfc = puv * iResolution.xy;\n    \n    vec3 prd = normalize(pmat * vec3(ppv, invTanFov));\n    \n    vec4 prev = texture(iChannel0, puv);\n    \n    vec3 ppos = pro + prd * prev.a;\n    \n    if (puv != saturate(puv))\n        blend = 1.0;\n    \n    #ifndef STATIC_CAMERA\n    if (m.zw != vec2(0) && abs(t - prev.a) > 0.05) blend = 1.0;\n    #endif\n    \n    col = max(col, vec3(0));\n    col = mix(prev.rgb, col, blend);\n    \n    fragColor = vec4(col, t);\n    \n    #else\n        \n    vec4 prev = texture(iChannel0, uv);\n    \n    float blend = iFrame == 0 ? 1.0 : 1.0 / (1.0 + 1.0 / prev.a);\n    \n    #ifndef STATIC_CAMERA\n    if (m.zw != vec2(0)) blend = 1.0;\n    #endif\n    \n    col = max(col, vec3(0));\n    col = mix(prev.rgb, col, blend);\n    \n    fragColor = vec4(col, blend);\n    \n    #endif\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dly3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[683, 683, 740, 740, 1084]]}
{"id": "DtKGDm", "name": "Falling Polyhedra", "author": "dr2", "description": "Lots of shiny pentakisdodecahedra", "tags": ["grid", "polyhedron", "pentakis"], "likes": 16, "viewed": 271, "published": 3, "date": "1684133824", "time_retrieved": "2024-07-30T17:55:45.175905", "image_code": "// \"Falling Polyhedra\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0  // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3v3 (vec3 p);\n\nvec3 bGrid, cId, obDisp, obRot, ltDir[4], ltCol[4];\nfloat dstFar, tCur, vSpd;\nbool cOcc;\nconst float pi = 3.1415927;\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n    p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n  p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n  p.xy = sin ((2. * pi / 5.) * (fract ((atan (p.x, p.y) + pi / 5.) / (2. * pi / 5.)) - 0.5) +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{  // (from \"Pentakis Dodecahedron\")\n  float d, a;\n  d = dstFar;\n  if (cOcc) {\n    p -= obDisp;\n    p.yz = Rot2Cs (p.yz, sin (obRot.x + vec2 (0.5 * pi, 0.)));\n    p.xz = Rot2Cs (p.xz, sin (obRot.y + vec2 (0.5 * pi, 0.)));\n    p.xy = Rot2Cs (p.xy, sin (obRot.z + vec2 (0.5 * pi, 0.)));\n    a = 0.5 * (acos (-1. / sqrt (5.)) - acos (- (80. + 9. * sqrt (5.)) / 109.));\n    d = abs (dot (DodecSym (p).yz, sin (a + vec2 (0., 0.5 * pi)))) - 0.12;\n  }\n  return d;\n}\n\nvoid ObjState ()\n{\n  vec3 vRan;\n  vRan = Hashv3v3 (cId + 11.1);\n  cOcc = (vRan.x * step (4., length (cId.xz)) > 0.2);\n  if (cOcc) {\n    obDisp = bGrid * (cId + 0.5 + 0.3 * cos ((0.5 + 0.5 * vRan) * tCur + vRan.zxy));\n    obRot = (vRan - 0.5) * tCur;\n  }\n}\n\nvec3 ObjCell (vec3 p)\n{\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y += vSpd * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return p;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ObjCell (ro + dHit * rd);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    d = min (d, abs (Minv3 ((bGrid * (cId + step (0., rd)) - p) * rdi)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, c, vn, sumD, sumS;\n  float dstObj, nDotL;\n  col = vec3 (0.1);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ObjCell (ro));\n    c = HsvToRgb (vec3 (Hashfv3 (cId), 0.7, 1.));\n    sumD = vec3 (0.);\n    sumS = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      nDotL *= nDotL;\n      sumD += ltCol[k] * c * nDotL * nDotL;\n      sumS += vec3 (0.7) * pow (max (0., dot (ltDir[k], reflect (rd, vn))), 128.);\n    }\n    col = sumD + sumS;\n    col = mix (col, vec3 (0.1), 1. - exp (min (0., 3. - 5. * dstObj / dstFar)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, e;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.01 * tCur;\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  bGrid = vec3 (1.);\n  vSpd = 0.2;\n  ro = vec3 (0.5 * bGrid.x);\n  zmFac = 6.;\n  dstFar = 50.;\n  e = vec2 (1., -1.);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltDir[k] = normalize ((k < 2) ? ((k == 0) ? e.xxx : e.xyy) : ((k == 2) ? e.yxy : e.yyx));\n    ltDir[k].xz = Rot2D (ltDir[k].xz, 0.17 * pi * tCur);\n    ltDir[k].xy = Rot2D (ltDir[k].xy, 0.13 * pi * tCur);\n  }\n  ltCol[0] = vec3 (1., 1., 0.3);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKGDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[563, 563, 587, 587, 1238], [1240, 1240, 1262, 1297, 1719], [1721, 1721, 1739, 1739, 1976], [1978, 1978, 2001, 2001, 2132], [2134, 2134, 2167, 2167, 2725], [2727, 2727, 2748, 2748, 3003], [3005, 3005, 3040, 3040, 3696], [3698, 3698, 3754, 3754, 5181], [5183, 5183, 5205, 5205, 5243], [5245, 5245, 5281, 5281, 5487], [5489, 5489, 5519, 5519, 5632], [5634, 5634, 5665, 5665, 5729], [5731, 5731, 5755, 5755, 5872], [5906, 5906, 5930, 5930, 5990], [5992, 5992, 6016, 6016, 6081], [6083, 6083, 6107, 6107, 6225]]}
{"id": "DtK3Dw", "name": "Audio ball curl to lava", "author": "firebreathz", "description": "Page Curl Effect from shader https://www.shadertoy.com/view/XlX3RS displaced on Ball\nMouse control activated\na liitle bit slow for the moment", "tags": ["curl", "effect", "ball", "page"], "likes": 5, "viewed": 177, "published": 3, "date": "1684127877", "time_retrieved": "2024-07-30T17:55:46.111403", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n////////////////////////////////////////////////////////\n// page curl effect from my shader https://www.shadertoy.com/view/XlX3RS\nfloat curlExtent = 0.;\n    \nconst float minAmount = -0.16;\nconst float maxAmount = 0.9;\nconst float PI = 3.14159;\nconst float scale = 100.0;\nconst float sharpness = 30.0;\nvec4 bgColor;\n\nfloat amount;\nfloat cylinderCenter;\nfloat cylinderAngle;\nconst float cylinderRadius = 1. / PI / 9.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)\n{\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float dis)\n{\n    dis *= scale;\n    if (dis < 30.0) return color2;\n    if (dis > 20.0) return color1;\n    float dd = pow(1.0 - dis / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point)\n{\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))\n        return bgColor;\n    if (yc > 0.0)\n        return textureLod(iChannel1, p, 0.0);\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0)\n        shadow = 0.0;\n    else\n        shadow *= amount;\n    vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point)\n{\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\n/////////////////////////////////////////////\n\n//////2D FUNC TO MODIFY////////////////////\nvec3 effect(vec2 uv) \n{\n    uv/=8.;\n    uv+=0.6;\n    \n\tbgColor = textureLod(iChannel2, uv, 0.0).rgga;\n    \n    curlExtent = (sin((iTime)*0.3)*0.5+0.5);\n    \n    if (iMouse.z>0.) curlExtent = 1.-iMouse.y/iResolution.y;\n        \n\tamount = curlExtent * (maxAmount - minAmount) + minAmount;\n\tcylinderCenter = amount;\n\tcylinderAngle = 2.0 * PI * amount;\n\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(c, s, 0, -s, c, 0, 0.12, 0.258, 1);\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(c, s, 0, -s, c, 0, 0.15, -0.5, 1);\n    vec3 point = rotation * vec3(uv, 1.0);\n    float yc = point.y - cylinderCenter;\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n    if (yc < -cylinderRadius) // See through to background\n    {\n        color = bgColor;\n    } \n    else if (yc > cylinderRadius) // Flat surface\n    {\n        \n        color = textureLod(iChannel1, uv, 0.0);\n    } \n    else \n    {\n        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n        float hitAngleMod = mod(hitAngle, 2.0 * PI);\n        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) \n        {\n            color = seeThrough(yc, uv, rotation, rrotation);\n        } \n        else \n        {\n            point = hitPoint(hitAngle, yc, point, rrotation);\n            if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) \n            {\n                color = seeThroughWithShadow(yc, uv, point, rotation, rrotation);\n            } \n            else \n            {\n                color = backside(yc, point);\n                vec4 otherColor;\n                if (yc < 0.0) \n                {\n                    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n                    shado *= pow(-yc / cylinderRadius, 3.0);\n                    shado *= 0.5;\n                    otherColor = vec4(0.0, 0.0, 0.0, shado);\n                } \n                else \n                {\n                    otherColor = textureLod(iChannel1, uv, 0.0);\n                }\n                color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n            }\n        }\n    }\n    return color.rgb;\n}\n\n///////FRAMEWORK////////////////////////////////////\nvec4 displacement(vec3 p)\n{\n    vec3 col = effect(p.xz);\n    \n    col = clamp(col, vec3(0), vec3(1.));\n    \n    float dist = dot(col,vec3(0.1));\n    \n    return vec4(dist,col);\n}\n\n////////BASE OBJECTS///////////////////////\nfloat obox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat osphere( vec3 p, float r ){ return length(p)-r;}\n////////MAP////////////////////////////////\nvec4 map(vec3 p)\n{\n   \tvec4 disp = displacement(p);\n        \n    float y = 1. - smoothstep(0., 1., disp.x);\n    \n    float dist = osphere(p, +5.-y);\n    \n    return vec4(dist, disp.yzw);\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n///////////////////////////////////////////\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec;\n    float d = 0.;\n    float l = log(2.);\n    for(int i=0;i<60;i++)\n    {      \n        if (s<rmPrec||s>maxd) break;\n        s = map(ro+rd*d).x * l;\n        d += abs(s);\n    }\n    return d;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iTime*0.3;\n    float cam_a = 0.; // angle z\n    \n    float cam_e = 5.52; // elevation\n    float cam_d = 1.88; // distance to origin axis\n   \t\n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat li = 0.6; // light intensity\n    float prec = 0.00001; // ray marching precision\n    float maxd = 50.; // ray marching distance max\n    float refl_i = 0.45; // reflexion intensity\n    float refr_a = 0.7; // refraction angle\n    float refr_i = 0.8; // refraction intensity\n    float bii = 0.35; // bright init intensity\n    float marchPrecision = 0.8; // ray marching tolerance precision\n    \n    /////////////////////////////////////////////////////////\n    //if ( iMouse.z>0.) cam_e = iMouse.x/iResolution.x * 10.; // mouse x axis \n    //if ( iMouse.z>0.) cam_d = iMouse.y/iResolution.y * 50.; // mouse y axis \n    /////////////////////////////////////////////////////////\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = march(ro, rd, prec, maxd, marchPrecision);\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-1., 1.)*0.005; \n    \tvec3 p = ro+rd*d;\n        vec3 n = calcNormal(p);\n        \n        b=li;\n        \n        vec3 reflRay = reflect(rd, n);\n\t\tvec3 refrRay = refract(rd, n, refr_a);\n        \n        vec3 cubeRefl = texture(iChannel0, reflRay).rgb * refl_i;\n        vec3 cubeRefr = texture(iChannel0, refrRay).rgb * refr_i;\n        \n        col = cubeRefl + cubeRefr + pow(b, 15.);\n        \n       \tfloat occ = calcAO( p, n );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, reflRay.y );\n        float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( reflRay, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( p, lig, 0.02, 2.5 );\n       \tdom *= softshadow( p, reflRay, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol *= brdf;\n\n    \tcol = mix(col, map(p).yzw, 0.5);\n    }\n    else\n    {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col;\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n\n\nfloat Gyroid(vec3 p, float scale, float bias, float thickness) {\n    p *= scale;\n    float d = abs(dot(sin(p), cos(p.yzx))+bias)-thickness;\n\treturn d/scale;\n}\n\nvec4 GetGyroids(vec3 p) {    \n    float t = iTime*.1;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., .4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, -7., .3, .1);\n    \n    return vec4(g1, g2, g3, g4);              \n}\n\nfloat GetDist(vec3 p) {\n\tfloat d = p.y;\n    p.x+=.33;\n    \n    float t = iTime*.1;\n    float scale = 20.;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., 1.4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, 89., .3, .1);\n    float g5 = Gyroid(p, 189., .3, .1);\n    float g6 = Gyroid(p, 289., .0, .1);\n    \n    d = g1*.7;\n    d -= g2*.3;\n    d += g3*.2;\n    d += g4*.1;\n    d += g5*g4*20.;\n    d += g6*.1;\n    \n   \tvec3 P = p;\n    P.xz = fract(P.xz)-.5;\n    vec2 id = floor(p.xz);\n    float n = Hash21(id);\n    //P = fract(P)-.5;\n    \n    \n    return d;              \n}\n\nfloat sdSpark(vec3 p) {\n    float t = iTime*.5;\n    \n    p.xz *= Rot(t*.1);\n    \n    vec3 id = floor(p);\n    p.xz = fract(p.xz)-.5;\n    \n    float n = Hash21(id.xz);\n    \n\tfloat z = fract(t+n)-.5;\n   \tz *= 10.;\n    \n    n *= 6.2832;\n    float size = .3+.2*sin(t*.1);\n    vec3 p1 = vec3(0, z-size*1., 0);\n    vec3 p2 = vec3(0, z+size*1., 0);\n    \n    p.x += sin(p.y*3.)*.1;\n    \n    float d = sdCapsule(p, p1, p2, size*.1);\n    \n    d = min(d, length(p.xz)+size*2.);\n    \n    return d;\n}\n\nvec2 SparkMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = sdSpark(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetSparkNormal(vec3 p) {\n\tfloat d = sdSpark(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        sdSpark(p-e.xyy),\n        sdSpark(p-e.yxy),\n        sdSpark(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z, vec3 up) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 GetPos(float t) {\n    float y = .6+cos(t)*.2;\n\treturn mix(vec3(-.3, y, t), vec3(2.2, y, t), (sin(t)*.5+.5)*1.);\n}\n\nvec3 Bg(vec3 rd) {\n    float b = -rd.y*.5+.5;\n\tvec3 col = vec3(.9, .6, .5)*b*4.;\n    \n    float a = atan(rd.x, rd.z);\n    \n    //col += sin(a*10.+iTime)*(1.-rd.y);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n\tfloat t = iTime;\n   \n    vec2 heat=sin(vec2(.123, .234)*t*30.+uv*40.+vec2(0,t*10.));\n    //heat *= uv.y+.5;\n    float c = (sin(t*.1)*.5+.5);\n   \n    #ifndef ABSTRACT\n    c = .1;\n    #endif\n    \n   //c=.9;\n    uv += heat*.02*(c*c*c*c+.1);\n    \n    \n    vec3 ro = vec3(0, 0, .01);\n    ro.yz *= Rot(m.y*3.14*.25+.25);\n    ro.xz *= Rot(-m.x*6.2831+t*.1);\n   \n   // ro = GetPos(t*0.);\n    vec3 up = vec3(0,1,0);\n    //up.xy *= Rot(sin(t)*.4);\n    vec3 lookat = vec3(0,0,0);\n    \n    float zoom = mix(.7, 1.7, sin(t*.15)*.5+.5);\n    vec3 rd = R(uv, ro, lookat, zoom, up);\n\n    float d = RayMarch(ro, rd).x;\n    \n    vec3 bg = Bg(rd);\n    vec3 col = vec3(0.);\n\t\n    if(d<MAX_DIST) {\n        \n        vec3 p = ro + d*rd;\n        vec3 n = GetNormal(p);\n       \n        float dif = n.y*.5+.5;\n        \n        vec4 g = GetGyroids(p);\n        \n        col += dif;\n        col *= min(1., g.y*20.);\n        //col *= .1;\n        \n        float lava = S(.01-min(0., p.y*.1), -.01, g.y);\n        lava *= sin(g.z*100.+t)*.5+.5;\n       // lava += S(-.7, -1., n.y);\n        \n        \n        float flicker = Gyroid(p-vec3(0,t,0), 5., 0., .1);\n        flicker *= Gyroid(p-vec3(.2,.5,0)*t, 5., 0., .1);\n        \n        col *= sin(t*.2)*.5+.5; \n        col += flicker*10.*vec3(1., .4, .1);//*S(.01,.0, g.y);\n        \n        col += lava*vec3(1., .5, .1);\n        \n    }\n    col = mix(col, bg, S(0., 7., d));\n    \n    \n    float dSpark = SparkMarch(ro, rd).x;\n    \n    \n    if(dSpark<MAX_DIST && dSpark<d) {\n        //col += 1.;\n        \n        vec3 p = ro+rd*dSpark;\n        vec3 n = GetSparkNormal(p);\n        n = normalize(n*vec3(1,0,1));\n        \n        float f = max(0., dot(rd, -n));\n        float fade = 1.-pow(f, 5.);\n        fade = .05/fade;\n        fade *= S(.0, 1., f);\n        col += fade;\n        //col += 1.;\n    }\n    \n    \n    \n    fragColor = vec4(col,d);\n}", "buffer_d_inputs": [], "common_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n// uncomment this for some extra periodic 2d fuckery ;)\n//#define ABSTRACT\n\n#define VIGNETTE 1.\n#define EXPOSURE 1.3\n#define DOF_SAMPLES 40\n\n#define MAX_STEPS 100\n#define MAX_DIST 7.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n// Dave Hoskins hash without sine\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.23,234.34));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y);\n}\n\nfloat Hash31(vec3 p) {\n\tp = fract(p*vec3(123.23,234.34,345.54));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y*p.z);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// DOF function borrowed from XT95\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 dof(sampler2D tex,vec2 uv,float rad, vec2 iResolution)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.003*iResolution.y/iResolution.x,.003),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<DOF_SAMPLES;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/float(DOF_SAMPLES);\n}\n\n\n", "buffer_a_code": "#define WAVES 9.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 1.3 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 3.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.0008 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 90.0), 0.5 * intensity, 2.5 * intensity) * (9.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtK3Dw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[556, 556, 625, 625, 725], [727, 727, 780, 780, 964], [966, 966, 1000, 1000, 1420], [1422, 1422, 1488, 1488, 1959], [1961, 1961, 2049, 2049, 2388], [2390, 2390, 2427, 2427, 2684], [2733, 2777, 2800, 2800, 5023], [5025, 5078, 5105, 5105, 5256], [5258, 5302, 5331, 5331, 5366], [5367, 5367, 5400, 5400, 5421], [5422, 5466, 5484, 5484, 5654], [5656, 5755, 5829, 5829, 6089], [6091, 6091, 6123, 6123, 6340], [6342, 6342, 6384, 6384, 6683], [6685, 6729, 6801, 6801, 7014], [7016, 7060, 7117, 7147, 10028]]}
{"id": "fsBBRh", "name": "Lava page curl audio vis ball", "author": "firebreathz", "description": "Page Curl Effect from shader https://www.shadertoy.com/view/XlX3RS displaced on Ball\nMouse control activated\na liitle bit slow for the moment", "tags": ["curl", "effect", "ball", "page"], "likes": 5, "viewed": 251, "published": 3, "date": "1684124346", "time_retrieved": "2024-07-30T17:55:47.050891", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n////////////////////////////////////////////////////////\n// page curl effect from my shader https://www.shadertoy.com/view/XlX3RS\nfloat curlExtent = 0.;\n    \nconst float minAmount = -0.16;\nconst float maxAmount = 1.3;\nconst float PI = 3.14159;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nvec4 bgColor;\n\nfloat amount;\nfloat cylinderCenter;\nfloat cylinderAngle;\nconst float cylinderRadius = 1. / PI / 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)\n{\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float dis)\n{\n    dis *= scale;\n    if (dis < 30.0) return color2;\n    if (dis > 20.0) return color1;\n    float dd = pow(1.0 - dis / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point)\n{\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))\n        return bgColor;\n    if (yc > 0.0)\n        return textureLod(iChannel1, p, 0.0);\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0)\n        shadow = 0.0;\n    else\n        shadow *= amount;\n    vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point)\n{\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\n/////////////////////////////////////////////\n\n//////2D FUNC TO MODIFY////////////////////\nvec3 effect(vec2 uv) \n{\n    uv/=8.;\n    uv+=0.5;\n    \n\tbgColor = textureLod(iChannel2, uv, 0.0).rgga;\n    \n    curlExtent = (sin((iTime)*0.3)*0.5+0.5);\n    \n    if (iMouse.z>0.) curlExtent = 1.-iMouse.y/iResolution.y;\n        \n\tamount = curlExtent * (maxAmount - minAmount) + minAmount;\n\tcylinderCenter = amount;\n\tcylinderAngle = 2.0 * PI * amount;\n\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(c, s, 0, -s, c, 0, 0.12, 0.258, 1);\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(c, s, 0, -s, c, 0, 0.15, -0.5, 1);\n    vec3 point = rotation * vec3(uv, 1.0);\n    float yc = point.y - cylinderCenter;\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n    if (yc < -cylinderRadius) // See through to background\n    {\n        color = bgColor;\n    } \n    else if (yc > cylinderRadius) // Flat surface\n    {\n        \n        color = textureLod(iChannel1, uv, 0.0);\n    } \n    else \n    {\n        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n        float hitAngleMod = mod(hitAngle, 2.0 * PI);\n        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) \n        {\n            color = seeThrough(yc, uv, rotation, rrotation);\n        } \n        else \n        {\n            point = hitPoint(hitAngle, yc, point, rrotation);\n            if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) \n            {\n                color = seeThroughWithShadow(yc, uv, point, rotation, rrotation);\n            } \n            else \n            {\n                color = backside(yc, point);\n                vec4 otherColor;\n                if (yc < 0.0) \n                {\n                    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n                    shado *= pow(-yc / cylinderRadius, 3.0);\n                    shado *= 0.5;\n                    otherColor = vec4(0.0, 0.0, 0.0, shado);\n                } \n                else \n                {\n                    otherColor = textureLod(iChannel1, uv, 0.0);\n                }\n                color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n            }\n        }\n    }\n    return color.rgb;\n}\n\n///////FRAMEWORK////////////////////////////////////\nvec4 displacement(vec3 p)\n{\n    vec3 col = effect(p.xz);\n    \n    col = clamp(col, vec3(0), vec3(1.));\n    \n    float dist = dot(col,vec3(0.1));\n    \n    return vec4(dist,col);\n}\n\n////////BASE OBJECTS///////////////////////\nfloat obox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat osphere( vec3 p, float r ){ return length(p)-r;}\n////////MAP////////////////////////////////\nvec4 map(vec3 p)\n{\n   \tvec4 disp = displacement(p);\n        \n    float y = 1. - smoothstep(0., 1., disp.x);\n    \n    float dist = osphere(p, +5.-y);\n    \n    return vec4(dist, disp.yzw);\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n///////////////////////////////////////////\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec;\n    float d = 0.;\n    float l = log(2.);\n    for(int i=0;i<60;i++)\n    {      \n        if (s<rmPrec||s>maxd) break;\n        s = map(ro+rd*d).x * l;\n        d += abs(s);\n    }\n    return d;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iTime*0.3;\n    float cam_a = 0.; // angle z\n    \n    float cam_e = 5.52; // elevation\n    float cam_d = 1.88; // distance to origin axis\n   \t\n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat li = 0.6; // light intensity\n    float prec = 0.00001; // ray marching precision\n    float maxd = 50.; // ray marching distance max\n    float refl_i = 0.45; // reflexion intensity\n    float refr_a = 0.7; // refraction angle\n    float refr_i = 0.8; // refraction intensity\n    float bii = 0.35; // bright init intensity\n    float marchPrecision = 0.8; // ray marching tolerance precision\n    \n    /////////////////////////////////////////////////////////\n    //if ( iMouse.z>0.) cam_e = iMouse.x/iResolution.x * 10.; // mouse x axis \n    //if ( iMouse.z>0.) cam_d = iMouse.y/iResolution.y * 50.; // mouse y axis \n    /////////////////////////////////////////////////////////\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = march(ro, rd, prec, maxd, marchPrecision);\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-1., 1.)*0.005; \n    \tvec3 p = ro+rd*d;\n        vec3 n = calcNormal(p);\n        \n        b=li;\n        \n        vec3 reflRay = reflect(rd, n);\n\t\tvec3 refrRay = refract(rd, n, refr_a);\n        \n        vec3 cubeRefl = texture(iChannel0, reflRay).rgb * refl_i;\n        vec3 cubeRefr = texture(iChannel0, refrRay).rgb * refr_i;\n        \n        col = cubeRefl + cubeRefr + pow(b, 15.);\n        \n       \tfloat occ = calcAO( p, n );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, reflRay.y );\n        float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( reflRay, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( p, lig, 0.02, 2.5 );\n       \tdom *= softshadow( p, reflRay, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol *= brdf;\n\n    \tcol = mix(col, map(p).yzw, 0.5);\n    }\n    else\n    {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col;\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n\n\nfloat Gyroid(vec3 p, float scale, float bias, float thickness) {\n    p *= scale;\n    float d = abs(dot(sin(p), cos(p.yzx))+bias)-thickness;\n\treturn d/scale;\n}\n\nvec4 GetGyroids(vec3 p) {    \n    float t = iTime*.1;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., .4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, -7., .3, .1);\n    \n    return vec4(g1, g2, g3, g4);              \n}\n\nfloat GetDist(vec3 p) {\n\tfloat d = p.y;\n    p.x+=.33;\n    \n    float t = iTime*.1;\n    float scale = 20.;\n       \n    p.xy *= Rot(p.z*.3);\n    p.z += t;\n    \n    float g1 = Gyroid(p, 5., 1.4, .1);\n    float g2 = Gyroid(p, 17., .3, .1);\n    float g3 = Gyroid(p, 39., .3, .1);\n    float g4 = Gyroid(p, 89., .3, .1);\n    float g5 = Gyroid(p, 189., .3, .1);\n    float g6 = Gyroid(p, 289., .0, .1);\n    \n    d = g1*.7;\n    d -= g2*.3;\n    d += g3*.2;\n    d += g4*.1;\n    d += g5*g4*20.;\n    d += g6*.1;\n    \n   \tvec3 P = p;\n    P.xz = fract(P.xz)-.5;\n    vec2 id = floor(p.xz);\n    float n = Hash21(id);\n    //P = fract(P)-.5;\n    \n    \n    return d;              \n}\n\nfloat sdSpark(vec3 p) {\n    float t = iTime*.5;\n    \n    p.xz *= Rot(t*.1);\n    \n    vec3 id = floor(p);\n    p.xz = fract(p.xz)-.5;\n    \n    float n = Hash21(id.xz);\n    \n\tfloat z = fract(t+n)-.5;\n   \tz *= 10.;\n    \n    n *= 6.2832;\n    float size = .3+.2*sin(t*.1);\n    vec3 p1 = vec3(0, z-size*1., 0);\n    vec3 p2 = vec3(0, z+size*1., 0);\n    \n    p.x += sin(p.y*3.)*.1;\n    \n    float d = sdCapsule(p, p1, p2, size*.1);\n    \n    d = min(d, length(p.xz)+size*2.);\n    \n    return d;\n}\n\nvec2 SparkMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = sdSpark(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetSparkNormal(vec3 p) {\n\tfloat d = sdSpark(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        sdSpark(p-e.xyy),\n        sdSpark(p-e.yxy),\n        sdSpark(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z, vec3 up) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 GetPos(float t) {\n    float y = .6+cos(t)*.2;\n\treturn mix(vec3(-.3, y, t), vec3(2.2, y, t), (sin(t)*.5+.5)*1.);\n}\n\nvec3 Bg(vec3 rd) {\n    float b = -rd.y*.5+.5;\n\tvec3 col = vec3(.9, .6, .5)*b*4.;\n    \n    float a = atan(rd.x, rd.z);\n    \n    //col += sin(a*10.+iTime)*(1.-rd.y);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n\tfloat t = iTime;\n   \n    vec2 heat=sin(vec2(.123, .234)*t*30.+uv*40.+vec2(0,t*10.));\n    //heat *= uv.y+.5;\n    float c = (sin(t*.1)*.5+.5);\n   \n    #ifndef ABSTRACT\n    c = .1;\n    #endif\n    \n   //c=.9;\n    uv += heat*.02*(c*c*c*c+.1);\n    \n    \n    vec3 ro = vec3(0, 0, .01);\n    ro.yz *= Rot(m.y*3.14*.25+.25);\n    ro.xz *= Rot(-m.x*6.2831+t*.1);\n   \n   // ro = GetPos(t*0.);\n    vec3 up = vec3(0,1,0);\n    //up.xy *= Rot(sin(t)*.4);\n    vec3 lookat = vec3(0,0,0);\n    \n    float zoom = mix(.7, 1.7, sin(t*.15)*.5+.5);\n    vec3 rd = R(uv, ro, lookat, zoom, up);\n\n    float d = RayMarch(ro, rd).x;\n    \n    vec3 bg = Bg(rd);\n    vec3 col = vec3(0.);\n\t\n    if(d<MAX_DIST) {\n        \n        vec3 p = ro + d*rd;\n        vec3 n = GetNormal(p);\n       \n        float dif = n.y*.5+.5;\n        \n        vec4 g = GetGyroids(p);\n        \n        col += dif;\n        col *= min(1., g.y*20.);\n        //col *= .1;\n        \n        float lava = S(.01-min(0., p.y*.1), -.01, g.y);\n        lava *= sin(g.z*100.+t)*.5+.5;\n       // lava += S(-.7, -1., n.y);\n        \n        \n        float flicker = Gyroid(p-vec3(0,t,0), 5., 0., .1);\n        flicker *= Gyroid(p-vec3(.2,.5,0)*t, 5., 0., .1);\n        \n        col *= sin(t*.2)*.5+.5; \n        col += flicker*10.*vec3(1., .4, .1);//*S(.01,.0, g.y);\n        \n        col += lava*vec3(1., .5, .1);\n        \n    }\n    col = mix(col, bg, S(0., 7., d));\n    \n    \n    float dSpark = SparkMarch(ro, rd).x;\n    \n    \n    if(dSpark<MAX_DIST && dSpark<d) {\n        //col += 1.;\n        \n        vec3 p = ro+rd*dSpark;\n        vec3 n = GetSparkNormal(p);\n        n = normalize(n*vec3(1,0,1));\n        \n        float f = max(0., dot(rd, -n));\n        float fade = 1.-pow(f, 5.);\n        fade = .05/fade;\n        fade *= S(.0, 1., f);\n        col += fade;\n        //col += 1.;\n    }\n    \n    \n    \n    fragColor = vec4(col,d);\n}", "buffer_d_inputs": [], "common_code": "// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n// uncomment this for some extra periodic 2d fuckery ;)\n//#define ABSTRACT\n\n#define VIGNETTE 1.\n#define EXPOSURE 1.3\n#define DOF_SAMPLES 40\n\n#define MAX_STEPS 100\n#define MAX_DIST 7.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n// Dave Hoskins hash without sine\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.23,234.34));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y);\n}\n\nfloat Hash31(vec3 p) {\n\tp = fract(p*vec3(123.23,234.34,345.54));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y*p.z);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// DOF function borrowed from XT95\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 dof(sampler2D tex,vec2 uv,float rad, vec2 iResolution)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.003*iResolution.y/iResolution.x,.003),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<DOF_SAMPLES;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/float(DOF_SAMPLES);\n}\n\n\n", "buffer_a_code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 1.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBBRh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[555, 555, 624, 624, 724], [726, 726, 779, 779, 963], [965, 965, 999, 999, 1419], [1421, 1421, 1487, 1487, 1958], [1960, 1960, 2048, 2048, 2387], [2389, 2389, 2426, 2426, 2683], [2732, 2776, 2799, 2799, 5022], [5024, 5077, 5104, 5104, 5255], [5257, 5301, 5330, 5330, 5365], [5366, 5366, 5399, 5399, 5420], [5421, 5465, 5483, 5483, 5653], [5655, 5754, 5828, 5828, 6088], [6090, 6090, 6122, 6122, 6339], [6341, 6341, 6383, 6383, 6682], [6684, 6728, 6800, 6800, 7013], [7015, 7059, 7116, 7146, 10027]]}
{"id": "mtGGWm", "name": "clouds attempt1", "author": "manji369", "description": "clouds", "tags": ["clouds"], "likes": 1, "viewed": 106, "published": 3, "date": "1684112517", "time_retrieved": "2024-07-30T17:55:47.810859", "image_code": "\nconst float pos_x = -0.61;\nconst float pos_y = 0.23;\nconst float t = 4.60;\n\nfloat cloudShape(vec2 uv) {\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float cloudBody1 = smoothstep(0.0, 0.2, length(uv * vec2(1.0, 2.0)) - 0.2);\n    float cloudBody2 = smoothstep(0.1, 0.2, uv.y - sin(uv.x * 3.0) * 0.1);\n    float cloudBody3 = smoothstep(0.0, 0.2, length(uv - vec2(-0.1, -0.35)) - 0.1);\n    return min(min(cloudBody1, cloudBody2), cloudBody3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 bgColor = vec3(0.529, 0.808, 0.922);\n    vec3 cloudColor = vec3(0.3, 0.3, 1.0);\n    vec2 pos = vec2(pos_x, pos_y);\n    float time = t + iTime * 0.5;\n    pos.x += sin(time) * 0.2;\n    pos.y += cos(time * 0.5) * 0.1;\n    vec3 color = mix(bgColor, cloudColor, cloudShape(uv + pos)); \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 104, 104, 459], [462, 462, 519, 519, 887]]}
{"id": "dlG3Dw", "name": "Super Sampled Clock - 249 chars", "author": "GregRostami", "description": "This is a super sampled version of my previous Smallest Clock shader:\n[url]https://www.shadertoy.com/view/MsdXzH[/url]\nI'm certain fwidth can be used to do the same without super sampling, I just don't know how to do that.", "tags": ["2d", "clock", "short", "golf"], "likes": 6, "viewed": 176, "published": 3, "date": "1684107576", "time_retrieved": "2024-07-30T17:55:48.560854", "image_code": "// 249 chars - by Fabrice - Using analytic anti-aliasing (with smoothstep & fwidth)\n#define S(v) smoothstep(1.,0., v ) // \n#define N(t) + vec4( S( ( length(u/=.8) - R.y ) / dFdx(u.x) ) \\\n                   * S( (.998 - cos(iDate.w/t-atan(u.x,u.y) ))*length(6.*u)/fwidth(t+u.x) ))\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.xy;\n         u += u-R;\n         o = N(1e8-12.*)\n             N(573.)\n             N(9.55)\n             N(6875.); \n}\n\n\n// 228 chars - Golfed by Fabrice - will wait for further development before using fwidth\n/*\n#define N(t) +vec4( length(i/=.8) < R.y && cos(iDate.w/t-atan(i.x,i.y)) > .998 )\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o *= 0.;\n    vec2 R = iResolution.xy, i;  \n    for (int k=0; k++<100;    // Super sampling loop\n        o += N(1e9-12.*)      // Clock lines\n             N(9.55)          // Seconds hand\n             N(573.)          // Minutes hand \n             N(6875.))        // Hours hand\n             i = vec2(k%10,k/10)*.1 +u+u-R;  // Offset i by subpixel increments \n    o /= 1e2;                 // Divide by 100 for the average of 100 samples\n}\n*/\n\n// 247 chars - Original shader by Greg Rostami\n/*\n#define N(t) +vec4( length(i/=.8) < R.y && cos(iDate.w/t-atan(i.x,i.y)) > .998 )\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o *= 0.;\n    vec2 R = iResolution.xy, i; \n    for (float x=0., y; x<1.; x+=.1) for (y=0.; y<1.; y+=.1)  // Super sampling x,y loops\n        i = vec2(x,y)+u+u-R,  // Offset i by x,y subpixel increments\n        o += N(1e9-12.*)      // Clock lines\n             N(9.55)          // Seconds hand\n             N(573.)          // Minutes hand \n             N(6875.);        // Hours hand\n    o /= 1e2;                 // Divide by 100 for the average of 100 samples\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlG3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "mtGGDw", "name": "Test_cymatics", "author": "oliviano", "description": "Created by Cellulose in 2013-10-10\nhttps://www.shadertoy.com/view/4dfGDs", "tags": ["cymatics"], "likes": 3, "viewed": 156, "published": 3, "date": "1684100580", "time_retrieved": "2024-07-30T17:55:49.319825", "image_code": "float ripple(float dist, float shift)\n{\n\treturn cos(64.0 * dist + shift) / (1.0 + 1.0 * dist);\n}\n\n\n#define POLES 21\n\n#define REFLECTIONS 10.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat larger = max(iResolution.x, iResolution.y);\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) / larger;\n\tvec2 uvflip = vec2(uv.x, -uv.y);\n\tvec2 cursor = (iMouse.xy - .5*iResolution.xy) / larger;\n\tvec2 blessr = vec2(-cursor.x, cursor.y);\n\t\n\t//float on = float(abs(uv.x)<.25 && abs(uv.y)<.25);\n\t\n\tfloat lum = .5 +\n\t\t/*.1 * ripple(length(cursor - uv), -iTime) +\n\t\t.1 * ripple(length(blessr - uv), -iTime) +\n\t\t.1 * ripple(length(cursor - uvflip), -iTime) +\n\t\t.1 * ripple(length(blessr - uvflip), -iTime) +*/\n\t\t.1 * ripple(length(uv), 0.0) +\n\t\t//.1 * cos(64.0*uv.y - iTime) +\n\t\t//.1 * cos(64.0*(uv.x*uv.x) - iTime) +\n\t\t0.0;\n\t\n\tconst float twopi = 2.0*3.141592654;\n\tconst int count = POLES;\n\tfloat fcount = float(count);\n\tvec2 rot = vec2(cos(twopi*.618), sin(twopi*.618));\n\tvec2 tor = vec2(-sin(twopi*.618), cos(twopi*.618));\n\tfor (int i = 0; i < count; ++i)\n\t{\n\t\tlum += .2 * ripple(length(cursor - uv), -iTime);\n\t\tcursor = cursor.x*rot + cursor.y*tor;\n\t}\n\t\n\t/*float lum = .5, dist;\n\tvec2 part, flip = vec2(1.0, 1.0);\n\t\n\t//float freq = 64.0, phase = -iTime;\n\tfloat freq = 32.0, phase  = 0.0; // * pow(4.0, cos(iTime/8.0)), phase = 0.0;\n\t\n\tfor (float ox = -REFLECTIONS; ox <= REFLECTIONS; ox += 1.0)\n\t{\n\t\tfor (float oy = -REFLECTIONS; oy <= REFLECTIONS; oy += 1.0)\n\t\t{\n\t\t\tdist = length((cursor*flip-uv)+vec2(ox, oy));\n\t\t\tlum += cos(freq * dist - phase) / (5.0 + 10.0*dist);\n\t\t\t\n\t\t\tflip.y *= -1.0;\n\t\t}\n\t\tflip.x *= -1.0;\n\t}*/\n\t\n\tlum = 3.0*lum*lum - 2.0*lum*lum*lum;\n\tfragColor = vec4(lum, lum, lum, 1.0);\n\t\n\t\n\t/*fragColor = vec4(.5+.5*sin(3000.0*iTime),\n\t\t.5+.5*sin(4997.0*iTime+iResolution.x*3910.0),\n\t\t.5+.5*cos(2872.0*iTime+iResolution.y*8721.0), 1.0);*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 96], [143, 143, 200, 200, 1854]]}
{"id": "ctGGWm", "name": "kai time", "author": "jorge2017a2", "description": "kai time---Supremo kaioshama del tiempo--Super Dragon ball Heroes", "tags": ["draw", "anime", "dragonball", "kaitime", "lineto"], "likes": 6, "viewed": 217, "published": 3, "date": "1684085064", "time_retrieved": "2024-07-30T17:55:50.077798", "image_code": "//por jorgefloresP. jorge2017a1----\n//14-may-2023\n//kai time---Supremo kaioshama del tiempo--Super Dragon ball Heroes\n/// de nuevo falta el pelo ;(  :)\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(0.7),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat sdCircle( vec2 p, float r )\n {return length(p) - r; }\nfloat sdBox( in vec2 p, in vec2 b )\n { vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\n///-----rostro\nfloat sdPoly12 POLY(12)\nvec2  pt12[12]=vec2[](\nvec2(3.19,2.28),vec2(2.58,2.58),vec2(2.54,2.63),vec2(2.23,3.16),vec2(2.05,4.23),\nvec2(4.4,4.21),vec2(4.18,3.08),vec2(4.11,2.97),vec2(3.95,2.68),vec2(3.91,2.65),\nvec2(3.28,2.28),vec2(3.19,2.28)  );\n\n\n///ojo izq\nfloat sdPoly5 POLY(5)\nvec2  pt5[5]=vec2[](\nvec2(2.43,3.39),vec2(2.93,3.35),vec2(2.76,3.61),vec2(2.22,3.72),vec2(2.43,3.39)  );\n\nfloat sdPoly6 POLY(6) //ojo der\nvec2  pt6[6]=vec2[](\nvec2(3.47,3.34),vec2(3.68,3.62),vec2(3.97,3.69),vec2(4.32,3.72),vec2(3.99,3.38),\nvec2(3.47,3.34)  );\n\nfloat sdPoly7 POLY(7)  //corona\nvec2  pt7[7]=vec2[](\nvec2(1.65,4.11),vec2(1.28,5.75),vec2(5.28,5.77),vec2(4.86,4),vec2(3.45,4.75),\nvec2(3.02,4.73),vec2(1.65,4.11)  );\n\nfloat sdPoly6N POLY(6) //nariz\nvec2  pt6N[6]=vec2[](\nvec2(3.19,3.23),vec2(3.12,3.11),vec2(3.05,3.05),vec2(3.05,3.03),vec2(3.19,2.93),\nvec2(3.19,3.23)  );\n\n\n//boca \nfloat sdPoly9 POLY(9)\nvec2  pt9[9]=vec2[](\nvec2(2.99,2.91),vec2(3.03,2.88),vec2(3.35,2.88),vec2(3.42,2.93),vec2(3.44,2.88),\nvec2(3.35,2.71),vec2(3.09,2.7),vec2(2.99,2.85),vec2(2.99,2.91)  );\n\nvec2 p0_; //punto uv\nvec2 pt0; //punto pos0\nfloat DistL;\nvec3 ColL;  //color linea\nvec3 ColO;  //color salida Out\n\nvoid L( vec2 p1)\n{   DistL=sdSegment(p0_, pt0, p1 );\n    ColO= DrawFigBorde(ColL, ColO,DistL); //cabeza\n    pt0 = p1;\n}\nvoid SZ(vec2 p ){pt0 = p;}\nvoid M(vec2 p1){pt0 = p1;}\nvoid C(vec3 pcol){ColL=pcol;}\n\nvec3 LineaPelo(vec2 p,vec3 col )\n{\n///puntos linea pelo 2\nvec2 p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21;\np1=vec2(1.95,2.79);p2=vec2(2.38,2.31);\np3=vec2(2.24,3);p4=vec2(2.18,3.89);\np5=vec2(2.33,4.07);p6=vec2(2.21,3.72);\np7=vec2(2.89,3.98);p8=vec2(2.64,3.74);\np9=vec2(3.35,3.79);p10=vec2(3.49,3.89);\np11=vec2(3.32,3.67);p12=vec2(3.83,3.74);\np13=vec2(4.13,3.99);p14=vec2(4.07,3.76);\np15=vec2(4.31,4);p16=vec2(4.2,3.89);\np17=vec2(4.19,3.03);p18=vec2(4.1,2.34);\np19=vec2(4.35,2.64);p20=vec2(4.44,2.83);\np21=vec2(4.42,2.47);\np0_=p;\nColO=col;\nSZ(p1);M(p1);C(vec3(0.0));\nL(p1);L(p2);L(p3);L(p4);L(p5);L(p6);L(p7);L(p8);L(p9);L(p10);L(p11);\nL(p12);L(p13);L(p14);L(p15);L(p16);L(p17);L(p18);L(p19);L(p20);L(p21);\n col=ColO; return col;\n}\n\nvec3 cabezaKaiTime(vec2 p, vec3 col)\n{   float sd12 = sdPoly12(p, pt12); //rostro\n    float sd5 = sdPoly5(p, pt5);//ojo izq\n    float sd6 = sdPoly6(p, pt6);//ojo der\n    float sd7 = sdPoly7(p, pt7); //corona\n    float sd6N = sdPoly6N(p, pt6N); //nariz\n   float sd9 = sdPoly9(p, pt9); //boca\n    //cornea izq\n    vec2 p1=vec2(2.71,3.64) ; float r1=0.24;\n    float d1=sdCircle(p-p1,r1);\n    //cornea der\n    vec2 p2=vec2(3.82,3.6); float r2=0.22;\n    float d2=sdCircle(p-p2,r2);\n    //iris izq\n    vec2 p3=vec2(2.715,3.595);float r3=0.085;\n    float d3=sdCircle(p-p3,r3);\n    //iris der\n    vec2 p4=vec2(3.805,3.595); float r4=0.085;\n    float d4=sdCircle(p-p4,r4);\n    //cabeza\n    vec2 p5=vec2(3.26,3.48) ; float r5=1.45;\n    float d5=sdCircle(p-p5,r5);\n    d1= intersectSDF(sd5, d1);\n    d3= intersectSDF(d3, d1); //cornea e iris izq\n    d2= intersectSDF(sd6, d2);\n    d4= intersectSDF(d4, d2);\n    //diente superior\n    float l1=3.19, t1=2.95;\n    float an1=0.32, al1=0.11;\n    vec2 pos=vec2(l1,t1);\n    vec2 med=vec2(an1, al1);\n\n    float d6a= sdBox(p-pos, med);\n    d6a= intersectSDF(d6a, sd9);\n    \n    //diente inferior\n    l1=3.19, t1=2.68;\n    an1=0.32, al1=0.11;\n     pos=vec2(l1,t1);\n     med=vec2(an1, al1);\n    float d6b= sdBox(p-pos, med);\n    d6b= intersectSDF(d6b, sd9);\n     ///cuello\nl1=3.22; t1=2.31;\nan1=0.62; al1=0.27;\npos=vec2(l1,t1);\nmed=vec2(an1, al1);\nfloat d7= sdBox(p-pos, med);\n\n    vec3 colr=vec3(0.95,0.97,1.); //blanco\n    vec3 colra=vec3(0.66,0.83,0.92);\n    col= DrawFigBorde(colr, col,d7); //cuello\n    col= DrawFigBorde(colr, col,sd12); //cabeza\n    col= DrawFigBorde(vec3(1.0), col,sd5 );\n    col= DrawFigBorde(vec3(1.0), col,sd6);\n    col= DrawFigBorde(vec3(1.0,0.75,0.3), col,sd7); //corona\n    col= DrawFigBorde(vec3(1.0), col,sd6N); //nariz\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col,sd9); //boca\n    col= DrawFigBorde(vec3(1.0), col,d6a); //diente\n    col= DrawFigBorde(vec3(1.0), col,d6b); ///diente\n    col= DrawFigBorde(vec3(0.0,0.7,1.0), col,d1);\n    col= DrawFigBorde(vec3(0.0,0.7,1.0), col,d2);\n    col= DrawFigBorde(vec3(0.0,0.0,0.0), col,d3);\n    col= DrawFigBorde(vec3(0.0,0.0,0.0), col,d4);\n    col= LineaPelo(p,col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5); uv*=3.5;\n    vec3 col=mix(vec3(0.66,0.83,0.92),vec3(0.76,0.78,0.9),fract(iTime*0.5))  ;\n    float t=iTime;\n    col= cabezaKaiTime(uv-vec2(-3.5,-1.5),col);\n    uv.x=abs(uv.x)+(2.0+0.5*sin(t*2.0))-(1.0+0.5*sin(t));\n    col= cabezaKaiTime(uv*0.5-vec2(0.0,-2.0),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "#define PI 3.14159265358979323846\n#define TAU PI*2.\n#define C  32.703\n/*#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n*/\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n {return sin(t*note*exp2(octave)*PI);}\nfloat saw(float t, float note, float octave)\n {return fract(t*note*exp2(octave-1.))-0.5;}\nfloat tri(float t, float note, float octave)\n {return (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;}\nfloat sqr(float t, float note, float octave)\n {return step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;}\nvec2 mainSound( int samp, float time )\n{ float t=time*0.5;\n  float s1=tri(t, C+sn(t, C, 3.0), 5.)*0.35;\n  return vec2(s1);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[655, 655, 717, 717, 843], [844, 844, 925, 925, 1053], [1054, 1054, 1118, 1118, 1189], [1190, 1190, 1237, 1237, 1264], [1265, 1265, 1308, 1308, 1335], [1336, 1336, 1384, 1384, 1412], [1413, 1413, 1449, 1449, 1472], [1473, 1473, 1511, 1511, 1583], [1584, 1584, 1636, 1636, 1743], [2939, 2939, 2957, 2957, 3058], [3059, 3059, 3076, 3076, 3085], [3086, 3086, 3102, 3102, 3112], [3113, 3113, 3131, 3131, 3142], [3144, 3144, 3178, 3201, 3905], [3907, 3907, 3945, 3945, 6094], [6096, 6096, 6153, 6153, 6567]]}
{"id": "dtVGWW", "name": "Personal Voronoi Generator", "author": "RoboticWater", "description": "Generates Voronoi noise for a game project. Will probably be used for games.", "tags": ["voronoi", "noise", "cells", "generator"], "likes": 1, "viewed": 174, "published": 3, "date": "1684076557", "time_retrieved": "2024-07-30T17:55:50.888630", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    float scale = 10.;\n\n    // Scale\n    st *= scale;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimum distance\n    vec2 m_neighbor = vec2(0,0);\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n\n            // Random position from current + neighbor place in the grid\n            vec2 test = vec2(mod(i_st.x + neighbor.x, scale), mod(i_st.y + neighbor.y, scale));\n            vec2 point = random2(test);\n\n\t\t\t// Animate the point\n            // point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_neighbor = m_dist <= dist ? m_neighbor : point;\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    //color += m_dist;\n\n    // Draw cell center\n    // color += 1.-step(.02, m_dist);\n\n    // Draw grid\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    // Show isolines\n    // color -= step(.7,abs(sin(27.0*m_dist)))*.5;\n    //float c = random2( m_neighbor ).x;\n    float c = m_dist;\n\n    fragColor = vec4(c, c, c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVGWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 143, 143, 236], [238, 238, 294, 294, 1792]]}
{"id": "Dty3Ww", "name": "vastness of Image space (WIP)", "author": "jakel101", "description": "with help of Copilot chat\nIt is meant to show the concept of how vast image space is. Based on a fact noted by Steve Brunton in this video https://www.youtube.com/watch?v=Dt2WYkqZfbs a 20x20 image with just black or white pixels has more information than ", "tags": ["random", "educational"], "likes": 2, "viewed": 164, "published": 3, "date": "1684075553", "time_retrieved": "2024-07-30T17:55:51.740353", "image_code": "float modSecs(float modulo)\n{\n    return mod(floor(iTime), modulo);\n}\n\n// an array of 13 int32 numbers can hold the 400bit number for us?\nint[13] number;\n\nbool get_bit(int idx)\n{   \n    // register of which idx of the array we are in\n    int reg = idx >> 5;\n    // remainder of which index in the specific int32 we are in\n    int rem = idx & 0x1F;\n    \n    return ((number[reg] >> int(rem)) & 1) == 0;\n}\n\nbool get_bit_from_float(float inp, int idx)\n{   \n    return ((int(inp) >> idx) & 1) == 1;\n}\n\nvoid set_bit(bool val, int idx)\n{\n    // register of which idx of the array we are in\n    int reg = idx >> 5;\n    // remainder of which index in the specific int32 we are in\n    int rem = idx & 0x1F;\n\n    number[reg] |= (int(val) << rem);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Define the resolution of the screen\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 fields = floor(uv * 20.0);\n    \n    float field_idx = fields.x + (fields.y * 20.0);\n\n    // fill number with something \"random\"\n    for (int i = 0; i < 13; i++)\n    {\n        // number[i] = 0xFA0AFA0A; // some funny pattern\n        number[i] = int(fract(sin(floor(iTime)))*165191048.7*float(i+1)); // some \"random\" number constructor for now\n    }\n\n    // set_bit(true, (int(iTime)*2)); // not persistent?\n\n    // Determine the color of the pixel based on its position\n    // color.r (red) is one field at a time, walks around the whole screen in 400 seconds\n    // color.g (green) does nothing right now (working on LSFR to run through all 400 bit of possible numbers randomly)\n    // color.b (blue) is a binary counter of iDate.w (the seconds), counts up to 3600, but runs over at 32 bit.\n    vec3 color = vec3(mod(field_idx - modSecs(400.0),400.0), get_bit(int(field_idx)), get_bit_from_float(iDate.w, int(field_idx)));\n\n    // just look at red channel\n    // color = vec3(color.r);\n    \n    // just look at green channel\n    color = vec3(color.g);\n\n    // just look at blue channel\n    // color = vec3(color.b);\n\n    // Set the color of the pixel\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dty3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 69], [155, 155, 178, 233, 403], [741, 741, 796, 839, 2076]]}
{"id": "clyGWw", "name": "[Revision 2023] Qualif", "author": "totetmatt", "description": "Not exactly the same because of usual platform difference between bonzo and st.", "tags": ["revision", "shadershowdown"], "likes": 11, "viewed": 276, "published": 3, "date": "1684073109", "time_retrieved": "2024-07-30T17:55:52.489350", "image_code": "float bpm;\n  vec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\nfloat txt(vec2 p,float t){\n     ivec2 i = ivec2(abs(p)*128.);\n      return dot(sin(float(i)),cos(float(i.yx)*t))+float(i.x&i.y)/128.;;\n  }\n  float rand(vec2 p){\n       return fract(535.55*sin(dot(p,vec2(85.5,479.5))));\n    }\n  vec3 path(vec3 p){\n    \n     vec3 o = vec3(0.);\n       o.x +=sin(p.z*.1)*2.;\n       o.x +=sin(p.z*.55)*.44;\n       o.y +=sin(p.z*.33)*.44;\n       o.y +=cos(p.z*.24)*.5;\n      return o;\n    }\n    float terr(vec3 p){\n        float d=0.;\n         for(float i=.5;i<5.;i+=i){\n           \n              d+= dot(asin(sin(erot(p*i,vec3(0.,1.,0),i))),vec3(.5))/i/4.;\n           }\n           \n           return d;\n      \n      }\nvec2 sdf(vec3 p){\n     vec2 h;\n     vec3 hp=p;\n  \n     vec3 ph= path(hp);\n  \n     float ff = 1.-tanh(abs(hp.x-ph.x)-1.);\n     h.x  = dot(hp,vec3(0.,1.,0.))+1.+ff+terr(hp)+texture(iChannel0,fract(vec2(.3+ff*.01))).r;;\n     h.y= 1.;\n  \n     vec2 t;\n     vec3 tp=p;\n     \n      tp-=ph;  \n      tp.y +=1.;\n   float gy = dot(sin(tp*1.5),cos(tp.zxy));\n    tp+=gy*.1;\n     tp= erot(tp,vec3(0,0,1),tp.z);\n  tp.xy= abs(tp.xy)-.2;tp.xy=abs(tp.xy)-.1;\n     t.x =  max(abs(tp.z-bpm)-5.,length(tp.xy)-.02);\n     t.y = 2.;\n     h=t.x < h.x ? t:h;\n     return h;\n  \n  }\n  #define q(s) s*sdf(p+s).x\n  \n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  bpm = +iTime*2.;\n   bpm+=+rand(uv)*.1;\n  bpm = floor(bpm) + pow(fract(bpm),2.1);\nvec3 col = vec3(0.);\n// Imagine revision logo\n    //col.r= texture(iChannel1,clamp(uv+.5+texture(iChannel0,vec2(1.)*fract(floor(bpm)*.1+txt(uv,1.))).r,0.,1.)).r;\n   //  col.gb= texture(iChannel1,clamp(uv+.5+texture(iChannel0,vec2(1.)*fract(floor(bpm)*.1+txt(uv,2.)))).r,0.,1.)).gb;\n   \n  vec3 ro=vec3(1.,1.,bpm+cos(bpm)),rt=vec3(0.,0.,bpm+tanh(sin(bpm*.25))*15.);\n  ro+=path(ro);\n  rt+=path(rt);\n  vec3 z=normalize(rt-ro),x=normalize(cross(z,vec3(0.,-1.,0))),y=cross(z,x);  \n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.+sin(bpm)*.1));\n  \n  vec3 rp= ro;\n   vec3 acc= vec3(0.);\n  // AZERTY FOR THE WIN\n   float dd =0.;\n  vec3 light = normalize(vec3(1.,2.,-3.));\n  for(float i=0.;i++<128. && dd < 50.;){\n    \n      vec2 d = sdf(rp);\n    \n       if(d.y ==2.){\n          acc+=vec3(.0,.3,.7)*exp(-abs(d.x))/(50.-min(45.,texture(iChannel0,vec2(fract(.3+bpm+rp.z*.1))).r*100.));\n          d.x = max(.001,abs(d.x));\n         }\n      rp+=rd*d.x;\n      dd+=d.x;\n       if(d.x < .001){\n          vec3 n = norm(rp,.005);\n         vec3 n2 = norm(rp,.007);\n           float dif = max(0.,dot(light,n));\n            float fr= pow(1.+dot(rd,n),4.);\n             col = +dif * vec3(.1);\n             if(d.y==1.){\n                  col  += smoothstep(.001,.1,length(n-n2))+fr*vec3(1.,.7,.3)*max(0.,1.-abs(rp.z-bpm-5.)*.2);\n                  rd= reflect(rd,n);\n                  rp+=rd*.1;\n                  continue;\n               \n               }\n             break;\n         \n         }\n    }\n    col = mix(col,vec3(.1),(.5)-exp(-dd));\n  \n\n    // Output to screen\n    fragColor = vec4(sqrt(col+acc),1.);\n    }", "image_inputs": [{"id": 33304, "src": "https://soundcloud.com/alkama/dissonance", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 47, 47, 101], [102, 102, 128, 128, 240], [243, 243, 262, 262, 326], [329, 329, 347, 347, 519], [524, 524, 543, 543, 747], [748, 748, 765, 765, 1302], [1336, 1336, 1363, 1363, 1438], [1442, 1442, 1499, 1549, 3284]]}
{"id": "dlVGDD", "name": "XY Grids_learn", "author": "afterlifevj", "description": "XY Grids", "tags": ["grids"], "likes": 0, "viewed": 145, "published": 3, "date": "1684064691", "time_retrieved": "2024-07-30T17:55:53.237351", "image_code": "#define SCALE 6.0\n#define R iResolution.xy\n#define M iMouse\n#define PI 3.14159265358979\n\n// gradient map ( equation, time, hardness, shadow, reciprocals )\nfloat gm(float eq, float t, float h, float s, bool i)\n{\n    float sg = min(abs(eq), 1.0/abs(eq)); // smooth gradient\n    float og = abs(sin(eq*PI-t)); // oscillating gradient\n    if (i) og = min(og, abs(sin(PI/eq+t))); // reciprocals\n    return pow(1.0-og, h)*pow(sg, s);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    float t = iTime/2.0;\n    float z = (M.z > 0.0) ? SCALE/2.0/(M.y/R.y): SCALE; // zoom\n    float h = 5.0; // hardness\n    float s = 0.25; // shadow\n    bool rc = false; // reciprocals\n    vec3 bg = vec3(0); // black background\n    \n    float aa = 2.0; // anti-aliasing\n    for (float j = 0.0; j < aa; j++)\n    for (float k = 0.0; k < aa; k++)\n    {\n        vec3 c = vec3(0);\n        vec2 o = vec2(j, k)/aa;\n        vec2 sc = (XY-0.5*R+o)/R.y*z; // screen coords\n        float x2 = sc.x*sc.x;\n        float y2 = sc.y*sc.y;\n\n        // square root grids\n        c += gm(x2, t, h, s, rc); // x\n        c += gm(y2, 0.0, h, s, rc); // y\n        c += gm(x2+y2, t, h, s, rc); // addition\n        c += gm(x2-y2, t, h, s, rc); // subtraction\n        c += gm(x2*y2, t, h, s, rc); // multiplication\n        c += gm(x2/y2, t, h, s, rc); // division\n        \n        bg += c;\n    }\n    bg /= aa*aa;\n    \n    bg *= sqrt(bg)*0.5; // brightness & contrast\n    RGBA = vec4(bg, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 155, 210, 210, 428], [430, 430, 473, 473, 1443]]}
{"id": "dtKGDD", "name": "animated knitting 2", "author": "FabriceNeyret2", "description": "WIP\ninspiration reference:https://twitter.com/PavelBoytchev/status/1650945937462685713\n- any cheap way to avoid the artifact ?\n- way to accelerate ?", "tags": ["short", "reproduction"], "likes": 32, "viewed": 418, "published": 3, "date": "1684063922", "time_retrieved": "2024-07-30T17:55:53.999313", "image_code": "// variant of https://shadertoy.com/view/mtKGWD\n// cf https://www.desmos.com/calculator/zd265cjxqi\n#define rot2(a)  mat2(cos(a+vec4(0,11,33,0)))\n#define arc(L)   t = min(t, max( length( vec2( length((L).xy)-r,(L).z) ) -.1, abs(atan((L).x,(L).y)-A)-A ))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,d=1., h,r,A,i, T, y, s = 1.5;\n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),        // ray direction\n          p = vec3(0,0,30), q,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.        // camera control\n              :  vec3( -.8,-.5,0);\n    \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 ) {     // march scene\n        q = p, \n        q.yz *= rot2(-M.y),                              // rotations\n        q.xz *= rot2(-M.x-1.57),\n        T = mod(.3*iTime,1.33), q.y +=  6.; q.x -= T*1.5;   // infinite scroll\n        if (q.x>1.) T = 2.65-T;\n        T -= floor(abs(q.x/2.)+.5)*1.3, q.x = abs(mod(q.x-1.,2.)-1.); // repeat along x\n        for( i=0.; i<8.; i++ , q.y -= s )                // foreach thread\n            h = 3.*clamp(T-i+3.7,1e-3,1.), r = (d*d+h*h)/h/4., A = atan(h/d),\n            y = .5*sin(s*q.y),\n            arc(     vec3(1, r  , y ) - q ), \n            arc( q - vec3(0, h-r, y )     ),\n            t = min(t, length(q-vec3(1,.75,0))+.1 );     // trick to limit the artifact\n         // t = min(t,max( length(q.yz)-.1, 1.-abs(q.x)) );\n        p += .5*t*D;                                     // step forward = dist to obj    \n    }\n   O *= O*O*O*2.;                                        // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 290, 290, 1624]]}
{"id": "mtKGWD", "name": "animated knitting", "author": "FabriceNeyret2", "description": "WIP\ninspiration reference:https://twitter.com/PavelBoytchev/status/1650945937462685713\n- any cheap way to avoid the artifact ?\n- way to accelerate ?", "tags": ["short", "reproduction"], "likes": 30, "viewed": 262, "published": 3, "date": "1684057571", "time_retrieved": "2024-07-30T17:55:54.759281", "image_code": "// cf https://www.desmos.com/calculator/zd265cjxqi\n#define rot2(a)  mat2(cos(a+vec4(0,11,33,0)))\n#define arc(L)   t = min(t, max( length( vec2( length((L).xy)-r,(L).z) ) -.1, abs(atan((L).x,(L).y)-A)-A ))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,d=1., h,r,A,i, T,y;\n    vec3  R = iResolution, \n          D = normalize(vec3(U+U, -12.*R.y) - R),        // ray direction\n          p = vec3(0,0,30), q,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.        // camera control\n              :  vec3( -.8,-.5,0);\n    \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 ) {     // march scene\n        q = p, \n        q.yz *= rot2(-M.y),                              // rotations\n        q.xz *= rot2(-M.x-1.57),\n        T = fract(iTime), q.y += 1.5*T + 6.,             // infinite scroll\n        T -= floor(abs(q.x/2.)+.5)*1.3, q.x = abs(mod(q.x-1.,2.)-1.); // repeat along x\n        for( i=0.; i<8.; i++ , q.y -= 1.5 )              // foreach thread\n            h = 3.*clamp(T-i+4.7,1e-3,1.), r = (d*d+h*h)/h/4., A = atan(h/d),\n            y = .5*sin(1.5*q.y),\n            arc(     vec3(1, r  , y ) - q ), \n            arc( q - vec3(0, h-r, y )     ),\n            t = min(t, length(q-vec3(1,.75,0))+.1 );     // trick to limit the artifact\n         // t = min(t,max( length(q.yz)-.1, 1.-abs(q.x)) );\n        p += .5*t*D;                                     // step forward = dist to obj    \n    }\n   O *= O*O*O*2.;                                        // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 242, 242, 1533]]}
{"id": "Dly3zm", "name": "Extruded Hexagon Grid Traversal", "author": "gelami", "description": "Fast ray-traversal of an extruded hexagonal grid\nFeatures hexagonal depth of field with FXAA 3.11\n\nMouse drag to look around\nDefines in Common", "tags": ["3d", "raytracing", "hexagon", "tiling"], "likes": 17, "viewed": 408, "published": 3, "date": "1684051448", "time_retrieved": "2024-07-30T17:55:55.694780", "image_code": "\n// Extruded Hexagon Traversal - gelami\n// https://www.shadertoy.com/view/Dly3zm\n\n/*\n * Fast ray-traversal of an extruded hexagonal grid\n * Features hexagonal depth of field with FXAA 3.11\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * Hexagonal grid traversals are nothing new and have been done alot of times already\n * but I figured I'd give it a try myself, which turned out to be pretty neat\n * \n * The traversal works by precomputing the side distances in the slab intersection\n *   which allows us to only use additions to advance the ray, like you would in DDA\n * That simplifies the traversal to only use additions for the side distances,\n *   and a couple of checks for picking the axis\n * \n * The rest is the usual extruded traversal method,\n * where you intersect the far-hit only, checking if the y position is less than height\n * before and after advancing the ray, if before its a top hit, else a side hit\n * \n * The DoF pass actually takes longer to do than rendering the actual scene itself lol\n * \n * Would be cool to add rounded edges to the hexagons, but perhaps for next time\n * Also a 3D voxel traversal equivalent to this, something like a truncated octahedron\n * or a a rhombic dodecahedral honeycomb would be quite interesting to explore as well\n * \n * Other hexagonal grid traversal shaders:\n * \n * Hexagonal Grid Traversal - 3D - iq\n * https://www.shadertoy.com/view/WtSfWK\n *\n * Hex Voxel Scene - Shane\n * https://www.shadertoy.com/view/4dsBz4\n * \n * Hex grid traversal - mattz\n * https://www.shadertoy.com/view/XdSyzK\n *\n * \n * FXAA 3.11 implementation and DoF from:\n * Two Grid Traversal w/ 1Pass DoF - gelami\n * https://www.shadertoy.com/view/dtt3DS\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    #ifdef CHROMATIC_ABBERATION\n    col = vec3(0);\n    vec3 w = vec3(0);\n    \n    float caStr = smoothstep(0.0, 0.5, dot(uv - 0.5, uv - 0.5));\n    \n    vec2 dir = normalize(uv - 0.5) / iResolution.xy;\n    \n    const float count = CHROMATIC_ABBERATION_STEPS;\n    for (float i = 0.0; i < count; i++)\n    {\n        vec3 c = palette((i + 0.5) / count);\n        w += c;\n        col += texture(iChannel0, uv + caStr * dir * i).rgb * c;\n    }\n    col /= w;\n    #endif\n    \n    #ifdef VIGNETTE\n    col *= smoothstep(1.0, 0.0, dot(uv - 0.5, uv - 0.5)) * 0.8 + 0.2;\n    #endif\n    \n    col = col / (1.0 + col);\n    \n    //col = mix(col, smoothstep(vec3(0), vec3(1), col), 0.2);\n    //col = ACESFilm(col);\n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//#define SSAA 2\n\n#define FXAA\n#define DOF\n\n#define CHROMATIC_ABBERATION\n#define CHROMATIC_ABBERATION_STEPS 8.0\n\n//#define VIGNETTE\n//#define FOG\n\n#define CAMERA_DISTANCE (14.0+(sin(iTime*0.25-PI*0.3)*0.5+0.5)*12.0)\n\n// DoF Defines\n#define DOF_FLAT_Z_DEPTH\n#define DOF_STEPS 32\n#define DOF_RADIUS 12.0\n\n#define DOF_FOCUS_DIST (CAMERA_DISTANCE*1.1)\n#define DOF_FOCUS_SCALE 12.0\n\n#define GOLDEN_ANGLE 2.39996323\n\n// Scene Defines\n#define STEPS 256\n\n#define MAX_HEIGHT 6.0\n#define MOTION 1\n\n// Constants\n#define MAX_DIST 100.0\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .25, .75)));\n}\n\nvec3 palette2(float t)\n{\n    return .45 + .55 * cos(TAU * (vec3(1, 0.95, 1) * t + vec3(0.3, 0.6, 0.8)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "\n// Scene\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-10 08:41:22\n\nfloat map(vec2 p)\n{\n    vec2 r = texture(iChannel0, 0.35 * (p - 1.5) / iChannelResolution[0].xy).xy;\n    float h = r.x;\n    \n    //h = (h-0.5)*1.7+0.5;\n    //h = saturate(h)*0.8+0.1;\n    h = smoothstep(0.22, 0.78, h)*0.8+0.1;\n    \n    #if MOTION == 0\n    h = saturate(sin((h + iTime * 0.4 + p.x * 0.06 + p.y * 0.08) * TAU)*0.5+0.5)*(h*0.7+0.3);\n    #elif MOTION == 1\n    h += sin((h + iTime * 0.55 + p.x * 0.06 + p.y * 0.08) * TAU)*0.13;\n    #endif\n    \n    return saturate(h) * 0.9999 * MAX_HEIGHT;\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 id;\n};\n\n// Traversal method\nbool trace(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    if (rd.y > 0.0 && ro.y > MAX_DIST)\n        return false;\n    \n    // Normals\n    const vec2 n0 = vec2(1, 0);\n    const vec2 n1 = vec2(0.5, sqrt(3.0)/2.0);\n    const vec2 n2 = vec2(0.5, -sqrt(3.0)/2.0);\n    \n    const vec2 ts = vec2(1, sqrt(3.0));\n    \n    // ID\n    vec2 p0 = floor(ro.xz / ts);\n    vec2 p1 = floor(ro.xz / ts - 0.5) + 0.5;\n    \n    vec2 c0 = (ro.xz - p0 * ts) - ts*0.5;\n    vec2 c1 = (ro.xz - p1 * ts) - ts*0.5;\n    \n    vec2 id = dot(c0, c0) < dot(c1, c1) ? p0 : p1;\n    \n    vec2 pc = id * ts + ts*0.5;\n    vec2 pp = ro.xz - pc;\n    \n    // Pre-compute variables\n    vec3 prd = 1.0 / vec3(dot(rd.xz, n0), dot(rd.xz, n1), dot(rd.xz, n2));\n    vec3 pro = vec3(dot(pp, n0), dot(pp, n1), dot(pp, n2)) * prd;\n    vec3 ard = abs(prd);\n    vec3 srd = sign(prd);\n    \n    vec2 o0 = n0 * srd.x;\n    vec2 o1 = n1 * srd.y;\n    vec2 o2 = n2 * srd.z;\n    \n    vec2 i0 = vec2(1, 0) * srd.x;\n    vec2 i1 = vec2(0.5, 0.5) * srd.y;\n    vec2 i2 = vec2(0.5, -0.5) * srd.z;\n    \n    vec3 pp0 = vec3(dot(i0 * ts, n0), dot(i0 * ts, n1), dot(i0 * ts, n2)) * prd;\n    vec3 pp1 = vec3(dot(i1 * ts, n0), dot(i1 * ts, n1), dot(i1 * ts, n2)) * prd;\n    vec3 pp2 = vec3(dot(i2 * ts, n0), dot(i2 * ts, n1), dot(i2 * ts, n2)) * prd;\n    \n    vec2 nrd = vec2(0);\n    float lt = 0.0;\n    vec3 pos = ro;\n    \n    vec3 k = ard * 0.5;\n    \n    vec2 ido = vec2(0);\n    vec3 ppo = vec3(0);\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        float h = map(id + ido);\n        \n        // Side hit\n        if (pos.y < h)\n        {\n            hit.t = lt;\n            hit.n = -vec3(nrd.x, 0, nrd.y);\n            hit.id = id + ido;\n            return true;\n        }\n        \n        // Compute side distances\n        vec3 n = pro - ppo;\n        vec3 t2 = -n + k;\n        \n        // Pick smallest axis\n        float tF = t2.x;\n        vec2 no = i0;\n        vec3 ppp = pp0;\n        nrd = o0;\n        \n        if (t2.y < tF)\n        {\n            tF = t2.y;\n            no = i1;\n            nrd = o1;\n            ppp = pp1;\n        }\n        if (t2.z < tF)\n        {\n            tF = t2.z;\n            no = i2;\n            nrd = o2;\n            ppp = pp2;\n        }\n        \n        pos = ro + rd * tF;\n        \n        // Early exit if above max height\n        if (rd.y > 0.0 && pos.y > MAX_HEIGHT)\n            return false;\n        \n        // Top hit\n        if (pos.y < h)\n        {\n            hit.t = -(ro.y - h) / rd.y;\n            hit.n = vec3(0, 1, 0);\n            hit.id = id + ido;\n            return true;\n        }\n        \n        // Advance ray\n        lt = tF;\n        id += no;\n        ppo += ppp;\n    }\n    \n    return false;\n}\n\nvec3 getSky()\n{\n    return palette2(0.35) * 0.6 + 0.1;\n}\n\nvec3 shade(vec3 pos, HitInfo hit, const bool shadow)\n{\n    vec3 col = vec3(0);\n    vec3 alb = palette2(hash12(hit.id));\n    \n    col += alb * dot(abs(vec3(hit.n)), vec3(0.8, 1, 0.9));\n    \n    vec3 ldir = normalize(vec3(1, 3, 1));\n    vec3 ligCol = vec3(1, 0.6, 0.5)*1.2;\n    \n    float diff = max(dot(hit.n, ldir), 0.0);\n    \n    if (shadow)\n    {\n        HitInfo hitL;\n        bool isHitL = trace(pos + hit.n * EPS, ldir, hitL);\n\n        diff *= float(!isHitL);\n    }\n    \n    col *= smoothstep(0.0, MAX_HEIGHT*0.8, pos.y)*0.7+0.3;\n    \n    col *= (diff * 0.8 + 0.2) * ligCol;\n    \n    //col += alb * getSky() * 0.15;\n    \n    return col;\n}\n\nfloat fresnel(float r0, vec3 rd, vec3 n)\n{\n    return r0 + (1.0 - r0) * pow(1.0 - dot(-rd, n), 5.0);\n}\n\nvec3 fresnel(vec3 r0, vec3 rd, vec3 n)\n{\n    return r0 + (1.0 - r0) * pow(1.0 - dot(-rd, n), 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef SSAA\n    vec4 tot = vec4(0);\n    \n    for (int x = 0; x < SSAA; x++)\n    {\n        for (int y = 0; y < SSAA; y++)\n        {\n    vec2 o = (vec2(x, y) + 0.5) / float(SSAA);\n    vec2 pv = (2. * (fragCoord + o - 0.5) - iResolution.xy) / iResolution.y;\n    #else\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    #endif\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, CAMERA_DISTANCE);\n    vec3 lo = vec3(0, MAX_HEIGHT, 0);\n    \n    lo.xz += vec2(1, 0.4) * iTime * 0.8;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? -TAU * 0.3 + iTime * .21 : -m.x * TAU + PI;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? PI * (0.18+(sin(iTime*0.13)*0.5+0.5)*0.2) : -m.y * PI * 0.5 + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n\n    vec3 pos = ro;\n    float pt = 0.0;\n    \n    if (pos.y > MAX_HEIGHT)\n    {\n        pt = -(ro.y - MAX_HEIGHT) / rd.y;\n        pos = pos + rd * pt;\n    }\n    \n    HitInfo hit;\n    bool isHit = trace(pos, rd, hit);\n    //vec2 id = round((hit.id - 0.5) / vec2(1, sqrt(3.0)));\n    \n    float t = pt + hit.t;\n    \n    pos = pos + rd * hit.t;\n    \n    vec3 col = shade(pos, hit, true);\n    \n    vec3 alb = palette2(hash12(hit.id));\n    \n    vec3 ref = reflect(rd, hit.n);\n    \n    HitInfo hitR;\n    bool isHitR = trace(pos + hit.n * EPS, ref, hitR);\n    \n    vec3 refPos = pos + ref * hitR.t;\n    \n    vec3 refCol = shade(refPos, hitR, true);\n    \n    if (!isHitR)\n    {\n        refCol = getSky();\n    }\n    \n    vec3 specCol = mix(alb, vec3(1), 0.8);\n    float r0 = hash12(hit.id.yx) < 0.1 ? 1.0 : 0.1;\n    \n    float fre = fresnel(r0, rd, hit.n);\n    \n    col = mix(col, refCol * specCol, fre);\n    \n    if (!isHit)\n    {\n        col = getSky();\n    }\n    \n    #ifdef FOG\n    float fog = 1.0 - exp(-max(t - 20.0, 0.0) * 0.001);\n    col = mix(col, getSky(), fog);\n    #endif\n    \n    \n    #ifdef DOF_FLAT_Z_DEPTH\n    t *= dot(rd, cmat[2]);\n    #endif\n    \n    #ifndef SSAA\n    col = max(col, vec3(0));\n    \n    col = col / (1.0 + col);\n    col = linearTosRGB(col);\n    \n    fragColor = vec4(saturate(col), t);\n    \n    #else\n        tot += vec4(col, t);\n        }\n    }\n    tot /= float(SSAA*SSAA);\n    \n    tot.rgb = tot.rgb / (1.0 + tot.rgb);\n    tot.rgb = linearTosRGB(tot.rgb);\n    tot.rgb = saturate(tot.rgb);\n    \n    fragColor = tot;\n    #endif\n}\n", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// FXAA 3.11\n\n// Implementation from\n// Two Grid Traversal w/ 1Pass DoF - gelami\n// https://www.shadertoy.com/view/dtt3DS\n\n// FXAA Defines\n// Trims the algorithm from processing darks.\n//   0.0833 - upper limit (default, the start of visible unfiltered edges)\n//   0.0625 - high quality (faster)\n//   0.0312 - visible limit (slower)\n#define FXAA_THRESHOLD_MIN 0.0312\n\n// The minimum amount of local contrast required to apply algorithm.\n//   0.333 - too little (faster)\n//   0.250 - low quality\n//   0.166 - default\n//   0.125 - high quality \n//   0.063 - overkill (slower)\n#define FXAA_THRESHOLD_MAX 0.063\n\n// This can effect sharpness.\n//   1.00 - upper limit (softer)\n//   0.75 - default amount of filtering\n//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n//   0.25 - almost off\n//   0.00 - completely off\n#define FXAA_SUBPIXEL_QUALITY 0.75\n\n// Assumed to be in perceptual/gamma-encoded space\nfloat luma(vec3 col)\n{\n    //return dot(col, vec3(0.2126729, 0.7151522, 0.0721750));\n    return dot(col, vec3(0.299, 0.587, 0.114));\n    return sqrt(dot(col, vec3(0.299, 0.587, 0.114)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    #ifndef FXAA\n    col.rgb = sRGBToLinear(col.rgb);\n    col.rgb = col.rgb / (1.0 - col.rgb);\n    \n    fragColor = col;\n    #else\n    float lumaCenter = luma(col.rgb);\n    float lumaUp    = luma(texture(iChannel0, uv + vec2(0, px.y)).rgb);\n    float lumaDown  = luma(texture(iChannel0, uv - vec2(0, px.y)).rgb);\n    float lumaLeft  = luma(texture(iChannel0, uv - vec2(px.x, 0)).rgb);\n    float lumaRight = luma(texture(iChannel0, uv + vec2(px.x, 0)).rgb);\n\n    float lumaMin = min(min(min(lumaUp, lumaDown), min(lumaLeft, lumaRight)), lumaCenter);\n    float lumaMax = max(max(max(lumaUp, lumaDown), max(lumaLeft, lumaRight)), lumaCenter);\n\n    float lumaRange = lumaMax - lumaMin;\n\n    if (lumaRange < max(FXAA_THRESHOLD_MIN, lumaMax * FXAA_THRESHOLD_MAX))\n    {\n        col.rgb = sRGBToLinear(col.rgb);\n        col.rgb = col.rgb / (1.0 - col.rgb);\n    \n        fragColor = col;\n        return;\n    }\n    \n    float lumaDownLeft  = luma(texture(iChannel0, uv - vec2(px.x, px.y)).rgb);\n    float lumaUpRight   = luma(texture(iChannel0, uv + vec2(px.x, px.y)).rgb);\n    float lumaDownRight = luma(texture(iChannel0, uv + vec2(px.x, -px.y)).rgb);\n    float lumaUpLeft    = luma(texture(iChannel0, uv + vec2(-px.x, px.y)).rgb);\n    \n    float lumaDownUp = lumaDown + lumaUp;\n    float lumaLeftRight = lumaLeft + lumaRight;\n    \n    float lumaCornerDown = lumaDownRight + lumaDownLeft;\n    float lumaCornerUp = lumaUpRight + lumaUpLeft;\n    float lumaCornerLeft = lumaDownLeft + lumaUpLeft;\n    float lumaCornerRight = lumaDownRight + lumaUpRight;\n\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaCornerLeft) +\n                           abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 +\n                           abs(-2.0 * lumaRight + lumaCornerRight);\n    \n    float edgeVertical   = abs(-2.0 * lumaUp + lumaCornerUp) +\n                           abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 +\n                           abs(-2.0 * lumaDown + lumaCornerDown);\n\n    bool isEdgeHorizontal = edgeHorizontal >= edgeVertical;\n\n    float luma0 = isEdgeHorizontal ? lumaDown : lumaLeft;\n    float luma1 = isEdgeHorizontal ? lumaUp : lumaRight;\n    \n    float grad0 = abs(luma0 - lumaCenter);\n    float grad1 = abs(luma1 - lumaCenter);\n\n    bool gradStep = grad0 >= grad1;\n    \n    float gradScaled = 0.25 * max(grad0, grad1);\n    \n    float stepSize = isEdgeHorizontal ? px.y : px.x;\n    stepSize = gradStep ? -stepSize : stepSize;\n    \n    float lumaLocalAvg = 0.5 * ((gradStep ? luma0 : luma1) + lumaCenter);\n\n    vec2 curUV = uv;\n    \n    if (isEdgeHorizontal)\n        curUV.y += stepSize * 0.5;\n    else\n        curUV.x += stepSize * 0.5;\n    \n    vec2 stepOffset = isEdgeHorizontal ? vec2(px.x, 0) : vec2(0, px.y);\n    \n    vec2 uv0 = curUV - stepOffset;\n    vec2 uv1 = curUV + stepOffset;\n    \n    float lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n    float lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n    \n    bool reached0 = abs(lumaEnd0) >= gradScaled;\n    bool reached1 = abs(lumaEnd1) >= gradScaled;\n    \n    if (!reached0) uv0 -= stepOffset;\n    if (!reached1) uv1 += stepOffset;\n    \n    if (!(reached0 && reached1))\n    {\n        #define ITERATIONS 12\n        const float QUALITY[ITERATIONS] = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0, 8.0);\n        for (int i = 2; i < ITERATIONS; i++)\n        {\n            if (!reached0)\n            {\n                lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n            }\n            if (!reached1)\n            {\n                lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n            }\n            \n            reached0 = abs(lumaEnd0) >= gradScaled;\n            reached1 = abs(lumaEnd1) >= gradScaled;\n            \n            if (!reached0) uv0 -= stepOffset * QUALITY[i];\n            if (!reached1) uv1 += stepOffset * QUALITY[i];\n            \n            if (reached0 && reached1) break;\n        }\n    }\n    \n    float distance0 = isEdgeHorizontal ? (uv.x - uv0.x) : (uv.y - uv0.y);\n    float distance1 = isEdgeHorizontal ? (uv1.x - uv.x) : (uv1.y - uv.y);\n    \n    float lumaDist = distance0 < distance1 ? lumaEnd0 : lumaEnd1;\n    \n    float pixelOffset = -min(distance0, distance1) / (distance0 + distance1) + 0.5;\n    \n    bool correctVar = lumaCenter < lumaLocalAvg != lumaDist < 0.0;\n    \n    float finalOffset = correctVar ? pixelOffset : 0.0;\n    \n    float lumaAvg = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaCornerLeft + lumaCornerRight);\n    \n    float subpixelOffset = smoothstep(0.0, 1.0, abs(lumaAvg - lumaCenter) / lumaRange);\n    subpixelOffset = subpixelOffset * subpixelOffset * FXAA_SUBPIXEL_QUALITY;\n    \n    finalOffset = max(finalOffset, subpixelOffset);\n    \n    vec2 finalUV = uv;\n    \n    if (isEdgeHorizontal)\n        finalUV.y += stepSize * finalOffset;\n    else\n        finalUV.x += stepSize * finalOffset;\n    \n    vec3 fcol = texture(iChannel0, finalUV).rgb;\n    \n    fcol = sRGBToLinear(fcol);\n    fcol = fcol / (1.0 - fcol);\n    \n    fragColor = vec4(fcol, col.a);\n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// Depth of Field\n\n// Hexagonal bokeh shape from:\n// Morphing bokeh shape sample taps - BeRo\n// https://www.shadertoy.com/view/MtlGRn\n// http://www.crytek.com/download/Sousa_Graphics_Gems_CryENGINE3.pdf\nvec2 getBokehCoord(vec2 o, const float f, const float n, const float offset){\n    vec2 ab = o;    \n    vec2 p;\n    if (ab.x * ab.x > ab.y * ab.y)\n        p = vec2(abs(ab.x) > 1e-8 ? PI * 0.25 * ab.y / ab.x : 0.0, ab.x);\n    else\n        p = vec2(abs(ab.y) > 1e-8 ? (PI * 0.5 - (PI * 0.25 * ab.x / ab.y)) : 0.0, ab.y); \n    p.x += f * offset;\n    \n    if (f > 0.0)\n        p.y *= pow((cos(PI / n) / cos(p.x - ((TAU / n) * floor((n * p.x + PI) / TAU)))), f);\n    \n    return vec2(cos(p.x), sin(p.x)) * p.y;\n}\n\nfloat getCoC(float t, float focalDist, float scale)\n{\n    return saturate(abs(1.0 / focalDist - 1.0 / t) * scale) * DOF_RADIUS;\n}\n\n// Depth of Field method modified from:\n// Two Grid Traversal w/ 1Pass DoF - gelami\n// https://www.shadertoy.com/view/dtt3DS\nvec3 depthOfField(sampler2D tex, vec2 fragColor, vec2 res)\n{\n    vec2 px = 1.0 / res;\n    vec2 uv = fragColor * px;\n    \n    vec4 center = texture(tex, uv);\n    \n    float coc = getCoC(center.a, DOF_FOCUS_DIST, DOF_FOCUS_SCALE);\n    \n    if (coc < 0.5)\n        return center.rgb;\n    \n    const float DOF_SIDES = 6.0;\n    const float f = 1.0;\n    \n    vec3 color = center.rgb;\n    float w = 1.0;\n    \n    float radStep = DOF_RADIUS / float(DOF_STEPS);\n    float rad = radStep * 0.5;\n    float ang = 0.0;\n    \n    for (int i = 0; i < DOF_STEPS; i++)\n    {\n        //vec2 p = vec2(cos(ang), sin(ang));\n        vec2 p = getBokehCoord(vec2(cos(ang), sin(ang)), f, DOF_SIDES, PI * 0.5);\n        \n        vec4 samp = texture(tex, uv + p * rad * px);\n        \n        float sampCoC = getCoC(samp.a, DOF_FOCUS_DIST, DOF_FOCUS_SCALE);\n        \n        if (samp.a > center.a)\n            sampCoC = clamp(sampCoC, 0.0, coc * 2.0);\n        \n        float r = rad * length(p);\n        float m = smoothstep(r - 0.5, r + 0.5, sampCoC);\n        \n        color += mix(color / w, samp.rgb, m);\n        ang += GOLDEN_ANGLE;\n        rad += radStep / rad;\n        //rad = sqrt(DOF_RADIUS * float(i) / float(DOF_STEPS));\n        w += 1.0;\n    }\n    \n    return color / w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef DOF\n    vec3 col = depthOfField(iChannel0, fragCoord, iResolution.xy);\n    #else\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    #endif\n    \n    fragColor = vec4(col, 1);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dly3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1704, 1704, 1761, 1761, 2695]]}
{"id": "dlVGDW", "name": "generalized solenoid", "author": "FabriceNeyret2", "description": "mouse.x vs .y  controls the 2 turns parameters", "tags": ["spiral", "ring"], "likes": 29, "viewed": 254, "published": 3, "date": "1684049449", "time_retrieved": "2024-07-30T17:55:56.441783", "image_code": "// variant of https://shadertoy.com/view/ctyGWD\n\n#define rot2(a)      mat2(cos(a+vec4(0,11,33,0)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),        // ray direction\n          p = vec3(0,0,15), q, a,                        // marching point along ray \n          C = // iMouse.z > 0. ? 6.*iMouse.xyz/R -3. :   // camera control\n                vec3( 1,-.5,0),\n            //  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)),\n          S = ceil(20.* ( iMouse.z > 0. ? iMouse.xyz/R : // control of the turns amount\n                                         .5+.5*vec3(sin(iTime),cos(iTime/1.7),0)\n                  )     );\n\n    \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )       // march scene\n        q = p, \n        q.yz *= rot2(-C.y),                              // rotations\n        q.xz *= rot2(-C.x-1.57),\n        q = vec3( length(q.xz)-1., q.y, atan(q.z,q.x)-.5*iTime ), // cylindrical coordinates\n        q = vec3( length(q.xy), atan(q.y,q.x), q.z ),    // torus coordinates\n      //a = cos(q.z -iTime + vec3(0,11,0)), q.z += .5*iTime, // time modulators: radius, angle\n      //q.x -= .2*(.5+.5*a.x), q.z += .5*a.y,            // time modulation\n        t = min(t, length( vec2(q.x-.2, ( mod(S.x*q.z-S.y*q.y,6.28)-3.14 ) /16. ) // solenoïd\n                         ) - .05 ),\n        p += .5*t*D;                                     // step forward = dist to obj    \n    \n   O *= O*O*O*1.6;                                       // color scheme \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 136, 136, 1548]]}
{"id": "clV3WD", "name": "Walking squares", "author": "Slals", "description": "left down and down left", "tags": ["2d", "flat", "pixel", "pattern"], "likes": 8, "viewed": 168, "published": 3, "date": "1684018164", "time_retrieved": "2024-07-30T17:55:57.273559", "image_code": "float easeInQ(float x) {\n    return pow(x, 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv *= 30.0;\n    vec2 pid = floor(uv);\n    uv = fract(uv);\n    \n    float s = step(max(abs(uv.x), abs(uv.y)), 1.0);\n    \n    vec2 m = mod(pid, 2.0);\n    fragColor = vec4( vec3(m.x, 0.5 * m.y, 1.0 - 0.5 * m.x) * s * easeInQ(abs(sin(iTime * 1.33 + pid.x)) * abs(cos(iTime * 1.33 + pid.y))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clV3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 50], [52, 52, 109, 109, 480]]}
{"id": "DtVGWD", "name": "Pins of Light remix", "author": "afterlifevj", "description": "Original by Chunderfpv - I'm just tinkering!", "tags": ["spiral", "vortex"], "likes": 7, "viewed": 254, "published": 3, "date": "1684013824", "time_retrieved": "2024-07-30T17:55:58.145229", "image_code": "void mainImage(out vec4 RGBA, in vec2 XY)\n{\n\tvec4 mc = M; mc.xy = MC; // mouse coords\n\tfloat z = Z; // mouse y zoom\n    float e = E; // spiral exponent\n    float s = SCALE;\n    if (mc.z > 0.0) {s = 2.5; e = -mc.y;}\n\tvec2 sc = SC; // screen coords\n\tfloat px = PX; // pixel radius\n    \n    vec3 purp = vec3(0.4, 0.3, 0.9);\n\tvec3 c = purp*vec3(pow(min(length(sc), 1.0/length(sc)), 2.0))*0.5; // background\n\tfloat lim = 25.0;\n\tfor(float i = 0.0; i < 1.0; i += 1.0/lim)\n\t{\n\t\tvec3 h = vec3(i, 1.0-abs(i+i-1.0), 1.0-i); // Xor's chromatic\n\t\tc += texture(iChannel0, mix(XY/R, vec2(0.5), -sign(e)*0.25*i), AA).rgb*h*0.25;\n\t}\n\tc += FS(px*8.0)*purp;\n    c += FS(px);\n\tRGBA = vec4(c, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T iTime\n#define M iMouse\n#define SCALE 1000.0\n#define E (1.0)\n#define N ((T/60.0)+50.0)\n#define PI radians(180.0)\n#define TAU (PI*2.0)\n#define CS(a) vec2(cos(a), sin(a))\n#define FS(w) fs(sc, e, N, w, sqrt(N)*200.0)\n#define SC ((XY-0.5*R)/R.y*s*z)\n#define MC ((M.xy-0.5*R.xy)/R.y*2.0)\n#define Z (mc.z > 0.0) ? pow(1.0-abs(mc.y), 3.0*sign(mc.y)): 1.0\n#define PX length(fwidth(sc/1.414))\n#define AA 0.5\n\n// fraction spiral: decimal(n) to visual fraction\n// screen coords, exponent, value, width, rotation\nfloat fs(vec2 sc, float e, float n, float w, float ro)\n{\n\tfloat t = TAU*sqrt(abs(n))*sign(n);\n\tfloat r = round(exp(log(length(sc))/e));\n\tvec2 xy = sc-CS(ro-t*sqrt(r*2.0))*pow(r, e);\n\treturn max(0.0, 1.0-length(xy/w));\n}\n", "buffer_a_code": "void mainImage(out vec4 RGBA, in vec2 XY)\n{\n\tvec4 mc = M; mc.xy = MC; // mouse coords\n\tfloat z = Z; // mouse y zoom\n    float e = E; // spiral exponent\n    float s = SCALE;\n    if (mc.z > 0.0) {s = 2.5; e = -mc.y;}\n\tvec2 sc = SC; // screen coords\n\tfloat px = PX; // pixel radius\n    \n    vec3 c = vec3(texture(iChannel0, mix(XY/R, vec2(0.5), 0.002), AA).rgb)*0.95; // subtle after-image\n    c += FS(px*2.0); // spiral\n\tRGBA = vec4(c, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 679]]}
{"id": "7dXBD2", "name": "strobe glow", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 5, "viewed": 192, "published": 3, "date": "1684011024", "time_retrieved": "2024-07-30T17:55:59.204396", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-10.; i<=0.75; ++i) {\n\t\tfor(float j=-2.; j<=0.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(80000.,80000.), iResolution.y>7200. ? 60. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.01,02.,col);\n    col = pow(col,vec3(.65));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 044.1031);\n    p *= p + 33.33;\n    return fract(0.4*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * 33.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.3) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t,vec3(20,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(2.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.8)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.0001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<1;\n\tbool lightsilver = section>2 && section<12;\n\tbool lightgreen = section>5;\n\tbool lightpink = section>7 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>2);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.);\n     // motion slowing down during the last section\n\tfloat t2=section!=1?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==16) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 15;\n\tint sphmax = 15;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=100.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.1:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dXBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1416]]}
{"id": "DtK3DW", "name": "somnolent retrowave pyramid", "author": "hashtagexo", "description": "alteration of 'AI not included' by mrange seemingly undertaken directly by my subconscious: I fell asleep at my desk and just woke up with this on my screen and zero memory of working on it. \n", "tags": ["2d", "heartless"], "likes": 2, "viewed": 68, "published": 3, "date": "1684007959", "time_retrieved": "2024-07-30T17:56:00.016226", "image_code": "// Fork of \"AI not included\" by mrange. https://shadertoy.com/view/ctd3Rl\n// 2023-05-13 19:41:49\n\n// CC0: AI not included\n// Tinkering around with old shaders.\n// No AI and very little human intelligence used ;)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.58;\nconst vec3 dbcol = HSV2RGB(vec3(hoff+0.96, 0.8, 0.75));\nconst vec3 sbcol = HSV2RGB(vec3(hoff+0.95, 0.4, 1.0));\nconst vec3 gbcol = HSV2RGB(vec3(hoff+0.98, 0.9, 0.001));\nconst vec3 fbcol = HSV2RGB(vec3(hoff+0.95, 0.7, 2.0));\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 0.51f;\n  float b = 2.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 1.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  p.x = pabs(p.x, 0.001);\n\n  if( p.y+p.x>1.0 )\n      return sqrt(dot2(p-vec2(0.05,0.36))) - sqrt(2.0)/5.0;\n  return sqrt(min(dot2(p-vec2(0.03,0.04)),\n                  dot2(p-0.2*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat df(vec2 p) {\n  vec2 hp = p;\n  const float hz = 1.40;\n  hp /= hz;\n  hp.y -= -1.2;\n  float d = heart(hp)*hz;\n  return d;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float h = (-20.0*d);\n  h = tanh_approx(h);\n  h -= 3.0*length(p);\n  h = pmin(h, 0.0, 1.);\n  h *= 1.25;\n  return h;\n}\n\nvec3 nf(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = hf(p + e.yx) - hf(p - e.yx);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  float f = (aggr * 0.5) + 0.5;\n  \n  return f;\n}\n\nfloat divf(float offset, float f) {\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  float r = abs(goff + offset - f);\n  r = max(r, gfloor);\n  return r;\n}\n\n// This way of computing \"lightning\" I found at shadertoy. Unfortunately I don't remember where.\nvec3 lightning(vec2 pos, vec2 pp, float offset) {\n  vec3 sub = 0.006*vec3(0.4, 0.01, 0.6).zyx*length(pp);\n\n  float time = TIME+13.4;\n  float stime = time/100.0;\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*cos(vec2(sqrt(0.5), 1.0)*stime)+vec2(0.0, -7.0)*stime;\n  const float glow = 0.0025;\n  const float goff = 0.9;\n  const float gfloor = 0.005;\n  for (float i = 0.0; i < 5.0; ++i) {\n    vec3 gcol0 = (1.0+cos(1.59*vec3(1.1, 0.0, 2.0) -time+3.0*pos.x+8.33*i));\n    vec3 gcol1 = (1.0+cos(1.75*vec3(0.0, 1.6, 0.50) -2.*time+pos.y+12.25*i));\n    float btime = stime*145.0 + (i);\n    float rtime = stime*104.0 + (i);\n    float div1 = divf(offset, fbm((pos + f) * 1.4, rtime));\n    float div2 = divf(offset, fbm((pos + f) * 2.0, btime));\n    float d1 = offset * glow / div1;\n    float d2 = offset * glow / div2;\n    col += (d1 * gcol0)-sub;\n    col += (d2 * gcol1)-sub;\n  }\n    \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 4.0/RESOLUTION.y;\n  float d = df(p);\n  float h = hf(p);\n  vec3 n = nf(p);\n  const vec3 lp = vec3(-9.0, -5.0, 5.0);\n  const vec3 ro = vec3(0.4, -5.0, 10.0);\n  vec3 p3 = vec3(p, h); \n  vec3 rd = normalize(p3-ro);\n  vec3 ld = normalize(lp-p3);\n  vec3 r = reflect(rd, n);\n  float diff = max(dot(ld, n), 0.0);\n  vec3 dcol = dbcol*mix(vec3(0.009), vec3(1.2), diff);\n  float spe = pow(max(dot(ld, r), -0.6), 5.0);\n  vec3 scol = spe*sbcol;\n  float gd = d-0.25;\n  vec2 gp = p;\n  vec3 gcol = lightning(gp, pp, gd);\n  vec3 hcol = dcol;\n  hcol += scol;\n  vec3 col = vec3(-0.05);\n  col += gbcol/max(0.01*(dot2(p)-0.15), 0.0001);\n  col += gcol;\n  col = mix(col, hcol, smoothstep(0.0, -aa, d));\n  col = mix(col, fbcol, smoothstep(0.0, -aa, abs(d+0.01)-0.01));\n  col *= smoothstep(1.75, 0.25, length(pp));\n\n  col = aces_approx(col); \n  col = sqrt(col); \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.3 + 2.5 * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp); \n  fragColor = vec4(col.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtK3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[501, 501, 523, 523, 669], [1213, 1341, 1369, 1435, 1511], [1513, 1620, 1646, 1646, 1831], [1833, 1933, 1972, 1972, 2057], [2059, 2147, 2177, 2177, 2205], [2207, 2207, 2227, 2227, 2249], [2251, 2369, 2390, 2390, 2608], [2610, 2610, 2628, 2628, 2736], [2738, 2738, 2756, 2756, 2893], [2895, 2895, 2912, 2912, 3102], [3104, 3104, 3123, 3123, 3246], [3248, 3248, 3269, 3269, 3696], [3698, 3698, 3729, 3729, 4090], [4092, 4092, 4127, 4127, 4255], [4257, 4354, 4403, 4403, 5238], [5240, 5240, 5270, 5270, 6137], [6139, 6139, 6194, 6194, 6373]]}
{"id": "DlXXR2", "name": "Barth Sextic Surfaces", "author": "mla", "description": "The Barth sextic, seen as a stereographic projection from the hypersphere S³. Animation is applying a Clifford translation (one sided quaternion multiplication) to S³.\n\n Various controls, see code header.", "tags": ["quaternion", "surface", "barth", "decic", "sextic"], "likes": 23, "viewed": 320, "published": 3, "date": "1683994859", "time_retrieved": "2024-07-30T17:56:01.097335", "image_code": "///////////////////////////////////////////////////////////\n//\n// Barth Sextic Surfaces.\n//\n// Barth discovered a 1-parameter family of sextic surfaces,\n// with 'the' Barth sextic corresponding to parameter k = 0.5\n// containing 65 nodes, the maximum possible for a surface of order 6.\n//\n// Here, the surface in ℙ³ is stereographically projected to ℝ³ via\n// the double cover of ℙ³ by S³. ie. point p = (x,y,z,w) on the\n// hypersphere corresponds to point in ℙ³ with homogeneous coordinates\n// (x,y,z,w) (which is also represented by -p on the hypersphere\n// so the surface is duplicated by the projection).\n//\n// <mouse>: rotate view of surface\n// <up>/<down>: zoom in/out\n// 'a': enable AA\n// 'c','t': align various surface features with rotation\n// 'k': animate surface parameter k\n// 'm': mirror effect (best with AA enabled)\n// 'q': toggle S³ quaternion rotation\n// 's': use projection (x,y,z,w) -> (x/w,y/w,z/w)\n//\n///////////////////////////////////////////////////////////\n\nbool doMirror = false;\nbool doGamma = true;\nbool doSpecular = true;\nbool doDiffuse = true;\n\nconst float ambient = 0.5;\nconst float diffuse = 0.5;\nfloat specpower = 4.0;\n\nconst vec3 defaultColor = vec3(0.7,1.0,1.0);\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;\nconst float phi = 1.618033;\nconst float phi2 = phi*phi;\nconst float phi4 = phi2*phi2;\n\nvec3 light;\n\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec4 transform4(vec3 p3) {\n  vec4 p = vec4(p3,0);\n  if (key(CHAR_S)) {\n    p.w = 1.0;\n  } else {\n    // Invert at south pole of S3 - equivalent to a stereographic projection.\n    p.w += 1.0;\n    p *= 2.0/dot(p,p);\n    p.w -= 1.0;\n  }\n  if (key(CHAR_Q)) return p;\n  float k = 0.0;\n  k = 0.1*PI*iTime;\n  vec3 axis = vec3(0,0,-1);\n  // axis = normalize(axis);\n  p = qmul(p,vec4(sin(k)*axis,cos(k)));\n  if (!key(CHAR_C)) p.xz = rotate(p.xz,0.55); // Pentagon centred\n  if (key(CHAR_T)) p.yz = rotate(p.yz,0.36);   // Triangle centred\n  return p;\n}\n\nfloat Barth0(vec4 p, float K) {\n  float x = p.x; float y = p.y;\n  float z = p.z; float w = p.w;\n  float x2 = x*x; float y2 = y*y;\n  float z2 = z*z; float w2 = w*w;\n  float A = 4.0*(phi2*x2-y2)*(phi2*y2-z2)*(phi2*z2-x2);\n  float B = x2 + y2 + z2 - w2;\n  return (1.0-K)*(1.0+2.0*phi)*w2*B*B - K*A;\n}\n\nfloat Barth(vec4 p, float K) {\n  // Slightly more compact version.\n  vec4 p2 = p*p;\n  vec3 t = phi2*p2.xyz-p2.yzx;\n  float A = 4.0*t.x*t.y*t.z;\n  float B = dot(p2.xyz,vec3(1))-p2.w;\n  return (1.0-K)*(1.0+2.0*phi)*p2.w*B*B - K*A;\n}\n\n// Barth Decic\nfloat Barth10(vec4 p){//decic\n  float r2 = dot(p.xyz,p.xyz);\n  vec4 p2 = p*p;\n  float r4 = dot(p2.xyz,p2.xyz);\n  vec4 p4 = p2*p2;\n  // 8.0*(p2.xyz-phi4*p2.yzx)*(r4-2.0*dot2(p.xyz*p.yzx))+(3.0+5.0*phi)*...\n  return (8.0*(p2.x-phi4*p2.y)*(p2.y-phi4*p2.z)*(p2.z-phi4*p2.x)*\n          (r4-2.0*((p.x*p.y)*(p.x*p.y)+(p.x*p.z)*(p.x*p.z)+(p.y*p.z)*(p.y*p.z)))\n         +(3.0+5.0*phi)*(r2-p2.w)*(r2-p2.w)*(r2-(2.0-phi)*p2.w)*(r2-(2.0-phi)*p2.w)*p2.w);\n}\n\nfloat Fun(vec3 p3) {\n  vec4 p = transform4(p3);\n  //return Barth10(p);\n  float K = 0.5;\n  if (key(CHAR_K)) K = sin(-0.1*PI*iTime)+0.01; // K is mixing parameter\n  return Barth(p,K);\n}\n\nvec3 getColor(vec3 r, vec3 n) {\n  if (!doMirror) {\n    //return defaultColor;\n    return smoothstep(0.0,1.0,abs(n));\n  } else {\n    vec3 color = textureLod(iChannel0,n,1.0).rgb;\n    color = pow(color,vec3(2.2));\n    return color;\n  }\n}\n\n// Solution parameters.\nconst int iterations = 200;    // Maximum number of iterations\nconst float maxincrease = 1.03; // Largest allowed step increase.\nconst float maxstep = 2.0;     // The largest step that can be taken.\nconst float minstep = 0.001;  // The smallest step\nconst float initstep = 0.1;\nconst float maxdist = 20.0;\n\nvec3 solve(vec3 p0, vec3 r) {\n  bool bracketed = false;\n  bool found = false;\n  float step = initstep;\n  vec3 color = vec3(0);//texture(iChannel0,r,0.0).rgb;\n  color = pow(color,vec3(2.2));\n  vec3 p = p0;\n  float t0 = 0.0, t1;\n  float f0 = Fun(p), f1;\n  // The idea here is to step forward carefully until a change of\n  // sign, then use bisection to home in on (hopefully) closest root.\n  for (int i = 0; i < iterations; i++) {\n    //assert(i < 50);\n    t1 = t0 + step;\n    if (t1 > maxdist) return color;\n    p = p0 + t1*r;\n    f1 = Fun(p);\n    if (f0*f1 <= 0.0) {\n      // We can hit exactly 0 - this counts as bracketed.\n      bracketed = true;\n      break;\n    } else {\n      float step0 = step;\n      step = f1*step/(f0-f1);\n      if (!key(CHAR_R) && step < 0.0) step = 1.0; // Don't step backwards - check this!\n      step = abs(step);\n      step = min(step,t1*maxstep);\n      // Don't grow step by more than a certain amount\n      step = max(step,minstep);\n      step = min(step,maxincrease*step0);\n      t0 = t1; f0 = f1;\n    }\n  }\n  if (!bracketed) return color;\n  for (int i = 0; i < 10; i++) {\n    //assert(i < 5);\n    // Once we are bracketed, just use bisection\n    // We could use eg. the secant method, but this is fine and\n    // is reasonably quick (since the stepping procedure tends\n    // to produce fairly small intervals).\n    if ((t1-t0)/t0 < minstep) break;\n    float t2 = (t0 + t1)/2.0;\n    p = p0+t2*r;\n    float f2 = Fun(p);\n    if (f0*f2 <= 0.0) {\n      t1 = t2; f1 = f2;\n    } else {\n      t0 = t2; f0 = f2;\n    }\n  }\n\n  // Compute gradient & normal\n  float eps = 1e-3;\n  vec2 delta = max(t0,1.0)*vec2(eps,0.0);\n  p = p0 + t0*r; // Ensure p corresponds to t0 and a0\n#if 1\n  vec3 n = vec3(Fun(p + delta.xyy), Fun(p + delta.yxy), Fun(p + delta.yyx)) - f0;\n#else\n  // Not sure how much difference this makes, not a lot, I suspect.\n  vec3 n = vec3(Fun(p + delta.xyy) - Fun(p - delta.xyy),\n                Fun(p + delta.yxy) - Fun(p - delta.yxy),\n                Fun(p + delta.yyx) - Fun(p - delta.yyx));\n#endif\n  vec4 p4 = transform4(p);\n  float grad = abs(length(n));\n  n = normalize(n);\n\n  // Point normal towards eye\n  //assert(dot(r,n) < 0.0);\n  if (dot(r,n) > 0.0) n *= -1.0;\n  vec3 baseColor = getColor(r,n);\n  color = baseColor;\n  if (!doMirror) {\n    color *= ambient;\n    float k = dot(light,n);\n    if (doDiffuse && k > 0.0) {\n      color += baseColor*diffuse*k;\n    }\n    if (doSpecular && k > 0.0) {\n      float specular = pow(max(0.0,dot(reflect(light,n),r)),specpower);\n      color += 0.8*specular*vec3(1);\n    }\n  }\n  return color;\n}\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  //p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  doMirror = key(CHAR_M);\n  light = vec3(0.5,1,1);\n  // Projection parameters\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0,0,camera);\n  p = transform(p);\n  light = transform(light); // Light moves with camera\n  light = normalize(light);\n  vec3 color = vec3(0);\n  int AA = key(CHAR_A) ? 2 : 1;\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 inc = vec2(i,j)/float(AA);\n      vec2 uv = (2.0*(fragCoord+inc) - iResolution.xy)/iResolution.y;\n      vec3 r = normalize(vec3(uv,-2));\n      r = transform(r);\n      r = normalize(r);\n      color += solve(p,r);\n    }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n//#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n//#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n//#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n//#define keycount(code) (int(store((code),0).x))\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_I = 73;\nconst int CHAR_K = 75;\nconst int CHAR_M = 77;\n\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state  \n  }\n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXXR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1372, 1372, 1399, 1399, 1486], [1488, 1488, 1518, 1518, 1563], [1565, 1565, 1591, 1591, 2108], [2110, 2110, 2141, 2141, 2407], [2409, 2409, 2439, 2475, 2639], [2641, 2656, 2678, 2685, 3100], [3102, 3102, 3122, 3122, 3285], [3287, 3287, 3318, 3318, 3522], [3855, 3855, 3884, 3884, 6429], [6431, 6431, 6455, 6455, 6723], [6725, 6725, 6777, 6777, 7549]]}
{"id": "mty3WD", "name": "Raymarched golden temple - fancy", "author": "ativata", "description": "A very cool project\nVery Gorgeous", "tags": ["raymarching", "template", "artofcode"], "likes": 0, "viewed": 103, "published": 3, "date": "1683994269", "time_retrieved": "2024-07-30T17:56:01.949058", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n#define sSAUCE -3.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat sdSphere(vec3 p, vec4 s) {\n\treturn length(p-s.xyz)-s.w;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat GetDist(vec3 p) {\n    \n    float d2 = sdBox(p,vec3(.55,2,.098));\n    float d8 = sdRoundBox(p-vec3(0,2.8,0), vec3(.1,.5,.1),0.1);\n    float d14 = sdBox(p-vec3(0,2.2,0), vec3(1,.2,.2));\n    \n    float d10 = sdSphere(p-vec3(0,-0.6,0), vec4(0,0,0,1.67));\n    \n    float d11 = sdSphere(p-vec3(-1.5,-1.,0), vec4(0,0,0,1));\n    float d16 = sdSphere(p-vec3(1.5,-1.,0), vec4(0,0,0,1));\n    \n    float d18 = sdSphere(p-vec3(-.5,-1.2,-1.3), vec4(0,0,0,.8));\n    float d19 = sdSphere(p-vec3(1.5,-1.,1), vec4(0,0,0,1));\n    \n    float d12 = sdSphere(p-vec3(-1,-0.7,1), vec4(0,0,0,1.4));\n    float d17 = sdSphere(p-vec3(1,-0.7,-1), vec4(0,0,0,1.4));\n    \n    float d15 = unionSDF(unionSDF(d10,unionSDF(unionSDF(d11,unionSDF(d18,d19)),unionSDF(d11,d17))),unionSDF(d12,d16));\n    \n    float d6 = unionSDF(d15,unionSDF(d2,unionSDF(d8,d14)));\n    float d7 = sdBoxFrame(p,vec3(4.3,2.3,4.3),.2);\n    float d13 = unionSDF(unionSDF(unionSDF(\n    sdRoundBox(p -vec3(0,-2.1,0),vec3(4.4,.21,4.4),0.1)\n    ,sdRoundBox(p -vec3(0,-2.6,0),vec3(4.5,.21,4.5),0.1))\n    ,sdRoundBox(p -vec3(0,-3.1,0),vec3(4.6,.21,4.6),0.1))\n    ,sdRoundBox(p -vec3(0,-3.6,0),vec3(4.7,.21,4.7),0.1));\n    \n    \n    float torus1 = sdTorus(p-vec3(0,4,0),vec2(3.3,.2));\n    float torus2 = sdTorus(p-vec3(0,5,0),vec2(3,.2));\n    float torus3 = sdTorus(p-vec3(0,6,0),vec2(2.6,.2));\n    float torus4 = sdTorus(p-vec3(0,7,0),vec2(2,.2));\n    \n    \n    return unionSDF(unionSDF(unionSDF(d6, d7),d13),unionSDF(unionSDF(torus1,torus4),unionSDF(torus2,torus3)));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i+=7) {\n        //maybe this helps cuz I heard that GPUs are shit at branching\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        \n        p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        \n        p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        \n        p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        \n                p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        \n        p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        \n        p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nfloat luminance(vec3 v)\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\nvec3 change_luminance(vec3 c_in, float l_out)\n{\n    float l_in = luminance(c_in);\n    return c_in * (l_out / l_in);\n}\n\nvec3 reinhard_extended(vec3 v, float max_white_l)\n{\n    float l_old = luminance(v);\n    float numerator = l_old * (1.0f + (l_old / (max_white_l * max_white_l)));\n    float l_new = numerator / (1.0f + l_old);\n    return change_luminance(v, l_new);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 10, -10);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,1.,0), 1.);\n    vec3 col = texture(iChannel0,rd).rgb*vec3(1.,.8,.7);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float dif = dot(n, vec3(1.5,1.7,.3)) + 1.5;\n        col = vec3(dif) * texture(iChannel0,r).rgb*vec3(1.40,.7,0.06);\n    }\n    \n    col = pow(reinhard_extended(col,.81), vec3(.7));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mty3WD.jpg", "access": "api", "license": "mit", "functions": [[1535, 1535, 1554, 1554, 1616], [1618, 1618, 1664, 1664, 1696], [1698, 1698, 1740, 1740, 1772], [1774, 1774, 1821, 1821, 1854], [1857, 1857, 1886, 1886, 1967], [1968, 1968, 2000, 2000, 2031], [2033, 2033, 2078, 2078, 2169], [2170, 2170, 2215, 2215, 2502], [2503, 2503, 2536, 2536, 2601], [2603, 2603, 2626, 2626, 4112], [4114, 4114, 4148, 4148, 5207], [5209, 5209, 5233, 5233, 5388], [5390, 5390, 5440, 5440, 5625], [5627, 5627, 5652, 5652, 5706], [5708, 5708, 5755, 5755, 5825], [5827, 5827, 5878, 5878, 6075], [6076, 6076, 6133, 6133, 6838]]}
{"id": "mtG3DD", "name": "Visor", "author": "dikadk", "description": "Binocular visor with blue tv like (Star Wars inspired)", "tags": ["noise", "tv", "starwars", "visor"], "likes": 1, "viewed": 165, "published": 3, "date": "1683994005", "time_retrieved": "2024-07-30T17:56:02.745927", "image_code": "#define M_PI (3.1415926535897932384626433832795)\n\nfloat qScanLine (vec2 uv, float n, float rotation) {\n\tuv -= 0.5; // move origin to center\n    float theta = radians(rotation); // convert to degrees\n\n    // Apply rotation\n    float x = uv.x * cos(theta) - uv.y * sin(theta);\n    float y = uv.x * sin(theta) + uv.y * cos(theta);\n\n    uv = vec2(x, y);\n    uv += 0.5; // move origin back to corner\n\n    return abs(sin(uv.y * M_PI * n));\n}\n\nfloat qVignete (vec2 uv,float q, float o) {\n\tfloat x = clamp (1.0 - distance (uv, vec2 (0.5,0.5))*q, 0.0, 1.0);\n\treturn (log((o - 1.0/exp (o))*x + 1.0/exp (o)) + o)/(log(o) + o);\n}\n\n\nvec2 vCrtCurvature (vec2 uv, float q) {\n\tfloat x = 1.0- distance (uv, vec2 (0.5, 0.5));\n\tvec2 g = vec2 (0.5, 0.5) - uv;\n\treturn uv + g*x*q;\n}\n\nvec4 v2DNoiseSample (vec2 gPos) {\n\tvec2 nPos = vec2(\n\t\tmod (gPos.x+iTime*9.66,1.0),\n\t\tmod (gPos.y+iTime*7.77,1.0)\n\t);\t\t\n\treturn texture (iChannel1, nPos);\n}\n\nvec4 v1DNoiseSample (float idx, float s) {\t\n\treturn texture (iChannel1, vec2 (\n\t\tmod (idx, 1.0), \n\t\tmod (iTime*s, 1.0))\n\t);\n}\n\nfloat q2DNoiseSample (vec2 gPos) {\n \tvec4 nPnt = v2DNoiseSample (gPos);\n\treturn nPnt.x;\n}\n\nfloat q1DNoiseSample (float idx, float s){\n\tvec4 nPnt = v1DNoiseSample (idx, s);\n\treturn nPnt.x;\n}\n\nvec4 cSignalNoise (vec4 c,float q, vec2 gPos) {\n\treturn c*(1.0 - q) + q*q2DNoiseSample(gPos);\n}\n\nvec2 vScanShift (vec2 uv, float q, float dy, float dt) {\n\treturn vec2 (uv.x + q1DNoiseSample (uv.y*dy, dt)*q, uv.y);\n}\n\nvec2 vFrameShift (vec2 uv, float q, float dt) {\n\tfloat s = (q1DNoiseSample (0.5, dt) - 0.5)/500.0;\n\treturn vec2 (uv.x, mod (uv.y + iTime*(q+s), 1.0));\t\n}\n\nvec2 vDirShift (vec2 uv, float angle, float q) {\n\tfloat a =(angle/180.0)*M_PI;\n\tvec2 dir = vec2 (sin (a), cos (a));\n\treturn uv + dir*q;\n}\n\nvec4 vRGBWithShift (vec2 uv, float angle, float q) {\n\tvec2 rPos = vDirShift (uv, angle, q);\n\tvec2 gPos = uv;\n\tvec2 bPos = vDirShift (uv, -angle, q);\n\tvec4 rPix = texture (iChannel0, rPos);\n\tvec4 gPix = texture (iChannel0, gPos);\n\tvec4 bPix = texture (iChannel0, bPos);\n\treturn vec4 (rPix.x, gPix.y, bPix.z, 1.0);\n}\n\nvec4 vPowerNoise (vec4 col, vec2 uv, float b, float dt, float w) {\n\tfloat s = q1DNoiseSample (0.0, 0.001)/500.0;\n\tfloat y = mod (iTime * (dt + s) , 1.0);\n\tfloat d = 1.0 - clamp (abs (uv.y - y), 0.0, w)/w;\n\treturn pow (col,vec4(1.0/(1.0 + b*d)) ) ;\n}\n\nvec4 qGamma (vec4 i, vec4 g){\n\treturn pow(i, 1.0/g);\n}\n\nvec4 vRGBTint (vec4 col, vec3 g, float q) {\t\n\treturn qGamma (col, vec4 (g, 1.0))*q + (1.0 - q)*col;\t\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 vColorDrift (vec4 col, float q) {\n\tvec3 hsv = rgb2hsv (col.xyz);\n\thsv.y = mod (hsv.y * q, 1.0);\n\treturn vec4 (hsv2rgb (hsv), col.w);\n}\n\nvec4 vColorFilter(vec4 color, vec3 cFilter) {\n    vec3 adjustedColor = color.rgb * cFilter;\n    return vec4(adjustedColor, color.a);\n}\n\nvec4 vApplyMask(vec4 baseColor, vec2 uv) {\n    // Sample mask color from iChannel2\n    vec4 maskColor = texture(iChannel2, uv);\n\n    // Multiply baseColor by the red channel of the mask color\n    // Assuming mask is a grayscale image, so red, green, and blue channels are equal\n    return baseColor * maskColor.r;\n}\n\nvec4 applyTint(vec4 baseColor, vec4 tintColor, float tintStrength) {\n    return mix(baseColor, tintColor, tintStrength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 cRes = iChannelResolution [0].xy;\n\tvec2 gRes = iResolution.xy;\n\tvec2 gPos = fragCoord.xy / gRes;\t\n\tvec2 cPos = gPos ;\n\tvec4 cCol = vec4(1.0);\n\tvec2 bPos = vec2(1.0);\n\tfloat qNoise = q1DNoiseSample(0.01,0.01);\n\t\n\t//cPos = vScanShift (cPos, 0.02, 0.1, 0.1);\t\t\t// snaline shift\n\t//cPos = vCrtCurvature (cPos, 0.3);\t\t\t\t\t// crt curving of coords\n\t//bPos = vCrtCurvature (gPos, 0.3);\t\t\t\t\t// curvature for the noize bar\n\t//cPos = vFrameShift (cPos, 0.01, 0.001);\t\t\t\t// frame shift\t\t\n\t//cCol = vColorDrift (cCol, 1.0 - qNoise);\t\n\tcCol = vRGBWithShift (cPos, 100.0, 0.00); \t\t\t// sample signal color\t\n\t//cCol = cSignalNoise (cCol, qNoise * 0.8, gPos);\t\t\t\t// add signal noise\n\t//cCol = vPowerNoise (cCol, bPos, 4.0, -0.2, 0.1); \t// power line noize\n\t//cCol = vRGBTint (cCol, vec3 (0.5, 0.5, 1.0), 1.0);\t// gamma tint\n\tcCol = cCol * qScanLine (gPos, 150.0, 0.0); \t\t\t\t// add scanlines\n\t//cCol = cCol * qVignete (gPos, 1.5, 3.0); \t\t\t// add edge darkening\n    cCol = vColorFilter(cCol, vec3 (0.5, 0.5, 1.0));\n    \n    cCol = applyTint(cCol, vec4(0.0, 0.0, 1.0, 1.0), 0.4);\n    cCol = vApplyMask(cCol, gPos); //apply mask\n\tfragColor = cCol;\n\t\t\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtG3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 102, 102, 435], [437, 437, 480, 480, 617], [620, 620, 659, 659, 761], [763, 763, 796, 796, 919], [921, 921, 963, 963, 1046], [1048, 1048, 1082, 1082, 1137], [1139, 1139, 1181, 1181, 1237], [1239, 1239, 1286, 1286, 1334], [1336, 1336, 1392, 1392, 1454], [1456, 1456, 1503, 1503, 1609], [1611, 1611, 1659, 1659, 1748], [1750, 1750, 1802, 1802, 2064], [2066, 2066, 2132, 2132, 2315], [2317, 2317, 2346, 2346, 2371], [2373, 2373, 2416, 2416, 2475], [2477, 2477, 2499, 2499, 2830], [2832, 2832, 2854, 2854, 3023], [3025, 3025, 3063, 3063, 3164], [3166, 3166, 3211, 3211, 3300], [3302, 3302, 3344, 3384, 3617], [3619, 3619, 3687, 3687, 3741], [3743, 3743, 3800, 3800, 4936]]}
{"id": "clt3Rf", "name": "Stable fluid for water", "author": "ddinhddoong", "description": "test", "tags": ["2d", "fluid", "navier", "stokes"], "likes": 8, "viewed": 272, "published": 3, "date": "1683983499", "time_retrieved": "2024-07-30T17:56:03.619591", "image_code": "void scale(inout vec2 p, float ratio, vec2 origin)\n{\n    p-= origin;\n    p/= ratio;\n    p+= origin;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    if(KEY_S > 0.) scale(fragCoord, iResolution.y*0.005, iMouse.xy);\n    \n    vec4 o = T(fragCoord);\n    //fragColor = vec4(abs(c.xy)*1.0f, abs(c.z)*100.0f, c.w);\n    \n    vec4 color = vec4(.2, .8, 1, 1)*.5;\n    fragColor = color*o.w;\n    fragColor += length(o.xy)*0.05;\n    fragColor -= o.z*0.005;\n    \n    if(isObstacle(fragCoord, iResolution.xy)) fragColor = mix(vec4(.3,.2,.1,1.), fragColor, 0.25);;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// advection & boundary & control\nint id(int i, int j){\n    return (i+1) + 3*(j+1);\n}\n\n// Runge-Kutta 4 backward advection\nvec2 RK4(vec2 p){\n    vec2 k1 = T(p).xy;\n    vec2 k2 = T(p - 0.5 * k1).xy;\n    vec2 k3 = T(p - 0.5 * k2).xy;\n    vec2 k4 = T(p - k3).xy;\n    return (0.5 * k1 + k2 + k3 + 0.5 * k4) / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 n = T(fragCoord + vec2(0, 1));\n    vec4 e = T(fragCoord + vec2(1, 0));\n    vec4 s = T(fragCoord + vec2(0, -1));\n    vec4 w = T(fragCoord + vec2(-1, 0));\n    \n    // advection\n    fragColor = T(fragCoord);\n    //vec2 prePos = fragCoord - fragColor.xy * dt;\n    vec2 prePos = fragCoord - RK4(fragCoord) * dt;\n    //fragColor.xyw = bilerp(iChannel0, prePos, iResolution.xy).xyw;\n    fragColor.xyw = T(prePos).xyw;\n    \n    //vorticity\n    /*\n    float vor[9];\n    for(int i = -1; i < 2; i++)\n    for(int j = -1; j < 2; j++)\n    if(i*j == 0){\n        vec2 cc = fragCoord + vec2(i, j);\n        float   nn = T(cc + vec2(0, 1)).x,\n                ee = T(cc + vec2(1, 0)).y,\n                ss = T(cc + vec2(0, -1)).x,\n                ww = T(cc + vec2(-1, 0)).y;\n        vor[id(i, j)] = (ee - ww - nn + ss)*0.5;\n    }\n    \n    vec2 force = vec2(0.5);\n    force.x *= abs(vor[id(0, 1)]) - abs(vor[id(0, -1)]);\n    force.y *= abs(vor[id(1, 0)]) - abs(vor[id(-1, 0)]);\n    force = normalize(force + 0.0001) * vor[id(0, 0)] * curl;\n    force.y *= -1.;\n     \n    fragColor.xy += force*dt;\n    //*/\n    \n     //gravity\n    vec2 dir = (KEY_G > 0.)? vec2(0, -1) : normalize(iResolution.xy/2. - fragCoord);\n    fragColor.xy += dir * g * fragColor.w;\n    \n    //water's behavior\n    fragColor.w = smoothstep(0.0, 1.0, fragColor.w);\n    fragColor.z *= fragColor.w;\n    //*/\n    // interaction\n    if(length(iMouse.xy - fragCoord.xy) < 30. && iMouse.z > 1.)\n    {\n        fragColor.w = 1.0;\n    }\n    //*\n    if(length(fragCoord - iResolution.xy/1.2)<20. && iTime < 10.) {\n        fragColor.x = -3. + sin(iTime*1.)/10.;\n        fragColor.w = 1.;\n    }\n    if(length(fragCoord - vec2(iResolution.x*0.2, iResolution.y/1.2))<20. && iTime < 10.) {\n        fragColor.x = 3. + sin(iTime*1.)/20.;\n        fragColor.w = 1.;\n    }//*/\n    /*\n    if(iFrame < 1  && fragCoord.x < iResolution.x/2. && fragCoord.y < iResolution.y/1.2){\n        fragColor.w = 1.;\n    }\n    //*/\n\n    if(isObstacle(fragCoord, iResolution.xy)){\n        fragColor.xy *= 0.;\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texture(iChannel0, (U)/iResolution.xy)\n#define KEY_G round(texelFetch(iChannel3, ivec2(71,2) , 0 ).x)\n#define KEY_S round(texelFetch(iChannel3, ivec2(83,0) , 0 ).x)\n\nconst float dt = 1.0;\nconst float dx = 1.0;\nconst float halfrdx = 0.5 / dx;\nconst float ov = 1.9;\nconst float g = 0.1;\nconst float curl = 0.1;\n\nfloat jacobi(float e, float w, float n, float s, float alpha, float bC, float rBeta){\n    return (e + w + n + s + alpha * bC) * rBeta;\n}\n\nvec4 bilerp(sampler2D tex, vec2 pos, vec2 size){\n    vec2 i = floor(pos);\n    vec2 j = fract(pos);\n    vec4 x1 = texture(tex, (i)/size),\n         x2 = texture(tex, (i + vec2(1,0))/size),\n         y1 = texture(tex, (i + vec2(0,1))/size),\n         y2 = texture(tex, (i + vec2(1,1))/size);\n         \n    vec4 z1 = mix(x1, x2, j.x);\n    vec4 z2 = mix(y1, y2, j.x);\n    return mix(z1, z2, j.y); \n}\n\nbool isObstacle(vec2 fragCoord, vec2 size){\n    //land\n    float ratio = size.y/100.;\n    float nScale = 3. * ratio;\n    float noise = 10. *ratio *(cos(fragCoord.x/nScale) * sin(fragCoord.y/nScale));\n    bool land = length(fragCoord - size/2.) + noise < size.y/4.;\n    //wall\n    bool wall = fragCoord.x < 1. || fragCoord.y < 1. || fragCoord.x > size.x-1. || fragCoord.y > size.y-1.;\n    \n    return  wall || land;\n}", "buffer_b_code": "// pressure poisson\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 n = T(fragCoord + vec2(0, 1));\n    vec4 e = T(fragCoord + vec2(1, 0));\n    vec4 s = T(fragCoord + vec2(0, -1));\n    vec4 w = T(fragCoord + vec2(-1, 0));\n    fragColor = T(fragCoord);\n    \n    // divergence of the velocity\n    float div = (e.x - w.x + n.y - s.y) * halfrdx * ov;\n    \n    //jacobi(float e, float w, float n, float s, float alpha, float bC, float rBeta)\n    fragColor.z = jacobi(e.z, w.z, n.z, s.z, -dx*dx, div, 0.25);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// pressure poisson\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 n = T(fragCoord + vec2(0, 1));\n    vec4 e = T(fragCoord + vec2(1, 0));\n    vec4 s = T(fragCoord + vec2(0, -1));\n    vec4 w = T(fragCoord + vec2(-1, 0));\n    fragColor = T(fragCoord);\n    \n    // divergence of the velocity\n    float div = (e.x - w.x + n.y - s.y) * halfrdx * ov;\n    \n    //jacobi(float e, float w, float n, float s, float alpha, float bC, float rBeta)\n    fragColor.z = jacobi(e.z, w.z, n.z, s.z, -dx*dx, div, 0.25);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// projection\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 n = T(fragCoord + vec2(0, 1));\n    vec4 e = T(fragCoord + vec2(1, 0));\n    vec4 s = T(fragCoord + vec2(0, -1));\n    vec4 w = T(fragCoord + vec2(-1, 0));\n    fragColor = T(fragCoord);\n    \n    // gradient of the pressure\n    vec2 grad = vec2( e.z - w.z, n.z - s.z ) * halfrdx;\n\n    // project\n    fragColor.xy -= grad;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clt3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 101], [104, 104, 161, 161, 601]]}
{"id": "ctyGWD", "name": "solenoid", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/Yugemaku/status/1657059689375608833", "tags": ["spiral", "ring", "reproduction"], "likes": 44, "viewed": 385, "published": 3, "date": "1683967004", "time_retrieved": "2024-07-30T17:56:04.395517", "image_code": "\n#define rot2(a)      mat2(cos(a+vec4(0,11,33,0)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),        // ray direction\n          p = vec3(0,0,15), q, a,                        // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.        // camera control\n              :  vec3( 1,-.5,0);\n    \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )       // march scene\n        q = p, \n        q.yz *= rot2(-M.y),                              // rotations\n        q.xz *= rot2(-M.x-1.57),\n        q = vec3( length(q.xz)-1., q.y, atan(q.z,q.x) ), // cylindrical coordinates\n        q = vec3( length(q.xy), atan(q.y,q.x), q.z ),    // torus coordinates\n        a = cos(q.z -iTime + vec3(0,11,0)), q.z += .5*iTime, // time modulators: radius, angle\n        q.x -= .2*(.5+.5*a.x), q.z += .5*a.y,            // time modulation\n        t = min(t, length( vec2(q.x, ( mod(16.*q.z-q.y,6.28)-3.14 ) /16. ) // solenoïd\n                         ) - .05 ),\n     // t = length(q.xy + .2 * (.5+.5*a.x)* cos(16.*q.z+8.*a.y+vec2(0,11)) ) -.05,\n        p += .5*t*D;                                     // step forward = dist to obj    \n    \n   O *= O*O*O*1.6;                                       // color scheme \n// q.x = atan(q.y,q.x)/6.; q = sin(32.*q); t = q.x*q.z; O *= clamp(.5+t/fwidth(t),0.,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 88, 88, 1399]]}
{"id": "ctG3DW", "name": "jeweled vortex test", "author": "afterlifevj", "description": "just learning how this works, thanks/credit to the creator: Chunderfpv", "tags": ["vortex"], "likes": 5, "viewed": 217, "published": 3, "date": "1683959249", "time_retrieved": "2024-07-30T17:56:05.158477", "image_code": "#define M iMouse\n#define R iResolution.xy\n#define PI 3.14159265358979\n#define TAU 6.283185307179586\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec3 c = vec3(0);\n    vec2 m = (M.xy-.5*R)/R.y*2.; // mouse coords\n    float t = (M.z > 0.) ? atan(m.x, -m.y): -.54+(iTime*TAU)/3600., // arc from time or mouse\n          n = (cos(t) > 0.) ? sin(t): 1./sin(t), // t to sin/csc\n          e = n*2.,                              // exponent\n          z = clamp(pow(500., n), 1e-16, 1e+18); // zoom\n    vec2 uv = (XY-.5*R)/R.y*2., // screen coords\n          u = uv*z;             // coords with zoom\n    float ro = -PI/2.,               // rotation\n          cr = iTime*TAU/5.,         // counter rotation\n          a = atan(u.y, u.x)-ro,     // screen arc\n          i = a/TAU,                 // arc to range between +/-0.5\n          r = exp(log(length(u))/e), // radius | slightly faster than pow(length(u), 1./e)\n          sc = ceil(r-i),            // spiral contour\n          s = pow(sc+i, 2.),         // spiral gradient\n          vd = cos((sc*TAU+a)/n),    // visual denominator\n          ts = cr+s/n*TAU;           // segment with time\n    c += sin(ts/2.); // spiral 1\n    c *= cos(ts);    // spiral 2\n    c *= pow(abs(sin((r-i)*PI)), abs(n*2.)+5.); // smooth edges & thin near inf\n    c *= .2+abs(vd);                            // dark folds\n    c = min(c, pow(length(u)/z, -1./n));        // dark gradient\n    vec3 rgb = vec3(vd+1., abs(sin(t)), 1.-vd); // color\n    c += (c*2.)-(rgb*.5);                       // add color\n    if (M.z > 0.) c = max(c, digit(iChannel0, uv-m, n, .2, 4., 4.)); // digits\n    RGBA = vec4(c, 1.);\n}\n\n/* golf 489 char\nvoid mainImage( out vec4 c, vec2 X )\n{\n    vec2 R = iResolution.xy, u,\n         m = (2.*iMouse.xy-R)/R.y;\n    float T = 6.283,\n          t = (iMouse.z > 0.) ? \n              atan(m.x, -m.y): \n              -.54+iTime*T/3600.,\n          n = (cos(t) > 0.) ? sin(t): 1./sin(t),\n          z = clamp(pow(5e2, n), 1e-16, 1e+18);\n    u = (2.*X-R)/R.y*z;\n    float a = T/4.+atan(u.y, u.x),\n          i = a/T,\n          l = length(u),\n          r = exp(log(l)/n/2.),\n          h = ceil(r-i),\n          v = cos((h*T+a)/n),\n          k = iTime*T/5.+pow(h+i, 2.)/n*T;\n    c *= 0.;\n    c += sin(k/2.)*cos(k) *\n             pow(abs(sin((r-i)*T/2.)), abs(n*2.)+5.) *\n             (.2+abs(v));\n    c = min(c, pow(l/z, -1./n));\n    c += c+c-.5*vec4(v+1., abs(sin(t)), 1.-v, 0);\n}\n*/", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// font code from https://www.shadertoy.com/view/7tV3zK\nvec4 char(sampler2D ic, vec2 p, int c)\n{\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad(ic, p/16. + fract( vec2(c, 15-c/16)/16.), dFdx, dFdy );\n}\nvec4 pInt(sampler2D ic, vec2 p, float n, float d)\n{\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(ic, p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = d; i>0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(ic, p - .5*vec2(i-1.,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// texture, screen coords, value, size, num left digits, num right digits\nvec3 digit(sampler2D ic, vec2 uv, float v, float s, float l, float r)\n{\n    float numleft = min(log2(abs(v))/log2(10.), l-1.);\n    l = max(floor(numleft), 0.)+1.;\n    uv /= s; // size\n    if (isinf(abs(v))) return vec3(char(ic, uv*.7+vec2(.5, .3), 153).x); // infinity symbol\n    uv += vec2((l+1.)/2., .28); // center on decimal\n    vec3 d = vec3(0);\n    d += pInt(ic, uv, v, l).x; // left of decimal\n    uv.x -= l/2.;\n    d += char(ic, uv, 46).x; // decimal point\n    uv.x -= .5;\n    d += pInt(ic, uv, floor(abs(v)*pow(10., r)), r).x; // right of decimal\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctG3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 145, 145, 1634]]}
{"id": "dly3zm", "name": "RayTracing(Wbox1)", "author": "wbox", "description": "my first try of making ray tracing shaders", "tags": ["myraytracingfirsttry"], "likes": 1, "viewed": 185, "published": 3, "date": "1683957932", "time_retrieved": "2024-07-30T17:56:06.134866", "image_code": "const float MaxDistance = 99999.0;\nconst int MaxReflections = 4;\nconst float lightStrenth = 1.0;\nconst int samples = 4;\nconst float blur = 0.9995;\n\nfloat seed;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Box\n{\n    vec3 position;\n    float size;\n    vec4 color;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec4 color;\n};\n\nstruct Plane\n{\n    float position;\n    vec3 normal;\n    vec4 color;\n};\n\nstruct LightSource\n{\n    vec3 position;\n    float radius;\n};\n\nint LCGStep(int z, int A, int C)\n{\n\treturn (A * z + C);\t\n}\n\nfloat random(vec2 co){\n    return fract(sin(dot(co * seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 randomOnSphere(Ray ray) {\n\tvec3 rand = vec3(\n    random(ray.direction.xy),\n    random(ray.direction.yz),\n    random(ray.direction.zx));\n\tfloat theta = rand.x * 2.0 * 3.14159265;\n\tfloat v = rand.y;\n\tfloat phi = acos(2.0 * v - 1.0);\n\tfloat r = pow(rand.z, 1.0 / 3.0);\n\tfloat x = r * sin(phi) * cos(theta);\n\tfloat y = r * sin(phi) * sin(theta);\n\tfloat z = r * cos(phi);\n\treturn vec3(x, y, z);\n}\n\nvec3 light = normalize(vec3(0.0, -1.0, 1.0));\n\nvec3 getSky(vec3 rd) {\n\tvec3 col = vec3(0.3, 0.6, 1.0);\n\tvec3 sun = vec3(0.95, 0.9, 1.0);\n\tsun *= max(0.0, pow(dot(rd, light), 256.0));\n\t//col *= max(0.0, pow(dot(rd, light), 256.0));\n    col *= pow(dot(rd * 2.0,vec3(0.0,1.0,0.0)),0.1);\n    //return vec3(0.0);\n\treturn clamp(sun+col,0.0,1.0);\n}\n\nfloat planeIntersect(Ray ray,Plane plane)\n{\n    return -(dot(ray.origin,plane.normal)+plane.position)/dot(ray.direction,plane.normal);\n}\n\nvec2 sphereIntersect(Ray ray, Sphere sphere)\n{\n    vec3 oc = ray.origin - sphere.position;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sphere.radius*sphere.radius;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection(Ray ray, Box box, out vec3 outNormal) \n{\n    ray.origin -= box.position;\n    vec3 m = 1.0/ray.direction; \n    vec3 n = m*ray.origin;   \n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    if (tN > 0.0)\n    {\n        outNormal = step(vec3(tN),t1);\n    }\n    else\n    {\n        outNormal = step(t2,vec3(tF));\n    }\n    outNormal *= -sign(ray.direction);\n    return vec2( tN, tF );\n}\n\nvec4 castRay(out Ray ray)\n{\n    vec2 minHitDistance = vec2(MaxDistance);\n    vec2 hitDistance = vec2(0.0);\n    vec4 color = vec4(1.0);\n    vec3 normal = vec3(0.0);\n    \n    Sphere sphere;\n    sphere.position =  vec3(7.0,6.0,2.0);\n    sphere.radius = 1.5;\n    sphere.color = vec4(1.0,1.0,1.0,-1.0);\n    \n    hitDistance = sphereIntersect(ray,sphere);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere.position);\n        color = sphere.color;\n    }\n    \n    Sphere sphere2;\n    sphere2.position = vec3(-6.0,0.1,6.0);\n    sphere2.radius = 3.0;\n    sphere2.color = vec4(1.0,1.0,1.0,0.95);    \n    hitDistance = sphereIntersect(ray,sphere2);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere2.position);\n        color = sphere2.color;\n    }\n    \n    Sphere sphere3;\n    sphere3.position = vec3(0.0,15.0,10.0);\n    sphere3.radius = 3.0;\n    sphere3.color = vec4(1.0,1.0,1.0,-3.0);    \n    hitDistance = sphereIntersect(ray,sphere3);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere3.position);\n        color = sphere3.color;\n    }\n    \n    Plane plane;\n    plane.normal = vec3(0.0,1.0,0.0);\n    plane.position = 1.0;\n    plane.color = vec4(0.5,0.5,0.5,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane.normal;\n        color = plane.color;\n    }\n    \n    Plane plane2;\n    plane2.normal = vec3(-1.0,0.0,0.0);\n    plane2.position = 10.0;\n    plane2.color = vec4(1.0,0.1,0.1,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane2));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane2.normal;\n        color = plane2.color;\n    }\n    \n    Plane plane3;\n    plane3.normal = vec3(1.0,0.0,0.0);\n    plane3.position = 10.0;\n    plane3.color = vec4(1.0,1.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane3));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane3.normal;\n        color = plane3.color;\n    }\n    \n    Plane plane4;\n    plane4.normal = vec3(0.0,0.0,-1.0);\n    plane4.position = 10.0;\n    plane4.color = vec4(0.0,1.0,0.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane4));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane4.normal;\n        color = plane4.color;\n    }\n    \n    Plane plane5;\n    plane5.normal = vec3(0.0,-1.0,0.0);\n    plane5.position = 15.0;\n    plane5.color = vec4(0.0,0.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane5));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane5.normal;\n        color = plane5.color;\n    }\n    \n    Box box;\n    box.position = vec3(7.0,2.1,2.0);\n    box.size = 2.0;\n    box.color = vec4(0.0,1.0,0.0,0.0);\n    vec3 boxNormal = vec3(0.0);\n    hitDistance = boxIntersection(ray,box,boxNormal);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        color = box.color;\n        normal = boxNormal;\n    }\n    if (minHitDistance.x == MaxDistance)\n    {\n        return vec4(getSky(ray.direction),-2.0);\n    }\n    if(color.a == -2.0) \n    {\n        return color;\n    }\n    vec3 reflected = reflect(ray.direction, normal);\n    if(color.a == -3.0)\n    {\n        \n        //float fresnel = 1.0 - abs(dot(ray.direction, normal));\n        //if (1.0/fresnel > 2.0) \n        //{\n        //    color.a = -2.0;\n        //    return color;\n        //}\n        //vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n        //vec3 r = randomOnSphere(ray);\n        //vec3 diffuse = normalize(r * dot(r, normal));\n        //ray.origin += ray.direction * (minHitDistance.x - 0.0001);\n        //ray.direction = mix(diffuse, reflected, color.a);\n\t\treturn color;\n    }\n    if(color.a < 0.0) {\n\t\tfloat fresnel = 1.0 - abs(dot(ray.direction, normal));\n\t\tif(length(randomOnSphere(ray)) - 0.7 < pow(fresnel,5.4)) {\n\t\t\tray.direction = reflected;\n\t\t\treturn color * pow(fresnel+1.0,0.25);\n\t\t}\n\t\tray.origin += ray.direction * (minHitDistance.y + 0.0001);\n\t\tray.direction = refract(ray.direction, normal, 1.0 / (1.0 - color.a));\n\t    \n        return color;\n\t}\n    vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n\tvec3 r = randomOnSphere(ray);\n\tvec3 diffuse = normalize(r * dot(r, normal));\n\tray.origin += ray.direction * (minHitDistance.x - 0.0001);\n\tray.direction = mix(diffuse, reflected, color.a);\n    return color;\n}\n\nvec3 traceRay(Ray ray) {\n\tvec3 color = vec3(1.0);\n\tfor(int i = 0; i < MaxReflections; i++)\n\t{\n\t\tvec4 reflectedColor = castRay(ray);\n\t\t\n\t\tif(reflectedColor.a == -2.0)\n        {\n            float a = 0.8;\n            color *= vec3(\n            pow(reflectedColor.r,a),\n            pow(reflectedColor.g,a),\n            pow(reflectedColor.b,a));\n            if (distance(color,vec3(1.0,1.0,1.0)) < 0.310009)\n            {\n                color = color * lightStrenth;\n            }\n            return color;\n        }\n        color *= reflectedColor.rgb;\n        if(reflectedColor.a == -3.0) \n        {\n           \n            return color * reflectedColor.rgb;\n        }\n\t}\n\treturn vec3(0.0);\n}\n\nvec2 initUV(vec2 fragCoord)\n{\n    return (fragCoord-0.5*iResolution.xy)/iResolution.y;\n}\n\nuniform float accumulator;\n\nvec4 GetColor(vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = initUV(fragCoord);\n    Ray ray;\n    ray.origin = vec3(-1.0,7.5,-15.0);\n    ray.direction = normalize(vec3(uv,1.0));\n    \n    seed = iTime;\n    vec3 r = randomOnSphere(ray);\n\tray.direction = normalize(mix(r, ray.direction, blur));\n    \n    \n    vec3 color = vec3(0.0);\n   \n    \n    for(int i = 0;i<samples;i++)\n    {\n        color+=traceRay(ray);\n        seed +=1.1;\n    }\n    color/=float(samples);\n    \n    float white = 8.0;\n    color = (color * white * (1.0 + color / white))/(1.0 + color*white);\n    //vec3 sampleColor = texture(iChannel0,fragCoord.xy).rgb;\n    //color = mix(color,sampleColor,(1.0/float(seed)/10.0));\n    //color = mix(color,sampleColor,1.0);\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; \n    \n    vec4 color = texture(iChannel0, uv);\n    float white = 14.0;\n\tcolor *= white * 3.0;\n\tcolor = (color * (1.0 + color / white / white)) / (1.0 + color);\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float MaxDistance = 99999.0;\nconst int MaxReflections = 4;\nconst float lightStrenth = 4.0;\nconst int samples = 4;\nconst float blur = 0.999;\n\nvec2 u_seed1;\nvec2 u_seed2;\n\nfloat seed;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Box\n{\n    vec3 position;\n    float size;\n    vec4 color;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec4 color;\n};\n\nstruct Plane\n{\n    float position;\n    vec3 normal;\n    vec4 color;\n};\n\nstruct LightSource\n{\n    vec3 position;\n    float radius;\n};\n\nint LCGStep(int z, int A, int C)\n{\n\treturn (A * z + C);\t\n}\n\nvec2 hash22(vec2 p)\n{\n\tp += u_seed1.x;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat random(vec2 co){\n    return fract(sin(dot(co * seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 randomOnSphere(Ray ray) {\n\tvec3 rand = vec3(\n    random(ray.direction.xy),\n    random(ray.direction.yz),\n    random(ray.direction.zx));\n\tfloat theta = rand.x * 2.0 * 3.14159265;\n\tfloat v = rand.y;\n\tfloat phi = acos(2.0 * v - 1.0);\n\tfloat r = pow(rand.z, 1.0 / 3.0);\n\tfloat x = r * sin(phi) * cos(theta);\n\tfloat y = r * sin(phi) * sin(theta);\n\tfloat z = r * cos(phi);\n\treturn vec3(x, y, z);\n}\n\nvec3 light = normalize(vec3(0.0, -1.0, 1.0));\n\nvec3 getSky(vec3 rd) {\n\tvec3 col = vec3(0.3, 0.6, 1.0);\n\tvec3 sun = vec3(0.95, 0.9, 1.0);\n\tsun *= max(0.0, pow(dot(rd, light), 256.0));\n\t//col *= max(0.0, pow(dot(rd, light), 256.0));\n    col *= pow(dot(rd * 2.0,vec3(0.0,1.0,0.0)),0.1);\n    //return vec3(0.0);\n\treturn clamp(sun+col,0.0,1.0);\n}\n\nfloat planeIntersect(Ray ray,Plane plane)\n{\n    return -(dot(ray.origin,plane.normal)+plane.position)/dot(ray.direction,plane.normal);\n}\n\nvec2 sphereIntersect(Ray ray, Sphere sphere)\n{\n    vec3 oc = ray.origin - sphere.position;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sphere.radius*sphere.radius;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection(Ray ray, Box box, out vec3 outNormal) \n{\n    ray.origin -= box.position;\n    vec3 m = 1.0/ray.direction; \n    vec3 n = m*ray.origin;   \n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    if (tN > 0.0)\n    {\n        outNormal = step(vec3(tN),t1);\n    }\n    else\n    {\n        outNormal = step(t2,vec3(tF));\n    }\n    outNormal *= -sign(ray.direction);\n    return vec2( tN, tF );\n}\n\nvec4 castRay(out Ray ray)\n{\n    vec2 minHitDistance = vec2(MaxDistance);\n    vec2 hitDistance = vec2(0.0);\n    vec4 color = vec4(1.0);\n    vec3 normal = vec3(0.0);\n    \n    Sphere sphere;\n    sphere.position =  vec3(7.0,6.0,2.0);\n    sphere.radius = 1.5;\n    sphere.color = vec4(1.0,1.0,1.0,-1.0);\n    \n    hitDistance = sphereIntersect(ray,sphere);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere.position);\n        color = sphere.color;\n    }\n    \n    Sphere sphere2;\n    sphere2.position = vec3(-6.0,0.1,6.0);\n    sphere2.radius = 3.0;\n    sphere2.color = vec4(1.0,1.0,1.0,0.95);    \n    hitDistance = sphereIntersect(ray,sphere2);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere2.position);\n        color = sphere2.color;\n    }\n    \n    Sphere sphere3;\n    sphere3.position = vec3(0.0,15.0,10.0);\n    sphere3.radius = 3.0;\n    sphere3.color = vec4(1.0,1.0,1.0,-3.0);    \n    hitDistance = sphereIntersect(ray,sphere3);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere3.position);\n        color = sphere3.color;\n    }\n    \n    Plane plane;\n    plane.normal = vec3(0.0,1.0,0.0);\n    plane.position = 1.0;\n    plane.color = vec4(0.5,0.5,0.5,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane.normal;\n        color = plane.color;\n    }\n    \n    Plane plane2;\n    plane2.normal = vec3(-1.0,0.0,0.0);\n    plane2.position = 10.0;\n    plane2.color = vec4(1.0,0.1,0.1,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane2));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane2.normal;\n        color = plane2.color;\n    }\n    \n    Plane plane3;\n    plane3.normal = vec3(1.0,0.0,0.0);\n    plane3.position = 10.0;\n    plane3.color = vec4(1.0,1.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane3));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane3.normal;\n        color = plane3.color;\n    }\n    \n    Plane plane4;\n    plane4.normal = vec3(0.0,0.0,-1.0);\n    plane4.position = 10.0;\n    plane4.color = vec4(0.0,1.0,0.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane4));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane4.normal;\n        color = plane4.color;\n    }\n    \n    Plane plane5;\n    plane5.normal = vec3(0.0,-1.0,0.0);\n    plane5.position = 15.0;\n    plane5.color = vec4(0.0,0.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane5));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane5.normal;\n        color = plane5.color;\n    }\n    \n    Box box;\n    box.position = vec3(7.0,2.1,2.0);\n    box.size = 2.0;\n    box.color = vec4(0.0,1.0,0.0,0.0);\n    vec3 boxNormal = vec3(0.0);\n    hitDistance = boxIntersection(ray,box,boxNormal);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        color = box.color;\n        normal = boxNormal;\n    }\n    if (minHitDistance.x == MaxDistance)\n    {\n        return vec4(getSky(ray.direction),-2.0);\n    }\n    if(color.a == -2.0) \n    {\n        return color;\n    }\n    vec3 reflected = reflect(ray.direction, normal);\n    if(color.a == -3.0)\n    {\n        \n        //float fresnel = 1.0 - abs(dot(ray.direction, normal));\n        //if (1.0/fresnel > 2.0) \n        //{\n        //    color.a = -2.0;\n        //    return color;\n        //}\n        //vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n        //vec3 r = randomOnSphere(ray);\n        //vec3 diffuse = normalize(r * dot(r, normal));\n        //ray.origin += ray.direction * (minHitDistance.x - 0.0001);\n        //ray.direction = mix(diffuse, reflected, color.a);\n\t\treturn color;\n    }\n    if(color.a < 0.0) {\n\t\tfloat fresnel = 1.0 - abs(dot(ray.direction, normal));\n\t\tif(length(randomOnSphere(ray)) - 0.7 < pow(fresnel,5.4)) {\n\t\t\tray.direction = reflected;\n\t\t\treturn color * pow(fresnel+1.0,0.25);\n\t\t}\n\t\tray.origin += ray.direction * (minHitDistance.y + 0.0001);\n\t\tray.direction = refract(ray.direction, normal, 1.0 / (1.0 - color.a));\n\t    \n        return color;\n\t}\n    vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n\tvec3 r = randomOnSphere(ray);\n\tvec3 diffuse = normalize(r * dot(r, normal));\n\tray.origin += ray.direction * (minHitDistance.x - 0.0001);\n\tray.direction = mix(diffuse, reflected, color.a);\n    return color;\n}\n\nvec3 traceRay(Ray ray) {\n\tvec3 color = vec3(1.0);\n\tfor(int i = 0; i < MaxReflections; i++)\n\t{\n\t\tvec4 reflectedColor = castRay(ray);\n\t\t\n\t\tif(reflectedColor.a == -2.0)\n        {\n            float a = 0.8;\n            color *= vec3(\n            pow(reflectedColor.r,a),\n            pow(reflectedColor.g,a),\n            pow(reflectedColor.b,a));\n            if (distance(color,vec3(1.0,1.0,1.0)) < 0.310009)\n            {\n                color = color * lightStrenth;\n            }\n            return color;\n        }\n        color *= reflectedColor.rgb;\n        if(reflectedColor.a == -3.0) \n        {\n           \n            return color * reflectedColor.rgb * lightStrenth;\n        }\n\t}\n\treturn vec3(0.0);\n}\n\nvec2 initUV(vec2 fragCoord)\n{\n    return (fragCoord-0.5*iResolution.xy)/iResolution.y;\n}\n\nuniform float accumulator;\n\nvec4 GetColor(vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = initUV(fragCoord);\n    u_seed1 = vec2(0.0,1.0/iTime);\n    Ray ray;\n    ray.origin = vec3(-1.0,7.5,-15.0);\n    ray.direction = normalize(vec3(uv,1.0));\n    \n    seed = iTime;\n    vec3 r = randomOnSphere(ray);\n\tray.direction = normalize(mix(r, ray.direction, blur));\n    \n    \n    vec3 color = vec3(0.0);\n   \n    \n    for(int i = 0;i<samples;i++)\n    {\n        color+=traceRay(ray);\n        seed +=1.1;\n    }\n    color/=float(samples);\n    \n    float white = 8.0;\n    color = (color * white * (1.0 + color / white))/(1.0 + color*white);\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    color = mix(color,texture(iChannel0,uv2).rgb,0.5);\n    //vec3 sampleColor = texture(iChannel0,fragCoord.xy).rgb;\n    //color = mix(color,sampleColor,(1.0/float(seed)/10.0));\n    //color = mix(color,sampleColor,1.0);\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = initUV(fragCoord);\n    u_seed1 = vec2(0.0,1.0/iTime);\n    Ray ray;\n    ray.origin = vec3(-1.0,7.5,-15.0);\n    ray.direction = normalize(vec3(uv,1.0));\n    \n    seed = iTime;\n    vec3 r = randomOnSphere(ray);\n\tray.direction = normalize(mix(r, ray.direction, blur));\n    \n    \n    vec3 color = vec3(0.0);\n   \n    \n    for(int i = 0;i<samples;i++)\n    {\n        color+=traceRay(ray);\n        seed +=1.1;\n    }\n    color/=float(samples);\n    \n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec3 previousColor = texture(iChannel0,uv2).rgb;\n    if (iFrame > 0)\n    color = mix(previousColor,color,1.0/pow(float(iFrame),0.7));\n    //if (iFrame > 0)\n    //color = clamp(color+texture(iChannel0,uv2).rgb,0.0,1.0);\n    //vec3 sampleColor = texture(iChannel0,fragCoord.xy).rgb;\n    //color = mix(color,sampleColor,(1.0/float(seed)/10.0));\n    //color = mix(color,sampleColor,1.0);\n\tfragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dly3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 490, 524, 524, 548], [550, 550, 572, 572, 649], [651, 651, 681, 681, 1047], [1096, 1096, 1118, 1118, 1390], [1392, 1392, 1435, 1435, 1528], [1530, 1530, 1576, 1576, 1829], [1831, 1831, 1892, 1892, 2397], [2399, 2399, 2426, 2426, 7445], [7447, 7447, 7471, 7471, 8138], [8140, 8140, 8169, 8169, 8228], [8258, 8258, 8306, 8306, 9013], [9015, 9015, 9072, 9072, 9307]]}
{"id": "ctGGW1", "name": "Dancing Tiles Illusion (628 ch)", "author": "fenix", "description": "My take on the popular \"negative space becomes positive space\" illusion genre.", "tags": ["illusion", "squares", "floating", "codegolf"], "likes": 17, "viewed": 202, "published": 3, "date": "1683950860", "time_retrieved": "2024-07-30T17:56:06.966642", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  My take on the popular \"negative space becomes positive space\" illusion genre.\n//\n//  This shader seems like the kind of thing that is amenable to golfing, but I feel like\n//  I'm still missing something big. Maybe there is a more compact noise function?\n//\n// ---------------------------------------------------------------------------------------\n\n// From FabriceNeyret2: (628 chars)\n\n//*\n#define R(X) mat2(cos( X * 3.14 + vec4(0, 11, 33, 0)))                 //\n#define c   ( vec4(.3, .6, 1, 1) - r* vec4(-.2,.5,.5,0) )              //\n#define S(v) smoothstep(v,0.,d)                                        //\n#define L                                                               \\\n        d = 1.;                                                         \\\n        for (int k=0; k<9; k++)                                         \\\n            P = vec2(k%3,k/3) - .5,                                     \\\n            h = fract(1e4*sin(trunc(vec3(u + P + .5, t))                \\\n             * mat3(R+17.,R+51.,57.-R))) -.5,                           \\\n            D = abs( ( fract(u) - P + h.xy * R(t) * M )                 \\\n                    * R( .8 - trunc( h.z*12. + sign(h.z) ) * fract(t) ) \\\n                   ) - .354,                                            \\\n            d = min(d, length(max(D,0.)) + min(max(D.x,D.y),0.));       \\\n        O \n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec3  R = iResolution, h;\n    float t = iTime / 8.,\n          m = abs( fract(t) - .5), d=m, M = S(.5),\n          r = fract(t * .5) > .5 ? 1. : 0.,   \n          z = 4. - 2.*cos(t);\n    vec2  P, D;\n          u = z * ( u+u - R.xy ) / R.y + r*.5;\n    z *= 3./R.y;\n    L = c *(1.-.5*S(  M *.1 + z));\n    d = m-.25, u += vec2(.2, -.2) * S(.25);\n    r = 1. - r; L += (c-O)*  S(z);\n}\n\n\n/**/\n\n\n// Golfed by me: (735 ch)\n\n/*\n\n#define R(X) mat2(cos((X) * 3.14 + vec4(0, 11, 33, 0)))\n#define c(X) mix(vec4(.3, .6, 1, 1), vec4(.5, .1, .5, 1), X)\n#define S smoothstep\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t = iTime / 8.,\n          m = abs(fract(t) - .5),\n          r = fract(t * .5) > .5 ? 1. : 0.,\n          s = 0., x, y, d, R = iResolution.y;\n    \n    u = (8. - cos(t) * 4.) * (u - .5 * iResolution.xy) / R + r * .5;\n    \n    for (O = c(r); s < 2.; ++s)\n    {\n        d = 1e6;\n        for (x = -1.; x <= 1.; ++x)\n        for (y = -1.; y <= 1.; ++y)\n        {\n            vec3 h = fract(vec3(trunc(u + vec2(x, y) + 10.), trunc(t)) * vec3(.1, .11, .01));\n            h += dot(h, h.yxz+33.33);\n            h = fract((h.xxy + h.yxx)*h.zyx) - .5;\n            \n            vec2 v = (fract(u) - .5 - vec2(x, y) + h.xy * R(t) * S(.5, 0., m))\n                     * R(-trunc(h.z * 12. + sign(h.z)) * fract(t) + .25),\n                 D = abs(v) - .354;\n                 \n            d = min(d, length(max(D,0.)) + min(max(D.x,D.y),0.));\n        }\n        \n        u += vec2(.2, -.2) * smoothstep(.5, .25, m);\n        O = mix(O, s < 1. ? O * .5 : c(1. - r), S((1. - s) * S(.5, 0., m) * .1 + 3. / R, 0., d));\n    }\n}\n/**/\n\n// Original: 1038 chars\n\n/*\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r + vec4(0, 11, 33, 0)));\n}\n\n// Dave_Hoskin's Hash Without Sine: https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nconst float PI = 3.14159;\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    float t = (iTime - .5) * .125;\n    float m = fract(t);\n    float r = float(fract(t * .5) > .5);\n    \n    u = (8. - cos(t) * 4.) * (u - .5 * iResolution.xy) / iResolution.y + (r * vec2(.5));\n    \n    O = mix(vec4(.3, .6, 1, 1), vec4(.5, .1, .5, 1), r);\n    \n    for (float s = 0.; s < 2.; ++s)\n    {\n        float md = 1e6;\n        for (float x = -1.; x <= 1.; ++x)\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            vec2 id = trunc(u + vec2(x, y) + 100.);\n            vec3 h = hash33(vec3(id, trunc(t)) + 130.) - .5;\n            vec2 off = h.xy * rot(PI * t) * smoothstep(.5, 0., abs(m - .5));\n            vec2 v = fract(u) - .5 - vec2(x, y);\n            v += off;\n            v *= rot(PI * (-trunc(h.z * 12. + sign(h.z)) * m + .25));\n\n            float d = sdBox(v, vec2(.5/sqrt(2.)));\n            md = min(md, d);\n        }\n        \n        u += vec2(.2, -.2) * smoothstep(.5, .25, abs(m - .5));\n        O = mix(O, s < 1. ? O * .5 : mix(vec4(.5, .1, .5, 1), vec4(.3, .6, 1, 1), r),\n            smoothstep((1. - s) * smoothstep(.5, 0., abs(m - .5)) * .1 + 3. / iResolution.y, 0., md));\n    }\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGGW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1578, 1578, 1614, 1614, 1994]]}
{"id": "dtVGW1", "name": "Livings", "author": "Slals", "description": "Was looking to do another thing, looks cool tho, remind me of Game of Life structures", "tags": ["2d", "flat", "pixel", "pattern", "gameoflifestyle"], "likes": 6, "viewed": 173, "published": 3, "date": "1683931639", "time_retrieved": "2024-07-30T17:56:07.820360", "image_code": "float easeInQ(float x) {\n    return pow(x, 6.0 * (cos(iTime) + 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv *= 10.0 * iTime;\n    vec2 pid = floor(uv);\n\n    fragColor = vec4(vec3(easeInQ(abs(sin(iTime * 4.0 + abs(pid.x * pid.y))))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtVGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 71], [73, 73, 130, 130, 339]]}
{"id": "mlKGW1", "name": "Rainbow Soothie", "author": "mcritz", "description": "An example of a fairly simple shader. If your first shader was “I animated a gradient” then this is the next thing to look into.", "tags": ["simple", "flow"], "likes": 0, "viewed": 156, "published": 3, "date": "1683931566", "time_retrieved": "2024-07-30T17:56:08.601272", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime / 7. + uv.xyx + vec3(0,2,4));\n    \n    col /= length(uv.y - vec2(.5,.5 * sin(iTime / 5.)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 365]]}
{"id": "dlVGWh", "name": "Fork AI not inc supernlogn 812", "author": "supernlogn", "description": "Used python code to extract Fourier series coefficients from ECG samples found here: ttps://raw.githubusercontent.com/paulvangentcom/heartrate_analysis_python/master/heartpy/data/data2.csv\n\nPython code (after downloading the file as temp.txt) in comments\n", "tags": ["2d", "heart", "ecg"], "likes": 4, "viewed": 346, "published": 3, "date": "1683929642", "time_retrieved": "2024-07-30T17:56:09.428061", "image_code": "// CC0: AI not included\n// Tinkering around with old shaders.\n// No AI and very little human intelligence used ;)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.58;\nconst vec3 dbcol = HSV2RGB(vec3(hoff+0.96, 0.8, 0.75));\nconst vec3 sbcol = HSV2RGB(vec3(hoff+0.95, 0.4, 1.0));\nconst vec3 gbcol = HSV2RGB(vec3(hoff+0.98, 0.9, 0.001));\nconst vec3 fbcol = HSV2RGB(vec3(hoff+0.95, 0.7, 2.0));\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n\nfloat computeBeat() {\n    float timeSlow = TIME; // this works for 60 fps as we use coefficients till 60 Hz\n    float val = (0.37785045725124383) * cos(0.3141592653589793 * timeSlow)+(2.3364232140542085) * cos(1.5707963267948966 * timeSlow)+(18.717028467910303) * cos(1.6336281798666925 * timeSlow)+(3.696330823238726) * cos(1.7592918860102842 * timeSlow)+(9.578403455815018) * cos(1.8221237390820801 * timeSlow)+(1.3625736929657797) * cos(1.8849555921538756 * timeSlow)+(2.7942202996192163) * cos(1.9477874452256716 * timeSlow)+(1.7711610615255986) * cos(2.0106192982974678 * timeSlow)+(0.9713881229829386) * cos(2.0734511513692637 * timeSlow)+(1.721581029181113) * cos(2.1362830044410597 * timeSlow)+(1.0957706783455479) * cos(2.199114857512855 * timeSlow)+(1.0743272383031455) * cos(2.261946710584651 * timeSlow)+(1.9237696070026973) * cos(2.324778563656447 * timeSlow)+(3.0501469540827926) * cos(2.4504422698000385 * timeSlow)+(3.57347625097854) * cos(2.57610597594363 * timeSlow)+(4.164819657445082) * cos(2.701769682087222 * timeSlow)+(0.9780693241331418) * cos(2.764601535159018 * timeSlow)+(13.732993114269574) * cos(2.827433388230814 * timeSlow)+(8.990633102958629) * cos(2.9530970943744057 * timeSlow)+(6.260044998909341) * cos(3.141592653589793 * timeSlow)+(2.422189622275397) * cos(3.267256359733385 * timeSlow)+(15.933357175405717) * cos(3.4557519189487724 * timeSlow)+(0.3716019058694118) * cos(3.581415625092364 * timeSlow)+(4.2045240500285095) * cos(3.6442474781641603 * timeSlow)+(0.43314671398601945) * sin(0.3141592653589793 * timeSlow)+(10.259948928086486) * sin(1.5707963267948966 * timeSlow)+(12.083461743869616) * sin(1.6336281798666925 * timeSlow)+(8.091002375361459) * sin(1.7592918860102842 * timeSlow)+(-4.947019252504502) * sin(1.8221237390820801 * timeSlow)+(0.0600410407611961) * sin(1.8849555921538756 * timeSlow)+(5.842610601241493) * sin(1.9477874452256716 * timeSlow)+(1.3074994797075126) * sin(2.0106192982974678 * timeSlow)+(2.0786788597400236) * sin(2.0734511513692637 * timeSlow)+(1.876456336333239) * sin(2.1362830044410597 * timeSlow)+(2.2983684279760968) * sin(2.199114857512855 * timeSlow)+(1.5756881298204577) * sin(2.261946710584651 * timeSlow)+(0.7598722612130775) * sin(2.324778563656447 * timeSlow)+(3.092277842258946) * sin(2.4504422698000385 * timeSlow)+(1.1479047878773916) * sin(2.57610597594363 * timeSlow)+(2.2552228380551265) * sin(2.701769682087222 * timeSlow)+(-1.1038233102198718) * sin(2.764601535159018 * timeSlow)+(4.851386456130351) * sin(2.827433388230814 * timeSlow)+(13.47166890824398) * sin(2.9530970943744057 * timeSlow)+(-29.19821342041527) * sin(3.141592653589793 * timeSlow)+(-1.5531119423375312) * sin(3.267256359733385 * timeSlow)+(-2.646483440926437) * sin(3.4557519189487724 * timeSlow)+(6.665382994344453) * sin(3.581415625092364 * timeSlow)+(-4.85667950496648) * sin(3.6442474781641603 * timeSlow);\n    return -val/100.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  float beatFraction = computeBeat();\n  p.x = pabs(p.x, 0.05) * (0.90 + 0.10 * beatFraction);\n  p.y = p.y * (0.93 + 0.07 * beatFraction);\n  if( p.y+p.x>1.0 )\n      return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n  return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                  dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat df(vec2 p) {\n  vec2 hp = p;\n  const float hz = 1.0;\n  hp /= hz;\n  hp.y -= -0.6;\n  float d = heart(hp)*hz;\n  return d;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float h = (-20.0*d);\n  h = tanh_approx(h);\n  h -= 3.0*length(p);\n  h = pmin(h, 0.0, 1.);\n  h *= 0.25;\n  return h;\n}\n\nvec3 nf(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = hf(p + e.yx) - hf(p - e.yx);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  float f = (aggr * 0.5) + 0.5;\n  \n  return f;\n}\n\nfloat divf(float offset, float f) {\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  float r = abs(goff + offset - f);\n  r = max(r, gfloor);\n  return r;\n}\n\n// This way of computing \"lightning\" I found at shadertoy. Unfortunately I don't remember where.\nvec3 lightning(vec2 pos, vec2 pp, float offset) {\n  vec3 sub = 0.03*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n\n  float time = TIME+123.4;\n  float stime = time/200.0;\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*cos(vec2(sqrt(0.5), 1.0)*stime)+vec2(0.0, -11.0)*stime;\n  const float glow = 0.0125;\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  for (float i = 0.0; i < 3.0; ++i) {\n    vec3 gcol0 = (1.0+cos(0.50*vec3(0.0, 1.0, 2.0) +time+3.0*pos.x-0.33*i));\n    vec3 gcol1 = (1.0+cos(1.25*vec3(0.0, 1.0, 2.0) +2.*time+pos.y+0.25*i));\n    float btime = stime*85.0 + (i);\n    float rtime = stime*75.0 + (i);\n    float div1 = divf(offset, fbm((pos + f) * 3.0, rtime));\n    float div2 = divf(offset, fbm((pos + f) * 2.0, btime));\n    float d1 = offset * glow / div1;\n    float d2 = offset * glow / div2;\n    col += (d1 * gcol0)-sub;\n    col += (d2 * gcol1)-sub;\n  }\n    \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 4.0/RESOLUTION.y;\n  float d = df(p);\n  float h = hf(p);\n  vec3 n = nf(p);\n  const vec3 lp = vec3(-4.0, -5.0, 3.0);\n  const vec3 ro = vec3(10.0, 00.0, 0.0);\n  vec3 p3 = vec3(p, h); \n  vec3 rd = normalize(p3-ro);\n  vec3 ld = normalize(lp-p3);\n  vec3 r = reflect(rd, n);\n  float diff = max(dot(ld, n), 0.0);\n  vec3 dcol = dbcol*mix(vec3(0.15), vec3(1.0), diff);\n  float spe = pow(max(dot(ld, r), 0.0), 3.0);\n  vec3 scol = spe*sbcol;\n  float gd = d+0.0;\n  vec2 gp = p;\n  vec3 gcol = lightning(gp, pp, gd);\n  vec3 hcol = dcol;\n  hcol += scol;\n  vec3 col = vec3(1.0);\n  col += gbcol/max(0.01*(dot2(p)-0.15), 0.0001);\n  col += gcol;\n  col = mix(col, hcol, smoothstep(0.0, -aa, d));\n  col = mix(col, fbcol, smoothstep(0.0, -aa, abs(d+0.01)-0.01));\n  col *= smoothstep(1.75, 0.5, length(pp));\n\n  col = aces_approx(col); \n  col = sqrt(col); \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col.yxz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlVGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 425, 425, 571], [1115, 1243, 1271, 1337, 1413], [1415, 1522, 1548, 1548, 1733], [1735, 1835, 1874, 1874, 1959], [1961, 2049, 2079, 2079, 2107], [2109, 2109, 2129, 2129, 2151], [2154, 2154, 2175, 2175, 5052], [5054, 5172, 5193, 5193, 5522], [5524, 5524, 5542, 5542, 5649], [5651, 5651, 5669, 5669, 5806], [5808, 5808, 5825, 5825, 6015], [6017, 6017, 6036, 6036, 6159], [6161, 6161, 6182, 6182, 6609], [6611, 6611, 6642, 6642, 7003], [7005, 7005, 7040, 7040, 7168], [7170, 7267, 7316, 7316, 8147], [8149, 8149, 8179, 8179, 9040], [9042, 9042, 9097, 9097, 9273]]}
{"id": "3tXyDS", "name": "Field of prime divisors", "author": "brianhaak", "description": "potato", "tags": ["primenumbersfactorization"], "likes": 2, "viewed": 147, "published": 3, "date": "1683913595", "time_retrieved": "2024-07-30T17:56:10.288760", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    \n    //fragCoord = floor(fragCoord);// - 0.5);\n    \n    //fragCoord.x *= 0.5 / (log(fragCoord.x) - 1.0); // 0.125;\n    //fragCoord.y *= 0.25;// / (log(fragCoord.y) - 1.0);\n   \n   \n    float zoom = 1.0;//8.0;\n    \n    fragCoord = vec2(fragCoord) / zoom;\n    \n    // float vert_pos = (iResolution.y - (iMouse.y - iMouse.w)) / zoom;\n    \n    // float vert_pos = (iResolution.y - abs(iMouse.w)) / zoom;\n    float vert_pos = (abs(iMouse.w)) / zoom;\n    if (iMouse.y > 0.0) {\n        //vert_pos = (iResolution.y - abs(iMouse.y)) / zoom;\n        vert_pos = (abs(iMouse.y)) / zoom;\n    }\n    \n    vert_pos = floor(vert_pos);\n    \n    float y = fragCoord.y;//iResolution.y - fragCoord.y;\n    \n    //fragCoord = floor(vec2(fragCoord.x, y) / zoom);\n    //fragCoord = floor(fragCoord / zoom);\n    //y = fragCoord.y;\n    \n    \n    //float x = floor(0.5 * fragCoord.x) + 2.0;\n    float x = fragCoord.x;// + 1.0;\n    \n    //if (x == y) {\n        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    //    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    //    return;\n    //}\n    \n    //if (x > 1.5) {\n    //    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        //return;\n    //}\n    \n   \n    const vec4 rate = vec4(240.0,144.0,120.0,60.0);\n    vec4  d = abs(rate-iFrameRate);\n    float refresh = (d.x<d.y && d.x<d.z && d.x<d.w) ? rate.x:\n                               (d.y<d.z && d.y<d.w) ? rate.y:\n                                          (d.z<d.w) ? rate.z:\n                                                      rate.w;\n    \n    // compute how many frames we should have delivered so far\n    float frame = round(iTime*refresh);\n    \n    \n    // float offset = iTime * 60.0;\n    float speed = 111.0;\n    //float speed = 1.0 / 4.0;\n    float offset = floor(speed * frame);// / speed) * speed;//iTime * 500.0;\n    \n    vec4 mix_mouse = vec4(0.0);\n    \n    if (abs(y - vert_pos) < 0.51) {\n        mix_mouse = vec4(0.5, 0.5, 0.0, 0.0);\n    }\n    \n    //y += offset + 1046527.0;// + 1800.0;\n    //x += 1046527.0 / 2000.0;// - 2000.0;\n    y += offset;\n    \n    //x += 2.0;\n    \n    float x_for_rem = x + 1.0;\n    \n    float rem = mod(y, x_for_rem); //y - x * integral_ratio;\n    \n    float distance_from_zero = 0.5 * x_for_rem - rem + 1.0;\n    \n    //float intensity = 100.0 - abs(distance_from_zero * distance_from_zero) / (x_for_rem * x_for_rem);\n    float intensity = 1.0 - 1.5 * abs(distance_from_zero * distance_from_zero) / (x_for_rem * x_for_rem);\n    \n    // float dynamic_range = 16.0;\n    //float intensity = (dynamic_range - floor(mod(distance_from_zero, dynamic_range)))/dynamic_range;\n    \n    if (abs(distance_from_zero) / x_for_rem > 0.49) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    fragColor = vec4(intensity, intensity, intensity, 1.0);\n    \n    \n    return;\n    \n    \n    /*\n    if (x >= y) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    if (x > y) {\n        fragColor = vec4(0.0);\n        return;\n    }*/\n    \n    //if (y - offset == floor(iResolution.y / zoom) - 10.0) { //52.0) {\n    //    fragColor = vec4(1.0);\n    //    return;\n    //}\n    \n    \n   \n    \n    //if (x <= 1.0) {\n    //\tfragColor = vec4(0.0);;//vec4(vec3((1.0 / 256.0) * mod(y, 256.)), 1.0);\n    //    return;\n    //}\n    \n    \n   \n    //float line = mod(y / x, repeat); //* step(remainder, 1.0), 256.0);\n    \n    // float linemix = line;//step(remainder, 1.0);//(mod(remainder, 256.) / 512.0);// * (1.0 / 512.0) * mod(remainder, 256.);\n    \n    //fragColor = vec4(vec3(linemix * remainder * step(remainder, 1.0)), 1.0);\n    \n    //fragColor = vec4(vec3(remainder * step(remainder, 1.0) * (repeat - line) / repeat), 1.0);\n    \n    //fragColor = vec4(vec3(remainder * step(remainder, 1.0) * (1.0 - line / repeat)), 1.0);\n    \n    \n    //fragColor = vec4(vec3(remainder * step(remainder, 1.0)), 1.0);\n    // fragColor = vec4(vec3((y / x) * remainder * step(remainder, 1.0)), 1.0);\n    //fragColor = vec4(vec3((y / x) * remainder), 1.0);\n    \n    //float ratio = (y + 0.125) / (x + 0.125);\n    //float integral_ratio = floor(ratio);\n    // float remainder = floor(mod(y + 1.0, x + 0.125)); //y - x * integral_ratio;\n    float remainder = floor(mod(floor(y), floor(x + 1.0))); //y - x * integral_ratio;\n    \n    vec4 shade = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    if (mod(y, vert_pos) < 1.0 && abs(y / (vert_pos) - x) < 1.0) {\n        shade = vec4(0.2, 2.0, 0.2, 1.0);\n    }\n    \n   \n    //float remainder = floor(mod(y, x));\n    // fragColor = vec4(vec3(step(remainder, 0.5)), 1.0);\n    //fragColor = (vec4(vec3(step(remainder, 1.0)), 1.0) + mix_mouse) * shade;\n    //fragColor = ((vec4(0.0, 0.0, 0.0, 1.0), 1.0) + mix_mouse) * shade;\n    fragColor = (vec4(1.7 * step(remainder, 1.0), 1.7 * step(remainder, 1.0), 1.7 * step(remainder, 1.0), 1.0) + mix_mouse) + shade;\n    \n    \n    /* Semi-working code\n    float repeat = 3.0;\n    float r = 1.0 - mod(y / x + 2.0, repeat);// / repeat);\n    float g = 1.0 - mod(y / x + 1.0, repeat);// / repeat);\n    float b = 1.0 - mod(y / x, repeat);// / repeat);\n    fragColor = vec4(vec3(remainder * step(remainder, 1.0)), 1.0);\n    fragColor *= vec4(r, g, b, 1.0);\n    */\n    \n    \n    //fragColor *= vec4(vec3(remainder), 1.0);\n    \n    /*float odd_x = mod(x, 2.0);\n    \n    fragColor *= vec4(odd_x, 1.0, 1.0, 1.0);\n    \n    float even_x = mod(x + 1.0, 2.0);\n    \n    fragColor *= vec4(1.0, even_x, 1.0, 1.0);*/\n    \n    if (x >= y && mix_mouse.x < 0.01) {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 326, 5580]]}
{"id": "clKGW1", "name": "Interctv*Noise Singularity 2035", "author": "timmaffett", "description": "It doesn't always end up where you expect.\nadded some mouse control and color -tmm\nadded Noise() factor to seed and got intersting result\nmouse x 0->1", "tags": ["experiments"], "likes": 2, "viewed": 224, "published": 3, "date": "1683912994", "time_retrieved": "2024-07-30T17:56:11.041747", "image_code": "// Fork of \"Interactive Starlink 2035TMM\" by timmaffett. https://shadertoy.com/view/clV3Dh\n// 2023-05-12 17:08:40\n\n// Fork of \"Starlink 2035\" by Grendor. https://shadertoy.com/view/dlK3Dz\n// 2023-05-12 16:52:22\n\n//Hash and Noise Functions\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n                        f.y),\n                mix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n                        f.y),\n                f.z);\n\n}\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.72) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(5.0*mouse.y));\n    return uv;\n}\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n#define UV_NOISE_DIV  (13.0/(mouse2.x/mouse2.y))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse2 = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n   \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv = mouseRotZoom(uv);\n    \n    float time = iTime * 0.2;\n    vec3 color = vec3(0.0);\n    for(int i = 0; i < 100; i++)\n    {\n        vec2 seed = vec2(float(i) * 40.33*Noise(vec3(uv.x/UV_NOISE_DIV,uv.y/UV_NOISE_DIV,0.1*time/200.)), float(i) * 1000.0) + time*(0.03 + sin(time*0.001) * 0.03) ;\n        vec2 pos = fract(sin(seed) * 43.5453)-0.55;\n        float HoleDist = length(vec2(0.0) - uv);\n        pos = mix(pos, uv, smoothstep(-2.0, 2.3, HoleDist));\n        float brightness = 0.8 / length(uv - pos);\n        vec3 starColor = vec3(brightness * (0.002 + (abs(sin(time )) * 0.001)));\n        starColor *= sin(time * brightness) * 0.001 + 0.0019;\n        \n        starColor *= 2.0*hsb2rgb( vec3(seed.x, 1.0, 1.0) );\n        color += starColor;\n    }\n    float Hole = (80.3 ) * (length(uv/0.4)-1.0);\n    color = mix(color, vec3(-0.0), Hole);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clKGW1.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[1254, 1364, 1387, 1387, 1512], [1514, 1624, 1646, 1646, 1775], [1777, 1887, 1910, 1910, 2025], [2027, 2137, 2159, 2159, 2287], [2289, 2400, 2421, 2421, 2547], [2549, 2660, 2682, 2682, 2793], [2795, 2905, 2927, 2927, 3045], [3048, 3159, 3180, 3180, 3308], [3310, 3421, 3443, 3443, 3560], [3562, 3671, 3693, 3693, 3826], [3828, 3937, 3958, 3958, 4092], [4094, 4203, 4224, 4224, 4358], [4360, 4469, 4491, 4491, 4610], [4772, 4772, 4796, 4796, 5327], [5399, 5399, 5418, 5418, 5467], [5469, 5469, 5497, 5536, 5705], [5708, 5708, 5735, 5735, 5970], [6022, 6022, 6079, 6079, 7166]]}
{"id": "clV3Dh", "name": "InteractiveColor Starlink 2035", "author": "timmaffett", "description": "It doesn't always end up where you expect.\nadded some mouse control and color -tmm", "tags": ["experiments"], "likes": 0, "viewed": 166, "published": 3, "date": "1683910409", "time_retrieved": "2024-07-30T17:56:11.832632", "image_code": "// Fork of \"Starlink 2035\" by Grendor. https://shadertoy.com/view/dlK3Dz\n// 2023-05-12 16:52:22\n\n// simple mouse rotate and zoom for shader\n#define pi 3.14159265359 \n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 mouseRotZoom(vec2 uv) {\n    // allow mouse zoom and rotate    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0,0.2) : iMouse.xy/iResolution.xy;\n    uv.xy *= r2d(-(mouse.x)*pi*2.);\n    uv *= (1./(5.0*mouse.y));\n    return uv;\n}\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv = mouseRotZoom(uv);\n    \n    float time = iTime * 0.2;\n    vec3 color = vec3(0.0);\n    for(int i = 0; i < 100; i++)\n    {\n        vec2 seed = vec2(float(i) * 40.33, float(i) * 1000.0) + time*(0.03 + sin(time*0.001) * 0.03) ;\n        vec2 pos = fract(sin(seed) * 43.5453)-0.55;\n        float HoleDist = length(vec2(0.0) - uv);\n        pos = mix(pos, uv, smoothstep(-2.0, 2.3, HoleDist));\n        float brightness = 0.8 / length(uv - pos);\n        vec3 starColor = vec3(brightness * (0.002 + (abs(sin(time )) * 0.001)));\n        starColor *= sin(time * brightness) * 0.001 + 0.0019;\n        \n        starColor *= 2.0*hsb2rgb( vec3(seed.x, 1.0, 1.0) );\n        color += starColor;\n    }\n    float Hole = (80.3 ) * (length(uv/0.4)-1.0);\n    color = mix(color, vec3(-0.0), Hole);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clV3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 186, 186, 235], [237, 237, 265, 304, 472], [475, 475, 502, 502, 737], [740, 740, 797, 797, 1736]]}
{"id": "mly3W1", "name": "float pattern3", "author": "blueacryl", "description": "\nTest 3", "tags": ["3dnoise", "perlin"], "likes": 1, "viewed": 166, "published": 3, "date": "1683897323", "time_retrieved": "2024-07-30T17:56:12.719262", "image_code": "float pattern(vec3 p, float time)\n{\n    float r = length(p.xy) * time;\n    float angle = atan(p.y, p.x) + time * 0.2;\n    float z = p.z * sin(time) * 0.1;\n    float color = sin(5.0 * (r - time)) + cos(1.0  + angle) + 100.0 + z;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y - vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    \n    float time = iTime * 999.3;\n\n    vec3 color = vec3(0.0);\n    for(float z = -1.0; z <= 1.0; z += 0.5)\n    {\n        vec3 p = vec3(uv, z);\n        color += cos(pattern(p, time)) * vec3(1.0, 0.5, 0.3);\n        color += sin(pattern(p, time + 0.33)) * vec3(0.3, 0.5, 1.0);\n        color += cos(pattern(p, time + 0.66)) * vec3(0.5, 1.0, 0.3);\n    }\n    color /= 6.0;\n\n    fragColor = vec4(color, 100.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mly3W1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 247], [249, 249, 306, 306, 801]]}
{"id": "clVGRh", "name": "spiderman", "author": "cisemsu", "description": "spiderman", "tags": ["spiderman"], "likes": 3, "viewed": 177, "published": 3, "date": "1683883454", "time_retrieved": "2024-07-30T17:56:14.023775", "image_code": "void XLine(vec2 uv, float ratio, out vec4 fragColor, in vec2 fragCoord){\n  int gridCount = 14;\n  for (int i = 0; i < int(iResolution.x); i+=gridCount)\n      for (int j = 0; j < int(iResolution.y); j+=gridCount)\n          if (uv.x == ((float(i) + 0.5) / iResolution.x) || uv.y == ((float(j) + 0.5) / iResolution.y))\n              fragColor = vec4(0.0,0.0,0.0,1.0);\n}\nvoid spiderman(vec2 uv, float ratio, out vec4 fragColor, in vec2 fragCoord){\n   if (uv.x >= 1.68 && uv.x <=1.71 && uv.y >0.031 && uv.y <0.063)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.68 && uv.x <=1.71 && uv.y >0.063 && uv.y <0.251)\n       fragColor = vec4(1.0,0.0,0.0,1.0);     \n   if (uv.x >= 1.68 && uv.x <=1.71 && uv.y >0.251 && uv.y <0.280)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.68 && uv.x <=1.71 && uv.y >0.280 && uv.y <0.685)\n       fragColor = vec4(1.0,0.0,0.0,1.0);    \n   if (uv.x >= 1.68 && uv.x <=1.71 && uv.y >0.685 && uv.y <0.715)\n       fragColor = vec4(0.0,0.0,0.0,1.0);     \n   if (uv.x >= 1.65 && uv.x <=1.68 && uv.y >0.063 && uv.y <0.094)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.65 && uv.x <=1.68 && uv.y >0.094 && uv.y <0.28)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.65 && uv.x <=1.68 && uv.y >0.28 && uv.y <0.314)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.65 && uv.x <=1.68 && uv.y >0.314 && uv.y <0.685)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.65 && uv.x <=1.68 && uv.y >0.685 && uv.y <0.715)\n        fragColor = vec4(0.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.62 && uv.x <=1.65 && uv.y >0.094 && uv.y <0.158)\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.62 && uv.x <=1.65 && uv.y >0.158 && uv.y <0.314)\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.62 && uv.x <=1.65 && uv.y >0.314 && uv.y <0.344)\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.62 && uv.x <=1.65 && uv.y >0.344 && uv.y <0.656)\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.62 && uv.x <=1.65 && uv.y >0.656 && uv.y <0.684)\n        fragColor = vec4(0.0,0.0,0.0,1.0);      \n   if (uv.x >= 1.589 && uv.x <=1.62 && uv.y >0.158 && uv.y <0.22)\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.589 && uv.x <=1.62 && uv.y >0.22 && uv.y <0.345)\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.589 && uv.x <=1.62 && uv.y >0.345 && uv.y <0.405)\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.589 && uv.x <=1.62 && uv.y >0.405 && uv.y <0.622)\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.589 && uv.x <=1.62 && uv.y >0.622 && uv.y <0.654)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.558 && uv.x <=1.589 && uv.y >0.22 && uv.y <0.375)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.558 && uv.x <=1.589 && uv.y >0.375 && uv.y <0.405)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.558 && uv.x <=1.589 && uv.y >0.405 && uv.y <0.501)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.558 && uv.x <=1.589 && uv.y >0.501 && uv.y <0.591)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.558 && uv.x <=1.589 && uv.y >0.591 && uv.y <0.874)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.525 && uv.x <=1.558 && uv.y >0.279 && uv.y <0.376)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.525 && uv.x <=1.558 && uv.y >0.376 && uv.y <0.655)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.525 && uv.x <=1.558 && uv.y >0.655 && uv.y <0.718)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.525 && uv.x <=1.558 && uv.y >0.718 && uv.y <0.874)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.525 && uv.x <=1.558 && uv.y >0.874 && uv.y <0.905)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.496 && uv.x <=1.525 && uv.y >0.279 && uv.y <0.405)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.496 && uv.x <=1.525 && uv.y >0.405 && uv.y <0.623)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.496 && uv.x <=1.525 && uv.y >0.623 && uv.y <0.654)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.496 && uv.x <=1.525 && uv.y >0.654 && uv.y <0.905)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.496 && uv.x <=1.525 && uv.y >0.905 && uv.y <0.935)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.465 && uv.x <=1.493 && uv.y >0.310 && uv.y <0.622)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.465 && uv.x <=1.493 && uv.y >0.622 && uv.y <0.905)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.465 && uv.x <=1.493 && uv.y >0.905 && uv.y <0.935)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.434 && uv.x <=1.465 && uv.y >0.310 && uv.y <0.470)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.434 && uv.x <=1.465 && uv.y >0.469 && uv.y <0.593)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.434 && uv.x <=1.465 && uv.y >0.593 && uv.y <0.622)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.34 && uv.x <=1.465 && uv.y >0.622 && uv.y <0.935)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.434 && uv.x <=1.465 && uv.y >0.622 && uv.y <0.935)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.21 && uv.x <=1.465 && uv.y >0.935 && uv.y <0.966)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.40 && uv.x <=1.43 && uv.y >0.342 && uv.y <0.438) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.40 && uv.x <=1.43 && uv.y >0.438 && uv.y <0.630) \n       fragColor = vec4(1.0,0.0,0.0,1.0);    \n   if (uv.x >= 1.37 && uv.x <=1.4 && uv.y >0.342 && uv.y <0.375) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.37 && uv.x <=1.4 && uv.y >0.375 && uv.y <0.625) \n       fragColor = vec4(1.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.34 && uv.x <=1.369 && uv.y >0.313 && uv.y <0.342) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.34 && uv.x <=1.369 && uv.y >0.342 && uv.y <0.625) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n   if (uv.x >= 1.31 && uv.x <=1.34 && uv.y >0.280 && uv.y <0.312) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n   if (uv.x >= 1.31 && uv.x <=1.34 && uv.y >0.312 && uv.y <0.622) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.31 && uv.x <=1.34 && uv.y >0.622 && uv.y <0.839) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.31 && uv.x <=1.34 && uv.y >0.839 && uv.y <0.933) \n       fragColor = vec4(1.0,0.0,0.0,1.0);    \n   if (uv.x >= 1.216 && uv.x <=1.31 && uv.y >0.25 && uv.y <0.280) \n       fragColor = vec4(0.0,0.0,0.0,1.0);        \n   if (uv.x >= 1.278 && uv.x <=1.31 && uv.y >0.28 && uv.y <0.563) \n        fragColor = vec4(1.0,0.0,0.0,1.0); \n   if (uv.x >= 1.278 && uv.x <=1.31 && uv.y >0.563 && uv.y <0.813) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.278 && uv.x <=1.31 && uv.y >0.810 && uv.y <0.935) \n      fragColor = vec4(1.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.247 && uv.x <=1.275 && uv.y >0.281 && uv.y <0.528) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.247 && uv.x <=1.275 && uv.y >0.528 && uv.y <0.560) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.215 && uv.x <=1.275 && uv.y >0.716 && uv.y <0.778) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n   if (uv.x >= 1.215 && uv.x <=1.275 && uv.y >0.778 && uv.y <0.935) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.214 && uv.x <=1.247 && uv.y >0.281 && uv.y <0.501) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.214 && uv.x <=1.247 && uv.y >0.281 && uv.y <0.501) \n       fragColor = vec4(1.0,0.0,0.0,1.0);     \n   if (uv.x >= 1.119 && uv.x <=1.247 && uv.y >0.501 && uv.y <0.530) \n       fragColor = vec4(0.0,0.0,0.0,1.0);          \n   if (uv.x >= 1.185 && uv.x <=1.215 && uv.y >0.28 && uv.y <0.314) \n       fragColor = vec4(0.0,0.0,0.0,1.0);      \n   if (uv.x >= 1.185 && uv.x <=1.215 && uv.y >0.314 && uv.y <0.500) \n       fragColor = vec4(1.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.154 && uv.x <=1.215 && uv.y >0.685 && uv.y <0.750) \n       fragColor = vec4(0.0,0.0,0.0,1.0);       \n   if (uv.x >= 1.154 && uv.x <=1.215 && uv.y >0.748 && uv.y <0.905) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n   if (uv.x >= 1.154 && uv.x <=1.215 && uv.y >0.905 && uv.y <0.935) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n   if (uv.x >= 1.154 && uv.x <=1.185 && uv.y >0.310 && uv.y <0.375) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.154 && uv.x <=1.185 && uv.y >0.375 && uv.y <0.501) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.122 && uv.x <=1.151 && uv.y >0.375 && uv.y <0.404) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.122 && uv.x <=1.151 && uv.y >0.404 && uv.y <0.500) \n        fragColor = vec4(1.0,0.0,0.0,1.0);         \n   if (uv.x >= 1.122 && uv.x <=1.151 && uv.y >0.655 && uv.y <0.717) \n        fragColor = vec4(0.0,0.0,0.0,1.0);        \n   if (uv.x >= 1.122 && uv.x <=1.151 && uv.y >0.717 && uv.y <0.874) \n        fragColor = vec4(1.0,0.0,0.0,1.0);      \n   if (uv.x >= 1.122 && uv.x <=1.151 && uv.y >0.874 && uv.y <0.905) \n        fragColor = vec4(0.0,0.0,0.0,1.0);             \n   if (uv.x >= 1.092 && uv.x <=1.122 && uv.y >0.405 && uv.y <0.470) \n        fragColor = vec4(0.0,0.0,0.0,1.0);          \n   if (uv.x >= 1.092 && uv.x <=1.122 && uv.y >0.469 && uv.y <0.532) \n        fragColor = vec4(1.0,0.0,0.0,1.0);      \n   if (uv.x >= 1.092 && uv.x <=1.122 && uv.y >0.532 && uv.y <0.685) \n       fragColor = vec4(0.0,0.0,0.0,1.0);       \n   if (uv.x >= 1.092 && uv.x <=1.122 && uv.y >0.685 && uv.y <0.840) \n       fragColor = vec4(1.0,0.0,0.0,1.0);        \n   if (uv.x >= 1.092 && uv.x <=1.122 && uv.y >0.840 && uv.y <0.872) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.06 && uv.x <=1.09 && uv.y >0.468 && uv.y <0.560) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n   if (uv.x >= 1.06 && uv.x <=1.09 && uv.y >0.560 && uv.y <0.810) \n        fragColor = vec4(1.0,0.0,0.0,1.0);         \n   if (uv.x >= 1.06 && uv.x <=1.09 && uv.y >0.810 && uv.y <0.842) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n   if (uv.x >= 1.03 && uv.x <=1.06 && uv.y >0.560 && uv.y <0.592) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n   if (uv.x >= 1.03 && uv.x <=1.06 && uv.y >0.592 && uv.y <0.750) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n   if (uv.x >= 1.03 && uv.x <=1.06 && uv.y >0.749 && uv.y <0.810) \n       fragColor = vec4(0.0,0.0,0.0,1.0);     \n   if (uv.x >= 0.998 && uv.x <=1.03 && uv.y >0.592 && uv.y <0.749) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n \n}\nvoid spiderman2(vec2 uv, float ratio, out vec4 fragColor, in vec2 fragCoord){\n  if (uv.x >= 0.065 && uv.x <=0.093 && uv.y >0.031 && uv.y <0.063)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.065 && uv.x <=0.093 && uv.y >0.063 && uv.y <0.251)\n       fragColor = vec4(1.0,0.0,0.0,1.0);     \n  if (uv.x >= 0.065 && uv.x <=0.093 && uv.y >0.251 && uv.y <0.280)\n      fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.065 && uv.x <=0.093 && uv.y >0.280 && uv.y <0.685)\n      fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.065 && uv.x <=.093 && uv.y >0.685 && uv.y <0.715)\n      fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.095 && uv.x <=0.127 && uv.y >0.063 && uv.y <0.094)\n       fragColor = vec4(0.0,0.0,0.0,1.0);    \n  if (uv.x >= 0.095 && uv.x <=0.127 && uv.y >0.094 && uv.y <0.28)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.095 && uv.x <=0.127 && uv.y >0.28 && uv.y <0.314)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.095 && uv.x <=0.127 && uv.y >0.314 && uv.y <0.685)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.095 && uv.x <=0.127 && uv.y >0.685 && uv.y <0.715)\n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.127 && uv.x <=0.156 && uv.y >0.094 && uv.y <0.158)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.127 && uv.x <=0.156 && uv.y >0.158 && uv.y <0.314)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.127 && uv.x <=0.156 && uv.y >0.314 && uv.y <0.344)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.127 && uv.x <=0.156 && uv.y >0.344 && uv.y <0.656)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.127 && uv.x <=0.156 && uv.y >0.656 && uv.y <0.684)\n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.158 && uv.x <=0.188 && uv.y >0.158 && uv.y <0.22)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.158 && uv.x <=0.188 && uv.y >0.22 && uv.y <0.345)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.158 && uv.x <=0.188 && uv.y >0.345 && uv.y <0.405)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.158 && uv.x <=0.188 && uv.y >0.405 && uv.y <0.622)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.158 && uv.x <=0.188 && uv.y >0.622 && uv.y <0.654)\n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.19 && uv.x <=0.22 && uv.y >0.22 && uv.y <0.375)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.19 && uv.x <=0.22 && uv.y >0.375 && uv.y <0.405)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.19 && uv.x <=0.22 && uv.y >0.405 && uv.y <0.501)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.19 && uv.x <=0.22 && uv.y >0.501 && uv.y <0.591)\n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.19 && uv.x <=0.22 && uv.y >0.591 && uv.y <0.874)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.221 && uv.x <=0.25 && uv.y >0.279 && uv.y <0.376)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.221 && uv.x <=0.25 && uv.y >0.376 && uv.y <0.655)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.221 && uv.x <=0.25 && uv.y >0.655 && uv.y <0.718)\n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.221 && uv.x <=0.25 && uv.y >0.718 && uv.y <0.874)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.221 && uv.x <=0.25 && uv.y >0.874 && uv.y <0.905)\n       fragColor = vec4(0.0,0.0,0.0,1.0);    \n  if (uv.x >= 0.25 && uv.x <=0.279 && uv.y >0.279 && uv.y <0.405)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.25 && uv.x <=0.279 && uv.y >0.405 && uv.y <0.623)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.25 && uv.x <=0.279 && uv.y >0.623 && uv.y <0.654)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.25 && uv.x <=0.279 && uv.y >0.654 && uv.y <0.905)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.25 && uv.x <=0.279 && uv.y >0.905 && uv.y <0.935)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.279 && uv.x <=0.31 && uv.y >0.310 && uv.y <0.622)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.279 && uv.x <=0.31 && uv.y >0.622 && uv.y <0.905)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.279 && uv.x <=0.31 && uv.y >0.905 && uv.y <0.935)\n       fragColor = vec4(0.0,0.0,0.0,1.0);    \n  if (uv.x >= 0.314 && uv.x <=0.345 && uv.y >0.310 && uv.y <0.470)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.314 && uv.x <=0.345 && uv.y >0.469 && uv.y <0.593)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.314 && uv.x <=0.345 && uv.y >0.593 && uv.y <0.622)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.314 && uv.x <=0.405 && uv.y >0.622 && uv.y <0.935)\n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.314 && uv.x <=0.559 && uv.y >0.935 && uv.y <0.966)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.345 && uv.x <=0.377 && uv.y >0.342 && uv.y <0.438) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.345 && uv.x <=0.377 && uv.y >0.438 && uv.y <0.630) \n       fragColor = vec4(1.0,0.0,0.0,1.0);     \n  if (uv.x >= 0.377 && uv.x <=0.405 && uv.y >0.342 && uv.y <0.375) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.377 && uv.x <=0.405 && uv.y >0.375 && uv.y <0.625) \n       fragColor = vec4(1.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.405 && uv.x <=0.438 && uv.y >0.313 && uv.y <0.342) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.405 && uv.x <=0.438 && uv.y >0.342 && uv.y <0.933) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.438 && uv.x <=0.468 && uv.y >0.280 && uv.y <0.312) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.438 && uv.x <=0.468 && uv.y >0.312 && uv.y <0.622) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.438 && uv.x <=0.468 && uv.y >0.622 && uv.y <0.839) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.438 && uv.x <=0.468 && uv.y >0.839 && uv.y <0.933) \n       fragColor = vec4(1.0,0.0,0.0,1.0);    \n  if (uv.x >= 0.468 && uv.x <=0.565 && uv.y >0.25 && uv.y <0.280) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.468 && uv.x <=0.5 && uv.y >0.28 && uv.y <0.563) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.468 && uv.x <=0.5 && uv.y >0.563 && uv.y <0.813) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.468 && uv.x <=0.5 && uv.y >0.810 && uv.y <0.935) \n      fragColor = vec4(1.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.5 && uv.x <=0.532 && uv.y >0.281 && uv.y <0.528) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.5 && uv.x <=0.532 && uv.y >0.528 && uv.y <0.560) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.5 && uv.x <=0.562 && uv.y >0.716 && uv.y <0.778) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.5 && uv.x <=0.562 && uv.y >0.778 && uv.y <0.935) \n       fragColor = vec4(1.0,0.0,0.0,1.0);\n  if (uv.x >= 0.53 && uv.x <=0.56 && uv.y >0.281 && uv.y <0.501) \n       fragColor = vec4(1.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.53 && uv.x <=0.658 && uv.y >0.501 && uv.y <0.530) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.56 && uv.x <=0.59 && uv.y >0.28 && uv.y <0.314) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.56 && uv.x <=0.59 && uv.y >0.314 && uv.y <0.500) \n       fragColor = vec4(1.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.56 && uv.x <=0.625 && uv.y >0.685 && uv.y <0.750) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.56 && uv.x <=0.625 && uv.y >0.748 && uv.y <0.905) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.56 && uv.x <=0.625 && uv.y >0.905 && uv.y <0.935) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.59 && uv.x <=0.625 && uv.y >0.310 && uv.y <0.375) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.59 && uv.x <=0.625 && uv.y >0.375 && uv.y <0.501) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.625 && uv.x <0.656 && uv.y >0.375 && uv.y <0.404) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.625 && uv.x <=0.656 && uv.y >0.404 && uv.y <0.500) \n       fragColor = vec4(1.0,0.0,0.0,1.0);       \n  if (uv.x >= 0.625 && uv.x <=0.656 && uv.y >0.655 && uv.y <0.717) \n       fragColor = vec4(0.0,0.0,0.0,1.0);      \n  if (uv.x >= 0.625 && uv.x <=0.656 && uv.y >0.717 && uv.y <0.874) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.625 && uv.x <=0.656 && uv.y >0.874 && uv.y <0.905) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.656 && uv.x <=0.687 && uv.y >0.405 && uv.y <0.470) \n       fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.656 && uv.x <=0.687 && uv.y >0.469 && uv.y <0.532) \n       fragColor = vec4(1.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.656 && uv.x <=0.687 && uv.y >0.532 && uv.y <0.685) \n       fragColor = vec4(0.0,0.0,0.0,1.0);\n  if (uv.x >= 0.656 && uv.x <=0.687 && uv.y >0.685 && uv.y <0.840) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.656 && uv.x <=0.687 && uv.y >0.840 && uv.y <0.872) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.687 && uv.x <=0.718 && uv.y >0.468 && uv.y <0.560) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.687 && uv.x <=0.718 && uv.y >0.560 && uv.y <0.810) \n       fragColor = vec4(1.0,0.0,0.0,1.0);     \n  if (uv.x >= 0.687 && uv.x <=0.718 && uv.y >0.810 && uv.y <0.842) \n       fragColor = vec4(0.0,0.0,0.0,1.0);  \n  if (uv.x >= 0.718 && uv.x <=0.747 && uv.y >0.560 && uv.y <0.592) \n       fragColor = vec4(0.0,0.0,0.0,1.0); \n  if (uv.x >= 0.718 && uv.x <=0.747 && uv.y >0.592 && uv.y <0.750) \n       fragColor = vec4(1.0,0.0,0.0,1.0); \n  if (uv.x >= 0.718 && uv.x <=0.747 && uv.y >0.749 && uv.y <0.810) \n      fragColor = vec4(0.0,0.0,0.0,1.0);   \n  if (uv.x >= 0.747 && uv.x <=0.780 && uv.y >0.592 && uv.y <0.749) \n      fragColor = vec4(0.0,0.0,0.0,1.0); \n      \n      \n      \n\n\n}\nvoid spider(vec2 uv, float ratio, out vec4 fragColor, in vec2 fragCoord){\nif (uv.x >= 0.874 && uv.x <=0.905 && uv.y >0.345 && uv.y <0.905)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\nif (uv.x >= 0.81 && uv.x <=0.84 && uv.y >0.283 && uv.y <0.345)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\nif (uv.x >= 0.935 && uv.x <=0.965 && uv.y >0.283 && uv.y <0.345)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\nif (uv.x >= 0.84 && uv.x <=0.935 && uv.y >0.248 && uv.y <0.283)\n       fragColor = vec4(0.0,0.0,0.0,1.0);    \nif (uv.x >= 0.84 && uv.x <=0.935 && uv.y >0.189 && uv.y <0.248)\n       fragColor = vec4(101.0/255.,67.0/255.,33.0/255.,1.0);  \nif (uv.x >= 0.935 && uv.x <=0.968 && uv.y >0.189 && uv.y <0.248)\n       fragColor = vec4(0.0,0.0,0.0,1.0);       \nif (uv.x >= 0.968 && uv.x <=0.997 && uv.y >0.220 && uv.y <0.252)\n       fragColor = vec4(0.0,0.0,0.0,1.0);       \nif (uv.x >= 0.809 && uv.x <=0.839 && uv.y >0.189 && uv.y <0.248)\n       fragColor = vec4(0.0,0.0,0.0,1.0);       \nif (uv.x >= 0.780 && uv.x <=0.809 && uv.y >0.220 && uv.y <0.252)\n       fragColor = vec4(0.0,0.0,0.0,1.0);     \nif (uv.x >= 0.750 && uv.x <=0.780 && uv.y >0.252 && uv.y <0.313)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \nif (uv.x >= 0.997 && uv.x <=1.027 && uv.y >0.252 && uv.y <0.313)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \nif (uv.x >= 0.967 && uv.x <=1.027 && uv.y >0.158 && uv.y <0.19)\n       fragColor = vec4(0.0,0.0,0.0,1.0);      \nif (uv.x >= 0.750 && uv.x <=0.809 && uv.y >0.158 && uv.y <0.19)\n       fragColor = vec4(0.0,0.0,0.0,1.0);         \nif (uv.x >= 0.718 && uv.x <=0.747 && uv.y >0.187 && uv.y <0.22)\n       fragColor = vec4(0.0,0.0,0.0,1.0);     \nif (uv.x >= 1.03 && uv.x <=1.058 && uv.y >0.187 && uv.y <0.22)\n       fragColor = vec4(0.0,0.0,0.0,1.0);     \nif (uv.x >= 0.998 && uv.x <=1.028 && uv.y >0.065 && uv.y <0.093)\n       fragColor = vec4(0.0,0.0,0.0,1.0);       \nif (uv.x >= 0.935 && uv.x <=0.997 && uv.y >0.093 && uv.y <0.125)\n       fragColor = vec4(0.0,0.0,0.0,1.0);   \nif (uv.x >= 0.905 && uv.x <=0.935 && uv.y >0.125 && uv.y <0.19)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \nif (uv.x >= 0.839 && uv.x <=0.87 && uv.y >0.125 && uv.y <0.19)\n       fragColor = vec4(0.0,0.0,0.0,1.0);  \nif (uv.x >= 0.78 && uv.x <=0.842 && uv.y >0.093 && uv.y <0.125)\n       fragColor = vec4(0.0,0.0,0.0,1.0);     \nif (uv.x >= 0.75 && uv.x <=0.78 && uv.y >0.065 && uv.y <0.093)\n       fragColor = vec4(0.0,0.0,0.0,1.0);   \nif (uv.x >= 0.874 && uv.x <=0.905 && uv.y >0.093 && uv.y <0.127)\n       fragColor = vec4(0.0,0.0,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; \n    XLine(uv, 1.0, fragColor, fragCoord);\n    \n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    spiderman(uv,ratio,fragColor, fragCoord);\n    spiderman2(uv,ratio,fragColor, fragCoord);\n    spider(uv,ratio,fragColor, fragCoord); \n    \n    \n    vec2 uv2 = fragCoord/iResolution.xy; \n    XLine(uv2, 1.0, fragColor, fragCoord);\n          \n       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 442, 442, 10408], [10409, 10409, 10486, 10486, 20090], [20091, 20091, 20164, 20164, 22607], [22609, 22609, 22665, 22715, 23124]]}
{"id": "Dty3zh", "name": "Interactive Fractal Folding!", "author": "ShelbyLynn", "description": "Sampling: Hold B to increase smoothness, N to decrease smoothness\nMoving: Arrow keys as well as W/S to move around camera\nCamera: Z/X to adjust focal distance, C/V to adjust aperature \nANGLES: 1/2, 3/4, 5/6\nJULIA: 7/8, 9/0, -/=\nSCALARS: R/F, T/G, Y/H,U/J\n", "tags": ["mandelbulb", "dof", "pathtracing", "de", "rt", "mc"], "likes": 14, "viewed": 344, "published": 3, "date": "1683855154", "time_retrieved": "2024-07-30T17:56:15.059006", "image_code": "// for font https://www.shadertoy.com/view/stVBRR\n#define C(c) O += char(U,64+c).x ; U.x-=.5\n\n#define LF (U.y++)\n#define CR (U.x = (( uv.x - position.x)*64.0/FontSize))\n#define NL (CR,LF)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 uv )\n{\n    \n    if (texelFetch(iChannel1, ivec2(3, 0), 0).r > 0. && 1. - (uv.y / iResolution.y) < 0.2) {\n        \n        //vec3 srgb = ;\n        //vec3 srgb = post_process(col / float(SAMPLES));\n        // Output to screen\n        O = vec4(0.,0.,0.,1.);\n\n    \n        uv /= iResolution.y;\n        float FontSize = 2.5;\n        vec2 position = vec2(0,1.0 - FontSize / 64.0);\n        vec2 U = ( uv - position)*64.0/FontSize;\n        NL;U.x-=.5;U.x-=.5;\n\n        C(3);C(1);C(13);U.x-=.5;C(24);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(0, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);C(1);C(13);U.x-=.5;C(25);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(1, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);C(1);C(13);U.x-=.5;C(26);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(2, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(6);C(4);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(5, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(1);C(16);C(20);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(6, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);C(21);C(6);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(7, 0), 0).r).xxxx;NL;U.x-=.5;U.x-=.5;\n        C(1);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(8, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(9, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(10, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(4);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(11, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(1);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(12, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);U.x-=.5;\n            O +=    pFloat(U, texelFetch(iChannel1, ivec2(13, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(14, 0), 0).r).xxxx;NL;U.x-=.5;U.x-=.5;\n        C(1);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(15, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(2);U.x-=.5;\n            O +=   pFloat(U, texelFetch(iChannel1, ivec2(16, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        C(3);U.x-=.5;\n            O +=  pFloat(U, texelFetch(iChannel1, ivec2(17, 0), 0).r).xxxx;U-=vec2(1.,0.)*12.0/FontSize;\n        O = vec4(O.xyz, 1.);\n            \n    } else {\n    vec4 col = texture(iChannel0, uv / iResolution.xy);\n        col /= col.w;\n        //vec3 srgb = ;\n        //vec3 srgb = post_process(col / float(SAMPLES));\n        // Output to screen\n        O = vec4(post_process(col.xyz),1.);\n    }\n    \n    \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 getCoord() {\n    return vec3(\n    \ttexelFetch(iChannel1, ivec2(0, 0), 0).r,\n        texelFetch(iChannel1, ivec2(1, 0), 0).r,\n        texelFetch(iChannel1, ivec2(2, 0), 0).r\n    );\n}\n\nvec2 getAngle() {\n    return vec2(\n    \ttexelFetch(iChannel1, ivec2(3, 0), 0).r,\n        texelFetch(iChannel1, ivec2(4, 0), 0).r\n    );\n}\n\nfloat getAperture() {\n    return (\n    \ttexelFetch(iChannel1, ivec2(6, 0), 0).r\n    );\n}\n\nfloat getFocal() {\n    return (\n    \ttexelFetch(iChannel1, ivec2(5, 0), 0).r\n    );\n}\n\n\n\n\nInputs getInputs() {\n    Inputs outputs;\n    outputs.a = vec4(\n    \ttexelFetch(iChannel1, ivec2(8, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(9, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(10, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(11, 0), 0).r\n    );\n    outputs.b = vec3(\n        texelFetch(iChannel1, ivec2(12, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(13, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(14, 0), 0).r\n    );\n    outputs.j = vec3(\n        texelFetch(iChannel1, ivec2(15, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(16, 0), 0).r,\n    \ttexelFetch(iChannel1, ivec2(17, 0), 0).r\n    );\n    return outputs;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rand =  uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    //float t = iMouse.x / iResolution.x * 2. - 1.;\n    vec2 mp = iMouse.xy / iResolution.xy;\n    //float t = ((1. - (iMouse.x / iResolution.x)) * 2. - 1.) * PI + PI_2;\n    float t = (iMouse.x / iResolution.x) * 6.;\n    float t2 = (iMouse.y / iResolution.y);\n    //vec3 ro = -mix(1.,1.2,t) * vec3(abs(cos(t)*cos(t)),mix(0.0,-0.1,t)-abs(sin(t) * sin(t)) * 0.5,1. + abs(sin(t) * sin(t)));\n    //vec3 o = 5. * vec3(mp.x,0.0,mp.y);\n    vec3 p = getCoord();\n    \n    //vec3 o = (t+1.) * vec3(-1.,0.,-1.);\n    \n    vec3 wu = vec3(0., 1., 0.);\n    //vec3 la = vec3(cos(t), t2 * 2. - 0.3 ,sin(t));\n    vec2 ang = getAngle();\n    //vec3 la = normalize(vec3(cos(ang.y)*sin(ang.x),sin(ang.y) * sin(ang.x),cos(ang.x)));\n    vec3 o = vec3(p.x,p.y,p.z);\n    vec3 la = (vec3(0.,0.0,0.));\n    vec3 cf = normalize(la - o);\n    vec3 cr = cross(wu, cf);\n    vec3 cu = cross(cf, cr);\n    \n    \n    \n    \n    vec3 col = vec3(0.);\n    int s = 0;\n    //vec4 old = texture(iChannel0, fragCoord / iResolution.xy);\n   //while (s < 1) {\n        vec2 offset = plastic(int(texture(iChannel0, fragCoord / iResolution.xy).w) + iFrame);\n        vec2 uv =  1.25*((fragCoord + 0.5 + offset)/iResolution.xy - 0.5);\n        uv.y *= iResolution.y / iResolution.x;\n        \n        vec3 sp =  cr * uv.x + cu * uv.y;\n        \n        float fd = (getFocal())*dot(normalize(sp +cf), cf);\n       // uv *= fd;\n        //sp =  cr * uv.x + cu * uv.y;\n        float apt_r =getAperture();\n\n        float r = fsqrt(random_float_01(rand)) * apt_r;\n        float theta = random_float_01(rand) * 2.f * PI;\n        //vec2 aps = vec2(0.);\n        //if (texelFetch(iChannel1, ivec2(7, 0), 0).r <= 0.9) {\n        //    aps = 2.*(plastic(int(texture(iChannel0, fragCoord / iResolution.xy).w)+ abs(int(hash(rand))%int(iFrameRate))+iFrame)-0.5) ;\n       // } else {\n        //    aps = 2.*(plastic(int(texture(iChannel0, fragCoord / iResolution.xy).w)+iFrame)-0.5);\n        //}\n        //vec2 ap = map_disk_lookup(aps) ;\n       // vec2 apt_o = apt_r * (ap.x)*vec2( cos(ap.y),sin(ap.y));\n        //if (fragCoord.y / iResolution.y > 0.5) {\n          vec2  apt_o = vec2(cos(theta),sin(theta)) * r;\n        //}\n        vec3 aperature = (cr * apt_o.x+cu * apt_o.y);\n\n        vec3 sensor =  (sp + cf * fd) ;\n\n        vec3 ro = sensor  + o + aperature;\n        vec3 rd = normalize( sensor - aperature  );  \n        \n        //col += skybox_test(ro, rd);\n        vec4 new_c = vec4(rt(getInputs(), rand, ro, rd) ,1.);\n       if (iMouse.z > 0. && iMouse.w > 0.) {\n           fragColor = new_c;\n        } else {\n        float s = texelFetch(iChannel1, ivec2(7, 0), 0).r;\n            fragColor = ( s*texture(iChannel0, fragCoord / iResolution.xy))+( new_c);\n        }\n        //s += 1;\n    //}\n    \n    // Output to screen\n    //fragColor = vec4(srgb,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_STEPS 64\n#define STOP_DIST 0.002\n#define NORM_SCALE 0.000001\n#define MAX_DIST 16.\n\n#define AO_STEPS 8\n#define AO_SCALE 0.1\n\n#define SHADOW_STEPS 32\n#define SHADOW_SOFT 5.\n\n#define BOUNCES 0\n#define ROUGHNESS 0.1\n#define SAMPLES 1\n\n#define EXPOSURE 4.4\n#define GAMMA 2.2\n\n#define PI   3.1415926535\n#define PI_2 1.5707963267\n\n// Set to 32 or higher for more clarity\n#define FOLD_STEPS 10\n\nfloat linear_rgb_c(float v) {\n  if (v <= 0.04045) {\n    return (v / 12.92);\n  }\n  else {\n    return pow((v + 0.005) / 1.055f, 2.4);\n  }\n}\n\nvec3 linear_rgb(vec3 rgba) {\n  return pow(rgba, vec3(2.2));\n}\n#define R_2_2 1.0f / 2.2f\nvec3 nonlinear_rgb(vec3 rgb) {\n    return pow(rgb, vec3(R_2_2));\n}\n\nvec3 rgb_to_xyz(vec3 rgba) {\n  vec3 srgb = linear_rgb(rgba);\n  return vec3(\n    dot(vec3(0.4124564, 0.3575761, 0.1804375), srgb),\n    dot(vec3(0.2126729, 0.7151522, 0.0721750), srgb),\n    dot(vec3(0.0193339, 0.1191920, 0.9503041), srgb));\n}\n\nvec3 xyz_to_rgb(vec3 xyz) {\n  return nonlinear_rgb(\n    vec3(dot(vec3(3.2404542, -1.5371385, -0.4985314), xyz),\n      dot(vec3(-0.9692660, 1.8760108, 0.0415560), xyz),\n      dot(vec3(0.0556434, -0.2040259, 1.0572252), xyz)));\n}\n\nstruct Inputs {\n    vec4 a;\n    vec3 b;\n    vec3 j;\n};\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fsqrt(float x) {\n    float c = 1.41421356237;\n    float x0 = c * x;\n    float nx = 0.5*(x0 + (x / x0));\n    return 0.5*(nx + (x / nx));\n}\n\nfloat flength(vec3 p) {\n    float s = max(max(abs(p.x),abs(p.y)), abs(p.z));\n    vec3 np = p / s;\n    return fsqrt(dot(np,np)) * s;\n}\n\n\nfloat atan2(float y, float x) {\n    return atan(y / (x+0.000001)) + (PI_2*sign(y)*sign(x)*(sign(x) - 1.));\n}\n// 315, 45, 135, 225\n#define pi_7_4 PI * 7. / 4.\n#define pi_1_4 PI * 1. / 4.\n#define pi_3_4 PI * 3. / 4.\n#define pi_5_4 PI * 5. / 4.\nvec2 map_disk_lookup(vec2 p) {\n    float theta = atan2(p.y, p.x);\n    float radius = fsqrt(p.x * p.x + p.y * p.y);\n    if (pi_7_4 < theta && theta < pi_1_4) {   \n         return vec2(p.x,pi_1_4 * (p.y / p.x));\n    } else if (pi_1_4 < theta && theta <= pi_3_4) {\n         return vec2(p.y,pi_1_4 * (2. - (p.x / p.y)));\n    } else if (pi_3_4 < theta && theta <= pi_5_4) {\n         return vec2(-p.x,pi_1_4 * (4. + (p.y / p.x)));\n    } else {\n         return vec2(-p.y,pi_1_4 * (6. - (p.x / p.y)));\n    }\n}\n\nvec4 box_fold(vec4 z, float l) {\n    return vec4(clamp(z.xyz, -l, (l))* 2. - z.xyz, z.w) ;\n}\n\nvec4 ball_fold(vec4 z, vec2 m) {\n    float r2 = dot(z.xyz, z.xyz);\n    if (r2 < m.x) {\n        return z * m.y / m.x;\n    } else if (r2 < m.y) {\n        return z * m.y / r2;   \n    } else {\n        return z;\n    }\n}\n\nvec2 fold(vec2 p, float theta) {\n    vec2 n = vec2(cos(-theta), sin(-theta));\n    float v = min(0., dot(p, n));\n    return p - (2. * v * n);\n}\n\n\nvec3 fold3d(vec3 p, vec3 theta) {\n    vec3 np = p;\n    np.xy = fold(np.xy, theta.x);\n    np.xz = fold(np.xz, theta.y);\n    np.yz = fold(np.yz, theta.z);\n    return np;\n}\nvec4 menger(vec3 point, Inputs inputs) {\n    vec3  pos = point * 0.5 + 0.5;\n    //let ( x, y, z) = (pos.0,pos.1,pos.2);\n\n    float xx = abs(pos.x - 0.5) - 0.5;\n    float yy = abs(pos.y - 0.5) - 0.5;\n    float zz = abs(pos.z - 0.5) - 0.5;\n\n    float d1 = max(xx,max(yy,zz));\n    float d = d1;\n    float p = 1.;\n    \n    int i = 0;\n    int steps = 3;\n    while (i < steps) {\n        i += 1;\n        float xa = mod(3. * pos.x * p, 3.) ;\n        float ya = mod(3. * pos.y * p, 3.);\n        float za = mod(3. * pos.z * p, 3.);\n        p *= 3.;\n\n        xx = 0.5 - abs(xa - 1.5);\n        yy = 0.5 - abs(ya - 1.5); \n        zz = 0.5 - abs(za - 1.5);\n\n        d1 = min(max(xx,zz),min(max(xx,yy),max(yy,zz))) / p;\n        d = max(d,d1);\n        \n    }\n    \n    return vec4(1.,1.,1., d * 2.);\n}\n\nvec4 mandelbulb(vec3 p, Inputs inputs) {\n    vec3 c = p.xzy;\n    c.z = -c.z;\n    vec3 z = c;\n     //c = inputs.j;\n    int i = 0;\n    float r = 0.;\n    float dr = 1.;\n    float s = 0.;\n    while (i < 16) {\n        r = dot(z, z);\n        if (r > 16.) break;\n        r = fsqrt(r);\n        float theta = acos(z.z / r);\n        float phi = atan2(z.y, z.x);\n       float r2 = r * r;\n       float r4 = r2 * r2;\n        float r5 = r4 * r;\n        dr = r5*  6. * dr +1.;\n        float zr = r5 * r;\n        theta *= 6.;\n        phi *= 6.;\n        \n        z = zr * vec3(\n            sin(theta) * cos(phi),\n            sin(phi) * sin(theta),\n            cos(theta)\n        ) + c;\n        \n        //z = zr * vec3( cos(phi)*cos(theta), sin(theta), sin(phi) ) + c ;\n        \n        i += 1;\n        s += exp(-r);\n    }\n    r = length(z);\n    float theta = s * PI * 2.;\n    float red = (sin(theta) + 1.0) * 0.5;\n    float blu = (cos(theta) + 1.0) * 0.5;\n    float grn = (red + blu) * 0.5;\n    vec3 color =  clamp(vec3(red, grn, blu), 0.0, 1.0);\n    //color = vec3(1.);\n    return vec4(color, 0.25 * r * log(r) / abs(dr ));\n}\nvec4 mandelbox2(vec3 p, Inputs inputs) {\n    vec3 c = p;\n    vec3 last_z = vec3(0.);\n    vec4 z = vec4(c, 1.);\n    int counter = 0;\n    int min_period = 1;\n    int i = 0;\n    //vec3 point = vec3(0.);\n    float mn = 1000.;\n    float mx = -1000.;\n    float avg = 0.;\n    while (i < FOLD_STEPS) {\n    \n        z.xyz = fold3d(z.xyz, inputs.b * PI * 2.);\n        //z = box_fold(z, inputs.a.z);\n        z.xyz = clamp(z.xyz, -inputs.a.z, inputs.a.z)* 2. - z.xyz;\n        z = ball_fold(z, vec2(inputs.a.x, inputs.a.y));\n        //z.xyz = fold3d(z.xyz, inputs.b);\n        \n        //z = inputs.a.w * ball_fold(box_fold(z, inputs.a.z), vec2(inputs.a.x, inputs.a.y));\n        z.xyz = z.xyz * inputs.a.w + inputs.j;\n        z.w = abs(inputs.a.w) * z.w + 1.;\n        \n        //float nm = flength(z.xyz - c);\n        float nm = flength(c)/flength(z.xyz);\n        if (nm > mx) {mx = nm;}\n        if (nm < mn) {mn = nm;}\n        avg += nm;\n        i += 1;\n    }\n    avg /= float(i);\n    float m = length(z.xyz);\n    float x = m / abs(z.w);\n    //float x2 =  0.1 - abs( sdTorus(z.xyz, vec2(0.,1.1))) ;\n    //vec4 res = menger(0.25*z.xyz, inputs);\n    //return vec4(res.xyz,abs(res.w/z.w));\n    float v = (avg-mn) / (mx-mn);\n    float theta = 4. * v  * PI * 2.;\n    float red = (sin(theta) + 1.0) * 0.5;\n    float blu = (cos(theta) + 1.0) * 0.5;\n    float grn = (red + blu) * 0.5;\n    return vec4(red,grn,blu,x);\n}\n\n\n\nfloat de(vec3 p, Inputs inputs) {\n    return mandelbox2(p, inputs).w;\n}\n\nvec3 set_color(vec3 p, Inputs inputs) {\n    return rgb_to_xyz(mandelbox2(p, inputs).rgb);\n}\nfloat huh(float d) {\n//return STOP_DIST+STOP_DIST * (log(d+1.) / log(2.));// \nreturn STOP_DIST + max(0., 0.01*(1.-exp2(-(d)*0.01)));\n\n    //return STOP_DIST + STOP_DIST * (1. - (1. / (1.+exp(d*d))));\n    //return STOP_DIST * (1. - (1. / (1.+exp(d))));\n}\nfloat trace(Inputs inputs, int steps, float sd, vec3 ro, vec3 rd, vec3 co) {\n    float d = sd;\n    vec3 p = ro + (sd * rd);\n    int s = 0;\n    while (s < steps) {\n        p = ro + (d * rd);\n        float de = de(p, inputs);\n        d += de;\n        if (de < huh(length(p-co)) ) break;\n        if (d > MAX_DIST) break;\n        s+=1;\n    }\n    return d;\n}\n\n\nvec3 ortho(vec3 v)\n{\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n                               : vec3(0.0, -v.z, v.y);\n}\n\n\nvec3 calcNormal( Inputs inputs, float d, vec3 p) // for function f(p)\n{\n    const float h = NORM_SCALE; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*de( p + k.xyy*h, inputs ) + \n                      k.yyx*de( p + k.yyx*h, inputs ) + \n                      k.yxy*de( p + k.yxy*h, inputs ) + \n                      k.xxx*de( p + k.xxx*h, inputs ) );\n}\n\n\nvec3 norm(Inputs inputs, float d, vec3 p) {\n    return normalize(vec3(\n        de(p + vec3(STOP_DIST, 0.,0.), inputs),\n        de(p + vec3(0.,STOP_DIST, 0.), inputs),\n        de(p + vec3(0.,0., STOP_DIST), inputs)\n    ) - d );\n}\n\n// Wang hash\nuint hash(inout uint  state) {\n\tstate = (state ^ 61U) ^ (state >> 16U);\n\tstate = state * 9U;\n\tstate = state ^ (state >> 4);\n\tstate = state * 0x27d4eb2dU;\n\tstate = state ^ (state >> 15);\n\treturn state;\n}\n\nfloat random_float_01(inout uint  state) {\n    return float(hash(state)) / float(0xFFFFFFFFU);\n}\n\nvec3 sphere_rand(inout uint  state) {\n    float z = random_float_01(state) * 2. - 1.;\n    float theta = random_float_01(state) * 2. * PI;\n    float mu2sqrt = fsqrt(1. - (z * z));\n    return vec3(\n        mu2sqrt * cos(theta),\n        mu2sqrt * sin(theta),\n        z\n    );\n}\n\nfloat schlick(float ior, float theta) {\n    float coeff = (1. - ior) / (1. + ior);\n    coeff *= coeff;\n    return coeff + ((1.- coeff)*pow(1. - theta,5.));\n}\n\nfloat ao(Inputs inputs, int steps, float sd, vec3 ro, vec3 rd, vec3 co) {\n    float d = sd ;\n    int i = 0;\n    float mn = 0.;\n    float mx = 0.;\n    while (i < steps) {\n        vec3 p = ro + (rd * float(i + 1) * AO_SCALE);\n        float de = 0.125 * de(p, inputs);\n        float decay = 1. / pow(2.,float(i + 1));\n        mn += de *decay;\n        mx +=  float(i + 1) * AO_SCALE * decay ; \n        \n        i += 1;\n    }\n    return   clamp(mn/mx, 0., 1.);\n}\n\nfloat soft_shadow(Inputs inputs, int steps, float sd, vec3 ro, vec3 rd, vec3 co)\n{\n\tfloat res = 1.0;\n    float d = sd;\n    for( int i=SHADOW_STEPS; i>0; i-- )\n    {\n        vec3 p = ro + rd*d;\n\t\tfloat dist = de(p, inputs);\n        res = min( res, SHADOW_SOFT*dist/d );\n        d += dist;\n        if( res<huh(length(co - p))|| d>MAX_DIST ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n//https://iquilezles.org/articles/fog/\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float d, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -d*1. );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 skybox_test(vec3 ro, vec3 rd) {\n    vec3 sky_dir = normalize(vec3(0.0, 1., 0.));\n    vec3 sun_dir = normalize(vec3(0.0, 0., -1.));\n    \n    float grnrd = max(0., -dot(rd, sky_dir));\n    float skyrd = max(0., dot(rd, sky_dir));\n    float sunrd = max(0., dot(rd, sun_dir));\n    \n    vec3 bmax = vec3( 92., 151., 247.) / 255.;\n    vec3 bmin = pow(bmax, vec3(0.2)) / 3.;\n    \n    vec3 omax = vec3(207., 130., 6.) / 255.;\n    vec3 omin = omax;\n    \n    float sky_pow = pow(skyrd, 0.5);\n    float sun_pow = pow(sunrd, 1.);\n    \n    return \n    sky_pow * mix(5.*mix(omin, bmax, sky_pow ), 5.*mix(bmax, omax, sun_pow), sky_pow);\n    //mix(vec3(0.),\n        //mix(\n            \n            //pow((sun_pow ),8./(sky_pow) )\n        //), pow((sky_pow ), 0.75));\n}\nvec3 rt(Inputs inputs, inout uint rand, vec3 ro, vec3 rd) {\n    vec3 co = ro;\n    vec3 throughput = vec3(1.);\n    //vec3 il = vec3(0.);\n    float t = 1.;\n    vec3 lp = vec3(-t,t, -3.);\n    int b = 0;\n   \n    while (b < BOUNCES+1) {\n        float d = trace(inputs, MAX_STEPS, 0., ro, rd, co);\n        vec3 n = vec3(0.);\n        vec3 p = ro + (rd * d);\n        float tde = de(p, inputs);\n        float rough = ROUGHNESS;\n        float hh = huh(length(co-p));\n        vec3 nrd = rd;\n        if (tde <  hh*MAX_DIST) {\n            n = calcNormal(inputs, tde, p);\n            p += n * hh;\n            \n            vec3 ord = normalize(ro - p);\n            rough = (1. - rough) * mix(0., 1., schlick(1.5, max(0.,-dot(ord, n))));\n            vec3 sphere = sphere_rand(rand);\n            vec3 hemi = sphere * sign(dot(sphere, n));\n            vec3 ray_diff = normalize(hemi);\n            vec3 ray_spec = rd - (2. * n * dot(rd,n));\n            \n            nrd = normalize((1. -rough) * ray_diff + ( rough) * ray_spec);\n            \n            throughput *= pow(max(0., 1.0-acos(dot(nrd,n))/PI),4.);\n            \n            \n            vec3 color = mix(vec3(1.),set_color(p, inputs),1. -  rough);\n            #if (BOUNCES == 0)\n            float ao = ao(inputs, AO_STEPS, STOP_DIST, p, n, co);\n            float soft_shadow = soft_shadow(inputs, SHADOW_STEPS, STOP_DIST, p, nrd, co);\n            color *= soft_shadow;\n            color += 0.1 * vec3( ao);\n            #endif\n            throughput *= (color);\n            \n            //throughput *= mix(color*texture(iChannel0, n).w,vec3(texture(iChannel0, n).xyz),rough)   + 0.2 * ao * color;\n        } else {\n            break;\n        }\n        rd = nrd;\n        if (b > 2) {\n            float pp = max(max(throughput.x, throughput.y), throughput.z);\n            if (random_float_01(rand) > pp) {\n                break;\n            }\n            throughput *= 1. / pp;\n        }\n        ro = p;\n        \n        b+=1;\n    }\n    return throughput*rgb_to_xyz(skybox_test(ro, rd));\n    //return throughput;\n}\n\n#define ACES\n#define ACES_IN  mat3(vec3(0.59719f, 0.35458f, 0.04823f),vec3(0.07600f, 0.90834f, 0.01566f),vec3(0.02840f, 0.13383f, 0.83777f))\n#define ACES_OUT mat3(vec3(1.60475f,-0.53108f,-0.07367f),vec3(-0.10208f,1.10813f,-0.00605f),vec3(-0.00327f,-0.07276f,1.07602f))\nvec3 post_process(vec3 color) {\n    color *= EXPOSURE;\n    #ifdef REINHARDT\n    color = color / (1.f + color);\n    #endif\n    #ifdef EXP_TM\n    color = 1.f - exp2(-color*EXPOSURE);\n    color.xyz = mix(color.xyz, smoothstep(0.f,1.f, color.xyz), .7f);\n    #endif\n    #ifdef ACES\n    vec3 col = (color).xyz * ACES_IN;\n    vec3 a = col * (col + 0.0245786f) - 0.000090537f;\n    vec3 b = col * (0.983729f * col + 0.4329510f) + 0.238081f;\n    color = (a / b) * ACES_OUT;\n    #endif\n    return xyz_to_rgb(color);\n//  return xyz_to_rgb(1. - exp2(-color*EXPOSURE));\n}\n\nfloat tridist(float f) {\n    float o = f * 2. - 1.;\n    float v = o * fsqrt(abs(o));\n    v = max(v, -1.f);\n    return v - sign(o);\n}\nfloat fract_fr(float x) {\n    return x - floor(x);\n}\nvec2 plastic(int s)  {\n    float g = 1.324717957244f;\n    float a1 = 1.f / g;\n    float a2 = 1.f / (g * g);\n    return vec2(\n        tridist(fract_fr(0.5f + a1 * float(s + 1))),\n        tridist(fract_fr(0.5f + a2 * float(s + 1)))\n    );\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}  \n\nfloat plane_intersect(vec3 po, vec3 n, vec3 rd, vec3 ro) {\n    float denom = max(0., -dot(n, rd));\n    if (denom > 0.)\n    {\n        float t = max(0., -dot(po - ro, n)) / denom;\n        if (t >= 0.)\n        {\n            return t;\n        }\n    }\n    return 100.;\n}\n\n", "buffer_b_code": "// Camera pan LEFT/RIGHT\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\n// Camera pan FORWARD/BACK\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\n// Camera pan UP/DOWN\nconst int KEY_W  = 87;\nconst int KEY_S    = 83;\n\n\n// Focal Distance Up/Down\nconst int KEY_Z  = 90;\nconst int KEY_X = 88;\n// Aperature Size Up/Down\nconst int KEY_C  = 67;\nconst int KEY_V = 86;\n// Buffer Flow\nconst int KEY_B  = 66;\nconst int KEY_N = 78;\n\n\n// SCALAR A\nconst int KEY_R  = 82;\nconst int KEY_F = 70;\n// SCALAR B\nconst int KEY_T  = 84;\nconst int KEY_G = 71;\n// SCALAR C\nconst int KEY_Y  = 89;\nconst int KEY_H = 72;\n// SCALAR D\nconst int KEY_U  = 85;\nconst int KEY_J = 74;\n\n// ANGLE 1\nconst int KEY_1  = 49;\nconst int KEY_2 = 50;\n// ANGLE 2\nconst int KEY_3  = 51;\nconst int KEY_4 = 52;\n// ANGLE 3\nconst int KEY_5  = 53;\nconst int KEY_6 = 54;\n\n// JULIA 1\nconst int KEY_7  = 55;\nconst int KEY_8 = 56;\n// JULIA 2\nconst int KEY_9  = 57;\nconst int KEY_0 = 48;\n// JULIA 3\nconst int KEY_MNS  = 173;\nconst int KEY_EQS = 61;\n\nconst int KEY_SPACE = 32;\n\n\nconst float speed = 3.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float outData = 0.0;\n    float initData = 0.0;\n    \n    switch(int(fragCoord.x)) {\n        case 0:\n            // Camera X\n        \toutData = texelFetch(iChannel0, ivec2(0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n            initData =-4.7231;\n        \tbreak;\n        \n        case 1:\n            // Camera Y\n        \toutData = texelFetch(iChannel0, ivec2(1, 0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n        \t\t(iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n            initData = 1.2520;\n        \tbreak;\n        case 2:\n            // Camera Z\n            outData = texelFetch(iChannel0, ivec2(2, 0), 0).r +\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r -\n                    (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r;\n            initData = -4.2027;\n                break;\n        case 3:\n            if (texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).r > 0.) {\n                outData = 1.;\n            } else {\n                outData = -1.;\n            }\n            initData = -1.;\n            break;\n        \n        case 5:\n            // Focal Distance\n            outData = texelFetch(iChannel0, ivec2(5, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_Z, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_X, 0), 0).r;\n           outData = max(0., outData);\n           initData = 1.9004;\n            break;\n        case 6:\n            // Aperature\n            outData = texelFetch(iChannel0, ivec2(6, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_C, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_V, 0), 0).r;\n            outData = max(0.000001, outData);\n            initData = 0.0201;\n            break;\n        case 7:\n            // Buffer Flow\n            outData = texelFetch(iChannel0, ivec2(7, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_B, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_N, 0), 0).r;\n            outData = clamp(outData, 0., 1.);\n            initData = 0.8;\n            break;\n        case 8:\n            outData = texelFetch(iChannel0, ivec2(8, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_R, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_F, 0), 0).r;\n            initData = 0.0;\n            break;\n        case 9:\n            outData = texelFetch(iChannel0, ivec2(9, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_T, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_G, 0), 0).r;\n            initData = 0.0;\n            break;\n        case 10:\n            outData = texelFetch(iChannel0, ivec2(10, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_Y, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_H, 0), 0).r;\n            initData = 0.35;\n            break;\n        case 11:\n            outData = texelFetch(iChannel0, ivec2(11, 0), 0).r +\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_U, 0), 0).r -\n                (iTimeDelta * 0.2) * texelFetch(iChannel1, ivec2(KEY_J, 0), 0).r;\n            initData = 2.25;\n            break;\n        case 12:\n            outData = texelFetch(iChannel0, ivec2(12, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_1, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_2, 0), 0).r;\n            initData =  0.07;\n            break;\n        case 13:\n            outData = texelFetch(iChannel0, ivec2(13, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_3, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_4, 0), 0).r;\n            initData =   0.33;\n            break;\n        case 14:\n            outData = texelFetch(iChannel0, ivec2(14, 0), 0).r +\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_5, 0), 0).r -\n                (iTimeDelta * 0.1) * texelFetch(iChannel1, ivec2(KEY_6, 0), 0).r;\n            initData =  -0.05;\n            break;\n        case 15:\n            outData = texelFetch(iChannel0, ivec2(15, 0), 0).r +\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_7, 0), 0).r -\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_8, 0), 0).r;\n            initData = 0.;\n            break;\n        case 16:\n            outData = texelFetch(iChannel0, ivec2(16, 0), 0).r +\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_9, 0), 0).r -\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_0, 0), 0).r;\n            initData = 1.75;\n            break;\n        case 17:\n            outData = texelFetch(iChannel0, ivec2(17, 0), 0).r +\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_MNS, 0), 0).r -\n                (iTimeDelta * 1.) * texelFetch(iChannel1, ivec2(KEY_EQS, 0), 0).r;\n            initData = -1.5;\n            break;\n    }\n    if (iFrame > 0) {\n        fragColor = vec4(outData, 0.0, 0.0, 1.0);\n        \n    } else {\n        fragColor = vec4(initData, 0.0, 0.0, 1.0);\n    \n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dty3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 216, 216, 386], [904, 928, 958, 958, 1300], [1302, 1302, 1344, 1344, 4219]]}
{"id": "clGGWR", "name": "Many lines", "author": "Slals", "description": "Wanted to create remanant lines, not satisfied by the result yet but the result feels ok", "tags": ["line", "pattern"], "likes": 3, "viewed": 161, "published": 3, "date": "1683836447", "time_retrieved": "2024-07-30T17:56:16.000488", "image_code": "float easeOutQuad(float x) {\n    return 1.0 - (1.0 - x) * (1.0 - x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = vec3(0);\n    \n    float f = 20.0;\n    uv.xy *= f;\n    vec2 ipos = ceil(uv);\n    uv = fract(uv);\n    \n    float t = iTime - ipos.x * 0.02;\n    float fx = sin(t * 2.0 - ipos.x) + 0.4;\n    float dx = 2.0 * cos(2.0 * t - ipos.x);\n    \n    float fadingF = 1.0;\n    if (dx < 1.5) {\n        fadingF = easeOutQuad(fx * 0.5);\n        col += (step(uv.x, min(fx, 1.0)) - step(uv.x + (f / iResolution.y), min(fx, 1.0))) * fadingF;\n    } else\n        col += (step(uv.x, fx) - step(uv.x + (f / iResolution.y), fx));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 70], [72, 72, 129, 129, 751]]}
{"id": "NslfWj", "name": "PITCH BRIGHT", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 4, "viewed": 205, "published": 3, "date": "1683832394", "time_retrieved": "2024-07-30T17:56:16.945961", "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(80000.,80000.), iResolution.y>7200. ? 60. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.1,1.,col);\n    col = pow(col,vec3(.65));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(20,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(5,8, 22.885)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n                        ,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n                        ,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.8)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.01;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<0;\n\tbool lightsilver = section>1 && section<2;\n\tbool lightgreen = section>1;\n\tbool lightpink = section>10&& section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>10);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.5);\n     // motion slowing down during the last section\n\tfloat t2=section!=2?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==10) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>10 && section<13) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>1 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.1:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NslfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 702, 702, 1412]]}
{"id": "DlV3Wz", "name": "发光效果练习", "author": "luckduck", "description": "用一个值除以length函数后就可以得到发光效果，把length换成atan函数也有发光效果\n如果有其他更好的方式欢迎补充~", "tags": ["effect"], "likes": 4, "viewed": 272, "published": 3, "date": "1683821241", "time_retrieved": "2024-07-30T17:56:17.824611", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y; \n\n    float a = atan(uv.x,uv.y)-sin(iTime)*.5;\n    fragColor = vec4(vec3(abs(.05/a)),1.);\n    \n    \n    //直线\n    vec3 l = vec3(length(uv.y));//\n    fragColor += vec4(0.01/l,1.);\n    \n    \n    //空心圆\n    vec3 r = vec3(length(uv));\n    fragColor += vec4(vec3(abs(.05/(r-.5))),1.);\n    \n    \n    //实心圆\n    vec3 r2 = vec3(length(vec2(uv.x-((fract(iTime*2.)*1.)*4.-2.),uv.y)));\n    fragColor += vec4(vec3(.05/r2),1.);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlV3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 559]]}
{"id": "DtK3Dz", "name": "Gas Lakes", "author": "me_123", "description": "Ray traced terrain using bilinear segments and 2d dda width volumetric lakes", "tags": ["heightfield", "realtime", "analytical", "bilinear"], "likes": 18, "viewed": 298, "published": 3, "date": "1683820534", "time_retrieved": "2024-07-30T17:56:18.631454", "image_code": "#define inf 1000.\nvec3 pos, o, n, rdi;\nvec3 getColor() {\n    vec2 cell = floor(o.xy), oldCell = cell;\n    float oldDist = 0.0, boxDist = 0.0, d;\n    vec4 k;\n    vec3 sky = vec3(vec3(2.5, 1.0, 0.5)/(n.z+0.2))*0.05;\n    for (int i = 0; i < 1000; i += 1) {\n        k = texelFetch(iChannel0, ivec2(oldCell+iResolution.xy*0.5), 0);\n        if (o.z+n.z*boxDist > 20. || k == vec4(0)) return sky;\n        if (o.z+n.z*boxDist < max(max(k.x, k.y), max(k.z, k.w))) {\n            vec3 v = o-vec3(oldCell, 0)+n*oldDist;\n            vec2 r = vec2(0.005+n.y*n.x*(k.w-k.z+k.x-k.y), n.y*(v.x*k.w+k.z+k.x*v.x-k.x-k.y*v.x-v.x*k.z)-n.z+k.x*v.y*n.x-n.x*k.x-k.y*v.y*n.x+n.x*k.y+v.y*n.x*k.w-v.y*n.x*k.z);\n            float dk = r.y*r.y-4.*r.x*(v.x*(v.y*(k.x-k.y)+k.y-k.x+v.y*(k.w-k.z))+v.y*(k.z-k.x)+k.x-v.z),dd;\n            dd = (dd=(sqrt(dk)-r.y)/r.x)>0.0?dd*0.5:inf;\n            if (dd < boxDist-oldDist) {\n                d = dd+oldDist;\n                vec2 p = pos.xy+n.xy*d;\n                float gp = get(p, 10);\n                vec3 normall = normalize(vec3((gp-get(vec2(p.x-0.01, p.y), 10))*100.,(gp-get(vec2(p.x, p.y-0.01), 10))*100.,1.0));\n                vec4 l = vec4(k.x,-k.y,-k.z,k.w);\n                vec3 nn = normalize(vec3(k.y-k.x+dot(fract(p.yyyy),l),k.z-k.x+dot(fract(p.xxxx),l),1));\n                float fog = 1.-exp(0.1*pow(4.0, -o.z-5.0-n.z*d)/(n.z*log(4.0)+pow(4.0,-o.z-5.0)/(n.z*log(4.0))));\n                vec3 c0 = mix(vec3(0.3*exp(2.0*dot(-mix(normall, nn, 0.7), normalize(vec3(5, -5, 3))))), 0.7*vec3(10, 1, 0.3)*2.0, fog);\n                return 1.-exp(-mix(c0, vec3(0.7, 0.2, 0.0), 1.-exp(-0.015*d)));\n            }\n        }\n        oldCell = cell, oldDist = boxDist;\n        vec2 plain = -(o.xy-cell-0.5-0.5*sign(n.xy))/n.xy;\n        cell += vec2(equal(plain, vec2(boxDist = min(plain.x, plain.y))))*sign(n.xy);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y,\n    m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n    o = vec3(vec2(iTime, iTime)*10.0, 0);\n    o.z = get(o.xy, 1)+20.0, pos = o;\n    o.xy = fract(o.xy); \n    n = normalize(vec3(1, 1, -1));\n    vec3 px = vec3(normalize(vec2(n.y, -n.x)), 0),\n    py = cross(px, n);\n    n = normalize(n + px*uv.x + py*uv.y);\n    rdi = 1./n;\n    fragColor = vec4(getColor(), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy-iResolution.xy*0.5);\n    p += floor(vec2(iTime, iTime)*10.0);\n    fragColor = vec4(get(p, 6), get(p+vec2(1, 0), 6), get(p+vec2(0, 1), 6), get(p+vec2(1, 1), 6));//vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float v = fract((p3.x + p3.y) * p3.z);\n    return v;\n}\nfloat noise(in vec2 p) {\n    vec2 k = fract(p);\n    vec2 f = floor(p);\n    k = k*k*(3.0-2.0*k);\n    return mix(mix(hash12(f), hash12(f+vec2(1, 0)), k.x),\n               mix(hash12(f+vec2(0, 1)), hash12(f+vec2(1, 1)), k.x), k.y);\n}\nfloat fbm(in vec2 p, in int n) {\n    float v = 0.0;\n    vec2 k = vec2(0.5, 2.0);\n    for (float i = 0.; i < float(n); i += 1.) {\n        v -= pow(noise(p*(k.x*=2.0)+i), 1.5)*(k.y*=0.5);\n    }\n    return v*0.5;\n}\nfloat get(in vec2 p, in int detail) {\n    return pow(fbm(p*0.03, detail), 2.0)*50.-12.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtK3Dz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 56, 56, 1834], [1835, 1835, 1892, 1892, 2329]]}
{"id": "mty3Wz", "name": "amaze_transformations", "author": "z0rg", "description": "Shader workshop for the amaze festival 2023", "tags": ["zef"], "likes": 0, "viewed": 133, "published": 3, "date": "1683812045", "time_retrieved": "2024-07-30T17:56:19.442286", "image_code": "mat2 rot(float a)\n{\n    float c= cos(a);\n    float s= sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv + vec2(sin(iTime*2.)*0.2, sin(iTime)*0.2);\n    uv = uv * 1.5;\n    uv = uv*rot(0.5);\n    vec3 col = vec3(0.,0.,0.);\n\n    \n    if (uv.x > 0.1 && uv.x < 0.5 && uv.y > 0.1 && uv.y < 0.5)\n        col = vec3(61, 137, 156)/255.;\n    else\n        col = vec3(1.,0.,0.);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mty3Wz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 93], [95, 95, 152, 152, 507]]}
{"id": "ctGGDz", "name": "zoomed maze in 3D", "author": "skal", "description": "port of excellent https://twitter.com/kamoshika_vrc/status/1656260144840478720 by @kamoshika\n\nUnrolled and explicited", "tags": ["maze"], "likes": 32, "viewed": 453, "published": 3, "date": "1683796791", "time_retrieved": "2024-07-30T17:56:20.191284", "image_code": "/*\nhttps://twitter.com/kamoshika_vrc/status/1656260144840478720\nfloat i,c=15./PI,d=c,g;\nfor(;i++<99.&&d>1e-4;g+=d){\n  vec3 P=normalize(vec3(FC.xy-r*.5,-r.y))*rotate3D(.9,FC.wzz)*g;\n  P.yz+=1.;\n  vec2 I=ceil(P.xz=vec2(log(d=length(P.xz))-t,atan(P.z,P.x))*c);\n  P.xz-=I;\n  d=max(P.y,(.4-abs(fract((fsnoise(I)<.5?-P.z:P.z)-P.x)-.5))*.7*d/c);\n}\no+=9./i;\n*/\n\nvec3 axis_rotation(vec3 P, vec3 Axis, float angle) {\n  Axis = normalize(Axis);\n  return mix(Axis * dot(P, Axis), P, cos(angle)) + sin(angle) * cross(P, Axis);\n}\n\nfloat fsnoise(vec2 v) {\n  return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 uv = normalize(vec3(fragCoord.xy - 0.5 * iResolution.xy, -iResolution.y));\n  vec3 dir = axis_rotation(uv, vec3(2.,1.,1.), .9);  // view direction\n  vec3 Po = vec3(0., 1., 1.);  // view origin\n  float wall_thickness = 0.4;\n  float scale = 4.0;\n  float luminosity = 0.5;\n  float steps = 0., distance = 0.;\n  while (++steps < 99.) {\n    vec3 P = Po + dir * distance;\n    float l = length(P.xz);\n    // https://www.osar.fr/notes/logspherical/\n    // switch to 'polar' log-spherical coordinates\n    P.xz = vec2(log(l) - iTime, atan(P.z, P.x)) * scale;\n    vec2 I = ceil(P.xz);   // integer part = cell ID\n    P.xz -= I;  // fractional part\n    // the 'maze' itself:\n    float v = abs(fract((fsnoise(I) < .5 ? -P.z : P.z) - P.x) - .5);\n    v = (wall_thickness - v) * luminosity * l / scale;\n    // here, walls are infinitely high, so we cut them with the plane P.y\n    l = max(P.y, v);\n    // advance the marching\n    distance += l;\n    if (l < 1e-4) break;\n  }\n  fragColor = vec4(10. / steps);  // divide by steps => ~AO\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 406, 406, 514], [516, 516, 539, 539, 606], [608, 608, 663, 663, 1688]]}
{"id": "mtGGWR", "name": "oyasumi", "author": "paperluigis", "description": "Recreation of the OMORI bad ending scene.", "tags": ["noisesky"], "likes": 1, "viewed": 166, "published": 3, "date": "1683796619", "time_retrieved": "2024-07-30T17:56:20.963220", "image_code": "const mat2 m = mat2(1.6,1.2,-1.2,1.6);\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\n}\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\nconst vec3 sky_color = vec3(0.03, 0.68, 0.92);\n\n\nvec3 close;\nvec3 your(vec2 eyes) {\n    vec2 offset_bg = vec2(0, -iTime * 0.08);\n    float youll =\n        ((fbm((eyes / 1200.) + offset_bg)*12.) * (fbm((eyes / 850.) + offset_bg*2.)*12.)) +\n        ((fbm((eyes / 690.) + offset_bg)*12.) * (fbm((eyes / 310.) + offset_bg*2.)*12.));\n    return max(sky_color, vec3(youll) * .35 + .65);\n}\nvec3 be(vec2 here) {\n    vec2 offset_hs = vec2(0, -iTime * 0.08) * 5.2;\n    vec3 soon = vec3(0.1, 0.25, 0.5);\n    vec2 ichi = here + offset_hs * iResolution.xy;\n    if(here.x < iResolution.x * 0.02) soon = soon * vec3(4.8, 2.4, 2.7);\n    if(mod(ichi.x, 48.) > 42. || mod(ichi.y, 48.) > 42.) soon = soon * 1.2;\n    return soon * (here.y / iResolution.y + 0.3);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos) {\n    if(pos.x < iResolution.x * .6) {\n        col = vec4(your(pos), 1);\n    } else {\n        col = vec4(be(pos - vec2(iResolution.x * .6, 0)), 1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGGWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 60, 60, 173], [174, 174, 200, 200, 722], [723, 723, 742, 742, 896], [959, 959, 981, 981, 1280], [1281, 1281, 1301, 1301, 1642], [1644, 1644, 1688, 1688, 1842]]}
{"id": "DtGGDz", "name": "Electron 2 - by Fabrice Neyret", "author": "MotionMountain", "description": "Copied from Fabrice's wonderful animation https://www.shadertoy.com/view/DttGzf\nOnly the comments marked \"CS:\" are mine. I tried to understand the code.\nIt is embedded in the web page https://www.motionmountain.net/research.html#et ", "tags": ["antitwisterspin12spinordiracsbelt"], "likes": 6, "viewed": 2683, "published": 3, "date": "1683786270", "time_retrieved": "2024-07-30T17:56:21.861817", "image_code": "// Variant (reach rest configuration) of https://shadertoy.com/view/cld3zX\n// variant2 (uncomment line32) of https://www.shadertoy.com/view/DstXRs\n// 3-knotted axis variant of https://shadertoy.com/view/DdcXRj\n\n#define N true                                                             // display the triangle normal ( green )\n#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))                         // 2D rotation \n#define rot3(P,A,a)  ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )  // 3D rot around an arbitrary axis\n  \n#define L(q) length(q.xy - vec2(1.2,-1.5*sin(clamp(q.z,-1.57,1.57))) ) -.2 // 3-knot cylinders SDF\n//#define L(q) length(q.xy - vec2(1,0)) -.2                                // 3 no-knot cylinders SDF\n#define d(q)  ( min(                                                       \\\n                  min( r= L((q).yzx), N ? g= max(length(q)-1.5,length(q-dot(q,vec3(1./3.))))-.1 : 1e2 ), \\\n                  min( w= L((q).zxy),                                      \\\n                       b= L((q).xyz)                                       \\\n              )    ) )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., w=0.,r=w,b=w,g=w;                      // CS: t=9., w=0. is original, no changes for different numbers\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),                          // ray direction - CS: size of triangle\n          p = vec3(0,0,90), q,a,                                           // marching point along ray - CS: observer position\n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n                            : vec3(-.8,0,0); // vec3(0,1.,0) // vec3(.5,-.5,0)   // CS: original was -.8,0,0 perp view with -12,0,0\n        p.yz *= rot(-M.y),                                                 // camera rotations - CS: and orientation\n        p.xz *= rot(-M.x), \n        D.yz *= rot(-M.y),\n        D.xz *= rot(-M.x); \n\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )                        // march scene - CS: original is O-=.005, changes shading                    \n        q = p,\n#if 1                                                                      // set 0 for no antitwister - CS: 1 makes things rotate\n\n# if 1  // anti-deform with antitwister(0) so as to obtain the \"rest configuration\" at t=4.5\n        a = vec3(sin(0.),0,cos(0.)),                              \n        a = rot3( a, vec3(.71,0,-.71), -3.14/2. ),                           \n        q = rot3( q,a, -3.14 *smoothstep(.05, .6, 1./length(p)) ),\n #endif\n\n        a = vec3(sin(iTime),0,cos(iTime)),                                 // CS: original is  vec3(sin(iTime),0,cos(iTime))\n        a = rot3( a, vec3(.71,0,-.71), 3.14/2. ),                          // variant - CS: comment out to get different rotation axis\n        q = rot3( q,a,                                                     // CS: Attention, there is q here, not p!\n               // 3.14 *smoothstep(8., 0., length(p)) ),                   // the magic is there\n                  3.14 *smoothstep(.05, .6, 1./length(p)) ),\n               // 3.14 ),                                                  // test: rot with no antitwister\n#endif\n        q = rot3( q,vec3(.71,0,-.71), .6 ),                                // make triangle vertical - CS: other sin & cos have no effect           \n     // q = rot3( q,vec3(.71,0,-.71), .955 ), // acos(1/sqrt(3))                                      \n     // J = inverse( mat3( D(p+e) -q, D(p+e.yxy) -q, D(p+e.yyx) -q ) / e.x ), // Jacobian\n        t = d(q),                                                          \n        p += .2*t*D;                                                       // step forward = dist to obj - CS: number changes blackness\n\n    O *= O*O*2.;                                                           // color scheme - CS: white is more white with *6.\n    O *= vec4( t==r, t==g, t==b, 1)*vec4(2,1,2,1) + float(t==w);\n    if (O.a < 0.) O += .9;                                                 // white background - CS: also works in grey with .+= .777\n} \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtGGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ctyGWz", "name": "Kaleidoscope carpet (music)", "author": "jarble", "description": "More awesome trippy stuff.", "tags": ["fractal", "music", "kaleidoscope", "trippy", "carpet"], "likes": 6, "viewed": 231, "published": 3, "date": "1683780192", "time_retrieved": "2024-07-30T17:56:22.695588", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        //if(uv.y>0.) uv.x += .5;\n        //else uv.y += .5;\n        \n        uv =\n            abs(.5+uv+t2*sign(uv.x-uv.y))/1.5\n        ;\n        //uv += sign(uv-uv.yx)/2.+.5;\n        if(uv.y>uv.x) uv = uv.yx;\n        //else k += 1;\n\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        \n        if(t2.y<uv.x)\n        {t2 = t2.yx; uv=uv.yx+iTime/8.;}\n\n        \n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n        ;\n        //uv /= 1.+mod(uv.y,2.);\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return\n        mod(floor(a),b)\n    ;\n}\nvec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  float s1 =\n      4.\n  ;\n  float t=\n      time/pow(2.,fmod(time/4.,3.))\n  ,\n  m1 =\n      fmod(t*pow(2.,fmod(t/4.,3.)),4.)\n  ,\n  m3 = fmod(t*s1/pow(2.,fmod(t/4.,3.))/abs(2.5-m1),s1);\n  t *=\n      s1\n  ;\n  float m2 =\n      1. + fmod((t/s1),s1)\n  ;\n  t /=\n      max(m2,m1+1.)\n  ;\n  float a = 128.*sqrt((1.-sqrt(fract(t)))/s1)*.2\n,\n  nb = pow(2.,m3/2.+7.5)*tempo;\n  return\n      abs(.5-vec2(fract(time*nb*.998/2.),fract(time*nb/2.)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctyGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1084]]}
{"id": "ctGGWz", "name": "Marching Segments", "author": "isaacchurchill", "description": "Uses Inigo Quilez's line segment SDF.", "tags": ["2d", "sdf", "lines", "trippy"], "likes": 6, "viewed": 190, "published": 3, "date": "1683777904", "time_retrieved": "2024-07-30T17:56:23.523374", "image_code": "const float PI = 3.14159265;\n\n// Line segment SDF by Inigo Quilez\n// from https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    const float len = 0.25;\n    const float spacing = 0.5;\n    float t = mod(iTime * 0.5, 2.0 * spacing / len);\n    float dist = 9999999.;\n    for (int i = -10; i <= 10; i++) {\n        for (int j = -1; j <= 1; j++) {\n            float x = floor(t) * len + float(i) * spacing;\n            float y = float(j);\n            y += (float(i % 2 == 0) - 0.5) * 0.3;\n            vec2 a = vec2(x, y);\n            float theta = mod(t, 1.0) * PI;\n            vec2 b = a + vec2(-cos(theta), sin(theta)) * len;\n            dist = min(dist, sdSegment(uv, a, b));\n         }\n    }\n    vec3 col = 0.5 + 0.5*sin(sin(iTime) * 10.0 + dist * 50.0 + vec3(0,1,2));\n//    vec3 col = vec3(float(dist < 0.05));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctGGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 123, 175, 175, 294]]}
{"id": "mtK3zw", "name": "voronoi of the day ", "author": "jonasfrey", "description": "voronoi, use the mouse to have fun", "tags": ["voronoi"], "likes": 5, "viewed": 170, "published": 3, "date": "1683757850", "time_retrieved": "2024-07-30T17:56:24.374100", "image_code": "float f_n_rnd(float n){\n\n    n = fract(n*.1031);\n    n *= n+33.33;\n    n *= n+n;\n    return fract(n);\n    \n}\nvec2 f_o_rnd(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    vec2 o_fccp = o_fc;\n    vec2 o_mc = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    if(iMouse.z == 0.){\n        //float n_amp = sin(iTime*0.002)*2.;\n        //o_mc = vec2(sin(iTime), cos(iTime))*n_amp;\n        o_mc = vec2(fract(iTime*0.2));\n    }\n    vec2 o_mccp = o_mc;\n\n    o_fc *= o_mc.x * 666.;\n    float n_tau =6.2831;\n    float n_amp = 2.;\n    float n_dmin = 1.;\n\n    vec2 o_fcmcdlt = o_fc-o_mc;\n    float n_ang = fract(atan(o_fcmcdlt.y, o_fcmcdlt.x)/n_tau);\n    float n_intensity = clamp(length(o_fccp - o_mccp), 0., 1.);\n    vec2 o_fcf = fract(o_fc)-.5;\n    vec2 o_sclk = vec2(33.);\n    float n_min = floor(o_sclk.x/2.);\n    vec2 o_rnd_min = vec2(0.);\n    for(float n_x = -n_min; n_x <= n_min; n_x+=1.){\n        for(float n_y = -n_min; n_y <= n_min; n_y+=1.){\n            vec2 o_fck = vec2(n_x, n_y);\n            vec2 o_rnd = f_o_rnd(floor(o_fc)+o_fck);\n            vec2 o_amp_rnd = n_amp*o_rnd;\n            n_intensity = n_ang*(1.-length(o_fcmcdlt));\n            vec2 o_dlt = (floor(o_fc)+o_fck)-o_mc;\n            float n_ang = atan(o_dlt.x, o_dlt.y);\n            vec2 o_off = vec2(o_rnd*3.);\n            \n            o_fck += o_off;\n    \n            float n = length(o_fcf-o_fck);\n            n = abs(n-0.01+(sin(iTime+o_rnd.y*10.)*.5+.5));\n            n*= 0.1+(sin(iTime+o_rnd.y*10.)*.5+.5);\n            n = pow(n, 1./2.);\n            n = n * (1.+(sin(iTime)*.5+.5));\n            if(n < n_dmin ){\n                o_rnd_min = o_rnd;\n                n_dmin = n;\n            }\n        }\n    }\n    //fragColor = vec4((sin(iTime)*.5+.5)*10.*(o_rnd_min.y*o_rnd_min.x)*pow(n_dmin, 1.3)*2.);\n    //fragColor = vec4(abs(float(o_rnd_min.x<0.5)*1.-pow(n_dmin, 1./1.1)));\n    //fragColor = vec4(o_rnd_min.x-pow(n_dmin, 1./1.1));\n    float n = abs(n_dmin -.5)*2.;\n\n    fragColor = vec4(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtK3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 108], [109, 109, 131, 131, 265], [266, 266, 323, 323, 2186]]}
{"id": "mtK3Rm", "name": "KochMagic", "author": "oemfoe", "description": "koch kifs", "tags": ["kochkifs"], "likes": 0, "viewed": 42, "published": 3, "date": "1683754530", "time_retrieved": "2024-07-30T17:56:25.194905", "image_code": "mat2 rot(float a){\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 M = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    uv -= 0.5;\n    uv.x *= aspect;\n    \n    uv.x -= 0.25;\n    vec2 c = uv.xy * 2.;\n    uv = vec2(0.);\n    int it = 0;\n    for (int i = 0; i < 50; i++){\n        uv = vec2(\n            uv.x * uv.x - uv.y * uv.y,\n            2. * uv.x * uv.y\n        ) + c;\n        \n        it = i;\n        if (length(uv) > 2.)\n            break;\n    }\n    \n    if (it < 49) {\n        uv = c;\n        uv.x += 0.5;\n    }\n    uv /= 2.;\n    //uv.x += 0.25;\n    \n    \n    \n    uv *= 1.5;\n    float zoom = 1.0;\n    uv /= zoom;\n    float d;\n    float a = 0.8333 * 3.14159;\n    vec2 n = vec2(sin(a), cos(a));\n    uv.x = abs(uv.x);\n    uv.y -= 0.29;\n    uv.x -= 0.5;\n    \n\n    d = dot(uv, n);\n    uv -= n * max(0., d) * 2.;\n    uv.x += 0.5;\n    \n    a = 0.6666 * 3.14159;\n    n = vec2(sin(a), cos(a));\n    uv.x += 0.5;\n    float scale = 1.;\n    \n    for (int i = 0; i < 8; i++) {\n        uv.x -= 0.5;\n        uv *= 3.;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n\n        d = dot(uv, n);\n        uv -= n * min(0., d) * 2.;\n        \n        scale *= 3.;\n    }\n    \n    \n    //col += vec3(uv.x, uv.y, 0.);\n    col += texture(iChannel0, rot(iTime / 20.) * uv / scale * zoom - M).rgb;\n    \n    d = abs(uv.y) + max(0., abs(uv.x) - 1.);\n    //col += smoothstep(0.01 * scale, 0., d);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtK3Rm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 70], [72, 72, 129, 179, 1658]]}
{"id": "DlVGRw", "name": "Quadrilateral Subdivision", "author": "mla", "description": "Iterated quadrilateral subdivision, using skew cuts, randomly placed but always subdividing the longer sides.\nMouse changes how centred the cuts are.", "tags": ["subdivision", "quadrilateral"], "likes": 41, "viewed": 417, "published": 3, "date": "1683731965", "time_retrieved": "2024-07-30T17:56:26.109460", "image_code": "//////////////////////////////////////////////////////////////////\n//\n// Quadrilateral subdivision, mla, 2023\n//\n//////////////////////////////////////////////////////////////////\n\nvec3 getcolor(float h) {\n  if (!key(CHAR_C)) h = pow(h,0.75);\n  if (key(CHAR_H)) h = pow(h,1.75);\n  if (key(CHAR_M)) return vec3(h);\n  if (key(CHAR_X)) return h2rgb(h);\n  vec3 colors[] =\n    vec3[](vec3(0.996078,0.152941,0.0705882),\n           vec3(0.988235,0.376471,0.0392157),\n           vec3(0.984314,0.6,0.00784314),\n           vec3(0.988235,0.8,0.101961),\n           vec3(0.996078,0.996078,0.2),\n           vec3(0.698039,0.843137,0.196078),\n\n           vec3(0.4,0.690196,0.196078),\n           vec3(0.203922,0.486275,0.596078),\n           vec3(0.00784314,0.278431,0.996078),\n           vec3(0.266667,0.141176,0.839216),\n           vec3(0.52549,0.00392157,0.686275),\n           vec3(0.760784,0.0784314,0.376471));\n  vec3 c = colors[int(12.0*h)%12];\n  c = pow(c,vec3(2.2));\n  return c;\n}\n\nfloat uint2float(uint n) {\n  // Visually, both ways give the same results, AFAICT.\n  //return float(n)/exp2(32.0); // The lazy way.\n  float x = uintBitsToFloat((n >> 9) | 0x3f800000u);\n  return x - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float lwidth = 0.0015;\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float px = fwidth(p.x);\n  vec3 col = vec3(0.25);\n  float border = 0.03;\n  float w = iResolution.x/iResolution.y-border;\n  float h = 1.0-border;\n  vec2 a = vec2(-w,h), b = vec2(w,h), c = vec2(-w,-h), d = vec2(w,-h);\n  if (abs(p.x) <= w && abs(p.y) <= h) {\n    uint h = 0x12345678u;\n    int N = 10;\n    for (int i = 0; i < N; i++) {\n      float r0 = uint2float(h);\n      float r1 = uint2float(xorshift(h));\n      vec2 k = vec2(0.2);\n      if (iMouse.x > 0.0) k = 0.5*iMouse.xy/iResolution.xy;\n      r0 = 0.5+k.x*sin(0.1*iTime+2.0*PI*r0);\n      r1 = 0.5+k.y*sin(0.0618*iTime+2.0*PI*r1);\n      // a -- b\n      // |    |\n      // c -- d\n      if (distance(a,b)+distance(c,d) > distance(a,c)+distance(b,d)) {\n        vec2 e = r0*a+(1.0-r0)*b;\n        vec2 f = r1*c+(1.0-r1)*d;\n        if (linedist(p,e,f) > 0.0) { a = e; c = f; }\n        else { b = e; d = f; h ^= 1u; }\n      } else {\n        vec2 e = r0*a+(1.0-r0)*c;\n        vec2 f = r1*b+(1.0-r1)*d;\n        if (linedist(p,e,f) < 0.0) { a = e; b = f; }\n        else { c = e; d = f; h ^= 1u; }\n      }\n      h = ihash(h);\n    }\n    col = getcolor(uint2float(h));\n  }\n  col *= smoothstep(0.0,1.4*px,quaddist(p,a,b,c,d)-lwidth);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\nfloat segment0(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  return segment0(p,a,b);\n  return min(segment0(p,a,b),segment0(p,-a,-b));\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nfloat rand(int n) {\n  uint h = ihash(uint(n));\n  return float(h)/exp2(32.0);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  // x²(3-2x) = 3x²-2x³, f'(x) = 6x-6x² = 6x(1-x)\n  // f'(x) = 1-x², f = 0.5*(3.0*x-x³)\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nfloat quaddist(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d) {\n  return min(min(segment(p,a,b),segment(p,c,d)),\n             min(segment(p,a,c),segment(p,b,d)));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  b = vec2(-b.y,b.x);\n  return dot(p,b);\n}\n\nuint xorshift(uint value) {\n  //return ihash(value);\n  // Xorshift*32\n  // By George Marsaglia: http://www.jstatsoft.org/v08/i14/paper\n  value ^= value << 13;\n  value ^= value >> 17;\n  value ^= value << 5;\n  return value;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[972, 972, 998, 1103, 1176], [1178, 1178, 1230, 1230, 2573]]}
{"id": "dly3zw", "name": "Morphing Voxels [441 chars]", "author": "kishimisu", "description": "this is not a voxel renderer", "tags": ["noise", "grid", "cube", "intersection", "4d", "cubic", "trace", "short", "golf"], "likes": 32, "viewed": 867, "published": 3, "date": "1683720845", "time_retrieved": "2024-07-30T17:56:26.916303", "image_code": "/* Morphing Voxels by @kishimisu (2023) - https://www.shadertoy.com/view/dly3zw\n   [Originally 611 chars, -151 chars by @FabriceNeyret!]                           \n*/\n\n#define T texture(iChannel0, vec3( O+f + O.w++*R + .5 )/32. )     //\n#define N (                                       \\\n    O = floor(f =  vec4(d.z+iTime, iTime, d)     \\\n                 * mat4(1,0,0,2,-1,-1,-2,1,1,0,-1,-1,0,1,1,.6)/2. ), \\\n    f -= O,  f *= f * (3.-f-f),                   \\\n    mix( T, T, f ) ).w \n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec4  R = iResolution.xyzz,\n          r = vec4(F+F, R.yw) - R,\n          P, d, f;\n    \n    for (; tanh( O.a = length( d = .1*floor(P) ) ) + O.a / 1e2 - .75 < N     \n         ; P += ( min(min( f = ( .5*sign(r) + .5 - P+d/.1 ) / r, f.y).x, f.z) + .01/R.y ) * r\n        ); \n          \n    r += length(P)*.2 - r; d/=.1;\n    O = (.6 + cos(r + N + vec4(0,1,2,0)) ) / exp(.06*r);\n}\n\n/*  Technical Details:\n   \n    I got inspired to create this after seeing https://www.shadertoy.com/view/mtyGzD\n    \n    I have no idea how voxels renderer work and I doubt this is the most efficient way\n    to do it.\n    My approach was to trace a ray along a cubic grid using direct box intersection.\n    The ray first starts at (0,0,0) and is inside a cube of size 1. \n    The intersection between the ray and the cube is calculated, then the ray is \n    moved to this new intersection (actually a bit further to make sur the ray is \n    on the other side).\n    Using space repetition, the ray will be translated to the origin before calculating\n    the next box intersection, this way we'll only ever have to check a unit cube \n    located at the origin for each step.\n    \n    Then I use 4d noise (3d + time) to stop the ray depending on a noise value treshold.\n    The noise function is a golfed version of @stubbe's 4D noise.\n    (https://www.shadertoy.com/view/XltSWj)\n*/\n\n/*  Original version [611 chars]:\n    \n#define T(u) texture(iChannel0, (u + p.xy + p.z*z + p.w*w + f.xy + .5)/256.).r,\nfloat n(vec3 a) {\n    a.z += iTime;\n\n    vec2 z = vec2(37, 17), w = vec2(59, 83);\n    vec4 x = vec4(a, iTime) * mat4(0,1,.6,-.4,-1,.36,-.48,-.5,-.6,-.5,.64,.2,.4,.3,.2,.4),\n         p = floor(x), \n         f = fract(x); \n         f *= f * (3.-f-f);\n\n    return mix(  mix(T()  T(z)   f.z), \n                 mix(T(w) T(z+w) f.z),  f.w);\n}\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec3 R   = iResolution,\n         r   = normalize(vec3(F+F, R.y)-R),\n         p   = R-R, q, d;\n\n    for ( float i = 0.; \n          i++ < 3e2 && \n          .15 + length(d = floor(p*.5))*.001 - smoothstep(6., 0., length(d.xy)) < n(d*.1);\n\n        q  = abs(1./r) - (mod(p, 2.) - 1.)/r,\n        p += (min(min(q.x, q.y), q.z) + .01) * r\n    ); \n\n    O = (.9 + cos(length(p)*.1 + n(d) + vec4(0,1,2,0))) / exp(.006*length(p));\n}\n*/", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dly3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 524, 524, 903]]}
{"id": "mty3zw", "name": "cleaner house thing", "author": "ThePlaneGuy45", "description": "raesterizer\na little glitchy\nfor Cesium_137", "tags": ["rasterizer"], "likes": 4, "viewed": 188, "published": 3, "date": "1683719784", "time_retrieved": "2024-07-30T17:56:27.663305", "image_code": "#define FOV 1.0\n#define LIGHT vec3(-0.4, -0.2, -1.0)\n\n\n\n\nfloat[] xcoords = float[](-1.25,0.0,-1.0,1.0,0.0,1.25,-0.5,0.5,0.5,-0.5,-1.0,0.0,-1.25,0.0,1.0,1.25,-1.0,-1.0,1.0,0.0,0.0,1.0,1.0,-1.0,-1.0,1.0,-0.75,0.75,-0.75,-0.5,-0.5,-0.75,0.75,0.5,0.5,0.75,1.0,0.75,1.0,0.75,1.0,1.0,0.75,-0.75,0.75,0.78);\nfloat[] ycoords = float[](1.25,1.25,1.25,1.25,1.25,1.25,1.0,1.0,1.0,1.0,-1.25,-1.25,-1.25,-1.25,-1.25,-1.25,1.0,1.0,1.0,1.0,-1.0,-1.0,1.0,-1.0,-1.0,-1.0,0.75,0.75,0.75,0.75,0.75,-0.75,-0.75,0.75,0.75,0.75,0.0,0.0,0.0,-0.5,-0.5,-0.5,-0.75,-0.75,0.0,-0.5);\nfloat[] zcoords = float[](0.5,1.5,0.5,0.5,1.75,0.5,-1.0,-1.0,0.0,0.0,0.5,1.5,0.5,1.75,0.5,0.5,-1.5,0.5,-1.5,1.5,1.5,0.5,0.5,0.5,-1.5,-1.5,-1.5,-1.5,0.5,-1.0,0.0,-1.5,-1.5,0.0,-1.0,0.5,-1.5,-1.5,-0.5,-1.5,-1.5,-0.5,0.5,0.5,-0.5,-0.5);\nint[] triData1 = int[](2,1,5,4,7,18,17,19,10,14,11,23,15,14,13,12,19,16,20,20,8,5,14,12,20,20,3,12,22,19,23,27,29,29,32,25,17,17,28,27,34,21,37,37,35,35,37,23,26,40,26,9,9,22,41,10,10,35,34,34,42,23,34,29,43,43,17,17,27,27,36,38,33,46,33,36,39,39,46,46,45,45,16,3,43,29,5,5);\nint[] triData2 = int[](3,5,6,2,8,9,18,17,7,13,12,9,16,12,1,2,8,15,21,22,9,1,5,11,18,24,2,4,24,27,18,19,27,30,33,26,27,32,36,28,35,24,38,28,8,7,19,39,25,41,33,34,31,26,42,31,30,30,9,8,39,22,36,31,33,32,25,24,29,44,28,45,46,43,43,45,45,38,42,41,39,42,4,11,44,36,14,16);\nint[] triData3 = int[](1,2,2,6,19,10,7,7,18,12,13,18,12,16,11,4,23,4,22,23,23,13,13,2,24,21,11,15,26,17,20,28,30,31,25,24,32,25,35,35,36,22,28,19,7,30,39,19,33,33,41,31,10,42,26,30,7,27,8,35,22,39,31,36,32,44,24,18,44,32,45,28,40,45,46,43,38,37,41,40,42,46,6,1,36,44,16,6);\n\n\n\n\n\nfloat sign3(vec2 p1, vec2 p2, vec2 p3){\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nfloat inTriangle(vec2 pt, vec2 p1, vec2 p2, vec2 p3){\n    float d1 = sign3(pt,p1,p2);\n    float d2 = sign3(pt,p2,p3);\n    float d3 = sign3(pt,p3,p1);\n    if(d1 < 0.0 && d2 < 0.0 && d3 < 0.0){\n        return 1.0;\n    }\n    else{\n        return 0.0;\n    }\n}\n\nvec3 midPoint(vec3 a, vec3 b, vec3 c) {\n    return mix(c, mix(a, b, 0.5), 2.0 / 3.0);\n}\n\nvec2 rot;\n\nvoid rotate(inout vec3 p) {\n\n    vec3 rp = p; // Rotated Point\n    rp.yz *= rot2(rot.y);\n    rp.xz *= rot2(rot.x);\n    rp.z += 5.0; // Camera Distance\n    p = rp;\n\n}\n\nvec2 project(vec3 p) { // Projection script\n    \n    return p.xy / (FOV * p.z);\n\n}\n\nvec3[3] coords(int offset) { // Get tri data\n\n    vec3 a = vec3(\n        xcoords[triData1[offset] - 1],\n        ycoords[triData1[offset] - 1],\n        zcoords[triData1[offset] - 1]\n    );\n    vec3 b = vec3(\n        xcoords[triData2[offset] - 1],\n        ycoords[triData2[offset] - 1],\n        zcoords[triData2[offset] - 1]\n    );\n    vec3 c = vec3(\n        xcoords[triData3[offset] - 1],\n        ycoords[triData3[offset] - 1],\n        zcoords[triData3[offset] - 1]\n    );\n    \n    return vec3[3](a, b, c);\n\n}\n\nvec3 normal(vec3 p1, vec3 p2, vec3 p3){\n    vec3 n;\n    vec3 v = p2 - p1;\n    vec3 w = p3 - p1;\n    n.x = (v.y*w.z)-(v.z*w.y);\n    n.y = (v.z*w.x)-(v.x*w.z);\n    n.z = (v.x*w.y)-(v.y*w.x);\n    return normalize(n);\n}\n\nfloat calculateIntensity(vec3 p1, vec3 p2, vec3 p3){\n    return clamp(dot(normalize(LIGHT),normal(p1,p2,p3)),0.05,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.25 * iResolution.x / iResolution.y;\n    \n    vec4 tri;\n    tri.w = 10000.0;\n    \n    rot = (iMouse.xy / iResolution.xy) * 8.0 - 4.0;\n    \n    for(int i = 0; i < 88; i++) {\n    \n        vec3 p[3] = coords(i);\n        rotate(p[0]);\n        rotate(p[1]);\n        rotate(p[2]);\n        float dist = midPoint(p[0], p[1], p[2]).z; // Midpoint depth\n        vec2 pr1 = project(p[0]);\n        vec2 pr2 = project(p[1]);\n        vec2 pr3 = project(p[2]);\n        \n        vec3 norm = normal(p[0], p[1], p[2]);\n        \n        if(dot(norm, norm) > 0.0) { // backface culling\n        \n            if(inTriangle(uv - 0.5, pr1, pr2, pr3) == 1.0 && dist < tri.w) { // In triangle and depth sorting\n        \n                tri.rgb = mix(vec3(0.2), vec3(1.0), calculateIntensity(p[0], p[1], p[2]));\n                tri.w = dist;\n        \n            }\n            \n        }\n    \n    }\n    \n    if(tri.w >= 10000.0) {\n    \n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    \n    } else {\n    \n        fragColor = vec4(tri.rgb, 1.0);\n        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mty3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1613, 1613, 1652, 1652, 1728], [1730, 1730, 1751, 1751, 1817], [1819, 1819, 1872, 1872, 2074], [2076, 2076, 2115, 2115, 2163], [2176, 2176, 2203, 2203, 2341], [2343, 2343, 2365, 2386, 2425], [2937, 2937, 2976, 2976, 3152], [3154, 3154, 3206, 3206, 3275], [3277, 3277, 3334, 3334, 4470]]}
{"id": "dlyGzw", "name": "Task_1_algoritms_CD", "author": "pylankina_Ann", "description": "Task_1", "tags": ["task1"], "likes": 0, "viewed": 135, "published": 3, "date": "1683718080", "time_retrieved": "2024-07-30T17:56:28.561903", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord){\nfloat x = fragCoord.x;\nfloat y = fragCoord.y;\nfloat d=x - (113.0* floor(x/113.0));\nfragColor = vec4(0.3901,0.999,0.5904,1.0);\nif(d <54.0){\nfragColor.r = x;\nfragColor.g = y*0.0021;\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyGzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 239]]}
{"id": "DtK3RW", "name": "PBR Path tracer attempt 2-2", "author": "pathtracerenthusiast", "description": "PBR PT, but with a ray marched fractal. I have circular AA available.", "tags": ["pathtracer"], "likes": 6, "viewed": 278, "published": 3, "date": "1683716362", "time_retrieved": "2024-07-30T17:56:29.942214", "image_code": "#define exposure .8\n\nvoid mainImage( out vec4 o, vec2 i ) {\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    o.xyz *= exposure;\n    \n    o.xyz = ACESFilm(o.xyz);\n    o.xyz = linearToSRGB(o.xyz);\n    //initR(i,float(iFrame));\n    //for(int i = 0;i<40;i++) rand();\n    //o = vec4(rand());\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FOV 60.\n#define shutAp .05\n#define blurAmt .001\n#define fcsDist 3.\nconst vec3 rightVec = vec3(1.,0.,0.),\nupVec = vec3(0.,1.,0.),\noutVec = vec3(0.,0.,1.);\n\n#define skyBrightness 1.\n\n#define numLvls 8\n#define spp 1.\n\nconst float dv = 1./tan(d2r(FOV)*.5);\n\nfloat sphDist(vec3 p,float r){\n    return length(p)-r;\n}\n\nfloat boxDist(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\n#define fractalLvls 4\nfloat map(vec3 p,out vec3 col,out float r) {\n    col = vec3(1.);\n    r = .5;\n    vec3 q = vec3(0.,0.,3.5);\n    float d = sphDist(p-q,2.);\n    return d;\n}\n\nvec3 getNor(vec3 p){\n    vec2 k = vec2(1.,-1.);\n    vec4 a;\n    //float d0 = map(p);\n    float h = c_EpsSmall;\n    return normalize(\n        k.xyy*map(p+k.xyy*h,a.xyz,a.w)+\n        k.yyx*map(p+k.yyx*h,a.xyz,a.w)+\n        k.yxy*map(p+k.yxy*h,a.xyz,a.w)+\n        k.xxx*map(p+k.xxx*h,a.xyz,a.w)\n        );\n}\n\nHit worldInt(vec3 ro,vec3 rd,World objs) {\n    Hit h;\n    h.len = -1.;\n    h.type = -1;\n    \n    vec3 col;\n    float r;\n    float dT = 0.;\n    for(int i = 0;i<300;i++){\n        vec3 p = dT*rd+ro;\n        float d1 = map(p,col,r);\n        dT+=abs(d1);\n        if(abs(d1)<c_SurfSmall&&dT>3.*c_SurfSmall) {h.len = dT; break;}\n        if(dT>10.) break;\n    }\n    \n    h.nor = getNor(h.len*rd+ro);\n    \n    h.mat = MatPBR(col,vec3(0.),r,0.);\n    \n    return h;\n}\n\nvec3 getSky(vec3 rd,float t) {\n    return skyBrightness*SRGBToLinear(texture(iChannel1,rd).xyz);\n    //return vec3(.3,.625,.95);\n}\n\nvec3 scatter(out vec3 ro, inout vec3 rd, MatPBR m,vec3 p,in vec3 n){\n    ro = p;\n    float r = m.roughness, met = m.metalness;\n    \n    vec3 N = HSampleGGX(n,r*r);\n    \n    rd = reflect(rd,N);\n    \n    #if 0\n    vec3 F0 = mix(vec3(.04),m.albedo,met);\n    vec3 F = fresnelSchlick(md(N,-rd),F0);\n    return mix(m.albedo,,F);\n    #else\n    return m.albedo;\n    #endif\n}\n\nSphere new(vec3 p,float rad,vec3 alb,float rog,vec3 ems,float met) {\n    return Sphere(p,rad,MatPBR(alb,ems,rog,met));\n}\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n    o = texelFetch(iChannel0,ivec2(i),0);\n    float framespp = float(iFrame)*spp;\n    \n    vec3 ttcol = vec3(0.);\n    \n    for(float j = 0.; j < spp; j++) {\n        initR(i,framespp + j);\n        \n        // 1 for circular AA\n        #if 0\n        vec2 u = rand2();\n        u.y *= 2.*c_PI;\n        vec2 jitter = .8*sqrt(u.x)*vec2(cos(u.y),sin(u.y));\n        \n        vec2 pixT = (-iR+ 2.*(i + jitter)) / iR.y;\n        #else\n        vec2 jitter = 1.5*rand2()-.75;\n        \n        vec2 pixT = (-iR+ 2.*(i + jitter)) / iR.y;\n        #endif\n        vec3 er = normalize(vec3(pixT,dv));\n        \n        float ctime = iTime - rand()*shutAp;\n        \n        // Objects\n        \n        Sphere sphs[c_w_sphs] = Sphere[c_w_sphs](\n        new(vec3(0.,0.,3.5),1.,vec3(1.,.8,.5),.8,vec3(0.),1.),\n        new(vec3(0.,-101.,0.),100.,vec3(1.),.3,vec3(0.),0.),\n        new(vec3(0.,2.5,3.),.75,vec3(.5),.75,vec3(1.),0.)\n        );\n        \n        // Automatic code continues\n        World W;\n        W.sphs = sphs;\n        \n        vec3 rd = er.x*rightVec+ er.y*upVec + er.z*outVec;\n        vec3 ro = vec3(0.);\n        \n        vec3 go = blurAmt*vec3(2.*rand2()-1.,0.);\n        vec3 gd = normalize(er*fcsDist - go);\n        rd = normalize(rd + gd.x*rightVec + gd.y*upVec);\n        ro += go.x*rightVec + go.y*upVec;\n        \n        vec3 col = vec3(0.), mask = vec3(1.), oldNor = rd;\n        \n        for(int k = 0; k < numLvls; k++){\n            // Intersection\n            Hit inter = worldInt(ro,rd,W);\n            \n            // Sky\n            if(inter.len == -1.) {col+=getSky(rd,ctime)*mask;break;}\n            \n            // Data Retrieval\n            MatPBR mat = inter.mat;\n            vec3 p = inter.len*rd+ro;\n            \n            \n            // Coloring, masking, and scattering\n            col += mat.ems*mask;\n            mask *= scatter(ro,rd,mat,p,inter.nor);\n        }\n        \n        ttcol += col;\n    }\n    \n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define c_w_sphs 3\n\n\n#define iR iResolution.xy\n#define c_PI 3.1415926523\n#define c_Inf 3.4028235e38\n#define c_SurfSmall .0003\n#define c_EpsSmall .000001\n#define c_SupSmall \t1.175494351e-38\n\n#define md(a,b) max(0.,dot(a,b))\nconst float c_piover180 = c_PI/180.;\n#define d2r(a) a*c_piover180\n\n//Thanks Dave_Hoskins\nfloat _seed = 0.;\n/*\nfloat rand(){\n    float v = fract(_seed*.1031);\n    v *= v + 33.33;\n    v *= v + v*18.23;\n    //v += 34.35;\n    _seed = v;\n    return fract(v);\n}\n\nvec2 rand2(){\n    vec3 p = fract(_seed*vec3(.1031,.103,.0973));\n    p += dot(p,p.yzx+33.33);\n    vec2 a = (p.xx+p.yz)*p.zy;\n    _seed = a.x+a.y-a.x*a.y+a.x*a.x+a.y*a.y;\n    return fract(a);\n}*/\n/*\nfloat rand() {\n    _seed = (_seed * 27.19 + 27.49) * _seed + 93.73;\n    _seed /= abs(_seed-234.56);\n    //_seed *= (1.+fract(_seed))*abs(90.78-_seed);\n    float a = _seed;\n    //_seed -= 45.54;\n    return fract(a);\n}*/\nfloat rand(){\n    float p = fract(_seed * .1031);\n    p *= p + 23.43;\n    p *= p + p;\n    _seed = p;\n    return fract(p);\n}\n\nvec2 rand2(){\n    return vec2(rand(),rand());\n}\n/*\nvoid initR(vec2 p,float t) {\n    vec3 p3 = vec3(p.y,t,p.x);\n    p3 = fract(p3*.1031);\n    p3 += dot(p3*2.*fract(p3),p3.zyx+32.31);\n    _seed = fract((p3.x+p3.y)*p3.z);\n}*/\nvoid initR(vec2 p,float t){\n    vec3 p3 = vec3(p,t);\n\tp3  = fract(p3 * .1214);\n    p3 += dot(p3, p3.zyx + 41.62);\n    _seed = fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*c_PI;\n    float z = rand()*2.-1.;\n    float r = sqrt(1.-z*z);\n    float x = r*cos(phi), y = r*sin(phi);\n\treturn vec3(x,y,z);\n}\n\nvec3 hemi(vec3 h){\n    vec3 v = uniformVec();\n    return normalize(v-2.*h*md(v,h));\n}\n\n\nstruct MatPBR {\n    vec3 albedo,\n    ems;\n    float roughness,\n    metalness;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rad;\n    MatPBR m;\n};\n\nstruct Hit {\n    float len;\n    vec3 nor;\n    bool ff;\n    MatPBR mat;\n    int type;\n};\n\nstruct World {\n    Sphere sphs[c_w_sphs];\n};\n\n\n\nvec3 LessThan(vec3 f, float val) {\n    return vec3(\n        (f.x < val) ? 1. : 0.,\n        (f.y < val) ? 1. : 0.,\n        (f.z < val) ? 1. : 0.);\n}\n \nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - .055,\n        rgb * 12.92,\n        LessThan(rgb, .0031308)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(((rgb + .055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        LessThan(rgb, 0.04045)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0., 1.);\n}\n\nfloat sphInt(in vec3 ro,vec3 rd,Sphere sph,out bool ff){\n    ro -= sph.pos;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sph.rad*sph.rad;\n    float h = b*b - c;\n    if( h<0. ) return -1.;\n    h = sqrt( h );\n    if(length(ro)<=sph.rad){\n        ff = false;\n        return -b+h;\n    }else{\n        ff = true;\n        return -b-h;\n    }\n}\n\nvec3 orient(vec3 S,vec3 N){\n    vec3 up = abs(N.z) < .999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\n    vec3 tangent = normalize(cross(up,N));\n    vec3 bitangent = cross(N,tangent);\n    return tangent*S.x + bitangent*S.y + N*S.z;\n}\n\n// Generated bu ChatGPT\nvec3 HSampleGGX(vec3 n,float r){\n    float a2 = r*r;\n    float phi = 2.*c_PI*rand();\n    float ry = rand();\n    float cosTheta = sqrt((1.-ry)/(1.+(a2*a2-1.)*ry));\n    float sinTheta = sqrt(1.-cosTheta*cosTheta);\n    \n    vec3 h = vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\n    return orient(h,n);\n}\n\n\nfloat distributionGGX(vec3 N, vec3 H, float r) {\n    float a2 = r*r*r*r;\n    float NdotH  = md(N,H);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float denom = (NdotH2*(a2-1.) + 1.);\n    denom *= c_PI*denom;\n\t\n    return a2/denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float r0) {\n    float r1 = r0 + 1.;\n    float k = r1*r1 / 8.;\n\n    float denom = NdotV*(1. - k) + k;\n\t\n    return NdotV / denom;\n}\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float r){\n    float NdotV = md(N,V);\n    float NdotL = md(N,L);\n    float ggx2  = geometrySchlickGGX(NdotV,r);\n    float ggx1  = geometrySchlickGGX(NdotL,r);\n\t\n    return ggx1*ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1. - F0)*pow(clamp(1.- cosTheta,0.,1.),5.);\n}  \n\n\nvec3 cosineWeighted(vec3 N) {\n    float u1 = rand(), u2 = rand();\n    float r = sqrt(u1),\n    theta = 2.*c_PI*u2;\n    \n    float x = r*cos(theta), y = r*sin(theta),\n    z = sqrt(max(0.,1.-x*x-y*y));\n    \n    return orient(vec3(x,y,z),N);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtK3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 59, 59, 304]]}
{"id": "DtyGzm", "name": "Rainbow rug 2 (music)", "author": "jarble", "description": "Another interesting rug pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 164, "published": 3, "date": "1683708357", "time_retrieved": "2024-07-30T17:56:30.688218", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    vec2 uv1 = uv;\n    //uv.x = mod(uv.x,.5)+.25;\n    uv.x = mod(uv.x,.5);\n    uv.y = mod(uv.y,1.)+1.;\n    for(int k = 0;k<100; k++){\n        uv =\n            abs(-.5-uv-t2*sign(uv.y-uv.x))/1.5-1.\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv-.5).yx\n        ;\n        uv =\n            t2+triangle_wave(uv.yx).yx\n        ;\n        if(uv.y>uv.x||!b)\n        //{t2 = t2.yx; uv=uv.yx;}\n        {\n        col.x =\n            abs((uv.x)+col.x)\n        ;\n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n        }\n        else break;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "//remix of: https://www.shadertoy.com/view/csK3zm\n\n#define fmod(x,y) floor(max(mod(floor((x/2.))*floor(x/2.),y),mod(floor(x/2.),y)))\n#define fmod1(x,y) floor(min(mod(floor((x/2.))*floor(x/2.),y),mod(floor(x/2.),y)))\nvec2 mainSound(int samp, float time){  \n  float tempo = .5;\n  time /= tempo;\n  float s2 = pow(2.,1.+fmod1(time/4.,3.)),\n  s1 = pow(2.,fmod(time*s2*2.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1*2.+1.,2.)),\n  t = time/s1/pow(2.,fmod1(time/5./8.,5.))*2.,\n  t1 = 1.+fmod(t/s1,2.),\n  m4 = fmod1(t*s1/t1,s2),\n  m3 = fmod(t*s1/m1,s2);\n  t *= s1/t1;\n  float m2 = 1. + fmod(t,s1),\n  a = 8.*fract(-t),\n  nb = time*tempo*pow(2.,(m3+m2)/5.+7.5);\n  return abs(abs(1./s1-1./s2)/8.-abs(vec2(sin(nb),cos(nb))))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtyGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1150]]}
{"id": "clG3zw", "name": "glowing balls changing colors", "author": "manji369", "description": "glowing balls with changing colors", "tags": ["colors", "glow"], "likes": 1, "viewed": 162, "published": 3, "date": "1683698006", "time_retrieved": "2024-07-30T17:56:31.523983", "image_code": "\nconst float shapeSize = 0.10;\nconst float shapeCount = 3.00;\nconst float colorSpeed = 0.90;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    uv = 2.0 * (uv - 0.5);\n\n    float time = iTime * colorSpeed;\n    float shapeDist = 0.0;\n    for (float i = 0.0; i < shapeCount; i++) {\n        float angle = 2.0 * 3.14159265 * (i / shapeCount);\n        vec2 shapePos = vec2(cos(angle), sin(angle));\n        shapeDist += shapeSize / length(uv - shapePos);\n    }\n\n    vec3 color = vec3(sin(time), sin(time + 2.0 * 3.14159265 / 3.0), sin(time + 4.0 * 3.14159265 / 3.0));\n    fragColor = vec4(shapeDist * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clG3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 149, 149, 743]]}
{"id": "ctG3zw", "name": "spinning simple shading", "author": "manji369", "description": "A simple rotating pattern loop", "tags": ["simple", "loop", "spinning"], "likes": 1, "viewed": 145, "published": 3, "date": "1683697060", "time_retrieved": "2024-07-30T17:56:32.343791", "image_code": "\nconst float speed = 0.42;\nconst float thickness = 1.00;\nconst float radius = 1.00;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float angle = atan(uv.y, uv.x);\n    float dist = length(uv);\n    float time = iTime * speed;\n    \n    float spinner = smoothstep(thickness, -thickness, abs(mod(angle + time, 2.0 * 3.14159 / 8.0) - 3.14159 / 8.0));\n    float circle = smoothstep(radius + thickness, radius - thickness, dist);\n    \n    float color = circle * spinner;\n    fragColor = vec4(vec3(color), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctG3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 140, 140, 587]]}
{"id": "dsySDK", "name": "Physical Dice", "author": "fenix", "description": "Rigid body dice colliding with the ground (not each other [yet!]). An ode to games and chance.\n\nFeaturing:\nfizzer's Simple and Cheap Dice SDF: https://shadertoy.com/view/csySDG\nwnu's sparkle commented: https://www.shadertoy.com/view/Ndlczs\n\n*mouse: grab*", "tags": ["simulation", "interactive", "shadows", "physics", "dice", "multipass", "rigidbody"], "likes": 20, "viewed": 380, "published": 3, "date": "1683696141", "time_retrieved": "2024-07-30T17:56:33.766986", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Rigid body dice colliding with the ground (not each other [yet!]). An ode to games\n//  and chance. Featuring code from:\n//\n//  The inspiration for this shader, fizzer's excellent\n//\n//      Simple and Cheap Dice SDF:      https://shadertoy.com/view/csySDG\n//\n//  wnu's beautiful\n//\n//      sparkle commented:              https://shadertoy.com/view/Ndlczs\n// \n//  Card suit SDFs were made using my own tool:\n//\n//      Polygon SDF Modelling Tool:     https://shadertoy.com/view/dtBSDw\n//\n//  Dipping my toes into rigid body physics simulation. Contact constraints are resolved\n//  via an iterative accumulation solver, and feature warm starting, restitution,\n//  friction, and position correction.\n//\n//  Dont's miss: mouse can grab and drag/throw dice!\n//\n//  The rendering is a fairly typical voronoi system, from both the camera and light\n//  source perspectives (the latter, for shadows). The shadows were somewhat tricky to\n//  get lined up correctly, and once I did I found a perspective projection was causing\n//  large shadows to be cast by dice passing close to the light source. So I switched to\n//  an orthographic projection and had to line the shadows up again. :P\n//\n//  Continuing with the theme of \"chance\", I figured there was a chance users might not\n//  notice, at least right away, that the dice don't collide with each other. :)\n//\n//  I do intend to keep going on research in this direction, and getting the bodies to\n//  collide against each other is a top priority. I think I just need to figure out some\n//  clever way to address the contact impulses for body pairs. If anyone know of any\n//  papers, shaders, or other prior art I would be very interested.\n//\n//  I have attempted to write clear code and detailed comments. Please let me know if I\n//  should explain anything in more detail.\n//\n// ---------------------------------------------------------------------------------------\n\n#define MSAA 1 // 1 to disable (for more speed), 2 for 2x2, 3 for 3x3, etc.\n\n// from fizzer's Simple and Cheap Dice SDF: https://shadertoy.com/view/csySDG\n// Distance to hemisphere-shaped hole in a plane.\nfloat hole(vec3 p, float r)\n{\n    float c = min(0., length(p.xz) - r);\n    return (p.y > 0.) ? length(vec2(c, p.y)) : r - length(p);\n}\n\n// Die SDF.\nfloat sdDie(vec3 p)\n{\n    // Get index of closest face on die, and local point b.\n    vec3 q = abs(p);\n\n    bvec3 dots = sign(p.z) > 0. ? bvec3(false, true, true) : bvec3(true, true, false);\n    vec3 b = p.xzy * sign(p.z);\n\n    if(q.x > q.y && q.x > q.z)\n    {\n        b = p.zxy * sign(p.x);\n        b.z = -b.z;\n        dots = sign(p.x) > 0. ? bvec3(false, true, false) : bvec3(true, true, true);\n    }\n    else if(q.y > q.z)\n    {\n        b = p.zyx * sign(p.y);\n        dots = sign(p.y) > 0. ? bvec3(false, false, true) : bvec3(false, false, false);\n    }\n    \n    // Some parameteric constants.\n    float r = .02, r2 = .04 ,r3 = .13;\n\n    b.y -= .5 - r;\n    \n    float d;\n\n    if(all(not(dots)))\n    {\n        // Special case for side 6.\n        b.x = abs(b.x);\n        b.z = mod(b.z + .3 / 2., .3) - .3 / 2.;\n        d = hole(b - vec3(.2, 0, 0), r3);\n    }\n    else\n    {\n        // The sides other than 6 have reflective symmetry in two lines.\n        if(b.x > -b.z)\n            b.xz = -b.zx;\n\n        if(b.x > b.z)\n            b.xz = b.zx;\n\n        // Thanks to this symmetry, the presence of only three dots account\n        // for all of the sides. So the effective LUT contains 3 bits per face.\n        if(b.z - b.x > .25)\n            d = dots.y ? hole(b - vec3(-1, 0, +1) / 4., r3) : b.y;\n        else if(-b.x - b.z > .25)\n            d = dots.x ? hole(b - vec3(-1, 0, -1) / 4., r3) : b.y;\n        else\n            d = dots.z ? hole(b, r3): b.y;\n    }\n    \n    // Use sdRoundBox to bevel the outer edges of the die.\n    return max(d - r, sdRoundBox(p, vec3(.5) - r2, r2));\n}\n\n// transform point from world space to body space\nvec3 bodyTrans(fxRigidBody b, vec3 p)\n{\n    return rotateVectorByQuat(p - b.pos, b.rot);\n}\n\nfloat sdBody(fxRigidBody b, vec3 p)\n{\n    p = bodyTrans(b, p);\n    return sdDie(p);\n}\n\nvec3 normBody(fxRigidBody b, vec3 p)\n{\n    float d = sdBody(b, p);\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        float d2d;\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdBody(b,p+0.000001*e);\n    }\n    return normalize(n);\n}\n\nvec3 dieColor(fxRigidBody b, vec3 p)\n{\n    p = bodyTrans(b, p);\n    return mix(vec3(0), vec3(1), smoothstep(.01, .02, sdRoundBox(p, vec3(.38), .1)));\n}\n\nfloat shadow(mat4 invMat, vec3 pos, vec3 lightPos, vec3 lightLeft, vec3 lightUp, int exception)\n{\n    vec3 sp = (invMat * vec4(pos, 1)).xyz;\n    sp.xy /= SHADOW_RES;\n    lightPos -= (lightLeft * sp.x + lightUp * sp.y) * SHADOW_RES;\n\n    vec2 r = iResolution.xy;\n    ivec2 coord = ivec2((sp.xy * vec2(r.y / r.x, 1) + .5) * r.xy);\n    if (coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y)) return 1.;\n\n    ivec4 old = fxGetClosestLight(coord);\n    float maxS = 0.;\n    for (int i = 0; i < 4; ++i)\n    {\n        int id = old[i];\n        if (id < 0) break;\n        if (id == exception) continue;\n        \n        vec3 bodyPos = fxGetBodyData(id, POS).xyz;\n        if (dot(bodyPos - pos, LIGHT_DIR) < 0.) continue;\n\n        vec4 bodyRot = fxGetBodyData(id, ROT);\n        vec3 localDir = rotateVectorByQuat(-LIGHT_DIR, bodyRot);\n        vec3 localOrigin = rotateVectorByQuat(lightPos - bodyPos, bodyRot);\n        float t = boxIntersection(localOrigin, localDir, vec3(.5));\n\n        if (t >= 0.)\n        {\n            maxS = max(maxS, smoothstep(8., 4., bodyPos.y)); // blend in shadows only near the ground\n        }\n    }\n    \n    return 1. - maxS;\n}\n\nvoid renderDie(int id, vec3 ro, vec3 rd, vec3 lightPos, vec3 lightLeft, vec3 lightUp, inout vec3 col, inout float maxT, mat4 invMat)\n{\n    fxRigidBody b = fxGetBody(id);\n    float t = 0.;\n    for(int i = 0; i < 100; ++i)\n    {\n        float d = sdBody(b, ro + rd * t);\n        if(abs(d) < 1e-4 || t > FAR_CLIP)\n            break;\n        t += d;\n    }\n\n    vec3 rp = ro + rd * t;\n        \n    if(t < maxT)\n    {\n        maxT = t;\n        \n        vec3 n = normBody(b, rp);\n        vec3 baseColor = dieColor(b, rp);\n        vec3 rr = reflect(rd, n);\n        vec3 spec = vec3(pow(dot(rr, LIGHT_DIR), 8.));\n        vec3 diff = vec3(0.5 + 0.5 * dot(n, LIGHT_DIR)) + vec3(0.5 + 0.5 * -n.y) * vec3(.1, .1, .2) * 1.5;\n        float fresnel = mix(0.01, .4, pow(clamp(1. + dot(rd, n), 0., 1.), 2.));\n\n        col = mix(baseColor * diff, spec, fresnel);\n\n        col *= shadow(invMat, rp, lightPos, lightLeft, lightUp, id) * .6 + .4;\n    }\n}\n\nconst int NUM_SPADE_VERTS = 11;\nconst vec2 SPADE_VERTS[NUM_SPADE_VERTS] = vec2[](\n    vec2(.0000,-.1333),\n    vec2(.1332,-.1720),\n    vec2(.1933,-.1690),\n    vec2(.2433,-.1353),\n    vec2(.2860,-.0811),\n    vec2(.2968, .0002),\n    vec2(.2738, .0715),\n    vec2(.2293, .1463),\n    vec2(.1500, .2117),\n    vec2(.0588, .2611),\n    vec2(.0000, .3944)\n);\n\nconst int NUM_TAIL_VERTS = 6;\nconst vec2 TAIL_VERTS[NUM_TAIL_VERTS] = vec2[](\n    vec2(.0000,-.3500),\n    vec2(.2077,-.3500),\n    vec2(.1118,-.2711),\n    vec2(.0589,-.2087),\n    vec2(.0158,-.1333),\n    vec2(.0000,-.1033)\n);\n\nconst int NUM_DIAMOND_VERTS = 7;\nconst vec2 DIAMOND_VERTS[NUM_DIAMOND_VERTS] = vec2[](\n    vec2(.0000,-.3655),\n    vec2(.0950,-.2267),\n    vec2(.1982,-.1086),\n    vec2(.3100,-.0011),\n    vec2(.1928, .1059),\n    vec2(.1074, .2135),\n    vec2(.0000, .3522)\n);\n\nconst int NUM_HEART_VERTS = 13;\nconst vec2 HEART_VERTS[NUM_HEART_VERTS] = vec2[](\n    vec2(.0000,-.3722),\n    vec2(.0369,-.3084),\n    vec2(.0724,-.2555),\n    vec2(.1203,-.2160),\n    vec2(.3477,-.0444),\n    vec2(.3898, .0161),\n    vec2(.4069, .0875),\n    vec2(.4051, .1644),\n    vec2(.3766, .2455),\n    vec2(.3350, .3174),\n    vec2(.2614, .3631),\n    vec2(.1659, .3701),\n    vec2(.0000, .3099)\n);\n\n// https://iquilezles.org/articles/distfunctions2d/\n#define DEFINE_POLYGON(X) \\\nfloat sdPolygon(int num, vec2 verts[X], vec2 p) \\\n{ \\\n    float d = dot(p-verts[0],p-verts[0]); \\\n    float s = 1.0; \\\n    for( int i=0, j=num-1; i<num; j=i, i++ ) \\\n    { \\\n        vec2 e = verts[j] - verts[i]; \\\n        vec2 w =    p - verts[i]; \\\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 ); \\\n        d = min( d, dot(b,b) ); \\\n        bvec3 cond = bvec3( p.y>=verts[i].y, \\\n                            p.y <verts[j].y, \\\n                            e.x*w.y>e.y*w.x ); \\\n        if( all(cond) || all(not(cond)) ) s=-s; \\\n    } \\\n    return s*sqrt(d); \\\n}\n\nDEFINE_POLYGON(NUM_SPADE_VERTS)\nDEFINE_POLYGON(NUM_TAIL_VERTS)\nDEFINE_POLYGON(NUM_DIAMOND_VERTS)\nDEFINE_POLYGON(NUM_HEART_VERTS)\n\nfloat sdSpade(vec2 p)\n{\n    p.x = abs(p.x);\n    return min(sdPolygon(NUM_SPADE_VERTS, SPADE_VERTS, p), sdPolygon(NUM_TAIL_VERTS, TAIL_VERTS, p));\n}\n\nfloat sdClub(vec2 p)\n{\n    p.x = abs(p.x);\n    float d = sdPolygon(NUM_TAIL_VERTS, TAIL_VERTS, p);\n    d = min(d, distance(p, vec2(0, .28)) - .18);\n    d = min(d, distance(p, vec2(.15, 0)) - .18);\n    d = min(d, distance(p, vec2(-.15, 0)) - .18);\n    return d;\n}\n\nfloat sdDiamond(vec2 p)\n{\n    p.x = abs(p.x);\n    p.y *= .9;\n    return sdPolygon(NUM_DIAMOND_VERTS, DIAMOND_VERTS, p);\n}\n\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x) * 1.5;\n    return sdPolygon(NUM_HEART_VERTS, HEART_VERTS, p);\n}\n\nfloat sdGround(vec2 p)\n{\n    ivec2 id = ivec2(mod(p, 4.));\n    p = (fract(p) - .5) * vec2(1, 1);\n\n    if (id.y == 0)\n    {\n        if (id.x == 0) return sdHeart(p);\n        if (id.x == 2) return sdClub(p);\n        return sdDiamond(p.yx * vec2(6, 1));\n    }\n    else if (id.y == 2)\n    {\n        if (id.x == 0) return sdSpade(p);\n        if (id.x == 2) return sdDiamond(p);\n        return sdDiamond(p.yx * vec2(6, 1));\n    }\n    if (id.x == 0 || id.x == 2) return sdDiamond(p * vec2(6, 1));;\n    return 1e6;\n}\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel3, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\n// from sparkle commented by wnu: https://www.shadertoy.com/view/Ndlczs\nvec3 glitter(vec3 rayHit, vec3 normal, vec3 camDir, float sh)\n{\n    float t = iTime;\n    vec3 n = normal;\n\n    /////BASE COLOR\n\n    //FRESNEL \n\n    float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n    float edge = sqrt(1.2-pow(fre,1./4.2));\n\n    //PICK YOUR COLOR\n\n    vec3 colorPick = vec3(1);\n\n    //COLOR FROM NORMALS AND FRESNEL\n\n    vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.z + t*0.+  colorPick);\n    float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n    c *= ss;\n\n    ///////GLINTS/GLITTER COMPUTATION\n\n    #define PRIMARY_INTENSITY 1.3\n    #define PRIMARY_CONCENTRATION 2.\n    #define SECONDARY_INTENSITY 8.\n    #define SECONDARY_CONCENTRATION 1.\n\n    // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n    // (7 is probably the smallest I would go)\n\n    float scale = 20.;\n    rayHit = floor(rayHit*scale)/scale;\n\n    vec3 h = normalize(LIGHT_DIR-camDir);\n    float nl = dot(n,LIGHT_DIR);\n\n    vec3 coord = rayHit*.5;\n    coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n    coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n    vec3 coord2 = coord;\n\n    //first layer (inner glints)\n    float pw = .5*((iResolution.x));\n    vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n    aniso -= n*dot(aniso,n);\n    float anisotropy = min(1.,length(aniso));\n    aniso /= anisotropy;\n    anisotropy = .55;\n    float ah = abs(dot(h,aniso));\n    float nh = abs(dot(n,h));\n    float qa = exp2((1.1-anisotropy)*1.5);\n    nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n    nh *= pow( 1.-ah*anisotropy, 10.0 );\n    vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n    //second layer (outer glints)\n    pw = .145*((iResolution.x));\n    vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n    anisotropy = .6;\n    float ah2 = abs(dot(h,aniso2));\n    float nh2 = abs(dot(n,h));\n    float q2 = exp2((.1-anisotropy)*3.5);\n    nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n    nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n    vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n\n    ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n\n    vec3 col = vec3(c)/4.;\n    col += (glints+glints2) * .5 * sh + .3;\n\n    return col*col;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvec3 renderScene(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    fxState state = fxGetState();\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 lightFwd, lightLeft, lightUp, lightPos, lightLookAt;\n    fxLightPath(cameraLookAt, cameraFwd, lightPos, lightLookAt);\n    fxCalcCamera(lightPos, lightLookAt, lightFwd, lightLeft, lightUp);\n\n    mat4 lightMat = fxCalcCameraMat(iResolution, lightLeft, lightUp, lightFwd, lightPos);\n    mat4 invMat = inverse(lightMat);\n\n    float maxT = FAR_CLIP;\n    vec3 col = vec3(0);\n    \n    // render dice\n#if 1 // disable to skip voronoi and render all bodies (slow, ground truth)\n    ivec2 ifc = ivec2(fragCoord);\n    ivec4 old = fxGetClosestCamera(ifc);      \n\n    for (int i = 0; i < 4; ++i)\n    {\n        int id = old[i];\n        if (id < 0) break;\n#else\n    for (int id = 0; id < NUM_BODIES; ++id)\n    {\n#endif\n        renderDie(id, cameraPos, rayDir, lightPos, lightLeft, lightUp, col, maxT, invMat); \n    }\n   \n    // render ground if we missed all the dice\n    if (maxT == FAR_CLIP)\n    {\n        float t = -cameraPos.y / rayDir.y;\n        vec3 hit = cameraPos + rayDir * t;\n        float d = sdGround(hit.xz * .5);\n        const vec3 GREEN = vec3(.05, .2, .05);\n        float sh = shadow(invMat, hit, lightPos, lightLeft, lightUp, -1);\n        const vec3 GOLD = vec3(1, .9, .1);\n        if (d <= .01)\n        {\n            vec3 g = glitter(hit, vec3(0, 1, 0), rayDir, sh) * GOLD;\n            col = mix(g, GREEN, smoothstep(0., .01, d));\n        }\n        else\n        {\n            col = GREEN;\n        }\n        \n        col *= sh * .6 + .4;\n    }\n\n    // render small blue sphere at grab point, if any\n    if (state.grabId >= 0)\n    {\n        fxRigidBody b = fxGetBody(state.grabId);\n\n        vec3 grabPoint = rotateVectorByQuat(state.localGrabPos, quatInverse(b.rot)) + b.pos;\n        float i1 = sphIntersect(cameraPos, rayDir, vec4(grabPoint, .1));\n        if (i1 > 0. && i1 < maxT)\n        {\n            col = vec3(0, 0, 1);\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n#if MSAA <= 1\n    vec3 col = renderScene(fragCoord);\n#else\n    vec3 col = vec3(0);\n    \n    for (int x = 0; x < MSAA; ++x)\n    for (int y = 0; y < MSAA; ++y)\n    {\n        vec2 offset = (vec2(x, y) / float(MSAA - 1)) - .5;\n        col += renderScene(fragCoord + offset);\n    }\n    \n    col /= float(MSAA * MSAA);\n#endif\n\n    fragColor.xyz = pow(ACESFilm(col), vec3(1./2.2));\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float FAR_CLIP = 100.;                       // don't render beyond this t value\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 1.5)); // fixed light direction (sunlight)\nconst float SHADOW_RES = 40.;                      // resolution/coverage of shadow buffer\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    float resolution;  // res.x * res.y to detect changes, negative for one frame when change is detected\n    int grabId;        // which body we're grabbing with the mouse\n    float grabDist;    // how far away the grab point is from the camera\n    vec3 localGrabPos; // where on the grabbed body we're grabbing\n};\n\n// retrieve persistent state information\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.localGrabPos = data1.xyz;\n    state.grabId = int(data0.y);\n    state.grabDist = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel0)\n\nbool fxIsStatePixel(ivec2 ifc)\n{\n    return ifc == ivec2(0, 0) || ifc == ivec2(1, 0);\n}\n\nconst int NUM_STATE_PIXELS = 2;\n\n// store persistent state information\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(state.resolution, state.grabId, 0, 0);\n    else\n        return vec4(state.localGrabPos, state.grabDist);\n}\n\n// RIGID BODIES\n\nconst int NUM_BODIES = 300; // only uses a small part of the buffer for this shader\n\nstruct fxRigidBody\n{\n    vec3 pos;         // world space CG position\n    vec4 rot;         // rotation expressed as quaternion\n    vec3 vel;         // linear velocity\n    vec3 angVel;      // angular velocity\n    vec3 impulses[8]; // retained impulses per contact (one per box corner); x - normal impulse, yz - friction impulse\n};\n\n#define POS 0\n#define ROT 1\n#define VEL 2\n#define ANG_VEL 3\n#define IMPULSES00 5\n#define IMPULSES01 6\n#define IMPULSES02 7\n#define IMPULSES03 8\n#define IMPULSES04 9\n#define IMPULSES05 10\n#define IMPULSES06 11\n#define IMPULSES07 12\n#define NUM_DATA_TYPES 13\n\n//returns the location of the body within the body buffer corresponding with the input id \nivec2 fxLocFromIDImpl(int width, int id, int dataType)\n{\n    int index = id * NUM_DATA_TYPES + dataType + NUM_STATE_PIXELS;\n    return ivec2(index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDImpl(int(iResolution.x), X, Y)\n\n//get the body corresponding to the input id\nfxRigidBody fxGetBodyImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 bodyData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS), 0);\n    vec4 bodyData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, ROT), 0);\n    vec4 bodyData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, VEL), 0);\n    vec4 bodyData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, ANG_VEL), 0);\n    vec4 bodyData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES00), 0);\n    vec4 bodyData5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES01), 0);\n    vec4 bodyData6 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES02), 0);\n    vec4 bodyData7 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES03), 0);\n    vec4 bodyData8 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES04), 0);\n    vec4 bodyData9 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES05), 0);\n    vec4 bodyData10 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES06), 0);\n    vec4 bodyData11 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, IMPULSES07), 0);\n\n    fxRigidBody body;\n    body.pos = bodyData0.xyz;\n    body.rot = bodyData1;\n    body.vel = bodyData2.xyz;\n    body.angVel = bodyData3.xyz;\n    body.impulses[0] = bodyData4.xyz;\n    body.impulses[1] = bodyData5.xyz;\n    body.impulses[2] = bodyData6.xyz;\n    body.impulses[3] = bodyData7.xyz;\n    body.impulses[4] = bodyData8.xyz;\n    body.impulses[5] = bodyData9.xyz;\n    body.impulses[6] = bodyData10.xyz;\n    body.impulses[7] = bodyData11.xyz;\n    \n    return body;\n}\n\n#define fxGetBody(X) fxGetBodyImpl(iChannel0, int(iResolution.x), X)\n\n// write out the correct data member to fragColor\nvec4 fxSaveBody(fxRigidBody b, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS:\n        return vec4(b.pos, 0);\n    case ROT:\n        return vec4(b.rot);\n    case VEL:\n        return vec4(b.vel, 0);\n    case ANG_VEL:\n        return vec4(b.angVel, 0);\n    case IMPULSES00:\n        return vec4(b.impulses[0], 0);\n    case IMPULSES01:\n        return vec4(b.impulses[1], 0);\n    case IMPULSES02:\n        return vec4(b.impulses[2], 0);\n    case IMPULSES03:\n        return vec4(b.impulses[3], 0);\n    case IMPULSES04:\n        return vec4(b.impulses[4], 0);\n    case IMPULSES05:\n        return vec4(b.impulses[5], 0);\n    case IMPULSES06:\n        return vec4(b.impulses[6], 0);\n    case IMPULSES07:\n        return vec4(b.impulses[7], 0);\n    }\n}\n\n// get just one body member (untyped)\nvec4 fxGetBodyDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetBodyData(X, Y) fxGetBodyDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// returns the ids of the four closest bodies from the input coords\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosestCamera(X) fxGetClosestImpl(iChannel1, X)\n#define fxGetClosestLight(X) fxGetClosestImpl(iChannel2, X)\n\n// UTILITY\n\nconst float PI = 3.141592653589793;\nconst vec4 QUAT_IDENT = vec4(0, 0, 0, 1);\n\nfloat length2(vec2 v) { return dot(v, v); }\n\n// rotate vector by quaternion\nvec3 rotateVectorByQuat(vec3 v, vec4 q)\n{\n    vec3 u = q.xyz;\n    float s = q.w;\n\n    return 2. * dot(u, v) * u\n          + (s*s - dot(u, u)) * v\n          + 2. * s * cross(u, v);\n}\n\n// multiply quaternions\nvec4 quatMult(vec4 Q1, vec4 Q2)\n{\n   return vec4( \n       Q2.x*Q1.w + Q2.y*Q1.z - Q2.z*Q1.y + Q2.w*Q1.x,\n      -Q2.x*Q1.z + Q2.y*Q1.w + Q2.z*Q1.x + Q2.w*Q1.y,\n       Q2.x*Q1.y - Q2.y*Q1.x + Q2.z*Q1.w + Q2.w*Q1.z,\n      -Q2.x*Q1.x - Q2.y*Q1.y - Q2.z*Q1.z + Q2.w*Q1.w\n   );\n}\n\n// construct quaternion from euler angles\nvec4 quatFromRot(vec3 rot)\n{\n    float cr = cos(rot.x * 0.5);\n    float sr = sin(rot.x * 0.5);\n    float cp = cos(rot.y * 0.5);\n    float sp = sin(rot.y * 0.5);\n    float cy = cos(rot.z * 0.5);\n    float sy = sin(rot.z * 0.5);\n\n    vec4 q;\n    q.w = cr * cp * cy + sr * sp * sy;\n    q.x = sr * cp * cy - cr * sp * sy;\n    q.y = cr * sp * cy + sr * cp * sy;\n    q.z = cr * cp * sy - sr * sp * cy;\n\n    return q;\n}\n\n// quaternion inverse\nvec4 quatInverse(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n// compute matrix from quaternion\nmat3 matFromQuat(vec4 Q)\n{\n    float q0 = Q[0];\n    float q1 = Q[1];\n    float q2 = Q[2];\n    float q3 = Q[3];\n     \n    float r00 = 2. * (q0 * q0 + q1 * q1) - 1.;\n    float r01 = 2. * (q1 * q2 - q0 * q3);\n    float r02 = 2. * (q1 * q3 + q0 * q2);\n     \n    float r10 = 2. * (q1 * q2 + q0 * q3);\n    float r11 = 2. * (q0 * q0 + q2 * q2) - 1.;\n    float r12 = 2. * (q2 * q3 - q0 * q1);\n     \n    float r20 = 2. * (q1 * q3 - q0 * q2);\n    float r21 = 2. * (q2 * q3 + q0 * q1);\n    float r22 = 2. * (q0 * q0 + q3 * q3) - 1.;\n     \n    return mat3(r00, r01, r02,\n                r10, r11, r12,\n                r20, r21, r22);\n}\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nfloat boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return -1.; // no intersection\n    \n    return tN;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// CAMERA\n\n// camera animation based on time\nvoid fxCameraPath(out vec3 cameraPos, out vec3 cameraLookAt, float t)\n{\n    t += 200.;\n    cameraPos = vec3(200. * sin(t * .02), 16, 200. * cos(t * .02));\n    cameraLookAt = vec3(14. * cos(t * .02), -16, -14. * sin(t * .02)) + cameraPos;\n}\n\n// light animation based on time (light position determines the center of focus for shadow voronoi buffer)\nvoid fxLightPath(vec3 cameraLookAt, vec3 cameraFwd, out vec3 lightPos, out vec3 lightLookAt)\n{\n    lightLookAt = cameraLookAt + vec3(cameraFwd.x, 0, cameraFwd.z) * 20.;\n    lightPos = lightLookAt + LIGHT_DIR * 50.;\n}\n\n// compute lookat basis vectors\nvoid fxCalcCamera(vec3 cameraPos, vec3 cameraLookAt, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(vec3(-cameraFwd.z, 0, cameraFwd.x));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\n// compute matrix from basis vectors\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\n// compute ray from camera basis\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// VORONOI\n\nfloat distance2Body(sampler2D bodyData, int resolutionWidth, int id, vec3 ro, vec3 rd)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    vec3 worldPos = fxGetBodyDataImpl(bodyData, resolutionWidth, id, POS).xyz;\n    vec4 worldRot = fxGetBodyDataImpl(bodyData, resolutionWidth, id, ROT);\n    \n    vec3 localDir = rotateVectorByQuat(rd, worldRot);\n    vec3 localOrigin = rotateVectorByQuat(ro - worldPos, worldRot);\n\n    float t = boxIntersection(localOrigin, localDir, vec3(.6)); // n.b.: slightly bigger than box\n    \n    if (t < 0.) return 1e6; // boxIntersection gives us a -1 if we miss, but we need something that sorts to the end\n    \n    return t;\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// online algorithm to compute the closest bodies to each raster position\nivec4 voronoi(sampler2D bodyData, int resolutionWidth, sampler2D cameraClosest, vec2 fragCoord, vec3 cameraPos, vec3 rayDir, int iFrame, uint searchRange, uint searchCount)\n{\n    ivec4 new = ivec4(-1);\n    if (iFrame == 0) return new;\n\n    vec4 dis = vec4(1e6);\n    ivec2 ifc = ivec2(fragCoord);\n    \n    // reinsert existing closest to compute distances\n    ivec4 old = fxGetClosestImpl(cameraClosest, ifc);      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        float dis2 = distance2Body(bodyData, resolutionWidth, id, cameraPos, rayDir);\n        insertion_sort( new, dis, id, dis2 );\n    }\n\n    // search nearby voronoi cells for bodies that should move into our cell\n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n        ivec4 old = fxGetClosestImpl(cameraClosest, ifc + ( ivec2(h0.xy % searchRange) - ivec2(searchRange / 2u) ));      \n\n        for (int j = 0; j < 1; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Body(bodyData, resolutionWidth, id, cameraPos, rayDir);\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n\n    // random searching to kick start the process\n    int searchIterations = iFrame < 5 ? 20 : 1;\n    for(int k = 0; k < searchIterations; k++)\n    {\n        int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % NUM_BODIES;\n        insertion_sort(new, dis, id, distance2Body(bodyData, resolutionWidth, id, cameraPos, rayDir));\n    }\n    \n    return new;\n}\n", "buffer_a_code": "// -------------------------------------------------------------------------------------------\n// Rigid body simulation and persistent state...an array of fxRigidBodies following an fxState\n// -------------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0, -.01, 0);            // velocity change per frame caused by gravity\nconst float FRIC_COEF = .03;                      // Coulomb friction constant\nconst float ALLOWED_PENETRATION = .001;           // object floats up to this high above surface to maintain contact coherence\nconst float RESTITUTION_COEF = .5;                // how much to bounce (elasticity); 1. == perfect elasticity 0. == perfect inelasticity\nconst float INVERSE_MASS = 80.;                   // one over the mass\nconst mat3 INV_INERTA_LOCAL = mat3(INVERSE_MASS); // box inertia, used for impulse calculations\n\n// maintains the status of each contact point during iterations\nstruct fxContact\n{\n    vec3 relPos;       // world space position of contact relative to body CG\n    vec3 norm;         // contact normal\n    float depth;       // collision depth, positive needs position correction\n    float targetVel;   // used by restitution to aim us towards to bigger velocity than zero\n    vec3 jacDiagABInv; // the relationship between impulse and velocity for x (normal) and yz (friction) directions\n};\n\n// get the linear velocity of a point on the body\nvec3 getLocalVelocity(fxRigidBody b, vec3 relPos)\n{\n    return b.vel + cross(relPos, b.angVel);\n}\n\n// rotate the inertia tensor into world space\nmat3 getInvInertiaTensorWorld(fxRigidBody b)\n{\n    mat3 basis = matFromQuat(b.rot);\n    return basis * INV_INERTA_LOCAL * transpose(basis);\n}\n\n// make arbitrary (but consistent) basis vectors given a direction\nvoid makeOrthonormals(vec3 v, out vec3 v1, out vec3 v2)\n{\n    v1 = cross(v, vec3(1, 0, 0));\n    if (length(v1) < 1e-6)\n    {\n        v1 = cross(v, vec3(0, 1, 0));\n    }\n    \n    v1 = normalize(v1);\n    v2 = normalize(cross(v, v1));\n}\n\n// how much impulse is needed to achieve a change in velocity in each direction (x - normal, yz - friction)\nvec3 computeImpulseDenominator(fxRigidBody b, vec3 relPos, vec3 norm)\n{\n    vec3 tangent, binormal; makeOrthonormals(norm, tangent, binormal);\n    mat3 invInertiaTensorWorld = getInvInertiaTensorWorld(b);\n    \n    vec3 c0 = cross(relPos, norm);\n    vec3 v0 = cross(c0 * invInertiaTensorWorld, relPos);\n\n    vec3 c1 = cross(relPos, tangent);\n    vec3 v1 = cross(c1 * invInertiaTensorWorld, relPos);\n\n    vec3 c2 = cross(relPos, binormal);\n    vec3 v2 = cross(c2 * invInertiaTensorWorld, relPos);\n\n    return INVERSE_MASS + vec3(dot(norm, v0), dot(tangent, v1), dot(binormal, v2));\n}\n\n// change the velocity of a body via an impulse at an offset from CG in world space\nvoid applyImpulse(inout fxRigidBody b, vec3 impulse, vec3 relPos)\n{\n    b.vel += impulse * INVERSE_MASS;\n    b.angVel += getInvInertiaTensorWorld(b) * cross(impulse, relPos);\n}\n\nvoid initRigidBody(inout fxRigidBody b, int id, vec3 cameraPos)\n{\n    // setup random initial position, rotation, velocity, angVel\n    vec4 h = hash44(vec4(iFrame, id, id, id));\n    b.pos = (h.xyz - vec3(.5, 0, .5)) * 16. * vec3(5, 30, 5) + vec3(0, 20, 0) + cameraPos;\n    vec4 h2 = hash44(vec4(iFrame, h.w, iDate.z, id));\n    b.rot = quatFromRot(vec3(h2.xyz * 3. * PI));\n\n    vec4 h3 = hash44(vec4(iFrame, h2.w, iDate.z, id));\n    b.vel = vec3(h3.x - .5, 0, h3.y - .5) * .3;\n    b.angVel = vec3((h2.xyz - .5) * 2. * PI) * .01;\n}\n\n// constraint math adapted from Erwin Coumans' Bullet:\n// https://github.com/bulletphysics/bullet3/blob/master/src/BulletDynamics/ConstraintSolver/btContactConstraint.cpp\nvoid prepareContact(inout fxRigidBody b, float warmStartImpulse, inout fxContact c)\n{\n    // compute the component of the jacobian in three directions (normal, tangent, binormal)\n\tvec3 denom = computeImpulseDenominator(b, c.relPos, c.norm);\n\tc.jacDiagABInv = 1. / denom;\n    \n    // precompute the target velocity necessary to achieve the desired restitution\n  \tvec3 vel = getLocalVelocity(b, c.relPos);\n\tfloat relVel = dot(c.norm, vel);\n    c.targetVel = min(0., relVel * RESTITUTION_COEF + .01);\n\n    // compute and apply the Baumgarte impulse (position correction) to prevent sinking\n    float positionalError = c.depth * .01;\n    float penetrationImpulse = positionalError / denom.x;\n    \n    // combine the Baumgarte with warm start impulse and apply\n    float prepareImpulse = penetrationImpulse + warmStartImpulse;\n    applyImpulse(b, c.norm * prepareImpulse, c.relPos);\n}\n\n// perform one iteration, computing impulses for one contact to resolve velocity error\nvoid resolveContact(inout fxRigidBody b, inout vec3 accumImpulse, inout fxContact c)\n{\n\tvec3 vel = getLocalVelocity(b, c.relPos); // the velocity at the contact point (world space)\n\tfloat relVel = dot(c.norm, vel); // the component of the local velocity in the normal direction\n\n\tfloat velocityError = -relVel - c.targetVel; // how much velocity error we need to correct\n\tfloat normalImpulse = velocityError * c.jacDiagABInv.x; // the impulse needed to correct the error\n\n    float totalImpulse = accumImpulse.x + normalImpulse; // the full normal impulse applied so far\n\ttotalImpulse = max(0., totalImpulse); // complementarity condition (can't apply negative total impulse)\n    float normalImpulseAdjustment = totalImpulse - accumImpulse.x; // how much correction to apply to the impulse\n    accumImpulse.x = totalImpulse; // save the normal impulse for next time (warm start)\n\n\tapplyImpulse(b, c.norm * normalImpulseAdjustment, c.relPos); // apply normal impulse\n\n\tvel = getLocalVelocity(b, c.relPos); // update the velocity after applying normal impulse\n    \n    vec3 tangent, binormal; makeOrthonormals(c.norm, tangent, binormal); // compute friction directions\n    \n    vec2 frictionVel = vec2(dot(vel, tangent), dot(vel, binormal)); // compute the velocity in the friction directions\n\tvec2 frictionImpulse = -frictionVel * c.jacDiagABInv.yz; // compute the impulse necessary to stop all sliding\n\n    vec2 totalFrictionImpulse = accumImpulse.yz + frictionImpulse; // compute the total friction impulse applied\n    \n    // clamp total friction based on friction constant times normal force to allow dynamic friction\n\ttotalFrictionImpulse = clamp(totalFrictionImpulse, -FRIC_COEF * totalImpulse, FRIC_COEF * totalImpulse);\n    vec2 frictionImpulseAdjustment = totalFrictionImpulse - accumImpulse.yz; // how much correction to apply to friction impulse\n    accumImpulse.yz = totalFrictionImpulse; // save the friction impulse for next time (warm start)\n\n    vec3 worldFrictionImpulse = totalFrictionImpulse.x * tangent + totalFrictionImpulse.y * binormal; // combine friction impulses\n\tapplyImpulse(b, worldFrictionImpulse, c.relPos); // apply friction impulses\n}\n\n// advance one body's state by one frame\nvoid updateRigidBody(int id, inout fxRigidBody b, fxState state)\n{\n    // integrate velocity\n    b.vel += GRAVITY;\n    const float MAX_Y_SPEED = .2;\n    if (abs(b.vel.y) > MAX_Y_SPEED)\n    {\n        b.vel.y = MAX_Y_SPEED * sign(b.vel.y);\n    }\n    \n    // collision detection (very simple, just corners vs. plane)\n    const int MAX_NUM_CONTACTS = 8;\n    fxContact contacts[MAX_NUM_CONTACTS];\n    int numContacts = 0;\n    \n    for (int x = 0; x < 2; x++)\n    for (int y = 0; y < 2; y++)\n    for (int z = 0; z < 2; z++)\n    {\n        int index = x * 4 + y * 2 + z;\n        vec3 localPos = (vec3(x, y, z) * 2. - 1.)  * .5;\n        vec3 relPos = rotateVectorByQuat(localPos, quatInverse(b.rot));\n        \n        vec3 worldPos = relPos + b.pos;\n        if (worldPos.y < ALLOWED_PENETRATION)\n        {\n            // prepare contact found below plane\n            contacts[index].relPos = relPos;\n            contacts[index].norm = vec3(0, 1, 0);\n            contacts[index].depth = ALLOWED_PENETRATION - worldPos.y;\n            prepareContact(b, b.impulses[index].x, contacts[index]);\n        }\n        else\n        {\n            // not touching, reset contact\n            contacts[index].depth = 0.;\n            b.impulses[index] = vec3(0);\n        }\n    }\n\n    // mouse grab impulse\n    if (iMouse.z > 0. && iMouse.w < 0. && state.grabId == id)\n    {\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCameraPath(cameraPos, cameraLookAt, iTime);\n        fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n        vec3 rayDir = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n        vec3 mouseGrabPos = cameraPos + rayDir * state.grabDist;\n        vec3 localPos = rotateVectorByQuat(state.localGrabPos, quatInverse(b.rot));\n        vec3 boxGrabPos = localPos + b.pos;\n        const float SPRING_K = .0003;\n        const float SPRING_DAMP = .001;\n        vec3 localVel = getLocalVelocity(b, localPos);\n        applyImpulse(b, SPRING_K * (mouseGrabPos - boxGrabPos) - localVel * SPRING_DAMP, boxGrabPos - b.pos);\n    }\n    \n    // constraint solve\n    for (int iter = 0; iter < 3; ++iter)\n    for (int index = 0; index < 8; ++index)\n    {\n        if (contacts[index].depth > 0.)\n        {\n            resolveContact(b, b.impulses[index], contacts[index]);\n        }\n    }\n    \n    // integrate position\n    b.pos += b.vel;\n    \n    // integrate rotation\n    vec4 rq = quatFromRot(b.angVel);\n    b.rot = quatMult(rq, b.rot);\n}\n\n// handle persistent state info\nvoid updateState(inout fxState state)\n{\n    if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n    }\n\n    if (iMouse.z > 0.)\n    {\n        if (iMouse.w > 0.)\n        {\n            state.grabId = -1;\n            float minT = 1e6;\n            for (int i = 0; i < NUM_BODIES; ++i) // seems like this should be slow, and could use voronoi buffer here, but ¯\\_(ツ)_/¯\n            {\n                fxRigidBody b = fxGetBody(i);\n                vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n                fxCameraPath(cameraPos, cameraLookAt, iTime);\n                fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n                vec3 rayDir = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n                vec3 localDir = rotateVectorByQuat(rayDir, b.rot);\n                vec3 localOrigin = rotateVectorByQuat(cameraPos - b.pos, b.rot);\n\n                float t = boxIntersection(localOrigin, localDir, vec3(.5));\n                if (t > 0. && t < minT)\n                {\n                    minT = t;\n                    state.grabId = i;\n                    state.grabDist = t;\n                    state.localGrabPos = localOrigin + localDir * t;\n                }\n            }\n        }\n    }\n    else\n    {\n        state.grabId = -1;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    fxState state = fxGetState();\n    \n    // handle state pixels\n    if (fxIsStatePixel(ifc))\n    {\n        updateState(state);\n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n    // locate which body we're in, and determine the data member we're computing\n    int index = ifc.x + ifc.y*int(iResolution.x) - NUM_STATE_PIXELS;\n    int id = index / NUM_DATA_TYPES;\n    int dataType = index - id * NUM_DATA_TYPES;\n    if(id>=NUM_BODIES) return;\n    \n    fxRigidBody b = fxGetBody(id);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n\n    if (iFrame == 0 || // reset on frame zero...\n        state.resolution < 0. || // ...or if the resolution changed...\n        distance(b.pos.xz, cameraPos.xz) > 40. || // ...or if too far from the camera...\n        dot(b.pos - cameraPos, cameraFwd) < 0.) // ...or if behind the camera\n    {\n        initRigidBody(b, id, cameraPos);\n    }\n    else\n    {\n        updateRigidBody(id, b, state);\n    }\n    \n    fragColor = fxSaveBody(b, dataType);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer from camera position\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    fxCalcCamera(cameraPos, cameraLookAt, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    const uint searchRange = 128u; // larger ranges allow faster movement, but require larger counts\n    const uint searchCount = 12u; // larger counts find more correct ids, but cost more\n    ivec4 new = voronoi(iChannel0, int(iResolution.x), iChannel1, fragCoord, cameraPos, rayDir, iFrame, searchRange, searchCount);\n    \n    fragColor = vec4(new);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer from light position (orthographic)\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 cameraLookAt, cameraPos;\n    fxCameraPath(cameraPos, cameraLookAt, iTime);\n    \n    vec3 lightPos, lightLookAt, lightFwd, lightLeft, lightUp;\n    fxLightPath(cameraLookAt, normalize(cameraLookAt - cameraPos), lightPos, lightLookAt);\n    fxCalcCamera(lightPos, lightLookAt, lightFwd, lightLeft, lightUp);\n\tvec2 screenPos = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    lightPos -= (lightLeft * screenPos.x + lightUp * screenPos.y) * SHADOW_RES; // move light pos intead of ray dir (orthographic projection)\n\n    vec3 rayDir = -LIGHT_DIR;\n    const uint searchRange = 64u; // larger ranges allow faster movement, but require larger counts\n    const uint searchCount = 12u; // larger counts find more correct ids, but cost more\n    ivec4 new = voronoi(iChannel0, int(iResolution.x), iChannel2, fragCoord, lightPos, rayDir, iFrame, searchRange, searchCount);\n    \n    fragColor = vec4(new);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsySDK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2202, 2330, 2359, 2359, 2464], [2466, 2478, 2499, 2559, 4060], [4062, 4112, 4151, 4151, 4202], [4204, 4204, 4241, 4241, 4289], [4291, 4291, 4329, 4329, 4592], [4594, 4594, 4632, 4632, 4745], [4747, 4747, 4844, 4844, 5935], [5937, 5937, 6071, 6071, 6868], [9033, 9033, 9055, 9055, 9295], [9297, 9297, 9322, 9322, 9418], [9420, 9420, 9443, 9443, 9526], [9528, 9528, 9552, 9552, 10036], [10038, 10038, 10063, 10063, 10282], [10284, 10356, 10419, 10419, 12579], [12581, 12665, 12688, 12688, 12848]]}
{"id": "mlKGRD", "name": "Longlow 2.5", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 4, "viewed": 202, "published": 3, "date": "1683678483", "time_retrieved": "2024-07-30T17:56:34.948826", "image_code": "// Fork of \"Longlow 2.0\" by firebreathz. https://shadertoy.com/view/7ssfDj\n// 2023-05-10 00:20:10\n\n// Fork of \"lONG BLUE SLOW LIGHTS\" by firebreathz. https://shadertoy.com/view/NslBW2\n// 2022-02-21 10:22:12\n\n// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-.50;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-10.; i<=0.5; ++i) {\n\t\tfor(float j=-0.; j<=.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(1920.,1080.), iResolution.y>1920. ? 60. : 40.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.9,0.,1.)*0.05;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*6.) * sat(999.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1001);\n    p *= p + 33.33;\n    return fract(4.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 5.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.2,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[2] = vec3[2]( \n\t\t\t\t\t\t vec3(8.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\n\t\t\t\t\t\t);\n\n\tint section = int(time/9000.);\n\tfloat rest = mod(time,9000.0);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*10. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 20.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*840.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.007)*0.1,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.3));\n\tbs.xz*= rot(avance*.3);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 1.001 + mval.y;\n\tfloat dofamount=0.00001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<2;\n\tbool lightsilver = section>1 && section<12;\n\tbool lightgreen = section>2;\n\tbool lightpink = section>10 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = !(section>0);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,1.);\n     // motion slowing down during the last section\n\tfloat t2=section!=16?time:pow(sat(rest*.6),.5)*1.5;\n\tif(section==16) {time=6.4; rest=1.;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*1.1 + (fract(mval.z+.5)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.7);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<1 ? 200. : 202.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-.6-i*184.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*.23)+cy*cos(h.y*1.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<2; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,2,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+9.0)*25.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.9+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][2];\n                \n\t\t\t\tfloat d2=1000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.000,0.000,0.251)*0.4, vec3(1.000,1.000,1.000) * 1., max(r.x+r.z*.3-r.y*.3,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.1,0.1,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.9,1);\n                    col += alpha * smoothstep(0.5,0.1,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.2+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*1.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .001;\n\t\t\t\t\tcol += alpha * smoothstep(0.009,0.001,fract(time*.005+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.001+floor(r.z*sqsize)*0.02))) * 1. * (rnd33(floor(r*sqsize)+floor(time)*.0037)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.9*.5)*.9)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 9. * vec3(0.345,0.000,0.690);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*3., localpos.y, length(localpos.xz)*.3);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*1.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*0.000033);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<0.1)?.4:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.1;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .1;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*34.,j*5)+fract(time))-.05)*rough);      \n\t\t}\n\t}\n\tcol *= 0.9/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlKGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[853, 853, 910, 910, 1615]]}
{"id": "sssfDj", "name": "Longlow", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "likes": 3, "viewed": 172, "published": 3, "date": "1683677072", "time_retrieved": "2024-07-30T17:56:36.058858", "image_code": "// Fork of \"lONG BLUE SLOW LIGHTS\" by firebreathz. https://shadertoy.com/view/NslBW2\n// 2022-02-21 10:22:12\n\n// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-.5;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*36./vec2(1920.,1080.), iResolution.y>720. ? 6. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.05;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*2.) * sat(131.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1001);\n    p *= p + 33.33;\n    return fract(4.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 5.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.2,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(10,5, 76.55)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(25,5, 62)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-9,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.9)\n\t\t\t\t\t\t);\n\n\tint section = int(time/200.);\n\tfloat rest = mod(time,30.0);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*10. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 20.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*840.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.007)*0.1,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.3));\n\tbs.xz*= rot(avance*.3);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 1.001 + mval.y;\n\tfloat dofamount=0.00001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<2;\n\tbool lightsilver = section>1 && section<12;\n\tbool lightgreen = section>2;\n\tbool lightpink = section>10 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = !(section>0);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,1.);\n     // motion slowing down during the last section\n\tfloat t2=section!=16?time:pow(sat(rest*.6),.5)*1.5;\n\tif(section==16) {time=6.4; rest=1.;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*1.1 + (fract(mval.z+.5)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.7);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 20. : 22.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-.6-i*184.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<2; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,2,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+9.9)*25.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.9+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][2];\n                \n\t\t\t\tfloat d2=1000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.000,0.000,0.251)*0.4, vec3(1.000,1.000,1.000) * 1., max(r.x+r.z*.3-r.y*.3,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.1,0.1,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.9,1);\n                    col += alpha * smoothstep(0.5,0.1,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.2+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*1.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .001;\n\t\t\t\t\tcol += alpha * smoothstep(0.009,0.001,fract(time*.005+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.001+floor(r.z*sqsize)*0.02))) * 1. * (rnd33(floor(r*sqsize)+floor(time)*.0037)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.9*.5)*.9)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 9. * vec3(0.345,0.000,0.690);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*3., localpos.y, length(localpos.xz)*.3);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*1.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*0.000033);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<0.1)?.4:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.1;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .5;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*34.,j*5)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.9/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sssfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[754, 754, 811, 811, 1511]]}
{"id": "clV3zD", "name": "Noise Blocks", "author": "drliquidglitch", "description": "Experimenting with noise functions", "tags": ["basic", "tutorial", "boilerplate", "workshop"], "likes": 0, "viewed": 158, "published": 3, "date": "1683665623", "time_retrieved": "2024-07-30T17:56:36.935514", "image_code": "//GLOBAL VARIABLES\nfloat time;\n//PRIMITIVE FUNCTIONS\nfloat box(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat sphere(vec3 p,float r){return length(p)-r;}\nfloat torus(vec3 p,vec2 t ){vec2 q=vec2(length(p.xz)-t.x,p.y);return length(q)-t.y;}\n// Pseudo random number generator. \nfloat hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\n// Value noise courtesy of BigWingz \n// check his youtube channel he has\n// a video of this one.\n// Succint version by FabriceNeyret\nfloat noise( vec2 U )\n{\n    vec2 id = floor( U );\n          U = fract( U );\n    U *= U * ( 3. - 2. * U );  \n\n    vec2 A = vec2( hash(id)            , hash(id + vec2(0,1)) ),  \n         B = vec2( hash(id + vec2(1,0)), hash(id + vec2(1,1)) ),  \n         C = mix( A, B, U.x);\n\n    return mix( C.x, C.y, U.y );\n}\n//MAP / SCENE FUNCTION\nfloat map(vec3 p)\n{ \n  float mainBox=box(p,vec3(.1));\n  float scene = mainBox;\n  float t = clamp(0., 24.0, iTime * 0.2);\n  for (float i=0.; i<(t); i+=0.222){\n      float fx = sin(noise(vec2(i, i*i)))-0.5;\n      float fy = cos(noise(vec2(i*i, i)))-0.5;\n      float fr = cos(noise(vec2(i)))-0.5;\n      float newBox = box(p+vec3(i*fx*fx*cos(i)*i, i * fy * fy * sin(iTime*0.2), i*fr*fr*tan(i*i))*2., vec3(0.2));\n      scene=min(scene,newBox);\n      }\n  //scene=max(scene,rightTorus);\n  return scene;\n}\n//RAY CAST / TRACE LOOP FUNCTION\nfloat raycast( vec3 ro, vec3 rd )\n{\n  float dist,res=0.;\n  for(int i=0;i<128;i++){ \n    dist=map(ro+rd*res); \n    if(dist<.0001||res>128.) break;\n    res+=dist;\n  }\n  if(res>120.) res=0.;\n  return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //UV.y from -.5 to .5 and UV.x from -.88 to .88 (aspect ratio broooh)\n  time=mod(iTime,62.82); //Modulo time to avoid sin glitch noise due to floating point precision\n  // CAMERA  \n  vec3 rayOrigin=vec3(cos(time*.2)*5.,2,sin(time*.2)*5.);\n  vec3 cameraForward=normalize(vec3(0)-rayOrigin);\n  vec3 cameraLeft=normalize(cross(cameraForward,vec3(0,1,0)));\n  vec3 cameraUp=normalize(cross(cameraLeft,cameraForward));\n  vec3 rayDirection=mat3(cameraLeft,cameraUp,cameraForward)*normalize(vec3(uv,.5)); \n  // LIGHT DIRECTION & BACKGROUND SETUP   \n  vec3 lightDirection=normalize(vec3(-.1,.4,-.3));  \n  vec3 backgroundColor=vec3(.1,.1,.1)-length(uv)*.1;\n  vec3 color=backgroundColor;\n  // TRACE AND GET RESULT FOR THIS PIXEL\n  float result=raycast(rayOrigin,rayDirection);\n  // IF WE HIT SOMETHING THEN DO SOME LIGHTING  \n  if(result>0.){ \n    vec3 hitPos=rayOrigin+rayDirection*result; // GET POSITION OF WHERE WE HIT\n    vec2 e=vec2(.00035,-.00035); // e=ESPILON = OFFSET NUMBER FOR NORMALS CALCULATION\n    vec3 normals=normalize(e.xyy*map(hitPos+e.xyy)+e.yyx*map(hitPos+e.yyx)+e.yxy*map(hitPos+e.yxy)+e.xxx*map(hitPos+e.xxx)); //CALCULATE NORMALS FOR WHERE WE HIT\n    vec3 albedo=vec3(.0,.2,.4); // SETUP BASE COLOUR\n    float diffuse=max(0.,dot(normals,lightDirection)); // SIMPLE DIFFUSE LIGHTING\n    float fresnel=pow(1.+dot(normals,rayDirection),4.); // FRESNEL = BACKGROUND REFLECTIONS ADDED TO EDGES OF GEOMETRY TO COMPOSITE IT BETTER IN THE SCENE\n    float specular=pow(max(dot(reflect(-lightDirection,normals),-rayDirection),0.),30.);// SPECULAR LIGHTING = Bright highlights, the shiny white flashy bit especially visible on metallic objects\n    float ao=clamp(map(hitPos+normals*.05)/.05,0.,1.); // AO = AMBIENT OCCLUSION = Small shadows where geometries touch due to ambient lighting\n    float sss=smoothstep(0.,1.,map(hitPos+lightDirection*.4)/.4);// SSS = Sub surface scattering = Light penetrating through edges of a translucent object, especially visible on candle wax or skin. Can be used as backlight too.\n    color=mix(specular+albedo*(ao+.2)*(diffuse+sss*.1),backgroundColor,fresnel); // Final lighting result made of all the above and then mixed with fresnel\n    color=mix(backgroundColor,color,exp(-.002*result*result*result)); // Add fog right at the end\n  }\n  fragColor = vec4(pow(color,vec3(.4545)),1);// RETURN FINAL COLOR WITH GAMMA CORRECTION (pow(color,vec3(.4545)))\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clV3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 53, 78, 78, 119], [120, 120, 149, 149, 169], [170, 170, 198, 198, 254], [255, 291, 313, 313, 384], [386, 519, 542, 542, 827], [828, 851, 870, 870, 1348], [1349, 1382, 1417, 1417, 1585], [1586, 1586, 1643, 1643, 4116]]}
{"id": "mtKGRW", "name": "Solum Object", "author": "QuantumSuper", "description": "An auto-VJ with circles & triangles, shattered particles, and visual tweaks.\n\n- Use with music in iChannel0 -", "tags": ["2d", "music"], "likes": 17, "viewed": 556, "published": 3, "date": "1683664807", "time_retrieved": "2024-07-30T17:56:37.925867", "image_code": "// Solum Object 0.52.230509 by QuantumSuper\n// auto-vj with circles & triangles, shattered particles, and visual tweaks\n// \n// - use with music in iChannel0 -\n\n\n#define PI 3.14159265359 \n#define aTime 128./60.*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n    //for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //workaround for VirtualDJ, ?any hints for reverting audio limiters appreciated \n}\n\nvec3 getCol(float id){ //color definitions, for triplets\n    vec3 setCol = vec3(0);\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\n    return setCol/256.;\n}\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nfloat hash21(vec2 p){ //pseudo random generator\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1./k;\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2., 0.);\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0., 1.);\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0., 1.);\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0., 1.);\n    float s = sign(e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min(min(vec2( dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2( dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2( dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat getParticle(vec2 p, vec2 p1, vec2 p2){ //background particle\n    float d = mix( \n        length(p*(.5+.5*sin(p1)))-p2.y+.2, //ellipse\n        sdTriangle(p,p1,p2,vec2(0)), //triangle \n        clamp(16.+16.*sin(aTime/4.),.0,1.)); //shapeshift\n    return smoothstep( min(.01,fwidth(d)), .0, abs(d));\n}\n\nfloat getTria(vec2 p, float r){ //triangle scaled by r about 0,0\n    return clamp( .02/abs(sdEquilateralTriangle(p/(r+.001))), .0, 1.);\n}\n\nfloat getRing(vec2 p, float r){ //ring with radius r about 0,0\n    return clamp( .01/abs(length(p)-r), .0, 1.);\n}\n\nfloat getShape(vec2 p, float r){ //shape combination scaling with r about 0,0\n    return (fract(aTime/16.)<.5)? getRing(p,r)+.2*(1.-fft.z)*getTria(p/3.,r) : getTria(p,r)+.2*(1.-fft.z)*getRing(p/3.,r);\n}\n\nfloat shatterLayer(vec2 p){ //background layers\n    float id = hash21(floor(p));\n    return getParticle(\n        (fract(p)-.5)*rotM(2.*PI*id+aTime)-.2*vec2(cos(id*aTime),sin(.8*id*aTime)) * vec2( 2.*cos(id*aTime), 1.), //multiple rotating shifting origins\n        .25*vec2(sin(id*aTime),cos(id*aTime)), //moving corner per id\n        vec2(.05+.3*id)) //fixed corner per id\n        * (step(id,.8)+clamp(sin(aTime),.0,1.)*step(id,.05)); //different brightness\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    compressFft(); //initializes fft, ffts\n    \n    // View definition\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio  \n    float fTime = fract(iTime/64.); //\"randomize\" view manipulation by using iTime instead of aTime\n    if (fract(aTime/32.)<.75); //\"break\", standard view\n    else if (fTime<.33) uv = fract(uv*2.*abs(sin(aTime/8.))+.5)-.5; //scaling multiples\n    else if (fTime<.66) uv *= 1.5*rotM(sign(fract(aTime/32.)-.5)*aTime/8.); //rotation\n    else uv = sin( PI*uv + vec2( sign(fract(aTime/32.)-.5) * aTime/4., 0)); //moving warp multiples\n    \n    // Draw color shapes\n    vec3 col = vec3(\n        getShape( uv*3., fft.y),\n        getShape( uv, fft.z),\n        getShape( uv, fft.w));\n    \n    // Overlay brightness with sound texture\n    float rho = atan(-abs(uv.x),uv.y)/PI+1.; //polar angle, flipped & mirrored\n    col = mix( col, col*smoothstep(.2,.8,vec3(\n        texelFetch( iChannel0, ivec2( 6.+17.*rho, 0), 0).x, //speech\n        texelFetch( iChannel0, ivec2( 24.+70.*rho, 0), 0).x, //presence\n        texelFetch( iChannel0, ivec2( 95.+416.*rho, 0), 0).x)), smoothstep(.66,1.,length(col))); //brilliance\n    col.r = mix(col.r,pow(col.r,9.),col.r); //heighten contrast of thin shape\n    \n    // Remap colors\n    float colId = 3. * floor(mod(aTime/8.,4.));\n    col = mat3(getCol(colId),getCol(colId+1.),getCol(colId+2.)) * col;\n    \n    // Draw white shape\n    rho = atan(uv.x,uv.y)/2./PI+.5; //polar angle, flipped\n    float shape = getShape( uv, .1/(fft.x*fft.x));\n    col += shape * mix( 1., smoothstep(.6,.9,texelFetch(iChannel0,ivec2(5.*rho,0),0).x), .75*smoothstep(.66,1.,shape));\n    \n    // Shatter background layers\n    uv *= 1. + .5*cos(uv)/length(2.*uv); //warp view\n    float aFrac,amp =0.;\n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-.05*aTime+.25*n)-1.*.1*fft.w*fft.w*fft.w;\n        amp += (1.-.5*fft.z) * shatterLayer((uv*2.*rotM(sin(aTime/32.))+n*vec2(.1,.05))*20.*aFrac) * smoothstep(1.,.33,aFrac);\n    }\n    amp *= .1 + .9*length(uv)*length(uv)*length(uv); //anti-vignette \n    col += 2. * amp * col/length(col); //merge with foreground\n    \n    // Final adjustments\n\tcol = pow(col, vec3(.4545)); //gamma correction\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 33281, "src": "https://soundcloud.com/dvskrecords/duskcast-riot-code", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtKGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 287, 378, 1538], [1540, 1540, 1562, 1596, 2415], [2417, 2417, 2436, 2436, 2489], [2512, 2512, 2533, 2559, 2652], [2654, 2654, 2690, 2749, 2953], [2955, 2955, 3007, 3066, 3623], [3625, 3625, 3669, 3691, 3929], [3931, 3931, 3962, 3995, 4068], [4070, 4070, 4101, 4132, 4183], [4185, 4185, 4217, 4262, 4387], [4389, 4389, 4416, 4436, 4848], [4850, 4850, 4906, 4906, 7174]]}
{"id": "clVGRD", "name": "Ambiant AI.", "author": "outofpaper", "description": "Experiment (1) for LLM Inference Engine Agent. ", "tags": ["sound", "cineshader", "llmanimation"], "likes": 5, "viewed": 1555, "published": 3, "date": "1683653505", "time_retrieved": "2024-07-30T17:56:38.743680", "image_code": "//TODO Test with lighter background colors\nfloat distFromMiddle(float n){\n    return abs(.5-n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // move image right, flip left horizontally\n    if (uv.x < .5){\n    \tuv.x = -uv.x+.5;        \n    }else{\n     \tuv.x = uv.x-.5;        \n    }    \n    \n    // Time varying pixel color\n    float t = iTime/5.;    \n    vec3 col = vec3(\n        .2+.2*sin(t),\n        .2-.2*tan(t),\n        .2+.9*sin(t));\n    \n    //Apply FFT\n\tfloat s = texture(iChannel0, (uv.xy*.333)).r;\n    col *= s/distFromMiddle(uv.y);\n    col *= .22;\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n    \n}", "image_inputs": [{"id": 33276, "src": "https://soundcloud.com/briandern/wandering-into-space", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clVGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 73, 73, 97], [99, 99, 156, 206, 738]]}
{"id": "ctKGRW", "name": "Cursed Nonsense", "author": "Emily_TTG", "description": "My new favourite function.", "tags": ["cursed"], "likes": 1, "viewed": 125, "published": 3, "date": "1683644236", "time_retrieved": "2024-07-30T17:56:39.719072", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x = uv.x;\n    float y = uv.y;\n\n    float p = 1.3;\n    \n    float t = 100.0 * sin(iTime / 60.0);\n\n    float l = (p * (t + x))/(y + cos(pow(t + x, exp(p)))) - p;\n\n    fragColor = vec4(l / t, 0.0, 0.5 + 0.5 * sin(iTime + x + y), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctKGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 342]]}
{"id": "dlyGzD", "name": "Funky Blobs", "author": "Emily_TTG", "description": "I screwed around in Desmos here https://www.desmos.com/calculator/yajo41bosx to make some garbage, then turned it into some coloured blobs.", "tags": ["simple", "colour"], "likes": 0, "viewed": 121, "published": 3, "date": "1683642065", "time_retrieved": "2024-07-30T17:56:40.593733", "image_code": "float PI = 3.14159265358979323846;\nfloat EULER = 0.57721566490153286060;\n\nfloat EPSILON = 0.00001;\n\nfloat gamma(float x)\n{\n    return sqrt(2.0 * PI / (x + EPSILON)) * pow(x / EULER, x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float x = uv.x;\n    float y = uv.y;\n\n    float p = 0.5 * sin(iTime) + 0.5;\n    float t = 0.5 * sin(iTime / 3.0) + 0.5;\n\n    float red_a = x * log((p + 0.5) / tan(x)) * 5.0;\n    float red_b = pow(x, tan(y)) / (p + t);\n    \n    float green = p * x;\n\n    float blue_a = (y * atan(gamma(exp(x)))) / (p + EPSILON);\n    float blue_b = pow(x, EULER / (y + EPSILON)) * pow(log(y), x);\n\n    float red = red_a * red_b;\n\n    vec3 col = vec3(red, green, (sin(iTime) + 0.1) / sin(x * y));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 122, 122, 187], [189, 189, 244, 244, 800]]}
{"id": "clG3zD", "name": "Stylised cel-shaded donut", "author": "Sumsar86", "description": "Cel shading shader applied to a rotating donut rendered using ray marching.", "tags": ["raymarching", "celshading", "donut", "doughnut"], "likes": 3, "viewed": 189, "published": 3, "date": "1683617999", "time_retrieved": "2024-07-30T17:56:41.516267", "image_code": "#define OUTLINE 1\n\nconst vec3 OUTLINE_COLOR = vec3(0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 color = vec3(0.0);\n    color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float outlineIntensity = dot(texelFetch(iChannel1, ivec2(fragCoord), 0).rgb, vec3(1.0));\n    \n#if OUTLINE\n    if (outlineIntensity > 0.0)\n        color = OUTLINE_COLOR;\n#endif\n\n    fragColor = vec4(color, 0.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FLAT_COLORS 1\n#define USE_VIDEO 0\n\nconst vec4 BACKGROUND_COLOR = vec4(0.8, 0.8, 0.8, -1.0);\nconst float N = 2.0;\n\nstruct Torus\n{\n    float r;\n    float s;\n\n    vec3 color;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 color;\n    float ambientIntensity;\n};\n\nTorus t1 = Torus(0.5, 0.25, vec3(0.80, 0.45, 0.38));\nLight l1 = Light(vec3(2.0, -5.0, 3.0), vec3(1.0), 0.2);\n\n\nmat4 translate(vec3 v) {\n    return mat4(\n        1, 0, 0, -v.x, \n        0, 1, 0, -v.y, \n        0, 0, 1, -v.z, \n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        1, 0, 0, 0,\n        0, c, -s, 0,\n        0, s, c, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(\n        c, 0, s, 0, \n        0, 1, 0, 0, \n        -s, 0, c, 0, \n        0, 0, 0, 1\n    );\n}\n\nfloat torusSDF(in vec3 p)\n{\n    float h = length(p.xz);\n    return length(vec2(h-t1.r,p.y))-t1.s;\n}\n\nvec3 calculateNormal(in vec3 pos)\n{\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = torusSDF(pos + smallStep.xyy) - torusSDF(pos - smallStep.xyy);\n    float gradientY = torusSDF(pos + smallStep.yxy) - torusSDF(pos - smallStep.yxy);\n    float gradientZ = torusSDF(pos + smallStep.yyx) - torusSDF(pos - smallStep.yyx);\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nvec4 rayMarch(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float totalDistTraveled = 0.0;\n    const int NUMBER_OF_STEPS = 256;\n    const float MINIMUM_HIT_DIST = 0.001;\n    const float MAXIMUM_TRACE_DIST = 5.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {        \n        if (totalDistTraveled >= MAXIMUM_TRACE_DIST)\n            break;\n            \n        vec4 currentPos = vec4(rayOrigin + totalDistTraveled * rayDir, 1.0);\n        currentPos *= translate(vec3(0.0, 0.0, 0.0)) * rotateY(iTime) * rotateX(1.0);\n\n        float smallestDist = torusSDF(currentPos.xyz);\n\n        if (smallestDist <= MINIMUM_HIT_DIST)\n        {\n            vec3 normal = calculateNormal(currentPos.xyz);\n            l1.pos = vec3(vec4(l1.pos, 0.0) * rotateY(iTime));\n            vec3 lightDir = normalize(currentPos.xyz - l1.pos);\n            \n            float diffuseIntensity = max(l1.ambientIntensity, dot(normal, lightDir));\n            \n            return vec4(t1.color * l1.color * diffuseIntensity, 0.0);\n        }\n            \n        totalDistTraveled += smallestDist;\n    }\n    \n    return BACKGROUND_COLOR;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // convert from (0 to 1) to (-1 to 1)\n    uv = uv * 2.0 - 1.0;\n    // rescale\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    vec3 rOrigin = vec3(0.0, 0.0, -1.2);\n    vec3 rDir = vec3(uv, 1.0);\n#if USE_VIDEO\n    vec4 color = texture(iChannel1, fragCoord / iResolution.xy).rgba;\n#else\n    vec4 color = rayMarch(rOrigin, rDir);\n#endif\n\n    float greyScale = dot(color.xyz, vec3(1.0));\n    float inverseN = 1.0 / N;\n    float difference = mod(greyScale, inverseN);\n    greyScale -= difference - inverseN;\n#if FLAT_COLORS\n    color *= vec4(vec3(greyScale), 1.0);\n    //color = vec4(t1.color, 1.0) * vec4(vec3(greyScale), 1.0); // arguably better\n#endif\n\n    if (color.a == -1.0)\n    {\n        color /= vec4(vec3(greyScale), 1.0);\n        greyScale = 0.0;\n    }\n    \n    // Output to buffer A\n    fragColor = vec4(color.xyz, greyScale);\n}\n", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const float sobelX[9] = float[](\n    1.0, 0.0, -1.0, \n    2.0, 0.0, -2.0, \n    1.0, 0.0, -1.0\n);\n\nconst float sobelY[9] = float[](\n    1.0, 2.0, 1.0, \n    0.0, 0.0, 0.0, \n    -1.0, -2.0, -1.0\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float horizontal = 0.0, vertical = 0.0;\n    \n    for (float y = 0.0; y <= 2.0; y++)\n    {\n        for (float x = 0.0; x <= 2.0; x++)\n        {\n            ivec2 newFragCoord = ivec2(fragCoord + vec2(x - 1.0, y - 1.0));\n            float greyScale = texelFetch(iChannel0, newFragCoord, 0).a;\n            \n            int index = int(x + 3.0 * y);\n            horizontal += greyScale * sobelX[index];\n            vertical += greyScale * sobelY[index];\n        }\n    }\n    \n    float edge = sqrt(dot(horizontal, horizontal) + dot(vertical, vertical));\n    fragColor = vec4(vec3(edge), 0.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const float STRONG_THRESHOLD = 0.7;\nconst float WEAK_THRESHOLD = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = floor(fragCoord.x), y = floor(fragCoord.y);\n    float prevIndex = x + iResolution.x * y - 1.0;\n    ivec2 prevFragCoord = ivec2(mod(prevIndex, iResolution.x), floor(prevIndex / iResolution.x));\n    \n    float nextIndex = x + iResolution.x * y + 1.0;\n    ivec2 nextFragCoord = ivec2(mod(nextIndex, iResolution.x), floor(nextIndex / iResolution.x));\n    \n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float colorIntensity = dot(color, vec3(1.0));\n    float prevColorIntensity = dot(texelFetch(iChannel0, prevFragCoord, 0).rgb, vec3(1.0));\n    float nextColorIntensity = dot(texelFetch(iChannel0, nextFragCoord, 0).rgb, vec3(1.0));\n\n    fragColor = vec4(0.0);\n    if (nextFragCoord.y == int(fragCoord.y) && floor(fragCoord.y) != iResolution.y - 1.0)\n    {\n        if (colorIntensity >= WEAK_THRESHOLD && colorIntensity >= prevColorIntensity && colorIntensity >= nextColorIntensity)\n        {\n            fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 0.1);\n            if (colorIntensity >= STRONG_THRESHOLD)\n            {\n                fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n            }\n        }\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    float sum = 0.0;\n    for (float y = -1.0; y <= 1.0; y++)\n    {\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            if (x != 0.0 && y != 0.0)\n            {\n                ivec2 newFragCoord = ivec2(fragCoord + vec2(x, y));\n                vec4 neighbour = texelFetch(iChannel0, newFragCoord, 0).rgba;\n                sum += neighbour.a;\n            }\n        }\n    }\n    \n    fragColor = vec4(color.rgb, 0.0);\n    if (sum >= 1.0)\n        fragColor = color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clG3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 115, 423]]}
{"id": "mttGWX", "name": "Rectangular Pillar LOD Traversal", "author": "gelami", "description": "Fast traversal of a dense grid of rectangular pillars using an implicit quadtree acceleration structure", "tags": ["3d", "raytracing", "grid", "lod", "box", "quadtree"], "likes": 31, "viewed": 536, "published": 3, "date": "1683606166", "time_retrieved": "2024-07-30T17:56:42.573440", "image_code": "\n// Rectangular Pillar LOD Traversal - gelami\n// https://www.shadertoy.com/view/mttGWX\n\n/*\n * Fast traversal of a dense grid of rectangular pillars\n * using an implicit quadtree acceleration structure\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * The idea is to have the height on each level be multiplied\n * with all of the heights of the levels above it\n * This ensures the height is smaller than than ones above,\n * and allowing us to traverse it as a quadtree structure\n * \n * Though the bounds for each level isn't tightly fit,\n * it works as long as it is conservative\n * \n * Another way to do this with proper bounds is using interval arithmetic,\n * which allows us to query the height over a range to have proper bounds\n * \n * No AA this time unfortunately,\n * the very dense grid didn't bode well with TAA or FXAA v_v\n * \n * My previous shader that also did minmax traversal\n * which precomputes the minmax mipmap in a buffer\n * \n * Fast Minmax Terrain Traversal - gelami\n * https://www.shadertoy.com/view/msj3Dh\n * \n */\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-05 04:42:46\n\nvec2 ce;\nfloat map(vec2 p, float lod)\n{\n    #ifdef ENABLE_LOD\n    \n    float st = (sin(iTime * TAU * 0.05)*0.5+0.5)*0.5 + 0.4;\n    \n    float h = 1.0;\n    for (float i = MAX_LOD; i >= lod; i--)\n    {\n        #if 0\n        float f = hash12(floor(p * exp2(MAX_LOD-i)));\n        \n        f = sin((f + iTime * 0.25) * TAU)*0.5+0.5;\n        f = mix(1.0, f, 0.4);\n        \n        #else\n        float s = exp2(MAX_LOD-i);\n        vec2 o = floor(p * s) / exp2(MAX_LOD-i);\n        vec2 o2 = (o - ce) * st + ce;\n        \n        float f = (sin(o2.x)*0.5+0.5 + cos(o2.y)*0.5+0.5)*0.5;\n        \n        float g = texture(iChannel0, 0.2 * o2 / iChannelResolution[0].xy).r;\n        \n        float of = texture(iChannel0, o * 0.0004).x;\n        f = sin((f + g + iTime * 0.25 + of) * TAU)*0.5+0.5;\n        \n        float f2 = hash12(-floor(p * exp2(MAX_LOD-i)));\n        f -= f2 * 0.1;\n        f = mix(1.0, f, 0.15);\n        #endif\n        \n        h *= f;\n    }\n    #else\n    float st = (sin(iTime*0.08)*0.5+0.5) + 0.2;\n    st *= 0.25;\n    float f = (sin(p.x * st)*0.5+0.5 + cos(p.y * st)*0.5+0.5)*0.5;\n    f = sin((f + iTime * 0.25) * TAU)*0.5+0.5;\n    float h = f;\n    #endif\n    \n    return clamp(h * 0.9999 * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 tp;\n    float lod;\n    int i;\n};\n\nbool trace(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    if ((ro.y > MAX_HEIGHT && rd.y > 0.0) || (ro.y < MIN_HEIGHT && rd.y > 0.0))\n        return false;\n    \n    vec2 tp = floor(ro.xz);\n    vec2 ltp = tp;\n    \n    float lod = MAX_LOD;\n    float bs = 1.0;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(rd);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = ro * ird;\n    \n    hit.t = MAX_DIST;\n    hit.n = vec3(-1);\n    \n    int i = 0;\n    for (; i < STEPS; i++)\n    {\n        float d = map(tp * bs, lod) * 0.5;\n        \n        vec3 p = vec3((tp.x + 0.5) * bs, d, (tp.y + 0.5) * bs);\n        vec3 s = vec3(bs * 0.5, d, bs * 0.5);\n        vec3 n = iro - p * ird;\n        vec3 k = ard * s;\n        \n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        \n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 pos = ro + rd * tN;\n        \n        if (pos.y > MAX_HEIGHT && rd.y > 0.0)\n            return false;\n        \n        if (tN < tF && tN >= 0.0)\n        {\n            if (tN >= MAX_DIST)\n                return false;\n\n            #ifndef ENABLE_LOD\n            hit.t = tN;\n            hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n            hit.tp = tp;\n            hit.i = i;\n            return true;\n            \n            #else\n            \n            float maxLod = log2(tN);\n            \n            if (lod > 0.0)\n            {\n                tp *= 2.0;\n                tp += step(vec2(0), pos.xz - p.xz);\n                ltp = tp;\n                \n                bs *= 0.5;\n                lod--;\n                continue;\n            } else\n            {\n                #ifndef ROUNDED\n                hit.t = tN;\n                hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n                hit.tp = tp * bs;\n                hit.lod = lod;\n                hit.i = i;\n                return true;\n                \n                #else\n                float rad = RADIUS;\n                vec3 o = p;\n                vec3 rp = ro - o;\n                vec3 rs = max(s-rad, vec3(0));\n                float rt = roundedboxIntersect(pos - o, rp, rd, rs, rad);\n                \n                if (rt != MAX_DIST)\n                {\n                    hit.t = rt == 0.0 ? tN : rt;\n                    vec3 pos = rp + rd * hit.t;\n                    hit.n = normalize(roundedboxNormal(pos, rs, rad));\n                    hit.tp = tp * bs;\n                    hit.lod = lod;\n                    hit.i = i;\n                    return true;\n                }\n                #endif\n            }\n            #endif\n        }\n        \n        ltp = tp;\n        tp += step(t2.xz, t2.zx) * srd.xz;\n        \n        #ifdef ENABLE_LOD\n        if (floor(ltp*0.5) != floor(tp*0.5) && lod < MAX_LOD)\n        {\n            tp = floor(tp*0.5);\n            ltp = tp;\n            bs *= 2.0;\n            lod++;\n        }\n        #endif\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pv = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    #ifdef ENABLE_LOD\n    vec3 ro = vec3(0, 0, 16);\n    #else\n    vec3 ro = vec3(0, 0, 60);\n    #endif\n    vec3 lo = vec3(0, MAX_HEIGHT*0.7, 0);\n    \n    lo.xz += vec2(1, 0.3) * iTime;\n    ce = lo.xz;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? -PI * .7 + iTime * .2 : -m.x * TAU + PI;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? PI * 0.23 : -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(pv, 2));\n\n    vec3 col = vec3(0);\n    \n    vec3 pl = ro;\n    float pt = 0.0;\n    if (pl.y > MAX_HEIGHT)\n    {\n        pt = -(pl.y - MAX_HEIGHT) / rd.y;\n        pl = pl + rd * pt;\n    }\n    \n    HitInfo hit;\n    bool isHit = trace(pl, rd, hit);\n    \n    vec3 pos = pl + rd * hit.t;\n    \n    float t = hit.t + pt;\n    \n    vec3 alb = palette2(map(hit.tp, 0.0) / MAX_HEIGHT * 2.0 + (hash12(hit.tp)-0.5)*0.15);\n    \n    col = alb;\n\n    col *= dot(abs(hit.n), vec3(0.85, 1, 0.7));\n    col *= smoothstep(MAX_HEIGHT*0.3, MAX_HEIGHT*0.8, pos.y)*0.8+0.2;\n    \n    vec3 ldir = normalize(vec3(1, 2.5, 0.6));\n    vec3 ref = reflect(rd, hit.n);\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + hit.n * EPS, ldir, hitL);\n    \n    float diff = max(dot(ldir, hit.n), 0.0) * float(!isHitL);\n    float bou = max(dot(ref, -ldir), 0.0);\n    \n    col *= diff*0.8+0.25;\n    col += alb * bou * 0.03;\n    \n    vec3 refCol = sRGBToLinear(textureLod(iChannel1, ref, 2.0).rgb) * palette2(0.0);\n    \n    float r0 = 0.08;\n    float fre = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, hit.n), 5.0);\n    \n    col = mix(col, refCol, fre * 0.6);\n    \n    #if 0\n    float a = 0.03;\n    float b = 0.1;\n    float fog = (a / b) * exp(-ro.y * b) * (1.0 - exp(-max(t - 20.0, 0.0) * rd.y * b)) / rd.y;\n    #else\n    float fog = 1.0 - exp(-max(t - 20.0, 0.0) * 0.01);\n    #endif\n    \n    #ifdef FOG\n    col = mix(col, palette2(0.0), saturate(fog));\n    #endif\n    \n    if (!isHit)\n        col = palette2(0.0);\n    \n    //float f = exp2(float(hit.i) / float(STEPS) * 4.0);\n    //f = float(hit.i) / float(STEPS) * 2.0;\n    //col = palette(f);\n      \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    col = mix(col, smoothstep(vec3(0), vec3(1), col), 0.2);\n    //col = ACESFilm(col);\n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define DYNAMIC_LOD\n#define FOG\n\n#define ENABLE_LOD\n\n#ifdef DYNAMIC_LOD\n#define MAX_LOD min(floor((cos(iTime*0.6)*0.5+0.5)*5.0), 3.0)\n#else\n#define MAX_LOD 3.0\n#endif\n\n#define ROUNDED\n//#define RADIUS 0.02\n#define RADIUS 0.012*(4.0 - MAX_LOD)\n\n#define MIN_HEIGHT 0.01\n#define MAX_HEIGHT 10.0\n\n#define STEPS 512\n#define MAX_DIST 1e2\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n// Rounded box ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 pos, in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n    \n    // Faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return 0.0;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    float t = MAX_DIST;\n    \n    // Corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b*b - c;\n        if( h>0.0 ) t = - b -sqrt(h);\n    }\n    \n    vec3 a = dd.yzx + dd.zxy;\n    vec3 b = od.yzx + od.zxy;\n    vec3 c = oo.yzx + oo.zxy - ra2;\n    vec3 h = b*b - a*c;\n    \n    // Edge X\n    if( h.x>0.0 )\n    {\n        float ht = (-b.x - sqrt(h.x)) / a.x;\n        if( ht>0.0 && ht<t && abs(ro.x+rd.x*ht)<size.x ) t = ht;\n    }\n    \n    // Edge Y\n    if( h.y>0.0 )\n    {\n        float ht = (-b.y - sqrt(h.y)) / a.y;\n        if( ht>0.0 && ht<t && abs(ro.y+rd.y*ht)<size.y ) t = ht;\n    }\n    \n    // Edge Z\n    if( h.z>0.0 )\n    {\n        float ht = (-b.z - sqrt(h.z)) / a.z;\n        if( ht>0.0 && ht<t && abs(ro.z+rd.z*ht)<size.z ) t = ht;\n    }\n    \n    return t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return .55 + .45 * cos(TAU * (vec3(1, 0.95, 1) * t + vec3(0, .25, .75)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mttGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1165, 1165, 1195, 1195, 2393], [2480, 2480, 2527, 2527, 5415], [5417, 5417, 5474, 5474, 8034]]}
{"id": "mtK3Rh", "name": "Additive vs. multiplicative", "author": "Slals", "description": "Click to invert colors", "tags": ["colors"], "likes": 5, "viewed": 161, "published": 3, "date": "1683576464", "time_retrieved": "2024-07-30T17:56:43.316454", "image_code": "#define M(C,s) col = mix(col, C, clamp(s,0.,1.))\n\nfloat circleSDF(vec2 uv, float s) {\n    return length(uv) - s + 1.0;\n}\nfloat fill(float x, float s) {\n    float pw = 1.0 / iResolution.y;\n    return smoothstep(x - pw, x + pw, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    col += (step(0.0, uv.x) - step(0.01, uv.x)) * vec3(1.0);\n    \n    vec3 r = vec3(1.0, 0.0, 0.0), g = vec3(0.0, 1.0, 0.0), b = vec3(0.0, 0.0, 1.0);\n    vec3 c = vec3(0.0, 1.0, 1.0), m = vec3(1.0, 0.0, 1.0), y = vec3(1.0, 1.0, 0.0);\n    \n    if (iMouse.z >= 1.0) {\n        r = c;\n        g = y;\n        b = m;\n        \n        c = vec3(1.0, 0.0, 0.0);\n        m = vec3(0.0, 0.0, 1.0);\n        y = vec3(0.0, 1.0, 0.0);\n \n    }\n    \n    float s = 0.2, yO = 0.25, xO = 0.42;\n    float leftACircle = fill(circleSDF(uv + vec2(xO, -yO * abs(sin(iTime))), s), 1.0);\n    float leftBCircle = fill(circleSDF(uv + vec2(xO, yO * abs(sin(iTime))), s), 1.0);\n    float rightACircle = fill(circleSDF(uv + vec2(-xO, -yO * abs(sin(iTime))), s), 1.0);\n    float rightBCircle = fill(circleSDF(uv + vec2(-xO, yO * abs(sin(iTime))), s), 1.0);\n    float midACircle = fill(circleSDF(uv + vec2(xO - 0.2 * sin(iTime), 0.0), s), 1.0);\n    float midBCircle = fill(circleSDF(uv + vec2((xO - 0.2 * sin(-iTime)) - xO * 2.01, 0.0), s), 1.0);\n    \n    col += leftACircle * r + leftBCircle * b;\n    col += rightACircle * c + rightBCircle * m;\n    col += midACircle * g + midBCircle * y;\n    \n    col = M(c * m, rightACircle + rightBCircle - 1.0);\n    col = M(y * c, midBCircle + rightACircle - 1.0);\n    col = M(y * m, midBCircle + rightBCircle - 1.0);\n    col = M(c * m * y, midBCircle + rightACircle + rightBCircle - 2.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtK3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 85, 85, 120], [121, 121, 151, 151, 231], [233, 233, 290, 340, 1888]]}
{"id": "dtK3Rh", "name": "Glow shader experiment found", "author": "mrange", "description": "CC0: Glow shader experiment found\nFound this old glow shader experiment\nBetter than I remembered it so publishing it now.\n\n", "tags": ["mandelbox"], "likes": 22, "viewed": 435, "published": 3, "date": "1683576349", "time_retrieved": "2024-07-30T17:56:44.192112", "image_code": "// CC0: Glow shader experiment found\n// Found this old glow shader experiment\n// I found it better than I remembered it so publishing it now.\n// Fractal based on EvilRyu's mandelbox\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define NORM_OFF    0.001\n\nconst int   max_iter      = 90;\nconst float fixed_radius2 = 1.8;\nconst float min_radius2   = 0.5;\nconst vec4  folding_limit = vec4(1.0);\nconst float scale         = -2.9-0.2;\n\nmat3 g_rot;\nfloat g_off;\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nmat3 rotX(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    1.0 , 0.0 , 0.0\n  , 0.0 , +c  , +s\n  , 0.0 , -s  , +c\n  );\n}\n\nmat3 rotY(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , 0.0 , +s\n  , 0.0 , 1.0 , 0.0\n  , -s  , 0.0 , +c\n  );\n}\n\nmat3 rotZ(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n    +c  , +s  , 0.0\n  , -s  , +c  , 0.0\n  , 0.0 , 0.0 , 1.0\n  );\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec4 pmin(vec4 a, vec4 b, vec4 k) {\n  vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid sphere_fold(inout vec4 z, inout float dz) {\n  float r2 = dot(z, z);\n    \n  float t1 = (fixed_radius2 / min_radius2);\n  float t2 = (fixed_radius2 / r2);\n\n  if (r2 < min_radius2) {\n    z  *= t1;\n    dz *= t1;\n  } else if (r2 < fixed_radius2) {\n    z  *= t2;\n    dz *= t2;\n  }\n}\n\nvoid box_fold(float k, inout vec4 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec4 zz = sign(z)*pmin(abs(z), folding_limit, vec4(k));\n  z = zz * 2.0 - z;\n}\n\nfloat mb(vec4 z, out float ss) {\n  float k = 0.1;\n  vec4 offset = z;\n  float dr = 1.0;\n  for(int n = 0; n < 5; ++n) {\n    box_fold(k/dr, z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n  }\n\n  float d0 = (box(z, vec4(3.5, 3.5, 3.5, 3.5))-0.2) / abs(dr);\n  ss = dr;\n  return d0;\n}\n\nfloat df(vec3 p, out float ss) {\n  const float z = 0.1;\n  p /= z;\n  vec4 p4 = vec4(p, g_off);\n  p4.yzw *= g_rot;\n    \n  float d0 = mb(p4, ss);\n  float d = d0;\n  return d*z;\n} \n\nvec3 glow(vec3 ro, vec3 rd, out float tt) {\n  float res;\n  float t = 0.+0.2;\n  int iter = max_iter;\n\n  vec3 col = vec3(0.0);    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    float ss;\n    res = df(p, ss);\n    float lss = log(ss);\n    float lum = 0.4*exp(-0.5*t-5.0*res*float(i*i));\n    vec3 gcol = ((0.5+0.5*cos(2.4-vec3(0.0, 1.0, 2.0)+1.2*(lss))))*lum;\n    col += gcol;\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n  \n  tt = t;\n    \n  return col;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  float ss;\n  nor.x = df(pos+eps.xyy, ss) - df(pos-eps.xyy, ss);\n  nor.y = df(pos+eps.yxy, ss) - df(pos-eps.yxy, ss);\n  nor.z = df(pos+eps.yyx, ss) - df(pos-eps.yyx, ss);\n  return normalize(nor);\n}\n\nvec3 render(vec2 p) {\n  float tm = TIME*0.5;\n  g_off = sin(tm*0.53);\n  g_rot = rotX(0.1*tm)*rotY(0.23*tm)*rotZ(0.31*tm);\n  vec3 lightDir = normalize(vec3(-1.0, 1.0, 1.0));\n  mat2 rot= ROT(TIME/10.0); \n  vec3 ro = 0.5*vec3(-1.0, 0.5, -0.0);\n  lightDir.xz *= rot;\n  ro.xz  *= rot;\n  vec3 la = vec3(0.0, 0.0, 0.0); \n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  float tt = 0.0;\n  vec3 col = vec3(0.0);\n  vec3 gcol = glow(ro, rd, tt);\n  vec3 pos = ro+rd*tt;\n  vec3 nor = normal(pos);\n  vec3 ref = reflect(rd, nor);\n \n  float ttt = tanh_approx(0.3*tt);\n  float diff  = max(dot(lightDir, nor), 0.0);\n  float spe   = pow(max(dot(lightDir, ref), 0.0), 40.0);\n  float fre   = dot(rd, nor) + 1.0;\n  fre *= fre;\n \n  float fog = exp(-0.75*tt);\n  float sfog = exp(-2.0*0.5*tt);\n  const vec3 scol = 4.0*vec3(1.0, 0.5, 0.5).zyx;\n  col += gcol;\n  col += spe*sfog*scol;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x*=RESOLUTION.x/RESOLUTION.y;\n\n \n  vec3 col = render(p);\n  col -= 0.05*vec3(1.0, 2.0, 1.0);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtK3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[591, 651, 679, 745, 821], [823, 923, 942, 942, 1029], [1031, 1138, 1164, 1164, 1348], [1350, 1350, 1370, 1370, 1490], [1492, 1492, 1512, 1512, 1632], [1634, 1634, 1654, 1654, 1776], [1778, 1778, 1805, 1805, 1902], [1904, 1904, 1943, 1943, 2031], [2033, 2033, 2068, 2068, 2153], [2155, 2155, 2203, 2203, 2435], [2437, 2437, 2491, 2535, 2615], [2617, 2617, 2649, 2649, 2939], [2941, 2941, 2973, 2973, 3115], [3118, 3118, 3161, 3161, 3638], [3640, 3640, 3663, 3663, 3907], [3909, 3909, 3930, 3930, 4931], [4933, 4933, 4990, 4990, 5238]]}
{"id": "DlVGz1", "name": "beepbopboop", "author": "greg1998", "description": "pattern, balls, moving", "tags": ["balls", "moving", "pattern"], "likes": 2, "viewed": 108, "published": 3, "date": "1683571407", "time_retrieved": "2024-07-30T17:56:45.063782", "image_code": "vec3 hsv2rgb(vec3 c) {\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy / iResolution.xy - 0.5;\n    p.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 2.1;\n    vec3 camPos = vec3(0.0, 0.0, -3.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n    vec3 camUp = cross(camDir, camRight);\n    vec3 rayDir = normalize(vec3(p, 1.0) * mat3(camRight, camUp, camDir));\n    \n    vec3 col = vec3(0.0);\n    float dist = 100.0;\n    \n    for (int i = 0; i < 50; i++) {\n        vec3 pos = camPos + rayDir * dist;\n        float d = length(pos - vec3(sin(pos.z * 0.5 + time), cos(pos.x * 0.5 + time), sin(pos.y * 0.5 + time)));\n        \n        col += hsv2rgb(vec3(d * 0.1 + time * 0.05, 1.0, 1.0));\n        dist += 0.05;\n    }\n    \n    fragColor = vec4(col / 50.0, 1.0);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.45));\n    fragColor.r = mix(fragColor.r, fract(sin(dot(fragColor.rgb, vec3(12.9898, 78.233, 98.422)) * 43758.5453)), 0.1);\n    fragColor.g = mix(fragColor.g, fract(sin(dot(fragColor.rgb, vec3(12.9898, 78.233, 98.422)) * 43758.5453)), 0.1);\n    fragColor.b = mix(fragColor.b, fract(sin(dot(fragColor.rgb, vec3(12.9898, 78.233, 98.422)) * 43758.5453)), 0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlVGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 225], [227, 227, 282, 282, 1524]]}
{"id": "DtVGz1", "name": "upupup v2", "author": "greg1998", "description": "dripping up smooth", "tags": ["dripping", "smooth", "up"], "likes": 0, "viewed": 95, "published": 3, "date": "1683570974", "time_retrieved": "2024-07-30T17:56:45.833723", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 8.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = iTime * 2.1;\n    \n    // Create a swirling pattern\n    float r = length(uv);\n    float angle = atan(uv.y, uv.x);\n    float swirl = sin(time + r * 10.0) * 0.1;\n    angle += swirl * (1.1 - smoothstep(0.0, 1.0, r));\n    uv = vec2(cos(angle), sin(angle)) * r;\n    \n    // Add dripping effect\n    float drip = sin(time * 0.1 + uv.y * 20.0) * 0.2;\n    uv.y += drip * (4564563.0 - smoothstep(0.0, 1.0, r));\n    \n    // Create a bright, swirly color palette\n    vec3 color = vec3(0.5, 0.5, 0.5) + 0.5 * vec3(\n        0.5 + 0.5 * sin(time * 1.0 + uv.y * 360.0),\n        0.5 + 0.5 * sin(time * 2.0 + uv.x * 60.0),\n        0.5 + 0.5 * sin(time * 3.0 + r * 47.0)\n    );\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 873]]}
{"id": "DtKGz1", "name": "upupup", "author": "greg1998", "description": "dripping up", "tags": ["glitch", "dripping", "up"], "likes": 0, "viewed": 103, "published": 3, "date": "1683570315", "time_retrieved": "2024-07-30T17:56:46.606657", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 8.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = iTime * 2.1;\n    \n    // Create a swirling pattern\n    float r = length(uv);\n    float angle = atan(uv.y, uv.x);\n    float swirl = sin(time + r * 10.0) * 0.1;\n    angle += swirl * (1.1 - smoothstep(0.0, 1.0, r));\n    uv = vec2(cos(angle), sin(angle)) * r;\n    \n    // Add dripping effect\n    float drip = sin(time * 0.1 + uv.y * 20.0) * 0.2;\n    uv.y += drip * (7.0 - smoothstep(0.0, 1.0, r));\n    \n    // Create a bright, swirly color palette\n    vec3 color = vec3(0.5, 0.5, 0.5) + 0.5 * vec3(\n        0.5 + 0.5 * sin(time * 1.0 + uv.y * 360.0),\n        0.5 + 0.5 * sin(time * 2.0 + uv.x * 60.0),\n        0.5 + 0.5 * sin(time * 3.0 + r * 47.0)\n    );\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtKGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 867]]}
{"id": "DtVGzh", "name": "peekv1", "author": "kesh", "description": "sampeekv1 test", "tags": ["cineshader"], "likes": 3, "viewed": 1262, "published": 3, "date": "1683563473", "time_retrieved": "2024-07-30T17:56:47.352662", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center1 = vec2(0.3 + 0.1 * cos(iTime), 0.3 + 0.1 * sin(iTime));\n    vec2 center2 = vec2(0.5 + 0.1 * cos(iTime + 1.0), 0.4 + 0.1 * sin(iTime + 1.0));\n    vec2 center3 = vec2(0.7 + 0.1 * cos(iTime + 2.0), 0.3 + 0.1 * sin(iTime + 2.0));\n    vec2 center4 = vec2(0.4 + 0.1 * cos(iTime + 3.0), 0.6 + 0.1 * sin(iTime + 3.0));\n    vec2 center5 = vec2(0.6 + 0.1 * cos(iTime + 4.0), 0.6 + 0.1 * sin(iTime + 4.0));\n\n    vec2 centers[5] = vec2[](\n        center1,\n        center2,\n        center3,\n        center4,\n        center5\n    );\n\n    float radii[5] = float[](\n        0.15,\n        0.1,\n        0.2,\n        0.05,\n        0.1\n    );\n\n    vec3 colors[5] = vec3[](\n        vec3(0.265,0.890,0.294),\n        vec3(0.800,0.484,0.238),\n        vec3(0.775,0.319,0.185),\n        vec3(0.9, 0.2, 0.1),\n        vec3(0.314,0.221,0.900)\n    );\n\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++) {\n        float dist = length(fragCoord - centers[i] * iResolution.xy) - radii[i] * min(iResolution.x, iResolution.y);\n        if (dist < 0.0) {\n            color += colors[i];\n            fragColor.a = 0.5;\n        }\n    }\n\n    fragColor.rgb = mix(vec3(0.044,0.059,0.140), color, step(0.032, color.r + color.g + color.b));\n}\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtVGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ctVGRh", "name": "vvhhss", "author": "greg1998", "description": "vhs, feedback, lofi", "tags": ["feedback", "vhs", "lofi"], "likes": 0, "viewed": 148, "published": 3, "date": "1683556642", "time_retrieved": "2024-07-30T17:56:49.157835", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set up time variable\n    float time = iTime * 0.2;\n\n    // Normalize pixel coordinates\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Apply feedback loop\n    p *= 1.5;\n    p = fract(p * 0.5 + vec2(time * 0.3, time * 0.2));\n    p /= 1.5;\n\n    // Generate color\n    vec3 col = vec3(0.0);\n    col.r = abs(sin(p.x * 162.0 + time * 20.0));\n    col.g = abs(sin(p.y * 1.0 + time * 4.0));\n    col.b = abs(sin((p.x + p.y) * 8.0 + time * 50.0));\n\n    // Add VHS-style distortion\n    col += 0.09 * vec3(sin(fragCoord.y * 0.11 + time), cos(fragCoord.x * 0.01 + time * 1.1), sin(fragCoord.x * 0.60 + time * 0.7));\n\n    // Output final color\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVGRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 83, 773]]}
{"id": "Dlt3Ds", "name": "Why #define ZERO (min(iFrame,0))", "author": "mrmcsoftware", "description": "Why do people use \"#define ZERO (min(iFrame,0))\" instead of 0 (usually in for loop)?  This shader proves iFrame is never negative (at least in terms of the bounds of this test). Force the compiler to do something? Time delay?  What's the reason to use it?", "tags": ["glsl", "shadertoy", "coding", "programming", "uniforms", "iframe"], "likes": 3, "viewed": 257, "published": 3, "date": "1683553893", "time_retrieved": "2024-07-30T17:56:50.211020", "image_code": "void mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\nvec2 uv=FragCoord.xy/iResolution.xy;\nFragColor=vec4(0.0);\nvec3 col;\nif (iFrame==-5) { col=vec3(127.0,0.0,0.0); }\nelse if (iFrame==-4) { col=vec3(255.0,255.0,0.0); }\nelse if (iFrame==-3) { col=vec3(0.0,255.0,255.0); } \nelse if (iFrame==-2) { col=vec3(255.0,255.0,255.0); }\nelse if (iFrame==-1) { col=vec3(255.0,0.0,255.0); }\nelse if (iFrame==0) { col=vec3(255.0,0.0,0.0); }\nelse if (iFrame==1) { col=vec3(0.0,255.0,0.0); }\nelse if (iFrame==2) { col=vec3(0.0,0.0,255.0); }\nelse if (iFrame==3) { col=vec3(127.0,127.0,127.0); }\nelse if (iFrame==4) { col=vec3(0.0,127.0,127.0); }\nelse if (iFrame==5) { col=vec3(127.0,127.0,0.0); }\nelse if (iFrame==6) { col=vec3(127.0,0.0,127.0); }\nelse if (iFrame==7) { col=vec3(0.0,0.0,127.0); }\nelse if (iFrame==8) { col=vec3(0.0,127.0,0.0); }\nelse { col=vec3(0.0,0.0,0.0); }\nfloat yvs=float(iFrame+5)/14.0;\nfloat yve=float(iFrame+6)/14.0;\nif ((uv.x>.8)&&(uv.y<yve)&&(uv.y>=yvs)) { col=vec3(col/255.0); }\nelse { col=vec3(0.0); }\nFragColor=texture(iChannel0,uv)+texture(iChannel1,uv)+texture(iChannel2,uv)+texture(iChannel3,uv)+vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv=fragCoord.xy/iResolution.xy;\nfragColor=texture(iChannel0,uv);\nvec3 col;\nif (iFrame==-5) { col=vec3(127.0,0.0,0.0); }\nelse if (iFrame==-4) { col=vec3(255.0,255.0,0.0); }\nelse if (iFrame==-3) { col=vec3(0.0,255.0,255.0); }\nelse if (iFrame==-2) { col=vec3(255.0,255.0,255.0); }\nelse if (iFrame==-1) { col=vec3(255.0,0.0,255.0); }\nelse if (iFrame==0) { col=vec3(255.0,0.0,0.0); }\nelse if (iFrame==1) { col=vec3(0.0,255.0,0.0); }\nelse if (iFrame==2) { col=vec3(0.0,0.0,255.0); }\nelse if (iFrame==3) { col=vec3(127.0,127.0,127.0); }\nelse if (iFrame==4) { col=vec3(0.0,127.0,127.0); } \nelse if (iFrame==5) { col=vec3(127.0,127.0,0.0); } \nelse if (iFrame==6) { col=vec3(127.0,0.0,127.0); }\nelse if (iFrame==7) { col=vec3(0.0,0.0,127.0); } \nelse if (iFrame==8) { col=vec3(0.0,127.0,0.0); } \nelse { col=vec3(0.0,0.0,0.0); }\nfloat yvs=float(iFrame+5)/14.0;\nfloat yve=float(iFrame+6)/14.0;\nif ((uv.x<.19)&&(uv.y<yve)&&(uv.y>=yvs)) { fragColor=vec4(col/255.0,1.0); }\nfloat x=.2-.12;\nfor (int i=-5;i<=8;i++)\n    {\n    yvs=float(i+5)/14.0;\n    if (i<0) { fragColor+=dchar(iChannel3,(uv-vec2(x+.05-.027,yvs+.005))*16.0,45).x; }\n    fragColor+=dchar(iChannel3,(uv-vec2(x+.05,yvs))*16.0,i<0?-i+48:i+48).x;\n    fragColor+=dchar(iChannel3,(uv-vec2(x-.08,yvs))*16.0,65).x;\n    }\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv=fragCoord.xy/iResolution.xy;\nfragColor=texture(iChannel0,uv);\nvec3 col;\nif (iFrame==-5) { col=vec3(127.0,0.0,0.0); }\nelse if (iFrame==-4) { col=vec3(255.0,255.0,0.0); }\nelse if (iFrame==-3) { col=vec3(0.0,255.0,255.0); }\nelse if (iFrame==-2) { col=vec3(255.0,255.0,255.0); }\nelse if (iFrame==-1) { col=vec3(255.0,0.0,255.0); }\nelse if (iFrame==0) { col=vec3(255.0,0.0,0.0); }\nelse if (iFrame==1) { col=vec3(0.0,255.0,0.0); }\nelse if (iFrame==2) { col=vec3(0.0,0.0,255.0); }\nelse if (iFrame==3) { col=vec3(127.0,127.0,127.0); }\nelse if (iFrame==4) { col=vec3(0.0,127.0,127.0); } \nelse if (iFrame==5) { col=vec3(127.0,127.0,0.0); } \nelse if (iFrame==6) { col=vec3(127.0,0.0,127.0); }\nelse if (iFrame==7) { col=vec3(0.0,0.0,127.0); } \nelse if (iFrame==8) { col=vec3(0.0,127.0,0.0); } \nelse { col=vec3(0.0,0.0,0.0); }\nfloat yvs=float(iFrame+5)/14.0;\nfloat yve=float(iFrame+6)/14.0;\nif ((uv.x<.39)&&(uv.x>.2)&&(uv.y<yve)&&(uv.y>=yvs)) { fragColor=vec4(col/255.0,1.0); }\nfloat x=.4-.12;\nfor (int i=-5;i<=8;i++)\n    {\n    yvs=float(i+5)/14.0;\n    if (i<0) { fragColor+=dchar(iChannel3,(uv-vec2(x+.05-.027,yvs+.005))*16.0,45).x; }\n    fragColor+=dchar(iChannel3,(uv-vec2(x+.05,yvs))*16.0,i<0?-i+48:i+48).x;\n    fragColor+=dchar(iChannel3,(uv-vec2(x-.08,yvs))*16.0,66).x;\n    }\n}", "buffer_b_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv=fragCoord.xy/iResolution.xy;\nfragColor=texture(iChannel0,uv);\nvec3 col;\nif (iFrame==-5) { col=vec3(127.0,0.0,0.0); }\nelse if (iFrame==-4) { col=vec3(255.0,255.0,0.0); }\nelse if (iFrame==-3) { col=vec3(0.0,255.0,255.0); }\nelse if (iFrame==-2) { col=vec3(255.0,255.0,255.0); }\nelse if (iFrame==-1) { col=vec3(255.0,0.0,255.0); }\nelse if (iFrame==0) { col=vec3(255.0,0.0,0.0); }\nelse if (iFrame==1) { col=vec3(0.0,255.0,0.0); }\nelse if (iFrame==2) { col=vec3(0.0,0.0,255.0); }\nelse if (iFrame==3) { col=vec3(127.0,127.0,127.0); }\nelse if (iFrame==4) { col=vec3(0.0,127.0,127.0); } \nelse if (iFrame==5) { col=vec3(127.0,127.0,0.0); } \nelse if (iFrame==6) { col=vec3(127.0,0.0,127.0); }\nelse if (iFrame==7) { col=vec3(0.0,0.0,127.0); } \nelse if (iFrame==8) { col=vec3(0.0,127.0,0.0); } \nelse { col=vec3(0.0,0.0,0.0); }\nfloat yvs=float(iFrame+5)/14.0;\nfloat yve=float(iFrame+6)/14.0;\nif ((uv.x<.59)&&(uv.x>.4)&&(uv.y<yve)&&(uv.y>=yvs)) { fragColor=vec4(col/255.0,1.0); }\nfloat x=.6-.12;\nfor (int i=-5;i<=8;i++)\n    {\n    yvs=float(i+5)/14.0;\n    if (i<0) { fragColor+=dchar(iChannel3,(uv-vec2(x+.05-.027,yvs+.005))*16.0,45).x; }\n    fragColor+=dchar(iChannel3,(uv-vec2(x+.05,yvs))*16.0,i<0?-i+48:i+48).x;\n    fragColor+=dchar(iChannel3,(uv-vec2(x-.08,yvs))*16.0,67).x;\n    }\n}", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv=fragCoord.xy/iResolution.xy;\nfragColor=texture(iChannel0,uv);\nvec3 col;\nif (iFrame==-5) { col=vec3(127.0,0.0,0.0); }\nelse if (iFrame==-4) { col=vec3(255.0,255.0,0.0); }\nelse if (iFrame==-3) { col=vec3(0.0,255.0,255.0); }\nelse if (iFrame==-2) { col=vec3(255.0,255.0,255.0); }\nelse if (iFrame==-1) { col=vec3(255.0,0.0,255.0); }\nelse if (iFrame==0) { col=vec3(255.0,0.0,0.0); }\nelse if (iFrame==1) { col=vec3(0.0,255.0,0.0); }\nelse if (iFrame==2) { col=vec3(0.0,0.0,255.0); }\nelse if (iFrame==3) { col=vec3(127.0,127.0,127.0); }\nelse if (iFrame==4) { col=vec3(0.0,127.0,127.0); } \nelse if (iFrame==5) { col=vec3(127.0,127.0,0.0); } \nelse if (iFrame==6) { col=vec3(127.0,0.0,127.0); }\nelse if (iFrame==7) { col=vec3(0.0,0.0,127.0); } \nelse if (iFrame==8) { col=vec3(0.0,127.0,0.0); } \nelse { col=vec3(0.0,0.0,0.0); }\nfloat yvs=float(iFrame+5)/14.0;\nfloat yve=float(iFrame+6)/14.0;\nif ((uv.x<.79)&&(uv.x>.6)&&(uv.y<yve)&&(uv.y>=yvs)) { fragColor=vec4(col/255.0,1.0); }\nfloat x=.8-.12;\nfor (int i=-5;i<=8;i++)\n    {\n    yvs=float(i+5)/14.0;\n    if (i<0) { fragColor+=dchar(iChannel3,(uv-vec2(x+.05-.027,yvs+.005))*16.0,45).x; }\n    fragColor+=dchar(iChannel3,(uv-vec2(x+.05,yvs))*16.0,i<0?-i+48:i+48).x;\n    fragColor+=dchar(iChannel3,(uv-vec2(x-.08,yvs))*16.0,68).x;\n    }\n}", "buffer_d_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 dchar(sampler2D chan,vec2 p,int c)\n{\nvec2 dFdx=dFdx(p/16.0),dFdy=dFdy(p/16.0);\nif ((p.x<0.0)||(p.x>1.0)||(p.y<0.0)||(p.y>1.0)) return(vec4(0,0,0,1e5));\nreturn(textureGrad(chan,p/16.0+fract(vec2(c,15-c/16)/16.0),dFdx,dFdy));\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlt3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1132]]}
{"id": "dtG3z1", "name": "Nitor office sun shader", "author": "shaiggon", "description": "Starfield copied from https://www.shadertoy.com/view/WtVBRG otherwise original", "tags": ["sun", "80s", "synthwave"], "likes": 0, "viewed": 147, "published": 3, "date": "1683553086", "time_retrieved": "2024-07-30T17:56:50.957025", "image_code": "vec4 sun(vec2 uv, float time)\n{\n    vec3 sunUp = vec3(250.0/255.0, 242.0/255.0, 0.0);\n    vec3 sunDown = vec3(252.0/255.0, 0.0, 140.0/255.0);\n    //float sunTopPosition = 0.\n    float gapSize = 0.2;\n    float gapFrequency = 0.03;\n    float sunSize = 0.19;\n    float gapSpeed = 0.007;\n    if (length(uv + vec2(0.0, -0.05)) < sunSize\n        && mod(uv.y + time*gapSpeed, gapFrequency) > gapSize * gapFrequency)\n    {\n        return vec4(mix(sunUp, sunDown, 1.1 - (uv.y / 0.4 + 0.5)), 1.0);\n    }\n    return vec4(0.0);\n}\n\nvec4 neonFloor(vec2 uv, float time)\n{\n    float t = time * 0.2;\n    vec3 baseFloor = vec3(10.0/255.0, 26.0/255.0, 48.0/255.0);\n    vec3 lightFloor = vec3(208.0/255.0, 0.0/255.0, 255.0/255.0);\n    if (uv.y < -0.06)\n    {\n        if (mod(uv.x / uv.y + sin(t), 1.1) < 0.05)\n        {\n            return vec4(lightFloor, 1.0);\n        }\n        \n        if (mod((uv.y + 0.5) / (uv.y - 0.05) - t, 0.4) < 0.2*-uv.y) {\n            return vec4(lightFloor, 1.0);\n        }\n        return vec4(baseFloor, 1.0);\n    }\n    return vec4(0.0);\n}\n\nvec4 middleGlow(vec2 uv, float time)\n{\n    float middlePoint = -0.06; // Modified uv\n    float dist = abs(uv.y - middlePoint);\n    float radialDist = length(uv*vec2(0.02, 1.0) - vec2(0.0, middlePoint));\n    //return vec4(111.0/255.0, 0.0/255.0, 255.0/255.0, clamp(1.0 - dist*9.0, 0.0, 1.0)) * 0.6\n    //    + vec4(1.0, 1.0, 1.0, clamp(1.0 - dist*20.0, 0.0, 1.0))*0.6;\n    vec4 col = vec4(111.0/255.0, 0.0/255.0, 255.0/255.0, 1.0 - dist*4.0);\n    col = mix(vec4(1.0, 1.0, 1.0, 1.0 / (1. + radialDist*20.)), col, 1.-1. / (1. + radialDist*20.));\n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 sunRays(vec2 uv, float time)\n{\n    float t = 0.1 * time;\n    float PI = 3.14159265359;\n    vec3 ray1 = vec3(252.0/255.0, 0.0, 140.0/255.0);\n    vec3 ray2 = vec3(250.0/255.0, 242.0/255.0, 0.0);\n    vec2 sunPosition = vec2(0.0, -0.05);\n    vec2 p = uv + sunPosition;\n    float c = round(mod(atan(p.y / p.x) * PI * 2.0 + t, 0.6) * 1.0/(0.6));\n    //return ray1 * \n    return (c * ray1 + (1.0 - c) * ray2) * 0.4 * clamp(1.0-length(p*2.0), 0.0, 1.0) * clamp(length(p*3.0), 0.0, 1.0);\n}\n\n\n\n//Shamelessly copied from https://www.shadertoy.com/view/WtVBRG\n// Some values changed\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvec4 starfield(vec2 C) {\n    vec4 O=vec4(0);\n    vec3 p=vec3(0.),r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,g=0.,e=0.,s=0.;\n        ++i<40.;\n        O.xyz+=5e-5*abs(cos(vec3(3,2,1)+log(s*9.)))/dot(p,p)/e\n    )\n    {\n        p=g*d;\n        p.z+=iTime*.01;\n        p=R(p,normalize(vec3(1,2,3)),.5);   \n        s=2.5;\n        p=abs(mod(p-1.,2.)-1.)-1.;\n        \n        for(int j=0;j++<10;)\n            p=1.-abs(p-vec3(-1.)),\n            s*=e=-1.8/dot(p,p),\n            p=p*e-.7;\n            g+=e=abs(p.z)/s+.001;\n     }\n     return O /= 16.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col = vec3(0.0);\n    \n    //float beat = length(texture(iChannel0, vec2(0.0, 1.0)));\n    \n    vec2 mUV = vec2(uv.x - 0.5, (uv.y - 0.5) * (iResolution.y / iResolution.x));\n    \n    vec4 col = neonFloor(mUV, iTime);\n    if (col.w < 0.5)\n    {\n        col += sun(mUV, iTime);\n    }\n    /*if (col.w < 0.5)\n    {\n        col += vec4(sunRays(mUV, iTime), 1.0);\n    }*/\n    \n    vec4 mg = middleGlow(mUV, iTime);\n    \n    \n    \n    col = vec4(mix(col.xyz, mg.xyz, mg.w), 1.0) + pow(length(mUV), 1.3)*starfield(fragCoord)+ length(mUV)*vec4(0.3, 0.0, 0.0, 1.0);\n    \n    \n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtG3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 517], [519, 519, 556, 556, 1049], [1051, 1051, 1089, 1089, 1628], [1630, 1630, 1665, 1665, 2115], [2265, 2265, 2289, 2289, 2842], [2845, 2845, 2902, 2952, 3705]]}
{"id": "mtdGRN", "name": "Path tracer attempt 4 v1.5", "author": "pathtracerenthusiast", "description": "A path tracer with bloom, HDR, glossy reflections, multiple shapes, large amounts of configuration, glass, lights, and a good sky. I’ve used stuff from Sebastian Lague and stuff produced by Bing AI and Ingo Quilez. Based on 3: 2.3. Demofox's tut was used.", "tags": ["pathtracer"], "likes": 1, "viewed": 253, "published": 3, "date": "1683549693", "time_retrieved": "2024-07-30T17:56:52.134876", "image_code": "//To change camera settings or the scene, go to the 'Buffer A' tab.\n//To change the bloom threshold settings, go to the 'Buffer B' tab.\n//To set or rwmove the maximum number of frames or objects go to the 'Common' tab.\n\n#define Bloom\n\n#define exposure .8\n\n//I used the Bing AI to improve this code.\nvec3 blur(sampler2D s, vec2 p, int w) {\n  vec2 invRes = 1. / vec2(textureSize(s, 0));\n  vec3 color = vec3(0.);\n  float n = 1./float(2*w*w);\n  const float invpi = 1./PI;\n  for (int x = -w; x <= w; x++) {\n    for (int y = -w; y <= w; y++) {\n      vec2 uv = p + vec2(x, y) * invRes;\n      float weight = n*invpi*exp(-float(x*x+y*y)*n);\n      //float weight = 1.;\n      color += texture(s, uv).xyz*weight;\n    }\n  }\n  return color;\n}\n\n#define size 2.25*((R.x+R.y)*.00119048)\nvoid mainImage( out vec4 o,  vec2 i )\n{\n    vec2 p = R-10.;\n    #ifdef maxFrame\n    if(i.x>=p.x&&i.y>=p.y&&iFrame>maxFrame){o=vec4(1.);return;}\n    #endif\n    o = texelFetch(iChannel0,ivec2(i),0);\n    o /= o.w;\n    \n    #ifdef Bloom\n    #ifdef maxFrame\n    if(iFrame>=maxFrame)\n    #endif\n    o.xyz += blur(iChannel1,i/R,int(size));\n    #endif\n    \n    \n    o.xyz *= exposure;\n    \n    o.xyz = ACESFilm(o.xyz);\n    o.xyz = linearToSRGB(o.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define maxFrame 256\n\n#define R iResolution.xy\n#define PI 3.1415926523\n#define d2r(a) a*(PI/180.)\n#define md(a,b) max(0.,dot(a,b))\n\nfloat _seed;\n// Thanks to Dave_Hoskin for the random numbers\nfloat rand(){\n    float v = fract(_seed*.1031);\n    v *= _seed + 33.33;\n    v *= _seed + _seed;\n    v += 34.35;\n    float a = fract(v);\n    _seed++;\n    _seed *= 2.*a;\n    return a;\n}\n\nvec2 rand2(){\n    vec3 p = fract(_seed*vec3(.1031,.103,.0973));\n    p += dot(p,p.yzx+33.33);\n    vec2 a = fract((p.xx+p.yz)*p.zy);\n    _seed++;\n    _seed *= a.x+a.y;\n    return a;\n}\n\nvoid irand(vec2 i,float t){\n    vec3 p = vec3(i.y,t,i.x);\n    p = fract(p*.1031);\n    p += dot(p,p.zyx+32.31);\n    _seed = fract((p.x+p.y)*p.z);\n}\n\nmat3 rot3(vec3 a){\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    \n    mat3 xm = mat3(1., 0., 0.,\n                   0., c.x, -s.x,\n                   0., s.x, c.x );\n    \n    mat3 ym = mat3(c.y, 0.,-s.y,\n                   0.,1.,0.,\n                   s.y,0.,c.y);\n    \n    mat3 zm = mat3(c.z,s.z,0.,\n                   -s.z,c.z,0.,\n                   0.,0.,1.);\n    \n    \n    return xm*ym*zm;\n}\n\n\nstruct Mat {\n    float r;\n    float IOR;\n    vec3 col;\n    vec3 ems;\n    float spcCh;\n    vec3 spcCl;\n    float rfaCh;\n    vec3 absorb;\n};\n\n\nstruct AABB {\n    vec3 minv,maxv;\n};\n\nstruct SphBody {\n    vec3 c;\n    float rad;\n    bool isActive;\n};\n\nstruct BoxBody {\n    vec3 pos,size,rot;\n    bool inverted, isActive;\n};\n\nstruct QuadBody {\n    vec3 v0,v1,v2,v3;\n    bool fn, isActive;\n};\n\nstruct Obj {\n    SphBody sph;\n    BoxBody box;\n    QuadBody quad;\n    Mat mat;\n    AABB bound;\n};\n\nstruct BVHNode {\n    AABB bound;\n    uint left,right;\n};\n\nstruct Viewer {\n    vec3 uu;\n    vec3 vv;\n    vec3 ww;\n    vec3 ro;\n};\n\nstruct NewHit {\n    float len;\n    vec3 nor;\n    Obj o;\n    bool ff;\n};\n\nstruct IntRes {\n    float len;\n    bool ff;\n};\n\n#define DefaultSph SphBody(vec3(0.),0.,false)\n#define DefaultBox BoxBody(vec3(0.),vec3(0.),vec3(0.),false,false)\n#define DefaultQuad QuadBody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),false,false)\n\n#define objC 9\nstruct NewWorld {\n    Obj objs[objC];\n    Viewer camera;\n};\n\nObj Obj_Sphere(vec3 pos,float rad,Mat m){\n    AABB bound = AABB(pos-rad-.0001,pos+rad+.0001);\n    return Obj(SphBody(pos,rad,true),DefaultBox,DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowSphere(vec3 pos,float rad,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Sphere(pos,rad,m);\n    objlst[idx1] = Obj_Sphere(pos,thickness-rad,m);\n}\n\nObj Obj_Box(vec3 pos,vec3 size,vec3 rot,Mat m){\n    AABB bound = AABB(pos-2.*size-.001,pos+2.*size+.0001);\n    return Obj(DefaultSph,BoxBody(pos,size,rot,false,true),DefaultQuad,m,bound);\n}\n\nvoid createObj_HollowBox(vec3 pos,vec3 size,vec3 rot,float thickness,int idx0,int idx1,Mat m,inout Obj objlst[objC]){\n    objlst[idx0] = Obj_Box(pos,size,rot,m);\n    AABB bound = AABB(pos-2.*abs(size)-.001+thickness,pos+2.*abs(size)+.0001-thickness);\n    objlst[idx1] = Obj(DefaultSph,BoxBody(pos,size-thickness,rot,true,true),DefaultQuad,m,bound);\n}\n\nObj Obj_Quad(vec3 v0,vec3 v1,vec3 v2,vec3 v3,bool fn,Mat m){\n    vec3 minv = min(min(v0,v1),min(v2,v3));\n    vec3 maxv = max(max(v0,v1),max(v2,v3));\n    AABB bound = AABB(minv,maxv);\n    return Obj(DefaultSph,DefaultBox,QuadBody(v0,v1,v2,v3,fn,true),m,bound);\n}\n\nIntRes newSphereInt( in vec3 ro, vec3 rd, SphBody sph) {\n    ro -= sph.c;\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - sph.rad*sph.rad;\n    float h = b*b - c;\n    if( h<0. ) return IntRes(-1.,false);\n    h = sqrt( h );\n    if(length(ro)<=sph.rad){\n        return IntRes(-b+h,false);\n    }else{\n        return IntRes(-b-h,true);\n    }\n}\n\nbool insideAabb(vec3 p,vec3 s){\n    return (p.x<=s.x&&p.x>=-s.x)&&(p.y<=s.y&&p.y>=-s.y)&&(p.z<=s.z&&p.z>=-s.z);\n}\n\nIntRes newBoxInt( in vec3 ro, in vec3 rd, BoxBody box) {\n    mat3 r = rot3(-box.rot);\n    \n    ro, rd *= r;\n    ro -= box.pos;\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*abs(box.size);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return IntRes(-1.,false);\n    if(insideAabb(ro,abs(box.size))){\n        return IntRes(tF,box.inverted);\n    }else{\n        return IntRes(tN,!box.inverted);\n    }\n}\n\nfloat newQuadInt(vec3 ro,vec3 rd,QuadBody q){\n    vec3 n = cross(q.v1-q.v0,q.v2-q.v0);\n    float d = dot(n, q.v0);\n    \n    float nd = dot(n, rd);\n    if (abs(nd) < 1e-6) return -1.;\n    \n    float t = (d - dot(n, ro)) / nd;\n    if (t < 0.) return -1.;\n    vec3 p = ro + t * rd;\n    \n    vec3 e0 = q.v1 - q.v0;\n    vec3 e1 = q.v2 - q.v1;\n    vec3 e2 = q.v3 - q.v2;\n    vec3 e3 = q.v0 - q.v3;\n    vec3 c0 = p - q.v0;\n    vec3 c1 = p - q.v1;\n    vec3 c2 = p - q.v2;\n    vec3 c3 = p - q.v3;\n    if (dot(n, cross(e0, c0)) > 0. &&\n        dot(n, cross(e1, c1)) > 0. &&\n        dot(n, cross(e2, c2)) > 0. &&\n        dot(n, cross(e3, c3)) > 0.) {\n        return t;\n    }\n    \n    return -1.;\n}\n\nbool aabbInt(in vec3 ro,vec3 rd,AABB box){\n    vec3 a = .5*(box.maxv+box.minv);\n    vec3 d = .5*(box.maxv-box.minv);\n    vec3 m = 1./rd;\n    vec3 n = m*(ro-a); \n    vec3 k = abs(m)*d;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return false;\n    return true;\n}\n\n\n\nconst float bias = 1.0001;\nvec3 newBoxNor(vec3 p,BoxBody b){\n    vec3 q = p-b.pos;\n    vec3 d = b.size;\n    return normalize(vec3(ivec3(q/d*bias)));\n}\n\nvec3 cosDir(vec3 nor)\n{\n    float u = rand();\n    float v = rand();\n    float a = 2.*PI*v; float b = 2.*u-1.;\n    vec3 dir = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(nor+dir);\n}\nvec3 uniformVec(void)\n{\n    float phi = rand()*2.*PI;\n    float z = rand()*2.-1.;\n    float r = sqrt(1.-z*z);\n    float x = r*cos(phi), y = r*sin(phi);\n\treturn vec3(x,y,z);\n}\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c,-s,\n                 s, c);\n}\nfloat reflectance(float cosv,float refidx){\n    float r0 = (1.-refidx)/(1.+refidx);\n    r0 *= r0;\n    return r0+(1.-r0)*pow(1.-cosv,5.);\n}\nvec3 hemi(vec3 h){\n    return reflect(uniformVec(),h);\n}\n\n\nvec3 LessThan(vec3 f, float val) {\n    return vec3(\n        (f.x < val) ? 1. : 0.,\n        (f.y < val) ? 1. : 0.,\n        (f.z < val) ? 1. : 0.);\n}\n \nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - .055,\n        rgb * 12.92,\n        LessThan(rgb, .0031308)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n     \n    return mix(\n        pow(((rgb + .055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        LessThan(rgb, 0.04045)\n    );\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0., 1.);\n}\n\nfloat fresnel(float n1, float n2, vec3 nor, vec3 I, float f0, float f90) {\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(nor, I);\n        if (n1 > n2) {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.) return f90;\n            cosX = sqrt(1.-sinT2);\n        }\n        float x = 1.-cosX;\n        float ret = r0+(1.-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}", "buffer_a_code": "//NOTE: When making any changes in the code in this tab, and the mode is zero,\n//you must reset the time for the changes to take effect.\n#define shutAp .6\n#define fcsDist 4.5\n#define blurAmt .001\n#define numLvls 8\n#define spp 1.\n#define FOV 75.\n#define fovInDeg 1\n#define SkyMode 2\nconst float mode = 0.;\n//mode=0.: Develop; the image develops over multiple frames.\n//mode=1.; Realtime; the image is signifigantly more noisy, but changes take effect\n//immediatly.\n//Any other value of mode: FPS; same as Develop, but resets the image every\n//->mode<- frames. FPS MODE NOT RECCOMENDED. Develop mode reccomended.\n\n//To add objects, look in the 'Common' tab.\n\n\n//NOTE: Component order:\n// - Roughness [0,1]\n// - IOR (1,+Inf)\n// - Diffuse Color (Color)\n// - Specular Chance [0,1]\n// - Specular Color (Color)\n// - Refractive Chance [0,1]\n// - Refractive Absorption (Absorption3)\n//\n//NOTE: Refractive Chance + Specular Chance <= 0\n\nNewWorld getNewWorld(float t){\n    NewWorld world;\n    Viewer cam = Viewer(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec3(0.,2.,-3.5));\n    \n    mat2 rx = rot(d2r(-5.));\n    cam.uu.zy *= rx;\n    cam.vv.zy *= rx;\n    cam.ww.zy *= rx;\n    \n    mat2 ry = rot(-d2r(0.));\n    cam.uu.xz *= ry;\n    cam.vv.xz *= ry;\n    cam.ww.xz *= ry;\n    \n    mat2 rz = rot(-d2r(0.));\n    cam.uu.yx *= rz;\n    cam.vv.yx *= rz;\n    cam.ww.yx *= rz;\n    \n    world.objs[0] = Obj_Sphere(vec3(0.,-402.001,0.),400.,Mat(.5,5.,vec3(.2,.5,1.),vec3(0.),.5,vec3(.2,.8,.8),0.,vec3(1.)));\n    //createObj_HollowSphere(vec3(-1.5,-.5,3.),1.5,.4,1,8,Mat(.2,vec3(1.),vec3(0.),0.,vec3(1.),1.52,false),world.objs);\n    world.objs[1] = Obj_Sphere(vec3(-1.5,-.5,3.),1.5,Mat(.1,1.5,vec3(1.),vec3(0.),.4,vec3(.8,.2,.8),0.,vec3(1.)));\n    world.objs[2] = Obj_Sphere(vec3(1.5,-1.,2.),1.,Mat(.9,1.5,vec3(1.),vec3(0.),.6,vec3(.8,.8,.2),0.,vec3(1.)));\n    world.objs[3] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(3.5,-2.,-2.),vec3(3.5,-2.,3.5),vec3(-3.5,-2.,3.5),true,Mat(1.,1.52,vec3(1.),vec3(0.),.5,vec3(1.),0.,vec3(1.)));\n    world.objs[4] = Obj_Quad(vec3(-3.5,-2.,-2.),vec3(-3.5,5.,-2.),vec3(-3.5,5.,3.5),vec3(-3.5,-2.,3.5),false,Mat(.5,1.52,vec3(1.,.1,.1),vec3(0.),.5,vec3(1.,.1,.1),0.,vec3(1.)));\n    world.objs[5] = Obj_Quad(vec3(3.5,-2.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(3.5,-2.,3.5),true,Mat(.5,1.52,vec3(.1,1.,.1),vec3(0.),.5,vec3(.1,1.,.1),0.,vec3(1.)));\n    world.objs[6] = Obj_Quad(vec3(-3.5,5.,-2.),vec3(3.5,5.,-2.),vec3(3.5,5.,3.5),vec3(-3.5,5.,3.5),false,Mat(0.,1.52,vec3(1.),vec3(0.),.5,vec3(1.),0.,vec3(1.)));\n    world.objs[7] = Obj_Box(vec3(0.,4.,.5),vec3(.75,.25,.75),d2r(vec3(0.)),Mat(.5,0.,vec3(.75,.775,.9),vec3(4.),1.,vec3(0.),0.,vec3(1.)));\n    world.objs[8] = Obj_Box(vec3(0.,-1.25,-.5),vec3(.75),d2r(vec3(0.)),Mat(0.,1.52,vec3(1.),vec3(0.),.15,vec3(1.),.85,vec3(1.,2.,3.)));\n    //TODO: Generate bounding boxes\n    \n    \n    world.camera = cam;\n    return world;\n}\n\nNewHit newInt(vec3 ro,vec3 rd,Obj objs[objC]){\n    NewHit h;\n    h.len = -1.;\n    \n    for(int i = 0; i < objC; i++) {\n        Obj o = objs[i];\n        //if(!aabbInt(ro,rd,o.bound)) continue;\n        if(o.sph.isActive) {IntRes res = newSphereInt(ro,rd,o.sph);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.box.isActive) {IntRes res = newBoxInt(ro,rd,o.box);if(res.len>=.0001&&(res.len<h.len||h.len<0.)){h.o=o;h.ff=res.ff;h.len=res.len;}}\n        else if(o.quad.isActive) {float res = newQuadInt(ro,rd,o.quad);if(res>=.0001&&(res<h.len||h.len<0.)){h.o=o;h.ff=true;h.len=res;}}\n    }\n    \n    Obj o = h.o;\n    vec3 p = ro+rd*h.len;\n    \n    if(o.sph.isActive) h.nor = normalize(p-o.sph.c);//*sign(o.sph.rad);\n    else if(o.box.isActive) {BoxBody b = o.box;mat3 r = rot3(b.rot);mat3 rn = rot3(-b.rot);h.nor = newBoxNor(b.pos+(p-b.pos)*rn,b)*r;}\n    else if(o.quad.isActive) {QuadBody q = o.quad;h.nor = normalize(cross(q.v1-q.v0,q.v2-q.v0))*(q.fn?-1.:1.);}\n    \n    //h.nor *= h.ff?1.:-1.;\n    \n    return h;\n}\n\nconst vec3 sunDir = normalize(vec3(.5,1.,.75));\n//Sebastian Lagues's sky function\nvec3 getSky(float t,vec3 rd) {\n    #if SkyMode == 1\n    float skyGradT = pow(smoothstep(0.,.4,rd.y),.35);\n    vec3 skyGrad = mix(vec3(.05),vec3(.3,.6,.9),skyGradT);\n    \n    vec3 sun = pow(max(0.,dot(rd,sunDir)),40.)*10.*vec3(1.,.85,.7);\n    \n    float groundT = smoothstep(-.01,0.,rd.y);\n    \n    return mix(vec3(.25),skyGrad,groundT)+sun;\n    #elif SkyMode == 0\n    return vec3(0.);\n    #elif SkyMode == 2\n    return SRGBToLinear(texture(iChannel1,rd).xyz);\n    #endif\n}\n\nvec3 newRay(inout vec3 ro,inout vec3 rd,vec3 p,in vec3 n,Mat m,bool ff) {\n    vec3 oro = ro; vec3 ord = rd;\n    ro = p;\n    #if 0\n    vec3 mn = normalize(mix(n,hemi(n),m.r));\n    rd = reflect(rd,mn);\n    return m.col;\n    #else\n    if(!ff) n *= -1.;\n    \n    float specChance = m.spcCh;\n    float refraChance = m.rfaCh;\n    \n    float rayProb = 1.;\n    if(specChance > 0.) {\n        specChance = fresnel(ff?1.:m.IOR,ff?m.IOR:1.,rd,n,m.spcCh,1.);\n        \n        float chanceMultiplier = (1.-specChance) / (1.-m.spcCh);\n        refraChance *= chanceMultiplier;\n    }\n    \n    float doRefra = 0., doSpec = 0., roll = rand();\n    if(specChance > 0. && roll < specChance) {\n        doSpec = 1.;\n        rayProb = specChance;\n    } else if(refraChance > 0. && roll < specChance + refraChance) {\n        doRefra = 1.;\n        rayProb = refraChance;\n    } else {\n        rayProb = 1.-(specChance+refraChance);\n    }\n    \n    rayProb  = max(rayProb, .0001);\n    \n    float r2 = m.r*m.r;\n    \n    vec3 difDir = normalize(n+uniformVec());\n    vec3 refDir = reflect(rd,n);\n    vec3 specDir = normalize(mix(refDir,difDir,r2));\n    \n    vec3 refraDir = refract(rd,n,ff?1./m.IOR:m.IOR);\n    refraDir = normalize(mix(refraDir,normalize(uniformVec()-n),r2));\n    \n    rd = mix(difDir,specDir,doSpec);\n    rd = mix(rd,refraDir,doRefra);\n    \n    vec3 col = vec3(1.);\n    \n    if(doRefra==0.) col *= mix(m.col,m.spcCl,doSpec);\n    \n    return col / rayProb;\n    #endif\n    \n}\n\nvoid mainImage( out vec4 o, in vec2 i ){\n    #ifdef maxFrame\n    if(iFrame>=maxFrame) {o=texelFetch(iChannel0,ivec2(i),0);return;}\n    #endif\n    irand(i,float(iFrame));\n    \n    float ftime;\n    if(mode==0.){\n        o = texelFetch(iChannel0,ivec2(i),0);\n        ftime = 0.;\n    } else if(mode==1.) {\n        o = vec4(0.);\n        ftime = iTime;\n    }else{\n        if(iTimeDelta*mode>1.) {\n        o = vec4(0.);\n        }else{\n        o = texelFetch(iChannel0,ivec2(i),0);\n        }\n        ftime = floor(iTime*mode)/mode;\n    }\n    if(texture(iChannel3, vec2(32.5/256.0,0.25)).x > 0.1) o = vec4(0.);\n    \n    #if fovInDeg==0\n    float dv = 1./tan(FOV/2.);\n    #else\n    float dv = 1./tan(PI*FOV/360.);\n    #endif\n    \n    vec3 ttcol = vec3(0.);\n    for(float _i = 0.; _i<spp;_i++) {\n        vec2 p1 = (-R+ 2.*(i + rand2())) / R.y;\n        \n        vec3 er = normalize(vec3(p1,dv));\n        float ctime = ftime - rand()*shutAp/24.;\n        \n        NewWorld world = getNewWorld(ctime);\n        Viewer cam = world.camera;\n        \n        vec3 rd = er.x*cam.uu + er.y*cam.vv+er.z*cam.ww;\n        \n        vec3 go = blurAmt*vec3(-1.+2.*rand2(),0.);\n        vec3 gd = normalize( er*fcsDist-go );\n        cam.ro += go.x*cam.uu + go.y*cam.vv;\n        rd += gd.x*cam.uu + gd.y*cam.vv;\n        rd = normalize(rd);\n        \n        vec3 tcol = vec3(0.);\n        vec3 fcol = vec3(1.);\n        for(int _j = 0; _j<numLvls;_j++) {\n            NewHit hit = newInt(cam.ro,rd,world.objs); \n            if(hit.len==-1.) {tcol+=getSky(ctime,rd)*fcol;break;}                             \n            \n            if(!hit.ff) fcol *= exp(-hit.o.mat.absorb*hit.len);\n            \n            vec3 p = hit.len*rd+cam.ro;\n            \n            Mat mat = hit.o.mat;\n            \n            \n            tcol += mat.ems*fcol;\n            fcol *= newRay(cam.ro,rd,p,hit.nor,mat,hit.ff);\n            \n            #if 1\n            {\n                float r_p = max(.0001,max(fcol.x,max(fcol.y,fcol.z)));\n                if(rand()>r_p) break;\n                fcol /= r_p;\n            }\n            #endif\n        }\n        \n        ttcol += tcol;\n    }\n    if(ttcol.x!=ttcol.x) ttcol.x = 0.;\n    if(ttcol.y!=ttcol.y) ttcol.y = 0.;\n    if(ttcol.z!=ttcol.z) ttcol.z = 0.;\n    o += vec4(ttcol / spp,1.);\n    //o = vec4(i*.001,.5,1.);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, vec2 i )\n{\n    o = texture(iChannel0,i/R);\n    o /= o.w;\n    float d = dot(o.xyz,vec3(1.));\n    o.xyz = d>4.?o.xyz:vec3(0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 299, 338, 338, 728]]}
{"id": "DlKGzR", "name": "Year of Truchets #019", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!", "tags": ["raymarching", "truchet", "tiles"], "likes": 22, "viewed": 268, "published": 3, "date": "1683547445", "time_retrieved": "2024-07-30T17:56:53.138193", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Year of Truchets #019\n    05/08/2023  @byt3 - m3chanic\n    \n    Just a mix of things laying around on the shader floor scrapped together \n    with some reflections and love.. \n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265\n#define PI2         6.28318530\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(26.37,45.93)))*4374.23); }\n\n// https://www.shadertoy.com/view/wsjfRD \n// simple fbm noise generation for clouds\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2. - 1.;\n}\n// A perlin noise function. Since we are not using textures, we am gonna sample 8 corners of a cube.\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0., 1., v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1, 0, 0));\n    float c = rand(u + vec3(0, 1, 0));\n    float d = rand(u + vec3(1, 1, 0));\n    float e = rand(u + vec3(0, 0, 1));\n    float f = rand(u + vec3(1, 0, 1));\n    float g = rand(u + vec3(0, 1, 1));\n    float h = rand(u + vec3(1, 1, 1));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n// The fbm function.\nfloat fbm(vec3 p) {\n    vec3 off = vec3(.175,.4,.0) * T;\n    vec3 q = p + off;\n    // fbm\n    float f = .5 * perlin(q); q *= 2.;\n    f += .125 * perlin(q); q *= 2.;\n    f += .225 * perlin(q); q *= 2.;\n    return clamp(f - p.y, .0, 1.);\n}\n\n//@iq shapes\nfloat box( vec3 p, vec3 s ) {\n    p = abs(p)-s;\n    return length(max(p,0.))+min(max(p.x, max(p.y, p.z)),0.)-.025;\n}\n\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0),speed=vec3(0);\nmat2 r90,r35,r25;\n\nconst float size = 2.125;\nconst float hlf = size/2.;\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    vec2 id = floor((p.xz+hlf)/size);\n    vec2 q = mod(p.xz+hlf,size)-hlf;\n\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n    float hs = hash21(id);\n    float hss = hs;\n    if(hs>.5) q*=r90;\n    \n    hs = perlin(vec3(id,.1)*2.2);\n    \n    vec2 d2 = vec2(length(q-hlf), length(q+hlf));\n    vec2 gx = d2.x<d2.y ? vec2(q-hlf) : vec2(q+hlf);\n\n    float ff = .15+perlin(vec3(p.xz,T*.7)*.45)*.75;  \n    float tk = .35+.25*sin(ff+(p.x*.33+p.z*.21)-T);\n    \n    vec3 r = vec3(gx.x,p.y-ff,gx.y);\n    vec3 t = vec3(q.x,p.y-ff,q.y);\n\n    float d4 = trs(r,vec2(hlf,tk));\n\n    if(hs>.75) {\n        d4 = min(length(t.yz)-tk,length(t.yx)-tk);\n    } else if (hs>.5) {\n        d4 = min(length(vec3(abs(t.x)-hlf,t.yz))-tk,length(vec3(t.yx,abs(t.z)-hlf))-tk);\n    } else if (hs>.25) {\n        d4 = min(length(t.yx)-tk, length(vec3(abs(t.x)-hlf,t.yz))-tk);\n    }\n\n    if(d4<res.x){\n        float rs=fract(hss*432.32);\n        res = vec2(d4,rs<.465?3.:4.);\n        hit = p; \n        gid = vec3(id,1);\n    }\n    \n    float fl = p.y+2.;\n    if(fl<res.x){\n        res = vec2(fl,2.);\n        hit = p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec4 sumColor;\nvec2 marcher(vec3 ro, vec3 rd, int steps,  float bnc) {\n    float t = .0;\n    float m = .0;\n    for( int i=0; i<steps; i++ ) {\n        vec3 p = ro + rd * t;\n        vec2 d = map(p);\n        //@42yeah https://www.shadertoy.com/view/wsjfRD \n        // simple volume trace in my march\n        float density = fbm(p);\n        if (density > 1e-2) {\n            vec4 color = vec4(mix(vec3(0), vec3(1), density), density);\n            color.w *= .5;\n            color.rgb *= color.w;\n            sumColor += color * (1.1 - sumColor.a);\n        }\n        //\n        m = d.y;\n        if(d.x<MIN_DIST*t||t>MAX_DIST) break;\n        t += i<32? d.x*.4 : d.x;\n    }\n    return vec2(t,m);\n}\n\nvec3 hue(float t) {\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(.88,.97,.85))); \n}\n\nvec4 FC = vec4(.65,.75,.75,0);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float bnc, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,100,bnc);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-5,20,-15);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.1);\n        vec3 hp = hitPoint*vec3(-1,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),.1),45.);\n\n        if(m==2.){\n            h = vec3(.1);\n            vec2 f = fract(hp.xz)-.5;\n            if(f.x*f.y>0.) {h = vec3(0); ref = vec3(0);}\n        }\n        if(m==3.){\n            h = hue(((121.-hp.z)*.02)+((321.-hp.x)*.015));\n            ref = h*.35;\n        }\n        if(m==4.){\n            h = vec3(clamp(.1+perlin(hp*.12),0.,1.));\n            ref = vec3(.1);\n        }\n\n        C = (diff*h)+spec;\n\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } else {\n        C = vec3(1);\n    }\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r35=rot(-.685);\n    r25=rot(-.685+.2*sin(T*.125));\n    r90=rot(1.5707);\n    speed = vec3(0,0,T*.55);\n    \n    // zoom level \n    float zoom = 10.;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*zoom,-(zoom+5.));\n    vec3 rd = vec3(0,0,1);\n    \n    ro.yz*=r35,ro.xz*=r25;\n    rd.yz*=r35,rd.xz*=r25;\n\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0),ref=vec3(0), fil=vec3(1);\n    float d = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n  \n    C += sumColor.rgb;\n    C = mix(C,clamp(C*.75,vec3(0),vec3(1)),hash21(uv+2.));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlKGzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[596, 596, 615, 615, 660], [661, 661, 683, 683, 738], [740, 824, 844, 844, 927], [928, 1029, 1051, 1051, 1576], [1577, 1598, 1617, 1617, 1835], [1837, 1850, 1879, 1879, 1966], [1968, 1968, 1994, 1994, 2063], [2211, 2211, 2232, 2232, 3380], [3382, 3382, 3412, 3412, 3652], [3669, 3669, 3724, 3724, 4344], [4346, 4346, 4365, 4365, 4439], [4472, 4472, 4566, 4566, 5629], [5631, 5631, 5672, 5672, 6367]]}
{"id": "dlG3zh", "name": "SDF cycle", "author": "motus_art", "description": "A library of cycling SDFs\n\nAll SDF code from the amazing Inigo Quilez https://iquilezles.org/articles/distfunctions2d/", "tags": ["sdf"], "likes": 3, "viewed": 112, "published": 3, "date": "1683542385", "time_retrieved": "2024-07-30T17:56:54.180407", "image_code": "//\n// SDFs\n//\nfloat dot2( in vec2 v ) {\n  return dot(v,v);\n}\n\nfloat inverseLerp(float v, float minValue, float maxValue) {\n  return (v - minValue) / (maxValue - minValue);\n}\n\nfloat remap(float v, float inMin, float inMax, float outMin, float outMax) {\n  float t = inverseLerp(v, inMin, inMax);\n  return mix(outMin, outMax, t);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nmat2 rotate2D(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c);\n}\n\n\n// All SDF code from the amazing Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n\nfloat sdEquilateralTriangle( in vec2 p, in float size ) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x) - size;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n  // Position\n  // Move\n  //vec2 pos = p - vec2(cos(iTime * 0.5) * 0.9, sin(iTime * 0.5) * 0.5);\n  \n  // Rotate\n  //pos *= rotate2D(iTime * 0.25);  \n  \n  // scale\n  //float d = sdEquilateralTriangle(pos, remap(sin(iTime * 0.5), -1.0, 1.0, 0.2, 0.9));\n  \n  // SDFs\n  float d = 0.0;\n  int shape = int(mod(iTime, 9.0));\n  switch (shape) {\n    case 0:\n      d += sdCircle(p, 0.5);\n      break;\n      \n    case 1:\n      d += sdBox(p, vec2(1.0, 0.5));\n      break;\n      \n    case 2:\n      d += sdRhombus(p, vec2(1.0, 0.5));\n      break;\n      \n    case 3:\n      d += sdEquilateralTriangle(p, 0.5);\n      break;\n      \n    case 4:\n      d += sdPentagon(p, 0.6);\n      break;\n      \n    case 5:\n      d += sdHexagon(p, 0.6);\n      break;\n      \n    case 6:\n      d += sdStar5(p, 0.75, 0.5);\n      break;\n      \n    case 7:\n      d += sdHeart(vec2(p.x, p.y + 0.5));\n      break;\n      \n    case 8:\n      d += sdRoundedX(p, 0.75, 0.2);\n      break;\n  }\n\n  // coloring\n  vec3 col;\n  if (d>0.0) {\n    col = vec3(0.15);\n    col *= 0.8 + 0.937 * cos(50.0 * d + iTime * -10.0);\n  } else {\n    col = vec3(0.937);\n  }\n    \n  col *= 2.0 - exp(-6.0*abs(d));\n\t\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlG3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 14, 39, 39, 60], [62, 62, 122, 122, 173], [175, 175, 251, 251, 328], [330, 330, 359, 359, 387], [389, 389, 417, 417, 495], [498, 596, 631, 631, 659], [661, 661, 698, 698, 778], [780, 780, 822, 822, 1003], [1006, 1006, 1063, 1063, 1263], [1265, 1265, 1308, 1308, 1590], [1592, 1592, 1634, 1634, 1824], [1826, 1826, 1877, 1877, 2255], [2257, 2257, 2285, 2285, 2505], [2507, 2507, 2562, 2562, 2625], [2628, 2628, 2685, 2685, 3916]]}
{"id": "mtGGzh", "name": "Reflecting Dynamic Block Grid", "author": "dr2", "description": "Dynamic blocks with multiple reflections (mouseable)", "tags": ["reflection", "block"], "likes": 17, "viewed": 275, "published": 3, "date": "1683539226", "time_retrieved": "2024-07-30T17:56:55.268497", "image_code": "// \"Reflecting Dynamic Block Grid\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// [Based on \"Dynamic Block Grid\" (sdsBDH)]\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r);\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r);\nfloat Maxv3 (vec3 p);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, bsHit, ltDir;\nvec2 pMid[4], pEdge[4], qcMin, ip;\nfloat tCur, dstFar, eFac, eRound;\nint nFrame;\nconst float pi = 3.1415927;\n\n#define H(z) (0.5 + 0.5 * cos (tCur * (0.1 + 0.9 * Hashfv2 (ip + z))))\n\nvoid CellParms ()\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 ee[4];\n  float hp;\n  e = vec3 (-1., 0., 1.);\n  ee[0] = e.xz;\n  ee[1] = e.zz;\n  ee[2] = e.zx;\n  ee[3] = e.xx;\n  hp = H(0.);\n  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));\n  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5) + pEdge[k] * ee[k];\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, bs;\n  vec2 qc;\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    qc = ip + pMid[k];\n    q.xz = p.xz - qc;\n    qc = floor (qc);\n    bs.xz = pEdge[k] - eFac + 0.05;\n    bs.y = 0.8 * (bs.x + bs.z) + 0.2 * Hashfv2 (qc);\n    q.y = p.y - bs.y;\n    d = PrRound4BoxDf (q, bs - eRound, eRound);\n    if (d < dMin) {\n      dMin = d;\n      qcMin = qc;\n      qHit = q;\n      bsHit = bs;\n    }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 fp, ipP;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  dHit = eps;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    fp = p.xz + 0.5;\n    ip = floor (fp);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    d = ObjDf (p);\n    dHit += min (d, eps + max (0., Minv2 ((ip + step (0., rd.xz) - fp) * rdi.xz)));\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d > eps || p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 ipP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  ipP = vec2 (0.5);\n  for (int j = VAR_ZERO; j < 32; j ++) {\n    p = ro + d * rd;\n    ip = floor (p.xz + 0.5);\n    if (ip != ipP) {\n      ipP = ip;\n      CellParms ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.02);\n    if (h < 0.001 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (8. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 q, qc, b;\n  float dstObj, dstGrnd, sh, s, ss, reflFac;\n  const int nRefl = 9;\n  eFac = 0.2;\n  eRound = 0.2;\n  reflFac = 1.;\n  for (int k = VAR_ZERO; k < nRefl; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k < nRefl - 1 && dstObj < dstFar && Maxv3 (abs (qHit) - bsHit) > -0.005) {\n      ro += dstObj * rd;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.01 * rd;\n      reflFac *= 0.85;\n    } else break;\n  }\n  dstGrnd = dstFar;\n  if (dstObj < dstFar || rd.y < 0.) {\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = vec4 (HsvToRgb (vec3 (Hashfv2 (qcMin), 0.8, 1.)), 0.1);\n      s = 1.;\n    } else {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 0.5);\n      ip = floor (ro.xz + 0.5);\n      CellParms ();\n      s = 1.;\n      for (int k = VAR_ZERO; k < 4; k ++) {\n        q = ro.xz - (ip + pMid[k]);\n        b = pEdge[k] - eFac + 0.1;\n        ss = PrRound4Box2Df (q, b - eRound, eRound);\n        if (ss < s) {\n          s = ss;\n          qc = floor (ip + pMid[k]);\n        }\n      }\n      col4 = vec4 (mix (HsvToRgb (vec3 (Hashfv2 (qc), 0.8, 1.)), vec3 (0.6),\n         smoothstep (0.02, 0.03, abs (s))), 0.1);\n      s = 0.5 + 0.5 * smoothstep (-0.03, -0.01, s);\n    }\n    sh = (dstGrnd < min (dstObj, dstFar)) ? min (s, ObjSShadow (ro + 0.01 * vn, ltDir)) : 1.;\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = SkyCol (rd);\n  }\n  col *= reflFac;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 1.;\n  az = 0.;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.6 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, -0.15 * pi);\n  ltDir = normalize (vec3 (0.7, 2., -1.));\n  vuMat = StdVuMat (el, az);\n  ro.xz = - vec2 (0.06, 0.15) * tCur;\n  ro.y = 5.;\n  zmFac = 4.;\n  dstFar = 80.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  col = vec3 (0.);\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r)\n{\n  p = max (abs (p) - b, 0.);\n  return sqrt (length (p * p)) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtGGzh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[770, 770, 789, 789, 1819], [1821, 1821, 1843, 1843, 2282], [2284, 2284, 2317, 2317, 2899], [2901, 2901, 2922, 2922, 3179], [3181, 3181, 3218, 3218, 3618], [3620, 3620, 3643, 3643, 3806], [3808, 3808, 3843, 3843, 5480], [5482, 5482, 5538, 5538, 6587], [6589, 6589, 6636, 6636, 6703], [6705, 6705, 6753, 6753, 6820], [6822, 6822, 6844, 6844, 6882], [6884, 6884, 6906, 6906, 6933], [6935, 6935, 6971, 6971, 7177], [7179, 7179, 7209, 7209, 7322], [7324, 7324, 7348, 7348, 7465], [7499, 7499, 7523, 7523, 7583], [7585, 7585, 7609, 7609, 7721], [7723, 7723, 7748, 7748, 7934], [7936, 7936, 7957, 7957, 8112], [8114, 8114, 8143, 8143, 8355], [8357, 8357, 8396, 8396, 8653]]}
{"id": "DlyGz1", "name": "X0X ", "author": "cisemsu", "description": "Piensa Fuera De La Na Ja", "tags": ["xox"], "likes": 0, "viewed": 108, "published": 3, "date": "1683530250", "time_retrieved": "2024-07-30T17:56:56.239900", "image_code": "vec2 remap01(vec2 x, vec2 minvalue, vec2 maxvalue){\n    return clamp((x - minvalue) / (maxvalue - minvalue), 0.0, 1.0);\n}\nvoid circle(inout vec4 fragColor, in vec2 fragCoord,vec2 uv, vec2 center, float radius, vec3 color){\n\n float d_ = length (center - uv);\n     if (d_ <= radius){\n        fragColor = vec4 (color,1.0);\n    }\n\n}\nvec2 rotation1(vec2 center,in vec2 fragCoord,float rotation){\n\n    vec2 right = vec2 (-cos(rotation), sin(rotation));\n    vec2 up = vec2(-right.y,right.x);\n    \n    vec2 asd = fragCoord - center;\n    float x = dot(asd, right);\n    float y = dot(asd, up);\n    return vec2(x,y);\n\n\n}\nfloat radian (float angle){\n\nfloat rad = angle / 180.*3.14159265;\nreturn rad;\n\n}\nvoid line(vec2 uv,inout vec4 fragColor, in vec2 fragCoord, vec2 center, vec2 extent,float angle){\n\n     vec2 rot = rotation1(center,fragCoord,radian(angle));\n     if (rot.x >= -extent.x && rot.x <= extent.x && rot.y >= -extent.y && rot.y <=extent.y)\n         fragColor =vec4(0.0,0.0,0.0,1.0); \n    \n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 center = vec2(0.25,0.375);\n    vec2 extent = vec2(0.25);\n    uv.x *= ratio;\n    fragColor = vec4 (1.0,0.0,0.0,1.0); //background color\n  \n\n\n    if (uv.x >=0.029 && uv.x <= 1.04 && uv.y >=0.33 && uv.y <=0.95)\n        fragColor = texture(iChannel1,remap01(uv,vec2 (0.75),vec2 (1.0)));\n        \n    if (fragCoord.x >20.0 && fragCoord.x <460. && fragCoord.y>155.0 && fragCoord.y<420.)\n        fragColor = vec4 (1.0,1.0,1.0,1.0);\n        \n    if (fragCoord.x >155.0 && fragCoord.x <160. && fragCoord.y>155.0 && fragCoord.y<420.)\n        fragColor = vec4 (0.0,0.0,0.0,1.0);\n    \n    if (fragCoord.x >315.0 && fragCoord.x <320. && fragCoord.y>155.0 && fragCoord.y<420.)\n        fragColor = vec4 (0.0,0.0,0.0,1.0);\n         \n    if (fragCoord.x >20.0 && fragCoord.x <460. && fragCoord.y>240.0 && fragCoord.y<245.)\n        fragColor = vec4 (0.0,0.0,0.0,1.0);\n          \n    if (fragCoord.x >20.0 && fragCoord.x <460. && fragCoord.y>330.0 && fragCoord.y<335.)\n        fragColor = vec4 (0.0,0.0,0.0,1.0);\n        \n   vec2 uv_= fragCoord.xy;   \n   vec2 center1 = vec2(240.,284.);\n   vec2 center2 = vec2(240.,284.);\n   vec2 center3 = vec2(392.35,201.);\n   vec2 center4 = vec2(392.,201.);\n   vec2 center5 = vec2(518,115.);\n   vec2 center6 = vec2(518,115);\n   vec2 center7 = vec2(90,201.);\n   vec2 center8 = vec2(90,201.);\n   vec2 center9 = vec2(240,375.);\n   vec2 center10 = vec2(240,375.);\n   float radius = 0.075 * iResolution.y;\n   float radius2 = 0.050 * iResolution.y;\n   vec3 red = vec3(1.0,0.0,0.0);\n   vec3 white=vec3(1.0,1.0,1.0);\n   vec3 black=vec3(0.0,0.0,0.0);\n   \n   \n   circle(fragColor, fragCoord, uv_, center1,radius,red);\n   circle(fragColor, fragCoord, uv_, center2,radius2,white);\n   circle(fragColor, fragCoord, uv_, center3,radius,red);\n   circle(fragColor, fragCoord, uv_, center4,radius2,white);\n   circle(fragColor, fragCoord, uv_, center5,radius,white);\n   circle(fragColor, fragCoord, uv_, center6,radius2,red);\n   circle(fragColor, fragCoord, uv_, center7,radius,black);\n   circle(fragColor, fragCoord, uv_, center8,radius2,white);\n   circle(fragColor, fragCoord, uv_, center9,radius,black);\n   circle(fragColor, fragCoord, uv_, center10,radius2,white);\n   \n\n   vec2 extent_x = vec2 (40.0,5.0);\n   vec2 extent_x2 = vec2 (170.0,5.0);\n   vec2 center_x1 = vec2 (89.0,378.0);\n   vec2 center_x2 = vec2 (390.0,378.0);\n   vec2 center_x3 = vec2 (390.0,290.0);\n   vec2 center_x4 = vec2 (89.0,290.0);\n   vec2 center_x5 = vec2 (240.0,202.0);\n   vec2 center_x6 = vec2 (380.0,200.0);\n\n   float angle = 220.;\n   float angle2 = 140.;\n   float angle4 = 31.;\n\n\n   line(uv_,fragColor,fragCoord,center_x1,extent_x,angle);\n   line(uv_,fragColor,fragCoord,center_x1,extent_x,angle2);\n   line(uv_,fragColor,fragCoord,center_x2,extent_x,angle);\n   line(uv_,fragColor,fragCoord,center_x2,extent_x,angle2);\n   line(uv_,fragColor,fragCoord,center_x3,extent_x,angle);\n   line(uv_,fragColor,fragCoord,center_x3,extent_x,angle2);\n   line(uv_,fragColor,fragCoord,center_x4,extent_x,angle);\n   line(uv_,fragColor,fragCoord,center_x4,extent_x,angle2);\n   line(uv_,fragColor,fragCoord,center_x5,extent_x,angle);\n   line(uv_,fragColor,fragCoord,center_x5,extent_x,angle2);\n   \n   line(uv_,fragColor,fragCoord,center_x6,extent_x2,angle4);\n   \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlyGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 121], [122, 122, 222, 222, 328], [329, 329, 390, 390, 609], [610, 610, 637, 637, 690], [691, 691, 788, 788, 992], [993, 993, 1049, 1099, 4421]]}
{"id": "clyGz1", "name": "maze worms / graffitis 6b", "author": "FabriceNeyret2", "description": "( not at all what I was looking for, but still fun :-) ).\nsome worms are drawing mazes under bark on in the silt above marine stones.\nThese correspond to very simple exploration rules. Here is an artificial example.\nChange parameters, try fullscreen.", "tags": ["automata", "worms", "maze", "short"], "likes": 25, "viewed": 266, "published": 3, "date": "1683530174", "time_retrieved": "2024-07-30T17:56:56.998872", "image_code": "// variant of https://shadertoy.com/view/dlyGzz\n// all maze worms: https://www.shadertoy.com/results?query=maze+worms\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define CS(a)  vec2(cos(a),sin(a))\n//#define rnd(x) ( 2.* fract(1456.68*sin(1e4*(x+fract(iDate.w)))) -1.) // NB: mod(t,1.) for less packed pattern\n#define rnd(x) ( 2.* fract(1456.68*sin(dot(vec2(x,fract(iDate.w)),R+71.))) -1.) // NB: mod(t,1.) for less packed pattern\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    float r = 1.5, N = min(500.,R.x); // width , number of worms\n    \n    //if (T(R).x==0.) { U = abs(U/R*2.-1.); O  = vec4(max(U.x,U.y)>1.-r/R.y); O.w=0.; return; }\n\n    if (U.y==.5 && T(U).w==0.) {                           // initialize heads state: P, a, t\n        vec4 P = T(vec2(.5+(.5+.5*rnd(U.x+.1))*N,.5)); // parallel to an existing one\n        if (P.w < 3.) {\n            if(rnd(U.x+.3)<.1) { O = vec4( R/2. + R/2.4* vec2(rnd(U.x),rnd(U.x+.1)) , 3.14 * rnd(U.x+.2), 1); if (T(O.xy).w>0.) O.w = 0.; return; }\n            return;\n        }\n        float a = P.z;\n        O = vec4( P.xy+(r+2.)*CS(a+1.57*sign(rnd(U.x))), a, 1);\n        if (T(O.xy).w>0.) O.w = 0.;                        // invalid start position\n        return;\n    }\n    \n    O = T(U);\n//  vec2 M = iMouse.xy; if (length(M)>0.) O += smoothstep(r,0., length(M-U));\n    \n    for (float x=.5; x<N; x++) {                           // draw heads\n        vec4 P = T(vec2(x,.5));                            // head state: P, a, t\n        if (P.w>0.) O += smoothstep(r,0., length(P.xy-U))  // draw head if active\n                         * .2*vec4(.01*P.w,1,0,1);          // coloring scheme\n                     // *.5*(.5+.5*sin(6.3*x/N+vec4(0,-2.1,2.1,1)));   // coloring scheme\n    }\n    \n    if (U.y==.5) {                                         // head programms: worm strategy\n        vec4 P = T(U);                                     // head state: P, a, t\n        if (P.w>0.) {                                      // if active\n            vec2 A = abs(P.xy-R/2.)-R/2.; if ( max(A.x,A.y) > 0. ) { O.w = 0.; return; }  // out: stop head\n            float a = P.z;\n            if ( T(P.xy+(r+2.)*CS(a)).w > 0. ) { O.w = 0.; return; }  // hit: stop head\n            if ( T(P.xy+(r+1.)*CS(a)).w > 0. ) { O.w = 0.; return; }  // hit: stop head\n            for (float x=U.x+1.; x<N; x++) \n                if( length(P.xy-T(vec2(x,.5)).xy)<1.)  { O.w = 0.; return; }  // hit: stop head\n                \n            a += .08*2.*rnd(U.x);// .08*rnd(P.x) + .02;\n            O = vec4(P.xy+1.*CS(a),mod(a,6.2832),P.w+1.);     // move head\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clyGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 157, 157, 173]]}
{"id": "dlyGzz", "name": "maze worms / graffitis 6", "author": "FabriceNeyret2", "description": "( not at all what I was looking for, but still fun :-) ).\nsome worms are drawing mazes under bark on in the silt above marine stones.\nThese correspond to very simple exploration rules. Here is an artificial example.\nChange parameters, try fullscreen.", "tags": ["automata", "worms", "maze", "short"], "likes": 28, "viewed": 272, "published": 3, "date": "1683529715", "time_retrieved": "2024-07-30T17:56:57.820674", "image_code": "// all maze worms: https://www.shadertoy.com/results?query=maze+worms\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define CS(a)  vec2(cos(a),sin(a))\n//#define rnd(x) ( 2.* fract(1456.68*sin(1e4*(x+fract(iDate.w)))) -1.) // NB: mod(t,1.) for less packed pattern\n#define rnd(x) ( 2.* fract(1456.68*sin(dot(vec2(x,fract(iDate.w)),R+71.))) -1.) // NB: mod(t,1.) for less packed pattern\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    float r = 1.5, N = min(500.,R.x); // width , number of worms\n    \n    //if (T(R).x==0.) { U = abs(U/R*2.-1.); O  = vec4(max(U.x,U.y)>1.-r/R.y); O.w=0.; return; }\n\n    if (U.y==.5 && T(U).w==0.) {                           // initialize heads state: P, a, t\n        if (iFrame<1)\n            O = vec4(vec2( R.x/2. + R.x/4.* rnd(U.x),0) , 1.57+.3*rnd(U.x+.2), 1);\n        else {\n            vec4 P = T(vec2(.5+(.5+.5*rnd(U.x+.1))*N,.5)); // parallel to an existing one\n            if (P.w < 3.) return;\n            float a = P.z;\n            O = vec4( P.xy+(r+2.)*CS(a+1.57*sign(rnd(U.x))), a, 1);\n           // O = vec4( R/2. + R/2.4* vec2(rnd(U.x),rnd(U.x+.1)) , 3.14 * rnd(U.x+.2), 1);\n         }\n        if (T(O.xy).w>0.) O.w = 0.;                        // invalid start position\n        return;\n    }\n    \n    O = T(U);\n//  vec2 M = iMouse.xy; if (length(M)>0.) O += smoothstep(r,0., length(M-U));\n    \n    for (float x=.5; x<N; x++) {                           // draw heads\n        vec4 P = T(vec2(x,.5));                            // head state: P, a, t\n        if (P.w>0.) O += smoothstep(r,0., length(P.xy-U))  // draw head if active\n                         * .2*vec4(.01*P.w,1,0,1);          // coloring scheme\n                     // *.5*(.5+.5*sin(6.3*x/N+vec4(0,-2.1,2.1,1)));   // coloring scheme\n    }\n    \n    if (U.y==.5) {                                         // head programms: worm strategy\n        vec4 P = T(U);                                     // head state: P, a, t\n        if (P.w>0.) {                                      // if active\n            vec2 A = abs(P.xy-R/2.)-R/2.; if ( max(A.x,A.y) > 0. ) { O.w = 0.; return; }  // out: stop head\n            float a = P.z;\n            if ( T(P.xy+(r+2.)*CS(a)).w > 0. ) { O.w = 0.; return; }  // hit: stop head\n            if ( T(P.xy+(r+1.)*CS(a)).w > 0. ) { O.w = 0.; return; }  // hit: stop head\n            for (float x=U.x+1.; x<N; x++) \n                if( length(P.xy-T(vec2(x,.5)).xy)<1.)  { O.w = 0.; return; }  // hit: stop head\n                \n            a += .08*2.*rnd(U.x);// .08*rnd(P.x) + .02;\n            O = vec4(P.xy+1.*CS(a),mod(a,6.2832),P.w+1.);     // move head\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlyGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 109, 109, 125]]}
{"id": "Dty3Rh", "name": "bonsai", "author": "greg1998", "description": "crazy", "tags": ["smooth"], "likes": 4, "viewed": 446, "published": 3, "date": "1683503224", "time_retrieved": "2024-07-30T17:56:58.802050", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.20;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv;\n    float d, a = atan(p.y, p.x) + time;\n    d = sqrt(dot(p,p));\n    p = vec2(cos(a), sin(a)) * d;\n    vec4 col = texture(iChannel0, p + vec2(time * 0.01, 0.0));\n    col.r = sin(col.r * 25.0 + time * 10.0);\n    col.g = sin(col.g * 30.0 + time * 30.0);\n    col.b = sin(col.b * 30.0 + time * 10.0);\n\n    fragColor = col;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dty3Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 470]]}
{"id": "dtK3zR", "name": "Mooneye's Lost Ember (195 chars)", "author": "ABizard", "description": "Just painting Mooneye's Lost Ember game logo", "tags": ["short", "golf"], "likes": 0, "viewed": 139, "published": 3, "date": "1683484177", "time_retrieved": "2024-07-30T17:56:59.654770", "image_code": "// With FabriceNeyret2: 195 chars\n#define S(v) smoothstep( 0., -7./R.y , v)\nvoid mainImage( out vec4 o, vec2 i )\n{\n    vec2 R = iResolution.xy,\n         U = (i+i-R)/R.y;\n    o = vec4(1, .28, .36, 1) *\n        max(\n            S( abs( length(U)-.825 ) - .125 ),\n            U.y > -.72 ? S( .7*U.y + abs(U.x) - .1 ) : 0.\n        );\n}\n\n// 251 chars\n/*\n#define R iResolution\n\n#define C(D) smoothstep(D 0., D 7./R.y, length(uv))\n#define S(O) smoothstep(.1, .1-7./R.y, .7*uv.y O uv.x)*\n\nvoid mainImage( out vec4 o, vec2 i )\n{\n    vec2 uv = (i+i-R.xy)/R.y;\n    o = vec4(.992, .277, .363, 1) *\n        max(\n            C(.95-) * C(.7+),\n            S(-) S(+) step(-uv.y, .72)\n        );\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtK3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 114, 114, 331]]}
{"id": "dtKGzR", "name": "Stick dood", "author": "SnoopethDuckDuck", "description": "A dood", "tags": ["man", "stick", "stickman", "dude", "mandude", "dudeman", "stickguy"], "likes": 20, "viewed": 197, "published": 3, "date": "1683480478", "time_retrieved": "2024-07-30T17:57:00.482557", "image_code": "#define res iResolution.xy\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define Dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define ss(a) smoothstep(k, -k, a)\n#define eps 1e-4\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    float k = 1. / res.y;\n    vec2 uv = (px - 0.5 * res) * k;\n    vec2 ouv = uv;\n\n    float t = 1.8 * iTime;   \n    uv *= rot(0.06*pi*cos(t));\n\n    float r = 0.2 - 0.02 * cos(0.5*t);\n    uv.y += r;\n    \n    vec2 pHead = vec2(0, mix(1.2, 1.5, .5-.5*cos(2.*t)) * r);\n    \n    float a = acos(pHead.y / r - 1.);  \n    float theta = (a-eps)*thc(2., 0.5 * uv.x + t) - pi/2.;\n    vec2 pHip = pHead + r * Dir(theta);\n    pHip.y += (r-pHip.y) * sin(2.*t);\n    vec2 pLegL = vec2(pHip.x + sqrt(r*r-pHip.y*pHip.y), 0);\n    vec2 pLegR = vec2(pHip.x - sqrt(r*r-pHip.y*pHip.y), 0);\n    \n    vec2 dir = normalize(pHead-pHip);\n    float a2 = atan(dir.y, dir.x);\n    pHead = pHip + r * dir;\n    vec2 pBody = mix(pHead, pHip, 0.3);\n    vec2 pArmL = pBody - 0.65 * r * Dir(a2 - pi/2. - sin(1.5*t) + .1*cos(2.*t));\n    vec2 pArmR = pBody + 0.65 * r * Dir(a2 - pi/2. - sin(1.5*t) - .1*cos(2.*t));\n    vec2 pFloorL = vec2(-2. * r, -0.02);\n    vec2 pFloorR = vec2( 2. * r, -0.02);\n    \n    float dHead     = length(uv - pHead)        - 0.03;\n    float dHeadHip  = seg(uv, pHead, pHip)      - 0.01;\n    float dHipLegL  = seg(uv, pHip, pLegL)      - 0.01;\n    float dHipLegR  = seg(uv, pHip, pLegR)      - 0.01;\n    float dBodyArmL = seg(uv, pBody, pArmL)     - 0.01;\n    float dBodyArmR = seg(uv, pBody, pArmR)     - 0.01;\n    float dFloor    = seg(uv, pFloorL, pFloorR) - 0.01;\n    float d = min(min(dHead, dHeadHip), min(dHipLegL, dHipLegR));    \n    d = min(min(d, dFloor), min(dBodyArmL, dBodyArmR));\n    \n    float dCircle = length(ouv) - (0.23 - 0.231 * thc(5., 0.5 * t));\n    float sCircle = ss(-dCircle);\n\n    float xp = exp(-20.*sqrt(abs(d)));\n    float s = max(ss(d), xp);\n    s = 1.- abs(s - sCircle);\n    vec3 col = vec3(1.-s);\n    vec3 tx1 = texture(iChannel1, ouv).rgb;\n    vec3 tx2 = texture(iChannel2, vec3(ouv, exp(-0.5*s*s))).rgb;\n\n    col = mix(2.*(1.-tx2)*sqrt(s)*tx1, col, 1.-s*s);\n    O = vec4(col, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtKGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 316, 360, 360, 479], [481, 481, 523, 523, 2427]]}
{"id": "ctVGRR", "name": "Reflective Wythoff polyhedra", "author": "neozhaoliang", "description": "Another reflective polyhedra shader", "tags": ["3d", "mirror", "reflect", "polyhedra", "wythoff"], "likes": 41, "viewed": 1649, "published": 3, "date": "1683457379", "time_retrieved": "2024-07-30T17:57:01.522775", "image_code": "/*\nWythoff reflective polyhedra, code adapted from\n\n    https://www.shadertoy.com/view/tlX3WH\n\nI basically rewrote the polyhera construction and raytracing part there,\nand kept the rendering part untouched.\n\nThe code should look simpler now?\n\nTo play with:\n\n1. Change pqr and truncation_type to see other polyhedron.\n2. use 'INSIDE_VIEW' to view from the inside.\n3. use 'DUAL' to view the dual polyhera.\n   pqr=(2, 3, 4) and truncation_type=(0, 0, 1) will give the\n   rhombic dodecahedron that tiles the whole inner space.\n*/\n#define PI                3.141592654\n#define L2(x)             dot(x, x)\n#define EDGE_THICKNESS    0.05\n#define MAX_TRACE_STEPS   128\n#define MAX_RAY_BOUNCES   12\n#define EPSILON           1e-4\n#define FAR               20.\n#define min3(x, y, z)     (min(x, min(y, z)))\n#define max3(x, y, z)     (max(x, max(y, z)))\n\n\n//#define INSIDE_VIEW\n\n//#define DUAL\n\nconst vec3 pqr = vec3(2, 3, 5);   // (2, 3, 3), (2, 3, 4)\nconst vec3 truncation_type = vec3(1, 1, 1);\n\nconst float size = 1.35;  // polyhera size\n\nmat3 M;  // normals of reflection mirrors\nmat3 T;  // three vertices of the fundamental triangle  \nvec3 v0; // initial vertex\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvoid init() {\n    vec3 c = cos(PI / pqr);\n    float sp = sin(PI / pqr.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    M = mat3(m1, m2, m3);\n    T[0] = normalize(cross(m2, m3));\n    T[1] = normalize(cross(m3, m1));\n    T[2] = normalize(cross(m1, m2));\n    v0 = normalize(truncation_type * inverse(M)) * size;\n#ifdef DUAL\n    #define proj(p, n)  (length(p - dot(p, n) * n))\n    float scale = min3(proj(v0, m1), proj(v0, m2), proj(v0, m3));\n    v0 /= scale;\n#endif\n}\n\nvec3 fold(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, M[j]), 0.) * M[j];\n    }\n    return p;\n}\n\nfloat dSegment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nvec3 distEdges(vec3 p) {\n    p = fold(p);\n#ifdef DUAL\n\tvec3 ed = vec3(1e5);\n    vec3 a = T[0] / dot(T[0], v0) * size;\n    vec3 b = T[1] / dot(T[1], v0) * size;\n    vec3 c = T[2] / dot(T[2], v0) * size;\n\tif(bool(truncation_type.x))\n        ed.x = dSegment(p, b, c);\n\tif(bool(truncation_type.y))\n        ed.y = dSegment(p, c, a) ;\n\tif(bool(truncation_type.z))\n        ed.z = dSegment(p, a, b);\n\treturn ed;\n#else\n    p -= v0;\n    vec3 ed;\n    for (int i = 0; i < 3; i++) {\n        ed[i] = L2(p - min(0., dot(p, M[i])) * M[i]);\n    }\n\treturn sqrt(ed);\n#endif\n}\n\nfloat map(vec3 p) {\n    p = fold(p);\n#ifdef DUAL\n    return dot(p, v0) - size;\n#else\n    p -= v0;\n    return max(dot(p, T[0]), max(dot(p, T[1]), dot(p, T[2])));\n#endif\n}\n\nfloat trace(vec3 pos, vec3 rd, bool outside) {\n    float t = 0.0;\n    float sgn = outside ? 1.0 : -1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        float d = map(pos + t * rd);\n        if (abs(d) < EPSILON)\n            return t;\n        if (t > FAR)\n            break;\n        t += sgn * d  * 0.9;\n    }\n    return FAR;\n}\n\nvec4 wallColor(vec3 dir, vec3 nor, vec3 eds) {\n    float d = min3(eds.x, eds.y, eds.z);\n    \n    // Texturing of walls\n    vec3 albedo = texture(iChannel1, vec2(eds.xy * 2.0)).rgb;\n    albedo = pow(albedo, vec3(2.2)) * 0.5;\n    \n    // Simple diffuse lighting\n    float lighting = 0.2 + max(dot(nor, vec3(0.8, 0.5, 0.0)), 0.0);\n    \n    if (dot(dir, nor) < 0.0) {\n        // Outer walls, just add a black line to hide seams\n        float f = clamp(d * 1000.0 - 3.0, 0.0, 1.0);\n        albedo = mix(vec3(0.01), albedo, f);\n        return vec4(albedo * lighting, f);\n    } else {\n        // Inner walls, add fancy lights\n        float m = max3(eds.x, eds.y, eds.z);\n        vec2 a = fract(vec2(d, m) * 40.6) - 0.5;\n        float b = 1.0 - sqrt(dot(a, a));\n        b = 0.2 / (dot(a, a) + 0.2);\n        \n        float lightShape = 1.0 - clamp(d * 100.0 - 2.0, 0.0, 1.0);\n        lightShape *= b;\n        \n        vec3 emissive = vec3(3.5, 1.8, 1.0);\n        return vec4(mix(albedo * lighting, emissive, lightShape), 0.0);\n    }\n\treturn vec4(1.0);\n}\n\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvec3 get_normal( in vec3 pos ) {\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nvec3 background(vec3 dir) {\n\tvec3 col = texture(iChannel0, dir).rgb;\n    col = pow(col, vec3(2.2));\n    float origLuma = dot(col, vec3(0.2126, 0.7152, 0.0722)) * 0.7;\n    return 2.5 * col / (1.0 - origLuma);\n}\n\nvec3 drawRay(vec3 pos, vec3 rd) {\n    vec3 color = vec3(0.0);\n#ifndef INSIDE_VIEW\n    float t = trace(pos, rd, true);\n    if (t == FAR) {\n    \treturn background(rd);\n    }\n    pos = pos + t * rd;\n    vec3 nor = get_normal(pos);\n    vec3 reflDir = reflect(rd, nor);\n    vec3 bgColor = pow(background(reflDir), vec3(1.0));\n    float fresnel = 0.04 + 0.96 * pow(1.0 - max(dot(rd, -nor), 0.0), 5.0);\n    color += bgColor * fresnel;\n    vec3 eds = distEdges(pos);\n    float d = min3(eds.x, eds.y, eds.z);\n    if (d < EDGE_THICKNESS) {\n        vec4 wc = wallColor(rd, nor, eds);\n    \treturn color * wc.a + wc.rgb;\n    }\n#endif\n    vec3 transmittance = vec3(1.0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        float t = trace(pos, rd, false);\n        pos = pos + t * rd;\n        vec3 eds = distEdges(pos);\n        vec3 nor = get_normal(pos);\n    \tfloat d = min3(eds.x, eds.y, eds.z);\n        if (d < EDGE_THICKNESS) {\n        \treturn color + transmittance * wallColor(rd, nor, eds).rgb;\n        }\n        rd = reflect(rd, nor);\n        pos += rd * 0.005;\n        transmittance *= vec3(0.4, 0.7, 0.7);\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init();\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    vec2 move = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n\n#ifdef INSIDE_VIEW\n    float radius = 0.1;\n#else\n    float radius = 2.0;\n#endif\n    vec3 eye = radius * vec3(\n        cos(move.x)*cos(move.y),\n        sin(move.y),\n        sin(move.x)*cos(move.y)\n    );\n    \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.)\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n    eye = rotateY(mouse.x) * rotateX(-mouse.y) * eye;\n    \n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 ray = normalize(uv.x*right + uv.y*up + forward * 1.0);\n    vec3 color = drawRay(eye, ray);\n    color = color / (color * 0.5 + 0.5);\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctVGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1158, 1158, 1185, 1185, 1332], [1334, 1334, 1361, 1361, 1508], [1510, 1510, 1523, 1523, 2126], [2128, 2128, 2147, 2147, 2283], [2285, 2285, 2325, 2325, 2466], [2468, 2468, 2492, 2492, 3024], [3026, 3026, 3045, 3045, 3195], [3197, 3197, 3243, 3243, 3530], [3532, 3532, 3578, 3578, 4576], [4579, 4579, 4631, 4631, 4806], [4808, 4808, 4840, 4840, 5051], [5053, 5053, 5080, 5080, 5262], [5264, 5264, 5297, 5297, 6398], [6401, 6401, 6458, 6458, 7375]]}
{"id": "Dt33D2", "name": "ShpereRayMarch", "author": "12gx", "description": "ShpereRayMarch", "tags": ["raymarch"], "likes": 0, "viewed": 408, "published": 3, "date": "1683446392", "time_retrieved": "2024-07-30T17:57:02.646771", "image_code": "mat2 rot(float angle){\n    float c= cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\nfloat map(vec3 p){\n    return length(p)-1.0;\n}\n\nfloat Raymarch(vec3 ro,vec3 rd){\n    float d;\n    for(int i =0;i<255;i++){\n        vec3 p =ro+rd*d;\n        float d0 = map(p);\n        if(d0<=0.001||d>=40.) break;\n        d+=d0;\n    }\n    return d;\n}\nvec3 GetNormal(vec3 p){\n    float d = map(p);\n    vec2 e = vec2(0.001,0.0);\n    float dx = d-map(p-e.xyy);\n    float dy = d-map(p-e.yxy);\n    float dz = d-map(p-e.yyx);\n    return normalize(vec3(dx,dy,dz));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;    \n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0,0.0,-3);\n    vec3 rd  = normalize(vec3(uv,1.0));\n    \n    float d= Raymarch(ro,rd);\n    if(d<40.0){\n        vec3 p = ro+rd*d;\n        vec3 n  = GetNormal(p);\n        vec3 lightPos = vec3(0,5,-5.0); \n        lightPos.xz*=rot(iTime);    \n        vec3 lightdir = normalize(lightPos-p);\n        float diffuse = dot(n,lightdir);\n        diffuse =diffuse*.5+.5;\n        vec3 color = vec3(1.0,1.0,1.0);\n        col+=diffuse*color;\n    }\n   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt33D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 102], [103, 103, 121, 121, 149], [151, 151, 183, 183, 351], [352, 352, 375, 375, 560], [561, 561, 618, 618, 1244]]}
{"id": "dtGGRz", "name": "Apollonian Britney", "author": "mla", "description": "Fork of @fizzer's original to show the calculation of uv coordinates for the limit circles. The coloured border shows the different limit circles.", "tags": ["mobius", "inversion", "apollonian", "gasket"], "likes": 14, "viewed": 262, "published": 3, "date": "1683445001", "time_retrieved": "2024-07-30T17:57:03.510461", "image_code": "// Apollonian Britney, mla, 2023\n//\n// Modification of @fizzer's original https://www.shadertoy.com/view/WtdSDf\n// See mainImage around line 210 for limit circle uv calculation.\n// Also made a few mods to the code, eg. only invert combined transformation\n// at the end & a different way of handling a division by zero.\n\nconst float pi = acos(-1.);\nconst int numCircles = 4; // Set this to 4, for the classic gasket.\n\n// For more on Möbius transformations see: \n// https://en.wikipedia.org/wiki/M%C3%B6bius_transformation\n// https://en.wikipedia.org/wiki/Indra%27s_Pearls_(book)\n\n// Transformations are represented by 2x2 complex matrices, mat4x2(a,b,c,d):\n// with z -> (az+b)/(cz+d), so multiplying a matrix by complex w represents\n// the same transformation. Inverse transformation is just (any multiple of)\n// the inverse matrix.\nconst mat4x2 midentity = mat4x2(vec2(1, 0),\n                                vec2(0, 0),\n                                vec2(0, 0),\n                                vec2(1, 0));\n\n// Apply transformation m to point x\nvec2 cMobius(mat4x2 m, vec2 x)\n{\n    return cDiv(cMul(x, m[0]) + m[1], cMul(x, m[2]) + m[3]);\n}\n\n// Matrix multiplication, in fact.\nmat4x2 cMobiusConcat(mat4x2 ma, mat4x2 mb)\n{\n    return mat4x2(cMul(ma[0], mb[0]) + cMul(ma[1], mb[2]),\n                  cMul(ma[0], mb[1]) + cMul(ma[1], mb[3]),\n                  cMul(ma[2], mb[0]) + cMul(ma[3], mb[2]),\n                  cMul(ma[2], mb[1]) + cMul(ma[3], mb[3]));\n}\n\n// Matrix inverse, but no need to divide by determinant.\nmat4x2 cMobiusInverse(mat4x2 m)\n{\n    return mat4x2(m[3], -m[1], -m[2], m[0]);\n}\n\n// Apply transformation T to circle C\nvec3 cMobiusOnCircle(mat4x2 T, vec3 C)\n{\n    vec3 D;\n    vec2 z = C.xy;\n    // Handle zero division.\n    if (T[2] != vec2(0)) z -= cDiv(vec2(C.z * C.z, 0), cConj(cDiv(T[3], T[2]) + C.xy));\n    D.xy = cMobius(T,z).xy;\n    D.z = length(D.xy - cMobius(T,C.xy + vec2(C.z, 0)));\n    return D;\n}\n\n// These are the N inversion circles necessary to produce the fractal which is the limit\n// set of a Kleinian group. The Möbius transformations which represent inversions in these circles\n// are the generators of the Kleinian group.\nvec3 getInversionCircle(int i)\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    if(i == numCircles - 1) return vec3(0, 0, r1 - r0); // Central circle\n    return vec3(cos(float(i) * theta * 2.) * r1, sin(float(i) * theta * 2.) * r1, r0);\n}\n\n// These are the N circles which are the minimum set of circles which all of the other circles\n// in the limit set are images of. There are N-1 circles in a circular chain of tangency, and\n// one circle surrounding the gasket with radius 1.\nvec3 getLimitCircle(int i)\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    float r = (r1 - r0) * tan(theta);\n    float r2 = (r1 - r0) / cos(theta);\n    if(i == numCircles - 1) return vec3(0, 0, 1);\n    return vec3(-cos((float(i)) * theta * 2.) * r2, sin((float(i)) * theta * 2.) * r2, r);\n}\n\nvec3 getInnerLimitCircle()\n{\n    float theta = pi / float(numCircles - 1);\n    float r0 = tan(theta);\n    float r1 = 1. / cos(theta);\n    float r = (r1 - r0) * tan(theta);\n    float r2 = (r1 - r0) / cos(theta);\n    return vec3(0., 0., r2 - r);\n}\n\nmat4x2 makeMobiusForInversionInCircle(vec3 ic)\n{\n    mat4x2 ma = mat4x2(vec2(1. / ic.z, 0),\n                       vec2(-ic.x / ic.z, ic.y / ic.z),\n                       vec2(0, 0),\n                       vec2(1, 0));\n\n    mat4x2 mb = mat4x2(vec2(ic.x, ic.y),\n                       vec2(ic.z, 0),\n                       vec2(1, 0),\n                       vec2(0, 0));\n\n    return cMobiusConcat(mb, ma);\n}\n\nvec3 getcol(int i) {\n  // Colors for limit circles. For consistent colouring\n  // we have 1=4 and 2=3.\n  if (i == 0) return vec3(0,0,1);\n  if (i == 1) return vec3(1,1,0);\n  if (i == 2) return vec3(1,0,0);\n  if (i == 3) return vec3(0,1,0);\n  if (i == 4) return vec3(1,1,0);\n  if (i == 5) return vec3(1,0,0);\n  return vec3(1);\n}\n\nvec3 getcol(int i, int parity) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1 && parity == 0 || i == 2 && parity == 1) return vec3(0,1,0);\n  if (i == 1 && parity == 1 || i == 2 && parity == 0) return vec3(0,0,1);\n  return vec3(1,1,0);\n}\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n\n    float scale = 1.;\n\n    fragColor = vec4(0, 0, 0, 1);\n\n\n    vec2 z = vec2(p.x, p.y);\n\n    mat4x2 mi = midentity;\n\n    if(iMouse.x > .5)\n    {\n        // This mouse interaction is based on mla's shader: https://www.shadertoy.com/view/MlVfzy\n        // [mla: actually there is a better way to do this]\n        mat4x2 m = midentity;\n        vec2 mo = (2.0 * iMouse.xy / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0)) * vec2(1, -1);\n\n        if(length(mo) < 0.999)\n        {\n            vec2 c = mo * (1.0 / dot(mo, mo));\n            vec3 ic = vec3(c, sqrt(dot(c, c) - 1.));\n\n            m = makeMobiusForInversionInCircle(ic);\n        }\n\n\n        mi = cMobiusConcat(m,mi);\n\n        z = cMobius( m,z );\n    }\n\n    // Rotate the gasket *after* the mouse position inversion.\n\n    float t = iTime * .4;\n    mat4x2 mrotation = mat4x2(vec2(cos(t), sin(t)),\n                              vec2(0, 0),\n                              vec2(0, 0),\n                              vec2(1, 0));\n\n    mi = cMobiusConcat(mrotation,mi);\n    z = cMobius( mrotation, z );\n    int parity = 0;\n    \n    for(int i = 0; i < 65; ++i)\n    {\n    parity = i%2;\n        int k = -1;\n\n        mat4x2 m;\n        vec3 ic;\n\n        for(int j = 0; j < numCircles; ++j)\n        {\n            vec3 c = getInversionCircle(j);\n            \n            if(distance(z.xy, c.xy * vec2(1, -1)) < c.z)// &&i%2==0)\n            {\n                k = j;\n                ic = c;\n                break;\n            }\n        }\n\n        if(k == -1) break;\n\n        ic.x += 1e-9;\n\n        m = makeMobiusForInversionInCircle(ic);\n\n        mi = cMobiusConcat(m,mi);\n\n        z = cMobius( m, z );\n    }\n\n    mi = cMobiusInverse(mi); // Get inverse transformation\n    \n    vec3 col = vec3(0);\n\n    float px = fwidth(p.x);\n    for(int i = 0; i < numCircles; ++i)\n    {\n        vec3 C = getLimitCircle(i);\n        vec3 D = cMobiusOnCircle(mi, C);\n\n        if(D.z > 1e-9 && D.z < 1. && abs(D.z - 1.) > .01)\n        {\n            vec2 v = p.xy - D.xy;\n\n            if(length(v) < D.z) {\n               // mla part\n               vec2 uv = 0.5*v/D.z;\n               //col = texture(iChannel0,uv+0.5).rgb;\n               //col = pow(col,vec3(2.2)); // I like the washed out effect of not doing this\n               col = getcol(i,parity);\n               float twidth = 0.02;\n               col = mix(col,texture(iChannel0,uv+0.5).rgb,vec3(smoothstep(0.0,px,0.5-length(uv)-twidth)));\n               //col = getcol(i,parity);\n               col *= smoothstep(0.0,px,D.z-length(v));\n               col *= smoothstep(0.0,px,abs(D.z-length(v)-2.0*D.z*twidth));\n               break;\n            }\n        }\n    }\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Complex arithmetic\nvec2 cMul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, \n                a.x * b.y + a.y * b.x);\n}\n\nvec2 cConj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nvec2 cInverse(vec2 a)\n{\n    return cConj(a) / dot(a,a);\n}\n\nvec2 cDiv( vec2 a, vec2 b)\n{\n    return cMul(a, cInverse(b));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtGGRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1011, 1048, 1080, 1080, 1143], [1145, 1180, 1224, 1224, 1463], [1465, 1522, 1555, 1555, 1602], [1604, 1642, 1682, 1682, 1931], [1933, 2167, 2199, 2199, 2467], [2469, 2710, 2738, 2738, 3063], [3065, 3065, 3093, 3093, 3310], [3312, 3312, 3360, 3360, 3718], [3720, 3720, 3740, 3822, 4046], [4048, 4048, 4080, 4080, 4286], [4290, 4290, 4347, 4347, 7169]]}
{"id": "mty3zR", "name": "Flower mosaic 3", "author": "jarble", "description": "A flower mosaic pattern.", "tags": ["fractal", "music", "flower", "mosaic", "rug"], "likes": 4, "viewed": 187, "published": 3, "date": "1683431547", "time_retrieved": "2024-07-30T17:57:04.378141", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = .5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    uv.y = mod(uv.y,.5)+.5;\n    uv.x = mod(uv.x,2.)+1.;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5+uv+t2*sign(uv.y-uv.x))/1.5\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        //else k += 2;\n        t2 =\n            -triangle_wave(uv-.5).yx*sign(uv.x-uv.y)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        //{uv=uv*sign(uv.y-uv.x);}\n        \n        //remove this line to make it gray\n        col.x = min(sign(uv.x-t2.y),col.x);\n        \n        col =\n            abs(col.yzx-float(b)/2.)\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/DdyXz3#\nfloat fmod(float a, float b){\n    for(float i = 1.; i < mod(floor(a/b),4.); i++){\n        a += mod(floor(a/2.),b)*i;\n        a *= 1.+mod(floor(a/2.),2.);\n    }\n    return\n        mod(floor(a),b)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float tempo = .125;\n  time /= tempo;\n  float s1 =\n      8.;\n  for(float i = 1.; i < mod(floor(time),4.); i++){\n      time += mod(floor(time/2.),s1)*i;\n      tempo *= 1.+fmod(floor(time/2.),2.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m1 =\n      fmod(t/2.,s2)\n  ,\n  m3 =\n      fmod(t/8.,1.+m1)+fmod(-t/8.,2.);\n\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  float a=\n      4.*(.125+fract(-t/s1))\n  ,\n  nb = time*pow(2.,floor((m3+m2)/2.)/5.+5.);\n  return\n      abs(abs(vec2(sin(nb),cos(nb))))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mty3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1108]]}
{"id": "clGGzz", "name": "Fake CMY", "author": "Slals", "description": "Only using plain RGB colors to make appearance of CMY in the x axis. Click to have zoom.", "tags": ["colorstudy"], "likes": 0, "viewed": 157, "published": 3, "date": "1683404233", "time_retrieved": "2024-07-30T17:57:05.265768", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 400.0;\n    \n    if (iMouse.z >= 1.0) {\n        uv /= mod(iTime, 14.0);\n    }\n    \n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    float r = 0.0, g = 1.0 * mod(id.x + id.y, 2.0), b = 1.0 * (1.0 - mod(id.x + id.y, 2.0));\n    \n    vec3 M = iMouse.xyz / iResolution.xyz;\n    if (M.x > 0.6) {\n        r = b;\n        b = 0.0;\n    } else if (M.x > 0.3) {\n        r = g;\n        g = 0.0;\n    }\n\n    fragColor = vec4(vec3(r, g, b),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clGGzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 594]]}
{"id": "clG3RR", "name": "Year of Truchets #018", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nif music doesnt start - stop/rrwd and play again\n\nmousable - and full screen is nice!\n", "tags": ["raymarching", "tunnel", "truchet", "path"], "likes": 22, "viewed": 404, "published": 3, "date": "1683393481", "time_retrieved": "2024-07-30T17:57:08.291677", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #018\n    05/06/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Thanks to @Shane for his path shaders!\n    https://www.shadertoy.com/view/MlXSWX\n    \n    good song choices\n    https://soundcloud.com/trybesof/tim-green-battle-illusion\n    https://soundcloud.com/trybesof/tim-green-pyxis\n\n*/\n\n#define COLOR(COORD) texture(iChannel0,(COORD))\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(27.609, 57.583)))*43758.5453); }\n// chroma spread fake thing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n    vec3 color = COLOR(uv).rgb;\n    // effect sammple\n    vec3 fgclr = vec3(0.);\n    float f = length(uv  - 1.75);\n    fgclr.x = COLOR(uv - vec2(f*0.001,.000)).x;\n    fgclr.y = COLOR(uv + vec2(f*0.002,.001)).y;\n    fgclr.z = COLOR(uv - vec2(f*0.002,.001)).z;\n \n    // mask for effect and mixdown \n    float dt = length(uv-.5)-.22;\n    vec3 C = mix(color,fgclr,smoothstep(0.,.275,dt));\n    C = mix(C,clamp(C+.01,vec3(0),vec3(1)),hash21(uv+2.));\n    // output -gamma correct\n    C = pow(C, vec3(0.4545));\n    fragColor = vec4(C,1.);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #018\n    05/06/2023  @byt3_m3chanic\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    Thanks to @Shane for his path shaders!\n    https://www.shadertoy.com/view/MlXSWX\n    \n    good song choices\n    https://soundcloud.com/trybesof/tim-green-battle-illusion\n    https://soundcloud.com/trybesof/tim-green-pyxis\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.141592653\n#define PI2        6.283185307\n\n#define MAX_DIST   80.\n#define MIN_DIST   1e-3\n\nfloat sampleFreq(float freq) { \n    float a = texture(iChannel0, vec2(freq, .25)).x; \n    if(a<.0001) a = .5+.5*sin(T+cos(T*.12));\n    return a;\n}\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(27.609, 57.583)))*43758.5453); }\n\n//@iq SDF's\nfloat box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n//@Shane - path function\nvec2 path(in float z){\n    vec2 p1 =vec2(2.38*sin(z * .15)+5.38*cos(z * .075), 3.4*cos(z * .0945));\n    vec2 p2 =vec2(3.2*sin(z * .089),4.31*sin(z * .127)+2.5*cos(z * .095));\n    return (p1 - p2)*.3;\n}\n\n//@MercurySexy\nvec2 pModPolar(inout vec2 p) {\n    float angle = 0.26179938779;//0.52359877559;//hardcoded for speed 2.*PI/24;\n    float a = atan(p.y, p.x) + angle/2.,\n          r = length(p),\n          c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (12.)) c = abs(c);\n    return vec2(c,angle);\n}\n\nfloat time=0.,tspeed=0.,glow = 0.,gwave=0.;\nvec3 hp,hit,lp = vec3(0.);\nvec2 gid,sid;\nmat2 rxa,rxb;\n\nconst float sz = 1.;\nconst float hf = .5;\n\nvec2 map (in vec3 pos, float sg) {\n \tvec2 res = vec2(1e5,0);\n \tvec3 p = pos;\n\n    \n \tvec2 tun = p.xy - path(p.z);\n    vec3 px = vec3(tun+vec2(0.,-.1),pos.z+tspeed+5.+gwave);\n    vec3 q = vec3(tun,p.z);\n\n    float iz = floor((q.z+hf)/sz);\n    q.z = mod(q.z+hf,sz)-hf;\n    vec3 r = q;\n    r.z*=1.15;\n    \n    float zhs=hash21(vec2(iz,0.));\n    if(zhs<.75) r.xy *= rxa;\n    if(zhs>.95) r.xy *= rxb;\n    vec2 id = pModPolar(r.xy);\n    r -= vec3(4.25,0,0);\n    r.xy *= rot(id.y*6.);\n\n    vec2 mid = vec2(id.x,iz);\n    float hs = hash21(mid);\n    \n    if(hs>.5) r.xz*=rot(1.5707);\n    float ct = box(r,vec3(hf));\n    float tk = .15+.1*sin(p.z*.075);\n    \n\n    float d = min(\n    trs(r-vec3(hf,0,-hf),vec2(hf,tk)),\n    trs(r-vec3(-hf,0,hf),vec2(hf,tk))\n    );\n\n    if(hs>.75) d = min(length(r.yz)-tk,length(r.yx)-tk);\n    if (hs>.9) d = min(length(vec3(abs(r.x),r.yz)-vec3(hf,0,0))-tk,length(r.yx)-tk);\n    \n    d = max(abs(d)-.025,d);\n    d = max(ct,d);\n    \n    if(d<res.x) {\n        res = vec2(d,1.);\n        hit=q;\n        sid=mid;\n    }\n        \n    float ns = sampleFreq(.01)*.5;    \n    float nx = sampleFreq(.4)*PI2; \n    float nr = sampleFreq(.75)*PI2; \n    float b=length(px)-(.001+ns); \n    px.xz *= rot(nx);\n    px = abs(px.xzy)-.3;\n    px.zy *= rot(-nr);\n    b = min(trs(px,vec2(.2+ns,.01)),b);\n       \n    if(sg==1.) { glow += .001/(.0002+b*b);}\n    \n    if(b<res.x) {\n        res = vec2(b,1.);\n        hit=px;\n        sid=vec2(0);\n    }\n\n    res.x /=1.15;\n \treturn res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p,0.).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n        );\n    return normalize(n);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    time = iTime;\n    tspeed = time*3.85;\n    gwave = 7.75+5.*sin(time*.1);\n    rxa=rot(T*.3);\n    rxb=rot(-T*.25);\n    \n    vec3 C =vec3(0);\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    vec3 ro = vec3(0,0,.1);\n    vec3 rd = normalize(vec3(uv,-1.));\n\n    // mouse //\n    float x = M.xy==vec2(0) && M.z<1. ? 0. : -(M.y/R.y*.5-.25)*PI;\n    float y = M.xy==vec2(0) && M.z<1. ? 0. : -(M.x/R.x*2.-1.)*PI;\n    if(M.z>0.){\n        mat2 rx = rot(x), ry = rot(y);\n        ro.zy *= rx; ro.xz *= ry; \n        rd.zy *= rx; rd.xz *= ry;\n    }\n    \n    ro.z -= tspeed;\n    ro.xy += path(ro.z);\n\n    // center tracking\n    rd.xy = rot( (.2*sin(time*.3))-path(lp.z).x/ 24. )*rd.xy;\n    rd.xz = rot( path(lp.z+1.).y/ 14. )*rd.xz;\n\n    float d,m;\n    vec3 p = vec3(0);\n\n    for(int i=0;i<255;i++) {\n        p=ro+rd*d;\n        vec2 ray = map(p,1.);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d+= i>75? ray.x*.65 : ray.x * .2;\n        m = ray.y;\n    }\n    gid=sid;\n\n    if(d<MAX_DIST) {\n        vec3 n = normal(p,d);\n\n        vec3 lpos = vec3(0,0,-6);\n        lpos.z -= tspeed;\n        lpos.xy += path(lpos.z);\n        vec3 l = normalize(lpos-p);\n        float diff = clamp(dot(n,l),.1,.9);\n\n        vec3 h = vec3(.001);\n\n        float hs = hash21(gid);\n        if(hs<.625) h = hsv2rgb(vec3(p.z*.025,1.,.5));\n \n        C = h *diff;\n        \n    } \n\n    C = mix(vec3(.0175),C, exp(-.000045*d*d*d));\n    C = mix(C,vec3(.89),clamp(glow*.5,0.,1.));\n    //C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "buffer_a_inputs": [{"id": 33253, "src": "https://soundcloud.com/trybesof/tim-green-pyxis", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clG3RR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[554, 554, 576, 576, 637], [638, 666, 723, 723, 1303]]}
{"id": "cly3RR", "name": "Rotating box", "author": "mrange", "description": "CC0: Rotating box\n Saw a tweet by @XorDev where he showed the neat trick of time-sin(time)\n Tried it, tinkered with it and published it\n https://twitter.com/XorDev/status/1654553771001749504\n", "tags": ["2d"], "likes": 24, "viewed": 495, "published": 3, "date": "1683391715", "time_retrieved": "2024-07-30T17:57:09.191272", "image_code": "// CC0: Rotating box\n//  Saw a tweet by @XorDev where he showed the neat trick of time-sin(time)\n//  Tried it, tinkered with it and published it\n//  https://twitter.com/XorDev/status/1654553771001749504\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  const float per = 4.0;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  float aa = 4.0/RESOLUTION.y;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 p0 = p;\n  float a0 = TAU*TIME/per;\n  p0 *= ROT(a0-sin(a0));\n  vec3 col = vec3(1.0);\n  float d0 = box(p0, vec2(0.25));\n  float a1 = a0 - TAU*d0/20.0;\n  vec2 p1 = p;\n  p1 *= ROT(a1-sin(a1));\n  float d1 = box(p1, vec2(0.5));\n  col = mix(col, vec3(0.0), smoothstep(0.0, -aa, d0));\n  float m = TAU*10.0;\n  col = mix(col, vec3(0.0), smoothstep(0.0, -aa*m, sin(m*d1-TAU*TIME/per)));\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cly3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 500, 527, 527, 603], [605, 605, 662, 662, 1252]]}
{"id": "ssGGWd", "name": "Apollonian Circle Packings", "author": "mla", "description": "Hyperbolic honeycombs projected from the hyperbolic boundary, and forming Apollonian circle packings. See code header for more.\n\nSee [url]http://www.hyperbolichoneycombs.org/[/url] for more on the maths.", "tags": ["circle", "apollonian", "packing", "hyperbolic"], "likes": 20, "viewed": 301, "published": 3, "date": "1683358435", "time_retrieved": "2024-07-30T17:57:10.120787", "image_code": "/////////////////////////////////////////////////////////////////////\n//\n// Apollonian Circle Packings, mla, 2023\n//\n// In fact, hyperbolic honeycombs, seen on the boundary of hyperbolic\n// space (eg. stereographically projected from the boundary sphere of\n// the Poincare ball).\n// \n// Generated by repeated reflection and inversion in two lines and two\n// circles intersecting at rational angles, representing the faces of\n// the generating hyperbolic tetrahedron.\n//\n// <up>/<down>: zoom in and out\n// <left>/<right>: select tetrahedron\n// i: invert at origin\n// j: invert at mouse position\n// m: monochrome\n// p: progressive folding\n// o: colour by iteration count\n// w,z: show generating lines & circles\n// (+ various other more esoteric key controls)\n//\n/////////////////////////////////////////////////////////////////////\n\n// If point on wrong side of line (p.n < 0), reflect in line\nint tryinvert(inout vec2 p, vec2 n, inout float scale) {\n  if (dot(p,n) < 0.0) {\n    p = reflect(p,n);\n    return 1;\n  }\n  return 0;\n}\n\n// If point in \"interior\" of circle, invert to \"exterior\"\nint tryinvert(inout vec2 p, vec3 c, inout float scale) {\n  if (sign(c.z)*(distance(p,c.xy)-abs(c.z)) < 0.0) {\n    p -= c.xy;\n    float k = c.z*c.z/dot(p,p);\n    p *= k;\n    scale *= k;\n    p += c.xy;\n    return 1;\n  }\n  return 0;\n}\n\nint solve2(vec2 p, float r, vec2 q, float s, int a, out vec2 k);\n\n// Given dihedral angles (P,Q,R),(S,T,U), find lines A,B and\n// circles C,D such that dihedral angles are:\n// AB: P; BC: Q; CA: R\n// AD: S; BD: T; CD: U\n//\n// Line through origin, normal n, and circle centre p, radius r,\n// have dihedral t where r cos t = c.n (draw a triangle),\n// so if (p,r) has dihedral t and u with n and m, we have:\n// r cos t = c.n and  r cos u = c.m  =>\n// c.n/c.m = cos t/cos u =>\n// c.n cos u - c.m cos t = 0 =>\n// c.(n cos u - m cos t) = 0\n// which is equation of a line & any point on the line is the centre\n// of a circle with the correct dihedral (for suitable radius).\n// For dihedral = PI/2, the circle centre is on the line itself,\n// so if both dihedrals are PI/2, the centre is at the origin.\n\nmat4x3 solve(ivec3 pqr, ivec3 stu) {\n  assert(pqr[0] != 0);\n  vec2 n = vec2(1,0);\n  vec2 m = vec2(-icos(pqr[0]),isin(pqr[0]));\n  // Confusing names here:\n  // pqr,stu are vectors of angles\n  // n,m are line normals\n  // p,r,q,s are centre and radius of circles\n\n  // Find point p on line with correct dihedral with n and m\n  vec2 p = mat2(0,-1,1,0)*(m*icos(pqr[2])-n*icos(pqr[1])*n);\n  //if (pqr[1] != 2 || pqr[2] != 2) p = normalize(p);\n  // Make sure cos(PI/2) = 0 is handled properly!\n  // If both, then origin is centre and radius can be arbitrary\n  float r =\n    pqr[1] != 2 ? dot(m,p)/icos(pqr[1]) \n    : pqr[2] != 2 ? dot(n,p)/icos(pqr[2])\n    : 1.0;\n\n  // Find point q on line with correct dihedral with n and m\n  vec2 q = mat2(0,1,-1,0)*(m*icos(stu[0])-n*icos(stu[1]));\n  float s =\n    stu[0] != 2 ? dot(n,q)/icos(stu[0])\n    : stu[1] != 2 ? dot(m,q)/icos(stu[1])\n    : -1.0;\n  // Now scale (q,s) to have correct dihedral with (p,r)\n  vec2 roots;\n  int nroots = solve2(p,r,q,s,stu[2],roots);\n  assert(nroots == 2); // Equation is usually solvable\n  // Default to larger root, this usually (always?) seems\n  // to be the correct thing to do.\n  vec3 C = vec3(p,r);\n  vec3 D = vec3(q,s);\n  D *= key(CHAR_0) ? roots[0] : roots[1]; // Flip roots\n  return mat4x3(vec3(n,0),vec3(m,0),C,D);\n}\n\n// Solve quadratic to find scaled circle (q,s) that has dihedral\n// angle PI/a with circle (p,r).\nint solve2(vec2 p, float r, vec2 q, float s, int a, out vec2 roots) {\n  roots = vec2(0);\n  // Use cosine law:\n  // |p-kq|² = p.p - 2kp.q + k²q.q = r²+k²s²-2krs.cos(a)\n  // If A == 0, then have linear solution plus \"infinity\"\n  // If C == 0, then have linear solution plus zero\n  // Solve Ak²-2Bk+C = 0\n  float A = dot(q,q)-s*s;\n  float B = dot(p,q)+r*s*icos(a);\n  float C = dot(p,p)-r*r;\n  if (abs(A) < 1e-3) {\n    // Problematic case - circle D passes through origin\n    // (which means triangle AB,BD,DA is Euclidean).\n    // -2Bx + C = 0\n    roots[0] = roots[1] = C/(2.0*B);\n    return 2;\n  }\n  if (abs(C) < 1e-3) {\n    // This case seems unproblematic\n    // Ax - 2B = 0\n    roots[0] = roots[1] = 2.0*B/A;\n    return 2;\n  }\n  float D = B*B-A*C;\n  if (D < 0.0) return 0;\n  roots[0] = (B + sqrt(D))/A;\n  roots[1] = (B - sqrt(D))/A;\n  return 2;\n}\n\n// We are really dealing with tetrahedral fundamental\n// domains in hyperbolic space, but just displaying\n// the boundary (as a stereographic projection to the\n// Euclidean plane).\n\n// Tetrahedron angles as (AB,BC,CA),(AD,BD,CD)\n// So for a standard linear Coxeter diagram:\n// AB,BC,CA,AD,BD,CD\n// P  Q  2  2  2  R\n// Q  R  2  P  2  2\n// Q  2  R  2  P  2\n\nconst ivec3 tetrahedra[] =\n  ivec3[](\n          //ivec3(4,4,4), ivec3(4,2,4), // Problem case: A = 0 in quadratic\n          ivec3(4,2,4), ivec3(4,4,4),\n          ivec3(1,0,0), ivec3(0,0,0),\n          ivec3(2,0,0), ivec3(0,0,0),\n          ivec3(3,0,0), ivec3(0,0,0),\n          ivec3(6,7,2), ivec3(2,2,20),\n          ivec3(7,6,2), ivec3(20,2,2),\n          ivec3(7,20,2), ivec3(6,2,2),\n          ivec3(3,3,3), ivec3(2,2,7),\n          ivec3(5,6,2), ivec3(2,2,5),\n          ivec3(6,5,2), ivec3(5,2,0),\n          ivec3(5,2,3), ivec3(2,2,0), // Nice recursive zoom\n          ivec3(3,5,2), ivec3(2,2,0),\n          ivec3(3,2,2), ivec3(2,5,4),\n          ivec3(5,3,2), ivec3(2,2,0),\n          ivec3(2,2,3), ivec3(0,3,2),\n          ivec3(5,3,2), ivec3(0,2,0),\n          ivec3(7,3,2), ivec3(2,2,0),\n          ivec3(3,3,3), ivec3(2,2,0),\n          ivec3(2,2,2), ivec3(3,3,0),\n          ivec3(2,3,5), ivec3(2,2,0),\n          ivec3(5,5,5), ivec3(5,5,0),\n          ivec3(4,2,4), ivec3(4,4,4),\n          ivec3(3,3,3), ivec3(0,0,0),\n          ivec3(6,6,6), ivec3(6,6,0),\n          ivec3(8,3,2), ivec3(2,2,0),\n          ivec3(3,2,8), ivec3(2,0,2),\n          ivec3(3,2,0), ivec3(2,7,0),\n          ivec3(3,7,2), ivec3(2,2,0),\n          ivec3(7,3,2), ivec3(0,2,2)\n          );\n\nvec3 getcol(vec2 p, float scale, vec2 mouse);\n\nvec2 A,B; // Lines\nvec3 C,D; // Circles\nvec3 O0,O1,O2,O3; // Orthogonal Circles\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 mouse = vec2(0);\n  if (iMouse.x > 0.0) mouse = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n\n  int ntetrahedra = tetrahedra.length()/2;\n  int tindex = keycount(KEY_RIGHT)-keycount(KEY_LEFT);\n  tindex %= ntetrahedra+1;\n  assert(tindex >= 0);\n  if (tindex != 0) tindex--;\n  else tindex = int(iTime)%(ntetrahedra);\n  ivec3 pqr = tetrahedra[2*tindex], stu = tetrahedra[2*tindex+1];\n  //if (stu.z == 0) stu.z = int(iTime);\n\n  mat4x3 ABCD = solve(pqr,stu);\n  A = vec2(ABCD[0]);\n  B = vec2(ABCD[1]);\n  C = ABCD[2];\n  D = ABCD[3];\n  if (key(CHAR_A) && iMouse.x != 0.0) D *= 2.0*mouse.x; // Set angle D from mouse\n\n  // Find orthogonal circles\n  // Any circle with centre (0,0) is orthogonal to A,B\n  O0 = vec3(0,0,sqrt(dot(C.xy,C.xy)-C.z*C.z)); // Orthogonal to A,B,C\n  O1 = vec3(0,0,sqrt(dot(D.xy,D.xy)-D.z*D.z)); // Orthogonal to A,B,D\n  {\n    // O2 orthogonal to A,C,D -> centre lies on A\n    // O3 orthogonal to B,C,D -> centre lies on B\n    vec2 e = (D.xy-C.xy);\n    float K = dot(C.xy,C.xy)-dot(D.xy,D.xy)+D.z*D.z-C.z*C.z;\n    vec2 p2 = vec2(A.y,-A.x), p3 = vec2(B.y,-B.x);\n    p2 *= -K/(2.0*dot(p2,e));\n    p3 *= -K/(2.0*dot(p3,e));\n    O2 = vec3(p2,sqrt(dot(C.xy-p2,C.xy-p2)-C.z*C.z));\n    O3 = vec3(p3,sqrt(dot(C.xy-p3,C.xy-p3)-C.z*C.z));\n  }\n\n  float zoom = 2.0;\n  // Try to scale so the main circle just fits on screen\n  if (O0.z > 0.001 || O1.z > 0.001) {\n    zoom = 1.0;\n    float k = 1.0/max(O0.z,O1.z);//O1.z;\n    C *= k; D *= k;\n    O0 *= k; O1 *= k; O2 *= k; O3 *= k;\n  }\n  \n  zoom *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n\n  bool dozoom = false;\n  //dozoom = !key(CHAR_I);\n  if (dozoom) zoom *= exp(10.0*mouse.y);\n  float AA = 2.0;\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 p = zoom*(2.0*(fragCoord.xy+vec2(i,j)/AA) - iResolution.xy)/iResolution.y;\n      col += getcol(p,zoom,mouse);\n    }\n  }\n  col /= AA*AA;\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n\nvec3 getcol(vec2 p, float scale, vec2 mouse) {\n  float maxscale = 200.0;\n  int loops = 20;\n  if (key(CHAR_P)) loops = min(loops,1+int(iTime)); // Progressive\n  if (key(CHAR_I)) {\n    // Invert at origin\n    float k = 1.0/dot(p,p);\n    p *= k;\n    scale *= k;\n  }\n  if (key(CHAR_J)) {\n    // Invert at mouse position\n    p -= 2.0*mouse;\n    float k = 1.0/dot(p,p);\n    p *= k;\n    scale *= k;\n    p += 2.0*mouse;\n  }\n  // Remember original coordinates & scale\n  // for drawing control circles & lines.\n  vec2 p0 = p;\n  float scale0 = scale;\n  vec3 col = vec3(0);\n  int i;\n  int steps = 0;\n  for (i = 0; i < loops; i++) {\n    // Apply mirrors first\n    for (int j = 0; j < 20; j++) {\n      int k = 0;\n      k += tryinvert(p,A,scale);\n      k += tryinvert(p,B,scale);\n      if (k == 0) break;\n    }\n    int k = 0;\n    // Then inversion circles\n    k += tryinvert(p,C,scale);\n    k += tryinvert(p,D,scale);\n    steps += k;\n    if (k == 0) break;\n  }\n  if (key(CHAR_O)) {\n    col = h2rgb(float(steps)/12.0); // Color by steps\n    col = 0.2+0.8*col;\n  } else if (!key(CHAR_M)) {\n    if (length(p) < O0.z) col = vec3(0,1,0);\n    if (length(p) > O1.z) col = vec3(1,1,0); // NB. O1 is \"inverted\"\n    if (length(p-O2.xy) < O2.z) col = vec3(0,0,1);\n    if (length(p-O3.xy) < O3.z) col = vec3(1,0,0);\n    col = 0.2+0.8*col;\n  }\n  if (key(CHAR_T)) col *= 0.6+0.4*texture(iChannel0,p).xyz;\n  float kk = 0.5;\n  if (length(p) < O0.z) kk /= O0.z;\n  else if (length(p) > O1.z) kk /= O1.z; // NB. O1 is \"inverted\"\n  else if (length(p-O2.xy) < O2.z) kk /= O2.z;\n  else if (length(p-O3.xy) < O3.z) kk /= O3.z;\n  if (key(CHAR_G)) kk *= 2.0;\n  if (key(CHAR_H)) kk *= 0.5;\n  if (length(p) > O1.z) {\n    // An adhoc correction to scale for the \"inverted\" circle O1.\n    if (key(CHAR_S)) assert(false);\n    vec2 p1 = p-O1.xy;\n    kk *= O1.z*O1.z/dot(p1,p1);\n  }\n  if (key(CHAR_D)) col *= 0.8;\n  float minwidth = 2.0*scale/iResolution.y;\n  float cdist = min(min(dist(p,A),dist(p,B)),\n                    min(dist(p,C),dist(p,D)));\n  if (!key(CHAR_X)) {\n    float cwidth = minwidth;\n    if (key(CHAR_F)) cwidth = max(0.0,0.01/kk);\n    vec3 ccol = vec3(1);\n    col = mix(ccol, col, 0.5+0.5*smoothstep(0.5*cwidth,cwidth,cdist));\n  }\n  if (key(CHAR_Y)) {\n    float cwidth = minwidth;\n    if (key(CHAR_F)) cwidth = max(0.0,0.005/kk);\n    vec3 ccol = vec3(0);\n    col = mix(ccol, col, 0.2+0.8*smoothstep(0.5*cwidth,cwidth,cdist));\n  }\n  if (!key(CHAR_U) && kk*scale > maxscale) col = vec3(0);\n  if (key(CHAR_W)){\n    vec3 ccol = vec3(1);\n    float d = 1e8;\n    float cwidth = 2.0*scale0/iResolution.y;\n    if (O0.z > 0.0) d = min(d,dist(p0,O0));\n    if (O1.z > 0.0) d = min(d,dist(p0,O1));\n    if (O2.z > 0.0) d = min(d,dist(p0,O2));\n    if (O3.z > 0.0) d = min(d,dist(p0,O3));\n    col = mix(ccol, col, smoothstep(0.0,cwidth,d-cwidth));\n  }\n  if (key(CHAR_Z)) {\n    float cwidth = 2.0*scale0/iResolution.y;\n    float cdist0 = min(min(dist(p0,A),dist(p0,B)),\n                       min(dist(p0,C),dist(p0,D)));\n    vec3 ccol = vec3(0);\n    col = mix(ccol, col, smoothstep(0.0,cwidth,cdist0-cwidth));\n  }\n  return col;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Distance to line (through origin)\nfloat dist(vec2 p, vec2 l) {\n  return abs(dot(p,l));\n}\n\n// Distance to circle (z coord is radius, if negative then consider\n// the \"interior\" to be points x with |x - c.xy| > c.z\nfloat dist(vec2 p, vec3 c) {\n  return abs(distance(p,c.xy)-abs(c.z));\n}\n\nfloat COS[] =\n  // I don't trust cos on the GPU to be accurate enough: cos(PI/n) for n = 0..31\n  float[](1.0,-0.5,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  if (p == 0) return 1.0;\n  return cos(PI/float(p));\n}\n\nfloat isin(int p) {\n  // sin(PI/p)\n  float t = icos(p);\n  return sqrt(1.0-t*t);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGGWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[831, 892, 948, 948, 1026], [1028, 1086, 1142, 1142, 1317], [2114, 2114, 2150, 2150, 3407], [3409, 3507, 3576, 3576, 4360], [6101, 6101, 6157, 6157, 8155], [8157, 8157, 8203, 8203, 11242]]}
{"id": "dldGWl", "name": "fadecircle", "author": "kenshin", "description": "circle", "tags": ["fadecircle"], "likes": 0, "viewed": 143, "published": 3, "date": "1683356490", "time_retrieved": "2024-07-30T17:57:10.872776", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    float fade = 0.02;\n    float thinness = 0.02;\n    vec3 circleColor = vec3(0.7, 0.2, 0.5);\n    float dist = 1.0 - sqrt(dot(uv, uv));\n    vec3 color  =  vec3(smoothstep(0.0, fade, dist));\n         color *= vec3(smoothstep(fade + thinness, thinness, dist));\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n    fragColor.rgb *= circleColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 537]]}
{"id": "Dld3Ds", "name": "Rainbow rug (music)", "author": "jarble", "description": "Another interesting rug pattern.", "tags": ["fractal", "mosaic", "carpet", "rug"], "likes": 6, "viewed": 161, "published": 3, "date": "1683354109", "time_retrieved": "2024-07-30T17:57:11.675630", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    vec2 uv1 = uv;\n    uv.x = mod(uv.x,.5)+.25;\n    //uv.y = mod(uv.y,1.)-.5;\n    uv.y = mod(uv.y,.5)+2.;\n    for(int k = 0; k < 9; k++){\n        uv =\n            abs(-.5+uv-t2*sign(uv.y-uv.x))/1.5+1.\n        ;\n        b = uv.y>uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv-.5*sign(uv.y-uv.x)).yx\n        ;\n        uv =\n            t2+triangle_wave(uv.yx).yx\n        ;\n        if(uv.y>uv.x)\n        //{t2 = t2.yx; uv=uv.yx;}\n        col.x =\n            abs((uv.x)-col.x)\n        ;\n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "//remix of: https://www.shadertoy.com/view/csK3zm\n\n#define fmod(x,y) floor(max(mod(floor(-(x))/2.,y),mod(floor(x)*2.,y)))\n#define fmod1(x,y) floor(min(mod(floor(-(x))/2.,y),mod(floor(x)*2.,y)))\nvec2 mainSound(int samp, float time){  \n  float tempo = .5;\n  time /= tempo;\n  float s2 = pow(2.,1.+fmod1(time/4.,3.)),\n  s1 = pow(2.,fmod(time*s2*2.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1*2.+1.,2.)),\n  t = time/s1/pow(2.,fmod1(time/5./8.,5.))*2.,\n  t1 = 1.+fmod(t/s1,2.),\n  m4 = fmod1(t*s1/t1,s2),\n  m3 = fmod(t*s1/m1,s2);\n  t *= s1/t1;\n  float m2 = 1. + fmod(t,s1),\n  a = 8.*(abs(.5+abs(fract(-t)))/1.5),\n  nb = time*tempo*pow(2.,(m3+m2)/5.+7.5);\n  return abs(abs(1./s1-1./s2)/8.-abs(vec2(sin(nb),cos(nb))))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dld3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1126]]}
{"id": "cttGDs", "name": "camera tracking default", "author": "tianluo97", "description": "camera tracking default", "tags": ["cameratrackingdefault"], "likes": 0, "viewed": 135, "published": 3, "date": "1683344516", "time_retrieved": "2024-07-30T17:57:12.522366", "image_code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float divisionLine;\n    divisionLine = 0.5;\n    float d = cubicPulse(divisionLine,0.16,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //混合遮罩\n    //maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板 分成三段\n    float PI = 3.1415926;\n    float time = iTime * 0.; \n    float scale = 1.;\n    \n    vec4 vcolor0 = vec4(0.000,0.298,1.000,1.0);\n    vec4 vcolor1 = vec4(0.322,0.502,1.000,1.0);\n    vec4 vcolor2 = vec4(0.000,0.192,0.722,1.0);\n    \n    float step0 = 0.2 * scale;\n    float step1 = 0.4 * scale;\n    float step2 = 0.6 * scale;\n\n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor;\n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor0,dist2);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //darkColorMask\n    float darkMaskd = cubicPulse(divisionLine,0.24,uv.x);\n    vec3 darkMaskColor = vec3(darkMaskd);\n    float darkMaskpct = plot(uv,darkMaskd);\n    \n    vec3 darkColorMask = darkMaskColor+darkMaskpct*vec3(0.0,1.0,0.0);\n    darkColor = mix(darkColor,vec4(0.361,0.639,1.000,1.),darkColorMask.r);\n    \n    \n    //浅色色板\n    float qscale = 0.25;\n    float qtime = iTime * 0.;\n    \n    float qstep0 = 0.05 * qscale;\n    float qstep1 = 0.25 * qscale;\n    float qstep2 = 0.45 * qscale;\n    float qstep3 = 0.75 * qscale;\n    \n    vec4 qcolor0 = vec4(0.722,0.804,1.000,1.0);\n    vec4 qcolor1 = vec4(0.722,0.804,1.000,1.0);\n    vec4 qcolor2 = vec4(1.000,0.616,0.522,1.0);\n    vec4 qcolor3 = vec4(1.000,0.933,0.702,1.0);\n    vec4 qcolor4 = vec4(1.000,1.000,1.000,1.0);\n    \n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x- 0.15;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    //lightColor = vec4(dist0);\n    //lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    //蓝到橙色\n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    //橙色到黄色\n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    //lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    //黄色到白色\n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    //lightColor = vec4(dist3);\n    //lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    //lightColor = vec4(1.0);\n    \n    //通过混合遮罩进行混合\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //ending mask mask\n    float endMask = smoothstep(0.62,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    //fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 189], [191, 191, 237, 237, 331], [333, 333, 364, 364, 455], [457, 457, 500, 500, 943], [945, 945, 999, 999, 1021], [1023, 1023, 1075, 1075, 1142], [1144, 1144, 1168, 1168, 1198], [1200, 1200, 1223, 1223, 1546], [1548, 1636, 1739, 1739, 4277], [4279, 4279, 4336, 4374, 8767]]}
{"id": "Dt33Dl", "name": "just fun 230505", "author": "elenzil", "description": "yep", "tags": ["optics", "transmission", "nonphysical"], "likes": 6, "viewed": 161, "published": 3, "date": "1683343759", "time_retrieved": "2024-07-30T17:57:13.399022", "image_code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nfloat gVPZoom     =   0.8;\nfloat gVPEps      =   1e9;        // viewport epsilon\nfloat gVPLW       =   1e9;        // viewport linewidth\n\n\nfloat viewportFromScreen(in float D) {\n    return D * 2.0 / MINRES / gVPZoom;\n}\n\nvec2 viewportFromScreen(in vec2 XY) {\n    return vec2(viewportFromScreen(XY.x - RES.x / 2.0),\n                viewportFromScreen(XY.y - RES.y / 2.0));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec2 xy = viewportFromScreen(XY);\n    gVPEps  = viewportFromScreen(2.0);\n    gVPLW   = viewportFromScreen(2.0);\n\n    float d = 1e9;\n    d =  min( d, smoothstep(0.0, gVPEps, abs(sin(xy.x * 3.0 + iTime)) - gVPLW * 4.0 ));\n    d = -min(-d, abs(xy.y) - gVPLW * 3.0);\n    vec3 c = vec3(0.8);\n    c = mix(c, vec3(0.5, 0.1, 0.1), smoothstep(gVPEps, 0.0, d));\n\n    xy.y /= sin(xy.x * 3.0 + iTime);\n    float q = length(xy) - 0.9;\n    c = mix(c, vec3(0.6, 0.7, 0.8), smoothstep(gVPEps, 0.0, q));\n    d = abs(q) - gVPLW;\n\n    c = mix(c, vec3(0.0), smoothstep(gVPEps, 0.0, d));\n\n\n    RGBA = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt33Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 245, 245, 286], [288, 288, 325, 325, 440], [442, 442, 485, 485, 1085]]}
{"id": "Dld3Ws", "name": "XOR Towers Mini - 143 chars", "author": "GregRostami", "description": "It's really amazing how much varied geometry you can get from a single XOR function!!\nCan you make this shorter? ", "tags": ["bw", "city", "fake3d", "short", "towers", "golf"], "likes": 12, "viewed": 310, "published": 3, "date": "1683343592", "time_retrieved": "2024-07-30T17:57:14.393363", "image_code": "// Wait for it ...\n// Amazing how much variation there is in an XOR!!\nvoid mainImage(out vec4 o, vec2 u){\n    o *= 0.;\n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )\n        b = ivec4( iTime * vec2 (1,4) + 5.*(u/iResolution.y-.7)*o.a, o+=.1 );\n    o /= 74.; }", "image_inputs": [{"id": 33218, "src": "https://soundcloud.com/sanya89/jean-michel-jarre-04-en-attendant-cousteau", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dld3Ws.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 105, 105, 258]]}
{"id": "mld3Wj", "name": "Year of Truchets #017", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nwow surprised that I made it to 17 truchet shaders so far!", "tags": ["2d", "truchet", "tile", "polarwarp"], "likes": 24, "viewed": 423, "published": 3, "date": "1683325291", "time_retrieved": "2024-07-30T17:57:15.170286", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #017\n    05/05/2023  @byt3_m3chanic\n    \n    - music just for effect -\n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453);}\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\n//@iq hue palettes \nvec3 hue(float t){ return .35 + .4*cos(PI2*t*(vec3(.95,.97,.98)*vec3(0.098,0.345,0.843))); }\n\nfloat ck = 0., d2 = 0.;\nvec2 g = vec2(0), id = vec2(0);\n\nfloat makeTile(vec2 uv){\n\n    id = floor(uv);\n    vec2 q = fract(uv)-.5;\n    g = q;\n  \n    ck = mod(id.x+id.y,2.)*2.-1.;\n    float hs = hash21(id);\n\n    float wd = .12+.1*sin(uv.x*.75+T*2.5);\n    if(hs>.5) q *= rot(1.5707);\n    \n    vec2 sp = vec2(length(q-.5),length(q+.5));\n    vec2 p = sp.x<sp.y? q-.5 : q+.5;\n\n    // main pattern\n    float d = length(p)-.5;\n    d = abs(d)-wd;\n    \n    float c = min(length(q.x)-wd,length(q.y)-wd);\n    if (hs>.9) d = c;\n    \n    hs = fract(hs*413.372);\n    if (hs>.9) d = min(length(abs(q)-vec2(.5,0))-wd,length(q.x)-wd);\n    if (hs<.1) d = min(abs(length(q)-.2)-wd,max(c,-(length(q)-.2)));\n\n    d2 = abs(max(abs(q.x),abs(q.y))-.5)-.005;\n\n    return d;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec3 C = vec3(.01);\n    \n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    vec2 vv = uv;\n   \n    float fd = (uv.y+.25)*1.35;\n    fd = clamp(1.,0.,fd);\n\n    \n    uv *= rot(-T*.11);\n    uv = vec2(log(length(uv)), atan(uv.y, uv.x))*5.41;  //3.5;//2.545;//1.91;//1.2726;//.63;\n    uv.x -= T*.35;\n        \n    vec3 clr = hue((uv.x+2.)*.209);\n    vec3 clx = hue((uv.x+2.)*.41);\n\n    float px = fwidth(uv.x); \n    float d = makeTile(uv);\n\n    float s = smoothstep(.075+px,-px,d);\n    d2 = smoothstep(px,-px,d2);\n\n    C = mix(C,vec3(.125),d2);\n    C = mix(C,C*.3,s);\n    \n    float d3 = smoothstep(px,-px,abs(d)-.04);\n    float d4=mix(d,0.,fd);\n    \n    d4 = smoothstep(px,-px,d4+.1);\n    d = smoothstep(px,-px,d);\n    \n    C = mix(C,clr,d);\n    C = mix(C,C*.1,d3);\n    C = mix(C,clamp(C+.3,C,vec3(1)),d4);\n    \n    float v = length(vv)-.0005;\n    v = smoothstep(.2,.0,v);\n    C = mix(C,vec3(.01),clamp(0.,.7,v));\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n\n\n    \n    \n        \n    \n        \n    \n        \n    \n        \n    \n    ", "image_inputs": [{"id": 33221, "src": "https://soundcloud.com/thegardensofbabylon/carlita-movimiento-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mld3Wj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[467, 467, 489, 489, 550], [551, 551, 570, 570, 614], [615, 635, 653, 653, 727], [786, 786, 810, 810, 1478], [1480, 1480, 1521, 1521, 2476]]}
{"id": "cltGWl", "name": "16,777,216 colors", "author": "Slals", "description": "RGB gamut\n\nClick to see the color of a specific pixel", "tags": ["colors", "rgb", "gamut"], "likes": 0, "viewed": 159, "published": 3, "date": "1683324294", "time_retrieved": "2024-07-30T17:57:15.918286", "image_code": "#define MODE 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 M = iMouse.xyz / iResolution.xyz;\n    \n    uv *= 16.0;\n    M.xy *= 16.0;\n    vec2 col = floor(uv);\n    vec2 MCol = floor(M.xy);\n    uv = fract(uv);\n    M.xy = fract(M.xy);\n    uv.x = 1.0 - uv.x;\n    M.x = 1.0 - M.x;\n    \n    float r = uv.x, g = uv.y, b = (col.x + (col.y * 16.0)) / 255.0;\n\n    if (iMouse.z >= 1.0) {\n        if (MODE == 1) {\n            vec2 baseUv = fragCoord / iResolution.xy;\n            r = 1.0 - baseUv.x;\n            g = baseUv.y;\n        } else {\n            r = M.x;\n            g = M.y;\n        }\n        b = (MCol.x + (MCol.y * 16.0)) / 255.0;\n    }\n\n    fragColor = vec4(1.0 - vec3(r, g, b), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltGWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 123, 800]]}
{"id": "ml3Gzf", "name": "less repetitive texture tilling", "author": "mdb", "description": "test of offset in texture tilling", "tags": ["texture", "tilling"], "likes": 2, "viewed": 193, "published": 3, "date": "1683321240", "time_retrieved": "2024-07-30T17:57:16.674265", "image_code": "vec2 getOffset(vec2 p){\n    return vec2(fract(sin(p.x*946336.+6.+p.y*334747.)), \n                fract(sin(p.x*756854. + p.y*95236.+1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=6.;\n    \n    float overlap = 0.1;\n    \n    float w = 0.;\n    vec3 col = vec3(0.);\n    vec2 uvf = fract(uv);\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n            vec2 off = vec2(i, j);\n            vec2 uv2 = off+vec2((i==0)?uvf.x:1.-uvf.x, (j==0)?uvf.y:1.-uvf.y);\n            \n            \n            float weight = (1. - smoothstep(0., overlap, abs(uvf.x - uv2.x)))\n                          *(1. - smoothstep(0., overlap, abs(uvf.y - uv2.y)));\n            \n            w += weight;\n            col += weight*texture(iChannel0, uvf+getOffset(floor(uv)+off)).rgb;\n        }\n    }\n    col /= w;\n    //test\n    if(fragCoord.x/iResolution.x < 0.5) col = texture(iChannel0, uv).rgb; \n    if(abs(fragCoord.x/iResolution.x-0.5) < 0.001) col = vec3(1.000,0.808,0.478);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3Gzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 140], [142, 142, 199, 249, 1120]]}
{"id": "mtcGDs", "name": "irregular checkerboard", "author": "ianwall", "description": "-", "tags": ["grid"], "likes": 2, "viewed": 160, "published": 3, "date": "1683318395", "time_retrieved": "2024-07-30T17:57:17.450190", "image_code": "float brightnessAtScale(vec2 fragCoord, float scale)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += iTime/10.0;\n    vec2 checker = (floor(uv * scale)+0.5) / scale;\n    return dot(texture(iChannel0, checker).rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Define the colors\n    vec3 color1 = vec3(1.0, 0.0, 0.0); // Red\n    vec3 color2 = vec3(0.0, 1.0, 0.0); // Green\n    vec3 color3 = vec3(0.0, 0.0, 1.0); // Blue\n    vec3 color4 = vec3(1.0, 1.0, 0.0); // Yellow\n    vec3 color;\n\n\n    float scale = 100.0;\n    for(int i = 0; i < 7; ++i)\n    {\n        float b = 1.0-brightnessAtScale(fragCoord, scale);\n        if(b > 0.9+0.06*sin(iTime/1.0))\n        {\n            break;\n        }\n        scale/=1.66;\n    }\n    \n    vec2 checker = mod(floor(uv * scale), 2.0);\n    color = mix(mix(color1, color2, checker.y), mix(color3, color4, checker.y), checker.x);\n\n    //color = vec3(fract(uv * scale), 0.0);\n    //color = vec3(brightnessAtScale(fragCoord, scale));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 246], [248, 248, 305, 355, 1143]]}
{"id": "dlcGDl", "name": "Song", "author": "forprix", "description": "Bored", "tags": ["music"], "likes": 2, "viewed": 155, "published": 3, "date": "1683310204", "time_retrieved": "2024-07-30T17:57:18.201182", "image_code": "\nconst float PI = 3.1415926538;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(cos(iTime * PI * 2. / 0.2) * 0.3);\n}", "image_inputs": [], "sound_code": "\nconst float PI = 3.1415926538;\n\nconst float nots2[] = float[](0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., -9., -9., -9., -9., -9., -9., -9., -9., -9., -9., -9., -9., -5., -5., -5., -5., -5., -5., -5., -5., -5., -5., -5., -5., 3., 3., 3., 3., 3., 3., 3., 3., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., -7., -7., -7., -7., -7., -7., -7., -7., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -2., -2., -2., -2., -2., -2., -2., -2., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -2., -2., -2., -2., -2., -2., -2., -2., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -2., -2., -2., -2., -2., -2., -2., -2., -19., -19., -19., -19., -19., -19., -19., -19., -19., -19., -19., -19., -3., -3., -3., -3., -3., -3., -3., -3., -3., -3., -3., -3., -12., -12., -12., -12., -12., -12., -12., -12., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -5., -5., -5., -5., -5., -5., -5., -5., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -5., -5., -5., -5., -5., -5., -5., -5., -9., -9., -9., -9., -9., -9., -9., -9., -9., -9., -9., -9., -5., -5., -5., -5., -5., -5., -5., -5., -5., -5., -5., -5., 3., 3., 3., 3., 3., 3., 3., 3., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., -7., -7., -7., -7., -7., -7., -7., -7., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -2., -2., -2., -2., -2., -2., -2., -2., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -17., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -2., -2., -2., -2., -2., -2., -2., -2., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -10., -2., -2., -2., -2., -2., -2., -2., -2., -19., -19., -19., -19., -19., -19., -19., -19., -19., -19., -19., -19., -3., -3., -3., -3., -3., -3., -3., -3., -3., -3., -3., -3., -12., -12., -12., -12., -12., -12., -12., -12., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -5., -5., -5., -5., -5., -5., -5., -5., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -21., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -14., -5., -5., -5., -5., -5., -5., -5., -5.);\nconst float vols2[] = float[](0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1.);\n\nconst float nots1[] = float[](0., 0., 0., 0., 0., 0., 0., 0., 2., 2., 2., 2., 2., 2., 2., 2., 5., 5., 5., 5., 5., 5., 5., 5., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 0., 0., 0., 0., 0., 0., 0., 0., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -7., -7., -7., -7., -7., -7., -7., -7., -2., -2., -2., -2., -2., -2., -2., -2., 0., 0., 0., 0., 0., 0., 0., 0., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., -7., -7., -7., -7., -7., -7., -7., -7., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., -2., 0., 0., 0., 0., 0., 0., 0., 0., 2., 2., 2., 2., 2., 2., 2., 2., 5., 5., 5., 5., 5., 5., 5., 5., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 7., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 9., 9., 9., 9., 9., 9., 9., 9., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 5., 5., 5., 5., 5., 5., 5., 5., 10., 10., 10., 10., 10., 10., 10., 10., 12., 12., 12., 12., 12., 12., 12., 12., 14., 14., 14., 14., 14., 14., 14., 14., 12., 12., 12., 12., 12., 12., 12., 12., 10., 10., 10., 10., 10., 10., 10., 10., 12., 12., 12., 12., 12., 12., 12., 12., 12., 12., 12., 12., 12., 12., 12., 12., 5., 5., 5., 5., 5., 5., 5., 5., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10., 10.);\nconst float vols1[] = float[](1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0.);\nconst int len = 512;\n\nfloat note2freq(float note) {\n  return pow(2., note / 12.) * 440.;\n}\nfloat smp2sec(int smp, float mod_) {\n    return float(smp % int(mod_ * float(iSampleRate))) / float(iSampleRate);\n}\nfloat smp2sec(int smp) {\n    return float(smp) / float(iSampleRate);\n}\n\nfloat sinWave(float time, float note) {\n    return sin(PI * 2. * note2freq(note) * time);\n}\nfloat sqrWave(float time, float note) {\n    return sinWave(time, note) > 0. ? 1. : -1.;\n}\nfloat sawWave(float time, float note) {\n    return mod(time * 2. * note2freq(note), 2.) - 1.;\n}\n\nfloat synth(int channel, int iSample) {\n    // Original Song: \"Virtual Riot - Chroma\"\n    int noteDuration = int(iSampleRate) / 40;\n    int mSample = iSample % (noteDuration * len);\n    \n    int notei1 = mSample / noteDuration;\n    int notei2 = (notei1 + 1) % len;\n    int pos = mSample - (notei1 * noteDuration);\n    float cosPos1 = (cos(float(pos) / float(noteDuration) * PI) + 1.) / 2.;\n\n    float nt1_1 = nots1[notei1];\n    float nt2_1 = nots1[notei2];\n    float nt1v_1 = vols1[notei1] * cosPos1;\n    float nt2v_1 = vols1[notei2] * (1. - cosPos1);\n\n    float nt1_2 = nots2[notei1];\n    float nt2_2 = nots2[notei2];\n    float nt1v_2 = vols2[notei1] * cosPos1;\n    float nt2v_2 = vols2[notei2] * (1. - cosPos1);\n    \n    return \n        sqrWave((float(mSample) / float(iSampleRate)), nt1_1) * nt1v_1 * 0.2 +\n        sqrWave((float(mSample) / float(iSampleRate)), nt2_1) * nt2v_1 * 0.2 +\n\n        sawWave((float(mSample) / float(iSampleRate)), nt1_2) * nt1v_2 * 0.2 +\n        sawWave((float(mSample) / float(iSampleRate)), nt2_2) * nt2v_2 * 0.2 ;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2(synth(0, samp), synth(1, samp));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlcGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 90, 90, 148]]}
{"id": "dtcGDl", "name": "To infinity and beyond...", "author": "mrange", "description": "CC0: To infinity and beyond...\nWIP - Had some more plans but stalled out\nTried to replicate something but don't reemmber what\n", "tags": ["infinity"], "likes": 31, "viewed": 448, "published": 3, "date": "1683310049", "time_retrieved": "2024-07-30T17:57:19.004036", "image_code": "// CC0: To infinity and beyond...\n// WIP - Had some more plans but stalled out\n// Tried to replicate something but don't reemmber what\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  12.0\n#define MAX_RAY_MARCHES 60\n#define MAX_SHADOW_MARCHES 30\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define CSA(a)          vec2(cos(a),sin(a))\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB_(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n           (p.x>0.0)?p.y:l );\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat inf(vec2 p) {\n  const float sm = 0.125;\n  p.y = -pabs(p.y, sm);\n  p.x = -pabs(p.x, sm);\n  const float a = PI/4.;\n  const vec2 csa = CSA(a);\n  const float r = 1.5;\n  p.y += 2.0*r*sin(a);\n  return horseshoe(p, csa, r, vec2(100.0, 0.25));\n}\n\nfloat inf(vec3 p, float h) {\n  p = p.yzx;\n  float d = inf(p.xy);\n  vec2 w = vec2(d, abs(p.z) - h);\n  return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\nfloat dot2(vec3 p) {\n  return dot(p, p);\n}\n\nfloat df(vec3 p) {\n  float d0 = inf(p, 0.125)-0.1;\n  vec2 pp = 20.0*p.yz;\n  float h = dot2(sin(pp));\n  h *= h;\n  h *= h;\n  h *= h;\n  float d1 = p.x-0.05*abs(p.y)+0.00005*h;\n  const vec2 nn = normalize(vec2(1.5, 1.));\n  const float zz = 0.5;\n  float d = d1;\n  /*\n  float d2 = vorMap(p/zz)*zz-0.025+0.025*length(p.zy);\n  d = pmax(d, -d2, 0.05);*/\n  d = pmax(d, -(d0-0.125), 0.025);\n  d = min(d, d0);\n\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\n\nfloat softShadow(vec3 ps, vec3 ld, float mint, float k) {\n  float res = 0.0;\n  float t = mint*7.0;\n  for (int i=0; i<MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = df(p);\n    if (d < 0.0) return 0.0;\n    res += 0.05*inversesqrt((d));\n    if (res > 1.0) {\n      return 0.0;\n    };\n    t += max(d, mint);\n  }\n  return clamp(1.0-res, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  const vec3 lightPos1 = vec3(5.0, 3.0, 1.0)*2.;\n  const vec3 lightPos2 = vec3(5.0, -3.0, -2.0)*2.;\n  \n  float t = rayMarch(ro, rd);\n  vec3 col = vec3(0.0);\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n\n  vec3 ld1 = normalize(lightPos1 - p);\n  float ll21 = dot2(lightPos1 - p);\n  float dif1 = max(dot(ld1, n), 0.0);\n  float spe1 = pow(max(dot(ld1, r), 0.0), 10.0);\n\n  float sd = softShadow(p, ld1, 0.025, 2.0);\n\n  vec3 ld2 = normalize(lightPos2 - p);\n  float ll22 = dot2(lightPos2 - p);\n//  float sd1 = softShadow(p, ld1, 0.025, 2.0);\n  float dif2 = max(dot(ld2, n), 0.0);\n  dif2 *= dif2;\n  float spe2 = pow(max(dot(ld2, r), 0.0), 20.0);\n\n  const float i = 100.0; \n//  float h = 0.7 + 0.125*p.z*p.x-0.25*p.x+0.0125*p.y*p.z;\n  float h1 = 0.6;\n  float h2 = 0.025;\n  \n  vec3 dcol1 = hsv2rgb(vec3(h1, 0.85, i));\n  vec3 scol1 = hsv2rgb(vec3(h1, 0.33, i));\n\n  vec3 dcol2 = hsv2rgb(vec3(h2, 0.90, 0.33*i));\n  vec3 scol2 = hsv2rgb(vec3(h2, 0.66, 0.33*i));\n  if (t < MAX_RAY_LENGTH) {\n    vec3 col1 = dcol1;\n    col1 *= mix(0.1, 1.0, dif1);\n    col1 *= mix(0.2, 1.0, sd);\n    col1 += spe1*sd*scol1;\n    col1 /= ll21;\n    col += col1;\n    \n    vec3 col2 = dcol2;\n    col2 *= mix(0.1, 1.0, dif2);\n    col2 *= mix(0.2, 1.0, sd);\n    col2 += spe2*sd*scol2;\n    col2 /= ll22;\n    col += col2;\n  }\n\n  col -= 0.08*vec3(1.0, 2.0, 1.0);\n  return 1.5*col;\n}\n\nvec3 effect(vec2 p) {\n  const vec3 ro = vec3(5.0, 0.0, 0.01);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(1.75, 1.0-0.5, length(pp));\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtcGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[680, 680, 702, 702, 848], [1144, 1244, 1263, 1263, 1350], [1352, 1459, 1485, 1485, 1669], [1671, 1771, 1810, 1810, 1895], [1897, 1985, 2024, 2024, 2053], [2055, 2143, 2173, 2173, 2201], [2203, 2321, 2371, 2371, 2612], [2614, 2614, 2633, 2633, 2857], [2859, 2859, 2887, 2887, 3012], [3014, 3014, 3034, 3034, 3056], [3058, 3058, 3078, 3078, 3100], [3102, 3102, 3120, 3120, 3514], [3516, 3516, 3539, 3539, 3747], [3749, 3749, 3783, 3783, 4115], [4118, 4118, 4175, 4175, 4479], [4481, 4481, 4512, 4512, 5876], [5878, 5878, 5899, 5899, 6260], [6262, 6262, 6319, 6319, 6600]]}
{"id": "ml3GDl", "name": "Lava lenses", "author": "pfuerte", "description": "abstract warping effect", "tags": ["lava"], "likes": 6, "viewed": 165, "published": 3, "date": "1683310037", "time_retrieved": "2024-07-30T17:57:19.858751", "image_code": "float random(in vec2 st){\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nmat2 rotate(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat lava(in vec2 coord, in float direction){\n    float len;\n    for(int i = 0;i  <3 ; i++){\n        float noi = sin(floor(random(coord)*.9));\n        len = length(coord)*length(coord)/9.;\n        coord.x = coord.x - cos(coord.y + sin(len)) + cos(iTime / 9.0);\n        coord.y = coord.y + cos(coord.y + cos(len)) + sin(iTime / 12.0);\n        coord *= rotate(direction*iTime/10.);\n    }\n    return len;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 coord = 12.0 * (fragCoord.xy-iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\n\n    float n = random(fragCoord.xy/200.);\n\n    float circle = sin(length(coord)*1.5);\n    float circleMask = 1.-smoothstep(.1,.2, circle);\n    float circleMask2 = smoothstep(.1,.1, circle);\n\n\n    float lava1 = lava(coord,-1.)*circleMask;\n    float lava2 = lava(coord+2.,1.)*circleMask2;\n    float fx = (lava1+lava2);\n    fragColor = vec4(cos((fx-.09)+.79), (cos(fx-.02))-.2, sin(cos(fx-.02))+.1, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml3GDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 142], [144, 144, 169, 169, 237], [239, 239, 285, 285, 643], [646, 646, 700, 700, 1199]]}
{"id": "mt3GDl", "name": "Ancient pyramid at dawn", "author": "mrange", "description": "CC0: Ancient pyramid at dawn\n WIP - Had the intention to expand more on this but stalled.\n Thought better to share it in the state its in than not.\n\n", "tags": ["3d"], "likes": 32, "viewed": 411, "published": 3, "date": "1683308865", "time_retrieved": "2024-07-30T17:57:20.604756", "image_code": "// CC0: Ancient pyramid at dawn\n//  WIP - Had the intention to expand more on this but stalled.\n//  Thought better to share it in the state its in than not.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define ROTY(a)               \\\n  mat3(                       \\\n    +cos(a) , 0.0 , +sin(a) \\\n  , 0.0     , 1.0 , 0.0     \\\n  , -sin(a) , 0.0 , +cos(a) \\\n  )\n\n#define ROTZ(a)               \\\n  mat3(                       \\\n    +cos(a) , +sin(a) , 0.0   \\\n  , -sin(a) , +cos(a) , 0.0   \\\n  , 0.0     , 0.0     , 1.0   \\\n  )\n\n#define ROTX(a)               \\\n  mat3(                       \\\n    1.0 , 0.0     , 0.0       \\\n  , 0.0 , +cos(a) , +sin(a)   \\\n  , 0.0 , -sin(a) , +cos(a)   \\\n  )\n\nconst mat3 roty       = ROTY(radians(10.0));\nconst vec3 sunDir     = normalize(vec3(0.0, -0.01, 1.0))*roty;\nconst vec3 lightPos   = vec3(0.0, -60.0, -200.0)*roty;\nconst float hoff      = 0.725;\nconst vec3 sunColor   = HSV2RGB(vec3(hoff+0.0, 0.9, 0.0005));\nconst vec3 topColor   = HSV2RGB(vec3(hoff+0.0, 0.9, 0.0001));\nconst vec3 glowColor0 = HSV2RGB(vec3(hoff+0.0, 0.9, 0.0001));\nconst vec3 glowColor2 = HSV2RGB(vec3(hoff+0.3, 0.95, 0.001));\nconst vec3 diffColor  = HSV2RGB(vec3(hoff+0.0, 0.9, .25));\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 dim) {\n  return -(dot(ro,dim.xyz)+dim.w)/dot(rd,dim.xyz);\n}\n\nvec2 planeCoord(vec3 p, vec3 c, vec3 up, vec4 dim) {\n  vec3 d = p - c;\n  vec3 xx = (cross(up,dim.xyz));\n  vec3 yy = (cross(xx,dim.xyz));\n  return vec2(dot(d,xx), dot(d,yy));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triIso(vec2 p, vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n  float s = -sign( q.y );\n  vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                vec2( dot(b,b), s*(p.y-q.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal)  {\n  vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n  vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n  vec3 k = abs(m)*boxSize;\n  vec3 t1 = -n - k;\n  vec3 t2 = -n + k;\n  float tN = max( max( t1.x, t1.y ), t1.z );\n  float tF = min( min( t2.x, t2.y ), t2.z );\n  if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n  outNormal = (tN>0.0) ? step(vec3(tN),t1)  : // ro ouside the box\n                         step(t2,vec3(tF))  ;  // ro inside the box\n  outNormal *= -sign(rd);\n  return vec2( tN, tF );\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  col += sunColor/(1.0+0.00001 - dot(sunDir, rd));\n  float hd = max(abs(rd.y+0.15), 0.00066);\n  col += 100.0*glowColor0/sqrt(hd);\n  col += glowColor2/(hd);\n  return col;\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 glow(vec3 ro, vec3 rd) {\n  vec3 bn;\n  vec3 bro = ro;\n  bro.y += -1000.0+70.0;\n  vec2 bi = rayBox(bro, rd, vec3(90.0, 1000.0, 90.0), bn);\n  float lightDist = distance(lightPos, ro);\n  vec3 lightDir   = normalize(lightPos-ro);\n  float g3        = 1.0+0.00001 - dot(lightDir, rd);\n  vec3 col = vec3(0.0);\n  col += 8.0*glowColor0/(g3);\n  vec3 rrd = rd*transpose(roty)*ROTX(0.027);\n  if (bi != vec2(-1.0)) {\n    float bdi = tanh_approx(0.00125*(bi.y-bi.x));\n    col += 1000.0*glowColor0*(bdi/max(rrd.y, 0.005));\n  }\n  \n  float sx = abs(rrd.x);\n  col += 20.0*glowColor0/(abs(mix(20.0*rrd.y*rrd.y, abs(rrd.y), tanh_approx(4.0*sx)))+2.0*sx*sx*sx+0.0001);\n  \n  return col;\n}\n\nvec3 side(vec3 col, vec3 ro, vec3 rd, vec3 nrd, float t, float nt, vec4 dim, vec3 c) {\n  vec3 n = dim.xyz;\n\n  vec3 p = ro + rd*t;\n  vec3 np = ro + nrd*t;\n\n  vec3 r = reflect(rd, n);\n  vec3 ldiff = p - lightPos;\n  vec3 ld = normalize(ldiff);\n  vec3 rcol0 = sky(p, r);\n  float dcol = max(dot(ld, n), 0.0);\n  dcol *= dcol;\n  float aa = distance(p, np);\n  vec2 pp = planeCoord(p, c, vec3(0.0, 1.0, 0.0), dim);\n  vec2 p0 = pp;\n  vec2 p1 = pp;\n  const vec2 tri =vec2(485, sqrt(3.0)*356.0);\n  float d0 = triIso(p0, tri);\n  float d1 = triIso(p1, 0.11*tri);\n  float d = d0;\n  vec3 bcol = col;\n  float hf = smoothstep(-600.0, -400.0, p.y);\n  vec3 pcol = 3.0*diffColor*dcol;  \n  pcol += rcol0;\n  pcol = mix(clamp(col, 0.0, 0.1), pcol, hf); \n  col = mix(col, pcol, smoothstep(aa, 0.0, d));\n  col += topColor/max(0.00005*(d1-1.), 0.000025)*hf;\n  return col;\n}\n\nvec3 pyramid(vec3 col, vec3 ro, vec3 rd, vec3 nrd) {\n  const mat3 rotx = ROTX(radians(-51.8));\n  const mat3 rr0  = rotx;\n  const mat3 rr1  = rr0*ROTY(PI/2.0);\n\n  const vec3 n0   = normalize(vec3(.0, 0.0, 1.0))*rr0;\n  const vec3 c0   = vec3(0.0);\n  const vec4 dim0 = vec4(n0, -dot(c0, n0));\n\n  const vec3 n1   = normalize(vec3(.0, 0.0, 1.0))*rr1;\n  const vec3 c1   = vec3(0.0);\n  const vec4 dim1 = vec4(n1, -dot(c1, n1));\n\n  float t0  = rayPlane(ro, rd , dim0);\n  float nt0 = rayPlane(ro, nrd, dim0);\n  float t1  = rayPlane(ro, rd , dim1);\n  float nt1 = rayPlane(ro, nrd, dim1);\n  if (t1 > 0.0 && nt1 > 0.0) {\n    col = side(col, ro, rd, nrd, t1, nt1, dim1, c1);\n  }\n  if (t0 > 0.0 && nt0 > 0.0) {\n    col = side(col, ro, rd, nrd, t0, nt0, dim0, c0);\n  }\n\n\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  const float rdd = 3.0;\n  const float mm = 4.0;\n  vec2 np = p + 4.0/RESOLUTION.y;\n\n  vec3 rd   = normalize(-p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd  = normalize(-np.x*uu + np.y*vv + rdd*ww);\n  vec3 glowCol = glow(ro, rd);\n  \n  vec3 col = sky(ro, rd); \n  col = pyramid(col, ro, rd, nrd);\n  col += glowCol;  \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  const vec3 ro = vec3(0.0, 0.0, -2700.0)*roty;\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0,1.0,0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = (cross(ww, uu));\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3GDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[430, 430, 452, 452, 598], [1884, 1984, 2003, 2003, 2090], [2092, 2199, 2225, 2225, 2409], [2411, 2411, 2455, 2455, 2508], [2510, 2510, 2562, 2562, 2685], [2687, 2805, 2835, 2835, 3129], [3131, 3223, 3289, 3289, 3843], [3845, 3845, 3873, 3873, 4069], [4071, 4199, 4227, 4293, 4369], [4371, 4371, 4400, 4400, 5041], [5043, 5043, 5129, 5129, 5889], [5891, 5891, 5943, 5943, 6662], [6664, 6664, 6720, 6720, 7042], [7044, 7044, 7074, 7074, 7397], [7399, 7399, 7456, 7456, 7631]]}
{"id": "dt3GDl", "name": "Levels jerry, levels!", "author": "mrange", "description": "CC0: Levels jerry, levels!\nCreated on a bus trip last week (good seats and power outlets).\nFelt a bit meh at the time but looking at it today I felt it good enough to share \n", "tags": ["2d"], "likes": 50, "viewed": 605, "published": 3, "date": "1683308114", "time_retrieved": "2024-07-30T17:57:21.456478", "image_code": "// CC0: Levels jerry, levels!\n// Created on a bus trip last week (good seats and power outlets).\n// Felt a bit meh at the time but looking at it today I felt it good enough to share \n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 layerColor(float n) {\n  return 0.75*(1.0+cos(1.2*vec3(0.0, 1.0, 2.0)+0.2*n-TIME));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat dcross(vec2 p, vec2 b, float r )  {\n  p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n  vec2  q = p - b;\n  float k = max(q.y,q.x);\n  vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n  return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat df(vec2 pp, float n) {\n  float r = 0.0035*(n*n)+0.35;\n  float nn = 4.0;\n  return dcross(pp,r*vec2(2.0, 0.75), 0.3*r)-0.2*r;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float lum = 0.125/max(length(p), 0.1);\n  vec3 col = vec3(0.1, 0.2, 1.0)*lum;\n  \n  p *= ROT(0.1*TIME);\n  \n  float aa = 4.0/RESOLUTION.y;\n  \n  for (float n = 0.0; n < 12.0; ++n) {\n    const float soff = 0.0125;\n    float nn = 4.0;\n    mat2 rot = ROT(0.5*PI*sin(0.25*TIME-0.1*n)*cos(-0.123*TIME+0.123*n));\n    vec2 pp = p;\n    pp *= rot;\n    vec2 sp = p+vec2(0.0, soff);\n    sp *= rot;\n    float dd = df(pp, n);\n    float sdd = df(sp, n);\n    \n    col *= mix(0.333, 1.0, smoothstep(0.0, 0.3, sqrt(max(-sdd+soff, 0.0))));\n    vec3 dcol = layerColor(n);\n    col = mix(col, dcol, smoothstep(0.0, -aa, -dd)); \n  }\n  \n  vec2 cpp = pp-vec2(0.0, 0.25);\n  col -= 0.1*vec3(1.0, 2.0, 3.0).yzx*length(cpp);\n  col *= smoothstep(2.0, 0.5, length(cpp));  \n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3GDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 388, 388, 451], [453, 571, 612, 612, 787], [789, 789, 817, 817, 920], [922, 922, 952, 952, 1728], [1730, 1730, 1787, 1787, 1959]]}
{"id": "mtc3Wl", "name": "Fake trail of bubbles", "author": "mrange", "description": "CC0: Fake trail of bubbles\nWas tinkering with bubble trail earlier\nThis version uses the distance field and how\nquickly it changes to determine the intensity of the trail\nVery fake but looked decent enough to share.\n", "tags": ["2d"], "likes": 22, "viewed": 271, "published": 3, "date": "1683307600", "time_retrieved": "2024-07-30T17:57:22.204479", "image_code": "// CC0: Fake trail of bubbles\n// Was tinkering with bubble trail earlier\n// This version uses the distance field and how\n// quickly it changes to determine the intensity of the trail\n// Very fake but looked decent enough to share.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat df(vec2 p, float tm) {\n  vec2 p0 = p; \n  p0 += 0.71*sin(vec2(1.0, sqrt(0.5))*0.5*tm);\n  p0 *= ROT(-tm*0.5);\n  float d = box(p0, vec2(0.25, 0.01));\n  return d;\n}\n\nvec3 bubbles(vec3 col, vec2 p) {\n  float aa = 4.0/RESOLUTION.y;\n  for (float i = 1.0; i < 10.0; ++i) {\n    float sz = 0.3/(1.0+i);\n    vec2 off = vec2(0.123*i);\n    vec2 pp = p+off;\n    pp /= sz;\n    vec2 rp = round(pp);\n    vec2 cp = pp;\n    cp -= rp;\n    const float delta = .01;\n    float dp = df(rp*sz-off, TIME-delta);\n    float dn = df(rp*sz-off, TIME);\n    float dd = (dn-dp)/delta;\n    float h0 = hash(rp);\n    float h1 = fract(3677.0*h0);\n    float h2 = fract(8677.0*h0);\n    float r  = sqrt(h0)/3.0;\n    r *= tanh(4.0*dd);\n    cp -= (0.5-r)*vec2(h1, h2);\n    float fo = smoothstep(12.0*sz*r, -0.1, dn);\n    float d = (length(cp)-mix(r, 0., fo));\n    d = abs(d);\n    d *= sz;\n    d -= aa*0.75;\n    vec3 bcol = vec3(2.0*sqrt(fo))*smoothstep(0.0, -aa, d)*step(0.0, dd)*smoothstep(-0.05, 0.1, dn);\n    col += bcol;\n  }\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float ds = df(p, TIME);\n  vec3 col = vec3(0.0);\n  col = bubbles(col, p);\n  float aa = 4.0/RESOLUTION.y;\n  col = mix(col, vec3(1.0, 0.0, 0.25), smoothstep(0.0, -aa, ds));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtc3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 470, 491, 491, 561], [563, 681, 708, 708, 784], [786, 786, 814, 814, 952], [954, 954, 986, 986, 1794], [1796, 1796, 1826, 1826, 2033], [2035, 2035, 2092, 2092, 2264]]}
{"id": "DlcGDs", "name": "a SDF for Arches", "author": "FTPlus", "description": "A signed distance function for arches aka circle arcs defined by two points and a height.\nFeel free to use.\n\nI'm trying to make this as compact as possible.\nAny comments about improvements and potential problems or else are welcome! :)\n", "tags": ["sdf", "arch", "circlearc"], "likes": 2, "viewed": 128, "published": 3, "date": "1683301841", "time_retrieved": "2024-07-30T17:57:23.238713", "image_code": "// A signed distance function for arches aka circle arcs\n// by Ferry \"FTPlus\" Timmers\n// with help from iq and ollj\n\nfloat sdfArc(vec2 I, vec2 A, vec2 B, float s)\n{   \n    vec2 v = .5 * (B-A);\n    float p = abs(s),\n          k = dot(v, v),\n          l = sqrt(k) * sign(s),\n          r = .5 * (k / p + p);\n    vec2 n = vec2(-v.y, v.x) / l,\n         C = A + v + n * (r - p);\n    float d = length(C - I);\n    if (dot(n, C - I) * r < (r - p) * d)\n        return sqrt(min(dot(A - I, A - I), dot(B - I, B - I)));\n    return abs(d - r);\n}\n\n\n/* Compacted version:\nfloat sdfArc(vec2 I, vec2 A, vec2 B, float s)\n{   \n    vec2 v=.5*(B-A);float p=abs(s),k=dot(v,v),l=sqrt(k)*sign(s),r=.5*(k/p+p);\n    vec2 n=vec2(-v.y,v.x)/l,C=A+v+n*(r-p);float d=length(C-I);\n    if (dot(n,C-I)*r<(r-p)*d)return sqrt(min(dot(A-I,A-I),dot(B-I,B-I)));\n    return abs(d-r);\n}\n*/\n\n/* Version 1:\nfloat sdfArc(vec2 coords, vec2 A, vec2 B, float s)\n{   \n    vec2 v = (B - A) / 2.;\n    vec2 n = normalize(vec2(A.y - B.y, B.x - A.x)) * sign(s);\n    float r = abs(pow(length(v), 2.) / (2. * s) + (s / 2.));\n    vec2 C = A + v + n * (r - abs(s));\n    if (dot(n, normalize(C - coords)) < dot(n, normalize(C - A)))\n        return min(length(A - coords), length(B - coords));\n    return abs(length(C - coords) - r);\n}\n*/\n\n// We define an arch as two points, and a height (sagitta [1])\n//\n// Let A and B be two points in the 2d space.\n// Let s be a scalar.\n// We can find a circle that passes through both A and B such that:\n// - the distance between the base of the arch and the center of the arch is |s|.\n// - the direction of the arch is sign(s) (i.e. negative mirrors the arch around AB)\n//\n// Let n be the normal vector of the arch: i.e. be perpendicular to AB.\n// Then:\n// The radius of the circle is r = |(AB)^2 / 8s + s/2|\n// The center of the circle is C = A + (B-A)/2 + n * (r - |s|)\n\n/*          _.--\"\"T\"\"--._            +\n         _-`      |      `-_         |\n       .\"         |         \".       |\n     .\"           |           \".     | s \n    /             |             \\    |\n   o . . . . . . .|. . . . . . . o   +\n   A              |              B   \n                  | r\n                  |\n                  o\n                  C\n*/\n\n// Then the field is divided into two parts:\n// 1. Inside the cone CA CB (the circle pie between A and B extended to infinity)\n//    the distance acts a circle i.e. | ||C - X|| - r | for some point X\n// 2. Outside the cone either point A or B is closest, we take the minimum,\n//    i.e. ||A - X|| min ||B - X|| for some point X\n// To check if it is inside the cone we use teh dot product of vectors C-X and C-A\n\n// Sources:\n// [1] https://en.wikipedia.org/wiki/Sagitta_(geometry)\n\n// ------------------------------------------------------------------------------------\n\n// Visualize the field\n\n// Sawtooth function\nfloat ramp(float x)\n{\n    x = abs(x);\n    float y = 0.;\n    for (int i = 1; i < 7; ++i)\n        y += (1. / float(i)) * sin(x * float(i));\n    return y * .5 + .5;\n}\n\n#define BG vec3(.17, .13, .15)\n#define FG (vec3(1.) - BG)\n\nvoid mainImage(out vec4 O, in vec2 I)\n{\n    float w = min(iResolution.x, iResolution.y);\n    I -= iResolution.xy / 2.;\n    \n    float t = iTime + 25.;\n    float tA = t / -5.;\n    float tB = t / -7.;\n    float ts = t / 10.;\n    \n    vec2 A = vec2(cos(tA), sin(tA)) * .4 * w;\n    vec2 B = vec2(cos(tB), sin(tB)) * .2 * w;\n    float s = sin(ts) * .5 * w;\n    \n    if (iMouse.z >= 0.)\n        s = iMouse.y - .5 * w;\n    \n    float d = sdfArc(I, A, B, s) - .04 * w;\n    \n    vec3 color = d >= 0. ? vec3(.4, .9, .3) : vec3(.9, .3, .4);\n    vec3 field = BG + FG * color * ramp(d / 5.);\n    vec3 image = mix(field, FG * vec3(.4, .3, .9), smoothstep(2., 0., abs(d) - 1.));\n    O = vec4(image, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 164, 164, 531], [2807, 2828, 2849, 2849, 2991], [3052, 3052, 3091, 3091, 3742]]}
{"id": "ct3GDs", "name": "output initialization test", "author": "elenzil", "description": "Left to Right: O = v4(0) , O -= O, O *= 0, O = O - O + 0", "tags": ["glsl", "platform"], "likes": 1, "viewed": 139, "published": 3, "date": "1683300777", "time_retrieved": "2024-07-30T17:57:24.210116", "image_code": "void mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec4 c;\n    \n    const float N = 4.0;\n    \n    if (fragCoord.x < iResolution.x * 1.0 / N) {\n        O = vec4(0.0);\n        c = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    else if (fragCoord.x < iResolution.x * 2.0 / N) {\n        O -= O;\n        c = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    else if (fragCoord.x < iResolution.x * 3.0 / N) {\n        O *= 0.0;\n        c = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n    else {\n        O = O - O + 0.0;\n        c = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n    \n    if (fragCoord.y < 20.0) {\n        O = vec4(-0.2);\n    }\n    \n    O += c;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3GDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 610]]}
{"id": "cl3GDl", "name": "Colourful Apollonian III - short", "author": "FabriceNeyret2", "description": "simplifying \"Colourful Apollonian III\" by mla. https://shadertoy.com/view/wdsfWX\n\nmouse control. \nclick back to bottom-left corner for demo mode.", "tags": ["inversion", "apollonian", "short", "golf", "gasket"], "likes": 25, "viewed": 280, "published": 3, "date": "1683294276", "time_retrieved": "2024-07-30T17:57:24.960111", "image_code": "// simplifying \"Colourful Apollonian III\" by mla. https://shadertoy.com/view/wdsfWX\n\n\n\n#define inv   z = (z-t) / dot(z-t,z-t) *s + t\n \n\nvoid mainImage(out vec4 O, vec2 u) {\n\n  vec2 R = iResolution.xy,\n       z = ( u+u - R ) / R.y,\n       t = ( 2.*iMouse.xy - R ) / R.y;\n\n  float N = 3.,                       // Any odd N >= 3 will work\n        a = 3.14/N,\n        D = 1./cos(a),                // Centre distance of outer circles\n        T = tan(a),                   // Radius of outer circles\n        K = D - T,                    // Radius squared of centre circle\n        n = 50., i = 0.,j, s = 1.;\n                                      // --- init setup \n  if ( length(iMouse.xy) > 9. )       // interactive mode:\n      t /= s = dot(t,t),              //   set inversion translation & scaling\n      s = 1./s - 1.;\n   // z = inv( z, t/s, (1.-s)/s );    //   invertto(z,t)\n  else                                // demo mode:\n      z += t = vec2( 0, 1.618*sin(.5*iTime) ), // set inversion translation; scaling = 1\n      z /= dot(z,z);\n   // z = inv( z, t, 1.);\n  inv;\n                                      // --- compute Apollonian\n  for (s = T*T ; i < n && length(z) > K ; i++) { // fractal iterations\n    z *= - K / dot(z,z);              // Imaginary radius\n    for ( j = 0.; j++ < N; )\n      t = D * sin( 6.28*j/N + vec2(0,1.57)),                   \n      length(z-t) < T ? inv, j=n : j; // getcircle(j)      \n  }\n\n  O = sqrt( // i == n ? vec4(0) :     // to sRGB\n            ( .6 + .6 * cos( i  + vec4(0,23,21,0)) )  // hue\n            * ( 1.-length(z)/K ) );   // pseudo-shading\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl3GDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 172, 172, 1591]]}
{"id": "DtcGWl", "name": "Soddy's Mirror", "author": "dr2", "description": "Soddy Circles (or Apollonian Gasket) used to construct multiple varifocal mirrors (mouseable)", "tags": ["reflection", "apollonian", "android", "bumpmap", "gasket", "soddy"], "likes": 37, "viewed": 242, "published": 3, "date": "1683282533", "time_retrieved": "2024-07-30T17:57:25.950463", "image_code": "// \"Soddy's Mirror\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Based on \"Shaded Gasket\"\n\n#define AA  1  // (= 0/1)\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_CIRC  3  // odd value (>= 3)\n\nvec3 limCirc[N_CIRC + 1], invCirc[N_CIRC + 1], sunDir, msOrg;\nvec2 rAngHCs, rAngACs, rAngShCs;\nfloat tCur, dstFar, msDep, mDskRad, frmWid, mirFac;\nint idObj;\nbool isRefl, isSh, oneFace;\nconst int idFrm = 1, idRob = 2, idEye = 3;\nconst int maxIt = 64;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nstruct Mob {\n  vec2 a, b, c, d;\n};\n\nvec2 CMul (vec2 a1, vec2 a2)\n{\n  return vec2 (a1.x * a2.x - a1.y * a2.y, a1.x * a2.y + a1.y * a2.x);\n}\n\nvec2 CConj (vec2 a)\n{\n  return vec2 (a.x, - a.y);\n}\n\nfloat CModSq (vec2 a)\n{\n  return a.x * a.x + a.y * a.y;\n}\n\nvec2 CDiv (vec2 a1, vec2 a2)\n{\n  return CMul (a1, CConj (a2)) / CModSq (a2);\n}\n\nvec2 MobOp (Mob m, vec2 z)\n{\n  return CDiv (CMul (z, m.a) + m.b, CMul (z, m.c) + m.d);\n}\n\nMob MobInv (Mob m)\n{\n  return Mob (m.d, - m.b, - m.c, m.a);\n}\n\nMob MobProd (Mob m1, Mob m2)\n{\n  return Mob (CMul (m1.a, m2.a) + CMul (m1.b, m2.c), CMul (m1.a, m2.b) + CMul (m1.b, m2.d),\n     CMul (m1.c, m2.a) + CMul (m1.d, m2.c), CMul (m1.c, m2.b) + CMul (m1.d, m2.d));\n}\n\nvec3 MobToCirc (Mob m, vec3 c)\n{\n  vec2 z;\n  z = MobOp (m, c.xy - CDiv (vec2 (c.z * c.z, 0.), CConj (c.xy + CDiv (m.d, m.c))));\n  return vec3 (z, length (z - MobOp (m, c.xy + vec2 (c.z, 0.))));\n}\n\nMob CircToMob (vec3 c)\n{\n  Mob m;\n  m = Mob (vec2 (c.z, 0.), c.xy, vec2 (0.), vec2 (1., 0.));\n  return MobProd (MobProd (m, Mob (vec2 (0.), vec2 (1., 0.), vec2 (1., 0.), vec2 (0.))),\n     Mob (m.d, m.b * vec2 (-1., 1.), m.c, m.a));\n}\n\nvoid CircInit ()\n{\n  float a, r, rs;\n  a = pi / float (N_CIRC);\n  r = 1. / cos (a);\n  rs = sqrt (r * r - 1.);\n  for (int j = 0; j < N_CIRC; j ++) {\n    limCirc[j] = vec3 (sin (2. * a * float (j) - vec2 (0.5 * pi, 0.)) * r, rs) * (r - rs);\n    invCirc[j] = vec3 (sin (2. * a * float (j) + vec2 (0.5 * pi, 0.)) * r, rs);\n  }\n  limCirc[N_CIRC] = vec3 (0., 0., 1.);\n  invCirc[N_CIRC] = vec3 (0., 0., r - rs);\n}\n\n#define DDOT(x) dot ((x), (x))\n\nvec4 PCirc (vec2 p, vec2 pm)\n{\n  Mob mm, m;\n  vec3 g, gi, w;\n  vec2 z, cm;\n  float eps;\n  bool done;\n  eps = 1e-9;\n  CircInit ();\n  z = p;\n  mm = Mob (vec2 (1., 0.), vec2 (0.), vec2 (0.), vec2 (1., 0.));\n  if (DDOT (pm) > 0.0005 && DDOT (pm) < 1.) {\n    cm = pm * vec2 (-1., 1.) / DDOT (pm);\n    m = CircToMob (vec3 (cm, sqrt (DDOT (cm) - 1.)));\n    z = MobOp (m, z);\n    mm = MobProd (m, mm);\n  }\n  for (int it = VAR_ZERO; it < maxIt; it ++) {\n    done = true;\n    for (int j = 0; j <= N_CIRC; j ++) {\n      gi = invCirc[j];\n      if (DDOT (z - gi.xy * vec2 (1., -1.)) < gi.z * gi.z) {\n        g = gi;\n        done = false;\n        break;\n      }\n    }\n    if (! done) {\n      if (g.x == 0.) g.x = eps;\n      m = CircToMob (g);\n      z = MobOp (m, z);\n      mm = MobProd (m, mm);\n    } else break;\n  }\n  mm = MobInv (mm);\n  if (CModSq (mm.c) == 0.) mm.c = vec2 (eps, 0.);\n  w.z = 1.;\n  for (int j = 0; j <= N_CIRC; j ++) {\n    g = MobToCirc (mm, limCirc[j]);\n    if (g.z > 0. && g.z < 1.) {\n      w.xy = (p - g.xy) / g.z;\n      w.z = DDOT (w.xy);\n      if (w.z < 1.) break;\n    }\n  }\n  return vec4 (w, g.z);\n}\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, szFac;\n  p.xz = vec2 (- p.z, p.x);\n  szFac = 0.2;\n  p /= szFac;\n  dMin /= szFac;\n  p.yz = Rot2Cs (p.yz, rAngShCs);\n  q = p; \n  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q.y -= -0.08;\n  d = min (d, PrCylDf (q.xzy, 0.75, 0.1));\n  q = p;\n  q.y -= 1.55;\n  d = min (d, PrRoundCylDf (q.xzy, 0.62, 0.28, 0.42));\n  q = p;  \n  q.xz = Rot2Cs (q.xz, rAngHCs);\n  q.x = abs (q.x) - 0.3;\n  q.y -= 3.1;\n  q.xy = Rot2Cs (q.xy, CosSin (0.2 * pi));\n  q.y -= 0.25;\n  d = min (d, PrRoundCylDf (q.xzy, 0.02, 0.04, 0.26));\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (1.05, 2.1);\n  q.yz = Rot2Cs (q.yz, rAngACs);\n  q.y -= -0.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.05, 0.15, 0.45));\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.4, 0.475);\n  d = min (d, PrRoundCylDf (q.xzy, 0.1, 0.15, 0.4));\n  DMIN (idRob);\n  q = p;\n  q.xz = Rot2Cs (q.xz, rAngHCs);\n  q.x = abs (q.x);\n  q -= vec3 (0.4, 2.7, 0.6);\n  d = PrSphDf (q, 0.15);\n  DMIN (idEye);\n  return szFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r;\n  dMin = dstFar;\n  q = p;\n  q.y -= msOrg.y;\n  r = length (q.xy) - mDskRad;\n  if (! isRefl) {\n    d = max (abs (r - frmWid) - frmWid, abs (q.z) - msDep);\n    DMIN (idFrm);\n    q = p;\n    q.y -= 0.2 * frmWid;\n    d = PrRndBoxDf (q, vec3 (0.5, 0.2 * frmWid, msDep), 0.01);\n    DMIN (idFrm);\n  }\n  if (isSh && ! oneFace) {\n    d = max (r, abs (q.z) - 0.1);\n    DMIN (idFrm);\n  }\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (13. * ((length (q.xz) > 0.) ? atan (q.z, - q.x) /\n     (2. * pi) : 0.)) + 0.5) / 13.);\n  q.x += 1.5;\n  dMin = RobDf (q, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  isSh = true;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += max (h, 0.02);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  isSh = false;\n  return 0.6 + 0.4 * sh;\n}\n\nfloat CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s;\n  float dMin, d, a, b, w, srdz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cylRad * cylRad);\n  if (w > 0.) {\n    srdz = sign (rd.z);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.z = cylLen;\n    } else s.z = cylLen;\n    if (abs (s.z) < cylLen) {\n      dMin = d;\n    } else if (srdz * ro.z < - cylLen) {\n      d = - (srdz * ro.z + cylLen) / abs (rd.z);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xy) < cylRad) {\n          dMin = d;\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w, e;\n  float sd, f;\n  e = vec2 (0.01, 0.);\n  if (rd.y == 0.) rd.y = 1e-3;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * (1. - rd.y) +\n       0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.);\n    f = Fbm2 (0.02 * (ro.xz + rd.xz * (100. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.2 + 1.6 * f * rd.y, 0., 1.));\n  } else {\n    ro -= (ro.y / rd.y) * rd;\n    w = 4. * ro.xz;\n    f = Fbm2 (w);\n    col = mix (vec3 (0.3, 0.4, 0.1), vec3 (0.4, 0.5, 0.2), 2. * f) * (1. - 0.1 * Noisefv2 (w));\n    vn = normalize (vec3 (f - vec2 (Fbm2 (w + e.xy), Fbm2 (w + e.yx)), 0.05)).xzy;\n    col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.45, 0.55, 0.7), pow (1. + rd.y, 64.));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 p4;\n  vec3 col, vn;\n  vec2 p;\n  float dstObj, dstMir, sh, nDotL, sz;\n  bool needSh;\n  dstMir = CylHit (ro - msOrg, rd, mDskRad, 0.9 * msDep);\n  isRefl = false;\n  isSh = false;\n  sz = sign (rd.z);\n  for (int k = 0; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k == 0 && (dstMir < min (dstObj, dstFar) && (! oneFace || sz > 0.))) {\n      ro += dstMir * rd;\n      p = (ro.xy - msOrg.xy) / mDskRad;\n      p4 = PCirc (vec2 (- p.y, p.x), vec2 (0.));\n      p = mirFac * p4.xy;\n      vn = sz * vec3 (vec2 (- p.y, p.x), sqrt (1. - dot (p, p)));\n      rd = reflect (rd, vn);\n      ro += 0.001 * rd;\n      isRefl = true;\n    } else break;\n  }\n  needSh = false;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idFrm) {\n      vn = VaryNf (128. * ro, vn, 1.);\n      col = vec3 (0.6, 0.6, 0.7);\n    } else if (idObj == idRob) {\n      col = HsvToRgb (vec3 (fract (floor (13. * (atan (ro.z, - ro.x) / (2. * pi))) / 13. +\n         0.25), 0.8, 1.));\n    } else if (idObj == idEye) {\n      col = vec3 (1., 1., 0.8);\n    }\n    nDotL = max (dot (vn, sunDir), 0.);\n    needSh = true;\n  } else {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) {\n      ro -= (ro.y / rd.y) * rd;\n      isRefl = false;\n      vn = vec3 (0., 1., 0.);\n      needSh = true;\n    }\n  }\n  sh = (needSh) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n  if (dstObj < dstFar) col *= (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n     0.8 * sh * nDotL * nDotL);\n  else if (rd.y < 0.) col *= sh;\n  if (isRefl) col = mix (col, HsvToRgb (vec3 (fract (0.75 - 0.9 * log2 (p4.w) /\n     log2 (float (maxIt))), 1., 1.)), 0.1 * smoothstep (0., 0.05, abs (mirFac)));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, sr, t, rAngA;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    t = 0.05 * tCur;\n    az = 0.15 * pi * SmoothBump (0.25, 0.75, 0.2, fract (t)) * sign (mod (t, 2.) - 1.);\n  }\n  el = clamp (el, -0.3 * pi, 0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  oneFace = false;\n  t = 0.06 * tCur;\n  mirFac = 0.7 * SmoothBump (0.25, 0.75, 0.22, fract (t)) * sign (mod (t, 2.) - 1.);\n  t = mod (0.3 * tCur, 1.);\n  rAngHCs = CosSin (0.2 * pi * sin (2. * pi * t));\n  rAngA = 2. * pi * (0.5 - abs (t - 0.5));\n  rAngACs = CosSin (rAngA);\n  rAngShCs = CosSin (0.1 * (rAngA - 0.5 * pi));\n  mDskRad = 1.;\n  frmWid = 0.02;\n  msDep = 0.1;\n  msOrg = vec3 (0., mDskRad + frmWid, 0.);\n  zmFac = 4.;\n  ro = vuMat * vec3 (0., 0.6 * msOrg.y, -7.);\n  sunDir = normalize (vec3 (-1., 2., -1.));\n  dstFar = 50.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRndBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtcGWl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1140, 1140, 1170, 1170, 1242], [1244, 1244, 1265, 1265, 1295], [1297, 1297, 1320, 1320, 1354], [1356, 1356, 1386, 1386, 1434], [1436, 1436, 1464, 1464, 1524], [1526, 1526, 1546, 1546, 1587], [1589, 1589, 1619, 1619, 1797], [1799, 1799, 1831, 1831, 1994], [1996, 1996, 2020, 2020, 2229], [2231, 2231, 2249, 2249, 2637], [2671, 2671, 2701, 2701, 3781], [3783, 3783, 3817, 3817, 4790], [4792, 4792, 4814, 4814, 5412], [5414, 5414, 5447, 5447, 5630], [5632, 5632, 5653, 5653, 5910], [5912, 5912, 5949, 5949, 6235], [6237, 6237, 6298, 6298, 6948], [6950, 6950, 6981, 6981, 7791], [7793, 7793, 7828, 7828, 9528], [9530, 9530, 9586, 9586, 11137], [11139, 11139, 11183, 11183, 11230], [11232, 11232, 11265, 11265, 11292], [11294, 11294, 11336, 11336, 11387], [11389, 11389, 11446, 11446, 11522], [11524, 11524, 11581, 11581, 11664], [11666, 11666, 11690, 11690, 11812], [11814, 11814, 11844, 11844, 11957], [11959, 11959, 11990, 11990, 12054], [12056, 12056, 12092, 12092, 12298], [12332, 12332, 12356, 12356, 12468], [12470, 12470, 12495, 12495, 12681], [12683, 12683, 12704, 12704, 12859], [12861, 12861, 12890, 12890, 13102], [13104, 13104, 13143, 13143, 13395]]}
{"id": "dld3Df", "name": "camera - tracking", "author": "tianluo97", "description": "camera - tracking", "tags": ["cameratracking"], "likes": 1, "viewed": 136, "published": 3, "date": "1683279775", "time_retrieved": "2024-07-30T17:57:26.953780", "image_code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float divisionLine;\n    //divisionLine = 0.5;\n    float d = cubicPulse(divisionLine,0.14,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //混合遮罩\n    //maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.08; \n    float scale = 1.3;\n    \n    vec4 vcolor0 = vec4(0.259,0.482,1.000,1.0);\n    vec4 vcolor1 = vec4(0.278,0.471,1.000,1.0);\n    vec4 vcolor2 = vec4(0.459,0.604,1.000,1.0);\n    \n    float step0 = 0.1 * scale;\n    float step1 = 0.4 * scale;\n    float step2 = 0.6 * scale;\n    float step3 = 0.65  * scale;\n    float step4 = 0.85  * scale;\n    \n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor; \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    //darkColor = correct(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor0,dist2);\n    //darkColor = correct(vcolor2, vcolor3, dist2);\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //darkColorMask\n    float darkMaskd = cubicPulse(divisionLine,0.24,uv.x);\n    vec3 darkMaskColor = vec3(darkMaskd);\n    float darkMaskpct = plot(uv,darkMaskd);\n \n    vec3 darkColorMask = darkMaskColor+darkMaskpct*vec3(0.0,1.0,0.0);\n    \n    darkColor = mix(darkColor,vec4(0.361,0.639,1.000,1.),darkColorMask.r);\n    \n    //浅色色板\n    float qscale = .25;\n    float qtime = iTime* 0.0;\n    \n    float qstep0 = 0.15 * qscale;\n    float qstep1 = 0.25 * qscale;\n    float qstep2 = 0.45 * qscale;\n    float qstep3 = 0.65 * qscale;\n    \n    vec4 qcolor0 = vec4(1.000,0.851,0.702,1.0);\n    \n    vec4 qcolor1 = vec4(1.000,0.596,0.380,1.0);\n    \n    vec4 qcolor2 = vec4(1.000,0.545,0.302,1.0);\n  \n    vec4 qcolor3 = vec4(1.000,0.557,0.322,1.0);\n\n    vec4 qcolor4 = vec4(1.000,0.749,0.502,1.0);\n    \n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x-qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    //lightColor = vec4(dist0);\n    //lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    //蓝到橙色\n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    //橙色到黄色\n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    //lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    //黄色到白色\n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    //lightColor = vec4(dist3);\n    //lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    //lightColor = vec4(1.0);\n    \n    //通过混合遮罩进行混合\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //ending mask mask\n    float endMask = smoothstep(0.62,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    //fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dld3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 189], [191, 191, 237, 237, 331], [333, 333, 364, 364, 455], [457, 457, 500, 500, 943], [945, 945, 999, 999, 1021], [1023, 1023, 1075, 1075, 1142], [1144, 1144, 1168, 1168, 1198], [1200, 1200, 1223, 1223, 1546], [1548, 1636, 1739, 1739, 4277], [4279, 4279, 4336, 4374, 8950]]}
{"id": "mtd3Df", "name": "test009", "author": "yym28088", "description": "error", "tags": ["test"], "likes": 0, "viewed": 102, "published": 3, "date": "1683279771", "time_retrieved": "2024-07-30T17:57:27.763615", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtd3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "dtt3WX", "name": "base64", "author": "kig", "description": "Base64 encode and decode in a shader? Why???\n\nBuffers A and B do sorta kinda contiguous packing & unpacking. The Image buffer does a RGB->RGBA hack.\n\nYou could use Buffer A for fast (30 GB/s) data URI creation. Need to add last-three-bytes handling tho.", "tags": ["hack", "compute", "base64"], "likes": 1, "viewed": 196, "published": 3, "date": "1683266820", "time_retrieved": "2024-07-30T17:57:28.515604", "image_code": "int enc(int c) {\n    int off = 65;\n    if (c > 25) off = 71;\n    if (c > 51) off = -4;\n    if (c == 62) off = 43 - c;\n    if (c == 63) off = 47 - c;\n    return c + off;\n}\n\nint dec(int c) {\n    int off = 65;\n    if (c > 96) off = 71;\n    if (c < 58) off = -4;\n    if (c == 43) off = c - 62;\n    if (c == 47) off = c - 63;\n    if (c == 61) off = c;\n    return c - off;\n}\n\nivec4 base64_encode(ivec3 triplet) {\n    return ivec4(\n        enc(triplet.x >> 2),\n        enc(((triplet.x & 3) << 4) | (triplet.y >> 4)),\n        enc(((triplet.y & 15) << 2) | (triplet.z >> 6)),\n        enc(triplet.z & 63)\n    );\n}\n\nivec4 base64_encode(ivec2 triplet) {\n    return ivec4(\n        enc(triplet.x >> 2),\n        enc(((triplet.x & 3) << 4) | (triplet.y >> 4)),\n        enc(((triplet.y & 15) << 2)),\n        61\n   );\n}\n\nivec4 base64_encode(int triplet) {\n    return ivec4(\n        enc(triplet >> 2),\n        enc((triplet & 3) << 4),\n        61,\n        61\n   );\n}\n\n\nivec3 base64_decode(ivec4 quad) {\n    quad = ivec4(\n        dec(quad.x),\n        dec(quad.y),\n        dec(quad.z),\n        dec(quad.w)\n    );\n    return ivec3(\n        (quad.x << 2) | (quad.y >> 6),\n        ((quad.y << 4) | (quad.z >> 2)) & 0xff,\n        ((quad.z << 6) | quad.w) & 0xff\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec3 triplet = ivec3(255.0 * texelFetch(iChannel0, ivec2(fragCoord), 0).rgb);\n    ivec4 encoded = base64_encode(triplet);\n\n    // Output to screen\n    if (fragCoord.x > iResolution.x * (0.75 + 0.25*sin(iTime))) fragColor = vec4(triplet, 255.0) / 255.0;\n    if (fragCoord.x < iResolution.x * (0.75 + 0.25*sin(iTime))) fragColor = vec4(base64_decode(encoded), 255.0) / 255.0;\n    if (fragCoord.x < iResolution.x * (0.5 + 0.25*sin(iTime))) fragColor = vec4(encoded) / 255.0;\n    if (fragCoord.x < iResolution.x * (0.25 + 0.25*sin(iTime))) fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0) / 255.0;\n    if (abs(fragCoord.x - iResolution.x * (0.25 + 0.25*sin(iTime))) < 2.0) fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    if (abs(fragCoord.x - iResolution.x * (0.5 + 0.25*sin(iTime))) < 2.0) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    if (abs(fragCoord.x - iResolution.x * (0.75 + 0.25*sin(iTime))) < 2.0) fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// How fast is it?\n// Set this to 500 or something and calculate:\n// BENCHMARK_ITERATIONS * width * height * 4 * fps / 1e9 = gigabytes per second\n//\n// On an M2 Macbook Air, around 30 GB/s encode.\n// (YMMV with real data, especially if you need to truck the data over the PCIe bus.)\n//\n// A proper compute shader implementation should be a bit faster still.\n//\n// For comparison, Chrome's btoa runs at about 500-600 MB/s.\n// I got a JavaScript implementation to run at about 300 MB/s.\n//\n// I don't know who needs a memory-speed btoa but there you have it.\n//\n#define BENCHMARK_ITERATIONS 0\n\n\nint enc(int c) {\n    int off = 65;\n    if (c > 25) off = 71;\n    if (c > 51) off = -4;\n    if (c == 62) off = 43 - c;\n    if (c == 63) off = 47 - c;\n    return c + off;\n}\n\nivec4 base64_encode(ivec3 triplet) {\n    return ivec4(\n        enc(triplet.x >> 2),\n        enc(((triplet.x & 3) << 4) | (triplet.y >> 4)),\n        enc(((triplet.y & 15) << 2) | (triplet.z >> 6)),\n        enc(triplet.z & 63)\n    );\n}\n\nivec2 quadIndexToTexCoord(int quadIndex, int width) {\n    return ivec2(quadIndex % width, quadIndex / width);\n}\n\nvec4 readVec4(int byteIndex, int width) {\n    int quadIndex = byteIndex / 4;\n    ivec2 texCoord1 = quadIndexToTexCoord(quadIndex, width);\n    ivec2 texCoord2 = quadIndexToTexCoord(quadIndex + 1, width);\n    vec4 quad1 = texelFetch(iChannel0, texCoord1, 0);\n    vec4 quad2 = texelFetch(iChannel0, texCoord2, 0);\n    vec4 result = quad1;\n    int byteOffset = byteIndex % 4;\n    if (byteOffset == 1) result = vec4(quad1.yzw, quad2.x);\n    if (byteOffset == 2) result = vec4(quad1.zw, quad2.xy);\n    if (byteOffset == 3) result = vec4(quad1.w, quad2.xyz);\n    return result;\n}\n\nivec4 base64EncodeTexture(in vec2 fragCoord) {\n    // Fetch the triplet of bytes corresponding to the current pixel and encode it into a quad.\n    int w = int(iChannelResolution[0].x);\n    int h = int(iChannelResolution[0].y);\n    int byteIndex = ((int(fragCoord.y) * int(iResolution.x) + int(fragCoord.x)) * 3) % (w * h * 4);\n    ivec3 triplet = ivec3(readVec4(byteIndex, w).xyz * 255.0);\n    return base64_encode(triplet);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(base64EncodeTexture(fragCoord));\n    for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {\n      fragColor += vec4(base64EncodeTexture(fragCoord + vec2(float(i*37), float(i*17))));\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// How fast is it?\n// Set this to 500 or something and calculate:\n// BENCHMARK_ITERATIONS * width * height * 4 * fps / 1e9 = gigabytes per second\n//\n// On an M2 Macbook Air, around 30 GB/s decode.\n// (YMMV with real data, especially if you need to truck the data over the PCIe bus.)\n//\n// A proper compute shader implementation should be a bit faster still.\n//\n// For comparison, Chrome's atob runs at about 700 MB/s.\n//\n// I don't know who needs a memory-speed atob either, but there you have it.\n//\n#define BENCHMARK_ITERATIONS 0\n\nint dec(int c) {\n    int off = 65;\n    if (c > 96) off = 71;\n    if (c < 58) off = -4;\n    if (c == 43) off = c - 62;\n    if (c == 47) off = c - 63;\n    if (c == 61) off = c;\n    return c - off;\n}\n\nivec3 base64_decode(ivec4 quad) {\n    quad = ivec4(\n        dec(quad.x),\n        dec(quad.y),\n        dec(quad.z),\n        dec(quad.w)\n    );\n    return ivec3(\n        (quad.x << 2) | (quad.y >> 6),\n        ((quad.y << 4) | (quad.z >> 2)) & 0xff,\n        ((quad.z << 6) | quad.w) & 0xff\n    );\n}\n\nivec2 quadIndexToTexCoord(int quadIndex, int width) {\n    return ivec2(quadIndex % width, quadIndex / width);\n}\n\nvec4 readVec4(int byteIndex, int width) {\n    int quadIndex = byteIndex / 4;\n    ivec2 texCoord1 = quadIndexToTexCoord(quadIndex, width);\n    ivec2 texCoord2 = quadIndexToTexCoord(quadIndex + 1, width);\n    vec4 quad1 = texelFetch(iChannel0, texCoord1, 0);\n    vec4 quad2 = texelFetch(iChannel0, texCoord2, 0);\n    vec4 result = quad1;\n    int byteOffset = byteIndex % 4;\n    if (byteOffset == 1) result = vec4(quad1.yzw, quad2.x);\n    if (byteOffset == 2) result = vec4(quad1.zw, quad2.xy);\n    if (byteOffset == 3) result = vec4(quad1.w, quad2.xyz);\n    return result;\n}\n\nivec4 base64DecodeTexture(in vec2 fragCoord, int width) {\n    // Convert the fragCoord to the byte index in the decoded string.\n    // Convert the decoded byte index to the encoded byte index for the triplet.\n    //\n    // byteIndex 8.\n    //            V\n    // [AAAB|BBCC|CDDD]\n    //\n    // encoded 12 . = (byteIndex / 3) * 4 = tripletByteIndex\n    //            V\n    // [aaaa|bbbb|cccc|dddd]\n    //\n    // Grab the two triplets from encoded.\n    //\n    // [cccc|dddd] = tripletByteIndex, tripletByteIndex + 4\n    //\n    // Decode the encoded triplets.\n    //\n    // [CCC|DDD]\n    //\n    // Extract the wanted bytes.\n    //     V = byteIndex % 3 = 8 % 3 = 2\n    // [CC|CDDD] \n\n    int byteIndex = (int(fragCoord.y) * width + int(fragCoord.x)) * 4;\n    int tripletByteIndex = (byteIndex / 3) * 4;\n\n    int w = int(iChannelResolution[0].x);\n\n    ivec4 encodedTriplet1 = ivec4(readVec4(tripletByteIndex, w));\n    ivec4 encodedTriplet2 = ivec4(readVec4(tripletByteIndex + 4, w));\n\n    ivec3 triplet1 = base64_decode(encodedTriplet1);\n    ivec3 triplet2 = base64_decode(encodedTriplet2);\n\n    int byteOffset = byteIndex % 3;\n\n    ivec4 quad = ivec4(triplet1.xyz, triplet2.x);\n    if (byteOffset == 1) quad = ivec4(triplet1.yz, triplet2.xy);\n    if (byteOffset == 2) quad = ivec4(triplet1.z, triplet2.xyz);\n\n    return quad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(base64DecodeTexture(fragCoord, 512)) / 255.0;\n    for (int i = 0; i < BENCHMARK_ITERATIONS; i++) {\n      fragColor += vec4(base64DecodeTexture(fragCoord + vec2(float(i*37), float(i*17)), 512));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtt3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 170], [172, 172, 188, 188, 368], [370, 370, 406, 406, 603], [605, 605, 641, 641, 801], [803, 803, 837, 837, 946], [949, 949, 982, 982, 1244], [1245, 1245, 1302, 1302, 2247]]}
{"id": "dldGWX", "name": "B/W logarithmic circles", "author": "mrange", "description": "CC0: B/W logarithmic circles\n Inspired by this tweet: https://twitter.com/concinnus/status/1654244526297583616?s=20\n Not an exact copy but good enough for a quick morning hack\n", "tags": ["2d"], "likes": 19, "viewed": 291, "published": 3, "date": "1683265726", "time_retrieved": "2024-07-30T17:57:29.348378", "image_code": "// CC0: B/W logarithmic circles\n//  Inspired by this tweet: https://twitter.com/concinnus/status/1654244526297583616?s=20\n//  Not an exact copy but good enough for a quick morning hack\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(2.24);\n\nfloat forward(float l) {\n  return exp2(ExpBy*l);\n}\n\nfloat reverse(float l) {\n  return log2(l)/ExpBy;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec3 effect(vec2 p) {\n  float aa = 4.0/RESOLUTION.y;\n  float ltm = 0.75*TIME;\n  mat2 rot0 = ROT(-0.5*ltm); \n  float mtm = fract(ltm);\n  float ntm = floor(ltm);\n  float zz = forward(mtm);\n\n  vec2 p0 = p;\n  p0 *= rot0;\n  p0 /= zz;\n\n  float l0 = length(p0);\n  \n  float n0 = ceil(reverse(l0));\n  float r0 = forward(n0);\n  float r1 = forward(n0-1.0);\n  float r = (r0+r1)/2.0;\n  float w = r0-r1;\n  float nn = n0;\n  n0 -= ntm;\n  vec2 p1 = p0;\n  p1 *= ROT(3.0*n0*TAU/16.0);\n  float n1 = modPolar(p1, 8.0);\n  p1.x -= r;\n\n  float a = 0.5*ltm+n1/8.0;\n  a = fract(a);\n  float d1 = length(p1)-0.5*w;\n  float d2 = length(p1)-0.5*w*smoothstep(0.0, 0.45, mod(a, 0.5));\n  d1 *= zz;\n  d2 *= zz;\n  vec3 col = vec3(0.2*smoothstep(-sqrt(0.5), sqrt(0.5), sin(0.5*TAU*p.y/aa)));\n  vec3 ccol = vec3(1.0)*smoothstep(0.0, -aa, d2);\n  if (a >= 0.5) ccol = 1.0-ccol;\n  col = mix(col, ccol, smoothstep(0.0, -aa, d1));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dldGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[397, 397, 421, 421, 447], [449, 449, 473, 473, 499], [501, 501, 550, 550, 949], [951, 951, 972, 972, 1874], [1876, 1876, 1933, 1933, 2089]]}
{"id": "DldGDf", "name": "camera - no more 变量", "author": "tianluo97", "description": "camera - no more 变量", "tags": ["cameranomore"], "likes": 0, "viewed": 105, "published": 3, "date": "1683255259", "time_retrieved": "2024-07-30T17:57:30.166191", "image_code": "const vec2 target_resolution = vec2(940, 86);\n\nvec4 correct(vec4 col1, vec4 col2, float p)\n{\n \tvec4 temp = col1 * col1;\n    vec4 temp2 = col2 * col2;\n    return sqrt(mix(temp, temp2, p));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nmat4 saturationMatrix( float saturation ) {\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    float oneMinusSat = 1.0 - saturation;\n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red.r += saturation;\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green.g += saturation;\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue.b += saturation;\n    \n    return mat4( \n        red,     0,\n        green,   0,\n        blue,    0,\n        0, 0, 0, 1 );\n}\n\nvoid brightnessAdjust( inout vec4 color, in float b) {\n    color.rgb += b;\n}\n\nvoid contrastAdjust( inout vec4 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\tconst int BIT_COUNT = 32;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a >>= 1;\n        b >>= 1;\n        n <<= 1;\n\n        if (!(a > 0 && b > 0))\n            break;\n    }\n    return result;\n}\n\n// forked from https://www.shadertoy.com/view/llGSzK\n// performance optimized by Ruofei\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = dot(inCol.rgb, vec3(0.3, 0.6, 0.1));\n        outCol.rgb = mix(vec3(avg), inCol.rgb, vibrance); \n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol.r, inCol.g), inCol.b);\n        _max = max(max(inCol.r, inCol.g), inCol.b);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = step(_max, 0.0);\n        s = (dlt / _max) * (1.0 - br1);\n        h = -1.0 * br1;\n\n\t\tbr2 = 1.0 - step(_max - inCol.r, 0.0); \n        br2_or_br1 = max(br2, br1);\n        h = ((inCol.g - inCol.b) / dlt) * (1.0 - br2_or_br1) + (h*br2_or_br1);\n\n\t\tbr3 = 1.0 - step(_max - inCol.g, 0.0); \n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol.b - inCol.r) / dlt) * (1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol.r - inCol.g) / dlt) * (1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        // Reduce the enhancements on skin tones.    \n        a = step(1.0, hue_a) * a * (hue_a * 0.67 + 0.33) + step(hue_a, 1.0) * a;                                    \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a * pow(s, 0.25);\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol.rgb = vec3(0.0); \n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p3, p1);\n \n        a = float(and(use , 1)); // i == 1;\n        use >>= 1;\n        inCol.rgb += a * vec3(p2, v, p1); \n\n        a = float( and(use,1)); // i == 2;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, v, p3);\n\n        a = float(and(use, 1)); // i == 3;\n        use >>= 1;\n        inCol.rgb += a * vec3(p1, p2, v);\n\n        a = float(and(use, 1)); // i == 4;\n        use >>= 1;\n        inCol.rgb += a * vec3(p3, p1, v);\n\n        a = float(and(use, 1)); // i == 5;\n        use >>= 1;\n        inCol.rgb += a * vec3(v, p1, p2);\n\n        outCol = inCol;\n    }\n    return outCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Same texCoord as in Minecraft\n    vec2 texCoord = fragCoord/iResolution.xy;\n    // Own uv variable\n    vec2 uv = texCoord;\n    \n    // Center origin around screen center (range -0.5, 0.5)\n    uv -= .5;\n    \n    // Squish image in excessive dimension\n    float r = (iResolution.x/iResolution.y) / (target_resolution.x/target_resolution.y);\n    if (r >= 1.) uv.x *= r;\n    else uv.y /= r;\n    \n    // Recenter origin to start at 0 (range 0.0, 1.0)\n    uv += .5;\n    uv.y -= 0.5/r - 0.5;    \n    \n    float divisionLine;\n    float d = cubicPulse(divisionLine,0.14,uv.x);\n    vec3 maskColor = vec3(d);\n    float pct = plot(uv,d);\n    \n    //混合遮罩\n    maskColor = (1.0-pct)*maskColor+pct*vec3(0.0,1.0,0.0);\n    //maskColor = maskColor+pct*vec3(0.0,1.0,0.0);\n    \n    //深色色板\n    float PI = 3.1415926;\n    float time = iTime * 0.08; \n    float scale = 1.3;\n    \n    vec4 vcolor0 = vec4(0.259,0.482,1.000,1.0);\n    vec4 vcolor1 = vec4(0.278,0.471,1.000,1.0);\n    vec4 vcolor2 = vec4(0.561,0.678,1.000,1.0);\n    vec4 vcolor3 = vec4(1.000,0.612,0.400,1.0);\n    vec4 vcolor4 = vec4(1.000,0.788,0.580,1.0);\n    \n    float step0 = 0.1 * scale;\n    float step1 = 0.4 * scale;\n    float step2 = 0.6 * scale;\n    float step3 = 0.65  * scale;\n    float step4 = 0.85  * scale;\n    \n    float offset = uv.x - time;\n    float y = mod(offset,scale);\n    \n    vec4 darkColor; \n    if (y < step0) {\n    float dist0 = smoothstep(0.0, step0, y);\n    darkColor = mix(vcolor0, vcolor1, dist0);\n    darkColor = correct(vcolor0, vcolor1, dist0);\n    }\n    \n    if (y > step0 && y < step1) {\n    float dist1 = smoothstep(step0, step1, y);\n    darkColor = mix(vcolor1, vcolor2, dist1);\n    //darkColor = correct(vcolor1, vcolor2, dist1);\n    }\n    \n    else if (y > step1 && y < step2) {\n    float dist2 = smoothstep(step1, step2, y);\n    darkColor = mix(vcolor2, vcolor3, dist2);\n    //darkColor = correct(vcolor2, vcolor3, dist2);\n    }\n    \n    else if (y > step2 && y < step3) {\n    float dist02 = smoothstep(step2, step3, y);\n    darkColor = mix(vcolor3, vcolor4, dist02);\n    darkColor = correct(vcolor3, vcolor4, dist02);\n    }\n    \n    else if (y > step3 && y < step4){\n    float dist3 = smoothstep(step3, step4, y);\n    darkColor = mix(vcolor4, vcolor0, dist3);\n    //darkColor = correct(vcolor4, vcolor0, dist3);\n    }\n    \n    else if(y>step4){\n    float dist3 = smoothstep(step3, step4, y);\n    darkColor = vcolor0;\n    }\n    \n    darkColor = sqrt(darkColor);\n    \n    //darkColorMask\n    float darkMaskd = cubicPulse(divisionLine,0.24,uv.x);\n    vec3 darkMaskColor = vec3(darkMaskd);\n    float darkMaskpct = plot(uv,darkMaskd);\n \n    vec3 darkColorMask = darkMaskColor+darkMaskpct*vec3(0.0,1.0,0.0);\n    \n    darkColor = mix(darkColor,vec4(0.361,0.639,1.000,1.),darkColorMask.r);\n    \n    //浅色色板\n    float qscale = 0.25;\n    float qtime = iTime* 0.015;\n    \n    float qstep0 = 0.15 * qscale;\n    float qstep1 = 0.35 * qscale;\n    float qstep2 = 0.45 * qscale;\n    float qstep3 = 0.65 * qscale;\n    \n    vec4 qcolor0 = vec4(0.722,0.804,1.000,1.0);\n    \n    vec4 qcolor1 = vec4(0.722,0.804,1.000,1.0);\n    \n    vec4 qcolor2 = vec4(1.000,0.663,0.522,1.0);\n  \n    vec4 qcolor3 = vec4(1.000,0.820,0.702,1.0);\n\n    vec4 qcolor4 = vec4(1.000,1.000,1.000,1.0);\n    \n    float brightness4 = 0.15;\n\tfloat contrast4 = 1.0;\n    float saturation4 = 1.;\n    qcolor4 = saturationMatrix(saturation4) * qcolor4; \n    brightnessAdjust(qcolor4, brightness4); \n    contrastAdjust(qcolor4, contrast4); \n    \n    float qoffset = uv.x-qtime;\n    float qy = mod(qoffset,qscale);\n    \n    vec4 lightColor; \n    if (qy < qstep0) {\n    float dist0 = smoothstep(0.0, qstep0, qy);\n    //lightColor = vec4(dist0);\n    //lightColor = mix(qcolor0, qcolor1, dist0);\n    lightColor = correct(qcolor0, qcolor1, dist0);\n    }\n    \n    if (qy > qstep0 && qy < qstep1) {\n    float dist1 = smoothstep(qstep0, qstep1, qy);\n    //lightColor = vec4(dist1);\n    //lightColor = mix(qcolor1, qcolor2, dist1);\n    lightColor = correct(qcolor1, qcolor2, dist1);\n    }\n    \n    //蓝到橙色\n    else if (qy > qstep1 && qy < qstep2) {\n    float dist2 = smoothstep(qstep1, qstep2, qy);\n    //lightColor = mix(qcolor2, qcolor3, dist2);\n    lightColor = correct(qcolor2, qcolor3, dist2);\n    }\n    \n    //橙色到黄色\n    else if (qy > qstep2 && qy < qstep3) {\n    float dist02 = smoothstep(qstep2, qstep3, qy);\n    //lightColor = vec4(dist02);\n    //lightColor = mix(qcolor3, qcolor4, dist02);\n    lightColor = correct(qcolor3, qcolor4, dist02);\n    }\n    \n    //黄色到白色\n    else if (qy > qstep3){\n    float dist3 = smoothstep(qstep3, 1.0 * qscale, qy);\n    //lightColor = vec4(dist3);\n    //lightColor = mix(qcolor4, qcolor0, dist3);\n    lightColor = correct(qcolor4, qcolor0, dist3);\n    }\n    \n    lightColor = sqrt(lightColor);\n    //lightColor = vec4(1.0);\n    \n    //通过混合遮罩进行混合\n    fragColor = mix(darkColor, lightColor, maskColor.r);\n    \n    //ending mask mask\n    float endMask = smoothstep(0.62,1.0,uv.x);\n    vec4 endMaskColor = vec4(0.741,0.812,1.000,1.0);\n    //fragColor = mix(fragColor,endMaskColor,endMask);\n    \n    // Black bars at the sides\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) fragColor = vec4(0);    \n   \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DldGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 92, 92, 189], [191, 191, 237, 237, 331], [333, 333, 364, 364, 455], [457, 457, 500, 500, 943], [945, 945, 999, 999, 1021], [1023, 1023, 1075, 1075, 1142], [1144, 1144, 1168, 1168, 1198], [1200, 1200, 1223, 1223, 1546], [1548, 1636, 1739, 1739, 4277], [4279, 4279, 4336, 4374, 9585]]}
{"id": "cldGDf", "name": "Triangle Gradient Background", "author": "kbnt", "description": "Inspired by / Remix of \"ice and fire\" by mattz (https://www.shadertoy.com/view/MdfBzl)", "tags": ["2d", "triangles", "gradient", "background"], "likes": 12, "viewed": 268, "published": 3, "date": "1683253711", "time_retrieved": "2024-07-30T17:57:31.101690", "image_code": "/* \n   Triangle Gradient Background by kbnt\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Inspired by / Remix of \"ice and fire\" by mattz (https://www.shadertoy.com/view/MdfBzl)\n*/\n\nconst float scaleAmnt = 6.2;\nconst float motionSpeed = 0.1;\nconst float motionSize  = 0.45; // max 0.5\nconst float colourSpeed = 0.1;\n\n/*\nconst float s6  = 0.866025388240814208984; // sin(60)\nconst float ti6 = 0.577350258827209472656; // cos(60) / sin(60)\nconst float si6 = 1.154700517654418945310; // 1 / sin(60)\n\nconst mat2 tri2cart = mat2(s6, -0.5, 0, 1);\nconst mat2 cart2tri = mat2(si6, ti6, 0, 1);\n/**/\n\n/**/\nconst float s3 = 1.7320508075688772; // 2 * sin(60)\nconst float i3 = 0.5773502691896258; // tan(60)\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n/**/\n\n/*\nconst mat2 tri2cart = mat2(1, 0, 0, 1);\nconst mat2 cart2tri = mat2(1, 0, 0, 1);\n/**/\n\n//////////////////////////////////////////////////////////////////////\n// cosine based palette \n// adapted from https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return clamp(a + b*cos( 6.28318*(c*t+d) ), 0.0, 1.0);\n}\n\nvec3 pala(in float t) {\n    return pal( t, vec3(0.5),vec3(0.5),vec3(0.8, 0.8, 0.5),vec3(0, 0.2, 0.5) );\n}\n\nvec3 colourForPoint(vec2 uv) {\n    float t = colourSpeed*iTime;\n    \n    // pallet sample\n    vec3 col00 = pala( t+0.00 );\n    vec3 col01 = pala( t+0.25 );\n    vec3 col11 = pala( t+0.50 );\n    vec3 col10 = pala( t+0.75 );\n    \n    // mix colours\n    vec3 colorA = mix(col00,col10,uv.x);\n    vec3 colorB = mix(col01,col11,uv.x);\n    return mix(colorA, colorB, uv.y);\n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);   \n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// generate a random point on a circle from 3 integer coords (x, y, t)\n\nvec2 randCircle(vec3 p) {\n    \n    vec2 rt = hash23(p);\n    \n    float r = sqrt(rt.x);\n    float theta = 6.283185307179586 * rt.y;\n    \n    return r*vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a time-varying cubic spline at integer coords p that stays\n// inside a unit circle\n\nvec2 randCircleSpline(vec2 p, float t) {\n\n    // standard catmull-rom spline implementation\n    float t1 = floor(t);\n    t -= t1;\n    \n    vec2 pa = randCircle(vec3(p, t1-1.0));\n    vec2 p0 = randCircle(vec3(p, t1));\n    vec2 p1 = randCircle(vec3(p, t1+1.0));\n    vec2 pb = randCircle(vec3(p, t1+2.0));\n    \n    vec2 m0 = 0.5*(p1 - pa);\n    vec2 m1 = 0.5*(pb - p0);\n    \n    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;\n    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;\n    vec2 c1 = m0;\n    vec2 c0 = p0;\n    \n    return (((c3*t + c2)*t + c1)*t + c0) * 0.8;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// perturbed point from index\n\nvec2 triPoint(vec2 p) {\n    float t0 = hash12(p);\n    return tri2cart*p + motionSize*randCircleSpline(p, motionSpeed*iTime + t0);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle\n\nfloat sgn (vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n{\n    float d1, d2, d3;\n    bool has_neg, has_pos;\n\n    d1 = sgn(pt, v1, v2);\n    d2 = sgn(pt, v2, v3);\n    d3 = sgn(pt, v3, v1);\n\n    has_neg = (d1 < 0.0) || (d2 < 0.0) || (d3 < 0.0);\n    has_pos = (d1 > 0.0) || (d2 > 0.0) || (d3 > 0.0);\n\n    return !(has_neg && has_pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // scale from screen space to scene space\n    float scl = scaleAmnt / iResolution.y;\n   \n    // get 2D scene coords\n    vec2 p = (fragCoord - 0.5*iResolution.xy) * scl;\n    \n    // get triangular base coords\n    vec2 tfloor = floor(cart2tri * p + 0.5);\n\n    // precompute 9 neighboring points\n    vec2 pts[9];\n\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            pts[3*i+j] = triPoint(tfloor + vec2(i-1, j-1));\n        }\n    }\n    \n    vec2 center;\n    \n    // note: must look at 4 quads cause when the triangle our current  \n    //       pixel is in gets randomly nudged in the positive direction,\n    //       our pixel may end up in another triangle\n    // for each of the 4 quads:\n    for (int i=0; i<2; ++i) {\n        for (int j=0; j<2; ++j) {\n    \n            // look at lower and upper triangle in this quad\n            vec2 t00 = pts[3*i+j  ];\n            vec2 t10 = pts[3*i+j+3];\n            vec2 t01 = pts[3*i+j+1];\n            vec2 t11 = pts[3*i+j+4];\n          \n            // lower\n            if (PointInTriangle(p, t00, t10, t11)) \n                center = (t00 + t10 + t11) / 3.0; // get centeroid of triangle\n\n            // upper\n            if (PointInTriangle(p, t00, t11, t01))\n                center = (t00 + t11 + t01) / 3.0;\n           \n        }\n    }\n    \n    \n    // convert from scene space to uv to sample colour \n    center = center / scl;\n    center += 0.5*iResolution.xy;\n    center += 0.5;\n    center = center / iResolution.xy;\n    \n    vec4 col = vec4(colourForPoint(center), 1.0);\n    \n    // final pixel color\n    fragColor = col;\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldGDf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1089, 1089, 1157, 1157, 1217], [1219, 1219, 1242, 1242, 1324], [1326, 1326, 1356, 1356, 1693], [1890, 1890, 1912, 1912, 2040], [2042, 2042, 2064, 2064, 2168], [2314, 2314, 2339, 2339, 2499], [2664, 2664, 2704, 2755, 3217], [3321, 3321, 3344, 3344, 3452], [3622, 3622, 3661, 3661, 3737], [3739, 3739, 3798, 3798, 4072], [4074, 4074, 4131, 4178, 5734]]}
{"id": "ctdGDf", "name": "多种mat", "author": "12gx", "description": "two different mats", "tags": ["raymarchmaterial"], "likes": 2, "viewed": 118, "published": 3, "date": "1683253628", "time_retrieved": "2024-07-30T17:57:31.930474", "image_code": "struct material{\n    float d;\n    float id;\n    vec3 col;\n    //其他不同的信息，读者可以自行添加。\n};\nmat2 rot(float angle){\n    float c= cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\nfloat smin(float a,float b,float k){\n    float h = clamp(0.5+0.5*(a-b)/k,0.0,1.0);\n    return mix(a,b,h)-k*h*(1.0-h);\n}\n\nmaterial map(vec3 p){\n    material mat;\n    float sphere=  length(p)-1.0;\n    if(sphere<=0.001) {\n        mat.id = 1.0;\n        mat.col = vec3(1.0,0.0,0.0);\n    }\n    float plane = p.y+1.5;\n    if(plane<=0.001) {\n        mat.id = 2.0;\n        //因为平面的y是-1.5 永远不变的\n        mat.col = mod(floor(p.x)+floor(p.z),2.0)*vec3(1.0);\n    };\n    mat.d = min(sphere,plane);\n    return mat;\n    \n}\n\nmaterial Raymarch(vec3 ro,vec3 rd){\n    float d;\n    material mat;\n    for(int i =0;i<255;i++){\n        vec3 p =ro+rd*d;\n        mat = map(p);\n        float d0 = mat.d;\n        if(d0<=0.001||d>=40.) break;\n        d+=d0;\n    }\n    mat.d = d;\n    return mat;\n}\nvec3 GetNormal(vec3 p){\n    float d = map(p).d;\n    vec2 e = vec2(0.001,0.0);\n    float dx = d-map(p-e.xyy).d;\n    float dy = d-map(p-e.yxy).d;\n    float dz = d-map(p-e.yyx).d;\n    return normalize(vec3(dx,dy,dz));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;    \n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0,0.0,-5);\n    vec3 rd  = normalize(vec3(uv,1.0));\n    \n    material mat = Raymarch(ro,rd);\n    if(mat.d<40.0){\n        vec3 p = ro+rd*mat.d;\n        vec3 n  = GetNormal(p);\n        vec3 lightPos = vec3(0,5,-5.0); \n        vec3 lightdir = normalize(lightPos-p);\n        float diffuse = dot(n,lightdir);\n        diffuse =diffuse*.5+.5;\n        col+=diffuse * mat.col;\n    }\n   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 141, 141, 221], [222, 222, 258, 258, 341], [343, 343, 364, 364, 748], [750, 750, 785, 785, 1009], [1010, 1010, 1033, 1033, 1226], [1227, 1227, 1284, 1284, 1851]]}
{"id": "mtd3W2", "name": "Voxel thing", "author": "ThePlaneGuy45", "description": "textures go brrr\ntextures hand made, imported into shadertoy\nI'm trying to make a voxel game off this (for fun :P)\nMost of the raycaster code by Shane (I updated it a decent bit to work with what I need)", "tags": ["textures"], "likes": 1, "viewed": 207, "published": 3, "date": "1683252560", "time_retrieved": "2024-07-30T17:57:32.921824", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = textureLod(iChannel0, uv, 0.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define DIRT int[768](0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35)\n#define STONE int[768](0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x58, 0x58, 0x58, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x72, 0x72, 0x72, 0xA5, 0xA5, 0xA5, 0x8C, 0x8C, 0x8C);\n#define GRASS_SIDE int[768](0x46, 0x92, 0x40, 0x57, 0xB6, 0x50, 0x51, 0xA9, 0x4A, 0x46, 0x92, 0x40, 0x40, 0x87, 0x3B, 0x46, 0x93, 0x41, 0x46, 0x92, 0x40, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x4E, 0xA3, 0x48, 0x4D, 0xA1, 0x47, 0x49, 0x98, 0x43, 0x58, 0xB8, 0x51, 0x57, 0xB6, 0x50, 0x4A, 0x9A, 0x44, 0x56, 0xB4, 0x4F, 0x59, 0xBB, 0x52, 0x58, 0xB8, 0x51, 0x4F, 0xA5, 0x49, 0x41, 0x89, 0x3C, 0x59, 0xBB, 0x52, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x58, 0xB9, 0x51, 0x49, 0x99, 0x43, 0x57, 0xB6, 0x50, 0x42, 0x8A, 0x3D, 0x58, 0xB9, 0x51, 0x3E, 0x83, 0x39, 0x58, 0xB7, 0x51, 0x4A, 0x9B, 0x44, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x4E, 0xA3, 0x48, 0x4D, 0xA1, 0x47, 0x49, 0x98, 0x43, 0x58, 0xB8, 0x51, 0x57, 0xB6, 0x50, 0x4A, 0x9A, 0x44, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4C, 0x59, 0xBB, 0x52, 0x58, 0xB7, 0x51, 0x56, 0xB4, 0x4F, 0x3F, 0x84, 0x3A, 0x59, 0xBB, 0x52, 0x56, 0xB5, 0x50, 0x58, 0xB9, 0x51, 0x49, 0x99, 0x43, 0x57, 0xB6, 0x50, 0x42, 0x8A, 0x3D, 0x58, 0xB9, 0x51, 0x3E, 0x83, 0x39, 0x58, 0xB7, 0x51, 0x4A, 0x9B, 0x44, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x4A, 0x9B, 0x44, 0x59, 0xBB, 0x52, 0x57, 0xB6, 0x50, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x4A, 0x9A, 0x44, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4C, 0x59, 0xBB, 0x52, 0x58, 0xB7, 0x51, 0x56, 0xB4, 0x4F, 0x3F, 0x84, 0x3A, 0x59, 0xBB, 0x52, 0x56, 0xB5, 0x50, 0x40, 0x87, 0x3B, 0x46, 0x93, 0x41, 0x46, 0x92, 0x40, 0x58, 0xB8, 0x51, 0x51, 0xA9, 0x4A, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4D, 0x4A, 0x9B, 0x44, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x28, 0x54, 0x25, 0x33, 0x6A, 0x2F, 0x57, 0xB6, 0x50, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x41, 0x89, 0x3C, 0x59, 0xBB, 0x52, 0x53, 0xAE, 0x4C, 0x4F, 0xA5, 0x49, 0x46, 0x92, 0x40, 0x33, 0x6A, 0x2F, 0x46, 0x92, 0x40, 0x28, 0x54, 0x25, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x28, 0x54, 0x25, 0x55, 0x38, 0x25, 0x55, 0x38, 0x25, 0x33, 0x6A, 0x2F, 0x58, 0xB9, 0x51, 0x3E, 0x83, 0x39, 0x33, 0x6A, 0x2F, 0x28, 0x54, 0x25, 0x53, 0xAE, 0x4D, 0x41, 0x89, 0x3C, 0x28, 0x54, 0x25, 0x55, 0x38, 0x25, 0x33, 0x6A, 0x2F, 0x55, 0x38, 0x25, 0x33, 0x6A, 0x2F, 0x57, 0xB6, 0x50, 0x28, 0x54, 0x25, 0x55, 0x38, 0x25, 0xA0, 0x72, 0x56, 0x67, 0x44, 0x2D, 0x33, 0x6A, 0x2F, 0x28, 0x54, 0x25, 0x55, 0x38, 0x25, 0x55, 0x38, 0x25, 0x28, 0x54, 0x25, 0x53, 0xAE, 0x4C, 0x33, 0x6A, 0x2F, 0x67, 0x44, 0x2D, 0x55, 0x38, 0x25, 0xA0, 0x72, 0x56, 0x55, 0x38, 0x25, 0x33, 0x6A, 0x2F, 0x67, 0x44, 0x2D, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x55, 0x38, 0x25, 0x67, 0x44, 0x2D, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x55, 0x38, 0x25, 0x33, 0x6A, 0x2F, 0x55, 0x38, 0x25, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x55, 0x38, 0x25, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x67, 0x44, 0x2D, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x79, 0x4F, 0x35, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35, 0x79, 0x4F, 0x35, 0xA0, 0x72, 0x56, 0xA0, 0x72, 0x56, 0x93, 0x60, 0x41, 0x93, 0x60, 0x41, 0x6B, 0x40, 0x24, 0x6B, 0x40, 0x24, 0x79, 0x4F, 0x35);\n#define GRASS_TOP int[768](0x4A, 0x9A, 0x44, 0x4A, 0x9B, 0x44, 0x56, 0xB5, 0x50, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4D, 0x46, 0x93, 0x41, 0x46, 0x92, 0x40, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x4E, 0xA3, 0x48, 0x4A, 0x9A, 0x44, 0x58, 0xB9, 0x51, 0x5C, 0xC0, 0x54, 0x56, 0xB4, 0x4F, 0x46, 0x92, 0x40, 0x57, 0xB6, 0x50, 0x58, 0xB7, 0x51, 0x59, 0xBB, 0x52, 0x58, 0xB8, 0x51, 0x3E, 0x83, 0x39, 0x3F, 0x84, 0x3A, 0x57, 0xB6, 0x50, 0x5C, 0xC0, 0x54, 0x58, 0xB9, 0x51, 0x49, 0x99, 0x43, 0x57, 0xB6, 0x50, 0x5C, 0xC0, 0x54, 0x49, 0x99, 0x43, 0x56, 0xB5, 0x50, 0x59, 0xBB, 0x52, 0x57, 0xB6, 0x50, 0x58, 0xB8, 0x51, 0x3E, 0x83, 0x39, 0x3F, 0x84, 0x3A, 0x49, 0x98, 0x43, 0x58, 0xB9, 0x51, 0x56, 0xB4, 0x4F, 0x59, 0xBB, 0x52, 0x4A, 0x9A, 0x44, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4C, 0x59, 0xBB, 0x52, 0x53, 0xAE, 0x4C, 0x57, 0xB6, 0x50, 0x4E, 0xA3, 0x48, 0x58, 0xB8, 0x51, 0x51, 0xA9, 0x4A, 0x49, 0x98, 0x43, 0x58, 0xB9, 0x51, 0x56, 0xB4, 0x4F, 0x4D, 0xA1, 0x47, 0x42, 0x8A, 0x3D, 0x58, 0xB7, 0x51, 0x4A, 0x9B, 0x44, 0x4A, 0x9B, 0x44, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x59, 0xBB, 0x52, 0x42, 0x8A, 0x3D, 0x4D, 0xA1, 0x47, 0x4F, 0xA5, 0x49, 0x46, 0x92, 0x40, 0x4D, 0xA1, 0x47, 0x42, 0x8A, 0x3D, 0x58, 0xB7, 0x51, 0x4E, 0xA3, 0x48, 0x57, 0xB6, 0x50, 0x59, 0xBB, 0x52, 0x56, 0xB5, 0x50, 0x59, 0xBB, 0x52, 0x56, 0xB5, 0x50, 0x40, 0x87, 0x3B, 0x46, 0x93, 0x41, 0x58, 0xB7, 0x51, 0x58, 0xB9, 0x51, 0x49, 0x98, 0x43, 0x41, 0x89, 0x3C, 0x40, 0x87, 0x3B, 0x4E, 0xA3, 0x48, 0x57, 0xB6, 0x50, 0x59, 0xBB, 0x52, 0x56, 0xB5, 0x50, 0x49, 0x99, 0x43, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x4E, 0xA3, 0x48, 0x4D, 0xA1, 0x47, 0x56, 0xB4, 0x4F, 0x3E, 0x83, 0x39, 0x58, 0xB8, 0x51, 0x59, 0xBB, 0x52, 0x46, 0x93, 0x41, 0x56, 0xB5, 0x50, 0x49, 0x99, 0x43, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x58, 0xB9, 0x51, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4D, 0x58, 0xB9, 0x51, 0x49, 0x99, 0x43, 0x57, 0xB6, 0x50, 0x42, 0x8A, 0x3D, 0x3F, 0x84, 0x3A, 0x58, 0xB7, 0x51, 0x57, 0xB6, 0x50, 0x53, 0xAE, 0x4C, 0x46, 0x92, 0x40, 0x5C, 0xC0, 0x54, 0x58, 0xB9, 0x51, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x4A, 0x9A, 0x44, 0x4A, 0x9B, 0x44, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4C, 0x59, 0xBB, 0x52, 0x58, 0xB7, 0x51, 0x59, 0xBB, 0x52, 0x4A, 0x9B, 0x44, 0x4A, 0x9A, 0x44, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4D, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x4A, 0x9A, 0x44, 0x46, 0x92, 0x40, 0x53, 0xAE, 0x4C, 0x57, 0xB6, 0x50, 0x58, 0xB7, 0x51, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x56, 0xB5, 0x50, 0x4A, 0x9B, 0x44, 0x56, 0xB5, 0x50, 0x53, 0xAE, 0x4D, 0x5C, 0xC0, 0x54, 0x58, 0xB9, 0x51, 0x5C, 0xC0, 0x54, 0x46, 0x92, 0x40, 0x51, 0xA9, 0x4A, 0x46, 0x92, 0x40, 0x46, 0x93, 0x41, 0x59, 0xBB, 0x52, 0x58, 0xB8, 0x51, 0x3E, 0x83, 0x39, 0x56, 0xB5, 0x50, 0x40, 0x87, 0x3B, 0x46, 0x93, 0x41, 0x46, 0x92, 0x40, 0x40, 0x87, 0x3B, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4C, 0x49, 0x99, 0x43, 0x56, 0xB5, 0x50, 0x46, 0x93, 0x41, 0x58, 0xB8, 0x51, 0x4F, 0xA5, 0x49, 0x40, 0x87, 0x3B, 0x41, 0x89, 0x3C, 0x49, 0x98, 0x43, 0x58, 0xB9, 0x51, 0x5C, 0xC0, 0x54, 0x41, 0x89, 0x3C, 0x59, 0xBB, 0x52, 0x53, 0xAE, 0x4C, 0x46, 0x93, 0x41, 0x56, 0xB5, 0x50, 0x59, 0xBB, 0x52, 0x57, 0xB6, 0x50, 0x4E, 0xA3, 0x48, 0x40, 0x87, 0x3B, 0x41, 0x89, 0x3C, 0x49, 0x98, 0x43, 0x58, 0xB9, 0x51, 0x58, 0xB7, 0x51, 0x46, 0x93, 0x41, 0x40, 0x87, 0x3B, 0x56, 0xB5, 0x50, 0x59, 0xBB, 0x52, 0x3F, 0x84, 0x3A, 0x56, 0xB4, 0x4F, 0x58, 0xB7, 0x51, 0x59, 0xBB, 0x52, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x4A, 0x9A, 0x44, 0x46, 0x92, 0x40, 0x4F, 0xA5, 0x49, 0x4D, 0xA1, 0x47, 0x42, 0x8A, 0x3D, 0x59, 0xBB, 0x52, 0x56, 0xB5, 0x50, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4D, 0x4A, 0x9B, 0x44, 0x58, 0xB7, 0x51, 0x3E, 0x83, 0x39, 0x58, 0xB9, 0x51, 0x42, 0x8A, 0x3D, 0x57, 0xB6, 0x50, 0x49, 0x99, 0x43, 0x58, 0xB9, 0x51, 0x51, 0xA9, 0x4A, 0x58, 0xB8, 0x51, 0x4E, 0xA3, 0x48, 0x57, 0xB6, 0x50, 0x53, 0xAE, 0x4C, 0x59, 0xBB, 0x52, 0x53, 0xAE, 0x4C, 0x5C, 0xC0, 0x54, 0x4A, 0x9A, 0x44, 0x57, 0xB6, 0x50, 0x58, 0xB8, 0x51, 0x49, 0x98, 0x43, 0x4D, 0xA1, 0x47, 0x4E, 0xA3, 0x48, 0x56, 0xB5, 0x50, 0x5C, 0xC0, 0x54, 0x57, 0xB6, 0x50, 0x59, 0xBB, 0x52, 0x56, 0xB5, 0x50, 0x49, 0x99, 0x43, 0x5C, 0xC0, 0x54, 0x57, 0xB6, 0x50, 0x49, 0x99, 0x43, 0x58, 0xB9, 0x51, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4C, 0x59, 0xBB, 0x52, 0x41, 0x89, 0x3C, 0x4F, 0xA5, 0x49, 0x58, 0xB8, 0x51, 0x59, 0xBB, 0x52, 0x56, 0xB4, 0x4F, 0x46, 0x92, 0x40, 0x56, 0xB4, 0x4F, 0x5C, 0xC0, 0x54, 0x58, 0xB9, 0x51, 0x4A, 0x9A, 0x44, 0x4E, 0xA3, 0x48, 0x56, 0xB5, 0x50, 0x5C, 0xC0, 0x54, 0x53, 0xAE, 0x4D, 0x46, 0x92, 0x40, 0x46, 0x93, 0x41, 0x40, 0x87, 0x3B, 0x46, 0x92, 0x40, 0x51, 0xA9, 0x4A, 0x57, 0xB6, 0x50, 0x46, 0x92, 0x40);\n#define WOOD_SIDE int[768](0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x5E, 0x3C, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x5C, 0x1C, 0x72, 0x48, 0x00, 0x81, 0x51, 0x00, 0x81, 0x51, 0x00, 0x72, 0x48, 0x00, 0x58, 0x38, 0x00);\n#define WOOD_TOP int[768](0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0xAF, 0x91, 0x5D, 0x93, 0x76, 0x43, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x7D, 0x64, 0x3A, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0x93, 0x76, 0x43, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAF, 0x91, 0x5D, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0xAE, 0x8B, 0x50, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00, 0x58, 0x38, 0x00);\n#define LEAF int[768](0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x3C, 0xB6, 0x69, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x34, 0x9C, 0x5A, 0x22, 0x66, 0x3B, 0x29, 0x7D, 0x48, 0x34, 0x9C, 0x5A);\n\nint[768] tex(int texID) {\n    switch(texID){\n    case 0:\n        return DIRT;\n    case 1:\n        return STONE;\n    case 2:\n        return GRASS_SIDE;\n    case 3:\n        return GRASS_TOP;\n    case 4:\n        return WOOD_SIDE;\n    case 5:\n        return WOOD_TOP;\n    case 6:\n        return LEAF;\n    }\n}\nvec3 getData(int index, int texID) {\n    int i = index * 3;\n    vec3 a;\n    int[768] j = tex(texID);\n    a.x = float(j[i]);\n    a.y = float(j[i+1]);\n    a.z = float(j[i+2]);\n    return a / 255.0;\n}\nvec3 sampleTex(vec2 uv, int texID) {\n    ivec2 coord = ivec2(floor(uv * 16.0));\n    int index = coord.x + (16 * coord.y);\n    return getData(index, texID);\n}\nint getId(int texID, vec3 mask) {\n\n    switch(texID){\n    case 0:\n        return texID;\n    case 1:\n        return texID;\n    case 2:\n        return mask.y > 0.0 ? texID + 1 : texID;\n    case 3:\n        return mask.y > 0.0 ? texID + 2 : texID + 1;\n    case 4:\n        return texID + 2;\n    }\n    \n    return 0;\n\n}\n\nvec4 worldMap(vec3 position) {\n    \n    if(position.z <= 1.0 && position.z > 0.0) {\n    if(position.y <= 1.0 && position.y > 0.0) {\n    if(position.x <= 1.0 && position.x > 0.0) { \n        return vec4(0.0, 0.0, 0.0, 1.0); } else if(position.x <= 2.0 && position.x > 0.0) {\n        return vec4(1.0, 0.0, 0.0, 1.0); } else if(position.x <= 3.0 && position.x > 0.0) {\n        return vec4(2.0, 0.0, 0.0, 1.0); } else if(position.x <= 4.0 && position.x > 0.0) {\n        return vec4(3.0, 0.0, 0.0, 1.0); } else if(position.x <= 5.0 && position.x > 0.0) {\n        return vec4(4.0, 0.0, 0.0, 1.0); } else { return vec4(0.0); }\n    } else { return vec4(0.0); }\n    } else { return vec4(0.0); }\n\n}\n\nvec3 singleRay(in Ray ray) {\n    \n    vec3 p = vec3(0.5);\n\n    float s = sign(ray.normal.z);\n    vec3 rayn = ray.normal;\n    rayn.z *= s;\n\tvec3 dRd = 1.0 / abs(rayn);\n\tvec3 rayNormal = sign(rayn);\n    vec3 side = dRd * (rayNormal * p + 0.5);\n    \n    vec3 mask = vec3(0.0);\n    \n    vec4 voxel;\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\t\n        voxel = worldMap(vec3(p.xy, p.z * s) + ray.origin);\n        \n        if (voxel.w > 0.0) { break; }\n        \n        mask = step(side, side.yzx) * (1.0 - step(side.zxy, side));\n\t\tside += mask * dRd;\n\t\tp += mask * rayNormal;\n\t}\n    \n    if(voxel.w > 0.0) {\n    \n    \tvec3 tCube = (p - 0.5 * sign(rayn)) / rayn;\n        float t = max(max(tCube.x, tCube.y), tCube.z);\n        vec3 position = ray.origin + ray.normal * t;\n        vec3 relative = ((position + 0.5) - round(position + 0.5)) * (1.0 - mask);\n        vec3 normal = -(mask * sign(ray.normal));\n        \n        vec2 uv;\n        if(!bool(relative.x)){ uv = relative.zy; }\n        if(!bool(relative.y)){ uv = relative.xz; }\n        if(!bool(relative.z)){ uv = relative.xy; }\n        \n        uv += 0.5;\n        uv.y = 1.0 - uv.y;\n        \n        int texID = getId(int(voxel.x), mask);\n        \n        vec3 color = sampleTex(uv, texID);\n        \n        float fog = pow(clamp(150.0 / (t + 100.0), 0.0, 1.0), 32.0);\n        \n        vec3 lightNormal = normalize(vec3(10.0, 10.0, -10.0) - position);\n        float shade = mix(0.2, 1.0, clamp(dot(lightNormal, normal), 0.0, 1.0));\n        \n        return mix(vec3(0.2), color * shade, fog);\n    \n    } else {\n    \n        return vec3(0.2);\n        \n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    Ray ray;\n    ray.origin = vec3(1.0, 3.0, -4.0);\n    ray.normal = normalize(vec3(uv, 1.5));\n    mat2 rot = rot2((iMouse.y / iResolution.y - 0.5) * 5.0);\n    ray.normal.yz *= rot;\n    rot = rot2((iMouse.x / iResolution.x - 0.5) * 5.0);\n    ray.normal.xz *= rot;\n    fragColor = vec4(singleRay(ray), 1.0);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAP_SIZE vec3(100.0, 10.0, 100.0)\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 normal;\n\n};\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\nvec4 readMapTex(vec2 pos, sampler2D iChannel, vec3 resolution) {\n\treturn textureLod(iChannel, (floor(pos) + .5) / (floor(resolution.xy)), 0.);\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float index = round(fragCoord.x + 1280.0 * fragCoord.y);\n    vec3 voxel;\n    voxel.z = floor(index / (MAP_SIZE.x * MAP_SIZE.y));\n    voxel.y = mod(floor(index / MAP_SIZE.x), MAP_SIZE.y);\n    voxel.x = mod(index, MAP_SIZE.x);\n    \n    int id;\n    if(voxel.y <= 0.0){ id = 2; } else { id = 0; }\n    if(voxel.x < 75.0 && voxel.z < 75.0){ fragColor = vec4(float(id), 1.0, 0.0, 1.0); }\n    else{ fragColor = vec4(-1.0,0.0,0.0,0.0); }\n    fragColor = vec4(voxel, 1.0);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtd3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 153]]}
{"id": "mtjXWz", "name": "Genuary2023 Minimalism", "author": "z0rg", "description": "Genuary2023 finally published ", "tags": ["2d", "tree", "lsystem", "minimalism"], "likes": 10, "viewed": 176, "published": 3, "date": "1683243485", "time_retrieved": "2024-07-30T17:57:33.779531", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a)\n{\n  float c = cos(a), s= sin(a);\n   return mat2(c,-s,s,c);\n}\nfloat hash11(float seed)\n{\n    return fract(sin(seed*123.456)*123.456);\n}\nfloat _seed;\nfloat rand()\n{\n    return hash11(_seed++);\n}\nfloat _sqr(vec2 uv, vec2 s)\n{\n  vec2 l = abs(uv)-s;\n  return max(l.x,l.y);\n}\n#define sat(a) clamp(a,0.,1.)\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\nvec3 rdr(vec2 uv)\n{\n    uv -= vec2(.1,-.7);\n  vec3 col = vec3(0.);\n\n    float stp = .02;\n    \n  vec2 uvb = uv;\n  uvb = floor(uvb/stp)*stp;\n  float back = _sqr(uvb+ vec2(.0,-0.7),vec2(.4,.4));\n  back -= sin(uvb.y*10.)*.1;\n  back -= texture(iChannel0, uvb*.1-iTime*.01).x*.4;\n  col = mix(vec3(.15), vec3(0.129,0.439,0.769), 1.-sat(back*400.));\n  col *= sat(rand()+.7);\n  float sharp = iResolution.x*.5;\n  uv.x+= sin(uv.y*5.+uv.x*2.+iTime)*.02*sat(uv.y);\n  vec2 p = uv;\n  for (float i = 0.;i<6.;++i)\n  {\n    float off = mix(.3,.05,i/7.);\n    p+= vec2(0.,-off*.45);\n    p*=r2d(.4*sat(i));\n    p+= vec2(0.,-off*.45);\n    p.x = abs(p.x);\n    vec2 pos = p;\n\n    float shape = _sqr(pos, vec2(.01,off*.45));\n    if (i > 2.9)\n        shape = mix(lenny(pos)-.1, length(pos)-.1, -1.+i*.3);\n    col = mix(col, vec3(0.),1.-sat(shape*sharp));\n    if (i > 2.9)\n        col = mix(col, vec3(1.,.1,.2),1.-sat((shape+.05)*sharp));\n  }\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)\n   / iResolution.xx;\n   _seed = texture(iChannel0, uv).x+iTime;\n  vec3 col = rdr(uv*2.);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjXWz.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 416, 416, 475], [476, 476, 502, 502, 549], [563, 563, 577, 577, 607], [608, 608, 637, 637, 684], [715, 715, 736, 736, 768], [769, 769, 788, 788, 1699], [1702, 1702, 1759, 1759, 1925]]}
{"id": "ctt3DX", "name": "is this linear actuator?", "author": "jonasfrey", "description": "i am watching a video ([url]https://www.youtube.com/watch?v=uf_Z57gAJTc[/url]) about linear actuator and i asked myself what the interpolation of all three sine waves would look like, it seems that they result in a straight line :thinking_face:\n", "tags": ["question"], "likes": 8, "viewed": 229, "published": 3, "date": "1683236745", "time_retrieved": "2024-07-30T17:57:34.608315", "image_code": "#define n_tau 6.2831\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float n_its = 20.;\n    float n_y_1 = sin(o_fc.x*n_tau)*0.2;\n    float n_lightness_y_1 = abs(o_fc.y - n_y_1); \n    n_lightness_y_1 = 1.-pow(n_lightness_y_1, 1./3.);\n\n    float n_y_2 = sin(o_fc.x*n_tau+n_tau/3.)*0.2;\n    float n_lightness_y_2 = abs(o_fc.y - n_y_2); \n    n_lightness_y_2 = 1.-pow(n_lightness_y_2, 1./3.);\n\n    float n_y_3 = sin(o_fc.x*n_tau+(n_tau/3.)*2.)*0.2;\n    float n_lightness_y_3 = abs(o_fc.y - n_y_3); \n    n_lightness_y_3 = 1.-pow(n_lightness_y_3, 1./3.);\n\n    float n_y_comb = \n        (n_y_1 / 3. )\n        + (n_y_2 / 3.)\n        + (n_y_3 / 3.);\n    float n_lightness_y_comb = abs(o_fc.y - n_y_comb); \n    n_lightness_y_comb = 1.-pow(n_lightness_y_comb, 1./10.);\n\n    float n_white = n_lightness_y_comb;\n    fragColor = vec4(\n        vec4(n_lightness_y_1/3., 0.,0.,1.)\n        + vec4(0., n_lightness_y_2/3., 0.,1.)\n        + vec4(0.,0.,n_lightness_y_3/3., 1.)\n    );\n    fragColor += vec4(n_white);\n    fragColor = fragColor*fragColor*3.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctt3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 1116]]}
{"id": "Dtd3WX", "name": "3D rasterized sphere", "author": "GetItemFromBlock", "description": "Fork of https://www.shadertoy.com/view/dsVXRm\nAn even bigger 3d model, this time a sphere with 720 triangles !\nI also generate the mesh, instead of hard-coding one in the code", "tags": ["3d", "rasterizer", "triangle"], "likes": 1, "viewed": 166, "published": 3, "date": "1683233029", "time_retrieved": "2024-07-30T17:57:35.432112", "image_code": "// Fork of \"3D low poly rotating Amogus\" by GetItemFromBlock. https://shadertoy.com/view/dsVXRm\n// GetItemFromBlock - 2023-05-04\n\n// Based on \"Rasterizer - Cube\" by iq. https://shadertoy.com/view/XdlGzn\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 rasterize(in vec2 coord)\n{\n    vec2 px = (2.0*coord-iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0.478,0.478,0.478);\n    // clear zbuffer\n    float mindist = -1000000.0;\n    \n    for (int i = 0; i < LONGITUDE * (LATITUDE - 1) * 2; i++)\n    {\n        ivec2 tCoord = ivec2(i % int(iResolution.x), i / int(iResolution.x) * 7);\n        vec4 bounds = texelFetch(iChannel0, ivec2(tCoord.x, tCoord.y + 3), 0);\n        if (px.x < bounds.x || px.x > bounds.y || px.y < bounds.z || px.y > bounds.w)\n        {\n            continue;\n        }\n        vec4 frb = texelFetch(iChannel0, ivec2(tCoord.x, tCoord.y + 1), 0);\n        vec4 frc = texelFetch(iChannel0, ivec2(tCoord.x, tCoord.y + 2), 0);\n        vec2 cp0 = frb.xy;\n        vec2 cp1 = frb.zw;\n        vec2 cp2 = frc.xy;\n\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n                        \n        if( all(greaterThan(di,vec3(0.0))) )\n        {\n            vec4 fra = texelFetch(iChannel0, tCoord, 0);\n            float w0 = fra.x;\n            float w1 = fra.y;\n            float w2 = fra.z;\n            \n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n            \n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n\t\t\t// depth (-1/z) buffer test\n\t\t\tif( z>mindist )\n\t\t\t{\n\t\t\t\tmindist = z;\n                \n                vec3 a = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y), 0).xyz;\n                vec3 b = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 1), 0).xyz;\n                vec3 c = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 2), 0).xyz;\n            \n                vec3 p0 = a * w0;\n                vec3 p1 = b * w1;\n                vec3 p2 = c * w2;\n                \n                vec3 na = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 3), 0).xyz * w0;\n                vec3 nb = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 4), 0).xyz * w1;\n                vec3 nc = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 5), 0).xyz * w2;\n\n                vec3 n = ba.x*na + ba.y*nb + ba.z*nc;\n                \n\t\t\t\t// perform lighting/shading \n                vec3 cameraPos = texelFetch(iChannel1, ivec2(0,4), 0).rgb;\n                vec3 col = texelFetch(iChannel2, ivec2(tCoord.x, tCoord.y + 6), 0).xyz;\n                vec3 worldPos = p0 * ba.x + p1 * ba.y + p2 * ba.z;\n                worldPos *= z;\n                n = normalize(n*z);\n\t\t\t\tcolor = shader(normalize(-cameraPos-worldPos), n, col);\n                \n\t\t\t}\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = texelFetch(iChannel2, ivec2(fragCoord/2.), 0)*-5.;\n    fragColor = vec4(rasterize(fragCoord), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 processTriangle(ivec2 coord, int subdata)\n{\n\tmat4 mvp = mat4(\n        texelFetch(iChannel0,ivec2(0,0),0),\n        texelFetch(iChannel0,ivec2(0,1),0),\n        texelFetch(iChannel0,ivec2(0,2),0),\n        texelFetch(iChannel0,ivec2(0,3),0)\n    );\n    vec3 a = texelFetch(iChannel1, ivec2(coord.x, coord.y), 0).xyz;\n    vec3 b = texelFetch(iChannel1, ivec2(coord.x, coord.y + 1), 0).xyz;\n    vec3 c = texelFetch(iChannel1, ivec2(coord.x, coord.y + 2), 0).xyz;\n    vec3 ep0 = (mvp * vec4(a,1.0)).xyz;\n    vec3 ep1 = (mvp * vec4(b,1.0)).xyz;\n    vec3 ep2 = (mvp * vec4(c,1.0)).xyz;\n\n    // transform to clip space\n    float w0 = 1.0/ep0.z;\n    float w1 = 1.0/ep1.z;\n    float w2 = 1.0/ep2.z;\n\n    if (subdata == 0)\n    {\n        return vec4(w0,w1,w2,0);\n    }\n\n    vec2 cp0 = 2.0*ep0.xy * -w0;\n    vec2 cp1 = 2.0*ep1.xy * -w1;\n    vec2 cp2 = 2.0*ep2.xy * -w2;\n    if (subdata == 1)\n    {\n        return vec4(cp0, cp1);\n    }\n    else if (subdata == 2)\n    {\n        return vec4(cp2, 0, 0);\n    }\n    float minY = min(min(cp0.y, cp1.y), cp2.y);\n    float maxY = max(max(cp0.y, cp1.y), cp2.y);\n    float minX = min(min(cp0.x, cp1.x), cp2.x);\n    float maxX = max(max(cp0.x, cp1.x), cp2.x);\n    return vec4(minX, maxX, minY, maxY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    int index = coord.y / 7 * int(iResolution.x) + coord.x;\n    int subdata = coord.y % 7;\n    if (index >= LONGITUDE * (LATITUDE - 1) * 2 || subdata > 3)\n    {\n        discard;\n    }\n    fragColor = processTriangle(ivec2(index % int(iResolution.x), index / int(iResolution.x) * 7), subdata);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LONGITUDE 24\n#define LATITUDE 16\n#define M_PI   3.141593\n#define M_PI_2 1.570796\n\nfloat cross2d( in vec2 a, in vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nconst vec3 lightDir = normalize(vec3(.5, 1, -1));\nconst vec3 lightCol = vec3(.5, .5, .5);\nconst float smoothness = 256.;\n\nvec3 shader(vec3 view, vec3 normal, vec3 color)\n{\n    float deltaA = dot(lightDir,normal);\n    if (deltaA < 0.) deltaA = 0.;\n    vec3 halfV = normalize(lightDir + view);\n    float deltaB = pow(max(dot(normal,halfV), .0), smoothness);\n    return color + lightCol * deltaA + deltaB * .5;\n}", "buffer_b_code": "mat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    if (coord.x < 1)\n    {\n        float rx = iMouse.z <= 0. ? .3 + .3 * sin(iTime * .55) : (iMouse.y/iResolution.y-.5)*-3.1415;\n        float ry = iMouse.z <= 0. ? .3*iTime : iMouse.x/iResolution.x*10.;\n        if (coord.y < 5)\n        {\n            if (coord.y == 4)\n            {\n                fragColor = vec4(0,0,-8,0) * setRotation( rx, 0.,  0. ) * setRotation( 0., ry, 0. );\n            }\n            else\n            {\n                mat4 mvp = setTranslation(0., 0., -8. ) * \n                   setRotation( rx, 0.,  0. ) * \n                   setRotation( 0., ry, 0. );\n                fragColor = mvp[coord.y];\n            }\n        }\n    }\n}", "buffer_b_inputs": [], "buffer_c_code": "vec3 GetSphericalCoord(float longitude, float latitude)\n{\n    return vec3(cos(longitude)*cos(latitude),sin(latitude), sin(longitude) * cos(latitude));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n    int index = pos.y / 7 * int(iResolution.x) + pos.x;\n    int subdata = pos.y % 7;\n    if (index >= LONGITUDE * (LATITUDE - 1) * 2) discard;\n    float ref = texelFetch(iChannel0, ivec2(0),0).w;\n    if (ref == iResolution.x)\n    {\n        fragColor = texelFetch(iChannel0, pos, 0);\n        return;\n    }\n    bool second = index >= LONGITUDE * (LATITUDE - 1);\n    if (subdata == 6)\n    {\n        if ((index & 0x1) == 0)\n        {\n            fragColor = vec4(.5, second ? .5 : .0, 0, 0);\n        }\n        else\n        {\n            fragColor = vec4(0, .5, second ? .5 : .0, 0);\n        }\n        return;\n    }\n    float DtY = M_PI / float(LATITUDE);\n    float DtX = 2. * M_PI / float(LONGITUDE);\n    int a = index % LONGITUDE;\n    int b = index / LONGITUDE + 1;\n    if (second)\n    {\n        b = b - LATITUDE + 2;\n    }\n    vec3 vert;\n    if (subdata == 0 || subdata == 3)\n    {\n        vert = GetSphericalCoord(DtX * float(a), DtY * float(second ? b - 1 : b) - M_PI_2);\n    }\n    else if (subdata == 1 || subdata == 4)\n    {\n        vert = GetSphericalCoord(DtX * float(second ? a : a + 1), DtY * float(b) - M_PI_2);\n    }\n    else\n    {\n        vert = GetSphericalCoord(DtX * float(a + 1), DtY * float(b - 1) - M_PI_2);\n    }\n    if (subdata < 3)\n    {\n        fragColor = vec4(vert * 2., 0);\n    }\n    else\n    {\n        fragColor = vec4(normalize(vert), 0);\n    }\n    if (pos.x == 0 && pos.y == 0) fragColor.w = iResolution.x;\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtd3WX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[292, 292, 323, 323, 3024], [3026, 3026, 3083, 3152, 3201]]}
{"id": "Dtt3W2", "name": "PIXEL PLAY <3", "author": "armonnaeini", "description": "datamosh", "tags": ["campinput"], "likes": 4, "viewed": 296, "published": 3, "date": "1683217538", "time_retrieved": "2024-07-30T17:57:36.245936", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 1.5453);\n}\n\n\nfloat perlin(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 colorVariation(vec2 coord, float time) {\n    // Generate Perlin noise based on the coordinate and time\n    float noiseValue = perlin(coord * 1.0 + time * 1.0);\n\n    // Map the noise value to a color offset\n    vec3 colorOffset = vec3(\n        sin(noiseValue * 120.0) * 12.95 + 0.0905,\n        cos(noiseValue * 10.0) / 2.9095 + 0.0905,\n        sin(noiseValue*12.0) * 0.9395 + 0.01025\n    );\n\n    return colorOffset;\n}\n\n\nfloat avg(vec4 color) {\n    float displacement = (color.r/color.r*color.r)*sin(iTime/2.);\n    // Threshold to determine if the displacement is minimal\n    float threshold = 0.5;\n\n    // Return 0 if the displacement is below the threshold, otherwise return the calculated displacement\n    return (abs(displacement) < threshold) ? 0.0 : displacement;\n}\n\n// New function to create pixelated texture coordinates\nvec2 pixelate(vec2 coord, float pixelSize) {\n    return floor(coord * pixelSize) / pixelSize;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy);\n\n    // Pixelation factor (higher values for more pixelation)\n    float pixelationFactor = sin(iTime) + sin(iTime / 8.0) * 256.0;\n    \n    \n    // Use pixelated texture coordinates for displacement\n    vec2 pixelatedCoord = pixelate(uv, pixelationFactor);\n    \n    // Create displacement vector\n    vec4 displace = texture(iChannel1, vec2(pixelatedCoord));\n    \n    \n    displace.rg *= vec2(cos(iTime + pixelatedCoord.y * cos(iTime/2.0)*12.0) * 0.5 + 0.5, sin(iTime + pixelatedCoord.y * 10.0) * 0.5 + 0.5);\n\n    // Datamosh effect\n    float displaceFactor = .92125 + sin(iTime);\n    vec2 datamoshUV = uv + displace.rg / displaceFactor;\n\n    vec4 datamosh = texture(iChannel0, datamoshUV);\n    vec4 newColor = vec4(datamosh.rgb + colorVariation(datamosh.rg, iTime), 1.0);\n    fragColor = newColor;\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 1.5453);\n}\n\n\nfloat perlin(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat avg(vec4 color) {\n    float displacement = (color.r/color.r*color.r)*sin(iTime/2.);\n     // Threshold to determine if the displacement is minimal\n    float threshold = 0.011125;\n\n    // Return 0 if the displacement is below the threshold, otherwise return the calculated displacement\n    return (abs(displacement) < threshold) ? 0.0 : displacement;\n}\n\n\n// New function to create pixelated texture coordinates\nvec2 pixelate(vec2 coord, float pixelSize) {\n    return floor(coord * pixelSize) / pixelSize;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    float drunk = 0.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec2 normalizedCoord = mod((fragCoord.xy + vec2(0, drunk)) / iResolution.xy, 1.0);\n    \n    // Mirror the UV coordinates at the top and bottom\n    vec2 mirroredUV = vec2(uv.x, 1.0 - abs(uv.y * 2.0 - 1.0));\n\n    // Pixelation factor (higher values for more pixelation)\n    float pixelationFactor = cos(iTime)+sin(iTime/4.0)*512.0;\n\n    // Use pixelated texture coordinates for displacement\n    vec2 pixelatedCoord = pixelate(normalizedCoord, pixelationFactor);\n    vec4 displace = texture(iChannel1, vec2(pixelatedCoord));\n    \n    //datamosh effect\n    float displaceFactor = 0.2;\n    vec2 datamoshUV = uv + displace.gr * displaceFactor;\n    \n    // Background image\n    vec4 background = texture(iChannel0, vec2(uv.y, uv.y));\n    vec4 background2 = texture(iChannel1, vec2(uv.x, uv.y - avg(displace*12.)));\n       \n    vec4 datamosh = texture(iChannel0, datamoshUV);\n    // Output to screen\n   // fragColor = (displace)*.01 * background + background2;\n    fragColor = datamosh;\n}\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtt3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 83], [86, 86, 107, 107, 316], [318, 318, 363, 425, 739], [742, 742, 765, 765, 1092], [1094, 1150, 1194, 1194, 1245], [1248, 1248, 1303, 1353, 2196]]}
{"id": "dtt3DS", "name": "Two Grid Traversal w/ 1Pass DoF", "author": "gelami", "description": "Ray-traversal of two grids of primitives in a single traversal loop\nwith a single-pass depth of field, also an implementation of FXAA 3.11\n\nMouse drag to look around", "tags": ["3d", "raytracing", "grid", "dof", "bokeh", "box", "aa", "fxaa"], "likes": 44, "viewed": 832, "published": 3, "date": "1683167067", "time_retrieved": "2024-07-30T17:57:37.229307", "image_code": "\n// Single Pass Depth of Field\n// https://www.shadertoy.com/view/dtt3DS\n\n/* \n * Ray-traversal of two grids of primitives in a single traversal loop\n * with a single-pass depth of field, also an implementation of FXAA 3.11\n * \n * Mouse drag to look around\n * \n * Buffer A: Scene\n * Buffer B: FXAA 3.11\n * Buffer C: Single-Pass Depth of Field \n *\n * The two grids are done by traversing the rectangular prism grid normally\n * And when the ray steps into a new cell in the sphere grid,\n * if there is a hit from the previous cell, then there is an intersection on the sphere\n * if not then it only then intersects the sphere grid on that cell\n * \n * Ray differentials were used to calculate the texture gradients\n * for texture filtering of the reflections\n * \n * The single-pass depth of field method and scene is based from:\n * https://blog.voxagon.se/2018/05/04/bokeh-depth-of-field-in-single-pass.html\n * \n * For a change, anti-aliasing only uses FXAA 3.11 based on these tutorials:\n * http://blog.simonrodriguez.fr/articles/2016/07/implementing_fxaa.html\n * https://catlikecoding.com/unity/tutorials/custom-srp/fxaa/\n * \n * Additional resources:\n * \n * FXAA 3.11 source code copy\n * https://gist.github.com/kosua20/0c506b81b3812ac900048059d2383126\n * \n * FXAA 3.9 implementation\n * https://github.com/AmplifyCreations/FXAA/blob/master/Assets/FXAA/Shaders/Fxaa3_9.cginc\n * \n * Ray differentials for reflections formula from:\n * https://graphics.stanford.edu/papers/trd/\n * \n * Shape operator of a sphere:\n * https://jhavaldar.github.io/assets/2017-07-16-diffgeo-notes5.pdf\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef DOF\n    vec3 col = texture(iChannel2, uv).rgb;\n    #else\n    vec3 col = texture(iChannel1, uv).rgb;\n    #endif\n    \n    col = col / (1.0 + col);\n    \n    col = mix(col, smoothstep(vec3(0), vec3(1), col), 0.5);\n    col = linearTosRGB(col);\n    \n    fragColor = vec4(col, 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Defines\n\n#define FXAA\n#define DOF\n\n#define FOG\n#define FOG_STRENGTH 0.002\n#define FOG_START 25.0\n\n#define DOF_CAMERA_Z\n\n#define ROUNDED\n#define RADIUS 0.04\n\n//#define MOTION\n\n#define BOX_SIZE vec2(1, 1.5)\n#define SPHERE_PERIOD vec2(5)\n#define SPHERE_RADIUS 1.0\n#define SPHERE_HEIGHT 5.0\n\n#define MIN_HEIGHT (3.0*RADIUS)\n#define MAX_HEIGHT 8.0\n\n#define STEPS 256\n#define MAX_DIST 150.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\nstruct HitInfo\n{\n    float t;\n    vec3 n;\n    vec2 tp;\n    int type;\n};\n\n// Sphere ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphereIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    if (b > 0.0 && c > 0.0) return vec2(MAX_DIST);\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(MAX_DIST); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// Rounded box ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 pos, in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 s = vec3(sign(pos.x), 1, sign(pos.z));\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n    \n    // Faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return 0.0;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    float t = MAX_DIST;\n    \n    // Corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b*b - c;\n        if( h>0.0 ) t = - b -sqrt(h);\n    }\n    \n    vec3 a = dd.yzx + dd.zxy;\n    vec3 b = od.yzx + od.zxy;\n    vec3 c = oo.yzx + oo.zxy - ra2;\n    vec3 h = b*b - a*c;\n    \n    // Edge X\n    if( h.x>0.0 )\n    {\n        float ht = (-b.x - sqrt(h.x)) / a.x;\n        if( ht>0.0 && ht<t && abs(ro.x+rd.x*ht)<size.x ) t = ht;\n    }\n    \n    // Edge Y\n    if( h.y>0.0 )\n    {\n        float ht = (-b.y - sqrt(h.y)) / a.y;\n        if( ht>0.0 && ht<t && abs(ro.y+rd.y*ht)<size.y ) t = ht;\n    }\n    \n    // Edge Z\n    if( h.z>0.0 )\n    {\n        float ht = (-b.z - sqrt(h.z)) / a.z;\n        if( ht>0.0 && ht<t && abs(ro.z+rd.z*ht)<size.z ) t = ht;\n    }\n    \n    return t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nfloat luminance(vec3 col) { return dot(col, vec3(0.2126729, 0.7151522, 0.0721750)); }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (vec3(1, 1, 1) * t + vec3(0, .33, .67)));\n}\n\nvec3 palette2(float t)\n{\n    return vec3(0.6, 0.4, 0.4) + 0.4 * vec3(1, 0.3, 0.3) * cos(TAU * (vec3(1) * t + vec3(0, 0.25, 0.75)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "\n// Scene\n\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-02 21:17:35\n\nfloat map(vec2 p)\n{\n    float h = texture(iChannel0, (p*1.0 - vec2(-4.0, 1.0)) / iChannelResolution[0].xy).r;\n    \n    h = smoothstep(0.52, 0.8, h);\n    //float h = pow(hash12(p), 12.0)*0.8+0.1;\n    \n    #ifdef MOTION\n    h = h*0.8+0.1;\n    h += sin((iTime*0.5 + texture(iChannel0, p / iChannelResolution[0].xy).g) * TAU)*h*0.1;\n    //h += getPillarMotion(p, iTime);\n    #endif\n    \n    //float h = hash12(p * 0.033);\n    return clamp(h * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\n\n\nvec4 debug = vec4(-1);\nbool trace(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    if ((ro.y > MAX_HEIGHT && rd.y > 0.0) || (ro.y < MIN_HEIGHT && rd.y < 0.0))\n        return false;\n    \n    const vec2 s = BOX_SIZE;\n    const vec2 s2 = s * 0.5;\n    \n    vec2 tp = floor(ro.xz / s);\n    \n    const vec2 sps = SPHERE_PERIOD;\n    const vec2 sps2 = sps * 0.5;\n    const float srad = SPHERE_RADIUS;\n    const float spy = SPHERE_HEIGHT;\n    \n    vec2 spp = vec2(1e5);\n    vec2 sp = floor(ro.xz / sps);\n    bool sphit = false;\n    float st = MAX_DIST;\n    \n    //if (ro.y < map(tp))\n    //    return true;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(rd);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = (ro - vec3(s2.x, 0, s2.y)) * ird;\n    \n    float tmin = MAX_DIST;\n    hit.t = MAX_DIST;\n    hit.n = vec3(-1);\n    \n    int i = 0;\n    for (; i < STEPS; i++)\n    {\n        #if 1\n        if (spp != sp)\n        {\n            if (sphit)\n            {\n                hit.t = st;\n                vec3 pos = ro + rd * hit.t;\n                hit.n = normalize(pos - vec3((spp.x + 0.5) * sps.x, spy, (spp.y + 0.5) * sps.y));\n                hit.tp = spp;\n                hit.type = 1;\n                return true;\n            }\n            \n            vec3 ce = vec3((sp.x + 0.5) * sps.x, spy, (sp.y + 0.5) * sps.y);\n            vec2 spt = sphereIntersect(ro, rd, ce, srad);\n            if (spt.x < 0.0)\n            {\n                /*\n                hit.t = spt.y;\n                hit.n = normalize(ro + rd * spt.y - ce);\n                hit.tp = sp;\n                hit.type = 1;*/\n                return true;\n            }\n            if (spt.x < MAX_DIST)\n            {\n                st = spt.x;\n                sphit = true;\n            }\n            spp = sp;\n        }\n        #endif\n        \n        float d = map(tp) * 0.5;\n        \n        vec3 p = vec3(tp.x * s.x, d, tp.y * s.y);\n        vec3 bs = vec3(s2.x, d, s2.y);\n        vec3 n = iro - p * ird;\n        vec3 k = ard * bs;\n        \n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        \n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 pos = ro + rd * tN;\n        \n        if (tN < st && pos.y > MAX_HEIGHT && rd.y > 0.0)\n            return false;\n        \n        if (tN < st && tN >= MAX_DIST)\n            return false;\n        \n        if (tN < st && tN < tF && tN >= 0.0)\n        {\n            #ifndef ROUNDED\n            hit.t = tN;\n            hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n            hit.tp = tp;\n            hit.type = 0;\n            return true;\n            \n            #else\n            \n            const float rad = RADIUS;\n            \n            /*\n            if (d*2.0 < MIN_HEIGHT)\n            {\n                hit.t = tN;\n                hit.n = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n                hit.tp = tp;\n                hit.type = 0;\n                return true;\n            }*/\n            \n            vec3 o = p + vec3(s2.x, 0, s2.y);\n            vec3 rp = ro - o;\n            float rt = roundedboxIntersect(pos - o, rp, rd, bs-rad, rad);\n                \n            if (rt != MAX_DIST)\n            {\n                hit.t = rt == 0.0 ? tN : rt;\n                vec3 pos = rp + rd * hit.t;\n                hit.n = normalize(roundedboxNormal(pos, bs-rad, rad));\n                hit.tp = tp;\n                hit.type = 0;\n                return true;\n            }\n            \n            if (ro.y + rd.y * min(t2.x, t2.z) < 0.0)\n            {\n                hit.t = -ro.y * ird.y;\n                hit.n = vec3(0, 1, 0);\n                hit.tp = vec2(0);\n                hit.type = 2;\n                return true;\n            }\n            #endif\n        }\n        \n        tp += step(t2.xz, t2.zx) * srd.xz;\n        sp = floor(tp * s / sps);\n        \n    }\n    return false;\n}\n\nvec3 invReinhard(vec3 color, float exposure)\n{\n    return color / (exposure * max((1.0 - color) / exposure, 1e-3));\n}\n\nvec3 getSky(vec3 rd)\n{\n    vec3 sky = sRGBToLinear(texture(iChannel3, rd).rgb);\n    \n    sky = invReinhard(sky, 400.0);\n    \n    return sky;\n}\n\nvec3 getSky(vec3 rd, vec3 rdDx, vec3 rdDy)\n{\n    vec3 sky = sRGBToLinear(textureGrad(iChannel3, rd, rdDx, rdDy).rgb);\n    \n    sky = invReinhard(sky, 400.0);\n    \n    return sky;\n}\n\nvec3 shade(vec3 pos, HitInfo hit, vec3 ldir, vec3 rd)\n{\n    vec3 col = vec3(0);\n    vec3 alb = palette2(hash12(hit.tp));\n    vec3 skyCol = vec3(1, 0.5, 0.4);\n    \n    HitInfo hitL;\n    bool isHitL = trace(pos + ldir * hit.t*EPS, ldir, hitL);\n    \n    vec3 ref = reflect(rd, hit.n);\n    \n    float dif = max(dot(hit.n, ldir), 0.0) * float(!isHitL);\n    float bou = max(dot(ref, -ldir), 0.0);\n    float ao = smoothstep(0.0, MAX_HEIGHT*0.6, pos.y);\n    \n    col += alb * (dif * 0.9 + 0.1);\n    col += alb * bou * 0.08;\n    col += skyCol * 0.1 * ao;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 ndcDx = (2. * (fragCoord + vec2(1, 0)) - iResolution.xy) / iResolution.y;\n    vec2 ndcDy = (2. * (fragCoord + vec2(0, 1)) - iResolution.xy) / iResolution.y;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, 16);\n    vec3 lo = vec3(0.2 * iTime, 2, 0.8 * iTime);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = -PI * .7 - iTime * 0.16;\n    float ay = PI * 0.2;\n    \n    if (iMouse.z > 0.0)\n    {\n        if (iMouse.x != 0.0) ax = -m.x * TAU + PI;\n        if (iMouse.y != 0.0) ay = m.y * PI * 0.5 + PI * 0.5;\n    }\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    float tanFov = 2.0;\n    vec3 rd = normalize(cmat * vec3(ndc, tanFov));\n    vec3 rdDx = normalize(cmat * vec3(ndcDx, tanFov));\n    vec3 rdDy = normalize(cmat * vec3(ndcDy, tanFov));\n\n    HitInfo hit;\n    bool isHit = trace(ro, rd, hit);\n\n    float t = hit.t;\n    vec3 n = hit.n;\n    vec2 tp = hit.tp;\n    \n    vec3 col = vec3(0);\n    vec3 alb = palette2(hash12(hit.tp));\n    vec3 skyCol = vec3(1, 0.5, 0.4);\n    //skyCol = vec3(0.5, 0.8, 1);\n    \n    vec3 ldir = normalize(vec3(0.8, 2, 1.2));\n    \n    vec3 pos = ro + rd * t + n * EPS;\n    vec3 posDx = ro - rdDx * dot(ro - pos, n) / dot(rdDx, n);\n    vec3 posDy = ro - rdDy * dot(ro - pos, n) / dot(rdDy, n);\n    \n    vec3 nDx = hit.type == 1 ? (posDx - pos) : vec3(0);\n    vec3 nDy = hit.type == 1 ? (posDy - pos) : vec3(0);\n    \n    if (hit.type == 0)\n    {\n        float d = map(hit.tp) * 0.5;\n        vec3 bpos = pos - vec3((hit.tp + 0.5) * BOX_SIZE, d).xzy;\n        bpos = abs(bpos);\n\n        vec3 size = vec3(BOX_SIZE.x * 0.5, d, BOX_SIZE.y * 0.5) - RADIUS;\n        bpos -= size;\n\n        vec3 bmpos = max( bpos.xyz, bpos.yzx );\n\n        if( min(min(bmpos.x, bmpos.y), bmpos.z) < 0.0 )\n        {\n            nDx = vec3(0);\n            nDy = vec3(0);\n        } else if (all(greaterThan(bpos, vec3(0))))\n        {\n            nDx = (posDx - pos) / RADIUS;\n            nDy = (posDy - pos) / RADIUS;\n        } else\n        {\n            vec3 bm = 1.0 - step(bpos, bpos.yzx) * step(bpos, bpos.zxy);\n            \n            nDx = (posDx - pos) * bm / RADIUS;\n            nDy = (posDy - pos) * bm / RADIUS;\n        }\n    }\n    \n    vec3 ref = reflect(rd, n);\n    vec3 refDx = (rdDx - rd) - 2.0 * (dot(rd, n) * nDx + (dot(rdDx - rd, n) + dot(rd, nDx)) * n);\n    vec3 refDy = (rdDy - rd) - 2.0 * (dot(rd, n) * nDy + (dot(rdDy - rd, n) + dot(rd, nDy)) * n);\n    \n    col = shade(pos, hit, ldir, rd);\n    \n    HitInfo hitR;\n    bool isHitR = trace(pos, ref, hitR);\n    \n    vec3 refPos = pos + ref * hitR.t + hitR.n * EPS;\n    vec3 refCol = shade(refPos, hitR, ldir, ref);\n    \n    if (!isHitR)\n    {\n        #if 1\n        refCol = getSky(ref, refDx, refDy);\n        #else\n        refCol = getSky(ref);\n        #endif\n    }\n    \n    vec3 r0 = hit.type == 1 ? alb : vec3(0.08);\n    vec3 fre = r0 + (1.0 - r0) * pow(1.0 - dot(-rd, n), 5.0);\n    \n    col = mix(col, refCol, fre);\n    \n    //if (hit.type == 1) col = refCol;\n    \n    #ifdef FOG\n    vec3 fog = 1.0 - exp(-max(t - FOG_START, 0.0) * skyCol * FOG_STRENGTH);\n    col = col * (1.0 - fog) + vec3(1, 0.7, 0.5) * fog;\n    #endif\n    \n    if (!isHit)\n    {\n        col = getSky(rd);\n        t = MAX_DIST;\n    }\n    \n    col = max(col, vec3(0));\n    #ifdef FXAA\n    col = col / (1. + col);\n    col = linearTosRGB(col);\n    #endif\n    \n    #ifdef DOF_CAMERA_Z\n    t = t * dot(rd, cmat[2]);\n    #endif\n    \n    fragColor = vec4(col, t);\n    \n    if (debug != vec4(-1))\n        fragColor = debug;\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// FXAA\n\n// FXAA Defines\n// Trims the algorithm from processing darks.\n//   0.0833 - upper limit (default, the start of visible unfiltered edges)\n//   0.0625 - high quality (faster)\n//   0.0312 - visible limit (slower)\n#define FXAA_THRESHOLD_MIN 0.0312\n\n// The minimum amount of local contrast required to apply algorithm.\n//   0.333 - too little (faster)\n//   0.250 - low quality\n//   0.166 - default\n//   0.125 - high quality \n//   0.063 - overkill (slower)\n#define FXAA_THRESHOLD_MAX 0.063\n\n// This can effect sharpness.\n//   1.00 - upper limit (softer)\n//   0.75 - default amount of filtering\n//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n//   0.25 - almost off\n//   0.00 - completely off\n#define FXAA_SUBPIXEL_QUALITY 1.0\n\n// Assumed to be in perceptual/gamma-encoded space\nfloat luma(vec3 col)\n{\n    //return dot(col, vec3(0.2126729, 0.7151522, 0.0721750));\n    return dot(col, vec3(0.299, 0.587, 0.114));\n    return sqrt(dot(col, vec3(0.299, 0.587, 0.114)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 px = 1.0 / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    #ifndef FXAA\n    fragColor = col;\n    #else\n    float lumaCenter = luma(col.rgb);\n    float lumaUp    = luma(texture(iChannel0, uv + vec2(0, px.y)).rgb);\n    float lumaDown  = luma(texture(iChannel0, uv - vec2(0, px.y)).rgb);\n    float lumaLeft  = luma(texture(iChannel0, uv - vec2(px.x, 0)).rgb);\n    float lumaRight = luma(texture(iChannel0, uv + vec2(px.x, 0)).rgb);\n\n    float lumaMin = min(min(min(lumaUp, lumaDown), min(lumaLeft, lumaRight)), lumaCenter);\n    float lumaMax = max(max(max(lumaUp, lumaDown), max(lumaLeft, lumaRight)), lumaCenter);\n\n    float lumaRange = lumaMax - lumaMin;\n\n    if (lumaRange < max(FXAA_THRESHOLD_MIN, lumaMax * FXAA_THRESHOLD_MAX))\n    {\n        col.rgb = sRGBToLinear(col.rgb);\n        col.rgb = col.rgb / (1.0 - col.rgb);\n    \n        fragColor = col;\n        return;\n    }\n    \n    float lumaDownLeft  = luma(texture(iChannel0, uv - vec2(px.x, px.y)).rgb);\n    float lumaUpRight   = luma(texture(iChannel0, uv + vec2(px.x, px.y)).rgb);\n    float lumaDownRight = luma(texture(iChannel0, uv + vec2(px.x, -px.y)).rgb);\n    float lumaUpLeft    = luma(texture(iChannel0, uv + vec2(-px.x, px.y)).rgb);\n    \n    float lumaDownUp = lumaDown + lumaUp;\n    float lumaLeftRight = lumaLeft + lumaRight;\n    \n    float lumaCornerDown = lumaDownRight + lumaDownLeft;\n    float lumaCornerUp = lumaUpRight + lumaUpLeft;\n    float lumaCornerLeft = lumaDownLeft + lumaUpLeft;\n    float lumaCornerRight = lumaDownRight + lumaUpRight;\n\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaCornerLeft) +\n                           abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 +\n                           abs(-2.0 * lumaRight + lumaCornerRight);\n    \n    float edgeVertical   = abs(-2.0 * lumaUp + lumaCornerUp) +\n                           abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 +\n                           abs(-2.0 * lumaDown + lumaCornerDown);\n\n    bool isEdgeHorizontal = edgeHorizontal >= edgeVertical;\n\n    float luma0 = isEdgeHorizontal ? lumaDown : lumaLeft;\n    float luma1 = isEdgeHorizontal ? lumaUp : lumaRight;\n    \n    float grad0 = abs(luma0 - lumaCenter);\n    float grad1 = abs(luma1 - lumaCenter);\n\n    bool gradStep = grad0 >= grad1;\n    \n    float gradScaled = 0.25 * max(grad0, grad1);\n    \n    float stepSize = isEdgeHorizontal ? px.y : px.x;\n    stepSize = gradStep ? -stepSize : stepSize;\n    \n    float lumaLocalAvg = 0.5 * ((gradStep ? luma0 : luma1) + lumaCenter);\n\n    vec2 curUV = uv;\n    \n    if (isEdgeHorizontal)\n        curUV.y += stepSize * 0.5;\n    else\n        curUV.x += stepSize * 0.5;\n    \n    vec2 stepOffset = isEdgeHorizontal ? vec2(px.x, 0) : vec2(0, px.y);\n    \n    vec2 uv0 = curUV - stepOffset;\n    vec2 uv1 = curUV + stepOffset;\n    \n    float lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n    float lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n    \n    bool reached0 = abs(lumaEnd0) >= gradScaled;\n    bool reached1 = abs(lumaEnd1) >= gradScaled;\n    \n    if (!reached0) uv0 -= stepOffset;\n    if (!reached1) uv1 += stepOffset;\n    \n    if (!(reached0 && reached1))\n    {\n        #define ITERATIONS 12\n        const float QUALITY[ITERATIONS] = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0, 8.0);\n        for (int i = 2; i < ITERATIONS; i++)\n        {\n            if (!reached0)\n            {\n                lumaEnd0 = luma(texture(iChannel0, uv0).rgb) - lumaLocalAvg;\n            }\n            if (!reached1)\n            {\n                lumaEnd1 = luma(texture(iChannel0, uv1).rgb) - lumaLocalAvg;\n            }\n            \n            reached0 = abs(lumaEnd0) >= gradScaled;\n            reached1 = abs(lumaEnd1) >= gradScaled;\n            \n            if (!reached0) uv0 -= stepOffset * QUALITY[i];\n            if (!reached1) uv1 += stepOffset * QUALITY[i];\n            \n            if (reached0 && reached1) break;\n        }\n    }\n    \n    float distance0 = isEdgeHorizontal ? (uv.x - uv0.x) : (uv.y - uv0.y);\n    float distance1 = isEdgeHorizontal ? (uv1.x - uv.x) : (uv1.y - uv.y);\n    \n    float lumaDist = distance0 < distance1 ? lumaEnd0 : lumaEnd1;\n    \n    float pixelOffset = -min(distance0, distance1) / (distance0 + distance1) + 0.5;\n    \n    bool correctVar = lumaCenter < lumaLocalAvg != lumaDist < 0.0;\n    \n    float finalOffset = correctVar ? pixelOffset : 0.0;\n    \n    float lumaAvg = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaCornerLeft + lumaCornerRight);\n    \n    float subpixelOffset = smoothstep(0.0, 1.0, abs(lumaAvg - lumaCenter) / lumaRange);\n    subpixelOffset = subpixelOffset * subpixelOffset * FXAA_SUBPIXEL_QUALITY;\n    \n    finalOffset = max(finalOffset, subpixelOffset);\n    \n    vec2 finalUV = uv;\n    \n    if (isEdgeHorizontal)\n        finalUV.y += stepSize * finalOffset;\n    else\n        finalUV.x += stepSize * finalOffset;\n    \n    vec3 fcol = texture(iChannel0, finalUV).rgb;\n    \n    fcol = sRGBToLinear(fcol);\n    fcol = fcol / (1.0 - fcol);\n    \n    fragColor = vec4(fcol, col.a);\n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// Depth of Field\n\n// DoF Defines\n#define DOF_FOCUS_DIST 16.0\n\n#define DOF_RADIUS 24.0\n#define DOF_FOCUS_SCALE 8.0\n\n#define RADIUS_SCALE 1.\n\n//#define DOF_USE_LOD\n#define DOF_MAX_LOD 4.0\n\n#define DOF_STEPS 32\n\n#define GOLDEN_ANGLE 2.39996323\n\nfloat getCoc(float t, float focalDist, float scale)\n{\n    return saturate(abs(1.0 / focalDist - 1.0 / t) * scale) * DOF_RADIUS;\n}\n\nvec3 depthOfField(sampler2D tex, vec2 uv)\n{\n    float ct = texture(tex, uv).a;\n    // Auto-focus (doesn't work T_T)\n    //float fd = texture(tex, vec2(0.5)).a;\n    float fd = DOF_FOCUS_DIST;\n    \n    float cs = getCoc(ct, fd, DOF_FOCUS_SCALE);\n    \n    #ifdef DOF_USE_LOD\n    vec3 color = textureLod(tex, uv, DOF_MAX_LOD * cs / DOF_RADIUS).rgb;\n    #else\n    vec3 color = texture(tex, uv).rgb;\n    #endif\n    \n    vec2 px = 1.0 / iResolution.xy;\n    float w = 1.0;\n    float radStep = DOF_RADIUS / float(DOF_STEPS);\n    float rad = radStep * 0.5;\n    float ang = 0.0;\n    \n    for (int i = 0; i < DOF_STEPS; i++)\n    {\n        vec2 p = uv + vec2(cos(ang), sin(ang)) * rad * px;\n        #ifdef DOF_USE_LOD\n        vec4 sampCol = textureLod(tex, p, DOF_MAX_LOD * rad / DOF_RADIUS);\n        #else\n        vec4 sampCol = texture(tex, p);\n        #endif\n        \n        float ss = getCoc(sampCol.a, DOF_FOCUS_DIST, DOF_FOCUS_SCALE);\n        \n        if (sampCol.a > ct)\n            ss = clamp(ss, 0.0, cs * 2.0);\n        \n        float m = smoothstep(rad - 0.5, rad + 0.5, ss);\n\n        color += mix(color / w, sampCol.rgb, m);\n        ang += GOLDEN_ANGLE;\n        rad += radStep / rad;\n        w += 1.0;\n    }\n    \n    return color / w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef FXAA\n    vec3 col = depthOfField(iChannel1, uv);\n    #else\n    vec3 col = depthOfField(iChannel1, uv);\n    #endif\n    //col = col / (1.0 + col);\n    //col = linearTosRGB(col);\n    \n    fragColor = vec4(col, 1);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtt3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1583, 1583, 1640, 1640, 2047]]}
{"id": "dttGWj", "name": "Rotation 3D ~ traditional", "author": "Dirk", "description": "A simple Quaternion Rotation Demo.\nThis example is for beginners who dare to brave quaternions.", "tags": ["3d", "simple", "basic", "rotate", "easy", "quaternion", "matrix", "rotation", "spin", "beginners"], "likes": 4, "viewed": 199, "published": 3, "date": "1683161967", "time_retrieved": "2024-07-30T17:57:37.994261", "image_code": "\n\n    // Rotation 3D ( Quanternions for Beginners )\n    // by Dirk Stockton\n    \n\n    // USE THESE THREE FUNCTIONS...\n\n    vec4 quanternionMul(vec4 q1, vec4 q2) {\n        vec3 crossProduct = cross(q1.xyz, q2.xyz);\n        float dotProduct = dot(q1.xyz, q2.xyz);\n        return vec4(crossProduct + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dotProduct);\n    }\n    \n    vec4 quanternionRot(vec3 axis, float angle) {\n        float halfAngle = angle * 0.5;\n        float s = sin(halfAngle);\n        return vec4(axis * s, cos(halfAngle));\n    }\n    \n    vec3 rotate3D(vec3 p, vec3 axis, float angle) {\n        vec4 quat = quanternionRot(normalize(axis), angle);\n        return quanternionMul(quanternionMul(quat, vec4(p, 0.0)), vec4(-quat.xyz, quat.w)).xyz;\n    }\n    \n    \n    // ...TO ROTATE THE POSITION OF AN OBJECT LIKE BOX()...\n    \n    float box( vec3 p, vec3 b ){\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float map( vec3 p ){\n    \n        p = rotate3D( p, vec3(1, 1, 0), iTime ); // ...BY USING THIS LINE OF CODE :P \n        \n        //  rotate3D( p, axis, angle )\n        \n        //  p     = The position to be rotated\n        //  axis  = The Axis(xyz) to be rotated, 0=off 1=on\n        //  angle = The magnitude of the rotation\n        \n        float d = box(p,vec3(.25));\n        return d;\n    }\n    \n    //   Standard RayMarch   //\n    //                       //\n    //   | | | | | | | | |   //\n    //   v v v v v v v v v   //\n    \n    #define e vec2(0.0,0.001)\n    \n    vec3 calcNormal( vec3 p ){\n        return normalize( vec3( map(p+e.xyy)-map(p-e.xyy),\n                                map(p+e.yxy)-map(p-e.yxy),\n                                map(p+e.yyx)-map(p-e.yyx) ));\n    }\n    float castRay( vec3 ro, vec3 rd ){\n        float t = 0.;\n        for( int i=0; i<100; i++ ){\n            vec3 p = ro+rd*t;\n            float d = map(p);\n            if(abs(d)<e.y) break;\n            t+=d;\n            if(d>20.0) break;\n        }\n        if(t>20.0) t=-1.;\n        return t;\n    }\n    void mainImage( out vec4 O, in vec2 U ){\n        vec2  uv = (2.*U-iResolution.xy)/iResolution.y;\n        vec3  ro = vec3(0.,0.,1.5);\n        vec3  rd = normalize( vec3(uv,-1.5) );\n        float t = castRay(ro,rd);\n        vec3  col = vec3(0.);\n        if(t>0.0){\n            vec3  pos = ro+rd*t;\n            vec3  nor = calcNormal(pos);\n            vec3  dir = normalize(vec3(2.,1.,3.4));\n            float dif = dot(nor,dir);\n            col += dif;\n        }\n        col *= 1.3;\n        O = vec4(col,0.);\n    }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dttGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 162, 162, 354], [364, 364, 409, 409, 535], [545, 545, 592, 592, 754], [834, 834, 862, 862, 965], [975, 975, 995, 995, 1369], [1547, 1547, 1573, 1573, 1759], [1764, 1764, 1798, 1798, 2058], [2063, 2063, 2103, 2103, 2575]]}
{"id": "mtt3Dj", "name": "Disco snowflake", "author": "bronna", "description": "Based on https://thebookofshaders.com/07/", "tags": ["blackandwhite", "rotating", "snowflake"], "likes": 2, "viewed": 169, "published": 3, "date": "1683158667", "time_retrieved": "2024-07-30T17:57:38.849974", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the normalized pixel coordinates\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.x;\n\n    vec3 color = vec3( 0.0 );\n\n    vec2 pos = uv;\n    \n    float t = iTime * 0.3;\n\n    float rad = length( pos ) * 2.0;\n    float ang = atan( pos.y, pos.x );\n\n    float shape = step( 0.0, cos( (ang + t) * 10.0 ) ) * 0.2 + 0.5;\n    \n    // add cutouts\n    float cutouts = abs( cos( (ang - t) * 3.0 ) ) * 0.2 + 0.2;\n    shape = max(shape - cutouts, 0.0);\n\n    color = vec3( 1.0 - step( shape, rad ) );\n\n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtt3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 617]]}
{"id": "cdV3Rc", "name": "Dream Island", "author": "VPaltoDance", "description": "Hacky, but alive.", "tags": ["procedural", "noise", "waves", "terrain", "raymarch", "sea", "lighting", "island"], "likes": 42, "viewed": 866, "published": 3, "date": "1683144948", "time_retrieved": "2024-07-30T17:57:41.962651", "image_code": "// water based on https://www.shadertoy.com/view/Ms2SD1\n\nfloat water_octave(vec2 uv) \n{\n    uv += value_noise(uv) * 2.0 - 1.0;        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),2.0);\n}\n\n// leave only big waves for geometry calculation\nfloat water_geom(vec2 uv)\n{\n    float freq = WATER_FREQ * 5.832;\n    float amplitude = WATER_HEIGHT * 0.02;\n    float time = WATER_TIME;\n    uv *= octave_m_3;\n    \n    return WATER_LEVEL_HEIGHT + (water_octave((uv+time)*freq) + water_octave((uv-time)*freq))* amplitude;\n}\n\n// for detailed per-fragment appearance use more octaves\nfloat water_detailed(vec2 uv)\n{\n    float freq = WATER_FREQ * 3.24;\n    float amplitude = WATER_HEIGHT *0.0625;\n    float height = WATER_LEVEL_HEIGHT; \n    float time = WATER_TIME;\n    uv *= octave_m_2;\n    \n    for(int i = 0; i < 3; i++) \n    {        \n        height += (water_octave((uv+time)*freq) + water_octave((uv-time)*freq))* amplitude;\n        \n    \tuv *= octave_m; freq *= 1.8; amplitude *= 0.25;\n    }\n    \n    return height;\n}\n\n\nbool map(vec3 ray, inout float t, inout int material_idx)\n{\n    float delta_w_terrain = ray.y - terrain(ray.xz);\n    float delta_w_water = ray.y - water_geom(ray.xz);\n    \n    if(abs(delta_w_terrain) < ERROR) { material_idx = 0; return true; }\n    if(abs(delta_w_water) < ERROR) {material_idx = 1; return true;}\n    \n    \n    float step_mul = min(delta_w_water, delta_w_terrain);\n    t += step_mul * 0.2;\n    \n    return false;\n}\n\nvec3 get_sky_color(vec3 rd)\n{\n    return SKY_LIGHT;\n}\n\nvec3 water_color(vec3 normal, vec3 pos, vec3 rd)\n{\n    // calibrate fresnel - we want some pattern even at high view angels\n    if(rd.y < -0.5)\n        rd.y = -0.5;\n    \n   \tfloat fresnel = pow( 1.0-clamp(dot(-rd, normal), 0.0, 1.0), 5.0);\n            \n    return fresnel*SKY_LIGHT + 0.8 * MAIN_BLUE ;\n}\n\n// doing normals\nvec3 calc_normal(float center, float dhdx, float dhdz, float eps)\n{\n    return normalize(vec3(center - dhdx, eps, center - dhdz));\n}\n\nvec3 get_normal(in vec3 p, float t, int mat)\n{\n    float eps = 0.001 * t;\n    \n    if(mat == 0)\n    {\n        return calc_normal(terrain(p.xz), terrain(vec2(p.x+eps, p.z)), terrain(vec2(p.x, p.z+eps)), eps);\n    }\n    else if(mat == 1) \n    {\n        return calc_normal(water_detailed(p.xz), water_detailed(vec2(p.x+eps, p.z)), water_detailed(vec2(p.x, p.z+eps)), eps);\n    }\n    \n    return vec3(1.0, 0.0, 1.0);\n}\n\n// super-hacky shadows\nfloat test_shadow( vec3 ray_origin, vec3 ray_direction)\n{\n    \n    vec2 box_intersect = box_intersection(ray_origin, ray_direction, BOX);\n    \n    float res = 1.0;\n    \n    if(box_intersect.x > 0.0\n        || (ray_origin.x < 1.0 && ray_origin.x > -1.0 &&  \n            ray_origin.y < BOX.y && \n            ray_origin.z < 1.0 && ray_origin.z > -1.0))\n    {\n        float t = box_intersect.x > 0.0 ? box_intersect.x : 0.02;\n        for (int i = 0; i < MAX_ITER; i++)\n        {\n            vec3 ray = ray_origin + t*ray_direction;\n            float delta_w_terrain = ray.y - terrain(ray.xz );\n            if (delta_w_terrain < ERROR)\n            {\n                return clamp(ray.y * ray.y * t * t * 1.5, clamp(t, 0.0, 0.3), 1.0 );\n            }\n            \n            t += delta_w_terrain * 0.4 + 0.001;\n            if(t > box_intersect.y || ray.y > BOX.y) return 1.0;\n        }\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\n// main material function for water and terrain\nvec3 material_calc(vec3 pos, vec3 ray_direction, vec3 normal, float t, int mat_type)\n{\n    vec3 col;\n    vec3 light_dir = -normalize(LIGHT_DIR);\n    \n    float sun_shadow = test_shadow(pos, light_dir);\n    if(mat_type == TERRAIN_MATERIAL)\n    {\n        float sun_diffuse = clamp(dot(normal, light_dir), 0.0, 1.0);\n        float sky_diffuse = sqrt(clamp(0.5 + 0.5 * normal.y, 0.0, 1.0 ));\n        float ind_diffuse = clamp( 0.2 + 0.8*dot( normalize( vec3(-light_dir.x, 0.0, light_dir.z ) ), normal ), 0.0, 1.0 );\n\n        float mid = pos.y - WATER_LEVEL_HEIGHT * 0.5;\n        vec3 colmain = mix(MAIN_GREEN, MAIN_BROWN, smoothstep(0.2,0.9,fract(mid)) );\n        colmain *= 1.0-0.6*smoothstep(0.31,0.8,pos.y);\n          \n        if(abs(pos.y - WATER_LEVEL_HEIGHT) < 0.04) colmain = SAND_COLOR;\n        \n        col = LIGHT_COL *sun_diffuse *sun_shadow + SKY_LIGHT * sky_diffuse;\n        col += ind_diffuse * vec3(0.45,0.35,0.25) + (get_sky_color(normal) + MAIN_BLUE)*0.12 ;\n        col *= colmain; \n        \n        vec3 hal = normalize(light_dir-ray_direction);\n        \n        col += (0.5)*(0.04+0.96*pow(clamp(1.0+dot(hal,ray_direction),0.0,1.0),5.0))*\n               vec3(7.0,6.0,5.0)*sun_diffuse*sun_shadow*\n               pow( clamp(dot(normal,hal), 0.0, 1.0),16.0);\n    }\n    else if(mat_type == WATER_MATERIAL)\n    {\n        float x = terrain(pos.xz);\n        float delta = abs(pos.y - x) * 0.5;\n        \n        float atten = smoothstep(1.0,0.99,length(pos.xz));\n        vec3 depth_layer1 =  atten*vec3(0.0, 0.2, 0.4);\n               \n        \n        col = water_color(normal, pos, ray_direction);\n        \n        \n        col *= (1.0 + 1.3 * smoothstep(0.11, 0.0, delta));\n        \n        float sh = float(clamp(abs(value_noise(pos.xz * 12.0 + iTime*0.1)), 0.0, 1.0)> 0.5);\n        col += 0.4 * smoothstep(0.35, 1.0, \n                sh * sin(delta * 200.0 + iTime * 1.5)\n                * smoothstep(1.5, 1.45, length(pos.xz))\n                * smoothstep(0.07, 0.02, delta));\n        \n        col = mix(0.3 * col, col, sun_shadow);\n    }\n    else\n    {\n        col = vec3(1.0, 0.0, 1.0); // Debug for missing some parts with no material\n    }\n    \n    \n   float fo = 1.0 - exp(-pow(0.1 * t, 1.5) );\n   vec3 fco = 0.25 * (MAIN_BLUE + get_sky_color(normal))*vec3(0.2, 0.33, 0.5);\n   col = mix( col, fco, fo );\n   \n   col += rainbow(ray_direction);\n   \n   return col;\n}\n\n\nvec3 Render(in vec3 ray_origin, in vec3 ray_direction)\n{\n    vec2 box_intersect = box_intersection(ray_origin, ray_direction, BOX);\n    float water_dist = ( WATER_LEVEL_HEIGHT * 2.0 - ray_origin.y) / ray_direction.y;\n    \n    int material_idx = WATER_MATERIAL;\n    \n    float t = box_intersect.x > 0.0 ? box_intersect.x : water_dist;\n    vec3 ray = ray_origin + ray_direction * t;\n    \n    for(int i = 0; i < MAX_ITER; ++i)\n    {\n        if(map(ray, t, material_idx)) break;\n        \n        ray = ray_origin + ray_direction * t;\n    }\n    \n    vec3 normal = get_normal(ray, t, material_idx);\n    vec3 col = material_calc(ray, ray_direction, normal, t, material_idx);  \n    return col;\n}\n\n// Post-processing from some of Inigo Quilez shaders\nvoid psot_process(inout vec3 in_color, vec2 q, vec2 sp, float aspect)\n{\t\n    in_color += smoothstep(1.0, 0.0, length(sp)) * LIGHT_COL * 0.003;\n    \n    // Color grading\n    in_color = in_color * vec3(1.11,0.89,0.79);\n    \n    // Compress\n    in_color = 1.35*in_color/(1.0+in_color);\n    \n    // Gamma\n    in_color = pow( in_color, vec3(0.454545) );\n    \n    // S-surve\n    //color = clamp(color,0.0,1.0);\n    in_color = in_color*in_color*(3.0-2.0*in_color);\n    \n    // Vignette\n    in_color *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec3 view_target = vec3(0.0, 0.1, 0.0);\n    vec3 cam_pos = vec3( 0.0,1.288,-0.96);\n    mat3 cam_mat = set_camera(cam_pos, view_target); \n    \n    vec3 color = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = (-0.5 + vec2(float(m),float(n)) / float(AA)) * 2.0/ iResolution.y;\n        vec3 view_dir = cam_mat * normalize(vec3(p + o,1.5));\n\t#else    \n        vec3 view_dir = cam_mat * normalize(vec3(p,1.5));\n\t#endif\n    \n        color += Render(cam_pos, view_dir);\n    \n\t#if AA>1\n    }\n    color /= float(AA*AA);\n\t#endif\n    \n    // Do the post-processing\n    psot_process(color, fragCoord/iResolution.xy, p, aspect);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// math\n#define PI 3.14159265\n#define PI_D_2 1.5707963267\n// parameters\n#define WATER_LEVEL_HEIGHT 0.21\n#define TERRAIN_OCTAVE_NUM 8\n#define MAX_ITER 64\n\n// error to be used for float operations\n#define ERROR 0.02\n\n// AABB of the island for ray marching optimization\n#define BOX vec3(1.0, 0.7, 1.0)\n\n\n// main colors use for material appearance\n#define MAIN_GREEN vec3(0.035, 0.08, 0.02)\n#define MAIN_BLUE vec3(0.0, 0.15, 0.35)\n#define MAIN_BROWN vec3(0.4,0.2,0.05)\n#define SAND_COLOR vec3(0.256, 0.16, 0.04)\n\n// light parameters\n#define LIGHT_DIR vec3(0.1, -0.2, 1.0)\n#define LIGHT_COL vec3(8.10,6.00,4.20)\n#define SKY_LIGHT vec3(0.4, 0.7, 1.2)\n\n// water parameters\n#define WATER_HEIGHT 0.36\n#define WATER_SPEED 0.4\n#define WATER_FREQ 0.16\n#define WATER_TIME iTime * WATER_SPEED\n\n// material ids\n#define WATER_MATERIAL 1\n#define TERRAIN_MATERIAL 0\n\nconst mat2 octave_m   = mat2(1.6,1.2,-1.2,1.6);\nconst mat2 octave_m_2 = mat2(1.12,3.84,-3.84,1.12); // octave_m * octave_m\nconst mat2 octave_m_3 = mat2(-2.816,7.488,-7.488,-2.816); // octave_m * octave_m * octave_m\n\n// super-sampling parameter for AA\n#define AA 1\n\n// a hack for webgl compiler to not unroll the loop\n#define ZERO (min(iFrame,0))\n\n// rotation matrix for octaves\nconst mat2 terrain_octave_rot = mat2(0.75471,-0.65606,0.65606,0.75470);\n\nfloat hash13(vec2 p2)\n{\n    vec3 p3 = vec3(fract(p2 * .1031), .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat value_noise( in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 u = smoothstep(0.0, 1.0, fract(p));    \n    \n    float res = mix(mix( hash13(i),             \n                         hash13(i + vec2(1,0)),u.x),\n                    mix( hash13(i + vec2(0,1)), \n                         hash13(i + vec2(1,1)),u.x),u.y);\n    return res;\n}\n\n// a terrain pattern of first (OCTAVE_NUM / 2) octaves\nfloat terrain_raw_height( in vec2 p)\n{\n    float amplitude = 1.0;\n\tfloat height = 0.0;\n    vec2 rot_coords = p;\n\tfor (int i = 0; i < TERRAIN_OCTAVE_NUM / 2; ++i)\n\t{\n\t\theight += amplitude * value_noise(rot_coords);\n\t\tamplitude *= 0.45;\n\t\trot_coords = 2.0 * terrain_octave_rot * rot_coords;\n\t}\n    \n    return height;\n    \n}\n\n// the actual terrain heightmap, downscaled at the edges the bounding box to make the actual island form\nfloat terrain( in vec2 p)\n{\n    // calculating major low-freq octaves\n    float amplitude = 1.0;\n\tfloat octaves = 0.0;\n    vec2 rot_coords = p;\n\tfor (int i = 0; i < TERRAIN_OCTAVE_NUM / 2; i++)\n\t{\n\t\toctaves += amplitude * value_noise(rot_coords);\n\t\tamplitude *= 0.45;\n\t\trot_coords = 2.0 * terrain_octave_rot * rot_coords;\n\t}\n    \n    // downscale them to get the island pattern\n    float height = (octaves - 1.0) * (1.5 - smoothstep(0.8, 1.0, length(p)));\n    \n    // calculating minor high-freq octaves \n    octaves = .0;\n\tfor (int i = TERRAIN_OCTAVE_NUM / 2; i < TERRAIN_OCTAVE_NUM; i++)\n\t{\n\t\toctaves += amplitude * value_noise(rot_coords);\n\t\tamplitude *= 0.45;\n\t\trot_coords = 2.0 * terrain_octave_rot * rot_coords;\n\t}\n    \n    // adding them without any scale\n    height += 2.0 * octaves;\n\t\n    // making shure the underwater surface fades smoothly with distance from the center\n    float dist = length(p);\n    return dist > 1.0 ? max(0.0, height) * (2.0 - dist * dist) : height;\n}\n\nvec3 rainbow(vec3 ray_dir) \n{\n    \n    vec3 rainbow_dir = normalize(vec3(0.0, -1.0, 0.7));\n    float angle = degrees(acos(4.0*dot(rainbow_dir, ray_dir) - 2.35));\n\n    const float intensity = 0.15;\n\t\n\tvec3 color_angles = vec3(50.0, 53.0, 56.0);\t// angle for red, green and blue\n    vec3 spectre_color = clamp(1.0 - abs((color_angles - angle) * 0.2), 0.0, 1.0);\n    \n    vec3 spectre_color_2 = spectre_color * spectre_color;    \n    vec3 spectre_color_3 = spectre_color_2 * spectre_color;\n\tvec3 color = (3.0 * spectre_color_2 - 2.0 * spectre_color_3) * intensity;\n    \n    return color  *  smoothstep(-0.6, -0.5, ray_dir.y);\n}\n\n\nmat3 set_camera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cf = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cf,up) );\n\tvec3 cv = normalize( cross(cu,cf) );\n    return mat3( cu, cv, cf );\n}\n\n// Box intersection by Inigo Quilez https://iquilezles.org/articles/boxfunctions\n\nvec2 box_intersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    \n    return vec2( tN, tF );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdV3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 87, 87, 273], [275, 324, 351, 351, 595], [597, 654, 685, 685, 1093], [1096, 1096, 1155, 1155, 1525], [1527, 1527, 1556, 1556, 1580], [1582, 1582, 1632, 1705, 1885], [1887, 1904, 1971, 1971, 2036], [2038, 2038, 2084, 2084, 2452], [2454, 2477, 2534, 2534, 3404], [3406, 3454, 3540, 3540, 5833], [5836, 5836, 5892, 5892, 6523], [6525, 6578, 6649, 6649, 7133]]}
{"id": "ctt3W2", "name": "ASCII art donut", "author": "Sumsar86", "description": "ASCII art shader applied to a rotating donut rendered using ray marching.", "tags": ["raymarching", "ascii", "donut", "asciiart", "doughnut"], "likes": 6, "viewed": 280, "published": 3, "date": "1683137679", "time_retrieved": "2024-07-30T17:57:43.215302", "image_code": "#define getDisplayPos(pos,scale) PrintPosition((fragCoord-pos*iResolution.xy)/(scale*1920.0),pos,iResolution.xy,scale);\n#define WriteWord(word, style, p, font_tex, color)\\\n\tfor(int i = 0; i < word.length(); i++)\\\n        writeChar(word[i], style, 1.0, 0.0, p, font_tex, color);\n\nconst int\t_=32,                         // https://www.shadertoy.com/view/MdycDK\n\t\t\t_SHARP=35,\t\t// #\n\t\t\t_PERCENT=37,\t// %\n\t\t\t_ASTERISK=42,\t// *\n\t\t\t_PLUS=43,\t\t// +\n\t\t\t_MINUS=45,\t\t// -\n\t\t\t_DOT=46,\t\t// .\n    \t\t_COLON=58,\t\t// :\n    \t\t_EQ=61,\t\t\t// =\n    \t\t_AT=64;\t\t\t// @\n\nconst int[] gradient = int[](_AT, _PERCENT, _SHARP, _ASTERISK, _PLUS, _EQ, _MINUS, _COLON, _DOT, _);// @%#*+=-:. \n\nstruct PrintPosition\n{\n    vec2 uv,\n         pos,\n         R;\n    float scale;\n};\n\nstruct PrintStyle\n{\n    vec3 char_color,\n         outline_color;\n    float outline_size;\n};\n\nvoid writeChar(int char, PrintStyle style, float w, float x_offset, inout PrintPosition p, sampler2D font_tex, inout vec3 color)\n{\n    \t#define getFont(uv,char) texture(font_tex, (uv+vec2(char%16,15-char/16))/16.0)\n\t\tvec2 uv = p.uv;\n    \tuv.x += x_offset;\n    \tfloat outline_size = style.outline_size;\n    \tif(uv.x>0. && uv.x<w && uv.y>0. && uv.y<1.){\n            // We are inside the bbox, display the char\n            color = mix(color,style.outline_color,smoothstep(0.,-1./p.R.y,getFont(uv,char).a - outline_size-.5));\n            color = mix(color,style.char_color, getFont(uv,char).r);\n        }\n\t\tuv.x -= w; // move uv for next char\n    \tp.uv = uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\n    float downScaleValue = 20.0 * (2.0 * iResolution.x / 1920.0);\n    float scale = 1.0 / 1600.0 * downScaleValue;\n\n    vec4 color = vec4(0.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 newFragCoord = floor(fragCoord / downScaleValue) * downScaleValue;\n    vec2 newUV = newFragCoord / iResolution.xy;\n\n    color = texelFetch(iChannel0, ivec2(newUV * iResolution.xy), 0);\n\n    \n    PrintPosition p;\n\n    p = getDisplayPos(newFragCoord / iResolution.xy, scale);\n\n    PrintStyle white_out_black = PrintStyle(color.xyz + (vec3(1.0) - color.xyz) * 0.4, vec3(0.0), 1.0);\n\n    int index = 9 - int(color.x * 10.0);\n    int[] char = int[](gradient[index]);\n    WriteWord(char, white_out_black, p, iChannel1, fragColor.xyz);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define WHITE vec3(1.0)\n#define BLACK vec3(0.0)\n\n\nstruct Torus\n{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n};\n\nTorus t1 = Torus(normalize(vec3(1.0, 0.5, 0.0)), vec3(0.0), 2.0, 1.0);\n\nvec3 lightPos = vec3(2.0, -5.0, 3.0);\n\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c, 0, s, \n        0, 1, 0, \n        -s, 0, c\n    );\n}\n\nfloat torusSDF(in vec3 p)\n{\n    vec3 relativePos = p - t1.pos;\n    vec3 relPosProj = t1.r * normalize(relativePos - t1.dir * dot(relativePos, t1.dir));\n    return length(relPosProj - relativePos) - t1.s;\n}\n\nvec3 calculateNormal(in vec3 pos)\n{\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = torusSDF(pos + smallStep.xyy) - torusSDF(pos - smallStep.xyy);\n    float gradientY = torusSDF(pos + smallStep.yxy) - torusSDF(pos - smallStep.yxy);\n    float gradientZ = torusSDF(pos + smallStep.yyx) - torusSDF(pos - smallStep.yyx);\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nvec3 rayMarch(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float totalDistTraveled = 0.0;\n    const int NUMBER_OF_STEPS = 256;\n    const float MINIMUM_HIT_DIST = 0.001;\n    const float MAXIMUM_TRACE_DIST = 10.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 currentPos = rayOrigin + totalDistTraveled * rayDir;\n        float smallestDist = torusSDF(currentPos);\n        \n        if (smallestDist <= MINIMUM_HIT_DIST)\n        {\n            vec3 normal = calculateNormal(currentPos);\n            vec3 lightDir = normalize(currentPos - lightPos);\n            \n            float diffuseIntensity = max(0.05, dot(normal, lightDir));\n            \n            return vec3(1.0) * diffuseIntensity;\n        }\n            \n        if (totalDistTraveled >= MAXIMUM_TRACE_DIST)\n            break;\n            \n        totalDistTraveled += smallestDist;\n    }\n    \n    return BLACK;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // convert from (0 to 1) to (-1 to 1)\n    uv = uv * 2.0 - 1.0;\n    // rescale\n    uv.x *= iResolution.x / iResolution.y;\n    \n    t1.dir *= rotateY(-iTime * 0.2);\n\n    vec3 rOrigin = vec3(0.0, 0.0, -5.0);\n    vec3 rDir = vec3(uv, 1.0);\n    vec3 col = rayMarch(rOrigin, rDir);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctt3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[837, 837, 967, 967, 1493]]}
{"id": "DltGW2", "name": "Shaded Gasket", "author": "dr2", "description": "Apollonian Gasket / Soddy Circles with color and bump-mapping (mouseable)", "tags": ["apollonian", "bumpmap", "gasket", "soddy"], "likes": 27, "viewed": 267, "published": 3, "date": "1683137000", "time_retrieved": "2024-07-30T17:57:44.308379", "image_code": "// \"Shaded Gasket\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Based on fizzer's \"Apollonian Gasket Möbius\" (WtdSDf); this method\n  provides disk coordinates and radii, but not iteration counts for the\n  disks shown.\n  \n  A simpler version is mla's (e.g.) \"Colourful Apollonian III\" (wdsfWX);\n  this uses colors based on iteration counts, but not proper coordinates\n  for the disks shown (note how the shading can vary inside each disk).\n  \n  Since both quantities are used here - for combining normal-based bump\n  mapping with different disk colors, disk radius (log) is used as a\n  proxy for the iteration count.\n \n  See \"Indra's Pearls\" for lots of info, but only the simplest color\n  renderings appear in the book.\n  \n  The Möbius code has been reformulated.\n*/\n\n#define AA  1 // (= 0/1)\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\n#define N_CIRC  3  // odd value (>= 3)\n\nvec3 limCirc[N_CIRC + 1], invCirc[N_CIRC + 1], ltDir;\nvec2 sAzEl;\nconst int maxIt = 64;\nconst float pi = 3.1415927;\n\nstruct Mob {\n  vec2 a, b, c, d;\n};\n\nvec2 CMul (vec2 a1, vec2 a2)\n{\n  return vec2 (a1.x * a2.x - a1.y * a2.y, a1.x * a2.y + a1.y * a2.x);\n}\n\nvec2 CConj (vec2 a)\n{\n  return vec2 (a.x, - a.y);\n}\n\nfloat CModSq (vec2 a)\n{\n  return a.x * a.x + a.y * a.y;\n}\n\nvec2 CDiv (vec2 a1, vec2 a2)\n{\n  return CMul (a1, CConj (a2)) / CModSq (a2);\n}\n\nvec2 MobOp (Mob m, vec2 z)\n{\n  return CDiv (CMul (z, m.a) + m.b, CMul (z, m.c) + m.d);\n}\n\nMob MobInv (Mob m)\n{\n  return Mob (m.d, - m.b, - m.c, m.a);\n}\n\nMob MobProd (Mob m1, Mob m2)\n{\n  return Mob (CMul (m1.a, m2.a) + CMul (m1.b, m2.c), CMul (m1.a, m2.b) + CMul (m1.b, m2.d),\n     CMul (m1.c, m2.a) + CMul (m1.d, m2.c), CMul (m1.c, m2.b) + CMul (m1.d, m2.d));\n}\n\nvec3 MobToCirc (Mob m, vec3 c)\n{\n  vec2 z;\n  z = MobOp (m, c.xy - CDiv (vec2 (c.z * c.z, 0.), CConj (c.xy + CDiv (m.d, m.c))));\n  return vec3 (z, length (z - MobOp (m, c.xy + vec2 (c.z, 0.))));\n}\n\nMob CircToMob (vec3 c)\n{\n  Mob m;\n  m = Mob (vec2 (c.z, 0.), c.xy, vec2 (0.), vec2 (1., 0.));\n  return MobProd (MobProd (m, Mob (vec2 (0.), vec2 (1., 0.), vec2 (1., 0.), vec2 (0.))),\n     Mob (m.d, m.b * vec2 (-1., 1.), m.c, m.a));\n}\n\nvoid CircInit ()\n{\n  float a, r, rs;\n  a = pi / float (N_CIRC);\n  r = 1. / cos (a);\n  rs = sqrt (r * r - 1.);\n  for (int j = 0; j < N_CIRC; j ++) {\n    limCirc[j] = vec3 (sin (2. * a * float (j) - vec2 (0.5 * pi, 0.)) * r, rs) * (r - rs);\n    invCirc[j] = vec3 (sin (2. * a * float (j) + vec2 (0.5 * pi, 0.)) * r, rs);\n  }\n  limCirc[N_CIRC] = vec3 (0., 0., 1.);\n  invCirc[N_CIRC] = vec3 (0., 0., r - rs);\n}\n\n#define DDOT(x) dot ((x), (x))\n\nvec4 PCirc (vec2 p, vec2 pm)\n{\n  Mob mm, m;\n  vec3 g, gi, w;\n  vec2 z, cm;\n  float eps;\n  bool done;\n  eps = 1e-9;\n  CircInit ();\n  z = p;\n  mm = Mob (vec2 (1., 0.), vec2 (0.), vec2 (0.), vec2 (1., 0.));\n  if (DDOT (pm) > 0.0005 && DDOT (pm) < 1.) {\n    cm = pm * vec2 (-1., 1.) / DDOT (pm);\n    m = CircToMob (vec3 (cm, sqrt (DDOT (cm) - 1.)));\n    z = MobOp (m, z);\n    mm = MobProd (m, mm);\n  }\n  for (int it = VAR_ZERO; it < maxIt; it ++) {\n    done = true;\n    for (int j = 0; j <= N_CIRC; j ++) {\n      gi = invCirc[j];\n      if (DDOT (z - gi.xy * vec2 (1., -1.)) < gi.z * gi.z) {\n        g = gi;\n        done = false;\n        break;\n      }\n    }\n    if (! done) {\n      if (g.x == 0.) g.x = eps;\n      m = CircToMob (g);\n      z = MobOp (m, z);\n      mm = MobProd (m, mm);\n    } else break;\n  }\n  mm = MobInv (mm);\n  if (CModSq (mm.c) == 0.) mm.c = vec2 (eps, 0.);\n  w.z = 1.;\n  for (int j = 0; j <= N_CIRC; j ++) {\n    g = MobToCirc (mm, limCirc[j]);\n    if (g.z > 0. && g.z < 1.) {\n      w.xy = (p - g.xy) / g.z;\n      w.z = DDOT (w.xy);\n      if (w.z < 1.) break;\n    }\n  }\n  return vec4 (w, g.z);\n}\n\nvec3 BgCol (vec3 v)\n{\n  vec4 col4;\n  vec3 u, c;\n  vec2 f;\n  v.xz = Rot2D (v.xz, sAzEl.x);\n  v.xy = Rot2D (v.xy, sAzEl.y);\n  col4 = vec4 (0.);\n  for (int ky = -1; ky <= 1; ky ++) {\n    for (int kx = -1; kx <= 1; kx ++) {\n      u = v;\n      f = 0.0025 * vec2 (kx, ky);\n      u.yz = Rot2D (u.yz, f.y);\n      u.xz = Rot2D (u.xz, f.x);\n      c = vec3 (1. - Minv2 (smoothstep (0.03, 0.05, abs (fract (16. *  vec2 (atan (u.z, - u.x),\n         asin (u.y)) / pi) - 0.5)))) * (0.6 + 0.4 * u.y);\n      col4 += vec4 (min (c, 1.), 1.) * (1. - 0.15 * dot (f, f));\n    }\n  }\n  return col4.rgb / col4.a;\n}\n\nvec3 Color (vec2 p, vec2 pm)\n{\n  vec4 p4;\n  vec3 col, vn;\n  float nDotL;\n  p4 = PCirc (p.yx, pm.yx);\n  col = vec3 (0.);\n  if (p4.z < 1.) {\n    vn = vec3 (p4.xy, sqrt (1. - p4.z)).xzy;\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = HsvToRgb (vec3 (fract (0.75 - 0.9 * log2 (p4.w) / log2 (float (maxIt))), 1., 1.));\n    col = col * (0.2 +  0.8 * nDotL * nDotL) + vec3 (0.2) * pow (max (dot (ltDir,\n       reflect (vec3 (0., -1., 0.), vn)), 0.), 64.);\n    col = mix (col, BgCol (vn), 0.3);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, uvv, pm;\n  float tCur, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (abs (uv.x) < 1.) {\n    sAzEl = vec2 (0.2 * pi * tCur, 0.1 * pi);\n    ltDir = vec3 (0., 1., 0.);\n    ltDir.xy = Rot2D (ltDir.xy, 0.2 * pi);\n    ltDir.xz = Rot2D (ltDir.xz, -0.7 * pi);\n    pm = (mPtr.z > 0. && Maxv2 (abs (mPtr.xy * canvas)) < 0.5 * canvas.y) ? mPtr.xy : vec2 (0.);\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      if (length (uvv) < 1.) col += (1. / naa) * Color (1.05 * uvv, pm);\n    }\n  } else col = vec3 (0.82);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DltGW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1205, 1205, 1235, 1235, 1307], [1309, 1309, 1330, 1330, 1360], [1362, 1362, 1385, 1385, 1419], [1421, 1421, 1451, 1451, 1499], [1501, 1501, 1529, 1529, 1589], [1591, 1591, 1611, 1611, 1652], [1654, 1654, 1684, 1684, 1862], [1864, 1864, 1896, 1896, 2059], [2061, 2061, 2085, 2085, 2294], [2296, 2296, 2314, 2314, 2702], [2736, 2736, 2766, 2766, 3846], [3848, 3848, 3869, 3869, 4437], [4439, 4439, 4469, 4469, 4963], [4965, 4965, 5018, 5018, 6021], [6023, 6023, 6045, 6045, 6072], [6074, 6074, 6096, 6096, 6123], [6125, 6125, 6155, 6155, 6268], [6270, 6270, 6294, 6294, 6416]]}
{"id": "Dlt3Dj", "name": "Elevated Contours", "author": "SnoopethDuckDuck", "description": "All of the important code came from the fork, I just played around with it :)", "tags": ["parallax"], "likes": 25, "viewed": 308, "published": 3, "date": "1683135827", "time_retrieved": "2024-07-30T17:57:45.260833", "image_code": "#define pi 3.14159\n#define res iResolution.xy\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec4 qMult(vec4 qa, vec4 qb) {\n    vec3 v = cross( qa.xyz, qb.xyz ) + (qa.xyz * qb.w) + (qb.xyz * qa.w);\n    float scalar = qa.w * qb.w - dot(qa.xyz, qb.xyz);\n    return vec4(v, scalar);\n}\n\nvec4 qFromAxisAngle(vec3 axisNorm, float angle) {\n    float halfAngle = angle * 0.5;\n    return vec4(axisNorm * sin(halfAngle), cos(halfAngle));\n}\n    \nvec4 qFromEuler(vec3 rot) {\n    vec4 qx = qFromAxisAngle(vec3(1,0,0), rot.x);\n    vec4 qy = qFromAxisAngle(vec3(0,1,0), rot.y);\n    vec4 qz = qFromAxisAngle(vec3(0,0,1), rot.z);\n    vec4 q = qMult(qx, qy);\n    return qMult(q, qz);\n}\n\nvec3 qRot(vec3 v, vec4 q) {\n\treturn v + 2. * cross(cross(v, q.xyz) + q.w * v, q.xyz);\n}\n\nfloat getSlice(vec2 uv) {\n    float r  = texture(iChannel1, 0.5*uv).r; \n    float r2 = texture(iChannel2, uv).r;\n    float r3 = texture(iChannel3, 0.5*uv).r;\n    float t = mod(0.12 * iTime, 3.);\n    float ft = smoothstep(0.4, 0.6, fract(t));\n    if (t < 1.) r = mix(r, r2, ft);\n    else if (t < 2.) r = mix(r2, r3, ft);\n    else if (t < 3.) r = mix(r3, r, ft);\n    //r = mix(r, r2, 0.5 + 0.5 * thc(20., uv.x+uv.y + 0.2*iTime));\n    return smoothstep(0., 1., r);\n}\n\nvec2 getNormal(vec2 uv) {\n    vec2 e = vec2(1./res.y, 0);\n    vec2 n = vec2(getSlice(uv-e.xy), getSlice(uv-e.yx));\n    return (getSlice(uv) - n);\n}\n\nvoid mainImage( out vec4 O, in vec2 px ) \n{    \n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 ouv = uv;\n    vec2 ms = iMouse.xy;  \n    \n    float rotX = ms.y / res.y - 1.;\n    float rotZ = 0.5 - ms.x / res.x;\n    rotX = -0.15 + 0.07 * thc(4., 0.32 * iTime);//0.3 * cos(0.7 * iTime) - 0.5;\n    rotZ = 0.08 * sin(0.4 * iTime) - 0.;\n    vec3 rot = pi * vec3(rotX, 0, rotZ);\n\n    vec4 quat = qFromEuler(rot);  \n   \n    vec3 camScene = vec3(0, 0.15, -1);\n    vec3 dirScene = normalize(vec3(uv, 1.2+0.1*cos(0.32*iTime))); // (uv, zoom)\n    \n    vec3 cam = qRot(camScene, quat);\n   \n    vec3 dir = qRot(dirScene, quat);\n    float aDir = atan(uv.y, uv.x);//atan(dir.y, dir.x);\n    \n    float depth = 0.3;\n  \n    float d = -cam.y / dir.y;\n    uv = (dir.xz * d + cam.xz) + 0.5;\n   \n    vec3 bg = vec3(1,0.96,0.98);\n    vec3 col = vec3(0);\n    \n    if (d > 0.) {\n    \tfloat alphaBudget = 1.4;\n        \n        float n = 36.; // 255.; // Big!!\n        for (float i = 0.; i < n; i++) {            \n\t\t\tfloat io = i / n;\n            \n            vec3 dirNorm = normalize(dir);\n            dirNorm.xz /= dir.y;\n\n\t\t\tvec2 uv2 = uv + dirNorm.xz * io * depth;\n            uv2 = mix(uv, uv2, .5-.5*thc(4.,iTime+2.*pi*io));\n            uv2 +=  vec2(0.5 * thc(2.,0.32 * iTime), .32 * iTime);\n            \n            float slice = getSlice(0.28 * uv2);\n            slice = round(slice * n) / n;\n            \n            // Use normal for lighting\n            vec2 normal = getNormal(0.28 * uv2);\n            float aNorm = atan(normal.y, normal.x);\n            \n            float v = abs(io - slice);\n            //float alpha = step(v, 0.001);           \n            float alpha = smoothstep(0.03, 0., v);\n            alpha = mix(alpha, min(alpha, alphaBudget), 0.75);\n            alpha = max(alpha, 0.); // clamp won't work if alphaBudget < 0.\n\n            vec3 tx = texture(iChannel0, 0.5 * uv2).rgb;            \n            tx *= 5. * bg * tx;\n            tx *= .85-.3*cos(aNorm);\n            col += (0.1 + 0.9 * smoothstep(0.,1.,slice)) * tx * alpha;\n            //col *= 1. / cosh(-0.03 * length(uv2 - 0.5));\n            alphaBudget -= 0.6*alpha;  //alpha;         \n        }    \n        col = mix(bg, col, exp(-0.4*d));\n    } else\n        col = bg;\n    \n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlt3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 117, 117, 275], [277, 277, 326, 326, 423], [429, 429, 456, 456, 661], [663, 663, 690, 690, 750], [752, 752, 777, 777, 1215], [1217, 1217, 1242, 1242, 1364], [1366, 1366, 1409, 1409, 3629]]}
{"id": "Dtd3Wj", "name": "Ripple distortion - no texture", "author": "pfuerte", "description": "implementation of three.js tutorial \nhttps://www.youtube.com/watch?v=WZWgOCoHUSE&list=PLFky-gauhF452rW98W4cyZ8_2fXBjfGOT&index=5&ab_channel=NikLever", "tags": ["distortion", "shockwave", "ripple"], "likes": 3, "viewed": 210, "published": 3, "date": "1683130881", "time_retrieved": "2024-07-30T17:57:46.418737", "image_code": "// Implmentation of ripple effect by Nik Lever\n//https://www.youtube.com/watch?v=WZWgOCoHUSE&list=PLFky-gauhF452rW98W4cyZ8_2fXBjfGOT&index=5&ab_channel=NikLever\nconst float u_duration = .8;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 coord = fragCoord.xy/iResolution.xy;\n    vec2 v_position = coord;\n    float len = length(v_position.xy-.5);\n\n    vec2 ripple = coord + v_position.xy / len* 0.03*cos(len*10.0-iTime*5.0);\n    float delta = (((sin(iTime)+1.0)/2.0)* u_duration)/u_duration;\n    vec2 uv = mix(ripple, coord, delta);\n    float fx = sin(uv.x*200.)*sin(uv.y*200.);\n    vec3 color = vec3(fx);\n    fragColor = vec4(color, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtd3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 245, 245, 658]]}
{"id": "ml33W2", "name": "shin", "author": "jorge2017a2", "description": "shin, dragon ball", "tags": ["dragonball", "shin"], "likes": 6, "viewed": 133, "published": 3, "date": "1683124381", "time_retrieved": "2024-07-30T17:57:47.246524", "image_code": "///por jorge217a1 ..jorge.f.p\n//shin--dragon ball\n//3-may-2023\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(4.0*antialiasing(1.0),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[9]=vec2[]( \nvec2(2.38,3.26),vec2(2.39,3.12),vec2(2.56,2.64),vec2(2.82,2.49),vec2(2.89,2.49),\nvec2(3.17,2.66),vec2(3.3,3.07),vec2(3.34,3.3),vec2(2.38,3.26)  \n);\n\nfloat sdPoly6I POLY(6)\nvec2 pt6I[6]=vec2[]( \nvec2(2.42,3.06),vec2(2.01,3.22),vec2(1.99,3.18),vec2(2.32,2.8),vec2(2.52,2.74),\nvec2(2.42,3.06)  \n);\n\nfloat sdPoly6D POLY(6)\nvec2 pt6D[6]=vec2[]( \nvec2(3.27,3.04),vec2(3.69,3.23),vec2(3.7,3.2),vec2(3.39,2.81),vec2(3.19,2.74),\nvec2(3.27,3.04)  );\n\n//---Pelo 1,2,3,4,5,6,7\nfloat sdPoly9P1 POLY(9)\nvec2 pt9P1[9]=vec2[]( \nvec2(3.11,3.59),vec2(2.89,3.34),vec2(2.87,3.38),vec2(2.75,3.13),vec2(2.74,2.86),\nvec2(2.57,3.15),vec2(2.62,3.48),vec2(2.79,3.69),vec2(3.11,3.59)  );\n\n\nfloat sdPoly10P2 POLY(10)\nvec2 pt10P2[10]=vec2[]( \nvec2(3.09,3.59),vec2(3.09,3.83),vec2(2.62,4.1),vec2(2.16,3.66),vec2(2.15,2.91),\nvec2(2.33,3.18),vec2(2.63,3.47),vec2(2.85,3.57),vec2(2.96,3.44),vec2(3.09,3.59));\n\nfloat sdPoly9P3 POLY(9)\nvec2 pt9P3[9]=vec2[]( \nvec2(3.09,3.63),vec2(3.14,3.69),vec2(3.16,4.1),vec2(2.67,4.51),vec2(2.32,4.35),\nvec2(1.88,4.04),vec2(2.17,4.01),vec2(2.95,3.47),vec2(3.09,3.63));\n\nfloat sdPoly7P4 POLY(7)\nvec2 pt7P4[7]=vec2[]( \nvec2(3.14,3.67),vec2(3.24,3.99),vec2(3.27,4.19),vec2(2.63,4.77),vec2(2.61,4.5),\nvec2(3.07,3.67),vec2(3.14,3.67));\n\nfloat sdPoly6P5 POLY(6)\nvec2 pt6P5[6]=vec2[]( \nvec2(3.15,3.67),vec2(3.41,3.9),vec2(3.41,4.25),vec2(3.48,4.45),vec2(3.08,4.19),\nvec2(3.15,3.67)  );\n\nfloat sdPoly6P6 POLY(6)\nvec2 pt6P6[6]=vec2[]( \nvec2(3.27,3.52),vec2(3.5,3.7),vec2(3.52,3.92),vec2(3.56,4.01),vec2(3.2,3.65),\nvec2(3.27,3.52));\n\n\nfloat sdPoly6P7 POLY(6)\nvec2 pt6P7[6]=vec2[]( \nvec2(3.29,3.54),vec2(3.46,3.55),vec2(3.59,3.44),vec2(3.47,3.41),vec2(3.32,3.35),\nvec2(3.29,3.54));\n\nfloat sdPoly4CI POLY(4)\nvec2 pt4CI[4]=vec2[]( \nvec2(2.46,3.06),vec2(2.63,2.97),vec2(2.76,2.89),vec2(2.46,3.06));\n\nfloat sdPoly4CD POLY(4)\nvec2 pt4CD[4]=vec2[]( \nvec2(2.95,2.93),vec2(3.12,3.01),vec2(3.23,3.03),vec2(2.95,2.93));\n\nfloat sdPoly5OI POLY(5)\nvec2 pt5OI[5]=vec2[]( \nvec2(2.79,2.82),vec2(2.65,2.92),vec2(2.5,2.93),vec2(2.61,2.83),vec2(2.79,2.82));\n\nfloat sdPoly5OD POLY(5)\nvec2 pt5OD[5]=vec2[]( \nvec2(2.92,2.82),vec2(3.02,2.91),vec2(3.19,2.93),vec2(3.14,2.87),vec2(2.92,2.82));\n\n//boca\nfloat sdPoly4B POLY(4)\nvec2 pt4B[4]=vec2[]( \nvec2(2.79,2.67),vec2(2.85,2.64),vec2(2.93,2.66),vec2(2.79,2.66));\n\n//nariz\nfloat sdPoly5N POLY(5)\nvec2 pt5N[5]=vec2[]( \nvec2(2.81,2.8),vec2(2.79,2.7),vec2(2.83,2.79),vec2(2.92,2.75),vec2(2.81,2.8));\n\n///ropa\nfloat sdPoly17R POLY(17)\nvec2 pt17R[17]=vec2[]( \nvec2(2.59,2.46),vec2(2.33,2.53),vec2(2.02,2.56),vec2(2.24,2.15),vec2(2.31,1.76),\nvec2(2.38,1.7),vec2(2.36,1.41),vec2(2.04,0.49),vec2(3.55,0.47),vec2(3.33,1.34),\nvec2(3.28,1.64),vec2(3.39,1.88),vec2(3.41,2.1),vec2(3.71,2.48),vec2(3.67,2.52),\nvec2(3.16,2.46),vec2(2.59,2.46)  );\n\nvec3 cabezaShin(vec2 p, vec3 col)\n{   float sd9 = sdPoly9(p, pt9);\n    float sd6I = sdPoly6I(p, pt6I);\n    float sd6D = sdPoly6D(p, pt6D);\n    float sd9P1 = sdPoly9P1(p, pt9P1);\n    float sd10P2 = sdPoly10P2(p, pt10P2);\n    float sd9P3 = sdPoly9P3(p, pt9P3);\n    float sd7P4 = sdPoly7P4(p, pt7P4);\n    float sd6P5 = sdPoly6P5(p, pt6P5);\n    float sd6P6 = sdPoly6P6(p, pt6P6);\n    //float sd6P7 = sdPoly6P7(p, pt6P7);\n    float sd4CI = sdPoly4CI(p, pt4CI);\n    float sd4CD = sdPoly4CD(p, pt4CD);\n    float sd5OI = sdPoly5OI(p, pt5OI); //ojo izq\n    float sd5OD = sdPoly5OD(p, pt5OD); //ojo der\n    float sd4B = sdPoly4B(p, pt4B);\n    float sd17R = sdPoly17R(p, pt17R); //Ropa\n      vec2 l1, l2;\n    l1=vec2(2.84,2.8);l2=vec2(2.79,2.7);\n    float dl1= sdSegment(p, l1, l2);\n    l1=vec2(2.9,2.69);l2=vec2(2.78,2.7);\n    float dl2= sdSegment( p, l1, l2);\n   vec2 p1=vec2(2.86,3.32) ;\n   float r1=0.48;\n    float d1= sdCircle(p-p1, r1);\n    float df= unionSDF(sd9, d1);\n    ///------corneas\n    p1=vec2(2.67,2.88); r1=0.05;\n    vec2 p2=vec2(3.02,2.88); float r2=0.05;\n    float dc1= sdCircle(p-p1, r1);\n    float dc2= sdCircle(p-p2, r2);\n    dc1=intersectSDF(sd5OI,dc1 );\n    dc2=intersectSDF(sd5OD,dc2 );\n    col= DrawFigBorde(vec3(.72,.7,.9), col,df );\n    col= DrawFigBorde(vec3(.72,.7,.9), col,sd6I );  //oreja\n    col= DrawFigBorde(vec3(.72,.7,.9), col,sd6D );  //oreja\n    //col= DrawFigBorde(vec3(.86,1.,.94), col,sd6P7); //pelo\n    col= DrawFigBorde(vec3(.86,1.,.94), col,sd6P5);\n    col= DrawFigBorde(vec3(.86,1.,.94), col,sd7P4);\n    col= DrawFigBorde(vec3(.86,1.,.94), col,sd9P3);\n    col= DrawFigBorde(vec3(.86,1.,.94), col,sd10P2 ); //pelo 2\n    col= DrawFigBorde(vec3(.86,1.,.94), col,sd9P1 );  //pelo 1\n    col= DrawFigBorde(vec3(0.0), col,sd4CI);  //ceja izq\n    col= DrawFigBorde(vec3(0.0), col,sd4CD);  //ceja dert\n    col= DrawFigBorde(vec3(1.0), col,sd5OI);  //ojo i\n    col= DrawFigBorde(vec3(1.0), col,sd5OD);  //ojo D\n    col= DrawFigBorde(vec3(0.0), col,sd4B);  //boca\n    //col= DrawFigBorde(vec3(0.0), col,dc1);  //cornea izq\n    col= DrawFigDelgado(vec3(0.0), col, dc1 );\n    //col= DrawFigBorde(vec3(0.0), col,dc2);  //cornea der\n    col= DrawFigDelgado(vec3(0.0), col, dc2 );\n    col= DrawFigBorde(vec3(0.0,0.2,0.8), col,sd17R);  //ropa\n    col= DrawFigBorde(vec3(0.0), col,dl1);  //nariz 1\n    col= DrawFigBorde(vec3(0.0), col,dl2);  //nariz 2\n    \n    //col= DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5); uv*=2.0;\n   vec3 col =mix(vec3(0.56,0.96,0.93),vec3(0.,0.39,0.71),uv.y*0.5);\n    float t=iTime;\n    uv.x=abs(uv.x)+(0.5+0.5*sin(t*2.0))-(1.0+0.5*sin(t));\n    col= cabezaShin(uv-vec2(-2.5,-2.0),col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml33W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 565, 627, 627, 753], [754, 754, 835, 835, 963], [964, 964, 1028, 1028, 1099], [1103, 1103, 1150, 1150, 1177], [1178, 1178, 1221, 1221, 1248], [1249, 1249, 1297, 1297, 1325], [1327, 1327, 1362, 1362, 1385], [1387, 1387, 1439, 1439, 1546], [4338, 4338, 4373, 4373, 6803], [6805, 6805, 6862, 6862, 7235]]}
{"id": "cdVXDd", "name": "spontanious", "author": "jonasfrey", "description": "stuff", "tags": ["stuff"], "likes": 14, "viewed": 233, "published": 3, "date": "1683106460", "time_retrieved": "2024-07-30T17:57:48.025441", "image_code": "#define n_tau 6.2831\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_its = 20.;\n\n    float n_dmax = 0.;\n    vec2 o_fc = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n        float n_it_nor = n_it / n_its;\n        float n_radians = n_it_nor * n_tau;\n        float n_speed = 4.;\n        float n_corners = floor(mod(iTime*(1./(n_tau/n_speed)),9.));//3.;//floor(fract(iTime*0.1)*9.);\n        float n_radius = 0.2+(sin(iTime*n_speed+n_it_nor*n_tau*n_corners+(n_tau/2.))*.5+.5)*0.2; \n        vec2 o_p = vec2(\n            sin(n_radians)*n_radius, \n            cos(n_radians)*n_radius\n        );\n\n        vec2 o_diff = o_fc - o_p;\n        float n_d_1 = length(\n            o_diff*3.\n        );\n\n        float n_d_2 = (max(\n            abs(o_diff.x), abs(o_diff.y)\n        ))*0.5;\n        float n_fact = sin(iTime*n_speed+n_it_nor*n_tau)*.5+.5;\n        float n_d = \n        (1.-n_fact)* n_d_1 + \n        n_fact * n_d_2;\n        \n        // n_d = abs(n_d-(sin(iTime+n_it_nor)*0.5+.5)*0.2);\n        n_d = abs(n_d-(1./n_its/2.));\n        n_d = pow(n_d, 1./3.);\n        n_d = n_d *2.;\n        n_d = 1.- n_d;\n        // n_d = n_d*2.;\n        // n_d = abs(n_d-(sin(iTime)*.5+.5));\n        // n_d = fract(n_d-sin(iTime)*0.5);\n\n        if(n_d > n_dmax){\n            n_dmax = n_d;\n        }\n\n    }\n    fragColor = vec4(n_dmax);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 1390]]}
{"id": "cl33D2", "name": "Broken Rubix Cube Effect (WIP)", "author": "FabriceNeyret2", "description": "WIP\nreference: [url]https://twitter.com/Bbbn192/status/1653070539970183168[/url]\n\nhow would you properly handle a BSP with sphere marching ? \nBeside, the rotation axis are wrong when more than 1 cut (and only last should turn).", "tags": ["raymarching", "bsp", "reproduction"], "likes": 14, "viewed": 317, "published": 3, "date": "1683103364", "time_retrieved": "2024-07-30T17:57:48.772444", "image_code": "\n#define rot2(a)      mat2(cos(a+vec4(0,11,33,0)))\n#define rot(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n#define H(v)         fract(1e4*sin((v)*(R+71.)))\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., T,n = mod(iTime/2.,4.), d, i, c;\n    vec3  R = iResolution, N,\n          D = normalize(vec3(U+U, -12.*R.y) - R), D2=D,D3, // ray direction\n          p = vec3(0,0,20), q,a,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n    D2.yz *= rot2(-M.y),                                   // rotations\n    D2.xz *= rot2(-M.x-1.57);\n    \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 ) {       // march scene\n        q = p, \n        q.yz *= rot2(-M.y),                                // rotations\n        q.xz *= rot2(-M.x-1.57);\n        D3 = D2;\n        t = 9.;\n        for( i=0.; i++ < n; )\n          T = i <= n ? i*2. : (n-(i-1.))*2.,\n          d = dot(q, N = normalize(H(i)-.5) ),             // random cut plane\n          d>0. ? q = rot(q,N,T) : q,                       // rot half-space\n       // t = min(t, abs(d) + .01),                        // slow close to plane for correct stepping through\n          c = - d / dot(D3,N),\n          c>0. ? t = min(t, c+.01) : t,                    // exact dist along ray\n          d>0. ? D3 = rot(D3,N,T) : q;                 \n        a = abs(q),\n        t = min( t,  c = max(a.x, max(a.y,a.z)) - 1. ),    // cube\n        p += .5*t*D;                                       // step forward = dist to obj    \n    }\n    if (t<.01)                                             // color scheme   \n               O = c > 0. \n                    ? p = floor(q+q), t++, \n                      vec4( (.5+.5*mod(p.x+p.y+p.z,2.))    // tiling pattern\n                           * dot(vec3(t==a.x,t==a.y,t==a.z), vec3(.9,.7,.5)) ) // shading\n                    : vec4(.4,0,0,1);                      // cut part in red\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl33D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 209, 209, 1995]]}
{"id": "clc3D2", "name": "Zellij pattern 10", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "carpet", "rug", "zellij"], "likes": 4, "viewed": 148, "published": 3, "date": "1683100529", "time_retrieved": "2024-07-30T17:57:49.683009", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    vec2 uv1 = uv;\n    uv.y = mod(uv.y,.5)+.25;\n    uv.x = mod(uv.x,.5)+.25;\n\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv+t2*sign(uv.y-uv.x))/1.5+sign(uv.x)/2.\n        ;\n        b = uv.y>uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv+.5).yx\n            //triangle_wave(uv+.5).yx*(1.5-mod(floor(uv.y),2.)/2.)\n        ;\n        uv =\n            t2+triangle_wave(uv.yx).yx\n        ;\n        if(uv.y>uv.x)\n        //{t2 = t2.yx; uv=uv.yx;}\n        col.x =\n            abs((uv.x)-col.x)\n            //fract((uv.x)-col.x-iTime/4.)\n        ;\n        \n        //awesome kaleidoscope effect!\n        //if(t2.y>t2.x) {t2 = t2.yx; uv=uv.yx-iTime/8.;}\n        \n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n            //abs(vec3(col.zx,max(uv.y-uv.x,col.y)))\n        ;\n        //if(t2.x>t2.y) col=col.yzx;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "//remix of: https://www.shadertoy.com/view/csK3zm\n\n#define fmod(x,y) floor(max(mod(floor(-(x))*4.,y),mod(floor(x)*5.,y)))\n#define fmod1(x,y) floor(min(mod(floor(-(x))*4.,y),mod(floor(x)*5.,y)))\nvec2 mainSound(int samp, float time){  \n  float tempo = .5;\n  time /= tempo;\n  float s2 = pow(2.,1.+fmod1(-time/4.,2.)),\n  s1 = pow(2.,fmod(-time*s2*2.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1*2.+1.,2.)),\n  t = time/s1/pow(2.,fmod1(time/5./8.,5.))*2.,\n  t1 = 1.+fmod(t/s1,2.),\n  m4 = fmod1(-t*s1/t1,s2),\n  m3 = fmod(-t*s1/m1,s2);\n  t *= s1/t1;\n  float m2 = 1. + fmod(-t,s1),\n  a = 8.*fract(-t),\n  nb = time*tempo*pow(2.,(m3+m2)/5.+7.5);\n  return abs(abs(1./s1-1./s2)/8.-abs(vec2(sin(nb),cos(nb))))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clc3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 166], [168, 168, 225, 225, 1430]]}
{"id": "mt3GWj", "name": "Zellij pattern 11", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "carpet", "rug", "zellij"], "likes": 3, "viewed": 157, "published": 3, "date": "1683100505", "time_retrieved": "2024-07-30T17:57:50.470902", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    vec2 uv1 = uv;\n    uv.y = mod(uv.y,.5)+.25;\n    uv.x = mod(uv.x,.5)+.25;\n    for(int k = 0; k < 15; k++){\n        uv =\n            abs(.5-uv-t2*sign(uv.y-uv.x))/1.5-sign(-uv.x)/2.\n        ;\n        b = uv.y>uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(-uv+.5).yx\n        ;\n        uv =\n            t2+triangle_wave(-uv.yx).yx\n        ;\n        if(uv.y>uv.x)\n        //{t2 = t2.yx; uv=uv.yx;}\n        col.x =\n            abs((uv.x)-col.x)\n        ;\n        \n        //awesome kaleidoscope effect!\n        //if(t2.y>t2.x) {t2 = t2.yx; uv=uv.yx+iTime/8.;}\n        \n        col.xyz =\n            //abs(col.yzx-float(b)/2.)\n            abs(vec3(col.zx,max(uv.y-uv.x,col.y)))\n        ;\n        k += int(uv.y>uv.x);\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "//remix of: https://www.shadertoy.com/view/csK3zm\n\n#define fmod(x,y) floor(max(mod(floor((x))*4.,y),mod(floor(x)*7.,y)))\n#define fmod1(x,y) floor(min(mod(floor((x))*4.,y),mod(floor(x)*3.,y)))\nvec2 mainSound(int samp, float time){  \n  float tempo = .5;\n  time /= tempo;\n  float s2 = pow(2.,1.+fmod1(-time/4.,3.)),\n  s1 = pow(2.,fmod(-time*s2*2.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1*2.+1.,2.)),\n  t = time/s1/pow(2.,fmod1(-time/5./8.,5.))*2.,\n  t1 = 1.+fmod(t/s1,2.),\n  m4 = fmod1(-t*s1/t1,s2),\n  m3 = fmod(-t*s1/m1,s2);\n  t *= s1/t1;\n  float m2 = 1. + fmod(-t,s1),\n  a = 8.*fract(-t),\n  nb = time*tempo*pow(2.,(m3+m2)/5.+7.5);\n  return abs(abs(1./s1-1./s2)/8.-abs(vec2(sin(nb),cos(nb))))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3GWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1291]]}
{"id": "ct3GW2", "name": "Green and gold leaves", "author": "jarble", "description": "A gold leaf pattern.", "tags": ["fractal", "mosaic", "carpet", "rug"], "likes": 7, "viewed": 193, "published": 3, "date": "1683090362", "time_retrieved": "2024-07-30T17:57:51.460257", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    vec2 uv1 = uv;\n    uv.y = mod(uv.y,.5)+.25;\n    uv.x = mod(uv.x,.5)+.25;\n    //uv.x = mod(uv.x,.5)+.25;\n    for(int k = 0; k < 9; k++){\n        uv =\n            abs(.5-uv+t2*sign(uv.y-uv.x))/1.5-sign(-uv.x)/2.\n        ;\n        b = uv.y<uv.x;\n        if(b) uv = uv.yx;\n        t2 =\n            triangle_wave(uv+.5).yx\n        ;\n        uv =\n            t2+triangle_wave(uv.yx).yx\n        ;\n        if(uv.y<uv.x)\n        //{t2 = t2.yx; uv=uv.yx;}\n        col.x =\n            abs((uv.x)-col.x)\n        ;\n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "//remix of: https://www.shadertoy.com/view/csK3zm\n\n#define fmod(x,y) floor(max(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\n#define fmod1(x,y) floor(min(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\nvec2 mainSound(int samp, float time){  \n  float tempo = .5;\n  time /= tempo;\n  float s2 = pow(2.,1.+fmod1(-time/4.,3.)),\n  s1 = pow(2.,fmod(-time*s2*2.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1*2.+1.,2.)),\n  t = time/s1/pow(2.,fmod1(time/5./8.,5.))*2.,\n  t1 = 1.+fmod(t/s1,2.),\n  m4 = fmod1(-t*s1/t1,s2),\n  m3 = fmod(-t*s1/m1,s2);\n  t *= s1/t1;\n  float m2 = 1. + fmod(-t,s1),\n  a = 8.*fract(-t),\n  nb = time*tempo*pow(2.,(m3+m2)/5.+7.5);\n  return abs(abs(1./s1-1./s2)/8.-abs(vec2(sin(nb),cos(nb))))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3GW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [144, 144, 201, 201, 1123]]}
{"id": "dld3DS", "name": "Isometric Pixel Castles!", "author": "SnoopethDuckDuck", "description": "The castles are inspired by: https://www.instagram.com/p/BpuJAdIlTZt/\nThe color palette is modified from Dawnbringer32: https://lospec.com/palette-list/dawnbringer-32\n\nMake sure you click the music thingy in iChannel1!", "tags": ["pixel", "tower", "isometric", "castle", "pixelart", "dawnbringer"], "likes": 29, "viewed": 309, "published": 3, "date": "1683064788", "time_retrieved": "2024-07-30T17:57:52.538375", "image_code": "vec4 cell(in vec2 q) {\n    ivec2 p = ivec2(q);\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0);\n}\n\nvec2 pxToF(vec2 px) { return round(sc * (px - 0.5 * res) / res.y); }\nvec2 fToPx(vec2 f)  { return f / sc * res.y + 0.5 * res; }\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n    vec2 f = round(sc * uv);\n    \n    vec4 c = cell(px);\n    float x = 1.;\n    vec4 t = cell(fToPx(f - vec2( 0,  x)));\n    vec4 l = cell(fToPx(f - vec2( x,  0)));\n    vec4 r = cell(fToPx(f - vec2(-x,  0)));\n    vec4 b = cell(fToPx(f - vec2( 0, -x)));\n    \n    // Outline (might be off by one or two pixels)\n    if (c.a == 2. && (t.a != 2. || l.a != 2. || r.a != 2. || b.a != 2.))\n        c.rgb *= 0.95;//= vec3(63,63,116) / 255.;\n    \n    O = c;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33183, "src": "https://soundcloud.com/jordgubbsblond/ichika-nito?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define res iResolution.xy\nfloat sc = 120.; // Grid scale", "buffer_a_code": "// Small issues:\n// Spacing wrong for big towers + overlap occurs\n// Some low towers only cover half the wall trim e.g. 65 seconds\n\n// todo maybe:\n// raise wall,tower heights from 0->max height from fract(t)=0 to 1\n// or: audiovisual, heights change with sound\n// make island consider thickness of towers\n// make bottom of island consider towDim.y\n// add door and path/road\n// add centre castle\n\n// Basis vectors for skewed plane\nconst vec2 bX = vec2( 2, 1);\nconst vec2 bY = vec2(-2, 1);\n\n\n// --- COLORS ---\n\n// 0: tower dark\n// 1: tower light\n// 2: background\n// 3: trim dark\n// 4: trim light\n// 5: carpet\n// 6: grass dark\n// 7: grass\n// 8: grass light\n// 9: under light\n// 10: under dark\n// 11: flag \n\nint pal;   // Color palette: 0=grey+green 1=orange 2=green+blue\nfloat ind; // Color index\n\nconst int nCol = 12;\nconst vec3[] colArr = vec3[3 * nCol] ( \nvec3(89,86,82),  vec3(132,126,135),vec3(91,110,225),vec3(99,155,255), vec3(95,205,225), vec3(217,87,99), vec3(55,148,110),vec3(106,190,48),vec3(153,229,80), vec3(143,86,59),vec3(102,56,49),vec3(255),\nvec3(143,86,59), vec3(180,123,80), vec3(55,148,110),vec3(217,160,102),vec3(238,195,154),vec3(180,123,80),vec3(223,113,38),vec3(254,182,45),vec3(238,195,154),vec3(143,86,59),vec3(102,56,49),vec3(255),\nvec3(55,148,110),vec3(106,190,48), vec3(180,123,80),vec3(203,219,252),vec3(255,255,255),vec3(153,229,80),vec3(48,96,130), vec3(91,110,225),vec3(99,155,255), vec3(143,86,59),vec3(102,56,49),vec3(255)\n);\n\nvec3 getCol() {\n    return colArr[pal * nCol + int(ind)] / 255.;\n}\n\n\n// --- HASH FUNCTIONS ---\n\n// ty Dave Hoskins! https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// --- PRIMITIVE SHAPES --- \n\n// x,y bottom left corner\nfloat box(vec2 f, float x, float y, float w, float h) {\n    return step(x, f.x) * step(f.x, x + w - 1.) *\n           step(y, f.y) * step(f.y, y + h - 1.);\n}\n// Diamond\nfloat dia(vec2 f, float w, float h) {\n    f = abs(f - vec2(0.5, 0));\n    return step(f.x, h - 2. * f.y) * step(f.x, w); \n}\n// Slanted box: left+right sides are vertical, bottom+top are slanted\nfloat sbox(vec2 f, float w, float h, float s) {\n    f -= vec2(0.5 * (s - 1.), 0.); // Why -1.?\n    f.x *= s;\n    return step(0., f.x) * step(f.x, w) *\n           step(f.x, 2.*f.y+1.) * step(2.*f.y-h, f.x);\n}\n// Slanted rect: b bottom point, t top point\nfloat srect(vec2 f, vec2 b, vec2 t) {\n    vec2 fb = f-b;\n    vec2 ft = f-t;\n    float s = step(fb.x-2.*fb.y, 0.) * step(1., fb.x+2.*fb.y); \n    return s * step(1., ft.x-2.*ft.y) * step(ft.x+2.*ft.y, 0.);\n}\n// Slanted rect with extra height\nfloat srect2(vec2 f, vec2 b, vec2 t, float h) {\n    vec2 fb = f-b-vec2(0,h);\n    vec2 ft = f-t;\n    float l = t.y-b.y+0.5*(t.x-b.x);\n    float r = t.y-b.y-0.5*(t.x-b.x);\n    float s = step(1., ft.x-2.*ft.y) * step(ft.x+2.*ft.y, 0.);\n    s *= step(fb.x-2.*fb.y, 0.) * step(1., fb.x+2.*fb.y); \n    s *= step(f.x-r, -1.) * step(2.,f.x+l);\n    return s;\n}\n\n\n// --- OBJECTS --- \n\n// b: bottom point, t: top point, h: height of lower island\nvoid drawIsland(vec2 f, vec2 b, vec2 t, float h) {\n    float top = srect(f, b, t);\n    float bot = srect2(f, b, t, -h) - top;\n    float uInd = mix(9., 10., step(b.x-t.x+1., f.x));\n    ind = mix(ind, 7., top);  \n    ind = mix(ind, uInd, bot);\n}\n// dm: diamond dimensions, h: height (>4), th: bot thickness\nvoid drawTower(vec2 f, vec2 dm, float h, float th) {\n    f.y -= h + 0.5*dm.y;\n    float m = min(dm.x, dm.y);\n    float di1    = dia(f, dm.x, dm.y);\n    float di2    = dia(f, dm.x - 2., dm.y - 2.);\n    float di3    = dia(f - vec2(0, -1), dm.x - 2., dm.y - 2.);\n    float base   = dia(f - vec2(0, -0.5*h), th, dm.y+h);\n    float top    = dia(f - vec2(0, -1.), m, 2.+dm.y);\n    float shadow = dia(f - vec2(0, -2.), m-1., 2.+dm.y);  \n    ind = mix(ind, mix(0., 1., step(f.x, 0.)), base);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, mix(0., 1., step(f.x, 1.)), top);\n    ind = mix(ind, 5., di1);\n    ind = mix(ind, mix(3., 4., step(f.x, 0.)), di1 - di2);\n    ind = mix(ind, 0., max(0., di2 - di3));\n}\nvoid drawWallTL(vec2 f, vec2 dm, float th) {\n    float base = sbox(f, dm.x + 1., dm.y, 1.);\n    float carpet = sbox(f - vec2(0, 0.5*dm.y+1.), dm.x-0., 2., 1.);\n    carpet *= step(f.y - (0.5*dm.y+1.), 0.5*dm.x);\n    float shadow = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-2., 0., 1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+4.), dm.x-2., 0., 1.);\n    ind = mix(ind, 0., base);\n    ind = mix(ind, 5., carpet);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, 4., trim);\n}\nvoid drawWallTR(vec2 f, vec2 dm, float th) {\n    float base = sbox(f, dm.x + 1., dm.y, -1.);\n    float carpet = sbox(f - vec2(0, 0.5*dm.y+1.), dm.x, 2., -1.);\n    carpet *= step(f.y - (0.5*dm.y+1.), 0.5*dm.x);\n    float shadow = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-2., 0., -1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+4.), dm.x-2., 0., -1.);\n    ind = mix(ind, 1., base);\n    ind = mix(ind, 5., carpet);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, 3., trim);\n}\nvoid drawWallBL(vec2 f, vec2 dm) {\n    float base = sbox(f, dm.x, dm.y, -1.);\n    float shadow = sbox(f - vec2(0, 0.5*dm.y+1.), dm.x, 0., -1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+2.), dm.x, 0., -1.);   \n    float carpet = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-1., 2., -1.);\n    ind = mix(ind, 1., base);\n    ind = mix(ind, 0., shadow);\n    ind = mix(ind, 4., trim);\n    ind = mix(ind, 5., carpet);\n}\nvoid drawWallBR(vec2 f, vec2 dm) {\n    float base = sbox(f, dm.x, dm.y + 2., 1.);\n    float trim = sbox(f - vec2(0, 0.5*dm.y+2.), dm.x, 0., 1.);\n    float carpet = sbox(f - vec2(0, 0.5*dm.y+3.), dm.x-1., 2., 1.);\n    ind = mix(ind, 0., base);\n    ind = mix(ind, 3., trim);\n    ind = mix(ind, 5., carpet);\n}\n// Only B and R towers\nvoid drawTowerShadow(vec2 f, vec2 dm, float th) {\n    f.y -= 0.5 * dm.y;\n    float shadow = dia(f - vec2(4, 0), dm.x, dm.y);\n    ind = mix(ind, 6., shadow);\n}\n// Only TL and BR walls\nvoid drawWallShadow(vec2 f, vec2 dm) {\n    float shadow = sbox(f - vec2(2, -1), dm.x + 1., 3., 1.);\n    ind = mix(ind, 6., shadow);\n}\nvoid drawTowerGrass(vec2 f, vec2 dm, float th) {\n    f.y -= 0.5 * dm.y;\n    float grass = dia(f - vec2(0, -1), th, dm.y);\n    ind = mix(ind, 8., grass);\n}\nvoid drawWallGrass(vec2 f, vec2 dm) {\n    float grass = sbox(f - vec2(0, -1), dm.x, 0., -1.);\n    ind = mix(ind, 8., grass);\n}\nvoid drawFlag(vec2 f, float h) {\n    float m = mod(floor(4. * iTime), 2.);\n    float pole = box(f, 0., 0., 1., h);\n    float tip  = box(f, 0., h + 1., 1., 1.);\n    float flag = box(f, 0., h, 1., 1.) + box(f, 1., h-2.+m, 1., 3.) +\n                 box(f, 2., h-1.-m, 1., 3.);\n    float shadow = box(f, 1., 0., 2., 1.);  \n    ind = mix(ind, 1., pole);\n    ind = mix(ind, 4., tip);\n    ind = mix(ind, 11., flag);\n    ind = mix(ind, 0., shadow);\n}\n// Unfinished, needs to consider tower thickness? has a left bias\nvoid drawDoor(vec2 f, float w, float h) {\n    //if (ind != 1.) return; // Only draw on front wall\n    w = 5.;\n    h = 48.;    \n    float door = sbox(f - 0.25*(2.-w)*bY, w, h, -1.);\n    float e = step(f.x, -floor(0.5*w)-2.) * door;\n    //ind = mix(ind, 0., e);   \n    ind = mix(ind, 7., door);   \n    ind = mix(ind, 0., e);  \n}\n\nvoid mainImage(out vec4 O, in vec2 px) {  \n    vec2 uv = (px - 0.5 * res.xy) / res.y;\n    \n    // Pixelate uv\n    vec2 f = round(sc * uv); // Towers look good with f = sc * uv\n    \n    // Pick palette with time\n    pal = int(mod(floor(iTime), 3.));\n    \n    // Random parameters\n    float[13] rand;\n    float fTime = floor(iTime);\n    for (int i = 0; i < 13; i++) {\n        rand[i] = hash11(fTime + float(i) / 13.);\n    }\n  \n    // Tower: dimensions, height, thickness\n    vec2 towDim = vec2(0, 6. + 2.*floor(8. * rand[0]));\n    towDim.x = floor(mix(max(5., 0.25*towDim.y), towDim.y+2., rand[1]));\n    float towH = 2.*floor(mix(4., 20., rand[2]));\n    float towTh = 2.;//floor(mix(6., min(towDim.x, towDim.y)-1., rand[3]));\n    towTh = clamp(towTh, 4., min(towDim.x, towDim.y)-1.);\n    \n    // Wall: height, lengths (keep height even, lengths odd)\n    float wallH = 2.*floor(mix(2., 0.5*towH, rand[4]));\n    wallH = min(wallH, towH+2.);\n    float wallX = 1. + 2.*max(8., floor(30.*rand[5]));\n    float wallY = 1. + 2.*max(8., floor(30.*rand[6]));\n    \n    // Island: padding (>=4.), height\n    float islPad = 4.;\n    float islH = 4.;\n    \n    // Flag: height\n    float flagH = floor(mix(8., 17., rand[7]));\n        \n    // Positions\n    vec2 pTowT = vec2(0);\n    vec2 pTowL = -0.5 * bX * (3. + wallX);\n    vec2 pTowR = -0.5 * bY * (3. + wallY);\n    vec2 pTowB = pTowL + pTowR;    \n    vec2 pWallTL = pTowL + vec2(8.-towTh, 0.5*(1.+towTh));\n    vec2 pWallTR = pTowR + vec2(towTh-6., 0.5*(1.+towTh));\n    vec2 pWallBR = pTowB + vec2(1, 2.5);\n    vec2 pWallBL = pWallBR;\n        \n    // Centre coords to centre of castle and translate\n    f += round(0.5*pTowB);\n    f.y += 18.;\n    \n    \n    // --- DRAW --   \n\n    // Background \n    ind = 2.;\n    \n    // Island (offset with bX, bY for non-constant padding)\n    drawIsland(f, pTowB - vec2(0, islPad), pTowT - vec2(0, 1.-towDim.y-islPad), islH);\n    \n    // Grass and Shadows\n    drawTowerShadow(f - pTowT, towDim, towTh); \n    drawWallGrass  (f - pWallBL, vec2(wallY, wallH));\n    drawWallGrass  (f - pWallTR, vec2(wallY, wallH));\n    drawTowerGrass (f - pTowL, towDim, towTh);\n    drawTowerGrass (f - pTowB, towDim, towTh);\n    drawTowerShadow(f - pTowL, towDim, towTh); \n    drawTowerShadow(f - pTowB, towDim, towTh);\n    drawTowerShadow(f - pTowR, towDim, towTh);\n    drawWallShadow (f - pWallTL, vec2(-2.+wallX, wallH));\n    drawWallShadow (f - pWallBR, vec2(1.+wallX, wallH));    \n    \n    // Towers and Walls\n    drawTower (f - pTowT, towDim, towH, towTh);  \n    drawWallTR(f - pWallTR, vec2(-2.+wallY, wallH), towTh);\n    drawWallTL(f - pWallTL, vec2(-2.+wallX, wallH), towTh);      \n    drawTower (f - pTowL, towDim, towH, towTh);\n    drawTower (f - pTowR, towDim, towH, towTh);    \n    drawWallBR(f - pWallBR, vec2(wallX, wallH));\n    drawWallBL(f - pWallBL, vec2(wallY, wallH));\n    drawTower (f - pTowB, towDim, towH, towTh);      \n          \n    // Door (todo)\n    // drawDoor(f - 0.5*(pTowB+pTowL)- vec2(0, 3), 9., 6.);\n          \n    // Flags\n    if (rand[8] > 0.5) \n        drawFlag(f - pTowT - vec2(0, towH + 0.5 * towDim.y), flagH);     \n    if (rand[9] > 0.5) \n        drawFlag(f - pTowL - vec2(0, towH + 0.5 * towDim.y), flagH);    \n    if (rand[10] > 0.5) \n        drawFlag(f - pTowR - vec2(0, towH + 0.5 * towDim.y), flagH);    \n    if (rand[11] > 0.5) \n        drawFlag(f - pTowB - vec2(0, towH + 0.5 * towDim.y), flagH);    \n\n    vec3 col = getCol();\n         \n    // Texture front wall and a random part\n    float hh = hash12(mod(floor(iTime) + mod(f + ind, 4.),vec2(301.)));\n    float hi1 = floor(float(nCol) * hash11(floor(iTime)));\n    float hi2 = floor(float(nCol) * hash11(floor(iTime) + 0.5));\n    if (rand[12] > 0.4 && (ind == hi1 || ind == hi2))\n        col *= 0.9 + 0.2 * hh;\n     \n    // Vignette (very weak)\n    col = mix(col, vec3(1), 1.-1./cosh(0.25*length(uv)));\n    \n    O = vec4(col, ind);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dld3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 155], [157, 157, 178, 178, 225], [226, 226, 247, 247, 284], [286, 286, 328, 328, 816]]}
{"id": "ctdGDB", "name": "Galaxy flash", "author": "bronna", "description": "Based on https://thebookofshaders.com/07/", "tags": ["space", "galaxy", "red", "blue", "flash"], "likes": 1, "viewed": 165, "published": 3, "date": "1683050869", "time_retrieved": "2024-07-30T17:57:53.354194", "image_code": "// easing function from https://easings.net/\nfloat quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the aspect ratio\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n\t// Calculate the normalized pixel coordinates\n    vec2 uv = ( ( fragCoord.xy / iResolution.xy ) - 0.5 ) * vec2( 1.0, aspectRatio ) + vec2( 0.5 );\n    float position = 0.0;\n    \n    float t = quarticInOut(abs(fract(iTime)) / 2.4);\n\n    // the galaxy\n    position = max(distance(uv,vec2(0.1)),distance(uv,vec2(0.9)));\n    float circ = smoothstep(0.49, position, 0.5+t/4.0);\n\n    vec3 color = vec3(circ, 0.2, 0.4);\n\n\tfragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 74, 74, 156], [158, 158, 215, 249, 758]]}
{"id": "DttGDB", "name": "Eclipse pulse", "author": "bronna", "description": "Based on https://thebookofshaders.com/07/", "tags": ["pulse", "blackandwhite", "eclipse"], "likes": 2, "viewed": 180, "published": 3, "date": "1683050045", "time_retrieved": "2024-07-30T17:57:54.174999", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Calculate the aspect ratio\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n\t// Calculate the normalized pixel coordinates\n    vec2 uv = ( ( fragCoord.xy / iResolution.xy ) - 0.5 ) * vec2( 1.0, aspectRatio ) + vec2( 0.5 );\n    float position = 0.0;\n\n    \n    float t = abs( sin( iTime ) ) / 18.0;\n\n    // distance from the pixel to the center\n    position = distance( uv, vec2( 0.5 ) ) * 2.0;\n    float circ = smoothstep( 0.29, position, 0.3+t/4.0 );\n\n    vec3 color = vec3( circ );\n\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DttGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 88, 591]]}
{"id": "ctd3WB", "name": "interp bluenoise texture =danger", "author": "FabriceNeyret2", "description": "Better seen in fullscreen.\n\ntop: nearest blue noise ( every sec: with threshold )\nbottom: interpolated blue noise\nleft to right: noise scaled less to more than 1024.\nclick: offset all by 1/2 pixel.\nswitch #if line 7 to compare with whitenoise", "tags": ["bluenoise"], "likes": 12, "viewed": 318, "published": 3, "date": "1683049010", "time_retrieved": "2024-07-30T17:57:55.029714", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = u;\n    if ( iMouse.z > 0. ) U -= .5;                       // click: offset by 1/2 pixel\n    \n    U /= 1024. -16.+32.* floor(u.x/R.x*8.)/8.;          // left to right: noise scaled by less to more than 1024.\n#if 1                                                   // --- blue noise\n    O = vec4( u.y/R.y > .5 ? texture(iChannel0,U).x     // top: nearest blue noise \n                           : texture(iChannel1,U).x );  // bottom: interpolated blue noise\n#else                                                   // --- white noise\n    U *= 4.;\n    O = vec4( u.y/R.y > .5 ? texture(iChannel2,U).x     // top: nearest blue noise \n                           : texture(iChannel3,U).x );  // bottom: interpolated blue noise\n#endif\n    if ( fract(iTime/2.) < .5 ) O = step(.7,O);         // every sec: thresholding the noise \n    if ( mod( u.x,R.x/8.) < 1.) O = vec4(1,0,0,1);      // red separators\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctd3WB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 968]]}
{"id": "DtdGWS", "name": "爱心", "author": "12gx", "description": "跳动的心", "tags": ["2dlove"], "likes": 3, "viewed": 135, "published": 3, "date": "1683036035", "time_retrieved": "2024-07-30T17:57:55.779708", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float w = 1.0/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    \n    uv.x*=iResolution.x/iResolution.t;\n    vec3 col = vec3(0.0);\n    \n    float r = 0.4+sin(iTime)*0.05+0.05;\n    //float r = 0.4 + pow(sin(iTime*4.+uv.y*3.5)*0.2+0.2,4.5);\n    \n    uv.x=abs(uv.x);\n    uv.y*=1.2;\n    uv.y-=uv.x*sqrt(((10.0-uv.x*15.0)/20.));\n    \n    float d= length(uv)-r;\n    float c= smoothstep(w,-w,d);\n    \n    col=mix(col,vec3(1,0,0),c);\n\n\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtdGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 577]]}
{"id": "Dt33DB", "name": "Caffienated monday hack", "author": "timmaffett", "description": "added some color and more, mouse 4 effects sweep of bubbles\nCC0: Quick monday hack\nSaw this tweet: https://twitter.com/junkiyoshi/status/1652996530146787329?s=20\nThought I could do something like.\nt's not quite good enough but good enough to share\n", "tags": ["2d"], "likes": 4, "viewed": 192, "published": 3, "date": "1682997234", "time_retrieved": "2024-07-30T17:57:56.591539", "image_code": "// Fork of \"Quick monday hack\" by mrange. https://shadertoy.com/view/dld3Rs\n// 2023-05-02 03:12:14\n\n// CC0: Quick monday hack\n//  Saw this tweet: https://twitter.com/junkiyoshi/status/1652996530146787329?s=20\n//  Thought I could do something like.\n//  It's not quite good enough but good enough to share\n#define TIME        iTime*1.2\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat df(vec2 p, float tm) {\n  p *= ROT(-tm*0.5);\n  float d = -p.y;\n  return abs(d)-0.003;\n}\n\nvec3 bubbles(vec3 col, vec2 p) {\n\n vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    \n\n  float aa = 4.0/RESOLUTION.y;\n  for (float i = 1.0; i < 11.0; ++i) {\n    float sz = 0.5/(1.0+i);\n    vec2 pp = p;\n    pp /= sz;\n    vec2 rp = round(pp);\n    vec2 cp = pp;\n    cp -= rp;\n    float dt = 0.01;\n    float dp = df(rp*sz, TIME-dt);\n    float dn = df(rp*sz, TIME);\n    float dd = (dn-dp)/dt;\n    float h0 = hash(rp);\n    float h1 = fract(667.0*h0);\n    float h2 = fract(1667.0*h0);\n    float r  = mouse.x/mouse.y*0.533*sqrt(h0);\n    r *= smoothstep(0.1, 0.9, length(p));\n//    r *= tanh(1.0*dd);\n    cp -= (0.8-r)*vec2(h1, h2);\n    float fo = smoothstep(12.0*sz*r, -0.1, dn/2.);\n    float d = (length(cp)-mix(r, 0., fo*fo*fo));\n    \n    float randcol = r*h0;//p.x/p.y; //hash(p) * 300.0;//round((p.x*300.)/5.0);\n    \n    d = abs(d);\n    d *= sz;\n    d -= 0.003;\n    vec3 bcol = /*vec3(sqrt(fo)) * */ hsb2rgb(vec3(randcol*PI*2.,1.0,sqrt(fo)*0.8))*smoothstep(.0, -aa, d)*step(.0, dd)*smoothstep(-0.05, 0.1, dn);\n    col += bcol;\n  }\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float ds = df(p, TIME);\n  vec3 col = vec3(0.0);\n  col = bubbles(col, p);\n  float aa = 4.0/RESOLUTION.y;\n  //blueline//col = mix(col, vec3(0.0, 0.0, 0.725), smoothstep(0.0, -aa, ds));\n  col = sqrt(col) * 2.;\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt33DB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 487, 514, 514, 749], [752, 812, 833, 833, 903], [905, 905, 933, 933, 997], [999, 999, 1031, 1031, 2072], [2074, 2074, 2104, 2104, 2329], [2331, 2331, 2386, 2386, 2558]]}
{"id": "ctcGDB", "name": "circle around", "author": "mbaernestocr", "description": "circle around", "tags": ["circle", "around"], "likes": 1, "viewed": 120, "published": 3, "date": "1682993354", "time_retrieved": "2024-07-30T17:57:57.417330", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set up the variables\n    vec2 resolution = vec2(420.0, 236.0);\n    float time = iTime;\n    vec2 center = vec2(0.5, 0.5);\n    float radius = 0.05;\n    vec2 position = center + vec2(0.1 * cos(time), 0.1 * sin(time));\n    \n    // Create a black box\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Draw a bright circle\n    if (distance(position, fragCoord.xy / resolution) < radius) {\n        color = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    // Output the fragment color\n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctcGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 83, 557]]}
{"id": "ct3GWB", "name": "Color Stud - Transfo PXV-2b", "author": "Slals", "description": "Changing color's luminosity across layers makes an illusion of depth.", "tags": ["colorinteraction"], "likes": 4, "viewed": 140, "published": 3, "date": "1682984784", "time_retrieved": "2024-07-30T17:57:58.197244", "image_code": "float rectSDF(vec2 uv, vec2 s) {\n    return max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\n\nfloat fill(float x, float s) {\n    return smoothstep(x -0.005, x + 0.005, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.4;\n    \n    float a = radians(45.0 * cos(iTime * 0.2));\n    uv = mat2(cos(a), -sin(a), sin(a), cos(a)) * (uv - 0.5);\n    \n    vec3 M = iMouse.xyz / iResolution.xyz;\n    \n    vec3 baseColor = vec3(0.7647, 0.2039, 0.1529), color = vec3(0.0);\n    for (int i = 5; i-- >= 0;) {\n        float m = float(i) * 0.05;\n        float square = fill(rectSDF(uv + vec2(0.0, m * sin(iTime)), vec2(1.0)), 0.05 + m);\n        color = mix(color, baseColor - (sin(iTime * 0.5) * m), square);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct3GWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 84], [86, 86, 116, 116, 165], [167, 167, 224, 274, 918]]}
{"id": "Dlc3DS", "name": "Jelly blobs", "author": "bronna", "description": "Based on https://thebookofshaders.com/07/", "tags": ["2d", "blobs", "retro", "red", "jelly"], "likes": 1, "viewed": 146, "published": 3, "date": "1682984662", "time_retrieved": "2024-07-30T17:57:59.043981", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the aspect ratio\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n\t// Calculate the normalized pixel coordinates\n    vec2 uv = ( fragCoord.xy / iResolution.xy ) * vec2( 1.0, aspectRatio );\n    float position = 0.0;\n\n    // Time varying blob position and size\n    position = distance( uv, vec2( 0.4, 0.4 * aspectRatio ) ) \n        * distance( uv, vec2( 0.1 * aspectRatio + abs( sin( iTime / 1.3 ) ) ) );\n     \n    float circ = step( 0.1, position );\n  \n    vec3 color = vec3( 0.8, circ, circ );\n\n    // Output to screen\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlc3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 91, 639]]}
{"id": "DlcGDS", "name": "Chladni Diagram w/mouse", "author": "timmaffett", "description": "use mouse to vary n/m vibration modes or a/b eigen values.\nPress 'E' to toggle to eigen values on/off  \nBased off a video by UselessGameDev (link to video below), animated and colored by me.\nhttps://www.youtube.com/watch?v=Fvkw3IKJ8SU&t=139s", "tags": ["animated", "chladni"], "likes": 4, "viewed": 141, "published": 3, "date": "1682981226", "time_retrieved": "2024-07-30T17:57:59.810930", "image_code": "// Fork of \"Chladni Diagram\" by CeruleanBoolean141. https://shadertoy.com/view/dttGz2\n// 2023-05-01 22:45:00\n\n//Created by CeruleanBoolean141 April 2023\n//Thanks to user FabriceNeyret2 for antialiasing method and other advice\n\n#define SCALE   5.0\n#define ESCALE 3.0 //8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n     vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    vec2 mouse2 = vec2(1.0);\n    \n    if( texture(iChannel0, vec2( 69./256.0, 2./2.0 ) ).x > 0. ) {\n       mouse2 = mouse;\n       mouse = vec2(1.);\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float pi = 3.14159, t = 0.5*iTime;\n    vec2 nm = vec2(1.0*(mouse.x*SCALE),4.0*(mouse.y*SCALE)); //higher values -> shorter periods.  ratio effects overall shape\n    \n    vec2 ab = vec2(sin(t)*1.2*(mouse2.x*ESCALE),cos(t)*0.49*(mouse2.y*ESCALE)); //larger values increase \"sharpness\", effects shape\n    float col =  abs(ab.x*sin(pi*uv.x*nm.y)*sin(pi*uv.y*nm.x) + ab.y*sin(pi*uv.x*nm.x)*sin(pi*uv.y*nm.y));   \n    fragColor = mix(vec4(0.8), vec4(col*vec3(sin(t),uv),1.0), smoothstep(0., 10./iResolution.y ,col-.1));\n    \n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlcGDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 330, 330, 1189]]}
{"id": "clcGDS", "name": "Landscape 2001", "author": "Slals", "description": "Funny color interaction", "tags": ["interactionofcolor"], "likes": 2, "viewed": 158, "published": 3, "date": "1682981111", "time_retrieved": "2024-07-30T17:58:00.557973", "image_code": "float rectSDF(vec2 uv, vec2 s) {\n    return max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\nfloat fill(float x, float s) {\n    return step(x, s);\n}\n\n// From easy RGB : xyz -> RGB\nvec3 colorWheel(float x, float y, float z) {\n    vec3 c = vec3(\n        x * 3.2406 + y * -1.5372 + z * -0.4986,\n        x * -0.9689 + y * 1.8758 + z * 0.0415,\n        x * 0.0557 + y * -0.204 + z * 1.057\n    );\n    \n    float t = 0.0031308;\n    if (c.r > t)\n        c.r = 1.055 * (pow(c.r, (1.0 / 2.4))) - 0.055;\n    else\n        c.r = 12.92 * c.r;\n    \n    if (c.g > t)\n        c.g = 1.055 * (pow(c.g, (1.0 / 2.4))) - 0.055;\n    else\n        c.g = 12.92 * c.g;\n    \n    if (c.b > t)\n        c.b = 1.055 * (pow(c.b, (1.0 / 2.4))) - 0.055;\n    else\n        c.b = 12.92 * c.b;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.43;\n\n    uv *= 20.0;\n    \n    vec2 M = iMouse.xy / iResolution.xy;\n    \n    \n    float fRed = 0.0, fGreen = 0.0, fBlue = 0.0;\n    \n    vec2 fi = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec3 modulator = colorWheel(M.x, M.y, 0.5);\n    \n    vec3 refAColor = modulator;\n    vec3 refBColor = modulator.bgr;\n    \n    vec3[] pcts = vec3[](\n        vec3(0.0528634, 0.050209, 0.0123966),\n        vec3(0.319672, 0.2823529, 0.132653),\n        vec3(0.1307189, 0.1156069, 0.1173469)\n    );\n    \n    int I = 0;\n    vec2 bPos = vec2(0.0);\n    \n    if (mod(fi.x, 2.0) == 0.0 && mod(fi.y, 2.0) == 1.0) {\n        bPos.x = -1.0;\n    } else if (mod(fi.x, 2.0) == 0.0 && mod(fi.y, 2.0) == 0.0) {\n        I = 1;\n        bPos = vec2(-1.0);\n    } else if (mod(fi.x, 2.0) == 1.0 && mod(fi.y, 2.0) == 0.0) {\n        I = 2;\n        bPos.y = -1.0;\n    } else if (mod(fi.x, 2.0) == 1.0 && mod(fi.y, 2.0) == 1.0) {\n        I = 3;\n    } else {\n        refAColor = vec3(0.0);\n        refBColor = vec3(0.0);\n    }\n    \n    if (iMouse.z >= 1.0) {\n        vec3 a = refAColor;\n        refAColor = refBColor;\n        refBColor = a;\n    }\n    \n    float d = (fi.x * fi.y) * sin(iTime);\n    \n    for (int i = 0; i < I; i++) {\n        fRed += pcts[i].r * d * 0.02;\n        fGreen += pcts[i].g * d * 0.02;\n        fBlue += pcts[i].b * d * 0.02;\n    }\n    \n    float B = fill(rectSDF(f + bPos, vec2(1.0)), 0.52);\n\n    vec3 color = refAColor.rgb * (1.0 + vec3(fRed, fGreen, fBlue)) * fill(rectSDF(f, vec2(1.0)), 1.0);\n    color = B == 1.0 ? refBColor.rgb * (1.0 + vec3(fBlue, fGreen, fRed)) : color;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clcGDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 84], [85, 85, 115, 115, 140], [142, 172, 216, 216, 766]]}
{"id": "cltGRl", "name": "Extruded Flagstone Tiling 3D", "author": "gelami", "description": "Ray traversal of an extruded flagstone/asymmetric tiling\nEach step of the traversal computes the position and size of the current tile which is used for the intersection\n\nMouse drag to look around\nDefines in Common", "tags": ["3d", "raytracing", "grid", "box", "aa", "tiling", "fxaa", "taa", "asymmetric", "flagstone"], "likes": 27, "viewed": 914, "published": 3, "date": "1682971790", "time_retrieved": "2024-07-30T17:58:01.611117", "image_code": "\n// Extruded Flagstone Filing - gelami\n// https://www.shadertoy.com/view/cltGRl\n\n/*\n * Ray traversal of an extruded flagstone/asymmetric tiling\n * \n * Each step of the traversal computes the position and size\n * of the current tile which is used for the intersection\n * \n * Mouse drag to look around\n * Defines in Common\n * \n * Kind of a sequel from my previous shader:\n * Colorful Rectangular Pillars - gelami\n * https://www.shadertoy.com/view/dtcGzX\n *\n * The tiling setup is from my old shader here:\n * Straight Flagstone Tiles - gelami\n * https://www.shadertoy.com/view/7tKGRc\n * \n * Anti-aliasing uses my TAA shader with an added CAS pass for sharpening\n * \n * TAA implementation from\n * Temporal AA Study - gelami\n * https://www.shadertoy.com/view/DsfGWX\n * \n * CAS implementation from\n * AMD FidelityFX: CAS - goingdigital\n * https://www.shadertoy.com/view/ftsXzM\n * \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col;\n    \n    #ifdef TAA\n    col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    // CAS implementation from\n    // AMD FidelityFX: CAS - goingdigital\n    // https://www.shadertoy.com/view/ftsXzM\n    #ifdef CAS\n    col = CAS_Pass(iChannel0, uv, iChannelResolution[0].xy).rgb;\n    #endif\n    \n    #else\n    col = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n    #endif\n    \n    //col = smoothstep(vec3(0), vec3(1), col);\n    //col = ACESFilm(col);\n    fragColor = vec4(linearTosRGB(col), 1);\n    fragColor += (dot(hash23(vec3(fragCoord, iTime)), vec2(1)) - 0.5) / 255.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define TAA\n#define CAS\n\n#define MOTION\n#define WARPING\n\n#define ROUNDED\n#define RADIUS 0.06\n\n#define MIN_HEIGHT 0.05\n#define MAX_HEIGHT 8.0\n\n#define STEPS 256\n#define MAX_DIST 180.\n#define EPS 1e-4\n\n#define PI (acos(-1.))\n#define TAU (PI*2.)\n\n// CAS implementation from\n// AMD FidelityFX: CAS - goingdigital\n// https://www.shadertoy.com/view/ftsXzM\n\n#define CAS_FACTOR 0.0\n\nvec3 CAS_Pass(sampler2D tex, vec2 uv, vec2 size)\n{\n    // CAS algorithm\n    vec3 col = texture(tex, uv).rgb;\n    \n    float max_g = col.y;\n    float min_g = col.y;\n    \n    vec4 uvoff = vec4(1,0,1,-1) / size.xxyy;\n    vec3 colw;\n    vec3 col1 = texture(tex, uv+uvoff.yw).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw = col1;\n    \n    col1 = texture(tex, uv+uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    \n    col1 = texture(tex, uv+uvoff.yz).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    \n    col1 = texture(tex, uv-uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    \n    float d_min_g = min_g;\n    float d_max_g = 1.-max_g;\n    float A;\n    \n    if (d_max_g < d_min_g) {\n        A = d_max_g / max_g;\n    } else {\n        A = d_min_g / max_g;\n    }\n    \n    A = sqrt(A);\n    A *= mix(-.125, -.2, CAS_FACTOR);\n    vec3 col_out = (col + colw * A) / (1.+4.*A);\n    \n    return col_out;\n}\n\n// Rounded box ray-intersection\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 pos, in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n    \n    // Faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z) < 0.0 ) return 0.0;\n\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n    vec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    float t = MAX_DIST;\n    \n    // Corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b*b - c;\n        if( h>0.0 ) t = - b -sqrt(h);\n    }\n    \n    vec3 a = dd.yzx + dd.zxy;\n    vec3 b = od.yzx + od.zxy;\n    vec3 c = oo.yzx + oo.zxy - ra2;\n    vec3 h = b*b - a*c;\n    \n    // Edge X\n    if( h.x>0.0 )\n    {\n        float ht = (-b.x - sqrt(h.x)) / a.x;\n        if( ht>0.0 && ht<t && abs(ro.x+rd.x*ht)<size.x ) t = ht;\n    }\n    \n    // Edge Y\n    if( h.y>0.0 )\n    {\n        float ht = (-b.y - sqrt(h.y)) / a.y;\n        if( ht>0.0 && ht<t && abs(ro.y+rd.y*ht)<size.y ) t = ht;\n    }\n    \n    // Edge Z\n    if( h.z>0.0 )\n    {\n        float ht = (-b.z - sqrt(h.z)) / a.z;\n        if( ht>0.0 && ht<t && abs(ro.z+rd.z*ht)<size.z ) t = ht;\n    }\n    \n    return t;\n}\n\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\nmat3 getCameraMatrix(vec3 ro, vec3 lo)\n{\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n    vec3 cv = cross(cu, cw);\n\n    return mat3(cu, cv, cw);\n}\n\nfloat safeacos(float x) { return acos(clamp(x, -1.0, 1.0)); }\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 x) { return clamp(x, vec2(0), vec2(1)); }\nvec3 saturate(vec3 x) { return clamp(x, vec3(0), vec3(1)); }\n\nfloat sqr(float x) { return x*x; }\nvec2 sqr(vec2 x) { return x*x; }\nvec3 sqr(vec3 x) { return x*x; }\n\nmat2 rot2D(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n// https://iquilezles.org/articles/palettes/\nvec3 palette(float t)\n{\n    return 0.5 - 0.5 * cos(TAU * (vec3(0.8, 0.9, 0.9) * t + vec3(0.25, .5, 0)));\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n#define coprimes vec2(2,3)\nvec2 halton (vec2 s)\n{\n  vec4 a = vec4(1,1,0,0);\n  while (s.x > 0. && s.y > 0.)\n  {\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(vec2(s),coprimes);\n    s = floor(s/coprimes);\n  }\n  return a.zw;\n}\n\n// Taken from https://www.shadertoy.com/view/MtVGWz\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += texture(tex, vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += texture(tex, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += texture(tex, vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += texture(tex, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += texture(tex, vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += texture(tex, vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += texture(tex, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += texture(tex, vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\nvec2 getJitter(vec2 pos, int frame)\n{\n    pos = floor(pos);\n    return halton(vec2(frame%8+1)) - .5;\n}\n\nvec3 getLookAtPos(float time)\n{\n    return vec3(0, 6, time * 2.0);\n}\n\nfloat getHeightMotion(vec2 p, float time, sampler2D tex, vec2 size)\n{\n    float r = texture(tex, 0.2 * p / size).y;\n    return (saturate(sin((r + time * 0.5) * TAU)*0.8+0.5)-0.5)*0.2;\n}\n\nvec3 sRGBToLinear(vec3 col)\n{\n    return mix(pow((col + 0.055) / 1.055, vec3(2.4)), col / 12.92, lessThan(col, vec3(0.04045)));\n}\n\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sp = ivec2(fragCoord);\n    \n    if (sp.x >= 2 || sp.y > 0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    vec3 ro = vec3(0, 0, 18);\n    vec3 lo = getLookAtPos(iTime);\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float ax = iMouse.z < 0. || iMouse.x == 0. ? -PI * .7 + iTime * .2 : -m.x * TAU;\n    float ay = iMouse.z < 0. || iMouse.y == 0. ? PI * 0.2 : -m.y * PI + PI * 0.5;\n    \n    ro.yz *= rot2D(ay);\n    ro.xz *= rot2D(ax);\n    ro += lo;\n    \n    if (sp.x == 0)\n        fragColor = vec4(ro, 1);\n    else if (sp.x == 1)\n        fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n// Fork of \"Gelami Raymarching Template\" by gelami. https://shadertoy.com/view/mslGRs\n// 2023-05-01 11:08:18\n\nfloat getHeight(vec2 p)\n{\n    float h = texture(iChannel0, 0.2 * p / iChannelResolution[0].xy).x;\n    return smoothstep(0.3, 0.8, h)*0.8+0.1;\n}\n\nfloat map(vec2 p)\n{\n    float h = getHeight(p);\n    \n    #ifdef MOTION\n    h += getHeightMotion(p, iTime, iChannel0, iChannelResolution[0].xy);\n    #endif\n    \n    return clamp(h * MAX_HEIGHT, MIN_HEIGHT, MAX_HEIGHT);\n}\n\n// \n// https://www.shadertoy.com/view/7tKGRc\nfloat randSpan( vec2 p )\n{\n    vec4 r = texelFetch(iChannel1, ivec2(mod(p, 256.0)), 0);\n    #ifdef WARPING\n    return (sin((iTime * 0.4 + r.x) * TAU)*0.5+0.5)*0.7+0.15;\n    #else\n    return r.x*0.7+0.15;\n    #endif\n}\n\n// Returns size and offset position\nvec4 getTile(vec2 id)\n{\n    bool ch = mod(id.x + id.y, 2.) > .5;\n    \n    // Get the random spans\n    float r00 = randSpan(id + vec2(0, 0));\n    float r10 = randSpan(id + vec2(1, 0));\n    float r01 = randSpan(id + vec2(0, 1));\n    float r11 = randSpan(id + vec2(1, 1));\n    \n    // Tile Size\n    vec2 s0 = ch ? vec2(r00, r10) : vec2(r01, r00);\n    vec2 s1 = ch ? vec2(r11, r01) : vec2(r10, r11);\n    vec2 s = 1. - s0 + s1;\n    \n    return vec4(s * 0.5, s0);\n}\n\nvec2 getTileID(vec2 p)\n{\n    vec2 fl = floor(p);\n    vec2 fr = p - fl;\n    \n    bool ch = mod(fl.x + fl.y, 2.) > .5;\n    \n    float r1 = randSpan(fl);\n    vec2 ax = ch ? fr.xy : fr.yx;\n    \n    float a1 = ax.x - r1;\n    float si = sign(a1);\n    vec2 o1 = ch ? vec2(si, 0) : vec2(0, si);\n    \n    float r2 = randSpan(fl + o1);\n    float a2 = ax.y - r2;\n    \n    vec2 st = step(vec2(0), vec2(a1, a2));\n    \n    // Tile ID\n    vec2 of = ch ? st.xy : st.yx;\n    vec2 id = fl + of - 1.;\n    \n    return floor(id);\n}\n\nbool trace(vec3 ro, vec3 rd, out float t, out vec2 tp, out vec3 normal)\n{\n    if ((ro.y > MAX_HEIGHT && rd.y > 0.0) || (ro.y < MIN_HEIGHT && rd.y > 0.0))\n        return false;\n    \n    tp = getTileID(ro.xz);\n    \n    //if (ro.y < map(tp))\n    //    return false;\n    \n    vec3 ird = 1.0 / rd;\n    vec3 srd = sign(rd);\n    vec3 ard = abs(ird);\n    \n    vec3 iro = ro * ird;\n    \n    t = MAX_DIST;\n    normal = vec3(-1);\n    \n    int i = 0;\n    for (; i < STEPS; i++)\n    {\n        float d = map(tp) * 0.5;\n        \n        vec4 tsp = getTile(tp);\n        \n        vec3 p = vec3(tp.x + tsp.z + tsp.x, d, tp.y + tsp.w + tsp.y);\n        vec3 s = vec3(tsp.x, d, tsp.y);\n        vec3 n = iro - p * ird;\n        vec3 k = ard * s;\n        \n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        \n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        \n        vec3 pos = ro + rd * (tN + EPS);\n        \n        if (pos.y > MAX_HEIGHT && rd.y > 0.0)\n            return false;\n        \n        if (tN < tF && tN >= 0.0)\n        {\n            if (tN > MAX_DIST)\n                return false;\n            \n            #ifndef ROUNDED\n            t = tN;\n            normal = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n            return true;\n            \n            #else\n            \n            const float rad = RADIUS;\n            \n            if (d < MIN_HEIGHT + rad)\n            {\n                t = tN;\n                normal = -srd * step(t1.yzx, t1) * step(t1.zxy, t1);\n                return true;\n            }\n            \n            vec3 o = p;\n            vec3 rp = ro - o;\n            vec3 rs = max(s-rad, vec3(0));\n            float rt = roundedboxIntersect(pos - o, rp, rd, rs, rad);\n            if (rt != MAX_DIST)\n            {\n                t = rt == 0.0 ? tN : rt;\n                vec3 pos = rp + rd * t;\n                normal = normalize(roundedboxNormal(pos, rs, rad));\n                return true;\n            }\n            #endif\n        }\n        \n        float dt;\n        vec2 st;\n        if (t2.x <= t2.z)\n        {\n            dt = t2.x;\n            st = vec2(1, 0);\n        } else\n        {\n            dt = t2.z;\n            st = vec2(0, 1);\n        }\n        \n        // Hacky way to get next tile ID v_v\n        // Ideally you would only check the neighboring span\n        // to pick which one from the two neighbors to advance to\n        //tp = getTileID(ro.xz + rd.xz * (min(t2.x, t2.z) + 1e-3) + step(t2.xz, t2.zx) * srd.xz * 5e-3);\n        tp = getTileID(ro.xz + rd.xz * (dt + 1e-3) + st * srd.xz * 5e-3);\n        //tp += st * srd.xz;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = getJitter(fragCoord, iFrame);\n    vec2 ndc = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = texelFetch(iChannel3, ivec2(0, 0), 0).rgb;\n    vec3 lo = getLookAtPos(iTime);\n\n    mat3 cmat = getCameraMatrix(ro, lo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, 2));\n\n    vec3 col = vec3(0);\n    \n    float t;\n    vec2 tp;\n    vec3 n;\n    bool hit = trace(ro, rd, t, tp, n);\n    \n    if (!hit) t = MAX_DIST;\n    \n    vec3 pos = ro + rd * t;\n    \n    vec3 ldir = normalize(vec3(1, 2, 0.9));\n    \n    float lt;\n    vec2 ltp;\n    vec3 ln;\n    bool lhit = trace(pos + n * EPS, ldir, lt, ltp, ln);\n    \n    float dif = max(dot(n, ldir), 0.0) * float(!lhit);\n    float bou = max(dot(-reflect(n, rd), ldir), 0.0);\n    \n    float r = getHeight(tp);\n    \n    col = palette(hash12(tp));\n    col *= vec3(1, 0.45, 0.08);\n    \n    float h = map(tp);\n    \n    vec3 bcol = vec3(1.2, 1, 0.8);\n    vec2 br = hash22(-tp.yx);\n    if (n.y == 0.0 && br.x < 0.1)\n    {\n        if (br.y < 0.5)\n        {\n            col = mix(col, bcol, step(fract(0.5 + (1.0-pos.y / h) * 1.2*ceil(r * MAX_HEIGHT)), 0.5));\n        } else\n        {\n            vec4 tsp = getTile(tp);\n            vec2 ww = 0.5 + 0.4999 * (pos.xz - tp - tsp.zw - tsp.xy) / tsp.xy;\n            ww = step(fract(ww * 2.0 - 0.25), vec2(0.5));\n            \n            col = mix(col, bcol, abs(n.x) > 0.5 ? ww.y : ww.x);\n        }\n    }\n    \n    col *= dot(abs(n), vec3(0.8, 1, 0.9));\n    col *= smoothstep(MIN_HEIGHT, MAX_HEIGHT*0.8, pos.y)*0.75+0.25;\n    \n    col *= dif + 0.15 + bou*0.15;\n    \n    vec3 ref = textureLod(iChannel2, reflect(rd, n), 2.0).rgb * palette(hash12(tp.yx));\n    ref *= vec3(1, 0.45, 0.08);\n    \n    float r0 = 0.05;\n    float fre = r0 + (1.0 - r0) * pow(1.0 - max(dot(-rd, n), 0.0), 5.0);\n    \n    col = mix(col, ref, fre * 0.8);\n    \n    vec3 sky = vec3(0.9, 0.6, 1);\n    \n    float fog = 1.0 - exp(-max(t - 30.0, 0.0) * 0.008);\n    col = mix(col, vec3(0.9, 0.6, 1), fog);\n    \n    col = mix(col, sky, smoothstep(MAX_DIST*0.9, MAX_DIST, t));\n    //if (t >= MAX_DIST)\n    //    col = rd;\n    \n    col = max(col, vec3(0));\n    col = col / (1. + col);\n    \n    fragColor = vec4(col, t);\n}", "buffer_b_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// TAA implementation from\n// Temporal AA Study - gelami\n// https://www.shadertoy.com/view/DsfGWX\n\n#if 0\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n\n#else\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n#endif\n\nvec3 RGBtoYCoCg(vec3 c)\n{\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\n// From https://github.com/playdeadgames/temporal/blob/master/Assets/Shaders/TemporalReprojection.shader\nvec3 clipToAABB(in vec3 cOld, in vec3 cNew, in vec3 center, in vec3 halfSize)\n{\n// Clip towards AABB center\n#if 0\n    vec3 o = cOld - center;\n    vec3 v = o / halfSize;\n    vec3 a = abs(v);\n    float t = max(a.x, max(a.y, a.z));\n    \n    if (t > 1.)\n        return cNew + o / t;\n    else\n        return cOld;\n#else\n    vec3 r = cOld - cNew;\n    vec3 m = (center + halfSize) - cNew;\n    vec3 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n\n\treturn cNew + r;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 sp = ivec2(fragCoord);\n    \n    vec2 o = getJitter(fragCoord, iFrame);\n    \n    vec2 ndc = (2. * (fragCoord) - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 curr = texture(iChannel0, (fragCoord - o) / iResolution.xy);\n\n    vec3 new = RGBtoYCoCg(curr.rgb);\n    \n    vec3 ro = texelFetch(iChannel2, ivec2(0, 0), 0).rgb;\n    vec3 pro = texelFetch(iChannel2, ivec2(1, 0), 0).rgb;\n    \n    vec3 lo = getLookAtPos(iTime);\n    vec3 plo = getLookAtPos(iTime - iTimeDelta);\n    \n    mat3 cmat = getCameraMatrix(ro, lo);\n    mat3 pmat = getCameraMatrix(pro, plo);\n\n    vec3 rd = normalize(cmat * vec3(ndc, 2));\n\n    vec3 p = ro + rd * curr.a;\n    \n    #ifdef MOTION\n    vec2 tp = floor(p.xz);\n    float h0 = getHeightMotion(tp, iTime, iChannel3, iChannelResolution[3].xy);\n    float h1 = getHeightMotion(tp, iTime - iTimeDelta, iChannel3, iChannelResolution[3].xy);\n    \n    p.y += (h1 - h0);\n    #endif\n    \n    vec3 cp = (p - pro) * pmat;\n    vec2 np = 2. * cp.xy / cp.z;\n    vec2 puv = np * vec2(iResolution.y / iResolution.x, 1) * .5 + .5;\n    \n    //vec4 hist = texture(iChannel1, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel1, iResolution.xy, puv);\n    \n    vec3 old = RGBtoYCoCg(hist.rgb);\n    \n    vec3 avg = new;\n    vec3 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec3 tex = RGBtoYCoCg(texelFetch(iChannel0, sp + off[i], 0).rgb);\n    \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec3 sig = sqrt(max(var - avg * avg, vec3(0)));\n    \n    const float g = 1.0;\n    vec3 cmin = avg - sig * g;\n    vec3 cmax = avg + sig * g;\n    \n    vec3 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    \n    vec3 col = iFrame != 0 ? mix(clip, new, a) : new;\n    \n    fragColor = vec4(saturate(YCoCgToRGB(col)), curr.a);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cltGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[880, 880, 937, 937, 1572]]}
{"id": "dl33R2", "name": "Cute Birds", "author": "aeveis", "description": "Birds drawn using SDFs", "tags": ["2d", "cute", "sdf", "bird"], "likes": 3, "viewed": 146, "published": 3, "date": "1682971782", "time_retrieved": "2024-07-30T17:58:02.466829", "image_code": "// View Options\n#define BIRD_AMOUNT    3.0\n#define BIRD_SCALE     0.35\n#define SCROLL_SPEED   0.2\n#define FLOOR_SCROLL   false\n#define SEED           124\n#define SATURATION     0.85\n\n// SDF Options\n#define LINE_SOFTNESS  0.005\n#define LINE_THICKNESS 0.015\n\n// Base Colors\n#define BG_COLOR       vec3(0.459, 0.878, 0.808)\n#define GLOW_COLOR     vec3(1.000, 1.000, 1.000)\n#define OUTLINE_COLOR  vec3(0.132, 0.045, 0.016)\n#define BIRD0_COLOR    vec3(0.84, 0.48, 0.53)\n#define BIRD1_COLOR    vec3(0.19, 0.95, 0.85)\n#define BIRD2_COLOR    vec3(0.91, 0.85, 0.47)\n#define EYEBASE_COLOR  vec3(0.934, 0.882, 0.753)\n#define EYE_COLOR      vec3(0.830, 0.618, 0.074)\n\n// Bird Variation\nfloat _HeadRoundness;\nfloat _BodyVariation;\nfloat _TailVariation;\n    \n// Noise https://blog.demofox.org/2022/01/01/interleaved-gradient-noise-a-different-kind-of-low-discrepancy-sequence/\nfloat IGN(int pixelX, int pixelY)\n{\n    return mod(52.9829189f * mod(0.06711056*float(pixelX) + 0.00583715*float(pixelY), 1.0), 1.0);\n}\n\n// https://www.shadertoy.com/view/WttXWX\nfloat Hash(float f)\n{\n    uint x = uint(f)+uint(SEED);\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return float(x) / float( 0xffffffffU );\n}\n\n// HSV conversion https://www.shadertoy.com/view/XljGzV\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n// Rotation\nvec2 Rotate2D(float angle, vec2 original)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return original * mat2(c, -s, s, c);\n}\n\n// SDF https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n// Bird Drawing\nfloat SDFOval(vec2 uv, float r, float angle)\n{\n    float sdf = sdEllipse(Rotate2D(angle, uv), vec2(r*(1.7 + 0.2 * _BodyVariation),r));\n    return sdf;\n}\n\nfloat SDFLine(vec2 uv, float l, float angle)\n{\n    float sdf = sdBox(Rotate2D(angle, uv), vec2(l,0.018));\n    return sdf;\n}\n\nfloat SDFFlatTriangle(vec2 uv, float l, float angle)\n{\n    float sdf = sdUnevenCapsule(Rotate2D(angle, uv), 0.015, 0.01, l);\n    return sdf;\n}\n\nfloat SDFFoot(vec2 uv)\n{\n    uv.y += 0.03 + 0.01 * _BodyVariation;\n    uv.x += 0.02 * _BodyVariation;\n    float toeAdd = 0.01 * _BodyVariation;\n    float legsdf = SDFLine(vec2((uv.x - 0.055), (uv.y+0.28)), 0.12, -0.8);\n    float footl1sdf = SDFFlatTriangle(vec2((uv.x+0.02), (uv.y+0.365)), 0.12 + toeAdd, 4.6);\n    float footl2sdf = SDFFlatTriangle(vec2((uv.x+0.01), (uv.y+0.365)), 0.1 + toeAdd, 4.33);\n    float footl3sdf = SDFFlatTriangle(vec2((uv.x+0.02), (uv.y+0.36)), 0.1 + toeAdd, 4.8);\n    float footl4sdf = SDFFlatTriangle(vec2((uv.x+0.025), (uv.y+0.365)), 0.08 + toeAdd, 1.57);\n    float sdf = min(legsdf, footl1sdf);\n    sdf = min(sdf, footl2sdf);\n    sdf = min(sdf, footl3sdf);\n    sdf = min(sdf, footl4sdf);\n    return sdf;\n}\n                \nfloat SDFHead(vec2 uv, float r, float angle)\n{\n    float roundsdf = sdEllipse(Rotate2D(angle, uv), vec2(r*(1.8 + 0.2 * _BodyVariation),r));\n    uv.x -= 0.03 + 0.05*(1.0 - _HeadRoundness);\n    float sharpersdf = sdUnevenCapsule(Rotate2D(angle - 1.6, uv), \n                        0.17, \n                        0.03 + 0.05 * _HeadRoundness, \n                        r*(1.9 + 0.2 * _BodyVariation) + 0.05 * (1.0 - _HeadRoundness));\n    uv.x += 0.04;\n    uv.y -= 0.05;\n    float sdf = mix(sharpersdf, sdCircle(uv, 0.22), 0.15);\n    sdf = mix(sdf, roundsdf, _HeadRoundness);\n    return sdf;\n}\n\nvoid SDFEye(vec2 uv, vec3 eyecolor, inout vec3 col)\n{\n    float eyeadj = 0.01 * (1.0 - _HeadRoundness);\n    uv.x += 0.15 + 0.02 * _BodyVariation;\n    uv.y -= 0.14;\n    float sdf = sdEllipse(uv, vec2(0.1 - eyeadj,0.12- eyeadj));\n    float eyeoutlineblend = smoothstep(0.0,LINE_SOFTNESS * 3.5, -sdf);\n    float eyeblend = smoothstep(0.0,LINE_SOFTNESS * 3.5, -(sdf + LINE_THICKNESS));\n\n    uv.x += 0.03;\n    float pupilsdf = sdEllipse(uv, vec2(0.065- eyeadj,0.09- eyeadj));\n    float pupiloutlineblend = smoothstep(0.0,LINE_SOFTNESS, -pupilsdf);\n    float pupilblend = smoothstep(0.0, LINE_SOFTNESS * 3.5, -sdEllipse(uv, vec2(0.028- eyeadj/2.0,0.05- eyeadj)));\n\n    col = mix(col, OUTLINE_COLOR.rgb, eyeoutlineblend);\n    col = mix(col, EYEBASE_COLOR.rgb, eyeblend);\n    col = mix(col, OUTLINE_COLOR.rgb, pupiloutlineblend);\n    col = mix(col, eyecolor, pupilblend);\n    uv -= 0.05 - 0.01 * (1.0 - _HeadRoundness);\n    col = mix(col, GLOW_COLOR.rgb, smoothstep(0.0, LINE_SOFTNESS * 3.5, -sdCircle(uv, 0.022)));\n}\n                \nvoid SDFBird(vec2 uv, float cell, inout vec3 col)\n{\n    // Random bird variations\n    _HeadRoundness = Hash(cell * 78523.0);\n    _BodyVariation = (Hash(cell * 34443.0) - 0.5) * 2.0;\n    _TailVariation = (Hash(cell * 43523.0) - 0.5) * 2.0;\n    \n    // Select Color and add variation\n    float colorChoice = mod(floor(Hash(cell * 12516.0) * 3.0),3.0);\n    vec3 birdColor = float(colorChoice == 0.0) * BIRD0_COLOR + float(colorChoice == 1.0) * BIRD1_COLOR + float(colorChoice == 2.0) * BIRD2_COLOR;\n    vec3 eyecolor = EYE_COLOR;\n\n    birdColor = rgb2hsv(birdColor);\n    birdColor.x += mix(-0.1, 0.1, Hash(cell * 1837.0));\n    birdColor.y += mix(-0.07, 0.0, Hash(cell * 8547.0));\n    birdColor.z += mix(-0.1, 0.05, Hash(cell * 2253.0));\n    birdColor = hsv2rgb(birdColor);\n    \n    eyecolor = rgb2hsv(eyecolor);\n    eyecolor.x += mix(-0.05, 0.2, Hash(cell * 3242.0));\n    eyecolor.y += mix(-0.3, 0.0, Hash(cell * 5643.0));\n    eyecolor.z += mix(0.0, 0.3, Hash(cell * 7545.0));\n    eyecolor = hsv2rgb(eyecolor);\n\n    // Random Flip\n    float flip = float(!FLOOR_SCROLL) * Hash(cell * 15632.0) + float(FLOOR_SCROLL);\n    uv.x = float(flip>0.5)*-uv.x + float(flip<0.5)*uv.x;\n\n    // Tweaks for placement\n    float scale = 1.35 + 2.0 * (1.0 - BIRD_SCALE);\n    uv *= scale;\n    uv.x += 0.11;\n    uv.y -= 0.1;\n    \n    // Draw Legs\n    float leg1sdf = SDFFoot(uv);\n    float leg2sdf = SDFFoot(vec2(uv.x - 0.08, uv.y + 0.05));\n    float legsdf = min(leg2sdf, leg1sdf);\n\n    // Random Rotation of main body\n    uv = Rotate2D(mix(-0.18, 0.1, Hash(cell * 898.0)), uv);\n    \n    // Draw Head, Body, Wing, and Tail\n    float headsdf = SDFHead(vec2(uv.x+0.18, uv.y-0.12), 0.16, -0.1);\n    float bodysdf = SDFOval(vec2(uv.x-0.13- 0.03 * _BodyVariation, uv.y+0.1), 0.2, 0.1 - 0.05 * _BodyVariation);\n    float rwingsdf = SDFOval(vec2(uv.x-0.25, uv.y+0.09), 0.2, 0.23);\n    float tailsdf = SDFOval(vec2(uv.x-0.45 - 0.05 * _TailVariation, uv.y+0.12- 0.02 * _TailVariation), 0.2, 1.0 + 0.5 * _TailVariation);\n    float rbacksdf = SDFOval(vec2((uv.x-0.56), (uv.y-0.45)), 0.6, 0.9);\n    float sdf = min(headsdf, bodysdf);\n    sdf = min(sdf, tailsdf);\n    sdf = max(sdf, -rwingsdf);\n    sdf = min(sdf, rwingsdf + LINE_THICKNESS - LINE_THICKNESS * mix(0.0, 0.5, LINE_SOFTNESS * 200.0));\n    sdf = max(sdf, -rbacksdf);\n    \n    // Scale adjustment to renormalize scale from tweaks\n    sdf /= scale;\n\n    // Get blend values for coloring\n    float birdbodyblend = smoothstep(0.0,LINE_SOFTNESS, -sdf);\n    float outlineblend = smoothstep(0.0,LINE_SOFTNESS, -(sdf - LINE_THICKNESS));\n    sdf = min(sdf- LINE_THICKNESS, legsdf);\n    float glowlineblend = smoothstep(0.0,LINE_SOFTNESS, -(sdf - LINE_THICKNESS));\n    float legblend = smoothstep(0.0,LINE_SOFTNESS * 2.0, -legsdf);\n\n    // Draw Mouth \n    float mouthsdf = SDFFlatTriangle(\n                        vec2((uv.x+0.34 + 0.03 * _BodyVariation + 0.08 * (1.1 - _HeadRoundness)), \n                        (uv.y+0.015 - 0.06 * (1.0 - _HeadRoundness))), \n                        0.06 + 0.04 * (1.0 - _HeadRoundness), \n                        0.6 + 0.65 * (1.0 - _HeadRoundness));\n    float mouthblend = smoothstep(0.0,LINE_SOFTNESS, -mouthsdf);\n\n    // Draw Beak \n    float beaksdf = sdEllipse(Rotate2D(-0.7,\n                        vec2(uv.x+0.52 + 0.02 * _BodyVariation+0.03 * (1.0 - _HeadRoundness), \n                              uv.y)), \n                        vec2(0.288, 0.19));\n    beaksdf = max(beaksdf, sdf + LINE_THICKNESS);\n    float beakblend = smoothstep(0.0,LINE_SOFTNESS, -beaksdf);\n    \n    // Slight shade warmer or cool depending on color\n    float shade = min(1.0, uv.y + 0.8);\n    float iscooler = float((birdColor.r - 0.3) <=birdColor.b);\n    float iswarmer = 1.0 - iscooler;\n    birdColor.rg = iscooler * mix(birdColor.rg/2.0, birdColor.rg, shade) + iswarmer * birdColor.rg;\n    birdColor.gb = iswarmer * mix(birdColor.gb/2.0, birdColor.gb, shade) + iscooler * birdColor.gb;\n\n    // Add colors\n    col = mix(col, GLOW_COLOR.rgb, glowlineblend);\n    col = mix(col, OUTLINE_COLOR.rgb, legblend);\n    col = mix(col, OUTLINE_COLOR.rgb, outlineblend);\n    col = mix(col, birdColor.rgb, birdbodyblend);\n    // Add colors for beak\n    col.rg *= beakblend * 0.65 + (1.0 - beakblend);\n    col.b *= beakblend * 0.85 + (1.0 - beakblend);\n    col = mix(col, OUTLINE_COLOR.rgb, mouthblend);\n    // Add eye wholesale\n    SDFEye(uv, eyecolor, col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= (iResolution.x-iResolution.y)/iResolution.y/2.0;\n\n    vec3 col = BG_COLOR;\n    \n    // 100 times different birds\n    float scale = 100.0;\n    float time = mod(iTime * SCROLL_SPEED, scale);\n    \n    time = floor(time) * float(FLOOR_SCROLL) + time * float(!FLOOR_SCROLL);\n    uv += time;\n    vec2 scaleduv = uv*scale;\n    \n    // Scale back to specified amount\n    scaleduv *= BIRD_AMOUNT/scale;\n    \n    // Offset even rows\n    float evenrow = float(mod(scaleduv.y,2.0) > 1.0);\n    scaleduv.x += evenrow * 0.5;\n    \n    // Get random value for each cell\n    float cell = IGN(int(mod(scaleduv.x,scale)),int(mod(scaleduv.y,scale)));\n    uv = (fract(scaleduv) - 0.5);\n    SDFBird(uv, cell, col);\n    \n    col = rgb2hsv(col);\n    col.y *= SATURATION;\n    col = hsv2rgb(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl33R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[745, 863, 898, 898, 998], [1000, 1041, 1062, 1062, 1239], [1298, 1298, 1320, 1320, 1651], [1653, 1653, 1675, 1675, 1844], [1847, 1859, 1902, 1902, 1997], [1999, 2055, 2090, 2090, 2118], [2120, 2120, 2157, 2157, 2237], [2239, 2239, 2301, 2301, 2540], [2542, 2542, 2584, 2584, 3606], [3608, 3624, 3670, 3670, 3776], [3778, 3778, 3824, 3824, 3901], [3903, 3903, 3957, 3957, 4045], [4047, 4047, 4071, 4071, 4784], [4802, 4802, 4848, 4848, 5390], [5392, 5392, 5445, 5445, 6401], [6419, 6419, 6470, 6500, 10800], [10802, 10802, 10859, 10909, 11792]]}
{"id": "dlt3zs", "name": "ColourCycling", "author": "Del", "description": "A Simple Colour Cycling grid image...\nhttps://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n", "tags": ["grid", "colourcycling"], "likes": 1, "viewed": 186, "published": 3, "date": "1682967816", "time_retrieved": "2024-07-30T17:58:03.235773", "image_code": "\n// generate a simple quantized colour cycle grid (12 colour steps)\n// used to generate a character-map grid for the Sega Genesis Version of A Blast From the Past.\n// 320x224 pixels packs down to 96 characters due to flipx/flipy (3072 bytes total)\n// https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n// https://www.youtube.com/watch?v=LUbrzg21X9c - The lost art of color cycling - Animating with color\n\nfloat Quant(float cc,float steps)\n{\n    return floor(steps*cc)/steps;           // pure quantization\n}\n\nvec2 CycleGrid(vec2 uv,float colorsteps)\n{\n\tfloat fade = (abs(uv.y)-.1)/.9;\n    fade = 1.0-step(fade,0.085);\n\tvec2 v = vec2(uv.x*abs(1.0/uv.y),abs(1.0/uv.y));\n    vec2 fs =  fract(v+0.5)-0.5;\n    float e = length(vec2(abs(fs.x)-0.5,0.0));\n    \n    float lines = step(e,.05);\n    float fill = fs.y+0.5;\n    if (iMouse.z<0.5)\n        fill+=Quant(fract(iTime*0.5),colorsteps);// Cycle colours\n    fill = Quant(fract(fill),colorsteps);\n    return vec2(lines,(fill+0.1)) * fade;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pixel coordinates\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 dat = CycleGrid(uv , 12.0);  // get grid with 12 colour steps\n    vec3 col = vec3(dat.y,0.0,0.0);\n\tcol.rgb += dat.x;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlt3zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[420, 420, 455, 455, 522], [524, 524, 566, 566, 999], [1001, 1001, 1056, 1081, 1327]]}
{"id": "dld3Rs", "name": "Quick monday hack", "author": "mrange", "description": "CC0: Quick monday hack\nSaw this tweet: https://twitter.com/junkiyoshi/status/1652996530146787329?s=20\nThought I could do something like.\nt's not quite good enough but good enough to share\n", "tags": ["2d"], "likes": 11, "viewed": 205, "published": 3, "date": "1682964206", "time_retrieved": "2024-07-30T17:58:04.171272", "image_code": "// CC0: Quick monday hack\n//  Saw this tweet: https://twitter.com/junkiyoshi/status/1652996530146787329?s=20\n//  Thought I could do something like.\n//  It's not quite good enough but good enough to share\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat df(vec2 p, float tm) {\n  p *= ROT(-tm*0.5);\n  float d = -p.y;\n  return abs(d)-0.003;\n}\n\nvec3 bubbles(vec3 col, vec2 p) {\n  float aa = 4.0/RESOLUTION.y;\n  for (float i = 1.0; i < 6.0; ++i) {\n    float sz = 0.3/(1.0+i);\n    vec2 pp = p;\n    pp /= sz;\n    vec2 rp = round(pp);\n    vec2 cp = pp;\n    cp -= rp;\n    float dt = 0.001;\n    float dp = df(rp*sz, TIME-dt);\n    float dn = df(rp*sz, TIME);\n    float dd = (dn-dp)/dt;\n    float h0 = hash(rp);\n    float h1 = fract(3667.0*h0);\n    float h2 = fract(8667.0*h0);\n    float r  = 0.33*sqrt(h0);\n    r *= smoothstep(0.1, 0.9, length(p));\n//    r *= tanh(1.0*dd);\n    cp -= (0.5-r)*vec2(h1, h2);\n    float fo = smoothstep(12.0*sz*r, -0.1, dn);\n    float d = (length(cp)-mix(r, 0., fo*fo*fo));\n    d = abs(d);\n    d *= sz;\n    d -= 0.003;\n    vec3 bcol = vec3(sqrt(fo))*smoothstep(0.0, -aa, d)*step(0.0, dd)*smoothstep(-0.05, 0.1, dn);\n    col += bcol;\n  }\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float ds = df(p, TIME);\n  vec3 col = vec3(0.0);\n  col = bubbles(col, p);\n  float aa = 4.0/RESOLUTION.y;\n  col = mix(col, vec3(1.0, 0.0, 0.25), smoothstep(0.0, -aa, ds));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dld3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 442, 463, 463, 533], [535, 535, 563, 563, 627], [629, 629, 661, 661, 1458], [1460, 1460, 1490, 1490, 1697], [1699, 1699, 1754, 1754, 1926]]}
{"id": "dt3GzS", "name": "Messing with simple raymarching", "author": "Oman395", "description": "I've been messing about with some of the methods used for conduit (https://www.shadertoy.com/view/Mlf3RS), although it is all my code.\n19 lines, could be 11 w/o configuration.\nI'll make a version with comments if y'all want.", "tags": ["raytracing", "raymarching", "simple", "short"], "likes": 6, "viewed": 184, "published": 3, "date": "1682961818", "time_retrieved": "2024-07-30T17:58:05.165613", "image_code": "float rad = 3.0;\nfloat distanceFade = 6.0;\nfloat timeScale = 1.0;\nfloat depthScale = 0.25;\nfloat widthAdjustmentAmount = 0.5;\nvec4 col1 = vec4(145, 215, 227,255) / 255.0;\nvec4 col2 = vec4(36, 39, 58, 255) / 255.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 position = vec3(uv + vec2(cos(iTime * timeScale), sin(iTime * timeScale)), 0);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    for(int i = 0; i < 256; i++) {\n        float dist = rad - distance(position.xy, vec2(0));\n        fragColor = vec4((1.0 - 1.0 / ((position.z + distanceFade) / distanceFade)) * col1 + (1.0 / ((position.z + distanceFade) / distanceFade)) * col2);\n        if(dist < 0.01) break;\n        position += dist * normalize(dir + vec3(widthAdjustmentAmount * vec2(cos(iTime * timeScale + position.z * depthScale), sin(iTime * timeScale + position.z * depthScale)), 0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt3GzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 272, 272, 974]]}
{"id": "dtdGzl", "name": "Landscape 2000", "author": "Slals", "description": "Funny color interaction", "tags": ["interactionofcolor"], "likes": 1, "viewed": 111, "published": 3, "date": "1682957411", "time_retrieved": "2024-07-30T17:58:06.061219", "image_code": "float rectSDF(vec2 uv, vec2 s) {\n    return max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\nfloat fill(float x, float s) {\n    return step(x, s);\n}\n\n// From easy RGB : xyz -> RGB\nvec3 colorWheel(float x, float y, float z) {\n    vec3 c = vec3(\n        x * 3.2406 + y * -1.5372 + z * -0.4986,\n        x * -0.9689 + y * 1.8758 + z * 0.0415,\n        x * 0.0557 + y * -0.204 + z * 1.057\n    );\n    \n    float t = 0.0031308;\n    if (c.r > t)\n        c.r = 1.055 * (pow(c.r, (1.0 / 2.4))) - 0.055;\n    else\n        c.r = 12.92 * c.r;\n    \n    if (c.g > t)\n        c.g = 1.055 * (pow(c.g, (1.0 / 2.4))) - 0.055;\n    else\n        c.g = 12.92 * c.g;\n    \n    if (c.b > t)\n        c.b = 1.055 * (pow(c.b, (1.0 / 2.4))) - 0.055;\n    else\n        c.b = 12.92 * c.b;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.43;\n\n    uv *= 20.0;\n    \n    vec2 M = iMouse.xy / iResolution.xy;\n    \n    \n    float fRed = 0.0, fGreen = 0.0, fBlue = 0.0;\n    \n    vec2 fi = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec3 modulator = colorWheel(M.x, M.y, 0.5);\n    \n    vec3 refAColor = modulator;\n    vec3 refBColor = modulator.bgr;\n    \n    vec3[] pcts = vec3[](\n        vec3(0.0528634, 0.050209, 0.0123966),\n        vec3(0.319672, 0.2823529, 0.132653),\n        vec3(0.1307189, 0.1156069, 0.1173469)\n    );\n    \n    int I = 0;\n    vec2 bPos = vec2(0.0);\n    \n    if (mod(fi.x, 2.0) == 0.0 && mod(fi.y, 2.0) == 1.0) {\n        bPos.x = -1.0;\n    } else if (mod(fi.x, 2.0) == 0.0 && mod(fi.y, 2.0) == 0.0) {\n        I = 1;\n        bPos = vec2(-1.0);\n    } else if (mod(fi.x, 2.0) == 1.0 && mod(fi.y, 2.0) == 0.0) {\n        I = 2;\n        bPos.y = -1.0;\n    } else if (mod(fi.x, 2.0) == 1.0 && mod(fi.y, 2.0) == 1.0) {\n        I = 3;\n    } else {\n        refAColor = vec3(0.0);\n        refBColor = vec3(0.0);\n    }\n    \n    if (iMouse.z >= 1.0) {\n        vec3 a = refAColor;\n        refAColor = refBColor;\n        refBColor = a;\n    }\n    \n    for (int i = 0; i < I; i++) {\n        fRed += pcts[i].r * cos(fi.x * fi.y * iTime * 0.02);\n        fGreen += pcts[i].g * cos(fi.x * fi.y * iTime * 0.02);\n        fBlue += pcts[i].b * cos(fi.x * fi.y * iTime * 0.02);\n    }\n    \n    float B = fill(rectSDF(f + bPos, vec2(1.0)), 0.52);\n\n    vec3 color = refAColor.rgb * (1.0 + vec3(fRed, fGreen, fBlue)) * fill(rectSDF(f, vec2(1.0)), 1.0);\n    color = B == 1.0 ? refBColor.rgb * (1.0 + vec3(fBlue, fGreen, fRed)) : color;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtdGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 84], [85, 85, 115, 115, 140], [142, 172, 216, 216, 766]]}
{"id": "ctdGzs", "name": "Color Stud - Tetrachord PXIV-1b", "author": "Slals", "description": "The study consist of observing the perception of the square edges. When a plain color A is displayed inside a background of plain color B, A will form edges (4 for a square). This displays how A can have a consistent edges across colors;", "tags": ["interactionofcolor"], "likes": 3, "viewed": 115, "published": 3, "date": "1682954678", "time_retrieved": "2024-07-30T17:58:06.957821", "image_code": "float rectSDF(vec2 uv, vec2 s) {\n    return max(abs(uv.x / s.x), abs(uv.y / s.y));\n}\nfloat fill(float x, float s) {\n    return step(x, s);\n}\n\n// From easy RGB : xyz -> RGB\nvec3 colorWheel(float x, float y, float z) {\n    vec3 c = vec3(\n        x * 3.2406 + y * -1.5372 + z * -0.4986,\n        x * -0.9689 + y * 1.8758 + z * 0.0415,\n        x * 0.0557 + y * -0.204 + z * 1.057\n    );\n    \n    float t = 0.0031308;\n    if (c.r > t)\n        c.r = 1.055 * (pow(c.r, (1.0 / 2.4))) - 0.055;\n    else\n        c.r = 12.92 * c.r;\n    \n    if (c.g > t)\n        c.g = 1.055 * (pow(c.g, (1.0 / 2.4))) - 0.055;\n    else\n        c.g = 12.92 * c.g;\n    \n    if (c.b > t)\n        c.b = 1.055 * (pow(c.b, (1.0 / 2.4))) - 0.055;\n    else\n        c.b = 12.92 * c.b;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.43;\n\n    uv *= 2.0;\n    \n    vec2 M = iMouse.xy / iResolution.xy;\n    \n    \n    float fRed = 0.0, fGreen = 0.0, fBlue = 0.0;\n    \n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec3 modulator = colorWheel(M.x, M.y, sin(iTime * 0.2));\n    \n    vec3 refAColor = modulator;\n    vec3 refBColor = modulator.bgr;\n    \n    vec3[] pcts = vec3[](\n        vec3(0.0528634, 0.050209, 0.0123966),\n        vec3(0.319672, 0.2823529, 0.132653),\n        vec3(0.1307189, 0.1156069, 0.1173469)\n    );\n    \n    int I = 0;\n    vec2 bPos = vec2(0.0);\n    \n    if (i.x == 0.0 && i.y == 1.0) {\n        bPos.x = -1.0;\n    } else if (i.x == 0.0 && i.y == 0.0) {\n        I = 1;\n        bPos = vec2(-1.0);\n    } else if (i.x == 1.0 && i.y == 0.0) {\n        I = 2;\n        bPos.y = -1.0;\n    } else if (i.x == 1.0 && i.y == 1.0) {\n        I = 3;\n    } else {\n        refAColor = vec3(0.0);\n        refBColor = vec3(0.0);\n    }\n    \n    if (iMouse.z >= 1.0) {\n        vec3 a = refAColor;\n        refAColor = refBColor;\n        refBColor = a;\n    }\n    \n    for (int i = 0; i < I; i++) {\n        fRed += pcts[i].r;\n        fGreen += pcts[i].g;\n        fBlue += pcts[i].b;\n    }\n    \n    float B = fill(rectSDF(f + bPos, vec2(1.0)), 0.52);\n\n    vec3 color = refAColor.rgb * (1.0 + vec3(fRed, fGreen, fBlue)) * fill(rectSDF(f, vec2(1.0)), 1.0);\n    color = B == 1.0 ? refBColor.rgb * (1.0 + vec3(fBlue, fGreen, fRed)) : color;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 84], [85, 85, 115, 115, 140], [142, 172, 216, 216, 766]]}
{"id": "ctd3Rl", "name": "AI not included", "author": "mrange", "description": "CC0: AI not included\nTinkering around with old shaders.\nNo AI and very little human intelligence used ;)\n", "tags": ["2d", "heart"], "likes": 159, "viewed": 6433, "published": 3, "date": "1682944354", "time_retrieved": "2024-07-30T17:58:07.803560", "image_code": "// CC0: AI not included\n// Tinkering around with old shaders.\n// No AI and very little human intelligence used ;)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.58;\nconst vec3 dbcol = HSV2RGB(vec3(hoff+0.96, 0.8, 0.75));\nconst vec3 sbcol = HSV2RGB(vec3(hoff+0.95, 0.4, 1.0));\nconst vec3 gbcol = HSV2RGB(vec3(hoff+0.98, 0.9, 0.001));\nconst vec3 fbcol = HSV2RGB(vec3(hoff+0.95, 0.7, 2.0));\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  p.x = pabs(p.x, 0.05);\n\n  if( p.y+p.x>1.0 )\n      return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n  return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                  dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat df(vec2 p) {\n  vec2 hp = p;\n  const float hz = 1.0;\n  hp /= hz;\n  hp.y -= -0.6;\n  float d = heart(hp)*hz;\n  return d;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float h = (-20.0*d);\n  h = tanh_approx(h);\n  h -= 3.0*length(p);\n  h = pmin(h, 0.0, 1.);\n  h *= 0.25;\n  return h;\n}\n\nvec3 nf(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = hf(p + e.yx) - hf(p - e.yx);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  float f = (aggr * 0.5) + 0.5;\n  \n  return f;\n}\n\nfloat divf(float offset, float f) {\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  float r = abs(goff + offset - f);\n  r = max(r, gfloor);\n  return r;\n}\n\n// This way of computing \"lightning\" I found at shadertoy. Unfortunately I don't remember where.\nvec3 lightning(vec2 pos, vec2 pp, float offset) {\n  vec3 sub = 0.03*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n\n  float time = TIME+123.4;\n  float stime = time/200.0;\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*cos(vec2(sqrt(0.5), 1.0)*stime)+vec2(0.0, -11.0)*stime;\n  const float glow = 0.0125;\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  for (float i = 0.0; i < 3.0; ++i) {\n    vec3 gcol0 = (1.0+cos(0.50*vec3(0.0, 1.0, 2.0) +time+3.0*pos.x-0.33*i));\n    vec3 gcol1 = (1.0+cos(1.25*vec3(0.0, 1.0, 2.0) +2.*time+pos.y+0.25*i));\n    float btime = stime*85.0 + (i);\n    float rtime = stime*75.0 + (i);\n    float div1 = divf(offset, fbm((pos + f) * 3.0, rtime));\n    float div2 = divf(offset, fbm((pos + f) * 2.0, btime));\n    float d1 = offset * glow / div1;\n    float d2 = offset * glow / div2;\n    col += (d1 * gcol0)-sub;\n    col += (d2 * gcol1)-sub;\n  }\n    \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 4.0/RESOLUTION.y;\n  float d = df(p);\n  float h = hf(p);\n  vec3 n = nf(p);\n  const vec3 lp = vec3(-4.0, -5.0, 3.0);\n  const vec3 ro = vec3(0.0, 0.0, 10.0);\n  vec3 p3 = vec3(p, h); \n  vec3 rd = normalize(p3-ro);\n  vec3 ld = normalize(lp-p3);\n  vec3 r = reflect(rd, n);\n  float diff = max(dot(ld, n), 0.0);\n  vec3 dcol = dbcol*mix(vec3(0.15), vec3(1.0), diff);\n  float spe = pow(max(dot(ld, r), 0.0), 3.0);\n  vec3 scol = spe*sbcol;\n  float gd = d+0.0;\n  vec2 gp = p;\n  vec3 gcol = lightning(gp, pp, gd);\n  vec3 hcol = dcol;\n  hcol += scol;\n  vec3 col = vec3(0.0);\n  col += gbcol/max(0.01*(dot2(p)-0.15), 0.0001);\n  col += gcol;\n  col = mix(col, hcol, smoothstep(0.0, -aa, d));\n  col = mix(col, fbcol, smoothstep(0.0, -aa, abs(d+0.01)-0.01));\n  col *= smoothstep(1.75, 0.5, length(pp));\n\n  col = aces_approx(col); \n  col = sqrt(col); \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp); \n  fragColor = vec4(col.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctd3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 425, 425, 571], [1115, 1243, 1271, 1337, 1413], [1415, 1522, 1548, 1548, 1733], [1735, 1835, 1874, 1874, 1959], [1961, 2049, 2079, 2079, 2107], [2109, 2109, 2129, 2129, 2151], [2153, 2271, 2292, 2292, 2509], [2511, 2511, 2529, 2529, 2636], [2638, 2638, 2656, 2656, 2793], [2795, 2795, 2812, 2812, 3002], [3004, 3004, 3023, 3023, 3146], [3148, 3148, 3169, 3169, 3596], [3598, 3598, 3629, 3629, 3990], [3992, 3992, 4027, 4027, 4155], [4157, 4254, 4303, 4303, 5134], [5136, 5136, 5166, 5166, 6026], [6028, 6028, 6083, 6083, 6260]]}
{"id": "cttGRl", "name": "kaleïdoscope2", "author": "FabriceNeyret2", "description": "click to see the mirror-less scene.", "tags": ["2d", "kaleidoscope", "symmetry", "tuto", "short"], "likes": 14, "viewed": 239, "published": 3, "date": "1682941613", "time_retrieved": "2024-07-30T17:58:08.650296", "image_code": "// variant of  https://shadertoy.com/view/ctt3zf\n\n#define H(s)  fract(1e4*sin(i*vec4(R-17.,R+17.)-s))  // 4 random numbers, seed s\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, A,\n          U = ( u+u - R ) / R.y;                     // normalized coordinates\n    vec4  H; \n          \n    if (iMouse.z<=0.)                                // 6-rot symmetry + miror\n      U = length(U) * cos( abs( mod( atan(U.y,U.x), 1.05) - .525 ) - .525  + vec2(0,11) );\n    O *= 0.;\n    \n    for( float d, i=0.; i++ < 80.; )                 // loop on objects\n      H = H(17.7) + .2,                              // compute location:\n      A =   ( iTime/3. + 6.28*H.y )                  //   random angle\n          * ( H.zw *2. - 1. ),                       //   random speed\n      d = length( H.x*vec2(cos(A.x),sin(A.y)) - U )  // circle at random dist + radius\n          - .2*H(3.1).x,\n      O +=     smoothstep(2./R.y,0.,d)\n           * ( 1. + cos( i  + vec4(0,23,21,0)  ) )*.42; // random hue\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cttGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 170, 170, 1006]]}
{"id": "mlt3R2", "name": "Year of Truchets #016", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n1st of may, 1st of may....", "tags": ["raymarching", "truchet", "tiles", "truchetcore"], "likes": 18, "viewed": 234, "published": 3, "date": "1682939825", "time_retrieved": "2024-07-30T17:58:09.611726", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Year of Truchets #016\n    05/01/2023  @byt3 - (it's Gonna Be May) - m3chanic\n    \n    Just a mix of things laying around on the shader floor scrapped together \n    with some reflections and love.. \n    \n    All year long I'm going to just focus on truchet tiles and the likes!\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p, vec2(27.609,47.983)))*43758.5453);}\nfloat lsp(float b, float e, float t) { return clamp((t - b) / (e - b), 0.0, 1.0); }\n\n//@iq shapes\nfloat box( vec3 p, vec3 s ) {\n    p = abs(p)-s;\n    return length(max(p,0.))+min(max(p.x, max(p.y, p.z)),0.)-.025;\n}\nfloat box( vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\nfloat cap( vec3 p, float r, float h ) {\n    vec2 d = abs(vec2(length(p.xy),p.z))-vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nfloat vcap( vec3 p, float h, float r ) {\n    p.y -= clamp(p.y,0.,h);\n    return length(p) - r;\n}\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nconst float rep = 14.;\nconst float hrep = rep/2.;\nconst float angle = 2.*PI/rep;\nconst float angfl = angle/2.;\n\nfloat polar(inout vec2 p)  {\n    float a = atan(p.y, p.x) + angfl;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angfl;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (hrep)) ? abs(c) : c;\n} \n\nfloat column(vec3 q) {\n    q.y += 1.4;\n    vec3 p = vec3(q.x,abs(q.y)-2.35,q.z);\n    float b = cap(q.xzy,2.,1.1);\n    float c = box(p,vec3(1.35,.25,1.35))-.005;\n    polar(q.xz);\n    float g = vcap(q-vec3(1.1,-1.25,0),2.5,.175);\n    return min(c,max(b,-g));\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0),gid=vec3(0),sid=vec3(0),speed=vec3(0);\nmat2 r45,r25;\n\nconst float size = 5.;\nconst float hlf = size/2.;\nconst vec3  grid = vec3(1,1,1);\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p += speed;\n\n    vec2 id = floor((p.xz+hlf)/size);\n    vec2 q = mod(p.xz+hlf,size)-hlf;\n    \n    vec3 q2 = p+vec3(hlf,0,hlf);\n    vec2 ip = floor((q2.xz+hlf)/size);\n    q2.xz = mod(q2.xz+hlf,size)-hlf;\n    \n    float chk = mod(ip.y + ip.x,2.) * 2. - 1.;\n    float hs = hash21(id);\n    if(hs>.5) q.x*=-1.;\n\n    vec2 d2 = vec2(length(q-hlf), length(q+hlf));\n    vec2 gx = d2.x<d2.y ? vec2(q-hlf) : vec2(q+hlf);\n\n    vec3 r = vec3(gx.x,p.y,gx.y);\n    vec3 t = vec3(q.x,p.y,q.y);\n    float tk = .35+.15*sin(p.x*.4+T*2.94);\n    \n    float d3 = box(r,vec3(size));\n    float d4 = trs(r,vec2(hlf,tk));\n\n    if(hs>.75) d4 = min(length(t.yz)-tk,length(t.yx)-tk);\n\n    if(hs>.075 && hs<.1) d4 = min(length(vec3(abs(t.x)-hlf,t.yz))-tk,length(vec3(t.yx,abs(t.z)-hlf))-tk);\n\n    if(hs<.075) d4 = min(length(t.yx)-tk, length(vec3(abs(t.x)-hlf,t.yz))-tk);\n    \n    d3=max(d3,d4);\n\n    if(d3<res.x){\n        float rs=fract(hs*432.32);\n        res = vec2(d3,rs<.65?4.:3.);\n        hit = p; \n        gid = vec3(id,1);\n    }\n\n    float rs=hash21(ip*432.32);\n    float cl = column(q2-vec3(0,2,0));\n    if(cl<res.x &&chk>.5 && rs>.5){\n        res = vec2(cl,5.);\n        hit = t;\n        gid=vec3(ip.xyx);\n    }\n    \n    \n    float fl = p.y+2.;\n    if(fl<res.x){\n        res = vec2(fl,2.);\n        hit = p;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps) {\n    float d = 0., m = 0.;\n    for(int i=0;i<steps;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.4:ray.x;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec3 hue(float t) {\n    return .45 + .35*cos(PI2*t*(vec3(.12,.47,.92)+vec3(.88,.97,.85))); \n}\n\nvec4 FC = vec4(.65,.75,.75,0);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,110);\n    hitPoint = hit;  \n    sid = gid;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-5,20,-15);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.05);\n        vec3 hp = hitPoint*vec3(-1.,1,1);\n \n        float diff = clamp(dot(n,l),.1,.95);\n        \n        float shdw = 1.;\n        for( float t = .01; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 25.*h/t);\n            t += h;\n            if( shdw < MIN_DIST || t > 25. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.35);\n\n        // materials\n        if(m==2.){\n            h = vec3(.25);//hue((311.-hp.x)*.005);\n            \n            vec2 k = fract(hp.xz*.1)-.5;\n            vec2 f = fract(hp.xz*1.)-.5;\n            if(k.x*k.y>0.) f = k;\n             \n            if(f.x*f.y>0.) {\n                h=vec3(.1); \n                ref = h;\n            }\n        }\n        if(m==3.){\n            h = hue((321.-hp.x)*.005);\n            ref = h*.35;\n        }\n        if(m==4.){\n            h = vec3(.05);\n            ref = vec3(.15);\n        }\n        if(m==5.){\n            h = vec3(.95);\n            h = hue( (sid.x*.02)+(sid.y*.05)+(hp.y*.01) );\n            ref = vec3(0);\n        }\n        \n        C = (diff*h);\n        C = mix(FC.rgb,C,exp(-.0000095*d*d*d));\n        \n        ro = p+n*.0001;\n        rd = reflect(rd,n);\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r45=rot(-.685);\n    mat2 r25=rot(-.685+.1*sin(T*.25));\n    speed = vec3(T*.75,0,0);\n    float zoom = 15.;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*zoom,-(zoom+10.));\n    vec3 rd = vec3(0.,0.,1.);\n    \n    ro.yz*=r45,ro.xz*=r25;\n    rd.yz*=r45,rd.xz*=r25;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0),ref=vec3(0), fil=vec3(1);\n    float d = 0.;\n\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i==2.-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n    C = clamp(C,vec3(.01),vec3(1));\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlt3R2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[624, 624, 643, 643, 688], [689, 689, 710, 710, 769], [770, 770, 808, 808, 853], [855, 868, 897, 897, 984], [985, 985, 1017, 1017, 1095], [1096, 1096, 1135, 1135, 1240], [1241, 1241, 1281, 1281, 1337], [1338, 1338, 1364, 1364, 1433], [1547, 1547, 1575, 1575, 1759], [1762, 1762, 1784, 1784, 2020], [2193, 2193, 2214, 2214, 3555], [3557, 3557, 3587, 3587, 3827], [3829, 3829, 3872, 3872, 4097], [4099, 4099, 4118, 4118, 4192], [4225, 4225, 4319, 4319, 5931], [5933, 5933, 5974, 5974, 6592]]}
{"id": "mlcGzl", "name": "fork Water Droplets - volosati", "author": "volosati", "description": "Pseudo random water drops displayed as a simple normalmap.", "tags": ["water", "drop", "droplet"], "likes": 7, "viewed": 196, "published": 3, "date": "1682936370", "time_retrieved": "2024-07-30T17:58:10.620030", "image_code": "// Fork of \"Water Droplets\" by Marrrk. https://shadertoy.com/view/4sBcDh\n// 2023-04-30 17:03:42\n\n#define GET 2 // 0 - Height, 1 - Normal, 2 - Textured\n\nconst int maxDroplets = 10;\n\nconst float dropletExpandSpeed = 1.5;\nconst float dropletHeightFactor = 1.;\nconst float dropletRipple = 80.0;\nconst float PI = 3.141;\n\nfloat getDropletHeight(vec2 uv)\n{\n    float time = (iTime + 1245.6789) * 0.5;\n    vec2 ddxy = 1.0 / iChannelResolution[0].xy;\n    float height = 0.0;\n    for (int i = 0; i < maxDroplets; ++i)\n    {\n        float decayRate = 0.323 + 2.0 * texture(iChannel0, vec2(float(i) * ddxy.x, 0.237)).x;\n        float dropletStrength = texture(iChannel0, vec2(float(i) * ddxy.x, 0)).x;\n        float dropletStrengthBias = 0.1 + 0.2 * texture(iChannel0, vec2(float(i) * ddxy.x, 0.345)).x;\n        float dropFraction = time / decayRate;\n        float dropIndex = floor(dropFraction);\n        dropFraction = fract(dropFraction);\n\n        float dropletX = texture(iChannel0, vec2(float(i) * ddxy.x + dropIndex * 0.1, dropIndex)).x;\n        float dropletY = texture(iChannel0, vec2(float(i) * ddxy.y + dropIndex * 0.1, dropIndex)).y;\n        vec2 dropletPosition;\n\n        //if (iMouse.z > 0. || iMouse.w > 0.)\n        //{\n        //    dropletPosition = iMouse.xy / iResolution.xy - .5;\n        //}\n        //else\n        //{\n        //    dropletPosition = (vec2(dropletX, dropletY) * 2.0 - 1.0);\n        //}\n        \n        dropletPosition = (vec2(dropletX, dropletY) * 2.0 - 1.0);\n\n        float ringRadius = dropletExpandSpeed * dropFraction * dropletStrength - dropletStrengthBias;\n        float distanceToDroplet = distance(uv, dropletPosition);\n        float distanceToEdge = max(0.0, ringRadius - distanceToDroplet) / ringRadius;\n\n        float dropletHeight = distanceToDroplet > ringRadius ? 0.0 : distanceToDroplet;\n        dropletHeight = cos(PI + (dropletHeight - ringRadius) * dropletRipple * dropletStrength) * 0.5 + 0.5;\n        dropletHeight *= 1.0 - dropFraction;\n        dropletHeight *= distanceToDroplet > ringRadius ? 0.0 : distanceToDroplet / ringRadius;\n\n        height += (1.0 - (cos(dropletHeight * 3.141) + 1.0) * 0.5) * dropletHeightFactor;\n    }\n\n    return height;\n}\n\nvec3 getDropletNormal(vec2 uv)\n{\n    float NORMAL_OFF = (1.0 / 128.0);\n    vec3 off = vec3(-NORMAL_OFF, 0, NORMAL_OFF);\n\n    // s11 = Current\n    float s11 = getDropletHeight(uv);\n\n    // s01 = Left\n    float s01 = getDropletHeight(vec2(uv.xy + off.xy));\n\n    // s21 = Right\n    float s21 = getDropletHeight(vec2(uv.xy + off.zy));\n\n    // s10 = Below\n    float s10 = getDropletHeight(vec2(uv.xy + off.yx));\n\n    // s12 = Above\n    float s12 = getDropletHeight(vec2(uv.xy + off.yz));\n\n    vec3 va = normalize( vec3(off.z, 0.0, s21 - s11) );\n    vec3 vb = normalize( vec3(0.0, off.z, s12 - s11) );\n\n    vec3 normal = cross(va, vb);\n    normal.xy *= s11;\n    return normalize(normal);\n}\n\nvec3 generateNormalMap(vec2 uv)\n{\n    vec3 d = getDropletNormal(uv - 0.5);\n    return normalize(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tif (GET > 0)\n\t{\n    \tvec3 normal = generateNormalMap(uv);\n    \tif (GET == 1)\n    \t{\n    \t\tfragColor = vec4((normal + 1.0) * 0.5, 1.0);\n    \t}\n    \telse if (GET == 2)\n    \t{\n    \t\tfragColor.xyz = texture(iChannel1, normal).xyz;\n    \t}\n\t}\n\telse\n\t{\n        float h = getDropletHeight(uv);\n        fragColor = vec4(h, h, h, 1.0);\n    }\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlcGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 316, 349, 349, 2197], [2199, 2199, 2231, 2231, 2882], [2884, 2884, 2917, 2917, 2985], [2987, 2987, 3044, 3044, 3424]]}
{"id": "dlc3zl", "name": "Zellij pattern 9 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "carpet", "rug", "zellij"], "likes": 6, "viewed": 193, "published": 3, "date": "1682923321", "time_retrieved": "2024-07-30T17:58:11.457791", "image_code": "vec2 f1(vec2 a){\n    float s1 = 16.;\n    return\n        fract(a)\n        //fract(a-fract(-a)/16.)\n        //abs(fract(a)+fract(a/s1)/s1)/(1.+1./s1)\n        //abs(fract(a)-fract(a/s1)/s1)/(1.-1./s1)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n        //-vec2(1.+sign(a.x)/2.,0.5-sign(a.x)/2.)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.x/t1;\n    uv.y += (iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    vec2 uv1 = uv;\n    //uv.x = mod(uv.x,.5)+.25;\n    uv.y = mod(uv.y,.5)+.25;\n    uv.x = mod(uv.x,.5)+.25;\n    for(int k = 0; k < 6; k++){\n        uv =\n            abs(.5-uv-t2*sign(uv.y-uv.x))/1.5-1.\n            //abs(.5-uv/1.5-t2)/1.5-1.\n        ;\n        b = uv.y<uv.x;\n        if(b)\n            uv = uv.yx\n            //uv.x += .5\n            //uv.y += .5\n        ;\n        t2 =\n            triangle_wave(uv-.5).yx\n        ;\n        uv =\n            t2+triangle_wave(uv.yx).yx\n        ;\n        if(uv.y<uv.x)\n        //{t2 = t2.yx; uv=uv.yx;}\n        col.x =\n            abs((uv.x)-col.x)\n            //min((uv.x)/2.,col.x)\n        ;\n        \n        //awesome kaleidoscope effect!\n        //if(t2.y>t2.x) {t2 = t2.yx; uv=uv.yx-iTime/8.;}\n        \n        col.xyz =\n            abs(col.yzx-float(b)/2.)\n        ;\n    }\n    if (!b) col = 1.-col;\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "//remix of: https://www.shadertoy.com/view/csK3zm\n\n#define fmod(x,y) floor(max(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\n#define fmod1(x,y) floor(min(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\nvec2 mainSound(int samp, float time){  \n  float tempo = .5;\n  time /= tempo;\n  float s2 = pow(2.,1.+fmod1(time/4.,3.)),\n  s1 = pow(2.,fmod(time*s2*2.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1*2.+1.,2.)),\n  t = time/s1/pow(2.,fmod1(time/5./8.,5.))*2.,\n  t1 = 1.+fmod(t/s1,2.),\n  m4 = fmod1(t*s1/t1,s2),\n  m3 = fmod(t*s1/m1,s2);\n  t *= s1/t1;\n  float m2 = 1. + fmod(t,s1),\n  a =\n      8.*(abs(.125+fract(-t)))/1.125\n      //32.*pow((1.-(fract(t))),2.)\n  ,\n  nb = time*tempo*pow(2.,(m3+m2)/5.+7.5);\n  return (.125+abs(abs(1./s1-1./s2)/8.-abs(vec2(sin(nb),cos(nb))))*a)/1.125;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlc3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 205], [207, 207, 234, 234, 396], [398, 398, 455, 455, 1620]]}
{"id": "mtcGzl", "name": "Degenerate Donut", "author": "bub", "description": "A degenerate torus is a double covered sphere.\nSo a degenerate donut is a double covered iced sphere.\n\nAlso see https://www.shadertoy.com/view/mt3Gzl", "tags": ["3d", "raymarching", "subsurfacescattering", "sss", "ray", "volume", "torus", "volumetric", "raymarcher", "scattering", "subsurface", "surface", "scatter", "blender"], "likes": 9, "viewed": 226, "published": 3, "date": "1682920472", "time_retrieved": "2024-07-30T17:58:12.542888", "image_code": "//██████╗░░█████╗░███╗░░██╗██╗░░░██╗████████╗  ██╗\n//██╔══██╗██╔══██╗████╗░██║██║░░░██║╚══██╔══╝  ██║\n//██║░░██║██║░░██║██╔██╗██║██║░░░██║░░░██║░░░  ██║\n//██║░░██║██║░░██║██║╚████║██║░░░██║░░░██║░░░  ╚═╝\n//██████╔╝╚█████╔╝██║░╚███║╚██████╔╝░░░██║░░░  ██╗\n//╚═════╝░░╚════╝░╚═╝░░╚══╝░╚═════╝░░░░╚═╝░░░  ╚═╝\n\n// wich one do you prefer?\n// inspired by Blender Guru: https://www.youtube.com/@blenderguruofficial\n// move the mouse to rotate the donut\n\n//////////////\n//          //\n// SETTINGS //\n//          //\n//////////////\n\n// donut with ice\n//#define FROZEN_DONUT\n// just the materials color\n//#define MATERIAL_PREVIEW\n\n// antialiasing, icrease it if you have a fast computer\n#define AA 2\n// comment this if you want a concrete donut\n#define SUB_SURFACE_SCATTERING\n// sharpness of the shadows\n#define SHADOW_SHARPNESS 7.\n// pi\n#define PI 3.141592\n\n\n//////////////////////\n//                  //\n// USEFUL FUNCTIONS //\n//                  //\n//////////////////////\n\n\n// ray sphere intersection\n// tnanks to iq: https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect(vec3 ro, vec3 rd, float ra) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - ra*ra;\n    float h = b*b - c;\n    if(h<0.) return vec2(-1); // no intersection\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a); // sine and cosine\n    return mat2(c, -s, s, c);\n}\n\n// generate a random value\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// noise function by iq\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f); // S curve\n\n    float n = p.x + p.y*157. + 113.*p.z;\n\n    return mix(mix(mix(hash(n+  0.), hash(n+  1.),f.x),\n                   mix(hash(n+157.), hash(n+158.),f.x),f.y),\n               mix(mix(hash(n+113.), hash(n+114.),f.x),\n                   mix(hash(n+270.), hash(n+271.),f.x),f.y),f.z);\n}\n\n// fractal noise\nfloat fbm(vec3 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .125*noise(4.*p);\n    return f;\n}\n\n// sphere sdf\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\n// torus sdf\nfloat sdTorus(vec3 p, float r1, float r2) {\n    vec2 q = vec2(length(p.xz)-r1, p.y);\n    return length(q)-r2;\n}\n\n// union of two objects\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n// smooth minimum\n// thanks to iq: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5+.5*(b-a)/k, 0., 1.);\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\n\n///////////////\n//           //\n// MODELLING //\n//           //\n///////////////\n\n\n// materials idx\n#define MAT_DONUT 0.\n#define MAT_ICING 1.\n#define MAT_SPRINKLES 2.\n\n// polar coorninates\nvec3 polarCoords(vec3 p, float an, out float sector) {\n    an = 2.*PI/an;\n    sector = round(atan(p.z, p.x)/an);\n    p.zx *= rot(sector*an);\n    return p;\n}\n\n// scene\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e10); // big number\n             float size = 0.2;\n           float idk = 1.0;  \n    float majorRadius = idk*size + idk*size*sin(iTime); //major radius\n            \n    // rotate the point\n    p.xz *= rot(.75*PI);\n    p.yz *= rot(.3*PI);\n    \n    // displacement\n    float f = sin(20.*p.x)*sin(20.*p.y)*sin(20.*p.z);\n    // radius of the torus\n    float r = .24-.01*sin(16.*p.y+8.); // this sinus makes the donut less round\n    // donut\n    d = opU(d, vec2(sdTorus(p, majorRadius, r)-.005*f, MAT_DONUT));\n    \n    // icing\n    float i = sdTorus(p, majorRadius, r+.05)-.0035*f;\n    \n    // woobles\n    float an = atan(p.x,p.z); // horizontal axis of the polar coordinates\n    float h = sin(10.*an)*.028;\n    h += .009*sin(24.*an+3.);\n    h *= dot(p.xz, p.xz); // attenuate the wobbles in the hole of the donut\n    i = smin(i, h-p.y, -.06); // cut of the icing\n\n    d = opU(d, vec2(i,MAT_ICING));\n    d.x *= .8; // make the step size smaller\n\n    return d;\n}\n\n\n///////////////\n//           //\n// RENDERING //\n//           //\n///////////////\n\n\n// raymarching loop\n// return the distance and material idx\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin;\n    for (int i=0; i<256 && t<tmax; i++) {\n        vec3 p = ro + rd*t; // point\n        \n        vec2 h = map(p); // distance to the scene and material idx\n        if (h.x<.001) return vec2(t,h.y); // we hit the surface!\n        t += h.x; // march\n    }\n    return vec2(-1); // no intersection\n}\n\n// normal estimation\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0);\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n// soft shadow function\n// thanks to iq: https://iquilezles.org/articles/rmshadows/\n// k is the softness of the shadow\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=.005; t<tmax;) {\n        vec3 p = ro + rd*t;\n        \n        float h = map(p).x+.004; // offset to see better the sss\n        if (h<.001) return 0.;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res*res*(3.-2.*res); // S curve\n}\n\n// ambient occlusion function\n// k is the radius of AO\nfloat calcAO(vec3 p, vec3 n, float k) {\n    float res = clamp(.5+.5*map(p + n*k).x/k,0.,1.);\n    return res*res*(3.-2.*res); // S curve\n}\n\n// subsurface scattering function\n// thanks to iq: https://www.shadertoy.com/view/llXBWn\n// I used his function but I added small modifications\n// ra is the radius of the subsurface\n// sca is the scattered color under the surface\nvec3 calcSSS(vec3 p, vec3 n, vec3 lig, float ra, vec3 sca) {\n    float dif = dot(n, lig); // diffuse light\n    \n    float pdif = clamp(dif,0.,1.); // positive diffuse\n    float ndif = clamp(-dif,0.,1.); // negative diffuse\n    vec3 sha = vec3(1)*shadow(p, lig, 1., SHADOW_SHARPNESS); // shadow\n    sha = pow(sha, 1./sqrt(sca)); // ading sss also on the shadow\n\n    vec3 col = vec3(0);\n    col += pdif*sha; // diffuse light\n    // aproximation of the scattered light under the surface\n    col += sha*.2*sca*ra*(1.-ndif)*(1.-ndif)*pow(1.-ndif,3./ra);\n        \n    return col;\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    // transition\n    float tr = step(.5,fract((uv.x+uv.y+.05*sin(26.*uv.x))*.1+.1*iTime));\n    \n    // background\n    float stripes = step(0., sin(10.*uv.y+sin(10.*uv.x)+iTime));\n    vec3 pink = mix(vec3(1,.23,.52), vec3(1,.36,.7), stripes);\n    vec3 brown = vec3(.022,.014,.011)*(.5+.5*stripes);\n    vec3 col = mix(pink, brown, tr);\n        \n    // light direction\n    vec3 lig = normalize(vec3(-2,2,-2));\n    \n    // bounding volume\n    vec2 bound = sphIntersect(ro, rd, .81);\n    vec2 tm = vec2(-1);\n    if (bound.x>0.) { // we hit the sphere\n        tm = intersect(ro, rd, bound.x, bound.y); // distance and material idx\n    }\n    float t = tm.x;\n        \n    if (t>0.) { // we hit the surface!\n    \n        // lighting and coloring\n        \n        vec3 p = ro + rd*t; // hit point\n        vec3 n = calcNormal(p); // surface normal\n        vec3 r = reflect(rd, n); // reflected vector\n        \n        // ambient occlusion\n        float occ = 1.;\n        for (int i=0; i<4; i++) {\n            occ *= calcAO(p, n, float(i+1)*.03);\n        }\n        occ *= calcAO(p, n, .5);\n        \n        float dif = clamp(dot(n, lig), 0., 1.); // diffuse light\n        float sha = shadow(p, lig, 1., 8.); // soft shadow\n        float spe = clamp(dot(r, lig), 0., 1.); // specular light\n        float fre = 1.+dot(rd, n); // fresnel\n             \n        vec3 mat, sca, sss; // material sss scatter and sss (diffuse+shadow+sss)\n        col = vec3(0);\n        // some very ugly code, i'm to lazy to make it better\n        if (tm.y == MAT_DONUT) { // donut\n            mat = vec3(1,.55,.3);\n            sca = mat;\n            sss = calcSSS(p, n, lig, .5, sca);\n            fre = .1*pow(fre,1.5);\n            spe = 0.;\n        } else if (tm.y == MAT_ICING) { // icing\n            mat = mix(vec3(1,.3,.8), vec3(1,.72,.55), tr);\n            sca = mat*mix(vec3(1,.8,.3), vec3(1,.55,.55), tr);\n            sss = calcSSS(p, n, lig, .4, sca);\n            \n            fre = .4*pow(fre,2.);\n            spe = 1.5*pow(spe, 48.*fbm(32.*p));\n            \n            vec3 bou = mat;\n            #ifdef SUB_SURFACE_SCATTERING\n            bou *= sca;\n            #endif\n            col += .35*occ*bou*(1.-calcAO(p, n, .8)); // fake global illumination\n        } else if (tm.y == MAT_SPRINKLES) { // sprinkles\n            if (p.z>.48)      mat = vec3(.3,.7,1);\n            else if (p.z>.2)  mat = vec3(.6,.2,1);\n            else if (p.x<-.4) mat = vec3(1,.5,.7);\n            else              mat = vec3(1,.7,.4);\n            mat = mix(mat, .65*vec3(.9,.35,.15), tr);\n            \n            sca = mat*mat;\n            sss = calcSSS(p, n, lig, .3, sca);\n            fre = .3*pow(fre,3.);\n            spe = 2.*pow(spe, 32.);\n        }\n        \n        #ifdef SUB_SURFACE_SCATTERING\n        col += sss; // base layer\n        col += sca*occ*fre; // sss on raising angles\n        #else\n        col += dif*sha; // base layer\n        #endif\n        col += .08*occ; // ambient light\n        col += sss*spe; // specular\n        \n        col *= mat; // coloring\n                \n        // blue rimlight only on the white donut\n        vec3 bac = lig*vec3(-1,-1,1);\n        dif = clamp(dot(n,bac),0.,1.);\n        fre = 1.+dot(rd, n);\n        col += 2.*tr*vec3(.1,.4,1)*occ*pow(fre,4.)*dif*clamp(.2+.8*dot(rd, bac), 0., 1.);\n        \n        // cheap ice effect\n        #ifdef FROZEN_DONUT\n        col += occ*.7*vec3(.3,.7,1)*pow(fre, 3.*pow(fbm(8.*p),.5));\n        #endif\n        #ifdef MATERIAL_PREVIEW\n        col = mat*occ*(.5+.5*n.y);\n        #endif\n    }\n        \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // music frequency\n    float freq = texture(iChannel0, vec2(0,.1)).r;\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n)/float(AA)-.5; // antialiasing offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy)/iResolution.y;\n        p *= .9-.2*freq; // music bounce\n        \n        // normalized mouse coordinates\n        vec2 mo = iMouse.xy/iResolution.xy;\n        // normalized pixel coordinates\n        vec2 q = (fragCoord+off)/iResolution.xy;\n\n        // time value\n        float time = .5*iTime + mo.x*PI*2.;\n                                \n        vec3 ro = vec3(0,0,3); // ray origin\n        ro.xz *= rot(time); // rotate the camera\n        vec3 ta = vec3(0); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n    \n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n        vec3 col = render(ro, rd, q);\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    tot = 2.*tot/(1.+tot); // tonemapping\n    tot = pow(tot, vec3(.4545)); // gamma correction\n                    \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .5+.5*pow(24. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    // dithering\n    tot += hash(fragCoord.x+13.*fragCoord.y)/255.;\n                \n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [{"id": 31270, "src": "https://soundcloud.com/lukrembo/biscuit-3", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtcGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1542, 1632, 1679, 1679, 1861], [1863, 1884, 1903, 1903, 1988], [1990, 2017, 2038, 2038, 2074], [2076, 2100, 2121, 2121, 2485], [2487, 2504, 2523, 2523, 2632], [2634, 2648, 2681, 2681, 2707], [2709, 2722, 2765, 2765, 2833], [2835, 2859, 2885, 2885, 2915], [2917, 2990, 3029, 3029, 3107], [3277, 3298, 3352, 3352, 3454], [3456, 3465, 3483, 3483, 4459], [4544, 4604, 4662, 4662, 4977], [4979, 5000, 5025, 5025, 5230], [5232, 5351, 5404, 5404, 5689], [5691, 5746, 5785, 5785, 5883], [5885, 6115, 6175, 6175, 6690], [6692, 6714, 6754, 6772, 10308], [10310, 10329, 10363, 10363, 10497], [10499, 10499, 10556, 10579, 11950]]}
{"id": "mt3Gzl", "name": "Degenerate Torus 2", "author": "bub", "description": "This is an animation of a ring torus transforming into a horn torus, then a spindle torus, and then degenerating into a double-covered sphere. https://en.wikipedia.org/wiki/Torus", "tags": ["3d", "sdf", "torus", "gradient", "normal", "analytic"], "likes": 3, "viewed": 180, "published": 3, "date": "1682918070", "time_retrieved": "2024-07-30T17:58:13.291886", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgTorus() returns the torus SDF and its gradient, by \n// computing it analytically. This means the normal to\n// the torus surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n// Ellipsoid: https://www.shadertoy.com/view/flXyRS\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .w = ∂f(p)/∂z\n// .yzw = ∇f(p) with ‖∇f(p)‖ = 1\n\n//where is major radius and minor radius?\n//ra is major and rb is minor?\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n    float h = length(p.xz);\n    return vec4( length(vec2(h-ra,p.y))-rb,\n                 normalize(p*vec3(h-ra,h,h-ra)) );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    float size = 0.2;\n   \n   float idk = 1.0;\n   \n    // animate torus\n    float majorRadius = idk*size + idk*size*sin(iTime); //major radius\n    float minorRadius = size; //minor radius\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgTorus(pos,majorRadius,minorRadius).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgTorus(pos,majorRadius,minorRadius).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgTorus( pos + e.xyy*eps, majorRadius, minorRadius ).x + \n                             e.yyx*sdgTorus( pos + e.yyx*eps, majorRadius, minorRadius ).x + \n                             e.yxy*sdgTorus( pos + e.yxy*eps, majorRadius, minorRadius ).x + \n                             e.xxx*sdgTorus( pos + e.xxx*eps, majorRadius, minorRadius ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt3Gzl.jpg", "access": "api", "license": "mit", "functions": [[1660, 1733, 1778, 1778, 1903]]}
{"id": "Dl33zs", "name": "GPT 3.5 green fractal pattern", "author": "mbaernestocr", "description": "PROMPT: Create code written in GLSL (OpenGL Shading Language) for ShaderToy.com, the code must creates a moving animated fractal patterns of colorful dots moving, make a very simple version, use a maximum of 25 lines of code.", "tags": ["fractal", "pattern", "gpt"], "likes": 0, "viewed": 134, "published": 3, "date": "1682907334", "time_retrieved": "2024-07-30T17:58:14.148595", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0; // normalize coordinates\n    vec2 z = vec2(0.0); // initialize complex number\n    \n    // fractal iteration\n    for (int i = 0; i < 10; i++) {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + vec2(p.x*2.0, p.y*2.0);\n    }\n    \n    // color the dots based on the position\n    vec3 color = vec3(sin(z.x + iTime), cos(z.y + iTime), sin(z.x + z.y + iTime));\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl33zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 505]]}
{"id": "Dt3Gzs", "name": "GPT-3 animated blue sphere ", "author": "mbaernestocr", "description": "PROMPT: Create code written in GLSL (OpenGL Shading Language) for ShaderToy.com, the code must creates an animated blue sphere bouncing in a red background. \n\nRESULT: It animates the sphere using a sine wave function to create a bouncing effect. ", "tags": ["sphere", "animated", "blue", "gpt3"], "likes": 1, "viewed": 115, "published": 3, "date": "1682904797", "time_retrieved": "2024-07-30T17:58:15.075118", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy / iResolution.xy) - 0.5; // center the coordinate system\n    p.x *= iResolution.x / iResolution.y; // correct the aspect ratio\n    \n    // background color\n    vec4 bgColor = vec4(1.0, 0.0, 0.0, 1.0); // red\n    \n    // sphere properties\n    vec3 spherePos = vec3(0.0, 0.0, 0.0); // sphere center position\n    float sphereRadius = 0.3;\n    vec3 sphereColor = vec3(0.0, 0.0, 1.0); // blue\n    \n    // sphere animation\n    float speed = 0.5;\n    float time = iTime * speed;\n    float bounce = abs(sin(time)); // bouncing effect\n    vec3 sphereOffset = vec3(0.0, bounce * 0.5, 0.0);\n    spherePos += sphereOffset;\n    \n    // calculate distance between pixel and sphere center\n    float dist = length(p - spherePos.xy);\n    \n    // check if pixel is inside the sphere\n    if (dist < sphereRadius) {\n        // calculate color based on distance from sphere center\n        vec3 color = mix(sphereColor, vec3(1.0), smoothstep(0.0, sphereRadius, dist));\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = bgColor;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3Gzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1117]]}
{"id": "ctc3Rs", "name": "ECR Colorful Moving Bands", "author": "mbaernestocr", "description": "In this version, we've adjusted the conditions for the red and green waves to be shown by changing the range for uv.y in the if statement. We've also added a buffer on the right side by adjusting the range for uv.x. ", "tags": ["colorful", "bands", "moving"], "likes": 0, "viewed": 102, "published": 3, "date": "1682903570", "time_retrieved": "2024-07-30T17:58:16.064474", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalize the coordinates to range from -1 to 1\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    // calculate the pixel aspect ratio\n    float aspect = iResolution.x / iResolution.y;\n    \n    // set the wave parameters\n    float time = iTime * 0.5;\n    float freq1 = 1.0;\n    float freq2 = 2.0;\n    float freq3 = 3.0;\n    float amp1 = 0.1;\n    float amp2 = 0.15;\n    float amp3 = 0.2;\n    \n    // calculate the wave values\n    float wave1 = sin(uv.x * freq1 + time) * amp1;\n    float wave2 = sin(uv.x * freq2 + time) * amp2;\n    float wave3 = sin(uv.x * freq3 + time) * amp3;\n    \n    // combine the waves\n    float totalWave = wave1 + wave2 + wave3;\n    \n    // map the value to colors\n    vec3 color = vec3(0.0);\n    if (totalWave < -0.4) {\n        color = vec3(0.1, 0.1, 0.1);\n    } else if (totalWave < 0.0) {\n        color = vec3(0.0, 0.0, 1.0);\n    } else if (totalWave < 0.4) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.1);\n    }\n    \n    // render the waves\n    if (uv.y < -0.4 || uv.y > 0.4 || uv.x > -aspect + 0.2) {\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctc3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 110, 1254]]}
