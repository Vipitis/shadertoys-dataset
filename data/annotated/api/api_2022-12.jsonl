{"id": "dssXWN", "name": "2023", "author": "catafest", "description": "Happy New Year 2023! \nmy shader builds for the year 2023.", "tags": ["catafest", "2023"], "likes": 7, "viewed": 162, "published": 3, "date": "1672523526", "time_retrieved": "2024-07-30T16:09:52.368878", "image_code": "mat2 rotate2d(float angle){\n   return mat2(\n       cos(angle),-sin(angle),\n       sin(angle),cos(angle)\n   );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //f = texelFetch(iChannel0, ivec2(g),0);\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    float a = 3.1415/6.;\n    float a_cos = cos(a);\n    float a_sin = sin(a);\n    mat2 rot = mat2(a_cos, -a_sin, a_sin, a_cos); \n    for (float i=0.0; i<3.; i++ )\n        uv = abs(uv*rot);  \n    for (int i = 0; i <11; i++) {\n        float a = atan(uv.y, uv.x)*(0.5 + cos(iTime*0.2)*uv.y);\n        a_sin = sin(a);\n        a_cos = cos(a);\n        uv = uv * mat2(a_cos, -a_sin, a_sin, a_cos);\n        uv.y = abs(uv.y) + sin(iTime)*0.4 *uv.x;\n        uv.x += 0.2+ sin(iTime)*0.02 + 0.02;\n    }\n    uv /= 3.1;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    uv *= rotate2d(iTime)*12.0; // Scale the coordinate system by 10\n    vec2 int_pos = floor(uv);  // get the integer coords\n    vec2 float_pos = fract(uv);  // get the fractional coords\n\n    // rand for cell\n    vec3 color = a+vec3(uv.x-uv.y);\n\n    // color\n    color =vec3(0);\n    color *= vec3(11.0, 11.0, 11.0);\n    // Time varying pixel color\n    vec3 col = sin(uv.xyx+vec3(cos(1.0/iTime),sin(1.0/iTime),(int_pos/iTime).x*cos(1.0/iTime)));\n        fragColor = vec4(\n        smoothstep((int_pos/iTime).x, (int_pos/iTime).y, fract(abs(uv.y-(float_pos/iTime).x)+iTime)),\n        smoothstep((int_pos/iTime).x, (int_pos/iTime).y, fract(abs(uv.y-(float_pos/iTime).x)+iTime)),\n        smoothstep((int_pos/iTime).x, (int_pos/iTime).y, fract(abs(uv.y-(float_pos/iTime).x)+iTime)),\n    1.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31793, "src": "https://soundcloud.com/mdindir16/abba-happy-new-year-www", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 111], [113, 113, 170, 216, 1772]], "test": "untested"}
{"id": "Dlf3Df", "name": "Swetugg for Windows Terminal", "author": "mrange", "description": "CC0: Swetugg for Windows Terminal\nPorting the Swetugg logo to windows terminal\nLots of random hacking to make the colors pop a bit.\n\nhttps://mrange.github.io/windows-terminal-shader-gallery/", "tags": ["2d", "swetugg"], "likes": 13, "viewed": 341, "published": 3, "date": "1672514754", "time_retrieved": "2024-07-30T16:09:53.340280", "image_code": "// CC0: Swetugg for Windows Terminal\n//  Porting the Swetugg logo to windows terminal\n//  Lots of random hacking to make the colors pop a bit.\n\n// https://mrange.github.io/windows-terminal-shader-gallery/\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat polygon5(vec2 p, vec2[5] v) {\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=5-1; i<5; j=i, i++ ) {\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n    bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n    if( all(c) || all(not(c)) ) s*=-1.0;  \n  }\n  return s*sqrt(d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat polygon8(vec2 p, vec2[8] v) {\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=8-1; i<8; j=i, i++ ) {\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n    bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n    if( all(c) || all(not(c)) ) s*=-1.0;  \n  }\n  return s*sqrt(d);\n}\n\nvec3 swetugg(vec2 p) {\n  const vec2[8] p2 = vec2[8](\n    vec2(0.98, 0.965)-0.98*vec2(1.0, 0.67)\n  , vec2(0.98, 0.965)\n  , vec2(1.245, 0.935)\n  , vec2(1.13, 0.165)\n  , vec2(1.18, -0.09)\n  , vec2(0.91, -0.625)\n  , vec2(0.405, -0.97)\n  , vec2(0.00, 0.08)\n  ); \n\n  const vec2[5] p3 = vec2[5](\n    vec2(-0.1, -0.8)\n  , vec2(0.082, -0.42)\n  , vec2(0.045, 0.18)\n  , vec2(0.1, 0.38)\n  , vec2(-0.1, 0.4)\n  );\n  \n  p.x = abs(p.x);\n  float d3 = polygon5(p, p3);\n\n  p.x *= mix(0.95, 1.05, (0.5+0.5*sin(TAU*TIME*5.0))*smoothstep(0.9, 1.0, sin(TAU*TIME/10.0)));\n  float d0 = triangle(p, vec2(0.055, -0.07), vec2(0.405, -0.97), vec2(0.91, -0.625));\n  float d1 = triangle(p, vec2(1.13, 0.165)-1.18*vec2(1.0, 0.0375), vec2(1.245, 0.935), vec2(1.13, 0.165));\n  float d2 = polygon8(p, p2);\n\n  float dx = d0;\n  dx = min(dx, d1);\n  float dy = d2;\n  float dz = d3;\n  \n  return vec3(dx, dy, dz);\n}\n\nvec3 df(vec2 p) {\n  const float z = 0.5;\n  const mat2 rot = ROT(radians(7.0));\n  p /= z;\n  p.xy *= rot;\n  return swetugg(p)*z;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 dd = df(p);\n  float dt = min(min(dd.x, dd.y), dd.z);\n\n  const vec3 col0 = vec3(104.0, 0.0, 19.0)/255.0;\n  const vec3 col1 = vec3(166.0, 0.0, 31.0)/255.0;\n  const vec3 col2 = vec3(16.0, 16.0, 17.0)/255.0;\n\n  vec3 col  = 0.1*sqrt(col0);\n  col += col1*exp(-20.0*dd.z*dd.z);\n  col = mix(col, col1*2.0, smoothstep(aa, -aa, abs(dt)-0.005));\n  col = mix(col, col1*mix(0.5, 1.0, 40.0*dd.y*dd.y), smoothstep(aa, -aa, dd.y));\n  col = mix(col, col0*mix(0.5, 1.0, 30.0*-dd.x), smoothstep(aa, -aa, dd.x));\n  col = mix(col, col2*20.0*-dd.z, smoothstep(aa, -aa, dd.z));\n  \n  col *= 1.5*smoothstep(1.25, 0.0, length(pp));\n  col = sqrt(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, pp);\n \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlf3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 560, 560, 706], [1001, 1119, 1170, 1170, 1735], [3637, 3637, 3654, 3654, 3765], [3767, 3767, 3797, 3797, 4477], [4479, 4479, 4536, 4536, 4714]], "test": "untested"}
{"id": "mts3Wj", "name": "kiosk", "author": "spqr", "description": "a", "tags": ["a"], "likes": 9, "viewed": 249, "published": 3, "date": "1672509805", "time_retrieved": "2024-07-30T16:09:54.328638", "image_code": "\n\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nfloat hash12(vec2 p ) {\n  float a = fract(sin(p.x * 4321.531) * 9831.113);\n float b = fract(sin(p.y * 5959.951) * 7891.517);\n float c = fract(\n sin(a * 4523.232 + b * 5490.954) * 9954.234);\n return c;\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\n\n\n\n\n\n\n\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s =10.;\n  for ( float i = 0.; i <5.; i++ ) {\n \n    p.yz *= rot((t + i));\n    p.xz *= rot((t - i) * .7);\n    \n   \n    p = abs(p);\n    \n    p -= s;\n    s *= 0.7;\n  }\n  return p;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n    //pt.xz=pt.x<pt.z?pt.zx:pt.xz;\n  }\n  return pt;\n}\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n\n\n\n\n\n\nfloat highway (vec3 p , vec3 shape, vec3 off, vec3 dir, float prob) {\n\n  prob *= .4;\n  dir *= .47;\n  shape *= .11;\n  p += off + dir * iTime * 3.11; \n  vec3 q = opRep(p, vec3(30,30,30)) ;\n  vec3 qid = opId(p, vec3(30,30,30));\n  float lim = fract(hash(qid * 1.7));\n  float s;\n  \n  prob *=1.;\n  \n  if ( lim < prob ) {\n      return runner(q);\n  } else {\n      return 10.;\n  }\n\n\n}\nint matter = 0;\nfloat artifact(vec3 p, float f1) {\n\n\n  \n  vec3 p1 = p;\n  vec3 p2 = p;\n  vec3 p3 = p;\n  vec3 p4 = p;\n  vec3 p5 = p;\n  vec3 p6 = p;\n\n\n\n \n  //float final = R;\n  float final=10000.;\n  \n vec3 pt=p;\n  \n  //vec3 pr = p;\n  //pr = p + vec3(10,-27.565,243.7 * time)/3.3; \n  //pr = rep(pr, vec3(20,50,20));\n  //float run = runner(pr);\n  \n  \n  \n  //float width = mix(5.,15., abs(sin(iTime/100.)));\n  float width = 13.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n \n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(pt,vec3(3.6,3.0+0.4+(iTime + f1 * 321.1)/11.,3.1),vec3(3.0,2.3,3.5));\n\n  vec3 seed = floor(p/width);\n\n  float dist;\n  \n  dist=box(pt,vec3(1.)*.17);\n\n  dist=max(dist,clampBox);\n\n  return dist;\n \n}\nvec3 polar ( vec3 p ) {\n  float pi = 3.141592;\n  p =  vec3(atan(p.x,p.y)*pi*(1.), length(p.xy) - 8. , p.z );\n  return p;\n}\n\nfloat map(vec3 p) {\n  \n  p = polar(p);//mix(p, polar(p), sin(iTime)*.5+.5);\n    // geo\n  \n \n  float domx = 4.5;\n  float domy = 14.;\n  vec2 id = floor(p.xz/domx);\n  float f1 = hash12(id);\n  \n  p.x = mod(p.x, domx) - domx/2.;\n  p.z = mod(p.z, domy) - domy/2.;\n \n float a = artifact(p,f1);\n  return a;\n}\n\n\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\n\n\nvec3 flitfbm(float t) {\n    vec3 z = vec3(0);\n    float amp = 1.;\n    float freq = 1.;\n    for (float a = 0.; a < 5.; a++) {\n      z += flit((t+a) * freq) * amp;\n      freq *= 1.5;\n      amp /=1.4;\n    }\n    \n    return z;;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n  \n  // nav\n  \n  float tt = iTime * 1.;\n  \n  //tt = sin(tt) + tt;\n\n  \n  vec3 adv = vec3(0.,0.,21.) * iTime;\n  \n \n  vec3 s = vec3(0.,0.,0.) + adv;\n  vec3 t = vec3(0.,0.,100.) + adv;\n  \n  s+= bezier(iTime*2.1)*1.;\n  t+= bezier(iTime*3.1)*1.;\n \n  s += sin(iTime)* vec3(4,0,0);\n  s += sin(iTime*.81) * vec3(0,2,0);\n  \n  s += flitfbm(iTime*1.41)*.4;\n  //t += flitfbm(iTime*1.71)*.01;\n  \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz -= dot(uv,uv)/6.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  r.xy *= rot(noise(s/100.)*3.);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n \n  for(float z=0.;z<200.;z++){ \n  \n    i = z;\n    d = map(p);\n\n    if ( d < .0001 ) {\n      hit = true;\n      break;\n    } \n    \n    dd += d;\n    p += r * d;\n  \n\n  }\n \n  \n  \n  // hue\n  \n  vec3 col = vec3(.8, .5, .2);\n\n\n\n  n2 = norm(p, vec2(0.0, 1.0E-2 ));\n  n1 = norm(p, vec2(0.0, 2.5E-2 ));\n\n\n  edge = saturate(length(n1-n2)/0.1);\n  \n  col -= edge*22.;\n\n  \n  if (! hit){\n      col = vec3(.93, .95, .90);\n      //col = vec3(1);\n  }\n  \n  \n \n  fragColor = vec4(col, 1.0);\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 208, 208, 311], [312, 312, 334, 334, 542], [544, 544, 567, 567, 746], [748, 748, 802, 857, 1081], [1083, 1083, 1107, 1107, 1309], [1313, 1313, 1342, 1342, 1407], [1408, 1408, 1450, 1450, 1557], [1559, 1559, 1582, 1582, 1690], [1692, 1692, 1716, 1716, 2263], [2265, 2265, 2287, 2287, 2495], [2497, 2497, 2522, 2522, 2555], [2557, 2557, 2579, 2579, 2697], [2701, 2701, 2722, 2722, 2771], [2772, 2772, 2792, 2792, 2841], [2843, 2843, 2864, 2864, 2911], [2912, 2912, 2931, 2931, 3000], [3001, 3001, 3021, 3021, 3400], [3401, 3401, 3426, 3426, 3895], [3897, 3897, 3920, 3920, 3998], [3999, 3999, 4019, 4019, 4203], [4205, 4205, 4228, 4228, 4354], [4357, 4357, 4386, 4386, 4415], [4419, 4419, 4444, 4444, 4484], [4489, 4489, 4503, 4503, 4543], [4546, 4546, 4582, 4582, 4635], [4659, 4659, 4683, 4683, 4738], [4741, 4741, 4765, 4765, 4851], [4860, 4860, 4880, 4880, 5094], [5095, 5095, 5121, 5121, 5170], [5174, 5174, 5213, 5213, 5290], [5293, 5293, 5323, 5323, 5349], [5352, 5352, 5390, 5390, 5713], [5716, 5716, 5739, 5739, 5852], [5853, 5853, 5874, 5874, 6273], [6275, 6275, 6297, 6297, 6502], [6504, 6504, 6531, 6531, 6557], [6559, 6559, 6587, 6587, 6618], [6619, 6619, 6643, 6643, 6834], [6841, 6841, 6910, 6910, 7216], [7233, 7233, 7267, 7267, 8047], [8048, 8048, 8071, 8071, 8170], [8172, 8172, 8191, 8191, 8472], [8477, 8477, 8503, 8503, 8628], [8631, 8631, 8651, 8651, 8770], [8776, 8776, 8797, 8797, 8820], [8824, 8824, 8847, 8847, 9049], [9052, 9052, 9109, 9109, 10462]], "test": "untested"}
{"id": "DtfGDX", "name": "Time Sync Demo", "author": "lennyjpg", "description": "machine sync testing", "tags": ["realtime"], "likes": 1, "viewed": 170, "published": 3, "date": "1672504625", "time_retrieved": "2024-07-30T16:09:55.088606", "image_code": "// test sync for multiple machines via time\n//\n//\n// related shaders\n// https://www.shadertoy.com/view/ldKGRR\n// https://www.shadertoy.com/view/Ms3XzM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = round(fract(iDate.w * .5));\n    fragColor = vec4(t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 209, 209, 278]], "test": "untested"}
{"id": "ctX3DX", "name": "MMXXIII", "author": "mla", "description": "The complete tripartite graph K(17,51,17) has 2023 (= 7.17²) edges, so here it is. Best full screen.\n\nHappy New Year to all!", "tags": ["complete", "2023", "tripartite"], "likes": 16, "viewed": 274, "published": 3, "date": "1672504534", "time_retrieved": "2024-07-30T16:09:55.828627", "image_code": "vec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// Signed distance from p segment qr. Positive distance for\n// points on the left of the line looking from q to r.\nfloat ssegment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  k = clamp(k,0.0,1.0);\n  vec2 closestpoint = k*r;\n  float dist = distance(p,closestpoint);\n  vec2 normal = vec2(-r.y,r.x);\n  float s = dot(p,normal) >= 0.0 ? 1.0 : -1.0;\n  return s*dist;\n}\n\nvec3 diagram(vec2 p, float N) {\n  p.y = abs(p.y);\n  float px = fwidth(p.x);\n  float d = 1e8;\n  float imin;\n  vec3 col = vec3(1,1,0.5);\n  float k = iResolution.y/iResolution.x*25.5;\n  float M = 3.0*N+1.0;\n  for (float i = -N, j = M; i <= N && j >= -M; ) {\n    float d1 = ssegment(p,vec2(3.0*i,k),vec2(j,0)+vec2(0.5*sign(j),0));\n    if (abs(d1) < d) { d = abs(d1); imin = i; }\n    if (d1 > 0.0) i++;\n    else j--;\n  }\n  col = mix(h2rgb(float(imin+N)/float(2.0*N+1.0)),col,smoothstep(0.0,px,d));\n  d = 1e8;\n  for (float i = -N, j = N; i <= N && j >= -N; ) {\n    float d1 = ssegment(p,vec2(3.0*i,k),vec2(3.0*j,-k));\n    if (abs(d1) < d) { d = abs(d1); imin = i; }\n    if (d1 > 0.0) i++;\n    else j--;\n  }\n  //col = mix(h2rgb(float(imin+8)/17.0),col,smoothstep(0.0,px,d));\n  col = mix(vec3(0),col,smoothstep(0.0,px,d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 25.5;\n  vec2 p = scale*(2.0*fragCoord-iResolution.xy)/iResolution.x;\n  float t = mod(iTime,40.0);\n  if (t > 20.0) { p.x = -p.x; t -= 20.0; }\n  t = min(t,20.0-t)-1.0;\n  t = clamp(t,0.0,8.0);\n  vec3 col = diagram(p,t);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctX3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 154], [156, 271, 311, 311, 550], [552, 552, 583, 583, 1382], [1384, 1384, 1437, 1437, 1730]], "test": "untested"}
{"id": "dts3D2", "name": "Foggy laser tunnel", "author": "Virgill", "description": "Have a nice party tonight. Here´s a laser tunnel for you :)\n", "tags": ["tunnel", "madtracer", "madtracing"], "likes": 14, "viewed": 448, "published": 3, "date": "1672489235", "time_retrieved": "2024-07-30T16:09:56.731214", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n    float flicker = 0.15*fract(iFrameRate*iTime*0.333)+0.8;\n    fragColor = texture(iChannel0, uv)*flicker;\n    vec2 uv_border = (fragCoord.xy/iResolution.xy)*vec2(1.0,-1.0);\n    if (uv_border.y<-0.80||uv_border.y>-0.20) fragColor= vec4(0.0);  // black borders\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31782, "src": "https://soundcloud.com/virgill/nihil-admirari", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "\n#define FAR 10.0\n#define ITER 25\n#define BOUNCES 3\n\n\n// palette calculation (IQ)\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 col( in float t)\n{\nreturn pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n\n}\n\n// hemispherical hash function (fizzer+slerpy)\nvec3 hashHs( vec3 n, uint seed )\n{\n    float a=(float((seed*0x73493U)&0xfffffU)/float(0x100000))*2.-1.;\n    float b=6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float c=sqrt(1.-a*a);\n    vec3 r=vec3(c*cos(b),a,c*sin(b));\n    return dot(r,n)>0.?r:-r;\n    //return r;\n}\n\n\n// 3d noise function (shane)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n\n// smooth minimum function (iq)\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// signed distance box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.));\n\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// 3d rotation function\nvoid pR(inout vec2 p,float a) \n{\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n// sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// min for the map function\nvoid dmin(inout vec3 d, in float x, in float y, in float z)\n{\n    if(x < d.x) d = vec3(x,y,z);\n}\n\nvec3 map(vec3 p)\n{\n    vec3 d = vec3(1e+31,0,0); \n    float floornoise = noise(3.*p+0.2*iTime)+0.1*noise(20.*p+0.1*iTime); \n    \n    dmin(d,smin(7.-p.z,8.,8.),1.,.0);\n    vec3 q=p;\n\n    pR(q.yz,(3.1415*.5));\n    float cylinder = max(-sdCylinder(q,vec3(0.0,0.0,1.)),sdCylinder(q,vec3(0.0,0.0,1.)));\n    dmin(d,cylinder,2.-2.*floornoise,1.0);\n    \n    float random = iTime*iFrameRate;\n   // random=0.;\n    float beam = sdCylinder(q,vec3(sin(random),cos(random),.005));\n    dmin(d,beam,4.-2.*floornoise,0.);\n\n    return d;\n}\n\n// normal calculation function\nvec3 normal(vec3 p, float k)\n{\n    float m = map(p).x;\n\tvec2 e = vec2(0.,k);\n\treturn normalize(m-vec3(map(p - e.yxx).x,map(p - e.xyx).x,map(p - e.xxy).x));\n}\n\n\n// standard ray marching function\nvec3 tracer(vec3 ro, vec3 rd)\n{    \n    vec3 m;\n    float t=.001;\n    for(int i=0; i < ITER; i++)\n    {\n        m = map(ro + rd*t);\n        if(t > FAR)break;\n        if(m.z!=0.) t += abs(m.x); else t += m.x; \n    }\n    return vec3(t, m.yz);\n}\n\n\n// set up a very basic camera (ro= ray origin, rd=ray direction)\nvoid camera(out vec3 ro, out vec3 rd, in vec2 p)\n{\n\n\tvec2 uv = (2.*p.xy-iResolution.xy)/iResolution.x*vec2(1.0,-1.0);\n\tro =  vec3(0,0, -3);\n    rd =  normalize(vec3(uv, 1));\n    pR(ro.yz,0.15*sin(0.1*iTime));    \n    pR(ro.xz,0.15*cos(0.1*iTime));   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // feedbak noise (with buffer a)\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n   \tuv.x-=0.0002*noise(uv.yxx*32.-iTime)-0.00002; \n   \tuv.y+=0.0002*noise(uv.yxx*32.+iTime)-0.00002; \n    vec4 buffer= texture(iChannel0,uv);\t\t  \n\n    uint seed = uint(fragCoord) * uint(fragCoord.y); \n    vec3 emit = vec3(0), ro, rd, t, sp, sn;\n    \n    camera(ro, rd, fragCoord); \n    \n    for(int i=0; i<BOUNCES; i++)\n    {\n        t = tracer(ro, rd);\n        sp = ro + rd*t.x; \n\t\tsn = normal(sp,0.001); \n        if(t.y > 1.) emit = t.y * col(t.z+0.25*iTime); \n        seed *= uint(iTime*112.); \n        rd = mix(reflect(rd, sn), hashHs(sn, seed), clamp(t.y,0.,1.));  \n        ro = sp;\n    }\n    float blur=.97; \t\t\t\n    float amplify =.02; \n    \n    emit*=amplify;\n    \n    fragColor = vec4(emit.x,emit.y,emit.z, 1.)+buffer*blur;\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dts3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 363]], "test": "untested"}
{"id": "dlsGW2", "name": "matrix order, matrix mul", "author": "FabriceNeyret2", "description": "guessing matrix order and vec*matrix order in computer languages is always a nightmare.\nA quick test to check: U * mat2(1,0,0,0) ,  U * mat2(0,1,0,0), etc.\n→ vec * mat =  horizontal * mat( vertical v1,v2 ) = vec2( dot(vec,v1), dot(vec,v2) ).", "tags": ["matrix", "short"], "likes": 8, "viewed": 264, "published": 3, "date": "1672478243", "time_retrieved": "2024-07-30T16:09:57.558003", "image_code": "#define S(v)  smoothstep( 6./R.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n     vec2 R = iResolution.xy, U = u/R, V;\n  // O = vec4( U * mat2( 1,0, 0,0 ) , 0,0 );  //  red horizontal gradient\n  // O = vec4( U * mat2( 0,1, 0,0 ) , 0,0 );  //  red vertical gradient\n  // O = vec4( U * mat2( 0,0, 1,0 ) , 0,0 );  //  green horizontal gradient\n  // O = vec4( U * mat2( 0,0, 0,1 ) , 0,0 );  //  green vertical gradient\n     \n  // O = vec4( mat2( 1,0, 0,0 ) * U , 0,0 );  //  red horizontal gradient\n  // O = vec4( mat2( 0,1, 0,0 ) * U , 0,0 );  //  green horizontal gradient\n  // O = vec4( mat2( 0,0, 1,0 ) * U , 0,0 );  //  red vertical gradient\n  // O = vec4( mat2( 0,0, 0,1 ) * U , 0,0 );  //  green vertical gradient\n  \n     int i = ( iFrame/60) % 4;\n     O *= 0.; O[i]++;                         // set a matrix component to one, rest = 0\n     O = vec4( U * mat2(O) , 0,0);\n\n     U = 2.*( u+u - R ) / R.y;                // --- draw the boxes\n     if ( U.y > 1. && abs(U.x) < 2. ) {\n         V = abs(fract(U)-.5);\n         float a = max(V.x,V.y)-.2;\n         O += S( abs(a) );                    // frame box\n         if ( int(U.x+2.) == i ) O += S( a ); // plain box\n     }\n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 81, 81, 1188]], "test": "untested"}
{"id": "dllGW2", "name": "2023 new year", "author": "lasoy", "description": "2023", "tags": ["noise", "effect", "2023"], "likes": 10, "viewed": 371, "published": 3, "date": "1672474344", "time_retrieved": "2024-07-30T16:09:58.484526", "image_code": "// segment function modified from https://www.shadertoy.com/view/MdfGzf\nfloat segment(vec2 uv, bool On)\n{\n\tif (!On) return 0.0;\n\tfloat seg = (1.0-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t    (1.0-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)));\n\tif (On) seg *= (1.0-length(uv*vec2(3.8,0.9)));//-sin(iTime*25.0*6.26)*0.04;\n\telse seg *= -(0.05+length(uv*vec2(0.2,0.1)));\n\treturn seg;\n}\n\n// sevenSegment function modified from https://www.shadertoy.com/view/MdfGzf\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    seg += segment(uv.yx+vec2(-1.0, 0.0),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-0.5,-0.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( 0.5,-0.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0.0, 0.0),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-0.5, 0.5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( 0.5, 0.5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1.0, 0.0),num!=-1 && num!=1 && num!=4 && num!=7          );\n\t\n\treturn seg;\n}\n\n// showNum function modified from https://www.shadertoy.com/view/MdfGzf\nfloat showNum(vec2 uv,int nr)\n{\n\tif (abs(uv.x)>1.5 || abs(uv.y)>1.2) return 0.0;\n\tfloat seg= 0.0;\n\tif (uv.x>0.0){\n\t\tnr /= 10;\n\t\tseg += sevenSegment(uv+vec2(-0.75,0.0),nr);\n\t} else seg += sevenSegment(uv+vec2( 0.75,0.0),int(mod(float(nr),10.0)));\n\treturn seg;\n}\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 colorPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(2.*3.1415926*(c*t+d));\n}\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    float a = hash12(i);\n    float b = hash12(i + vec2(1, 0));\n    float c = hash12(i + vec2(0, 1));\n    float d = hash12(i + vec2(1, 1));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec3 color0 = 0.1 + 0.2*cos(iTime*2.+uv.xyx+vec3(0,2,4));\n\n\tuv *= vec2(-4, 4);\n\tuv.x += uv.y/12.0*sin(iTime*2.);\n    uv = rotate2d(noise((uv + vec2(iTime*.5)) * 2.5 + .5) * .2) * uv;\n\n    uv.x += 1.5;\n\tfloat seg = 0.0;\n\tseg += showNum(uv,23);\n    uv.x -= 3.;\n    seg += showNum(uv,20);\n    \n    vec3 color1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 finalColor = vec3(0);\n    finalColor = colorPalette(uv.x*.1 + iTime*.5, vec3(.5), vec3(.5), vec3(1.), vec3(0, .33, .67));\n\tfinalColor *= seg;\n    finalColor = smoothstep(color1, finalColor, 1. - vec3(seg));\n    finalColor += smoothstep(0.8, 0.9, 1. - seg) * color0;\n\n\tfragColor = vec4(finalColor,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 72, 105, 105, 404], [406, 483, 520, 520, 1179], [1181, 1253, 1284, 1284, 1513], [1515, 1580, 1602, 1602, 1722], [1724, 1724, 1784, 1784, 1832], [1834, 1834, 1857, 1857, 2146], [2148, 2148, 2175, 2175, 2257], [2260, 2260, 2317, 2317, 3051]], "test": "untested"}
{"id": "mtXGR2", "name": "JenKai Liu “The Reversal”", "author": "JenKaiLiu", "description": "▶️Demo Video:\nhttps://youtu.be/r4oCbazujmY\n\nReferences:\n[1]Cloudy Shapes by kaneta\n[2]Heartfelt by BigWIngs\n[3]Heart SDF Base Code by gracegi", "tags": ["raymarching", "volumetriccloud"], "likes": 45, "viewed": 730, "published": 3, "date": "1672474034", "time_retrieved": "2024-07-30T16:09:59.415039", "image_code": "// 【Raindrop amount】0. ~ 1.\n#define RAINAMOUNT 0.25\n\n\n\n\n// [2]Raindrop filter\n// https://www.shadertoy.com/view/ltffzl\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define USE_POST_PROCESSING\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainBlur( out vec4 fragColor, in vec2 fragCoord ,float focus)\n{\n    float thresh = 1.;//depth threshold\n    vec2 dir = vec2(0.1,-0.1);//blur direction\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n\n    float dist = focus;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color/=totalw;\n\tfragColor = vec4(color,dist);\n}\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 M = iMouse.xyz/iResolution.xyz;\n    float T = iTime+M.x*2.;  \n    float t = T*.2;\n    \n    float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7; // 雨水濃度\n    rainAmount = RAINAMOUNT;\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;   \n    float story = 0.;\n  \n    float staticDrops = S(-.5, 1., rainAmount)*2.;\n    float layer1 = S(.25, .75, rainAmount);\n    float layer2 = S(.0, .5, rainAmount);\n       \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n\n    vec2 e = vec2(.001, 0.);\n    float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n    float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n    vec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\n   \n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    focus = 1.-clamp(pow(focus,1.5)/15.,0.,1.); // 模糊程度，clamp到0~1\n    vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    vec4 fragcol = vec4(col,1.);\n    mainBlur(fragcol,fragCoord, focus*rainAmount);\n    //col *= fragcol.rgb; 模糊\n    //col =  vec3(focus*rainAmount);\n    \n    #ifdef USE_POST_PROCESSING\n    //t = (T+3.)*.5;\t\t\t\t\t\t\t\t\t\t// make time sync with first lightnoing\n    //float colFade = sin(t*.2)*.5+.5+story;\n    //col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n    float fade = S(0., 10., T);\t\t\t\t\t\t\t// fade in at the start\n    \n    //float lightning = sin(t*sin(t*10.));\t\t\t\t// lighting flicker\n    //lightning *= pow(max(0., sin(t+sin(t))), 10.);\t\t// lightning flash\n    //col *= 1.+lightning*fade*mix(1., .1, story*story);\t// composite lightning\n    //col *= fade*mix(1., .1, story*story);\t// composite lightning\n    \n    //col *= 1.-dot(UV-=.5, UV);\t\t\t\t\t\t\t// vignette    \t\t\t\t\t\t\t\t\t\t\t   \n    //col *= fade;\t\t\t\t\t\t\t\t\t\t// composite start and end fade\n    #endif\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// 【How the sky looks】\n// 0: Cloudy\n// 1: Rainy\n// 2: Sunny\n#define LOOK 2\n\n\n\n\n// [1]\n// Cloud simulation  \n// https://www.shadertoy.com/view/WdXGRj\n\n// noise\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n/////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// [3]Heart SDF\n// https://www.shadertoy.com/view/3ldXD7\nfloat sdHeart( vec3 p, float t )\n{\n    float y = 1.3 * p.y - abs(p.x) * sqrt(1.0 - abs(p.x));\n    vec3 p2 = vec3(p.x, y, p.z);\n    return length(p2) - t;\n}\n\n\nfloat map( in vec3 p )\n{\n    float n_speed = 0.5; // 雲霧noise變化速度 _________ default: 1., Bad Wheather: 0.5,\n\tvec3 q = p - vec3(0.0,0.5,1.0)*iTime*n_speed;\n    float f = fbm(q);\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    \n    vec3 cp = p;\n    cp.yz *= Rot(0.25);\n    float cloud = 1.0 - length(cp * vec3(0., 5., 0.12)+ vec3(0.0, -2.5, 0.7)) + f * 3.5;\n    cloud = 1.0 - length(p * vec3(0.1, 1., 0.2)) + f * 2.2;\n    //float cloud = 1.0 - length(cp * vec3(0., 5., 0.12)+ vec3(0.0, -2.5, 0.7)) + f * 3.5;\n    \n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n    float s3 = 1.0 - smin(smin(\n                           length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),\n                           length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),\n                           length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\n    \n    // Heart SDF function:\n    vec3 hp = p/3.5;\n    float sadHeart = 1. - sdHeart(hp, 0.7)*8.+ f * 4.5;\n    \n    \n    vec3 smp = hp;\n    smp.xy *= Rot(0.3+sin(iTime+2.)*0.05);\n    smp.xz *= Rot(0.2);\n    smp.zy *= Rot(0.5);\n    float smilehHeart = 1. - sdHeart(smp, 0.7)*8.+ f *1.5;\n    smp = hp;\n    smp.xy *= Rot(-0.2+sin(iTime)*0.05);\n    float smilehHeart2 = 1. - sdHeart(smp-vec3(-0.6,-0.1,0.8), 0.15)*8.+ f *1.;    \n    smp = hp;\n    smp.xy *= Rot(0.9);\n    smp.xz *= Rot(iTime);\n    float smilehHeart3 = 1. - sdHeart(smp-vec3(-0.9,0.5,0.5), 0.02)*15.+ f *2.;\n    smp = hp;\n    smp.xy *= Rot(-1.);\n    smp.yz *= Rot(-0.5);\n    smp.xz *= Rot(-iTime-1.);\n    float smilehHeart4 = 1. - sdHeart(smp-vec3(-0.9,0.5,0.2), 0.02)*15.+ f *2.;\n    \n    vec3 fp = p;\n    fp.yz *= Rot(-0.2);\n    s1 = 1.0 - length(fp * vec3(0.4, 8.0, 1.1)+vec3(0.,23.,-2.8)) + f * 5.5;\n    float smile = max(max(max(max(smilehHeart,smilehHeart2),smilehHeart3),smilehHeart4),s1);\n    \n    \n    float t = mod(stepUp(iTime, 3.0, 1.0), 3.0);\n    \n\tfloat d = mix(smile, sadHeart, clamp(t, 0.0, 1.0));\n    d = mix(d, cloud, clamp(t - 1.0, 0.0, 1.0));\n    d = mix(d, smile, clamp(t - 2.0, 0.0, 1.0));\n    \n    // A to B\n\t//d = mix(sadHeart, cloud, clamp(t, 0.0, 1.0));\n    //d= cloud;\n    //d = smilehHeart;\n    //d= cloud;\n\treturn min(max(0.0, d), 1.0);\n}\n\nfloat jitter;\n\n#if LOOK==2\n#define MAX_STEPS 48  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2. // 越小雲霧明暗對比越大 _________ default: 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n            sum.a *= 1.-density;\n\n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\n#if LOOK==1\n#define MAX_STEPS 128  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 1.25 // 越小雲霧明暗對比越大 _________ default: 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n            \n            float DensityStrength = 100.; // 雲霧密度，數值越大立體感越明顯 _________ default: 20.\n            density = clamp((d / float(MAX_STEPS)) * DensityStrength, 0.0, 1.0);\n            \n            \n            vec3 HighlightColor = vec3(0.946,0.980,1.000) *1.1; // 雲霧高光顏色 _________ default: vec3(1.1, 0.9, .5)         \n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.5);\n            sum.rgb += vec3(s * density) * HighlightColor * sum.a;\n            sum.a *= 1.-density;\n            \n            vec3 DiffuseColor = vec3(-0.01); // 雲霧底色 _________ default: vec3(0.15, 0.45, 1.1)       \n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * DiffuseColor * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\n#if LOOK==0\n#define MAX_STEPS 128  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 1.25 // 越小雲霧明暗對比越大 _________ default: 2.\n\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n            \n            float DensityStrength = 100.; // 雲霧密度，數值越大立體感越明顯 _________ default: 20.\n            density = clamp((d / float(MAX_STEPS)) * DensityStrength, 0.0, 1.0);\n            \n            \n            vec3 HighlightColor = vec3(1.); // 雲霧高光顏色 _________ default: vec3(1.1, 0.9, .5)         \n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * HighlightColor * sum.a;\n            sum.a *= 1.-density;\n            \n            vec3 DiffuseColor = vec3(0.0); // 雲霧底色 _________ default: vec3(0.15, 0.45, 1.1)       \n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * DiffuseColor * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if LOOK==2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0);\n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\n    vec3 sunPos = vec3(2., 3.5, -2.); // 太陽光位置 _________\n    float sundot = clamp(dot(ray,normalize(sunPos)),0.0,1.0);\n    result += 1.7*vec3(0.9,0.624,0.)*pow( sundot, 14.0 ); // 太陽光顏色 _________\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}\n#endif  \n#if LOOK==1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0); // 相機位置 _________ default: vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0)  \n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    \n    vec3 lowerSkyColor = vec3(0.1,0.140,0.15); // 下半天空顏色 _________ default: vec3(0.3, 0.6, 1.0) Logo: vec3(0.98,0.98,1.0)\n    vec3 upperSkyColor = vec3(0.2,0.240,0.25); // 上半天空顏色 _________ default: vec3(0.05, 0.35, 1.0) Logo:vec3(0.73,0.81,0.81)\n    \n    vec3 result = col.rgb + mix(lowerSkyColor, upperSkyColor, p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);  \n}\n#endif  \n#if LOOK==0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0); // 相機位置 _________ default: vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0)  \n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    \n    vec3 lowerSkyColor = vec3(0.98,0.98,1.0); // 下半天空顏色 _________ default: vec3(0.3, 0.6, 1.0)\n    vec3 upperSkyColor = vec3(0.73,0.81,0.81); // 上半天空顏色 _________ default: vec3(0.05, 0.35, 1.0)\n    \n    vec3 result = col.rgb + mix(lowerSkyColor, upperSkyColor, p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}\n#endif  ", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 214, 214, 237], [239, 239, 307, 307, 967], [969, 969, 988, 1014, 1186], [1188, 1188, 1207, 1207, 1295], [1297, 1297, 1315, 1315, 1361], [1363, 1363, 1392, 1392, 1427], [1429, 1429, 1464, 1464, 2616], [2618, 2618, 2655, 2655, 2931], [2933, 2933, 2993, 2993, 3212], [3214, 3214, 3271, 3271, 5211]], "test": "untested"}
{"id": "dll3Wj", "name": "ChatGPT's Sphere", "author": "FoobarBigTime", "description": "Wow, it took some teeth pulling, but this code is nearly completely from chatGPT. I only had to port some of the syntax and Shadertoy specific things to make it work. That and it had a difficult time normalizing the fragment coordinates. ", "tags": ["raymarching", "sphere", "chatgpt"], "likes": 0, "viewed": 200, "published": 3, "date": "1672462390", "time_retrieved": "2024-07-30T16:10:00.154062", "image_code": "// Define a function that calculates the signed distance from a point to a sphere\nfloat sphereSDF(vec3 point, vec3 sphereCenter, float sphereRadius) {\n  return length(point - sphereCenter) - sphereRadius;\n}\n\n// Define the main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  \n  // Define the position and radius of the sphere\n  vec3 sphereCenter = vec3(0, 0, 0);\n  float sphereRadius = 1.0;\n\n  // Define the camera position and field of view\n  vec3 cameraPosition = vec3(0, 0, -2);\n  float fieldOfView = 90.0;\n\n  // Normalize the fragment coordinates\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  \n  float z = tan(radians(fieldOfView) / 2.0);\n  \n  // Calculate the direction of the ray from the camera to the fragment\n  vec3 rayDirection = normalize(vec3(uv, z));\n\n  // Define the maximum number of iterations\n  int maxIterations = 100;\n\n  // Define the distance from the ray origin to the nearest point on the ray that intersects with the sphere\n  float dist = 0.001; // Initialize the distance to a small value\n\n  // Iterate until the ray intersects with the sphere or the maximum number of iterations is reached\n  for (int i = 0; i < maxIterations; i++) {\n    // Calculate the current position of the ray\n    vec3 rayPosition = cameraPosition + dist * rayDirection;\n\n    // Calculate the signed distance from the current position to the sphere\n    float sdf = sphereSDF(rayPosition, sphereCenter, sphereRadius);\n\n    // Check if the distance to the surface of the sphere is smaller than the threshold\n    if (sdf < 0.001){\n      // The distance to the surface of the sphere is smaller than the threshold, so we can calculate the point of intersection and the surface normal\n      vec3 intersectionPoint = rayPosition;\n      vec3 surfaceNormal = normalize(intersectionPoint - sphereCenter);\n\n      // Use the surface normal to shade the pixel corresponding to the point of intersection\n      fragColor = vec4(surfaceNormal, 1);\n      return;\n    }\n\n    // The distance to the surface of the sphere is larger than the threshold, so we can move the ray along its direction by the distance to the surface of the sphere\n    dist += sdf;\n  }\n\n  // The ray does not intersect with the sphere within the maximum number of iterations, so we can return a background color\n  fragColor = vec4(0, 0, 0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dll3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 150, 150, 206], [208, 236, 292, 346, 2339]], "test": "untested"}
{"id": "ctsGD2", "name": "that thing i see in my coffe cup", "author": "jonasfrey", "description": "coffe", "tags": ["coffe"], "likes": 3, "viewed": 199, "published": 3, "date": "1672447689", "time_retrieved": "2024-07-30T16:10:01.091556", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    \n    vec2 o_diff = vec2(0.)-o_trn_fc_nor_offset;\n    float n_tau = 6.2831;\n    float n_ang_nor = fract(((atan(o_diff.y, o_diff.x)+(n_tau/2.))/n_tau));\n    \n    float n_its = 200.;\n    \n    float n_ang_nor_snapped = floor(n_ang_nor * n_its)/n_its;\n\n    float n_it = floor(n_ang_nor * n_its);\n    float n_radius = (sin(iTime+(n_tau/n_its)*n_it)*0.5+0.5)*0.4;\n    vec2 o_p = vec2(\n        cos((n_ang_nor_snapped+(1./n_its/2.))*n_tau)*n_radius, \n        sin((n_ang_nor_snapped+(1./n_its/2.))*n_tau)*n_radius\n    );\n    \n    float n_dist = length(o_p-o_trn_fc_nor_offset);\n    \n    \n    fragColor = vec4(n_dist);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1015]], "test": "untested"}
{"id": "Dls3W2", "name": "mandelbrot dream", "author": "graygoose", "description": "simple mandlebrot, click and drag to pan.  Epilepsy warning.\n\nDisable the filter out by commenting it's define in Image.\n\nDisable the noisy filter by commenting NOISY_S in Buffer A.\n- NOISY_S should produce moirre-like gratings after a few cycles.", "tags": ["fractal", "kernel"], "likes": 0, "viewed": 169, "published": 3, "date": "1672443849", "time_retrieved": "2024-07-30T16:10:01.970207", "image_code": "#define FILTER\nprecision highp float;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef FILTER\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    #else\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    #endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "precision highp float;\n\nint get_nearest_root(vec2 z){\n    int index = 0; float dist = 1000.;\n    \n    for(int i = 0; i < NROOTS; i++){\n        float d = length(z - roots[i]);\n        if(d < dist){\n            index = i; dist = d;\n        }\n    }\n    \n    return index;\n}\n\n#define ITER_MAX 2500\nint mandelbrot(vec2 p){\n    float x0 = p.x, y0 = p.y;\n    float x = 0., y = 0.;\n\n    int iter = 0;\n    while(x*x + y*y < 4. && iter < ITER_MAX){    \n        float xtemp = x*x - y*y + x0;\n        y = 2.*x*y + y0;\n        x = xtemp;\n\n        iter++;\n    }\n\n    return iter;\n}\n\nfloat hash(int n){ return fract(sin(float(n))*136.5453123); }\n\n// coloring using iter as a hash into a palette function\nvec3 hash_color(int i){\n    float max = float(ITER_MAX);\n    float r = mod(hash(i), float(ITER_MAX));\n    float g = mod(hash(i+1), float(ITER_MAX));\n    float b = mod(hash(i+2), float(ITER_MAX));\n\n    return vec3(r, g, b);\n}\n\n#define PI 3.1415926535\n\n\n#define MOUSE\n\n#define Z_SPD 0.001\n#define Z_SCALE 10.\n#define ZOOM (cos(iTime*Z_SPD*0.5)*sin(iTime*Z_SPD)*Z_SCALE)\n#define MZOOM (ZOOM*2.)\n#define BAILOUT 512.\n#define NOISY_S\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // scale math space -1.41855\n    vec2 z = vec2(-1.4185+ZOOM, 0.) + scale(fragCoord.xy, iResolution.xy, mat2(-2.*ZOOM, 0.47*ZOOM, -1.12*ZOOM, 1.12*ZOOM)); \n    #ifdef MOUSE\n    if (iMouse.z > 0.0) {\n        vec2 m = scale(iMouse.xy, iResolution.xy, mat2(-2., 0.47, -1.12, 1.12)*MZOOM);\n        z -= m;\n    }\n    #endif\n    \n    // mandelbrot \n    float x0 = z.x, y0 = z.y;\n    float x = 0., y = 0.;\n\n    float iter = 0.;\n    vec2 zn = vec2(0., 0.);\n    while(x*x + y*y < BAILOUT && int(iter) < ITER_MAX){    \n        float xtemp = x*x - y*y + x0;\n        y = 2.*x*y + y0;\n        x = xtemp;\n\n        zn = vec2(x, y);\n        iter++;\n    }\n\n    // stop for points that don't escape\n    if (int(iter) == ITER_MAX) {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    } \n    \n    if (int(iter) < ITER_MAX) {\n        float logzn = log(zn.x*zn.x + zn.y*zn.y) * 0.5;\n        float iter_part = log(logzn / log(2.)) / log(2.);\n        iter += 1. - iter_part;\n    }\n\n    // color\n    vec3 col1 = hash_color(int(iter));\n    vec3 col2 = hash_color(int(iter+1.));\n\n    // interpolated color\n    vec3 col = mix(col1, col2, fract(float(iter)));\n\n    // smooth coloring\n    #ifdef NOISY_S\n    float S = abs(cos(iTime*0.015))-sin(iTime*0.025);\n    #else\n    float S = abs(cos(iTime*0.05));\n    #endif\n    float N = float(ITER_MAX);\n    float v = mod(pow(pow((iter/float(ITER_MAX)), S) * N, 1.75), N)/N;\n\n\n    // color\n    fragColor = vec4(col * v, 1.);\n    //fragColor = vec4(hueShift(col, cos(iTime)), 1.);\n}", "buffer_a_inputs": [], "buffer_b_code": "\n#define STX sin(fragCoord.x*iTime)\n#define STY sin(fragCoord.y*iTime)\nprecision highp float;\n\n\n//#define TV_COLOR\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 L0 = filter3x3(fragCoord.xy, LAPLACIAN, iChannel0, iResolution.xy);\n    vec4 G0 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel0, iResolution.xy);\n    vec4 S0 = sobel(fragCoord.xy, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n\n    vec4 F0 = -L0 * (2.-C0);\n    vec4 col = C0*(sin(iTime*1.1)*0.5)*S0+2.*abs(cos(iTime*0.9)+1.)*F0;\n    col = col + cos(iTime)*C0*((G0 + G1) * 0.5);\n    \n    #ifdef TV_COLOR\n    O = vec4(hueShift(col.xyz, cos(iTime*0.01)), 1.);\n    #else\n    O = col;\n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NROOTS 3\nvec2 roots[NROOTS];\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\nvec2 wrap(in vec2 p, in vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.,0.,0.,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 95, 95, 262]], "test": "untested"}
{"id": "dlXGWj", "name": "Reflected tubes", "author": "z0rg", "description": "Some old never puiblished shader I did on Shader Editor on android.", "tags": ["raymarching", "fractal"], "likes": 17, "viewed": 488, "published": 3, "date": "1672440349", "time_retrieved": "2024-07-30T16:10:02.735161", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.1,1.)\nmat2 r2d(float a){float c = cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 3.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if(a.x<b.x)\n  return a;\n  return b;\n}\n\nvec2 map(vec3 p)\n{\n  float repv = .5;\n  vec3 pv = p;\n  pv.y= mod(pv.y+iTime+repv*.5,repv)-repv*.5;\n  for (int i = 0;i<6;++i)\n  {\n    float fi = float(i);\n\n\n    p.xz*=r2d(iTime*.15*fi/4.);\n    p = abs(p);\n    p+= vec3(-1.,-2.,.0);\n    p.xy*=r2d(iTime*.25*fi/4.*mod(fi,2.));\n\n  }\n  vec2 acc = vec2(10000.,-1.);\n\nvec2 rep = vec2(1.5);\nvec2 id = floor((p.xz+rep*.5)/rep);\np.xz = mod(p.xz+rep*.5,rep)-rep*.5;\n float h = 2.+sin(length(id)+iTime)+length(id)*.25;\n  float shape = max(length(p.xz)-.05,abs(p.y)-h);\n  shape = max(shape,-(abs(pv.y)-.1));\n  acc = _min(acc, vec2(shape, 0.));\n\n  return acc;\n}\n\nvec3 getNorm(float d, vec3 p)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 gradient(float f)\n{\n  vec3 cols[7];\n  cols[0] = vec3(254,241,193)/255.;\n  cols[1] = vec3(254,228,77)/255.;\n  cols[2] = vec3(254,136,85)/255.;\n  cols[3] = vec3(254,49,54)/255.;\n  cols[4] = vec3(79,28,113)/255.;\n  cols[5] = vec3(49, 18,70)/255.;\n  cols[6] = vec3(32,11,45)/255.;\n\n  return cols[int(min(f*7.,6.))];\n}\n\nvec3 getCol(vec2 uv)\n{\n  return gradient(sat(length(uv)*.1));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accCol = vec3(0.);\n  vec3 p = ro;\n  for (int i = 0;i<steps&&distance(p,ro)<20.;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n      accCol+= getCol(p.xz)\n      *(1.-sat(res.x/.75))*.05\n      *sat(.5+.5*sin(length(p)-iTime*4.));\n    p+=rd*res.x*.85;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col= vec3(0.);\n\nfloat t = iTime*.35;\nfloat d = 3.;\n  vec3 ro = vec3(d*cos(t),-8.+4.*sin(iTime*.1),d*sin(t));\n  vec3 ta = vec3(0.,0.,0.);\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n\n  vec3 res = trace(ro,rd, 128);\n  if (res.y >0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(res.x,p);\n    col = n*.5+.5;\n    col = getCol(p.xz);\n    if (abs(dot(n,vec3(0.,1.,0.)))>0.1)\n     col = gradient(sat(length(p.xz)*.1));\n  }\ncol+= accCol;\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.xx;\n\n  vec3 col = rdr(uv);\n  col = pow(col, vec3(1.2));\n  col *= 1.-sat(lenny(uv*2.)-.25);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXGWj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[428, 428, 446, 446, 495], [496, 496, 517, 517, 549], [550, 550, 581, 581, 729], [731, 731, 758, 758, 798], [800, 800, 818, 818, 1396], [1398, 1398, 1429, 1429, 1537], [1539, 1539, 1563, 1563, 1857], [1859, 1859, 1881, 1881, 1922], [1936, 1936, 1977, 1977, 2306], [2308, 2308, 2327, 2327, 2795], [2798, 2798, 2855, 2855, 3037]], "test": "untested"}
{"id": "ctl3W2", "name": "ChatGPT Mandelbrot Animation", "author": "lloydevans", "description": "This code was written in part by ChatGPT with further modifications by me to include better animation.", "tags": ["mandelbrot", "maths"], "likes": 5, "viewed": 450, "published": 3, "date": "1672439849", "time_retrieved": "2024-07-30T16:10:03.543999", "image_code": "// This is a Shadertoy - a shader that runs on the GPU and can be used to create\n// visual effects. In this case, we're using it to render an animated Mandelbrot set.\n\n// Now we'll define the main function of the shader. This is where the magic happens!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // First, we'll map the fragment coordinate (the location of the current pixel\n    // being rendered) to a point in the complex plane. The Mandelbrot set is defined\n    // in the complex plane, so this will allow us to calculate which point in the\n    // set the current pixel corresponds to.\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Now we'll define a few variables that we'll use to calculate the Mandelbrot set.\n    vec2 c = uv;\n    vec2 z = vec2(0.0, 0.0);\n\n    // Next, we'll iterate over the Mandelbrot set, using the complex number z to\n    // represent each point in the set. We'll use the variable \"t\" to animate the\n    // set by adding a small value to the real and imaginary parts of \"c\" on each\n    // iteration.\n    for (int i = 0; i < 64; i++) {\n        if (length(z) > 2.0) {\n            // If the length of \"z\" is greater than 2, it means that the point is\n            // outside the Mandelbrot set, so we can stop iterating.\n            break;\n        }\n\n        // Add a small amount to the real and imaginary parts of \"c\" on each iteration\n        // to animate the set. The value of \"t\" controls the speed and direction of\n        // the animation.\n        float s = 0.3;\n        float t = iTime * s;\n        c.x += sin(t) * s * (sin(iTime) * s * 2.0) + 0.05;\n        c.y += cos(t) * s * (sin(iTime) * s * 2.0) + 0.05;\n\n        z = vec2(z.x * z.x - z.y * z.y + c.x, 2.0 * z.x * z.y + c.y);\n    }\n\n\n    // Finally, we'll use the number of iterations we performed to calculate a color\n    // for the current pixel. We'll use a color gradient to give the set a nice,\n    // psychedelic look.\n    fragColor = vec4(sin(z.x) * 0.5 + 0.5, sin(z.y) * 0.5 + 0.5, sin(length(z)) * 0.5 + 0.5, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctl3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 254, 311, 608, 2089]], "test": "untested"}
{"id": "DtXGRl", "name": "oil crystals", "author": "nickbrick", "description": "Crossing a noise texture with itself over a varying amount and distribution of nearby points to showcase the various behaviors. This system is very prone to blacking out so a few extra steps were needed to improve stability.", "tags": ["trippy"], "likes": 3, "viewed": 203, "published": 3, "date": "1672433549", "time_retrieved": "2024-07-30T16:10:04.384751", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TAU 6.283185307179586476925286766559\n#define STEPS (sin(iTime * 0.5) * 4.0 + 5.0)\n#define R 0.001\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (iFrame < 1){ fragColor = texture(iChannel0, uv); return; }\n    \n    vec3 sum = vec3(1.3);\n    for (float a = 0.0; a < TAU; a += TAU / STEPS)\n        sum += cross(sum.rgb, texture(iChannel1, uv + vec2(R * sin(a), R * cos(a))).rgb);\n    sum = cross(sum, vec3(0.6));\n    sum = max(sum, vec3(0.0));\n    fragColor = vec4(sum / STEPS, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 141]], "test": "untested"}
{"id": "ctX3Rl", "name": "Chaos game sierpinski", "author": "01000001", "description": "Sierpinski triangle. It renders almost instantly rather than taking hours, because there's actually a separate chaos game running for every column of pixels in the image. You can also click to define start pos. https://en.wikipedia.org/wiki/Chaos_game", "tags": ["fractal", "chaos"], "likes": 4, "viewed": 211, "published": 3, "date": "1672431749", "time_retrieved": "2024-07-30T16:10:05.247444", "image_code": "void mainImage( out vec4 O, in vec2 U ){\n    O = texture(iChannel0, U/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, in vec2 U )\n{\n\n    if (U.y < 1.0){//set this to 1 for peak performance\n        float ratio = iResolution.y/iResolution.x;\n        ratio/=cos(3.1415926/6.0);\n        float gap = (1.0-ratio)/2.0;\n        points[0] = vec2(gap, 0);\n        points[1] = vec2(1.0-gap, 0);\n        points[2] = vec2(0.5, 1);\n        \n\n        vec2 uv = U/iResolution.xy;\n        vec2 point = texture(iChannel0, vec2(uv.x, 0)).xy;\n\n        vec2 target;\n\n\n\n        float rand = rand(vec2(mod(iTime, 20.73)*uv.x + float(iFrame), -mod(iTime, 23.57)*mod(iTime, 17.23)+uv.x / float(iFrame)));\n        rand *= float(points.length());\n        rand = floor(rand);\n        int index = int(rand);\n\n        target = points[index];\n\n        O.xy = mix(target, point, 0.5);\n        \n        if (iFrame == 0 || iMouse.z > 0.){ \n            O.xy = points[0];\n            if (iMouse.z > 0.) O.xy = iMouse.xy/iResolution.xy;\n        }\n\n    } else { O = vec4(0); }\n    \n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U/iResolution.xy;\n\n    O = texture(iChannel1, uv);\n    if (iMouse.z > 0.) O = vec4(0);\n    vec2 point = texture(iChannel0, uv).xy;\n    int width = int(iResolution.x);\n    \n    for(int i = 0; i<width; i++)\n    {\n        point = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        if (length(uv.xy - point.xy) < 1.0/iResolution.x)\n        {\n            O += vec4(0.2);\n        }\n\n    }\n    \n    //fragColor = vec4(max(0.0, fragColor.x - 0.01/(iTime)));\n    //fragColor -= vec4(0.002);\n    //^ uncomment this line if you want to render in full screen.  Then reset time and go to fullscreen asap (<1 second)\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvec2 points[3];", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctX3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 88]], "test": "untested"}
{"id": "mtfGD2", "name": "Decontaminate Edge Color", "author": "MysteryPancake", "description": "I remade this effect from Photoshop and After Effects. It basically extends the edges outwards to remove green.\nUse your mouse to control the extension radius, it looks super cool :)", "tags": ["2d", "chroma", "color", "greenscreen", "chromakey", "matte", "compositing", "photoshop", "despill", "decontaminate"], "likes": 2, "viewed": 297, "published": 3, "date": "1672421960", "time_retrieved": "2024-07-30T16:10:06.153023", "image_code": "const float TAU = 6.28318530;\n\nfloat getAlpha(vec3 col) {\n    const vec3 green = vec3(0.0, 1.0, 0.0);\n    return smoothstep(0.6, 0.7, distance(col, green));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float dirSteps = 64.0;\n    \n    // Shrink factor, change with mouse\n    float radius = iMouse.z > 0.0 ? length(iMouse.xy / iResolution.xy - 0.5) * 200.0 : cos(iTime * 3.0) * 30.0 + 30.0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 bg = vec3(0.8 * smoothstep(0.9, 0.0, length(uv - 0.5)));\n    \n    fragColor = texture(iChannel0, uv);\n    float alpha = getAlpha(fragColor.rgb);\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n    // STEP 1: Find average direction away from edge\n    \n    vec2 dirAvg = vec2(0.0);\n    for (float i = 0.0; i < TAU; i += TAU / dirSteps) {\n        // Move in a circle to find edges within radius\n        vec2 dir = vec2(sin(i), cos(i));\n        vec4 col = texture(iChannel0, uv + dir * aspect * radius);\n        // Edge was found, accumulate for average\n        if (alpha > getAlpha(col.rgb)) dirAvg += dir;\n    }\n    \n    // No edges within radius\n    if (length(dirAvg) <= 0.0) {\n        fragColor.rgb = mix(bg, fragColor.rgb, alpha);\n        return;\n    }\n    \n    // Calculate average direction\n    dirAvg = normalize(dirAvg);\n\n    // STEP 2: Raycast in average direction until an edge is hit\n    \n    float d = radius * 0.5;\n    float move = d * 0.5;\n    // Binary search works better than linear search\n    for (int i = 0; i < 8; i++, move *= 0.5) {\n        vec4 col = texture(iChannel0, uv + dirAvg * aspect * d);\n        d += alpha > getAlpha(col.rgb) ? -move : move;\n    }\n    \n    // Distort the image\n    fragColor = texture(iChannel0, uv + dirAvg * aspect * (d - radius));\n    fragColor.rgb = mix(bg, fragColor.rgb, getAlpha(fragColor.rgb));\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 158], [160, 160, 215, 215, 1868]], "test": "untested"}
{"id": "dlfGDB", "name": "Claude after the LSD hits", "author": "MysteryPancake", "description": "My proudest work yet\nMove mouse to change shrink factor :)", "tags": ["2d", "chroma", "distort", "greenscreen", "chromakey", "matte", "compositing", "weird", "drugs", "funny", "weed"], "likes": 6, "viewed": 298, "published": 3, "date": "1672420692", "time_retrieved": "2024-07-30T16:10:06.897034", "image_code": "const float TAU = 6.28318530;\n\nfloat getAlpha(vec3 col) {\n    const vec3 green = vec3(0.0, 1.0, 0.0);\n    return smoothstep(0.6, 0.7, distance(col, green));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float dirSteps = 32.0;\n    \n    // Shrink factor, change with mouse\n    float radius = iMouse.z > 0.0 ? length(iMouse.xy / iResolution.xy - 0.5) * 500.0 : 30.0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 bg = vec3(uv.x, 1.0 - uv.y, 1.0) + smoothstep(0.4, 0.6, length(uv - 0.5));\n    \n    fragColor = texture(iChannel0, uv);\n    float alpha = getAlpha(fragColor.rgb);\n    \n    // Correct aspect ratio\n    vec2 aspect = 1.0 / vec2(textureSize(iChannel0, 0));\n    \n    // STEP 1: Find average direction away from edge\n    \n    vec2 dirAvg = vec2(0.0);\n    for (float i = 0.0; i < TAU; i += TAU / dirSteps) {\n        // Move in a circle to find edges within radius\n        vec2 dir = vec2(sin(i), cos(i));\n        vec4 col = texture(iChannel0, uv + dir * aspect * radius);\n        // Edge was found, accumulate for average\n        if (alpha > getAlpha(col.rgb)) dirAvg += dir;\n    }\n    \n    // No edges within radius\n    if (length(dirAvg) <= 0.0) {\n        fragColor.rgb = mix(bg, fragColor.rgb, alpha);\n        return;\n    }\n    \n    // Calculate average direction\n    dirAvg = normalize(dirAvg);\n\n    // STEP 2: Raycast in average direction until an edge is hit\n    \n    float d = radius * 0.5;\n    float move = d * 0.5;\n    // Binary search works better than linear search\n    for (int i = 0; i < 8; i++, move *= 0.5) {\n        vec4 col = texture(iChannel0, uv + dirAvg * aspect * d);\n        d += alpha > getAlpha(col.rgb) ? -move : move;\n    }\n    \n    // Distort the image\n    fragColor = texture(iChannel0, uv + dirAvg * aspect * (radius - d));\n    fragColor.rgb = mix(bg, fragColor.rgb, getAlpha(fragColor.rgb));\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 158], [160, 160, 215, 215, 1860]], "test": "untested"}
{"id": "mlfGW2", "name": "Shortest Centered Circle - 78 ch", "author": "GregRostami", "description": "Is this the shortest centered circle?", "tags": ["2d", "short", "golfing"], "likes": 1, "viewed": 198, "published": 3, "date": "1672417258", "time_retrieved": "2024-07-30T16:10:07.640047", "image_code": "void mainImage(out vec4 o,vec2 u)\n{\n    o.g = length( u - (o.rb=.5*iResolution.xy) ) - o.b;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 93]], "test": "untested"}
{"id": "dlXGW2", "name": "Squiggly Stars", "author": "drliquidglitch", "description": "Another simple fractal pattern.", "tags": ["fractal", "flower", "star"], "likes": 3, "viewed": 221, "published": 3, "date": "1672414119", "time_retrieved": "2024-07-30T16:10:08.380068", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.6)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 12; k++){\n        t3 = uv.x > uv.y || !t3;\n        uv = (uv+t2)/scale+float(!t3)/2.;\n        t2 = triangle_wave(uv+.6);\n        uv = t2-triangle_wave(uv.yx);\n        float c1 = abs(uv.x-uv.y);\n        col = col.yzx;  \n        if(uv.y > uv.x) col = vec3(col.yz,c1);\n    }\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 703]], "test": "untested"}
{"id": "dtX3Dj", "name": "Sphere of circles", "author": "callumacrae", "description": "Circles moving together to create the appearance of a sphere", "tags": ["3d", "sphere", "animated", "animation", "geometry"], "likes": 8, "viewed": 245, "published": 3, "date": "1672408801", "time_retrieved": "2024-07-30T16:10:09.136048", "image_code": "#define SPHERE_RADIUS 0.35 // 0.1 - 0.6\n#define ELLIPSE_SQUASH_FACTOR 3.85 // 1.0 - 10.0\n#define TIME_FACTOR 1.0 // 0.1 - 10.0\n#define LINE_THICKNESS_FACTOR 120.0 // 50.0 - 300.0\n\n// name: Circle sphere\n// date: 2022-12-28\n// tags: GLSL\n// favourite: true\n// shadertoy: https://www.shadertoy.com/view/dtX3Dj\n\n// https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid drawCircle(inout vec4 fragColor, vec2 fragCoord, float offsetFactor, float hue, float sphereRadius) {\n  // ellipse: ( y * a ) ^ 2 + x ^ 2 = radius ^ 2\n  // line to point: y = fragCoord.x / fragCoord.y * x\n  // adjustedRadius = sqrt(pow(x, 2.0) + pow(y, 2.0));\n\n  vec2 origin = iResolution.xy / 2.0;\n  float yOffset = offsetFactor * sphereRadius;\n  float radius = sqrt(pow(sphereRadius, 2.0) - pow(yOffset, 2.0));\n\n  float a = ELLIPSE_SQUASH_FACTOR;\n\n  float x = abs(origin.x - fragCoord.x);\n  float y = abs(origin.y - yOffset - fragCoord.y);\n  float xOnCircle;\n  float yOnCircle;\n  if (x < 1.0) {\n    xOnCircle = 0.0;\n    yOnCircle = radius / a;\n  } else {\n    xOnCircle = sqrt(pow(radius, 2.0) / (pow(a, 2.0) * pow(y / x, 2.0) + 1.0));\n    yOnCircle = y / x * xOnCircle;\n  }\n  float adjustedRadius = sqrt(pow(xOnCircle, 2.0) + pow(yOnCircle, 2.0));\n\n  float dist = sqrt(pow(x, 2.0) + pow(y, 2.0));\n\n  float innerLineWidth = sphereRadius / LINE_THICKNESS_FACTOR;\n  float outerLineWidth = sphereRadius / LINE_THICKNESS_FACTOR * 3.0;\n\n  float alpha = 0.0;\n  if (dist < adjustedRadius + innerLineWidth / 2.0 && dist > adjustedRadius - innerLineWidth / 2.0) {\n    alpha = 1.0;\n  } else if (dist < adjustedRadius) {\n    alpha = smoothstep(adjustedRadius - outerLineWidth / 2.0, adjustedRadius - innerLineWidth / 2.0, dist);\n  } else {\n    alpha = smoothstep(adjustedRadius + outerLineWidth / 2.0, adjustedRadius + innerLineWidth / 2.0, dist);\n  }\n\n  if (alpha > 0.0) {\n    fragColor.rgb = mix(fragColor.xyz, hsv2rgb(vec3(hue, 0.75, 0.75)), alpha);\n  }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = vec4(vec3(0.0), 1.0);\n\n  float adjustedTime = iTime * TIME_FACTOR;\n\n  float sphereRadius = min(iResolution.x, iResolution.y) * SPHERE_RADIUS;\n  float layers = 20.0;\n  for (float i = 0.0; i != layers; ++i) {\n    float offsetFactor = cos(3.1416 / layers * (i + mod(adjustedTime, 1.0)));\n    float hue = mod((i - floor(adjustedTime)) / layers, 1.0);\n    drawCircle(fragColor, fragCoord, offsetFactor, hue, sphereRadius);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtX3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 411, 433, 433, 596], [598, 598, 704, 862, 2151], [2153, 2153, 2205, 2205, 2643]], "test": "untested"}
{"id": "dlXGDj", "name": "Mirrored Repeat / Ping Pong", "author": "MysteryPancake", "description": "Optimized mirror repeat methods I wrote myself. Range is 0 (inclusive) to size (exclusive).\nI added the integer version to Blender (developer.blender.org/D16432)", "tags": ["triangle", "mirror", "mirrored", "repeat", "pingpong", "flipped"], "likes": 0, "viewed": 194, "published": 3, "date": "1672408204", "time_retrieved": "2024-07-30T16:10:09.873077", "image_code": "// VARIANT 1: Floating point coordinates\n// For float, vec2, vec3, vec4, etc.\nvec2 mirror(vec2 p, vec2 size) {\n    return abs(mod(p + size, 2.0 * size) - size);\n}\n\n// VARIANT 2: Integer coordinates\n// My derivation: developer.blender.org/D16432\nint mirror(int p, int size) {\n    p = abs(p + int(p < 0)) % (2 * size);\n    return p >= size ? 2 * size - p - 1 : p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float scale = sin(iTime) * 3.0 + 4.0;\n    ivec2 size = textureSize(iChannel0, 0);\n    \n    float mid = fragCoord.x / iResolution.x - 0.5;\n    if (mid > 0.0) {\n        // Integer demo\n        ivec2 p = ivec2(fragCoord * scale);\n        ivec2 uv = ivec2(mirror(p.x, size.x), mirror(p.y, size.y));\n        fragColor = texelFetch(iChannel0, uv, 0);\n    } else {\n        // Floating point demo\n        vec2 uv = mirror(fragCoord * scale / vec2(size), vec2(1.0));\n        fragColor = texture(iChannel0, uv);\n    }\n    \n    // Line down the center\n    fragColor *= smoothstep(0.0, 0.01, abs(mid));\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 110, 110, 162], [164, 245, 274, 274, 363], [365, 365, 420, 420, 1018]], "test": "untested"}
{"id": "dtXGWj", "name": "Trippy rectangles", "author": "mrange", "description": "CC0: Trippy rectangles\nContinuation of last night trippy effects\n", "tags": ["2d", "trippy"], "likes": 32, "viewed": 447, "published": 3, "date": "1672396541", "time_retrieved": "2024-07-30T16:10:10.665957", "image_code": "// CC0: Trippy rectangles\n//  Continuation of last night trippy effects\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(1.2);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat forward(float n) {\n  return exp2(ExpBy*n);\n}\n\nfloat reverse(float n) {\n  return log2(n)/ExpBy;\n}\n\nvec2 cell(float n) {\n  float n2  = forward(n);\n  float pn2 = forward(n-1.0);\n  float m   = (n2+pn2)*0.5;\n  float w   = (n2-pn2)*0.5;\n  return vec2(m, w);\n}\n\nvec2 df(vec2 p, float aa) {\n  float tm = TIME;\n  float m = fract(tm);\n  float f = floor(tm);\n  float z = forward(m);\n  \n  vec2 p0 = p;\n  p0 /= z;\n  vec2 sp0 = sign(p0);\n  p0 = abs(p0);\n\n  float l0x = p0.x;\n  float n0x = ceil(reverse(l0x));\n  vec2 c0x  = cell(n0x); \n\n\n  float l0y = p0.y;\n  float n0y = ceil(reverse(l0y));\n  vec2 c0y  = cell(n0y); \n\n\n  vec2 p1 = vec2(p0.x, p0.y);\n  vec2 o1 = vec2(c0x.x, c0y.x);\n  vec2 c1 = vec2(c0x.y, c0y.y);\n  p1 -= o1;\n  \n  float r1 = 0.5*aa/z;\n\n  vec2 p2 = p1;\n  vec2 c2 = c1;\n  float n2 = 0.0; \n  \n  if (c1.x < c1.y) {\n    float f2 = floor(c1.y/c1.x);\n    c2 = vec2(c1.x, c1.y/f2);\n    if (fract(0.5*f2) < 0.5) {\n      p2.y -= -c2.y;\n    }\n    \n    n2 = mod1(p2.y, 2.0*c2.y);\n  } else if (c1.x > c1.y){\n    float f2 = floor(c1.x/c1.y);\n    c2 = vec2(c1.x/f2, c1.y);\n    if (fract(0.5*f2) < 0.5) {\n      p2.x -= -c2.x;\n    }\n\n    n2 = mod1(p2.x, 2.0*c2.x);\n  }\n  float h0 = hash(n2+vec2(n0x, n0y)-vec2(f)+vec2(sp0.x, sp0.y));\n  \n  float d2 = box(p2, c2-2.0*r1)-r1;\n  \n  float d = d2;\n  d *= z;\n\n  return vec2(d, h0);\n}\n\nvec4 effect(vec2 p, float hue) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 d2 = df(p, aa);\n\n  vec3 col = vec3(0.0);\n  vec3 bcol = hsv2rgb(vec3(fract(hue+0.3*d2.y), 0.85, 1.0));\n  return vec4(bcol, smoothstep(aa, -aa, d2.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 ppp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float hue = -length(p)+0.1*TIME; \n\n  vec2 pp = p;\n  vec3 col = vec3(0.0);\n  vec4 col0 = effect(pp, hue);\n  col = mix(col, col0.xyz, col0.w);\n\n  col += hsv2rgb(vec3(hue, 0.66, 4.0))*mix(1.0, 0.0, tanh_approx(2.0*sqrt(length(p))));\n  col *= smoothstep(1.5, 0.5, length(ppp));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 457, 457, 603], [898, 958, 979, 979, 1049], [1051, 1111, 1139, 1205, 1281], [1283, 1369, 1408, 1408, 1533], [1535, 1653, 1680, 1680, 1756], [1758, 1758, 1782, 1782, 1808], [1810, 1810, 1834, 1834, 1860], [1862, 1862, 1882, 1882, 2017], [2019, 2019, 2046, 2046, 3075], [3077, 3077, 3109, 3109, 3299], [3301, 3301, 3358, 3358, 3798]], "test": "untested"}
{"id": "DlX3Dj", "name": "马赛克test4", "author": "xst02071211", "description": "mosaic", "tags": ["mosaic"], "likes": 0, "viewed": 161, "published": 3, "date": "1672385055", "time_retrieved": "2024-07-30T16:10:11.475792", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 center = vec2(iMouse.x,iMouse.y);\n    float mosaicSize = 30.0;\n    float recSide = 90.0;\n        \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 texColor = texture(iChannel0, uv);\n    \n    if(fragCoord.x<center.x - recSide || fragCoord.x>center.x + recSide || fragCoord.y<center.y - recSide || fragCoord.y>center.y + recSide)\n    {\n        fragColor = texColor;\n    }\n    else{\n        //\n        if(fragCoord.x>center.x - mosaicSize && fragCoord.x<center.x && fragCoord.y>center.y - mosaicSize && fragCoord.y<center.y){\n            fragColor = texture(iChannel0, vec2(center.x-15.0,center.y-15.0)/iResolution.xy);\n        }\n        else if(fragCoord.x>center.x - mosaicSize && fragCoord.x<center.x && fragCoord.y<center.y + mosaicSize && fragCoord.y>center.y){\n            fragColor = texture(iChannel0, vec2(center.x-15.0,center.y+15.0)/iResolution.xy);\n        }\n        else if(fragCoord.x<center.x + mosaicSize && fragCoord.x>center.x && fragCoord.y>center.y - mosaicSize && fragCoord.y<center.y){\n            fragColor = texture(iChannel0, vec2(center.x+15.0,center.y-15.0)/iResolution.xy);\n        }\n        else if(fragCoord.x<center.x + mosaicSize && fragCoord.x>center.x && fragCoord.y<center.y + mosaicSize && fragCoord.y>center.y){\n            fragColor = texture(iChannel0, vec2(center.x+15.0,center.y+15.0)/iResolution.xy);\n        }\n        \n        else if(fragCoord.x>(center.x - 60.0) && fragCoord.x<center.x-30.0 && fragCoord.y>(center.y - 60.0)&& fragCoord.y<center.y-30.0){\n            fragColor = texture(iChannel0, vec2(center.x-30.0,center.y-30.0)/iResolution.xy);\n        }\n        else if(fragCoord.x>center.x - 60.0 && fragCoord.x<center.x-30.0 && fragCoord.y<center.y + 60.0 && fragCoord.y>center.y-30.0){\n            fragColor = texture(iChannel0, vec2(center.x-30.0,center.y+30.0)/iResolution.xy);\n        }\n        else if(fragCoord.x<center.x + 60.0 && fragCoord.x>center.x+-30.0 && fragCoord.y>center.y - 60.0 && fragCoord.y<center.y-30.0){\n            fragColor = texture(iChannel0, vec2(center.x+30.0,center.y-30.0)/iResolution.xy);\n        }\n        else if(fragCoord.x<center.x + 60.0 && fragCoord.x>center.x+-30.0 && fragCoord.y<center.y + 60.0 && fragCoord.y>center.y-30.0){\n            fragColor = texture(iChannel0, vec2(center.x+30.0,center.y+30.0)/iResolution.xy);\n        }\n        \n        else if(fragCoord.x>(center.x - 90.0) && fragCoord.x<center.x-60.0 && fragCoord.y>(center.y - 90.0)&& fragCoord.y<center.y-60.0){\n            fragColor = texture(iChannel0, vec2(center.x-60.0,center.y-60.0)/iResolution.xy);\n        }\n        else if(fragCoord.x>center.x - 90.0 && fragCoord.x<center.x-60.0 && fragCoord.y<center.y + 90.0 && fragCoord.y>center.y-60.0){\n            fragColor = texture(iChannel0, vec2(center.x-60.0,center.y+60.0)/iResolution.xy);\n        }\n        else if(fragCoord.x<center.x + 90.0 && fragCoord.x>center.x+-60.0 && fragCoord.y>center.y - 90.0 && fragCoord.y<center.y-60.0){\n            fragColor = texture(iChannel0, vec2(center.x+60.0,center.y-60.0)/iResolution.xy);\n        }\n        else if(fragCoord.x<center.x + 90.0 && fragCoord.x>center.x+-60.0 && fragCoord.y<center.y + 90.0 && fragCoord.y>center.y-60.0){\n            fragColor = texture(iChannel0, vec2(center.x+60.0,center.y+60.0)/iResolution.xy);\n        }\n    }\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlX3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 3367]], "test": "untested"}
{"id": "Dlf3Wj", "name": "Fractal flower stars", "author": "jarble", "description": "Another simple fractal pattern.", "tags": ["fractal", "flower", "star"], "likes": 6, "viewed": 230, "published": 3, "date": "1672382890", "time_retrieved": "2024-07-30T16:10:12.231770", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 12; k++){\n        t3 = uv.x > uv.y || !t3;\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        uv = (uv+t2)/scale+float(!t3)/2.;\n        t2 = triangle_wave(uv+.5);\n        uv = t2-triangle_wave(uv.yx);\n        //t2.x += .5+float(t3)/2.;\n        float c1 = abs(uv.x-uv.y);\n        col = col.yzx;  \n        if(uv.y > uv.x) col = vec3(col.yz,c1);\n        //t2 -= floor(iTime)*vec2(1.,1./16.)/16.;\n        \n    }\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlf3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 855]], "test": "untested"}
{"id": "clX3Wj", "name": "马赛克test3", "author": "xst02071211", "description": "mosaic", "tags": ["mosaic"], "likes": 0, "viewed": 138, "published": 3, "date": "1672382379", "time_retrieved": "2024-07-30T16:10:12.977776", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 center = vec2(iMouse.x,iMouse.y);\n    float mosaicSize = 30.0;\n    float recSide = 90.0;\n    \n\n    vec2 mosaicBlockSize = vec2(mosaicSize,mosaicSize);\n    vec2 blockStart = fragCoord;;\n    blockStart.x -= mod(blockStart.x,mosaicBlockSize.x);\n    blockStart.y -= mod(blockStart.y,mosaicBlockSize.y);\n    vec2 texSize = vec2(textureSize(iChannel0,0));\n  \tvec4 col = texture(iChannel0,blockStart/texSize);\n    fragColor = vec4(col);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 texColor = texture(iChannel0, uv);\n    \n    if(fragCoord.x<center.x - recSide || fragCoord.x>center.x + recSide || fragCoord.y<center.y - recSide || fragCoord.y>center.y + recSide)\n    {\n        fragColor = texColor;\n    }\n\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clX3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 779]], "test": "untested"}
{"id": "dllGDB", "name": "catradora starfield", "author": "elenzil", "description": "for a screen-printing project.", "tags": ["catradorastars"], "likes": 7, "viewed": 229, "published": 3, "date": "1672375256", "time_retrieved": "2024-07-30T16:10:13.718795", "image_code": "#define RES    iResolution\n#define MINRES min(RES.x, RES.y)\nconst float   DEG2RAD = 2.0 * 3.14159 / 360.0;\n\n// units per pixel. set at runtime.\nfloat UPP = 1.0;\n\nfloat THETA = 5.0 * DEG2RAD;\n\n\nmat2 rot2(in float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\n\nvoid star(inout float c, in vec2 p, in vec2 q, in float r, in float z) {\n    p  -= q;\n    p *= rot2(THETA);\n    float l  = length(p);\n    float d   = l - r;\n    \n    z *= r / 0.2;\n    \n    d *= pow(abs(p.x), z);\n    d *= pow(abs(p.y), z);\n    \n    d = smoothstep(0.0, 0.1, d) * 18.0;\n    d = max(d, (l - r * 5.0));\n    \n    c = mix(c, 1.0, smoothstep(UPP, 0.0, d));\n    c = mix(c, 0.0, smoothstep(UPP, 0.0, l - r * 0.9));\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    float zoom = 0.8;\n    UPP = 1.0 / (zoom * MINRES);\n    vec2 uv = (XY - RES.xy/2.0) * UPP * 2.0;\n    \n    float c = 0.0;\n    \n    float num = 60.0;\n    \n    for (float n = 0.0; n < num; ++n) {\n        vec3  h = hash31(n * 11.0);\n        \n        vec2  p = (h.xy - 0.5) * 4.0;\n        float r = mix(0.03, 0.3, pow(h.z, 4.8));\n    \n        star(c, uv, p, r, 1.1);\n    }\n    \n    \n    RGBA = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 220, 220, 288], [291, 291, 363, 363, 714], [716, 716, 759, 759, 1173]], "test": "untested"}
{"id": "mtsGDB", "name": "Expanding Loops", "author": "Offline", "description": "A grid of loops that join with each other nicely by checking their closest neighbor in the direction of their travel.\n", "tags": ["procedural", "noise", "grid", "sdf", "branchless", "hash"], "likes": 17, "viewed": 330, "published": 3, "date": "1672375104", "time_retrieved": "2024-07-30T16:10:14.458816", "image_code": "float hash(in vec2 p){\n    return fract(sin(dot(p, vec2(21.952, 38.783))) * 67845.8521);\n}\n\n// Modified 2D Value noise by iq: https://www.shadertoy.com/view/lsf3WH\nfloat noise(in vec2 p){ \n    p *= .35;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n    vec2 o = vec2(0.,1.);\n    \n    return mix( mix( hash(i + o.xx), \n                     hash(i + o.yx), f.x),\n                mix( hash(i + o.xy), \n                     hash(i + o.yy), f.x), f.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.x * 16.;\n    float screenScale = length(fwidth(uv));\n    \n    uv.y += iTime;\n    uv = vec2(uv.x - uv.y, uv.x + uv.y); // \"Rotate\" UV 45°\n    \n    vec2 cell = floor(uv);\n    float direction = round(noise(cell));\n    \n    // Offset only in current cell direction.\n    vec2 neighborOffset = sign(fract(uv) - .5) * vec2(1. - direction, direction); \n    float neighborDir = round(noise(cell + neighborOffset));\n\n    vec2 clampDir = vec2(max(direction, neighborDir), 1.-min(direction, neighborDir));\n    uv = (fract(uv) - .5) * clampDir;\n    \n    float loopMask = 1. - clamp((abs(length(uv) - .25 ) - .1) / screenScale, 0.,1.);\n    vec3 color = mix(vec3(.2,.9,.5), vec3(1.,.2,.6), direction) * loopMask;\n    fragColor = vec4(color, 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 90], [92, 164, 187, 187, 449], [451, 451, 506, 506, 1276]], "test": "untested"}
{"id": "dlsGWB", "name": "马赛克test2", "author": "xst02071211", "description": "mosaic", "tags": ["mosaic"], "likes": 0, "viewed": 143, "published": 3, "date": "1672361678", "time_retrieved": "2024-07-30T16:10:15.197840", "image_code": "#define pi 3.14159265\n#define test 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 texSize = vec2(textureSize(iChannel0,0));\n    vec2 offset = vec2((aspect-1.0)/2.0,0.0);\n    vec2 uv = (fragCoord)/iResolution.y - offset;\n    //get the coords relative to the texture\n    vec2 texCoord = floor(uv*texSize);\n    \n    \n    float mosaicSize = 30.0;//floor(sin(mod(iTime/10.0*pi - pi/2.0,0.3))*0.2 * texSize.x);\n\tvec2 mosaicBlockSize = vec2(mosaicSize,mosaicSize);\n    //use modulo to get the top left pixel position of the current group\n    vec2 blockStart = fragCoord; //texCoord;\n    blockStart.x -= mod(blockStart.x,mosaicBlockSize.x);\n    blockStart.y -= mod(blockStart.y,mosaicBlockSize.y);\n  \tvec4 col = texture(iChannel0,blockStart/texSize);\n    // Output to screen\n    fragColor = vec4(col);\n    \n    vec2 uv2 = fragCoord / iResolution.xy;\n    vec4 texColor = texture(iChannel0, uv2);\n    \n    if(uv.x > 1.0 || uv.x < 0.0) fragColor = texColor; //vec4(0.0);\n\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 94, 94, 1032]], "test": "untested"}
{"id": "Dls3WB", "name": "Snowy Mount In", "author": "SnoopethDuckDuck", "description": "slapped a few things together and got this, kinda messy but cool i think", "tags": ["h"], "likes": 30, "viewed": 415, "published": 3, "date": "1672345399", "time_retrieved": "2024-07-30T16:10:16.032608", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float th = tanh(0.4*iTime);\n    float y = mix(5., 2., th);\n    float z = mix(-5., -3., th);\n    vec3 ro = vec3(0, y, z);\n    ro.xz *= rot(-0.04*(iTime+25.));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nvec2 map(vec3 p) {\n    float mat = 0.;  \n    float t = 0.1 * (iTime + 25.);\n    float sc = 0.1;\n    float pd = p.y - texture(iChannel0, sc*(p.xz + t)).r;\n    pd -= 0.5*texture(iChannel0, 2.*sc*(p.xz-100. + 1.01*t)).r;\n    pd += 0.25*texture(iChannel0, 4.*sc*(p.xz +0.99* t)).r;\n    float v = mix(7., 1., tanh(0.4*iTime));\n    pd = mix(pd, p.y-0.5, 1.-1./cosh(v*length(p.xz)));\n   \n    float pd2 = p.y-0.4;//\n    if (pd2 < pd) {\n        //pd = smin(pd, pd2, 0.12);\n        //mat = 1.;\n    }\n    mat = exp(-4.*(pd+pd2));\n    return vec2(0.25*pd, mat);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        //m.x *= 0.8 + 0.2 * hash(hash(p.x,p.z), p.y); // for glow\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < SURF_DIST || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }\n    \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.01 * i;\n        float d = map(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0,.9,0), 2.5);\n    vec3 col = vec3(0);\n   \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n    vec3 n = norm(p);\n    vec3 r = reflect(rd, n);\n    \n    if (d<MAX_DIST) {        \n        vec3 ld = normalize(vec3(1,2,3));\n        \n        float t = 0.1 * iTime;\n        ld = normalize(vec3(30.*cos(t),13,30.*sin(t))-p);\n        float dif  = dot(n,  ld)*.5+.5;\n        float spec = pow(dif, 16.);\n        spec = 1.-pow(.5+.5*dot(r, ld), 2.);\n        spec = clamp(spec, 0., 1.);\n        float fres = pow(1. + dot(rd, n),  5.);    \n        \n        // accidentally looks like clouds\n        vec3 c1 = texture(iChannel1, 0.01*p.xz + 0.01*iTime).rgb;\n        c1 = pow(c1 * vec3(.9,.9,1), vec3(4));\n        col = vec3(spec) * clamp((1.-m.z), 0., 1.); \n        \n        col = max(col, c1);\n        col = mix(col, vec3(.6,.55,1), 1.-exp(-0.005*m.y));\n        \n       // col = vec3(pow(spec, 8.));\n        // why not\n        col = mix(col, vec3(1,0.5,0.5), pow(AO(p, n), 8.));\n        \n        // somehow looks like there's no snow on it\n        // (im literally just bashing things together but it's\n        //  looking cool)\n        col *= .45+.55*clamp(shadow(p+SURF_DIST*n, ld), 0., 1.);\n    }\n    \n    col = clamp(col, 0., 1.);\n    \n    //col = vec3(1. - exp(-0.01 * m.y));\n    col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3WB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 80, 80, 365], [367, 367, 385, 385, 918], [920, 920, 959, 959, 1471], [1473, 1473, 1492, 1492, 1674], [1676, 1676, 1720, 1720, 1911], [1913, 1913, 1945, 1945, 2179], [2181, 2181, 2219, 2219, 2562], [2564, 2564, 2621, 2621, 4133]], "test": "untested"}
{"id": "DllGzX", "name": "The N-Body Problem", "author": "Yetman", "description": "2D Non-Euclidean Particles with Almost-Newtonian Physics.\nIf the sim is unstable, increase the DAMPING in the Buffer A shader.\n\nInteraction: \n- Hold LMB to attract particles to the mouse.\n- Hold Left Shift to increase DAMPING and decrease G.", "tags": ["2d", "particles", "physics", "nbody"], "likes": 16, "viewed": 410, "published": 3, "date": "1672345099", "time_retrieved": "2024-07-30T16:10:16.849424", "image_code": "#define PARTICLE_MAX_SIZE 10.0\n#define PARTICLE_MIN_SIZE 2.0\n#define VORONOI_EXP 4.0\n#define VORONOI_AMOUNT 0.08\n#define BG_COLOR vec3(0.01, 0.00, 0.02)\n\n// Source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float particle_size_base = max(iResolution.x, iResolution.y) / 640.0;\n\n    vec3 color = vec3(0.0);\n    vec3 voronoi_num = vec3(0.0);\n    float voronoi_den = 0.0;\n    \n    for(int idx = 0; idx < PARTICLE_COUNT; idx++){\n        vec2 position = decode(texelFetch(iChannel0, ivec2(idx, T_POS), 0)) * iResolution.xy;\n        vec2 delta = abs(position-fragCoord);\n        delta = min(delta, iResolution.xy - delta);\n        float d_sqr = dot(delta, delta);\n        \n        vec4 color_size = texelFetch(iChannel0, ivec2(idx, T_COL), 0);\n        float radius = mix(PARTICLE_MIN_SIZE, PARTICLE_MAX_SIZE, color_size.w) * particle_size_base;\n        float intensity = smoothstep(radius * radius, 0.0, d_sqr);\n        color += color_size.rgb * intensity;\n        \n        float voronoi_factor = 1.0 / max(0.01, pow(d_sqr / (particle_size_base * particle_size_base), VORONOI_EXP));\n        voronoi_num += color_size.rgb * voronoi_factor;\n        voronoi_den += voronoi_factor;\n    }\n    vec3 voronoi = voronoi_num / voronoi_den;\n    color += voronoi * VORONOI_AMOUNT + BG_COLOR;\n\n    // Output to screen\n    fragColor = vec4(ACESFilm(color), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define G 0.001\n#define MOUSE_G 0.05\n#define DAMPING 0.05\n#define INITIAL_VEL 0.2\n#define MAX_VEL 1.0\n#define COLOR_TINT vec3(1.0, 0.5, 0.25)\n\n// G and Damping applied when Left-Shift is pressed.\n#define SHIFT_G 0.00001\n#define SHIFT_DAMPING 0.5\n\nvec2 to_v(vec2 v) { return MAX_VEL * (2.0 * v - 1.0); }\nvec2 from_v(vec2 v) { return (v * (1.0 / MAX_VEL) + 1.0) * 0.5; }\n\nvec4 noise(int p){\n    int w = int(iChannelResolution[1].x);\n    return texelFetch(iChannel1, ivec2(p%w, p/w), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n        \n    int type = int(fragCoord.y), index = int(fragCoord.x);\n    \n    float delta_time = min(1.0/30.0, iTimeDelta);\n    int rand_offset = int(iDate.w)%1024;\n    \n    bool ini = texelFetch(iChannel0, ivec2(T_INI, 0), 0).a == 0.0;\n    \n    \n    if(index < PARTICLE_COUNT){\n        if(type == T_INI){\n            fragColor = noise(0);\n        }\n        else if(type == T_POS) {\n        \n            // Initialization Frame\n            if(ini){\n                vec2 p = decode(noise(index + rand_offset));\n                p = mix(sqrt(p), p*p, p);\n                fragColor = encode(p);\n            } \n            // Update Frame\n            else {\n                vec2 p = decode(texelFetch(iChannel0, ivec2(index, T_POS), 0));\n                vec2 v = to_v(decode(texelFetch(iChannel0, ivec2(index, T_VEL), 0)));\n                p += v * delta_time;\n                p = fract(p);\n                fragColor = encode(p);\n            }\n        } \n        \n        else if(type == T_VEL) {\n        \n            // Initialization Frame\n            if(ini){\n                vec2 v = INITIAL_VEL * (2.0 * decode(noise(index + rand_offset + PARTICLE_COUNT)) - 1.0);\n                fragColor = encode(from_v(v));\n            } \n            // Update Frame\n            else {\n                bool shift_pressed = KEY(SHIFT_ASCII, IS_PRESSED);\n                float g = mix(G, SHIFT_G, shift_pressed);\n                float damping = mix(DAMPING, SHIFT_DAMPING, shift_pressed);\n                \n                vec2 p = decode(texelFetch(iChannel0, ivec2(index, T_POS), 0));\n                vec2 v = to_v(decode(texelFetch(iChannel0, ivec2(index, T_VEL), 0)));\n                \n                vec2 a = vec2(0);\n                for(int other = 0; other < PARTICLE_COUNT; other++){\n                    if(other == index) continue;\n                    vec2 p_other = decode(texelFetch(iChannel0, ivec2(other, T_POS), 0));\n                    vec2 dir = p_other - p;\n                    dir = mix(dir, sign(dir)*(abs(dir)-1.0), step(vec2(0.5), abs(dir)));\n                    a += dir / max(0.0001, dot(dir, dir));\n                }\n                a *= g;\n                \n                if(iMouse.z > 0.0 && iMouse.w < 0.0){\n                    vec2 dir = iMouse.xy / iResolution.xy - p;\n                    dir = mix(dir, sign(dir)*(abs(dir)-1.0), step(vec2(0.5), abs(dir)));\n                    a += MOUSE_G * dir / max(0.0001, dot(dir, dir));\n                }\n                \n                v = exp(-delta_time * damping) * v + a * delta_time;\n                fragColor = encode(from_v(v));\n            }\n        }\n        \n        else if(type == T_COL) {\n        \n            // Initialization Frame\n            if(ini){\n                vec4 color_size = 0.01 + noise(index + rand_offset + 2 * PARTICLE_COUNT);\n                vec3 color = color_size.rgb;\n                color *= COLOR_TINT / dot(color, vec3(1.0/3.0));\n                fragColor = vec4(color, color_size.a);\n            }\n            // Update Frame (Nothing to update)\n            else {\n                fragColor = texelFetch(iChannel0, ivec2(index, T_COL), 0);\n            }\n        }\n        \n    }\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PARTICLE_COUNT 128\n\nvec2 decode(vec4 e) { return e.xy + e.zw * (1.0 / 256.0); }\nvec4 encode(vec2 d) { \n    d *= 256.0;\n    vec2 zw = fract(d);\n    return vec4(floor(d) * (1.0 / 256.0), zw);\n}\n\n#define T_INI 0\n#define T_POS 1\n#define T_VEL 2\n#define T_COL 3\n\n#define SHIFT_ASCII 16\n#define CTRL_ASCII 17\n#define SPACE_ASCII 32\n#define IS_PRESSED 0\n#define JUST_PRESSED 1\n\n#define KEY(ascii, event) (texelFetch(iChannel3, ivec2(ascii, event), 0).x != 0.0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 241, 264, 264, 409], [411, 411, 468, 468, 1611]], "test": "untested"}
{"id": "cllGWB", "name": "A bit trippy...", "author": "mrange", "description": "CC0: A bit trippy...\nThis didn't come out at all as I was intending.\n", "tags": ["2d", "trippy"], "likes": 24, "viewed": 367, "published": 3, "date": "1672338862", "time_retrieved": "2024-07-30T16:10:17.595429", "image_code": "// CC0: A bit trippy...\n//  This didn't come out at all as I was intending.\n\n// Comment to remove kaleidoscope effect\n#define KALEIDOSCOPE\n\n// Try other numbers like 2.0, 6.0, 10.0\n//  Odd numbers don't really work because I am lazy.\n#define REP         36.0\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(1.2);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat forward(float n) {\n  return exp2(ExpBy*n);\n}\n\nfloat reverse(float n) {\n  return log2(n)/ExpBy;\n}\n\nvec2 cell(float n) {\n  float n2  = forward(n);\n  float pn2 = forward(n-1.0);\n  float m   = (n2+pn2)*0.5;\n  float w   = (n2-pn2)*0.5;\n  return vec2(m, w);\n}\n\nvec2 df(vec2 p, float aa) {\n  float tm = TIME;\n  float m = fract(tm);\n  float f = floor(tm);\n  float z = forward(m);\n  \n  vec2 p0 = p;\n  p0 /= z;\n  vec2 sp0 = sign(p0);\n  p0 = abs(p0);\n\n  float l0x = p0.x;\n  float n0x = ceil(reverse(l0x));\n  vec2 c0x  = cell(n0x); \n\n\n  float l0y = p0.y;\n  float n0y = ceil(reverse(l0y));\n  vec2 c0y  = cell(n0y); \n\n  float h0 = hash(vec2(n0x, n0y)-vec2(f)+vec2(sp0.x, sp0.y));\n\n  vec2 pp = vec2(p0.x, p0.y);\n  vec2 oo = vec2(c0x.x, c0y.x);\n  vec2 cc = vec2(c0x.y, c0y.y);\n  pp -= oo;\n  \n  float rr = 0.0033/z;\n  float d1 = box(pp, cc-2.0*rr)-rr;\n  \n  float d = d1;\n  d *= z;\n\n  return vec2(d, h0);\n}\n\nvec4 effect(vec2 p, float hue) {\n  float aa =2.0/RESOLUTION.y;\n  vec2 d2 = df(p, aa);\n\n  float fd = min(abs(p.x), abs(p.y));\n  vec3 col = vec3(0.0);\n  vec3 bcol = hsv2rgb(vec3(fract(hue+0.3*d2.y), 0.85, 1.0));\n  return vec4(bcol, smoothstep(aa, -aa, d2.x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 ppp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float hue = -length(p)+0.1*TIME; \n\n  vec2 pp = p;\n  const float rep = REP;\n  const float sm  = 0.05*36.0/REP;\n#if defined(KALEIDOSCOPE)\n  float nn = smoothKaleidoscope(pp, sm, rep);\n#endif  \n  pp *= ROT(0.05*TIME-0.5*length(p));\n  vec3 col = vec3(0.0);\n  vec4 col0 = effect(pp, hue);\n  col = mix(col, col0.xyz, col0.w);\n\n  col += hsv2rgb(vec3(hue, 0.66, 4.0))*mix(1.0, 0.0, tanh_approx(2.0*sqrt(length(p))));\n  col *= smoothstep(1.5, 0.5, length(ppp));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[622, 622, 644, 644, 790], [1085, 1145, 1166, 1166, 1236], [1238, 1338, 1377, 1377, 1462], [1464, 1550, 1595, 1595, 1749], [1751, 1839, 1869, 1869, 1897], [1899, 1959, 1987, 2053, 2129], [2131, 2219, 2241, 2241, 2285], [2287, 2375, 2396, 2396, 2441], [2443, 2531, 2592, 2592, 2805], [2807, 2925, 2952, 2952, 3028], [3030, 3030, 3054, 3054, 3080], [3082, 3082, 3106, 3106, 3132], [3134, 3134, 3154, 3154, 3289], [3291, 3291, 3318, 3318, 3924], [3926, 3926, 3958, 3958, 4185], [4187, 4187, 4242, 4242, 4861]], "test": "untested"}
{"id": "dtX3WS", "name": "2D SDF with circles & smooth min", "author": "lorismat_", "description": "Distance to a circle", "tags": ["2d", "distancefield", "sdf", "circle", "distance"], "likes": 13, "viewed": 756, "published": 3, "date": "1672335858", "time_retrieved": "2024-07-30T16:10:18.346421", "image_code": "// smooth min implementation and SDF in 2d with circles\n// from Inigo Quilez articles!\n// smooth min: \n// https://iquilezles.org/articles/smin/\n// sdf in 2d:\n// https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pix = 2./iResolution.y;  \n\n\tvec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 m = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float f = 0.9;\n\n\tfloat d = sdCircle(p,0.8);\n    float dd = sdCircle(m+vec2(sin(iTime*f + 1.)*1.5,sin(iTime*f + 1.)*0.4),0.2);\n    \n    vec3 col = vec3(1.);\n    \n    col = mix(col, vec3(0.), smoothstep(-pix,pix, smin(d,dd,1.0) - .0375 ));\n    col = mix(col, vec3(0.), smoothstep(pix,-pix, smin(d,dd,0.3) - .0065 ));\n\t\n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtX3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 253, 253, 279], [281, 281, 320, 320, 401], [404, 404, 461, 461, 970]], "test": "untested"}
{"id": "dtXGDB", "name": "Golfed Color Key (96 chars)", "author": "MysteryPancake", "description": "New winner is coyote, great job!", "tags": ["2d", "chroma", "greenscreen", "chromakey", "matte", "compositing", "replace", "golf", "golfed"], "likes": 3, "viewed": 254, "published": 3, "date": "1672321405", "time_retrieved": "2024-07-30T16:10:19.085446", "image_code": "// By coyote, 96 chars\nvoid mainImage(out vec4 O, vec2 u) {\n    dot(O = texture(iChannel0, u / iResolution.xy), O) < .5 + 2. * O.g ? O-- : O;\n}\n\n// By FabriceNeyret2, 105 chars\n/*void mainImage(out vec4 O, vec2 u) {\n    vec4 G = O = texture(iChannel0, u / iResolution.xy);\n    G.ga--;\n    dot(G, G) < .5 ? O-- : O;\n}*/\n\n// Sharp alpha, 109 chars (thanks Alpgaga, kishimisu)\n/*void mainImage(out vec4 O, vec2 u) {\n    O = texture(iChannel0, u / iResolution.xy);\n    O -= step(length(O - vec4(0, 1, 0, 1)), .7);\n}*/\n\n// Smooth alpha, 118 chars\n/*void mainImage(out vec4 O, vec2 u) {\n    O = texture(iChannel0, u / iResolution.xy);\n    O *= smoothstep(.5, .7, length(O - vec4(0, 1, 0, 1)));\n}*/", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 59, 59, 143]], "test": "untested"}
{"id": "dlfGWS", "name": "马赛克test1", "author": "xst02071211", "description": "mosaic", "tags": ["2d"], "likes": 0, "viewed": 183, "published": 3, "date": "1672305265", "time_retrieved": "2024-07-30T16:10:19.835441", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 10.0;     // Scale the coordinate system by 10\n\n    vec2 ipos = floor(uv);  // get the integer coords\n    vec2 fpos = fract(uv);  // get the fractional coords\n\n\n    vec3 color = vec3(random( ipos ));     // Assign a random value based on the integer coord\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 190, 240, 607]], "test": "untested"}
{"id": "DlXGDB", "name": "2d marchin ", "author": "timeiskey", "description": "has some antialiasing now. would like to sample a thresholded texture for the distance function next", "tags": ["2d", "raymarch"], "likes": 1, "viewed": 218, "published": 3, "date": "1672297422", "time_retrieved": "2024-07-30T16:10:20.573467", "image_code": "#define MAX_STEPS 100\n#define MIN_SURFACE_DIST 0.001\n#define MAX_DIST 100.0\n\nfloat get_dist(vec2 p)\n{\n    vec2 c = vec2(0.0, 0.0);\n     \n    float r = 0.1;\n\tfloat cd = length(p - c) - r;\n    \n    return cd;\n}\n\nfloat march(vec2 ro, vec2 rd)\n{\n    float total_dist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec2 p = ro + rd * total_dist;\n        float dist = get_dist(p);\n        total_dist += dist;\n        if(dist < MIN_SURFACE_DIST || total_dist > MAX_DIST)\n        {\tbreak;\t}\n    }\n    return total_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tstart it off\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n\n    // light\n    float light_brightness = 0.03;\n    //vec2 light = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 light_center = vec2(0.0, 0.0);\n    vec2 light_offset = vec2(\n    \t(sin(iTime) - 0.0) * 1.0,\n        (cos(iTime) - 0.0) * 1.0);\n    vec2 light = light_center + light_offset * 0.5;\n    \n    //\tfire a ray for each pixel\n    vec2 ro = light;\n    vec2 rd = normalize(uv.xy - light);\n\tfloat d2shape = march(ro, rd);\n    float d2l = length(uv - light);\n    \n    //if d2shape and d2light are different. its collided, so be black.\n    vec3 shadow_color = vec3(0.0);\n    float raw_b = light_brightness / pow(d2l, 3.0);//brightness from light assuming no collision\n    float dif = d2shape - d2l;\n    //float b = raw_b * float(dif >= 0.01);\n    float b = smoothstep(0.005, .005+(3.0/iResolution.y), dif) * raw_b;\n    //col = vec3(b);\n    col = vec3(b);\n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 101, 101, 208], [210, 210, 241, 241, 523], [525, 525, 582, 602, 1591]], "test": "untested"}
{"id": "dtl3Rl", "name": "String Engine", "author": "ang_rq", "description": "Shader for drawing chars and string in specific places with specific sizes and spacing.\nString needs to be of a specific length, in this case 20.\nChars are representes as ints by the ASCII ord(char). ", "tags": ["font", "string", "char"], "likes": 1, "viewed": 240, "published": 3, "date": "1672275218", "time_retrieved": "2024-07-30T16:10:21.315483", "image_code": "//#define debug\n\n\nvec4 getCharBoundsOnMap(in int char) {\n    char += 32;\n    float x = mod(float(char), 16.0);\n    float y = 1.-(float(char) - x) / 16.0;\n    vec2 uv = vec2(x, y) / 16.0;\n    return vec4(uv, uv + 0.0625);\n}\n\nbool inBounds(in vec2 uv, in vec4 bounds) {\n    return (uv.x >= bounds.x && uv.x <= bounds.z) && (uv.y >= bounds.y && uv.y <= bounds.w);\n}\n\nvec2 map(vec2 x, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return ((x-a)*(d-c))/(b-a) + c;\n}\n\n\nvec4 drawChar(in vec2 uv, in vec2 charDrawPos, in vec2 charSize,\nin vec3 charColorRGB, in vec2 charWidthEdge, vec2 zoomChar, in int char)\n{\n\n    vec4 whereDrawChar = vec4(charDrawPos-charSize/2., charDrawPos+charSize/2.);\n    if(inBounds(uv, whereDrawChar))\n    {\n        \n        vec4 zoom = vec4(zoomChar, -zoomChar);\n        float width = charWidthEdge.x;\n        float edge = charWidthEdge.y;\n        vec4 charSample = vec4(0.);\n        vec4 charBounds = getCharBoundsOnMap(char) + zoom;\n        charSample = texture(iChannel0, map(uv, whereDrawChar.xy, whereDrawChar.zw,\n                                             charBounds.xy, charBounds.zw));\n                                             \n        \n        float dist = 1. - charSample.a;\n        float alpha = smoothstep(width, width + edge, dist);\n        vec4 charColorRGBA = vec4(charColorRGB, alpha);\n        \n        return charColorRGBA;\n    }\n    else\n        return vec4(-1., -2., -3., 0.);\n}\n\n//vec4 drawString(in vec2 uv, in ve2\n\n\nvec4 drawString(in vec2 uv, in vec2 stringPos, in vec2 charSize, \n        in vec3 charColorRGB, in vec2 charWidthEdge, in vec2 zoomChar,\n                in float charSpacing, in int[20] string)\n{\n    int slen = string.length();\n    int slenp2 = slen/2;\n    float x = 0.;\n    for(int i = 0; i < slen; i++)\n    {\n        \n        x = float(i-slenp2)*(charSize.x + charSpacing) + float(slen%2==0)*(charSize.x + charSpacing)/2.;\n        \n        vec2 charPos = vec2(stringPos.x + x, stringPos.y);\n        vec4 color = drawChar(uv, charPos, charSize, charColorRGB,\n                                    charWidthEdge, zoomChar, string[i]);\n        if(color.x != -1.)\n        {\n            return color;\n            break;\n        }\n        x += charSize.x + charSpacing;\n        \n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    return vec4(-1., -2., -3., 0.);\n}\n\nint[] string = int[20](65, 66, 67, 68, 65,\n65, 66, 67, 68, 65,\n65, 66, 67, 68, 65,\n65, 66, 67, 68, 65);\n\n\n\n//blending from https://www.shadertoy.com/view/MstfWl\nvec4 oneMinusSrcAlpha(vec4 srcColor, vec4 dstColor)\n{\n    return (srcColor.a * srcColor) + ((1.0 - srcColor.a) * dstColor);\n}\n\n// Pick a blend func for testing\nvec4 blendFunc(vec4 srcColor, vec4 dstColor)\n{\n    return oneMinusSrcAlpha(srcColor, dstColor);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 charPos = iMouse.xy/iResolution.xy;\n    vec2 charSize = vec2(0.055, 0.19);\n    vec3 charColorRGB = vec3(1.0, 0.5, 0.9);\n    vec2 zoomChar = vec2(0.015, 0.01);\n    float charSpacing = 0.01;\n    vec2 charWidthEdge = vec2(0.5, 0.007); // width and edge\n    \n    vec2 stringPos = iMouse.xy/iResolution.xy;\n    \n    vec4 background = vec4(0.4, 0.7, 0.8, 1.0);\n    \n    \n    //vec4 charColorRGBA = drawChar(uv, charPos, charSize, charColorRGB\n    //                                    , charWidthEdge, 65);\n    vec4 charColorRGBA = drawString(uv, stringPos, charSize, charColorRGB\n                                  , charWidthEdge, zoomChar, charSpacing, string);\n    \n    if(charColorRGBA.r == -1.)\n    {\n        fragColor = background;\n        return;\n    }\n \n    fragColor = blendFunc(charColorRGBA, background);\n    \n \n    \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define sLen 20\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtl3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 267, 267, 362], [364, 364, 414, 414, 452], [455, 455, 594, 594, 1415], [2421, 2475, 2528, 2528, 2600], [2602, 2635, 2681, 2681, 2732], [2737, 2737, 2792, 2792, 3667]], "test": "untested"}
{"id": "mllGzs", "name": "Continuous Arm IK - Solution 1", "author": "oneshade", "description": "One possible solution for a continuous arm reaching between two points and with a fixed length.\nClick and drag the mouse to move the gripper.", "tags": ["ik", "arc", "continuous", "arm"], "likes": 16, "viewed": 228, "published": 3, "date": "1672271708", "time_retrieved": "2024-07-30T16:10:22.053510", "image_code": "#define PI 3.1415926536\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0.0, 1.0));\n}\n\n// https://www.shadertoy.com/view/wl23RK\nfloat sdArc(in vec2 p, in vec2 sc, in float r) {\n    p.x = abs(p.x);\n    return sc.y * p.x > sc.x * p.y ? length(p - sc * r) : abs(length(p) - r);\n}\n\nvec2 arclength(in float h, in float r, out float halfH, out float halfArc, out float R) {\n    halfH = h / 2.0;\n    R = sqrt(r * r + halfH * halfH);\n\n    float si = r / R;\n    halfArc = asin(si);\n    if (h < 0.0) halfArc = PI - halfArc;\n\n    float arclen = 2.0 * R * halfArc;\n    float q = si / sqrt(1.0 - si * si);\n    float slope = (h < 0.0 ? halfArc + q : halfArc - q) * halfH / R;\n\n    return vec2(arclen, slope);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        float ang = 0.5 + 0.5 * sin(iTime);\n        mouse = vec2(3.0 * cos(ang), sin(ang));\n    }\n\n    float mouseDist = length(mouse);\n    vec2 cosi = mouse / mouseDist;\n    mat2 rot = mat2(cosi.x, cosi.y, -cosi.y, cosi.x);\n\n    // Check if the target is within reach\n    float L = 3.5;\n    if (mouseDist < L) {\n        // Solve for parameter h to set arclength equal to L\n        float r = mouseDist / 2.0;\n        float h = L;\n        float halfH, halfArc, R;\n        for (int i=0; i < 6; i++) {\n            vec2 A = arclength(h, r, halfH, halfArc, R);\n            h -= (A.x - L) / A.y;\n        }\n\n        // Draw the arm\n        //vec2 prev = vec2(0.0);\n        //for (float t=0.02; t < 1.02; t += 0.02) {\n        //    float theta = mix(halfArc, -halfArc, t);\n        //    vec2 cur = rot * (R * vec2(-sin(theta), cos(theta)) + vec2(r, -halfH));\n        //    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, sdLine(uv, prev, cur)));\n        //    prev = cur;\n        //}\n\n        float gripper = length(uv - mouse) - 0.2;\n\n        float arm = sdArc(uv * rot - vec2(r, -halfH), vec2(sin(halfArc), cos(halfArc)), R) - 0.05;\n        arm = max(arm, -gripper);\n        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, arm));\n\n        gripper = max(gripper, 0.1 - sdLine(uv, mouse, mouse + rot * vec2(cos(halfArc), -sin(halfArc))));\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, gripper));\n    }\n\n    // Otherwise, choose the closest approximation to the target\n    else {\n        vec2 nearest = cosi * L;\n        float gripper = length(uv - nearest) - 0.2;\n\n        float arm = sdLine(uv, vec2(0.0), nearest) - 0.05;\n        arm = max(arm, -gripper);\n        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, arm));\n\n        gripper = max(gripper, 0.1 - sdLine(uv, nearest, nearest + cosi));\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, gripper));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 72, 72, 161], [163, 204, 252, 252, 352], [354, 354, 443, 443, 772], [774, 774, 829, 829, 3032]], "test": "untested"}
{"id": "dls3Rf", "name": "Soothing Circles w/ clock", "author": "fishy", "description": "Clock from here: https://www.shadertoy.com/view/DtX3Rl", "tags": ["circles"], "likes": 2, "viewed": 232, "published": 3, "date": "1672255326", "time_retrieved": "2024-07-30T16:10:22.795526", "image_code": "#define DISPLAY_STYLE vec2(0.1, 0.02)\n\n#define AA(d) smoothstep(px, -px, d)\n\n#define HIDE_ZERO\n\nstruct displayInfo\n{\n    bool a, b, c, d, e, f, g;\n};\n\nfloat box(in vec2 uv, vec2 b)\n{\n    uv = abs(uv)-b; return max(uv.x, uv.y);\n}\n\n#define t true\n#define f false\ndisplayInfo[] info = displayInfo[] (\ndisplayInfo(t, t, t, t, t, t, f),\ndisplayInfo(f, t, t, f, f, f, f),\ndisplayInfo(t, t, f, t, t, f, t),\ndisplayInfo(t, t, t, t, f, f, t),\ndisplayInfo(f, t, t, f, f, t, t),\ndisplayInfo(t, f, t, t, f, t, t),\ndisplayInfo(t, f, t, t, t, t, t),\ndisplayInfo(t, t, t, f, f, f, f),\ndisplayInfo(t, t, t, t, t, t, t),\ndisplayInfo(t, t, t, t, f, t, t));\n#undef t\n#undef f\n\n#define vc(p, b, z) if(i.z) d = min(d, box(uv-vec2(size.xx*p.xy), size.yx+vec2(0, size.y)))\n#define hc(p, b, z) if(i.z) d = min(d, box(uv-vec2(0, size.x*p*2.), size.xy+vec2(size.y, 0)))\nfloat segDisplay(vec2 uv, vec2 size, displayInfo i)\n{\n    float d = 1e20;\n    hc(1., size.x, a);\n    vc(vec2(1, 1), size.x, b);\n    vc(vec2(1, -1), size.x, c);\n    hc(-1., size.x, d);\n    vc(vec2(-1, -1), size.x, e);\n    vc(vec2(-1, 1), size.x, f);\n    hc(0., size.x, g);\n    return d;\n}\n\nfloat getClock(vec2 uv, float px, vec2 time, float blink)\n{\n    //float hours = mod(time/60./60.-offset, 12.)+offset;\n    //float minutes = mod(time/60., 60.);\n    float hours = time.x;\n    float minutes = time.y;\n    \n    float col = 0.;\n    col +=\n    #ifdef HIDE_ZERO\n    step(0.1, floor(time.x/10.))*\n    #endif\n    AA(segDisplay(uv+vec2(DISPLAY_STYLE.x*1.5, 0)-vec2(-DISPLAY_STYLE.x*4., 0), DISPLAY_STYLE, info[int(mod(hours/10., 10.))]));\n    col += AA(segDisplay(uv-vec2(DISPLAY_STYLE.x*1.5, 0)-vec2(-DISPLAY_STYLE.x*4., 0) , DISPLAY_STYLE, info[int(mod(hours, 10.))]));\n    col += AA(segDisplay(uv+vec2(DISPLAY_STYLE.x*1.5, 0)-vec2( DISPLAY_STYLE.x*4., 0), DISPLAY_STYLE, info[int(mod(minutes/10., 10.))]));\n    col += AA(segDisplay(uv-vec2(DISPLAY_STYLE.x*1.5, 0)-vec2( DISPLAY_STYLE.x*4., 0) , DISPLAY_STYLE, info[int(mod(minutes, 10.))]));\n    col += AA(box(uv-vec2(0, DISPLAY_STYLE.x*1.3), vec2(DISPLAY_STYLE.y)))*blink;\n    col += AA(box(uv+vec2(0, DISPLAY_STYLE.x*1.3), vec2(DISPLAY_STYLE.y)))*blink;\n    return col;\n}\n\nfloat circles(vec2 p, float px, float time)\n{\n    float sum = 0.;\n    for(float i = -2.01; i <= 2.; i++) // An artifact appears if i is initialized at -2 instead of -2.01\n    {\n        float currentCircle = floor(p.x+i);\n        float circleSize = 1.2+0.2*sin(currentCircle*0.5+time);\n        sum += smoothstep(px, -px, distance(p, vec2(currentCircle, 0))-circleSize);\n    }\n    return sum;\n}\n\nfloat pulse(float x, float k)\n{\n    return round(min(1., fract(x)/(2.*k)));\n}\n\n#define time iDate.w\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float px = 1.5/iResolution.y;\n    \n    float clock1 = getClock(uv, px, vec2(mod(time/60./60.-1., 12.)+1., mod(time/60., 60.)), mix(1., 0.8, pulse(time*0.5, 0.5)));\n    float clock2 = getClock(uv, px, vec2(88., 88.), 0.);\n    \n    vec3 col = ((circles((vec2(uv.x*sign(uv.y), abs(uv.y))-vec2(0, 1))*6., 6.*px, iTime*0.5)*0.2)+0.1)*vec3(1);\n    col += clamp(clock2*0.1+clock1, 0., 1.)*0.4;\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dls3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 182, 182, 228], [844, 844, 897, 897, 1131]], "test": "untested"}
{"id": "DtsGRs", "name": "Lyrics Player", "author": "ang_rq", "description": "A simple text renderer using the character map texture. Characters are represented by codes between 0x00 and 0xFF (0 and 255). Characters in the map start in the bottom left corner and end in the top right corner.", "tags": ["text", "rendering"], "likes": 3, "viewed": 284, "published": 3, "date": "1672254571", "time_retrieved": "2024-07-30T16:10:23.534550", "image_code": "//int[] stringChars = int[14](0xB7, 0x95, 0x9C, 0x9C, 0x9F, 0xDC, 0x50, 0xA7, 0x9F, 0x82, 0x9C, 0x94, 0xD1, 0x50);\n\n#define sLen 20\n//#define debug\n\nint[] stringChars = int[](32,32,32,32,32,32,72,101,121,32,71,117,121,115,32,32,32,32,32,32,\n32,32,32,32,105,32,97,109,32,116,101,115,116,105,110,103,32,32,32,32,\n32,32,32,32,32,116,104,105,115,32,116,104,105,110,103,32,32,32,32,32,\n32,32,32,32,32,32,32,32,98,117,116,32,32,32,32,32,32,32,32,32,\n32,32,32,73,32,116,104,105,110,107,32,105,32,110,101,101,100,32,32,32,\n32,32,32,32,32,115,111,109,101,32,104,101,108,112,32,32,32,32,32,32,\n32,32,32,105,116,39,115,32,106,117,115,116,32,116,111,111,32,32,32,32,\n32,32,32,32,32,32,32,32,115,108,111,119,32,32,32,32,32,32,32,32,\n119,104,101,110,32,116,104,101,114,101,32,97,114,101,32,97,32,108,111,116,\n32,32,32,32,32,111,102,32,108,121,114,105,99,115,32,32,32,32,32,32,\n32,32,102,111,114,32,115,111,109,101,32,114,101,97,115,111,110,32,32,32,\n97,110,100,32,73,32,100,111,110,39,116,32,107,110,111,119,32,119,104,121,\n32,32,111,114,32,104,111,119,32,116,111,32,102,105,120,32,105,116,32,32,\n32,32,32,32,32,32,32,116,104,120,32,60,51,32,32,32,32,32,32,32,32);\n\nfloat[] times = float[](0.5804988662131519,0.9984580498866213,1.509297052154195,\n                        1.7647165532879818,2.391655328798186,2.8560544217687074,\n                        3.297233560090703,3.8312925170068026,4.133151927437642,\n                        4.760090702947846,5.2477097505668935,5.688888888888889,\n                        6.594467120181406,7.174965986394557,9.05578231292517);\n\n\nvec4[sLen] stringBounds;\n\nvec2 mapBounds(in vec2 uv, in vec4 drawBounds, in vec4 charBounds) {\n    vec2 mappedToDrawBounds = (uv - drawBounds.xy) / (drawBounds.zw - drawBounds.xy);\n    return charBounds.xy + (mappedToDrawBounds * (charBounds.zw - charBounds.xy));\n}\n\nbool inBounds(in vec2 uv, in vec4 bounds) {\n    return (uv.x >= bounds.x && uv.x <= bounds.z) && (uv.y >= bounds.y && uv.y <= bounds.w);\n}\n\n\nvec4 calcCharBounds(in int char) {\n    char += 32;\n    float x = mod(float(char), 16.0);\n    float y = 1.-(float(char) - x) / 16.0;\n    vec2 uv = vec2(x, y) / 16.0;\n    return vec4(uv, uv + 0.0625);\n}\n\n\n\nvoid calcStringBounds(in vec2 position, in vec2 charSize, in int stringLength) {\n    vec2 topLeft = position - 0.5 * vec2(charSize.x * float(stringLength), charSize.y);\n    for (int i=0; i < stringLength; i++) {\n        stringBounds[i] = vec4(topLeft, topLeft + charSize);\n        topLeft.x += charSize.x;\n    }\n}\n\nvec3 renderText(in vec2 uv, in int stringStart, in int stringLength) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i=0; i < stringLength; i++) {\n        if (inBounds(uv, stringBounds[i])) {\n            int charIndex = int(mod(float(stringStart + i), float(stringChars.length())));\n            vec4 bounds = calcCharBounds(stringChars[charIndex]);\n            vec2 mapped = mapBounds(uv, stringBounds[i], bounds);\n            color += texture(iChannel0, mapped).r;\n        }\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = vec2(0.5, 0.5);//iMouse.xy/iResolution.xy;\n    vec2 size = vec2(0.04, 0.08);\n    calcStringBounds(pos, size, sLen);\n    \n    int nline = 0;\n    while(times[nline] < mod(iTime/2., times[times.length()-1]) && nline < sLen)\n        {\n            nline += 1;\n            nline = nline>sLen? 0: nline;\n        }\n    fragColor = vec4(renderText(uv, nline * sLen, sLen), 1.0);\n    #ifdef debug\n    fragColor = vec4(texture(iChannel0, uv).r);\n    #endif\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1581, 1581, 1649, 1649, 1820], [1822, 1822, 1865, 1865, 1960], [2167, 2167, 2247, 2247, 2480], [2482, 2482, 2552, 2552, 2988], [2990, 2990, 3045, 3045, 3550]], "test": "untested"}
{"id": "DtX3Rl", "name": "Minimal Digital Clock", "author": "fishy", "description": "Clock!", "tags": ["time", "clock", "digits", "counting"], "likes": 6, "viewed": 211, "published": 3, "date": "1672251485", "time_retrieved": "2024-07-30T16:10:24.276566", "image_code": "#define DISPLAY_STYLE vec2(0.1, 0.02)\n\n#define AA(d) smoothstep(px, -px, d)\n\nstruct displayInfo\n{\n    bool a, b, c, d, e, f, g;\n};\n\nfloat box(in vec2 uv, vec2 b)\n{\n    uv = abs(uv)-b; return max(uv.x, uv.y);\n}\n\n#define t true\n#define f false\ndisplayInfo[] info = displayInfo[] (\ndisplayInfo(t, t, t, t, t, t, f),\ndisplayInfo(f, t, t, f, f, f, f),\ndisplayInfo(t, t, f, t, t, f, t),\ndisplayInfo(t, t, t, t, f, f, t),\ndisplayInfo(f, t, t, f, f, t, t),\ndisplayInfo(t, f, t, t, f, t, t),\ndisplayInfo(t, f, t, t, t, t, t),\ndisplayInfo(t, t, t, f, f, f, f),\ndisplayInfo(t, t, t, t, t, t, t),\ndisplayInfo(t, t, t, t, f, t, t));\n#undef t\n#undef f\n\n#define vc(p, b, z) if(i.z) d = min(d, box(uv-vec2(size.xx*p.xy), size.yx+vec2(0, size.y)))\n#define hc(p, b, z) if(i.z) d = min(d, box(uv-vec2(0, size.x*p*2.), size.xy+vec2(size.y, 0)))\nfloat segDisplay(vec2 uv, vec2 size, displayInfo i)\n{\n    float d = 1e20;\n    hc(1., size.x, a);\n    vc(vec2(1, 1), size.x, b);\n    vc(vec2(1, -1), size.x, c);\n    hc(-1., size.x, d);\n    vc(vec2(-1, -1), size.x, e);\n    vc(vec2(-1, 1), size.x, f);\n    hc(0., size.x, g);\n    return d;\n}\n\nfloat getClock(vec2 uv, float px, float time)\n{\n    float hours = mod(time/60./60.-1., 12.)+1.;\n    float minutes = mod(time/60., 60.);\n    \n    float col = AA(segDisplay(uv+vec2(DISPLAY_STYLE.x*1.5, 0)-vec2(-DISPLAY_STYLE.x*4., 0), DISPLAY_STYLE, info[int(mod(hours/10., 10.))]));\n    col +=      AA(segDisplay(uv-vec2(DISPLAY_STYLE.x*1.5, 0)-vec2(-DISPLAY_STYLE.x*4., 0) , DISPLAY_STYLE, info[int(mod(hours, 10.))]));\n    col +=      AA(segDisplay(uv+vec2(DISPLAY_STYLE.x*1.5, 0)-vec2( DISPLAY_STYLE.x*4., 0), DISPLAY_STYLE, info[int(mod(minutes/10., 10.))]));\n    col +=      AA(segDisplay(uv-vec2(DISPLAY_STYLE.x*1.5, 0)-vec2( DISPLAY_STYLE.x*4., 0) , DISPLAY_STYLE, info[int(mod(minutes, 10.))]));\n    col +=      AA(box(uv-vec2(0, DISPLAY_STYLE.x*1.3), vec2(DISPLAY_STYLE.y)));\n    col +=      AA(box(uv+vec2(0, DISPLAY_STYLE.x*1.3), vec2(DISPLAY_STYLE.y)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float px = 2./iResolution.y;\n    \n    float col = getClock(uv, px, iDate.w);\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtX3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 132, 163, 163, 209], [825, 825, 878, 878, 1112], [1114, 1114, 1161, 1161, 1996], [1998, 1998, 2055, 2055, 2224]], "test": "untested"}
{"id": "dllGRl", "name": "Secret Listenbourg Vortex", "author": "totetmatt", "description": "Secret Listenbourg Vortex", "tags": ["secretlistenbourg"], "likes": 6, "viewed": 101, "published": 3, "date": "1672250445", "time_retrieved": "2024-07-30T16:10:25.016587", "image_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nfloat qq(vec2 uv){\n    uvec2 uuv = uvec2(uv*256.);\n    return float(uuv.x&uuv.y)/128.;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv*=4.;\n\n    \n    uv*=rot(asin(sin(iTime+length(uv)))*.5);\n    uv = vec2(log(length(uv)),atan(uv.y,uv.x)*3.14*.5);\n    uv.x -=iTime;\n    float sc= 1.;\n    for(float i=0.;i++<4.;){\n        uv =  asin(sin(abs(uv)-.75));\n        uv *= rot(.785*i);\n        uv*=1.2;\n        sc*=1.2;\n    }\n    uv/=sc;\n    float d = abs(uv.x)-.1-clamp(.1,.15,uv.y)+qq(uv)*.2;\n    d = min(d,abs(uv.y)-.1-qq(uv)*.2);\n    d = smoothstep(fwidth(d),0.,d);\n    vec3 col = vec3(1.)*d;\n    col = mix(vec3(.8+qq(uv)),vec3(.5-qq(uv),.0,.0),col);\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [67, 67, 85, 85, 155], [156, 156, 211, 211, 831]], "test": "untested"}
{"id": "Dls3Rl", "name": "Polar image on a sphere", "author": "ang_rq", "description": "Image projected inside a view sphere using spherical coordinates.\nI am sure there is a better way to do it, would love your thoughts on this.", "tags": ["sphere", "projection", "image"], "likes": 1, "viewed": 196, "published": 3, "date": "1672241970", "time_retrieved": "2024-07-30T16:10:25.839388", "image_code": "\n#define Mouse (iMouse.xy / iResolution.xy)\n#define Resolution (iResolution.xy)\n#define Time (iTime)\n#define PI 3.1415926535897932384626433832795028841971693993751058209749\n\n\n//rotmat and getRay from https://www.shadertoy.com/view/MdXyzX\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = (axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n    if(Resolution.x < 400.0) return proj;\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\n//polar coordinates from https://gamedev.stackexchange.com/questions/87305/how-do-i-convert-from-cartesian-to-spherical-coordinates\nfloat getPhi(in float y, in float x)\n{\n    if (x == 0.0) {\n        if (y == 0.0) {\n            return 0.0;\n        } else if (y > 0.0) {\n            return PI/2.0;\n        } else {\n            return -1.0 * PI/2.0;\n        }\n    } else if (x > 0.0) {\n        return atan(y/x);\n    } else if (x < 0.0) {\n        if (y >= 0.0) {\n            return atan(y/x) + PI;\n        } else {\n            return atan(y/x) + PI;\n        }\n    }\n}\n\nvec3 toPolar(in vec3 cart)\n{\n    float xySquared = (cart.x * cart.x) + (cart.y * cart.y);\n    float radius = sqrt(xySquared + (cart.z * cart.z));\n    return vec3(radius, atan(sqrt(xySquared), cart.z), getPhi(cart.y, cart.x));\n}\n\nvec3 toCartesian(in vec3 sph) {\n    return vec3(\n        sin(sph.y) * cos(sph.z) * sph.x,\n        sin(sph.y) * sin(sph.z) * sph.x,\n        cos(sph.y) * sph.x\n    );\n}\n\n//check if x is between a and a+d\nbool inside(vec2 x, vec2 a, vec2 d)\n{\n    return ((x.x >= a.x-d.x/2. && x.x <= a.x + d.x/2.) &&\n            (x.y >= a.y-d.y/2. && x.y <= a.y + d.y/2.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //View Ray\n    vec3 cartView = normalize(getRay(uv));\n    //Direction to Image\n    vec3 cartImage = normalize(vec3(1., 0., 0.));\n    \n    //Polar form (x, y, z) -> (r, theta, phi)\n    vec3 polarView = toPolar(cartView);\n    vec3 polarImage = toPolar(cartImage);\n    \n    //Cordinates to the image\n    vec2 imageUV = vec2(0.);\n    vec2 delta = vec2(1.);\n    \n    //little image\n    //polarView = toPolar(rotmat(vec3(1., 0., 0.), iTime) * cartView);\n    if(inside(polarView.yz, polarImage.yz, delta))\n        {\n            imageUV = (polarView-polarImage).yz/delta+0.5;\n            fragColor = texture(iChannel0, imageUV);\n        }\n    \n    //background image\n    else\n    {\n        imageUV = polarView.yz/(2.*PI);\n        fragColor = texture(iChannel1, imageUV);\n     }\n\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 238, 275, 275, 680], [682, 682, 703, 703, 1071], [1073, 1205, 1243, 1243, 1636], [1638, 1638, 1666, 1666, 1865], [1867, 1867, 1898, 1898, 2033], [2035, 2069, 2106, 2106, 2223], [2225, 2225, 2280, 2280, 3104]], "test": "untested"}
{"id": "ctsGzl", "name": "Nlights", "author": "Del", "description": "A simple scrolling nebula effect (nlights remix)  https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n", "tags": ["noise", "fbm", "nebula", "blend", "blend"], "likes": 17, "viewed": 404, "published": 3, "date": "1672240666", "time_retrieved": "2024-07-30T16:10:26.585393", "image_code": "// Cheap(ish) scrolling nebula effect (just noise mixing)\n// https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n\n// noise, IQ - https://www.shadertoy.com/view/4sfGzS\n// (somewhat jigged)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n//#define UI3 uvec3(UI0, UI1, 2798796415U)\n//#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat mNoise( in vec2 pos )\n{\n    vec2 q = pos;\n    const mat2 m = mat2( 0.36,  0.80,  -0.80,  0.36 );\n                    \n    float amplitude = 0.5;\n    float f  = amplitude*noise( q );\n    float scale = 2.12;\n    for (int i = 0; i < 5; ++i)\n    {    \n        q = m*q*scale; //q*=scale;\n    \tf += amplitude * noise( q );\n        amplitude *= 0.5;\n    }\n    return f;\n}\n\n\n// voronoi stars - simplified and slightly optimized to use a single texture fetch for the randomness\nvec3 stars(in vec2 pos)\n{\n    vec3 col = vec3(0.0);\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n    vec2 dir = sign(f-0.5);\n    for( float j=0.0; j<=1.0; j+=1.0 )\n    {\n   \t\tfor( float i=0.0; i<=1.0; i+=1.0 )    \n\t    {\n            vec2 cell = vec2(i*dir.x,j*dir.y);\n            vec2 p = (n + cell)+0.5;\n            vec4 rnd1 = texture( iChannel0, p/256.0, -100.0 ).xyzw; // random offset,col,brightness\n            float d = length(cell + rnd1.xy - f);                \n            rnd1.w = max(0.2,rnd1.w);\n            // falloff\n            float dist = max(0.1, 1.0 - d);\n            float starfo = pow(dist, 60.0) * 6.5 + pow(dist, 120.0);\n\t        col += vec3(rnd1.z*0.2) * rnd1.w * starfo;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tvec2 uv = p;\n    \n    float ny = p.y+0.5; // ypos 0-1\n\n    uv.y *= 0.45;\n    uv.x *= 2.95;\n\n\tfloat t = iTime * 0.23;\n    uv.y += t;\n    \n    float fval1 = mNoise(uv);\n    uv.x *= 0.64;\n    \n    float fval = 0.18+(ny*0.15); // 0.13 less fuckage\n    uv.x += 3.5+(fval1*fval); // here, we fuck layer2 with layer1 a touch for a lavalamp style effect\n    uv.y -= t*0.91;\n    float fval2 = mNoise(uv);\n    \n    float cut = 0.4;  \n    fval1 = smoothstep(cut-0.1,1.8,fval1);\n    fval2 = smoothstep(cut,1.8,fval2);\n    fval1 = fval1+fval2;\n\n    // colors (layer1)\n    vec3 col1top = vec3(0.65,1.0,0.5);\n    vec3 col1bot = vec3(1.35,0.6,0.55);\n\n    // colors (layer2)\n    vec3 col2top = vec3(0.5,0.65,1.1);\n    vec3 col2bot = vec3(0.45,0.6,0.7);\n    \n    vec3 col1 = mix(col1bot,col1top,ny)*fval1;\n    vec3 col2 = mix(col2bot,col2top,ny)*fval2;\n    \n    // this blend is calculated with the asspluck constant\n    float blend = 0.5+(sin(fval1*4.25+fval2*1.75)*0.225);\n    vec3 color = mix(col1,col2,blend)*1.61;\n\n    ny = smoothstep(-0.5,1.0,ny);\n    color*=ny;\n\n\n    // test it with a starfield background...\n    color = clamp(color,vec3(0.0),vec3(1.0));\n    float a = smoothstep(0.4,0.0,length(color)); // a = starmask\n    color +=  stars(p*15.0) * a;\n\n\n    // vignetting\t\n   color *= 1.0 - 0.4*dot(p,p);\t\t// vignette\n\n\n\tfragColor = vec4(color.xyz,1.0);\n}\n\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 401, 423, 423, 512], [514, 514, 540, 540, 887], [889, 889, 918, 918, 1259], [1262, 1364, 1389, 1389, 2099], [2101, 2101, 2158, 2158, 3576]], "test": "untested"}
{"id": "mlXGzs", "name": "Infinite Arcs III", "author": "mrange", "description": "CC0: Infinite Arcs III\nCreated to be a windows terminal shader background.\n\n", "tags": ["2d", "arcs"], "likes": 27, "viewed": 512, "published": 3, "date": "1672229355", "time_retrieved": "2024-07-30T16:10:27.330401", "image_code": "// CC0: Infinite Arcs III\n//  Created to be a windows terminal shader background.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(1.25);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 sca(float a) {\n  return vec2(sin(a), cos(a)); \n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat arc(vec2 p, vec2 sc, float ra, float rb) {\n  // sc is the sin/cos of the arc's aperture\n  p.x = abs(p.x);\n  return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                abs(length(p)-ra)) - rb;\n}\n\nfloat forward(float n) {\n  return exp2(ExpBy*n);\n}\n\nfloat reverse(float n) {\n  return log2(n)/ExpBy;\n}\n\nvec2 cell(float n) {\n  float n2  = forward(n);\n  float pn2 = forward(n-1.0);\n  float m   = (n2+pn2)*0.5;\n  float w   = (n2-pn2)*0.5;\n  return vec2(m, w);\n}\n\nvec2 df(vec2 p) {\n  const float w = 2.0/3.0;\n  \n  float tm = 0.5*TIME;\n  float m = fract(tm);\n  float f = floor(tm);\n  float z = forward(m);\n  \n  vec2 p0 = p;\n  p0 /= z;\n\n  float l0 = length(p0);\n  float n0 = ceil(reverse(l0));\n  vec2 c0 = cell(n0); \n  \n  float h0 = hash(n0-f);\n  float h1 = fract(3677.0*h0);\n  float h2 = fract(8677.0*h0);\n  float sh2 = (h2-0.5)*2.0;\n\n  float a = TAU*h2+sqrt(abs(sh2))*sign(sh2)*TIME*TAU/20.0;\n  p0 *= ROT(a);\n  float d0 = arc(p0, sca(PI/4.0+0.5*PI*h1), c0.x, c0.y*w);\n  d0 = abs(d0)-c0.y*0.1;\n  d0 *= z;\n  return vec2(d0, n0-f);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  float dd = length(p);\n  vec2 d2 = df(p);\n  float fi = smoothstep(0.25, 0.5, 10.0*dd);\n  float h = fract(-0.1*dd+0.75+sin(0.25*d2.y)*0.2);\n  vec3 bcol = hsv2rgb(vec3(h, 0.8, fi));\n  \n  vec3 col = bcol*smoothstep(aa, -aa, d2.x);\n  vec3 gcol = HSV2RGB(vec3(0.55, 0.5, 2.0)); \n  col += gcol*mix(1.0, 0.0, tanh(10.0*dd));\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float aa =2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 446, 468, 468, 614], [909, 969, 991, 991, 1039], [1041, 1041, 1060, 1060, 1094], [1096, 1214, 1262, 1307, 1435], [1437, 1437, 1461, 1461, 1487], [1489, 1489, 1513, 1513, 1539], [1541, 1541, 1561, 1561, 1696], [1698, 1698, 1715, 1715, 2264], [2266, 2266, 2296, 2296, 2754], [2756, 2756, 2813, 2813, 3015]], "test": "untested"}
{"id": "mtf3zl", "name": "Palladian Schneekugel", "author": "dr2", "description": "A snow globe in the style of Palladio", "tags": ["snow", "architecture", "globe", "palladio", "palace"], "likes": 31, "viewed": 310, "published": 3, "date": "1672223675", "time_retrieved": "2024-07-30T16:10:28.247948", "image_code": "#define Ck min(IH,0)\n#define XY(x)(sin((x)+vec2(0.5*ZN,0.)))\n#define JX(Ow)if(Bu<Im){Im=Bu; WZ=Ow; Wa=Up;}\nconst int Hn=1,Cg=2,Qh=3,Av=4,DR=5,YK=6,TD=7,IY=8,RS=9,FC=10,Vo=11;const float ZN=3.1415927;vec3 Tm,UX,Wa,Nt,ON,Sj,Cx;vec2 RF[2],LI;float Jt,SA,LZ,ID,Ko,Vb,PU,Tq[2],AQ,Le,GW,My,DV,FT,SE;int IH,WZ;bool Ei,Mu;float GF(vec3 Yc,vec3 Ng){vec3 Bu;Bu=abs(Yc)-Ng;return min(max(Bu.x,max(Bu.y,Bu.z)),0.)+length(max(Bu,0.));}float Nx(vec3 Yc,vec3 Ng,float CS){return length(max(abs(Yc)-Ng,0.))-CS;}float EU(vec2 Yc,vec2 Ng){vec2 Bu;Bu=abs(Yc)-Ng;return min(max(Bu.x,Bu.y),0.)+length(max(Bu,0.));}float LM(vec2 Yc,vec2 Ng,float CS){return length(max(abs(Yc)-Ng,0.))-CS;}float Pi(vec3 Yc,float Bh){return length(Yc)-Bh;}float Kb(vec3 Yc,float Bh,float HE){return max(length(Yc.xy)-Bh,abs(Yc.z)-HE);}float Iq(vec3 Yc,vec2 ZJ,float Bh,float HE){float Bu;Bu=max(dot(vec2(length(Yc.xy)-Bh,Yc.z),ZJ),abs(Yc.z)-HE);HE/=ZJ.x*ZJ.x;Bh/=ZJ.x;Bu=min(Bu,min(length(vec3(Yc.xy,Yc.z+Bh*ZJ.y-HE))-Bh+HE*ZJ.y,length(vec3(Yc.xy,Yc.z+Bh*ZJ.y+HE))-Bh-HE*ZJ.y));return Bu;}float QT(vec3 Yc,float Bu){vec2 Zs;Zs=vec2(1.,-1.)/sqrt(3.);return max(max(dot(Yc,Zs.yxx),dot(Yc,Zs.xyx)),max(dot(Yc,Zs.xxy),dot(Yc,Zs.yyy)))-Bu;}float Yt(vec2 Yc){return min(Yc.x,Yc.y);}float WI(vec3 Yc){return max(Yc.x,max(Yc.y,Yc.z));}float Ae(vec3 Yc){return min(Yc.x,min(Yc.y,Yc.z));}mat3 FX(float Bd,float Fh){vec2 UG,NK,OR;UG=vec2(Bd,Fh);NK=cos(UG);OR=sin(UG);return mat3(NK.y,0.,-OR.y,0.,1.,0.,OR.y,0.,NK.y)*mat3(1.,0.,0.,0.,NK.x,-OR.x,0.,OR.x,NK.x);}vec2 Lv(vec2 Up,float BL){vec2 ZJ;ZJ=sin(BL+vec2(0.5*ZN,0.));return vec2(dot(Up,vec2(ZJ.x,-ZJ.y)),dot(Up.yx,ZJ));}vec2 JK(vec2 Up,vec2 ZJ){return vec2(dot(Up,vec2(ZJ.x,-ZJ.y)),dot(Up.yx,ZJ));}const float Rg=43758.54;float Jp(vec2 Yc){return fract(sin(dot(Yc,vec2(37.,39.)))*Rg);}vec2 La(vec2 Yc){vec2 SR=vec2(37.,39.);return fract(sin(dot(Yc,SR)+vec2(0.,SR.x))*Rg);}vec3 ML(float Yc){return fract(sin(Yc+vec3(37.,39.,41.))*Rg);}float Ks(vec2 Yc){vec2 HI,KJ,JG;KJ=floor(Yc);JG=fract(Yc);JG=JG*JG*(3.-2.*JG);HI=mix(La(KJ),La(KJ+vec2(0.,1.)),JG.y);return mix(HI.x,HI.y,JG.x);}float Gk(vec2 Yc){float Ez,BL;Ez=0.;BL=1.;for(int Of=0;Of<5;Of++){Ez+=BL*Ks(Yc);BL*=0.5;Yc*=2.;}return Ez*(1./1.9375);}float HV(vec3 Yc,vec3 DA){vec3 Ng;float BL;Ng=vec3(0.);BL=1.;for(int Of=0;Of<5;Of++){Ng+=BL*vec3(Ks(Yc.yz),Ks(Yc.zx),Ks(Yc.xy));BL*=0.5;Yc*=2.;}return dot(Ng,abs(DA));}vec3 Az(vec3 Yc,vec3 DA,float Ez){vec4 YO;vec3 HE;vec2 Zs;Zs=vec2(0.1,0.);for(int Of=Ck;Of<=3;Of++)YO[Of]=HV(Yc+((Of<2)?((Of==0)?Zs.xyy:Zs.yxy):((Of==2)?Zs.yyx:Zs.yyy)),DA);HE=YO.xyz-YO.w;return normalize(DA+Ez*(HE-DA*dot(DA,HE)));}float Md(vec3 Yc){vec3 Up,Dj;vec2 Vs;float Im,Bu,Yx,Pe,EQ;Pe=0.48;Im=SA;Dj=Yc;Dj.xz=mix(abs(Dj.xz),abs(Dj.zx),step(abs(Dj.z),abs(Dj.x)));Up=Dj;Up.yz-=vec2(ID,LZ);Yx=abs(abs(Up.x)-2.1)-0.4;Bu=EU(vec2(Up.y,Up.z),vec2(ID,Ko));for(int PQ=0;PQ<2;PQ++)Bu=max(min(Bu,Nx(vec3(Yx,Up.y+Tq[PQ],Up.z),vec3(RF[PQ],Ko),0.03)),-EU(vec2(Yx,Up.y+Tq[PQ]),RF[PQ]));Bu=min(Bu,Nx(vec3(Up.x,Up.y+Pe,Up.z),vec3(Nt.xy*vec2(2.,1.),0.04),0.04));Bu=max(Bu,-EU(vec2(Up.x,Up.y+Pe),Nt.xy*vec2(2.,1.)));JX(Hn);Up=Dj;Up.yz-=vec2(ID-Pe,LZ);Up.x=abs(Up.x);Up.xz-=vec2(0.2,0.01);Up.xz=JK(Up.xz-Nt.xz*vec2(1.,-1.),LI)+Nt.xz*vec2(1.,-1.);Bu=GF(Up,Nt);JX(RS);Up=Dj;Up.yz-=vec2(ID,LZ);Vs=vec2(abs(abs(Yx)-0.5*Vb)-0.5*Vb,abs(abs(Up.y+Tq[0])-0.5*RF[0].y)-0.5*RF[0].y);EQ=length(vec2(Vs.x,Up.z))-PU;Bu=min(max(EQ,abs(Vs.y)-RF[0].y),Kb(vec3(Vs,Up.z).yzx,PU,RF[0].x));JX(IY);Vs.y=abs(Up.y+Tq[1])-RF[1].y;Bu=min(max(EQ,abs(Vs.y)-RF[1].y),Kb(vec3(Vs,Up.z).yzx,PU,RF[1].x));JX(IY);Up=Dj;Up.yz-=vec2(2.8,LZ);Bu=max(abs(dot(vec2(Up.y,-Up.z),XY(-0.1*ZN)))-0.02,Up.z-Ko);Bu=max(Bu,1.-length(Yc.xz));JX(Cg);Up=Yc;Up.y-=3.;Bu=max(abs(length(vec3(Up.xz,max(Up.y,0.8)).xzy)-1.28)-0.02,0.3-Up.y);Bu=max(Bu,0.1-length(vec2(Dj.x,Up.y-0.63)));JX(Qh);Up=Yc;Up.y=abs(Up.y-0.2)-0.18;Bu=Nx(Up,vec3(LZ+Ko,0.,LZ+Ko),0.02);Up=Yc;Up.y=abs(Up.y-2.23)-0.55;Bu=min(Bu,Nx(Up,vec3(LZ+Ko,0.,LZ+Ko),0.02));JX(TD);Up=Dj;Up.yz-=vec2(0.9,LZ+0.5);Bu=EU(Up.xz,vec2(1.3,0.5));Up.y-=1.65;Vs.y=dot(Up.yx,XY(0.1*ZN));Bu=max(Bu,max(max(Vs.y,-0.45-Up.y),-max(max(Vs.y+0.06,-0.39-Up.y),0.42-Up.z)));Bu=max(Bu,-Kb(Up-vec3(0.,-0.25,0.47),0.08,0.1));JX(Av);Up=Dj;Vs=Up.yz-2.1;Vs=20.*vec2(Vs.x+Vs.y,-Vs.x+Vs.y)/sqrt(2.);Bu=(1./20.)*(Vs.x-abs(0.5-abs(0.5-fract(Vs.y/sqrt(2.))))*sqrt(2.));Bu=0.5*max(Bu,max(max(abs(Up.x)-1.3,abs(Up.y-0.2)-0.2),LZ-Up.z));JX(DR);Up=Dj;Up.yz-=vec2(1.25,LZ+0.6);Bu=1.3-abs(Up.x);Up.x=(fract(2.2*Up.x)-0.5)/2.2;Bu=max(min(Kb(Up.xzy,0.06,0.85),GF(vec3(Up.x,abs(Up.y)-0.83,Up.z),vec3(0.08,0.02,0.08))),-Bu);JX(YK);Up=Dj;Up.x=abs(Up.x);Up-=vec3(2.7,0.15,LZ+2.5);Bu=LM(vec2(length(Up.xz)-0.55,Up.y),vec2(0.15,0.2)-0.1,0.1);JX(FC);Up.y-=1.25;Bu=Iq(Up.xzy,XY(0.03*ZN),0.15,1.1);JX(FC);Up=Dj;Up.x=abs(Up.x);Up-=vec3(1.45,0.2,LZ+3.1);Bu=Nx(Up,vec3(0.15,0.25,1.6)-0.1,0.1);JX(FC);Up=Yc;Up.xz=Lv(Up.xz,2.*ZN*(floor(32.*atan(Up.z,-Up.x)/(2.*ZN)+0.5))/32.);Up.xy-=vec2(-8.5,1.);Bu=Iq(Up.xzy,XY(0.04*ZN),0.15,0.75);Bu=max(Bu,1.3-abs(Dj.x));JX(FC);Up=Yc;Up.y-=-0.51;Bu=Kb(Up.xzy,AQ,0.51);JX(Vo);return Im;}float Pz(vec3 Go,vec3 CS){float GB,Bu;GB=0.;for(int Of=Ck;Of<120;Of++){Bu=Md(Go+GB*CS);if(Bu<0.0005||GB>SA)break;GB+=Bu;}return GB;}vec3 NO(vec3 Yc){vec4 YO;vec2 Zs;Zs=2e-4*vec2(1.,-1.);for(int Of=Ck;Of<=3;Of++){YO[Of]=Md(Yc+((Of<2)?((Of==0)?Zs.xxx:Zs.xyy):((Of==2)?Zs.yxy:Zs.yyx)));}YO.x=-YO.x;return normalize(2.*YO.yzw-dot(YO,vec4(1.)));}float Rk(vec3 Go,vec3 CS){float Sn,Bu,HE;Sn=1.;Bu=0.02;for(int Of=Ck;Of<40;Of++){HE=Md(Go+Bu*CS);Sn=min(Sn,smoothstep(0.,0.05*Bu,HE));Bu+=HE;if(Sn<0.05)break;}return Mu?0.7+0.3*Sn:0.5+0.5*Sn;}float VF(vec3 Yc){vec3 Up;float Bu;Bu=SA/FT;if(Ei){Yc-=Sj;Yc/=FT;Yc.yz=JK(Yc.yz,XY(Cx.x));Yc.xz=JK(Yc.xz,XY(Cx.y));Yc.xy=JK(Yc.xy,XY(Cx.z));for(float PQ=-1.;PQ<=1.;PQ+=2.){Up=Yc;Up.y*=PQ;Up.xz=JK(Up.xz,XY(-PQ*ZN/6.));Up.xy=JK(Up.xy,XY(ZN/2.-0.5*acos(1./3.)));Up.xz=JK(Up.xz,XY(ZN/4.));Bu=min(Bu,QT(Up,0.04));}}return FT*Bu;}void AM(vec3 Yc){vec3 KN,Up;KN=ML(dot(ON,vec3(31.1,41.1,51.1))+99.);Ei=(length(ON.xz+0.5)<AQ&&length(KN)<sqrt(3.)*SE);if(Ei){Up=ON+0.5;Sj=Up+0.3*cos((1.+KN)*Jt+KN.zxy);Cx=2.*(KN-0.5)*Jt;Up.y=floor(Up.y-DV);FT=0.001+0.999*smoothstep(0.,0.1*AQ,min(AQ-length(Up),Yc.y));}}vec3 TU(vec3 Yc){ON.xz=floor(Yc.xz);DV=My*Jt*(1.+Jp(ON.xz));Yc.y+=DV;ON.y=floor(Yc.y);return Yc;}\nfloat Zb(vec3 Go,vec3 CS){vec3 Yc,By,Qy,ED;float GB,Bu,CO;CO=0.001;if(CS.x==0.)CS.x=0.001;if(CS.y==0.)CS.y=0.001;if(CS.z==0.)CS.z=0.001;ED=1./CS;Qy=vec3(-999.);GB=CO;for(int Of=Ck;Of<160;Of++){By=Go+GB*CS;Yc=TU(By);if(ON!=Qy){AM(By);Qy=ON;}Bu=((length(floor(By+0.5))-1.)<AQ)?VF(Yc):SA;Bu=min(Bu,abs(Ae((ON+step(0.,CS)-Yc)*ED))+CO);GB+=Bu;if(Bu<CO||GB>SA)break;}if(Bu>=CO)GB=SA;return GB;}vec3 Xq(vec3 Yc){vec4 YO;vec2 Zs;Zs=2e-4*vec2(1.,-1.);for(int Of=Ck;Of<=3;Of++){YO[Of]=VF(Yc+((Of<2)?((Of==0)?Zs.xxx:Zs.xyy):((Of==2)?Zs.yxy:Zs.yyx)));}YO.x=-YO.x;return normalize(2.*YO.yzw-dot(YO,vec4(1.)));}float Ql(vec3 Yc){vec3 Up,Dj;float Im,Bu,Yx;Im=SA;Dj=Yc;Dj.xz=mix(abs(Dj.xz),abs(Dj.zx),step(abs(Dj.z),abs(Dj.x)));Up=Dj;Up.yz-=vec2(ID,LZ);Yx=abs(abs(Up.x)-2.1)-0.4;Bu=Im;for(int PQ=0;PQ<2;PQ++)Bu=min(Bu,EU(vec2(Yx,Up.y+Tq[PQ]),RF[PQ]));Bu=max(Bu,abs(Up.z)-PU+0.004);JX(0);Up=Yc;Bu=max(abs(length(Up.xz)-1.)-0.02,length(vec2(Dj.x,Up.y-3.63))-0.1);JX(0);return Im;}float TH(vec3 Go,vec3 CS){float GB,Bu;GB=0.;for(int Of=Ck;Of<50;Of++){Bu=Ql(Go+GB*CS);if(Bu<0.0005||GB>SA)break;GB+=Bu;}return GB;}vec3 RW(vec3 Yc){vec4 YO;vec2 Zs;Zs=2e-4*vec2(1.,-1.);for(int Of=Ck;Of<=3;Of++){YO[Of]=Ql(Yc+((Of<2)?((Of==0)?Zs.xxx:Zs.xyy):((Of==2)?Zs.yxy:Zs.yyx)));}YO.x=-YO.x;return normalize(2.*YO.yzw-dot(YO,vec4(1.)));}vec4 Zf(vec3 Go,vec3 CS,float Zw){vec3 Hr;float GS,Bu,WM;GS=dot(CS,Go);WM=GS*GS+Zw*Zw-dot(Go,Go);Bu=SA;if(WM>0.){Bu=-GS-sqrt(WM);Hr=(Go+Bu*CS)/Zw;}return vec4(Bu,Hr);}vec3 Em(vec3 CS,float QC){vec3 OA,XL,Vs;vec2 Up;float Ez;OA=-1./max(abs(CS),0.0001);XL=-sign(CS)*step(OA.zxy,OA)*step(OA.yzx,OA);Vs=WI(OA)*CS;Up=atan(vec2(dot(Vs.zxy,XL),dot(Vs.yzx,XL)),vec2(1.))/ZN;Ez=0.57*(Gk(11.*dot(0.5*(XL+1.),vec3(1.,2.,4.))+131.13*QC*Up)+Gk(13.*dot(0.5*(XL+1.),vec3(1.,2.,4.))+171.13*QC*Up.yx));return 4.*vec3(1.,1.,0.8)*pow(Ez,16.);}vec3 VJ(vec3 CS){vec3 UC;if(Mu)UC=vec3(0.,0.,0.05)+Em(CS,8.);else{CS.y=abs(CS.y);UC=mix(vec3(0.3,0.35,0.7),vec3(0.8,0.8,0.8),clamp(2.*(Gk(2.*CS.xz/CS.y+0.1*Jt)-0.1)*CS.y,0.,1.));}return UC;}vec3 TY(vec3 Go,vec3 CS){vec4 Wn,Df;vec3 UC,Hr,HZ,Jc;vec2 FG,Vs;float VW,XH,Ul,QP,Xu,Sn,HI;bool Wr;LZ=3.;ID=1.4;Ko=0.05;PU=0.012;Vb=0.18;RF[0]=vec2(Vb,0.45);RF[1]=vec2(Vb,0.2);Tq[0]=0.35;Tq[1]=-0.95;Nt=vec3(0.2,0.55,0.02);LI=XY(-0.5*ZN*clamp(-0.3+1.6*abs(2.*fract(0.25*Jt)-1.),0.,1.)*(1.-smoothstep(0.01,0.1,SE)));Wr=true;HZ=Go;VW=Pz(Go,CS);if(VW<SA){Go+=VW*CS;Hr=NO(Go);FG=vec2(0.);if(WZ==Hn){if(Wa.z<0.){Wn=vec4(0.7,0.7,0.75,0.05);Wr=false;}else{Wn=vec4(0.9,0.9,0.5,0.02);if(abs(Wa.z-0.05)<0.002){Vs=Wa.xy*vec2(1./6.,1.)*16.;if(abs(Hr.x)<abs(Hr.z))Vs.x+=0.5;HI=Vs.x+1./3.+((fract(0.5*Vs.y)<0.5)?0.:0.5);Wn*=0.8+0.2*smoothstep(0.12,0.15,min(fract(Vs.y),6.*min(fract(HI),fract(HI+2./3.))));FG=vec2(64.,1.);}}}else if(WZ==Cg){Wn=vec4(1.,0.5,0.,0.1)*(0.8+0.2*smoothstep(0.08,0.1,fract(8.*Wa.z)));FG=vec2(64.,0.1);}else if(WZ==Qh){if(Wa.y>0.8){Wn=vec4(0.95,1.,0.95,0.05)*(0.9+0.1*smoothstep(0.08,0.1,fract(8.*length(Wa.xz)+0.5)));}else{Wn=vec4(0.9,0.9,0.5,0.1);FG=vec2(64.,0.5);}}else if(WZ==TD){if(max(abs(Wa.x),abs(Wa.z))>LZ){Wn=vec4(0.7,0.7,0.4,0.1);}else{Wn=(Hr.y>0.)?vec4(0.7,0.4,0.2,0.05):vec4(1.,1.,1.,0.05);Wr=false;}}else if(WZ==Av){Wn=vec4(0.8,0.8,0.7,0.1);FG=vec2(64.,0.5);}else if(WZ==DR){Wn=vec4(0.8,0.8,0.7,0.1);FG=vec2(64.,0.5);}else if(WZ==YK){Wn=vec4(0.8,0.7,0.7,0.1);if(abs(Wa.y)<0.81)Wn*=(0.8+0.2*smoothstep(0.06,0.08,fract(4.9*Wa.y)))*(1.-0.3*smoothstep(0.15,0.17,fract(16.*atan(Wa.z,Wa.x)/(2.*ZN)+0.5)));else FG=vec2(64.,0.5);}else if(WZ==IY){Wn=vec4(0.2,0.4,0.2,0.2);Wr=false;}else if(WZ==RS){Wn=vec4(0.7,0.3,0.1,0.1);Wn*=1.-0.5*smoothstep(0.01,0.012,EU(Wa.xy,Nt.xy-0.05));Wr=false;}else if(WZ==FC){Wn=vec4(0.,0.5,0.,0.);FG=vec2(16.,8.);}else if(WZ==Vo){if(Wa.y>0.5){if(Yt(abs(Wa.xz))<1.4||length(Wa.xz)<sqrt(2.)*LZ+0.5){Wn=vec4(0.8,0.8,0.6,0.1);FG=vec2(16.,0.2);}else{Wn=vec4(0.,0.8,0.,0.05);if(Hr.y>0.1)FG=vec2(8.,0.5);}}else{Wn=vec4(0.6,0.3,0.,0.1)*(0.8+0.2*sin(16.*ZN*Wa.y));}Wn.rgb*=0.7;}Xu=smoothstep(0.15,0.35,Le-0.15*Gk(2.*Go.xz+mod(GW,16.)))-smoothstep(0.8,0.95,Le);if(FG.y>0.){if(Xu>0.&&Wr&&Hr.y>0.01)FG=vec2(min(FG.x,16.),max(FG.y,0.2));Hr=Az(FG.x*Go,Hr,FG.y);}if(Xu>0.&&Wr&&Hr.y>0.01)Wn=mix(Wn,vec4(0.95,0.95,1.,0.1),Xu);Sn=Rk(Go+0.01*Hr,Tm);UC=Wn.rgb*(0.3+0.7*Sn*max(dot(Hr,Tm),0.))+Wn.a*step(0.95,Sn)*pow(max(dot(Tm,reflect(CS,Hr)),0.),32.);}else{UC=VJ(CS);}Go=HZ;XH=TH(Go,CS);if(XH<min(VW,SA)){Go+=XH*CS;Hr=RW(Go);UC=Mu?vec3(1.,0.7,0.2)*(0.2+0.6*max(-dot(Hr,CS),0.)):mix(UC,VJ(reflect(CS,Hr)),0.3+0.7*pow(1.-abs(dot(Hr,CS)),5.));}Go=HZ;Df=Zf(Go,CS,AQ);QP=Df.x;Jc=Df.yzw;if(QP<SA){Go+=QP*CS;Ul=Zb(Go,CS);if(Ul<min(VW,SA)){Hr=Xq(TU(Go+Ul*CS));UC=vec3(1.)*(0.2+0.8*max(-dot(CS,Hr),0.));}HI=0.;if(Go.y>0.)HI=0.02+0.05*max(dot(UX,Jc),0.)+0.25*pow(max(dot(reflect(UX,Jc),CS),0.),64.);if(Mu)HI*=2.;UC+=HI*vec3(1.);}return clamp(UC,0.,1.);}void mainImage(out vec4 Lr,in vec2 Nc){mat3 Oj;vec4 BP;vec3 Go,CS,UC;vec2 Pv,Xd;float Bd,Fh,Ai,Dw,CB,MP,HI;\nIH=iFrame;Pv=iResolution.xy;Xd=2.*Nc.xy/Pv-1.;Xd.x*=Pv.x/Pv.y;Jt=iTime;BP=iMouse;BP.xy=BP.xy/Pv-0.5;\nDw=Pv.x/Pv.y;Fh=0.;Bd=-0.1*ZN;if(BP.z>0.){Fh+=2.*ZN*BP.x;Bd+=0.5*ZN*BP.y;}else{HI=mod(0.007*Jt,2.);Fh=2.*ZN*(abs((floor(12.*HI)+smoothstep(0.8,1.,fract(12.*HI)))/12.-1.));}Bd=clamp(Bd,-0.25*ZN,-0.02*ZN);Oj=FX(Bd,Fh);AQ=10.;My=0.05*AQ;Go=Oj*vec3(0.,2.,-5.*AQ);Ai=4.5+1.2*abs(mod(Fh+ZN,2.*ZN)-ZN);SA=length(Go)+AQ;MP=25.;GW=floor(Jt/MP);Le=fract(Jt/MP);SE=smoothstep(0.05,0.5,Le)-smoothstep(0.65,0.8,Le);Mu=false;Tm=Oj*normalize(vec3(1.,1.,-1.));UX=Oj*normalize(vec3(0.6,1.,-0.03));const float Fl=3.;UC=vec3(0.);CB=2.*mod(dot(mod(floor(0.5*(Xd+1.)*Pv),2.),vec2(1.)),2.)-1.;for(float BL=float(Ck);BL<Fl;BL++){CS=Oj*normalize(vec3(Xd+step(1.5,Fl)*Lv(vec2(0.5/Pv.y,0.),CB*(0.667*BL+0.5)*ZN),Ai));UC+=(1./Fl)*TY(Go,CS);}Lr=vec4(UC,1.);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtf3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 340, 340, 422], [422, 422, 457, 457, 495], [495, 495, 521, 521, 593], [593, 593, 628, 628, 666], [666, 666, 693, 693, 715], [715, 715, 751, 751, 794], [794, 794, 838, 838, 1048], [1048, 1048, 1075, 1075, 1194], [1194, 1194, 1212, 1212, 1235], [1235, 1235, 1253, 1253, 1286], [1286, 1286, 1304, 1304, 1337], [1337, 1337, 1364, 1364, 1507], [1507, 1507, 1533, 1533, 1621], [1621, 1621, 1646, 1646, 1699], [1723, 1723, 1741, 1741, 1786], [1786, 1786, 1803, 1803, 1873], [1873, 1873, 1891, 1891, 1935], [1935, 1935, 1953, 1953, 2080], [2080, 2080, 2098, 2098, 2199], [2199, 2199, 2225, 2225, 2367], [2367, 2367, 2401, 2401, 2599], [2599, 2599, 2617, 2617, 5028], [5028, 5028, 5054, 5054, 5160], [5160, 5160, 5177, 5177, 5369], [5369, 5369, 5395, 5395, 5561], [5561, 5561, 5579, 5579, 5885], [5885, 5885, 5902, 5902, 6154], [6154, 6154, 6171, 6171, 6251], [6252, 6252, 6278, 6278, 6640], [6640, 6640, 6657, 6657, 6849], [6849, 6849, 6867, 6867, 7214], [7214, 7214, 7240, 7240, 7345], [7345, 7345, 7362, 7362, 7554], [7554, 7554, 7588, 7588, 7721], [7721, 7721, 7747, 7747, 8078], [8078, 8078, 8095, 8095, 8268], [8268, 8268, 8293, 8293, 11034], [11034, 11034, 11073, 11073, 11973]], "test": "untested"}
{"id": "dlXGzl", "name": "You and what army?", "author": "MysteryPancake", "description": "He finally brought the army :) Click and drag to move camera", "tags": ["mirror", "clone", "redgiant", "aftereffects", "hallofmirrors", "plugin", "army"], "likes": 73, "viewed": 767, "published": 3, "date": "1672222603", "time_retrieved": "2024-07-30T16:10:28.993953", "image_code": "// Modification of https://www.shadertoy.com/view/dsSGWm\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Number of images to display\n\tint images = 128;\n\t// Scale factor per image\n\tfloat scale = 0.96;\n\t\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tfragColor = vec4(0.0);\n\t\n\t// View angle\n\tfloat camAngle = iMouse.z > 0.0 ? 1.5 - 2.0 * m.y : 0.6 - sin(iTime) * 0.5;\n\t\n\tfor (int i = 0; i < images; ++i) {\n\t\t// Different heights for variety\n        float height = cos(float(i) + iTime) * 0.1;\n        \n        // Offset, apply scale, reset offset\n\t\tvec2 offset = vec2(i, 0.5 + 0.5 * camAngle);\n\t\tvec2 pos = uv - offset;\n\t\tpos /= pow(scale, float(i));\n\t\tvec2 camPos = vec2(iMouse.z > 0.0 ? -m.x : iTime * 0.5, camAngle + height);\n\t\tpos += offset + camPos;\n\t\t\n\t\t// Clamp bottom and discard top\n\t\tif (pos.y >= 0.995) continue;\n\t\tpos.y = max(pos.y, 0.005);\n        \n\t\t// Flip every 2nd one for variety\n\t\tif (i % 2 == 1) pos.x *= -1.0;\n        \n        // Below is required if the wrap mode isn't repeat\n        pos.x = fract(pos.x);\n\t\t\n\t\t// Color key (despill from Inigo Quilez)\n\t\tvec4 color = texture(iChannel0, pos);\n\t\tfloat rbMax = max(color.r, color.b);\n        float og = color.g; \n        color.g = min(color.g, rbMax * 0.85); \n        color += og - color.g;\n        color.a = 1.0 - clamp((og - rbMax) * 4.0, 0.0, 1.0);\n\n\t\t// Brightness variation for variety\n\t\tcolor.rgb -= 0.3 - cos(float(i * 4)) * 0.1;\n\t\t\n\t\t// Tint towards white\n\t\tfloat fog = sqrt(float(i) / float(images));\n\t\tcolor.rgb = mix(color.rgb, vec3(1.0), fog);\n\t\t\n\t\t// Premultiply color\n\t\tcolor.rgb *= color.a;\n\t\t// Composite behind\n\t\tfragColor += (1.0 - fragColor.a) * color;\n\t\t\n\t\t// Early exit\n\t\tif (fragColor.a >= 1.0) return;\n\t}\n\t\n\t// Make background white\n\tfragColor += vec4(1.0 - fragColor.a);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 113, 146, 1809]], "test": "untested"}
{"id": "mlf3Rl", "name": "Infinite Arcs II", "author": "mrange", "description": "CC0: Infinite Arcs II\nRethinking a bit on how do the infinite \"zoom\". \nIf I expotential zoom then it becomes scale invariant\nwhich ended up quite useful\n Potentially useful for future raymarchers.\n", "tags": ["2d", "infinite", "arcs"], "likes": 22, "viewed": 337, "published": 3, "date": "1672218310", "time_retrieved": "2024-07-30T16:10:29.736966", "image_code": "// CC0: Infinite Arcs II\n//  Rethinking a bit on how do the infinite \"zoom\". \n//  If I expotential zoom then it becomes scale invariant\n//  which ended up quite useful\n//  Potentially useful for future raymarchers.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(1.2);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 sca(float a) {\n  return vec2(sin(a), cos(a)); \n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat arc(vec2 p, vec2 sc, float ra, float rb) {\n  // sc is the sin/cos of the arc's aperture\n  p.x = abs(p.x);\n  return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat forward(float n) {\n  return exp2(ExpBy*n);\n}\n\nfloat reverse(float n) {\n  return log2(n)/ExpBy;\n}\n\nvec2 cell(float n) {\n  float n2  = forward(n);\n  float pn2 = forward(n-1.0);\n  float m   = (n2+pn2)*0.5;\n  float w   = (n2-pn2)*0.5;\n  return vec2(m, w);\n}\n\nvec2 df(vec2 p) {\n  const float w = 2.0/3.0;\n  \n  float tm = TIME;\n  float m = fract(tm);\n  float f = floor(tm);\n  float z = forward(m);\n  \n  vec2 p0 = p;\n  p0 /= z;\n\n  float l0 = length(p0);\n  float n0 = ceil(reverse(l0));\n  vec2 c0 = cell(n0); \n  \n  float h0 = hash(n0-f);\n  float h1 = fract(3677.0*h0);\n  float h2 = fract(8677.0*h0);\n  float sh2 = (h2-0.5)*2.0;\n\n  float a = TAU*h2+sqrt(abs(sh2))*sign(sh2)*TIME*TAU/20.0;\n  p0 *= ROT(a);\n  float d0 = arc(p0, sca(PI/4.0+0.5*PI*h1), c0.x, c0.y*w);\n  d0 *= z;\n  return vec2(d0, h0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 d2 = df(p);\n\n  vec3 col = vec3(0.0);\n  vec3 bcol = hsv2rgb(vec3(d2.y, 0.9, smoothstep(10.0*aa, 20.0*aa, length(p))));\n  col = mix(col, bcol, smoothstep(aa, -aa, d2.x));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlf3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[578, 578, 600, 600, 746], [1041, 1101, 1123, 1123, 1171], [1173, 1173, 1192, 1192, 1226], [1228, 1346, 1394, 1439, 1569], [1571, 1571, 1595, 1595, 1621], [1623, 1623, 1647, 1647, 1673], [1675, 1675, 1695, 1695, 1830], [1832, 1832, 1849, 1849, 2367], [2369, 2369, 2424, 2424, 2779]], "test": "untested"}
{"id": "ctf3zs", "name": "Sobel by Mellos", "author": "mellos", "description": "Sobel", "tags": ["sobel"], "likes": 1, "viewed": 200, "published": 3, "date": "1672217298", "time_retrieved": "2024-07-30T16:10:30.476988", "image_code": "\nfloat pi = 3.1415;\nfloat Thickness = 0.0;\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec3 GetmainImage(in vec2 fragCoord)\n{  \n    vec2 p = fragCoord.xy;\n    return texture(iChannel0, p / iResolution.xy).xyz;\n}\n\nvec3 samplef(const int x, const int y, in vec2 fragCoord)\n{\n\treturn GetmainImage(fragCoord + vec2(x, y));\n}\n\n// Sobel Kernel - Horizontal\n// -1 -2 -1\n//  0  0  0\n//  1  2  1\n\n// Sobel Kernel - Horizontal\n// -1  0  1\n// -2  0  2\n// -1  0  1\n\nfloat Sobel(in vec2 fragCoord)\n{\n\tfloat hc =\n    (samplef(-1,-1, fragCoord) *  1. +\n    samplef( 0,-1, fragCoord) *  2. +\n    samplef( 1,-1, fragCoord) *  1. +\n    samplef(-1, 1, fragCoord) * -1. +\n    samplef( 0, 1, fragCoord) * -2. + \n    samplef( 1, 1, fragCoord) * -1.).x;\t\t\n\n    float vc =\n    (samplef(-1,-1, fragCoord) *  -1. +\n    samplef(-1, 0, fragCoord) *  -2. +\n    samplef(-1, 1, fragCoord) *  -1. +\n    samplef( 1,-1, fragCoord) * 1. +\n    samplef( 1, 0, fragCoord) * 2. +\n    samplef( 1, 1, fragCoord) * 1.).x;\n    \n    if (hc < 0.f)\n        hc = -hc;\n    if (vc < 0.f)\n        vc = -vc;  \n        \n    float ret = hc + vc;\n    ret = clamp(ret, 0.f, 1.f);\n        \n\treturn ret;\n}\n\n#define NORMAL 1\n#define EDGE_ONLY 2\n#define EDGE_WITH_SOURCE 3\n\nint STATUS = EDGE_WITH_SOURCE;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 edgeColor = vec3(1., 0.0, 0.0);\n\n    if (STATUS == 1)\n    {\n        vec3 r = GetmainImage(fragCoord);\n        fragColor = vec4(r, 0.f);\n    }\n    else if (STATUS == 2)\n    {\n        float edge = Sobel(fragCoord);\n        fragColor = vec4(edgeColor * edge, 0.f);\n    }\n    else if (STATUS == 3)\n    {\n        vec3 r = GetmainImage(fragCoord);\n        float dege = Sobel(fragCoord);\n        fragColor = vec4(r + dege * edgeColor, 0.);\n    }\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctf3zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 93, 93, 236], [238, 238, 276, 276, 362], [364, 364, 423, 423, 471], [605, 605, 637, 637, 1299], [1398, 1398, 1455, 1455, 1905]], "test": "untested"}
{"id": "dtfGRl", "name": "Hall of Claude 2", "author": "MysteryPancake", "description": "Modified from my \"Hall of Mirrors\" shader (shadertoy.com/view/dsSGWm). Click to drag offset position :)", "tags": ["mirror", "redgiant", "aftereffects", "hallofmirrors", "plugin", "obsolete"], "likes": 9, "viewed": 308, "published": 3, "date": "1672217104", "time_retrieved": "2024-07-30T16:10:31.216012", "image_code": "// Modification of https://www.shadertoy.com/view/dsSGWm\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Number of images to display\n\tint images = 96;\n\t// Scale factor per image\n\tfloat scale = 0.9 + cos(iTime) * 0.05;\n\t// Rotation per image in degrees\n\tfloat rotation = sin(iTime * 0.25) * 45.0;\n\t// Position offset per image in normalized coordinates (0-1)\n\tvec2 offset = iMouse.z > 0.0 ? vec2(iMouse.xy / iResolution.xy) : 0.5 + vec2(cos(iTime), sin(iTime)) * 0.25;\n\n\tfloat rad = radians(-rotation);\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(0.0);\n    \n\tfor (int i = 0; i < images; ++i) {\n\t\t// SCALING: Offset, apply scale, reset offset\n\t\tvec2 pos = uv - offset;\n\t\tpos /= pow(scale, float(i));\n\t\tpos += offset;\n\n\t\t// ROTATION\n\t\tfloat theta = rad * float(i);\n\t\tfloat cs = cos(theta);\n\t\tfloat sn = sin(theta);\n\t\t// Offset to center, fix aspect ratio\n\t\tpos -= vec2(0.5);\n\t\tpos *= iResolution.xy;\n\t\t// Rotate coordinate space\n\t\tpos = vec2(pos.x * cs - pos.y * sn, pos.x * sn + pos.y * cs);\n\t\t// Reset aspect ratio, reset offset\n\t\tpos /= iResolution.xy;\n\t\tpos += vec2(0.5);\n        \n        // Below is required if the wrap mode isn't repeat\n        pos = fract(pos);\n\n\t\t// Color key\n        vec4 color = texture(iChannel0, pos);\n        color.a = smoothstep(0.5, 0.8, distance(color.rgb, vec3(0.0, 1.0, 0.0)));\n        // Tint towards red/yellow\n        color.rgb += vec3(float(i * 4) / float(images), float(i) / float(images), 0.0);\n        // Premultiply color\n        color.rgb *= color.a;\n        // Composite behind\n        fragColor += (1.0 - fragColor.a) * color;\n        // Early exit\n        if (fragColor.a >= 1.0) return;\n\t}\n    \n    // Make background yellow\n    fragColor += (1.0 - fragColor.a) * vec4(1.0, 1.0, 0.0, 1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 113, 146, 1764]], "test": "untested"}
{"id": "clfGRs", "name": "power 1000w nor map texture ver", "author": "chenxianming", "description": "output the video for tiktok clips.", "tags": ["raymarching", "fbm", "cineshader"], "likes": 3, "viewed": 1990, "published": 3, "date": "1672208611", "time_retrieved": "2024-07-30T16:10:31.963015", "image_code": "\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nfloat noise( in vec2 p) {\n    return sin(p.x) * sin(p.y);\n}\n\nfloat fbm4(vec2 p) {\n    float f = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        f += 1.5 * .1 * noise(p * i);\n        p = m * p * abs(i - 2.) * 2.3;\n    }\n\n    return f / 0.99999990;\n}\n\nvec2 fbm4_2(vec2 p) {\n    return vec2(fbm4(p), fbm4(p + vec2(7.8)));\n}\n\n\nfloat myNoise( in vec2 f ){\n  f *= m;\n  return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\nmat2 rot( float d ){\nfloat s = sin(d), c = cos(d);\nreturn mat2(c, s, -s, c);\n}\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        x *= rot( float( i ) );\n        float a = pow( f, -H );\n        a = smoothstep( 0., .05, a );\n        \n        t += a*myNoise(f*x * rot( float(i) ));\n\n    }\n    return t;\n}\n\nfloat coreCalc(vec3 pos, int i) {\n\n    vec3 p = pos;\n\n    p.xz *= rotation(3.1415926 * iTime * .1 * float(i) + float(i));\n\n    float d = length(p) - .5 + (fbm4_2(p.yz - iTime * .2).y * 1.5 * fbm4_2(p.xz- iTime * .2).x * 1. * cos(p).y * 1.) * .6;\n\n    return d;\n}\n\nfloat map(vec3 pos) {\n\n    vec3 p = pos;\n\n    float d = coreCalc(p, 1);\n\n    float bg = length(pos) - .1;\n\n    d = mix(d, .05, bg);\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n\n\n    // Time varying pixel color\n    float tt = iTime * .4;\n\n    uv = (uv - .5) * 2.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n\n    vec3 origin = vec3(cos(tt) * -1.2, 0.0, sin(tt) * -1.2);\n    vec3 ta = vec3(0.0, 0., 0.0);\n\n    origin = vec3(0., 0., -1.);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = origin + ray * t;\n        float distance = map(p);\n        t += distance * 0.9999;\n    }\n\n    vec3 col = vec3(0.0);\n    vec3 lig = normalize(vec3(.57703));\n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n            \n        \n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n        float p = fbm( vec2( fbm( nor.xy * .5 - iTime * .01, 1. ) ), .9 );\n        \n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        col = spe + vec3( p * .08 + .1 ) * amb + vec3(.6) * dif + vec3(.3);\n    }\n\n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 91], [135, 135, 160, 160, 194], [196, 196, 216, 216, 386], [388, 388, 409, 409, 458], [461, 461, 488, 488, 568], [570, 570, 590, 590, 648], [650, 650, 686, 686, 965], [967, 967, 1000, 1000, 1229], [1231, 1231, 1252, 1252, 1379], [1381, 1427, 1458, 1458, 1706], [1707, 1707, 1762, 1812, 3332]], "test": "untested"}
{"id": "DlXGRs", "name": "Bootleg Clouds SDF", "author": "MysteryPancake", "description": "Using an invalid SDF to ensure the raymarcher never converges results in clouds :)", "tags": ["3d", "raymarching", "raymarch", "sdf", "clouds", "cloud", "bootleg"], "likes": 12, "viewed": 262, "published": 3, "date": "1672207063", "time_retrieved": "2024-07-30T16:10:32.716999", "image_code": "// From https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\n// Invalid SDF, distance never reaches 0\nfloat map(vec3 p, float r) {\n    float d = 8.0;\n    // 6 grids of overlapping circles\n    for (float i = 0.0; i < 6.0; i++) {\n        vec3 offset = vec3(i * 4.2, i * 0.5, i * 3.4);\n        float grid = length(mod(p + offset, 6.0) - 3.0);\n        // Negative radius, ensures no convergence\n        d = min(grid + r, d);\n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 q = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    const float fov = 1.0;\n    vec3 ro = vec3(iTime * 8.0, 0.0, 0.0);\n    mat3 ca = setCamera(ro, vec3(-1.0, 0.0, 0.0), 0.0);\n    vec3 rd = ca * normalize(vec3(q, fov));\n    \n    // Animate radius over time\n    float radius = -cos(iTime) + 2.0;\n\n    // Raymarching with only 8 iterations produces clouds\n    float dist = 1.0;\n    for (int i = 0; i < 8; i++) {\n        // Don't bother checking for convergence\n        dist += map(ro + rd * dist, radius);\n    }\n    float light = 12.0 + radius * 6.0;\n    float shade = pow(light / dist, 2.0);\n    fragColor = vec4(0.0, shade * light / dist, shade, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 96, 96, 260], [262, 303, 331, 331, 643], [645, 645, 700, 700, 1378]], "test": "untested"}
{"id": "clX3zl", "name": "CosmicWaterfall", "author": "Del", "description": "scrolling nebula effect - waterfall remix\nhttps://store.steampowered.com/app/1751970/A_Blast_From_The_Past/", "tags": ["noise", "fbm", "blend"], "likes": 15, "viewed": 452, "published": 3, "date": "1672205272", "time_retrieved": "2024-07-30T16:10:33.510876", "image_code": "// Cheap(ish) scrolling nebula effect (just noise mixing)\n// https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n\n// noise, IQ - https://www.shadertoy.com/view/4sfGzS\n// (somewhat jigged)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n//#define UI3 uvec3(UI0, UI1, 2798796415U)\n//#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat mNoise( in vec2 pos )\n{\n    vec2 q = pos;\n    const mat2 m = mat2( 0.36,  0.80,  -0.80,  0.36 );\n                    \n    float amplitude = 0.5;\n    float f  = amplitude*noise( q );\n    float scale = 2.12;\n    for (int i = 0; i < 4; ++i)\n    {    \n        q = m*q*scale; //q*=scale;\n    \tf += amplitude * noise( q );\n        amplitude *= 0.5;\n    }\n    return f;\n}\n\n\n// voronoi stars - simplified and slightly optimized to use a single texture fetch for the randomness\nvec3 stars(in vec2 pos)\n{\n    vec3 col = vec3(0.0);\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n    vec2 dir = sign(f-0.5);\n    for( float j=0.0; j<=1.0; j+=1.0 )\n    {\n   \t\tfor( float i=0.0; i<=1.0; i+=1.0 )    \n\t    {\n            vec2 cell = vec2(i*dir.x,j*dir.y);\n            vec2 p = (n + cell)+0.5;\n            vec4 rnd1 = texture( iChannel0, p/256.0, -100.0 ).xyzw; // random offset,col,brightness\n            float d = length(cell + rnd1.xy - f);                \n            rnd1.w = max(0.2,rnd1.w);\n            // falloff\n            float dist = max(0.1, 1.0 - d);\n            float starfo = pow(dist, 60.0) * 6.5 + pow(dist, 120.0);\n\t        col += vec3(rnd1.z*0.2) * rnd1.w * starfo;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tvec2 uv = p;\n    \n    uv.x *= length(p-vec2(1.0));\n    \n    float ny = p.y+0.5; // ypos 0-1\n\n    uv.y *= 1.2;\n    uv.x *= 3.55;\n\n\tfloat t = iTime * .915;\n    uv.y += t;\n    \n    float fval1 = mNoise(uv);\n    uv.x *= 0.74;\n    \n    float fval = 0.33+(ny*0.1); // 0.13 less fuckage\n    uv.x += 3.5+(fval1*fval); // here, we fuck layer2 with layer1 a touch for a lavalamp style effect\n    uv.y -= t*0.53;\n    float fval2 = mNoise(uv);\n    \n    float cut = 0.3;  \n    fval1 = smoothstep(cut-0.1,1.8,fval1);\n    fval2 = smoothstep(cut,1.8,fval2);\n    fval1 = fval1+fval2;\n\n    // colors (layer1)\n    vec3 col1top = vec3(0.65,1.0,0.5);\n    vec3 col1bot = vec3(0.85,0.86,0.85);\n\n    // colors (layer2)\n    vec3 col2top = vec3(1.1,0.75,0.5)*1.8;\n    vec3 col2bot = vec3(1.0,0.85,0.7)*1.8;\n    \n    vec3 col1 = mix(col1bot,col1top,ny)*fval1;\n    vec3 col2 = mix(col2bot,col2top,ny)*fval2;\n    \n    // this blend is calculated with the asspluck constant\n    float blend = 0.5+(sin(fval1*4.25+fval2*1.75)*0.25);\n    vec3 color = mix(col1,col2,blend)*1.11;\n\n    // test it with a starfield background...\n    color = clamp(color,vec3(0.0),vec3(1.0));\n    float a = smoothstep(0.4,0.0,length(color)); // a = starmask\n    color +=  stars(p*15.0) * a;\n\n\n    // mouse = rgb swizzle\n    //if (iMouse.z>0.5)\n        color = color.zyx;\n    // vignetting\t\n   color *= 1.0 - 0.4*dot(p,p);\t\t// vignette\n\n\n\tfragColor = vec4(color.xyz,1.0);\n}\n\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clX3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 401, 423, 423, 512], [514, 514, 540, 540, 887], [889, 889, 918, 918, 1259], [1262, 1364, 1389, 1389, 2099], [2101, 2101, 2158, 2158, 3647]], "test": "untested"}
{"id": "clfGzl", "name": "SolarWinds", "author": "Del", "description": "scrolling nebula effect (solar wind remix)\nhttps://store.steampowered.com/app/1751970/A_Blast_From_The_Past/", "tags": ["noise", "fbm", "blend"], "likes": 8, "viewed": 294, "published": 3, "date": "1672203388", "time_retrieved": "2024-07-30T16:10:34.256881", "image_code": "// Cheap(ish) scrolling nebula effect (just noise mixing)\n// https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n\n// noise, IQ - https://www.shadertoy.com/view/4sfGzS\n// (somewhat jigged)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n//#define UI3 uvec3(UI0, UI1, 2798796415U)\n//#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat mNoise( in vec2 pos )\n{\n    vec2 q = pos;\n    const mat2 m = mat2( 0.36,  0.80,  -0.80,  0.36 );\n                    \n    float amplitude = 0.5;\n    float f  = amplitude*noise( q );\n    float scale = 2.12;\n    for (int i = 0; i < 4; ++i)\n    {    \n        q = m*q*scale; //q*=scale;\n    \tf += amplitude * noise( q );\n        amplitude *= 0.5;\n    }\n    return f;\n}\n\n\n// voronoi stars - simplified and slightly optimized to use a single texture fetch for the randomness\nvec3 stars(in vec2 pos)\n{\n    vec3 col = vec3(0.0);\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n    vec2 dir = sign(f-0.5);\n    for( float j=0.0; j<=1.0; j+=1.0 )\n    {\n   \t\tfor( float i=0.0; i<=1.0; i+=1.0 )    \n\t    {\n            vec2 cell = vec2(i*dir.x,j*dir.y);\n            vec2 p = (n + cell)+0.5;\n            vec4 rnd1 = texture( iChannel0, p/256.0, -100.0 ).xyzw; // random offset,col,brightness\n            float d = length(cell + rnd1.xy - f);                \n            rnd1.w = max(0.2,rnd1.w);\n            // falloff\n            float dist = max(0.1, 1.0 - d);\n            float starfo = pow(dist, 60.0) * 6.5 + pow(dist, 120.0);\n\t        col += vec3(rnd1.z*0.2) * rnd1.w * starfo;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tvec2 uv = p;\n    \n    uv.x += length(p-vec2(1.0));\n    \n    float ny = p.y+0.5; // ypos 0-1\n\n    uv.y *= 1.1;\n    uv.x *= 3.25;\n\n\tfloat t = iTime * .725;\n    uv.y += t;\n    \n    float fval1 = mNoise(uv);\n    uv.x *= 0.64;\n    \n    float fval = 0.23+(ny*0.1); // 0.13 less fuckage\n    uv.x += 3.5+(fval1*fval); // here, we fuck layer2 with layer1 a touch for a lavalamp style effect\n    uv.y -= t*0.53;\n    float fval2 = mNoise(uv);\n    \n    float cut = 0.45;  \n    fval1 = smoothstep(cut-0.1,1.8,fval1);\n    fval2 = smoothstep(cut,1.8,fval2);\n    fval1 = fval1+fval2;\n\n    // colors (layer1)\n    vec3 col1top = vec3(0.65,1.0,0.5);\n    vec3 col1bot = vec3(0.55,0.6,0.75);\n\n    // colors (layer2)\n    vec3 col2top = vec3(1.1,0.75,0.35)*1.8;\n    vec3 col2bot = vec3(1.0,0.65,0.3)*1.8;\n    \n    vec3 col1 = mix(col1bot,col1top,ny)*fval1;\n    vec3 col2 = mix(col2bot,col2top,ny)*fval2;\n    \n    // this blend is calculated with the asspluck constant\n    float blend = 0.5+(sin(fval1*4.25+fval2*1.75)*0.25);\n    vec3 color = mix(col1,col2,blend)*1.31;\n\n    // test it with a starfield background...\n    color = clamp(color,vec3(0.0),vec3(1.0));\n    float a = smoothstep(0.4,0.0,length(color)); // a = starmask\n    color +=  stars(p*15.0) * a;\n\n\n    // mouse = rgb swizzle\n    if (iMouse.z>0.5)\n        color = color.zyx;\n    // vignetting\t\n   color *= 1.0 - 0.4*dot(p,p);\t\t// vignette\n\n\n\tfragColor = vec4(color.xyz,1.0);\n}\n\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 401, 423, 423, 512], [514, 514, 540, 540, 887], [889, 889, 918, 918, 1259], [1262, 1364, 1389, 1389, 2099], [2101, 2101, 2158, 2158, 3646]], "test": "untested"}
{"id": "dtX3W7", "name": "Font with even-odd and non-zero", "author": "BeRo", "description": "Direct font → SDF rendering with hopefully correct handling of even-odd and non-zero fill rules, see useEvenOddRule bool for configuration, otherwise read the beginning code comment. \n\nBased on https://www.shadertoy.com/view/dls3Wr by mkeeter \n", "tags": ["raycasting", "sdf", "bezier", "font", "quadratic", "windingrule", "evenodd", "nonzero", "fillrule", "intersectioncounting"], "likes": 10, "viewed": 391, "published": 3, "date": "1672201370", "time_retrieved": "2024-07-30T16:10:35.233271", "image_code": "// Using distance-to-quadratic and winding number to generate a closed-form\n// distance field of a font outline, which is specified as lines + quadratic\n// Bézier curves with correct handling of even-odd / non-zero rules by\n// pseudo-scanline-wise raycasting and counting the winding information,\n// where it does not matter how it is deformed or rotated at the end for the \n// display, because the main thing is that the winding number is correct, \n// regardless of the actual visual 2D projection.\n//\n// It's based on https://www.shadertoy.com/view/dls3Wr by mkeeter where I, \n// Benjamin 'BeRo' Rosseaux, have added the correct handling of the even-odd \n// and non-zero rules handling.\n//\n// It is admittedly still unoptimized, since at the moment all lines and \n// quadratic curves are still checked bruteforce-like with a pseudo-\n// scanline-wise raycasting check, instead of only the ones actually needed \n// for the current each fragment shader position including a preliminary \n// start winding value information for pseudo-scanline such-and-such in \n// quadtree cell or start-search-index-lookup-mip-map-texture such-and-such,\n// more or less like at Pathfinder 3, \"Random Access Vector Graphics\", and so on.  \n//\n// At least this should now serve as ground truth for further optimization and \n// for other better and more clever implementations as well. \n//\n// Quadratic solver is based on https://www.shadertoy.com/view/MlKcDD, which\n// includes the following copyright notice:\n//\n//      Copyright © 2018 Inigo Quilez\n//      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nbool useEvenOddRule = false; // true for even-odd rule, false for non-zero rule \n\n// Additional informations:\n//\n// Quadratic curve tangent is normalize(mix(q1, q2, t) - mix(q0, q1, t))\n//\n// +1 is added for each crossing where the Y coordinate is increasing\n// -1 is added for each crossing where the Y coordinate is decreasing        \n\n// Curves are baked by an external tool\n#define QUAD_COUNT 38\nconst vec2 QUADS[QUAD_COUNT * 3] = vec2[QUAD_COUNT * 3](\n    vec2(0.5758487, -4.5724106), vec2(0.5758487, -4.9204984), vec2(0.7176622, -5.221315),\n    vec2(0.7176622, -5.221315), vec2(0.8594757, -5.5221314), vec2(1.1216158, -5.758487),\n    vec2(0.7520412, -2.0842285), vec2(0.8594757, -1.6974645), vec2(1.0034379, -1.3859046),\n    vec2(0.86162436, -3.5904598), vec2(0.5758487, -3.9664803), vec2(0.5758487, -4.5724106),\n    vec2(1.0034379, -1.3859046), vec2(1.1474, -1.0743446), vec2(1.3837559, -0.8036098),\n    vec2(1.1216158, -5.758487), vec2(1.3708637, -5.9819508), vec2(1.7103566, -6.1087236),\n    vec2(1.3794585, -4.9591746), vec2(1.3794585, -4.563816), vec2(1.5642458, -4.3038244),\n    vec2(1.3837559, -0.8036098), vec2(1.6072196, -0.55006444), vec2(1.9058874, -0.3996562),\n    vec2(1.5642458, -4.3038244), vec2(1.7490331, -4.0438333), vec2(2.101418, -3.8762355),\n    vec2(1.6630855, -2.9823806), vec2(1.1474, -3.2144392), vec2(0.86162436, -3.5904598),\n    vec2(1.6673828, -5.599484), vec2(1.3794585, -5.337344), vec2(1.3794585, -4.9591746),\n    vec2(1.6974645, -0.0021486892), vec2(1.2892135, -0.12892136), vec2(0.99269444, -0.30941126),\n    vec2(1.7103566, -6.1087236), vec2(2.0498495, -6.235496), vec2(2.419424, -6.235496),\n    vec2(1.9058874, -0.3996562), vec2(2.2045553, -0.24924795), vec2(2.599914, -0.24924795),\n    vec2(2.101418, -3.8762355), vec2(2.4151268, -3.7258272), vec2(2.718092, -3.616244),\n    vec2(2.2862053, -2.7266867), vec2(1.9252255, -2.862054), vec2(1.6630855, -2.9823806),\n    vec2(2.363558, -5.8616242), vec2(1.9553072, -5.8616242), vec2(1.6673828, -5.599484),\n    vec2(2.419424, -6.235496), vec2(2.840567, -6.235496), vec2(3.173614, -6.106575),\n    vec2(2.5139663, 0.12462398), vec2(2.1057155, 0.12462398), vec2(1.6974645, -0.0021486892),\n    vec2(2.599914, -0.24924795), vec2(2.896433, -0.24924795), vec2(3.117748, -0.32660076),\n    vec2(2.718092, -3.616244), vec2(3.0210571, -3.506661), vec2(3.3046842, -3.382037),\n    vec2(2.9265146, -2.4795873), vec2(2.647185, -2.5913193), vec2(2.2862053, -2.7266867),\n    vec2(3.0167596, -5.7133646), vec2(2.7503223, -5.8616242), vec2(2.363558, -5.8616242),\n    vec2(3.117748, -0.32660076), vec2(3.3390632, -0.40395358), vec2(3.4765792, -0.54576707),\n    vec2(3.173614, -6.106575), vec2(3.506661, -5.9776535), vec2(3.781693, -5.8057585),\n    vec2(3.3046842, -3.382037), vec2(3.5625267, -3.270305), vec2(3.8010314, -3.1284916),\n    vec2(3.4679844, -5.315857), vec2(3.2831972, -5.565105), vec2(3.0167596, -5.7133646),\n    vec2(3.4765792, -0.54576707), vec2(3.6140952, -0.6875806), vec2(3.6807046, -0.8788139),\n    vec2(3.54104, -2.0004296), vec2(3.3347657, -2.316287), vec2(2.9265146, -2.4795873),\n    vec2(3.6807046, -0.8788139), vec2(3.747314, -1.0700473), vec2(3.747314, -1.3192952),\n    vec2(3.747314, -1.3192952), vec2(3.747314, -1.6845723), vec2(3.54104, -2.0004296),\n    vec2(3.775247, -4.7400084), vec2(3.657069, -5.0580144), vec2(3.4679844, -5.315857),\n    vec2(3.8010314, -3.1284916), vec2(4.039536, -2.9866781), vec2(4.2157283, -2.7975934),\n    vec2(3.9879673, -4.073915), vec2(3.893425, -4.4220023), vec2(3.775247, -4.7400084),\n    vec2(3.996562, -0.3996562), vec2(3.3992264, 0.12462398), vec2(2.5139663, 0.12462398),\n    vec2(4.2157283, -2.7975934), vec2(4.4091105, -2.5827246), vec2(4.501504, -2.3270304),\n    vec2(4.501504, -2.3270304), vec2(4.593898, -2.0713365), vec2(4.593898, -1.7318435),\n    vec2(4.593898, -1.7318435), vec2(4.593898, -0.92393637), vec2(3.996562, -0.3996562)\n);\n\n#define LINE_COUNT 8\nconst vec2 LINES[LINE_COUNT * 2] = vec2[LINE_COUNT * 2](\n    vec2(0.40395358, -2.0842285), vec2(0.7520412, -2.0842285),\n    vec2(0.46411687, 0.0042973785), vec2(0.40395358, -2.0842285),\n    vec2(0.80790716, 0.0042973785), vec2(0.46411687, 0.0042973785),\n    vec2(0.99269444, -0.30941126), vec2(0.80790716, 0.0042973785),\n    vec2(3.781693, -5.8057585), vec2(3.9578855, -6.09798),\n    vec2(3.9578855, -6.09798), vec2(4.301676, -6.09798),\n    vec2(4.301676, -6.09798), vec2(4.336055, -4.073915),\n    vec2(4.336055, -4.073915), vec2(3.9879673, -4.073915)\n);\n\nfloat cross2(vec2 lhs, vec2 rhs){\n  return (lhs.x * rhs.y) - (lhs.y * rhs.x);\n}\n\n#define MORE_OPTIMIZED\n\n#ifdef MORE_OPTIMIZED\n// signed distance to a line\nfloat sdLine(in vec2 pos, in vec2 A, in vec2 B) {   \n  vec2 pSubA = pos - A;\n  vec2 lineSegment = B - A;\n  float squaredLineLength = dot(lineSegment, lineSegment);\n  vec2 nearestPoint = mix(A, B, clamp(dot(pSubA, lineSegment) / squaredLineLength, 0.0, 1.0));\n  vec2 nearestVector = nearestPoint - pos;\n  return length(nearestVector) * sign(-cross2(nearestVector, lineSegment)); \n}\n\nfloat sdLine(in vec2 pos, in vec2 A, in vec2 B, inout int winding) {   \n  vec2 pSubA = pos - A;\n  vec2 lineSegment = B - A;\n  float squaredLineLength = dot(lineSegment, lineSegment);\n  vec2 nearestPoint = mix(A, B, clamp(dot(pSubA, lineSegment) / squaredLineLength, 0.0, 1.0));\n  vec2 nearestVector = nearestPoint - pos;\n  \n  // Pseudo-scanline-based winding code part by Benjamin 'BeRo' Rosseaux\n  // The following code calculates the winding number of a point (pos) relative to a\n  // line segment formed by two points A and B. It does so by simulating a horizontal line \n  // at the y-coordinate of the point (pos) and checking whether this line intersects the \n  // line segment. If the intersection occurs within the limits of the line segment, it\n  // increments or decrements the winding number by 1, depending on the orientation of\n  // the line segment. The winding number can be used to determine whether the point is \n  // inside or outside a polygon. If the line intersects the polygon an even number of times,\n  // the winding number is 0, indicating that the point is outside the polygon. If the line \n  // intersects the polygon an odd number of times, the winding number is either 1 (if the \n  // polygon is oriented counter-clockwise) or -1 (if the polygon is oriented clockwise).  \n  if(abs(lineSegment.y) > 1e-8){\n    float t = -(A.y - pos.y) / lineSegment.y;\n    winding += ((t >= 0.0) && (t <= 1.0) && (mix(A.x, B.x, t) <= pos.x)) ?\n                 ((B.y < A.y) ? -1 : 1) :\n                 0;\n  } \n  \n  return length(nearestVector) * sign(-cross2(nearestVector, lineSegment)); \n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    if(h >= 0.0) { // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        // When p≈0 and p<0, h - q has catastrophic cancelation. So, we do\n        // h=√(q² + 4p³)=q·√(1 + 4p³/q²)=q·√(1 + w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1 + ½w) so that the q's\n        // cancel each other in h - q. Expanding and simplifying further we\n        // get x=vec2(p³/q, -p³/q - q). And using a second degree Taylor\n        // expansion instead: x=vec2(k, -k - q) with k=(1 - p³/q²)·p³/q\n        if(abs(abs(h/q) - 1.0) < 0.0001) {\n            float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n            x = vec2(k, -k - q);\n        }\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2  q = d + (c + b * t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0 * b * t, q);\n    } else { // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2  qx=d + (c + b * t.x) * t.x;\n        float dx = dot(qx, qx), sx = cross2(c + 2.0 * b * t.x, qx);\n        vec2  qy=d + (c + b * t.y) * t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c + (2.0 * b * t.y), qy);\n        if (dx<dy) {\n            res=dx;\n            sgn=sx;\n        } else {\n            res=dy;\n            sgn=sy;\n        }\n    }\n\n    return sqrt(res) * sign(sgn);\n}\n\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C, inout int winding) {\n  vec2 a = B - A;\n  vec2 b = A - 2.0 * B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0 / dot(b, b);\n  float kx = kk * dot(a, b);\n  float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n  float kz = kk * dot(d, a);\n\n  float res = 0.0;\n  float sgn = 0.0;\n\n  float p  = ky - kx * kx;\n  float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n  float p3 = p * p * p;\n  float q2 = q * q;\n  float h  = q2 + 4.0 * p3;\n\n  if(h >= 0.0) { // 1 root\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n\n    // When p≈0 and p<0, h - q has catastrophic cancelation. So, we do\n    // h=√(q² + 4p³)=q·√(1 + 4p³/q²)=q·√(1 + w) instead. Now we approximate\n    // √ by a linear Taylor expansion into h≈q(1 + ½w) so that the q's\n    // cancel each other in h - q. Expanding and simplifying further we\n    // get x=vec2(p³/q, -p³/q - q). And using a second degree Taylor\n    // expansion instead: x=vec2(k, -k - q) with k=(1 - p³/q²)·p³/q\n    if(abs(abs(h/q) - 1.0) < 0.0001) {\n      float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n      x = vec2(k, -k - q);\n    }\n\n    vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n    float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n    vec2  q = d + (c + b * t) * t;\n    res = dot(q, q);\n    sgn = cross2(c + 2.0 * b * t, q);\n  } else { // 3 roots\n    float z = sqrt(-p);\n    float v = acos(q / (p * z * 2.0)) / 3.0;\n    float m = cos(v);\n    float n = sin(v) * 1.732050808;\n    vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n    vec2  qx=d + (c + b * t.x) * t.x;\n    float dx = dot(qx, qx), sx = cross2(c + 2.0 * b * t.x, qx);\n    vec2  qy=d + (c + b * t.y) * t.y;\n    float dy = dot(qy, qy);\n    float sy = cross2(c + (2.0 * b * t.y), qy);\n    if (dx<dy) {\n      res=dx;\n      sgn=sx;\n    } else {\n      res=dy;\n      sgn=sy;\n    }\n  }\n  \n  // Pseudo-scanline-based winding code part by Benjamin 'BeRo' Rosseaux\n  // This following code calculates the winding number of a quadratic bezier curve at \n  // a given point. The winding number is a measure of how many times a curve wraps \n  // around a given point, and it is used in the implementation of the even-odd or \n  // non-zero rule for determining whether a point is inside or outside of a path. \n  // It does so by simulating a horizontal line at the y-coordinate of the point (pos) \n  // and checking whether this horizontal line intersects the quadratic curve. \n  // The code first calculates the coefficients of a quadratic equation in the form \n  // \"at^2 + bt + c = y\", where \"y\" is the y-coordinate of the given point, and \"t\" is a \n  // value that varies between 0 and 1. The coefficients are then used to solve the equation \n  // using the quadratic formula, which gives the values of \"t\" at which the curve intersects\n  // the given y-coordinate. These values of \"t\" are then used to calculate the x-coordinates\n  // of the intersections, and the winding number is incremented or decremented by 1,\n  // depending on the orientation of the quadratic curve by evaluating the quadratic curve \n  // tangents for the x-axis coordinates.\n  // Overall, the code is well-written and easy to understand. It effectively uses the quadratic \n  // formula to find the intersections of the curve with a given y-coordinate, and then checks with\n  // help of quadratic tangents at time \"t\" on which side of the given point these intersections are \n  // to determine the winding number.\n  { \n    float a = (A.y - (2.0 * B.y)) + C.y;\n    float b = (-2.0 * A.y) + (2.0 * B.y);\n    float d = (b * b) - (4.0 * a * (A.y - pos.y));\n    if (d > 0.0) {\n      vec2 t = (vec2(-b) + (vec2(-1.0, 1.0) * sqrt(d))) / (2.0 * a);\n      vec2 h = mix(mix(A.xx, B.xx, t), mix(B.xx, C.xx, t), t);  \n      winding += (((t.x >= 0.0) && (t.x <= 1.0)) && (h.x <= pos.x)) ?\n                   (((mix(B.y, C.y, t.x) - mix(A.y, B.y, t.x)) < 0.0) ? -1 : 1) : \n                   0;\n      winding += (((t.y >= 0.0) && (t.y <= 1.0)) && (h.y <= pos.x)) ? \n                   (((mix(B.y, C.y, t.y) - mix(A.y, B.y, t.y)) < 0.0) ? -1 : 1) : \n                   0;\n    }          \n  } \n  \n  return sqrt(res) * sign(sgn);\n}\n\nfloat getAccordingToFillRuleCorrectSignedDistance(const in vec2 p, const in bool evenOdd){\n  // Ray = Scanline segment = Line segment for counting of the winding intersections on\n  // the current pseudo-scanline of p.y\n  int w = 0;\n  float d = 1e+26;\n  for (int i = 0; i < QUAD_COUNT; i++) {\n    d = min(d, abs(sdBezier(p, QUADS[i * 3], QUADS[(i * 3) + 1], QUADS[(i * 3) + 2], w)));\n  }\n  for (int i = 0; i < LINE_COUNT; i++) {\n    d = min(d, abs(sdLine(p, LINES[i * 2], LINES[(i * 2) + 1], w)));\n  }\n  return abs(d) * ((evenOdd ? ((w & 1) != 0) /* even odd rule */ \n                            : (w != 0) /* non-zero rule */) ? -1.0 : 1.0);\n}\n\n#else\n\n// signed distance to a line\nfloat sdLine(in vec2 pos, in vec2 A, in vec2 B) {   \n  vec2 pSubA = pos - A;\n  vec2 lineSegment = B - A;\n  float squaredLineLength = dot(lineSegment, lineSegment);\n  vec2 nearestPoint = mix(A, B, clamp(dot(pSubA, lineSegment) / squaredLineLength, 0.0, 1.0));\n  vec2 nearestVector = nearestPoint - pos;\n  return length(nearestVector) * sign(-cross2(nearestVector, lineSegment)); \n}\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    if(h >= 0.0) { // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        // When p≈0 and p<0, h - q has catastrophic cancelation. So, we do\n        // h=√(q² + 4p³)=q·√(1 + 4p³/q²)=q·√(1 + w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1 + ½w) so that the q's\n        // cancel each other in h - q. Expanding and simplifying further we\n        // get x=vec2(p³/q, -p³/q - q). And using a second degree Taylor\n        // expansion instead: x=vec2(k, -k - q) with k=(1 - p³/q²)·p³/q\n        if(abs(abs(h/q) - 1.0) < 0.0001) {\n            float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n            x = vec2(k, -k - q);\n        }\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2  q = d + (c + b * t) * t;\n        res = dot(q, q);\n        sgn = cross2(c + 2.0 * b * t, q);\n    } else { // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2  qx=d + (c + b * t.x) * t.x;\n        float dx = dot(qx, qx), sx = cross2(c + 2.0 * b * t.x, qx);\n        vec2  qy=d + (c + b * t.y) * t.y;\n        float dy = dot(qy, qy);\n        float sy = cross2(c + (2.0 * b * t.y), qy);\n        if (dx<dy) {\n            res=dx;\n            sgn=sx;\n        } else {\n            res=dy;\n            sgn=sy;\n        }\n    }\n\n    return sqrt(res) * sign(sgn);\n}\n\nint sumWindingForLineCurveAtScanlineSegment(const in vec2 l0,\n                                            const in vec2 l1,\n                                            const in vec2 p0,\n                                            const in vec2 p1){\n  int w = 0;\n  float AX = (l1.x - l0.x);\n  float BX = l0.x;\n  float AY = (l1.y - l0.y);\n  float BY = l0.y;\n  float ax = (p1.x - p0.x);\n  float bx = p0.x;\n  float ay = (p1.y - p0.y);\n  float by = p0.y;\n  if (ax == 0.0) {\n    float t;\n    t = ax; ax = ay; ay = t;\n    t = bx; bx = by; by = t;\n    t = AX; AX = AY; AY = t;\n    t = BX; BX = BY; BY = t;\n  }\n  float r = ay / ax;\n  float a = (AY - r * AX);\n  float b = (BY - r * BX) - (by - r * bx);\n  float t = -b/a;\n  if (t >= 0.0 && t <= 1.0) {\n    float k = t * AX/ax + BX/ax - bx/ax;\n    if (k >= 0.0 && k <= 1.0){\n      w += (AY < 0.0) ? -1 : 1;\n    }\n  } \n  return w;\n}\n\nint sumWindingForQuadraticCurveAtScanlineSegment(const in vec2 q0,\n                                                 const in vec2 q1,\n                                                 const in vec2 q2,\n                                                 const in vec2 p0,\n                                                 const in vec2 p1){\n  int w = 0;\n  float AX = (q0.x - 2.0*q1.x + q2.x);\n  float BX = (-2.0*q0.x + 2.0*q1.x);\n  float CX = q0.x;\n  float AY = (q0.y - 2.0*q1.y + q2.y);\n  float BY = (-2.0*q0.y + 2.0*q1.y);\n  float CY = q0.y;\n  float ax = (p1.x - p0.x);\n  float bx = p0.x;\n  float ay = (p1.y - p0.y);\n  float by = p0.y;\n  if (ax == 0.0) {\n    float t;\n    t = ax; ax = ay; ay = t;\n    t = bx; bx = by; by = t;\n    t = AX; AX = AY; AY = t;\n    t = BX; BX = BY; BY = t;\n    t = CX; CX = CY; CY = t;\n  }\n  float r = ay / ax;\n  float a = (AY - r * AX);\n  float b = (BY - r * BX);\n  float c = (CY - r * CX) - (by - r * bx);\n  float d = b*b - 4.0*a*c;\n  if (d > 0.0) {\n    float sd = sqrt( d );\n    float t1 = (-b - sd) / (2.0*a);\n    float t2 = (-b + sd) / (2.0*a);\n    if (t1 >= 0.0 && t1 <= 1.0) {\n      float k1 = t1*t1 * AX/ax + t1 * BX/ax + CX/ax - bx/ax;\n      if (k1 >= 0.0 && k1 <= 1.0){\n        w += ((mix(q1.y, q2.y, t1) - mix(q0.y, q1.y, t1)) < 0.0) ? -1 : 1;\n      }\n    }\n    if (t2 >= 0.0 && t2 <= 1.0) {\n      float k2 = t2*t2 * AX/ax + t2 * BX/ax + CX/ax - bx/ax;\n      if (k2 >= 0.0 && k2 <= 1.0){\n        w += ((mix(q1.y, q2.y, t2) - mix(q0.y, q1.y, t2)) < 0.0) ? -1 : 1;\n      } \n    }\n  }          \n  return w;\n}\n\nfloat getAccordingToFillRuleCorrectSignedDistance(const in vec2 p, const in bool evenOdd){\n  // Ray = Scanline segment = Line segment for counting of the winding intersections on\n  // the current pseudo-scanline of p.y\n  vec2 p0 = p; // ray origin = p \n  vec2 p1 = p - vec2(65536.0, 0.0); // just shift as ray end vector p x-wise to a position far before the beginning of the pseudo-scanline of p.y   \n  int w = 0;\n  float d = 1e+26;\n  for (int i = 0; i < QUAD_COUNT; i++) {\n    vec2 q0 = QUADS[i * 3], q1 = QUADS[(i * 3) + 1], q2 = QUADS[(i * 3) + 2];\n    d = min(d, abs(sdBezier(p, q0, q1, q2)));\n    w += sumWindingForQuadraticCurveAtScanlineSegment(q0, q1, q2, p0, p1);\n  }\n  for (int i = 0; i < LINE_COUNT; i++) {\n    vec2 l0 = LINES[i * 2], l1 = LINES[(i * 2) + 1];\n    d = min(d, abs(sdLine(p, l0, l1)));\n    w += sumWindingForLineCurveAtScanlineSegment(l0, l1, p0, p1);\n  }\n  return abs(d) * ((evenOdd ? ((w & 1) != 0) /* even odd rule */ \n                            : (w != 0) /* non-zero rule */) ? -1.0 : 1.0);\n}\n\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    p = (p + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m = (m + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n\n    float d = getAccordingToFillRuleCorrectSignedDistance(p, useEvenOddRule); \n\n    // Apply a color based on signed distance\n    vec3 col = vec3(1.0) - vec3(0.1, 0.4, 0.7) * sign(d);\n    col *= 1.0 - exp(-4.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(60.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    // Draw the mouse stuff\n    if(iMouse.z > 0.001) {\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, abs(sdBezier(m, v0, v1, v2)));\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, abs(sdLine(m, v0, v1)));\n        }\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.01));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.05));\n    }\n\n    { // Draw the skeleton of the Bezier curves\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, min(abs(sdLine(p, v0, v1)), abs(sdLine(p, v1, v2))));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n            d = min(d, length(p - v2) - 0.05);\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, abs(sdLine(p, v0, v1)));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n        }\n        col = mix(col, vec3(1, 0, 0), 1.0 - smoothstep(0.0, 0.014, d));\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtX3W7.jpg", "access": "api", "license": "mit", "functions": [[7007, 7007, 7040, 7040, 7086], [22142, 22142, 22197, 22197, 24300]], "test": "error"}
{"id": "DlfGRl", "name": "Smarter digits", "author": "fishy", "description": "I made some digits previously but I think this seven segment system is a lot better. I also learned the powers of #define lol", "tags": ["digits", "counting"], "likes": 6, "viewed": 186, "published": 3, "date": "1672196155", "time_retrieved": "2024-07-30T16:10:36.000221", "image_code": "float box(in vec2 uv, vec2 b)\n{\n    uv = abs(uv)-b; return max(uv.x, uv.y);\n}\n\nstruct displayInfo\n{\n    bool a, b, c, d, e, f, g;\n};\n\n#define t true\n#define f false\ndisplayInfo[] info = displayInfo[] (\ndisplayInfo(t, t, t, t, t, t, f),\ndisplayInfo(f, t, t, f, f, f, f),\ndisplayInfo(t, t, f, t, t, f, t),\ndisplayInfo(t, t, t, t, f, f, t),\ndisplayInfo(f, t, t, f, f, t, t),\ndisplayInfo(t, f, t, t, f, t, t),\ndisplayInfo(t, f, t, t, t, t, t),\ndisplayInfo(t, t, t, f, f, f, f),\ndisplayInfo(t, t, t, t, t, t, t),\ndisplayInfo(t, t, t, t, f, t, t));\n#undef t\n#undef f\n\n#define vc(p, b, z) if(i.z) d = min(d, box(uv-vec2(size.xx*p.xy), size.yx+vec2(0, size.y)))\n#define hc(p, b, z) if(i.z) d = min(d, box(uv-vec2(0, size.x*p*2.), size.xy+vec2(size.y, 0)))\nfloat segDisplay(vec2 uv, vec2 size, displayInfo i)\n{\n    float d = 1e20;\n    hc(1., size.x, a);\n    vc(vec2(1, 1), size.x, b);\n    vc(vec2(1, -1), size.x, c);\n    hc(-1., size.x, d);\n    vc(vec2(-1, -1), size.x, e);\n    vc(vec2(-1, 1), size.x, f);\n    hc(0., size.x, g);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.-step(0., segDisplay(uv, vec2(0.3, 0.05), info[int(mod(iTime, 10.))])));\n    #define t true\n    col += vec3(1.-step(0., segDisplay(uv, vec2(0.3, 0.05), displayInfo(t, t, t, t, t, t, t))))*0.2;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 77], [748, 748, 801, 801, 1035], [1037, 1037, 1094, 1144, 1509]], "test": "untested"}
{"id": "mll3zf", "name": "[House]", "author": "SnoopethDuckDuck", "description": "House: https://www.slynyrd.com/blog/2018/3/14/pixelblog-3-graphical-projections-1\n\nReset the music so it works!\n\nI was going to do the brickwork too but lost my mind before I got that far", "tags": ["house"], "likes": 36, "viewed": 406, "published": 3, "date": "1672192072", "time_retrieved": "2024-07-30T16:10:36.743234", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n#define blue1 vec3(126,229,218)/255.\n#define blue2 vec3(82,163,204)/255.\n#define blue3 vec3(46,109,153)/255.\n#define blue4 vec3(46,57,115)/255.\n#define brown0 vec3(217,217,195)/255.\n#define brown1 vec3(193,182,162)/255.\n#define brown2 vec3(161,136,124)/255.\n#define brown3 vec3(132,92,92)/255.\n#define brown4 vec3(91,70,84)/255.\n#define brown5 vec3(66,57,66)/255.\n\n#define rn 64.\n\n// https://www.shadertoy.com/view/4tGXzt\nfloat getFreq(float x) {\n\treturn texture(iChannel0, vec2(floor(x * rn + 1.) / rn, 0)).x;\n}\n\nfloat getFreq_smooth(float x) {\n\tfloat index = floor(x * rn) / rn;\n    float next = floor(x * rn + 1.0) / rn;\n\treturn mix(getFreq(index), getFreq(next), smoothstep(0.0, 1.0, fract(x * rn)));\n}\n\n// Globals\nfloat w, w2, h;\n\n// x,y bottom left corner\nfloat box(vec2 f, float x, float y, float width, float height) {\n    return step(x, f.x) * step(f.x, x + width - 1.) *\n           step(y, f.y) * step(f.y, y + height - 1.);\n}\n\n// x,y bottom left corner, rhombus\nfloat rhom(vec2 f, float x, float y, float width, float height, float s) {\n    f -= vec2(x + 1.,y);\n    return step(0., f.y) * step(f.y, height) *\n           step(f.x - width, s*f.y) * \n           step(s*f.y, f.x);\n}\n\nvec3 face(vec2 f, vec3 col) {\n    f.x = abs(f.x-0.5);\n    return mix(col, brown3, \n               step(f.x, 2.*w+h-f.y) * step(abs(f.x), w) * \n               step(0., f.y));\n}\n\nvec3 roof(vec2 f, vec3 col) {\n    return mix(col, blue1, rhom(f, w, w+h, w2, w+1., -1.));    \n}\n\nvec3 trim(vec2 f, vec3 col) {\n    col = mix(col, blue2, rhom(f, w, w+h, 0., w+1., -1.));\n    col = mix(col, blue3, rhom(f, -w-3., w+h, 0., w+1., 1.));\n    col = mix(col, blue4, rhom(f, -w-2., w+h, 1., w, 1.));\n    col = mix(col, brown4, rhom(f, -w, w+h, 0., w-2., 1.) +\n                           rhom(f, w-2., w+h, 1., w-1., -1.));   \n    return col;\n}\n\nvec3 side(vec2 f, vec3 col) {\n    col = mix(col, brown1, box(f,w+1.,0.,w2-2.,w+h));\n    col = mix(col, brown2, box(f,w+1.,w+h-2.,w2-2.,2.));\n    return col;\n}\n\nvec3 windowSide(vec2 f, vec3 col, vec3 win) {\n    float w3 = floor(w2/3.); // sloppy\n    col = mix(col, mix(win,blue2,.5), box(f, w+w3+2., 5., 3., 4.));\n    col = mix(col, mix(win,blue3,.5), box(f, w+w3+2., 9., 3., 1.));\n    col = mix(col, brown3, box(f, w+w3+5., 9., 1., 1.));\n    col = mix(col, brown2, box(f, w+w3+5., 5., 1., 4.) +\n                           box(f, w+w3+1., 3., 5., 1.) +\n                           box(f, w+w3+1., 4., 1., 1.));\n    return col;\n}\n\nvec3 windowTop(vec2 f, vec3 col, vec3 win) {\n    col = mix(col, mix(win,blue3,.5), \n              box(f,-1.,12.,4.,4.) * \n              max(step(0.,f.x)   * step(f.x, 1.),\n                  step(13., f.y) * step(f.y, 14.)));\n    col = mix(col, mix(win,blue4,.5), box(f, 0., 15., 2., 1.) +\n                                      box(f, -1., 14., 1., 1.));\n    return col;\n}\n\n// should have written all objects like this \n// (centre at 0,0 then can translate arbitrarily)\nvec3 windowFace(vec2 f, vec3 col, vec3 win) {\n    col = mix(col, mix(win,blue2,.5), box(f, 1., 0., 2., 4.));\n    col = mix(col, mix(win,blue3,.5), box(f, 1., 4., 2., 1.));\n    col = mix(col, brown2, box(f, 0., 0., 1., 4.) +\n                           box(f, 2., -1., 1., 1.));\n    col = mix(col, brown4, box(f, -1., -2., 4., 1.));\n    return col;\n}\n\nvec3 windowsFace(vec2 f, vec3 col, vec3 win) {\n    col = windowFace(f - vec2(5,5), col, win);\n    col = windowFace(f - vec2(-6,5), col, win);\n    return col;\n}\n\nvec3 door(vec2 f, vec3 col) {\n    col = mix(col, brown4, box(f, 0., 0., 3., 9.));\n    col = mix(col, brown5, box(f, 0., 9., 3., 1.));\n    col = mix(col, brown2, box(f, -1., 0., 1., 9.));\n    return col;\n}\n\nvec3 chimney(vec2 f, vec3 col) {\n    col = mix(col, brown1, box(f, w+5., w+h+5., 4., 10.));\n    col = mix(col, brown3, step(2.*w+h+2.*5.-1.-f.y, f.x) *\n                           box(f, w + 1., w+h+5., 4., 10.));   \n    col = mix(col, brown0, box(f, w+5., w+h+14., 4., 1.));\n    col = mix(col, brown2, box(f, w+1., w+h+14., 4., 1.));\n    col = mix(col, blue2, rhom(f, w-2., w+h+5., 4., 3., -1.));\n    col = mix(col, brown4, box(f, w+1., w+h+11.,2.,1.) +\n                           box(f, w+4., w+h+11.,1.,1.));\n    col = mix(col, brown2, box(f, w+5., w+h+11.,1.,1.) +\n                           box(f, w+7., w+h+11.,2.,1.) +\n                           box(f, w+6., w+h+9.,2.,1.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(130,161,124)/255.;\n    float t = iTime;\n    vec2 res = iResolution.xy;   \n    vec2 uv = (fragCoord - 0.5 * res) / res.y;\n    float sc = 52.;\n    vec2 f = round(sc * uv) - 0.;\n    f.x += 7.;\n    f.y += floor(0.5*sc);  \n    \n    float fr = getFreq_smooth(0.);\n   \n    // song is 126 BPM, hacky way of matching it (probably incorrect!)\n    float t2 = 0.5*pi*125.9/60.*t;\n    float th = step(9.*pi, t2); //round(8.*tanh(0.1 * max(0., t-8.))) / 8.;\n    float i1 = round(th*(5. + 5. * thc(10., t2)));\n    float i2 = round(th*(5. + 5. * thc(10., t2 + 0.5*pi)));\n\n    w = 9. + i1;\n    h = 15. + i2 - w;\n       \n    // roof width\n    w2 = 15. + i2 + 3. + 2.;\n\n    vec3 win = .6 + .4 * cos(2.*pi*(uv.y/5.+.1*t+2.*fr+vec3(0,1,2)/3.));\n    \n    col = face(f, col);\n    col = roof(f, col);\n    col = trim(f, col);\n    col = side(f, col);\n    col = windowSide(f, col, win);\n    col = windowTop(f, col, win);\n    col = windowsFace(f, col, win);    \n    col = door(f, col);\n    col = chimney(f, col);\n     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31740, "src": "https://soundcloud.com/sonxc/cant-get-you-out-of-my-head-playing-from-another-room?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mll3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 482, 506, 506, 572], [574, 574, 605, 605, 766], [796, 822, 886, 886, 996], [998, 1033, 1107, 1107, 1249], [1251, 1251, 1280, 1280, 1426], [1428, 1428, 1457, 1457, 1523], [1525, 1525, 1554, 1554, 1878], [1880, 1880, 1909, 1909, 2038], [2040, 2040, 2085, 2085, 2506], [2508, 2508, 2552, 2552, 2879], [2881, 2977, 3022, 3022, 3325], [3327, 3327, 3373, 3373, 3486], [3488, 3488, 3517, 3517, 3692], [3694, 3694, 3726, 3726, 4392], [4394, 4394, 4451, 4451, 5495]], "test": "untested"}
{"id": "mts3zf", "name": "Turbulent Seas", "author": "jarble", "description": "A variant of David Hoskins' \"Rough Seas\" shader with a more dynamic wave animation.", "tags": ["3d", "raymarch", "sound", "sea", "rough"], "likes": 21, "viewed": 531, "published": 3, "date": "1672191513", "time_retrieved": "2024-07-30T16:10:37.491234", "image_code": "// Rough Seas, by Dave Hoskins.\n// https://www.shadertoy.com/view/dtXGW4\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n#define FAR 1000.\n#define FOG_COLOUR vec3(.4,.4,.5)\n#define SKY_TOP vec3(.2, 0.21, 0.26)\n\nvec3 camPos;\nfloat time;\nvec3 skyColour;\nconst vec3 sunDir = normalize(vec3(4,8,18));\n\n//------------------------------------------------------------------------------\n// Hashes from here: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Pretty basic smoothed noise...\n//------------------------------------------------------------------------------\nfloat noise2D(in vec2 p)\n{\n\treturn (sin(p.x)+cos(p.y))/2.;\n}\n\nfloat noise3D(in vec3 p)\n{\n    const vec2 add = vec2(1.0, 0.0);\n\n    vec3 f = fract(p); \n    f *= f * (3.0-2.0*f);\n    p = floor(p);\n\n    float h = mix(\n                    mix(mix(hash13(p), hash13(p + add.xyy),f.x),\n                        mix(hash13(p + add.yxy), hash13(p + add.xxy),f.x), f.y),\n                    mix(mix(hash13(p + add.yyx), hash13(p + add.xyx),f.x),\n                        mix(hash13(p + add.yxx), hash13(p + add.xxx),f.x), f.y),\n                 f.z);\n    return h*h*h*2.;\n}\n\n\n//------------------------------------------------------------------------------\n// A very basic sky...\nvec3 sky(vec3 dir)\n{\n \n    return mix(FOG_COLOUR, SKY_TOP ,abs(dir.y)*1.7);\n}\n\n//-----------------------------------------------------------------\n// This creates the sea, it's complexity is governed by the incoming iteration count...\nconst float COSR = cos(.43);\nconst float SINR = sin(.52);\nconst mat2 rot2D = mat2(COSR, SINR, -SINR, COSR) * 1.4;\nfloat oceanFundamental(vec2 p, float d, float tim, float iter)\n{\n    float a =noise2D(p*.01)*8.+3.0;\n    float h = 0.0;\n    float it = 1./iter;\n    float spr = 0.0;\n    p.x -= tim*5.0;\n\n    p *= .025;// ...Scale it\n\n    for (float i = 0.0; i <= 1.0; i += it)\n    {\n        float t = (2.-i) * tim*.5;\n        float r =noise2D(p*2.1) * i;\n        vec2 y1 = (cos(p-t)+1.0);\n        vec2 y2 = (1.0-abs(sin(p-t)));\n        \n        y1 = mix(y1, y2, r);\n          \n        float s = y1.x + y1.y;\n        \n        h += s*a;\n        \n        a *= .59;\n        p = p * rot2D;\n        p += 19.9+r/2.+iTime/2.;\n    }\n\n    return h;\n}\n\n// Map the ocean relative to the point...\n//-----------------------------------------------------------------\nfloat map(in vec3 p, in float d, float iter)\n{\n    float h = oceanFundamental(p.xz, d, time, iter);\n    return p.y-h;\n}\n\n// Bog standard ray marching, there's so much noise that any misses get lost...🤞\n//-----------------------------------------------------------------\nvec2 rayMarch(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    float spr = 0.0;\n    for ( int i = 0; i < 120; i++)\n    {\n        vec3 pos = p + dir*d;\n\n        float hh = oceanFundamental(pos.xz, d, time, 7.);\n        float h = pos.y-hh;\n        \n        if (h < 0.1 || d > FAR)\n        {\n            break;\n        }\n        float wind = noise3D(pos*.08) * noise3D(pos*3.5+vec3(0, time*h*.1,0));\n        spr += max(20.-h, 0.0) * smoothstep(20.0, .0,max(h, 0.0))*smoothstep(FAR, 150.0,d)*smoothstep(30., 80.0, hh)\n        * wind;\n\n\n        //if (h < 0.0) h *= .5;\n        d+= h*.7;\n    }\n    return vec2(d, min(spr*.03, 1.0));\n}\n\n//------------------------------------------------------------------------------\n// Get a view of pixel using Euler...\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//------------------------------------------------------------------------------\n\n// I forgot where this came from, it using a higher iteration than the ray march...\nvec3 normal(vec3 pos, float ds)\n{\n    ds *= 2./iResolution.y;\n    ds = max(ds*ds, .1);\n\n    float c = map(pos, 0., 14.);\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0, 14.),\n                          map(pos + eps_zero.yxy, 0.0, 14.),\n                          map(pos + eps_zero.yyx, 0.0, 14.)) - c);\n}\n\n//------------------------------------------------------------------------------\n\n// I was using my 2 tweet water caustic here,\n// but some compilers opimized it broken with the rest of the code\n// So I opted for a basic voronoi cell thing...\nfloat waterPattern(vec2 p)\n{\n    p *=.02;\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float wp = 1e10;\n    for (int i = -1;i<=1;i++)\n    {\n        for (int j = -1;j<=1;j++)\n        {\n            vec2 g = vec2(i, j);\n            vec2 o = hash22(n+g);\n            \n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d < wp)\n            {\n                wp = d;\n            }\n        }\n    }\n    return pow(wp, 3.5);\n}\n\n\n//------------------------------------------------------------------------------\nfloat waveDepth(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    for( float i = 3.0; i < 25.0; i+=5.)\n    {\n        float h = map(p + dir*i, i, 7.);\n        if (h > 0.) break;\n        d += -h;\n    }\n    return clamp(1.0-d*.02, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 lighting(vec3 pos, vec3 nor, in vec3 dir,in vec3 mat)\n{\n    vec3 col;\n    col = mat * max(dot(sunDir, nor), 0.0);\n    vec3 ref = reflect(dir, nor);\n    float fres = clamp(pow( 1.+dot(nor, dir), 5. ), 0.0, 1.0);\n    col = mix(col, sky(nor), .3);\n    col = mix(col, sky(ref), fres);\n    return col;\n}\n\n//------------------------------------------------------------------------------\nvec3 diffuse(in vec3 pos, in vec3 nor, in float dep)\n{\n    pos.x -= time*1.8;\n    vec3 mat = vec3(.1,.2,.4);\n    float h = smoothstep(0., 1.0,nor.y);\n    \n    mat += h*.1;\n\n    mat = mix(mat, vec3(.4,.8,.7), dep);\n\n\n    // Add different frequencies of voronoi cells...\n    float foam = waterPattern(pos.xz*vec2(.5,1.)+99.)*15.;\n    foam += waterPattern(pos.xz*3.63)*10.;\n    foam += waterPattern(pos.xz*12.)*3.;\n    \n    foam = clamp(foam, 0.0, 1.0);\n    \n\n    mat = mat+foam * dep*dep*3.;\n\n    return mat;\n}\n\n//------------------------------------------------------------------------------\n// Exponential fader...\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 outCol, in vec2 coord )\n{\n    // Take into account non-square viewport to keep aspect ratio of shapes..\n    // Zero in centre and .5 at the max Ys\n    vec2 uv = (coord-iResolution.xy*.5)/iResolution.y;\n\n    vec2 mouse = vec2(0);\n    if (iMouse.z > 0.) mouse = (iMouse.xy-iResolution.xy*.5) /iResolution.y;\n    \n\n    vec3 colour = vec3(0);\n    // Find a good point in time with time blurring for the top of the display...\n    float f = coord.y/iResolution.y;\n    time = iTime+10.;\n\n    // Set colour to zero then call the rayMarcher to get distant object...\n\n    camPos = vec3(time*.01,100,0);\n    float h = (sin(time*.65)+1.0)*40.+ 10.;\n\n    float oce = 0.0;\n\n    // Bounce along the average wave height for a set time...\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        oce += oceanFundamental(camPos.xz, 0.0, time + i, 7.0);\n    }\n    oce = (oce / 4.0)+140.0;\n    oce= h-oce;\n    if (oce < 0.0)\n    {\n        // Don't lock any movement - it's the sea!\n        h = h+pow(-oce, .3)*4.;\n    }\n\n\n    // Setup camera...\n    vec3 col;\n    vec3 dir  = vec3(0,0, 1.);\n    dir = viewMat (uv.y -.3, uv.x-2.+time*.25 + mouse.x*6.28) * dir;\n\n    camPos.y = h;\n    vec2 dis = rayMarch(camPos, dir);\n\n\n    if (dis.x < FAR)\n    {\n        // The position is the start position plus the normalised direction X distance...\n        vec3  pos = camPos + dir * dis.x; // ...wave hit position\n        vec3  nor = normal(pos, dis.x);   // ... Normal\n         // The depth of the wave in forward direction, it's simple but effective in helping the water transparent effect...\n        float dep = waveDepth(pos+dir*.3, dir);\n        vec3  mat = diffuse(pos, nor, dep);\n\n        col = lighting(pos, nor, dir, mat);\n        col = mix(col, FOG_COLOUR, smoothstep(250.0, FAR, dis.x));\n    }else\n    {\n        col = sky(dir);\n    }\n    colour += col;\n\n\n    colour = mix(col, vec3(.55,.56,.59),dis.y);\n\n    // Some adjustment..\n    colour = colour*.5 + smoothstep(0.0, 1.0, colour)*.5;\n    \n    vec2 xy = coord/iResolution.xy;\n    colour *= 0.5 + .5*pow( 80.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .5);  // ...Vignette.\n    outCol = vec4(fader(0.0, 4.0, iTime)*sqrt(colour), 1);\n}\n\n//-----------------------------------------------------------------\n", "image_inputs": [], "sound_code": "\n\n// Rough Seas, by Dave Hoskins.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n\nvec2 noise2D(in float p)\n{\n\tfloat f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 res = mix(hash21(p), hash21(p + 1.0), f);\n    return res-.5;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v, aud;\n    float t= time;\n    \n    \n    // Add vary volumes of different frequencies...\n    v = noise2D(t*.6)*.5+.5;\n    aud = noise2D(t*320.) * v;\n    \n    v = noise2D(t*.3)*.8+.2;\n    aud += noise2D(t*800.)*v;\n\n    v = noise2D(t*.3)*.8;\n    aud += noise2D(t*1900.)*v;\n\n\n    v = (noise2D(-t*.4)+noise2D(-t*.3))*.3;\n    aud += noise2D(t*4400.)*v;\n\n    v = (noise2D(t*.7) +noise2D(t*.22))*.2;\n    aud += noise2D(t*10200.)*v;\n\n\n    aud = clamp(aud, -1.0, 1.0) * fader(.0, 1.0,time) * fader(180.0, 170.0,time);\n    \n    return aud;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3zf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[367, 507, 529, 529, 646], [647, 647, 668, 668, 801], [803, 803, 826, 826, 929], [932, 1047, 1073, 1073, 1107], [1109, 1109, 1135, 1135, 1609], [1612, 1716, 1736, 1736, 1793], [2065, 2065, 2129, 2129, 2687], [2689, 2799, 2845, 2845, 2918], [2920, 3072, 3105, 3105, 3694], [3696, 3815, 3850, 3850, 4048], [4132, 4216, 4249, 4249, 4562], [4646, 4807, 4835, 4835, 5259], [5262, 5343, 5378, 5378, 5576], [5578, 5659, 5719, 5719, 5962], [5964, 6045, 6099, 6099, 6553], [6555, 6660, 6708, 6708, 6809], [6811, 6892, 6942, 7063, 9066]], "test": "untested"}
{"id": "mls3Rf", "name": "Minimalist clock", "author": "fishy", "description": "Clock constructed with distance fields. sdOrientedBox and the smoothMax functions are by @iq and the blackbody function is by @FabriceNeyret2 (modified by me). Simple design now (and loopless!)", "tags": ["time", "sdf", "clock"], "likes": 9, "viewed": 225, "published": 3, "date": "1672189113", "time_retrieved": "2024-07-30T16:10:38.250205", "image_code": "#define PI 3.141592653\n#define date (iDate * 1.)\n\n#define rot(t) mat2(cos(t), -sin(t), sin(t), cos(t))\n\nfloat join(float d1, float d2) { return min(d1, d2); }\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th ) // Made by iq\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdDisk(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdDiskOutline(vec2 p, float r1, float r2)\n{\n    return abs(length(p) - r1) - r2*0.5;\n}\n\nfloat sdRotatedLine(vec2 p, vec2 start, float offset, float len, float theta, float thick)\n{\n    return sdOrientedBox(p, start + vec2(sin(theta), cos(theta)) * offset, vec2(sin(theta), cos(theta)) * (len + offset), thick);\n}\n\nvec2 radialArray(vec2 p, float r)\n{\n    float t = mod(atan(p.y, p.x), 2.*PI/r)+(r/2.-1.)*PI/r;\n    return vec2(cos(t), sin(t))*length(p);\n}\n\nfloat sd(vec2 p)\n{\n    float seconds = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.15, (floor(date.w)/60.0)*2.0*PI, 0.005);\n    float minutes = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.1, (date.w/60.0/60.0)*2.0*PI, 0.005);\n    float hours = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.06, (date.w/60.0/60.0/12.0)*2.0*PI, 0.005);\n    float centerDisk = sdDisk(p, 0.0025);\n    float outerCircle = sdDiskOutline(p, 0.22, 0.005);\n    \n    float ticks = 1000000.0;\n    ticks = join(ticks, sdRotatedLine(radialArray(p*rot(PI/60.),60.), vec2(0.0, 0.0), 0.2, 0.01, 0., 0.0025));\n    ticks = join(ticks, sdRotatedLine(radialArray(p*rot(PI/12.),12.), vec2(0.0, 0.0), 0.18, 0.03, 0., 0.005));\n    \n    return join(join(join(join(join(seconds, minutes), hours), centerDisk), outerCircle), ticks);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*0.5;\n    \n    float px = 0.5/iResolution.y;\n    vec4 col = vec4(smoothstep(px, -px, sd(uv)));\n    fragColor = col;\n    //fragColor = vec4(radialArray(uv, PI*1.), 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mls3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 136, 136, 158], [160, 160, 240, 240, 457], [459, 459, 490, 490, 518], [520, 520, 569, 569, 612], [614, 614, 706, 706, 838], [840, 840, 875, 875, 979], [981, 981, 999, 999, 1758], [1760, 1760, 1817, 1817, 2051]], "test": "untested"}
{"id": "dtlGzf", "name": "A pear", "author": "chengsun", "description": "3D modelling / raymarching practice", "tags": ["3d"], "likes": 23, "viewed": 227, "published": 3, "date": "1672186501", "time_retrieved": "2024-07-30T16:10:39.178722", "image_code": "/* A pear: a study on the basics of distance-field modelling, and raymarched\n * rendering.\n *\n * I'm reasonably happy with how things turned out here, for my first serious\n * attempt at modelling a nontrivial 3D object. Things to think about for next\n * time:\n *\n * - The noise/hash as used on the texture of the pear body isn't great. The\n *   current implementation was lifted directly from another shader, and then\n *   left pretty much untweaked because it looked \"good enough\". We could get\n *   away with a cheaper implementation and/or one that has fewer artifacts.\n *\n * - Play around with the difference between small-scale distance field\n *   displacement and bump-mapping, for subtle surface qualities. I used a mix\n *   of the two here; could I have gotten away with the latter for everything?\n *   It seems likely to be considerably cheaper. How much \"worse\" is it?\n *\n * - Figure out how texture mapping / UV coordinates are meant to work. This\n *   time I simply gave up on UV mapping and simply used the 3D coordinates in\n *   model space. I'm not convinced this method is very good. It certainly\n *   doesn't if I want to animate the model at all.\n *\n * - Learn and use a more realistic reflection model -- I used Blinn-Phong\n *   because it's all I know.\n *\n * - Work on making the background more appealing. The current background is\n *   both very expensive and very boring: the backdrop casts full-blown\n *   lighting/shadow rays for very little visual gain.\n *\n * - Try animating the model, or at least making the object do something a bit\n *   more stylish than simply rotating in place.\n *\n * - Working in a linear colour space (gamma-corrected and tonemapped) from the\n *   beginning made both very easy. iq's article was super helpful here:\n *   https://iquilezles.org/articles/outdoorslighting/\n *   Debanding was added afterwards and was also super easy. But, I need to\n *   figure out some sort of antialiasing for next time (I couldn't get\n *   supersampling to work properly here; I probably did something wrong).\n */\n\n#define ZERO (min(iFrame, 0))\n\n// polynomial smooth min\n// https://iquilezles.org/articles/smin/\nfloat smin(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.) / k;\n    return min(d1, d2) - h * h * k * 0.25;\n}\n\n// cubic pulse\n// https://iquilezles.org/articles/functions/\nfloat pulse(float c, float w, float x) {\n    x = abs(x - c);\n    if(x > w) return 0.;\n    x /= w;\n    return 1. - x * x * (3. - 2. * x);\n}\n\nmat2 rotationMatrix(float th) {\n    return mat2(cos(th), -sin(th), sin(th), cos(th));\n}\n\n// SDF primitives\n// https://iquilezles.org/articles/distfunctions/\n//\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s;\n}\n\nfloat sdVerticalCapsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0., h);\n    return length(p) - r;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  // sampling independent computations (only depend on shape)\n  float b = (r1 - r2) / h;\n  float a = sqrt(1. - b * b);\n\n  // sampling dependant computations\n  vec2 q = vec2(length(p.xz), p.y);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.) return length(q) - r1;\n  if (k > a*h) return length(q - vec2(0., h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\n// distance fields\n\nfloat mapStalk(vec3 pp) {\n    float dd;\n\n    // main stalk\n    {\n        vec3 p = pp;\n        p.xy = rotationMatrix(0.11) * p.xy;\n        p.yz = rotationMatrix(-0.04) * p.yz;\n\n        // bend a bit\n        p.xz -= vec2(-0.16, -0.06)*smoothstep(0.3, 1.3, p.y);\n\n        dd = sdVerticalCapsule(p, 0.6, 0.1);\n    }\n\n    // knobbly tip\n    {\n        vec3 p = pp - vec3(-0.18, 0.75, -0.12);\n        p.yz = rotationMatrix(-0.4) * p.yz;\n\n        float d = sdRoundBox(p, vec3(0.03), 0.06);\n\n        // displacement for roughness where the stalk was cut\n        float displacement = 0.01 * sin(110. * pp.x) * sin(110. * pp.y) * sin(110.*pp.z);\n        d += displacement*smoothstep(0.1, -0.2, p.x);\n\n        dd = smin(dd, d, 0.16);\n    }\n\n    return dd;\n}\n\nvec2 map(vec3 pp, out vec3 uv) {\n    float dd = 100.;\n    float material = 0.;\n\n    // rotate model with time\n    pp.xz = rotationMatrix(-iTime) * pp.xz;\n\n    uv = pp;\n\n    // base\n    {\n        vec3 p = pp - vec3(0., -3.58, 0.);\n\n        // flatten the base a bit\n        vec3 v = pow(p, vec3(4.)) - vec3(0., 0.24, 0.);\n        p = sign(v) * pow(abs(v), vec3(.25)) - vec3(0., 1.75, 0.);\n\n        dd = sdSphere(p, 1.18);\n    }\n\n    // neck\n    {\n        vec3 p = pp - vec3(-0.2, -0.8, 0.);\n        p.xy = rotationMatrix(0.22) * p.xy;\n\n        // bend neck a bit\n        p.z -= 0.26 * smoothstep(0.1, 2.8, p.y);\n\n        // carve a little saddle into the top\n        p.y += 0.05 * pulse(0., 0.2, p.x);\n\n        float d = sdRoundCone(p, 0.77, 0.4, 2.);\n\n        dd = smin(dd, d, 0.65);\n    }\n\n\n    // stalk\n    {\n        vec3 p = pp - vec3(-0.7, 1.5, 0.24);\n        float d = mapStalk(p);\n\n        if (dd > d) {\n            dd = d;\n            material = 1.;\n        }\n    }\n\n    return vec2(dd, material);\n}\n\nfloat map(vec3 pp) {\n    vec3 uv = vec3(0.);\n    return map(pp, uv).x;\n}\n\n// ACES tonemap\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 aces(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// Noise\n// https://iquilezles.org/articles/morenoise\n// This particular code from \"Rainforest - iq\"\n// https://www.shadertoy.com/view/4ttSWf\n\nfloat hash1(float n) {\n    return fract(n * 17. * fract(n * 0.3183099));\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n\n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n    float f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nfloat fbm(in vec3 x) {\n    float result = 0.;\n    for (int i = ZERO; i <= 3; ++i) {\n        result += noise(x);\n        x = 3.*x;\n    }\n    return result;\n}\n\n// Raymarch loop\nfloat march(vec3 ro, vec3 rd) {\n    float t = 0.;\n    vec3 p = ro;\n    for (int i = ZERO; i < 32; ++i) {\n        float dt = map(p);\n        t += dt;\n        p = ro + t * rd;\n        if (dt <= 0.01 || t > 20. || p.y < -3.) break;\n    }\n    return t;\n}\n\n// Soft shadows raymarch loop\n// https://iquilezles.org/articles/rmshadows/\nfloat shadow(vec3 ro, vec3 rd) {\n    float t = 0.1;\n    vec3 p = ro + t * rd;\n    float res = 1.0;\n    for (int i = ZERO; i < 16; ++i) {\n        float dt = map(p);\n        t += dt;\n        p = ro + t * rd;\n        res = min(res, 2.*dt/t);\n        if (dt <= 0.01) return 0.;\n        if (t > 20. || p.y < -3.) break;\n    }\n    return res;\n}\n\nvec3 lighting1(vec3 p, vec3 norm, vec3 ro, vec3 matcol, vec3 ld, float specular_factor) {\n    float diffuse = 1. * clamp(dot(norm, ld), 0., 1.);\n    vec3 view = normalize(p - ro);\n    vec3 refl_view = view - 2.*dot(view, norm)*norm;\n    float specular = specular_factor * pow(clamp(dot(refl_view, ld), 0., 1.), 7.);\n\n    return diffuse * matcol + specular;\n}\n\nvec3 lighting(vec3 p, vec3 norm, vec3 ro, vec3 matcol, float specular_factor) {\n    vec3 col = vec3(0.);\n\n    // two strip lights to the left and right\n    for (float lx = float(ZERO)-6.; lx <= 6.; lx += 12.) {\n        int nz = 4;\n        for (int zz = 0; zz < nz; ++zz) {\n            vec3 lo = vec3(lx, 4., mix(-4., 4., float(zz)/float(nz-1)));\n            vec3 ld = normalize(lo - p);\n            float sh = shadow(p, ld);\n\n            col += vec3(4.1 / float(nz)) * sh * lighting1(p, norm, ro, matcol, ld, specular_factor);\n        }\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 scr = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0., 0., -10.);\n    vec3 rd = normalize(vec3(scr*3.4, 0.) - ro);\n\n    float t = march(ro, rd);\n    vec3 p = ro + t * rd;\n    vec3 uv = vec3(0.);\n    vec2 map_result = map(p, uv);\n    float d = map_result.x;\n    float material = map_result.y;\n\n    float groundheight = -2.7;\n    float groundt = (groundheight - ro.y)/rd.y;\n    vec3 groundmatcol = vec3(1., 1., 1.) * 0.4;\n\n    vec3 pearmatcol0 = vec3(0.89, 0.81, 0.3) * 0.15;\n    vec3 pearmatcol1 = vec3(0.75, 0.9, 0.1) * 0.15;\n    vec3 pearmatcol2 = vec3(0.9, 0.5, 0.2) * 0.15;\n\n    vec3 stalkmatcol1 = pearmatcol1 * 0.9;\n    vec3 stalkmatcol2 = vec3(0.65, 0.45, 0.25) * 0.15;\n    vec3 stalkmatcol3 = vec3(0.9, 0.6, 0.6) * 0.055;\n    vec3 stalkmatcol4 = vec3(0.9, 0.8, 0.7) * 0.045;\n\n    vec3 col = vec3(0.);\n    if (groundt >= 0. && length(ro+groundt*rd) <= 10. && (d > 0.01 || groundt < t)) {\n        // ground circle\n        p = ro + groundt * rd;\n        vec3 norm = vec3(0., 1., 0.);\n        float specular_factor = 0.1;\n        col = lighting(p, norm, ro, groundmatcol, specular_factor);\n\n        // pear indirect bounce -- very subtle\n        col += 0.5*mix(pearmatcol1, pearmatcol2, 0.2) * lighting1(p, norm, ro, groundmatcol, normalize(vec3(0.)-p), specular_factor);\n    } else if (d <= 0.01) {\n        // pear\n        vec3 norm = vec3(0.);\n        vec2 eps = vec2(0.0001, 0.);\n        norm = vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                    map(p + eps.yxy) - map(p - eps.yxy),\n                    map(p + eps.yyx) - map(p - eps.yyx));\n\n        vec3 matcol;\n        float specular_factor;\n        if (material < 0.5) {\n            // fruit body\n            matcol = mix(pearmatcol0, pearmatcol1, smoothstep(-2., 0., uv.y - 0.2*abs(uv.x) + 0.4*abs(uv.z)));\n            matcol = mix(matcol, pearmatcol2, clamp(fbm(uv), 0., 1.));\n            specular_factor = 0.08;\n\n            // bumpmap\n            norm += noise((uv+vec3(1.,2.,-1.))*vec3(100.,30.,100.))*0.00001;\n            norm = normalize(norm);\n        } else {\n            // stalk\n            matcol = mix(stalkmatcol1, stalkmatcol2, clamp(smoothstep(1.5, 1.8, uv.y) + 0.6*pow(fbm(uv*20.*vec3(0.7,0.2,0.7)),3.), 0., 1.));\n            matcol = mix(matcol, stalkmatcol3, clamp(fract(2.8*cos(1.4+15.*uv.x+sin(0.3+31.*uv.z))+cos(5.2*uv.y+0.8))+smoothstep(1.6, 2.3, uv.y-uv.z*0.6)-0.89, 0., 1.));\n\n            float cut_factor = smoothstep(0.09, 0.03, uv.z);\n            matcol = mix(matcol, stalkmatcol4, cut_factor);\n            specular_factor = mix(0.01, 0.08, cut_factor);\n\n            // bumpmap\n            norm += noise((uv+vec3(1.,2.,-1.))*vec3(70.,10.,70.))*0.00009;\n            norm = normalize(norm);\n        }\n\n        // lights\n        col += lighting(p, norm, ro, matcol, specular_factor);\n\n        // ground indirect bounce\n        vec3 ld = vec3(0., -1., 0.);\n\n        float occlusion = mix(0.4, 1., smoothstep(-2.65, -2.4, p.y));\n\n        float sh = clamp(shadow(p, ld) * occlusion, 0., 1.);\n        col += groundmatcol * sh * matcol * pow(clamp(dot(norm, vec3(0., -1., 0.)), 0., 1.), 0.5);\n    } else {\n        // walls\n        float specular_factor = 0.1;\n        p = ro + 20. * rd;\n        col = lighting(p, normalize(p - ro), ro, groundmatcol, specular_factor);\n    }\n\n    // tonemapping, gamma correction, debanding\n    col = aces(col);\n    col = pow(col, vec3(0.4545));\n    col += vec3(noise(vec3(fragCoord.xyy))) / 256.;\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2081, 2147, 2188, 2188, 2278], [2280, 2341, 2381, 2381, 2479], [2481, 2481, 2512, 2512, 2568], [2570, 2641, 2674, 2674, 2700], [2702, 2702, 2753, 2753, 2811], [2813, 2813, 2856, 2856, 2953], [2955, 2955, 3011, 3073, 3362], [3384, 3384, 3409, 3409, 4129], [4131, 4131, 4163, 4163, 5137], [5139, 5139, 5159, 5159, 5211], [5213, 5308, 5327, 5327, 5530], [5675, 5675, 5697, 5697, 5749], [5751, 5751, 5775, 5775, 6494], [6496, 6496, 6518, 6518, 6652], [6654, 6671, 6702, 6702, 6921], [6923, 6999, 7031, 7031, 7337], [7339, 7339, 7428, 7428, 7697], [7699, 7699, 7778, 7778, 8259], [8261, 8261, 8316, 8316, 11805]], "test": "untested"}
{"id": "mts3Rf", "name": "Soothing Circles", "author": "fishy", "description": "This is sort of soothing to me and I couldn't think of a better name", "tags": ["circles"], "likes": 2, "viewed": 174, "published": 3, "date": "1672185078", "time_retrieved": "2024-07-30T16:10:39.918744", "image_code": "float circles(vec2 p, float px, float time)\n{\n    float sum = 0.;\n    for(float i = -2.01; i <= 2.; i++) // An artifact appears if i is initialized at -2 instead of -2.01\n    {\n        float currentCircle = floor(p.x+i);\n        float circleSize = 1.2+0.2*sin(currentCircle*0.5+time);\n        sum += smoothstep(px, -px, distance(p, vec2(currentCircle, 0))-circleSize);\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    vec3 col = ((circles((vec2(uv.x*sign(uv.y), abs(uv.y))-vec2(0, 1))*6., 6./iResolution.y, iTime*0.5)*0.2)+0.1)*vec3(1);\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 392], [394, 394, 451, 451, 670]], "test": "untested"}
{"id": "mll3RX", "name": "Jean Claude van Dice", "author": "fenix", "description": "Everyone's favorite action hero rendered using a dice mosaic style.", "tags": ["mosaic", "dice"], "likes": 11, "viewed": 292, "published": 3, "date": "1672177415", "time_retrieved": "2024-07-30T16:10:40.687687", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Everyone's favorite action hero rendered using a dice mosaic style.\n//\n// ---------------------------------------------------------------------------------------\n\n#define RES 50.\n#define pip(X, Y) smoothstep(.1 + RES / iResolution.y, .1, length(p - vec2(X, Y)))\n\nfloat die(vec2 p, int pips)\n{\n    if (pips == 1) { return pip(0, 0); }\n    if (pips == 2) { return max(pip(-.25, -.25), pip(.25, .25)); }\n    if (pips == 3) { return max(max(pip(-.3, -.3), pip(0, 0)), pip(.3, .3)); }\n    if (pips == 4) { return max(max(max(pip(-.25, -.25),pip(.25, -.25)), pip(.25, .25)), pip(-.25, .25)); }\n    if (pips == 5) { return max(max(max(max(pip(-.3, -.3),pip(.3, -.3)),pip(0, 0)), pip(.3, .3)), pip(-.3, .3)); }\n    if (pips == 6) { return max(max(max(max(max(pip(-.25, -.3),pip(.25, -.3)),pip(.25, 0)),pip(-.25, 0)), pip(.25, .3)), pip(-.25, .3)); }\n    return 0.;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = U / R.y;\n    \n    vec2 m = fract(u * RES) - .5;\n    float o = texture(iChannel0, vec2(R.y / R.x, 1) * trunc(u * RES) / RES).r;\n    O = vec4(die(m, int(o * 6.)));\n}\n", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mll3RX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[476, 476, 505, 505, 1071], [1073, 1073, 1111, 1111, 1317]], "test": "untested"}
{"id": "dls3RX", "name": "StickMan - 2d Raytracing", "author": "SONENEIS", "description": "nothing here.", "tags": ["raytracing", "reflection", "ray", "sun", "cloud", "circle", "raytrace", "square", "pink", "ball", "box", "tracing", "ground", "rect", "dark", "man", "magenta", "stick", "stickman", "ref"], "likes": 6, "viewed": 263, "published": 3, "date": "1672175595", "time_retrieved": "2024-07-30T16:10:41.429703", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\n//--------------------- scene ---------------------//\n\n#define CircsLen 7\n#define RectsLen 10\n\nstruct Circ{\n\tvec2 pos;\n  float rad;\n} [CircsLen] circs;\n\nstruct Rect{\n\tvec2 pos;\n  vec2 size;\n  float ang;\n  vec2 axis;\n} [RectsLen] rects;\n\nvoid initScene(){\n\t//stick man\n\tcircs[0] = Circ(vec2(0.0,0.05),0.1);\n\trects[0] = Rect(vec2(0.0,-0.1),vec2(0.02,0.25),0.0,vec2(0));\n\trects[1] = Rect(vec2(0.0,0.14-0.2),vec2(0.1,0.02),0.5,vec2(0.1,0.0));\n\trects[2] = Rect(vec2(0.0,0.14-0.2),vec2(0.1,0.02),3.14-0.5,vec2(0.1,0.0));\n\trects[3] = Rect(vec2(0.0,-0.34),vec2(0.1,0.02),0.9,vec2(0.1,0.0));\n\trects[4] = Rect(vec2(0.0,-0.34),vec2(0.1,0.02),3.14-0.9,vec2(0.1,0.0));\n\tcircs[5] = Circ(vec2(0.18,0.04-0.2),0.02);\n\tcircs[6] = Circ(vec2(-0.18,0.04-0.2),0.02);\n\t\n\t//sun\n\tcircs[1] = Circ(vec2(0.3,0.4),0.05);\n\trects[6] = Rect(vec2(0.3,0.4),vec2(0.085,0.005),0.0,vec2(0));\n\trects[7] = Rect(vec2(0.3,0.4),vec2(0.005,0.085),0.0,vec2(0));\n\trects[8] = Rect(vec2(0.3,0.4),vec2(0.005,0.085),0.8,vec2(0));\n\trects[9] = Rect(vec2(0.3,0.4),vec2(0.085,0.005),0.8,vec2(0));\n\t\n\t//cloud\n\tcircs[2] = Circ(vec2(-0.2,0.3),0.09);\n\tcircs[3] = Circ(vec2(-0.1,0.3),0.045);\n\tcircs[4] = Circ(vec2(-0.3,0.3),0.05);\n\t\n\t//ground\n\trects[5] = Rect(vec2(0.0,-0.78),vec2(10.0,0.3),0.0,vec2(0));\n}\n\n//--------------- 2d primitive sdfs ---------------//\n\n#define sdf(c,s) mix(col,c,smoothstep(3.0/iResolution.y,0.0,s))\n#define sdf1(c,s) (c * clamp(smoothstep(3.0/iResolution.y,0.0,s),0.0,1.0))\n\nfloat sdCirc(vec2 p,float r){\n\treturn length(p) - r;\n}\n\nfloat sdRect(vec2 p,vec2 b){\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdLine(vec2 p,float r,vec2 v1,vec2 v2){\n\tvec2 a = p - v1, b = v2 - v1;\n\tfloat h = clamp(dot(a,b)/dot(b,b),0.0,1.0);\n\treturn length(a - b*h) - r;\n}\n\n//------------------- raytracing ------------------//\n\nstruct Ray{\n\tvec2 ro;\n\tvec2 rd;\n};\n\nvec3 iUn(vec3 a,vec3 b){\n\treturn b.z > 0.0 && b.z < a.z ? b : a;\n}\n\nvec3 iCirc(vec2 ro,vec2 rd,float r){\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n\tfloat h = b*b - c;\n\tfloat t = -b - sqrt(h);\n\tif(h < 0.0) return vec3(0,0,-1);\n\tvec2 nor = (ro+rd*t)/r;\n\treturn vec3(nor,t);\n}\n\nvec3 iRect(vec2 ro,vec2 rd,vec2 b){\n\tvec2 m = 1.0/rd;\n\tvec2 n = ro*m;\n\tvec2 k = abs(m) * b;\n\tvec2 t1 = -n - k;\n\tvec2 t2 = -n + k;\n\tfloat tN = max(t1.x,t1.y);\n\tfloat tF = min(t2.x,t2.y);\n\tfloat t = tN;\n\tif(tN > tF || tF < 0.0) return vec3(0,0,-1);\n\tvec2 nor = tN > 0.0 ? step(vec2(tN),t1) : step(t2,vec2(tF));\n\tnor *= sign(-rd);\n\treturn vec3(nor,t);\n}\n\n//xy: surface normal\n//z: scene sdf\n//w: t (I do not know what it means)\nvec4 raytrace(vec2 p,Ray ray){\n\tvec4 hit = vec4(0,0,999999999999.9,999999999999.9);\n\t\n\tfor(int i=0;i<CircsLen;i++){\n\t\tCirc h = circs[i];\n\t\thit.xyw = iUn(hit.xyw,iCirc(ray.ro-h.pos,ray.rd,h.rad));\n\t\thit.z = min(hit.z,sdCirc(p-h.pos,h.rad));\n\t}\n\n\tfor(int i=0;i<RectsLen;i++){\n\t\tRect h = rects[i];\n\t\tvec2 ro = (ray.ro - h.pos) * rot(h.ang) - h.axis;\n\t\tvec2 rd = ray.rd * rot(h.ang);\n\t\tvec3 inter = iRect(ro,rd,h.size);\n\t\tinter.xy *= rot(-h.ang);\n\t\thit.xyw = iUn(hit.xyw,inter);\n\t\thit.z = min(hit.z,sdRect((p-h.pos)*rot(h.ang)-h.axis,h.size));\n\t}\n\t\n\treturn hit;\n}\n\n//------------------- main loop -------------------//\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = 0.8*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mo = 0.8*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.06);\n  \n  initScene();\n  \n  Ray ray;\n  ray.ro = mo;\n  ray.rd = normalize(vec2(0,1)) * rot(iTime*0.25);\n  vec4 hit = raytrace(uv,ray);\n  vec2 pos = ray.ro + ray.rd*hit.w;\n  vec2 nor = hit.xy;\n  \n  //draw scene\n  col = sdf(vec3(1,0,0.5),hit.z);\n  \n  // draw rays //\n  //main ray\n  //col += sdf1(vec3(0.2),sdLine(uv,0.0025,ray.ro,pos));\n  col += sdf1(vec3(0.2),sdCirc(uv-ray.ro,0.015));\n  //normal ray\n  //col += sdf1(vec3(0,1,0.5),sdLine(uv,0.005,pos,pos+nor*0.1));\n  \n  for(int i=1;i<6;i++){\n    hit = raytrace(uv,ray);\n    pos = ray.ro + ray.rd*hit.w;\n    nor = hit.xy;\n    col += sdf1(vec3(1.0/float(i*2)),sdLine(uv,0.0025,ray.ro,pos));\n    ray.ro = pos;\n    ray.rd = reflect(ray.rd,nor);\n  }\n  \n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dls3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [300, 300, 317, 330, 1311], [1508, 1508, 1537, 1537, 1562], [1564, 1564, 1592, 1592, 1668], [1670, 1670, 1715, 1715, 1822], [1915, 1915, 1939, 1939, 1981], [1983, 1983, 2019, 2019, 2198], [2200, 2200, 2235, 2235, 2550], [2552, 2625, 2655, 2655, 3184], [3241, 3241, 3291, 3291, 4163]], "test": "untested"}
{"id": "Dtf3zX", "name": "Hammertime [zenta2022]", "author": "robin_be", "description": "My entry for the animation compo of the Zenta 2022 demoparty", "tags": ["raymarching", "loop", "toy"], "likes": 8, "viewed": 146, "published": 3, "date": "1672173581", "time_retrieved": "2024-07-30T16:10:42.169725", "image_code": "/*\nMy entry for the animation compo of the Zenta 2022 demoparty\nContains code sourced from various shaders from various people\nand articles by iq.\n\nhacked and butchered together not last-minute but still pretty\nclose to the deadline (and there's a party to enjoy instead of\nspending that time coding very nervously)\n*/\n\n#define shadertoy 1\n#if shadertoy == 0\n#define debugmov 0\n#define iTime fpar[0].x\nlayout (location=0) uniform vec4 fpar[2];\nlayout (location=2) uniform vec4 debug[2]; //noexport\n#else\n#define debugmov 0\n#endif\n#define PI 3.14159265359\n#define HALFPI 1.5707963268\n#define MAT_GROUND 1\n#define MAT_RED 2\n#define MAT_WOOD 3\n#define MAT_BLUE 4\n#define MAT_YELLOW 5\n#define MAT_GREEN 6\nint i;\nvec3 gHitPosition = vec3(0);\nfloat gTimeMod;\n\nmat2 rot2(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nfloat iq(float t){return t*t;} // easing_in_quad\nfloat oq(float t){return -1.*t*(t-2.);} // easing_out_quad\nfloat ioq(float t){t=t*2.;if(t<1.){return .5*t*t*t*t;}t-=2.;return -.5*(t*t*t*t-2.);} // easing_in_out_quart\nfloat ioc(float t){t=t*2.;if(t<1.){return .5*t*t*t;}t-=2.;return .5*(t*t*t+2.);} // easing_in_out_cubic\nfloat ob(float t){ // easing_out_bounce\n\tif(t<0.36363636){return 7.5625*t*t;}\n\tif(t<.72727273){t-=.54545454;return 7.5625f*t*t+.75;}\n\tif(t<.90909091){t-=.81818182;return 7.5625*t*t+.9375;}\n\tt-=.9545456;return 7.5625*t*t+.984375;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat ss(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 - 0.5*(b+a)/k, 0., 1.);\n\treturn mix(b, -a, h) + k*h*(1.-h);\n}\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n\tvec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n\treturn min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat peg(vec3 p, float offset, float downfrom)\n{\n\tp.x -= offset;\n\tif (gTimeMod > downfrom) {\n\t\tif (gTimeMod > downfrom + .2) {\n\t\t\tp.z -= 1.;\n\t\t} else {\n\t\t\tfloat t = mod(gTimeMod, .5) / .2;\n\t\t\tt = t < .4 ? 0. : (t - .4) / .6;\n\t\t\tvec3 q = vec3(0., .65, 2.15);\n\t\t\tq.yz *= rot2(HALFPI/2.);\n\t\t\tfloat base = q.z;\n\t\t\tq.yz *= rot2(HALFPI/2.*t);\n\t\t\tfloat now = q.z;\n\t\t\tq.yz *= rot2(HALFPI/2.*(1.-t));\n\t\t\tfloat to = q.z;\n\t\t\tp.z += 1. - 2. * (now - base) / (to - base);\n\t\t}\n\t} else {\n\t\tp.z += 1.;\n\t}\n\treturn sdCappedCylinder(p, 2.3, .8) - .2;\n}\n\nvec2 pegs(vec3 p)\n{\n\tvec2 one = vec2(peg(p, 0., .5), MAT_BLUE),\n\t\ttwo = vec2(peg(p, 3.5, .0), MAT_YELLOW),\n\t\ttri = vec2(peg(p, -3.5, 1.), MAT_GREEN);\n\tif (two.x < one.x) one = two;\n\tif (tri.x < one.x) one = tri;\n\treturn one;\n}\n\nvec2 base(vec3 p)\n{\n\tfloat middle = length(max(abs(p) - vec3(6.5, 1.5, .5), 0.));\n\t//middle = max(middle, -(length(p.xy) - 1.23));\n\tmiddle = ss(length(p.xy) - 1.3, middle, .2);\n\tmiddle = ss(length(vec2(abs(p.x) - 3.5, p.y)) - 1.3, middle, .2);\n\t//middle = max(middle, -(length(vec2(abs(p.x) - 3.5, p.y)) - 1.23));\n\tmiddle -= .2;\n\tvec2 m = vec2(middle, MAT_WOOD);\n\tp.x = abs(p.x) - 7.;\n\tp.z = abs(p.z) - 1.8;\n\tfloat side = length(max(abs(p) - vec3(.5, 3., 2.), 0.)) - .3;\n\tp.z -= 2.;\n\tside = ss(length(p.yz) - 2., side, .3);\n\tvec2 s = vec2(side, MAT_RED);\n\n\tif (m.x < s.x) s = m;\n\treturn s;\n}\n\nvec2 hammer(vec3 p)\n{\n\tp.x-=3.5;p.z += 4.3;p.y += 2.6;\n\tif (gTimeMod < 1.2) {\n\t\tfloat tpt = mod(gTimeMod, .5);\n\t\tp.x += 3.5 * (gTimeMod - tpt) * 2.;\n\t\tif (tpt < .2) {\n\t\t\tfloat t = tpt / .2;\n\t\t\tp.yz *= rot2(HALFPI/2.*t);\n\t\t\tp.z -= 2. * t;\n\t\t} else {\n\t\t\tfloat t = (tpt - .2) / .3;\n\t\t\tp.x += 3.5 * t;\n\t\t\tif (t < .5) {\n\t\t\t\tt /= .5;\n\t\t\t\tp.yz *= rot2(HALFPI/2.*(1.-t));\n\t\t\t\tp.z += -2. + (2. + 2.) * oq(t);\n\t\t\t} else {\n\t\t\t\tt = (t - .5) / .5;\n\t\t\t\tp.z += 2. * (1. - iq(t));\n\t\t\t}\n\t\t}\n\t\tp.yz *= rot2(HALFPI/2.);\n\t} else {\n\t\tfloat t = (gTimeMod-1.2)/1.3;\n\t\tp.x += 7. * (1. - t);\n\t\tif (t < .5) {\n\t\t\tfloat xx = 1.-clamp(t / .2, 0., 1.);\n\t\t\tp.yz *= rot2(HALFPI/2.*xx);\n\t\t\tp.z -= 2. * xx;\n\t\t\tp.z += oq(t/.5) * 8.;\n\t\t} else {\n\t\t\tp.z += oq(1.-(t-.5)/.5) * 8.;\n\t\t}\n\t\tp.yz *= rot2(HALFPI/2.-PI*2.*ioc(t));\n\t}\n\tvec2 r = vec2(sdCappedCylinder(p, 4., .8), MAT_RED);\n\tp.z += 3.5;\n\tp.yz *= rot2(HALFPI);\n\tvec2 head = vec2(sdCappedCylinder(p, 1.3, 1.1) - .1, MAT_WOOD);\n\tif (head.x < r.x) r = head;\n\treturn r;\n}\n\nvec2 map(vec3 p)\n{\n\t// bright the scene a bit more into the light\n\tp.y -= 2.;\n\tp.x -= 1.;\n\tp.xy *= rot2(.1);\n\tvec2 r = vec2(dot(p,normalize(vec3(0.,0.,-1.))), MAT_GROUND);\n\tp.z += 4.;\n\t//p.xz *= rot2(.3);\n\t//p.zy *= rot2(iTime);\n\tvec2 hammer = hammer(p);\n\tif (gTimeMod > 1.2) {\n\t\tif (gTimeMod > 1.6) {\n\t\t\tfloat t = clamp((gTimeMod - 1.6) /.9, 0., 1.);\n\t\t\tp.z += 5. - 5. * ob(t);\n\t\t} else {\n\t\t\tp.z += 5. * oq((gTimeMod - 1.2) / .4);\n\t\t}\n\t\tif (gTimeMod > 1.4) {\n\t\t\tfloat t = clamp((gTimeMod - 1.4) / .4, 0., 1.);\n\t\t\tp.zy *= rot2(PI*ioq(t));\n\t\t}\n\t}\n\tvec2 base = base(p);\n\tvec2 pegs = pegs(p);\n\tif (base.x < r.x) r = base;\n\tif (pegs.x < r.x) r = pegs;\n\tif (hammer.x < r.x) r = hammer;\n\treturn r;\n}\n\n/*vec3 norm(vec3 p, float dist_to_p)\n{\n\tvec2 e=vec2(.00035,-.00035);\n\treturn normalize(e.xyy*map(p+e.xyy).x+e.yyx*map(p+e.yyx).x+e.yxy*map(p+e.yxy).x+e.xxx*map(p+e.xxx).x);\n}*/\n// suggestion by Shane (see comments)\nvec3 norm(vec3 p, float dist_to_p){     \n    vec3 n = vec3(0);\n    for(int i=min(iFrame, 0); i<4; i++){\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .00035*e).x;\n    }    \n    return normalize(n);\n}\n\n// x=hit y=dist_to_p z=dist_to_ro w=material(if hit)\nvec4 march(vec3 ro, vec3 rd, int maxSteps)\n{\n\tvec4 r = vec4(0);\n\tfor (i = 0; i < maxSteps && r.z < 350.; i++){\n\t\tgHitPosition = ro + rd * r.z;\n\t\tvec2 m = map(gHitPosition);\n\t\tfloat dist = m.x;\n\t\tif (dist < .0001) {\n\t\t\tr.x = float(i)/float(maxSteps);\n\t\t\tr.y = dist;\n\t\t\tr.w = m.y;\n\t\t\tbreak;\n\t\t}\n\t\tr.z += dist;\n\t}\n\treturn r;\n}\n\n// sourced from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = map(pos + h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow(vec3 ro, vec3 rd)\n{\n\tfloat res = 1.0;\n\tfloat ph = 9e9;\n\tfor(float dist = 0.01; dist < 40.; ) {\n\t\tfloat h = map(ro + rd*dist).x;\n\t\tif (h<0.001) {\n\t\t\treturn 0.0;\n\t\t}\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min(res, 5.*d/max(0.0,dist-y));\n\t\tph = h;\n\t\tdist += h;\n\t}\n\treturn res;\n}\n\nvec3 colorHit(vec4 result, vec3 rd)\n{\n\tvec3 shade = vec3(0., 1., 0.);\n\n\tswitch (int(result.w)) {\n\tcase MAT_GROUND: shade = vec3(.93,.83,.74); break;\n\tcase MAT_RED: shade = vec3(1.,0.,0.); break;\n\tcase MAT_WOOD: shade = vec3(.88,.8,.71); break;\n\tcase MAT_BLUE: shade = vec3(0.,.56,.81); break;\n\tcase MAT_YELLOW: shade = vec3(.98,.84,0.); break;\n\tcase MAT_GREEN: shade = vec3(.12,.69,.32); break;\n\t}\n\t//return shade * .3 + .4 * result.x;\n\n\tvec3 normal = norm(gHitPosition, result.y);\n\tvec3 material = shade * .3;\n\n    // https://www.shadertoy.com/view/lsKcDD\n\t// key light\n\tvec3 lig = normalize(vec3(0.1, 0.3, -0.6));\n\tvec3 hal = normalize(lig-rd);\n\tfloat dif = clamp(dot(normal, lig), 0.0, 1.0) * softshadow(gHitPosition, lig);\n\n\tfloat spe = pow(clamp(dot(normal, hal), 0.0, 1.0 ),16.0)* dif *\n\t(0.04 + 0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0), 5.0));\n\n\tvec3 col = material * 4.0*dif*vec3(1.00,0.70,0.5);\n\tcol += 12.0*spe*vec3(1.00,0.70,0.5);\n\n\t// ambient light\n\tfloat occ = calcAO(gHitPosition, normal);\n\tfloat amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\tcol += material*amb*occ*vec3(0.0,0.08,0.1);\n\n\t// fog\n\tfloat t = result.z;\n\tcol *= exp(-0.000007*t*t*t);\n\t//col *= exp(-0.00007*t);\n    //col *= exp(-0.0005*t*t*t);\n\treturn col;\n}\n\n#if shadertoy == 1\nvoid mainImage(out vec4 c, in vec2 v)\n{\n#else\nout vec4 c;\nin vec2 v;\nvoid main()\n\t{\n#endif\n\tgTimeMod = mod(iTime, 2.5);\n\n\t//vec3 ro = vec3(3, 14, -12) * 1.3;\n\t//vec3 at = vec3(1, 0, -8);\n\tvec3 ro = vec3(10, 14, -10) * 1.3;\n\tvec3 at = vec3(1, 0, -6);\n\n#if debugmov //noexport\n\tro = debug[0].xyz; //noexport\n\tfloat vertAngle = debug[1].y/20.; //noexport\n\tfloat horzAngle = debug[1].x/20.; //noexport\n\tif (abs(vertAngle) < .001) { //noexport\n\t\tvertAngle = .001; //noexport\n\t} //noexport\n\tfloat xylen = sin(vertAngle); //noexport\n\tvertAngle = cos(vertAngle); //noexport\n\tat.x = ro.x + cos(horzAngle) * xylen; //noexport\n\tat.y = ro.y + sin(horzAngle) * xylen; //noexport\n\tat.z = ro.z + vertAngle; //noexport\n#endif //noexport\n\n    vec3  cf = normalize(at-ro),\n\t      cl = normalize(cross(cf,vec3(0,0,-1)));\n\tmat3 rdbase = mat3(cl,normalize(cross(cl,cf)),cf);\n\n\tvec3 resultcol = vec3(0.);\n\tfor (int aaa = 0; aaa < 2; aaa++) {\n\t\tfor (int aab = 0; aab < 2; aab++) {\n#if shadertoy == 1\n\t\t\tvec2 o = v + vec2(float(aaa),float(aab)) / 2. - 0.5;\n\t\t\tvec2 uv = (o-.5*iResolution.xy)/iResolution.y;\n#else\n            vec2 iResolution = fpar[0].yz;\n\t\t\tvec2 uv = v*(iResolution + vec2(float(aaa),float(aab))/4)/iResolution;\n\t\t\tuv.y /= iResolution.x/iResolution.y;\n#endif\n\t\t\tvec3 rd = rdbase*normalize(vec3(uv,1)), col = vec3(0.);\n\n\t\t\tvec4 result = march(ro, rd, 200);\n\n\t\t\tif (result.x > 0.) { // hit\n\t\t\t\tcol = colorHit(result, rd);\n\t\t\t}\n\t\t\tresultcol += col;\n\t\t}\n\t}\n\tresultcol /= 4.;\n\n\n\tc = vec4(pow(resultcol, vec3(.4545)), 1.0); // pow for gamma correction because all the cool kids do it\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtf3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[754, 754, 773, 773, 820], [821, 821, 839, 839, 851], [852, 870, 888, 888, 909], [910, 929, 948, 948, 1014], [1015, 1038, 1057, 1057, 1118], [1119, 1142, 1160, 1181, 1372], [1374, 1424, 1461, 1461, 1544], [1545, 1595, 1645, 1645, 1748], [1750, 1750, 1799, 1799, 2284], [2286, 2286, 2305, 2305, 2512], [2514, 2514, 2533, 2533, 3105], [3107, 3107, 3128, 3128, 4092], [4094, 4094, 4112, 4159, 4787], [4789, 5004, 5039, 5039, 5253], [5255, 5308, 5352, 5352, 5631], [5633, 5687, 5721, 5721, 5978], [5980, 6026, 6062, 6062, 6340], [6342, 6342, 6379, 6379, 7574]], "test": "untested"}
{"id": "ctsGzf", "name": "scrollingnebula", "author": "Del", "description": "A simple scrolling nebula effect for a level background - https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n", "tags": ["noise", "fbm", "nebula", "blend", "blend"], "likes": 6, "viewed": 278, "published": 3, "date": "1672169691", "time_retrieved": "2024-07-30T16:10:42.981554", "image_code": "// Cheap(ish) scrolling nebula effect (just noise mixing)\n// https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n\n// noise, IQ - https://www.shadertoy.com/view/4sfGzS\n// (somewhat jigged)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n//#define UI3 uvec3(UI0, UI1, 2798796415U)\n//#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat mNoise( in vec2 pos )\n{\n    vec2 q = pos;\n    const mat2 m = mat2( 0.36,  0.80,  -0.80,  0.36 );\n                    \n    float amplitude = 0.5;\n    float f  = amplitude*noise( q );\n    float scale = 2.12;\n    for (int i = 0; i < 4; ++i)\n    {    \n        q = m*q*scale; //q*=scale;\n    \tf += amplitude * noise( q );\n        amplitude *= 0.5;\n    }\n    return f;\n}\n\n\n// voronoi stars - simplified and slightly optimized to use a single texture fetch for the randomness\nvec3 stars(in vec2 pos)\n{\n    vec3 col = vec3(0.0);\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n    vec2 dir = sign(f-0.5);\n    for( float j=0.0; j<=1.0; j+=1.0 )\n    {\n   \t\tfor( float i=0.0; i<=1.0; i+=1.0 )    \n\t    {\n            vec2 cell = vec2(i*dir.x,j*dir.y);\n            vec2 p = (n + cell)+0.5;\n            vec4 rnd1 = texture( iChannel0, p/256.0, -100.0 ).xyzw; // random offset,col,brightness\n            float d = length(cell + rnd1.xy - f);                \n            rnd1.w = max(0.2,rnd1.w);\n            // falloff\n            float dist = max(0.1, 1.0 - d);\n            float starfo = pow(dist, 60.0) * 6.5 + pow(dist, 120.0);\n\t        col += vec3(rnd1.z*0.2) * rnd1.w * starfo;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tvec2 uv = p;\n    \n    float ny = p.y+0.5; // ypos 0-1\n\n    uv.y *= 1.1;\n    uv.x *= 3.25;\n\n\tfloat t = iTime * .25;\n    uv.y += t;\n    \n    float fval1 = mNoise(uv);\n    uv.x *= 0.64;\n    \n    float fval = 0.23+(ny*0.1); // 0.13 less fuckage\n    uv.x += 3.5+(fval1*fval); // here, we fuck layer2 with layer1 a touch for a lavalamp style effect\n    uv.y -= t*0.53;\n    float fval2 = mNoise(uv);\n    \n    float cut = 0.45;  \n    fval1 = smoothstep(cut-0.1,1.8,fval1);\n    fval2 = smoothstep(cut,1.8,fval2);\n    fval1 = fval1+fval2;\n\n    // colors (layer1)\n    vec3 col1top = vec3(0.65,1.0,0.5);\n    vec3 col1bot = vec3(0.55,0.6,0.75);\n\n    // colors (layer2)\n    vec3 col2top = vec3(1.1,0.65,0.5);\n    vec3 col2bot = vec3(0.7,0.6,0.45);\n    \n    vec3 col1 = mix(col1bot,col1top,ny)*fval1;\n    vec3 col2 = mix(col2bot,col2top,ny)*fval2;\n    \n    // this blend is calculated with the asspluck constant\n    float blend = 0.5+(sin(fval1*4.25+fval2*1.75)*0.25);\n    vec3 color = mix(col1,col2,blend)*1.61;\n\n    // test it with a starfield background...\n    color = clamp(color,vec3(0.0),vec3(1.0));\n    float a = smoothstep(0.4,0.0,length(color)); // a = starmask\n    color +=  stars(p*15.0) * a;\n\n\n    // mouse = rgb swizzle\n    if (iMouse.z>0.5)\n        color = color.zyx;\n\n\n\tfragColor = vec4(color.xyz,1.0);\n}\n\n\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 401, 423, 423, 512], [514, 514, 540, 540, 887], [889, 889, 918, 918, 1259], [1262, 1364, 1389, 1389, 2099], [2101, 2101, 2158, 2158, 3534]], "test": "untested"}
{"id": "DtsGzf", "name": "Diffusion Claude", "author": "fishy", "description": "diffusion claude, diffusion cloud, haha", "tags": ["lod"], "likes": 7, "viewed": 227, "published": 3, "date": "1672169614", "time_retrieved": "2024-07-30T16:10:43.780419", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 old = texture(iChannel1, fragCoord/iResolution.xy, 3.).rgb*0.999;\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    float a = clamp(max(0., color.g-color.r-color.b)*100., 0., 1.);\n    fragColor = vec4(mix(old, color, 1.-a), 1.);\n    //fragColor = vec4(a);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 189]], "test": "untested"}
{"id": "cllGzf", "name": "interfeterence", "author": "drliquidglitch", "description": "noob", "tags": ["basic"], "likes": 2, "viewed": 171, "published": 3, "date": "1672168659", "time_retrieved": "2024-07-30T16:10:44.546370", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    if ((uv.x > abs(sin(iTime*uv.y))) || (uv.y > abs(cos(iTime*uv.x)))) {\n        {\n            col = vec3(0.0);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 428]], "test": "untested"}
{"id": "Dts3zX", "name": "Manually anti-aliased circle", "author": "callumacrae", "description": "TODO: what's with the artefacts :(", "tags": ["circle", "antialiasing", "animation"], "likes": 2, "viewed": 194, "published": 3, "date": "1672157812", "time_retrieved": "2024-07-30T16:10:45.286392", "image_code": "#define PIXELS_PER_PIXEL 8.0\n#define RADIUS 25.0\n#define RADIUS_VAR 3.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 origin = iResolution / 2.0 / PIXELS_PER_PIXEL;\n  float radius = RADIUS + cos(iTime) * RADIUS_VAR;\n\n  // We check the intersections against the pixel represented by rectangle ABCD:\n  //\n  // (x, y)\n  //      __D__\n  //      |   |\n  //      A   C\n  //      |   |\n  //      --B--\n  //           (x + 1, y + 1)\n\n  // Transform the points to test a circle about the point (0, 0) - means we don't\n  // have to worry about the negative values of square roots\n  float x = abs(origin.x - floor(fragCoord.x / PIXELS_PER_PIXEL));\n  float y = abs(origin.y - floor(fragCoord.y / PIXELS_PER_PIXEL));\n\n  float intersectionOnA = sqrt(pow(radius, 2.0) - pow(x, 2.0));\n  bool isIntersectionWithinA = intersectionOnA >= y && intersectionOnA <= y + 1.0;\n\n  float intersectionOnB = sqrt(pow(radius, 2.0) - pow(y + 1.0, 2.0));\n  bool isIntersectionWithinB = intersectionOnB >= x && intersectionOnB <= x + 1.0;\n\n  float intersectionOnC = sqrt(pow(radius, 2.0) - pow(x + 1.0, 2.0));\n  bool isIntersectionWithinC = intersectionOnC >= y && intersectionOnC <= y + 1.0;\n\n  float intersectionOnD = sqrt(pow(radius, 2.0) - pow(y, 2.0));\n  bool isIntersectionWithinD = intersectionOnD >= x && intersectionOnD <= x + 1.0;\n\n  float dist = sqrt(pow(x, 2.0) + pow(y, 2.0));\n  float color = dist < radius ? 1.0 : 0.0;\n\n  if (isIntersectionWithinA && isIntersectionWithinD) {\n    color = (intersectionOnD - x) * (intersectionOnA - y) / 2.0;\n  }\n  if (isIntersectionWithinA && isIntersectionWithinC) {\n    color = (intersectionOnA + intersectionOnC) / 2.0 - y;\n  }\n  if (isIntersectionWithinB && isIntersectionWithinC) {\n    color = 1.0 - (x + 1.0 - intersectionOnB) * (y + 1.0 - intersectionOnC) / 2.0;\n  }\n  if (isIntersectionWithinB && isIntersectionWithinD) {\n    color = (intersectionOnB + intersectionOnD) / 2.0 - x;\n  }\n\n  fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dts3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 128, 128, 1965]], "test": "untested"}
{"id": "mlX3Rf", "name": "Animated Fancam", "author": "MysteryPancake", "description": "My first real experiment using raymarching :)", "tags": ["3d", "raymarching", "raymarch", "video", "sdf", "texture", "animation"], "likes": 16, "viewed": 1082, "published": 3, "date": "1672155040", "time_retrieved": "2024-07-30T16:10:46.026413", "image_code": "const float PI = 3.1415926;\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\n// From https://easings.net/\nfloat outPow(float x, float p) {\n    x = clamp(x, 0.0, 1.0);\n    return 1.0 - pow(1.0 - x, p);\n}\n\nfloat inPow(float x, float p) {\n    x = clamp(x, 0.0, 1.0);\n    return pow(x, p);\n}\n\nfloat outElastic(float x) {\n    const float c4 = (2.0 * PI) / 3.0;\n    return pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;\n}\n\nfloat stars(vec3 p, float t) {\n    float d = 9999.9;\n    for (float i = 0.0; i < 4.0; i++) {\n        vec3 offset = vec3(i * 1.4, i * 1.2, i * -0.5);\n        float grid = length(mod(p + offset, 4.0) - 2.0);\n        d = min(grid - 0.08, d);\n    }\n    return d;\n}\n\nvec2 map(vec3 p, float t) {\n    vec2 res = vec2(sdBox(p + vec3(0.0, 0.0, 0.1), vec3(0.5, 0.5, 0.05)), 1.5);\n    res = opU(res, vec2(stars(p, t), 0.5));\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 q = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float mod2 = mod(iTime, 2.0);\n    float mod4 = mod(iTime, 4.0);\n    \n    // Main camera animation\n    float xrot = 4.0 - outElastic(0.3 * mod4) * 4.0;\n    float yrot = 16.0 - outPow(mod4 * 2.0, 3.0) * 16.0\n        - inPow(mod2 - 1.0, 5.0) * 16.0;\n    float zrot = mod4 > 2.0\n        ? 8.0 - outPow(mod2, 4.0) * 8.0\n        : sin(iTime * PI) * 0.5;\n    \n    // Flip motion every 2 iterations\n    if (mod(iTime, 8.0) > 4.0) {\n        xrot *= -1.0;\n        yrot *= -1.0;\n        zrot *= -1.0;\n    }\n    \n    float fov = sin(iTime * PI) * 0.3 + 0.7;\n    vec3 ro = vec3(xrot, yrot, fov);\n    mat3 ca = setCamera(ro, vec3(0.0), zrot);\n    vec3 rd = ca * normalize(vec3(q, fov));\n\n    // Raymarching with only 20 iterations produces glow\n    vec2 h; vec3 p;\n    float t = 0.1;\n    const int iters = 20;\n    const float tmax = 22.0;\n    for (int i = 0; i < iters && t < tmax; i++) {\n        p = ro + rd * t;\n        h = map(p, iTime);\n        if (abs(h.x) < 0.001) {\n            break;\n        }\n        t += h.x;\n    }\n    \n    vec4 red = vec4(1.0, uv.y, 0.5, 1.0);\n    vec4 blu = vec4(0.0, uv.y, 1.0, 1.0);\n    float fog = min(10.0, 2.0 + 6.0 * mod2) / t;\n    vec4 color = (mod4 > 2.0 ? blu : red) * fog;\n    \n    if (h.y > 1.0) {\n        // Video\n        vec2 size = vec2(textureSize(iChannel0, 0));\n        vec2 uv = vec2(p.x * size.y / size.x, p.y);\n        fragColor = texture(iChannel0, 0.5 + uv);\n    } else {\n        // Background and stars\n        fragColor = color;\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlX3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 75, 104, 104, 199], [201, 201, 227, 227, 256], [258, 258, 308, 308, 472], [474, 503, 535, 535, 599], [601, 601, 632, 632, 684], [686, 686, 713, 713, 822], [824, 824, 854, 854, 1084], [1086, 1086, 1113, 1113, 1255], [1257, 1257, 1312, 1312, 2909]], "test": "untested"}
{"id": "dlsGRH", "name": "protocapsid", "author": "remaindeer", "description": "See the \"Image\" tab for controls. Background: [url]https://viralzone.expasy.org/8577[/url].", "tags": ["raymarch", "model", "tiling", "icosahedron", "application", "construction", "virus", "schwarz", "wythoff", "capsid", "casparklug", "hkcage", "chimerax"], "likes": 10, "viewed": 273, "published": 3, "date": "1672153921", "time_retrieved": "2024-07-30T16:10:47.054665", "image_code": "// MIT License\n// \n// Copyright (c) 2022, Daniel Antonio Negrón (@remaindeer)\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// [abstract]\n// Capsids house viral genetic material. Understanding their structure is\n// essential for developing antivirals, gene therapies, and vaccines. This is an\n// app for modeling based on Caspar-Klug theory and lattice geometry. The goal is\n// reimplementation of the democapsid app (https://github.com/dnanto/democapsid)\n// and to show that it's a cool effect for demoscene.\n\n// [acknowledgements]\n// @iq, @FabriceNeyret2, @inspirnathan, @mla\n\n// [controls]\n// * ctrl+1-3: icosahedron, facet, or plane view (default: ctrl+1)\n// * (shift+)1-7: tilings and their duals (default: 1)\n// * (shift+)h/k: decrement/increment plane step parameters (>= 0) (default: h=2, k=1)\n// * (shift+)t/f/z: decrement/increment edge thickness, fiber length, camera zoom\n// * l/p/c/r/s: outline, h/k-walk arrows, centroid point, random Wythoff, spin (default: off/off/on/off/off)\n\nfloat scene(vec3 p) {\n    // dynamic scene parameters\n    vec4 para_1 = texelFetch(iChannel1, IDX_PARA_1, 0);\n    vec4 para_2 = texelFetch(iChannel1, IDX_PARA_2, 0);\n    vec4 mode_1 = texelFetch(iChannel1, IDX_MODE_1, 0);\n    vec4 mode_2 = texelFetch(iChannel1, IDX_MODE_2, 0);\n    bool is_lines = mode_1.g == MODE_LINES;\n    bool is_paths = mode_1.b == MODE_PATHS;\n    bool is_point = mode_2.r == MODE_POINT;\n    bool[5] config = bool[5] (true, true, is_lines, is_paths, is_point);\n    //// Caspar-Klug\n    float h = para_1.r;\n    float k = para_1.g;\n    //// Wythoff\n    vec4 tiling = TILINGS[int(para_1.b)];\n    vec2 g = tiling.rg;                 // generator point\n    float m = tiling.b;                 // mirror toggles\n    float w = tiling.w;                 // wall toggles\n    float t = THICK_STEP * para_1.a;    // thickness\n    float f = FIBER_STEP * para_2.r;    // fiber length\n    if (mode_1.a == MODE_RANDO) {\n        ////// pick point within fundamental triangle\n        ////// https://mathworld.wolfram.com/TrianglePointPicking.html\n        ////// http://extremelearning.com.au/evenly-distributing-points-in-a-triangle/\n        float a1 = 0.5 + sin(1.25 * iTime / 1.25) / 2.0;\n        float a2 = 0.5 + cos(2.00 * iTime / 1.75) / 2.0;\n        ////// generator point\n        g = (((a1 + a2) < 1.0) ? (a1 * ft.zw + a2 * ft.xy) : ((1.0 - a1) * ft.zw + (1.0 - a2) * ft.xy));\n        ////// mirrors\n        m = mod(round((iTime - 2.0 / 1.5) / 2.0), 10.0);\n        ////// rotate\n    }\n    //// spin\n    p = mode_2.g == MODE_RSPIN ? rotmat3(vec3(iTime * 0.25)) * p : p;\n        \n    // distance\n    float d = 1.0;\n    //// scale to 1.0 / (h/k-facet side length)\n    float s = 1.0 / length(mat2(1.5, cos30, 0.0, 2.0 * cos30) * vec2(h, k));\n    /****/ if (mode_1.r == MODE_ICOSA) { \n        //// find nearest centroid facet\n        int argkey = 0;\n        float argval = distance(p, centroids[0]);\n        for (int i = 1; i < transforms.length(); i++) {\n            float result = distance(p, centroids[i]);\n            if (result < argval) {\n                argkey = i;\n                argval = result;\n            }\n        }\n        //// now calc\n        vec4 q = transforms[argkey] * vec4(p - centroids[argkey], 1);\n        config[0] = false;\n        d = sdCasparKlugFacet(q.xyz / s, h, k, g, m, w, t, config) * s;\n        vec3 vertex = normalize(vec3(1, 0, PHI));\n        vec3[4] dir = vec3[4] (vec3( 1, 0,  1), vec3(-1, 0,  1), vec3( 1, 0, -1), vec3(-1, 0, -1));\n        // vertex fibers\n        for (int i = 0; f > 0.0 && i < dir.length(); i++) {\n            vec3 u, v;\n            u = ICO_CIRCUMRADIUS * (vertex * dir[i]).xyz; v = u + f * u;\n            d = opUnion(d, sdCapsule(p.xyz, u, v, t / 4.0));\n            d = opUnion(d, sdSphere(p.xyz - v, t / 2.0));\n            u = ICO_CIRCUMRADIUS * (vertex * dir[i]).yzx, v = u + f * u;\n            d = opUnion(d, sdCapsule(p.xyz, u, v, t / 4.0));\n            d = opUnion(d, sdSphere(p.xyz - v, t / 2.0));\n            u = ICO_CIRCUMRADIUS * (vertex * dir[i]).zxy, v = u + f * u;\n            d = opUnion(d, sdCapsule(p.xyz, u, v, t / 4.0));\n            d = opUnion(d, sdSphere(p.xyz - v, t / 2.0));\n        }\n    } else if (mode_1.r == MODE_FACET) {\n        d = sdCasparKlugFacet(p.xyz / s, h, k, g, m, w, t, config) * s;\n    } else if (mode_1.r == MODE_PLANE) {\n        config[1] = false;\n        d = sdCasparKlugFacet(p.xyz / s, h, k, g, m, w, t, config) * s;\n    }\n        \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    float d;\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + depth * rd;\n        d = scene(p);\n        depth += d;\n        if (d < PRECISION || depth > MAX_DIST) {\n            break;\n        }\n    }\n\n    d = depth;\n\n    return d;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n        e.xyy * scene(p + e.xyy) +\n        e.yyx * scene(p + e.yyx) +\n        e.yxy * scene(p + e.yxy) +\n        e.xxx * scene(p + e.xxx)\n    );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (m == vec2(0.0)) m = vec2(0.5);\n\n    vec3 col = vec3(0);\n    vec3 lp = vec3(0);\n    vec4 para_2 = texelFetch(iChannel1, IDX_PARA_2, 0);\n    vec3 ro = vec3(0, 0, para_2.g * ZOOM_STEP);\n\n    float camRadius = 1.0;\n    ro.yz = ro.yz * camRadius * rotmat2(mix(-PI / 2.0, PI / 2.0, m.y));\n    ro.xz = ro.xz * rotmat2(mix(-PI, PI, m.x)) + vec2(lp.x, lp.z);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(p, -1));\n\n    float d = march(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = COLOR_BACKGROUND;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 norm = normal(p);\n\n        vec3 lightPos = vec3(0, 2, 2);\n        vec3 lightDir = normalize(lightPos - p) * 0.65;\n\n        float diff = clamp(dot(norm, lightDir), 0.0, 1.0) * 0.5 + 0.5;\n\n        vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n        col = vec3(diff) + rnd;    \n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// MIT License\n// \n// Copyright (c) 2022, Daniel Antonio Negrón (@remaindeer)\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// keyboard\n///// https://www.shadertoy.com/view/llySRh\n#define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0. )\n#define keyDown(ascii)    ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0. )\n\n// buffer data/indexing\n#define IDX_PARA_1 ivec2(0, 0)\n#define IDX_PARA_2 ivec2(0, 1)\n#define IDX_MODE_1 ivec2(0, 2)  \n#define IDX_MODE_2 ivec2(0, 3)  \n#define MODE_ICOSA 1.0\n#define MODE_FACET 2.0\n#define MODE_PLANE 3.0\n#define MODE_LINES 4.0\n#define MODE_PATHS 5.0\n#define MODE_RANDO 6.0\n#define MODE_POINT 7.0\n#define MODE_RSPIN 8.0\n#define THICK_STEP 0.005\n#define FIBER_STEP 0.05\n#define ZOOM_STEP  0.25\n\n// ray marching\n#define MAX_ITER 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define EPSILON 0.0005\n#define COLOR_BACKGROUND vec3(0, 0, 0)\n#define COLOR_AMBIENT vec3(0.42, 0.20, 0.1);\n\n// math\n//// constants\n#define PI 3.1415926535897932384626433\n#define PHI (1.0 + sqrt(5.0)) / 2.0\n#define ICO_CIRCUMRADIUS sin((2.0 * PI) / 5.0)\n#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n//// fundamental triangle\n#define ft vec4(0, cos30, 0.5, cos30)\n//// special generator points\n#define gq vec2(0.25, cos30)\n#define gc (ft.xy + cos30 * ft.zw) / (0.5 + cos30 + 1.0)\n#define gx vec2((3.0 - sqrt3) / 4.0, tan(radians(60.0)) * ((3.0 - sqrt3) / 4.0))\n//// Wythoff construction ===========================================================\nconst vec4[14] TILINGS = vec4[14] (\n    ////// Platonic and Archimedean tilings -----------------------------------------\n    vec4(ft.zw, 1.0, 0.0), // Hexagonal tiling (hextille)\n    vec4(ft.xy, 2.0, 0.0), // Trihexagonal tiling (hexadeltille)\n    vec4(gq   , 3.0, 0.0), // Truncated hexagonal tiling (truncated hextille)\n    vec4(ft.xx, 4.0, 0.0), // Triangular tiling (deltille) \n    vec4(gx   , 5.0, 0.0), // Rhombitrihexagonal tiling (rhombihexadeltille)\n    vec4(gc   , 7.0, 0.0), // Truncated trihexagonal tiling (truncated hexadeltille)\n    vec4(ft.xx, 8.0, 0.0), // Snub trihexagonal tiling (snub hextille)\n    ////// Dual Laves tilings -------------------------------------------------------\n    vec4(ft.xx, 4.0, 0.0), // Triangular tiling (deltille) \n    vec4(ft.xx, 0.0, 2.0), // Rhombille tiling (rhombille)\n    vec4(ft.xx, 0.0, 3.0), // Triakis triangular tiling (kisdeltille)\n    vec4(ft.zw, 1.0, 0.0), // Hexagonal tiling (hextille)\n    vec4(ft.xx, 0.0, 5.0), // Deltoidal trihexagonal tiling (tetrille)\n    vec4(ft.xx, 0.0, 7.0), // Kisrhombille tiling (kisrhombille)\n    vec4(ft.xx, 9.0, 0.0)  // Floret pentagonal tiling (6-fold pentille)\n); // ===============================================================================\n////// centroid vectors\nconst vec3[20] centroids = vec3[20] (\n\tvec3( 0. , -0.26967233, 0.70601133),\n\tvec3( 0.436339, -0.436339, 0.436339),\n\tvec3(0.70601133, 0. , 0.26967233),\n\tvec3(0.436339, 0.436339, 0.436339),\n\tvec3(0. , 0.26967233, 0.70601133),\n\tvec3( 0. , -0.26967233, -0.70601133),\n\tvec3(-0.436339, -0.436339, -0.436339),\n\tvec3(-0.70601133, 0. , -0.26967233),\n\tvec3(-0.436339, 0.436339, -0.436339),\n\tvec3( 0. , 0.26967233, -0.70601133),\n\tvec3(-0.70601133, 0. , 0.26967233),\n\tvec3(-0.436339, -0.436339, 0.436339),\n\tvec3(-0.26967233, -0.70601133, 0. ),\n\tvec3( 0.26967233, -0.70601133, 0. ),\n\tvec3( 0.436339, -0.436339, -0.436339),\n\tvec3( 0.70601133, 0. , -0.26967233),\n\tvec3( 0.436339, 0.436339, -0.436339),\n\tvec3(0.26967233, 0.70601133, 0. ),\n\tvec3(-0.26967233, 0.70601133, 0. ),\n\tvec3(-0.436339, 0.436339, 0.436339)\n);\n////// transformation matrices\nconst mat4[20] transforms = mat4[20] (\n\tmat4( 0.5 , 0.8660254 , 0. , 0. , -0.80901699, 0.46708618, -0.35682209, 0. , -0.30901699, 0.17841104, 0.93417236, -0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.80901699, 0.11026409, 0.57735027, 0. , 0.30901699, 0.75576131, -0.57735027, 0. , -0.5 , 0.64549722, 0.57735027, -0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0. , -0.35682209, 0.93417236, 0. , 1. , 0. , 0. , 0. , 0. , 0.93417236, 0.35682209, -0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4(-0.80901699, 0.11026409, 0.57735027, -0. , 0.30901699, -0.75576131, 0.57735027, 0. , 0.5 , 0.64549722, 0.57735027, -0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4(-0.5 , 0.8660254 , 0. , 0. , -0.80901699, -0.46708618, 0.35682209, 0. , 0.30901699, 0.17841104, 0.93417236, -0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4(-0.5 , -0.8660254 , 0. , 0. , -0.80901699, 0.46708618, 0.35682209, 0. , 0.30901699, -0.17841104, 0.93417236, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4(-0.80901699, -0.11026409, 0.57735027, 0. , 0.30901699, 0.75576131, 0.57735027, 0. , 0.5 , -0.64549722, 0.57735027, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0. , 0.35682209, 0.93417236, 0. , 1. , 0. , 0. , 0. , 0. , -0.93417236, 0.35682209, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.80901699, -0.11026409, 0.57735027, -0. , 0.30901699, -0.75576131, -0.57735027, 0. , -0.5 , -0.64549722, 0.57735027, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.5 , -0.8660254 , 0. , 0. , -0.80901699, -0.46708618, -0.35682209, 0. , -0.30901699, -0.17841104, 0.93417236, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0. , 0.35682209, -0.93417236, 0. , -1. , 0. , 0. , 0. , 0. , 0.93417236, 0.35682209, -0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.80901699, -0.11026409, -0.57735027, -0. , -0.30901699, 0.75576131, -0.57735027, 0. , 0.5 , 0.64549722, 0.57735027, -0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.80901699, 0.46708618, 0.35682209, -0. , -0.30901699, -0.17841104, 0.93417236, -0. , -0.5 , 0.8660254 , -0. , 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.80901699, -0.46708618, -0.35682209, 0. , 0.30901699, -0.17841104, 0.93417236, -0. , 0.5 , 0.8660254 , -0. , 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.5 , 0.64549722, -0.57735027, -0. , 0.80901699, -0.11026409, 0.57735027, 0. , -0.30901699, 0.75576131, 0.57735027, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.30901699, 0.17841104, -0.93417236, 0. , 0.5 , -0.8660254 , -0. , -0. , 0.80901699, 0.46708618, 0.35682209, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4(-0.5 , 0.64549722, -0.57735027, 0. , 0.80901699, 0.11026409, -0.57735027, 0. , 0.30901699, 0.75576131, 0.57735027, 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0. , 0.93417236, -0.35682209, 0. , 0. , -0.35682209, -0.93417236, 0. , 1. , 0. , 0. , 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4(-0.80901699, 0.46708618, 0.35682209, 0. , -0.30901699, 0.17841104, -0.93417236, -0. , 0.5 , 0.8660254 , -0. , 0.75576131, 0. , 0. , 0. , 1. ),\n\tmat4( 0.30901699, 0.75576131, -0.57735027, 0. , -0.5 , 0.64549722, 0.57735027, 0. , 0.80901699, 0.11026409, 0.57735027, -0.75576131, 0. , 0. , 0. , 1. )\n);\n\n// functions\n\n//// rotations\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotmat3(vec3 angle) {\n    float sintht = sin(angle.x), sinpsi = sin(angle.y), sinphi = sin(angle.z);\n    float costht = cos(angle.x), cospsi = cos(angle.y), cosphi = cos(angle.z);\n    return mat3(\n        costht * cospsi, sintht * cospsi, -sinpsi, \n        costht * sinpsi * sinphi - sintht * cosphi, sintht * sinpsi * sinphi + costht * cosphi, cospsi * sinphi,\n        costht * sinpsi * cosphi + sintht * sinphi, sintht * sinpsi * cosphi - costht * sinphi, cospsi * cosphi\n    );\n}\n\n//// intersection\n\nvec2 intersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    // http://paulbourke.net/geometry/pointlineplane/\n    float d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;\n    // float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;\n    return p1 + ua * (p2 - p1);\n}\n\n//// signed distance functions\n////// ------------------------------------------------\n////// https://iquilezles.org/articles/distfunctions/\n////// https://iquilezles.org/articles/distfunctions2d/\n////// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\nfloat opIntersection( float d1, float d2 ) { \n    // https://iquilezles.org/articles/distfunctions/\n    return max(d1, d2); \n}\n\n\nfloat opUnion(float d1, float d2) {\n    // https://iquilezles.org/articles/distfunctions/\n    return min(d1, d2); \n}\n\nfloat opOnion(in float sdf, in float thickness) {\n    // https://iquilezles.org/articles/distfunctions/\n    return abs(sdf) - thickness;\n}\n\nvec3 opRep(in vec3 p, in vec3 c) {\n    // https://iquilezles.org/articles/distfunctions/\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdCone(in vec3 p, in vec2 c, float h) {\n    // c is the sin/cos of the angle, h is height\n    // Alternatively pass q instead of (c,h),\n    // which is the point at the base in 2D\n    vec2 q = h * vec2(c.x / c.y, -1.0);\n\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w,q) / dot(q,q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0 ), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 t0 = p  - p0, t1 = p  - p1, t2 = p  - p2;\n    vec2 pq0 = t0 - e0 * clamp(dot(t0, e0)/ dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = t1 - e1 * clamp(dot(t1, e1)/ dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = t2 - e2 * clamp(dot(t2, e2)/ dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x );\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (t0.x * e0.y - t0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (t1.x * e1.y - t1.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (t2.x * e2.y - t2.y * e2.x)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdEquilateralTriangle(in vec2 p, in float r) {\n    // r is half of the side\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0 * r, 0.0);\n    return -length(p) * sign(p.y);\n}\n\n////// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n////// https://iquilezles.org/articles/distfunctions/\n////// https://iquilezles.org/articles/distfunctions2d/\n////// ------------------------------------------------\n\n////// Wythoff Construction\n\nvec2 snub632() {\n    // fermat point\n    vec2 pf = intersection(vec2(-0.75, cos30 / 2.0), ft.zw, vec2(1, 0), ft.xy);\n    // reflect over side (y-axis)\n    vec2 q1 = vec2(-1.0 * pf.x, pf.y);\n    // vec2 q2 = vec2(pf.x, pf.y + 2.0 * (cos30 - pf.y));\n    // project to hypotenuse then double to obtain reflection\n    vec2 q3 = dot(pf, ft.zw) / dot(ft.zw, ft.zw) * ft.zw;\n    q3 = pf + 2.0 * (q3 - pf);\n    // snub point is at half the hypotenuse of the new right triangle (Thales's theorem)\n    return q1 + ((q3 - q1) / 2.0);\n}\n\nfloat sdSchwartz632Snub(vec3 p, float t) {\n    // p the uv\n    // t the thickness\n    // take advantage of symmetry\n    float a = atan(p.y, p.x);\n    float M = floor(mod(degrees(a) - 30.0, 360.0) / 60.0) * 60.0;\n    p.xy = rotmat2(radians(M)) * p.xy;\n    // snub point\n    vec3 g = vec3(snub632(), 0);\n    // rotate\n    vec3 G = vec3(rotmat2(radians(180.0)) * (g.xy - ft.xy) + ft.xy, 0);\n    // distance\n    float d = sdCapsule(p, g, G, t);\n    // fix by https://www.shadertoy.com/user/mla\n    d = opUnion(d, sdCapsule(vec3(rotmat2(radians(-60.0)) * p.xy, p.z), g, G, t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(-60.0)) * (G - g).xy + g.xy, 0), t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(+60.0)) * (G - g).xy + g.xy, 0), t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(+120.0)) * (G - g).xy + g.xy, 0), t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(+180.0)) * (G - g).xy + g.xy, 0), t));\n    return d;\n}\n\nfloat sdSchwartz632DualSnub(vec3 p, float t) {\n    // p the uv\n    // t the thickness\n    // snub point\n    vec3 g = vec3(snub632(), 0);\n    // take advantage of symmetry\n    float a = atan(p.y, p.x) - (atan(g.y, g.x) - radians(60.0));\n    float M = floor(mod(degrees(a), 360.0) / 60.0) * 60.0;\n    p.xy = rotmat2(radians(M)) * p.xy;\n    float R3 = sqrt3 / 2.0 * length(g);\n    float r3 = sqrt3 / 6.0 * length(g); \n    vec2 n0 = normalize(rotmat2(radians(+30.0)) * g.xy);\n    vec3 n1 = vec3((R3 + r3) * n0, 0);\n    vec3 n2 = vec3(n1.xy + rotmat2(radians(-60.0)) * (2.0 * r3 * n0), 0);\n    vec3 n3 = vec3(n1.xy + rotmat2(radians(+60.0)) * (2.0 * r3 * n0), 0);\n    // distance\n    float d = sdCapsule(p, vec3(ft.xx, 0), n1, t);\n    d = opUnion(d, sdCapsule(p, n1, n2, t));\n    d = opUnion(d, sdCapsule(p, n1, n3, t));\n    d = opUnion(d, sdCapsule(p, n2, n1 + n2 + -n3, t));\n    d = opUnion(d, sdCapsule(p, n3, n1 + n3 + -n2, t));\n    return d;\n}\n\nfloat sdSchwartz632(vec3 p, vec2 g, float m, float w, float t, bool o) {\n    // snub case\n    if (m == 8.0) {\n        return sdSchwartz632Snub(p, t);\n    }\n    // dual snub case\n    else if (m == 9.0) {\n        return sdSchwartz632DualSnub(p, t);\n    }\n    p = abs(p);\n    if (p.y < 2.0 * cos30 * p.x) {\n        p.xy = rotmat2(radians(-60.0)) * p.xy;\n        p = abs(p);\n    }\n    // distance\n    float d = o ? sdSphere(p, t) : MAX_DIST;\n    vec3 g3 = vec3(g, 0);\n    d = bool(mod(m, 2.0)) ? opUnion(d, sdCapsule(p, g3, vec3(0, g3.y, 0), t)) : d;\n    vec3 v = vec3(ft.zw, 0);\n    d = bool(mod(floor(m / 2.0), 2.0)) ? opUnion(d, sdCapsule(p, g3, dot(g3, v) / dot(v, v) * v, t)) : d;\n    d = bool(mod(floor(m / 4.0), 2.0)) ? opUnion(d, sdCapsule(p, g3, vec3(g3.x, ft.y, 0), t)) : d;\n    d = bool(mod(w, 2.0)) ? opUnion(d, sdCapsule(p, vec3(ft.xx, 0), vec3(ft.xy, 0), t)) : d;\n    d = bool(mod(floor(w / 2.0), 2.0)) ? opUnion(d, sdCapsule(p, vec3(ft.xx, 0), vec3(ft.zw, 0), t)) : d;\n    d = bool(mod(floor(w / 4.0), 2.0)) ? opUnion(d, sdCapsule(p, vec3(ft.xy, 0), vec3(ft.zw, 0), t)) : d;\n    return d;\n}\n\nfloat sdSchwartz632Plane(vec3 p, vec2 g, float m, float w, float t, bool o) {\n    vec3 v = vec3(3.0, 2.0 * cos30, 0.0);\n    vec3 p1 = opRep(p, v);\n    vec3 p2 = opRep(p + v / 2.0, v);\n    return opUnion(\n        sdSchwartz632(p1, g, m, w, t, o),\n        sdSchwartz632(p2, g, m, w, t, o)\n    );\n}\n\n//// Caspar-Klug\n\nfloat sdCasparKlugFacet(vec3 p, float h, float k, vec2 g, float m, float w, float t, bool[5] x) {\n    // @p vec3 the uv\n    // @h float the h-parameter (steps on plane)\n    // @k float the k-parameter (steps on plane after 60-degree turn)\n    // @g vec2 the generator point for Wythoff construction\n    // @m float the bits representing the activated mirrors for Wythoff construction\n    // @w float the bits representing the fundamental triangle wall display\n    // @t float the edge thickness\n    // @x vec4 the config\n    \n    mat2 b = mat2(1.5, cos30, 0.0, 2.0 * cos30);           // basis\n    // vec2 v1 = vec2(0);                                  // vector 1\n    vec3 v2 = vec3(b * vec2(h, k), 0);                     // vector 2\n    vec3 v3 = vec3(rotmat2(radians(-60.0)) * v2.xy, 0);    // vector 3\n    float s = length(v2);                                  // side length\n    // vec2 c = (v1 + v2 + v3) / 3.0;                      // centroid\n    vec3 c = (v2 + v3) / 3.0;                              // also centroid...\n\n    vec3 q = vec3(rotmat2(-atan(v2.y, v2.x)) * p.xy, p.z); // map p to triangle sitting on side -> ⍙\n    // tile the plane\n    float d = sdSchwartz632Plane(q + c, g, m, w, t, x[4]);\n    // carve-out facet\n    d = x[1] ? opIntersection(d, sdEquilateralTriangle(p.xy, s / (1.0 + float(x[0])))): d;\n    \n    // trace lines/paths of walk\n    // TODO: simplify...\n    if (x[2] || x[3]) {\n        vec3 h1 = h * vec3(1.5, cos30, 0);\n        mat2 h1_rot = (\n            rotmat2(-atan(h1.y, h1.x)) * \n            rotmat2(-acos(dot(h1, vec3(1, 0, 0)) / (length(h1) * length(vec3(1, 0, 0)))))\n        );\n        for(int i = 0; i < 3; i++) {\n            q.xy = rotmat2(radians(120.0)) * q.xy;\n            vec3 Q = q + c - h1;\n            Q.xy = h1_rot * Q.xy;\n            d = x[2] ? opUnion(d, sdCapsule(q + c, vec3(0), v2, t)) : d;\n            if (x[3]) {\n                d = opUnion(d, sdCapsule(q + c, vec3(0), h1, t));\n                d = opUnion(d, sdCapsule(q + c, h1, v2, t));\n                if (h > 0.0) d = opUnion(d, sdCone(Q, vec2(0.5, 1.0), 8.0 * t));\n                if (k > 0.0) d = opUnion(d, sdCone(q + c - v2, vec2(0.5, 1.0), 8.0 * t));\n            }\n        }\n    }\n    \n    return d;\n}\n", "buffer_a_code": "// MIT License\n// \n// Copyright (c) 2022, Daniel Antonio Negrón (@remaindeer)\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2  uv = fragCoord;\n    ivec2 iv = ivec2(uv);\n    \n    vec4 data = texelFetch(iChannel1, iv, 0);\n    \n    bool is_shift = keyDown(16/* shift */);\n    bool is_ctrl  = keyDown(17/* ctrl  */);\n    \n    if (iFrame == 0) {\n        /**/ if (iv == IDX_PARA_1) data = vec4( 2,  1, 0, 8); // h, k, wythoff, thickness\n        else if (iv == IDX_PARA_2) data = vec4(5, 12, 0, 0); // fiber, zoom, _, _\n        else if (iv == IDX_MODE_1) data = vec4(MODE_ICOSA, -MODE_LINES, -MODE_PATHS, -MODE_RANDO);\n        else if (iv == IDX_MODE_2) data = vec4(MODE_POINT, -MODE_RSPIN, 0, 0);\n    } else {\n        /**/ if (iv == IDX_PARA_1 && !(is_ctrl)) {\n            // Caspar-Klug\n            /**/ if (keyClick(72/* h */)) data.r += 1.0 * (is_shift ? -1.0 : 1.0);\n            else if (keyClick(75/* k */)) data.g += 1.0 * (is_shift ? -1.0 : 1.0);\n            data.r = data.r < 0.0 ? 0.0 : data.r;\n            data.g = data.g < 0.0 ? 0.0 : data.g;\n            // Wythoff Construction\n            float offset = is_shift ? float(TILINGS.length() / 2) : 0.0;\n            for (int i = 0; i < TILINGS.length() / 2; i++) \n                if (keyClick(i + 49 /* 1 */))\n                    data.b = float(i) + offset;\n            // thickness\n            if (keyClick(84/* t */)) data.a += 1.0 * (is_shift ? -1.0 : 1.0);\n            data.a = data.a < 1.0 ? 1.0 : data.a;\n        }\n        else if (iv == IDX_PARA_2 && !(is_ctrl)) {\n            /**/ if (keyClick(70/* f */)) data.r += 1.0 * (is_shift ? -1.0 : 1.0); // fiber\n            else if (keyClick(90/* z */)) data.g += 1.0 * (is_shift ? -1.0 : 1.0); // zoom\n            data.r = data.r < 0.0 ? 0.0 : data.r;\n        }\n        else if (iv == IDX_MODE_1) {\n            if (is_ctrl) {\n                /**/ if (keyClick(49/* 1 */)) data.r = MODE_ICOSA;\n                else if (keyClick(50/* 2 */)) data.r = MODE_FACET;\n                else if (keyClick(51/* 3 */)) data.r = MODE_PLANE;\n            } else {\n                /**/ if (keyClick(76/* l */)) data.g *= -1.0; // lines\n                else if (keyClick(80/* p */)) data.b *= -1.0; // paths\n                else if (keyClick(82/* r */)) data.a *= -1.0; // rando\n            }\n        }\n        else if (iv == IDX_MODE_2) {\n            /**/ if (keyClick(67/* c */)) data.r *= -1.0; // point\n            else if (keyClick(83/* s */)) data.g *= -1.0; // rspin\n        }\n    }\n    \n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsGRH.jpg", "access": "api", "license": "mit", "functions": [[5485, 5485, 5516, 5516, 5792], [5794, 5794, 5818, 5818, 6023], [6025, 6025, 6072, 6072, 6234], [6236, 6236, 6291, 6291, 7290]], "test": "untested"}
{"id": "cls3RX", "name": "Infinite arcs", "author": "mrange", "description": "Seen some CG art with infinite \"zooming\" \nThought I experiment up a distance field to support that\nEnded up with this which isn't really what I hoped for especially the infinite \"zooming\". \nFound it interesting enough to share though.", "tags": ["2d", "infinite"], "likes": 30, "viewed": 439, "published": 3, "date": "1672153701", "time_retrieved": "2024-07-30T16:10:47.845550", "image_code": "// CC0: Infinite arcs\n//  Seen some CG art with infinite \"zooming\" \n//  Thought I experiment up a distance field to support that\n//  Ended up with this which isn't really what I hoped for especially\n//  the infinite \"zooming\". \n//  Found it interesting enough to share though.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 sca(float a) {\n  return vec2(sin(a), cos(a)); \n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat arc(vec2 p, vec2 sc, float ra, float rb) {\n  // sc is the sin/cos of the arc's aperture\n  p.x = abs(p.x);\n  return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nvec2 cell(float n) {\n  float n2 = n*n;\n  float pn2 = (n-1.0)*(n-1.0);\n  float m = (n2+pn2)*0.5;\n  float w = (n2-pn2);\n  return vec2(m, 0.5*w);\n}\n\nvec2 df(vec2 p) {\n  float tm = 4.0*TIME;\n  float m = mod(tm, 1.0);\n  float f = floor(tm);\n  const float z = 0.0005;\n  p /= z;\n  float l = length(p);\n\n  float n0 = ceil(sqrt(l));\n  vec2 c0 = cell(n0); \n  \n  float nn = n0 + 1.0;\n  vec2 cn = cell(nn); \n\n  float np = n0 - 1.0;\n  vec2 cp = cell(np); \n\n  vec2 c = mix(c0, cn, m); \n  vec2 cc = mix(cp, c0, m);\n\n  float h0 = hash(n0-f);\n  float hp = hash(np-f);\n\n  float cd0 = abs(l-c.x)-c.y;\n  float cd1 = abs(l-cc.x)-cc.y;\n  const float w = 2.0/3.0;\n  \n  bool t = cd1 < cd0;\n  float h =  t ? hp : h0;\n  float a = TAU*h+(h-0.5)*TIME;\n  p *= ROT(a);\n  float d0 = arc(p, sca(1.0+0.5*PI*fract(8677.0*h0)), c.x, c.y*w);\n  float d1 = arc(p, sca(1.0+0.5*PI*fract(8677.0*hp)), cc.x, cc.y*w);\n  float d = t ? d1 : d0;\n\n  d *= z;\n  return vec2(d, h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa =2.0/RESOLUTION.y;\n  vec2 d2 = df(p);\n  vec3 col = vec3(0.00);\n  vec3 bcol = hsv2rgb(vec3(d2.y, 0.9, 1.0));\n  col = mix(col, bcol, smoothstep(aa, -aa, d2.x));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cls3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 630, 630, 776], [1071, 1131, 1153, 1153, 1201], [1203, 1203, 1222, 1222, 1256], [1258, 1376, 1424, 1469, 1599], [1601, 1601, 1621, 1621, 1745], [1747, 1747, 1764, 1764, 2534], [2536, 2536, 2591, 2591, 2910]], "test": "untested"}
{"id": "mlXGzf", "name": "Fork Elephant Ears", "author": "drliquidglitch", "description": "Trying to make a falling leaf shader\nforked from https://www.shadertoy.com/view/XsVGzm", "tags": ["raymarching", "distancefield", "leaf", "plant"], "likes": 2, "viewed": 167, "published": 3, "date": "1672147521", "time_retrieved": "2024-07-30T16:10:48.590558", "image_code": "// Originally created by Hsiang Yun 2016 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This shader is inspired by the leaf in https://www.shadertoy.com/view/ld3Gz2  (iq's Snail)\n\n\n/***************************\n\t\tUtility\n****************************/\n\nfloat rand(float id){\n    return fract(sin(id * 37.0) * 43758.5453);\n}\n\nfloat smin( float a, float b, float k )\n{\n  \tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax ( float a, float b, float k )\n{\n    return -smin(-a,-b, k);\n}\n\nfloat sub ( float a , float b )\n{\n    return smax(-b, a, 0.10);\n}\nvec2 rot ( vec2 p, float a ) \n{\n    a = radians(a);\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(vec2(c, s), vec2( -s, c )) * p; \n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat sdEllipse( vec2 p, vec2 r ) \n{\n    return ( length(p/r) - 1.0 ) * min(r.x,r.y);\n}\n\n/***************************\n\t\tGlobal\n****************************/\n#define INF 1.0e38\nstruct Hit\n{\n    float d;\n    float mID;\n    vec3 diff;\n    float thickness;\n};\n\nfloat leafID;\nvec3 darkgreen = vec3 ( 0.2,0.8,0.05) *0.02;\nvec3 yellow = vec3 ( 0.8,0.8,0.2)*0.04;\nvec3 leafClr()\n{\n    if ( leafID < 0.5 )\n        return darkgreen;\n    else if (leafID < 1.5 )\n        return darkgreen.yxz;\n    else if (leafID < 2.5 )\n        return darkgreen.zxy;\n    return yellow;\n}\nvec3 edgeClr()\n{\n    return yellow;\n}\n\n/***************************\n\tAlocasia Modeling\n****************************/\nvec2 sdVeins ( in vec3 p, in float rot_a, vec2 w, vec3 range, vec2 yoff, vec2 cnt_) \n{\n    float cntR = cnt_.x;\n    float cntL = cnt_.y;\n    float cnt = (p.x> 0.0) ? cntR : cntL;\n    float yoffsetR = yoff.x;\n    float yoffsetL = yoff.y;\n    float w2 = 0.01;\n    vec3 q = p ;\n    // stem \n    float dStem = abs(p.x) - w.x;\n    // offset & mirror\n    p.y += ( p.x > 0.0 ) ? yoffsetR : yoffsetL;\n    p.x = abs(p.x);    \n    q.x = abs(q.x);\n    // rotate\n    p.xy = rot ( p.xy, rot_a);\n    q.xy = rot ( q.xy, rot_a);\n    // repeat\n    p.y = sin (cnt* p.y) / cnt;\n    \n    float dVeins = abs(p.y) - 0.0005;\n    float dVeinRange = abs ( q.y + range.x  ) - range.y ;\n    // intersetion with range\n    dVeins = max ( dVeins, dVeinRange  ) ;\n    dVeins = smin ( dVeins, dStem, 0.01);\n    return vec2(dVeins, w.y);\n}\n\n\nHit sdLeaf ( in vec3 p, float rbias ) \n{\n    vec3 q = p;\n    float a = atan ( p.y, p.x ) ;\n    \n    // sharpen the heart shape\n    p.x = 1.1 * p.x * exp( -0.4*((p.y)));\n    float r = 1.0 - sin ( a ) ;  r += rbias;\n    \n    // veins \n  \tvec2 dVeins = sdVeins( p,28.0,  vec2(0.02,0.01), vec3(0.75,0.55,0.0), vec2(0.4,0.43), vec2(15.0,15.0));\n    vec3 p1 = p;\n    p1.x = abs(p1.x);\n    p1.y +=0.4;\n    p1.xy = rot(p1.xy,-110.0);\n    vec2 dVeins2 = sdVeins (p1, 42.0, vec2(0.005,0.01),vec3(0.8,0.7,0.1), vec2(0.0,0.03), vec2(20.0,15.0) );\n\n    vec3 p0 = p; \n    p.z += (1.0-smoothstep ( 0.0, 0.1, dVeins.x)) * 0.01; \n    p.z += (1.0-smoothstep ( 0.0, 0.05, dVeins2.x)) * 0.0025; \n   \n    // domain operation  \n    float dheart = length ( p ) -r ;\n    float mID = (p.z > 0.0) ? 1.5 : 0.5;\n    float dslab = abs(p.z) - 0.02;\n    float dhole = sdEllipse ( q.xy + vec2(0,-0.3), vec2(0.05,0.4));\n    float d = dheart ;\n    d = smax( d, dslab, 0.4);\n    d = sub ( d, dhole);   \n      \n    // vein material\n    float mVein1 = (1.0-smoothstep ( 0.0, dVeins.y, dVeins.x));\n    float mVein2 = (1.0-smoothstep ( 0.0, dVeins2.y, dVeins2.x));\n    float mVein = max ( mVein1, mVein2);\n   \t// leaf material \n    vec3 mat = mix( leafClr(), edgeClr() , smoothstep(-0.5 ,0.0, dheart )) ;\n    // final material  \n    mat += yellow * mVein * (1.0-smoothstep(-1.0,-0.25, dheart));\n    \n    // material stuff\n    Hit hit;\n    hit.d = d;\n    hit.mID = mID;\n    hit.diff = (mID > 1.0 ) ? mat :  mix( mix(edgeClr()*5.0,leafClr()*5.0,0.7), leafClr()*5.0 , smoothstep(-0.9 ,0.0, dheart ));;\n    hit.thickness = mVein * (1.0-clamp(smoothstep(-1.0,-0.35, dheart),0.0,1.0));\n \treturn hit;\n}\n\nHit sdDistortLeaf ( vec3 p ) \n{\n    // scale \n    p *= 0.45;\n    // bias\n    p.y -= 0.4;\n    p.z -= length(p.xy) *0.3 ;\n    p.z += 0.1;\n    // z vibration around the edge\n    vec3 q = p;\n    if ( q.x < 0.0 ) q.y-= 0.2;\n    q.x = abs(p.x);\n    float w = smoothstep(0.3,1.0, -q.y ) ; \n    q.xy = rot (q.xy, 30.0);\n    p.z += w * 0.1* sin(30.0*q.y*(1.0+q.y))* abs(p.x*p.x*p.x*q.x);\n  \n    // r vibration \n    vec3 v = q - vec3(0.0,-0.6,0.0);\n    float a2 = atan ( v.y, v.x);\n    float rbias = 0.04 * cos ( 22.0*a2);\n    // alocasia shape \n    return sdLeaf( p, rbias)   ;    \n}\n\nHit sdStem ( in vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    float d = sdBezier( a, b, c, p ).x;\n    d = abs(d) - mix(0.08, 0.1, clamp(-p.y,0.0,1.0));\n\tHit hit;\n    hit.d = d ;\n    hit.mID = 2.5;\n    vec3 yellow = vec3 ( 0.0,0.0,0.0);\n    hit.diff = yellow ;\n    hit.thickness = 1.0;\n    return hit;\n}\n\nHit sdAlocasia( in vec3 p, vec3 a, vec3 b, vec3 c, float leaf_rot )\n{\n    // float down from top\n    vec3 offset =  a ;\n    vec3 q = p - a;\n    q.y *= (sin(iTime*leaf_rot*0.01));\n    q.yz = rot (q.yz, leaf_rot) ;\n    Hit hitA = sdDistortLeaf ( q  ) ; \n    Hit hit = hitA;\n    return hit;\n}\n\nHit sdGround ( in vec3 p)\n{\n    Hit hit;\n    hit.d = p.y - 0.3;\n    hit.mID = 1.5;\n    hit.diff = vec3(0.0,0.0,0.0);\n    hit.thickness = 1.0;\n    return hit;\n}\n\nHit sdScene ( in vec3 p )\n{\n    Hit h_grnd = sdGround ( p ) ;\n    \n    leafID = 0.0;    \n    if ( p.z > 0.0 )\n    {\n        p *= 0.9;\n        leafID = 0.0;\n        if (p.x > 0.0 )\n        {\n            leafID = 1.0;\n        }\n    }\n    else\n    {\n        leafID = 2.0;\n        if (p.x > 0.0 )\n        {\n            p *= 0.85;\n            leafID = 3.0;\n        }\n    }\n    \n    float heightBais = rand( leafID + 5.0 ) * 4.0;\n    float sideBias = rand( leafID + 1.0 )* 1.5 +2.5; \n    vec3 a = vec3(0.0, 4.0+heightBais,sideBias);\n    vec3 b = vec3(0.0, 2.0+heightBais,sideBias * 0.1); \n    vec3 c = vec3(0.0, 0.0,0.0);    \n    p.x = abs(p.x);  \n\tp.z = abs(p.z);\n    p.xz = rot(p.xz, 40.0);\n    Hit h = sdAlocasia ( p, a, b, c, mix ( 30.0,40.0, rand(leafID))) ;\n    \n    \n    //h.d = min ( h.d, h_grnd.d ) ;\n    //if ( abs(h_grnd.d) < 0.001 )  return h_grnd;\n    return h;\n}\n\n/***************************\n\t\trender\n****************************/\n\nHit getMaterial( in vec3 p ) \n{\n    return sdScene ( p ); \n}\n\nfloat map( in vec3 p )\n{\n    return sdScene ( p ).d ;     \n}\n\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;          \n\tconst float precis = 0.0001;      \n    float h = precis*2.0;\n    float t = 0.00;\n\tfloat res = INF;\n    for( int i=0; i<90; i++ )         \n    {\n        //if( h<precis||t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n    if( t<maxd ) res = t;\n    return res;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;            \n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1*map( pos + v1*eps ) + \n\t\t\t\t\t  v2*map( pos + v2*eps ) + \n\t\t\t\t\t  v3*map( pos + v3*eps ) + \n\t\t\t\t\t  v4*map( pos + v4*eps ) );\n}\n\nvec3 getLightPos()\n{\n    float t = iTime;\n    return vec3(5.0*sin(t)*1.0,15.0+ 0.1*sin(t),cos(t)*5.0);\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nml, in vec3 rd, in float dis, in Hit hit )\n{\n    vec3 lin = vec3(0.0);\n    // ambient \n    lin += vec3(0.5);  \n    // lighting factors\n    vec3 ldir = normalize( getLightPos());    \n    vec3 hal = normalize( ldir -rd );\n    float fre = clamp(1.0+dot(nml,rd), 0.0, 1.0 );\n    float ndl = dot( nml, ldir ) ;\n    float dif = max(ndl,0.0);\n    float spe1 = clamp( dot(nml,hal), 0.0, 3.0 );\n    // shadow \n    float sha = 0.0; \n    //if( dif>0.01 ) sha= softshadow( pos+0.01*nml, ldir );\n    // simple lighiting\n    lin += pow( spe1, 1.0  + 5.0) * vec3(0.0);\n    lin += pow( fre,3.0) * dif * vec3(15.0) ;   \n    lin += dif * vec3(7.00)*sha;\n    \n    vec3 col = vec3(0.0);\n    col = hit.diff*lin;\n    \n    // leaf backface lighting \n    // http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\n    if (hit.mID < 1.0)\n    {       \n\t    float edl = clamp(dot (rd, ldir), 0.0, 1.0);\n\t    edl *= edl;     \n    \tlin +=  mix ( edl, -ndl, 0.1) *10.0* (1.0-hit.thickness);\n       \tcol = hit.diff * lin;\n    }\n    // fog\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro )* abs(cos(iTime*0.2));\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) )* abs(sin(iTime*0.5));\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    // camera \n    vec3 ro, ta;\n    float an = 0.3*iTime + 5.0*m.x;\n    float r = 10.0;\n\tro = vec3(r*sin(an), 3.0 +3.0* m.y,r*cos(an));\n    ta = vec3(0.0,6.0,0.0);    \n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \n\tvec3 rd = normalize( camMat * vec3(p.xy,1.0) ); \n    \n\tvec3 col = vec3 (0.0);\n\t// raymarch\n    float d  = raymarch( ro, rd );\n    if( d != INF )\n    {\n        float t = d;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        col = doLighting( pos, nor, rd, t,  getMaterial ( pos ) );        \n\t}\n    // sprite\n    vec3 ldir = normalize(getLightPos());\n    float lsprite =  clamp(pow (dot ( normalize(getLightPos()- ro), rd )*0.5+0.5, 128.0),0.0, 10.0);\n    lsprite = smoothstep(0.98,1.0, lsprite);\n\tcol += lsprite* lsprite;\n\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\t   \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXGzf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[296, 296, 317, 317, 366], [368, 368, 409, 409, 501], [503, 503, 545, 545, 575], [577, 577, 610, 610, 642], [643, 643, 674, 674, 789], [791, 855, 884, 884, 910], [911, 911, 958, 958, 1436], [1438, 1438, 1487, 1487, 1897], [1899, 1899, 1935, 1935, 1986], [2255, 2255, 2271, 2271, 2458], [2459, 2459, 2475, 2475, 2496], [2498, 2576, 2662, 2662, 3382], [3385, 3385, 3425, 3425, 5041], [5043, 5043, 5074, 5088, 5617], [5619, 5619, 5669, 5669, 5914], [5916, 5916, 5985, 6012, 6205], [6207, 6207, 6234, 6234, 6366], [6368, 6368, 6395, 6395, 7238], [7309, 7309, 7340, 7340, 7369], [7371, 7371, 7395, 7395, 7431], [7433, 7433, 7475, 7475, 7787], [7790, 7790, 7822, 7822, 8177], [8179, 8179, 8199, 8199, 8283], [8285, 8285, 8368, 8368, 9383], [9386, 9386, 9450, 9450, 9670], [9672, 9672, 9729, 9729, 10701]], "test": "untested"}
{"id": "clf3zf", "name": "Scaling Squares", "author": "rog", "description": "Color-changing squares whose size changes with relative mouse position", "tags": ["beginner"], "likes": 7, "viewed": 252, "published": 3, "date": "1672131940", "time_retrieved": "2024-07-30T16:10:49.333571", "image_code": "#define PI 3.141592\n\n// Number of squares in each axis\nvec2 grid = vec2(32.0, 18.0);\n\n// Margin on each edge of the view, as a proportion of the size of the constraining axis\nfloat padding = 0.00;\n\n// Margin for each square edge, as a proportion of the side length\nfloat spacing = 0.2;\n\nvec4 BLACK = vec4(vec3(0.0), 1.0);\n\n/// Component-wise maximum\nfloat min2(vec2 vec) {\n  return min(vec.x, vec.y);\n}\n\nvec4 fC(in vec2 fragCoord) {\n  // Largest size possible such that the grid elements are squares\n  vec2 usableSize = min2(iResolution.xy / grid) * grid;\n\n  vec2 sizeWithPadding = usableSize * (1.0 - 2.0 * padding);\n\n  // Psuedo-UV coordinate in [-0.5, 0.5]\n  vec2 uv = (fragCoord - iResolution.xy / vec2(2.0)) / sizeWithPadding;\n  vec2 mouseUv = (iMouse.xy - iResolution.xy / vec2(2.0)) / sizeWithPadding;\n  if (iMouse.z < 1.0) {\n    // If user not clicking, the center can move around in a circle\n    mouseUv = vec2(cos(iTime / 2.0), sin(iTime / 2.0)) * vec2(0.5 * 0.6);\n  }\n\n  // Ignore values outside the grid\n  if (any(greaterThan(abs(uv), vec2(0.5)))) {\n    return BLACK;\n  }\n\n  // If even number of elements, screen center is corner between grids\n  // If odd number of elements, screen center is center of a grid box\n  vec2 offset = vec2(0.5) * mod(grid + 1.0, 2.0);\n  vec2 gridPosition = uv * grid + offset;\n  // Position of nearest grid center in psuedo-UV\n  vec2 nearestCellCenter = round(gridPosition) / grid;\n\n  // Vector for fragment from nearest grid center in [-0.5, 0.5]\n  vec2 normVecFromCenter = gridPosition - nearestCellCenter * grid;\n\n  float mouseDist = length((nearestCellCenter - offset / grid) - mouseUv);\n  // As mouse distance from center increases, box size shrinks\n  float scalingFactor = max(0.1, 1.0 - mouseDist);\n\n  // Take spacing into account - padding on both edges, so multiply by 2\n  float normThreshold = 0.5 / (1.0 + 2.0 * spacing) * scalingFactor;\n  if (any(greaterThan(abs(normVecFromCenter), vec2(normThreshold)))) {\n    return BLACK;\n  }\n\n  return vec4(\n    cos(nearestCellCenter.x * PI + iTime) / 2.0 + 0.5,\n    sin(nearestCellCenter.y * PI + iTime) / 2.0 + 0.5,\n    1.0,\n    1.0\n  );\n}\n\n\n// Box-filter by Greg Rostami\n// Add this code to the bottom of any shader that has aliasing problems:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 8.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clf3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 350, 372, 372, 402], [404, 404, 432, 499, 2132], [2135, 2238, 2295, 2295, 2597]], "test": "untested"}
{"id": "Dtf3Rf", "name": "Rainbow Bump (314 chars)", "author": "fenix", "description": "Just a little fun shader to cleanse the palette since I've been working on so much more difficult ones lately.", "tags": ["raymarch", "codegolf"], "likes": 19, "viewed": 280, "published": 3, "date": "1672123855", "time_retrieved": "2024-07-30T16:10:50.125454", "image_code": "// From FabriceNeyret2: 314 chars\n//*\n#define n normalize\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3  R = iResolution,\n          u = ( U.xyy -.5*R ) / R.y,\n          p = vec3(6, 9, 3),\n          x = n(p.zzy - p.xzz), \n          r = u.x * x - u.y * n(cross(p, x)) - n(p);\n    float v = x.z;\n    \n    for (; v > .01;  )\n        R = exp(abs( p += .2*r * v )),\n        v = p.y - 15. * sin(p.z) / (R.x+R.z);\n    \n    v = p.x - iTime * .2;\n    O =   smoothstep(.2, .4, abs(fract(v * 2.) - .5)) \n       * ( sin(v + vec4(0, 1, 3, 0)) * .5 + .5 );\n}\n/**/\n\n// My golfing attempt: 333 chars\n/*\n#define n normalize\n#define R iResolution\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    u -= .5 * R.xy;\n    u /= R.y;\n    \n    vec3 p = vec3(6, 9, 3),\n         x = n(p.zzy - p.xzz),\n         r = (u.x * x - u.y * n(cross(p, x)) - n(p)) * .2;\n\n    for (;x.z > .01; x.z = p.y - 15. * sin(p.z) / (exp(abs(p.x)) + exp(abs(p.z))))\n        p += r * x.z;\n    \n    x.x = p.x - iTime * .2;\n    O = smoothstep(.2, .4, abs(fract(x.x * 2.) - .5)) * (sin(x.x + vec4(0, 1, 3, 0)) * .5 + .5);\n}\n/**/\n\n// Original (450 chars)\n/*\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    u = (u - .5*iResolution.xy) / iResolution.y;\n    vec3 p = vec3(6, 6, 3);\n    vec3 c = normalize(-p);\n    vec3 x = normalize(cross(c, vec3(0, -1, 0)));\n    vec3 y = normalize(cross(c, x));\n    vec3 r = normalize(c + u.x*x + u.y*y);\n\n    for (int i = 0; i < 1000; ++i)\n    {\n        float f = sin(p.z) / (exp(abs(p.x)) + exp(abs(p.z)));\n        float d = p.y - f*12.;\n        if (d < .0001) break;\n        p += r * d * .2;\n    }\n    \n    float t = p.x - iTime * .2;\n    vec3 color = sin(t + vec3(0, 1, 3)) * .5 + .5;\n    O = vec4(smoothstep(.1, .2, abs(mod(t, .5) - .25))) * vec4(color, 1);\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtf3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 97, 97, 546]], "test": "untested"}
{"id": "ctf3zf", "name": "Mouse Draw Condensation (LOD)", "author": "MysteryPancake", "description": "Click and drag :) LOD remake of https://www.shadertoy.com/view/7lcfDM", "tags": ["blur", "water", "glass", "lod", "draw", "mirror", "buffer", "window", "blurred", "blurred", "condensation"], "likes": 22, "viewed": 535, "published": 3, "date": "1672118563", "time_retrieved": "2024-07-30T16:10:50.870462", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float blur = texture(iChannel0, uv).r;\n    fragColor = textureLod(iChannel1, uv, 6.0 - blur);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float blur = max(0.0, texture(iChannel0, uv).r - 0.05);\n    if (iMouse.z > 0.0) {\n        float circleSdf = distance(fragCoord, iMouse.xy);\n        blur = max(blur, 6.0 * smoothstep(128.0, 0.0, circleSdf));\n    }\n    fragColor.r = blur;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctf3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 197]], "test": "untested"}
{"id": "ctX3zf", "name": "Ortho To Azimuthal Equidistant", "author": "blendermf", "description": "Ortho To Azimuthal equidistant projection", "tags": ["distortion"], "likes": 0, "viewed": 171, "published": 3, "date": "1672115139", "time_retrieved": "2024-07-30T16:10:51.669326", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    uv.x += (1. - aspect)*0.5;\n    \n    vec2 uvFromCenter = (uv - vec2(0.5,0.5));\n    float dist = length(uvFromCenter)*2.;\n    \n    vec2 newuv = (uvFromCenter * (sin(dist * PI / 2.) / dist)) + vec2(0.5,0.5);\n    vec4 col = texture(iChannel0, newuv);\n    vec4 col2 = texture(iChannel0, uv);\n   \n\n    if (dist < 1.) {\n            fragColor = col;\n    } else {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n    \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctX3zf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 133, 652]], "test": "untested"}
{"id": "DtXGzf", "name": "Mirror in mirror", "author": "shaofun", "description": "A very simple physics-based ray-tracing renderer.\nWASDQE to move, SHIFT to accelerate, SPACE to refresh.\n\nmore info: https://shao.fun/blog/w/taichi-ray-tracing.html\ngithub: https://github.com/HK-SHAO/RayTracingPBR", "tags": ["3d", "interactive", "sdf", "camera", "pathtracing", "ibl", "pbr"], "likes": 2, "viewed": 223, "published": 3, "date": "1672111331", "time_retrieved": "2024-07-30T16:10:52.674638", "image_code": "// Fork of \"Air in glass\" by shaofun. https://shadertoy.com/view/cls3Rj\n// 2022-12-27 03:19:47\n\n// Fork of \"fix ior\" by shaofun. https://shadertoy.com/view/mtfGzj\n// 2022-12-26 10:24:12\n\n// Fork of \"RayTracing PBR with Free Camera\" by shaofun. https://shadertoy.com/view/ddSSWy\n// 2022-12-26 05:00:26\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = vec4(color.rgb / color.a, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Modified by HK-SHAO - 2022\n\n// Upgraded from genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define key(K)  texelFetch(iChannel0, ivec2(K, 0), 0).x\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Keyboard constants definition\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_Q     = 81;\nconst int KEY_SHIFT = 16;\nconst int KEY_SP    = 32;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A), \n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 m) {\n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) discard;\n    \n    fragColor = load(fragCoord);\n    \n    if (iFrame == 0) {\n        store(POSITION, vec4(1.9, 0.0, 1.9, 0.0));\n        store(ROTATION, vec4(PI/4.0, PI/5.10, 0.0, 0.0));\n        \n        store(TARGET,   vec4(1.9, 0.0, 1.9, 0.0));\n        store(TMOUSE,   vec4(PI/4.0, PI/5.10, 0.0, 0.0));\n        store(PMOUSE,   vec4(PI/4.0, PI/5.10, 0.0, 0.0));\n        \n        return;\n    }\n\n    vec2 resolution  = load(RESOLUTION).xy;\n    \n    vec3 position    = load(POSITION).xyz;\n    vec2 rotation    = load(ROTATION).xy;\n\n    vec3 target      = load(TARGET).xyz;\n    vec3 tm          = load(TMOUSE).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    \n    float dt = clamp(iTimeDelta, 0.0, 0.1);\n    \n    const float rt_acc = 16.0;\n    const float mv_acc = 5.0;\n    float velocity =  5.0 + 15.0 * key(KEY_SHIFT);\n    \n    rotation += (tm.xy - rotation) * dt * rt_acc;\n    target   += CameraDirInput(rotation) * dt * velocity;\n    position += (target - position) * dt * mv_acc;\n    \n    bvec4 moving = bvec4(\n        length(tm.xy - rotation) * iResolution.x > 1.0,\n        length(target - position) * iResolution.x > 1.0,\n        any(notEqual(resolution, iResolution.xy)),\n        key(KEY_SP) > 0.0\n    );\n    \n    store(TARGET,     vec4(target, 0.0));\n    store(POSITION,   vec4(position, 0.0));\n    store(ROTATION,   vec4(rotation, 0.0, 0.0));\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(MOVING,     vec4(any(moving), 0.0, 0.0, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n        vec2 new_tm  = pm + (abs(iMouse.zw) - iMouse.xy) / iResolution.x;\n        \n        float clamp_y = float(new_tm.y > -PI*0.5+0.01 && new_tm.y < PI*0.5-0.01);\n        new_tm.y = mix(tm.y, new_tm.y, clamp_y);\n        \n        store(TMOUSE, vec4(new_tm, 1.0, 0.0));\n\t} else if (tm.z != 0.0) {\n        store(PMOUSE, vec4(tm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\n// Buffer A Shared\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 PMOUSE     = ivec2(0, 0);\nconst ivec2 TARGET     = ivec2(1, 0);\nconst ivec2 TMOUSE     = ivec2(2, 0);\n\nconst ivec2 RESOLUTION = ivec2(0, 1);\nconst ivec2 POSITION   = ivec2(1, 1);\nconst ivec2 ROTATION   = ivec2(2, 1);\n\nconst ivec2 MOVING     = ivec2(0, 2);\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}\n\n// Update History\n\n// 2022.12.26\n// 1. enables metal to be used in IOR.\n// 2. small optimization of performance.\n\n// 2022.12.24\n// 1. fixed camera jamming when looking up and down.\n\n// 2022.12.23\n// 1. fix the blackening of rough transparent material, it optimized the frame rate (more than twice).\n// 2. fix the camera misalignment when full screen.\n// 3. fix the inability to propagate reflected light inside an object.\n// 4. optimize the judgment about self-luminous light source.\n// 5. some formatting optimizations and minor efficiency optimizations.\n// 6. gamma correction for skybox.\n\n// 2022.12.21\n// 1. make the rotation of the view smooth.\n// 2. automatically perform noise reduction when stopping movement.\n// 3. hold down space to force a screen refresh.", "buffer_b_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// 摄像机参数\nconst float camera_vfov       = 36.0;                 // 摄像机的纵向视野\nconst float camera_focus      = 1.9*sqrt(3.0);        // 摄像机的对焦距离\nconst float camera_aperture   = 0.01;                 // 摄像机的光圈大小\nconst float camera_exposure   = 0.5;                  // 摄像机曝光值\nconst float light_quality     = 128.0;                // 间接光质量\nconst float gamma             = 2.2;                  // 伽马矫正值\n\n// 配置常量\nconst float TMIN         = 0.005;                      // 光开始传播的起始偏移，避免光线自相交\nconst float TMAX         = 2000.0;                     // 最大单次光线传播距离 (相当于可见范围)\nconst float PRECISION    = 0.0005;                     // 需小于 TMIN，否则光线无法正常离开物体表面\nconst float VISIBILITY   = pow(1.0 / 256.0, gamma);    // 亮度可见度\n\nconst uint  MAX_RAYMARCH = 512U;                      // 最大光线步进次数\nconst uint  MAX_RAYTRACE = 128U;                      // 最大光线追踪次数\n\nconst float ENV_IOR      = 1.000277;                  // 环境的折射率 （空气）\n\n// 枚举形状\nconst int SHAPE_SPHERE   = 0;\nconst int SHAPE_BOX      = 1;\nconst int SHAPE_CYLINDER = 2;\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// 物体材质\nstruct material {\n    vec3  albedo;       // 反照率\n    vec3  emission;     // 自发光\n    vec3  normal;       // 切线空间法线\n    float roughness;    // 粗糙度\n    float metallic;     // 金属度\n    float transmission; // 透明度\n    float ior;          // 折射率\n    bool  solid;        // 是否实心\n};\n\n// 物体变换\nstruct transform {\n    vec3 position;      // 位置\n    vec3 rotation;      // 旋转\n    vec3 scale;         // 缩放\n};\n\n// SDF 物体\nstruct object {\n    int       shape;    // 形状\n    float     dis;      // 距离物体表面\n    transform trs;      // 变换\n    material  mtl;      // 材质\n};\n\n// 光线\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\n// 光子击中的记录\nstruct record {\n    object obj;         // 物体\n    vec3   pos;         // 击中的位置\n    vec3   normal;      // 世界空间法线\n    bool   hit;         // 是否击中\n};\n\n// 摄像机\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\n// SDF 球体\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// SDF 盒子\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SDF 圆柱\nfloat sd_cylinder(vec3 p, vec2 rh) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - rh;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// 地图列表\nconst object[] map = object[] (\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0, -1.5, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.5, 0.5, 0.5)\n        ),\n        material(   vec3(1.0, 1.0, 1.0), // 基础色\n                    vec3(1.0)*10.0, // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0,   // 粗糙度\n                    1.0,   // 金属度\n                    0.0,   // 透明度\n                    1.000, // 折射率 （真空）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_CYLINDER, ZERO,\n        transform(  vec3(-1.0, -1.7, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 0.2, 0.2), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.1,   // 粗糙度\n                    0.0,   // 金属度\n                    0.0,   // 透明度\n                    1.460, // 折射率 （塑料）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_CYLINDER, ZERO,\n        transform(  vec3(0, -1.7, -1.0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 1.0, 0.2), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    1.0,   // 粗糙度\n                    0.0,   // 金属度\n                    0.0,   // 透明度\n                    1.460, // 折射率 （塑料）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(1.0, -1.7, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(0.2, 0.2, 1.0), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.2,   // 粗糙度\n                    1.0,   // 金属度\n                    0.0,   // 透明度\n                    1.100, // 折射率 （铜）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0.0, -1.7, 1),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0,   // 粗糙度\n                    0.0,   // 金属度\n                    1.0,   // 透明度\n                    1.500, // 折射率 （玻璃）\n                    true   // 是否实心\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, 0),\n                    vec3(0, 0, 0),\n                    vec3(2, 2, 2)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.500,  // 折射率 （金）\n                    false   // 是否实心\n        )\n    )\n);\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\n// 从摄像机获取光线\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2 rud = lens_radius * random_in_unit_disk();\n    vec3 offset = x * rud.x + y * rud.y;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\n// 从欧拉角计算旋转矩阵\nmat3 angle(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3(vec3( c.z,  s.z,    0),\n                vec3(-s.z,  c.z,    0),\n                vec3(   0,    0,    1)) *\n           mat3(vec3( c.y,    0, -s.y),\n                vec3(   0,    1,    0),\n                vec3( s.y,    0,  c.y)) *\n           mat3(vec3(   1,    0,    0),\n                vec3(   0,  c.x,  s.x),\n                vec3(   0, -s.x,  c.x));\n}\n\n// 计算有向距离 (物体内部距离为负)\nfloat signed_distance(object obj, vec3 pos) {\n    vec3 position = obj.trs.position;\n    vec3 rotation = obj.trs.rotation;\n    vec3 scale    = obj.trs.scale;\n    \n    vec3 p = pos - position;\n    \n    // 会重复的将欧拉角转换成旋转矩阵，实际上只用在第一次计算就行了\n    // 也有可能被编译器优化掉了\n    p *= angle(radians(rotation));\n    \n    switch(obj.shape) {\n        case SHAPE_SPHERE:\n            return sd_sphere(p, scale.x);\n        case SHAPE_BOX:\n            return sd_box(p, scale);\n        case SHAPE_CYLINDER:\n            return sd_cylinder(p, scale.xy);\n        default:\n            return sd_sphere(p, scale.x);\n    }\n}\n\n// 找到最近的物体并计算距离\nobject nearest_object(vec3 p) {\n    object o; o.dis = TMAX;\n    for (int i = 0; i < map.length(); i++) {\n        object oi = map[i];\n        oi.dis = abs(signed_distance(oi, p));\n        if (oi.dis < o.dis) o = oi;\n    }\n    return o;\n}\n\n// 找到最近的物体并计算距离\nobject innermost_object(vec3 p) {\n    object o; o.dis = TMAX; o.mtl.ior = ENV_IOR;\n    for (int i = 0; i < map.length(); i++) {\n        object oi = map[i];\n        float signed = signed_distance(oi, p);\n        oi.dis = abs(signed);\n        if (oi.dis < o.dis && signed < 0.0) o = oi;\n    }\n    return o;\n}\n\n// 计算物体法线 from https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal(object obj, vec3 p) {\n    vec2 e = vec2(1, -1) * 0.5773 * 0.0005;\n    return normalize( e.xyy*signed_distance(obj, p + e.xyy) + \n                      e.yyx*signed_distance(obj, p + e.yyx) + \n                      e.yxy*signed_distance(obj, p + e.yxy) + \n                      e.xxx*signed_distance(obj, p + e.xxx) );\n}\n\n// 用世界坐标下的法线计算 TBN 矩阵 from https://doi.org/10.1080/2165347X.2012.689606\nmat3 TBN(vec3 N) {\n    vec3 T, B;\n    \n    if (N.z < -0.99999) {\n        T = vec3(0, -1, 0);\n        B = vec3(-1, 0, 0);\n    } else {\n        float a = 1.0 / (1.0 + N.z);\n        float b = -N.x*N.y*a;\n        \n        T = vec3(1.0 - N.x*N.x*a, b, -N.x);\n        B = vec3(b, 1.0 - N.y*N.y*a, -N.y);\n    }\n    \n    return mat3(T, B, N);\n}\n\n// 使用光线步进 (Ray March) 检测第一个交点\nrecord raycast(ray r) {\n    record rec; float t = TMIN;\n    for(uint i = 0U; i < MAX_RAYMARCH && t < TMAX && !rec.hit; i++) {\n        rec.pos = at(r, t);\n        rec.obj = nearest_object(rec.pos);\n        rec.hit = rec.obj.dis < PRECISION;\n        t      += rec.obj.dis;\n    }\n    return rec;\n}\n\n// 采样立方体贴图\nvec4 mix_cube_lod(samplerCube sharp, samplerCube blur, vec3 dir, float lod) {\n    return mix(textureLod(sharp, dir, lod), textureLod(blur, dir, lod), lod);\n}\n\n// 采样天空\nvec3 sky(ray r, float brightness, float lod) {\n    // float t = 0.5 + 0.5 * r.direction.y;\n    // vec3 bottom = vec3(1.0, 1.0, 1.0);\n    // vec3 top = vec3(0.9, 1.5, 3.0);\n    // return mix(bottom, top, t * brightness);\n    vec4 ibl = mix_cube_lod(iChannel2, iChannel3, r.direction, lod); // 天空盒 IBL 照明\n    return pow(ibl.rgb * ibl.a * brightness, vec3(gamma)); // gamma 矫正\n}\n\n// 快速计算五次方\nfloat pow5(float x) {\n    float t = x*x; t *= t;\n    return t*x;\n}\n\n// 菲涅尔反射近似值\nfloat fresnel_schlick(float cosine, float F0) {\n    return mix(pow5(abs(1.0 - cosine)), 1.0, F0);\n}\n\n// 用粗糙度计算菲涅尔\nfloat fresnel_schlick(float cosine, float F0, float roughness) {\n    return mix(fresnel_schlick(cosine, F0), F0, roughness);\n}\n\n// 以 n 为法线进行半球采样\nvec3 hemispheric_sampling() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt(r.x);\n    vec2 xy = sqrt(1.0 - r.x) * v; \n\n    return vec3(xy, z);\n}\n\n// 用粗糙度采样沿向量 n 半球采样\nvec3 hemispheric_sampling(float roughness) {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    float shiny = pow5(roughness); // 光感越大高光越锐利\n    \n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt((1.0 - r.x) / (1.0 + (shiny - 1.0) * r.x));\n    vec2 xy = sqrt(abs(1.0 - z*z)) * v;\n    \n    return vec3(xy, z);\n}\n\n// 应用 PBR 材质\nray BSDF(ray r, record rec) {\n    // 材质参数\n    vec3  albedo       = rec.obj.mtl.albedo;\n    float roughness    = rec.obj.mtl.roughness;\n    float metallic     = rec.obj.mtl.metallic;\n    float transmission = rec.obj.mtl.transmission;\n    vec3  normal       = rec.obj.mtl.normal;\n    float ior          = rec.obj.mtl.ior;\n    bool  solid        = rec.obj.mtl.solid;\n    \n    normal = TBN(rec.normal) * normal; // 将切线空间法线转换到世界空间\n    \n    // 光线和物体表面参数\n    vec3 I  =  r.direction;\n    vec3 V  = -r.direction;\n    vec3 P  =  rec.pos;\n    vec3 N  =  normal;\n    vec3 C  =  r.color;\n    vec3 L;\n    \n    float outer = sign(dot(N, V)); // 光正在从外面穿入物体表面\n    N = normal *= outer; // 如果处于 SDF 物体内部就反过来\n    \n    N = TBN(N) * hemispheric_sampling(roughness);\n    float NoV   = dot(N, V);\n    \n    // 计算交界处折射率之比\n    ior = solid ? ior : ENV_IOR;\n    object obj = innermost_object(P - outer * TMIN * I);\n    float prev_or_next_ior = obj.mtl.solid ? obj.mtl.ior : ENV_IOR;\n    float eta = outer > 0.0 ? prev_or_next_ior / ior : ior / prev_or_next_ior;\n    \n    float k = 1.0 - eta * eta * (1.0 - NoV * NoV); // 小于 0 为全反射\n    float F0  = (eta - 1.0) / (eta + 1.0); F0 *= 3.0*F0; // 让透明材质的反射更明显一些\n    float F   = fresnel_schlick(NoV, F0, roughness); // 菲涅尔\n\n    vec2 rand2 = rand21(); // 取两个随机数\n    if (rand2.y < F + metallic || k < 0.0) {\n            L = I + 2.0 * NoV * N; // 包含镜面反射、菲涅尔反射、全反射\n            // 如果光穿入或穿出表面就反过来\n            L *= float(dot(L, normal) > 0.0);\n    } else {\n        if (rand2.x < transmission) {\n            L = eta * I - (sqrt(k)- eta * NoV) * N; // 斯涅尔折射\n        } else {\n            L = TBN(normal) * hemispheric_sampling(); // 漫反射\n        }\n    }\n\n    C *= albedo;\n\n    // 更新光的方向和颜色\n    r.color     = C;\n    r.origin    = P;\n    r.direction = L;\n    \n    return r;\n}\n\n// RGB 亮度\nfloat brightness(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\n\n// 光线追踪\nray raytrace(ray r) {\n    for (uint i = 0U; i < MAX_RAYTRACE; i++) {\n        // 俄罗斯轮盘赌概率，防止光线过分的反复反射\n        float inv_pdf = exp(float(i) / light_quality);\n        float roulette_prob = 1.0 - (1.0 / inv_pdf);\n    \n        // 光线被毙掉就不用继续了\n        if (rand11() < roulette_prob) {\n            r.color *= roulette_prob;\n            break;\n        }\n        \n        // 能量守恒\n        r.color *= inv_pdf;\n        \n        // 与地图求交\n        record rec = raycast(r);\n        \n        // 没击中物体就肯定击中天空\n        if (!rec.hit) {\n            r.color *= sign(float(i)); // 纯黑色背景\n            r.color *= sky(r, 2.0, 1.0 - 1.0 / (1.0 + 0.1 * float(i)));\n            break;\n        }\n        \n        // 计算法线\n        rec.normal = calc_normal(rec.obj, rec.pos);\n        \n        // 应用 PBR 材质\n        r = BSDF(r, rec);\n        \n        // 处理自发光\n        float intensity = brightness(r.color);\n              r.color  *= rec.obj.mtl.emission;\n        float visible   = brightness(r.color);\n        \n        // 太暗或者碰到光源\n        if (visible < VISIBILITY || visible > intensity) {\n            break;\n        }\n    }\n\n    return r;\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color *= mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color = a / b;\n\t// Back to color space\n    color *= mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\n// 片段着色器程序入口\nvec4 fragment(vec2 uv, vec2 SCREEN_PIXEL_SIZE, float TIME) {\n    // 计算摄像机方位和视线\n    vec3  lookfrom  = load(POSITION).xyz;\n    vec2  rotation  = load(ROTATION).xy;\n    vec3  direction = CameraRotation(rotation) * vec3(0, 0, -1);\n    vec3  lookat    = lookfrom + direction;\n    float aspect    = SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x;;\n    \n    // 初始化摄像机\n    camera cam;\n    cam.lookfrom = lookfrom;\n    cam.lookat   = lookat;\n    cam.aspect   = aspect;\n    cam.vfov     = camera_vfov;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = camera_focus;\n    cam.aperture = camera_aperture;\n    \n    // 用 UV 和时间初始化随机数发生器种子\n    seed = rand13(vec3(uv, TIME));\n\n    // 超采样\n    uv += rand21() * SCREEN_PIXEL_SIZE;\n    \n    // 对每个光子经过的表面采样一次\n    ray r = get_ray(cam, uv, vec3(1));\n    \n    // 处理颜色\n    vec3 color = raytrace(r).color;\n\n    // 色调映射\n    color *= camera_exposure;\n    color  = ACESFitted(color);\n    \n    // 伽马矫正\n    color = pow(color, vec3(1.0 / gamma));\n\n    return vec4(color, brightness(r.color));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 SCREEN_PIXEL_SIZE = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * SCREEN_PIXEL_SIZE;\n    \n    fragColor = fragment(uv, SCREEN_PIXEL_SIZE, iTime); // 获取片元颜色\n    \n    if (bool(load(MOVING).x)) return; // 如果正在移动就不积累上一帧\n    \n    fragColor += texture(iChannel0, uv); // 积累帧进行降噪\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 357, 357, 490]], "test": "untested"}
{"id": "dtXGW4", "name": "Rough Seas ", "author": "Dave_Hoskins", "description": "It took a few hours to build, and a few days to adjust everything to balance properly.\n\n", "tags": ["3d", "waves", "raymarch", "sound", "sea", "ocean", "foam", "rough", "spray", "whitecaps"], "likes": 80, "viewed": 1942, "published": 3, "date": "1672092769", "time_retrieved": "2024-07-30T16:10:53.471508", "image_code": "// Rough Seas, by Dave Hoskins.\n// https://www.shadertoy.com/view/dtXGW4\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n// Inspiration was from: https://www.istockphoto.com/search/more-like-this/882229368?assettype=film&phrase=rough%20sea\n\n\n#define FAR 1000.\n#define FOG_COLOUR vec3(.33,.3,.3)\n#define SKY_TOP vec3(.1, .13, 0.13)\n\nvec3 camPos;\nfloat time;\nvec3 skyColour;\nconst vec3 sunDir = normalize(vec3(4,8,18));\n//#define EXPORT_VERSON\n\n//------------------------------------------------------------------------------\n// Hashes from here: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Pretty basic smoothed noise overridden as 2D & 3D...\n//------------------------------------------------------------------------------\nfloat noise(in vec2 p)\n{\n\tvec2 f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float res = mix(mix(hash12(p),\n\t\t\t\t\t\thash12(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(hash12(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\thash12(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\nfloat noise(in vec3 p)\n{\n    const vec2 add = vec2(1.0, 0.0);\n\n    vec3 f = fract(p); \n    f *= f * (3.0-2.0*f);\n    p = floor(p);\n\n    float h = mix(\n                    mix(mix(hash13(p), hash13(p + add.xyy),f.x),\n                        mix(hash13(p + add.yxy), hash13(p + add.xxy),f.x), f.y),\n                    mix(mix(hash13(p + add.yyx), hash13(p + add.xyx),f.x),\n                        mix(hash13(p + add.yxx), hash13(p + add.xxx),f.x), f.y),\n                 f.z);\n    return h*h*h*2.;\n}\n\n\n//------------------------------------------------------------------------------\n// A very basic sky...\nvec3 sky(vec3 dir)\n{\n \n    return mix(FOG_COLOUR, SKY_TOP ,abs(dir.y)*2.);\n}\n\n//-----------------------------------------------------------------\n// This creates the sea, it's complexity is governed by the incoming iteration count...\nconst float COSR = cos(.43);\nconst float SINR = sin(.52);\nconst mat2 rot2D = mat2(COSR, SINR, -SINR, COSR) * 1.4;\nfloat oceanFundamental(vec2 p, float tim, float iter)\n{\n    float a =noise(p*.01)*8.+3.0;\n    float h = 0.0;\n    float it = 1./iter;\n    float spr = 0.0;\n    p.x -= tim*5.0;\n\n    p *= .025;// ...Scale it\n\n    for (float i = 0.0; i <= 1.0; i += it)\n    {\n        float t = (1.08-i) * tim;\n        float r =noise(p*2.1+t) * i;\n        vec2 y1 = (cos(p-t)+1.0);\n        vec2 y2 = (1.0-abs(sin(p-t)));\n        \n        y1 = mix(y1, y2, r);\n          \n        float s = y1.x + y1.y;\n        \n        h += s*a;\n        \n        a *= .59;\n        p = p * rot2D;\n        p += 19.9;\n    }\n\n    return h;\n}\n\n// Map the ocean relative to the point...\n//-----------------------------------------------------------------\nfloat map(in vec3 p, float iter)\n{\n    float h = oceanFundamental(p.xz, time, iter);\n    return p.y-h;\n}\n\n// Bog standard ray marching, there's so much noise that any misses get lost...🤞\n//-----------------------------------------------------------------\nvec2 rayMarch(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    float spr = 0.0;\n    for ( int i = 0; i < 120; i++)\n    {\n        vec3 pos = p + dir*d;\n\n        float hh = oceanFundamental(pos.xz, time, 7.);\n        float h = pos.y-hh;\n        \n        if (h < .11 || d > FAR)\n        {\n            break;\n        }\n        float wind = (noise(pos*.05)) * noise(pos*2.73+vec3(-time*10., time*.11,0));\n        spr += max(25.-h, 0.0) * smoothstep(40.0, .0,max(h, 0.0))*smoothstep(FAR, 0.0,d)*smoothstep(30., 80.0, hh)\n        * wind;\n\n\n        //if (h < 0.0) h *= .5;\n        d+= h*.7;\n    }\n    return vec2(d, min(spr*.03, 1.0));\n}\n\n//------------------------------------------------------------------------------\n// Get a view of pixel using Euler...\nmat3 viewMat (float ay, float az)\n{\n  vec2 o, ca, sa;\n  o = vec2 (ay, az);\n  ca = cos (o);\n  sa = sin (o);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n//------------------------------------------------------------------------------\n\n// I forgot where this came from, it using a higher iteration than the ray march...\nvec3 normal(vec3 pos, float ds)\n{\n    ds *= 2./iResolution.y;\n    ds = max(ds*ds, .1);\n\n    float c = map(pos, 14.);\n    vec2 eps_zero = vec2(ds, 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 14.),\n                          map(pos + eps_zero.yxy, 14.),\n                          map(pos + eps_zero.yyx, 14.)) - c);\n}\n\n//------------------------------------------------------------------------------\n\n// I was using my 2 tweet water caustic here,\n// but some compilers optimised it broken with the rest of the code\n// So I opted for a basic voronoi cell thing...\nfloat waterPattern(vec2 p)\n{\n    p *=.02;\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float wp = 1e10;\n    for (int i = -1;i<=1;i++)\n    {\n        for (int j = -1;j<=1;j++)\n        {\n            vec2 g = vec2(i, j);\n            vec2 o = hash22(n+g);\n            \n            vec2 r = g + o - f;\n            float d = dot(r, r);\n            if (d < wp)\n            {\n                wp = d;\n            }\n        }\n    }\n    return pow(wp, 3.5);\n}\n\n\n//------------------------------------------------------------------------------\nfloat waveDepth(vec3 p, vec3 dir)\n{\n    float d = 0.0;\n    for( float i = 3.0; i <= 23.0; i+=5.)\n    {\n        float h = map(p + dir*i, 7.);\n        if (h > 0.) break;\n        d += -h;\n    }\n    return clamp(1.0-d*.02, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvec3 lighting(vec3 pos, vec3 nor, in vec3 dir,in vec3 mat)\n{\n    vec3 col;\n    col = mat * max(dot(sunDir, nor), 0.0);\n    vec3 ref = reflect(dir, nor);\n    float fres = clamp(pow( 1.+dot(nor, dir), 7. ), 0.0, 1.0);\n    col = mix(col, sky(nor), .2);\n    col = mix(col, sky(ref), fres);\n    return col;\n}\n\n//------------------------------------------------------------------------------\nvec3 diffuse(in vec3 pos, in vec3 nor, in float dep)\n{\n    pos.x -= time*1.3;\n    vec3 mat = vec3(.1,.1,.12);\n    float h = smoothstep(0., 1.0,nor.y);\n    \n    mat += h*.1;\n\n    mat = mix(mat, vec3(.3,.7,.7), dep);\n\n\n    // Add different frequencies of voronoi cells...\n    float foam = waterPattern(pos.xz+99.)*25.;\n    foam += waterPattern(pos.xz*(1.5-nor.y)*30.0)*20.;\n    foam += waterPattern(pos.xz*8.)*16.;\n    \n    //foam += *10.;\n    \n    foam = clamp(foam, 0.0, 1.0);\n    \n\n    mat = mat+foam * dep*dep*2.;\n\n    return mat;\n}\n\n//------------------------------------------------------------------------------\n// Exponential fader...\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------\nvoid mainImage( out vec4 outCol, in vec2 coord )\n{\n    // Take into account non-square viewport to keep aspect ratio of shapes..\n    // Zero in centre and .5 at the max Ys\n    vec2 uv = (coord-iResolution.xy*.5)/iResolution.y;\n\n    vec2 mouse = vec2(0);\n#ifndef EXPORT_VERSON\n    if (iMouse.z > 0.) mouse = (iMouse.xy-iResolution.xy*.5) /iResolution.y;\n#endif\n    \n\n    vec3 colour = vec3(0);\n    // Find a good point in time with time..\n    time = iTime+35.;\n\n    // Set colour to zero then call the rayMarcher to get distant object...\n\n    camPos = vec3(time*.01,100,0);\n    float h = (sin(time*.65)+1.0)*40.+ 30.;\n\n    // Don't go in the water...\n    float oce = oceanFundamental(camPos.xz, time, 8.0)+100.;\n    \n    oce= h-oce;\n    if (oce < 0.0)\n    {\n        h += pow(-oce, .1);\n    }\n\n\n    // Setup camera...\n    vec3 col;\n    vec3 dir  = vec3(0,0, 1.);\n    dir = viewMat (uv.y -.3, uv.x-2.+time*.25 + mouse.x*6.28) * dir;\n\n    camPos.y = h;\n    vec2 dis = rayMarch(camPos, dir);\n\n\n    if (dis.x < FAR)\n    {\n        // The position is the start position plus the normalised direction X distance...\n        vec3  pos = camPos + dir * dis.x; // ...wave hit position\n        vec3  nor = normal(pos, dis.x);   // ... Normal\n         // The depth of the wave in forward direction, it's simple but effective in helping the water transparent effect...\n        float dep = waveDepth(pos, dir);\n        vec3  mat = diffuse(pos, nor, dep);\n\n        col = lighting(pos, nor, dir, mat);\n        //col = mix(col, FOG_COLOUR, smoothstep(250.0, FAR, dis.x));\n        col = mix(FOG_COLOUR, col, exp(-dis.x*.0015));\n    }else\n    {\n        col = sky(dir);\n    }\n    colour += col;\n\n\n    colour = mix(col, vec3(.51,.55,.59),dis.y);\n\n    // Some adjustment..\n    colour = colour*.5 + smoothstep(0.0, 1.0, colour)*.5;\n    \n    vec2 xy = coord/iResolution.xy;\n    colour *= 0.5 + .5*pow( 80.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .7);  // ...Vignette.\n    // Fade out at five minutes...\n#ifdef EXPORT_VERSON\n    outCol = vec4(fader(0.0, 4.0, iTime) * fader(299.0, 294.0, iTime)*sqrt(colour), 1);\n#else\n    outCol = vec4(fader(0.0, 4.0, iTime) * sqrt(colour), 1);\n#endif\n}\n\n//-----------------------------------------------------------------\n", "image_inputs": [], "sound_code": "\n\n// Rough Seas 🌊, by Dave Hoskins.\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n\nfloat fader(float edge0, float edge1, float x)\n{\n    float t = (x - edge0) / (edge1 - edge0);\n    return  clamp(exp((t-.9825)*3.)-.0525, 0.0, 1.0);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n/*\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nvec2 ihash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n*/\n\nvec2 noise2D(in float p)\n{\n\tfloat f = fract(p);\n    p = floor(p);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 res = mix(hash21(p), hash21(p + 1.0), f);\n    return res-.5;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v, aud;\n    float t = time;\n    \n    \n    // Add vary volumes of different frequencies...\n    // Magic numbers again, sorry folks...\n    v = noise2D(t*.6)*.5+.5;\n    v = v*v*3.0;\n    aud = noise2D(t*320.+sin(t*.1)*100.) * v;\n    \n    v = noise2D(t*.3)*.8+.2;\n    v = v*v*3.0;\n    aud += noise2D(t*600.)*v;\n\n    v = noise2D(-t*.3)*.8;\n    aud += noise2D(t*1300.)*v;\n\n    v = noise2D(-t*.5)*.6;\n    aud += noise2D(t*2200.)*v;\n\n\n    v = (noise2D(-t*.4)+noise2D(-t*.3))*.3;\n    aud += noise2D(t*4400.)*v;\n\n    v = (noise2D(t*.7) +noise2D(t*.22))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*7500.)*v;\n    \n    v = (noise2D(t*.4) +noise2D(t*.3))*.25;\n    v = v*v*4.0;\n    aud += noise2D(t*10000.)*v;\n    \n\n\n    aud = clamp(aud*.9, -1.0, 1.0);// Clamp it properly\n    aud = 1.5*aud-.5*aud*aud*aud; // Loudness\n    aud *= fader(.0, 3.0,time) * fader(180.0, 170.0,time); // Fade in and out.\n    \n    return aud;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXGW4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[511, 651, 673, 673, 790], [791, 791, 812, 812, 945], [947, 947, 970, 970, 1073], [1076, 1213, 1237, 1237, 1484], [1486, 1486, 1510, 1510, 1984], [1987, 2091, 2111, 2111, 2167], [2439, 2439, 2494, 2494, 3035], [3037, 3147, 3181, 3181, 3251], [3253, 3405, 3438, 3438, 4028], [4030, 4149, 4184, 4184, 4382], [4466, 4550, 4583, 4583, 4877], [4961, 5123, 5151, 5151, 5575], [5578, 5659, 5694, 5694, 5890], [5892, 5973, 6033, 6033, 6276], [6278, 6359, 6413, 6413, 6893], [6895, 7000, 7048, 7048, 7149], [7151, 7232, 7282, 7403, 9386]], "test": "untested"}
{"id": "clXGzX", "name": "[Tube]", "author": "SnoopethDuckDuck", "description": "Tube", "tags": ["tube"], "likes": 12, "viewed": 217, "published": 3, "date": "1672091636", "time_retrieved": "2024-07-30T16:10:54.216515", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n// Useful for filling inside of shape\n/*\nvec2 ellipse(vec2 f, vec2 p, float r, float sy, float sx) {\n    f -= round(p);\n    return vec2(abs(f.x) - round(sy*sqrt(r*r-f.y*f.y/(sx*sx))),\n                abs(f.y) - round(sx*sqrt(r*r-f.x*f.x/(sy*sy))));                           \n}\n//*/\n\n// Sometimes has sharp corners\nfloat ellipse(vec2 f, vec2 p, float r, float sy, float sx) {\n    f -= round(p);\n    // For a function F(), we check that either:\n    // f.x == F(f.y) or f.y == F^-1(f.x)\n    // f.xy takes integer values and so does F(), F^-1()\n    // so equality is possible\n    // https://www.desmos.com/calculator/1kwd2kzxmp\n    float dx = abs(abs(f.x) - round(sy*sqrt(r*r-f.y*f.y/(sx*sx))));\n    float dy = abs(abs(f.y) - round(sx*sqrt(r*r-f.x*f.x/(sy*sy))));                         \n    return step(min(dx,dy), 0.);         \n}\n\n// Unused, but cheaper method if you only need circles\nfloat circle(vec2 f, vec2 p, float r) {\n    f = abs(f - p);\n    r *= r;\n    float d = dot(f, f);\n    float h = dot(f - vec2(1,0), f - vec2(1,0));\n    float v = dot(f - vec2(0,1), f - vec2(0,1));\n    return step(min(h,v),r) - step(d,r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    float t = iTime;\n    vec2 res = iResolution.xy;   \n    vec2 uv = (f - 0.5 * res) / res.y;\n    float sc = 75.;\n    vec2 ipos = round(sc * uv) - 0.;\n\n    vec2 p = vec2(0);\n\n    // Start oscillating tube after 8 seconds\n    float mx = clamp(t - 8., 0., 1.);\n    \n    float n = 64.;\n    bool reverse = (sin(t) < 0.); // sin(2t) is cool too\n    for (float i = 0.; i <= n; i++) {\n        // Reverse the for loop when tube has rotated pi radians\n        // (so darker tube colors get drawn first)\n        if (reverse) i = n - i;\n        \n        // Offset tube value\n        float io = 2. * pi * i / n;\n        \n        // Tube (tube)\n        vec2 p2 = p + (i-n/2.) * vec2(cos(t),0.);\n        \n        // Squash each circle as they turn (tube)\n        float c = abs(sin(t));        \n        \n        // Tube\n        float el = ellipse(ipos, p2, \n                           14.5 + mx * 6. * thc(20.,.75*t+.25*io), \n                           c, 1.);\n                           \n        // Tube colors\n        float drk = ceil(i/n * 6.) / 6.;\n        if (col.b == 0.) \n            col.b = drk * el * (1.+8.*sign(uv.y)*uv.y*uv.y);          \n               \n        // Reset tube index\n        if (reverse) i = n - i;\n   }\n   \n   col = vec3(.6, .4, 1) * col.b + 0.16;\n   \n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 375, 435, 435, 889], [891, 946, 985, 985, 1183], [1185, 1185, 1234, 1234, 2555]], "test": "untested"}
{"id": "clXGRX", "name": "Drawable Curtains", "author": "fenix", "description": "Because the curtain can be opened, and it can be rendered (fast). Featuring:\n\nknarkowics's Cloth Shading: https://shadertoy.com/view/4tfBzn\nwnu's sparkle commented: https://shadertoy.com/view/Ndlczs\n\n*mouse, up/down cam*\n*left/right draw*\n*space to reset*", "tags": ["dynamics", "physics", "glitter", "quadtree", "cloth", "sheen", "curtain", "velvet"], "likes": 25, "viewed": 372, "published": 3, "date": "1672088259", "time_retrieved": "2024-07-30T16:10:55.252745", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  It's another cloth shader, and you know what that means...the comments here may be\n//  threaded with puns. Proceed at your own risk. My previous cloth shaders:\n//\n//      Tearable 3D Fishnet         https://shadertoy.com/view/NlKBW3\n//      Cloth Draping + Shadows     https://shadertoy.com/view/cdjGRR\n//      Textured Cloth              https://shadertoy.com/view/Ddj3Wh\n//      Quadtree Tapestry           https://shadertoy.com/view/mlXGzN\n//\n//  Much credit is due to two other shaders that I borrowed code from, for the \"Charlie\n//  Sheen\" velvet cloth and glittered stars respectively:\n//\n//    knarkowics's Cloth Shading    https://shadertoy.com/view/4tfBzn\n//    wnu's sparkle commented       https://shadertoy.com/view/Ndlczs  \n//\n//  The sky and moon are borrowed from my own\n//\n//    Arctic Fireflies              https://shadertoy.com/view/cssSRs\n//\n//  The title of this shader by itself has a double meaning, because 1) I am simulating\n//  curtains that can be drawn, aka opened, and 2) the cloth is able-to-be-drawn faster\n//  than ever before, now.\n//\n//  I was attempting a \"traditional\" quadtree traveral using a stack, and it worked. You\n//  can see an early version at least in my previous cloth shader \"Quadtree Tapestry\".\n//  But, I wasn't able to beat the performance of archee's amazing shader:\n//\n//      curtain and ball            https://shadertoy.com/view/MldXWX\n//\n//  So, I threw my stack-based traversal out the window, you could say, and went with\n//  archee's general method. I still think I am pushing the state of the art here, though,\n//  because I found a couple of optimizations to archee's code (e.g. only doing one texel\n//  fetch instead of two per iteration). I also massaged the code to hopefully be more\n//  readable and draped it with comments (ahem).\n//\n//  I felt that the speed was sufficient to keep cloth shadows enabled, but if your FPS is\n//  not silky smooth you might want to disable SHADOW_FROM_CLOTH. I guess it's time to bring\n//  this comment to a close. It was fun pulling this together!\n//\n// ---------------------------------------------------------------------------------------\n\n#define SHADOW_FROM_CLOTH 1\n\nconst float FAR_CLIP = 30.;\n\n#define CLOTH_POS_UNCLAMPED(X) texture(iChannel0, ((X)+.5)/iResolution.xy).xyz\n#define CLOTH_POS_CLAMPED(X) texture(iChannel0, (clamp(X, vec2(0), vec2(CLOTH_SIDE_LEN)+.5)/iResolution.xy)).xyz\n\nvec4 getClothNormalGrad(vec2 uv)\n{\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS_CLAMPED(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS_CLAMPED(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS_CLAMPED(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS_CLAMPED(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    vec3 normal = normalize(cross(deltaX, deltaY));\n    vec3 clothPos = CLOTH_POS_CLAMPED(uv);\n    float grad = dot(normal, clothPosX0 - clothPos) +\n                 dot(normal, clothPosX1 - clothPos) +\n                 dot(normal, clothPosY0 - clothPos) +\n                 dot(normal, clothPosY1 - clothPos);\n\n    return vec4(normal, grad);\n}\n\n// enable to see visualization of quadtree query counts per pixel\n#define DEBUG_NUM_PROC 0\n\n#if DEBUG_NUM_PROC\n#define DEBUG_NUM_PROC_ONLY(X) X\n#else\n#define DEBUG_NUM_PROC_ONLY(X)\n#endif\n\nDEBUG_NUM_PROC_ONLY(int numProc = 0;)\n\n// originally from archee's curtain and ball: https://www.shadertoy.com/view/MldXWX\n//\n// with optimizations:\n//    * only one texel fetch per loop\n//    * compute d2 only once\n//    * removed square roots (length)\n// \n// also, updated variable names and types, added comments\nvec3 quadtreeRender(vec3 cameraPos, vec3 rayDir, float minSize, bool side)\n{\n    vec3 uvz = vec3(0, 0, FAR_CLIP);\n\n    const float STRETCH_RATIO = 3.;\n    const float voxelK2 = (STRETCH_RATIO / CLOTH_SIDE_LEN_F) * (STRETCH_RATIO / CLOTH_SIDE_LEN_F);\n    float voxelsize2 = (minSize * minSize * voxelK2);\n    \n    vec2 corner = vec2(0); // corner of current quad being considered\n    float size = CLOTH_SIDE_LEN_F / 2.; // size of quad being considered\n    float end = size;\n    if (side)\n    {\n        corner = vec2(size, 0);\n        end = CLOTH_SIDE_LEN_F;\n    }\n    bool levelup = false;\n    \n    for (int i = 0; i < 5000; ++i) // less than 200 iterations for most pixels\n    {\n        DEBUG_NUM_PROC_ONLY(++numProc;)\n\n        vec3 boundingcenter = CLOTH_POS_UNCLAMPED(corner + size * .5);\n        float d2 = length2(cross(boundingcenter - cameraPos, rayDir));\n\n        if (size <= minSize)\n        {\n        \tif (d2 <= voxelsize2 &&\n                floor(corner.x + 1.) != CLOTH_SIDE_LEN_F / 2.) // missing between left and right sides\n        \t{\n                // found small enough quadrant to render it\n                float dept = dot(rayDir, boundingcenter - cameraPos);\n                uvz = dept < uvz.z ? vec3(corner + .5 * size, dept) : uvz;\n\t        }\n          \n            levelup = true; // don't bother to descend, we've already rendered\n        }\n\n        if (d2 > size * size * voxelK2 * .5)\n        {\n            levelup = true; // not near this quadrant, don't descend into here\n        }\n        \n        if (levelup)\n        {\n            levelup = false;\n            \n            if (fract(corner.y / size / 2.) < .25)\n            {\n                corner.y += size; // we're on the top...go to the bottom\n            }\n            else\n            {\n                corner.y -= size; // we're on the bottom...go back to the top\n\n                if (fract(corner.x / size / 2.) < .25)\n                {\n                    corner.x += size; // go from right to left\n                }\n                else\n                {\n                    corner.x -= size; // done with this quad, go up a level\n                    size *= 2.0;\n                    levelup = true;\n                }\n            }\n        }\n        else\n        {\n            if (size > minSize) size /= 2.;\n        }\n        \n        if (corner.x >= end) break;    \n    }\n    \n    return uvz;\n}\n\nvoid fxCalcCamera(in vec3 cameraLookAt, in vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxGetParticlePos(int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(iChannel0, addr, 0).xyz;\n}\n\n#define MAX_STEPS 100\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\tfloat d = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * d;\n        float dS = scene(p, true);\n        d += dS;\n        if(d > FAR_CLIP || abs(dS) < SURF_DIST) break;\n    }\n    \n    return min(FAR_CLIP, d);\n}\n\nconst vec3 FILL_LIGHT_DIR = normalize(vec3(-1, 0.75, 1));\n\nbool shadowScene(vec3 p, vec3 lightDir)\n{\n    return rayMarch(p, lightDir) < FAR_CLIP;\n}\n\n#if SHADOW_FROM_CLOTH\nbool shadowCloth(vec3 p, vec3 lightDir)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    \n    cameraPos = p;\n    cameraLookAt = p + lightDir;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = cameraFwd;\n\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./4., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./4., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n\n    return uvz.z > 0. && uvz.z < FAR_CLIP;\n}\n#endif // SHADOW_FROM_CLOTH\n\nvec3 light(vec3 n, vec3 pointLightDir, bool shadow)\n{\n    return vec3(abs(dot(n, FILL_LIGHT_DIR)) * .05) + float(!shadow) * max(0., dot(n, pointLightDir)) * .9;\n}\n\nvec2 noise( in vec3 x )\n{\n    vec3 ip = floor(x);\n    vec3 fp = fract(x);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec4 rz = textureLod( iChannel1, (tap+0.5)/256.0, 0.0 );\n\treturn mix( rz.yw, rz.xz, fp.z );\n}\n\n// from sparkle commented by wnu: https://www.shadertoy.com/view/Ndlczs\nvec3 glitter(vec3 rayHit, vec3 normal, vec3 camDir)\n{\n    float t = iTime;\n    vec3 n = normal;\n\n    /////BASE COLOR\n\n    //FRESNEL \n\n    float fre = clamp(1. + dot(camDir,normal),-1.,1.);\n    float edge = sqrt(1.2-pow(fre,1./4.2));\n\n    //PICK YOUR COLOR\n\n    vec3 colorPick = vec3(.65, .45, 0.);\n\n    //COLOR FROM NORMALS AND FRESNEL\n\n    vec3 c = 2.25*-sin(sin(t*0. + n.x*1.+ 1.57 + sin(n.z*1. + 0.76)) + n.y + t*0.+  colorPick);\n    float ss = min(.5 - edge, smoothstep(.45 - edge, 1., edge));\n    c *= ss;\n\n    ///////GLINTS/GLITTER COMPUTATION\n\n    #define PRIMARY_INTENSITY 2.3\n    #define PRIMARY_CONCENTRATION 6.\n    #define SECONDARY_INTENSITY 10.\n    #define SECONDARY_CONCENTRATION 0.9\n\n    // HOW BIG THE GLITTER SPECKS ARE ; BIGGER -> SMALLER SPECKS\n    // (7 is probably the smallest I would go)\n\n    float scale = 400.;\n    rayHit = floor(rayHit*scale)/scale;\n\n    vec3 ligt = vec3(1.);\n    vec3 h = normalize(ligt-camDir);\n    float nl = dot(n,ligt);\n\n    vec3 coord = rayHit*.5;\n    coord.xy = coord.xy*.7071+coord.yx*.7071*vec2(1,-1);\n    coord.xz = coord.xz*.7071+coord.zx*.7071*vec2(1,-1);\n    vec3 coord2 = coord;\n\n    //first layer (inner glints)\n    float pw = .5*((iResolution.x));\n    vec3 aniso = vec3( noise((coord*pw)), noise((coord.yzx*pw)) )*2.0-1.0;\n    aniso -= n*dot(aniso,n);\n    float anisotropy = min(1.,length(aniso));\n    aniso /= anisotropy;\n    anisotropy = .55;\n    float ah = abs(dot(h,aniso));\n    float nh = abs(dot(n,h));\n    float qa = exp2((1.1-anisotropy)*3.5);\n    nh = pow( nh, qa*PRIMARY_CONCENTRATION );\n    nh *= pow( 1.-ah*anisotropy, 10.0 );\n    vec3 glints = c*nh*exp2((1.2-anisotropy)*PRIMARY_INTENSITY);\n\n    //second layer (outer glints)\n    pw = .145*((iResolution.x));\n    vec3 aniso2 = vec3( noise(coord2*pw), noise(coord2.yzx*pw).x )*2.0-1.0;\n    anisotropy = .6;\n    float ah2 = abs(dot(h,aniso2));\n    float nh2 = abs(dot(n,h));\n    float q2 = exp2((.1-anisotropy)*3.5);\n    nh2 = pow( nh, q2*SECONDARY_CONCENTRATION );\n    nh2 *= pow( 1.-ah2*anisotropy, 150.0 );\n    vec3 glints2 = c*nh2*((1.-anisotropy)*SECONDARY_INTENSITY);\n\n    ///// ADD BASE COLOR AND GLINTS/GLITTER LAYERS   \n\n    vec3 col = vec3(c)/4.;\n    col += (glints+glints2);\n\n    return col*col;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\n// From Cloth Shading by knarkowics: https://www.shadertoy.com/view/4tfBzn\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat CharlieD(float roughness, float ndoth)\n{\n    float rcpR  = 1. / roughness;\n    float cos2h = ndoth * ndoth;\n    float sin2h = 1. - cos2h;\n    return (2. + rcpR) * pow(sin2h, rcpR * .5) / (2. * PI);\n}\n\nfloat L(float x, float r)\n{\n\tr = saturate(r);\n\tr = 1.0 - (1. - r) * (1. - r);\n\n\tfloat a = mix( 25.3245,  21.5473, r);\n\tfloat b = mix( 3.32435,  3.82987, r);\n\tfloat c = mix( 0.16801,  0.19823, r);\n\tfloat d = mix(-1.27393, -1.97760, r);\n\tfloat e = mix(-4.85967, -4.32054, r);\n\n\treturn a / (1. + b * pow(x, c)) + d * x + e;\n}\n\nfloat CharlieV(float roughness, float ndotv, float ndotl)\n{\n\tfloat visV = ndotv < .5 ? exp(L(ndotv, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotv, roughness));\n\tfloat visL = ndotl < .5 ? exp(L(ndotl, roughness)) : exp(2. * L(.5, roughness) - L(1. - ndotl, roughness));\n\n\treturn 1. / ((1. + visV + visL) * (4. * ndotv * ndotl));\n}\n\nconst vec3 MOON_DIR = normalize(vec3(1, 2, -1));\nconst vec3 MOON_COLOR = vec3(.1, .15, .3);\n\nvec3 velvet(vec4 normalGrad, vec3 rayDir, vec3 hit, vec3 baseColor)\n{\n    if (dot(normalGrad.xyz, rayDir) > 0.) normalGrad.xyz = -normalGrad.xyz;\n\n    vec3 viewDir = -rayDir;\n    vec3 lightDir = MOON_DIR;\n\n    vec3 halfVec = normalize(viewDir + lightDir);\n    float vdoth = saturate(dot(viewDir, halfVec));\n    float ndoth\t= saturate(dot(normalGrad.xyz, halfVec));\n    float ndotv = saturate(dot(normalGrad.xyz, viewDir));\n    float ndotl = saturate(abs(dot(normalGrad.xyz, lightDir)));\n\n    vec3 diffuseColor  = 0.25 * baseColor;\n    vec3 specularColor = sqrt(baseColor);\n    float roughness    = 0.5;\n\n    vec3 diffusePoint = diffuseColor * saturate(dot(normalGrad.xyz, lightDir));\n    vec3 diffuseFill = diffuseColor * saturate(dot(normalGrad.xyz, FILL_LIGHT_DIR));\n\n    vec3 f = FresnelTerm(specularColor, vdoth);\n\n    float d = CharlieD(roughness, ndoth);\n    float v = CharlieV(roughness, ndotv, ndotl);\n\n    vec3 specular = f * (d * v * PI * ndotl);\n\n    vec3 color = diffusePoint + diffuseFill + specular;\n    return color;\n}\n\n// From jarble's Glacial valleys: https://www.shadertoy.com/view/NscGWl\n// (used for moon)\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    uv *= 1.25;\n    float value = 0.;\n    float amplitude = 1.2;\n    float freq = 0.5,n2=0.;\n    vec2 n1 = vec2(0.);\n    for (int i = 0; i < octaves; i++)\n    {\n        n2 = sin(uv.x*freq)+cos(uv.y*freq);\n\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = abs(value-abs(n2-value) * amplitude);\n        amplitude *= .37;\n        freq *= 2.05;\n        uv = vec2(uv.y,uv.x+n2/(freq));\n    }\n    \n    return value;\n}\n\nfloat fbm(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nvec3 sky(vec3 rayDir)\n{\n    vec3 stars = vec3(smoothstep(.5, .8, pow(float(hash(uvec4(rayDir * iResolution.y + 4000., 1)).r) / 4.35e9, 50.))) * 4.;\n    float d = distance(rayDir, MOON_DIR);\n    if (d > .03 + + 2./iResolution.y) return stars;\n    vec3 moon = MOON_COLOR * (1. + fbm(rayDir.xxy * 100., 3));\n    return mix(moon, stars, smoothstep(.03, .03 + 2./iResolution.y, d));\n}\n\nvec4 hash4(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return vec4(x) * (1./float(0xffffffffU));\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// From iq's Star - distance 2d: https://www.shadertoy.com/view/3tSGDy\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec4 renderCurtain(vec2 fragCoord)\n{\n    vec4 fragColor = vec4(.15, .0, .2, 0);\n    \n    vec2 u = fragCoord;\n    \n#if 0 // animated stars\n    float t = iTime;\n    u.y += t * .05;\n#else\n    const float t = 1.;\n#endif\n    \n    vec2 r;\n    u = modf(u * 8., r) / 8.;\n    vec4 h1 = hash4(uvec4(r.xyxy * 1000.));\n    vec4 h2 = hash4(uvec4(h1 * 1000.));\n    u.x *= iResolution.x / iResolution.y;\n    fragColor = mix(vec4(1,1,0,1), fragColor, smoothstep(0., .001, sdStar((u - .0125 - h1.yz * .1) * rot2(h1.x * 2. * PI + t), .015, h2.x < .5 ? 5 : 6, 3. + 2. * h1.w)));\n    fragColor = mix(vec4(1,1,0,1), fragColor, smoothstep(0., .001, sdStar((u - .0125 - h2.yz * .1) * rot2(h2.x * 2. * PI - t), .015, 5, 3. + 2. * h2.w)));\n    \n    return fragColor;\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    DEBUG_NUM_PROC_ONLY(numProc = 0);\n    vec2 u = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxState state = fxGetState(iFrame);\n    \n    cameraPos = -state.orbit * vec3(sin(state.camera.x) * sin(state.camera.y), cos(state.camera.y), cos(state.camera.x) * sin(state.camera.y));\n    cameraLookAt = vec3(0, .3, 0);\n    cameraPos += cameraLookAt;\n\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 color = MOON_COLOR;\n    float d = rayMarch(cameraPos, rayDir);\n    bool s = false;\n    float ao = 0.;\n    \n    // render scene\n    if (d < FAR_CLIP)\n    {\n        vec3 hit = cameraPos + rayDir * d;\n        vec3 normal = getSceneNormal(hit, true);\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        s = s || shadowCloth(offsetPos, MOON_DIR);\n#endif\n        fragColor.xyz = (light(normal, MOON_DIR, s) - ao) * color;\n    }\n    else\n        fragColor.xyz = sky(rayDir);\n\n    // render cloth\n    vec3 uvz1 = quadtreeRender(cameraPos, rayDir, 1./16., false); // right side\n    vec3 uvz2 = quadtreeRender(cameraPos, rayDir, 1./16., true); // left side\n    vec3 uvz = uvz1.z < uvz2.z ? uvz1 : uvz2;\n    if (uvz.z < d)\n    {\n        vec4 normalGrad = getClothNormalGrad(uvz.xy);\n        vec3 normal = normalGrad.xyz;\n        vec3 hit = cameraPos + rayDir * uvz.z;\n        float ao = .5 + .5 *smoothstep(.2, 0.1, -normalGrad.w);\n\n        vec3 lightColor = MOON_COLOR * ao;\n\n#if 0 // enable shadows on cloth\n        vec3 offsetPos = hit + normal * 2. * SURF_DIST;\n        s = shadowScene(offsetPos, MOON_DIR);\n#if SHADOW_FROM_CLOTH\n        //s = s || shadowCloth(offsetPos, MOON_DIR); // self-shadowing adds a lot of cost, not a lot of effect\n#endif\n        if (s) lightColor *= .25;\n#endif\n       // if (dot(normal, cameraFwd) < 0.) lightColor *= .1;\n        \n        vec4 colorGlitter = renderCurtain(uvz.xy / CLOTH_SIDE_LEN_F);\n        //colorGlitter.a = 1.; // gold sparkly curtains\n        vec3 color = velvet(normalGrad, rayDir, hit, colorGlitter.rgb) * lightColor;\n        if (colorGlitter.a > 0.)\n        {\n            color = mix(color, glitter(hit, normal, -rayDir), colorGlitter.a);\n        }\n        fragColor = vec4(color, 1);\n    }\n    \n    fragColor.xyz = ACESFilm(pow(fragColor.xyz, vec3(1./2.2)));\n    fragColor.w = 1.;\n\n    DEBUG_NUM_PROC_ONLY(fragColor = sin(float(numProc) * vec4(1, 11, 13, 0)) * sqrt(vec4(numProc)) / 10.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CLOTH_SIDE_LEN = 128;\nconst float CLOTH_SIDE_LEN_F = float(CLOTH_SIDE_LEN);\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(uvec4 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(p);\n    return vec4(h)*scale;\n}\n\nfloat length2(vec3 v) { return dot(v, v); }\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat scene(vec3 p, bool rod)\n{\n    float d = 1e6;\n    \n    d = min(d, sdBox(p - vec3(-.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(.9,.05,.1), vec3(.1,.9,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,1.,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.8,.1), vec3(1.,.1,.1))); // wall\n    d = min(d, sdBox(p - vec3(0,-.65,.1), vec3(.9,.05,.2))); // sill\n    d = min(d, sdBox(p + vec3(0,3.5,0), vec3(10.,1.,10.))); // floor\n    if (rod)\n    {\n        d = min(d, sdCapsule(p, vec3(-.85, .95, -.02), vec3(.85, .95, -.01)) - .01); // rod\n        d = min(d, sdSphere(p - vec3(-.85, .95, -.02), .03)); // right side ball\n        d = min(d, sdSphere(p - vec3( .85, .95, -.02), .03)); // left side ball\n    }\n    \n    return d;\n}\n\n// // https://iquilezles.org/articles/normalsSDF\nvec3 getSceneNormal(vec3 p, bool rod)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(p + e.xyy, false ) + \n\t\t\t\t\t  e.yyx*scene(p + e.yyx, false ) + \n\t\t\t\t\t  e.yxy*scene(p + e.yxy, false ) + \n\t\t\t\t\t  e.xxx*scene(p + e.xxx, false ) );\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyDownImpl(sampler, ascii)    ( texelFetch(sampler,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    float draw;\n    float attractCurtain;\n    float attractCamera;\n    float orbit;\n    vec2 camera;\n    vec2 lastMouse;\n};\n\nvoid initState(inout fxState state)\n{\n    state.draw = .75;\n    state.attractCurtain = 15.;\n    state.attractCamera = 1.;\n    state.orbit = 2.2;\n    state.camera = vec2(sin(.0004), cos(.0002) * .25 + PI*.5);\n    state.lastMouse = vec2(0);\n}\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, CLOTH_SIDE_LEN * 2), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, CLOTH_SIDE_LEN * 2), 0);\n    \n    fxState state;\n    state.draw = data0.x;\n    state.attractCurtain = data0.y;\n    state.attractCamera = data0.z;\n    state.orbit = data0.w;\n    state.camera = data1.xy;\n    state.lastMouse = data1.zw;\n    if (iFrame == 0) initState(state);\n    return state;\n}\n\n#define fxGetState(iFrame) fxGetStateImpl(iChannel0, iFrame)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2))\n        return vec4(state.draw, state.attractCurtain, state.attractCamera, state.orbit);\n    else\n        return vec4(state.camera, state.lastMouse);\n}\n\nvec4 updateState(fxState state, sampler2D keySampler, ivec2 ifc, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE))\n    {\n        initState(state);\n    }\n    else\n    {\n        if (keyDownImpl(keySampler, KEY_LEFT))\n        {\n            state.draw += .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_RIGHT))\n        {\n            state.draw -= .0025;\n            state.attractCurtain = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_UP))\n        {\n            state.orbit -= .0025;\n            state.attractCamera = 0.;\n        }\n        if (keyDownImpl(keySampler, KEY_DOWN))\n        {\n            state.orbit += .0025;\n            state.attractCamera = 0.;\n        }\n        if (state.attractCurtain != 0.)\n        {\n            state.attractCurtain = mod(state.attractCurtain, 30.) + .005;\n            state.draw = smoothstep(10., 15., state.attractCurtain) * smoothstep(30., 25., state.attractCurtain) * .5 + .3;\n        }\n        state.draw = clamp(state.draw, .3, .8);\n\n        if (iMouse.z > 0.)\n        {\n            state.attractCamera = 0.;\n            \n            if (iMouse.w < 0.)\n            {\n                state.camera += 10. * ((iMouse.xy / iResolution.x) - state.lastMouse);\n                state.camera.y = clamp(state.camera.y, PI*.1, PI*.9);\n            }\n\n            state.lastMouse = iMouse.xy / iResolution.x;\n        }\n        \n        if (state.attractCamera > 0.)\n        {\n            state.attractCamera += 1.;\n            state.camera = vec2(sin(state.attractCamera * .0004), cos(state.attractCamera * .0002) * .25 + PI*.5);\n            state.orbit = 1.7 + cos(state.attractCamera * .0003) * .5;\n        }\n    }\n    \n    return fxPutState(state, ifc);\n}\n\nvec3 fxGetParticlePos(sampler2D sampler, int id)\n{\n    ivec2 addr = ivec2(id % CLOTH_SIDE_LEN, id / CLOTH_SIDE_LEN);\n    return texelFetch(sampler, addr, 0).xyz;\n}\n\nvoid horizConstraint(sampler2D sampler, ivec2 nb, int dist, inout vec3 pos)\n{\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    float idealDist = float(dist) * 2.7 / float(CLOTH_SIDE_LEN - 1);\n    float f = .4;\n    if (deltaLen > idealDist) f = .6;\n    pos = mix(nbPos + normalize(delta) * idealDist, pos, f);\n}\n\nvoid vertConstraint(sampler2D sampler, ivec2 nb, int dist, float f, inout vec3 pos)\n{\n    const float Y_STRETCH = 1.47;\n\n    vec3 nbPos = texelFetch(sampler, nb, 0).xyz;\n    vec3 delta = pos - nbPos;\n    float deltaLen = length(delta);\n    if (deltaLen > Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1))\n    {\n        pos = mix(nbPos + normalize(delta) * Y_STRETCH * float(dist) / float(CLOTH_SIDE_LEN - 1), pos, f);\n    }\n}\n\nvec3 initVert(ivec2 v, fxState state)\n{\n    vec2 vert = vec2(v);\n    vert.y = CLOTH_SIDE_LEN_F - (CLOTH_SIDE_LEN_F - vert.y)*.83;\n    vec3 pos = (vec3(((vert - float(CLOTH_SIDE_LEN - 1) * .5))*2./CLOTH_SIDE_LEN_F, -.01) + vec3(0, .05, 0)) * vec3(state.draw, .95, 1);\n    \n    // split down the middle\n    if (v.x < CLOTH_SIDE_LEN / 2) pos.x -= .8 - state.draw;\n    else pos.x += .8 - state.draw;\n    \n    // wavy top to set up the pleats\n    float s = sin(float(v.x) * 3.14 / 4.);\n    //if (abs(s) > 1e-6) s /= sqrt(abs(s));\n    pos.z -= (1. + s) * .03;\n    return pos;\n}\n\n#define CLOTH_POS(X) texture(sampler, clamp((X+.5)/res.xy, vec2(0), vec2(CLOTH_SIDE_LEN))).xyz\n\nvec3 getClothNormal(sampler2D sampler, vec3 res, ivec2 ifc)\n{\n    vec2 uv = vec2(ifc);\n    vec2 delta = vec2(1, 0);\n    vec3 clothPosX0 = CLOTH_POS(uv + delta.xy);\n    vec3 clothPosX1 = CLOTH_POS(uv - delta.xy);\n    vec3 deltaX = clothPosX0 - clothPosX1;\n    vec3 clothPosY0 = CLOTH_POS(uv + delta.yx);\n    vec3 clothPosY1 = CLOTH_POS(uv - delta.yx);\n    vec3 deltaY = clothPosY0 - clothPosY1;\n    return normalize(cross(deltaX, deltaY));\n}\n\nvoid clothBufferMainImpl( out vec4 fragColor, vec2 fragCoord, sampler2D vertexSampler, sampler2D keySampler, int iFrame, vec4 iMouse, vec3 iResolution, float iTime)\n{\n    ivec2 ifc = ivec2(fragCoord);\n    \n    fxState state = fxGetStateImpl(vertexSampler, iFrame);\n    \n    if (ifc == ivec2(0, CLOTH_SIDE_LEN * 2) || ifc == ivec2(1, CLOTH_SIDE_LEN * 2))\n    {\n        fragColor = updateState(state, keySampler, ifc, iFrame, iMouse, iResolution, iTime);\n        return;\n    }\n    \n    if (any(greaterThan(ifc, CLOTH_SIDE_LEN * ivec2(2, 1))))\n    {\n        fragColor = vec4(0); // discard all unneeded pixels\n        return;\n    }\n    \n    if (iFrame == 0 || keyDownImpl(keySampler, KEY_SPACE))\n    {\n        // init cloth positions\n        ifc.x = (ifc.x % CLOTH_SIDE_LEN);\n        fxState initState;\n        initState.draw = .8;\n        fragColor.xyz = initVert(ifc, initState);\n        fragColor.w = 1.;\n\n        return;\n    }\n    \n    if (ifc.x >= CLOTH_SIDE_LEN)\n    {\n        // store last position on right side\n        fragColor = texelFetch(vertexSampler, ifc - ivec2(CLOTH_SIDE_LEN, 0), 0);\n        return;\n    }\n    \n    vec3 pos = texelFetch(vertexSampler, ifc, 0).xyz;\n    if (ifc.y >= CLOTH_SIDE_LEN - 6)\n    {\n        pos = initVert(ifc, state); // top six rows are pinned\n    }\n    else\n    {\n        vec3 oldPos = texelFetch(vertexSampler, ifc + ivec2(CLOTH_SIDE_LEN, 0), 0).xyz;\n        \n        pos += (pos - oldPos) * .9; // integration\n        pos += vec3(0, -.1, 0); // gravity\n        \n        // wind\n        vec3 normal = getClothNormal(vertexSampler, iResolution, ifc);\n        pos.z += sin(pos.x*.3 + iTime*.2) * .03 * normal.z;\n\n        // vertical constraints\n        for (int i = 0; i < 5; ++i)\n        {\n            float Y_STRETCH = 1.47;\n            ivec2 nbU = ifc + ivec2(0, i);\n            if (nbU.y <= CLOTH_SIDE_LEN - 1) vertConstraint(vertexSampler, nbU, i, .5, pos);\n            ivec2 nbD = ifc - ivec2(0, i);\n            if (nbD.y >= 0) vertConstraint(vertexSampler, nbD, i, .99, pos);\n        }\n\n        // horizontal constraints\n        int endL = ifc.x < CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 - 1 : CLOTH_SIDE_LEN - 1;\n        int endR = ifc.x >= CLOTH_SIDE_LEN / 2 ? CLOTH_SIDE_LEN / 2 : 0;\n        for (int i = 0; i < 3; ++i)\n        {\n            ivec2 nbL = ifc + ivec2(i, 0);\n            ivec2 nbR = ifc - ivec2(i, 0);\n            if (nbL.x <= endL) horizConstraint(vertexSampler, nbL, i, pos);\n            if (nbR.x >= endR) horizConstraint(vertexSampler, nbR, i, pos);\n        }\n\n        // collision with scene\n        pos -= min(0., scene(pos, false) - .01) * getSceneNormal(pos, false);\n\n    }\n\n    fragColor = vec4(pos, 1);\n}\n\n#define clothBufferMain(fragColor, fragCoord) clothBufferMainImpl( fragColor, fragCoord, iChannel0, iChannel3, iFrame, iMouse, iResolution, iTime)\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    clothBufferMain(fragColor, fragCoord);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXGRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2607, 2607, 2641, 2641, 3324], [6222, 6222, 6342, 6342, 6522], [6524, 6524, 6637, 6637, 6793], [6795, 6795, 6898, 6898, 7031], [7033, 7033, 7064, 7064, 7179], [7227, 7227, 7261, 7261, 7502], [7563, 7563, 7604, 7604, 7651], [8344, 8344, 8397, 8397, 8506], [8508, 8508, 8533, 8533, 8752], [8754, 8826, 8879, 8879, 11054], [11056, 11056, 11081, 11081, 11112], [11114, 11114, 11137, 11137, 11180], [11182, 11257, 11308, 11308, 11405], [11407, 11407, 11453, 11453, 11612], [11614, 11614, 11641, 11641, 11936], [11938, 11938, 11997, 11997, 12276], [12371, 12371, 12440, 12440, 13404], [13406, 13497, 13532, 13581, 14033], [14035, 14035, 14067, 14067, 14117], [14119, 14119, 14142, 14142, 14498], [14500, 14500, 14520, 14520, 14770], [14772, 14772, 14792, 14792, 14872], [14874, 14945, 15015, 15073, 15509], [15511, 15511, 15547, 15547, 16254], [16256, 16340, 16363, 16363, 16523], [16525, 16525, 16582, 16582, 19197]], "test": "untested"}
{"id": "mll3zj", "name": "Condensation Claude", "author": "MysteryPancake", "description": "Real water moment", "tags": ["chroma", "blur", "water", "glass", "sharp", "lod", "mask", "sharpen", "buffer", "window", "blurring"], "likes": 5, "viewed": 245, "published": 3, "date": "1672076399", "time_retrieved": "2024-07-30T16:10:56.004734", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 vid = texture(iChannel1, uv);\n    float blur = 3.0 / distance(vid.rgb, vec3(0.0, 1.0, 0.0));\n    fragColor = textureLod(iChannel0, uv, blur);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 vid = texture(iChannel0, uv);\n    vec4 last = texture(iChannel1, uv);\n    fragColor = mix(last, vid, 0.04);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mll3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 250]], "test": "untested"}
{"id": "dllGzj", "name": "Yet another mandelbrot", "author": "01000001", "description": "Fractal!  fractals are cool.  Click to restart (for full screen rendering).", "tags": ["fractal", "mandelbrot"], "likes": 2, "viewed": 135, "published": 3, "date": "1672074798", "time_retrieved": "2024-07-30T16:10:56.747748", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 colOut = texture(iChannel0, fragCoord/iResolution.xy);\n    /*\n    fragColor = vec4(colOut.z/float(iFrame));//*/\n    //*\n    fragColor = 1.0-vec4(pow(0.99, colOut.z));//*/\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.x = iMouse.z<0.5?texture(iChannel0, vec2(0.5)).x + 1.0:0.0;\n    fragColor = vec4(fragColor.x);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 colIn = texture(iChannel0, fragCoord/iResolution.xy);\n    vec2 uv = (fragCoord/iResolution.xy)-vec2(0.5);\n    uv.x /= iResolution.y/iResolution.x;\n\n    \n    /*\n    uv*=0.2;\n    uv.x -= 0.3;\n    uv.y -= 0.7;\n    //*/\n\n    //*\n    //uv*=5e-6;//this value will take you to the limit of the floating point resolution\n    uv*=5e-2;\n    uv.x -= 0.230602;\n    uv.y -= 0.700407;\n    //*/\n\n\n\n    vec2 coords;\n    bool done = colIn.z != 0.0;\n    bool prevDone = done;\n    float margin = 10.0;\n\n    if (!done) {\n        coords = colIn.xy;\n        \n        vec2 i = coords;\n        vec2 o;\n        o.x = i.x*i.x - i.y * i.y;\n        o.y = i.x * i.y * 2.0;\n        \n        coords = o + uv;\n        \n        \n        if (length(coords) > margin)\n        {\n            done = true;\n        }\n    }\n\n    fragColor = vec4(coords, done?(prevDone?colIn.z:texture(iChannel1, vec2(0.5)).x):0.0 ,1.0);\n\n    if (texture(iChannel1, vec2(0.5)).x < 0.1)\n    {\n        fragColor.xy = uv;\n        fragColor.zw = vec2(0.0);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 239]], "test": "untested"}
{"id": "mtlGzj", "name": "Surface Blur (LOD)", "author": "MysteryPancake", "description": "Simple idea I had to create a surface blur, isolating edges via subtraction to avoid modifying them.", "tags": ["blur", "lod", "edge", "surface", "gaussian", "sharpen", "kernel", "sharpening"], "likes": 5, "viewed": 308, "published": 3, "date": "1672074541", "time_retrieved": "2024-07-30T16:10:57.565561", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    // Original texture without blurring\n    vec4 original = texture(iChannel0, uv);\n    // Blurred slightly for edge isolation\n    vec4 edges = textureLod(iChannel0, uv, 2.0);\n    // Blurred more for underlying surface\n    float blur = 4.0 + sin(iTime * 4.0) * 2.0;\n    vec4 blurred = textureLod(iChannel0, uv, blur);\n    \n    // Mix original with blurred depending on edge difference\n    float factor = 3.0 * distance(original.rgb, edges.rgb);\n    fragColor = mix(blurred, original, clamp(factor, 0.0, 1.0));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 611]], "test": "untested"}
{"id": "dtl3Rj", "name": "Unsharp Mask (LOD)", "author": "MysteryPancake", "description": "Unsharpen mask is faster using LOD levels. Left is result, right is mask.", "tags": ["sharp", "image", "mask", "photoshop", "sharpen", "unsharp", "unsharpen"], "likes": 3, "viewed": 251, "published": 3, "date": "1672071008", "time_retrieved": "2024-07-30T16:10:58.311567", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Optional sharpness boost\n    float amount = 1.0;\n    // Modulate blur over time\n    float radius = abs(mod(iTime * 8.0, 16.0) - 8.0);\n    \n    // Sample original and blurred image\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 original = texture(iChannel0, uv);\n    vec4 blurred = textureLod(iChannel0, uv, radius);\n    \n    // Produce mask\n    blurred = original - blurred;\n    original += blurred * amount;\n    \n    // Sharpened image on the left, mask on the right\n    fragColor = uv.x > 0.5 ? blurred : original;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtl3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 88, 586]], "test": "untested"}
{"id": "clfGz2", "name": "Kishimisu v3 [388 chars]", "author": "kishimisu", "description": "Started from 800+ chars down to 398. \n<300 really seem impossible for this username :sigh:", "tags": ["bloom", "glow", "font", "hack", "code", "letters", "bright", "neon", "short", "golf", "golfing", "title"], "likes": 27, "viewed": 685, "published": 3, "date": "1672069779", "time_retrieved": "2024-07-30T16:10:59.111428", "image_code": "/* @kishimisu - 2022 [399 => 388 chars by @FabriceNeyret2]\n   \n   Final attempt at code golfing my username.\n   I really don't think I'll be able to make it \n   any shorter than this!                        \n*/\n#define l(p,a) length(p-a*min(dot(p,a)/dot(a,a), 1.))         //\n#define _ ; w = vec4(p -= vec2(3,.3*sin(t.w+p.x)), q=abs(p)) o// \n#define o ; O += .04*(cos(p.x+t.w+t)+2.)/l(                   //\n#define i _ q, v)                                             //\n#define s _ w.xw + sin(p.y)*z, v)                             //\n#define h _ q-z, v) o w.zy\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec4 t = vec4(0,1,2,iTime), w;\n    vec2 r = iResolution.xy, p = (F+F-r)/r.y*9.+t.zx*8.,\n         v = t.xz, z = t.yx, q; O *= 0.\n         \n    i o w.xw, t.zz) i s h, z) i h, t.yz) i s h+v, z); // is that even glsl anymore?\n // K.............. I S H.... I M....... I S U......\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dtl3z2", "name": "Wave Propagation - Distance 2D", "author": "MysteryPancake", "description": "Basic but cool looking SDF :)", "tags": ["2d", "distancefield", "wave", "sdf", "circle", "distance"], "likes": 6, "viewed": 214, "published": 3, "date": "1672068282", "time_retrieved": "2024-07-30T16:11:00.013018", "image_code": "const float TAU = 6.28318530;\n\n// Ping-pong triangle waveform\nvec2 triangle(vec2 p, vec2 period) {\n    return abs(mod(p, period) - period * 0.5);\n}\n\n// For sharper transitions than regular cos\nfloat sharpCos(float x, float smoothness) {\n    float s = cos(x);\n    return s / sqrt(smoothness + s * s);\n}\n\n// Inefficient but simple SDF, uses 10 grids\nfloat waveSDF(vec2 p) {\n\n    float d = 9999.9;\n    for (float i = 0.0; i < 1.0; i += 0.1) {\n        // Base distortion\n        float distort = cos(4.0 * iTime + i * TAU) * 0.1;\n        \n        // Transition between different Y offsets\n        float a = sharpCos(iTime, 0.02) * 0.5 + 0.5;\n        float b = sharpCos(iTime * 0.5, 0.01) * 0.5 + 0.5;\n        vec2 offset = vec2(i + distort, a * i - b * distort);\n        \n        // Repeat domain using a grid\n        vec2 tri = triangle(p + offset, vec2(1.0, 0.5));\n        \n        // Use a sphere SDF\n        d = min(d, length(tri));\n    }\n    return d - 0.05;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Normalized coordinates, ripped from Inigo Quilez\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\t\n\tfloat d = waveSDF(p);\n\n\t// Coloring, ripped from Inigo Quilez\n\tvec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(120.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n\tif (iMouse.z > 0.001) {\n\t\td = waveSDF(m);\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n\t}\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtl3z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 62, 98, 98, 147], [149, 193, 236, 236, 301], [303, 348, 371, 371, 960], [962, 962, 1017, 1071, 1733]], "test": "untested"}
{"id": "cllGz2", "name": "Patterns animation", "author": "python273", "description": "-", "tags": ["pattern"], "likes": 2, "viewed": 168, "published": 3, "date": "1672066394", "time_retrieved": "2024-07-30T16:11:00.954500", "image_code": "#define PI 3.141592653589793\n#define S 0.7\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 U = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    U = U.yx;\n    for (int i = 0; i < 7; i++) {\n        U *= -1.;\n        U = vec2(\n            mod(U.x + floor(U.y / S) * S/2., S),\n            mod(U.y, S)\n        ) / S;\n        if ((U.y > U.x * 2.) || (U.y > (U.x * -2. + 2.))) {\n            U = vec2(mod(U.x + .5, 1.), 1. - U.y);\n        }\n        U = U.yx;\n        U *= rot((iTime-3.)*.02*PI);\n    }\n    U = mod(U, vec2(1.));\n    \n    //fragColor = vec4(U, 0., 1.); return;\n    fragColor = vec4(hsv2rgb(vec3(U.x, U.y*.4 + .6, 1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 119, 119, 279], [281, 281, 338, 338, 911]], "test": "untested"}
{"id": "cls3Rj", "name": "Air in glass", "author": "shaofun", "description": "A very simple physics-based ray-tracing renderer.\nWASDQE to move, SHIFT to accelerate, SPACE to refresh.\n\nmore info: https://shao.fun/blog/w/taichi-ray-tracing.html\ngithub: https://github.com/HK-SHAO/RayTracingPBR", "tags": ["3d", "interactive", "sdf", "camera", "pathtracing", "ibl", "pbr"], "likes": 4, "viewed": 407, "published": 3, "date": "1672052765", "time_retrieved": "2024-07-30T16:11:01.955823", "image_code": "// Fork of \"fix ior\" by shaofun. https://shadertoy.com/view/mtfGzj\n// 2022-12-26 10:24:12\n\n// Fork of \"RayTracing PBR with Free Camera\" by shaofun. https://shadertoy.com/view/ddSSWy\n// 2022-12-26 05:00:26\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = vec4(color.rgb / color.a, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Modified by HK-SHAO - 2022\n\n// Upgraded from genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define key(K)  texelFetch(iChannel0, ivec2(K, 0), 0).x\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Keyboard constants definition\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_Q     = 81;\nconst int KEY_SHIFT = 16;\nconst int KEY_SP    = 32;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A), \n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 m) {\n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) discard;\n    \n    fragColor = load(fragCoord);\n    \n    if (iFrame == 0) {\n        store(POSITION, vec4(0.0, 0.2, 6.0, 0.0));\n        store(ROTATION, vec4(0.0, 0.0, 0.0, 0.0));\n        \n        store(TARGET,   vec4(9.0, 9.0, 9.0, 0.0));\n        store(TMOUSE,   vec4(PI/4.0, PI/5.1, 0.0, 0.0));\n        store(PMOUSE,   vec4(PI/4.0, PI/5.1, 0.0, 0.0));\n        \n        return;\n    }\n\n    vec2 resolution  = load(RESOLUTION).xy;\n    \n    vec3 position    = load(POSITION).xyz;\n    vec2 rotation    = load(ROTATION).xy;\n\n    vec3 target      = load(TARGET).xyz;\n    vec3 tm          = load(TMOUSE).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    \n    float dt = clamp(iTimeDelta, 0.0, 0.1);\n    \n    const float rt_acc = 16.0;\n    const float mv_acc = 5.0;\n    float velocity =  10.0 + 15.0 * key(KEY_SHIFT);\n    \n    rotation += (tm.xy - rotation) * dt * rt_acc;\n    target   += CameraDirInput(rotation) * dt * velocity;\n    position += (target - position) * dt * mv_acc;\n    \n    bvec4 moving = bvec4(\n        length(tm.xy - rotation) * iResolution.x > 1.0,\n        length(target - position) * iResolution.x > 1.0,\n        any(notEqual(resolution, iResolution.xy)),\n        key(KEY_SP) > 0.0\n    );\n    \n    store(TARGET,     vec4(target, 0.0));\n    store(POSITION,   vec4(position, 0.0));\n    store(ROTATION,   vec4(rotation, 0.0, 0.0));\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(MOVING,     vec4(any(moving), 0.0, 0.0, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n        vec2 new_tm  = pm + (abs(iMouse.zw) - iMouse.xy) / iResolution.x;\n        \n        float clamp_y = float(new_tm.y > -PI*0.5+0.01 && new_tm.y < PI*0.5-0.01);\n        new_tm.y = mix(tm.y, new_tm.y, clamp_y);\n        \n        store(TMOUSE, vec4(new_tm, 1.0, 0.0));\n\t} else if (tm.z != 0.0) {\n        store(PMOUSE, vec4(tm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\n// Buffer A Shared\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 PMOUSE     = ivec2(0, 0);\nconst ivec2 TARGET     = ivec2(1, 0);\nconst ivec2 TMOUSE     = ivec2(2, 0);\n\nconst ivec2 RESOLUTION = ivec2(0, 1);\nconst ivec2 POSITION   = ivec2(1, 1);\nconst ivec2 ROTATION   = ivec2(2, 1);\n\nconst ivec2 MOVING     = ivec2(0, 2);\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}\n\n// Update History\n\n// 2022.12.26\n// 1. enables metal to be used in IOR.\n// 2. small optimization of performance.\n\n// 2022.12.24\n// 1. fixed camera jamming when looking up and down.\n\n// 2022.12.23\n// 1. fix the blackening of rough transparent material, it optimized the frame rate (more than twice).\n// 2. fix the camera misalignment when full screen.\n// 3. fix the inability to propagate reflected light inside an object.\n// 4. optimize the judgment about self-luminous light source.\n// 5. some formatting optimizations and minor efficiency optimizations.\n// 6. gamma correction for skybox.\n\n// 2022.12.21\n// 1. make the rotation of the view smooth.\n// 2. automatically perform noise reduction when stopping movement.\n// 3. hold down space to force a screen refresh.", "buffer_b_code": "// Copyright © 2019-2022 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// 摄像机参数\nconst float camera_vfov       = 40.0;                 // 摄像机的纵向视野\nconst float camera_focus      = 9.0*sqrt(3.0);        // 摄像机的对焦距离\nconst float camera_aperture   = 0.0;                  // 摄像机的光圈大小\nconst float camera_exposure   = 1.0;                  // 摄像机曝光值\nconst float light_quality     = 128.0;                // 间接光质量\nconst float gamma             = 2.2;                  // 伽马矫正值\n\n// 配置常量\nconst float TMIN         = 0.05;                      // 光开始传播的起始偏移，避免光线自相交\nconst float TMAX         = 2000.0;                    // 最大单次光线传播距离 (相当于可见范围)\nconst float PRECISION    = 0.005;                     // 需小于 TMIN，否则光线无法正常离开物体表面\nconst float VISIBILITY   = pow(1.0 / 256.0, gamma);   // 亮度可见度\n\nconst uint  MAX_RAYMARCH = 512U;                      // 最大光线步进次数\nconst uint  MAX_RAYTRACE = 128U;                      // 最大光线追踪次数\n\nconst float ENV_IOR      = 1.000277;                  // 环境的折射率 （空气）\n\n// 枚举形状\nconst int SHAPE_SPHERE   = 0;\nconst int SHAPE_BOX      = 1;\nconst int SHAPE_CYLINDER = 2;\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// 物体材质\nstruct material {\n    vec3  albedo;       // 反照率\n    vec3  emission;     // 自发光\n    vec3  normal;       // 切线空间法线\n    float roughness;    // 粗糙度\n    float metallic;     // 金属度\n    float transmission; // 透明度\n    float ior;          // 折射率\n    bool  solid;        // 是否实心\n};\n\n// 物体变换\nstruct transform {\n    vec3 position;      // 位置\n    vec3 rotation;      // 旋转\n    vec3 scale;         // 缩放\n};\n\n// SDF 物体\nstruct object {\n    int       shape;    // 形状\n    float     dis;      // 距离物体表面\n    transform trs;      // 变换\n    material  mtl;      // 材质\n};\n\n// 光线\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\n// 光子击中的记录\nstruct record {\n    object obj;         // 物体\n    vec3   pos;         // 击中的位置\n    vec3   normal;      // 世界空间法线\n    bool   hit;         // 是否击中\n};\n\n// 摄像机\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\n// SDF 球体\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// SDF 盒子\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.02;\n}\n\n// SDF 圆柱\nfloat sd_cylinder(vec3 p, vec2 rh) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - rh;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// 地图列表\nconst object[] map = object[] (\n    \n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0, 0, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.5, 0.5, 0.5)\n        ),\n        material(   vec3(1.0, 1.0, 1.0), // 基础色\n                    vec3(0.1, 1.0, 0.1)*10.0, // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0,   // 粗糙度\n                    1.0,   // 金属度\n                    0.0,   // 透明度\n                    1.000, // 折射率 （真空）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_CYLINDER, ZERO,\n        transform(  vec3(-1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 0.2, 0.2), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.1,   // 粗糙度\n                    0.0,   // 金属度\n                    0.0,   // 透明度\n                    1.460, // 折射率 （塑料）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_CYLINDER, ZERO,\n        transform(  vec3(0, -0.2, -1.0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 1.0, 0.2), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    1.0,   // 粗糙度\n                    0.0,   // 金属度\n                    0.0,   // 透明度\n                    1.635,  // 折射率 （沥青）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(0.2, 0.2, 1.0), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.2,   // 粗糙度\n                    1.0,   // 金属度\n                    0.0,   // 透明度\n                    1.100, // 折射率 （铜）\n                    true  // 是否实心\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0.0, -0.20, 1),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0,   // 粗糙度\n                    0.0,   // 金属度\n                    1.0,   // 透明度\n                    1.500, // 折射率 （玻璃）\n                    true   // 是否实心\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, 0),\n                    vec3(0, 0, 0),\n                    vec3(3, 3, 3)\n        ),\n        material(   vec3(0.85, 0.9, 1.0)*1.0, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    0.0, // 金属度\n                    1.0, // 透明度\n                    1.500,  // 折射率 （金）\n                    true   // 是否实心\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, 0),\n                    vec3(0, 0, 0),\n                    vec3(2, 2, 2)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*1.0, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    0.0, // 金属度\n                    1.0, // 透明度\n                    1.500,  // 折射率 （金）\n                    false   // 是否实心\n        )\n    )\n);\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\n// 从摄像机获取光线\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2 rud = lens_radius * random_in_unit_disk();\n    vec3 offset = x * rud.x + y * rud.y;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\n// 从欧拉角计算旋转矩阵\nmat3 angle(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3(vec3( c.z,  s.z,    0),\n                vec3(-s.z,  c.z,    0),\n                vec3(   0,    0,    1)) *\n           mat3(vec3( c.y,    0, -s.y),\n                vec3(   0,    1,    0),\n                vec3( s.y,    0,  c.y)) *\n           mat3(vec3(   1,    0,    0),\n                vec3(   0,  c.x,  s.x),\n                vec3(   0, -s.x,  c.x));\n}\n\n// 计算有向距离 (物体内部距离为负)\nfloat signed_distance(object obj, vec3 pos) {\n    vec3 position = obj.trs.position;\n    vec3 rotation = obj.trs.rotation;\n    vec3 scale    = obj.trs.scale;\n    \n    vec3 p = pos - position;\n    \n    // 会重复的将欧拉角转换成旋转矩阵，实际上只用在第一次计算就行了\n    // 也有可能被编译器优化掉了\n    p *= angle(radians(rotation));\n    \n    switch(obj.shape) {\n        case SHAPE_SPHERE:\n            return sd_sphere(p, scale.x);\n        case SHAPE_BOX:\n            return sd_box(p, scale);\n        case SHAPE_CYLINDER:\n            return sd_cylinder(p, scale.xy);\n        default:\n            return sd_sphere(p, scale.x);\n    }\n}\n\n// 找到最近的物体并计算距离\nobject nearest_object(vec3 p) {\n    object o; o.dis = TMAX;\n    for (int i = 0; i < map.length(); i++) {\n        object oi = map[i];\n        oi.dis = abs(signed_distance(oi, p));\n        if (oi.dis < o.dis) o = oi;\n    }\n    return o;\n}\n\n// 找到最近的物体并计算距离\nobject innermost_object(vec3 p) {\n    object o; o.dis = TMAX; o.mtl.ior = ENV_IOR;\n    for (int i = 0; i < map.length(); i++) {\n        object oi = map[i];\n        float signed = signed_distance(oi, p);\n        oi.dis = abs(signed);\n        if (oi.dis < o.dis && signed < 0.0) o = oi;\n    }\n    return o;\n}\n\n// 计算物体法线 from https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal(object obj, vec3 p) {\n    vec2 e = vec2(1, -1) * 0.5773 * 0.0005;\n    return normalize( e.xyy*signed_distance(obj, p + e.xyy) + \n                      e.yyx*signed_distance(obj, p + e.yyx) + \n                      e.yxy*signed_distance(obj, p + e.yxy) + \n                      e.xxx*signed_distance(obj, p + e.xxx) );\n}\n\n// 用世界坐标下的法线计算 TBN 矩阵 from https://doi.org/10.1080/2165347X.2012.689606\nmat3 TBN(vec3 N) {\n    vec3 T, B;\n    \n    if (N.z < -0.99999) {\n        T = vec3(0, -1, 0);\n        B = vec3(-1, 0, 0);\n    } else {\n        float a = 1.0 / (1.0 + N.z);\n        float b = -N.x*N.y*a;\n        \n        T = vec3(1.0 - N.x*N.x*a, b, -N.x);\n        B = vec3(b, 1.0 - N.y*N.y*a, -N.y);\n    }\n    \n    return mat3(T, B, N);\n}\n\n// 使用光线步进 (Ray March) 检测第一个交点\nrecord raycast(ray r) {\n    record rec; float t = TMIN;\n    for(uint i = 0U; i < MAX_RAYMARCH && t < TMAX && !rec.hit; i++) {\n        rec.pos = at(r, t);\n        rec.obj = nearest_object(rec.pos);\n        rec.hit = rec.obj.dis < PRECISION;\n        t      += rec.obj.dis;\n    }\n    return rec;\n}\n\n// 采样立方体贴图\nvec4 mix_cube_lod(samplerCube sharp, samplerCube blur, vec3 dir, float lod) {\n    return mix(textureLod(sharp, dir, lod), textureLod(blur, dir, lod), lod);\n}\n\n// 采样天空\nvec3 sky(ray r, float brightness, float lod) {\n    // float t = 0.5 + 0.5 * r.direction.y;\n    // vec3 bottom = vec3(1.0, 1.0, 1.0);\n    // vec3 top = vec3(0.9, 1.5, 3.0);\n    // return mix(bottom, top, t * brightness);\n    vec4 ibl = mix_cube_lod(iChannel2, iChannel3, r.direction, lod); // 天空盒 IBL 照明\n    return pow(ibl.rgb * ibl.a * brightness, vec3(gamma)); // gamma 矫正\n}\n\n// 快速计算五次方\nfloat pow5(float x) {\n    float t = x*x; t *= t;\n    return t*x;\n}\n\n// 菲涅尔反射近似值\nfloat fresnel_schlick(float cosine, float F0) {\n    return mix(pow5(abs(1.0 - cosine)), 1.0, F0);\n}\n\n// 用粗糙度计算菲涅尔\nfloat fresnel_schlick(float cosine, float F0, float roughness) {\n    return mix(fresnel_schlick(cosine, F0), F0, roughness);\n}\n\n// 以 n 为法线进行半球采样\nvec3 hemispheric_sampling() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt(r.x);\n    vec2 xy = sqrt(1.0 - r.x) * v; \n\n    return vec3(xy, z);\n}\n\n// 用粗糙度采样沿向量 n 半球采样\nvec3 hemispheric_sampling(float roughness) {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    float shiny = pow5(roughness); // 光感越大高光越锐利\n    \n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt((1.0 - r.x) / (1.0 + (shiny - 1.0) * r.x));\n    vec2 xy = sqrt(abs(1.0 - z*z)) * v;\n    \n    return vec3(xy, z);\n}\n\n// 应用 PBR 材质\nray BSDF(ray r, record rec) {\n    // 材质参数\n    vec3  albedo       = rec.obj.mtl.albedo;\n    float roughness    = rec.obj.mtl.roughness;\n    float metallic     = rec.obj.mtl.metallic;\n    float transmission = rec.obj.mtl.transmission;\n    vec3  normal       = rec.obj.mtl.normal;\n    float ior          = rec.obj.mtl.ior;\n    bool  solid        = rec.obj.mtl.solid;\n    \n    normal = TBN(rec.normal) * normal; // 将切线空间法线转换到世界空间\n    \n    // 光线和物体表面参数\n    vec3 I  =  r.direction;\n    vec3 V  = -r.direction;\n    vec3 P  =  rec.pos;\n    vec3 N  =  normal;\n    vec3 C  =  r.color;\n    vec3 L;\n    \n    float outer = sign(dot(N, V)); // 光正在从外面穿入物体表面\n    N = normal *= outer; // 如果处于 SDF 物体内部就反过来\n    \n    N = TBN(N) * hemispheric_sampling(roughness);\n    float NoV   = dot(N, V);\n    \n    // 计算交界处折射率之比\n    ior = solid ? ior : ENV_IOR;\n    object obj = innermost_object(P - outer * TMIN * I);\n    float prev_or_next_ior = obj.mtl.solid ? obj.mtl.ior : ENV_IOR;\n    float eta = outer > 0.0 ? prev_or_next_ior / ior : ior / prev_or_next_ior;\n    \n    float k = 1.0 - eta * eta * (1.0 - NoV * NoV); // 小于 0 为全反射\n    float F0  = (eta - 1.0) / (eta + 1.0); F0 *= 3.0*F0; // 让透明材质的反射更明显一些\n    float F   = fresnel_schlick(NoV, F0, roughness); // 菲涅尔\n\n    vec2 rand2 = rand21();\n    if (rand2.x < transmission) { // BTDF 透射或者反射\n        if (rand2.y < F + metallic || k < 0.0) {\n            L = I + 2.0 * NoV * N; // 菲涅尔反射或全反射\n        } else {\n            L = eta * I - (sqrt(k)- eta * NoV) * N; // 斯涅尔折射\n        }\n    } else { // BRDF 反射或者漫反射\n        if (rand2.y < F + metallic) {\n            L = I + 2.0 * NoV * N; // 镜面反射\n        } else {\n            L = TBN(N) * hemispheric_sampling(); // 漫反射\n        }\n        \n        // 如果光穿入或穿出表面就反过来\n        L *= float(dot(L, normal) > 0.0);\n        // C *= 1.0 - float(innermost_object(P + TMIN * L).mtl.solid);\n    }\n\n    C *= albedo;\n\n    // 更新光的方向和颜色\n    r.color     = C;\n    r.origin    = P;\n    r.direction = L;\n    \n    return r;\n}\n\n// RGB 亮度\nfloat brightness(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\n\n// 光线追踪\nray raytrace(ray r) {\n    for (uint i = 0U; i < MAX_RAYTRACE; i++) {\n        // 俄罗斯轮盘赌概率，防止光线过分的反复反射\n        float inv_pdf = exp(float(i) / light_quality);\n        float roulette_prob = 1.0 - (1.0 / inv_pdf);\n    \n        // 光线被毙掉就不用继续了\n        if (rand11() < roulette_prob) {\n            r.color *= roulette_prob;\n            break;\n        }\n        \n        // 能量守恒\n        r.color *= inv_pdf;\n        \n        // 与地图求交\n        record rec = raycast(r);\n        \n        // 没击中物体就肯定击中天空\n        if (!rec.hit) {\n            r.color *= sign(float(i)); // 纯黑色背景\n            r.color *= sky(r, 2.0, 1.0 - 1.0 / (1.0 + 0.1 * float(i)));\n            break;\n        }\n        \n        // 计算法线\n        rec.normal = calc_normal(rec.obj, rec.pos);\n        \n        // 应用 PBR 材质\n        r = BSDF(r, rec);\n        \n        // 处理自发光\n        float intensity = brightness(r.color);\n              r.color  *= rec.obj.mtl.emission;\n        float visible   = brightness(r.color);\n        \n        // 太暗或者碰到光源\n        if (visible < VISIBILITY || visible > intensity) {\n            break;\n        }\n    }\n\n    return r;\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color *= mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color = a / b;\n\t// Back to color space\n    color *= mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\n// 片段着色器程序入口\nvec4 fragment(vec2 uv, vec2 SCREEN_PIXEL_SIZE, float TIME) {\n    // 计算摄像机方位和视线\n    vec3  lookfrom  = load(POSITION).xyz;\n    vec2  rotation  = load(ROTATION).xy;\n    vec3  direction = CameraRotation(rotation) * vec3(0, 0, -1);\n    vec3  lookat    = lookfrom + direction;\n    float aspect    = SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x;;\n    \n    // 初始化摄像机\n    camera cam;\n    cam.lookfrom = lookfrom;\n    cam.lookat   = lookat;\n    cam.aspect   = aspect;\n    cam.vfov     = camera_vfov;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = camera_focus;\n    cam.aperture = camera_aperture;\n    \n    // 用 UV 和时间初始化随机数发生器种子\n    seed = rand13(vec3(uv, TIME));\n\n    // 超采样\n    uv += rand21() * SCREEN_PIXEL_SIZE;\n    \n    // 对每个光子经过的表面采样一次\n    ray r = get_ray(cam, uv, vec3(1));\n    \n    // 处理颜色\n    vec3 color = raytrace(r).color;\n\n    // 色调映射\n    color *= camera_exposure;\n    color  = ACESFitted(color);\n    \n    // 伽马矫正\n    color = pow(color, vec3(1.0 / gamma));\n\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 SCREEN_PIXEL_SIZE = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * SCREEN_PIXEL_SIZE;\n    \n    fragColor = fragment(uv, SCREEN_PIXEL_SIZE, iTime); // 获取片元颜色\n    \n    if (bool(load(MOVING).x)) return; // 如果正在移动就不积累上一帧\n    \n    fragColor += texture(iChannel0, uv); // 积累帧进行降噪\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cls3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 261, 261, 394]], "test": "untested"}
{"id": "cll3Rj", "name": "minimal Modular Flow ( 252 ch )", "author": "FabriceNeyret2", "description": "minimal variant of  [url]https://shadertoy.com/view/ctlGRj[/url]\ngolfing  2041 chars \"Modular Flow\" by mla. [url]https://shadertoy.com/view/dlXGRN[/url]\n", "tags": ["flow", "2tweets", "golf", "modular", "eigenvector", "eigenvalue"], "likes": 17, "viewed": 304, "published": 3, "date": "1672049425", "time_retrieved": "2024-07-30T16:11:02.778623", "image_code": "// minimal variant of  https://shadertoy.com/view/ctlGRj\n// golfing 2041 chars \"Modular Flow\" by mla. https://shadertoy.com/view/dlXGRN\n// Inspiration:\n// https://twitter.com/matthen2/status/1604117218027077634\n// https://twitter.com/etiennejcb/status/1604946331411292166 (@Bleuje)\n\n\n/**/ //   282 chars \n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, q,\n         U =   ( 8.* ( u+u - R ) / R.y  + 2. ) \n             * mat2(cos( .1*iTime + vec4(0,33,11,0)))\n             - 2.;\n    float k = exp( log(2.618)* fract(iTime/4.) - .5 );\n    mat2  P = mat2( vec2(1,-1.618) / 1.9 , \n                    vec2(1,  .618) / 1.176 );    \n    q = vec2(k,1./k);\n    U = P * ( U * q );\n    O = R.yyyy/24.* ( length( ( U - round(U) ) * P / q ) - .3 );\n}\n\n\n/**  // 253 chars \n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy, q;\n    q.x = exp( log(2.618)* fract(iTime/4.) - .5 ), q.y = 1./q.x;\n    mat2  P = mat2(.526,-.85, .85,.526);\n    O = R.yyyy/24.* ( length( ( fract(P * ( (  ( 8.* ( u+u - R ) / R.y  + 2. ) \n                                              * mat2(cos( .1*iTime + vec4(0,33,11,0)))\n                                              - 2.\n                                            )* q \n                                          ) +.5\n                                     ) -.5 \n                              ) * P / q \n                            ) - .3 );\n}\n\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cll3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 342, 342, 756]], "test": "untested"}
{"id": "mlXGz2", "name": "Mineral", "author": "cinmin", "description": "Play with various color palette.\nUse mouse X position to adjust the index of refraction(IOR).\nShape Reference: Traced Minkowski Tube by Shane on Shadertoy\n", "tags": ["raymarching", "refraction"], "likes": 3, "viewed": 160, "published": 3, "date": "1672044217", "time_retrieved": "2024-07-30T16:11:03.763989", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define PI 3.141592654\n#define TWOPI 6.283185308 \n\n\nvec3 normalMap(vec3 p, vec3 n);\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat noise_3(in vec3 p); //亂數範圍 [0,1]\nvec3 FlameColour(float f);\n\nvec2 SphereMap( vec3 ray){\t\t//ray mapping to UV\n   vec2 st;\n   ray=normalize(ray);\n   float radius=length(ray);\n   st.y = acos(ray.y/radius) / PI;\n   if (ray.z >= 0.0) st.x = acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   else st.x = 1.0 - acos(ray.x/(radius * sin(PI*(st.y)))) / TWOPI;\n   return st;\n}\n\nvec4 warpcolor(in vec2 uv, float t){   //Normalized uv[0~1]\n    \t\tfloat strength = 0.8;\n\t\tvec3 col = vec3(0);\n\t\t//pos coordinates (from -1 to 1)\n\t\tvec2 pos = uv*2.0-1.0;\n            \n\t\t//請小心！QC迴圈最好使用int index，float index有可能錯誤！\n\t\tfor(int i = 1; i < 6; i++){ \n\t\tpos.x += strength * sin(2.0*t+float(i)*1.2 * pos.y)+t*0.5;\n\t\tpos.y += strength * cos(2.0*t+float(i)*0.4 * pos.x);}\n\n\t\t//Time varying pixel colour\n\t\tcol += 0.5 + 0.5*cos(t+pos.yyx+vec3(2,1,3));\n\t\t//Gamma\n\t\tcol = pow(col, vec3(0.9545));\n\t\treturn vec4(col,1.0) ;\n}\n\nvec3 warpSky(vec3 e){\n    vec2 ST = SphereMap(e);\n    vec4 color =warpcolor(ST, iTime*0.05);\n    return color.xyz;\n}\n\n\nvec3 phong(vec3 p, vec3 n, vec3 v){\n    vec3 final = vec3(0.0);\n    vec3 ambient_color=vec3(0.351,0.900,0.955);\n\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n    {\n    vec3 light_pos = vec3(mouse.x,mouse.y,2.0);\n    vec3 light_color = vec3(0.245,0.194,0.241);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.620, ks=1.5, kd= 2.;//各參數權重\n    float shineness=5.160;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final=ambient_color+diffuse+specular;\n    }\n    {\n  \n    vec3 light_pos = vec3(-5.,15.,2.0);\n    vec3 light_color = vec3(0.920,0.266,0.258);\n    vec3 light_vector =normalize(light_pos-p);\n    vec3 reflection = normalize(reflect(-light_pos,n));  \n    float ka=0.320, ks=0.8, kd= 0.8;//各參數權重\n    float shineness=2.568;\n    \n    vec3 diffuse, specular, ambient;\n    ambient = ka*ambient_color;\n    diffuse= kd*dot(light_vector,n)*light_color;\n    specular= ks*pow(max(dot(reflection,v),0.),shineness)*light_color;\n    final+=(diffuse+specular)*0.6;\n    }\n    // final+=ambient_color;\n    vec3 refl = reflect(-v,n);\n    vec3 refl_clr=warpSky(refl);\n    float F =1.0-dot(n,v);\n    final = mix(final,refl_clr,F);\n    return final;\n}\n\n\n// by shane : https://www.shadertoy.com/view/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); // I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n    return  max(v.x, v.y) - max(v.z, v.w); // Maximum minus second order, for that beveled Voronoi look. Range [0, 1].\n    \n}\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nfloat bump=-0.288 * (Voronesque(p*1.0));\nfloat bump2=-0.9 * (noise_3(p*1.0)*2.0-1.0);\nvec3 p1 = p ;\n\n\n//return sdSphere(p1+vec3(0.,0.,0.0), 0.5);\n//return sdTorus(p1+vec3(sin(u_time*0.3)*0.2,sin(u_time)*0.5,0.0),vec2(0.4,0.2));\n//return sdTorus(p1+bump2,vec2(0.3,0.1));\nreturn sdSphere(p,0.1+Voronesque(p*3.5+vec3(0,0,iTime*0.2))*0.5);\n//return sdBox(p+vec3(0.0,0.0,0.0), vec3(0.4, 0.4, 0.4));\n//return udRoundBox(p+vec3(0.0,0.0,0.0), vec3(0.3, 0.3, 0.3), 0.1);\n\n\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<15; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.3; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\n// === raytrace functions===\nfloat trace_inner(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.01;\nfor (int i=0; i<32; ++i)\n{\n\tp= o+r*t;\n\td=-map(p);\n\tif(d<0.001|| t>10.) break;\n\tt += d*0.5; //影響輪廓精準程度\n\t}\nreturn t;\n}\n//=== sky ===\nfloat fbm(in vec2 uv);\nvec3 getSkyFBM(vec3 e) {\t//二維雲霧\n\tvec3 f=e;\n\tfloat m = 2.0 * sqrt(f.x*f.x + f.y*f.y + f.z*f.z);\n\tvec2 st= vec2(-f.x/m + .5, -f.y/m + .5);\n\t//vec3 ret=texture2D(iChannel0, st).xyz;\n\tfloat fog= fbm(0.6*st+vec2(-0.2*iTime, -0.02*iTime))*0.5+0.3;\n    return vec3(fog);\n}\n\nvec3 sky_color(vec3 e) {\t//漸層藍天空色\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    //ret.x = pow(1.0-e.y,3.0);\n    //ret.y = pow(1.0-e.y, 1.2);\n    //ret.z = 0.8+(1.0-e.y)*0.3;\n    ret=FlameColour(e.y);\n    return ret;\n}\n\nvec3 getSkyALL(vec3 e)\n{\t\n\treturn sky_color(e);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy/iResolution.xy;\nuv = uv*2.0-1.0;\nuv.x*= iResolution.x/iResolution.y;\nuv.y*=1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\nvec2 mouse=(iMouse.xy/iResolution.xy)*2.;\n\n// camera option1  (模型應在原點，適用於物件)\n\tvec3 CameraRot=vec3(0.0, 0., iTime*0.2); \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.5));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    vec3 bump=normalMap(p*1.652,n);\n    n=n+bump*0.05;\n    \n    float edge= dot(-RayDir, n);\n    //edge = step(0.2, edge);\n    edge = smoothstep(-0.072, 0.956, edge);\n    \n       //Second Ray\n    vec3 p2,n2;\n    float IOR=mouse.x;\n\tvec3 Rd_2 = refract(RayDir, n, 1.0/IOR);  //1.0=空氣折射率\n    float t2= trace_inner(p,Rd_2,p2);\n    n2=normalize(gradient(p2));\n\n    //Third Ray\n    vec3 Rd_3 = refract(Rd_2, -n2, IOR/1.0);\n    \n    vec3 refl = getSkyALL(reflect(RayDir,n));\n    vec3 refr= warpSky(Rd_3);\n    float F=1.0-0.5*dot(n,-RayDir); //edge=0 center=1\n\tvec4 final = mix(vec4(refr,1.),vec4( 1.), F);  //try assign final to result and see the effect\n\n\t\t\n//SHADING\n    vec3 result=n;\n    vec3 ao = vec3(calcAO(p,n));\n\n    vec3 refl2 = reflect(Rd_3,n2);\n    vec3 refl_clr=warpSky(refl2);\n\tvec3 BG=vec3(refl_clr.z)*0.1;\t   //或getSkyFBM(RayDir)\n\n\n\nif(t<2.5) fragColor = final; else fragColor = vec4(BG,1.0);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n//=== glow functions ===\nfloat glow(float d, float str, float thickness){\n    return thickness / pow(d, str);\n}\n\n//=== 2d noise functions ===\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(in vec2 uv)\t\t//亂數範圍 [-1,1]\n{\n\tfloat f;\t\t\t\t//fbm - fractal noise (4 octaves)\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf   = 0.5000*gnoise( uv ); uv = m*uv;\t\t  \n\tf += 0.2500*gnoise( uv ); uv = m*uv;\n\tf += 0.1250*gnoise( uv ); uv = m*uv;\n\tf += 0.0625*gnoise( uv ); uv = m*uv;\n\treturn f;\n}\n\n//=== 3d noise functions p/n ===\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n//=== iq’s calc AO ===\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,-0.1,0.1));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08)*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; //if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*2.95));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 274, 295, 553], [555, 555, 591, 614, 1110], [1112, 1112, 1133, 1133, 1228], [1231, 1231, 1266, 1266, 2616], [2619, 2671, 2702, 2702, 3487], [3489, 3518, 3553, 3553, 3579], [3580, 3580, 3611, 3611, 3698], [3699, 3699, 3732, 3732, 3797], [3800, 3800, 3843, 3886, 3930], [3932, 3932, 3954, 3954, 4420], [4422, 4451, 4497, 4497, 4715], [4718, 4747, 4788, 4788, 4930], [4932, 4961, 5008, 5008, 5162], [5200, 5200, 5224, 5239, 5473], [5475, 5475, 5499, 5520, 5700], [5702, 5702, 5726, 5726, 5751], [5753, 5780, 5832, 5832, 6009], [6011, 6019, 6045, 6045, 6415], [6417, 6437, 6494, 6494, 8430], [8451, 8480, 8503, 8503, 8553], [8554, 8554, 8576, 8576, 8656], [8657, 8657, 8679, 8679, 8767], [8769, 8781, 8807, 8807, 9428], [9429, 9454, 9502, 9502, 9540], [9542, 9571, 9617, 9617, 9755], [9756, 9756, 9806, 9806, 10227], [10228, 10228, 10274, 10274, 10532], [10534, 10567, 10598, 10598, 10686], [10688, 10688, 10729, 10729, 10925], [10971, 10971, 11009, 11009, 11408], [11410, 11410, 11442, 11442, 11758], [11760, 11785, 11827, 11827, 12172], [12174, 12243, 12277, 12277, 12455], [12457, 12457, 12498, 12498, 12613], [12615, 12615, 12642, 12642, 12716]], "test": "untested"}
{"id": "DlX3zj", "name": "Finite element scalar field", "author": "delfigamer", "description": "A finite element simulation of a scalar field.\n\nIf the screen is black, tap it with a mouse.", "tags": ["simulation", "scalarfield", "fem"], "likes": 2, "viewed": 259, "published": 3, "date": "1672006525", "time_retrieved": "2024-07-30T16:11:04.514980", "image_code": "/*\nThis shader simulates a scalar field S governed by this equation:\nd^2 / dt^2 S = div grad S + d/dt R\n\nThe exitation source is placed at the current mouse position.\n\nIn this simulation, this 2nd-order diff equation is decomposed into\ntwo 1st-order ones:\nd/dt Q = grad S\nd/dt S = div Q + R\n\nThe Q and S fields are placed on a staggered grid, with\nQx cells offset by -0.5 in the x direction, and\nQy cells offset by -0.5 in the y direction\nrelative to S and R.\n\nIn addition, on the boundaries of the simulation area,\nwe place (mostly) non-reflective boundary conditions of the form:\nd/dt S = d/dx S (on the left side, analogously for others)\n\nIn the decomposed form, this is formulated as:\nQx = S\n\n\n\nOverall, the FEM update equations are,\nfor the interior:\nQx[u-0.5, v, t+0.5] =\n    Qx[u-0.5, v, t-0.5] +\n    0.5 * (S[u, v, t] - S[u-1, v, t])\nQy[u, v-0.5, t+0.5] =\n    Qy[u, v-0.5, t-0.5] +\n    0.5 * (S[u, v, t] - S[u, v-1, t])\nS[u, v, t+1] =\n    S[u, v, t] +\n    0.5 * (Qx[u-0.5, v, t-0.5] - Qx[u-0.5, v, t-0.5]) +\n    0.5 * (Qy[u, v+0.5, t-0.5] - Qy[u, v-0.5, t-0.5]) +\n    R[u, v, t+0.5]\n\nfor the left edge:\nQx[-0.5, v, t+0.5] = R[0, v, t]\n\nfor the right edge:\nQx[maxu+0.5, v, t+0.5] = - R[maxu, v, t]\n\nfor the bottom edge:\nQy[u, -0.5, t+0.5] = R[u, 0, t]\n\nfor the top edge:\nQy[u, maxv+0.5, t+0.5] = - R[u, maxv, t]\n\n\n\nIn this simulation, the S field takes on complex values.\n\n\n\nThe R field here is:\nR[u, v, t] = A * Exp[I * (f t)] * DiracDelta[u - mouseu, v - mousev]\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = 100.0 * texture(iChannel0, fragCoord/iResolution.xy);\n    float r = dot(p, vec4( 1.0,  0.0,   0.0, 0.0));\n    float g = dot(p, vec4(-0.5,  0.866, 0.0, 0.0));\n    float b = dot(p, vec4(-0.5, -0.866, 0.0, 0.0));\n    fragColor = vec4(r, g, b, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (\n        fragCoord.x <= 1.0 ||\n        fragCoord.y <= 1.0 ||\n        fragCoord.x >= iResolution.x-1.0 ||\n        fragCoord.y >= iResolution.y-1.0\n    ) {\n        fragColor = vec4(0, 0, 0, 0);\n    } else {\n        vec4 p = texture(iChannel0, fragCoord/iResolution.xy);\n        vec4 qxr = texture(iChannel1, (fragCoord + vec2(1,0))/iResolution.xy);\n        vec4 qxl = texture(iChannel1, (fragCoord)/iResolution.xy);\n        vec4 qyr = texture(iChannel2, (fragCoord + vec2(0,1))/iResolution.xy);\n        vec4 qyl = texture(iChannel2, (fragCoord)/iResolution.xy);\n        vec4 r = rfield(fragCoord, iResolution.xy, iMouse.xy, iFrame);\n        vec4 dxqx = qxr - qxl;\n        vec4 dyqy = qyr - qyl;\n        vec4 dtp = 0.5 * (dxqx + dyqy) + r;\n        fragColor = p + dtp;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 rfield(vec2 coord, vec2 res, vec2 point, int frame)\n{\n    float t = 0.1 * float(frame);\n    float a = 0.3;\n    if ((coord + vec2(0.5, 0.5)) == point) {\n        return a * vec4(cos(t), sin(t), 0, 0);\n    //} else if ((coord + vec2(-0.5, 0.5)) == point) {\n    //    return -a * vec4(cos(t), sin(t), 0, 0);\n    } else {\n        return vec4(0, 0, 0, 0);\n    }\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x <= 2.0) {\n        fragColor = texture(iChannel0, (fragCoord)/iResolution.xy);\n    } else if (fragCoord.x >= iResolution.x - 2.0) {\n        fragColor = - texture(iChannel0, (fragCoord - vec2(1,0))/iResolution.xy);\n    } else {\n        vec4 qx = texture(iChannel1, fragCoord/iResolution.xy);\n        vec4 pr = texture(iChannel0, (fragCoord)/iResolution.xy);\n        vec4 pl = texture(iChannel0, (fragCoord - vec2(1,0))/iResolution.xy);\n        vec4 dxp = pr - pl;\n        vec4 dtqx = 0.5 * dxp;\n        fragColor = qx + dtqx;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y <= 2.0) {\n        fragColor = texture(iChannel0, (fragCoord)/iResolution.xy);\n    } else if (fragCoord.y >= iResolution.y - 2.0) {\n        fragColor = - texture(iChannel0, (fragCoord - vec2(0,1))/iResolution.xy);\n    } else {\n        vec4 qy = texture(iChannel2, fragCoord/iResolution.xy);\n        vec4 pr = texture(iChannel0, (fragCoord)/iResolution.xy);\n        vec4 pl = texture(iChannel0, (fragCoord - vec2(0,1))/iResolution.xy);\n        vec4 dyp = pr - pl;\n        vec4 dtqy = 0.5 * dyp;\n        fragColor = qy + dtqy;\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlX3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1476, 1476, 1533, 1533, 1792]], "test": "untested"}
{"id": "dlX3zS", "name": "Lorentz Initial Space Explorer", "author": "Txoka", "description": "Explorer that shows the evolution (usually into chaos, depends on attractor configuration, which you can also explore if you modify a bit the code and see which attractors end up in chaos and which not) of the different inital states. (also added RK4)", "tags": ["fractal", "simulation", "attractor", "chaos", "pattern", "explorer"], "likes": 3, "viewed": 196, "published": 3, "date": "1672004761", "time_retrieved": "2024-07-30T16:11:05.265973", "image_code": "float sig(float x){\n    return 1./(1.+exp(-x));\n}\n\nvec4 sig(vec4 x){\n    return vec4(sig(x.x),sig(x.y),sig(x.z),0.);\n}\n\nvoid mainImage(out vec4 O, in vec2 U){\n    O = sig(texture(iChannel0, U/iResolution.xy)*sigmoid_transition);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 acc(vec3 p,float s,float r,float b)\n{\n    return vec3(\n        s*(p.y-p.x),\n        p.x*(r-p.z)-p.y,\n        p.x*p.y-b*p.z);\n}\n\nvec3 RK4(vec3 x,float h,float s,float r, float b){\n    vec3 k1=acc(x,s,r,b);\n    vec3 k2=acc(x+k1*h*0.5,s,r,b);\n    vec3 k3=acc(x+k2*h*0.5,s,r,b);\n    vec3 k4=acc(x+k3*h,s,r,b);\n\n    return h*(k1+k2*2.+k3*2.+k4)/6.;\n}\n\nconst float dt=0.01;\n\n\nvoid mainImage(out vec4 O, in vec2 U){\n    vec2 uv=(U*2.-iResolution.xy)/iResolution.y*100.;\n    O=texture(iChannel0, U/iResolution.xy);\n    //60 frames to full-screen if you want\n    if(iFrame<60)O.xyz = initial_state;\n    \n    O.xyz += RK4(O.xyz,dt,s,r,b);\n    //O.xyz += acc(O.xyz,s,r,b)*dt;\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define initial_state vec3(uv,r-1.)\n\n//atractor parameters\nconst float s=10.;\nconst float r=28.;\nconst float b=8./3.; \n//change those for defines if you want to explore\n//parameter space\n\n\n//5,28,8/3 converges in all points\n//6,28,8/3 has convergence and chaos\n\n//(1,2,3,4),28,8/3 show cool patters\n\nconst float sigmoid_transition=0.1; //the lower the fuzzyer\n//just the strength of the transition\n//higher is more vivid colors but more constrast", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlX3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 49], [51, 51, 68, 68, 118], [120, 120, 158, 158, 230]], "test": "untested"}
{"id": "ctf3z7", "name": "Starry uh thing", "author": "fishy", "description": "a thing, idk don't ask me", "tags": ["cloud", "stars"], "likes": 3, "viewed": 192, "published": 3, "date": "1671989258", "time_retrieved": "2024-07-30T16:11:06.019957", "image_code": "#define saturate(x) clamp(x,0.0, 1.0)\n#define smooth(x) smoothstep(0., 1., x)\n\n#define MAIN_PALETTE palette(vec3(0.500, -0.072, 0.288), vec3(0.628, 1.118, 1.078), vec3(0.518, 0.558, 0.428), vec3(-0.092, -1.032, 0.898))\n#define BOTTOM_COLOR vec3(71, 12, 79)/255.\n#define BOTTOM_HEIGHT 0.05\n#define BOTTOM_FADE 0.6\n\n#define iTime iTime*0.2\n\n\nstruct palette\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n};\n\nvec3 pal( in float t, palette p) // by iq, modified\n{\n    return p.a + p.b*cos(6.28318*(p.c*t+p.d));\n}\n\n//palette np = palette(vec3(0.648, -0.162, 0.0), vec3(0.848, 0.500, 0.848), vec3(0.518, 0.518, 0.608), vec3(0.088, -1.172, 0.848));\n//palette np = ;\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nmat2 r(float t)\n{\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return (fract((p3.xx+p3.yz)*p3.zy) - 0.5) * 2.0;\n}\n\nfloat perlinNoise(vec2 p, float t)\n{\n    mat2 r = r(t);\n    vec2 tlVal = r*hash22(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = r*hash22(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = r*hash22(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = r*hash22(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, smooth(fract(p.y)));\n    float b = mix(br, tr, smooth(fract(p.y)));\n    \n    return mix(a, b, smooth(fract(p.x))) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 p, float r, float o, float t)\n{\n    float sum = 0.;\n    for(float i = 0.; i < o; i++)\n    {\n        float e = pow(r, -i);\n        sum += perlinNoise((p-hash22(vec2(i)))/e, t)*e;\n    }\n    return sum*0.5;\n}\n\nvec2 warpFbm(in vec2 p, float r, float o, float t, vec2 a)\n{\n    float sum = 0.;\n    for(float i = 0.; i < o; i++)\n    {\n        float e = pow(r, -i);\n        p += (perlinNoise((p+a-hash22(vec2(i)))/e, t)-0.5)*e;\n    }\n    return p;\n}\n\nfloat warpFbmNoise(in vec2 p, float r, float o, float t, vec2 a)\n{\n    return perlinNoise(warpFbm(p, r, o, t, a), t);\n}\n\nfloat voronoi(vec2 p, float jitter, out vec2 f1, out vec3 f2, float time)\n{\n    float cr = 100000.0; // A big number\n    vec2 fp = floor(p); // Round the current position down to the nearest whole number\n    f1 = vec2(0);\n    f2 = vec3(0);\n    for(int x = -1; x <= 1; x++) // Loop over the space near the point\n    for(int y = -1; y <= 1; y++) // Same thing\n    {\n        vec2 cell = fp+vec2(x, y); // Get the current square cell\n        mat2 rot = r(time*(hash22(cell).x-0.5)*2.);\n        vec2 rp = cell+0.5+rot*(hash22(cell)-0.5)*jitter; // Each square cell the point can be in has a single point, offset by a random value times the jitter\n        float d = distance(p, rp); // Get the distance between the random point and the input position\n        if(d < cr) // If the distance is the closer than the current closest distance, it becomes the closest distance (along with the position of the point)\n        {\n            f2.z = cr;\n            cr = d;\n            f2.xy = f1;\n            f1 = cell;\n        }\n    }\n    return cr;\n}\n\nfloat voronoi(vec2 p, float jitter)\n{\n    float r = 100000.0; // A big number\n    vec2 fp = floor(p); // Round the current position down to the nearest whole number\n    for(int x = -1; x <= 1; x++) // Loop over the space near the point\n    for(int y = -1; y <= 1; y++) // Same thing\n    {\n        vec2 cell = fp+vec2(x, y); // Get the current square cell\n        vec2 rp = cell+0.5+(hash22(cell)-0.5)*jitter; // Each square cell the point can be in has a single point, offset by a random value times the jitter\n        float d = distance(p, rp); // Get the distance between the random point and the input position\n        if(d < r) // If the distance is the closer than the current closest distance, it becomes the closest distance (along with the position of the point)\n        {\n            r = d;\n        }\n    }\n    return r;\n}\n\nfloat blob0(vec2 p)\n{\n    float d = 0.0;\n    p -= vec2(-0.4, 0.5);\n    d += distance(p, vec2(0.));\n    d += distance(p, vec2(-0.5, 0.4));\n    d += distance(p, vec2(-0.8, 0.5));\n    return 0.6/(max(0., d)+1.);\n}\n\nfloat blob1(vec2 p)\n{\n    float d = 0.0;\n    p -= vec2(-0.4, -0.2);\n    d += distance(p, vec2(0.));\n    d += distance(p, vec2(-0.5, 0.4));\n    d += distance(p, vec2(-0.8, 0.5));\n    d -= distance(p, vec2(-2., 1.))*1.;\n    d += distance(p, vec2(1., 0.5))*1.;\n    return 0.6/(max(0., d)+1.);\n}\n\nfloat bottom(vec2 p)\n{\n    float mask = smoothstep(-1.+BOTTOM_HEIGHT, -1.+BOTTOM_HEIGHT+BOTTOM_FADE, p.y);\n    float noiseMask = smooth(peak(0.5, 0.5, mask));\n    float noise = sin(50.*warpFbmNoise(p*2.-vec2(0, iTime*0.3), 2., 2., iTime*0.1, vec2(0.1, 0.05)*iTime)+iTime)*0.5+0.5;\n    return 1.-(mask+noise*noiseMask);\n}\n\nfloat snoise(float x, float e, float s)\n{\n    vec2 res = iChannelResolution[0].xy;\n    float nx = floor(x*res.x) + erp(fract(x*res.x), s);\n    return texture(iChannel0, vec2(nx/res.x, e)).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec2 blobPos = warpFbm(uv, 4., 4., iTime*0.1, vec2(iTime*0.1));\n    float b = smoothstep(0.2, 0.4, blob1(blobPos))+smoothstep(0.24, 0.4, blob0(blobPos))*3.5;\n    float n = perlinNoise(warpFbm(uv*5.*(b*0.1+0.9)+iTime*0.1, 3., 5., iTime*0.5, vec2(iTime*0.3)), iTime*0.5);\n    \n    vec2 f1; vec3 f2;\n    //float stars = (smoothstep(0.7, 0.8, perlinNoise(uv*40., iTime*0.2))*0.5-b*0.4);\n    float stars = voronoi(uv*20.+iTime*0.1, 0.4, f1, f2, iTime*0.2);\n    vec2 shash = hash22(f1);\n    stars = smoothstep(0.3-shash.y*0.1, 0.1-shash.y*0.1, stars*2.)*smoothstep(0.8, 0.9, shash.x)*snoise(iTime*0.01, shash.y, 1.);\n    \n    vec3 starColor = pal(saturate(1.-stars*2.), MAIN_PALETTE);\n    vec3 mainColor = b*pal(n-b*0.2, MAIN_PALETTE)+saturate(starColor);\n    float bottomMask = bottom(uv);\n\n    // Output to screen\n    fragColor = displayVar(mix(mainColor+warpFbmNoise(uv, 2., 2., iTime*0.1, vec2(0.1, 0.05)*iTime)*0.2, BOTTOM_COLOR, bottomMask));\n    //fragColor = displayVar();\n    //fragColor = displayVar(f1/20.);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 displayVar(bool a) { return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(float a){ return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(vec2 a) { return vec4(a, 0.0, 1.0); }\n\nvec4 displayVar(vec3 a) { return vec4(a, 1.0); }\n\nvec4 displayVar(vec4 a) { return vec4(a.xyz, 1.0); }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctf3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 409, 462, 462, 511], [663, 663, 707, 707, 743], [745, 745, 784, 784, 824], [826, 826, 843, 843, 895], [897, 897, 926, 926, 1001], [1004, 1004, 1025, 1025, 1169], [1171, 1171, 1207, 1207, 1988], [1992, 1992, 2041, 2041, 2215], [2217, 2217, 2277, 2277, 2451], [2453, 2453, 2519, 2519, 2572], [2574, 2574, 2649, 2649, 3609], [3611, 3611, 3648, 3648, 4442], [4444, 4444, 4465, 4465, 4654], [4656, 4656, 4677, 4677, 4947], [4949, 4949, 4971, 4971, 5269], [5271, 5271, 5312, 5312, 5463], [5465, 5465, 5522, 5572, 6744]], "test": "untested"}
{"id": "mllGzB", "name": "Merry Christmas! [256 chars]", "author": "kishimisu", "description": "Merry christmas!", "tags": ["fun", "tree", "code", "xmas", "golf", "golfing"], "likes": 51, "viewed": 2120, "published": 3, "date": "1671988207", "time_retrieved": "2024-07-30T16:11:06.768954", "image_code": "/* \"Merry Christmas!\" by @kishimisu (2022) - https://www.shadertoy.com/view/mllGzB\n   [256 chars]\n   \n   An happy christmas tree !\n   \n                  */\n                 void \n               mainImage\n             (out vec4 O, \n            vec2 F) { vec2 \n           r=iResolution.xy; \n          O *= 0.; for (float \n         i=0.,y, t=iTime*.04;i\n        <150.;O+=.05/abs(length\n       (1.3*(F+F-r)/r.y+vec2(cos\n      (i*4.+t*40.)*(y*.5+.5), y)*\n     (1.+sin(y*10.)*.2))/.01+cos(t\n    +i)-1.)*(y+3.)*(cos(i++/2.+vec4\n         (4,1,0,0))+1.))y=sin\n                 (i*\n                 .1+\n                 t);}\n     \n     \n/* De-obfuscated version:\n\nvoid mainImage(out vec4 O, vec2 F) { \n    vec2 r = iResolution.xy; O *= 0.;\n    for (float i=0.,y, t=iTime*.04; i<150.; O +=\n        .05/abs(length(1.3*(F+F-r)/r.y+\n        vec2(cos(i*4.+t*40.)*(y*.5+.5),y) * (1.+sin(y*10.)*.2))\n        /.01+cos(t+i)-1.)*(y+3.)*(cos(i++/2.+vec4(4,1,6,0))+1.)\n    ) y = sin(i*.1+t);\n} */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 173, 252, 252, 614]], "test": "untested"}
{"id": "mts3RB", "name": "The Human Dream", "author": "yasuo", "description": "Merry Christmas!", "tags": ["graphicdesign", "cineshader", "sts9", "thehumandream"], "likes": 45, "viewed": 2663, "published": 3, "date": "1671986141", "time_retrieved": "2024-07-30T16:11:07.513962", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n\nfloat SimpleVesicaDistanceY(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\nfloat SimpleVesicaDistanceX(vec2 p, float r, float d) {\n    p.y = abs(p.y);\n    p.y+=d;\n    return length(p)-r;\n}\n\nfloat eyeBall(vec2 p){\n    vec2 prevP = p;\n    p.x += sin(iTime)*0.05;\n    float thickness = 0.002;\n    float d = abs(length(p)-0.1)-thickness;\n    float d2 = abs(length(p)-0.04)-thickness;\n    d = min(d,d2);\n    \n    p = DF(p,6.0);\n    p -= vec2(0.05);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(0.001,0.015));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x += sin(iTime)*0.05;\n    d2 = length(p-vec2(-0.03,0.03))-0.015;\n    d = min(d,d2);\n    return d;\n}\n\nfloat eye(vec2 p){\n    p*=1.2;\n    vec2 prevP = p;\n    float thickness = 0.002;\n    float d = eyeBall(p);\n    float s = mod(iTime*0.5,2.3);\n    if(s<1.){\n        p.y*=1.+s;\n    } else if(s>=1. && s<2.){\n        p.y*=1.+2.-s;\n    }\n    float d2 = abs(SimpleVesicaDistanceX(p,0.21,0.1))-thickness;\n    float d3 = SimpleVesicaDistanceX(p,0.21,0.1);\n    d = max(d3,d);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat arrow(vec2 p){\n    float d = Tri(p,vec2(0.22),radians(45.));\n    float d2 =Tri(p-vec2(0.0,-0.11),vec2(0.22),radians(45.));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat featherBG(vec2 p){\n    p*=2.3;\n    vec2 prevP = p;\n    p.x*=mix(0.3,2.,smoothstep(-1.2,0.9,p.y));\n    float d = SimpleVesicaDistanceY(p,0.41,0.2);\n    return d;\n}\n\nfloat feather(vec2 p){\n    p*=2.3;\n    vec2 prevP = p;\n    p.x*=mix(0.3,2.,smoothstep(-1.2,0.9,p.y));\n    float d = abs(SimpleVesicaDistanceY(p,0.41,0.2))-0.003;\n    \n    p = prevP;\n    float d2 = B(p-vec2(0.,-0.035),vec2(0.003,0.38));\n    d = min(d,d2);\n    \n    p-=vec2(0.062,0.1);\n    p*=Rot(radians(-30.));\n    d2 = B(p,vec2(0.072,0.003));\n    d = min(d,d2);\n    \n    p = prevP;\n    p-=vec2(-0.048,0.18);\n    p*=Rot(radians(30.));\n    d2 = B(p,vec2(0.055,0.003));\n    d = min(d,d2);    \n        \n    p = prevP;\n    p-=vec2(0.079,-0.03);\n    p*=Rot(radians(-30.));\n    d2 = B(p,vec2(0.089,0.003));\n    d = min(d,d2);  \n    \n    p = prevP;\n    p-=vec2(-0.07,0.03);\n    p*=Rot(radians(30.));\n    d2 = B(p,vec2(0.083,0.003));\n    d = min(d,d2);      \n    \n    p = prevP;\n    d2 = abs(length(p-vec2(-0.08,-0.06))-0.06)-0.003;\n    d = min(d,d2);      \n    \n    p = prevP;\n    d2 = length(p-vec2(0.05,-0.11))-0.02;\n    d = min(d,d2);  \n    d2 = length(p-vec2(0.11,-0.075))-0.02;\n    d = min(d,d2);  \n    \n    d2 = B(p-vec2(0.07,0.032),vec2(0.003,0.068));\n    d = min(d,d2);    \n    d2 = B(p-vec2(-0.06,0.105),vec2(0.003,0.081));\n    d = min(d,d2);  \n    \n    d2 = abs(length(p-vec2(-0.035,0.25))-0.02)-0.003;\n    d = min(d,d2); \n    \n    d2 = abs(length(p-vec2(0.052,0.17))-0.03)-0.003;\n    d = min(d,d2);     \n    \n    d2 = abs(length(p-vec2(0.035,0.24))-0.015)-0.003;\n    d = min(d,d2);      \n    \n    p = prevP;\n    \n    p.x = abs(p.x);\n    \n    p-=vec2(0.08,-0.16);\n    p*=Rot(radians(-30.));\n    d2 = B(p,vec2(0.095,0.003));\n    d = min(d,d2);   \n    p*=Rot(radians(30.));\n    p-=vec2(-0.03,-0.09);\n    d2 = B(p,vec2(0.003,0.075));\n    d = min(d,d2);  \n    \n    p-=vec2(0.05,0.035);\n    d2 = B(p,vec2(0.003,0.066));\n    d = min(d,d2);  \n    \n    return d;\n}\n\nfloat drawMainGraphic(vec2 p){\n    vec2 prevP = p;\n\n    float d = eye(p);\n\n    p*=Rot(radians(10.*iTime));\n    p = DF(p,3.0);\n    p -= vec2(0.235);\n    p*=Rot(radians(45.));\n    float d2 = feather(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(10.*iTime));\n    p = DF(p,3.0);\n    p -= vec2(0.108);\n    d2 = abs(length(p)-0.02)-0.001;\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = abs(length(p)-0.155)-0.001;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat isoCube(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    p*=Rot(radians(45.));\n    \n    float d = abs(B(p,vec2(0.1)))-0.002;\n    p = prevP;\n    p.x=abs(p.x);\n    p-=vec2(0.072,-0.12);\n    p.x*=1.41;\n    p.y*=1.41;\n    p*=SkewY(radians(-34.));\n    float d2 = abs(B(p,vec2(0.1)))-0.002;\n    d = min(d,d2);\n    return d;\n}\n\nfloat background(vec2 p){\n    p.y-=iTime*0.1;\n    p*=2.;\n    vec2 prevP = p;\n    p.x = mod(p.x,0.288)-0.144;\n    p.y = mod(p.y,0.48)-0.24;\n    float d = isoCube(p);\n    p = prevP;\n    p.x+=0.144;\n    p.x = mod(p.x,0.288)-0.144;\n    p.y+=0.24;\n    p.y = mod(p.y,0.48)-0.24;\n    float d2 = isoCube(p);\n    \n    return min(d,d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    \n    vec3 col = vec3(0.);\n    float d = drawMainGraphic(p);\n    \n    float d6 = background(p);\n    d6 = max(-(length(p)-0.25),d6);\n    col = mix(col,vec3(0.5),S(d6,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(7.*iTime));\n    p = DF(p,3.0);\n    p -= vec2(0.45);\n    p*=Rot(radians(45.));\n    float d5 =arrow(p);\n    col = mix(col,vec3(0.),S(d5,0.0));  \n    col = mix(col,vec3(0.7),S(abs(d5)-0.001,0.0));  \n    \n    // feather bg\n    p = prevP;\n    p*=Rot(radians(-5.*iTime));\n    p = DF(p,4.0);\n    p -= vec2(0.3);\n    p*=Rot(radians(45.));\n    float d4 = featherBG(p);\n    col = mix(col,vec3(0.),S(d4,0.0));    \n    \n    p = prevP;\n    p*=Rot(radians(-5.*iTime));\n    p = DF(p,4.0);\n    p -= vec2(0.3);\n    p*=Rot(radians(45.));\n    float d3 = feather(p);\n    col = mix(col,vec3(0.8),S(d3,0.0));\n     \n    p = prevP;\n    \n    // feather bg\n    p*=Rot(radians(10.*iTime));\n    p = DF(p,3.0);\n    p -= vec2(0.235);\n    p*=Rot(radians(45.));\n    float d2 = featherBG(p);\n    col = mix(col,vec3(0.),S(d2,0.0));\n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[527, 527, 582, 582, 640], [642, 642, 697, 697, 755], [757, 757, 779, 779, 1214], [1216, 1216, 1234, 1234, 1620], [1622, 1622, 1642, 1642, 1786], [1788, 1788, 1812, 1812, 1956], [1958, 1958, 1980, 1980, 3717], [3719, 3719, 3749, 3749, 4183], [4185, 4185, 4207, 4207, 4508], [4510, 4510, 4535, 4535, 4838], [4840, 4840, 4897, 4897, 6064]], "test": "untested"}
{"id": "mtl3RB", "name": "Fork Neon Tunne Infames 758", "author": "Infames", "description": "Quick and dirty sketch for a project at work which never got the green lights", "tags": ["raymarching", "tunnel", "neon"], "likes": 15, "viewed": 355, "published": 3, "date": "1671984769", "time_retrieved": "2024-07-30T16:11:08.255978", "image_code": "//quick and dirty code for prototyping\n\n#define MAXSTEPS 256\n#define MAXDIST 30.0\n#define PI 3.1415926535898\n#define TWOPI 6.28318530718\n#define FUZZ 0.7\n#define PHASELENGTH 30.0\n#define PHASE mod(iTime/PHASELENGTH,1.0)\n#define CUBENUM 50.0\n#define DISTANCEPERPHASE 150.0\n#define EPSILON 0.005\n\nvec3 glow = vec3(0);\nvec3 lastglow = vec3(0);\nvec3 cubeColor = vec3(0);\nfloat ringOffset = +0.6;\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvec3 displacement(float p) {\n    p *= 8.0*TWOPI/DISTANCEPERPHASE;\n    return vec3(sin(p),cos(p*0.5+PI+PHASE*TWOPI*3.0)*0.37,0)*1.7;\n}\n\n\n//sdf functions taken from iq\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat sdBox( vec3 p, vec3 b )\n{    \n\tfloat interval = DISTANCEPERPHASE/CUBENUM;\n  \tvec3 offset = displacement(round(p.z / interval +0.5)*interval - ringOffset);\n  \tp -= offset;\n    \n    float num = mod(floor(p.z/interval)+1.0,DISTANCEPERPHASE/interval)*4.0;\n    cubeColor = normalize(texture(iChannel0, vec2((num+0.5)/256.0,0.2/256.0)).xyz);\n  \tp.z = mod(p.z,interval) - interval*0.5;\n    p = mat3(rotationX(PHASE*TWOPI*5.0) * rotationZ(PHASE*TWOPI*18.0))*p;\n    \n  \tvec3 d = abs(p) - b;\n  \tfloat res = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n\n    lastglow = pow(max(0.0,(1.0-(res/2.0))),4.0) * cubeColor * 0.1;\n    glow += lastglow;\n    \n    return res;\n}\nfloat sdTube(vec3 p, float r)\n{\n    p.y += 0.8;\n    p -= displacement(p.z);\n    return length(p.xy)-r;\n}\n\nfloat sdTube2(vec3 p, float r)\n{\n    p -= displacement(p.z+1.5 - ringOffset);\n    return min(length(p.xy - vec2(0,0.9)),min(length(p.xy + vec2(0.9,0)),length(p.xy- vec2(0.9,0))))-r;\n}\n\nfloat sdTorus( vec3 p, float r1, float r2 )\n{\n    float interval = DISTANCEPERPHASE/CUBENUM;\n    vec3 offset = displacement(round(p.z / interval+0.5)*interval - ringOffset);\n    p -= offset;\n    p.z = mod(p.z,interval) - interval*0.5;\n    return length( vec2(length(p.xy)-r1,p.z) )-r2;\n}\n\nfloat map(vec3 pos)\n{\n    vec3 p=pos;\n    float d0 = sdTube(pos, 0.501);\n    float d1 = sdTorus(pos, 0.9, 0.05);\n    float d2 = sdTube2(pos,0.05);\n    d0 = opSmoothUnion(d0,d1,0.5);\n    d0 = opSmoothUnion(d0,d2,0.1);\n    d1 = sdBox(pos, vec3(0.05));\n    return min(d0,d1);\n}\n\nvoid intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float d = 0.01;\n    for(int i = 0; i < MAXSTEPS; i++)\n    {\n        vec3 p = ro + rd * d;\n        res = map(p);\n        if(res < EPSILON * d || res > MAXDIST) {\n            break;\n        }\n        d += res*FUZZ;\n    }\n    glow += lastglow*6.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5)/ iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float fov = 0.25 * PI;\n    vec3 origin = vec3(0,0, PHASE*DISTANCEPERPHASE);\n    vec3 target = origin -vec3(0.0, 0.001, -0.05);\n    \n    target += displacement(target.z*1.0);\n    origin += displacement(origin.z*1.0);\n\n\tvec3 forward = normalize(target - origin);\n \tvec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));   \n    vec3 up = cross(right, forward);\n    vec3 dir = normalize(uv.x * right + uv.y * up + fov * forward);\n    \n    intersect(origin, dir);\n\tfragColor = vec4(glow, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtl3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 393, 427, 427, 566], [568, 568, 602, 602, 738], [740, 740, 774, 774, 907], [909, 909, 937, 937, 1042], [1045, 1075, 1127, 1127, 1226], [1229, 1229, 1260, 1260, 1898], [1899, 1899, 1930, 1930, 2003], [2005, 2005, 2037, 2037, 2188], [2190, 2190, 2235, 2235, 2477], [2479, 2479, 2500, 2500, 2753], [2755, 2755, 2789, 2789, 3055], [3057, 3057, 3114, 3114, 3728]], "test": "untested"}
{"id": "dlsGRB", "name": "shortest hexagrid", "author": "FabriceNeyret2", "description": ".", "tags": ["short", "onetweet", "hexa", "golf"], "likes": 18, "viewed": 241, "published": 3, "date": "1671983642", "time_retrieved": "2024-07-30T16:11:09.052847", "image_code": "// -2 chars by Greg\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O.rgb = 1. - (O.a=iResolution.y) /13.\n                * abs( fract( 9.* u/O.a *mat3x2(1,0,.5,.87,.5,-.87) +.5 ) -.5);\n}\n\n\n\n/*  // 124 chars\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float h = iResolution.y;\n    O.rgb = 1.- h/13.* abs( fract( 9.* u/h * mat3x2(1,0,.5,.87,.5,-.87) +.5 ) -.5 );\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 59, 59, 183]], "test": "untested"}
{"id": "mtsGRB", "name": "hexagrid-point illusion", "author": "FabriceNeyret2", "description": "reference: [url]https://twitter.com/gsarcone/status/1603067190399438848[/url]", "tags": ["opticalillusion", "perception", "reproduction"], "likes": 13, "viewed": 224, "published": 3, "date": "1671983231", "time_retrieved": "2024-07-30T16:11:09.806832", "image_code": "#define S(v) smoothstep(13./R.y,0.,v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, V,\n         U = 9.* ( u - .5*R ) / R.y;\n    vec3 H =  abs( fract( U * mat3x2(1,0,.5,.87,.5,-.87) ) -.5 );\n\n    float a = .5 - max( H.z ,max(H.x,H.y)) , r = .12;\n    O =  vec4(1. - .6* S(a-.04) );           // hex grid\n    \n    V =  mod( U+ vec2(.5,0), vec2(2,1.15) ) - vec2(.5,.56); // nodes\n    if ( V.x>.5 == U.x>.5 ) r *= .5;         // choose dot size\n    if ( V.x>.5 ) V.x--;                     // mid-segment\n    a = length(V) - r;\n    O = mix(O, vec4(S(abs(a))), S(a) );      // draw dots\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 78, 78, 606]], "test": "untested"}
{"id": "mllGRB", "name": "2d Raytracing", "author": "SONENEIS", "description": "raytracing in 2d!", "tags": ["2d", "raytracing", "ray", "text", "circle", "i", "square", "rectangle", "green", "ball", "font", "normal", "box", "disk", "trace", "dark", "h"], "likes": 5, "viewed": 237, "published": 3, "date": "1671981677", "time_retrieved": "2024-07-30T16:11:10.558821", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\n//----------------------------------------------------//\n//--------------------- 2d sdfs ----------------------//\n//----------------------------------------------------//\n\n#define sdf(c,s) mix(col,c,smoothstep(3.0/iResolution.y,0.0,s));\n\nfloat sdCirc(vec2 p,float r){\n\treturn length(p) - r;\n}\n\nfloat sdRect(vec2 p,vec2 b){\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdLine(vec2 p,float r,vec2 p1,vec2 p2){\n\tvec2 a = p - p1, b = p2 - p1;\n\tfloat h = clamp(dot(b,a)/dot(b,b),0.0,1.0);\n\treturn length(a - b*h) - r;\n}\n\n//----------------------------------------------------//\n//---------------------- scene -----------------------//\n//----------------------------------------------------//\n\n#define circsLen 8\n#define rectsLen 16\n\nstruct Circ{\n\tvec2 pos;\n\tfloat rad;\n} [circsLen] circs;\n\nstruct Rect{\n\tvec2 pos;\n\tvec2 size;\n} [rectsLen] rects;\n\nvoid initScene(){\n  // H\n  rects[0] = Rect(vec2(-0.15,0.0),vec2(0.03,0.15));\n  rects[1] = Rect(vec2(0.0,0.0),vec2(0.03,0.15));\n  rects[2] = Rect(vec2(-0.075,0.0),vec2(0.045,0.015));\n  rects[6] = Rect(vec2(0.0,0.14),vec2(0.045,0.015));\n  rects[7] = Rect(vec2(-0.15,0.14),vec2(0.045,0.015));\n  rects[8] = Rect(vec2(0.0,-0.14),vec2(0.045,0.015));\n  rects[9] = Rect(vec2(-0.15,-0.14),vec2(0.045,0.015));\n  // I\n  rects[3] = Rect(vec2(0.15,-0.05),vec2(0.03,0.1));\n  circs[0] = Circ(vec2(0.15,0.125),0.037);\n  rects[10] = Rect(vec2(0.15,-0.14),vec2(0.045,0.015));\n  rects[11] = Rect(vec2(0.16,0.05),vec2(0.04,0.015));\n  \n  //ranndom shaps\n  circs[1] = Circ(vec2(0.0,0.5),0.07);\n  circs[2] = Circ(vec2(0.3,0.4),0.1);\n  circs[3] = Circ(vec2(-0.2,0.3),0.11);\n  rects[4] = Rect(vec2(0.3,-0.4),vec2(0.1));\n  rects[5] = Rect(vec2(-0.2,-0.3),vec2(0.05));\n  circs[4] = Circ(vec2(-0.5,0.0),0.07);\n  circs[5] = Circ(vec2(-0.7,0.3),0.08);\n  rects[12] = Rect(vec2(-0.6,-0.3),vec2(0.06));\n  rects[13] = Rect(vec2(0.6,-0.3),vec2(0.08));\n  rects[14] = Rect(vec2(0.4,0.1),vec2(0.05));\n  circs[6] = Circ(vec2(0.7,0.3),0.12);\n  circs[7] = Circ(vec2(0.35,-0.2),0.05);\n  rects[15] = Rect(vec2(0.7,0.0),vec2(0.06));\n}\n\n\n//----------------------------------------------------//\n//------------------ 2d raytracer --------------------//\n//----------------------------------------------------//\n\nvec3 iUn(vec3 a,vec3 b){\n  return b.z > 0.0 && b.z < a.z ? b : a;\n}\n\nvec3 iCirc(vec2 ro,vec2 rd,float r){\n  float b = dot(ro,rd);\n  float c = dot(ro,ro) - r*r;\n  float h = b*b - c;\n  if(h < 0.0) return vec3(0,0,-1.0);\n  float tN = -b - sqrt(h);\n  float tF = -b + sqrt(h);\n  float t = tN > 0.0 ? tN : tF;\n  vec2 nor = (ro+rd*tN)/r;\n  return vec3(nor,t);\n}\n\nvec3 iRect(vec2 ro,vec2 rd,vec2 b){\n  vec2 m = 1.0/rd;\n  vec2 n = m*ro;\n  vec2 k = abs(m)*b;\n  vec2 t1 = -n - k;\n  vec2 t2 = -n + k;\n  float tN = max(t1.x,t1.y);\n  float tF = min(t2.x,t2.y);\n  if(tN > tF || tF < 0.0) return vec3(0,0,-1.0);\n  float t = tN > 0.0 ? tN : tF;\n  vec2 nor = tN > 0.0 ? step(vec2(tN),t1) : step(t2,vec2(tF));\n  nor *= sign(-rd);\n  return vec3(nor,t);\n}\n\n//xy: surface normal\n//z: scene sdf\n//w: t (I do not know what it means ;-;)\nvec4 raytrace(vec2 p,vec2 ro,vec2 rd){\n\tvec4 hit = vec4(0,0,vec2(999999999999.9));\n\n\tfor(int i=0;i<circsLen;i++){\n\t  Circ s = circs[i];\n\t  hit.xyw = iUn(hit.xyw,iCirc(ro-s.pos,rd,s.rad));\n\t  hit.z = min(hit.z,sdCirc(p-s.pos,s.rad));\n\t}\n\n\tfor(int i=0;i<rectsLen;i++){\n\t  Rect s = rects[i];\n\t  hit.xyw = iUn(hit.xyw,iRect(ro-s.pos,rd,s.size));\n\t  hit.z = min(hit.z,sdRect(p-s.pos,s.size));\n\t}\n  \n\treturn hit;\n}\n\n//-----------------------------------------------------//\n//--------------------- main loop ---------------------//\n//-----------------------------------------------------//\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = 0.5*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mo = 0.5*(2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.05);\n  \n  initScene();\n  \n  vec2 ro = mo;\n  vec2 rd = normalize(vec2(1,0)) * rot(iTime);\n  \n  vec4 t = raytrace(uv,ro,rd);\n  vec2 pos = ro + rd*t.w;\n  \n  //draw scene\n  col = sdf(vec3(0),t.z-0.01);\n  col = sdf(vec3(0,1,0.5),t.z);\n  \n  //draw ray\n  col = sdf(vec3(0.5),sdLine(uv,0.002,ro,pos));\n  col = sdf(vec3(0.5),sdCirc(uv-ro,0.01));\n  \n  //draw normal\n  col = sdf(vec3(1,0,1),sdLine(uv,0.005,pos,pos+t.xy*0.07));\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [301, 301, 330, 330, 355], [357, 357, 385, 385, 461], [463, 463, 508, 508, 615], [943, 943, 960, 967, 2133], [2308, 2308, 2332, 2332, 2375], [2377, 2377, 2413, 2413, 2662], [2664, 2664, 2699, 2699, 3042], [3044, 3121, 3159, 3159, 3529], [3706, 3706, 3756, 3756, 4349]], "test": "untested"}
{"id": "dtlGRS", "name": "BLBLmascot", "author": "CodeJUN", "description": "个人练习", "tags": ["3d", "shadow", "colour", "object"], "likes": 2, "viewed": 166, "published": 3, "date": "1671972190", "time_retrieved": "2024-07-30T16:11:11.307818", "image_code": "\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.14159265\n\nvec2 fixUV(in vec2 c)\n{\n    return(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n}\n\nfloat sdfSphere(in vec3 p)//球体\n{\n    return length(p) - 0.8 ; \n}\n\nfloat sdfRect(in vec3 p, in vec3 b)//方形\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,-.1))+min(max(d.x,max(d.y,d.z)),0.);//奇奇怪怪的\n\n}\nfloat sdfBox(in vec3 p, in vec3 r,float rad)\n{\n    vec3 b=abs(p)-r;\n    return length(max(b,0.))+min(max(max(b.x,b.y),b.z),0.)-rad;\n\n}\nfloat sdTorus(vec3 p ,vec2 t)//圆环\n{\n    vec2 q=vec2 (length(p.xz)-t.x,p.y);\n    return length (q)-t.y;\n}\nfloat sdCapsule(vec3 p,vec3 a,vec3 b, float r)\n{\n    vec3 pa=p-a,ba=b-a;\n    float h =clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa-ba*h)-r;\n}\nfloat sdCappendTorus(in vec3 p,in vec2 sc, in float ra,in float rb)\n{\n    p.x=abs(p.x);\n    float k=(sc.y*p.x>sc.x*p.y)?dot(p.xy,sc):length (p.xy);\n    return sqrt(dot(p,p)+ra*ra-2.0*ra*k)-rb;\n}\nvec4 opElongate(in vec3 p, in vec3 h)\n{\n    vec3 q=abs(p)-h;\n    return vec4 (max(q,0.0),min(max(q.x,max(q.y,q.z)),0.0));\n}\n\n/*float sdfPlane(in vec3 p)\n{\n    return p.y;    \n}*/\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 map(in vec3 p)//合并\n{\n    p.xz*=mat2(0.,1.,1.,0.);\n    //vec2 d=vec2(sdfSphere(p-vec3(0.,.8,0.)),2.);//球体位置\n    //d =opU(d,vec2(sdfPlane(p+vec3(0.,1.,0.)),1.));\n    /*float h=sdfRect(p,vec3(0.));\n    d =min(d,sdfPlane(p+vec3(0.,1.,0.))+(h,sdfRect(p,vec3(1.))));*/\n    //d=opU(d,vec2(sdfBox(p-vec3(2.,1.,0.),vec3(1.,1.,1.)),3.));//box Transfrem\n    //d=opU(d,vec2(sdfRect(p-vec3(-2.,.5,2.),vec3(.5,.5,1.)),4.));//方形 位置\n    vec2 d= vec2 (sdfBox(p-vec3(0.,1.3,0.),vec3(1.5,.9,1.),.3),3.);\n    {   //frame\n        vec4 w=opElongate(p.xzy-vec3(0.,1.3,1.3),vec3(1.2,0.,0.55));\n        float t=w.w=sdTorus(w.xyz,vec2(.3,0.05));\n        d=opU(d,vec2(t,5.));\n    }\n    {   //eye\n        d=opU(d,vec2( sdCapsule(p,vec3(.4,1.6,1.3),vec3(1.,1.3,1.3),.1),5.));\n        d=opU(d,vec2( sdCapsule(p,vec3(-.4,1.6,1.3),vec3(-1.,1.3,1.3),.1),5.));\n    }\n    {   //mouth\n        float an=70./180.*PI;\n        d=opU(d,vec2(sdCappendTorus(p*vec3(1.,-1.,1.)-vec3(.3,-1.,1.3),vec2(sin(an),cos(an)),.3,.07),5.));\n        d=opU(d,vec2(sdCappendTorus(p*vec3(1.,-1.,1.)-vec3(-.3,-1.,1.3),vec2(sin(an),cos(an)),.3,.07),5.));\n    }\n    {   //ear\n        d=opU(d,vec2( sdCapsule(p,vec3(1.3,3.,1.),vec3(.2,2.,1.),.1),5.));\n        d=opU(d,vec2( sdCapsule(p,vec3(-1.3,3.,1.),vec3(-.2,2.,1.),.1),5.));\n    }\n    {   //legs\n         d=opU(d,vec2( sdCapsule(vec3(abs(p.x),p.y,abs(p.z)) ,vec3(1.3,.3,1.),vec3(1.5,.1,1.3),.1),5.));\n\n    }\n    return d;\n\n}\nvec2 rayMarch(in vec3 ro, in vec3 rd)//射线方向和源头\n{\n    float t=0.1;\n    float tmax=40.;\n    vec2 res=vec2(-1.);\n    if(rd.y<0.)\n    {\n        float tp=-ro.y/rd.y;\n        tmax=min(tmax,tp);\n        res=vec2(tp,1.);\n    }\n    for(int i=0;i<RAYMARCH_TIME &&t<tmax;i++)\n    {\n        vec3 p=ro+t*rd;\n        //float d=sdfSphere(p);//输出球体\n        //float d=sdfRect(p,vec3(.8+.1*sin(iTime),.3+.2*cos(iTime),.3));//输出方形\n        vec2 d=map(p);\n        if(d.x<PRECISION)\n        {\n            //return t;\n            res =vec2(t,d.y);\n            break;\n           \n        }\n        t += d.x;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)//光照 物体法向量\n{\n    const float h=0.01;;\n    const vec2 k= vec2 (1,-1);\n  /* return normalize(k.xyy * sdfSphere(p + k.xyy * h) +\n        k.yyx * sdfSphere(p + k.yyx * h) +\n        k.yxy * sdfSphere(p + k.yxy * h) +\n        k.xxx * sdfSphere(p + k.xxx * h));*/ \n     return normalize(k.xyy * map(p + k.xyy * h).x +\n        k.yyx * map(p + k.yyx * h).x +\n        k.yxy * map(p + k.yxy * h).x +\n        k.xxx * map(p + k.xxx * h).x);\n}\n\nmat3 setCamera(vec3 ta,vec3 ro,float cr)//摄像机围绕球体旋转\n{\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr) , cos(cr),0.);\n    vec3 x= normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro,in vec3 rd,float k)//软阴影\n{\n    float res=1.0;\n    float ph=1e20;\n    float tmin=.1;\n    float tmax = 10.;\n    for(float t=tmin;t<tmax;)\n    {\n        float h =map(ro+rd*t).x;\n        if(h<.001)//光线过度，h越小，过度越平滑\n            return 0.0;\n        float y =h*h/(2.0*ph);\n        float d=sqrt(h*h-y*y);\n        res=min(res,k*d/max(0.0,t-y));\n        ph=h;\n        t+=h;\n    }\n    return res;\n}\nvec2 tri (in vec2 x)\n{\n    vec2 h=fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nfloat checkersGrad(in vec2 uv,in vec2 ddx, in vec2 ddy)\n{\n    vec2 w =max(abs(ddx),abs(ddy))+0.01;\n    vec2 i=(tri(uv+0.5*w)-tri(uv-0.5*w))/w;\n    return 0.5-0.5*i.x*i.y;\n} \n\nvec3 render(in vec2 uv ,in vec2 px, in vec2 py)\n{\n    float ca=3.f;\n    //vec3 color =vec3(.05);//背景颜色\n    vec3 ro =vec3 (4.*cos(.1*iTime),ca,4.*sin(.1*iTime));//球体旋转\n    //vec3 ro =vec3 (4.*cos(PI/2.),ca,4.*sin(PI/2.));//球体旋转\n    if(iMouse.z>0.01)//鼠标控制\n    {\n        float theta=iMouse.x/iResolution.x*2.*PI;\n        ro=vec3(2.*cos(theta),2.-iMouse.y/iResolution.y*2.,4.*sin(theta));  \n    } \n    vec3 ta=vec3(0.,1.,0.);//摄像机位置\n    mat3 cam=setCamera(ta,ro,.1*sin(iTime));//摄像机运动\n    float fl=1.;\n    vec3 rd =normalize(cam*vec3 (uv,fl));//球体大小\n    vec3 bg=vec3(.7,.7,.9);\n    vec3 color = bg-rd.y*vec3(.1);//背景颜色\n    vec2 t=rayMarch(ro,rd);\n    if(t.y>0.)\n    {\n        vec3 p=ro+t.x*rd;\n        vec3 n= (t.y<1.1)?vec3(0.,1.,0.):calcNormal(p);\n        // vec3 light =vec3 (2.*cos(iTime),2.,2.*sin(iTime+2.));//光线移动\n        vec3 light =vec3 (6.,4.,5.);\n        float dif=clamp(dot(normalize(light-p),n),0.,1.);\n        p+=PRECISION*n;\n       // float st = softShadow(p,normalize(light-p),2.);//明显交界线\n        \n        dif *=softShadow(p,normalize(light-p),2.);//光线平滑\n       /*float st=rayMarch(p,normalize(light-p));\n        if(st<TMAX)//假阴影\n        {\n            dif*=.1; \n        }*/\n\n        float amd=0.5+0.5*dot(n,vec3(0.,1.,0));//环境灯光亮度\n        vec3 c=vec3(0.);\n        if(t.y>1.9&&t.y<2.1)\n        {\n            c=vec3(1.,0.,0.);//Sphere\n\n        }else if (t.y>2.9&&t.y<3.1)\n        {\n            c=vec3(1.);//box\n        }\n        else if(t.y>0.9&&t.y<1.1)\n        {\n           /* vec2 grid =floor(p.xz);\n            c=vec3(.23)+.2*mod(grid.x+grid.y,2.);//Plane*/\n            vec3 rdx = normalize(cam*vec3 (px,fl));\n            vec3 rdy = normalize(cam *vec3(py, fl));\n            vec3 ddx=ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 ddy=ro.y*(rd/rd.y-rdy/rdy.y);\n            c=vec3(.3)+vec3(0.2)*checkersGrad(p.xz,ddx.xz,ddy.xz);\n        }\n        else if(t.y>3.9&&t.y<4.1)\n        {\n            c=vec3(0.,1.,0.);//Rect\n        }\n        else if (t.y>4.9&&t.y<5.1)\n        {\n            c=vec3(0.);\n        }\n        color=amd*c+dif*vec3(.6);\n\n    }\n    return sqrt(color);//幂\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 color=vec3(0.);\n    for(int m =0;m<AA;m++)\n    {\n        for(int n=0; n<AA;n++)\n        {\n            vec2 offset=2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            //vec2 uv = fixUV(fragCoord+offset)+offset;\n             vec2 uv = fixUV(fragCoord+offset+offset);\n            vec2 px=fixUV (fragCoord+vec2(1.,0.)+offset);\n            vec2 py=fixUV (fragCoord+vec2(0.,1.)+offset);\n            color += render(uv,px,py);\n        }\n    }\n    fragColor=vec4(color/float(AA*AA),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 109, 109, 178], [180, 180, 216, 216, 248], [250, 250, 295, 295, 397], [398, 398, 444, 444, 532], [533, 533, 572, 572, 641], [642, 642, 690, 690, 797], [798, 798, 867, 867, 992], [993, 993, 1032, 1032, 1116], [1173, 1173, 1199, 1199, 1225], [1227, 1227, 1256, 1256, 2667], [2668, 2668, 2730, 2730, 3305], [3307, 3353, 3405, 3405, 3822], [3824, 3824, 3895, 3895, 4050], [4052, 4097, 4157, 4157, 4543], [4544, 4544, 4566, 4566, 4620], [4622, 4622, 4679, 4679, 4794], [4797, 4797, 4846, 4846, 6999], [7001, 7001, 7055, 7055, 7549]], "test": "untested"}
{"id": "Dll3RB", "name": "Smudge of Dawn_vr", "author": "szuhanlu_karen", "description": "墨染熹微", "tags": ["3d", "raymarching", "clouds", "rocks", "mountains", "vr", "inkpainting"], "likes": 3, "viewed": 307, "published": 3, "date": "1671964157", "time_retrieved": "2024-07-30T16:11:12.056816", "image_code": "// distance functions\nfloat sdSphere(vec3 p){//sphere scene\n    vec4 sphere1 = vec4(50.,-70.,1.,28.); \n    vec4 sphere2 = vec4(8.,20.,2.,15.); \n    vec4 sphere3 = vec4(70.,20.,10.,10.); \n    //前後 / 左右 / 顏色\n\n    float dSphere1 = distance(p, sphere1.xyz)-sphere1.w;\n    float dSphere2 = distance(p, sphere2.xyz)-sphere2.w;\n    float dSphere3 = distance(p, sphere3.xyz)-sphere3.w;\n\n    return min(min(dSphere1, dSphere2),min(min(dSphere1, dSphere2),dSphere3));\n}\n\nfloat plasma(vec3 r) {\n\tfloat mx = r.x + iTime / 2.;\n\tmx += 60.0 * sin((r.y + mx) / 50.0 + iTime);\n\tfloat my = r.y + iTime / 5.;\n\tmy += 50.0 * cos(r.x / 20.0 + iTime);\n\t\n    return r.z - (sin(mx / 15.0) + sin(my / 5.0) + 5.);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\nfloat map(in vec3 p)\n{\n    mat3 rot=fromEuler(vec3(0.0,0.0,iTime));\n\n    vec4 sphere1 = vec4(0.0, 0.0, 1.2, .2); \n    vec4 sphere2 = vec4(1.2, 0.0, 0.0, .4); \n    vec4 sphere3 = vec4(-1.2, 0.0, 1.0, .4); \n   \n    \n    float dSphere1 = distance(p, sphere1.xyz)-sphere1.w;\n    float dSphere2 = distance(p, sphere2.xyz)-sphere2.w;\n    float dSphere3 = distance(p, sphere3.xyz)-sphere3.w;\n  \n\n    float bump = noise_3(p)*.8;\n    vec3 p1 = p + bump;\n\n    bump = noise_3(p*.2)*5.;\n    vec3 p2 = p + bump;\n\n\n    return smin(plasma(p1), sdSphere(p2), 6.);//將石頭融入波紋\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p )\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\nfloat RayMarching(vec3 ro,vec3 rd){\n    float dO = 0.;\n\n    for(int i = 0 ; i < 64 ; i++){\n        vec3 p = ro+rd*dO;\n        float ds = map(p);\n        dO += ds;\n        if(ds<0.01 || dO>100.)\n            break;\n    }\n    \n    return dO;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n\tfloat c, s;\n\t//float vfov = 3.14159 / 5.;//2.3\n\n\tvec3 cam = ro + vec3(0.0, 0.0, 50.0);\n    \n    \n    vec2 fragCoord = gl_FragCoord.xy;\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y *= -1.0;\n\n\tvec3 dir = vec3(0.0, 0.0, -1.0);\n    \n\n\tfloat xrot = length(uv)*.8;\n\n    c = cos(xrot);\n\ts = sin(xrot);\n\tdir = mat3(1.0, 0.0, 0.0,\n\t           0.0,   c,  -s,\n\t           0.0,   s,   c) * dir;\n\n\n\tc = normalize(uv).x;\n\ts = normalize(uv).y;\n\tdir = mat3(  c,  -s, 0.0,\n\t             s,   c, 0.0,\n\t           0.0, 0.0, 1.0) * dir;\n\n\tc = cos(0.8);\n\ts = sin(0.8);\n\tdir = mat3(  c, 0.0,   s,\n\t           0.0, 1.0, 0.0,\n\t            -s, 0.0,   c) * dir;\n\n  \n    float dist = RayMarching(cam, dir);\n    vec3 pos = cam + dist * dir;\n\n  \n    vec4 fragColor=vec4(1.);\n\tfragColor.rgb = mix(\n        vec3(55,60,56)/255.,\n        mix(\n\t\t\tvec3(0.0, 0.0, 0.0),\n\t\t\tvec3(1.0, 1.0, 1.0),\n\t\t\tpos.z / 15.0\n\t\t),\n\t\t1.0 / (dist / 25.0)\n\t);\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\n    vec3 ro = 10.0*vec3(-6.28*m.y, -6.*m.x, m.y);\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n   \n    \n    fragColor = render( ro, rd );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dll3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 45, 59, 471], [473, 473, 495, 495, 700], [702, 702, 743, 743, 827], [829, 858, 881, 881, 931], [932, 932, 954, 954, 1034], [1035, 1035, 1057, 1057, 1145], [1147, 1159, 1185, 1185, 1806], [1808, 1808, 1834, 1834, 2204], [2207, 2207, 2229, 2229, 2779], [2781, 2810, 2838, 2838, 3056], [3058, 3058, 3093, 3093, 3298], [3300, 3300, 3352, 3352, 3529], [3532, 3532, 3571, 3571, 4557], [4559, 4559, 4616, 4616, 4967], [4969, 4969, 5063, 5063, 5115]], "test": "untested"}
{"id": "cllGRB", "name": "My fifth Raytracer", "author": "SONENEIS", "description": "nothing here.", "tags": ["raytracing", "ray", "cube", "texture", "shadow", "sphere", "fog", "red", "green", "ball", "orb", "blue", "box", "checkred"], "likes": 1, "viewed": 200, "published": 3, "date": "1671959429", "time_retrieved": "2024-07-30T16:11:12.822768", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nstruct Hit{\n\tfloat t;\n\tvec3 nor;\n\tfloat id;\n} ehit = Hit(-1.0,vec3(0.0),-1.0);\n\nHit iUn(Hit a,Hit b){\n  if(b.t > 0.0 && b.t < a.t) return b;\n  return a;\n}\n\nHit iSphere(float id,vec3 ro,vec3 rd,float r){\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n\tfloat h = b*b - c;\n\tif(h < 0.0) return ehit;\n\th = sqrt(h);\n\tfloat t = -b - h;\n\tvec3 nor = (ro + t*rd) / r;\n\treturn Hit(t,nor,id);\n}\nHit iPlane(float id,vec3 ro,vec3 rd,vec4 p){\n  float k1 = dot(ro,p.xyz);\n  float k2 = dot(rd,p.xyz);\n  float t = (p.w-k1)/k2;\n  vec2 ab = (k2>0.0) ? vec2(t,1e20) : vec2(-1e20,t);\n  return Hit(ab.x,-p.xyz,id);\n}\nHit iBox(float id,vec3 ro,vec3 rd,vec3 b){\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*b;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x,t1.y),t1.z);\n\tfloat tF = min(min(t2.x,t2.y),t2.z);\n\tif(tN > tF || tF < 0.0) return ehit;\n\tvec3 nor = (tN>0.0) ? step(vec3(tN),t1) : step(t2,vec3(tF));\n\tnor *= -sign(rd);\n\treturn Hit(tN,nor,id);\n}\n\nHit raytrace(vec3 ro,vec3 rd){\n\tHit h = Hit(9999.9,vec3(0.0),-1.0);\n\n  h = iUn(h,iPlane(0.0,ro,rd,vec4(0,1,0,1.1)));\n  h = iUn(h,iPlane(0.0,ro,rd,vec4(0,-1,0,0.5)));\n  h = iUn(h,iPlane(0.0,ro,rd,vec4(1,0,0,0.75)));\n  h = iUn(h,iPlane(0.0,ro,rd,vec4(-1,0,0,0.75)));\n  h = iUn(h,iPlane(0.0,ro,rd,vec4(0,0,-1,0.1)));\n  \n  {\n    vec3 roo = ro;\n  \tvec3 rdd = rd;\n  \troo -= vec3(0,0,1.0);\n  \troo.zx *= rot(iTime);\n  \trdd.zx *= rot(iTime);\n  \tHit box = iBox(1.0,roo,rdd,vec3(0.3));\n  \tbox.nor.zx *= rot(-iTime);\n    h = iUn(h,box);\n  }\n  \n  {\n  \tvec3 roo = ro;\n  \tvec3 rdd = rd;\n  \troo -= vec3(0,-0.6,2.0);\n  \troo.zx *= rot(0.5);\n  \trdd.zx *= rot(0.5);\n  \tHit box = iBox(0.0,roo,rdd,vec3(0.2));\n  \tbox.nor.zx *= rot(-0.5);\n    h = iUn(h,box);\n  }\n  \n  h = iUn(h,iSphere(4.0,ro-vec3(0.0,-0.3,2.1),rd,0.1));\n  \n  //h = iUn(h,iSphere(1.0,ro-vec3(0,0,0.5),rd,0.5));\n  h = iUn(h,iSphere(2.0,ro-vec3(0.5,-0.25,1.0),rd,0.25));\n  h = iUn(h,iSphere(3.0,ro-vec3(-0.4,-0.3,1.5),rd,0.15));\n\n\treturn h;\n}\n\nvec3 getMaterial(float id,vec3 p,vec3 n){\n\tvec3 mate = vec3(0.0);\n    \n    p = p+.001*(1.-abs(sign(p)));\n    \n\tif(id == 0.0){\n\t\tmate += mod(floor(p.x*5.001)+floor(p.y*5.001)+floor(p.z*5.0),2.0);\n\t\tmate = 0.5+0.5*mate;\n\t\tmate = pow(mate,vec3(1.5)) * 0.5;\n\t}else if(id == 1.0){\n\t\tmate += vec3(1,0,0);\n\t}else if(id == 2.0){\n\t\tmate += vec3(0,1,0);\n\t}else if(id == 3.0){\n\t\tmate += vec3(0,0,1);\n\t}else if(id == 4.0){\n\t\tmate += vec3(1,0,0.2)*0.5+0.5*clamp(sin(p.x*100.0)+sin(p.y*100.0)+sin(p.z*100.0),0.0,1.0);\n\t}\n\t\n\treturn mate;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  vec3 ro = vec3(0.0,0.0,3.0);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  //ro.y += 1.5;\n  //rd.zy *= rot(0.5);\n\n  //ro.xz *= rot(iTime*0.5);\n  //rd.xz *= rot(iTime*0.5);\n\n  Hit h = raytrace(ro,rd);\n\n  {\n  \tvec3 pos = ro + h.t*rd;\n  \tvec3 nor = h.nor;\n  \tvec3 ref = reflect(rd,nor);\n  \tvec3 mate = getMaterial(h.id,pos,nor);\n\n    {\n      vec3 lig = normalize(vec3(0.0,0.5,3.0)-pos);\n      float dif = clamp(dot(nor,lig),0.0,1.0);\n      float sha = step(1.0,raytrace(pos,lig).t);\n      dif  *= sha;\n      float spe = clamp(dot(ref,lig),0.0,1.0);\n      spe = 0.5*pow(spe,25.0);\n\n    \tcol += mate * dif;\n    \tcol += spe * dif;\n\n      vec3 bg = mix(vec3(0.2,0.8,1),vec3(0,0,1),rd.y);\n      col = mix(col,bg,clamp(0.001*h.t*h.t,0.0,1.0));\n    }\n\n    {\n    \tfloat dif = clamp(nor.y*0.5+0.5,0.0,1.0);\n\n    \tcol += 0.05 * vec3(0.2,0.8,1) * mate * dif;\n    }\n    \n    col *= vec3(1,0.6,0.6);\n  }\n\n  col = clamp(pow(col,vec3(1.0/2.2)),0.0,1.0);\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [143, 143, 164, 164, 217], [219, 219, 265, 265, 450], [451, 451, 495, 495, 661], [662, 662, 704, 704, 1017], [1019, 1019, 1049, 1049, 2003], [2005, 2005, 2046, 2046, 2529], [2531, 2531, 2581, 2581, 3629]], "test": "untested"}
{"id": "Dls3RS", "name": "SDF Writer - Distance 2D", "author": "MysteryPancake", "description": "Click and drag to draw :) RIP interior distance", "tags": ["2d", "distancefield", "sdf", "line", "circle", "distance", "sketch", "drawer", "drawer", "sketcher", "drawable", "writer"], "likes": 14, "viewed": 320, "published": 3, "date": "1671947180", "time_retrieved": "2024-07-30T16:11:13.578747", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float d = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n\t// Coloring, ripped from Inigo Quilez\n\tvec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(120.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Larger brush sizes are OK, but have wrong interior distances\nconst float brushSize = 0.0;\n\n// From https://iquilezles.org/articles/distfunctions2d/\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Initialize with invalid blank SDF\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    if (iFrame < 1) {\n        fragColor.x = length(p) + 999.9;\n        return;\n    }\n    \n    // Store previous mouse position (thanks Envy24 for improving)\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    fragColor.yzw = vec3(m, iMouse.z > 0.0);\n    \n    // Read previous SDF\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.x = data.x;\n    if (iMouse.z > 0.0) {\n        // Draw line between previous and current mouse position\n        float d = line(p, data.w > 0.0 ? data.yz : m, m);\n        fragColor.x = min(fragColor.x, d - brushSize);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 382]], "test": "untested"}
{"id": "DtsGRS", "name": "Pseudo-Random SDF - Distance 2D", "author": "MysteryPancake", "description": "Layering a few triangle waves produces a cheap random looking SDF :)", "tags": ["2d", "voronoi", "distancefield", "grid", "sdf", "circle", "random", "distance", "dots", "chaos"], "likes": 9, "viewed": 268, "published": 3, "date": "1671943274", "time_retrieved": "2024-07-30T16:11:14.319765", "image_code": "const float iterations = 32.0;\n\nfloat noise(float n) {\n\treturn fract(cos(n * 7589.42) * 343.53);\n}\n\n// Ping-pong triangle waveform\nvec2 triangle(vec2 p, vec2 period) {\n    return abs(mod(p, period) - period * 0.5);\n}\n\n// Overlap a bunch of triangle waveforms\nfloat chaos(vec2 p) {\n\n    float spread = 0.5 + cos(iTime * 2.0) * 0.5;\n    float dist = 9999.9;\n    \n    for (float i = 1.0; i <= iterations; i++) {\n        // Random starting offset for each waveform\n        vec2 offset = vec2(noise(i), noise(i + iterations));\n        // Period could be randomized, kept linear here\n        vec2 period = vec2(spread) + i * 0.02;\n        // Generate triangle waveform\n        vec2 tri = triangle(p + offset * spread, period);\n        // Pick closest point\n        dist = min(dist, length(tri));\n    }\n    return dist - 0.05;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Normalized coordinates, ripped from Inigo Quilez\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\t\n\tfloat d = chaos(p);\n\n\t// Coloring, ripped from Inigo Quilez\n\tvec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(120.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n\tif (iMouse.z > 0.001) {\n\t\td = chaos(m);\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n\t}\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 54, 54, 98], [100, 131, 167, 167, 216], [218, 259, 280, 280, 821], [823, 823, 878, 932, 1587]], "test": "untested"}
{"id": "mlX3zB", "name": "traces without buffer", "author": "jonasfrey", "description": "its not working as expected :O", "tags": ["traces"], "likes": 2, "viewed": 178, "published": 3, "date": "1671931382", "time_retrieved": "2024-07-30T16:11:15.058789", "image_code": "vec4 f_o_col(vec2 o_fc_nor_offset, float n_t){\n    vec2 o_p = vec2(\n        sin(n_t)*0.24,\n        cos(n_t)*0.24\n    );\n    float n_dist = length(o_fc_nor_offset-o_p);\n    n_dist= smoothstep(0.1, 0.2, n_dist);\n    vec4 o_col_for_time_it = vec4(n_dist);\n    return o_col_for_time_it;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_fc_nor = fragCoord.xy / iResolution.y;\n    float n_ratio_x_to_y = iResolution.x / iResolution.y;\n    vec2 o_fc_nor_offset = o_fc_nor-vec2(n_ratio_x_to_y/2., 0.5);\n    vec2 o_p = vec2(0.,0.);\n    float n_time_its = 10.;\n    float n_dist = 0.;\n    vec4 o_col_now = f_o_col(o_fc_nor_offset, iTime);\n    for(float n_time_it = 1.; n_time_it<n_time_its; n_time_it+=1.){\n        float n_time_it_nor = (1./n_time_its)*n_time_it;\n        vec4 o_col_for_time_it = f_o_col(o_fc_nor_offset, iTime-n_time_it_nor*4.); \n        vec4 o_col_mix = mix(o_col_now, o_col_for_time_it, (n_time_it_nor*0.2));\n        o_col_now = o_col_now - (1.-o_col_for_time_it*(1.+1.-n_time_it_nor));\n    }\n    fragColor = vec4(o_col_now);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlX3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 284], [285, 285, 342, 392, 1108]], "test": "untested"}
{"id": "mlf3RB", "name": "Hue Rounding (Color Harmony)", "author": "MysteryPancake", "description": "Using rounding to force images to conform to a given palette", "tags": ["color", "hue", "quantization", "rounding", "harmony", "harmony", "quantize", "truncation"], "likes": 4, "viewed": 175, "published": 3, "date": "1671923400", "time_retrieved": "2024-07-30T16:11:15.816763", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Hue divisions when rounding\n    float divisions = 1.0 + round(mod(iTime * 0.5, 4.0));\n    // Hue rounding (0 = original, 1 = fully rounded)\n    float rounding = cos(iTime * PI) * 0.5 + 0.5;\n    \n    vec4 tex = texture(iChannel0, fragCoord / iResolution.xy);\n    // Convert from RGB to HSV\n    vec3 hsv = rgb2hsv(tex.rgb);\n    // Round hue to nearest color\n    hsv.x = mix(hsv.x, floor(hsv.x * divisions) / divisions, rounding);\n    // Convert back from HSV to RGB\n    fragColor = vec4(hsv2rgb(hsv), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // UVs for texture (left)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 noise = texture(iChannel0, uv);\n    \n    // UVs for hue circle (right)\n    vec2 uv2 = (vec2(1.0 / 0.75, 2.0) * fragCoord - iResolution.xy) / iResolution.y;\n    float hue = atan(uv2.x, uv2.y) / TAU;\n    \n    // Split halfway\n    vec3 col = uv.x > 0.5 ? hsv2rgb(vec3(hue, 1.0, 1.0)) : noise.rgb;\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415926;\nconst float TAU = 6.28318530;\n\n// From https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// From https://www.shadertoy.com/view/lsS3Wc\nvec3 rgb2hsv(vec3 c) {\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d)), d / q.x, q.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlf3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 91, 570]], "test": "untested"}
{"id": "mlX3RB", "name": "Actually OK Bokeh blur", "author": "fishy", "description": "I did an OK version that works pretty well with fewer samples. Not sure whether the spinning motion actually helps or is just distracting", "tags": ["bokeh"], "likes": 4, "viewed": 237, "published": 3, "date": "1671918669", "time_retrieved": "2024-07-30T16:11:16.564763", "image_code": "#define GOLDEN_RATIO_ROT mat2(-0.7373688781, -0.6754902943, 0.6754902943, -0.7373688781)\n\nvec4 bokeh(vec2 uv, sampler2D tex, float rad, float ratio, float samples, float gamma, float r)\n{\n    float mrad = sqrt(samples);\n    vec4 accumulate = vec4(0);\n    vec2 p = vec2(0, 1)*mat2(cos(r), -sin(r), sin(r), cos(r));\n    for(float i = 0.; i < samples; i++)\n    {\n        accumulate += pow(texture(tex, uv + p*vec2(rad*ratio, rad)*sqrt(i)/mrad), vec4(gamma));\n        p *= GOLDEN_RATIO_ROT;\n    }\n    return pow(accumulate / samples, 1./vec4(gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(bokeh(uv, iChannel0, 0.02, iResolution.y/iResolution.x, 16., 3., float(iFrame)*2.39996322972865332).rgb,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlX3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 187, 187, 548], [550, 550, 607, 657, 855]], "test": "untested"}
{"id": "dlf3zS", "name": "glitch that looks like rain", "author": "janpitokiala", "description": "if you don't have anything in the main image function, this happens (or doesn't happen, as FabriceNeyret2 pointed out)", "tags": ["rain", "bug"], "likes": 0, "viewed": 150, "published": 3, "date": "1671913686", "time_retrieved": "2024-07-30T16:11:17.307776", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlf3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 63]], "test": "untested"}
{"id": "DlXGzS", "name": "Still A-life, Pointillism shader", "author": "yunChenLee_329", "description": "Still A-life, Pointillism shader", "tags": ["raymarching", "phong", "sdf", "painting", "pointillism", "stilllife"], "likes": 6, "viewed": 327, "published": 3, "date": "1671890396", "time_retrieved": "2024-07-30T16:11:18.256241", "image_code": "// Author: Yun-Chen Lee yclee@arch.nycu.edu.tw\n// Project: Still A-life, Pointillism shader\n// Date: 2022/12/22\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n\n\n//=== noise ===//\n//-----------------------------------------------------------------\nvec3 normalMap(vec3 p, vec3 n);\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//=== distance functions ===//\n//-----------------------------------------------------------------\n// Rotate function\nmat2 Rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}  \n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n    n = normalize(n);\n    return dot(p,n) + h;\n}\n\nfloat sdSphere( vec3 p, float s, vec3 rotation, vec3 scale )\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    return length(bp)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    vec3 d = abs(bp) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    float q = length(bp.xz);\n    return max(dot(c.xy,vec2(q,bp.y)),-h-bp.y);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    vec2 d = abs(vec2(length(bp.xz),bp.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h , vec3 rotation, vec3 scale)\n{\n    vec3 bp = p;\t\t\t//\ttranslate\n    bp.yz *= Rot(rotation.x);\t//\trotate\n    bp.xz *= Rot(rotation.y);\t//\trotate\n    bp.xy *= Rot(rotation.z);\t//\trotate\n    bp *= scale;\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    bp = abs(bp);\n    bp.xy -= 2.0*min(dot(k.xy, bp.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(bp.xy-vec2(clamp(bp.x,-k.z*h.x,k.z*h.x), h.x))*sign(bp.y-h.x),\n       bp.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(in vec3 p)\n{\n    float dist;\n\n    float sd_plane = sdPlane(p,vec3(0.0,1.0,1.0),0.38);\n    float sd_box = sdBox(p+vec3(0.0,0.2,0.0), vec3(0.4, 0.4, 0.4),vec3(0.628,0.0,0.2), vec3(2.0));\n    dist = min(sd_plane,sd_box);\n    \n    float sd_sphere = sdSphere(p+vec3(-0.03,-0.04,-0.35), 0.2, vec3(0.0), vec3(1.0));\n    dist = min(dist, sd_sphere);\n\n    float sd_cone = sdCone(p+vec3(0.48,0.1,-0.45), vec2(0.8,0.25),0.8,vec3(-0.628,0.0,0.0), vec3(1.0));\n    dist = min(dist, sd_cone);\n\n    float sd_cappedCylinder = sdCappedCylinder(p+vec3(0.48,0.26,-0.3),0.3,0.1,vec3(0.628,0.0,-0.9), vec3(1.0));\n    dist = min(dist,sd_cappedCylinder);\n\n    float sd_hex = sdHexPrism(p+vec3(-0.45,0.45,-0.15),vec2(0.12,0.5), vec3(-0.9,-0.6,0.0), vec3(1.0));\n    dist = min(dist,sd_hex);\n\n\n    return dist;\n}\n\n//=== gradient functions ===//\n//-----------------------------------------------------------------\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===//\n//-----------------------------------------------------------------\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\n    float d=0.0, t=0.0;\n    for (int i=0; i<30; ++i)\n    {\n        p= o+r*t;\n        d=map(p);\n        if(d<0.0) break;\n        t += d*0.6; //影響輪廓精準程度\n        }\n    return t;\n}\n\nfloat traceInner(vec3 o,vec3 r,out vec3 p)\n{\n    float d=0.,t=0.01;\n    for(int i=0;i<32;++i)\n    {\n        p=o+r*t;\n        d=-map(p);\n        if(d<0.001 || t>10.0) break;\n        t+=d*.5;//影響輪廓精準程度\n    }\n    return t;\n}\n\n\n\n//=== camera functions ===//\n//-----------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n\n//=== phong shading ===//\n//-----------------------------------------------------------------\n// thank 仁愷!\nstruct Light{\n    vec3 p; // position\n    vec3 ia;\n    vec3 id; // diffuse color\n    vec3 is; // specular color\n};\n\nstruct Mat{    \n    float ka; // factor of abient\n    float kd; // factor of diffuse\n    float ks; // factor of specular\n    float s; // shiness\n};\n\nvec3 phongShading(Light light, Mat m, vec3 p, vec3 n, vec3 v, out vec3 ambient, out vec3 diffuse, out vec3 specular, out float shadow){\n\n    vec3 L = normalize(light.p-p);\n    vec3 r = normalize(reflect(-L,n));\n\n    ambient = m.ka*light.ia;\n    diffuse = m.kd*dot(L,n)*light.id;\n    specular = m.ks*pow(max(dot(r,v),0.0),m.s)*light.is;\n\n    vec3 diffWithShadow = diffuse;\n    vec3 temp;\n    float d = trace(p+n*0.03, L, temp);\n    if(d<length(light.p-p)) {\n        shadow = 0.0;\n        diffWithShadow *= 0.1;\n    }\n    else shadow = 1.0;\n\n    vec3 result;\n    // result = ambient + diffuse + specular;\n    result = ambient + diffWithShadow + specular;\n\n    return result;\n    \n}\n\n//=== dot brush ===//\n//-----------------------------------------------------------------\nfloat getMask(float r, float scl, float div, vec2 uv, vec2 offset){\n    // float mask = step(r*scl, length(mod((uv + offset)*div,1.)*2.-1.));\n    float mask = step(r*scl,length(random2(floor((uv+offset)*div))-fract(uv*div)));\n    if(mask>0.1) mask = 1.;\n    else mask = 0.;\n    return mask;\n}\n\nvec3 setColor(float mask, vec3 clr){\n    vec3 result = vec3(1.);\n    if(mask==0.) result = clr;\n    return result;\n}\n\nvec3 mixColor(vec3 clr1, vec3 clr2, float ratio){\n    vec3 result = vec3(1.0);\n\n    if(clr1.r<1.|| clr1.g<1.|| clr1.b<1.){\n        if(clr2 == vec3(1.)) result = clr1;\n        else result = mix(clr1,clr2,ratio);\n    }\n    else if(clr2.r<1.|| clr2.g<1.|| clr2.b<1.){\n        if(clr1 == vec3(1.)) result = clr2;\n        // else result = mix(clr1,clr2, ratio);\n        // else result = vec3(0.);\n        // if(clr1!=vec3(1.)) result = vec3(0.);\n    }\n    return result;\n}\n\n//=================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    uv.y*=1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\n    vec2 mouse=(iMouse.xy/iResolution.xy)*2.0-1.0;\n\n    // camera option1  (模型應在原點，適用於物件)\n\t// vec3 CameraRot=vec3(0.0, mouse.y, -mouse.x); \n   \n    vec3 CameraRot=vec3(0.0, -0.7, 0.0);  \n\tvec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\n    // vec3 CameraRot=vec3(u_time ,0.0, 0.0);  \n    // vec3 CameraRot=vec3(0.0,-mouse.y*3.0, mouse.x*3.0);\n\t// vec3 ro= vec3(0.0, 0.0, 2.0)*fromEuler(CameraRot);//CameraPos;\n\n\tvec3 ta =vec3(0.0, 0.0, 0.0); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\t\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    \n    vec3 bump = normalMap(p*10.0,n);\n    // // n=n+bump*0.05;\n    \n    \n    float edge = dot(-RayDir,n);\n    edge = smoothstep(-0.3,0.3,edge);\n    \n\n    // if(t<2.5) result = result; else result = vec3(0.9);//測試n, n_bump, fresnel, BG, color, fog, F, I, SS, reflectedCol\n\n    // mask\n    // float r = 1.0-(result.r+result.g+result.b)/3.0;\n    // float div = 40.0;\n    // float circleMask = step(r*1.2,length(mod((uv+bump.xy*0.005)*div,1.0)*2.0-1.70));\n    // float circleMask = step(r*1.2,length(mod((uv)*div,1.0)*2.0-1.0));\n\n    // float circleMask2 = step(r*1.2,length(mod((uv+vec2(0.0,0.01)+bump.xy*0.005)*div,1.0)*2.0-1.0));\n\n    // vec3 col1 = vec3(1.0-circleMask)*vec3(0.0,0.0,1.0);\n    // vec3 col2 = vec3(1.0-circleMask2)*vec3(1.0,0.0,0.0);\n\n    // vec3 col = mix(col1,col2,0.4);\n\n    // phong shading\n    Light l1 = Light(vec3(20.*sin(iTime/3.),10.+5.*sin(iTime/5.),20.+10.*cos(iTime/3.)),vec3(.7),vec3(1.0),vec3(1.));\n    Mat m1 = Mat(1.,1.,1.,1.);\n    vec3 amb1, diff1, spec1, result1;\n    float shdw1;\n    result1 = phongShading(l1, m1, p, n, -RayDir, amb1, diff1, spec1, shdw1);\n\n    Light l2 = Light(vec3(0.+5.*sin(iTime/3.),10.+8.*sin(iTime/4.),0.), vec3(.7),vec3(1.),vec3(1.));\n    Mat m2 = Mat(1.,1.,1.,10.);\n    vec3 amb2, diff2, spec2, result2;\n    float shdw2;\n    result2 = phongShading(l2, m2, p, n, -RayDir, amb2, diff2, spec2, shdw2);\n\n    // SSS\n    vec3 p1, n1;\n    float ior = 1.31;\n    vec3 RayDir1 = refract(p-l1.p,n,1.0/ior);  // material A -> B\n    // vec3 RayDir1 = refract(RayDir,n,1.0/ior);  // material A -> B\n    float t1 = traceInner(p,RayDir1, p1);\n\n    // color -----------------------------------------\n    // float siz = 1.3+sin(u_time)*0.5;\n    float siz = 1.;\n    // float mask1 = getMask(1.0-(result1.r+result1.g+result1.b)/3.0, 1.2, 40., uv, vec2(0.,0.01));\n    // vec3 layer1 = setColor(mask1, vec3(1.0,0.0,0.0));\n\n    // background\n    // float mbx = getMask(0.8+bump.x*0.5, 1.0,59.0,uv,0.002*vec2(bump.y,bump.z));\n    float mbx = getMask(0.3+bump.x*0.05, 1.0,58.0*siz,uv,0.002*vec2(bump.y,bump.z));\n    vec3 dbx = setColor(mbx, vec3(0.67, 0.82, 1.));\n\n    float mby = getMask(0.3+bump.y*0.05, 1.0,40.0*siz,uv,0.002*vec2(0.01+bump.x, bump.z));\n    vec3 dby = setColor(mby,vec3(1., 0.89, 0.85));\n\n    vec3 result = mixColor(dbx,dby,0.5);\n    // vec3 result = mix(dbx,dby,0.5);\n\n    float mbz = getMask(0.7+bump.z*0.5, 1.0,47.0*siz,uv,0.002*vec2(bump.x, bump.z));\n    vec3 dbz = setColor(mbz,vec3(0.71, 0.96, 0.95));\n\n    result = mixColor(result,dbz,0.5);\n    \n    // // toon\n    vec3 rt;\n    if(t<2.5)  rt = 1.0-vec3(floor(result1*2.0)/2.0);else rt = vec3(1.0);\n    // vec3 rt = 1.0-vec3(floor(result1*2.0)/2.0);\n    vec3 toon1 = vec3(1.), toon2 = vec3(1.), toon3 = vec3(1.);\n    if(rt.x < .01) toon1 = vec3(0.0);\n    if(rt.x > .2 && rt.x < .9) toon2 = vec3(0.0);\n    // if(result_toon.x > .9) toon3 = vec3(.0);\n\n    float mt1 = getMask((1.0-(toon1.x+toon1.y+toon1.z)/3.0)*0.4+bump.y*0.0, 1.0,60.0*siz,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    // float mt1 = getMask((1.0-(toon1.x+toon1.y+toon1.z)/3.0)*0.4+bump.y*0.0, 1.0,60.0,uv,vec2(0.));\n    vec3 dt1 = setColor(mt1, vec3(0., 0.5, 0.88));\n    float mt2 = getMask((1.0-(toon2.x+toon2.y+toon2.z)/3.0)*0.4+bump.y*0.0, 1.0,55.0*siz,uv,0.002*vec2(0.03+bump.y, 0.05+bump.x));\n    // float mt2 = getMask((1.0-(toon2.x+toon2.y+toon2.z)/3.0)*0.4+bump.y*0.0, 1.0,55.0,uv,vec2(0.));\n    vec3 dt2 = setColor(mt2, vec3(0., 0.73, 1.));\n    // float mt3 = getMask((1.0-(toon3.x+toon3.y+toon3.z)/3.0)*0.4+bump.y*0.0, 1.0,45.0,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    // vec3 dt3 = setColor(mt3, vec3(0.0235, 1.0, 0.9529));\n\n    vec3 temp = mixColor(dt1,dt2,0.5);\n    // temp = mixColor(temp,dt3,0.5);\n    result = mixColor(result,temp,0.5);\n\n    // diffuse\n    if(t<2.5)  diff1 = diff1;else diff1 = vec3(1.0);\n    // float md1 = getMask((1.0-(diff1.x+diff1.y+diff1.z)/3.0)*0.4+bump.y*0.0, 1.0,69.0,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    float md1 = getMask((1.0-(diff1.x+diff1.y+diff1.z)/3.0)*0.4+bump.y*0.0, 1.0,69.0*siz,uv,vec2(0.));\n    // vec3 dd1 = setColor(md1, vec3(0.078, 0.34, 0.22));\n    vec3 dd1 = setColor(md1, vec3(0.2196, 0.1725, 0.6471));\n    result = mixColor(result,dd1,0.5);\n\n\n    // light2 diff\n    if(t<2.5)  diff2 = diff2;else diff2 = vec3(1.0);\n    // float md2 = getMask((1.0-(diff2.x+diff2.y+diff2.z)/3.0)*0.4+bump.y*0.0, 1.0,40.0,uv,0.002*vec2(0.03+bump.x, 0.05+bump.z));\n    float md2 = getMask((1.0-(diff2.x+diff2.y+diff2.z)/3.0)*0.4+bump.y*0.0, 1.0,40.0*siz,uv,vec2(0.));\n    vec3 dd2 = setColor(md2, vec3(0.89, 0.49, 0.27));\n    result = mixColor(result,dd2,0.2);\n\n    \n\n    // shadow\n    float msd = getMask((1.-shdw1)*0.4, 1.0,73.0*siz,uv,vec2(0.));\n    vec3 dsd = setColor(msd, vec3(0.15, 0.22, 0.3));\n    result = mixColor(result,dsd,0.6);\n\n    // sss\n    if (t>2.5) t1=1.;\n    t1 = step(t1,0.5);\n    float msss = getMask(((t1)*0.3), 1.0,60.0*siz,uv,vec2(0.));\n    vec3 dsss = setColor(msss, vec3(1.0, 0.85, 0.17));\n    result = mixColor(result,dsss,0.5);\n\n    // sepcular\n    float msp = getMask((length(spec1))*0.3, 1.0,75.0*siz,uv,vec2(0.));\n    result += (1.-msp);\n\n    float msp2 = getMask((length(spec2))*0.5, 1.0,75.0*siz,uv,vec2(0.));\n    result += (1.-msp2);\n\n    fragColor = vec4(vec3(result),1.0);\n}\n\n//=================================================================\n\n\n\n\n\n//=== 2d noise functions ===//\n//-----------------------------------------------------------------\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//=== 3d noise functions p/n ===//\n//-----------------------------------------------------------------\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 357, 381, 381, 474], [476, 594, 613, 613, 686], [690, 690, 732, 732, 781], [783, 783, 845, 845, 1041], [1043, 1043, 1101, 1101, 1362], [1364, 1364, 1432, 1432, 1680], [1682, 1682, 1761, 1761, 2043], [2045, 2045, 2108, 2108, 2568], [2570, 2570, 2592, 2592, 3365], [3367, 3466, 3512, 3512, 3730], [3733, 3832, 3873, 3873, 4066], [4068, 4068, 4112, 4112, 4305], [4309, 4406, 4458, 4458, 4635], [4637, 4645, 4671, 4671, 5041], [5421, 5421, 5556, 5556, 6100], [6102, 6192, 6259, 6333, 6484], [6486, 6486, 6522, 6522, 6602], [6604, 6604, 6653, 6653, 7071], [7073, 7141, 7198, 7198, 13439], [13514, 13613, 13659, 13659, 13797], [13798, 13798, 13848, 13848, 14269], [14271, 14374, 14405, 14405, 14493], [14495, 14495, 14536, 14536, 14732], [14778, 14778, 14816, 14816, 15215], [15217, 15217, 15249, 15249, 15565]], "test": "untested"}
{"id": "mllGD7", "name": "Golden Piggy", "author": "OzoneOnYou", "description": "Just messing around on christmas day! (Published late lol)", "tags": ["raymarching", "rotation", "pig"], "likes": 0, "viewed": 109, "published": 3, "date": "1671882528", "time_retrieved": "2024-07-30T16:11:19.056102", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define PRECISION 0.01\n\nstruct object{\n    float sD;\n    vec3 col;\n};\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere(vec3 p, vec3 q, float r){\n    return length(p-q) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nobject sminObj(object a, object b, float k){\n    if(a.sD<b.sD) return object(smin(a.sD, b.sD, k), a.col);\n    return object(smin(a.sD, b.sD, k), b.col);\n}\n\nobject minObj(object a, object b){\n    if(a.sD < b.sD) return a;\n    return b;\n}\n\nobject sdScene(vec3 p){\n    p = p*rotateY(iTime*0.2)*rotateZ(clamp(cos(iTime*4.)/6., 0., 1.));\n    p -= vec3(0, clamp(sin(iTime*4.), 0., 1.), 0);\n    object belly = object(sdCapsule(p, vec3(-.3, 0, 0),       vec3(.5, 0, 0),        .5),  vec3(0.96, 0.9, 0.55));\n    \n    object leg1  = object(sdCapsule(p, vec3(-.4, -.45, .25),  vec3(-.45, -.5, .3),   0.2), vec3(0.96, 0.9, 0.55));\n    object leg2  = object(sdCapsule(p, vec3(.6, -.45, .25),   vec3(.65, -.5, .3),    .2),  vec3(0.96, 0.9, 0.55));\n    object leg3  = object(sdCapsule(p, vec3(-.4, -.45, -.25), vec3(-.45, -.5, -.3),  0.2), vec3(0.96, 0.9, 0.55));\n    object leg4  = object(sdCapsule(p, vec3(.6, -.45, -.25),  vec3(.65, -.5, -.3),   .2),  vec3(0.96, 0.9, 0.55));\n    \n    object nose  = object(sdRoundBox(p-vec3(0.9, 0, 0),vec3(0.1), 0.1), vec3(0.96, 0.9, 0.55));\n    object tail  = object(sdSphere(p, vec3(-0.7, 0.3, 0), 0.1), vec3(0.96, 0.9, 0.55));\n    \n    object ear1  = object(sdRoundCone(p, vec3(0.65, 0.3, 0.15), vec3(0.65, 0.5, 0.3), 0.15, 0.05), vec3(0.96, 0.9, 0.55));\n    object ear2  = object(sdRoundCone(p, vec3(0.65, 0.3, -.15), vec3(0.65, 0.5, -.3), 0.15, 0.05), vec3(0.96, 0.9, 0.55));\n    \n    object stand = object(sdHexPrism(p*rotateZ(-clamp(cos(4.)/6., 0., 1.))*rotateX(radians(90.)) - vec3(0, 0, -0.9-clamp(sin(iTime*4.), 0., 1.)), vec2(2, 0.2)), vec3(1));\n    return minObj(sminObj(sminObj(sminObj(sminObj(sminObj(sminObj(sminObj(sminObj(belly, ear2, 0.05), ear1, 0.05), tail, 0.1), nose, 0.1), leg4, 0.2), leg3, 0.2), leg2, 0.2), leg1, 0.2), stand);\n}\n\nobject raymarch(vec3 rO, vec3 rD){\n    object cO;\n    float sD;\n    for(int i=0;i<MAX_STEPS;i++){\n        cO = sdScene(rO + rD*sD);\n        sD+= cO.sD;\n        if(sD>MAX_DISTANCE||cO.sD<PRECISION) break;\n    }\n    cO.sD = sD;\n    return cO;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 error = vec2(.01, 0);\n    return normalize(sdScene(p).sD - vec3(sdScene(p-error.xyy).sD,\n                                          sdScene(p-error.yxy).sD,\n                                          sdScene(p-error.yyx).sD));\n}\n\nfloat shadow(vec3 rO, vec3 rD, vec3 col){\n    if(col ==vec3(0.96, 0.9, 0.55))return 1.;\n    object cO;\n    float sD;\n    for(int i=0;i<MAX_STEPS;i++){\n        cO = sdScene(rO + rD*sD);\n        sD+= cO.sD;\n        if(cO.sD<PRECISION) return 0.3;\n    }\n    return 1.;\n}\n\nvec3 compute(object o, vec3 rO, vec3 rD, vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 light = vec3(0, 10, 0);\n    vec3 normal = getNormal(rO+rD*o.sD);\n    float objectShadow = clamp(dot(normal, normalize(light)), 0.3, 1.);\n    float globalShadow = shadow(rO+rD*o.sD +normal*PRECISION*10., normalize(light), o.col);\n    float highlight = dot(normalize(light), normalize(reflect(rD, normal)));\n    highlight = pow(clamp(highlight, 0., 1.), 20.);\n    \n    float fogAmount = 1.0 - exp( -o.sD*0.05 );\n    vec3 fogColor = vec3(0.5, 0.5, 0.5);\n    vec3 col = mix( o.col*globalShadow*objectShadow+texture(iChannel0, normalize(normal+rO+rD*o.sD)).rgb*0.05 + highlight, fogColor, fogAmount );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    vec3 rO = vec3(0, 1, -5);\n    vec3 rD = vec3(uv.x, uv.y, 1);\n\n    object raymarch = raymarch(rO, rD);\n    vec3 col = compute(raymarch, rO, rD, fragCoord);\n\n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllGD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 146, 146, 293], [295, 295, 322, 322, 469], [471, 471, 498, 498, 645], [647, 647, 688, 688, 772], [774, 774, 826, 826, 947], [949, 949, 989, 989, 1019], [1021, 1021, 1066, 1066, 1156], [1158, 1158, 1182, 1182, 1201], [1202, 1202, 1265, 1265, 1750], [1752, 1752, 1788, 1788, 2061], [2063, 2063, 2107, 2107, 2217], [2219, 2219, 2253, 2253, 2299], [2301, 2301, 2324, 2324, 3839], [3841, 3841, 3875, 3875, 4083], [4085, 4085, 4108, 4108, 4344], [4346, 4346, 4387, 4387, 4613], [4615, 4615, 4672, 4672, 5336], [5338, 5338, 5394, 5394, 5646]], "test": "untested"}
{"id": "mtlGWM", "name": "Three Lights", "author": "SONENEIS", "description": "nothing here.", "tags": ["raytracing", "raytracer", "ray", "pointlight", "light", "sphere", "sky", "ball", "orb", "plane", "flare", "lights", "floor", "ground", "raycaster", "tracasting"], "likes": 3, "viewed": 176, "published": 3, "date": "1671865809", "time_retrieved": "2024-07-30T16:11:19.848982", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nstruct Inter{\n\tfloat t;\n\tvec3 nor;\n\tfloat id;\n};\n\nfloat iSphere(vec3 ro,vec3 rd,out vec3 nor,vec4 s){\n\tvec3 oc = ro - s.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - s.w*s.w;\n\tfloat h = b*b - c;\n\tfloat t = -b - sqrt(h);\n\tif(h < 0.0) t = -1.0;\n\tnor = normalize(((ro+rd*t)-s.xyz)/s.w);\n\treturn t;\n}\n\nfloat iPlane(vec3 ro,vec3 rd,out vec3 nor,vec4 p){\n\tp.xyz = normalize(p.xyz);\n\tnor = p.xyz;\n\treturn -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nInter raytrace(vec3 ro,vec3 rd){\n\tInter res = Inter(9999999999.9,vec3(0.0),-1.0);\n\tfloat temp = res.t;\n  vec3 tnor = res.nor;\n\n  temp = iPlane(ro,rd,tnor,vec4(0,1,0,0.5));\n  if(temp > 0.0 && temp < res.t){\n  \tres.nor = tnor;\n  \tres.id = 0.0;\n  \tres.t = temp;\n  }\n\n  temp = iSphere(ro,rd,tnor,vec4(0.5,0.0,-0.4,0.5));\n  if(temp > 0.0 && temp < res.t){\n    res.nor = tnor;\n    res.id = 3.0;\n  \tres.t = temp;\n  }\n\n  temp = iSphere(ro,rd,tnor,vec4(-0.6,sin(iTime*4.0)*0.2,-0.5,0.3));\n  if(temp > 0.0 && temp < res.t){\n    res.nor = tnor;\n    res.id = 1.0;\n  \tres.t = temp;\n  }\n\n  temp = iSphere(ro,rd,tnor,vec4(0.2,sin(iTime*6.0)*0.1,0.3,0.3));\n  if(temp > 0.0 && temp < res.t){\n    res.nor = tnor;\n    res.id = 2.0;\n  \tres.t = temp;\n  }\n\n  temp = iSphere(ro,rd,tnor,vec4(-0.2,-0.2,0.5,0.3));\n  if(temp > 0.0 && temp < res.t){\n    res.nor = tnor;\n    res.id = 4.0;\n  \tres.t = temp;\n  }\n\n\treturn res;\n}\n\nfloat pointLight(vec3 ro,vec3 rd,float t,vec3 lpos,float r){\n\tfloat lig = 1.0;\n\n\tfloat dt = dot(lpos-ro,rd);\n\tdt = clamp(dt,0.0,t);\n\tvec3 p = ro+rd*dt;\n\tlig = length(p-lpos);\n\n\treturn r/5.0 / (lig*lig);\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  vec3 ro = vec3(0.0,0.0,2.5);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  ro.xz *= rot(iTime*0.5);\n  rd.xz *= rot(iTime*0.5);\n\n  Inter hit = raytrace(ro,rd);\n\n  int ligsLen = 3;\n  vec3 lights[3] = vec3[](\n  \t2.0*vec3(-0.5,0.1,0.7),\n    2.0*vec3(0.2,0.2,0.3),\n    2.0*vec3(-0.5,1.0,-0.5)\n  );\n  \n  if(hit.t > 0.0 && hit.id != -1.0){\n  \tvec3 pos = ro + rd*hit.t;\n  \tvec3 nor = hit.nor;\n    vec3 ref = reflect(rd,nor);\n\n    vec3 mate = vec3(0.0);\n    float albedo = 0.5;\n    float shininess = 15.0;\n\n    if(hit.id == 0.0){\n    \tmate += 0.5+0.5*mod(floor(pos.x*5.0)+floor(pos.z*5.0),2.0);\n    }else if(hit.id == 1.0){\n    \tmate += vec3(1.0,0.3,0.15)+0.5;\n    \tshininess = 20.0;\n      albedo = 1.2;\n    }else if(hit.id == 2.0){\n   \t mate += vec3(0.2,0.0,0.3)+0.5;\n    \talbedo = 0.5;\n    }else if(hit.id == 3.0){\n      mate += vec3(0.7,1.5,0.5);\n      shininess = 1000.0;\n      albedo = 10.0;\n    }else if(hit.id == 4.0){\n      mate += vec3(0.0,0.0,0.5);\n      shininess = 100.0;\n      albedo = 2.0;\n    }\n\n    for(int i=0;i<ligsLen;i++){\n  \t\tvec3 lig = normalize(lights[i]-pos);\n  \t\tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n  \t  float sha = step(length(pos-lig),raytrace(pos,lig).t);\n    \tdif *= sha;\n    \tfloat spe = clamp(dot(ref,lig),0.0,1.0);\n  \t\tspe = albedo * pow(spe,shininess);\n\n    \tcol += mate * dif;\n  \t  col += spe * dif;\n    }\n    col /= float(ligsLen);\n  }\n  \n  col = mix(col,mix(vec3(0.2,0.1,1),vec3(0.5,0.8,1),clamp(1.0-rd.y,0.0,1.0)),clamp(hit.t*hit.t*0.01,0.0,1.0));\n  \n  for(int i=0;i<ligsLen;i++){\n  \tcol = mix(col,vec3(1),pointLight(ro,rd,hit.t,lights[i],0.005));\n  }\n  \n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [113, 113, 164, 164, 365], [367, 367, 417, 417, 504], [506, 506, 538, 538, 1403], [1405, 1405, 1465, 1465, 1609]], "test": "untested"}
{"id": "mtfGD4", "name": "Volumetric Glorb ", "author": "Aurcereal", "description": "Maybe WIP", "tags": ["raytracing"], "likes": 3, "viewed": 136, "published": 3, "date": "1671865208", "time_retrieved": "2024-07-30T16:11:20.898176", "image_code": "#define XPY 1.7777 // x per y = resx/resy\n\n//TODO\n//create ray intersection not march system for spheres and planes, their surface area coordinates\n//  in their respective area systems (theta, phi) for spherical and (x, y) for cartesian\n//try to create a marched glow, if we can march a step size and get a glow from a source\n//  like in the center of the sphere, that could be some cool volumetric lighting\n\n//current plan:\n//  ray sphere intersection using X = O + normalize(u)d and ||X - C||^2 = R^2\n//  check the closest if cut, check the farther if cut, draw skybox\n//  next - This is the most expensive part I think - we'll send out a stepped ray that'll sample glow\n//  each step, we check if we're exposed to light inside the sphere, if we are we'll add some glow\n//  possible extra bit of glow if we hit the sphere not just dodge it\n//  can maybe put glorb inside sphere for light\n\nvec3 shapeColor;\n\nvec3 accumulateGlow(vec3 ro, vec3 rd, vec4 sphere, float maxDist, float size, float c, float thickness, float insulation)\n{\n    float exposed, d = 0.;\n    vec3 sp, cp, glow = vec3(0.);\n    int steps = min(MAXSTEPS, int(maxDist/size));\n    \n    for(int i=0; i<steps; i++)\n    {\n        d += size;\n        \n        cp = ro + rd*d - sphere.xyz;\n        sp = cartesianToSpherical(cp);\n        exposed = 1.-insulation*smoothstep(c-thickness*.5,c+thickness*.5, sphereFunc(sp.x, sp.y));\n        glow += getGlow(sp.z, 1.0, 1.5) * size * (normalize(cp)*.5+.5) * .7*exposed;\n    }\n    \n    return glow;\n}\n\nfloat hash(vec2 i)\n{\n    i = fract(vec2(293.591, 512.052)*i);\n    i += dot(i, i+47.);//i*i*49.-(i+2.)*53.;\n    return fract((i.x+i.y)*(i.y+i.x*i.x)*exp(-i.x*0.0001));\n}\n\nvec2 dust(vec2 p)\n{\n    //draw circles\n    float centerLen = length(p - vec2(XPY*.5, .5));\n    p = (rot(p, centerLen*.1) - vec2(XPY*.5, .5))*.9 + vec2(XPY*.5, .5);\n    p += t * vec2(0.1, 0.07)*0.15;\n\n    float size = 0.05;\n    \n    vec2 lp = mod(p, size);\n    float id1 = hash(p - lp);\n    float id2 = hash(p - mod(p, size*2.));\n    \n    float d = length(lp + hash(vec2(id1, id2)) * size * 1.7 - vec2(size*.5)) - size*.03 * (1. - id1);\n    \n    //pulse\n    float opacity = clamp(sin(0.05*t+(id1*.2+id2*.8)*14.), 0., 1.);\n    opacity *= smoothstep(0.37, 0.45, centerLen);\n    //opacity *= step(0.1, id1);\n    \n    return vec2(step(d, 0.)*opacity, id1);\n}\n\nvec3 render(vec2 fragCoord)\n{\n    //set time\n    t = iTime;\n    \n    //shape specs\n    vec4 sphere = vec4(0.,0.,0.,2.);\n    float c = 2.1*sin(iTime)+3.3;\n    shapeColor = vec3(.2, .1, .5)+(sin(iTime*.4)*0.5+0.5)*(vec3(.1, .3, .8) - vec3(.2, .1, .5));\n     //maybe make dust volumetric lighting by \n     //checking whether to draw a dust and how bright by taking into account the glow accumulated (just mult dust rand by glow accum), dist travelled, and a rand that has ray pos\n     //look up a glitter tutorial since one of the shadertoy ppl on your playlist did a glitter tutorial\n    \n    //cam specs\n    vec3 camPos = vec3(5.*cos(iTime*1.1), 0.0, 5.*sin(iTime*1.1));                                //HARDCODE cam pos    \n    vec3 fo = normalize(vec3(0.) - camPos), up = vec3(0.0, 1.0, 0.0), ri = cross(fo, up); //assume perp HARDCODE cam space\n    float fovMultX = 1.0, fovMultY = .57735;                                              //HARDCODE fov TRIG\n                              \n    //make rayWS\n    vec3 ray = normalize(vec3(((fragCoord/iResolution.xy)*2.0-1.0) * vec2(fovMultX, fovMultY), 1.0));\n    ray = ray.z * fo + ray.y * up + ray.x * ri;\n    \n    //trace\n    float dist = raySphCutFor(camPos, ray, sphere, c);\n    float glorbDist = raySphFor(camPos, ray, vec4(sphere.xyz, sphere.w * 0.2));\n    \n    //glow\n    vec3 glow = accumulateGlow(camPos, ray, sphere, min(MAXDIST, dist), 0.1, c, 2., .8);\n    \n    //dust\n    float dustAppear = mix(0.04, 0.8, smoothstep(.7, 1.0, glow.x + glow.y + glow.z));//pow((glow.x+glow.y+glow.z)*.5, 4.0);\n    vec2 dustData = dust(fragCoord/iResolution.y);\n    vec3 dust = dustData.x * step(.1, dustData.y+dustAppear*0.7) * dustAppear * vec3(.6); //.3\n    \n    //skybox\n    if(min(dist, glorbDist) >= MAXDIST) { return acos(-ray.y) * .15*shapeColor+glow + dust; }\n    \n    //hit\n    vec3 hitPntLocal = (camPos+ray*dist)-vec3(0.);\n    vec3 unGlowCol = mix(shapeColor, hitPntLocal*.5+.5, sin(iTime)*.3+.4);\n    return dust + mix(unGlowCol+glow, vec3(1.), 1.-max(step(dist, glorbDist),step(MAXDIST, glorbDist)));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 d = vec2(.5, 0.);\n    vec3 col = render(fragCoord);//render(fragCoord + d.xy) + render(fragCoord + d.yx) + render(fragCoord + d.xx) + render(fragCoord + d.yy);\n    //col *= .25;\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(dust(fragCoord/iResolution.y).x);\n}", "image_inputs": [], "common_code": "#define D2R .0174533\n#define R2D 57.29578\n#define PI 3.14159265\n\n#define MAXSTEPS 100\n#define MAXDIST 100.0\n#define SDEPS 0.05\n#define NORMEPS 0.05\n\n//-=-=- HELP -=-=-\nvec2 rot(vec2 p, float o)\n{\n    vec2 right = normalize(p);\n    vec2 perp = cross(vec3(right, 0.), vec3(0., 0., 1.)).xy;\n    \n    return length(p) * sin(o) * perp + length(p) * cos(o) * right;\n}\n\nfloat t;\n\nvec2 raySph(vec3 ro, vec3 rd, vec4 sphere) //assume all normalized\n{\n    //|| dU + O - C ||^2 = R^2\n    //d^2 + d(2U dot (O-C)) + (O-C)^2 - R^2 = 0\n    \n    float a = 1.0;\n    float b = 2. * dot(rd, ro - sphere.xyz);\n    float c = dot((ro - sphere.xyz),(ro-sphere.xyz)) - sphere.w*sphere.w;\n    \n    //-b/2a +- sqrt(b^2-4ac)/2a\n    \n    float radicand = b*b - 4.*a*c;\n    if(radicand < 0.) return vec2(MAXDIST); //handle unreal\n    \n    return vec2((-b - sqrt(radicand))/(2.*a), (-b + sqrt(radicand))/(2.*a));\n}\n\n//-=-=-=- SPHERE FUNCS -=-=-=-\nfloat f1(float theta, float phi)\n{\n    float time = t;\n    return 4.+sin(phi*5.0+time*(theta+1.)*2.0);\n}\n\nfloat f2(float theta, float phi)\n{\n    float time = t;\n    return 4.+sin(phi*5.0+time*(theta+1.)*2.0) + cos(phi*(3.0+sin(time)*2.0));\n}\n\nfloat f3(float theta, float phi)\n{\n    float time = t*5.0;\n    theta *= 2.0;//+sin(time*.8);\n    phi *= 2.0;\n    return 4.+sin(time*.4)+sin(theta*4.0+time)+1.2*sin(phi*3.0+5.+time*1.5);\n}\n\nfloat f4(float theta, float phi)\n{\n    float time = t*5.0;\n    theta *= 2.0;\n    phi *= 2.0;\n    return 4.+sin(time*.4+sin(theta*10.)*.1+cos(phi*20.)*.1)+sin(theta*4.0+time)+1.2*sin(phi*3.0+5.+time*1.5);\n}\n\nfloat f5(float theta, float phi)\n{\n    float time = t*2.;\n    theta *= 2.0;\n    phi *= 2.0;\n    phi += pow(abs(theta), 0.7) -0.5;\n    return 4.+sin(time*.4+sin(theta*10.)*.1+cos(phi*10.)*.1)+sin(theta*(4.0+sin(phi*12.)*.0)+time)+1.2*sin(phi*(3.0+sin(theta*9.)*.14)+5.+time*1.5);\n}\n\n//-=-=-=-\n\nfloat sphereFunc(float theta, float phi)\n{\n    //f3, f5\n    float i = clamp(sin(.4*t)*1.2+.5, 0., 1.);\n    return f3(theta, phi) * i + (1.-i) * f5(theta, phi);\n}\n\nvec3 cartesianToSpherical(vec3 p)\n{\n    return vec3(atan(p.z, p.x), acos(p.y/length(p)), length(p)); //can rewrite to use arbitrary space\n}\n\nfloat raySphFor(vec3 ro, vec3 rd, vec4 sphere)\n{\n    //get raw dist\n    vec2 rawDists = raySph(ro, rd, sphere);\n    \n    //clamp\n    rawDists += (-rawDists+MAXDIST)*(1.-step(0., rawDists));\n    \n    //return\n    return min(rawDists.x, rawDists.y);\n}\n\nfloat raySphCutFor(vec3 ro, vec3 rd, vec4 sphere, float c) //ray sphere surface cut POSITIVE DIST ONLY\n{\n    //get raw dist\n    vec2 rawDists = raySph(ro, rd, sphere);\n    \n    //clamp\n    rawDists += (-rawDists+MAXDIST)*(1.-step(0., rawDists));\n   \n    //cut\n    vec2 thetaPhi;\n    \n    vec3 p1 = vec3((ro + rd*rawDists.x) - sphere.xyz);\n    thetaPhi = cartesianToSpherical(p1).xy;\n    rawDists.x += (-rawDists.x + MAXDIST)*(1.-step(c, sphereFunc(thetaPhi.x, thetaPhi.y)));\n    \n    vec3 p2 = vec3((ro + rd*rawDists.y) - sphere.xyz);\n    thetaPhi = cartesianToSpherical(p2).xy;\n    rawDists.y += (-rawDists.y + MAXDIST)*(1.-step(c, sphereFunc(thetaPhi.x, thetaPhi.y)));\n    \n    //return\n    return min(rawDists.x, rawDists.y);\n}\n\n//-=-=-=- GLOW -=-=-=-\nfloat getGlow(float d, float radius, float sharpness)\n{\n    return 1.-exp(-pow(radius / d, sharpness));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfGD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[909, 909, 1032, 1032, 1503], [1505, 1505, 1525, 1525, 1673], [1675, 1675, 1694, 1713, 2328], [2330, 2330, 2359, 2374, 4392], [4394, 4394, 4451, 4451, 4729]], "test": "untested"}
{"id": "mtfGzM", "name": "sponge flight", "author": "nickbrick", "description": "Discovering graphics by figuring out techniques on my own with minimal research. Features raymarching, diffuse & specular shading, supersampled ray shadows. Does not necessarily represent best practices or make sense.", "tags": ["raymarching", "shadows"], "likes": 1, "viewed": 149, "published": 3, "date": "1671854330", "time_retrieved": "2024-07-30T16:11:21.893515", "image_code": "#define PI 3.14159265\n#define SCENE 2\nfloat hills(vec3 p){ // test SCENE = 1\n    vec3 near = vec3(round(p.x), 0.0, round(p.z));\n    return distance(p, near);\n}\nvec3 hillsNormal(vec3 p){\n    vec3 near = vec3(round(p.x), 0.0, round(p.z));\n    return normalize(p - near);\n}\n\nfloat sampleFreqs(int bandFrom, int bandTo){\n    float v = 0.0;\n    for (int b = bandFrom; b <= bandTo; b ++)\n        v += texelFetch(iChannel0, ivec2(b, 0), 0).x; \n    return v / float(bandTo - bandFrom);\n}\n\nfloat sponge(vec3 p){ // actual SCENE = 2\n    vec3 near = round(p);\n    return norm(near, p, 5.0 - sampleFreqs(0, 64) * 4.0);\n}\nvec3 spongeNormal(vec3 p){ // this just returns the norm2 normals (spherical cells). i'd love to somehow calculate arbitrary norm normals\n    vec3 pp = round(p);\n    return normalize(round(p) - p);\n}\n\nbool hit(vec3 p){\n    if (SCENE == 1) return hills(p) < 0.55;\n    if (SCENE == 2) return sponge(p) > 0.55;\n}\nvec3 normal(vec3 p){\n    if (SCENE == 1) return hillsNormal(p);\n    if (SCENE == 2) return spongeNormal(p);\n}\n\nvec3 pixel(vec3 o, float fov, vec2 fc){\n    vec2 uv = (fc - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    float f = 0.5 / tan(fov/2.0);\n    vec3 n = vec3(0.0, 0.0, f);\n    return o + n + vec3(uv, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define FROM 0.0\n    #define TO   30.0\n    #define SAT  .9\n    #define STEP 0.07\n    #define DIFF 10.0\n    #define SPEC 80.0\n    #define AMBI 10.\n    #define BULB (sampleFreqs(256, 511) * 0.1 + 0.01)\n    #define SHADOWS true\n    #define SS   16.0\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //camera, light source\n    vec3 o = vec3(0.0 + 1.1 * cos((iTime + 0.5) * PI / 4.0),\n                  2.0 + 1.1 * sin((iTime + 0.5) * PI / 4.0), \n                  0.0 + 1.0 * iTime);\n    vec3 l = vec3(0.0,\n                  2.0 + sin(iTime) * 0.0,\n                  1.0 * iTime + 1.0);\n    \n    // shading components\n    float range = TO;\n    float diffuse = 0.0;\n    float specular = 0.0;\n    \n    vec3 n = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 pl = vec3(TO);\n    for (float a = FROM; a < TO; a += STEP){\n        vec3 pixel = pixel(o, 2.3, fragCoord);\n        pixel = axisAngle(vec3(0.,0.,1.), 0.5 * cos(0.5 * iTime)) * (pixel - o) + o;\n        vec3 p = mix(o, pixel, a);\n        if (hit(p)){ // surface\n            float shadow = 1.0;\n            if (SHADOWS){\n                vec3 dial = orthogonal(l - p) * BULB;\n                float hits = 0.0;\n\n                for (float a2 = 10.0 * STEP; a2 < 1.0; a2 += STEP){ // main shadow ray\n                        vec3 p2 = mix(p, l, a2);\n                        if (hit(p2)){ // shadow\n                            hits += 1.0;\n                            break;\n                        }\n                    }\n                for (float sector = 0.0; sector < 2.0 * PI; sector += 2.0 * PI / SS){ // shadow supersampling disk\n                    vec3 disk = (axisAngle(l - p, sector) * dial) + l;\n                    for (float a2 = 10.0 * STEP; a2 < 1.0; a2 += STEP){\n                        vec3 p2 = mix(p, disk, a2);\n                        if (hit(p2)){ // shadow\n                            hits += 1.0;\n                            break;\n                        }\n                    }\n                }\n                shadow =  (SS + 1.0 - hits) / (SS + 1.0);\n            }\n            range = distance(o, p);\n            pl = l - p;\n            vec3 po = o - p;\n            n = normal(p);\n            diffuse = pow(BULB, 0.5) / 0.1 * shadow / range * max(0.0, DIFF * dot(n, normalize(pl)));\n            specular = shadow * max(0.0001, SPEC * pow(max(0.0, -dot(normalize(po), reflect(normalize(pl), n))), 2.0 / BULB));\n            break;\n        }\n        if (length(l - p) < BULB) {diffuse = 100000000.; break;}\n    }\n    float v = 1.0 - (-1.0 / SAT / (TO - FROM) * ( (diffuse+ specular + AMBI) / pow(length(pl), 2.) ) + TO / (TO - FROM));\n    #define BMINOR vec3(0.82421875,0.41015625,0.03515625)\n    fragColor = vec4(v * BMINOR, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat3 axisAngle(vec3 u, float a){\n    float X = u.x;\n    float Y = u.y;\n    float Z = u.z;\n    float C = cos(a);\n    float S = sin(a);\n    float C_= 1.-cos(a);\n\n    return mat3(\n        C+X*X *C_ ,\n        Y*X*C_+Z*S,\n        Z*X*C_-Y*S,\n        X*Y*C_-Z*S,\n        C+Y*Y *C_  ,\n        Z*Y*C_+X*S,\n        X*Z*C_+Y*S,\n        Y*Z*C_-X*S,\n        C+Z*Z*C_\n     );\n}\n// returns a vector (0, y, z) where y, z >= 0 and magnitude = 1\nvec3 orthogonal(vec3 u){\n    if (abs(u.x) > 0.999) return vec3(0.0, 1.0, 0.0);\n    float y = abs(u.z) / sqrt(u.y * u.y + u.z * u.z);\n    float z = sqrt(1.0 - pow(y, 2.0));\n    return vec3(0.0, y, z);\n}\n\nfloat norm(vec3 p0, vec3 p1, float N){\n    vec3 d = abs(p0 - p1);\n    return pow(pow(d.x, N) + pow(d.y, N) + pow(d.z, N), 1.0 / N);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 76, 159], [160, 160, 185, 185, 270], [272, 272, 316, 316, 479], [481, 481, 502, 522, 608], [609, 609, 635, 746, 808], [810, 810, 827, 827, 918], [919, 919, 939, 939, 1028], [1030, 1030, 1069, 1069, 1250], [1252, 1252, 1309, 1309, 4015]], "test": "untested"}
{"id": "dlf3D7", "name": "😸 Cat Rave 😸", "author": "Xibanya", "description": "I mainly made this because I noticed that 😎 Pixel Rave 😎 was the 11th fork in a chain of forks so I thought, hell, why not make it 12? ", "tags": ["2d", "sdf", "cat", "motion"], "likes": 25, "viewed": 552, "published": 3, "date": "1671847458", "time_retrieved": "2024-07-30T16:11:22.949691", "image_code": "// the audio doesn't start automatically sometimes and I don't know why?\n// if it doesn't start you can hit pause/unpause on iChannel0 and it'll start...\n\n// designs inspired by https://www.freepik.com/premium-vector/cute-cats-collection-cats-faces_10120615.htm\n// comment this out to get four rows of procgen cats rather than 2\n#define BIGGER\n\n#define PUPIL vec3(0.18, 0.17, 0.165)\n#define CAT_BASE_1 vec3(0.9, 0.77, 0.55)\n#define CAT_BASE_2 vec3(0.4, 0.37, 0.37)\n#define CAT_BASE_3 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_4 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_5 vec3(0.9, 0.9, 0.83)\n#define CAT_LIGHT_1 vec3(0.97, 0.9, 0.7)\n#define CAT_LIGHT_2 vec3(1., 0.95, 0.97)\n#define CAT_LIGHT_3 vec3(1., 0.95, 0.85) \n#define CAT_LIGHT_4 vec3(1., 0.96, 0.78)\n#define CAT_LIGHT_5 vec3(0.9, 0.9, 0.83)\n#define CAT_DARK_1 vec3(0.7, 0.5, 0.4)\n#define CAT_DARK_2 vec3(0.25, 0.2, 0.2)\n#define CAT_DARK_3 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_4 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_5 vec3(0.44, 0.37, 0.36)\n#define CAT_OUTLINE_1 vec3(0.37, 0.2, 0.13)\n#define CAT_OUTLINE_2 vec3(0.18, 0.18, 0.16)\n#define CAT_OUTLINE_3 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_4 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_5 vec3(0.35, 0.3, 0.26)\n#define CAT_EYE_1 vec3(1.)\n#define CAT_EYE_2 vec3(0.8, 0.76, 0.38)\n#define CAT_EYE_3 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_4 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_5 vec3(0.9)\n#define CAT_BELLY_1 vec3(0.97, 0.9, 0.7)\n#define CAT_BELLY_2 vec3(1., 0.95, 0.97)\n#define CAT_BELLY_3 vec3(0.7, 0.6, 0.5) * 1.1\n#define CAT_BELLY_4 vec3(1., 0.96, 0.78)\n#define CAT_BELLY_5 vec3(0.9, 0.9, 0.83)\n\n#define TABBY_SPOT 0.075\n\n#define MAX_ROTATION 150.\n#define MIN_ROTATION -150.\n#define MAX_EAR_DOWN 225.\n#define MAX_EAR_UP 195.\n\n#ifdef BIGGER\n    #define OUTLINE_THICKNESS 0.04\n#else\n    #define OUTLINE_THICKNESS 0.02\n#endif\n#define OUTLINE_THRESHOLD 0.7\n\nstruct Cat {\n    float butt; // width of the lower end of the body\n    float height; // body length\n    float rotation; // body rotation in degrees\n    vec3 baseColor;\n    vec3 lightColor;\n    vec3 darkColor;\n    vec3 outlineColor;\n    vec3 eyeColor;\n    vec3 belly;\n    float f; // this is to cache the FBM noise value\n    float r; // progress from min rotation value to max rotation value from 0 to 1\n    float faceDark;\n    float heart;\n    float spots;\n    float tabby;\n    int type;\n    vec3 sound;\n};\nmat2 Rotate2DMatrix(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nvec2 Rotate2D(vec2 p, float a)\n{\n    return Rotate2DMatrix(radians(a)) * p;\n}\nvec3 DoOutline(float d, vec3 color, float thickness, vec3 outColor)\n{\n    if (d < 0.)\n    {\n        float t = -d / thickness;\n        t = t * t;\n        color = mix(outColor, color, step(OUTLINE_THRESHOLD, t));\n    }\n    return color;\n}\nfloat InvLerp(in float from, float to, float value)\n{\n    return (value - from) / (to - from);\n}\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\nfloat Spline(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n// 2D SDF functions from https://iquilezles.org/articles/distfunctions2d/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat Heart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\nfloat UnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\nfloat EquiTriSDF(in vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat Isosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat Egg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat Circle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat FBMRandom(vec2 st)\n{\n    vec2 m = vec2(iMouse.xy);\n    return fract(sin(dot(st.xy, m + vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\nfloat Audio(float x)\n{\n    return texture(iChannel0, vec2(x, 0.0)).r;\n}\n// https://www.shadertoy.com/view/MtG3Wh by FabriceNeyret2\nvec4 hue(float x)\n{\n    return .5+.5*cos(6.283185*(x +vec4(0,1,-1,0)/3.));\n}\nCat GetCat(vec2 uv)\n{\n    // declaring the arrays outside the function doesn't work on some platforms\n    // so gotta do this rigamarole here\n    vec3[5] base;\n    base[0] = CAT_BASE_1; base[1] = CAT_BASE_2; base[2] = CAT_BASE_3; \n    base[3] = CAT_BASE_4; base[4] = CAT_BASE_5;\n\n    vec3[5] light;\n    light[0] = CAT_LIGHT_1; light[1] = CAT_LIGHT_2; light[2] = CAT_LIGHT_3; \n    light[3] = CAT_LIGHT_4; light[4] = CAT_LIGHT_5;\n\n    vec3[5] dark;\n    dark[0] = CAT_DARK_1; dark[1] = CAT_DARK_2; dark[2] = CAT_DARK_3; \n    dark[3] = CAT_DARK_4; dark[4] = CAT_DARK_5;\n\n    vec3[3] eye;\n    eye[0] = CAT_EYE_1; eye[1] = CAT_EYE_2; eye[2] = CAT_EYE_3;\n\n    vec3[5] outline;\n    outline[0] = CAT_OUTLINE_1; outline[1] = CAT_OUTLINE_2; outline[2] = CAT_OUTLINE_3; \n    outline[3] = CAT_OUTLINE_4; outline[4] = CAT_OUTLINE_5;\n\n    vec3[5] belly;\n    belly[0] = CAT_BELLY_1; belly[1] = CAT_BELLY_2;\n    belly[2] = CAT_BELLY_3; belly[3] = CAT_BELLY_4;\n    belly[4] = CAT_BELLY_5;\n\n    Cat cat;\n\n    vec2 cUV = floor(uv * 2.);\n\n    float f = clamp(0., 1., FBMRandom(cUV));\n    cat.f = f;\n    int i = 0;\n    float count = 5.;\n    float mul = 1000.;\n    float cF = fract(f + cUV.x + cUV.y * 0.5);\n    if (mod(floor(cF * mul) + 1., count) == 0.) i = 1;\n    else if (mod(floor(cF * mul) + 2., count) == 0.) i = 2; \n    else if (mod(floor(cF * mul) + 3., count) == 0.) i = 3; \n    else if (mod(floor(cF * mul) + 4., count) == 0.) i = 4;\n\n    cat.type = i;\n    \n    float isEven = mod(float(i), 2.) == 0.? 1. : 0.;\n    float audioHigh = Audio(0.95 * isEven + 0.75 * (1. - isEven));\n    float audioMed = Audio(0.65 * isEven + 0.45 * (1. - isEven));\n    float bass = Audio(0.1);\n    cat.sound = vec3(audioHigh, audioMed, bass);\n    audioMed = smoothstep(0.25, 1., audioMed);\n    \n    cat.baseColor = base[i] * mix(vec3(1.), hue(cat.f).rgb * 1.25, smoothstep(0.15, 0.75, audioHigh));\n    cat.lightColor = light[i] + pow(hue(float(i)).rgb, vec3(audioMed));\n    cat.darkColor = dark[i] + hue(cat.f).rgb * audioHigh;\n    cat.outlineColor = outline[i];\n    cat.belly = belly[i];\n    cat.eyeColor = mod(floor(f * 100.), 3.) == 0.? eye[0] : \n        (mod(floor(f * 100.) + 1., 3.) == 0.? eye[1] : eye[2]);\n\n    float highRot = (smoothstep(0.5, 1., audioHigh) * 2. - 1.) * 0.5;\n    cat.rotation = mix(MIN_ROTATION, MAX_ROTATION, fract(f + cUV.x * 0.3) + highRot);\n    cat.r = InvLerp(MIN_ROTATION, MAX_ROTATION, cat.rotation);\n    cat.height = mix(0.5, 1., fract(f + 0.5 + cUV.y));\n    bass = smoothstep(0.6, 1., bass) * 2. - 1.;\n    cat.butt = mix(0.65, 0.95, abs(f * 2. - 1.) + bass * 0.25);\n   \n    cat.faceDark = mod(floor((1. - cat.f) * 5.), 4.) == 0.? 1. : 0.;\n    cat.heart = mod(floor(fract(cat.f + 0.75) * 10.), 2.) == 0.? 1. : 0.;\n    cat.spots = mod(floor(cat.f * 1450.), 2.) == 0.? 1. : 0.;\n    cat.tabby = mod(floor(fract(cat.f + 0.25) * 1329.), 3.) == 0.? 1. : 0.;\n\n    return cat;\n}\nfloat Smooth(float sdf) { return 1. - smoothstep(-0.025, -0.01, sdf);}\nfloat TopMarks(vec2 headUV)\n{\n    float xSign = sign(headUV.x);  \n    vec2 mUV = headUV * vec2(7., 1.) + vec2(0., 2.);\n    float markScale = 1.;\n    float mSDF = Circle(mUV, markScale);\n\n    vec2 mUV1 = Rotate2D(headUV, 16. * xSign);\n    mUV1 = mUV1 * vec2(10., 1.) + vec2(-1. * -xSign, 2.2);\n    mSDF = min(mSDF, Circle(mUV1, markScale));\n    return mSDF;\n}\nfloat HeartMark(vec2 headUV)\n{\n    vec2 heartUV = headUV * vec2(0.15, 0.2) + vec2(0., 1.05);\n    return Heart(heartUV);\n}\nvoid HeadMarkings(vec2 p, Cat cat, inout vec3 col)\n{\n    float xSign = sign(p.x);\n    vec3 light = mix(cat.lightColor * 1.1, cat.lightColor, \n        clamp(0., 1., dot(p, p)));\n    if (cat.heart == 1.)\n    {\n        float heartSDF = HeartMark(p);\n        col = heartSDF < 0.? col : light;\n    }\n   \n    if (cat.faceDark == 1.)\n    {\n        float spots = 0.;\n        vec3 sColor = cat.darkColor;\n        if (cat.spots == 1.)\n        {\n            float w =  sin(p.x * 50.) * 0.025;\n            vec2 stUV = p + vec2(1., 1.4);\n            stUV.y += w;\n            spots = Circle(stUV * vec2(1., 1.2), 1.2);\n            stUV -= vec2(2.3, 0.1);\n            spots = min(spots, Circle(Rotate2D(stUV, 25.) * vec2(1., 1.75), 0.75));\n            if (cat.heart == 0.)\n            {\n                stUV = p - vec2(0.8, 1.4);\n                stUV.y += w * 0.2;\n                stUV.x *= 0.7;\n                spots = min(spots, Circle(stUV, 0.75));\n            }\n            if (cat.tabby == 1.) sColor += TABBY_SPOT;\n        }\n        else\n        {\n            vec2 sideUV = p - vec2(1.6 * xSign, -0.9);\n            spots = Circle(sideUV, 1.5);\n        }\n         col = mix(col, sColor, Smooth(spots));\n    }\n    if (cat.tabby == 1.)\n    {\n        float mSDF = TopMarks(p);\n        col = mix(col, cat.darkColor, Smooth(mSDF));\n    }\n    if (mod(floor(cat.f * 1000.), 2.) == 0.)\n    {\n        float muzzle = Isosceles(p * 3. + vec2(0., 0.1), vec2(0.9, 1.)) - 1.;\n        col = mix(col, light, Smooth(muzzle));\n    }\n}\nvoid Eyes(vec2 headUV, Cat cat, inout vec3 col)\n{\n    float xSign = sign(headUV.x);  \n    vec2 eyeUV = headUV + vec2(0., 0.5);\n    eyeUV.x -= 0.8 * xSign;\n\n    // blinky blinky\n    float t = sin(iTime * max(0.5, cat.f) + cat.f) * 0.5 + 0.5;\n    float b = smoothstep(0., 1., InvLerp(0.999, 1., t));\n    eyeUV.y = mix(eyeUV.y, eyeUV.y * 7., b);\n\n    float eyeScale = mix(0.5, 0.55, cat.f);\n    float eyeSDF = Circle(eyeUV, eyeScale);\n    vec3 eyeCol = cat.eyeColor;\n    float pupil = Circle(eyeUV, eyeScale * 0.75);\n    eyeCol = mix(eyeCol, PUPIL, Smooth(pupil));\n    vec2 shineUV = eyeUV + vec2(0.2, 0.15);\n    float shine = Circle(shineUV, eyeScale * 0.3);\n    shine = min(shine, Circle(shineUV + vec2(0.1, -0.2), eyeScale * 0.15));\n    eyeCol = mix(eyeCol, vec3(1.), Smooth(shine));\n    vec2 lidUV = eyeUV * vec2(1., 0.95) + vec2(0., 0.05);\n    lidUV.y = mix(lidUV.y, lidUV.y * 0.95 - 0.02, b);\n    float lid = Circle(lidUV, eyeScale);\n    vec3 lidColor = cat.faceDark == 1.? cat.outlineColor : cat.darkColor;\n    eyeCol = mix(lidColor, eyeCol, Smooth(eyeSDF));\n    eyeSDF = min(eyeSDF, lid);\n    col = mix(col, eyeCol, Smooth(eyeSDF));\n}\nfloat Head(vec2 p, Cat cat, out vec3 col)\n{\n    float headHeight = cat.height * 1.2;\n    float headScale = 2.5 - smoothstep(0.25, 0.75, cat.sound.x) * 0.25;\n    vec2 headUV = (p - vec2(0., headHeight)) * headScale;\n    float headRot = (smoothstep(0.25, 1., cat.sound.y) * 2. - 1. ) * 10. * cat.sound.y * -sign(cat.rotation);\n    headUV = Rotate2D(headUV, -cat.rotation + headRot);\n    headUV.y *= -1.;\n    float xSign = sign(headUV.x);  \n    float headSDF = Egg(headUV, 2., 3.) + 0.1;\n    vec2 huv = headUV + vec2(0., 0.);\n    col = mix(cat.baseColor * 1.2, cat.baseColor, \n        smoothstep(0., 1.5, dot(huv, huv)));\n\n    // markings\n    HeadMarkings(headUV, cat, col);\n\n    //Ears\n    vec2 earUV = headUV;\n    earUV.x -= 1.1 * xSign;\n    earUV.y += 1.1;\n    float earWiggle = smoothstep(0.5, 1., Audio(0.5));\n    float earRot = mix(MAX_EAR_DOWN - earWiggle * 100., MAX_EAR_UP + earWiggle * 50., fract(cat.f * 25.) );\n    float earTip = 1.;\n    if (mod(floor(cat.f * 0.35 * 1000.), 3.) == 0.) earTip = 0.75;\n    earUV = Rotate2D(earUV, earRot * xSign);\n    float ear = Egg(earUV, 2., earTip) + 1.2;\n    vec3 earColor = cat.darkColor;\n    earUV = Rotate2D(earUV, -5. * xSign);\n    float earNeg = Egg(earUV * vec2(1.1, 1.) + vec2(0.2 * xSign, 0.), 2., 1.) + 1.4;\n    earColor = mix(earColor, cat.lightColor, Smooth(earNeg));\n    col = mix(earColor, col, Smooth(headSDF));\n    headSDF = min(headSDF, ear);\n   \n    // nose\n    vec3 noseColor = cat.outlineColor;\n    float noseScale = 8.;\n    vec2 noseUV = headUV;\n   \n    float bridge = Isosceles(noseUV * noseScale + vec2(0., 2.3), \n        vec2(0.7, 2.5)) - .75;\n    vec3 bridgeCol = cat.darkColor;\n    if (cat.type == 1) bridgeCol = cat.baseColor;\n    else if (mod(floor(cat.f * 2324321.), 2.) == 0.)\n    {\n        bridgeCol = cat.baseColor * 1.1;\n    }\n    col = mix(col, bridgeCol, Smooth(bridge));\n\n    noseUV *= vec2(1., -1.);\n    noseUV.y += 0.2;\n    float noseSDF = Isosceles(noseUV * noseScale, vec2(1.1, 0.8)) - .5;\n    col = mix(col, noseColor, Smooth(noseSDF));\n\n    // Eyes\n    Eyes(headUV, cat, col);\n\n    // Mouth\n    vec2 mouthUV = headUV - vec2(0., 0.3);\n    mouthUV.x *= 0.8;\n    mouthUV.x -= 0.19 * xSign;\n    float mouthScale = 0.2;\n    float mouth = Circle(mouthUV, mouthScale);\n    mouthUV = mouthUV * vec2(1.2, 0.9) + vec2(0., 0.1);\n    mouth = max(mouth, -Circle(mouthUV, mouthScale));\n    col = mix(col, cat.outlineColor, Smooth(mouth));\n\n    // head outline before whiskers\n    col = DoOutline(headSDF, col, OUTLINE_THICKNESS * headScale, cat.outlineColor);\n\n    // whiskers\n    vec2 wUV = headUV;\n    wUV.x -= 2. * xSign;\n    wUV.y -= 1.;\n    float wScale = 1.2;\n    float whisker = Circle(wUV, wScale);\n    vec2 wUV2 = wUV * vec2(0.8, 1.) - vec2(0.1 * xSign, 0.075);\n    whisker = max(whisker, -Circle(wUV2, wScale));\n\n    wUV.x += 0.35 * xSign;\n    wUV.y -= 0.25;\n    float w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.8, 1.) + vec2(0.1 * xSign, -0.075);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    wUV.x += 0.1 * xSign;\n    wUV.y -= 0.15;\n    w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.75, 1.) + vec2(0.2 * xSign, -0.05);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    col = whisker < 0.? cat.outlineColor : col;\n\n    headSDF = min(headSDF, whisker);\n    return headSDF;\n}\nfloat Tail(vec2 uv, Cat cat)\n{\n    float rSign = sign(cat.rotation);\n    float xMul = cat.r * 2. - 1.;\n    float invX = 1. - abs(xMul);\n    float t = (sin(iTime * (cat.f + cat.sound.y * 0.001) + cat.f + cat.sound.z * 0.1) * 0.5 + 0.5);\n    \n    float rotMod = (Audio(cat.f) * 2. - 1.) * 0.5;\n    t += rotMod;\n    xMul -= rotMod;\n\n    vec2 a = vec2(0. - cat.sound.y * 0.1, 0.6 + cat.sound.x * 0.1 - cat.sound.z * 0.15);\n    vec2 b = vec2(1. * xMul * t - cat.sound.z * 0.2, 1. * abs(xMul) - cat.sound.y * 0.1);\n    vec2 c = vec2((-0.5 + 0.5 *invX) * xMul + 1.5 * invX + t * 0.5 - cat.sound.z * 0.1, 1. - 0.5 * invX);\n    vec2 d = vec2((0.3 + 0.5 * invX) * xMul * t + cat.sound.y * 0.1, 1.5 + 0.15 * abs(xMul) * t * 2. - cat.sound.z * 0.1);\n\n    float tail = 0.;\n    const float STEPS = 20.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n        float l = Spline(uv, p0, p1) - 0.1;\n        tail = min(tail, l);\n    }   \n    return tail;\n}\nvoid BackPattern(vec2 p, Cat cat, inout vec3 col)\n{\n    float r = cat.r * 2. - 1.;\n    float aR = abs(r);\n    float rSign = sign(r);\n    \n    //spots\n    if ((cat.spots == 1. || cat.faceDark == 1.))\n    {\n        vec2 spotUV = p * 7.;\n        spotUV.y += mix(10., 2., aR) * rSign;\n        spotUV.x += mix(-10., -3., aR) * rSign;\n\n        // if smooth face marks, spots should also be smooth\n        if (cat.spots == 1.) spotUV.y += sin(spotUV.x * 10.) * 0.1;\n       \n        float spot = EquiTriSDF(spotUV) - 2.;\n        spot = min(spot, EquiTriSDF(spotUV * 2. + \n            vec2(10. * rSign + 10. * step(rSign, 0.), 6. + 5. * step(rSign, 0.))) - 2.);\n\n        vec3 spotColor = cat.darkColor;\n        if (cat.tabby == 1.) spotColor += TABBY_SPOT;\n        \n        col = spot < 0.? spotColor : col;\n    }\n    \n    // tabby stripes\n    if (cat.tabby == 1.)\n    {\n        float xSign = sign(p.x);\n        vec2 uv = p;\n        \n        if (rSign > 0.)\n        {\n            uv.x += mix(-2., -.05, aR);\n            uv = Rotate2D(uv, 25. * aR);\n        }\n        else if (rSign < 0.)\n        {\n            uv.x += mix(2., 0.5, aR);\n            uv = Rotate2D(uv, -50. * aR);\n        }\n        uv *= vec2(1., 8.);\n        float l = Circle(uv, 0.5);\n        l = min(l, Circle(uv + vec2(0., 1.5), 0.5));\n        l = min(l, Circle(uv - vec2(0, 1.5), 0.5));\n        col = l < 0.? cat.darkColor : col;\n    }\n}\nfloat SceneSDF(vec2 p, out vec3 col)\n{\n    Cat cat = GetCat(p);\n    p = fract(p * 2.) - 0.5;\n    #ifdef BIGGER\n    float scale = 4.;\n    p.y += 0.1;\n    #else\n     float scale = 4.5;\n    #endif\n    \n    vec2 bodyUV = p * scale;\n    \n    float rotMod = cat.f + (Audio(0.25) * 2. - 1.) * 0.01;\n   \n    col = mix(cat.baseColor, cat.baseColor * 1.2, dot(bodyUV, bodyUV) * 0.5 + 0.5);\n    cat.rotation += mix(-50., 50., cos(iTime * 0.2 * rotMod + (rotMod * 2. - 1.)) * 0.5 + 0.5);\n    bodyUV = Rotate2D(bodyUV, cat.rotation);\n   \n    float sdf = UnevenCapsule(bodyUV, cat.butt, 0.5, cat.height);\n\n    BackPattern(bodyUV, cat, col);\n\n    vec2 bellyUV = bodyUV;\n    bellyUV.y += sin(bodyUV.x * 75.) * 0.025;\n    float b = InvLerp(-90., 90., cat.rotation);\n    float bX = 0.75;\n    bellyUV.x += mix(-bX, bX, b);\n    bellyUV.y += mix(-0.1, 0.1, b);\n    float width = mix(0.7, 0.5, abs(b * 2. - 1.));\n    float belly = UnevenCapsule(bellyUV * 1.5, width, 0.5, cat.height) - 0.2;\n    col = mix(col, cat.belly, Smooth(belly));\n    col = DoOutline(sdf, col, OUTLINE_THICKNESS, cat.outlineColor);\n\n    // head casting shadow on the body\n    float shadow = Circle(bodyUV - vec2(0., cat.height * 1.1), 0.5);\n    col = shadow < 0.? col * 0.9 : col;\n\n    vec3 headCol;\n    float headSDF = Head(bodyUV, cat, headCol);\n    col = headSDF < 0.? headCol : col;\n    sdf = min(sdf, headSDF);\n\n    float tail = Tail(p * scale, cat);\n    vec3 tailCol = DoOutline(tail, cat.baseColor, OUTLINE_THICKNESS, cat.outlineColor);\n    col = sdf < 0.? col : tailCol;\n    sdf = min(sdf, tail);  \n    return sdf;\n}\n\n// this part is from the Pixel Rave shader this one's forked from\n// https://www.shadertoy.com/view/dts3Dr\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n//https://lospec.com/palette-list/endesga-32\n#define c0 vec3(184,111,80)/255.\n#define c1 vec3(194,133,105)/255.\n#define c2 vec3(228,166,114)/255.\n#define c3 vec3(232,183,150)/255.\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 h41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}\nvec3 Visualizer(vec2 f)\n{\n    f.x += 10.;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.3;\n    vec3 tx = texelFetch(iChannel0, ivec2(sc*f), 0).rgb;\n    vec3 col = vec3(0);\n    \n    float w = 64. / sc;\n    f.x += floor(-30. * iTime/sc) - 4.;\n    float ix = floor(f.x/w);\n    vec4 h = h41(ix);\n    \n    if (tx == vec3(1)) tx = vec3(24,20,37)/255.;\n    else if (tx.r > 0.) col = c0 * tx.r;\n    else if (tx.b > 0.) col = c1 * tx.b;\n    else if (tx.g > 0.) col = c2 * tx.g;\n    \n    vec3 pl = .5+.5*cos(2.*pi*(ix/8. + vec3(0,1,2)/3.));\n    float mx = mix(0., 0.5-0.5*uv.y, .25+.25*thc(400.,2.*pi*h.x - 10.*h.x*uv.y+iTime));\n    mx *= tanh(0.1 * iTime);\n    if (tx == vec3(0)) {\n        col = vec3(mix(240.,210.,.5-uv.y))/255.;\n        col = mix(col, pl, mx);\n    }\n    else\n        col = mix(col, col * (.6+.4*pl), mx);\n        \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p.x += (iTime + 3000.) * 0.25;\n    #ifdef BIGGER\n        // adjusting for how it looks different in shadertoy \n        // than from VSCode where I authored this...\n        p *= 0.5;\n        p.y += 0.01;\n    #else\n        p.y += 0.025;\n    #endif\n    \n    float bass = smoothstep(0.25, 1., Audio(0.2));\n    // https://www.shadertoy.com/view/llycWD\n    vec2 shake = vec2(sin(iTime * 10. + bass * 2.), cos(iTime * 3. + bass)) * 0.015;\n   \n    vec3 col = Visualizer((p + shake * 0.25) * 1000.);\n    vec3 fg = vec3(0.);\n    \n    float sdf = SceneSDF(p + shake, fg);\n    col = sdf < 0.? fg : col;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31654, "src": "https://soundcloud.com/kordhell/murder-in-my-mind", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlf3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2360, 2360, 2390, 2390, 2472], [2473, 2473, 2505, 2505, 2550], [2551, 2551, 2620, 2620, 2787], [2788, 2788, 2841, 2841, 2884], [2885, 2885, 2944, 2944, 3122], [3123, 3123, 3170, 3170, 3286], [3287, 3361, 3386, 3386, 3405], [3406, 3406, 3431, 3431, 3450], [3451, 3451, 3477, 3477, 3697], [3698, 3698, 3758, 3758, 3997], [3998, 3998, 4027, 4027, 4238], [4239, 4239, 4280, 4280, 4588], [4589, 4589, 4639, 4639, 4912], [4913, 4913, 4946, 4946, 4974], [4975, 4975, 5001, 5001, 5131], [5132, 5132, 5154, 5154, 5203], [5204, 5263, 5282, 5282, 5339], [8212, 8212, 8237, 8237, 8282], [8283, 8283, 8312, 8312, 8641], [8642, 8642, 8672, 8672, 8763], [8764, 8764, 8816, 8816, 10270], [10271, 10271, 10320, 10320, 11410], [11411, 11411, 11454, 11454, 14739], [14740, 14740, 14770, 14770, 15794], [15795, 15795, 15846, 15846, 17192], [17193, 17193, 17231, 17231, 18768], [19117, 19179, 19198, 19198, 19344], [19345, 19345, 19370, 19370, 20215], [20216, 20216, 20273, 20273, 20954]], "test": "untested"}
{"id": "dtfGD7", "name": "2D 3D SDF of a Fibonacci Sphere", "author": "fishy", "description": "Yeah, so I uh, I made a 2D sdf out of a collection of projected 3D points, kind of silly, right? Oh yeah and the coloring code is a little messy (just a little)", "tags": ["sdf"], "likes": 18, "viewed": 398, "published": 3, "date": "1671839214", "time_retrieved": "2024-07-30T16:11:23.744566", "image_code": "// An experiment into fibonacci spheres, originally was going to be just dots but that idea\n// was thrown out of the window pretty quickly\n\n#define FOCAL_LEN 1.\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 project(vec3 p)\n{\n    return vec3((p.xy*FOCAL_LEN), 1.)/(FOCAL_LEN+p.z);\n}\n\nfloat fibonacciSphere(vec2 p, float iter, float size)\n{\n    float st = 2./iter;\n    float d = 1e20;\n    float j = 0.;\n    for(float i = -1.; i < 1.; i += st)\n    {\n        float r = sqrt(1. - i*i);\n        float t = j*2.399963;\n        vec3 fp = vec3(cos(t)*r, i, sin(t)*r)*0.5;\n        fp = rotY(fp, -iTime*0.5);\n        fp = rotX(fp, -iTime*0.3);\n        vec3 projected = project(fp);\n        float dist = distance(p, projected.xy)-size*projected.z;\n        //if(fp.z < FOCAL_LEN)\n        d = min(d, dist);\n        j++;\n    }\n    return d;\n}\n\nfloat map(vec2 uv)\n{\n    return fibonacciSphere(uv, 50., 0.05);\n}\n\nvec3 colorSdf(vec2 uv, vec4 m, float px)\n{\n    #define PERIOD 200.\n    #define STR 0.2\n    #define STROKE_WIDTH 0.005\n    #define MOUSE_WIDTH 0.005\n    float d = map(uv);\n    float md = abs(map(m.xy));\n    vec3 col = mix(vec3(0.094,0.494,0.988), vec3(1.000,0.082,0.980), sign(d)*0.5+0.5);\n    col *= smoothstep(-px*PERIOD, px*PERIOD, cos(d*PERIOD))*STR+1.-STR;\n    col = mix(col, vec3(1), smoothstep(STROKE_WIDTH+px, STROKE_WIDTH-px, abs(d)));\n    if(m.z > 0.)\n    {\n        float mdc = smoothstep(px, -px, min(abs(distance(m.xy, uv)-md+MOUSE_WIDTH)-MOUSE_WIDTH, distance(m.xy, uv)-MOUSE_WIDTH*2.));\n        col = mix(col, vec3(1.000,0.875,0.000), mdc);\n    }\n    col /= d+1.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 1.5/iResolution.y;\n\n    vec3 col = vec3(colorSdf(uv, m, px));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfGD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 183, 183, 232], [234, 234, 262, 262, 297], [299, 299, 327, 327, 362], [364, 364, 392, 392, 427], [429, 429, 451, 451, 508], [510, 510, 565, 565, 1053], [1055, 1055, 1075, 1075, 1120], [1122, 1122, 1164, 1164, 1816], [1818, 1818, 1875, 1925, 2194]], "test": "untested"}
{"id": "dtXGD7", "name": "Circular Wavefront", "author": "oneshade", "description": "Another random thing.", "tags": ["waves", "animation", "disk"], "likes": 17, "viewed": 209, "published": 3, "date": "1671838396", "time_retrieved": "2024-07-30T16:11:24.664108", "image_code": "#define PI 3.1415926536\n\n// Settings\n//#define BOX_BOUNDARY\n#define DISK_BOUNDARY\n#define BOUNDARY_DIMS 1.5\n#define POINT_SIZE 0.05\n#define WAVE_ORIGIN vec2(-0.6, -0.4)\n#define WAVE_SPEED 2.0\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat sdBall(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdVector(in vec2 p, in vec2 v) {\n    return length(p - v * clamp(dot(p, v) / dot(v, v), 0.0, 1.0));\n}\n\nvoid boxBounce(in vec2 b, in vec2 p0, in vec2 v0, in float t, out vec2 pos, out vec2 vel) {\n     vec2 q = 2.0 * b - mod(p0 + v0 * t + b, 4.0 * b);\n     pos = b - abs(q), vel = v0 * sign(q);\n}\n\nvoid diskBounce(in float r, in vec2 p0, in vec2 v0, in float t, out vec2 pos, out vec2 vel) {\n    float a = dot(v0, v0);\n    float b = dot(p0, v0);\n    float c = dot(p0, p0) - r * r;\n    float dis = b * b - a * c;\n    if (dis >= 0.0 && c <= 0.0) {\n        dis = sqrt(dis);\n        t += (dis + b) / a;\n\n        vec2 hit = p0 + v0 * (dis - b) / a;\n        float reflDelta = 2.0 * asin((p0.y * v0.x - p0.x * v0.y) / (r * sqrt(a))) - PI;\n\n        float pathLen = 2.0 * dis / a;\n        float hitIndex = floor(t / pathLen);\n\n        float angle = reflDelta * hitIndex;\n        vec2 startPos = Rotate2D(angle - reflDelta) * hit;\n        vec2 startVel = Rotate2D(angle) * v0;\n\n        t -= pathLen * hitIndex;\n        pos = startPos + startVel * t, vel = startVel;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    #ifdef BOX_BOUNDARY\n    vec2 q = abs(uv) - BOUNDARY_DIMS;\n    color = mix(color, vec3(1, 0, 0), smoothstep(unit, 0.0, abs(max(q.x, q.y))));\n    #else\n    color = mix(color, vec3(1, 0, 0), smoothstep(unit, 0.0, abs(length(uv) - BOUNDARY_DIMS)));\n    #endif\n\n    for (float a=0.0; a < 2.0 * PI; a += 2.0 * PI / 50.0) {\n        vec2 v0 = vec2(cos(a), sin(a)) * WAVE_SPEED;\n        vec2 pos, vel;\n\n        #ifdef BOX_BOUNDARY\n        boxBounce(vec2(BOUNDARY_DIMS - POINT_SIZE), WAVE_ORIGIN, v0, iTime, pos, vel);\n        #else\n        diskBounce(BOUNDARY_DIMS - POINT_SIZE, WAVE_ORIGIN, v0, iTime, pos, vel);\n        #endif\n\n        vec2 pointUv = uv - pos;\n        //color = mix(color, vec3(0, 0, 1), smoothstep(unit, 0.0, sdVector(pointUv, 0.25 * vel)));\n        color = mix(color, vec3(0, 1, 1), smoothstep(unit, 0.0, sdBall(pointUv, POINT_SIZE)));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXGD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 220, 220, 292], [294, 294, 331, 331, 359], [361, 361, 399, 399, 468], [470, 470, 561, 561, 661], [663, 663, 756, 756, 1428], [1430, 1430, 1485, 1485, 2519]], "test": "untested"}
{"id": "dlXGWM", "name": "Dithered less bits", "author": "fishy", "description": "By SONENEIS. I just like the look of Bayer dithering", "tags": ["raymarching", "ray", "round", "cube", "pixel", "bit", "bit", "dark", "pixelated", "purpple"], "likes": 17, "viewed": 301, "published": 3, "date": "1671826980", "time_retrieved": "2024-07-30T16:11:25.478929", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nconst float pixBits = 32.0;\nconst float colBits = 8.0;\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n  \n  uv = floor(uv * pixBits) / pixBits;\n  \n  {\n    float d = 0.0;\n    for(float i=0.0;i<16.0;i++){\n      vec3 p = vec3(0.0,0.0,3.0) + normalize(vec3(uv*0.6,-2.0)) * d;\n      p.yz *= rot(iTime); p.zx *= rot(iTime); p.xy *= rot(iTime);\n      float h = length(max(abs(p)-0.25,0.0)) - 0.25;\n      d += h;\n      if(h < 0.001 || d > 4.0) break;\n    }\n    if(d < 4.0){\n      vec3 p = vec3(0.0,0.0,3.0) + normalize(vec3(uv,-2.0)) * d;\n      col = vec3(1,1,2) * p.z;\n    }\n  }\n\n  vec3 f = floor(col * colBits) / colBits;\n  vec3 e = col-f;\n  float n = texture(iChannel0, uv*iChannelResolution[0].xy).r;\n  col = f+step(n, e*colBits)/colBits;\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [119, 119, 169, 169, 915]], "test": "untested"}
{"id": "dtXGWM", "name": "Bouncy Lines in a Disk", "author": "oneshade", "description": "Based on [url=https://www.shadertoy.com/view/MlBSWt]https://www.shadertoy.com/view/MlBSWt[/url].", "tags": ["lines", "circle", "bouncing"], "likes": 21, "viewed": 171, "published": 3, "date": "1671826561", "time_retrieved": "2024-07-30T16:11:26.300732", "image_code": "#define PI 3.1415926536\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0.0, 1.0));\n}\n\nvoid diskBounce(in float r, in vec2 p0, in vec2 v0, in float t, out vec2 pos, out vec2 vel) {\n    float a = dot(v0, v0);\n    float b = dot(p0, v0);\n    float c = dot(p0, p0) - r * r;\n    float dis = b * b - a * c;\n    if (dis >= 0.0 && c <= 0.0) {\n        dis = sqrt(dis);\n        t += (dis + b) / a;\n\n        vec2 hit = p0 + v0 * (dis - b) / a;\n        float reflDelta = 2.0 * asin((p0.y * v0.x - p0.x * v0.y) / (r * sqrt(a))) - PI;\n\n        float pathLen = 2.0 * dis / a;\n        float hitIndex = floor(t / pathLen);\n\n        float angle = reflDelta * hitIndex;\n        vec2 startPos = Rotate2D(angle - reflDelta) * hit;\n        vec2 startVel = Rotate2D(angle) * v0;\n\n        t -= pathLen * hitIndex;\n        pos = startPos + startVel * t, vel = startVel;\n    }\n}\n\nvoid bouncyLine(inout vec3 pixel, in vec2 uv, in float unit, in vec3 color, float diskSize, in vec2 vel, in int idx, in vec2 a0, in vec2 b0) {\n    vec2 offs = vel / 20.0 * float(idx);\n\n    vec2 aPos0 = a0 + offs, aPos;\n    vec2 aVel0 = vel, aVel;\n    diskBounce(diskSize, aPos0, aVel0, iTime, aPos, aVel);\n\n    vec2 bPos0 = b0 + offs, bPos;\n    vec2 bVel0 = vel, bVel;\n    diskBounce(diskSize, bPos0, bVel0, iTime, bPos, bVel);\n\n    pixel += color * smoothstep(unit, 0.0, sdLine(uv, aPos, bPos));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float diskSize = 1.5;\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(length(uv) - diskSize)));\n\n    for (int i=0; i < 10; i++) {\n        bouncyLine(color, uv, unit, vec3(1, 0, 0), diskSize, vec2(2.0, 0.25), i, vec2(-0.6, 0.4), vec2(0.2, -0.8));\n        bouncyLine(color, uv, unit, vec3(0, 1, 0), diskSize, vec2(-1.0, 2.0), i, vec2(-0.2, -0.8), vec2(1.0, 0.2));\n        bouncyLine(color, uv, unit, vec3(0, 0, 1), diskSize, vec2(-3.0, 0.0), i, vec2(0.1, -0.8), vec2(1.0, 0.2));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 52, 52, 124], [126, 126, 173, 173, 262], [264, 264, 357, 357, 1029], [1031, 1031, 1173, 1173, 1529], [1531, 1531, 1586, 1586, 2261]], "test": "untested"}
{"id": "Dtf3W7", "name": "Synthwave starfox", "author": "GetItemFromBlock", "description": "A mod of https://www.shadertoy.com/view/Wt33Wf, which itself is a mod of https://www.shadertoy.com/view/3t3GDB\nEnjoy exploring the synthwave world with your spaceship\nIf the sound is not playing, pause and reset time\nUse arrow keys or mouse click to move", "tags": ["sun", "80s", "retro", "synthwave", "starfox", "fuji", "cineshader"], "likes": 4, "viewed": 1000, "published": 3, "date": "1671820770", "time_retrieved": "2024-07-30T16:11:27.221271", "image_code": "//Music is Koopawave Cove from Badub (https://soundcloud.com/user-746537853/course-8-koopawave-cove)\n\nfloat sun(vec2 uv)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.05 * 1.02) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * 1.05);\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n    \n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n    \n    return min(uniVal1, uniVal2);\n}\n\n#define BarCount 12.\nfloat getMusicLevel(vec2 uv)\n{\n    vec2 delta = (uv/4.+.5) * BarCount;\n    float position = floor(delta.x)/BarCount;\n    float factor = texture(iChannel1, vec2(position, 0)).x + 0.5;\n    if (floor(factor*15.)/15. < delta.y/5.) return 0.;\n    delta.y = delta.y * 3.;\n    vec2 smPos = mod(delta, 1.);\n    smPos = smPos * 2.;\n    if (smPos.x > 1.) smPos.x = 2.-smPos.x;\n    if (smPos.y > 1.) smPos.y = 2.-smPos.y;\n    if (smPos.x < .1 || smPos.y < .2) return 0.;\n    else if (smPos.x > 0.2 && smPos.y > 0.4) return 1.;\n    return pow(clamp(smPos.x*smPos.y,0.,1.),.1);\n}\n\nbool drawShip(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 factor = fragCoord / iResolution.xy * 2. - vec2(1,1);\n    float fov = 70.;\n    vec2 rot = texture(iChannel0, vec2(0.,0.)).xy * -90.;\n    float delta = length(texture(iChannel0, vec2(0.,0.)).zyx);\n    vec3 pos = vec3(-10. - delta * 10., 0., 0.) - texture(iChannel0, vec2(0.,0.)).zyx * 20.;\n    Ray r = Ray(pos, normalize(vec3(1., factor.y * fov / 100., factor.x * fov / 100. * iResolution.x / iResolution.y)) );\n    r.dir = vec3(\n    r.dir.x * cos(radians(rot.y)) - r.dir.y * sin(radians(rot.y)),\n    r.dir.y * cos(radians(rot.y)) + r.dir.x * sin(radians(rot.y)),\n    r.dir.z);\n    r.dir = normalize(vec3(\n    r.dir.x * cos(radians(rot.x)) - r.dir.z * sin(radians(rot.x)),\n    r.dir.y,\n    r.dir.z * cos(radians(rot.x)) + r.dir.x * sin(radians(rot.x))));\n    HitRecord nearest = HitRecord(false, vec2(0,0), r.dir, vec3(0,0,0), vec3(1,1,1), 1e24);\n    vec3 tmpcol = nearest.color;\n    for (int i = 0; i < tris.length(); i++)\n    {\n        HitRecord rec = HitTriangle(r, tris[i], .0, nearest.dist, tmpcol);\n        if (rec.hit && (!nearest.hit || rec.dist < nearest.dist))\n        {\n            nearest = rec;\n        }\n    }\n    if (nearest.hit)\n    {\n        float factor = 0.5 + dot(normalize(vec3(-1,1,.5)),nearest.normal) * 0.5;\n        fragColor = vec4(nearest.color * factor, 1.0);\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    uv = uv + texture(iChannel0,vec2(0.,0.)).xy;\n    if (!drawShip(fragColor, fragCoord))\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.1, 0.2);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv);\n            col = mix(col, vec3(1.0, 0.5, 1.0), gridVal);\n        }\n        else\n        {\n            float fujiD = min(uv.y * 4.5 - 0.5, 1.0);\n            uv.y -= 1.1 - 0.51;\n            \n            vec2 sunUV = uv;\n            vec2 fujiUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.75, 0.2);\n            //uv.y -= 1.1 - 0.51;\n            col = vec3(1.0, 0.2, 1.0);\n            float sunVal = sun(sunUV);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.), col, sunVal);\n            \n            // Music bars\n            float level = getMusicLevel(uv);\n            col = mix(col, vec3(1,0,0), level);\n            \n            // fuji\n            float fujiVal = sdTrapezoid( uv  + vec2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(uv.y * uv.y, 2.1), 0.2, 0.5);\n            float waveVal = uv.y + sin(uv.x * 20.0 + iTime * 2.0) * 0.05 + 0.2;\n            float wave_width = smoothstep(0.0,0.01,(waveVal));\n            \n            // fuji color\n            col = mix( col, mix(vec3(0.0, 0.0, 0.25), vec3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));\n            // fuji top snow\n            col = mix( col, vec3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));\n            // fuji outline\n            col = mix( col, vec3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );\n            //col = mix( col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );\n            //col = vec3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));\n            \n            // horizon color\n            col += mix( col, mix(vec3(1.0, 0.12, 0.8), vec3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );\n            \n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + iTime * 0.1, 4.0) - 2.0;\n            float cloudTime = iTime * 0.5;\n            float cloudY = -0.5;\n            float cloudVal1 = sdCloud(cloudUV, \n                                     vec2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY), \n                                     vec2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY), \n                                     vec2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY), \n                                     vec2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -0.6;\n            float cloudVal2 = sdCloud(cloudUV, \n                                     vec2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY), \n                                     vec2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY), \n                                     vec2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY), \n                                     vec2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);\n            \n            float cloudVal = min(cloudVal1, cloudVal2);\n            \n            //col = mix(col, vec3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));\n            col = mix(col, vec3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));\n            col += vec3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));\n        }\n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.r, col.r) * 0.5, col, 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n    //else fragColor = vec4(0.0);\n\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31645, "src": "https://soundcloud.com/user-746537853/course-8-koopawave-cove", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tmp = fragCoord / iResolution.xy * iChannelResolution[1].xy;\n    ivec2 position = ivec2(int(tmp.x),int(tmp.y));\n    if (position.x == 0 && position.y == 0)\n    {\n        vec3 mov = vec3(texture(iChannel1, vec2(39./256.,0.)).x*iTimeDelta -\n        texture(iChannel1, vec2(37./256.,0.0)).x*iTimeDelta,\n        texture(iChannel1, vec2(38./256.,0.0)).x*iTimeDelta -\n        texture(iChannel1, vec2(40./256.,0.0)).x*iTimeDelta,\n        0);\n        vec2 mousePos = iMouse.xy / iResolution.xy * 2. - 1.;\n        if ((iMouse.z > .5 && iMouse.w < .5))\n        {\n            mov.x = mousePos.x*iTimeDelta;\n            mov.y = mousePos.y*iTimeDelta;\n        }\n        mov.x = mov.x * 1.5;\n        fragColor = texture(iChannel0, vec2(0.,0.))*0.975 + vec4(mov*0.2,1);\n    }\n    else\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct HitRecord\n{\n    bool hit;\n    vec2 UV;\n    vec3 normal;\n    vec3 point;\n    vec3 color;\n    float dist;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Triangle\n{\n    vec3 A, AB, AC;\n    vec3 normal;\n    vec3 color;\n};\n\nHitRecord HitTriangle(Ray r, Triangle tr, float minimum, float maximum, vec3 colorIn)\n{\n\tHitRecord result = HitRecord(false, vec2(0,0), vec3(0,1,0), vec3(0,0,0), vec3(1,1,1), 0.0);\n    vec3 pvec = cross(r.dir, tr.AC);\n    float det = dot(tr.AB, pvec);\n    if (det < 0.00001) return result;\n    vec3 tvec = r.pos - tr.A;\n    result.UV.x = dot(tvec, pvec);\n    if (result.UV.x < .0 || result.UV.x > det) return result;\n    vec3 qvec = cross(tvec, tr.AB);\n    result.UV.y = dot(r.dir, qvec);\n    if (result.UV.y < .0 || result.UV.y + result.UV.x > det) return result;\n    det = 1./det;\n    result.dist = dot(tr.AC, qvec) * det;\n    if (result.dist < minimum || result.dist > maximum) return result;\n    result.UV *= det;\n\tresult.normal = tr.normal;\n\tresult.point = r.pos + r.dir * result.dist;\n    result.color = colorIn * tr.color;\n\tresult.hit = true;\n\treturn result;\n}\n\n// very long, very unoptimized model\nTriangle[] tris = Triangle[] (\nTriangle(vec3(-1.740639,0.263649,-0.447956),vec3(0.064408,-0.592643,0.447956),vec3(0.000000,0.000000,0.895913),vec3(-0.993900,-0.110400,-0.000000),vec3(1.0,0.215861,0.215861)),\nTriangle(vec3(-0.303772,0.664045,-0.000000),vec3(1.570167,-0.593793,0.000000),vec3(-0.456986,-0.394036,-0.300000),vec3(0.173000,0.456100,-0.872900),vec3(0.047274,0.296477,0.800000)),\nTriangle(vec3(-0.760758,0.270010,0.300000),vec3(0.456986,0.394035,-0.300000),vec3(-0.514815,0.212329,-0.300000),vec3(-0.126100,0.693500,0.709300),vec3(0.047274,0.296477,0.800000)),\nTriangle(vec3(-0.303772,0.664045,-0.000000),vec3(-0.456986,-0.394036,-0.300000),vec3(-0.971801,-0.181706,0.000000),vec3(-0.126100,0.693500,-0.709300),vec3(0.047274,0.296477,0.800000)),\nTriangle(vec3(-0.303772,0.664045,-0.000000),vec3(-0.456986,-0.394035,0.300000),vec3(1.570167,-0.593793,0.000000),vec3(0.173000,0.456100,0.872900),vec3(0.047274,0.296477,0.800000)),\nTriangle(vec3(3.168733,-0.300000,-0.000000),vec3(-5.092798,1.098304,0.000000),vec3(-4.168733,0.000000,1.000000),vec3(0.157600,0.732800,0.661900),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.000000,-0.300000,-1.000000),vec3(0.000000,0.000000,2.000000),vec3(-0.924065,1.098304,1.000000),vec3(-0.763700,-0.645600,-0.000000),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.000000,-0.300000,1.000000),vec3(0.000000,0.000000,-2.000000),vec3(4.168733,0.000000,-1.000000),vec3(-0.000000,-1.000000,-0.000000),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.743818,-0.300000,-0.772652),vec3(-0.246623,0.000000,-0.378231),vec3(-0.493364,1.488035,-0.719115),vec3(0.838000,0.015700,-0.545500),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.743818,-0.300000,0.772652),vec3(-0.493364,1.488036,0.719115),vec3(-0.246623,0.000000,0.378231),vec3(0.838000,0.015800,0.545500),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.346018,-0.439340,1.086163),vec3(0.355577,0.139340,0.064720),vec3(0.108836,1.627376,0.405604),vec3(-0.086500,-0.236100,0.967900),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.346019,-0.439340,-1.086163),vec3(0.108837,1.627375,-0.405604),vec3(0.355578,0.139340,-0.064720),vec3(-0.086500,-0.236100,-0.967900),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.237182,1.188035,-1.491767),vec3(-0.108837,-1.627375,0.405604),vec3(0.493364,-1.488035,0.719115),vec3(-0.489500,0.244800,0.836900),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.990441,-0.300000,-1.150883),vec3(0.246623,0.000000,0.378231),vec3(-0.355578,-0.139340,0.064720),vec3(0.323100,-0.922100,-0.212800),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.990441,-0.300000,1.150883),vec3(-0.355577,-0.139340,-0.064720),vec3(0.246623,0.000000,-0.378231),vec3(0.323100,-0.922100,0.212800),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.237182,1.188036,1.491767),vec3(0.493364,-1.488036,-0.719115),vec3(-0.108836,-1.627376,-0.405604),vec3(-0.489500,0.244800,-0.836900),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.582366,-0.288396,-0.530632),vec3(-0.166579,0.139211,0.000000),vec3(-0.000001,-0.527187,-2.703453),vec3(-0.637600,-0.755700,0.149600),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.748945,-0.149185,-0.530632),vec3(1.271236,-0.085085,0.000000),vec3(0.166578,-0.666398,-2.703453),vec3(0.063100,0.969600,-0.236500),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.582366,-0.288396,-0.530632),vec3(-0.000001,-0.527187,-2.703453),vec3(1.104657,0.054126,0.000000),vec3(0.047100,-0.981000,0.188300),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(0.522291,-0.234269,0.530632),vec3(-1.271236,0.085084,0.000000),vec3(-1.104657,-0.581312,2.703453),vec3(0.063100,0.969600,0.236500),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.582366,-0.288396,0.530632),vec3(1.104657,0.054127,0.000000),vec3(0.000000,-0.527185,2.703453),vec3(0.047100,-0.981000,-0.188300),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-0.748945,-0.149185,0.530632),vec3(0.166579,-0.139211,0.000000),vec3(0.166579,-0.666396,2.703453),vec3(-0.637600,-0.755700,-0.149600),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(3.168733,-0.300000,-0.000000),vec3(-4.168733,0.000000,-1.000000),vec3(-5.092798,1.098304,0.000000),vec3(0.157600,0.732800,-0.661900),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.676231,-0.328994,0.000000),vec3(0.360777,0.514515,0.279947),vec3(-0.064408,0.592643,0.447957),vec3(0.205500,-0.577000,0.790500),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.676231,-0.328994,0.000000),vec3(0.596570,0.156257,0.000000),vec3(0.360777,0.514515,0.279947),vec3(0.141200,-0.549100,0.823700),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.315454,0.185521,-0.279947),vec3(-0.360777,-0.514515,0.279947),vec3(-0.425185,0.078128,-0.168009),vec3(0.205500,-0.577100,-0.790400),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.315454,0.185521,-0.279947),vec3(0.235793,-0.358258,0.279947),vec3(-0.360777,-0.514515,0.279947),vec3(0.141200,-0.549100,-0.823700),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.315454,0.185521,0.279947),vec3(-0.425185,0.078128,-0.727903),vec3(-0.425185,0.078128,0.168010),vec3(0.180700,0.983500,-0.000000),vec3(0.494990,0.618285,0.800000)),\nTriangle(vec3(-1.315454,0.185521,0.279947),vec3(0.000000,0.000000,-0.559894),vec3(-0.425185,0.078128,-0.727903),vec3(0.180700,0.983500,-0.000000),vec3(0.494990,0.618285,0.800000)));", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtf3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 122, 122, 416], [418, 418, 439, 439, 718], [720, 720, 744, 744, 763], [765, 765, 830, 830, 1140], [1142, 1142, 1191, 1191, 1310], [1312, 1312, 1349, 1349, 1433], [1435, 1435, 1484, 1484, 1587], [1589, 1589, 1672, 1738, 2342], [2365, 2365, 2395, 2395, 2931], [2933, 2933, 2987, 2987, 4329], [4331, 4331, 4388, 4388, 8214]], "test": "untested"}
{"id": "dts3Wr", "name": "S4", "author": "mla", "description": "The symmetric group S4, but also showing a useful optimization for raytracing cylinders (left v. right), and a strange bug I've noticed on my Pixel 4a Android phone (top v. bottom). Mouse rotates, top left shows exponentially zooming distance.", "tags": ["precision", "bug", "cylinder", "android", "s4"], "likes": 14, "viewed": 261, "published": 3, "date": "1671816448", "time_retrieved": "2024-07-30T16:11:27.992209", "image_code": "////////////////////////////////////////////////////////////////////////\n//\n// S4, mla 2022\n//\n// This shows a representation of S4, the symmetric group on four elements\n// as acting on the diagonals of a cube, but more importantly, shows a\n// useful technique for improving the accuracy of finding ray-cylinder \n// intersections (and also the same for spheres, but we already know about\n// that (eg. see https://www.shadertoy.com/view/WdXfR2 by @fpsunflower).\n// As usual, I doubt if I'm the first to think of this, but I don't think\n// I've seen this trick before.\n//\n// The idea is to adjust the ray start position so as to make the linear\n// term in the quadratic of intersection vanish and the solutions are just\n// of the form ±k√x (the same idea as for the sphere, and just a little more\n// complicated to work out for the cylinder - it should be possible to do this\n// with any quadric, though I haven't tried it).\n//\n// I've also found an apparent bug with GLSL on my Pixel 4a Android phone -\n// it seems that storing the ray and direction in a Ray structure reduces\n// the representation precision (ie. as if highp was being cut down to mediump) -\n// see this in mainImage, line ***, where we round trip p and r through a structure\n// for the lower half of the screen - it would be interesting if any other platforms\n// show this behaviour - I have no idea if this is compliant with the standard but it\n// seems unlikely (the bug still exists with declaring the structure members highp).\n\nbool dorotate = true;\nbool optimize = true;\n\n// Putting p and r in can reduce their precision (eg. on Chrome/Android/Pixel 4a)\nstruct Ray {\n  vec3 p;\n  vec3 r;\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // (unnormalized) normal\n  int id;       // what was hit\n};\n\n// Solve Ax²+2Bx+C = 0 & return smallest root (ie. we are assuming we aren't\n// inside the object).\nbool quadratic(float A, float B, float C, out float x) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   float x0 = (-B-D)/A; // Largest magnitude root\n   float x1 = C/(A*x0);\n   x = min(x0,x1);\n   return true;\n}\n\n// Find intersection of ray p+tr with cylinder radius² = r2 and central axis ±n\n// (ie. so it's centred on the origin).\nbool cylinder(float r2, vec3 n, vec3 p, vec3 r, out float t, out vec3 normal) {\n  float len = length(n);\n  n /= len;\n  float pn = dot(p,n);\n  float rn = dot(r,n);\n  float pr = dot(p,r);\n  float k = 0.0;\n  if (optimize) {\n    // Adjust p so the B term in the quadratic is zero -\n    // then the solution is just ±√(-AC) and we avoid any\n    // cancellation errors due to subtraction from B².\n    k = (pr-pn*rn)/(rn*rn-1.0);\n    p += k*r;\n    float pp = dot(p,p);\n    pn = dot(p,n);\n    float A = 1.0 - rn*rn;\n    float C = pp - pn*pn - r2;\n    float D = -A*C;\n    if (D < 0.0) return false;\n    t = -sqrt(D)/A;\n  } else {\n    float pp = dot(p,p);\n    float A = 1.0 - rn*rn;\n    float B = pr - pn*rn;\n    float C = pp - pn*pn - r2;\n    if (!quadratic(A,B,C,t)) return false;\n  }\n  p += t*r; // Final point in line space\n  float lambda = dot(p,n);\n  if (abs(lambda) > len) return false; // No intersection\n  normal = p-lambda*n;\n  t += k; // Undo adjustment to p.\n  return t >= 0.0;\n}\n\nbool intersectCylinder(float r2, vec3 n, int id, vec3 p, vec3 r, inout Hit hit) {\n  float t;\n  vec3 normal;\n  if (!cylinder(r2,n,p,r,t,normal)) {\n    return false;\n  } else {\n    // Normal is the radial vector of cylinder\n    if (t < hit.t) hit = Hit(t, normal, id);\n    return true;\n  }\n}\n\nbool intersectSphere(float r2, vec3 s, int id, vec3 p, vec3 r, inout Hit hit) {\n  p -= s;\n  float k = 0.0;\n  float t;\n  if (optimize) {\n    k = dot(p,r);\n    p -= k*r;\n    float C = r2-dot(p,p);\n    if (C < 0.0) return false;\n    t = -sqrt(C);\n  } else {\n    float B = dot(p,r);\n    float C = dot(p,p)-r2;\n    float D = B*B - C;\n    if (D < 0.0) return false;\n    D = sqrt(D);\n    if (B < 0.0) D = -D;\n    t = -B-D;\n    float t1 = C/t;\n    t = min(t,t1);\n  }\n  vec3 n = p+t*r;\n  t -= k;\n  if (t < 0.0) return false;\n  if (t < hit.t) hit = Hit(t,n,id);\n  return true;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    p.zx = rotate(p.zx,t * 0.2);\n  }\n  return p;\n}\n\nbool intersectScene(vec3 p, vec3 r, out Hit hit) {\n  hit.t = 1e8;\n  vec3 p0 = vec3(1,1,1), p1 = vec3(1,-1,1);\n  vec3 p2 = vec3(-1,-1,1), p3 = vec3(-1,1,1);\n  float r2 = 0.1*0.1;\n  float s2 = 0.2*0.2;\n  intersectSphere(s2,p0,0,p,r,hit);\n  intersectSphere(s2,-p0,0,p,r,hit);\n  intersectSphere(s2,p1,1,p,r,hit);\n  intersectSphere(s2,-p1,1,p,r,hit);\n  intersectSphere(s2,p2,2,p,r,hit);\n  intersectSphere(s2,-p2,2,p,r,hit);\n  intersectSphere(s2,p3,3,p,r,hit);\n  intersectSphere(s2,-p3,3,p,r,hit);\n  intersectCylinder(r2,p0,4,p,r,hit);\n  intersectCylinder(r2,p1,4,p,r,hit);\n  intersectCylinder(r2,p2,4,p,r,hit);\n  intersectCylinder(r2,p3,4,p,r,hit);\n  return hit.t < 1e8;\n}\n\nvec3 getColor(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(0,1,0);\n  if (i == 2) return vec3(0,0,1);\n  if (i == 3) return vec3(1,1,0);\n  return vec3(1,1,1);\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 solve(vec3 p, vec3 r) {\n  Hit hit;\n  if (!intersectScene(p,r,hit)) {\n    return vec3(0,0,0.1);\n  } else {\n    vec3 n = normalize(hit.n);\n    //if (dot(r.d,n) > 0.0) n = -n;\n    vec3 basecolor = getColor(hit.id);\n    vec3 color = basecolor;\n    color *= ambient+diffuse*max(0.0,dot(light,n));\n    float specular = pow(max(0.0,dot(reflect(light,n),r)),2.0);\n    color += 0.2*specular*vec3(1,1,0);\n    //color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0); //????\n    return color;\n  }\n}\n\nfloat hud(vec2 fragCoord, float x) {\n  // Show the camera distance at top left.\n  const int digits = 7, nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1; // Reverse order of rows\n  if (row != 0 || column != 0) return 0.0;\n  \n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = printfloat(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c > 0) {\n    float charstart = charwidth*float(charpos); // character start\n    uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  }\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  if (c > 0) return t.x;\n  return 0.0;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  optimize = fragCoord.x > 0.5*iResolution.x;\n  vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  float camera = exp2(2.0+mod(iTime,28.0));\n  vec3 p = vec3(0,0,-camera);\n  vec3 r = vec3(uv,0.5*camera);\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  light = vec3(0.5,1,-1);\n  light = transform(light);\n  light = normalize(light);\n  float t = 0.5*iTime;\n  ambient = 0.2;\n  diffuse = 0.6;\n  Ray ray = Ray(p,r);\n  //assert(p == ray.p);\n  //assert(r == ray.r);\n  if (fragCoord.y < 0.5*iResolution.y) {\n    p = ray.p; r = ray.r; // *** Extract p and r from ray - they should be the same\n  }\n  vec3 col = solve(p,r);\n  col = mix(col,vec3(1),hud(fragCoord,camera));\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n  if (alert) fragColor.r = 1.0;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//precision highp float; // Makes no difference on Pixel 4a, nor should it.\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst float PI = 3.14159265;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\nint printfloat(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return 0;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  const int SPACE = 0x20;\n  if (isinf(x)) {\n    if (x < 0.0) CHAR(MINUS);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    if (1.0/x < 0.0) CHAR(MINUS);\n    CHAR(ZERO);\n  } else {\n    if (x < 0.0) CHAR(MINUS) // No semicolon!\n    else CHAR(SPACE);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return 0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dts3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1795, 1896, 1952, 1952, 2157], [2159, 2281, 2360, 2360, 3266], [3268, 3268, 3349, 3349, 3557], [3559, 3559, 3638, 3638, 4127], [4129, 4129, 4156, 4156, 4465], [4467, 4467, 4517, 4517, 5134], [5136, 5136, 5158, 5158, 5318], [5363, 5363, 5391, 5391, 5846], [5848, 5848, 5884, 5927, 7002], [7004, 7004, 7061, 7061, 7839]], "test": "untested"}
{"id": "mts3DN", "name": "less bits effect", "author": "SONENEIS", "description": "nothing here.", "tags": ["raymarching", "ray", "round", "cube", "pixel", "bit", "bit", "dark", "pixelated", "purpple"], "likes": 10, "viewed": 234, "published": 3, "date": "1671807879", "time_retrieved": "2024-07-30T16:11:28.765143", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nconst float pixBits = 32.0;\nconst float colBits = 8.0;\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n  \n  uv = floor(uv * pixBits) / pixBits;\n  \n  {\n    float d = 0.0;\n    for(float i=0.0;i<16.0;i++){\n      vec3 p = vec3(0.0,0.0,3.0) + normalize(vec3(uv*0.6,-2.0)) * d;\n      p.yz *= rot(iTime); p.zx *= rot(iTime); p.xy *= rot(iTime);\n      float h = length(max(abs(p)-0.25,0.0)) - 0.25;\n      d += h;\n      if(h < 0.001 || d > 4.0) break;\n    }\n    if(d < 4.0){\n      vec3 p = vec3(0.0,0.0,3.0) + normalize(vec3(uv,-2.0)) * d;\n      col = vec3(1,1,2) * p.z;\n    }\n  }\n\n  col = floor(col * colBits) / colBits;\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [119, 119, 169, 169, 793]], "test": "untested"}
{"id": "DlsGWN", "name": "Bouncy Ball in a Disk", "author": "oneshade", "description": "An afterthought (+headscratching).", "tags": ["disk", "bouncing"], "likes": 13, "viewed": 198, "published": 3, "date": "1671780668", "time_retrieved": "2024-07-30T16:11:29.504167", "image_code": "#define PI 3.1415926536\n\nmat2 Rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat sdBall(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdVector(in vec2 p, in vec2 v) {\n    return length(p - v * clamp(dot(p, v) / dot(v, v), 0.0, 1.0));\n}\n\nvoid diskBounce(in float r, in vec2 p0, in vec2 v0, in float t, out vec2 pos, out vec2 vel) {\n    float a = dot(v0, v0);\n    float b = dot(p0, v0);\n    float c = dot(p0, p0) - r * r;\n    float dis = b * b - a * c;\n    if (dis >= 0.0 && c <= 0.0) {\n        dis = sqrt(dis);\n        t += (dis + b) / a;\n\n        vec2 hit = p0 + v0 * (dis - b) / a;\n        float reflDelta = 2.0 * asin((p0.y * v0.x - p0.x * v0.y) / (r * sqrt(a))) - PI;\n\n        float pathLen = 2.0 * dis / a;\n        float hitIndex = floor(t / pathLen);\n\n        float angle = reflDelta * hitIndex;\n        vec2 startPos = Rotate2D(angle - reflDelta) * hit;\n        vec2 startVel = Rotate2D(angle) * v0;\n\n        t -= pathLen * hitIndex;\n        pos = startPos + startVel * t, vel = startVel;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float diskSize = 1.5;\n    float ballSize = 0.2;\n    vec2 p0 = vec2( 1.0517140025,  0.7641149501);\n    vec2 v0 = vec2(-2.8531707074, -0.9270474175);\n\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(length(uv) - diskSize)));\n\n    vec2 pos, vel;\n    diskBounce(diskSize - ballSize, p0, v0, iTime, pos, vel);\n\n    uv -= pos;\n    color = mix(color, vec3(0, 0, 1), smoothstep(unit, 0.0, sdVector(uv, 0.25 * vel)));\n    color = mix(color, vec3(1, 0, 0), smoothstep(unit, 0.0, sdBall(uv, ballSize)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 52, 52, 124], [126, 126, 163, 163, 191], [193, 193, 231, 231, 300], [302, 302, 395, 395, 1067], [1069, 1069, 1124, 1124, 1809]], "test": "untested"}
{"id": "mtX3WN", "name": "Bouncy Ball in a Box", "author": "oneshade", "description": "A random realization.", "tags": ["box", "bouncing"], "likes": 16, "viewed": 372, "published": 3, "date": "1671751639", "time_retrieved": "2024-07-30T16:11:30.244188", "image_code": "float sdBall(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdVector(in vec2 p, in vec2 v) {\n    return length(p - v * clamp(dot(p, v) / dot(v, v), 0.0, 1.0));\n}\n\nvoid boxBounce(in vec2 b, in vec2 p0, in vec2 v0, in float t, out vec2 pos, out vec2 vel) {\n     vec2 q = 2.0 * b - mod(p0 + v0 * t + b, 4.0 * b);\n     pos = b - abs(q), vel = v0 * sign(q);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 boxSize = vec2(2.0, 1.5);\n    float ballSize = 0.2;\n    vec2 p0 = vec2(-0.6, -0.4);\n    vec2 v0 = vec2(-2.0, 1.88);\n\n    vec2 q = abs(uv) - boxSize;\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(max(q.x, q.y))));\n\n    vec2 pos, vel;\n    boxBounce(boxSize - ballSize, p0, v0, iTime, pos, vel);\n\n    uv -= pos;\n    color = mix(color, vec3(0, 0, 1), smoothstep(unit, 0.0, sdVector(uv, 0.25 * vel)));\n    color = mix(color, vec3(1, 0, 0), smoothstep(unit, 0.0, sdBall(uv, ballSize)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtX3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 65], [67, 67, 105, 105, 174], [176, 176, 267, 267, 367], [369, 369, 424, 424, 1104]], "test": "untested"}
{"id": "cll3R4", "name": "Path Tracing (Disney BRDF)", "author": "XT95", "description": "What's better than writing a pathtracer!\n\nNext stop : BSDF!", "tags": ["pathtracing", "brdf", "pbr", "ggx", "disney"], "likes": 99, "viewed": 3674, "published": 3, "date": "1671750507", "time_retrieved": "2024-07-30T16:11:31.188663", "image_code": "// ----------------------------------------------------------------\n// Path Tracing (Disney BRDF)\n// ----------------------------------------------------------------\n//\n// This is not optimized, I tried to keep it clear.\n// The BRDF has only the diffuse and specular parts (isotropic)\n// for now but others parameters should be easy to implement at\n// this point.\n// \n// I'm not sure about the pdf part, but I think it's ok.\n// If you want to give me some feedback about that you are welcome:)\n//\n//\n// You can move the camera with the mouse\n// and zoom in/out with 'w' and 's'.\n//\n// - Buffer A : Draw a raw frame\n// - Buffer B : Accumulate frame\n//              You can change the mode to get TAAish output\n// - Image : Basic ACES tonemapping\n// ----------------------------------------------------------------\n\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    #if !FURNACE_TEST\n    col = ACES(col);\n    #endif\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ----------------------------------------------------------------\n// Defines\n// ----------------------------------------------------------------\n// - Scene can go from 0 to 2\n// - The furnace_test show the energy loss, the image should be\n//   all white in a perfect pathtracer\n//   \n// ----------------------------------------------------------------\n#define SCENE 0\n#define FURNACE_TEST 0\n#define CAMERA_SENSITIVTY .01\n#define FOCAL_LENGTH 2.5\n\n\n// ---------------------------------------------\n// Hash & Random\n// From iq\n// ---------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(rand())/32767.0; }\nvec2 frand2() { return vec2(frand(), frand()); }\nvec3 frand3() { return vec3(frand(), frand(), frand()); }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(floatBitsToUint(p));\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Maths\n// ---------------------------------------------\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n\nmat3 lookat(vec3 ro, vec3 ta)\n{\n    const vec3 up = vec3(0.,1.,0.);\n    vec3 fw = normalize(ta-ro);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,b,-b,a);\n}\n\n// From fizzer - https://web.archive.org/web/20170610002747/http://amietia.com/lambertnotangent.html\nvec3 cosineSampleHemisphere(vec3 n)\n{\n    vec2 rnd = frand2();\n\n    float a = PI*2.*rnd.x;\n    float b = 2.0*rnd.y-1.0;\n    \n    vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(n + dir);\n}\n\n// From pixar - https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.z<0.){\n        float a = 1.0 / (1.0 - n.z);\n        float b = n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, -b, n.x);\n        b2 = vec3(b, n.y * n.y*a - 1.0, -n.y);\n    }\n    else{\n        float a = 1.0 / (1.0 + n.z);\n        float b = -n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n        b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    }\n}\n\nvec3 toWorld(vec3 x, vec3 y, vec3 z, vec3 v)\n{\n    return v.x*x + v.y*y + v.z*z;\n}\n\nvec3 toLocal(vec3 x, vec3 y, vec3 z, vec3 v)\n{\n    return vec3(dot(v, x), dot(v, y), dot(v, z));\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Color\n// ---------------------------------------------\nvec3 RGBToYCoCg(vec3 rgb)\n{\n\tfloat y  = dot(rgb, vec3(  1, 2,  1 )) * 0.25;\n\tfloat co = dot(rgb, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat cg = dot(rgb, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(y, co, cg);\n}\n\nvec3 YCoCgToRGB(vec3 ycocg)\n{\n\tfloat y = ycocg.x;\n\tfloat co = ycocg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat cg = ycocg.z - ( 0.5 * 256.0 / 255.0 );\n\treturn vec3(y + co-cg, y + cg, y - co-cg);\n}\n\nfloat luma(vec3 color) {\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Microfacet\n// ---------------------------------------------\nvec3 F_Schlick(vec3 f0, float theta) {\n    return f0 + (1.-f0) * pow(1.0-theta, 5.);\n}\n\nfloat F_Schlick(float f0, float f90, float theta) {\n    return f0 + (f90 - f0) * pow(1.0-theta, 5.0);\n}\n\nfloat D_GTR(float roughness, float NoH, float k) {\n    float a2 = pow(roughness, 2.);\n    return a2 / (PI * pow((NoH*NoH)*(a2*a2-1.)+1., k));\n}\n\nfloat SmithG(float NDotV, float alphaG)\n{\n    float a = alphaG * alphaG;\n    float b = NDotV * NDotV;\n    return (2.0 * NDotV) / (NDotV + sqrt(a + b - a * b));\n}\n\nfloat GeometryTerm(float NoL, float NoV, float roughness)\n{\n    float a2 = roughness*roughness;\n    float G1 = SmithG(NoV, a2);\n    float G2 = SmithG(NoL, a2);\n    return G1*G2;\n}\n\nvec3 SampleGGXVNDF(vec3 V, float ax, float ay, float r1, float r2)\n{\n    vec3 Vh = normalize(vec3(ax * V.x, ay * V.y, V.z));\n\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1, 0, 0);\n    vec3 T2 = cross(Vh, T1);\n\n    float r = sqrt(r1);\n    float phi = 2.0 * PI * r2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n    return normalize(vec3(ax * Nh.x, ay * Nh.y, max(0.0, Nh.z)));\n}\n\nfloat GGXVNDFPdf(float NoH, float NoV, float roughness)\n{\n \tfloat D = D_GTR(roughness, NoH, 2.);\n    float G1 = SmithG(NoV, roughness*roughness);\n    return (D * G1) / max(0.00001, 4.0f * NoV);\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Sky simulation\n// ---------------------------------------------\nfloat iSphere(vec3 ro, vec3 rd, float radius) {\n    float b = 2.0 * dot(rd, ro);\n    float c = dot( ro, ro ) - radius * radius;\n    float disc = b * b - 4.0 * c;\n    if (disc < 0.0)\n        return (-1.0);\n    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;\n    float t0 = q;\n    float t1 = c / q;\n    return max(t0,t1);//vec2(t0,t1);\n}\n\nvec3 skyColor(vec3 rd, vec3 sundir)\n{\n#if FURNACE_TEST\n    return vec3(1.);\n#endif\n    rd.y = max(rd.y, .03);\n    const int nbSamples = 16;\n    const int nbSamplesLight = 16;\n    \n    vec3 absR = vec3(3.8e-6f, 13.5e-6f, 33.1e-6f);\n    vec3 absM = vec3(21e-6f);\n    \n    \n    vec3 accR = vec3(0.);\n    vec3 accM = vec3(0.);\n    \n    float mu = dot(rd, sundir); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction \n    float g = 0.76f; \n    vec2 phase = vec2(3.f / (16.f * PI) * (1. + mu * mu), 3.f / (8.f * PI) * ((1.f - g * g) * (1.f + mu * mu)) / ((2.f + g * g) * pow(1.f + g * g - 2.f * g * mu, 1.5f)));\n\n    float radA = 6420e3;\n    float radE = 6360e3;\n    vec3 ro = vec3(0., radE+1., 0.);\n    float t = iSphere(ro, rd, radA);\n    float stepSize = t / float(nbSamples);\n    \n    vec2 opticalDepth = vec2(0.);\n    \n    for(int i=0; i<nbSamples; i++) {\n     \tvec3 p = ro + rd * (float(i)+.5) * stepSize;\n        \n        float h = length(p) - radE;\n        vec2 thickness = vec2(exp(-h/7994.), exp(-h/1200.)) * stepSize;\n        opticalDepth += thickness;\n        \n        float tl = iSphere(p, sundir, radA);\n        float stepSizeLight = tl / float(nbSamplesLight);\n        vec2 opticalDepthLight = vec2(0.);\n        int j;\n        for(j=0; j<nbSamplesLight; j++) {\n            vec3 pl = p + sundir * (float(j)+.5) * stepSizeLight;\n            float hl = length(pl) - radE;\n            if (hl < 0.) break;\n        \topticalDepthLight += vec2(exp(-hl/7994.), exp(-hl/1200.)) * stepSizeLight;\n        }\n        if (j == nbSamplesLight) {\n            vec3 tau = absR * (opticalDepth.x + opticalDepthLight.x) + absM * 1.1 * (opticalDepth.y + opticalDepthLight.y);\n            vec3 att = exp(-tau);\n            accR += att * thickness.x ;\n            accM += att * thickness.y;\n        }\n    }\n    \n    vec3 col = min((accR * absR * phase.x + accM * absM * phase.y)*10., vec3(1.));\n    return col;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Data IO\n// ---------------------------------------------\nstruct Data {\n    float theta;\n    float phi;\n    float r;\n    \n    vec3 ro;\n    vec3 ta;\n    \n    vec3 oldRo;\n    vec3 oldTa;\n    \n    vec4 oldMouse;\n    \n    float refreshTime;\n};\n\nfloat readData1(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).r;\n}\nvec3 readData3(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).rgb;\n}\nvec4 readData4(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0);\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, float value) {\n    if (floor(fragCoord.x) == float(id))\n        col.r = value;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec3 value) {\n    if (floor(fragCoord.x) == float(id))\n        col.rgb = value.rgb;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec4 value) {\n    if (floor(fragCoord.x) == float(id))\n        col = value;\n        \n    return col;\n}\nData initData() {\n\tData data;\n    \n    data.theta = PI;\n    data.phi = 1.;\n    data.r = 9.;\n    \n    data.ro = normalize(vec3(cos(data.theta), data.phi, sin(data.theta)))*data.r;\n    data.ta = vec3(0.,0.5,0.);\n    \n    data.oldRo = data.ro;\n    data.oldTa = data.ta;\n    \n    data.oldMouse = vec4(0.);\n    \n    data.refreshTime = 0.;\n    \n    return data;\n}\nData readData(sampler2D tex, vec2 invRes) {\n\tData data;\n    \n    data.theta = readData1(tex, 0);\n    data.phi = readData1(tex, 1);\n    data.r = readData1(tex, 2);\n    \n    data.ro = readData3(tex, 3);\n    data.ta = readData3(tex, 4);\n    \n    data.oldRo = readData3(tex, 5);\n    data.oldTa = readData3(tex, 6);\n    \n    data.oldMouse = readData4(tex, 7);\n    data.refreshTime = readData1(tex, 8);\n    data.ta = vec3(0.,0.5,0.);\n    \n    return data;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, Data data) {\n    col = writeData(col, fragCoord.xy, 0, data.theta);\n    col = writeData(col, fragCoord.xy, 1, data.phi);\n    col = writeData(col, fragCoord.xy, 2, data.r);\n    col = writeData(col, fragCoord.xy, 3, data.ro);\n    col = writeData(col, fragCoord.xy, 4, data.ta);\n    col = writeData(col, fragCoord.xy, 5, data.oldRo);\n    col = writeData(col, fragCoord.xy, 6, data.oldTa);\n    col = writeData(col, fragCoord.xy, 7, data.oldMouse);\n    col = writeData(col, fragCoord.xy, 8, data.refreshTime);\n    return col;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Distance field \n// ---------------------------------------------\nfloat box( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p) {\n\n        float d = 99999.;\n    \n    #if SCENE == 0\n        vec3 pp = p;\n        p.xz = mod(p.zx,1.)-.5;\n        d = min(d, length(p-vec3(0.,.4,0.))-.4);\n        //d = min(d, sheep(p*8.)/8.);\n        d = max(d, abs(pp.z)-5.);\n        d = max(d, abs(pp.x)-3.);\n    #endif\n    \n    #if SCENE == 1\n        vec3 pp = p;\n        p.xz = mod(p.zx,1.)-.5;\n        //p.xz = rot(p.y*.5)*p.xz;\n        d = min(d, box(p-vec3(0.,.4,0.),vec3(.4)));\n        //d = min(d, sheep(p*8.)/8.);\n        d = max(d, abs(pp.z)-5.);\n        d = max(d, abs(pp.x)-3.);\n    #endif\n    \n    #if SCENE == 2\n    {\n        vec3 ip = floor(p);\n        vec3 fp = fract(p)-.5;\n\n        vec3 id = hash3(ip+1000.);\n        fp.y = p.y-.2;\n        fp.xy = rot(id.x*PI*3.) * fp.xy;\n        fp.xz = rot(id.y*PI*3.) * fp.xz;\n        fp.yz = rot(id.z*PI*3.) * fp.yz;\n        d = min(d, box(fp,vec3(.3)));\n        d = max(d, abs(p.z)-5.);\n        d = max(d, abs(p.x)-3.);\n        \n    }\n    #endif\n    \n    #if !FURNACE_TEST\n        d = min(d, p.y);\n    #endif\n    return d;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Ray tracing \n// ---------------------------------------------\nfloat trace(vec3 ro, vec3 rd, vec2 nf) {\n    float t = nf.x;\n    for(int i=0; i<256; i++) {\n        float d = map(ro+rd*t);\n        if (t > nf.y || abs(d)<0.001) break;\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 normal(vec3 p, float t) {\n    vec2 eps = vec2(0.0001,0.0);\n    float d = map(p);\n    vec3 n;\n    n.x = d - map(p - eps.xyy);\n    n.y = d - map(p - eps.yxy);\n    n.z = d - map(p - eps.yyx);\n    n = normalize(n);\n    return n;\n}\n", "buffer_a_code": "// ---------------------------------------------\n// Raw Frame\n// ---------------------------------------------\n#define sundir normalize( vec3(5.,1.,0.))\n\n\n// ---------------------------------------------\n// Material\n// ---------------------------------------------\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 emissive;\n};\nMaterial newMaterial() {\n    Material mat;\n    mat.albedo = vec3(1.);\n    mat.metallic = 0.;\n    mat.roughness = .1;\n    mat.emissive = vec3(0.);\n    \n    return mat;\n}\nMaterial getMaterial(vec3 p, inout vec3 n) {\n    \n    Material mat = newMaterial();\n        \n    #if 1 // Random materials\n        if (abs(map(p)-p.y) > 0.001) {\n            vec3 rnd = hash3(floor(p+1000.));\n            mat.roughness = rnd.y*rnd.y;\n            mat.metallic = rnd.x;\n            mat.albedo = hash3(floor(p))*.75;\n            mat.emissive = mat.albedo*step(rnd.y,.02);\n        } else {\n            mat.metallic = 1.;\n            mat.roughness = .5;\n        }\n    #else // Roughness/Metallic axis\n        if (abs(map(p)-p.y) > 0.001) {\n            mat.roughness = pow(floor(p.z+5.)/9.,1.)*.99+0.01;\n            mat.metallic = saturate(floor(p.x+3.)/5.);\n            mat.albedo = vec3(1.);\n        } else {\n            mat.metallic = 1.;\n            mat.roughness = mod(floor(p.x)+floor(p.z),2.)*.25+.25;\n        }\n    #endif\n    \n    \n    #if FURNACE_TEST // Set it in the common tab\n        mat.albedo = vec3(1.);\n        mat.roughness = pow(floor(p.z+5.)/9.,1.)*.99+0.01;\n        mat.metallic = saturate(floor(p.x+3.)/5.);\n        mat.emissive = vec3(0.);\n    #endif\n    \n    return mat;\n}\n\n\n\n// ---------------------------------------------\n// BRDF\n// ---------------------------------------------\nvec3 evalDisneyDiffuse(Material mat, float NoL, float NoV, float LoH, float roughness) {\n    float FD90 = 0.5 + 2. * roughness * pow(LoH,2.);\n    float a = F_Schlick(1.,FD90, NoL);\n    float b = F_Schlick(1.,FD90, NoV);\n    \n    return mat.albedo * (a * b / PI);\n}\n\nvec3 evalDisneySpecular(Material mat, vec3 F, float NoH, float NoV, float NoL) {\n    float roughness = pow(mat.roughness, 2.);\n    float D = D_GTR(roughness, NoH,2.);\n    float G = GeometryTerm(NoL, NoV, pow(0.5+mat.roughness*.5,2.));\n\n    vec3 spec = D*F*G / (4. * NoL * NoV);\n    \n    return spec;\n}\n\nvec4 sampleDisneyBRDF(vec3 v, vec3 n, Material mat, inout vec3 l) {\n    \n    float roughness = pow(mat.roughness, 2.);\n\n    // sample microfacet normal\n    vec3 t,b;\n    basis(n,t,b);\n    vec3 V = toLocal(t,b,n,v);\n    vec3 h = SampleGGXVNDF(V, roughness,roughness, frand(), frand());\n    if (h.z < 0.0)\n        h = -h;\n    h = toWorld(t,b,n,h);\n\n    // fresnel\n    vec3 f0 = mix(vec3(0.04), mat.albedo, mat.metallic);\n    vec3 F = F_Schlick(f0, dot(v,h));\n    \n    // lobe weight probability\n    float diffW = (1.-mat.metallic);\n    float specW = luma(F);\n    float invW = 1./(diffW + specW);\n    diffW *= invW;\n    specW *= invW;\n    \n    \n    vec4 brdf = vec4(0.);\n    float rnd = frand();\n    if (rnd < diffW) // diffuse\n    {\n        l = cosineSampleHemisphere(n);\n        h = normalize(l+v);\n        \n        float NoL = dot(n,l);\n        float NoV = dot(n,v);\n        if ( NoL <= 0. || NoV <= 0. ) { return vec4(0.); }\n        float LoH = dot(l,h);\n        float pdf = NoL/PI;\n        \n        vec3 diff = evalDisneyDiffuse(mat, NoL, NoV, LoH, roughness) * (1.-F);\n        brdf.rgb = diff * NoL;\n        brdf.a = diffW * pdf;\n    } \n    else // specular\n    {\n        l = reflect(-v,h);\n        \n        float NoL = dot(n,l);\n        float NoV = dot(n,v);\n        if ( NoL <= 0. || NoV <= 0. ) { return vec4(0.); }\n        float NoH = min(dot(n,h),.99);\n        float pdf = GGXVNDFPdf(NoH, NoV, roughness);\n        \n        vec3 spec = evalDisneySpecular(mat, F, NoH, NoV, NoL);\n        brdf.rgb = spec * NoL;\n        brdf.a = specW * pdf;\n    }\n\n    return brdf;\n}\n\n\n// ---------------------------------------------\n// Pathtrace\n// ---------------------------------------------\nvec4 pathtrace(vec3 ro, vec3 rd) {\n    \n    float firstDepth = 0.;\n    vec3 acc = vec3(0.);\n    vec3 abso = vec3(1.);\n    \n    const int BOUNCE_COUNT = 6;\n    for(int i=0; i<BOUNCE_COUNT; i++) {\n        \n        // raytrace\n        float t = trace(ro,rd, vec2(0.01, 1000.));\n        vec3 p = ro + rd * t;\n        if (i == 0) firstDepth = t;\n        \n        // sky intersection ?\n        if (t > 1000.) {\n            acc += skyColor(rd, sundir) * abso;\n            break;\n        }\n        \n        // info at intersection point\n        vec3 n = normal(p, t);\n        vec3 v = -rd;\n        Material mat = getMaterial(p,n);\n        \n        // sample BRDF\n        vec3 outDir;\n        vec4 brdf = sampleDisneyBRDF(v,n, mat, outDir);\n        \n        // add emissive part of the current material\n        acc += mat.emissive * abso;\n        \n        // absorption (pdf are in brdf.a)\n        if (brdf.a > 0.)\n            abso *= brdf.rgb / brdf.a;\n        \n        // next direction\n        ro = p+n*0.01;\n        rd = outDir;\n    }\n\n    return vec4(acc, firstDepth);\n}\n\n\n// ---------------------------------------------\n// Entrypoint\n// ---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    srand(ivec2(fragCoord), iFrame);\n    \n    // read data\n    Data data = readData(iChannel1, invRes);\n    if (iFrame == 0) data = initData();\n    \n    // setup ray\n    vec2 uv = (fragCoord + vec2(frand(), frand())-.5) * invRes;\n    vec3 ro = data.ro;\n    vec2 v = uv*2.-1.;\n    v.x *= iResolution.x * invRes.y;\n    vec3 rd = lookat(data.ro, data.ta) * normalize(vec3(v,FOCAL_LENGTH));\n    \n    // pathtrace\n    vec4 col = pathtrace(ro, rd);\n    \n    // fog\n    col.rgb = mix(col.rgb, skyColor(rd,sundir), 1.-exp(-col.a*0.001));\n\n    \n    fragColor = vec4(min(col.rgb, 10.), col.a > 1000. ? -1. : col.a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------\n// - Camera/data IO + Frames accumulation\n//\n//\n// MODE 0 - Raw frame\n// MODE 1 - Accumulate frames\n// MODE 2 - Temporal reprojection\n// ---------------------------------------------\n#define MODE 1\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 seed = hash3(vec3(fragCoord.xy, float((iFrame+1) % 10000)));\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = (fragCoord + seed.xy-.5) * invRes;\n    \n    // read input buffer\n    vec2 rawUv = fragCoord*invRes;\n    vec4 rawCol = texture(iChannel1, rawUv);\n    vec4 col = rawCol;\n    \n    // read data\n    bool needRefresh = false;\n    Data data = readData(iChannel0, invRes);\n    if (iFrame == 0) data = initData();\n    \n    // camera\n    if (iMouse.zw == data.oldMouse.zw) {\n        data.theta += (data.oldMouse.x - iMouse.x)  * CAMERA_SENSITIVTY;\n        data.phi += (data.oldMouse.y - iMouse.y)  * CAMERA_SENSITIVTY;\n        if (texelFetch( iChannel2, ivec2(87,0), 0 ).x > 0.) { // w\n            data.r *= 1.-CAMERA_SENSITIVTY;\n            needRefresh = true;\n        }\n        if (texelFetch( iChannel2, ivec2(83,0), 0 ).x > 0.) { // s\n            data.r *= 1.+CAMERA_SENSITIVTY;\n            needRefresh = true;\n        }\n        if (texelFetch( iChannel2, ivec2(32,0), 0 ).x > 0.) { // space\n            needRefresh = true;\n        }\n        if (iMouse.z > .5)\n            needRefresh = true;\n    }\n    data.phi = clamp(data.phi, 0.01, 3.);\n    \n    data.ro = normalize(vec3(cos(data.theta), data.phi, sin(data.theta)))*data.r;\n    data.ta = vec3(0.,0.5,0.);\n    \n    \n    // MODE 1 - accumulate frame\n    #if MODE == 1\n    vec4 lastCol = texture(iChannel0, fragCoord*invRes);\n    if (!needRefresh) {\n        float w = 1. / (float(iFrame)-data.refreshTime + 1.);\n        col = lastCol*(1.-w) + col * w;\n    }\n    else {\n        data.refreshTime = float(iFrame);\n    }\n    #endif\n    \n    // MODE 2 - temporal reprojection\n    #if MODE == 2\n    if (col.a > 0.) {\n        // reconstruct world space position\n        vec3 ro = data.ro;\n        vec2 v = uv*2.-1.;\n        v.x *= iResolution.x * invRes.y;\n        vec3 rd = lookat(data.ro, data.ta) * normalize(vec3(v,FOCAL_LENGTH));\n        float t = rawCol.a;\n        vec3 p = ro + rd * t;\n        \n        // reprojection\n        mat3 oldCam = lookat(data.oldRo, data.oldTa);\n        mat3x4 invOldCam = mat3x4( vec4( oldCam[0], -dot(oldCam[0],data.oldRo) ),\n                                   vec4( oldCam[1], -dot(oldCam[1],data.oldRo) ),\n                                   vec4( oldCam[2], -dot(oldCam[2],data.oldRo) ));\n        vec4 wpos = vec4(p,1.0);\n        vec3 cpos = wpos*invOldCam;\n        vec2 npos = FOCAL_LENGTH*cpos.xy/cpos.z;\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0) - (seed.xy-.5)*invRes;\n        vec2 rpos = spos * iResolution.xy;\n        vec4 lastCol = texture(iChannel0, spos);\n\n        float w = .0;\n        vec3 oldRd = lookat(data.oldRo, data.oldTa) * normalize(vec3(v,FOCAL_LENGTH));\n        vec3 oldwp = data.oldRo + oldRd * lastCol.w;\n\n        // depth rejection\n        for(int x=-1; x<=1; x++){\n            for(int y=-1; y<=1; y++){\n                float lastT = texture(iChannel0, spos + vec2(x, y) * invRes).a;\n                w = max(w, smoothstep(t*t*.005,0.,abs(t-lastT)));\n            }\n        }\n        w -= 0.02;\n        \n        // color clamping\n        #if 1\n        const int kernelSize = 2;\n        vec3 minCol = vec3(99999.);\n        vec3 maxCol = vec3(0.);\n        for(int x=-kernelSize; x<=kernelSize; x++){\n            for(int y=-kernelSize; y<=kernelSize; y++){\n                vec4 c = texture(iChannel1, spos + vec2(x, y) * invRes);\n                c.rgb = RGBToYCoCg(c.rgb);\n                minCol = min(minCol, c.rgb);\n                maxCol = max(maxCol, c.rgb);\n            }\n        }\n        lastCol.rgb = RGBToYCoCg(lastCol.rgb);\n        lastCol.rgb = clamp(lastCol.rgb, minCol, maxCol);\n        lastCol.rgb = YCoCgToRGB(lastCol.rgb);\n        #endif\n\n        //w = 0.99;\n        if (rpos.x < 7. && rpos.y < 1.) w = 0.;\n        if (abs(spos.x-.5) > .5) w = 0.;\n        if (abs(spos.y-.5) > .5) w = 0.;\n        \n        if (iFrame > 1)\n            col = mix(col, lastCol, saturate(w));\n    }\n    #endif\n   \n    \n    // write data\n    data.oldRo = data.ro;\n    data.oldTa = data.oldTa;\n    data.oldMouse = iMouse;\n    if (fragCoord.y < 1.)\n    col = writeData(col, fragCoord, data);\n    \n    // output pixel color\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cll3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[814, 814, 839, 839, 1025], [1027, 1027, 1084, 1084, 1283]], "test": "untested"}
{"id": "NldSW7", "name": "DnB corridor", "author": "z0rg", "description": "Some old never published visuals I did that I used for some VJ sets.", "tags": ["dark", "dnb", "boomboom"], "likes": 17, "viewed": 488, "published": 3, "date": "1671733338", "time_retrieved": "2024-07-30T16:11:32.067313", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n#define FFT(a) pow(texelFetch(iChannel2, ivec2(a, 0), 0).x, 5.)\n\nfloat _time;\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nvec2 _max(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\n\nvec2 map(vec3 p)\n{\nfloat ttunnel = _time*55.;\nvec3 po = p;\n    p.zy += vec2(_time*.5,0.);\n//return vec2(length(p)-.5, 0.);\n    vec2 acc = vec2(1000., -1.);\n    acc = _min(acc, vec2(-p.y\n    +sin(p.x+p.z-_time)*.1+0.025*sin((p.x-p.z*.5)*3.-_time*4.5)\n    +0.015*sin((p.x+p.z)*12.3+_time)\n    +0.01*sin((p.x-p.z)*9.+_time)*sin(p.x*5.)\n    , 0.));\n    p.zy += vec2(ttunnel*.5,0.);\n    float offWall = .2*(1.-sat(pow(texture(iChannel1, p.zy*.1).z, 5.)));\n    acc = _min(acc, vec2(-(abs(p.x)-1.-offWall), 1.));\n    acc = _max(acc, vec2(abs(po.z)-20., 0.));\n    \n    vec3 cpos = po-vec3(0,-1.+sin(_time),-5.);\n    cpos.zy*=r2d(_time);\n    cpos.xz*= r2d(_time*.5);\n    acc = _min(acc, vec2(_cube(cpos, vec3(.5)), 2.));\n    \n    return acc;\n}\n\nvec3 _norm(float d, vec3 p)\n{\n    return normalize(-cross(dFdx(p), dFdy(p)));\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x<0.001)\n            return vec3(res.x, distance(ro, p), res.y);\n        p+= rd * res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 2.5;\n    if (mod(iTime, 5.) < 2.)\n        fov += 5.5;\n    if (mod(iTime, 10.) < 5.)\n        fov *= .2;\n    fov -= FFT(10)*.5;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(1.);\n    \n    float dist = mix(-20., -15., mod(_time, 5.)/5.+FFT(10));\n    vec3 ro = vec3(sin(iTime+3.1415),-6.+sin(_time)*5.,dist);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    rd.xy *= r2d(sin(_time+FFT(15)*5.)*.25);\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd * res.y;\n        vec3 n = _norm(res.x, p);\n        \n        //col = n*.5+.5;\n        \n        if (res.z == 0.)\n        {\n            col = vec3(.05);\n            n.xz += 0.2*texture(iChannel0, p.xz*.1+_time*.025*vec2(1.,-1.)).x+.1*sin((p.x+p.z*.3)*8.+_time)+.1*sin(p.z*8.33-pow(abs(p.x)-.2, 5.)*10.)+.25*sin(_time+length((p.xz-vec2(0.,20.))*2.));\n            n = normalize(n);\n            col += pow(sat(-dot(normalize(vec3(0.,1.,1.)-rd), n)), 250.05)*vec3(.5)*length(uv*5.);\n        }\n        if (res.z == 1.)\n        {\n            col = vec3(.05);\n            col *= texture(iChannel0, p.zy*vec2(.01,2.)).xxx;\n            col += mix(vec3(0.), .15*texture(iChannel1, p.zy*.1*vec2(5.,1.)-vec2(-_time*.2, 0.)+sin((n.x+p.y+p.x)*3.+_time*.3)).xxx, \n            texture(iChannel0, p.zy*vec2(.1,1.)*.5).x);\n            col +=.1*texture(iChannel1, p.zy*vec2(1.,1.)*.5-vec2(-_time*.25,0.)).xyz;\n            \n        }\n        if (res.z == 2.)\n        {\n            col = vec3(0.0);\n            \n            col += (n*.5+.5)*pow(1.-sat(-dot(n, rd)), 5.);\n            //col = n*.5+.5;\n        }\n       col += vec3(.5)*pow(1.-sat(-dot(rd, n)), 5.);\n       col = sat(col);\n       col += pow(1.-sat(lenny(uv-vec2(0.,.15))), 3.)*1.2;\n       if (res.z == 1.)\n       {\n           col *= sat(pow(sat(-p.y*.25), .5)+.4);\n       }\n    }\n    \n    float waves = sin((uv.x+uv.y)*55.);\n     \n     float flicker = 0.1;\n     col = mix(col, 1.-col, sat(waves*400.)*pow(FFT(50),.25)*sat(length(uv*.25)));\n    return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n    vec2 dir = normalize(vec2(1.,1.));\n    float strength = 0.03*FFT(20);\n    vec3 col;\n    col.r = rdr(uv+dir*strength).r;\n    col.g = rdr(uv).g;\n    col.b = rdr(uv-dir*strength).b;\n    col *= mix(vec3(1.), vec3(0.180,1.000,0.863), sat(length(uv)*1.5-.3)*sat((sin(-iTime*5.+(uv.y-uv.x)*50.)-.9)*400.));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _time = iTime;//+texture(iChannel3, fragCoord/8.).x*.1;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr2(uv);\n    col *= mix(vec3(0.5), vec3(1.), 1.-sat(lenny(uv*1.5)));\n    col = pow(col, vec3(1.2));\n    float flicker = 1./12.;\n    float flickperiod = 2.;\n    col = mix(col, 1.-col, FFT(125)*float(mod(iTime, flickperiod)<.5)*sat(mod(iTime, flicker)/flicker));\n    col = mix(fwidth(col)*10., col, sat((sin(iTime*.5)+.8)*400.));\n   \n    col = mix(col, col.zxy*vec3(.1,.1,.3)*8., sat(sin(iTime*.25)*400.));\n    col = col * 2.*vec3(sat((sin(iTime*.25)*.5+.5)+.5)*.5,texture(iChannel0, vec2(iTime*.05)).x, .5); \n    col *= sat(pow(FFT(10)+.3,5.)+.5)*2.;\n    fragColor = vec4(2.*mix(col, col.xxx, .5)*mix(vec3(.1,.45,.23), vec3(0.541,1.000,0.992), sat(length(uv))),1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31622, "src": "https://soundcloud.com/stylesofbeyond/subculture-1?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldSW7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 448, 448, 506], [585, 585, 612, 612, 665], [666, 666, 693, 693, 746], [748, 748, 777, 777, 838], [841, 841, 859, 859, 1575], [1577, 1577, 1606, 1606, 1768], [1770, 1770, 1811, 1811, 2032], [2034, 2034, 2065, 2065, 2344], [2346, 2346, 2367, 2367, 2399], [2401, 2401, 2420, 2420, 4291], [4293, 4293, 4313, 4313, 4635], [4638, 4638, 4695, 4695, 5506]], "test": "untested"}
{"id": "sdjBWK", "name": "forked Voronoi Clicker", "author": "dreness", "description": "Click to add another point to the voronoi diagram", "tags": ["voronoi", "mouse", "buffer"], "likes": 3, "viewed": 220, "published": 3, "date": "1671725964", "time_retrieved": "2024-07-30T16:11:33.586253", "image_code": "// Fork of \"Voronoi Clicker\" by lwswl. https://shadertoy.com/view/NdjBWV\n// 2022-03-13 02:46:38\n\nvoid mainImage( out vec4 N, in vec2 D )\n{\n    vec2 uv = D/iResolution.xy;\n    N=texture(iChannel0,uv);\n    N=sqrt(N);\n    N-=0.01;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define buf(c) texture(iChannel0,(co+c)/iResolution.xy)\n\nvec4 d(vec2 c, vec2 co) {\n    return texture(iChannel0,(co+c)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 col, in vec2 co )\n{\n    col = vec4(0);\n    if(iFrame==0)col=vec4(0,0,0,1);\n    if(iMouse.z>0.)col+=.5/dot(co-iMouse.xy,co-iMouse.xy);\n    for(float i=-2.;i<=2.;i++)\n    for(float j=-2.;j<=2.;j++){\n        col=max(col,exp(-0.01*sqrt(i*i+j*j))*d(vec2(i,j), co));\n        \n    }\n    col=min(0.*col*1.4,col-1.);\n    col+=.997;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 138, 138, 229]], "test": "untested"}
{"id": "clfGW8", "name": "Rainbow Spiral [226 chars]", "author": "kishimisu", "description": "It sometimes synchs up to beautiful patterns", "tags": ["colorful", "code", "rotation", "neon", "short", "golf", "golfing"], "likes": 45, "viewed": 1244, "published": 3, "date": "1671718783", "time_retrieved": "2024-07-30T16:11:34.489836", "image_code": "/* \"Rainbow Spiral\" by @kishimisu (2022) - https://www.shadertoy.com/view/clfGW8 \n   [226 chars] */\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2 r = iResolution.xy;\n    float i = .3, l = length(F+=F-r)/r.y + i, t = iTime;\n\n    for (O *= 0.; i < 12.; \n         O += length(min(r.y/abs(F),r))/3e2*(cos(++t+i+vec4(0,1,2,0))*l+l)) \n         F *= mat2(cos(l*.2-i++*--t/1e2+vec4(0,33,11,0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 137, 137, 390]], "test": "untested"}
{"id": "mtsGW8", "name": "Not a Ray Marching", "author": "Ric3cir121", "description": "Thanks to poisson for the cornell box: www.shadertoy.com/view/mdX3Wn", "tags": ["ray"], "likes": 14, "viewed": 420, "published": 3, "date": "1671706259", "time_retrieved": "2024-07-30T16:11:35.398407", "image_code": "// not meant to be read\n\n// random functions\n\n#define mit 10\n#define off .005\n#define inf 99999999.\n\n#define rb1 1.1943\n#define rb2 1.5910\n#define rc1 2948.49\n#define rc2 1329.87\n#define rc3 9187.18\n#define rc4 3273.39\n#define rc5 1435.98\n\nfloat randm(float x,float y){\n    return fract(sin(dot(mod(vec2(x,y),vec2(rc2,rc3))+vec2(rc4,-rc5),vec2(rb1,rb2)))*rc1);\n}\nfloat randm(float x,float y,float z,float w,float s){return randm(randm(randm(x,y),z),randm(w,s));}\nfloat read(float x){return fract(x);}\nvec3 hash3(vec2 a,vec3 b){\n    float x = read(randm(a.x,a.y,b.x,b.y,b.z));\n    float y = read(randm(a.y,b.y,b.z,a.x,b.x));\n    float z = read(randm(b.z,b.y,a.x,b.x,a.y));\n    return vec3(x,y,z)-.5;\n}\nvec2 hash2(vec2 a,float b){\n    float x = read(randm(randm(a.x,a.y),b  ));\n    float y = read(randm(randm(b  ,a.x),a.y));\n    return vec2(x,y)-.5;\n}\nfloat hash1f(vec2 a,vec3 b){\n    return read(randm(a.y,a.x,b.z,b.x,b.y));\n}\n\n// rotation\n\nmat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvec3 rotate(vec3 c,float p){return vec3(c.xz*rotate(p),c.y).xzy;}\n\n// it's not ray marching\n\nfloat plane(vec3 p,vec3 c,float h){\n    return (c.y*sign(-p.y+h)>0.)?(sqrt(pow(length(c.xz),2.)+pow(c.y,2.))/c.y*(-p.y+h)):inf;\n}\nfloat cutplane(vec3 p,vec3 c,float h,vec2 a,vec2 b,float r,inout vec3 nor){\n    float dis = sqrt(dot(c.xz,c.xz)+c.y*c.y)/c.y*(-p.y+h);\n    vec2 d = dis*c.xz;\n    if(d.x<a.x-p.x||d.x>b.x-p.x||d.y<a.y-p.z||d.y>b.y-p.z)return inf;\n    float res = c.y*sign(-p.y+h)>0.?dis:inf;\n    if(res<r)nor = vec3(0,p.y>h?1.:-1.,0);\n    return res;\n}\n\nfloat cube(vec3 p,vec3 c,vec3 a,vec3 b,float r,inout vec3 nor){\n    vec3 siz = abs(a-b)/2.;\n    vec3 d = (a+b)/2.;\n    return min(min(min(inf,cutplane(p    ,c    ,-sign(c.y)*siz.y+d.y,a.xz,b.xz,r,nor)),\n                           cutplane(p.yzx,c.yzx,-sign(c.z)*siz.z+d.z,a.yx,b.yx,r,nor.yzx)),\n                           cutplane(p.zxy,c.zxy,-sign(c.x)*siz.x+d.x,a.zy,b.zy,r,nor.zxy));\n}\n\nfloat sphere(vec3 p,vec3 c,vec3 a,float s,float r,inout vec3 nor){\n    float mx = dot(a-p,c);\n    float d = length((a-p)-c*mx);\n    if(d<s){\n        if(length(normalize(p-a)-c)<1.414213562373)return inf;\n        float res = length(c*mx)-sqrt(1.-(d/s)*(d/s))*s*(length(p-a)-s<0.?-1.:1.);\n        if(res<r)nor = normalize((p+res*c)-a);\n        return res;\n    }\n    return inf;\n}\n\n// distance function, given position and camera returns the distance to a point in space where there's an object\n\nfloat d(vec3 p,vec3 c,inout vec3 nor){\n    /*\n        The reason for 'nor = normalize(nor*1.00001);'\n        is because it does some magics that fixes a bug\n        on chrome android, some gpus\n    */\n    float r = inf;\n    nor = vec3(0);\n    r = min(r,cutplane(p,c,5.,vec2(-5),vec2(5),r,nor));\n    r = min(r,cutplane(p,c,-5.,vec2(-5),vec2(5),r,nor));\n    r = min(r,cutplane(p.yzx,c.yzx,5.,vec2(-5),vec2(5),r,nor.yzx));\n    r = min(r,cutplane(p.yzx,c.yzx,-5.,vec2(-5),vec2(5),r,nor.yzx));\n    r = min(r,cutplane(p.zxy,c.zxy,5.,vec2(-5),vec2(5),r,nor.zxy));\n    nor = normalize(nor*1.00001);\n    r = min(r,cube(p,c,vec3(-.8,-.8,-1)*5.,vec3(.2,.2,-.98)*5.,r,nor));\n    nor = normalize(nor*1.00001);\n    r = min(r,sphere(p,c,vec3(0,-.6,-.4)*5.,.4*5.,r,nor));\n    nor = normalize(nor*1.00001);\n    r = min(r,sphere(p,c,vec3(0,-.7, .5)*5.,.3*5.,r,nor));\n    nor = normalize(nor*1.00001);\n    r = min(r,sphere(p,c,vec3(.5,-.7,-.4)*5.,.3*5.,r,nor));\n    return r;\n}\n\n// sky box, object color and material\n\nvec3 sky(vec3 pos){\n    return vec3(0);\n    // you might want to use a skybox\n    //return vec3(50000.*clamp(1.-10.*length(pos-normalize(vec3(-.7,1,-.7))),0.,1.));\n}\n\nvec3 getcolor(vec3 pos){\n    vec3 col = vec3(0);\n    col = vec3(.99);\n    if(pos.z+off>5.)col = vec3(.99,.05,.05);\n    if(pos.z-off<-5.)col = vec3(.05,.05,.99);\n    if(length(pos-vec3(.5,-.7,-.4)*5.)<=.3*5.+off)col = vec3(10,5,3);\n    float r = .628;\n    vec2 rp = pos.xz*mat2(cos(r),sin(r),-sin(r),cos(r))*.6;\n    if(max(abs(pos.x),abs(pos.z))<4.5){\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y),abs(rp.x)))<1.)col = vec3(10,5,3);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y+2.8),abs(rp.x-.45)))<1.)col = vec3(5,3,10);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y-2.8),abs(rp.x+.45)))<1.)col = vec3(10,3,5);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y+.45),abs(rp.x+2.8)))<1.)col = vec3(5,10,3);\n        if(max(abs(pos.y-4.9)*5.,max(abs(rp.y-.45),abs(rp.x-2.8)))<1.)col = vec3(3,5,10);\n    }\n    return col;\n}\n\nint getmaterial(vec3 pos){\n    int mat = 1;\n    if(length(pos-vec3(0,-.6,-.4)*5.)<=.4*5.+off)mat = 0;\n    if(length(pos-vec3(0,-.7, .5)*5.)<=.3*5.+off)mat = 2;\n    if(length(pos-vec3(.5,-.7,-.4)*5.)<=.3*5.+off)mat = 1;\n    if(all(lessThan(abs(pos+vec3(1.5,1.5,.99*5.))/(vec3(2.5,2.5,.05)+off),vec3(1))))mat = 0;\n    return mat;\n}\n\n// render function\n\nvec4 render(vec2 u){\n    vec4 o = vec4(0);\n    vec2 uv = (u*2.-iResolution.xy)/iResolution.yy/2.;\n    vec2 mouse = iMouse.xy;\n    if(floor(iMouse.xy)==vec2(0))mouse = iResolution.xy/2.;\n    vec2 dir = vec2(mouse/iResolution.xy*3.1415*vec2(2,-1));\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).zxy,-dir.y).zxy,-dir.x);\n    vec3 pos = -rotate(rotate(normalize(vec3(0,0,1)).zxy,-dir.y).zxy,-dir.x)*15.;\n    vec3 beg = pos;\n    int i;\n    vec3 col = vec3(1);\n    vec3 end = pos;\n    bool refr = true;\n    bool sca = false;\n    int frame = iFrame;\n    for(i=0;i<mit;i++){\n        pos += cam*off;\n        vec3 nor;\n        pos += d(pos,cam,nor)*cam-cam*off;\n        if(i==0)end=pos;\n        if(length(pos)>20.)break;\n        vec3 newcol = getcolor(pos);\n        col *= newcol;\n        if(dot(newcol,vec3(1))>=3.)break;\n        int mat = getmaterial(pos);\n        if(mat==2)if(hash1f(u,vec3(-1,frame,i))>.75)mat=0;\n        if(mat==1){\n            if(!sca){\n                sca = true;\n                const int ks = 16;\n                vec2 bucket = vec2(0);\n                vec3 bv = vec3(0);\n                for(int k=0;k<ks;k++){\n                    vec3 scam = normalize(hash3(u,vec3(k,frame,i)));\n                    if(length(scam-nor)>1.414213562373)scam *= -1.;\n\n                    int l = 0;\n                    vec3 spos = pos+scam*off;\n                    vec3 snor;\n                    spos += d(spos,scam,snor)*scam;\n                    float light = dot(getcolor(spos),vec3(1))/3.;\n                    if(length(spos)>20.)light = dot(sky(normalize(spos)),vec3(1))/3.;\n                    float weight = light;\n                    weight += .3;\n                    float noise = hash1f(u,vec3(k,frame,i));\n                    if(noise<weight/(weight+bucket.y)||k==0){\n                        bv = scam;\n                        bucket.x = weight;\n                    }\n                    bucket.y += weight;\n                }\n                col *= vec3(bucket.y/float(ks))/bucket.x;\n                cam = bv;\n            }else{\n                cam = normalize(hash3(u,vec3(0,frame-1,i)));\n            }\n        }\n        if(mat==2){\n            pos+=cam*off*4.;\n            if(refr)cam = normalize(refract(cam,nor,0.));\n            refr = refr^^true;\n        }else\n        if(length(cam-nor)>1.414213562373)cam = normalize(reflect(cam,nor));\n    }\n    vec3 lastcol = getcolor(pos);\n    if(dot(lastcol,vec3(1))<9.&&i!=mit)col*=sky(normalize(pos));\n    if(i==mit)col*=0.;\n    o = vec4(col,length(beg-end));\n    return o;\n}\n\n// main\n\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 uv = (u*2.-iResolution.xy)/iResolution.yy/2.;\n    vec2 mouse = iMouse.xy;\n    if(floor(iMouse.xy)==vec2(0))mouse = iResolution.xy/2.;\n    vec2 dir = vec2(mouse/iResolution.xy*3.1415*vec2(2,-1));\n    if(floor(u/2.)==vec2(0)){o = vec4(dir,0,0);return;}\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).zxy,-dir.y).zxy,-dir.x);\n    vec3 pos = -rotate(rotate(normalize(vec3(0,0,1)).zxy,-dir.y).zxy,-dir.x)*15.;\n    \n    vec3 col = render(u).xyz;\n    \n    o = pow(vec4(col/5.,1.),vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 269, 269, 362], [363, 363, 416, 416, 462], [463, 463, 483, 483, 500], [501, 501, 527, 527, 700], [701, 701, 728, 728, 849], [850, 850, 878, 878, 925], [940, 940, 961, 961, 1004], [1005, 1005, 1033, 1033, 1070], [1098, 1098, 1133, 1133, 1227], [1228, 1228, 1303, 1303, 1561], [1563, 1563, 1626, 1626, 1951], [1953, 1953, 2019, 2019, 2330], [2446, 2446, 2484, 2646, 3404], [3445, 3445, 3464, 3464, 3610], [3612, 3612, 3636, 3636, 4428], [4430, 4430, 4456, 4456, 4759], [7325, 7325, 7359, 7359, 7862]], "test": "untested"}
{"id": "mtl3zM", "name": "rfrctn_2", "author": "janaTox", "description": "Second GLSL refraction", "tags": ["glsl"], "likes": 5, "viewed": 103, "published": 3, "date": "1671700638", "time_retrieved": "2024-07-30T16:11:36.430647", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n\n\n    float d = sdBox(p, vec3(1));\n    \n    float c = cos(PI/5.), s = sqrt(.75-c*c);\n    vec3 n = vec3 (-.5,-c,s);\n    \n    p = abs(p);\n    p-= 2.* min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p-= 2.* min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p-= 2.* min(0., dot(p, n))*n;\n    \n    d = p.z-1.;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.01, 0); //AAAAAQUI\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 3.5); //AAAAAQUI\n    \n    vec3 col = texture(iChannel0, rd).rgb;\n    //vec3 col = vec3(0.);\n   \n    float d = RayMarch(ro, rd, 1.); // otside of object\n\n    float IOR = 1.45; // Index Of Refraction (water = 1.33)\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3D hit position\n        vec3 n = GetNormal(p); // normal of surface = orientation\n        vec3 r = reflect(rd, n);\n        \n        vec3 refOutside = texture(iChannel0, r).rgb;\n        \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray directin when entering\n\n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3D exit position\n        vec3 nExit = GetNormal(pExit); \n        \n        vec3 reflTex = vec3(0.);\n        \n        vec3 rdOut = vec3(0.);\n        \n        float abb = .01;\n        \n        rdOut = refract(rdIn, nExit, IOR-abb); // ray directin on exit\n        if (dot(rdOut, rdOut) == 0.) rdOut = reflect(rdIn, nExit);\n        reflTex.r = texture (iChannel0, rdOut).r;\n        \n        rdOut = refract(rdIn, nExit, IOR); // ray directin on exit\n        if (dot(rdOut, rdOut) == 0.) rdOut = reflect(rdIn, nExit);\n        reflTex.g = texture (iChannel0, rdOut).g;\n        \n        rdOut = refract(rdIn, nExit, IOR+abb); // ray directin on exit\n        if (dot(rdOut, rdOut) == 0.) rdOut = reflect(rdIn, nExit);\n        reflTex.b = texture (iChannel0, rdOut).b;\n        \n        float dens = .2;\n        float optDist = exp(-dIn*dens);\n        \n        col = reflTex*optDist*vec3(.8);\n        float fresnel = pow(1.+dot (rd, n), 5.);\n        \n        col = mix(reflTex, refOutside, fresnel);\n        \n        //col = vec3(reflTex);\n        //col = n*.5+.5; \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtl3zM.jpg", "access": "api", "license": "mit", "functions": [[1515, 1515, 1534, 1534, 1596], [1598, 1598, 1627, 1627, 1708], [1711, 1711, 1734, 1734, 2063], [2065, 2065, 2111, 2111, 2327], [2329, 2329, 2353, 2353, 2517], [2519, 2519, 2569, 2569, 2754], [2756, 2756, 2813, 2813, 4905]], "test": "untested"}
{"id": "Dls3WH", "name": "4D Voxel Raycasting ", "author": "SpencerKuan", "description": "A primitive test of 4D voxel raycasting with a random perlin noise grid. I have no idea if the result is correct, but it looks interesting.", "tags": ["raycasting", "voxel", "4d"], "likes": 11, "viewed": 329, "published": 3, "date": "1671699002", "time_retrieved": "2024-07-30T16:11:37.418007", "image_code": "/*\n\n\n    This program generalizes a 3D voxel DDA raycasting \n    approach into 4D, by simply casting a 4D ray into a 4D voxel \n    grid. The result has 4 axis of movement and 6 planes of rotation.\n\n\n*/\n\n\n\n\nstruct Ray4 {\n    vec4 o;\n    vec4 d;\n};\n\nstruct Hit4 {\n    float dist;\n    vec4 normal;\n};\n\nHit4 raycast (Ray4 ray, out bool hit){\n    vec4 p = ray.o;\n\n    vec4 grid = floor(ray.o);\n    \n    vec4 dirSign = sign(ray.d);\n    vec4 dirInv = abs(1.0 / ray.d);\n    \n    vec4 sideDist = vec4(0.0);\n    sideDist = vec4(\n        (dirSign.x == -1. ? p.x - grid.x : -(p.x - grid.x) + 1.) * dirInv.x, \n        (dirSign.y == -1. ? p.y - grid.y : -(p.y - grid.y) + 1.) * dirInv.y, \n        (dirSign.z == -1. ? p.z - grid.z : -(p.z - grid.z) + 1.) * dirInv.z,\n        (dirSign.w == -1. ? p.w - grid.w : -(p.w - grid.w) + 1.) * dirInv.w\n    );\n    \n    int side = 0;\n    \n    int i = 0;\n    hit = false;\n    float dist = 0.0;\n    \n    while (i++ < 50 && hit == false){\n        float minD = min(min(min(sideDist.x, sideDist.y), sideDist.z), sideDist.w);\n        \n        if (minD == sideDist.x){\n            side = 0;\n            \n            sideDist.x += dirInv.x;\n            dist = sideDist.x - dirInv.x;\n            grid.x += dirSign.x;\n        } else if (minD == sideDist.y){\n            side = 1;\n            dist = sideDist.y;\n            sideDist.y += dirInv.y;\n            grid.y += dirSign.y;\n        } else if (minD == sideDist.z){\n            side = 2;\n            dist = sideDist.z;\n            sideDist.z += dirInv.z;\n            grid.z += dirSign.z;\n        } else if (minD == sideDist.w){\n            side = 3; \n            dist = sideDist.w;\n            sideDist.w += dirInv.w;\n            grid.w += dirSign.w;\n        }\n        \n        hit = voxel(grid) > 0.5;\n    }\n\n    if (!hit) return Hit4(0.0, vec4(0));\n    \n    vec4 norm;\n    switch (side){\n        case 0:\n            norm = vec4(dirSign.x, 0, 0, 0);\n            break;\n        case 1:\n            norm = vec4(0, dirSign.y, 0, 0);\n            break;\n        case 2:\n            norm = vec4(0, 0, dirSign.z, 0);\n            break;\n        case 3:\n            norm = vec4(0, 0, 0, dirSign.w);\n            break;\n        \n    }\n    return Hit4(dist, norm);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float z = 0.3;\n    float w = 0.3;\n    vec4 rd = normalize(vec4((fragCoord.xy - iResolution.xy * 0.5) / max(iResolution.x, iResolution.y), z, w));\n    vec4 ro = vec4(0.2, -0.15, -0.1, 0.2) * iTime;\n    \n    \n    float rotations[6] = float[](0.2 * iTime, 0.4, 0.0, 0.1 * iTime, 0.0, -0.1 * iTime);\n    \n    mat4 mat = rotateXY(rotations[0]) * rotateXZ(rotations[1]) * rotateXW(rotations[2])* rotateYZ(rotations[3]) * rotateYW(rotations[4]) * rotateZW(rotations[5]);\n    rd = mat * rd;\n    \n    \n    bool didHit;\n    Ray4 camera = Ray4(ro, rd);\n    Hit4 hit = raycast(camera, didHit);\n    \n    \n    vec3 col = vec3(0);\n    if (didHit){\n        // vec4 col4 = hit.normal.wzyx * 0.25 + 0.5;\n        // col = cmykToRGB(col4);\n        \n        vec3 light = vec3(0);\n        \n        light += max(dot(vec4(0.2, 0.3, 0.5, -0.7), hit.normal), 0.0) * vec3(67, 197, 158) / 255.;\n        light += max(dot(vec4(0.8, -0.6, 0.1, 0), hit.normal), 0.0) * vec3(0, 157, 220) / 255.;\n        light += max(dot(vec4(-0.7, 0.7, -0.4, 0.6), hit.normal), 0.0) * vec3(242, 100, 48) / 255.;\n        \n        col = light / (hit.dist + 15.0) * 15.0;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "\n//////////////////////////////////////////////////////////////\n//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);vec4 p,s;p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;p.w = 1.5 - dot(abs(p.xyz), ones.xyz);s = vec4(lessThan(p, vec4(0.0)));p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;return p;}float snoise(vec4 v){const vec2  C = vec2( 0.138196601125010504,0.309016994374947451);vec4 i  = floor(v + dot(v, C.yyyy) );vec4 x0 = v -   i + dot(i, C.xxxx);vec4 i0;vec3 isX = step( x0.yzw, x0.xxx );vec3 isYZ = step( x0.zww, x0.yyz );i0.x = isX.x + isX.y + isX.z;i0.yzw = 1.0 - isX;i0.y += isYZ.x + isYZ.y;i0.zw += 1.0 - isYZ.xy;i0.z += isYZ.z;i0.w += 1.0 - isYZ.z;vec4 i3 = clamp( i0, 0.0, 1.0 );vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );vec4 x1 = x0 - i1 + 1.0 * C.xxxx;vec4 x2 = x0 - i2 + 2.0 * C.xxxx;vec4 x3 = x0 - i3 + 3.0 * C.xxxx;vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;i = mod(i, 289.0);float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);vec4 j1 = permute( permute( permute( permute (i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;vec4 p0 = grad4(j0,   ip);vec4 p1 = grad4(j1.x, ip);vec4 p2 = grad4(j1.y, ip);vec4 p3 = grad4(j1.z, ip);vec4 p4 = grad4(j1.w, ip);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;p4 *= taylorInvSqrt(dot(p4,p4));vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);m0 = m0 * m0;m1 = m1 * m1;return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;}\n//\n//////////////////////////////////////////////////////////////\n\n\n\n// scene helper \n\nfloat voxel(vec4 p)\n{\n    p = floor(p) + vec4(543., 423., 9432., 234.);\n    \n    float v = snoise(p * 0.2);\n    return clamp(round(v), 0.0, 1.0);\n}\n\n// --- 4D helper functions --- //\n\nmat4 rotateXY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, -s, 0.0, 0.0,\n        s, c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateYZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, -s, 0.0,\n        0.0, s, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateXW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        c, 0.0, 0.0, -s,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        s, 0.0, 0.0, c\n    );\n}\n\nmat4 rotateYW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, 0.0, -s,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, s, 0.0, c\n    );\n}\n\nmat4 rotateZW(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, c, -s,\n        0.0, 0.0, s, c\n    );\n}\n\n\n// --- color helper functions --- //\n\nvec3 cmykToRGB(vec4 cmyk) {\n    float c = cmyk.x;\n    float m = cmyk.y;\n    float y = cmyk.z;\n    float k = cmyk.w;\n\n    float r = (1.0 - c) * (1.0 - k);\n    float g = (1.0 - m) * (1.0 - k);\n    float b = (1.0 - y) * (1.0 - k);\n\n    return vec3(r, g, b);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 337, 337, 2223]], "test": "untested"}
{"id": "dlX3WH", "name": "Glitter Dimension_A21DC534", "author": "ConanG", "description": "Practice RTGT2022", "tags": ["glitter"], "likes": 4, "viewed": 354, "published": 3, "date": "1671681175", "time_retrieved": "2024-07-30T16:11:38.292669", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*2.);\n    float n2 = fract(n*50.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[3], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.01/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 50.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n   \n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.01;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*0.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., 0., z)*S(.5, .3, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.3), -sin(t*.24))*.4+.6;\n    vec3 col = baseCol*m;\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 5.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n   \n    #endif\n    \n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlX3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 100, 100, 235], [237, 237, 279, 279, 434], [436, 436, 474, 474, 500], [502, 502, 542, 542, 589], [591, 591, 640, 640, 756], [758, 758, 795, 795, 1009], [1011, 1011, 1054, 1054, 1793], [1795, 1795, 1852, 1852, 2764]], "test": "untested"}
{"id": "mtfGWH", "name": "2d normals test", "author": "SONENEIS", "description": "...", "tags": ["2d", "circle", "gradient", "diamond", "green", "normal", "rect"], "likes": 5, "viewed": 249, "published": 3, "date": "1671679112", "time_retrieved": "2024-07-30T16:11:39.170323", "image_code": "float scene(vec2 uv){\n\tfloat d = 999999999.9;\n\n\td = min(d,abs(length(uv)-0.25)-0.125);\n\td = min(d,max(abs(uv.x-0.75),abs(uv.y-0.5))-0.25);\n    d = min(d,length(uv+0.5)-0.25);\n    \n\treturn d;\n}\n\nvec3 calcNormal(vec2 p){\n\tvec2 e = vec2(-1,1) * 0.001;\n\treturn vec3(smoothstep(3.0/iResolution.y,0.0,scene(p))*normalize(\n\t\te.xy * scene(p + e.xy) +\n\t\te.yx * scene(p + e.yx) +\n\t\te.yy * scene(p + e.yy) +\n\t\te.xx * scene(p + e.xx)\n\t),0.5*sqrt(1.0-scene(p)));\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mo = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  vec3 nor = calcNormal(uv);\n\n  vec3 lig = normalize(vec3(mo-uv,1.0));\n  float dif = clamp(dot(nor,lig),0.0,1.0);\n\n  col += mix(col,vec3(0,1,0.5),smoothstep(3.0/iResolution.y,0.0,scene(uv)));\n  col *= dif + 0.1;\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 192], [194, 194, 218, 218, 451], [453, 453, 503, 503, 888]], "test": "untested"}
{"id": "dlXGWH", "name": "A Mall and the Night Visitors", "author": "Xibanya", "description": "you can tilt the camera a bit with the mouse", "tags": ["raymarching", "sdf", "neon", "vaporwave", "mall"], "likes": 14, "viewed": 482, "published": 3, "date": "1671678233", "time_retrieved": "2024-07-30T16:11:40.249437", "image_code": "// uncomment out in visual studio code\n//#define DEFINED_SATURATE\n\n#ifndef DEFINED_SATURATE\n#define DEFINED_SATURATE\n#define saturate(x) clamp(x, 0., 1.)\n#endif\n\nconst float _XRot = 5.;\nconst float _YRot = -55.;\nconst float _XPos = -4.5;\nconst float _YPos = 0.55;\nconst float _ZPos = 4.;\nconst float _FOV = 45.;\nconst float _LightX = -0.5;\nconst float _LightY = 0.9;\nconst float _LightZ = 0.9;\nconst float _LightR = 0.25;\nconst float _LightG = 0.2;\nconst float _LightB = 0.3;\nconst float _FogGamma = 2.2;\nconst float _FlickerRate = 5.;\nconst float _FlickerPhase = 25.;\n\nconst int MARCH_STEPS = 200;\nconst int SHADOW_MARCH_STEPS = 100;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00005;\n#define PI 3.14159265\n\nconst vec3 SHADOW_COLOR = vec3(0.25, 0.2, 0.4) * 0.5;\nconst vec3 PINK = vec3(0.8, 0.7, 0.9);\nconst vec3 BLUE = vec3(0.7, 0.7, 1.);\nconst vec3 TRUNK_COLOR = vec3(0.6, 0.5, 0.5);\nconst vec3 FROND_COLOR = pow(vec3(0., 1., 0.8) * 0.5, vec3(1.2));\nconst float MIN_FOG_GAMMA = 0.75;\nconst float MAX_FOG_GAMMA = 2.2;\nconst float FOG_GAMMA_TIME = 0.5;\nconst float BUILDING_ROUND = 0.02;\n\nfloat Distance(vec3 p);\n\nstruct Object \n{\n    float dist;\n    vec3 color;\n    float smoothness;\n    float emission;\n    float metallic;\n    vec3 p;\n    vec3 scale;\n};\nstruct Objects {\n    float total;\n    Object Ornament; \n    Object Neon;\n    Object Building; \n    Object Under; \n    Object Ground;\n    Object Door;\n    Object Wall;\n    Object CeilingTile;\n    Object CeilingPlaster;\n    Object CeilingNeon;\n    Object OverNeon;\n    vec4 tex;\n};\nstruct Light {\n    float nDotL;\n    vec3 dir;\n    float atten;\n    float shadow;\n    float diffuse;\n    float occlusion;\n};\n\n// AO stuff from https://www.shadertoy.com/view/4sdGWN\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat AO( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = n*l;\n        \n        ao += (l - max(Distance( p + rd ),0.)) / maxDist * falloff;\n    }\n    return clamp( 1.-ao/float(nbIte), 0., 1.);\n}\nfloat Flicker(float phase, float rate)\n{\n    float flick = floor((iTime + phase) * rate) / rate;\n    \n    flick = fract(sin(flick) * 43758.5453);\n    return flick;\n}\nfloat InvLerp(float from, float to, float value)\n{\n    return clamp(abs(value - from) / abs(to - from), 0., 1.);\n}\nmat3 YRotationMatrix(float degrees)\n{\n\tfloat angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat3 rotateYMatrix = mat3(\n        c, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c);\n\treturn rotateYMatrix;\n}\nmat3 ZRotationMatrix(float degrees)\n{\n\tfloat angleZ = radians(degrees);\n\tfloat c = cos(angleZ);\n\tfloat s = sin(angleZ);\n\tmat3 rotateZMatrix = mat3(\n        c, -s, 0,\n\t\ts, c, 0,\n\t\t0, 0, 1\n\t\t);\n\treturn rotateZMatrix;\n}\nmat3 XRotationMatrix(float degrees)\n{\n\tfloat angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat3 rotateXMatrix = mat3(\n        1, 0, 0,\n\t\t0, c, -s, \n\t\t0, s, c);\n\treturn rotateXMatrix;\n}\nvec3 Rotate(vec3 a, vec3 o)\n{\n    vec3 localScaledTranslatedRotX = o * XRotationMatrix(a.x);\n    vec3 localScaledTranslatedRotXY = localScaledTranslatedRotX * YRotationMatrix(a.y);\n    return localScaledTranslatedRotXY * ZRotationMatrix(a.z);\n}\nmat2 Rotate2DMatrix(float a)\n{\n    a = radians(a);\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nvec2 Rotate2D(float angle, vec2 original)\n{\n    return Rotate2DMatrix(angle) * original;\n}\n//https://www.shadertoy.com/view/XtBfzz\nfloat GridPattern( in vec2 p, float smoothness)\n{\n    vec2 thresh = vec2(1.0/ 30.);\n    vec2 fP = fract(p);\n    vec2 i = smoothstep(fP - smoothness, fP + smoothness, thresh);\n    return saturate(min((1.0 - i.x), (1.0 - i.y)));\n}\n//https://www.shadertoy.com/view/XlcSz2\nfloat CheckerPattern( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y, 2.0 );\n}\n//https://www.shadertoy.com/view/ws3Bzf\nvec4 BiplanarSample( sampler2D sam, in vec3 p, in vec3 n)\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n/////////////////////////////////\n//https://iquilezles.org/articles/distfunctions/\nfloat SDFBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    vec3 v = min(d, 0.);\n    return length(max(d, 0.0)) + max(max(v.x, v.y), v.z);\n}\n// individual scene pieces in separate functions to make them easier to duplicate \nfloat Overhang(vec3 p)\n{\n\treturn SDFBox(p - vec3(-.727,-.031,.0) -  vec3(.168,1.386,.42), \n        vec3(.961,.329,.917));\n}\nfloat Building(vec3 p, inout Objects o)\n{\n    vec3 wsPos = vec3(.0,.0,.0);\n    vec4 a0 = vec4(p, 1.0);\n    vec4 a1 = a0 - vec4(-.727,-.031,.0,.0);\n    vec4 a2 = a1;\n\tvec4 a3 = a2;\n    wsPos = a3.xyz - vec3(.164,.595,-.19);\n    o.Door.scale = vec3(.827,.795,.717);\n    o.Door.p = wsPos;\n    o.Door.dist = min(1., SDFBox(o.Door.p, o.Door.scale)) - BUILDING_ROUND;\n    wsPos = a3.xyz - vec3(.168,.661,-.408);\n    vec4 a4 = a1 - vec4(.168,1.386,.42,.0);\n    wsPos = a4.xyz - vec3(.0,-.493,-.837);\n    o.Building.dist = min(1., SDFBox(wsPos,vec3(1.5, .851, .917)));\n    o.Building.p = wsPos;\n    o.Building.dist = min(o.Building.dist, Overhang(p));\n    wsPos = a4.xyz - vec3(.773,-.901,.773);\n    float column = SDFBox(wsPos, vec3(.042, 0.5, .042)); // left column\n    wsPos = a4.xyz - vec3(-.773,-.901,.773);\n    column = min(column, SDFBox(wsPos,vec3(.042, 0.5,.042))); // right column\n    o.Building.dist = min(o.Building.dist, column) - BUILDING_ROUND;\n\n    float total = min(o.Building.dist, o.Door.dist);\n\n    vec4 a5 = a0 - vec4(.0,-.031,.0,.0);\n\twsPos = a5.xyz - vec3(-.559,1.45,.815);\n    float lowOrnament = SDFBox(wsPos,vec3(.996,.012,.544));\n    o.Ornament.dist = min(o.Ornament.dist, lowOrnament);\n\ttotal = min(total, lowOrnament);\n\twsPos = a5.xyz - vec3(-.559,1.525,.815);\n    float middleOrnament = SDFBox(wsPos,vec3(.996,.012,.544));\n    o.Ornament.dist = min(o.Ornament.dist, middleOrnament);\n\ttotal = min(total, middleOrnament);\n\twsPos = a5.xyz - vec3(-.559,1.6,.815);\n    float topOrnament = SDFBox(wsPos,vec3(.996,.012,.544));\n    o.Ornament.dist = min(o.Ornament.dist, topOrnament);\n    o.Ornament.dist -= 0.001;\n\ttotal = min(total, topOrnament);\n\twsPos = a5.xyz - vec3(-.559,1.032,.815);\n    o.Neon.p = wsPos;\n    o.Neon.dist = min(1., SDFBox(wsPos, vec3(.916,.014,.485)) - 0.005);\n\ttotal = min(total, o.Neon.dist);\n\twsPos = a5.xyz - vec3(-.559, 1.0, 0.819);\n    o.Under.dist = min(1., SDFBox(wsPos, vec3(.885,.035,.446)));\n    o.Under.p = wsPos;\n    total = min(total, o.Under.dist);\n    return total;\n}\n// diagonal domain repetition\nvec2 MirrorDiag( vec2 p, vec2 offset )\n{\n    p -= offset;\n    if( p.x > -p.y )\n        p.xy = -p.yx;\n    p += offset;\n    return p;\n}\nfloat Scene(vec3 p, out Objects o)\n{\n    o.Ornament.dist = 1.; \n    o.Neon.dist = 1.;\n    o.Building.dist = 1.;\n    o.Under.dist = 1.;\n    o.Ground.dist = 1.;\n    o.Wall.dist = 1.;\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n    o.total = 1.;\n\tvec4 a1 = a0 - vec4(-.727,-.031,.0,.0);\n\tvec4 a2 = a1;\n\tvec4 a3 = a2;\n\twsPos = a3.xyz - vec3(.164,.595,-.19);\n\twsPos = a3.xyz - vec3(.168,.661,-.408);\n\tvec4 a4 = a1 - vec4(.168,1.386,.42,.0);\n\twsPos = a4.xyz;\n\n    float groundGrid = GridPattern(p.xz * 4., 0.1) * 0.005 + 0.1;\n\tfloat ground = (dot(a0.xyz - vec3(.0, groundGrid,.0), vec3(.0, 1.0, .0)) * 1.0);\n    o.Ground.dist = min(o.Ground.dist, ground);\n    o.total = min(o.total, o.Ground.dist);\n    float wallGrid = GridPattern(p.xy * 8., 0.05);\n    o.Wall.color = vec3(wallGrid);\n    float wall = SDFBox(wsPos + vec3(0., -0.5, 1.75 - wallGrid * 0.01), vec3(10., 2., 0.01));\n   \n    vec3 buildP = p;\n    buildP.xz = MirrorDiag(buildP.xz, vec2(1., 1.));\n    o.Building.dist = Building(buildP, o);\n\n    o.Wall.dist = min(o.Wall.dist, wall);\n    wall = SDFBox(\n        Rotate(vec3(0., 45., 0.), wsPos + vec3(0., -1., 1.5 - wallGrid * 0.01)), \n        vec3(10., 2., 0.01));\n    o.Wall.dist = min(o.Wall.dist, wall);\n    o.total = min(o.total, o.Wall.dist);\n    o.total = min(o.total, o.Building.dist);\n    o.Building.dist = -max(o.Door.dist, o.Building.dist);\n    \n\treturn o.total;\n}\n// meant to be called when distance is needed but color zones are not.\nfloat Distance(vec3 p)\n{\n    Objects o;\n    return Scene(p, o);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize( e.xyy * Distance( pos + e.xyy) + \n\t\t\t\t\t  e.yyx * Distance( pos + e.yyx) + \n\t\t\t\t\t  e.yxy * Distance( pos + e.yxy) + \n\t\t\t\t\t  e.xxx * Distance( pos + e.xxx) );\n}\nfloat March(vec3 pos, vec3 dir, float withGlass, out Objects o) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Scene(p, o);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\n// https://iquilezles.org/articles/rmshadows\nfloat Shadow(in vec3 ro, in vec3 rd)\n{\n    float mint = 0.02;\n    float tmax = 2.5;\n    float tp = (0.4 - ro.y) / rd.y; \n    tmax = mix(tmax, min( tmax, tp ), step(0., tp));\n\n    float shadow = 1.0;\n    float t = mint;\n    for (int i = 0; i < SHADOW_MARCH_STEPS; i++ )\n    {\n\t\tfloat h = Distance( ro + rd * t);\n        float s = clamp(10.0 * h/t, 0.0, 1.0);\n        shadow = min(shadow, s * s * (3.0 - 2. * s));\n        t += clamp(h, 0.02, 0.2 );\n        if(shadow < 0.004 || t > tmax) break;\n    }\n    shadow = saturate(shadow);\n    return smoothstep(0., 0.2, shadow);\n}\n// SafeNormalize cribbed from \n// https://xibanya.github.io/UnityShaderViewer/Library/BuiltinShaders/CGIncludes/UnityStandardBRDF.html\nvec3 SafeNormalize(vec3 inVec)\n{\n    float dp3 = max(0.001f, dot(inVec, inVec));\n    return inVec * pow(dp3, -0.5);\n}   \nfloat GetSpecular(vec3 normal, vec3 lightDir, vec3 viewDir, float n)\n{\n    vec3 halfDir = SafeNormalize(lightDir + viewDir);\n    float NdotH = saturate(dot(normal, halfDir));\n    float normTerm = (n + 2.0) * (0.5/PI);\n    float specTerm = pow(NdotH, n);\n    return specTerm * normTerm;\n}\nLight GetLight(vec3 normal, vec3 p, vec3 lightPos, vec3 viewDir)\n{\n    // using a struct for this stuff because I'll be using\n    // some of these values later for other things\n    Light light;\n    light.dir = lightPos;\n    light.nDotL = max(0., dot(light.dir, normal));\n    light.shadow = Shadow(p, light.dir);\n    light.atten = smoothstep(0., 0.1, pow(light.shadow, 5.));\n    light.occlusion = AO(p, normal, 5., 1.5);\n    light.diffuse = light.nDotL * light.atten * light.occlusion;\n    return light;\n}\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n// I started writing this doing something more elaborate for the door\n// now I'm not but I might again so this function stays...\nvec3 DoorColor(inout Objects o, vec3 p, vec3 dir, vec3 normal)\n{\n    o.Door.smoothness = 1.;\n    o.Door.metallic = 1.;\n    return o.Door.color = vec3(1.);\n}\nvec3 InitColor(inout Objects o, vec3 pos, vec3 dir, vec3 normal, float dist)\n{\n    vec3 p = pos + dir * dist;\n    float up = step(0.9, dot(normal, vec3(0., 1., 0.)));\n    o.tex = 1. - BiplanarSample(iChannel2, p * 0.5, normal);\n    float groundGrid = GridPattern(p.xz * 4., 0.05);\n    o.Ground.color = vec3(saturate(groundGrid * 1.5));\n    o.Building.color = mix(vec3(1.), vec3(0.75), o.tex.r) * PINK;\n    o.Ornament.color = pow(BLUE, vec3(2.));\n    o.Neon.color = pow(PINK, vec3(2.));\n    o.Under.color = vec3(0.05);\n    float interiorTex = BiplanarSample(iChannel2, p * 2., normal).r;\n    vec3 doorP = p * 2. + vec3(0., -0.1, 0.);\n    o.Door.color = DoorColor(o, doorP, dir, normal);\n    o.Wall.smoothness = o.Wall.color.r;\n    o.Wall.color = max(vec3(0.9), o.Wall.color);\n\n    vec3 albedo = vec3(0.);\n    albedo = mix(albedo, o.Building.color, step(o.Building.dist, o.total));\n    albedo = mix(albedo, o.Wall.color, step(o.Wall.dist, o.total));\n    albedo = mix(albedo, o.Ground.color, step(o.Ground.dist, o.total));\n    albedo = mix(albedo, o.Under.color, step(o.Under.dist, o.total));\n    albedo = mix(albedo, o.Ornament.color, step(o.Ornament.dist, o.total));\n    albedo = mix(albedo, o.Neon.color, step(o.Neon.dist, o.total));\n    albedo = mix(albedo, o.Door.color, step(o.Door.dist, o.total));\n\n    // other initialization\n    o.Ornament.emission = 0.5;\n    o.Neon.emission = 1.;\n\n    o.Ground.smoothness = groundGrid * max(0.9, o.tex.r);\n    o.Ground.metallic = 0.1;\n    o.Building.smoothness = (1. - o.tex.r) * 0.1;\n    o.Ornament.smoothness = 0.8;\n    o.Neon.smoothness = 1.;\n    o.Under.smoothness = min(0.3, o.tex.r);\n   \n    return albedo;\n}\nfloat GetGlow(float dist, float steps)\n{\n    float glow = 0.;\n    for (float i = 0.; i < steps; i++)\n    {\n        glow += max(0., (0.1 * i) - dist);\n    }\n    return glow +  \n        (1. - max(0., smoothstep(0.001, 0.01, dist - 0.005)));\n}\nvec3 Color(Objects o, vec3 pos, vec3 dir, vec3 normal, float dist)\n{\n    vec3 p = pos + dir * dist;\n    vec3 albedo = InitColor(o, pos, dir, normal, dist);\n\n    vec3 lightDir = vec3(_LightX, _LightY, _LightZ);\n    Light light = GetLight(normal, p, lightDir, -dir);\n    // this is slightly inaccurate, mix would get better results\n    // but whatever, close enough\n    float smoothness = \n        o.Building.smoothness * step(o.Building.dist, o.total) +\n        o.Ground.smoothness * step(o.Ground.dist, o.total) +\n        o.Under.smoothness * step(o.Under.dist, o.total) +\n        o.Ornament.smoothness * step(o.Ornament.dist, o.total) +\n        o.Neon.smoothness * step(o.Neon.dist, o.total) + \n        o.Wall.smoothness * step(o.Wall.dist, o.total);\n    ;\n    smoothness = mix(smoothness, o.Door.smoothness, step(o.Door.dist, o.total));\n\n    float specTerm = GetSpecular(normal, light.dir, dir, max(0., smoothness));\n    float spec = smoothstep(0.3, 0.7, specTerm);\n\n    float fogGamma = _FogGamma;\n    float fogHeight = 1.5 * smoothstep(-0.5, 2.2, fogGamma);\n    float fogDist = 1. - pow(InvLerp(MAX_DIST * 0.2, MAX_DIST * 0.01, dist), fogGamma);\n    float fogFactor = fogDist * ( 1. - pow(InvLerp(0., fogHeight, p.y), fogGamma));\n   \n    vec3 lightColor = vec3(_LightR, _LightG, _LightB);\n    vec3 shadowColor = SHADOW_COLOR;\n    shadowColor = min(shadowColor, lightColor);\n    vec3 diffuse = mix(shadowColor, lightColor, max(0., light.diffuse));\n    \n    float isEmissive = saturate(\n        step(o.Neon.dist, o.total) * o.Neon.emission + \n        step(o.Ornament.dist, o.total) * o.Ornament.emission +\n        step(o.Door.dist, o.total) * o.Door.emission\n    );\n    // more emissive = less affected by light\n    diffuse = mix(diffuse, vec3(1.), isEmissive);\n    // I already know only the ground or door could be \n    // metallic which is why I'm only checking against those\n    float metallic = o.Door.metallic * step(o.Door.dist, o.total);\n    metallic = mix(metallic, o.Ground.metallic, step(o.Ground.dist, o.total));\n    vec3 specCube = texture(iChannel0, dir).rgb;\n    // get luminosity of specCube cuz I don't want orange speculars\n    float specLum = (specCube.r + specCube.g + specCube.b) / 3.;\n    // boost specColor because I want those shinies to be real shiny\n    specLum *= 7.;\n    vec3 specColor = specLum * lightColor;\n    albedo = mix(albedo, specColor, metallic);\n    vec3 col = albedo * diffuse + spec * specColor;\n\n    // using the neon colors as fog colors to help suggest some sort of scattering\n    vec3 fogColor = mix(o.Ornament.color, o.Neon.color, saturate(dot(p.y, 1.25)));\n\n    // FRESNEL\n    float up = step(0.9, dot(normal, vec3(0., 1., 0.)));\n    float fresnelTerm = 1. - max(0., dot(normal, -dir));\n    fresnelTerm = smoothstep(0.3, 0.5, fresnelTerm) * max(0.1, (1. - up)) * max(0.1, smoothness);\n    col += mix(albedo * shadowColor, albedo * fogColor, light.diffuse) * fresnelTerm * specLum;\n    \n    // fog after fresnel highlight\n    col = mix(col, fogColor, fogFactor);\n    \n    // glow after fog to make a sort of scattering effect\n    float neonGlow = mix(\n        GetGlow(o.Neon.dist, 4.),\n        pow(GetGlow(o.Neon.dist, 8.) * 0.5, fogGamma), \n        fogFactor\n    );\n    float lum = (diffuse.r + diffuse.g + diffuse.b) / 3.;\n    neonGlow *= max(0.5, (1. - lum));\n    vec3 neonGlowColor = mix(o.Neon.color, fogColor, fogFactor);\n    col += neonGlowColor * neonGlow * o.Neon.emission; \n    float ornGlow = mix(\n        GetGlow(o.Ornament.dist, 4.5), \n        pow(GetGlow(o.Ornament.dist, 9.) * 0.5, fogGamma), \n        fogFactor\n    );\n    ornGlow *= max(0.25, (1. - lum));\n    float ornFlick = Flicker(_FlickerPhase, _FlickerRate);\n    ornFlick = smoothstep(0.0, 0.25, ornFlick);\n    ornGlow *= mix(0.75, 1., ornFlick);   \n   \n    vec3 ornGlowColor = mix(pow(o.Ornament.color, vec3(2.)), fogColor, fogFactor);\n    col += ornGlowColor * ornGlow * o.Ornament.emission;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rot = vec2(_XRot, _YRot);\n    if( iMouse.z>0.0 ) rot += ((iMouse.yx/iResolution.yx) * 2. - 1.) * vec2(4., 16.);\n\tvec3 dir = RayDir(_FOV, iResolution.xy, fragCoord);\n    dir *= XRotationMatrix(rot.x);\n    dir = dir * YRotationMatrix(rot.y);\n    vec3 pos = vec3(_XPos, _YPos, _ZPos);\n    Objects o;\n    float dist = March(pos, dir, 0., o);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 diffuse = vec3(0.);\n    if (dist > MAX_DIST - EPSILON) \n    {\n        float bgGradient = InvLerp(0.5, 1., uv.y);\n        diffuse = mix(\n            pow(BLUE, vec3(2.)), \n            pow(PINK, vec3(3.)), \n            bgGradient\n        );\n    }\n    else\n    {\n        vec3 p = pos + dist * dir;\n        vec3 normal = GetNormal(p);\n        diffuse = Color(o, pos, dir, normal, dist);\n    }\n    // final color tweak\n    diffuse = pow(diffuse, vec3(1.25));\n    fragColor = vec4(diffuse, 1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1781, 1781, 1802, 1802, 1920], [1921, 1921, 1991, 1991, 2266], [2267, 2267, 2307, 2307, 2432], [2433, 2433, 2483, 2483, 2547], [2548, 2548, 2585, 2585, 2761], [2762, 2762, 2799, 2799, 2978], [2979, 2979, 3016, 3016, 3193], [3194, 3194, 3223, 3223, 3438], [3439, 3439, 3469, 3469, 3571], [3572, 3572, 3615, 3615, 3662], [3663, 3703, 3752, 3752, 3931], [3932, 3972, 4007, 4007, 4063], [4064, 4104, 4163, 4207, 5393], [5394, 5477, 5508, 5508, 5618], [5619, 5702, 5726, 5726, 5825], [5826, 5826, 5867, 5867, 7847], [7848, 7878, 7918, 7918, 8011], [8012, 8012, 8048, 8048, 9400], [9401, 9472, 9496, 9496, 9537], [9538, 9584, 9610, 9610, 9840], [9841, 9841, 9907, 9907, 10186], [10187, 10232, 10270, 10270, 10803], [10804, 10939, 10971, 10971, 11056], [11060, 11060, 11130, 11130, 11347], [11348, 11348, 11414, 11524, 11852], [11853, 11853, 11913, 11913, 12045], [12046, 12175, 12239, 12239, 12331], [12332, 12332, 12410, 12410, 13987], [13988, 13988, 14028, 14028, 14228], [14229, 14229, 14297, 14297, 18160], [18162, 18162, 18218, 18218, 19110]], "test": "untested"}
{"id": "DlXGDH", "name": "细胞游戏", "author": "taotao", "description": "~", "tags": ["simulateants"], "likes": 3, "viewed": 163, "published": 3, "date": "1671661607", "time_retrieved": "2024-07-30T16:11:40.992450", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=texture(iChannel0,(fragCoord)/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define dpix iResolution.xy\n#define time iTime\n\n\n\nfloat get(vec2 uv,vec2 neg)\n{\n \n    return texture(iChannel0,(uv+neg/dpix)).a;\n\n}\n\nvec4 eva(float sum,vec4 cell)\n{\n    \n    float wascell=mod(cell.a,2.);\n        \n    //康威游戏规则\n    float isg=step(abs(sum-3.),0.1);\n    float isl=step(abs(sum-2.),0.1);\n    \n    float iscell=step(.9,isg+isl*wascell);\n    float gg=(1.-iscell)*wascell;\n    \n \n    //return vec4(cc,iscell);\n    \n \n    return vec4(iscell*cell.b,\n                (1.-iscell)*cell.b,\n                max(cell.b*0.98,gg),\n                cell.a-wascell+iscell);\n     \n                \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    //uv=floor(uv*dpix);\n     \n    vec2 touch=iMouse.xy/iResolution.xy;\n    vec3 of=vec3(1.,-1.,0.);\n    \n    float sum=get(uv,of.xx)\n    +get(uv,of.xy)\n    +get(uv,of.xz)\n    +get(uv,of.yx)\n    +get(uv,of.yy)\n    +get(uv,of.yz)\n    +get(uv,of.zx)\n    +get(uv,of.zy);\n   \n    if (iMouse.z>0.&&length(uv-touch)<.02)\n        sum=3.;\n        \n    vec4 cell=texture(iChannel0,uv);\n        \n    fragColor=eva(sum,cell);\n   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 120]], "test": "untested"}
{"id": "ctXGD8", "name": "Stochastic bokeh blur (not good)", "author": "fishy", "description": "Meh", "tags": ["sketch"], "likes": 20, "viewed": 418, "published": 3, "date": "1671655995", "time_retrieved": "2024-07-30T16:11:41.751421", "image_code": "#define HPI 1.57079632679\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 stochasticBokehBlur(sampler2D tex, vec2 p, float radius, float ratio, float gamma, float samples)\n{\n    vec4 acc = vec4(0);\n    for(float i = 0.; i < samples; i++)\n    {\n        vec2 rnd = hash22((p+i)*25.)*vec2(TAU, 1);\n        rnd = vec2(cos(rnd.x)*ratio, sin(rnd.x))*sqrt(rnd.y)*radius;\n        acc += pow(texture(tex, p+rnd), vec4(gamma));\n    }\n    return pow(acc/samples, 1./vec4(gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = stochasticBokehBlur(iChannel1, uv, max(0., abs(uv.y-iMouse.y/iResolution.y)-0.1)*0.1, iResolution.y/iResolution.x, 4., 32.);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXGD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 99, 99, 235], [237, 237, 341, 341, 638], [640, 640, 697, 747, 955]], "test": "untested"}
{"id": "Dlf3W8", "name": "Sketchy sphere", "author": "fishy", "description": "Failed bokeh blur attempt made this", "tags": ["sketch"], "likes": 8, "viewed": 268, "published": 3, "date": "1671654644", "time_retrieved": "2024-07-30T16:11:42.639049", "image_code": "#define HPI 1.57079632679\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 stochasticBokehBlur(sampler2D tex, vec2 p, float radius, float ratio, float gamma, float samples)\n{\n    vec4 acc = vec4(0);\n    for(float i = 0.; i < samples; i++)\n    {\n        vec2 rnd = hash22(p+i+floor(iTime/0.05))*vec2(1, 1);\n        rnd.y*=rnd.y;\n        rnd = vec2(cos(rnd.x), sin(rnd.x))*rnd.y*radius;\n        rnd.x *= ratio;\n        acc += pow(texture(tex, p+rnd), vec4(gamma));\n    }\n    return pow(acc/samples, 1./vec4(gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = stochasticBokehBlur(iChannel0, uv, 0.1, iResolution.y/iResolution.x, 1., 16.)*(1.2-smoothstep(0.25, 0.3, length((fragCoord*2.-iResolution.xy)/iResolution.y)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(step(0.3, length((fragCoord*2.-iResolution.xy)/iResolution.y)));\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlf3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 99, 99, 235], [237, 237, 341, 341, 682], [684, 684, 741, 791, 1034]], "test": "untested"}
{"id": "DtX3W8", "name": "mini blackbody spectrum", "author": "fishy", "description": "Not intended to be super tiny (as in codegolfed) but just simply made a little more portable... however, I'd love to see anyone's attempts at making it smaller.", "tags": ["spectrum", "blackbody"], "likes": 5, "viewed": 232, "published": 3, "date": "1671651298", "time_retrieved": "2024-07-30T16:11:43.385054", "image_code": "#define HPI 1.57079632679\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define responseCurve(w, p, v) sin(TAU*saturate((v-p)/w + 0.5) - HPI)*0.5+0.5\nvec3 getBlackbodyColor(float t)\n{\n    vec3 col = vec3(0), m = vec3(0);\n    for(float v = 400.; v < 700.; v += 75.)\n    {\n        vec3 r = vec3(responseCurve(100., 440., v),\n                      responseCurve(200., 550., v),\n                      responseCurve(200., 600., v));\n        m += r;\n        col += 2.*v*v*v*(1./(exp(v/t) - 1.))*r;\n    }\n    return col/m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(sqrt(getBlackbodyColor(uv.x*20.+15.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtX3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 228, 228, 562], [564, 564, 621, 621, 728]], "test": "untested"}
{"id": "dts3Dr", "name": "😎 Pixel Rave 😎", "author": "fishy", "description": "I couldn't resist adding the music visualizer...", "tags": ["2d", "motion", "pixelart", "human", "stickman"], "likes": 28, "viewed": 480, "published": 3, "date": "1671647440", "time_retrieved": "2024-07-30T16:11:44.405326", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n//https://lospec.com/palette-list/endesga-32\n#define c0 vec3(184,111,80)/255.\n#define c1 vec3(194,133,105)/255.\n#define c2 vec3(228,166,114)/255.\n#define c3 vec3(232,183,150)/255.\n\nvec4 hue(float x)\n{\n    return .5+.5*cos(6.283185*(x +vec4(0,1,-1,0)/3.)); // by FabriceNeyret2 from https://www.shadertoy.com/view/MtG3Wh\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    // Looks buggy around the border\n    f.x += 10.;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.3;\n    vec3 tx = texelFetch(iChannel0, ivec2(sc*f), 0).rgb;\n    vec3 col = vec3(0);\n    \n    float w = 64. / sc;\n    f.x += floor(-30. * iTime/sc) - 4.;\n    float ix = floor(f.x/w);\n    vec4 h = h41(ix);\n    \n    if (tx == vec3(1)) tx = vec3(24,20,37)/255.;\n    else if (tx.r > 0.) col = c0 * tx.r;\n    else if (tx.b > 0.) col = c1 * tx.b;\n    else if (tx.g > 0.) col = c2 * tx.g;\n    \n    //float a = texelFetch(iChannel0, ivec2(sc*f), 0).a;\n    vec3 pl = .5+.5*cos(2.*pi*(ix/8. + vec3(0,1,2)/3.));\n    float mx = mix(0., 0.5-0.5*uv.y, .25+.25*thc(400.,2.*pi*h.x - 10.*h.x*uv.y+iTime));// + .5 * thc(4.,.2*uv.y+0.24*ix*pi+iTime);\n    //mx *= 0.5 + 0.5 * thc(4., 0.5 * iTime);\n    mx *= tanh(0.1 * iTime);\n    if (tx == vec3(0)) {\n        col = vec3(mix(240.,210.,.5-uv.y))/255.;\n        col = mix(col, pl, mx);\n    }\n    else\n        col = mix(col, col * (.6+.4*pl), mx);\n      \n    //float o = 2.*pi/3.;\n    //col += 0.2 * thc(40000., log(length(uv))*0.25 -0.5*iTime+ vec3(-o,0,o));\n\n    //vec3 col2 = vec3(exp(-8.*f.y/iResolution.y));\n    //col = mix(col, (1.-col) + col2, .5+.5*thc(40.,ix*pi + iTime));\n    //col = mix(col, col2, 1.-tx);\n        \n    fragColor = vec4(col,1.0);\n    fragColor *= hue(f.y/iResolution.y*0.3+iTime)*pow(texture(iChannel1, vec2(f.y/iResolution.y/50., 0), 6.).r, 6.)*0.7+0.3;\n    //fragColor = ;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat line(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n\n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat stride(float t, float i) {\n    float a = pi / 2.;\n    float f = min(1., mod(t + i * a, 2. * a) / a);\n    \n    // Some of these need remapping to [0,1]\n    //return pow(4.*f*(1.-f),2.);\n    //return 4. * f * (1.-f) * (1.-f);\n    return sqrt(1. - pow(2.*f-1., 2.));\n    //return 0.5 * abs(sin(pi * f));\n}\n\nvec2 footHeight(float t, float sw) {\n    t *= 0.1;\n    //return vec2(0);\n    return vec2(10. + 10. * cos(t + 0.01 * sw), 10. + 10. * cos(t));\n}\n\n\n// Gets 3rd point on isosceles triangle equidistant from p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.; \n    float d = 0.5 * length(p-q);\n    \n    // a=2. is min distance from pq line, so it doesn't snap\n    // into place and skip too many pixels at once\n    float a = 2.; // 3 is believable too\n    if (v > d) \n        a = sqrt(v * v - d * d);\n    \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + a * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 6. * iTime;\n       \n    float w = 64.;\n    f.x += floor(-5.*t);\n    float ix = floor(f.x / w);\n    f.x = mod(f.x, w) - w/2.;\n    f -= 0.5;\n\n    // Random values (sloppy)\n    vec4 h = h41(ix);\n    vec4 h2 = h41(2.*ix-103.4);\n    vec4 h3 = h41(-1.1*ix + 513.2);\n    vec4 h4 = h41(-0.21*ix + 317.);\n    t += 2.*pi*h.z;\n\n    // --- PARAMETERS ---  \n      \n    float sw = -2. - 20. * h.z;     // Stride width\n    vec2  sh = vec2(8); // Stride height (Left, Right)\n    \n    float vHip = 4.;         // Hip vertical motion per step\n    float xHip = (1.+5.*h4.x) * (1.5-2.*abs(cos(t))); // Hip horizontal offset\n    vec2 dimHip = vec2(8.,4.) * h2.y; // Hip dims (Length, Height-Osc)\n    float hHip = 15. + 20. * h.x;// Hip height\n    float aHip = -t;      // Hip angle\n    \n    float dTor = 4. + 35. * h.y;   // Torso length\n    float aTor = pi/2.; // Torso angle\n    \n    vec2 dimSho = vec2(10. * h2.y, 10. * h2.z);  // Shoulder dims (Length, Height-Osc)\n    \n    float dLeg = (.35 + .5 * h2.w) * hHip;  // Leg length/2, dLeg > (vHip+hHip)/2\n    \n    vec2 hFoot = 2.+0.*footHeight(t, sw); // Foot height\n    vec2 dFoot = vec2(4); // Foot length\n    float tf = 3.;    // Toe fluidity (idk how to describe this)\n \n    vec2 dElb = vec2(4. + 10. * h.z);      // Elbow length (Left, Right)\n    vec2 aElb = -0.5 * pi + 0.5*pi*(h4.z-0.5)   // Elbow angle\n                -0.5 * pi * vec2(cos(t), -cos(t)); \n    \n    vec2 dHand = 0.8 * (1. + h4.y) * dElb;//vec2(2. + 10. * h.w);     // Hand length (forearm)\n    vec2 aHand = -0.3 * pi // Hand angle \n                 -1.3 * h3.x * pi * vec2(cos(t), -cos(t));\n    \n    //vec2 dFing = vec2(2); // Finger length\n    \n    float dNeck = 2. + 10. * h3.y;             // Neck length\n    float aNeck = pi/2.+pi/8.*cos(t) + // Neck angle\n                  (2.*h3.z-1.) * pi/4.; \n    \n    float dHead = floor(2. + 6. * h3.w); // Head radius\n \n \n \n    // --- POINTS ---\n    \n    // Centre x coord\n    float spd = 0.*0.75 * sw; // (needs improving)\n    float x = spd * t;\n    \n    // Centre (of hip)\n    vec2 p = round(vec2(x - xHip, 0.*0.5*hFoot + hHip + vHip * abs(cos(t))));\n    \n    // Hip\n    vec2 pHip1 = round(p - dimHip * vec2(cos(aHip), sin(aHip)));\n    vec2 pHip2 = round(p + dimHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot\n    vec2 pFoot1 = round(vec2(x-sw*cos(t), \n                        hFoot.x + sh.x * stride(.5*t, 0.)));\n    vec2 pFoot2 = round(vec2(x+sw*cos(t), \n                        hFoot.y + sh.y * stride(.5*t, 1.)));\n        \n    // Toe\n    float o = -pi/12.; // Land on heels or toes?\n    vec2 pToe1 = vec2(x+tf-sw*cos(t+o), \n                      hFoot.x + .5*sh.x*stride(.5*t+o, 0.));\n    vec2 pToe2 = vec2(x+tf+sw*cos(t+o), \n                      hFoot.y + .5*sh.y*stride(.5*t+o, 1.));\n    vec2 fdir1 = normalize(pToe1 - pFoot1);\n    vec2 fdir2 = normalize(pToe2 - pFoot2);\n    pToe1 = round(pFoot1 + dFoot.x * fdir1);\n    pToe2 = round(pFoot2 + dFoot.y * fdir2);\n\n    // Knee\n    vec2 pKnee1 = getTriPoint(f, pHip1, pFoot1, dLeg);\n    vec2 pKnee2 = getTriPoint(f, pHip2, pFoot2, dLeg);\n      \n    // Neck\n    vec2 pNeck = round(vec2(x + xHip, p.y) + \n                       dTor * vec2(cos(aTor), sin(aTor)));\n      \n    // Shoulder\n    vec2 pSho1 = round(pNeck - dimSho * vec2(cos(aHip), sin(aHip)));\n    vec2 pSho2 = round(pNeck + dimSho * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow\n    vec2 pElb1 = round(pSho1 + dElb.x * vec2(cos(aElb.x), sin(aElb.x)));\n    vec2 pElb2 = round(pSho2 + dElb.y * vec2(cos(aElb.y), sin(aElb.y)));\n      \n    // Hand \n    vec2 pHand1 = round(pElb1 + dHand.x * vec2(cos(aHand.x), sin(aHand.x)));\n    vec2 pHand2 = round(pElb2 + dHand.y * vec2(cos(aHand.y), sin(aHand.y)));\n      \n    // Neck\n    vec2 dirHead = vec2(cos(aNeck), sin(aNeck)); \n    vec2 pHead = round(pNeck + dNeck * dirHead);\n    \n    \n \n    // --- DRAW ---  \n      \n    // Hip\n    col.b += line(f, pHip1, pHip2);  \n    \n    // Legs\n    col.r += line(f, pHip1,  pKnee1) + \n             line(f, pKnee1, pFoot1) +\n             line(f, pFoot1, pToe1);\n    col.g += line(f, pHip2,  pKnee2) + \n             line(f, pKnee2, pFoot2) +\n             line(f, pFoot2, pToe2);\n       \n    // Torso\n    col.b += line(f, p, pNeck);\n    \n    // Shoulder\n    col.b += line(f, pSho1, pSho2);\n    \n    // Arms\n    col.r += line(f, pSho1, pElb1) +\n             line(f, pElb1, pHand1);\n    col.g += line(f, pSho2, pElb2) + \n             line(f, pElb2, pHand2);\n\n    // Neck\n    col.b += line(f, pNeck, pHead);\n   \n    // Head\n    float head = length(round(f - pHead - dHead * dirHead));\n    float sHead = step(head, dHead + .5);\n    col.b += sHead;\n   \n    float l = 1.-step(30.+20.*cos(0.1*t + 0.01*f.x), f.y);\n   \n    //float l = length(col);\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, l);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec4 cell(in sampler2D tx, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(tx, 0));\n    p = (p+r) % r;\n    return texelFetch(tx, p, 0 );\n}\n\nfloat mx(vec4 b) {\n    return max(b.x,max(b.y,b.z));\n}\n\nfloat mx(float a, vec4 b) {\n    return max(max(a,b.x),max(b.y,b.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{ \n    float n = 2.; \n    vec4 e = vec4(0); // Colors\n    vec4 e2 = vec4(0);\n    float p = 0.;     // Outline\n    for (float i = -n; i < n + 1.; i++) {\n        for (float j = -n; j < n + 1.; j++) {\n            vec4 c = cell(iChannel0, ivec2(f + vec2(i,j)));\n            if (abs(i) <= n-1. && abs(j) <= n-1.)    \n                e = max(e, c);\n            if (abs(i) != n || abs(j) != n) {\n                e2 = max(e2, c);\n                p = mx(p, c);            \n            }\n        }\n    }\n   \n    // Could replace RGB with just R and use different values\n    e.rb *= step(e.g, 0.);\n    e.r  *= step(e.b, 0.);\n    \n    e2.rb *= step(e2.g, 0.);\n    e2.r  *= step(e2.b, 0.);\n    float q = mx(e);\n    \n    if (e.b > 0.)\n        e.b -= 0.25 * e2.g;\n    if (e.r > 0.)\n        e.r -= 0.25 * e2.b;\n    e.rgb += vec3(p-q);\n\n    //e = e2 - e;//vec4(p-q);\n\n   // vec4 e3 = cell(iChannel1, ivec2(f + vec2(1,2)));\n   // e = mix(e, e3, 0.1);\n\n    fragColor = e;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Ideas:\n// - Change stride height randomly to match some obstacles, move body up\n//   and down so it appears to climb over obstacles.\n// - Make zombie army\n// - Pick from collection of movement functions e.g. for stride\n\n// Improvements:\n// - Interior outline if arm overlaps leg\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 h41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 31485, "src": "https://soundcloud.com/kordhell/murder-in-my-mind", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dts3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 260, 260, 381], [383, 383, 432, 469, 1889]], "test": "untested"}
{"id": "dtl3Dr", "name": "3D Audio Visualizer", "author": "kishimisu", "description": "Continuation of my attemps to extract audio features from a song", "tags": ["raymarching", "sound", "interactive", "music", "pixel", "light", "bloom", "visual", "live", "neon"], "likes": 120, "viewed": 4734, "published": 3, "date": "1671645706", "time_retrieved": "2024-07-30T16:11:45.172275", "image_code": "/* \"3D Audio Visualizer\" by @kishimisu - 2022 (https://www.shadertoy.com/view/dtl3Dr)\n    \n    This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n    Wait for the drop!\n\n   The lights of this scene react live to the audio input.\n   I'm trying to find interesting ways to extract audio\n   features from the audio's FFT to animate my scenes.\n   \n   Each light is associated to a random frequency range,\n   ranging from bass (distant lights) to high (close lights)   \n   \n   Really happy with this result!\n*/\n\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define light(d, att) 1. / (1.+pow(abs(d*att), 1.3))\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n\nfloat logisticAmp(float amp){\n   float c = st(0., 10., .8, 1.), a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return logisticAmp(getLevel(freq));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv   = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col  = vec3(0.);\n    float vol = getVol(8.);\n    \n    float hasSound = 1.; // Used only to avoid a black preview image\n    if (iChannelTime[0] <= 0.) hasSound = .0;\n \n    for (float i = 0., t = 0.; i < 30.; i++) {\n        vec3 p  = t*normalize(vec3(uv, 1.));        \n        \n        vec3 id = floor(abs(p));\n        vec3 q  = fract(p)-.5;\n        \n        float boxRep = sdBox(q, vec3(.3));\n        float boxCtn = sdBox(p, vec3(7.5, 6.5, 16.5));\n\n        float dst = max(boxRep, abs(boxCtn) - vol*.2);     \n        float freq = smoothstep(16., 0., id.z)*3.*hasSound + hash13(id)*1.5;\n       \n        col += vec3(.8,.6,1) * (cos(id*.4 + vec3(0,1,2) + iTime) + 2.) \n             * light(dst, 10. - vol) \n             * getPitch(freq, 1.);\n        \n        t += dst;\n    }\n    \n    fragColor = vec4(col,1.0);   \n}", "image_inputs": [{"id": 31481, "src": "https://soundcloud.com/blazerjacket/blazerjacket-x-neogarde-freedom-or-death", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtl3Dr.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[894, 894, 923, 923, 1055], [1056, 1056, 1097, 1097, 1215], [1216, 1216, 1245, 1245, 1362], [1394, 1394, 1425, 1425, 1512], [1513, 1513, 1536, 1536, 1639], [1641, 1641, 1698, 1698, 2580]], "test": "untested"}
{"id": "mts3Wr", "name": "simple labyrinth", "author": "jonasfrey", "description": "labyrinth", "tags": ["labyrinth"], "likes": 3, "viewed": 200, "published": 3, "date": "1671643111", "time_retrieved": "2024-07-30T16:11:46.146670", "image_code": "vec4 f_o_index2d_by_o_fc_o_ires(vec2 o_fc, vec2 o_ires){\n    float n_index_x = floor(o_fc.x) + floor(o_fc.y) * (o_ires.x);\n    float n_index_x_nor = (floor(n_index_x) / (floor(o_ires.x) * floor(o_ires.y)));\n    float n_index_y = floor(o_fc.y) + floor(o_fc.x) * (o_ires.y);\n    float n_index_y_nor = (floor(n_index_y) / (floor(o_ires.y) * floor(o_ires.x)));\n    return vec4(\n        n_index_x,//+fract(o_fc.x), \n        n_index_x_nor, \n        n_index_y,//+fract(o_fc.y), \n        n_index_y_nor\n    );\n}\n\nfloat f_n_rand(float n){\n    n = sin(n*23.1234)*201.23;\n    n = n + n*n;\n    return fract(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_factor = 0.2;\n    float n_summand = 0.; //iTime;\n    \n    vec2 o_fc = floor(fragCoord.xy*n_factor+n_summand);\n    vec2 o_ires = floor(iResolution.xy*n_factor+n_summand);\n    \n    vec2 o_fc1_nor = vec2(1.)/o_ires.xy;\n    \n    vec2 o_fc_nor = o_fc.xy * o_fc1_nor;\n    \n    float n_ratio_ires_x_to_y = o_ires.x / o_ires.y;\n    \n    vec2 o_fc_nor_offset = \n        (o_fc_nor-0.5) \n        * vec2(n_ratio_ires_x_to_y, 1.);\n        \n    //float n_dist = length(o_fc_nor_offset);\n    \n    vec4 o_index2d_by_o_fc_o_ires = f_o_index2d_by_o_fc_o_ires(\n        o_fc, o_ires\n    );\n    float n_rand = f_n_rand(o_index2d_by_o_fc_o_ires[1]);\n    float bx = mod(floor(o_fc.x),2.);\n    float by = mod(floor(o_fc.y),2.);\n    \n    fragColor = vec4(bx*by + float(n_rand>0.5));\n    fragColor = 1.-fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 502], [504, 504, 528, 528, 599], [601, 601, 658, 658, 1460]], "test": "untested"}
{"id": "dls3Wr", "name": "Direct font → SDF rendering", "author": "mkeeter", "description": "We can combine the quadratic SDF from [1] with the winding rule trick from [2] and render fonts directly from their Bézier control points!\n\n[1] https://www.shadertoy.com/view/MlKcDD\n[2] https://www.shadertoy.com/view/Nt2yzd", "tags": ["sdf", "bezier", "font", "quadratic", "windingrule"], "likes": 33, "viewed": 2037, "published": 3, "date": "1671642272", "time_retrieved": "2024-07-30T16:11:47.076184", "image_code": "// Using distance-to-quadratic and winding number to generate a closed-form\n// distance field of a font outline, which is specified as lines + quadratic\n// Bézier curves.\n//\n// Quadratic solver is based on https://www.shadertoy.com/view/MlKcDD, which\n// includes the following copyright notice:\n//\n//      Copyright © 2018 Inigo Quilez\n//      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Curves are baked by an external tool\n#define QUAD_COUNT 38\nconst vec2 QUADS[QUAD_COUNT * 3] = vec2[QUAD_COUNT * 3](\n    vec2(0.5758487, -4.5724106), vec2(0.5758487, -4.9204984), vec2(0.7176622, -5.221315),\n    vec2(0.7176622, -5.221315), vec2(0.8594757, -5.5221314), vec2(1.1216158, -5.758487),\n    vec2(0.7520412, -2.0842285), vec2(0.8594757, -1.6974645), vec2(1.0034379, -1.3859046),\n    vec2(0.86162436, -3.5904598), vec2(0.5758487, -3.9664803), vec2(0.5758487, -4.5724106),\n    vec2(1.0034379, -1.3859046), vec2(1.1474, -1.0743446), vec2(1.3837559, -0.8036098),\n    vec2(1.1216158, -5.758487), vec2(1.3708637, -5.9819508), vec2(1.7103566, -6.1087236),\n    vec2(1.3794585, -4.9591746), vec2(1.3794585, -4.563816), vec2(1.5642458, -4.3038244),\n    vec2(1.3837559, -0.8036098), vec2(1.6072196, -0.55006444), vec2(1.9058874, -0.3996562),\n    vec2(1.5642458, -4.3038244), vec2(1.7490331, -4.0438333), vec2(2.101418, -3.8762355),\n    vec2(1.6630855, -2.9823806), vec2(1.1474, -3.2144392), vec2(0.86162436, -3.5904598),\n    vec2(1.6673828, -5.599484), vec2(1.3794585, -5.337344), vec2(1.3794585, -4.9591746),\n    vec2(1.6974645, -0.0021486892), vec2(1.2892135, -0.12892136), vec2(0.99269444, -0.30941126),\n    vec2(1.7103566, -6.1087236), vec2(2.0498495, -6.235496), vec2(2.419424, -6.235496),\n    vec2(1.9058874, -0.3996562), vec2(2.2045553, -0.24924795), vec2(2.599914, -0.24924795),\n    vec2(2.101418, -3.8762355), vec2(2.4151268, -3.7258272), vec2(2.718092, -3.616244),\n    vec2(2.2862053, -2.7266867), vec2(1.9252255, -2.862054), vec2(1.6630855, -2.9823806),\n    vec2(2.363558, -5.8616242), vec2(1.9553072, -5.8616242), vec2(1.6673828, -5.599484),\n    vec2(2.419424, -6.235496), vec2(2.840567, -6.235496), vec2(3.173614, -6.106575),\n    vec2(2.5139663, 0.12462398), vec2(2.1057155, 0.12462398), vec2(1.6974645, -0.0021486892),\n    vec2(2.599914, -0.24924795), vec2(2.896433, -0.24924795), vec2(3.117748, -0.32660076),\n    vec2(2.718092, -3.616244), vec2(3.0210571, -3.506661), vec2(3.3046842, -3.382037),\n    vec2(2.9265146, -2.4795873), vec2(2.647185, -2.5913193), vec2(2.2862053, -2.7266867),\n    vec2(3.0167596, -5.7133646), vec2(2.7503223, -5.8616242), vec2(2.363558, -5.8616242),\n    vec2(3.117748, -0.32660076), vec2(3.3390632, -0.40395358), vec2(3.4765792, -0.54576707),\n    vec2(3.173614, -6.106575), vec2(3.506661, -5.9776535), vec2(3.781693, -5.8057585),\n    vec2(3.3046842, -3.382037), vec2(3.5625267, -3.270305), vec2(3.8010314, -3.1284916),\n    vec2(3.4679844, -5.315857), vec2(3.2831972, -5.565105), vec2(3.0167596, -5.7133646),\n    vec2(3.4765792, -0.54576707), vec2(3.6140952, -0.6875806), vec2(3.6807046, -0.8788139),\n    vec2(3.54104, -2.0004296), vec2(3.3347657, -2.316287), vec2(2.9265146, -2.4795873),\n    vec2(3.6807046, -0.8788139), vec2(3.747314, -1.0700473), vec2(3.747314, -1.3192952),\n    vec2(3.747314, -1.3192952), vec2(3.747314, -1.6845723), vec2(3.54104, -2.0004296),\n    vec2(3.775247, -4.7400084), vec2(3.657069, -5.0580144), vec2(3.4679844, -5.315857),\n    vec2(3.8010314, -3.1284916), vec2(4.039536, -2.9866781), vec2(4.2157283, -2.7975934),\n    vec2(3.9879673, -4.073915), vec2(3.893425, -4.4220023), vec2(3.775247, -4.7400084),\n    vec2(3.996562, -0.3996562), vec2(3.3992264, 0.12462398), vec2(2.5139663, 0.12462398),\n    vec2(4.2157283, -2.7975934), vec2(4.4091105, -2.5827246), vec2(4.501504, -2.3270304),\n    vec2(4.501504, -2.3270304), vec2(4.593898, -2.0713365), vec2(4.593898, -1.7318435),\n    vec2(4.593898, -1.7318435), vec2(4.593898, -0.92393637), vec2(3.996562, -0.3996562)\n);\n\n#define LINE_COUNT 8\nconst vec2 LINES[LINE_COUNT * 2] = vec2[LINE_COUNT * 2](\n    vec2(0.40395358, -2.0842285), vec2(0.7520412, -2.0842285),\n    vec2(0.46411687, 0.0042973785), vec2(0.40395358, -2.0842285),\n    vec2(0.80790716, 0.0042973785), vec2(0.46411687, 0.0042973785),\n    vec2(0.99269444, -0.30941126), vec2(0.80790716, 0.0042973785),\n    vec2(3.781693, -5.8057585), vec2(3.9578855, -6.09798),\n    vec2(3.9578855, -6.09798), vec2(4.301676, -6.09798),\n    vec2(4.301676, -6.09798), vec2(4.336055, -4.073915),\n    vec2(4.336055, -4.073915), vec2(3.9879673, -4.073915)\n);\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat cro(in vec2 a, in vec2 b) { return a.x * b.y - a.y * b.x; }\n\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    if(h >= 0.0) { // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        // When p≈0 and p<0, h - q has catastrophic cancelation. So, we do\n        // h=√(q² + 4p³)=q·√(1 + 4p³/q²)=q·√(1 + w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1 + ½w) so that the q's\n        // cancel each other in h - q. Expanding and simplifying further we\n        // get x=vec2(p³/q, -p³/q - q). And using a second degree Taylor\n        // expansion instead: x=vec2(k, -k - q) with k=(1 - p³/q²)·p³/q\n        if(abs(abs(h/q) - 1.0) < 0.0001) {\n            float k = (1.0 - p3 / q2) * p3 / q;  // quadratic approx\n            x = vec2(k, -k - q);\n        }\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0/3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2  q = d + (c + b * t) * t;\n        res = dot2(q);\n        sgn = cro(c + 2.0 * b * t, q);\n    } else { // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3  t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2  qx=d + (c + b * t.x) * t.x;\n        float dx = dot2(qx), sx = cro(c + 2.0 * b * t.x, qx);\n        vec2  qy=d + (c + b * t.y) * t.y;\n        float dy = dot2(qy);\n        float sy = cro(c + 2.0 * b * t.y, qy);\n        if (dx<dy) {\n            res=dx;\n            sgn=sx;\n        } else {\n            res=dy;\n            sgn=sy;\n        }\n    }\n\n    return sqrt(res) * sign(sgn);\n}\n\n// Source: https://www.shadertoy.com/view/wdBXRW\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 e = b - a;\n    vec2 w = p - a;\n\n    // winding number from http://geomalgorithms.com/a03-_inclusion.html\n    bvec3 cond = bvec3(p.y >= a.y, \n                       p.y < b.y, \n                       e.x*w.y > e.y*w.x);\n    if( all(cond) || all(not(cond))) {\n        return -1.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat winding_angle(in vec2 p, in vec2 a, in vec2 b) {\n    float pa = dot2(a - p);\n    float pb = dot2(b - p);\n    float ab = dot2(a - b);\n    float ang = acos((pa + pb - ab) / (2.0 * sqrt(pa * pb)));\n    return sign(cro(a - p, b - p)) * ang;\n}\n\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    p = (p + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m = (m + vec2(0.5, 0.75)) * vec2(4.0, -4.0);\n\n    float d = 1e10;\n    float winding = 1.0;\n    for (int i=0; i < QUAD_COUNT; i++) {\n        vec2 v0 = QUADS[i * 3];\n        vec2 v1 = QUADS[i * 3 + 1];\n        vec2 v2 = QUADS[i * 3 + 2];\n\n        float sd = sdBezier(p, v0, v1, v2);\n        d = min(d, abs(sd));\n\n        if (sd > 0.0 == cro(v1 - v2, v1 - v0) < 0.0) {\n            winding *= winding_sign(p, v0, v1);\n            winding *= winding_sign(p, v1, v2);\n        } else {\n            winding *= winding_sign(p, v0, v2);\n        }\n    }\n    for (int i=0; i < LINE_COUNT; i++) {\n        vec2 v0 = LINES[i * 2];\n        vec2 v1 = LINES[i * 2 + 1];\n        d = min(d, udSegment(p, v0, v1));\n        winding *= winding_sign(p, v0, v1);\n    }\n\n    d *= winding;\n\n    // Apply a color based on signed distance\n    vec3 col = vec3(1.0) - vec3(0.1, 0.4, 0.7) * sign(d);\n    col *= 1.0 - exp(-4.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(60.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    // Draw the mouse stuff\n    if(iMouse.z > 0.001) {\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, abs(sdBezier(m, v0, v1, v2)));\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, udSegment(m, v0, v1));\n        }\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.01));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.05));\n    }\n\n    { // Draw the skeleton of the Bezier curves\n        float d = 1e10;\n        for (int i=0; i < QUAD_COUNT; i++) {\n            vec2 v0 = QUADS[i * 3];\n            vec2 v1 = QUADS[i * 3 + 1];\n            vec2 v2 = QUADS[i * 3 + 2];\n            d = min(d, min(udSegment(p, v0, v1), udSegment(p, v1, v2)));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n            d = min(d, length(p - v2) - 0.05);\n        }\n        for (int i=0; i < LINE_COUNT; i++) {\n            vec2 v0 = LINES[i * 2];\n            vec2 v1 = LINES[i * 2 + 1];\n            d = min(d, udSegment(p, v0, v1));\n            d = min(d, length(p - v0) - 0.05);\n            d = min(d, length(p - v1) - 0.05);\n        }\n        col = mix(col, vec3(1, 0, 0), 1.0 - smoothstep(0.0, 0.014, d));\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dls3Wr.jpg", "access": "api", "license": "mit", "functions": [[5475, 5475, 5498, 5498, 5518], [5519, 5519, 5552, 5552, 5584], [5586, 5627, 5689, 5689, 7707], [7709, 7758, 7811, 7811, 8140], [8142, 8142, 8196, 8196, 8386], [8388, 8388, 8438, 8438, 8570], [8572, 8572, 8627, 8627, 11360]], "test": "ok"}
{"id": "dlsGWr", "name": "simple spectrogram", "author": "jonasfrey", "description": "simple", "tags": ["sound"], "likes": 2, "viewed": 206, "published": 3, "date": "1671640843", "time_retrieved": "2024-07-30T16:11:47.863080", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    vec4 o_img = texture(iChannel0, o_fc_nor);\n    fragColor = vec4(o_img.r);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fc1_nor = vec2(1.) / iResolution.xy;\n    vec2 o_fc_nor = o_fc1_nor * fragCoord.xy;\n    \n    vec4 o_col_last_xp1 = texture(\n        iChannel0, \n        vec2(o_fc_nor.x + o_fc1_nor.x , o_fc_nor.y)\n    );\n    if(o_fc_nor.x >= 1.-(o_fc1_nor.x*1.)){\n        float n_timedomain_amp = texture(iChannel1, vec2(o_fc_nor.y, 1.))[0];\n        float n_freqdomain_amp = texture(iChannel1, vec2(o_fc_nor.y, 0.))[0];\n        fragColor = vec4(\n            n_freqdomain_amp\n        );\n    }else{\n        fragColor =  o_col_last_xp1;   \n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31480, "src": "https://soundcloud.com/shepard-tone/shepard-tone1?si=a675f9d75c0143b3a43f2e136fb3e629&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 189]], "test": "untested"}
{"id": "dll3Wr", "name": "😎 Pixel Men 😎", "author": "SnoopethDuckDuck", "description": "Make sure you click the music thingy :)\n\n(Basically the same as fork)\n\n", "tags": ["2d", "motion", "pixelart", "human", "stickman"], "likes": 33, "viewed": 378, "published": 3, "date": "1671640800", "time_retrieved": "2024-07-30T16:11:48.792595", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n//https://lospec.com/palette-list/endesga-32\n#define c0 vec3(184,111,80)/255.\n#define c1 vec3(194,133,105)/255.\n#define c2 vec3(228,166,114)/255.\n#define c3 vec3(232,183,150)/255.\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    // Looks buggy around the border\n    f.x += 10.;\n    vec2 uv = (f - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = 0.3;\n    vec3 tx = texelFetch(iChannel0, ivec2(sc*f), 0).rgb;\n    vec3 col = vec3(0);\n    \n    float w = 64. / sc;\n    f.x += floor(-30. * iTime/sc) - 4.;\n    float ix = floor(f.x/w);\n    vec4 h = h41(ix);\n    \n    if (tx == vec3(1)) tx = vec3(24,20,37)/255.;\n    else if (tx.r > 0.) col = c0 * tx.r;\n    else if (tx.b > 0.) col = c1 * tx.b;\n    else if (tx.g > 0.) col = c2 * tx.g;\n    \n    //float a = texelFetch(iChannel0, ivec2(sc*f), 0).a;\n    vec3 pl = .5+.5*cos(2.*pi*(ix/8. + vec3(0,1,2)/3.));\n    float mx = mix(0., 0.5-0.5*uv.y, .25+.25*thc(400.,2.*pi*h.x - 10.*h.x*uv.y+iTime));// + .5 * thc(4.,.2*uv.y+0.24*ix*pi+iTime);\n    //mx *= 0.5 + 0.5 * thc(4., 0.5 * iTime);\n    mx *= tanh(0.1 * iTime);\n    if (tx == vec3(0)) {\n        col = vec3(mix(240.,210.,.5-uv.y))/255.;\n        col = mix(col, pl, mx);\n    }\n    else\n        col = mix(col, col * (.6+.4*pl), mx);\n      \n    //float o = 2.*pi/3.;\n    //col += 0.2 * thc(40000., log(length(uv))*0.25 -0.5*iTime+ vec3(-o,0,o));\n\n    //vec3 col2 = vec3(exp(-8.*f.y/iResolution.y));\n    //col = mix(col, (1.-col) + col2, .5+.5*thc(40.,ix*pi + iTime));\n    //col = mix(col, col2, 1.-tx);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31432, "src": "https://soundcloud.com/kordhell/murder-in-my-mind?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat line(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n\n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat stride(float t, float i) {\n    float a = pi / 2.;\n    float f = min(1., mod(t + i * a, 2. * a) / a);\n    \n    // Some of these need remapping to [0,1]\n    //return pow(4.*f*(1.-f),2.);\n    //return 4. * f * (1.-f) * (1.-f);\n    return sqrt(1. - pow(2.*f-1., 2.));\n    //return 0.5 * abs(sin(pi * f));\n}\n\nvec2 footHeight(float t, float sw) {\n    t *= 0.1;\n    //return vec2(0);\n    return vec2(10. + 10. * cos(t + 0.01 * sw), 10. + 10. * cos(t));\n}\n\n\n// Gets 3rd point on isosceles triangle equidistant from p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.; \n    float d = 0.5 * length(p-q);\n    \n    // a=2. is min distance from pq line, so it doesn't snap\n    // into place and skip too many pixels at once\n    float a = 2.; // 3 is believable too\n    if (v > d) \n        a = sqrt(v * v - d * d);\n    \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + a * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 6. * iTime;\n       \n    float w = 64.;\n    f.x += floor(-5.*t);\n    float ix = floor(f.x / w);\n    f.x = mod(f.x, w) - w/2.;\n    f -= 0.5;\n\n    // Random values (sloppy)\n    vec4 h = h41(ix);\n    vec4 h2 = h41(2.*ix-103.4);\n    vec4 h3 = h41(-1.1*ix + 513.2);\n    vec4 h4 = h41(-0.21*ix + 317.);\n    t += 2.*pi*h.z;\n\n\n\n    // --- PARAMETERS ---  \n      \n    float sw = -2. - 20. * h.z;     // Stride width\n    vec2  sh = vec2(8); // Stride height (Left, Right)\n    \n    float vHip = 4.;         // Hip vertical motion per step\n    float xHip = (1.+5.*h4.x) * (1.5-2.*abs(cos(t))); // Hip horizontal offset\n    vec2 dimHip = vec2(8.,4.) * h2.y; // Hip dims (Length, Height-Osc)\n    float hHip = 15. + 20. * h.x;// Hip height\n    float aHip = -t;      // Hip angle\n    \n    float dTor = 4. + 35. * h.y;   // Torso length\n    float aTor = pi/2.; // Torso angle\n    \n    vec2 dimSho = vec2(10. * h2.y, 10. * h2.z);  // Shoulder dims (Length, Height-Osc)\n    \n    float dLeg = (.35 + .5 * h2.w) * hHip;  // Leg length/2, dLeg > (vHip+hHip)/2\n    \n    vec2 hFoot = 2.+0.*footHeight(t, sw); // Foot height\n    vec2 dFoot = vec2(4); // Foot length\n    float tf = 3.;    // Toe fluidity (idk how to describe this)\n \n    vec2 dElb = vec2(4. + 10. * h.z);      // Elbow length (Left, Right)\n    vec2 aElb = -0.5 * pi + 0.5*pi*(h4.z-0.5)   // Elbow angle\n                -0.5 * pi * vec2(cos(t), -cos(t)); \n    \n    vec2 dHand = 0.8 * (1. + h4.y) * dElb;//vec2(2. + 10. * h.w);     // Hand length (forearm)\n    vec2 aHand = -0.3 * pi // Hand angle \n                 -1.3 * h3.x * pi * vec2(cos(t), -cos(t));\n    \n    //vec2 dFing = vec2(2); // Finger length\n    \n    float dNeck = 2. + 10. * h3.y;             // Neck length\n    float aNeck = pi/2.+pi/8.*cos(t) + // Neck angle\n                  (2.*h3.z-1.) * pi/4.; \n    \n    float dHead = floor(2. + 6. * h3.w); // Head radius\n \n \n \n    // --- POINTS ---\n    \n    // Centre x coord\n    float spd = 0.*0.75 * sw; // (needs improving)\n    float x = spd * t;\n    \n    // Centre (of hip)\n    vec2 p = round(vec2(x - xHip, 0.*0.5*hFoot + hHip + vHip * abs(cos(t))));\n    \n    // Hip\n    vec2 pHip1 = round(p - dimHip * vec2(cos(aHip), sin(aHip)));\n    vec2 pHip2 = round(p + dimHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot\n    vec2 pFoot1 = round(vec2(x-sw*cos(t), \n                        hFoot.x + sh.x * stride(.5*t, 0.)));\n    vec2 pFoot2 = round(vec2(x+sw*cos(t), \n                        hFoot.y + sh.y * stride(.5*t, 1.)));\n        \n    // Toe\n    float o = -pi/12.; // Land on heels or toes?\n    vec2 pToe1 = vec2(x+tf-sw*cos(t+o), \n                      hFoot.x + .5*sh.x*stride(.5*t+o, 0.));\n    vec2 pToe2 = vec2(x+tf+sw*cos(t+o), \n                      hFoot.y + .5*sh.y*stride(.5*t+o, 1.));\n    vec2 fdir1 = normalize(pToe1 - pFoot1);\n    vec2 fdir2 = normalize(pToe2 - pFoot2);\n    pToe1 = round(pFoot1 + dFoot.x * fdir1);\n    pToe2 = round(pFoot2 + dFoot.y * fdir2);\n\n    // Knee\n    vec2 pKnee1 = getTriPoint(f, pHip1, pFoot1, dLeg);\n    vec2 pKnee2 = getTriPoint(f, pHip2, pFoot2, dLeg);\n      \n    // Neck\n    vec2 pNeck = round(vec2(x + xHip, p.y) + \n                       dTor * vec2(cos(aTor), sin(aTor)));\n      \n    // Shoulder\n    vec2 pSho1 = round(pNeck - dimSho * vec2(cos(aHip), sin(aHip)));\n    vec2 pSho2 = round(pNeck + dimSho * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow\n    vec2 pElb1 = round(pSho1 + dElb.x * vec2(cos(aElb.x), sin(aElb.x)));\n    vec2 pElb2 = round(pSho2 + dElb.y * vec2(cos(aElb.y), sin(aElb.y)));\n      \n    // Hand \n    vec2 pHand1 = round(pElb1 + dHand.x * vec2(cos(aHand.x), sin(aHand.x)));\n    vec2 pHand2 = round(pElb2 + dHand.y * vec2(cos(aHand.y), sin(aHand.y)));\n      \n    // Neck\n    vec2 dirHead = vec2(cos(aNeck), sin(aNeck)); \n    vec2 pHead = round(pNeck + dNeck * dirHead);\n    \n    \n \n    // --- DRAW ---  \n      \n    // Hip\n    col.b += line(f, pHip1, pHip2);  \n    \n    // Legs\n    col.r += line(f, pHip1,  pKnee1) + \n             line(f, pKnee1, pFoot1) +\n             line(f, pFoot1, pToe1);\n    col.g += line(f, pHip2,  pKnee2) + \n             line(f, pKnee2, pFoot2) +\n             line(f, pFoot2, pToe2);\n       \n    // Torso\n    col.b += line(f, p, pNeck);\n    \n    // Shoulder\n    col.b += line(f, pSho1, pSho2);\n    \n    // Arms\n    col.r += line(f, pSho1, pElb1) +\n             line(f, pElb1, pHand1);\n    col.g += line(f, pSho2, pElb2) + \n             line(f, pElb2, pHand2);\n\n    // Neck\n    col.b += line(f, pNeck, pHead);\n   \n    // Head\n    float head = length(round(f - pHead - dHead * dirHead));\n    float sHead = step(head, dHead + .5);\n    col.b += sHead;\n   \n    float l = 1.-step(30.+20.*cos(0.1*t + 0.01*f.x), f.y);\n   \n    //float l = length(col);\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, l);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec4 cell(in sampler2D tx, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(tx, 0));\n    p = (p+r) % r;\n    return texelFetch(tx, p, 0 );\n}\n\nfloat mx(vec4 b) {\n    return max(b.x,max(b.y,b.z));\n}\n\nfloat mx(float a, vec4 b) {\n    return max(max(a,b.x),max(b.y,b.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{ \n    float n = 2.; \n    vec4 e = vec4(0); // Colors\n    vec4 e2 = vec4(0);\n    float p = 0.;     // Outline\n    for (float i = -n; i < n + 1.; i++) {\n        for (float j = -n; j < n + 1.; j++) {\n            vec4 c = cell(iChannel0, ivec2(f + vec2(i,j)));\n            if (abs(i) <= n-1. && abs(j) <= n-1.)    \n                e = max(e, c);\n            if (abs(i) != n || abs(j) != n) {\n                e2 = max(e2, c);\n                p = mx(p, c);            \n            }\n        }\n    }\n   \n    // Could replace RGB with just R and use different values\n    e.rb *= step(e.g, 0.);\n    e.r  *= step(e.b, 0.);\n    \n    e2.rb *= step(e2.g, 0.);\n    e2.r  *= step(e2.b, 0.);\n    float q = mx(e);\n    \n    if (e.b > 0.)\n        e.b -= 0.25 * e2.g;\n    if (e.r > 0.)\n        e.r -= 0.25 * e2.b;\n    e.rgb += vec3(p-q);\n\n    //e = e2 - e;//vec4(p-q);\n\n   // vec4 e3 = cell(iChannel1, ivec2(f + vec2(1,2)));\n   // e = mix(e, e3, 0.1);\n\n    fragColor = e;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Ideas:\n// - Change stride height randomly to match some obstacles, move body up\n//   and down so it appears to climb over obstacles.\n// - Make zombie army\n// - Pick from collection of movement functions e.g. for stride\n\n// Improvements:\n// - Interior outline if arm overlaps leg\n\n// From Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 h41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dll3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[241, 241, 290, 327, 1602]], "test": "untested"}
{"id": "dtlGDn", "name": "interpolated layered noise tmplt", "author": "jonasfrey", "description": "noise", "tags": ["noise", "template"], "likes": 2, "viewed": 190, "published": 3, "date": "1671632686", "time_retrieved": "2024-07-30T16:11:51.281939", "image_code": "float f_n_rand(float p)\n{\n    //https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec4 f_o_index2d_by_o_fc_o_ires(vec2 o_fc, vec2 o_ires){\n    float n_index_x = floor(o_fc.x) + floor(o_fc.y) * (o_ires.x);\n    float n_index_x_nor = (floor(n_index_x) / (floor(o_ires.x) * floor(o_ires.y)));\n    float n_index_y = floor(o_fc.y) + floor(o_fc.x) * (o_ires.y);\n    float n_index_y_nor = (floor(n_index_y) / (floor(o_ires.y) * floor(o_ires.x)));\n    return vec4(\n        n_index_x,//+fract(o_fc.x), \n        n_index_x_nor, \n        n_index_y,//+fract(o_fc.y), \n        n_index_y_nor\n    );\n}\nfloat f_n_rand_interpolated(vec2 o_fc, vec2 o_ires){\n\n    vec4 o_index_xp0yp0 = f_o_index2d_by_o_fc_o_ires(o_fc+vec2(0.), o_ires);\n    vec4 o_index_xp1yp0 = f_o_index2d_by_o_fc_o_ires(o_fc+vec2(+1.,+0.), o_ires);\n    vec4 o_index_xp0yp1 = f_o_index2d_by_o_fc_o_ires(o_fc+vec2(+0.,+1.), o_ires);\n    vec4 o_index_xp1yp1 = f_o_index2d_by_o_fc_o_ires(o_fc+vec2(+1,+1.), o_ires);\n    \n    float n_rand_xp0yp0 = f_n_rand(floor(o_index_xp0yp0[0]));\n    float n_rand_xp1yp0 = f_n_rand(floor(o_index_xp1yp0[0]));\n    float n_rand_xp0yp1 = f_n_rand(floor(o_index_xp0yp1[0]));\n    float n_rand_xp1yp1 = f_n_rand(floor(o_index_xp1yp1[0]));\n\n    float n = mix(n_rand_xp0yp0, n_rand_xp1yp0, fract(o_fc.x));\n    float n2 = mix(n_rand_xp0yp1, n_rand_xp1yp1, fract(o_fc.x));\n    float n3 = mix(n, n2, fract(o_fc.y));\n    \n    return (n3);\n}\nvec4 f_o_smoothnoise(\n    vec2 o_fc,\n    vec2 o_ires\n){\n    //float n_rand_interpolated = f_n_rand_interpolated(o_fc, o_ires);\n    //float n_rand_interpolated2 = f_n_rand_interpolated(o_fc*0.2+20., o_ires*0.2+20.);\n    //float n_rand_interpolated3 = f_n_rand_interpolated(o_fc*0.5+10., o_ires*0.5+10.);\n    //float n_mix = mix(n_rand_interpolated, n_rand_interpolated2, 0.5);\n    //n_mix = mix(n_mix, n_rand_interpolated3, 0.5);\n    \n    float n_product = 1.;\n    float n_sum = 0.;\n    float n_sum_noamp = 0.;\n    float n_its = 5.;\n    float n_amp = 1.;\n    float n_freq = 1.;\n    float n_min = 1.;\n    float n_max = 0.;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n        n_amp = n_amp /2.;\n        n_freq = n_freq *2.;\n        float n_rand_interpolated = f_n_rand_interpolated(o_fc*n_freq, o_ires*n_freq);//*n_amp;\n        n_sum += n_rand_interpolated * n_amp;\n        n_sum_noamp += n_rand_interpolated;\n        n_min = min(n_min, n_rand_interpolated);\n        n_max = max(n_max, n_rand_interpolated);\n    }\n    float n_sum_noamp_nor = n_sum_noamp / n_its;\n    return vec4(\n        n_sum, \n        n_sum_noamp_nor, \n        n_min, \n        n_max\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_1fc_nor = 1. / iResolution.xy;\n    vec2 o_fc_nor = o_1fc_nor * fragCoord.xy;\n    vec2 o_fc_nor_offset = o_fc_nor - 0.5;\n    float n_y = o_fc_nor_offset.y;\n    //float n_rotation = o_fc_nor_offset.x\n    float n_rand_x = f_n_rand((o_fc_nor).x);\n    float n_tau = 6.2831;\n    float n = sin(o_fc_nor.x*n_tau*sin(o_fc_nor.x * n_tau)*10.);\n    float n_amp = 0.3 + n*0.1;\n    float n_freq = o_fc_nor_offset.x * 20.;\n    n_y = n_y + sin(n_freq)*n_amp;\n    float n_dist = length(n_y);\n    n_dist = n_dist * 1./0.01;\n    \n    vec2 o_m_nor = iMouse.xy / iResolution.xy;\n    if(iMouse.z == 0.){o_m_nor = vec2((sin(iTime)*0.5+0.5),0.);}\n    float n_factor = 0.02;\n    vec4 o_smoothnoise = f_o_smoothnoise(\n        fragCoord.xy*n_factor,\n        iResolution.xy*n_factor\n    );\n    \n    float n_index = floor(o_fc_nor.y/(1./4.));\n    fragColor = vec4(o_smoothnoise[int(n_index)]);\n    \n    \n    if(o_fc_nor.x > o_m_nor.x){\n        fragColor = vec4(o_smoothnoise.g);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 69, 154], [156, 156, 212, 212, 658], [659, 659, 711, 711, 1483], [1484, 1484, 1539, 1912, 2647], [2649, 2649, 2706, 2706, 3676]], "test": "untested"}
{"id": "mtlGWn", "name": "reflections (my first time)", "author": "SONENEIS", "description": "my first time programming reflective raymarching :)", "tags": ["raymarching", "reflection", "ray", "raymarch", "round", "sphere", "reflections", "box", "plane", "reflect", "reflects", "checkred"], "likes": 5, "viewed": 232, "published": 3, "date": "1671620875", "time_retrieved": "2024-07-30T16:11:52.170563", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nfloat sdSphere(vec3 p,float r){\n\treturn length(p) - r;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 p,vec3 n,float d){\n\treturn dot(p,n) + d;\n}\n\nvec2 opUn(vec2 a,vec2 b){\n\treturn a.y < b.y ? a : b;\n}\n\nvec2 scene(vec3 p){\n\tvec2 h = vec2(-1.0,99999999.9);\n\t\n\th = opUn(h,vec2(0.0,sdPlane(p,vec3(0,1,0),0.5)));\n\t//h = opUn(h,vec2(0.0,sdBox(p-vec3(0.0,-0.5,0.0),vec3(1.0,0.0,1.0))));\n\th = opUn(h,vec2(1.0,sdSphere(p,0.5)));\n\th = opUn(h,vec2(2.0,sdBox(p-vec3(1.0,0.0,-1.0),vec3(0.5))));\n\th = opUn(h,vec2(3.0,sdBox(p-vec3(-1.0,0.0,1.0),vec3(0.25))-0.25));\n\t\n\treturn h.yx;\n}\n\nvec3 calcNormal(vec3 p){\n\tvec2 e = vec2(-1,1) * 0.001;\n\treturn normalize(vec3(\n\t\te.xyy * scene(p + e.xyy).x +\n\t\te.yyx * scene(p + e.yyx).x +\n\t\te.yxy * scene(p + e.yxy).x +\n\t\te.xxx * scene(p + e.xxx).x\n\t));\n}\n\nvec2 raymarch(vec3 ro,vec3 rd){\n  float d = 0.0, id = -1.0;\n  \n  for(int i=0;i<128;i++){\n  \tvec3 p = ro + rd*d;\n  \tvec2 h = scene(p);\n  \th.x = abs(h.x);\n  \td += h.x;\n  \tid = h.y;\n  \tif(h.x < 0.001 || d > 20.0) break;\n  }\n  \n  if(d > 20.0) d = -1.0;\n\n  return vec2(d,id);\n}\n\nvec3 render3d(vec2 uv){\n\tvec3 col = vec3(0.0);\n\t\n  vec3 ro = vec3(0.0,0.0,2.5);\n  vec3 rd = normalize(vec3(uv,-1.0));\n  \n  ro.y += 0.5;\n  rd.zy *= rot(0.25);\n  \n  ro.xz *= rot(iTime*0.5);\n  rd.xz *= rot(iTime*0.5);\n  \n  vec3 lin = vec3(0.0);\n  for(int i=0;i<3;i++){\n    vec2 h = raymarch(ro,rd);\n  \tvec3 pos = ro + rd*h.x;\n  \tvec3 nor = calcNormal(pos);\n  \tvec3 ref = reflect(rd,nor);\n  \tvec3 mate = vec3(0.0);\n    \n    if(h.y == 0.0){\n    \tmate += mod(dot(floor(pos.xz*4.0),vec2(1.0)),2.0);\n    }else if(h.y == 1.0){\n  \t  mate += vec3(1.0,0.0,0.0);\n    }else if(h.y == 2.0){\n    \tmate += vec3(0.0,1.0,0.0);\n    }else if(h.y == 3.0){\n    \tmate += vec3(0.0,0.0,1.0);\n    }\n    \n    if(h.x > 0.0 && h.y != -1.0){\n      vec3 lig = normalize(vec3(0.5));\n      float dif = clamp(dot(nor,lig),0.0,1.0);\n      float spe = pow(clamp(dot(ref,lig),0.0,1.0),10.0);\n      float sha = step(raymarch(pos+nor*0.02,lig).x,0.0);\n  \t\n      lin += mate * dif * sha;\n      lin += spe * dif * sha;\n\n      ro = pos + nor*0.02;\n      rd = ref;\n      \n      lin = mix(lin,vec3(0.0),h.x*h.x*h.x*0.001);\n      \n      if(i == 0) col = lin;\n      else col *= lin;\n    }\n  }\n  \n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n  \n  col += render3d(uv);\n  \n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 94, 94, 119], [121, 121, 148, 148, 233], [235, 235, 272, 272, 296], [298, 298, 323, 323, 352], [354, 354, 373, 373, 719], [721, 721, 745, 745, 928], [930, 930, 961, 961, 1202], [1204, 1204, 1227, 1227, 2367], [2369, 2369, 2419, 2419, 2561]], "test": "untested"}
{"id": "Dts3Wn", "name": "Line Test1", "author": "myy", "description": "aaa", "tags": ["2d", "sdf"], "likes": 1, "viewed": 144, "published": 3, "date": "1671593226", "time_retrieved": "2024-07-30T16:11:53.118030", "image_code": "float sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    \n    float h = clamp(dot(pa,ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba * h);\n}\n\n// [-0.5, 0.5]\nfloat aa_3(float d) {\n    return clamp(0.5 - d, 0.0, 1.0);\n}\n\n// [-1, 1]\nfloat aa_4(float d) {\n    return clamp(0.5 - 0.5 * d, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fg = vec3(0.0, 0.0, 0.0);\n    vec3 bg = vec3(1.0, 1.0, 1.0);\n\n    float t = 0.3 * iTime;\n    vec2 p1 = vec2 (300.5, 250.5);\n    vec2 p2 = p1 + 200.0 * vec2 (cos(t), sin(t));\n    \n    // 20条 相隔很近的线段（相差 2像素）\n    for (int i = 0; i < 20; i += 1) {\n        p1 += vec2(2.0);\n        p2 += vec2(2.0);\n\n        float d = sdSegment(fragCoord, p1, p2);\n        float a = aa_3(d);\n        bg = mix(bg, fg, a);\n    }\n    \n    fragColor = vec4(bg, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dts3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 175], [177, 192, 213, 213, 252], [254, 265, 286, 286, 331], [333, 333, 390, 390, 870]], "test": "untested"}
{"id": "dlX3Wr", "name": "audio responsive shader", "author": "jonasfrey", "description": "audio\n", "tags": ["audio"], "likes": 4, "viewed": 240, "published": 3, "date": "1671582294", "time_retrieved": "2024-07-30T16:11:53.946815", "image_code": "\n\nfloat f_n_inout(float n){\n    if(n > .5){\n        return 0.5 - mod(n, 0.5); \n    }\n    return n;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = (fragCoord - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    float n_tau = 6.2831;\n    vec2 o_p = vec2(0., 0.);\n    vec2 o_diff = o_trpino-o_p;\n    float n_dist = length(o_diff);\n    float n_ang_nor = fract(((atan(o_diff.y, o_diff.x)+(n_tau/2.))/n_tau)+0.5);\n    float n_its = 9.;\n    float n_ang_snapped = floor(n_ang_nor / (1./n_its));\n    float n_ang_snapped_nor = n_ang_snapped / n_its;\n    vec2 o_p_center = vec2(0.);\n    float n_dist_center = length(o_trpino-o_p_center);\n    float n_a = fract(n_ang_snapped_nor);\n    vec2 o_p_onangle_snapped = vec2(\n        cos(n_a*n_tau+(1./n_its/2.)*n_tau)*n_dist_center,\n        sin(n_a*n_tau+(1./n_its/2.)*n_tau)*n_dist_center\n    );\n    float n_dist_o_p_onangle_snapped = length(\n        o_trpino - o_p_onangle_snapped\n    );\n    float n = n_dist_o_p_onangle_snapped*1.;\n    \n    float n_amp = texture(iChannel0, vec2(n_dist,0.)).r;\n    float n_amp_bass = texture(iChannel0, vec2(0.01,0.)).r;\n    float b_amp_bass = step(0.95, n_amp_bass);\n    //n = smoothstep(0.1, 0.11, n);\n    n*=n_amp*20.;\n    n = n+(sin(n_dist_center*n_tau+iTime)*0.5+0.5);\n\n    fragColor = vec4(b_amp_bass-n);\n    \n    fragColor += vec4(fract(1.-n_amp+b_amp_bass*0.4), n_amp, n_amp*2.,1.);\n    //fragColor += vec4(b_amp_bass*0.4, 0.2,0.5,1.);\n    //fragColor = fragColor*0.5;\n    //fragColor = vec4(b_amp_bass);\n}", "image_inputs": [{"id": 31416, "src": "https://soundcloud.com/eod-6/swurlk?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlX3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 27, 27, 101], [102, 102, 159, 159, 1555]], "test": "untested"}
{"id": "mlfGDn", "name": "another clock", "author": "jonasfrey", "description": "clock", "tags": ["tau", "shaderclockdenodev"], "likes": 3, "viewed": 261, "published": 3, "date": "1671577030", "time_retrieved": "2024-07-30T16:11:54.801529", "image_code": "\n\nfloat f_n_inout(float n){\n    if(n > .5){\n        return 0.5 - mod(n, 0.5); \n    }\n    return n;\n\n}\nfloat f_n_clockhand(\n    vec2 o_trpino, \n    float n_freq_offset\n){\n    float n_tau = 6.283185;\n    vec2 o_p = vec2(0., 0.);\n    vec2 o_diff = o_trpino-o_p;\n    float n_dist = length(o_diff);\n    float n_ang_nor = fract(((atan(o_diff.y, o_diff.x)+(n_tau/2.))/n_tau)+0.5);\n    float n_its = 1.;\n    float n_ang_snapped = floor(n_ang_nor / (1./n_its));\n    float n_ang_snapped_nor = n_ang_snapped / n_its;\n    vec2 o_p_center = vec2(0.);\n    float n_dist_center = length(o_trpino-o_p_center);\n    float n_a = fract(n_ang_snapped_nor);\n    vec2 o_p_onangle_snapped = vec2(\n        cos(n_a*n_tau+(1./n_its/2.)*n_tau)*n_dist_center,\n        sin(n_a*n_tau+(1./n_its/2.)*n_tau)*n_dist_center\n    );\n    float n_dist_o_p_onangle_snapped = length(\n        o_trpino - o_p_onangle_snapped\n    );\n    float n = n_dist_o_p_onangle_snapped*20.;\n\n    //n = smoothstep(0.1, 0.11, n);\n    n = n+(sin(n_dist_center*n_tau+n_freq_offset)*0.5+0.5);\n    return n;\n}\nfloat f_n_inout_parabola(\n    float n_nor, \n    float n_width, \n    float n_offset_nor\n){\n    //https://www.desmos.com/calculator/buuowzksdh?lang=de\n    float n = pow(n_nor - (1./2.)*2.*n_offset_nor, 2.) * - (4./n_width)+1.; \n    return n;\n}\nvec2 f_o_rotd(vec2 o, float n_angle_nor){\n    float n_tau = 6.283185;\n    float n_ang_rad = n_angle_nor * n_tau;\n    return vec2(\n        cos(n_ang_rad)*o.x - sin(n_ang_rad)*o.y, \n        sin(n_ang_rad)*o.x + cos(n_ang_rad)*o.y\n    );\n}\n//IMPORTANT START, keep the lines with and between IMPORTANT START and IMPORTANT END\n// and add the tag 'shaderclockdenodev' to the shader\n// otherwise the shader will not work on https://shaderclock.deno.dev/\n// also at the moment only the following variables are available iTime, iResolution,fragCoord,iDate\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//IMPORTANT END\n    vec2 o_trpino = (fragCoord - iResolution.xy*0.5)/ iResolution.y;\n    o_trpino = f_o_rotd(o_trpino, 1./4.);\n    o_trpino*=1.1;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    float n_tau = 6.283185;\n    float n_freq_sec = fract(iTime)*n_tau;\n    //float n_t_sec = (iTime);\n    //n_t_sec = floor(iTime);// for snapping handle\n    \n\n    float n_t_yea = (iDate.x);//year-1\n    float n_t_mon = (iDate.y);//month-1\n    float n_t_day = (iDate.z);//day-1\n    float n_t_sec = (iDate.w);//secs since midnight\n    float n_t_min = (n_t_sec / 60.); //min since midnight\n    float n_t_hou = (n_t_min / 60.); //hours since midnight\n    \n    float n_min_nor = n_t_min / 60.;\n    //float n_hou_nor = n_t_hou / 24.;\n    \n    float n_sec = iDate.w;\n    float n_hou_mod = floor(mod(n_sec, 60.*60.*12.));\n    float n_hou_nor = n_hou_mod / (60.*60.*12.);\n    \n    float n_ang_sec = (1./60.)*(mod(n_t_sec, 60.));\n    vec2 o_rotd_sec = f_o_rotd(o_trpino, n_ang_sec);\n    float n_clockhand_sec = f_n_clockhand(o_rotd_sec, iTime*n_tau);\n\n    float n_ang_min = n_min_nor;\n    vec2 o_rotd_min = f_o_rotd(o_trpino, n_ang_min);\n    float n_clockhand_min = f_n_clockhand(o_rotd_min, n_ang_min);\n    \n    float n_ang_hou = n_hou_nor;\n    vec2 o_rotd_hou = f_o_rotd(o_trpino, n_ang_hou);\n    float n_clockhand_hou = f_n_clockhand(o_rotd_hou, n_ang_hou);\n\n    float n_dist_center = length(o_trpino);\n    float n_circle_around = 1.-smoothstep(0.5-0.025, 0.5+0.025, n_dist_center);\n    float b_circle_mask = 1.-smoothstep(0.5, 0.5, n_dist_center);\n    n_circle_around = f_n_inout_parabola(n_circle_around, 1.0, 0.5);\n\n    float n_min = min(n_clockhand_sec, 1.);\n    n_min = min(n_min, n_clockhand_min);\n    n_min = min(n_min, n_clockhand_hou);\n    //n_min += (n_clockhand_sec*n_clockhand_min*n_clockhand_hou)*0.01;\n    //n_min = sqrt(n_min);\n    float n_max = 1.-n_min;\n\n    float n = b_circle_mask*n_max + n_circle_around;\n    fragColor = vec4(n);\n    //fragColor *= b_circle_mask;\n    //fragColor = 1.-fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 27, 27, 101], [102, 102, 169, 169, 1045], [1046, 1046, 1135, 1194, 1287], [1288, 1288, 1329, 1329, 1524], [1525, 1835, 1892, 1908, 3900]], "test": "untested"}
{"id": "dtfGWn", "name": "sternanis", "author": "jonasfrey", "description": "tau", "tags": ["tau"], "likes": 4, "viewed": 188, "published": 3, "date": "1671568328", "time_retrieved": "2024-07-30T16:11:55.623332", "image_code": "\n\nfloat f_n_inout(float n){\n    if(n > .5){\n        return 0.5 - mod(n, 0.5); \n    }\n    return n;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = (fragCoord - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    float n_tau = 6.2831;\n    vec2 o_p = vec2(0., 0.);\n    vec2 o_diff = o_trpino-o_p;\n    float n_dist = length(o_diff);\n    float n_ang_nor = fract(((atan(o_diff.y, o_diff.x)+(n_tau/2.))/n_tau)+0.5);\n    float n_its = 9.;\n    float n_ang_snapped = floor(n_ang_nor / (1./n_its));\n    float n_ang_snapped_nor = n_ang_snapped / n_its;\n    vec2 o_p_center = vec2(0.);\n    float n_dist_center = length(o_trpino-o_p_center);\n    float n_a = fract(n_ang_snapped_nor);\n    vec2 o_p_onangle_snapped = vec2(\n        cos(n_a*n_tau+(1./n_its/2.)*n_tau)*n_dist_center,\n        sin(n_a*n_tau+(1./n_its/2.)*n_tau)*n_dist_center\n    );\n    float n_dist_o_p_onangle_snapped = length(\n        o_trpino - o_p_onangle_snapped\n    );\n    float n = n_dist_o_p_onangle_snapped*n_its;\n    //n = smoothstep(0.1, 0.11, n);\n    n = n+(sin(n_dist_center*n_tau+iTime)*0.5+0.5);\n    fragColor = vec4(n);\n}", "image_inputs": [{"id": 31333, "src": "https://soundcloud.com/richarddjames/rhubarb-orc-1953-rev?in=user18081971/sets/mew5lanzyse3&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 27, 27, 101], [102, 102, 159, 159, 1157]], "test": "untested"}
{"id": "ctsGzr", "name": "multiple ways to 'morph' circles", "author": "jonasfrey", "description": "morphin circles , from left to right \n//n_sum,    (n+=n); \n//n_min     (min(n_min, n))\n//n_product (n*=n)\n//n_quotient", "tags": ["morphing"], "likes": 1, "viewed": 155, "published": 3, "date": "1671566366", "time_retrieved": "2024-07-30T16:11:56.495001", "image_code": "float f_o_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_fc_nor = (fragCoord.xy )/ iResolution.xy;\n    \n   \n    float[] a_n_operation_result = float[](\n        0.0, //n_sum,    (n+=n); \n        1.0, //n_min     (min(n_min, n))\n        1.0, //n_product (n*=n)\n        1.0 //n_quotient\n    );\n    float n_index = floor(o_fc_nor.x / (1. / float(a_n_operation_result.length())));\n    float n_x =(1./float(a_n_operation_result.length()));\n    n_x = (n_x)*n_index +(n_x/2.);\n    vec2[] a_o = vec2[](\n        vec2(n_x, sin(iTime)*0.5+0.5),\n        vec2(n_x, sin(iTime+(6.2831/2.))*0.5+0.5)\n    );\n    vec2 o_diff = vec2(0.);\n    for(float n_index = 0.; n_index < float(a_o.length()); n_index+=1.){\n        vec2 o_diff = o_fc_nor - a_o[int(n_index)];\n        float n_length = length(o_diff);\n        a_n_operation_result[0] += n_length;\n        a_n_operation_result[1] = min(a_n_operation_result[1], n_length);\n        a_n_operation_result[2] *= n_length;\n        a_n_operation_result[3] /= n_length;\n    }\n    \n    float n = a_n_operation_result[int(n_index)];\n    fragColor = vec4(n);\n    //fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 143]], "test": "untested"}
{"id": "dlXGRN", "name": "Modular Flow", "author": "mla", "description": "Inspired by @matthen2 on Twitter: [url]https://twitter.com/matthen2/status/1604117218027077634[/url]\n\nSee: [url]https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html[/url] for the maths\n\n<mouse x>: control zoom.\n\n", "tags": ["flow", "modular", "eigenvector", "eigenvalue"], "likes": 43, "viewed": 566, "published": 3, "date": "1671565902", "time_retrieved": "2024-07-30T16:11:57.678836", "image_code": "////////////////////////////////////////////////////////////////////////\n//\n// Modular Flow,mla, 2022\n//\n// Apply a stretch and squeeze transform (x,y)-> (kx,y/k) to a lattice, \n// add just the right skew, and you get a nice looping flow pattern.\n// \n// Inspiration:\n// https://twitter.com/matthen2/status/1604117218027077634\n// https://twitter.com/etiennejcb/status/1604946331411292166 (@Bleuje)\n//\n// For the maths:\n// https://golem.ph.utexas.edu/category/2014/04/the_modular_flow_on_the_space.html\n//\n// <mouse-x> to zoom\n// 'g' shows underlying grid\n// 'r' shows fundamental region\n//\n////////////////////////////////////////////////////////////////////////\n\n// Find a canonical representative under the group action - generally\n// the length of the vector decreases to a minimum, then increases\n// again, so just iterate both ways to find the smallest (breaking ties\n// the same way if two vectors are minimal).\nvec2 reduce(vec2 p, mat2 A, mat2 Ainv) {\n  if (p == vec2(0)) return p;\n  while (true) {\n    vec2 p1 = A*p;\n    if (dot(p1,p1) >= dot(p,p)) break;\n    p = p1;\n  }\n  while (true) {\n    vec2 p1 = Ainv*p;\n    if (dot(p1,p1) > dot(p,p)) break;\n    p = p1;\n  }\n  return p;\n}\n\nvec3 getcol(vec2 ix) {\n  //if (ix == vec2(0)) return vec3(1); // Show centre point\n  uint h = uint(int(ix.x)*12345^int(ix.y));\n  h = ihash(h);\n  return h2rgb(float(h)/exp2(32.0));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // A can be any suitable element of the modular group. This\n    // one has nice eigenvectors. Since determinant is 1, the\n    // eigenvalues are real and distinct if Tr(A) > 2, and the\n    // product of the eigenvalues is 1. If this is the case,\n    // we have an eigendecomposition A = P'XP where P is the\n    // matrix of eigenvectors and X is the diagonal matrix\n    // of the eigenvalues k,1/k.\n    mat2 A = mat2(2,1,1,1); // Must have Tr(A) > 2 and det(A) = 1\n    //A = mat2(0,-1,1,3); // Alternative matrix\n    float a = A[0][0], b = A[1][0], c = A[0][1], d = A[1][1];\n    assert(a+d > 2.0);\n    assert(a*d - b*c == 1.0);\n    float tr = a+d, disc = tr*tr-4.0;\n    float l0 = 0.5*(tr-sqrt(disc)), l1 = 0.5*(tr+sqrt(disc)); // l1 = 2.618\n    vec2 e0 = normalize(vec2(-b,a-l0)), e1 = normalize(vec2(-b,a-l1));\n    mat2 P = mat2(e0,e1); // Eigenvector matrix\n    //P = mat2(-1, 1.618034,-1,-0.618034); // For A = (2,1,1,1) (unnormalized)\n    mat2 Ainv = inverse(A), Pinv = inverse(P);\n    float cycle = log(l1); // Largest eigenvalue\n\n    // Compute skewed uv and grid cell indices\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv += 0.25; uv = rotate(uv,0.1*iTime); uv -= 0.25;\n    uv *= 8.0;\n    if (iMouse.x > 0.0) uv *= exp2(3.0*iMouse.x/iResolution.x-1.0);\n    float px = fwidth(uv.x);\n    float k = exp(cycle*fract(0.25*iTime)-0.5); // Time loop (repeat every 4 seconds)\n    uv *= vec2(k,1.0/k);\n    uv = P*uv;\n    vec2 ix = round(uv);\n    uv -= ix;\n    vec2 uv0 = uv; // Remember skewed uv\n    uv = Pinv*uv;\n    uv *= vec2(1.0/k,k); // uv now unskewed \n    vec2 ix0 = ix; // Unreduced cell index\n    ix = reduce(ix,A,Ainv);\n\n    // Now do the drawing\n    vec3 col = vec3(1,1,0.75);\n    if (key(CHAR_G)) {\n      // show grid\n      vec2 uv1 = 0.5-abs(uv0);\n      float d = min(uv1.x,uv1.y);\n      float px = fwidth(d);\n      vec3 col0 = vec3(0), col1 = vec3(0);\n      if (mod(ix0.x+ix0.y,2.0) == 0.0) col0 = col;\n      else col1 = col;\n      col = mix(col0,col1,smoothstep(-px,px,d)); // Show cells\n    }\n    float radius = 0.32;\n    vec3 dcol = getcol(ix);\n    vec2 rad = rotate(vec2(1,0),0.25*ix.x*iTime);\n    dcol *= smoothstep(0.0,px,segment(uv,-rad,rad)-0.01); \n    col = mix(dcol,col,vec3(smoothstep(0.0,px,length(uv)-radius)));\n    col *= smoothstep(0.0,px,abs(length(uv)-radius)-0.01);\n    if (key(CHAR_R) && ix0 != ix) col *= 0.5; // Fundamental region\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nint assert(bool b) {\n if (!b) alert = true;\n return 0;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n//const int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\n//const int CHAR_S = 83;\n//const int CHAR_T = 84;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[663, 917, 957, 957, 1185], [1187, 1187, 1209, 1269, 1368], [1370, 1370, 1422, 1825, 3907]], "test": "untested"}
{"id": "DlfGWn", "name": "Fork Indented g zankokun 514", "author": "zankokun", "description": "Simple trick with coordinates, I wanna try and do some lighting shading later.", "tags": ["2d", "distortion", "filter", "glass"], "likes": 5, "viewed": 475, "published": 3, "date": "1671553669", "time_retrieved": "2024-07-30T16:11:58.469721", "image_code": "void mainImage(out vec4 color, vec2 coord) {\n    vec2 mouse = mix(\n        vec2(iTime * 100.0),\n        iMouse.xy,\n        step(0.0, iMouse.z)) * 0.01;\n    \n    vec2 glass_offset = sin(coord * 0.1 - mouse) * 10.0;\n    vec2 glass_coord = coord + glass_offset;\n    \n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    vec2 glass_uv = glass_coord * ps;\n    \n    color = texture(iChannel0, glass_uv);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 423]], "test": "untested"}
{"id": "dll3RM", "name": "kernel to calculate adjacent", "author": "jonasfrey", "description": "instead of calculating random positions foreach pixel, we just calculate the adjacent", "tags": ["kernel"], "likes": 1, "viewed": 206, "published": 3, "date": "1671539848", "time_retrieved": "2024-07-30T16:11:59.440128", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 f_o_index_by_trn_scl(\n    vec2 o_trn, \n    vec2 o_scl\n){\n    float n_index = floor(o_trn.x)+floor(floor(o_trn.y)*floor(o_scl.x));\n    float n_index_nor = n_index / (floor(o_scl.x)*floor(o_scl.y));\n    return vec2(\n        n_index,\n        n_index_nor\n    );\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fragCoord_nor = fragCoord.xy /iResolution.xy;\n    vec4 o_col_last = texture(iChannel0, o_fragCoord_nor);\n\n    vec2 o_trmono_nooffset = iMouse.xy / iResolution.xy;\n    if(iMouse.z == 0.) o_trmono_nooffset = vec2(0.3, 0.);\n    vec2 o_scale_factor = vec2(o_trmono_nooffset.x*o_trmono_nooffset.x);\n    vec2 o_fc = (fragCoord.xy * o_scale_factor);\n    vec2 o_ires = (iResolution.xy * o_scale_factor);\n    \n    float n_fadeout = 5.;\n\n    vec2 o_index = f_o_index_by_trn_scl(\n        o_fc, \n        o_ires\n    );\n    \n    //optimal is 3, 5, ,7 ,9 (2|(n-1)) \n    vec2 o_scale_kernel = vec2(5.);\n    \n    // this is the maximum distance /pixels we can move before seeing\n    // the restriction of the kernel size \n    vec2 o_scl_kernel_half = floor(o_scale_kernel/2.);\n    \n    vec3 o_dist_sum = vec3(0.);\n    vec3 o_dist_mul = vec3(1.);\n    vec3 o_dist_min = vec3(1.);\n    vec3 o_col_min = vec3(1.);\n    for(float n_y = 0.; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.; n_x < o_scale_kernel.x; n_x+=1.){\n            vec2 o_fc_trn = vec2(\n                n_x-floor(o_scale_kernel.x/2.),\n                n_y-floor(o_scale_kernel.y/2.)\n            );\n            vec2 o_index_current = f_o_index_by_trn_scl(\n                floor(o_fc+o_fc_trn),\n                o_ires\n            );\n            vec2 o_trpino_new = floor(o_fc+o_fc_trn)/floor(o_ires);\n            vec4 o_col = texture(iChannel1, o_trpino_new);\n            \n            vec2 o_diff = (\n                fract(o_fc)- \n                o_fc_trn+sin(iTime+o_index_current.x)*0.5\n                -0.5\n            )*.5;\n            float n_dist = length(o_diff);\n            if(n_dist < o_dist_min.r){\n                o_col_min = vec3(o_index_current.g,1.-o_index_current.g,0.5);\n            }\n            o_dist_min = vec3(min(o_dist_min.r, n_dist));\n\n        }\n    }\n\n    fragColor = vec4(vec3(o_dist_min)*(o_col_min)*2., 1.);\n    fragColor = sqrt(fragColor);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dll3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 235]], "test": "untested"}
{"id": "cls3z7", "name": "how to pixelate/lowres anything", "author": "jonasfrey", "description": "by just multiplying fragCoord and iResolution by a lowernumber than 1. you can pixelate every shader\noriginal shader: https://www.shadertoy.com/view/XsVSDz\nuse mouse on x-axis to change the scale", "tags": ["2d", "oldschool", "plasma", "lowres", "pixelated"], "likes": 5, "viewed": 252, "published": 3, "date": "1671532377", "time_retrieved": "2024-07-30T16:12:00.354682", "image_code": "const vec2 vp = vec2(320.0, 200.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trmono_nooffset = iMouse.xy / iResolution.xy;\n    if(iMouse.z == 0.) o_trmono_nooffset = vec2(0.3, 0.);\n    vec2 o_scale_factor = vec2(o_trmono_nooffset.x*o_trmono_nooffset.x);\n    vec2 o_fc = floor(fragCoord.xy * o_scale_factor);\n    vec2 o_ires = floor(iResolution.xy * o_scale_factor);\n    //from now on: make sure to replace\n    //             fragCoord   and  iResoltuion \n    // with\n    //             o_fc        and  o_ires\n    \n\tfloat t = iTime * 10.0 + iMouse.x;\n\tvec2 uv = o_fc.xy / o_ires.xy; // <-- this was \"vec2 uv = fragCoord.xy / iResolution.xy;\"\n    vec2 p0 = (uv - 0.5) * vp;\n    vec2 hvp = vp * 0.5;\n\tvec2 p1d = vec2(cos( t / 98.0),  sin( t / 178.0)) * hvp - p0;\n\tvec2 p2d = vec2(sin(-t / 124.0), cos(-t / 104.0)) * hvp - p0;\n\tvec2 p3d = vec2(cos(-t / 165.0), cos( t / 45.0))  * hvp - p0;\n    float sum = 0.5 + 0.5 * (\n\t\tcos(length(p1d) / 30.0) +\n\t\tcos(length(p2d) / 20.0) +\n\t\tsin(length(p3d) / 25.0) * sin(p3d.x / 20.0) * sin(p3d.y / 15.0));\n    fragColor = texture(iChannel0, vec2(fract(sum), 0));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.1415926435;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trmono_nooffset = iMouse.xy / iResolution.xy;\n    if(iMouse.z == 0.) o_trmono_nooffset = vec2(0.3, 0.);\n    vec2 o_scale_factor = vec2(o_trmono_nooffset.x*o_trmono_nooffset.x);\n    vec2 o_fc = floor(fragCoord.xy * o_scale_factor);\n    vec2 o_ires = floor(iResolution.xy * o_scale_factor);\n    \n    float i = o_fc.x / o_ires.x;\n    vec3 t = (iTime + iMouse.y) / vec3(63.0, 78.0, 45.0);\n    vec3 cs = cos(i * pi * 2.0 + vec3(0.0, 1.0, -0.5) * pi + t);\n    fragColor = vec4(0.5 + 0.5 * cs, 1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cls3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 94, 94, 1128]], "test": "untested"}
{"id": "mlX3R7", "name": "Pixel Man 2!", "author": "SnoopethDuckDuck", "description": "He needs hands\n\nmake sure you click the music thingy :)\n\nCrawling man:\nhttps://www.shadertoy.com/view/mtlGzM\n", "tags": ["2d", "motion", "pixelart", "human", "stickman"], "likes": 28, "viewed": 410, "published": 3, "date": "1671497504", "time_retrieved": "2024-07-30T16:12:01.685124", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n// https://lospec.com/palette-list/resurrect-64\n// didn't look as nice imo\n#define c0 vec3(50,51,83)/255.\n#define c1 vec3(72,74,119)/255.\n#define c2 vec3(77,101,180)/255.\n#define c3 vec3(77,155,230)/255.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float sc = .16;\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    vec3 col2 = .5 + .5*cos(.5*pi*(2.5*exp(-2.*length(col)) + vec3(0,1,2)/3.));\n    \n    /*\n    if (col.r == .5) col = c0;\n    else if (col.r == 1.) col = c1;\n    else if (col.b == .5) col = c1;\n    else if (col.b == 1.) col = c2;\n    else if (col.g == .5) col = c2;\n    else if (col.g == 1.) col = c3;\n    //*/\n     \n    col = mix(col, col+col2, .5 - .5 * cos(uv.x + iTime));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31313, "src": "https://soundcloud.com/kynon-duff/wide-putin-walkingsong-for-denise-8-bit-vrc6-castlevania-3-jp-style?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat line(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n                  \n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat stride(float t, float i) {\n    float a = pi / 2.;\n    float f = min(1., mod(t + i * a, 2. * a) / a);\n    \n    // Some of these need remapping to [0,1]\n    //return pow(4.*f*(1.-f),2.);\n    //return 4. * f * (1.-f) * (1.-f);\n    return sqrt(1. - pow(2.*f-1., 2.));\n    //return 0.5 * abs(sin(pi * f));\n}\n\n// Gets 3rd point on isosceles triangle equidistant from p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.; \n    float d = 0.5 * length(p-q);\n    \n    // a=2. is min distance from pq line, so it doesn't snap\n    // into place and skip too many pixels at once\n    float a = 2.; // 3 is believable too\n    if (v > d) \n        a = sqrt(v * v - d * d);\n    \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + a * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 5. * iTime;\n\n    // (sorry if this is off-screen for you)\n    f -= vec2(64,2) - 0.5;\n      \n    // --- PARAMETERS ---  \n      \n    float silly = -4. * cos(t) * tanh(0.01 * t);  \n      \n    float sw = 6. + 6. * tanh(0.1 * t);     // Stride width\n    vec2 sh = vec2(6); // Stride height (Left, Right)\n    \n    float vHip = 2.;         // Hip vertical motion per step\n    float xHip = 1.-2.*abs(cos(t)); // Hip horizontal offset\n    vec2 dimHip = vec2(2,1); // Hip dims (Length, Height-Osc)\n    float hHip = 23. - silly;// Hip height\n    float aHip = t;//-t      // Hip angle\n    \n    float dTor = 17. + silly;   // Torso length\n    float aTor = pi/2.; // Torso angle\n    \n    vec2 dimSho = vec2(1);  // Shoulder dims (Length, Height-Osc)\n    \n    float dLeg = 9.;  // Leg length/2, dLeg > (vHip+hHip)/2\n    \n    float dFoot = 3.; // Foot length\n    float tf = 3.;    // Toe fluidity (idk how to describe this)\n \n    vec2 dElb = vec2(7);      // Elbow length (Left, Right)\n    vec2 aElb = -0.5 * pi +   // Elbow angle\n                -0.125 * pi * vec2(cos(t), -cos(t)); \n    \n    vec2 dHand = vec2(8);     // Hand length (forearm)\n    vec2 aHand = -0.3 * pi +  // Hand angle \n                 -0.3 * pi * vec2(cos(t), -cos(t));\n    \n    vec2 dFing = vec2(2); // Finger length\n    \n    float dHead = 3.;             // Head distance from neck\n    float aHead = pi/2. - pi/12.; // Head angle from neck\n    \n    \n    // --- POINTS ---\n    \n    // Centre x coord\n    float spd = 0.*0.75 * sw; // (needs improving)\n    float x = spd * t;\n    \n    // Centre (of hip)\n    vec2 p = round(vec2(x - xHip, hHip + vHip * abs(cos(t))));\n    \n    // Hip\n    vec2 pHip1 = round(p - dimHip * vec2(cos(aHip), sin(aHip)));\n    vec2 pHip2 = round(p + dimHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot\n    vec2 pFoot1 = round(vec2(x-sw*cos(t), sh.x * stride(.5*t, 0.)));\n    vec2 pFoot2 = round(vec2(x+sw*cos(t), sh.y * stride(.5*t, 1.)));\n        \n    // Toe\n    float o = -pi/12.; // Land on heels or toes?\n    vec2 pToe1 = (vec2(x+tf-sw*cos(t+o), .5*sh.x*stride(.5*t+o, 0.)));\n    vec2 pToe2 = (vec2(x+tf+sw*cos(t+o), .5*sh.y*stride(.5*t+o, 1.)));\n    vec2 fdir1 = normalize(pToe1 - pFoot1);\n    vec2 fdir2 = normalize(pToe2 - pFoot2);\n    pToe1 = round(pFoot1 + dFoot * fdir1);\n    pToe2 = round(pFoot2 + dFoot * fdir2);\n\n    // Knee\n    vec2 pKnee1 = getTriPoint(f, pHip1, pFoot1, dLeg);\n    vec2 pKnee2 = getTriPoint(f, pHip2, pFoot2, dLeg);\n      \n    // Neck\n    vec2 pNeck = round(vec2(x + xHip, p.y) + \n                       dTor * vec2(cos(aTor), sin(aTor)));\n      \n    // Shoulder\n    vec2 pSho1 = round(pNeck - dimSho * vec2(cos(aHip), sin(aHip)));\n    vec2 pSho2 = round(pNeck + dimSho * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow\n    vec2 pElb1 = round(pSho1 + dElb.x * vec2(cos(aElb.x), sin(aElb.x)));\n    vec2 pElb2 = round(pSho2 + dElb.y * vec2(cos(aElb.y), sin(aElb.y)));\n      \n    // Hand \n    vec2 pHand1 = round(pElb1 + dHand.x * vec2(cos(aHand.x), sin(aHand.x)));\n    vec2 pHand2 = round(pElb2 + dHand.y * vec2(cos(aHand.y), sin(aHand.y)));\n      \n    // Head\n    vec2 dirHead = vec2(cos(aHead), sin(aHead)); \n    vec2 pHead = round(pNeck + dHead * dirHead);\n    \n    \n \n    // --- DRAW ---  \n      \n    // Hip\n    col.b += line(f, pHip1, pHip2);  \n    \n    // Legs\n    col.r += line(f, pHip1,  pKnee1) + \n             line(f, pKnee1, pFoot1) +\n             line(f, pFoot1, pToe1);\n    col.g += line(f, pHip2,  pKnee2) + \n             line(f, pKnee2, pFoot2) +\n             line(f, pFoot2, pToe2);\n       \n    // Torso\n    col.b += line(f, p, pNeck);\n    \n    // Shoulder\n    col.b += line(f, pSho1, pSho2);\n    \n    // Arms\n    col.r += line(f, pSho1, pElb1) +\n             line(f, pElb1, pHand1);\n    col.g += line(f, pSho2, pElb2) + \n             line(f, pElb2, pHand2);\n\n    // Neck\n    col.b += line(f, pNeck, pHead);\n   \n    // Head\n    float head = length(round(f - pHead - 3. * dirHead));\n    float sHead = step(head, 3.5);// - step(head,2.5);\n    col.b += sHead;\n   \n    //col = length(col) * vec3(1);\n    \n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "vec4 cell(in sampler2D tx, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(tx, 0));\n    p = (p+r) % r;\n    return texelFetch(tx, p, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{ \n    vec4 e = vec4(0);\n    vec4 c = vec4(0);\n    int n = 1;\n    for (int i = -n; i < n + 1; i++) {\n        for (int j = - n; j < n + 1; j++) {\n            e = max(e, cell(iChannel0, ivec2(f + vec2(i,j))));\n            c += cell(iChannel0, ivec2(f + vec2(i,j)));\n        }\n    }\n    c /= 9.;\n    vec4 a = cell(iChannel0, ivec2(f - 1.));\n    e += a;\n\n    if (e.g > 0.)\n        e.rb *= 0.;\n    else if (e.b > 0.)\n        e.r *= 0.;\n        \n    e *= 0.5;\n\n    fragColor = e;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Ideas:\n// - Change stride height randomly to match some obstacles, move body up\n//   and down so it appears to climb over obstacles.\n// - Make zombie army\n// - Pick from collection of movement functions e.g. for stride\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlX3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 322, 322, 885]], "test": "untested"}
{"id": "mtf3R7", "name": "Catacombs Of Solaris Demake", "author": "Trixelized", "description": "A very hacky experiment of remaking the visual effect found in Catacombs Of Solaris. Someone here can definitely do this way better than me utilizing matrixes ^^'", "tags": ["trippy", "weird", "liminal"], "likes": 12, "viewed": 287, "published": 3, "date": "1671495252", "time_retrieved": "2024-07-30T16:12:02.587711", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > int(every_x_frames - 1.0)) {\n        if (mod(float(iFrame), every_x_frames) == 0.0) {\n            fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n        } else {\n            fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n        }\n    } else {\n        fragColor = texture(iChannel2, -fragCoord.xy / iResolution.xy);\n    }\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Thanks to Xor for 'voxels explained'\n// Which helped me set up geometry\n// https://www.shadertoy.com/view/fstSRH\n\nvec3 getcampos(float frame) {\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    cam.x = 12.0 * (smoothstep(-1., 1., cos(0.004 * frame)) - 0.5);\n    cam.z = 12.0 * (smoothstep(-1., 1., sin(0.004 * frame)) - 0.5);\n    cam.y = sin(frame * 0.01) * 0.5;\n    return cam;\n}\n\nfloat getcamframeoff(float frame) {\n    return sin(frame) * 1234.5678;\n}\n\nfloat map(vec3 pos)\n{\n    return\n        min(1.0 - length(pos.y) + 2.0 * fract(sin(pos.x * 1.2 + pos.z * 3.4) * 51234.5678901234),\n        min(17.0 - length(pos.x),\n        min(17.0 - length(pos.z),\n        2.0 - length((round(pos.xz / 3.0) * 3.0) - pos.xz))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float fr = floor(float(iFrame) / every_x_frames)*every_x_frames;\n    \n    vec3 cam = getcampos(float(iFrame) + getcamframeoff(fr));\n    vec3 pos = cam;\n    vec3 ray = normalize(vec3(fragCoord*2.0 - iResolution.xy, iResolution.y));\n    vec3 cell = vec3(0,0,0);\n    \n    for(int i = 0; i<50; i++)\n    {\n        vec3 dist = fract(-pos * sign(ray)) + 1e-4,\n        leng = dist / abs(ray),\n        near = min(leng.xxx, min(leng.yyy, leng.zzz));\n        pos += ray * near;\n        cell = ceil(pos) - 0.5;\n        if (map(cell) < 0.0) break;\n    }\n    \n    pos -= getcampos(fr + getcamframeoff(fr));\n    vec2 uv = (pos.xy) / pos.z;\n    uv.x /= iResolution.x / iResolution.y;\n    uv = fract(uv / 2.0 + 0.5);\n    \n    \n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define every_x_frames 200.0", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtf3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 124]], "test": "untested"}
{"id": "NlyXDm", "name": "Firework 2022", "author": "storyxx", "description": "A basic firework", "tags": ["raymarching"], "likes": 8, "viewed": 286, "published": 3, "date": "1671494673", "time_retrieved": "2024-07-30T16:12:03.468356", "image_code": "#define ITER 100\n#define MAX_DIST 1000.0\n#define MIN_DIST 0.01\n#define UP vec3(0,1,0)\n#define PI 3.1415926\n#define GOLDEN 2.3999632\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat atan2(in float y, in float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat grow(float x) {\n    return (cos(exp(-20.0*x)*PI)*0.5 + 0.5) * 100.0;\n}\n\nfloat falloff(float x) {\n    return pow(x, 512.0);\n}\n\nfloat DE(vec3 pos, vec3 dir, float index) {\n    float rVal = rand(index);\n    float block = max(4.0, abs(rVal)*10.0);\n    float subTime = fract(iTime/block);\n    float timeBlock = floor(iTime/block);\n    \n    vec3 offset = vec3((rand(timeBlock)*2.0-1.0) * 300.0, \n                       (rand(timeBlock+1.0)*2.0-1.0) * 100.0 - subTime*subTime*20.0, \n                       (rand(timeBlock+2.0)*2.0-1.0) * 300.0);\n    float boubleRadius = grow(subTime);\n    \n    vec3 newPos = normalize(pos-offset);\n    \n    float theta = atan2(newPos.x, newPos.z);\n    float y = newPos.y;\n    \n    float samples = 200.0+rand(timeBlock)*10.0; // has to be at least 29\n\n    \n    ////\n    vec2 q = vec2(y, theta);\n    \n    vec2 f1 = vec2(1.0-(2.0*8.0)/(samples-1.0), mod(8.0 * GOLDEN, 2.0 * PI));\n    vec2 f2 = vec2(1.0-(2.0*21.0)/(samples-1.0), mod(21.0 * GOLDEN, 2.0 * PI));\n    vec2 f3 = vec2(1.0-(2.0*29.0)/(samples-1.0), mod(29.0 * GOLDEN, 2.0 * PI));\n    \n    vec2 d1 = f2-f1;\n    vec2 d2 = f3-f1;\n    \n    mat2 m = mat2(d1.x, d1.y, d2.x, d2.y);\n    mat2 m_inv = inverse(m);\n    \n    vec2 p1 = floor(q*m_inv)*m;\n    vec2 p2 = q * m_inv;\n    p2.x = floor(p2.x);\n    p2.y = ceil(p2.y);\n    p2 = p2*m;\n    vec2 p3 = q*m_inv;\n    p3.x = ceil(p3.x);\n    p3.y = floor(p3.y);\n    p3 = p3*m;\n    vec2 p4 = ceil(q*m_inv)*m;\n    \n    float l1 = dot(p1-q, p1-q) + 1000.0 * float(abs(p1.x) > 1.0);\n    float l2 = dot(p2-q, p2-q) + 1000.0 * float(abs(p2.x) > 1.0);\n    float l3 = dot(p3-q, p3-q) + 1000.0 * float(abs(p3.x) > 1.0);\n    float l4 = dot(p4-q, p4-q) + 1000.0 * float(abs(p4.x) > 1.0);\n    \n    float minl = min(l1, min(l2, min(l3, l4)));\n    \n    vec2 res = float(minl==l1)*p1 + \n               float(minl==l2)*p2 + \n               float(minl==l3)*p3 + \n               float(minl==l4)*p4;\n    ////\n    \n    float resultY = res.x;\n    float resultTheta = res.y;\n    \n    \n    float radius = sqrt(1.0 - resultY*resultY);\n    \n    newPos.x = sin(resultTheta)*radius;\n    newPos.y = resultY;\n    newPos.z = cos(resultTheta)*radius;\n    \n    newPos *= boubleRadius + rand(res) * 10.0;\n    \n    return max(0.0, min(length(newPos+offset-pos)-1.0, length(pos-offset)));\n}\n\nvec3 march(vec3 pos, vec3 dir, vec3 clr, float index) {\n    float rVal = rand(index);\n    float block = max(4.0, abs(rVal)*10.0);\n    float subTime = fract(iTime/block);\n    float timeBlock = floor(iTime/block);\n\n    float totalDist;\n    float minDist = MAX_DIST;\n    \n    float maxDist = 0.0;\n    vec3 result = clr;\n    \n    for(int i=0; i<ITER; i++) {\n        float dist = DE(pos, dir, index);\n        totalDist += dist;\n        minDist = min(minDist, dist);\n        maxDist = max(maxDist, dist);\n        if(dist < MIN_DIST) {\n            //return vec3(float(i)/float(10.0));\n            result = clr;\n            break;\n        } else if(totalDist > MAX_DIST) {\n            result = clr * falloff(1.0-minDist/MAX_DIST);\n            break;\n        }\n        pos += dir*dist;\n    }\n    result = clr * falloff(1.0-minDist/MAX_DIST);\n    \n    return mix(result, vec3(0), subTime);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 centered = fragCoord-iResolution.xy/2.0;\n    \n    vec3 eye = vec3(sin(iTime*0.1)*510.0,0.0,cos(iTime*0.1)*510.0);\n    vec3 center = vec3(sin(iTime*0.1)*500.0,0.0,cos(iTime*0.1)*500.0);\n    \n    vec3 dir = normalize(center-eye);\n    \n    vec3 right = cross(dir, UP);\n    \n    vec3 color = march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.9,0.4), 1.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 2.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 3.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,0.3,1.0), 4.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.9,0.4), 5.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 6.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 7.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 8.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 9.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,0.3,1.0), 10.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.9,0.4), 11.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(1,0.2,0), 12.0);\n    color += march(right*centered.x + UP*centered.y + eye, dir, vec3(0.2,1.0,0.0), 13.0);\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 153, 153, 191], [192, 192, 212, 212, 279], [281, 281, 318, 318, 402], [404, 404, 425, 425, 480], [482, 482, 506, 506, 534], [536, 536, 579, 579, 2685], [2687, 2687, 2742, 2742, 3568], [3570, 3570, 3625, 3625, 5135]], "test": "untested"}
{"id": "Dls3z4", "name": "random flickering effect", "author": "jonasfrey", "description": "i want to reproduce the shader you see when googling \"world cup winner\" ", "tags": ["firework"], "likes": 5, "viewed": 234, "published": 3, "date": "1671493627", "time_retrieved": "2024-07-30T16:12:04.701061", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec4 f_o_coltxtnyan(vec2 o_nor){\n    vec2 o_scl_sprt = vec2(33.,20.);\n    vec2 o_offset_frst_sprt = vec2(3.,6.);\n    float n_t = iTime*10.;\n    n_t = 0.; // comment to animate\n    vec2 o_trs_sprt = vec2(floor(mod(n_t, 5.)), 0.);\n    \n    vec2 o_trs = o_nor * o_scl_sprt;\n    vec2 o_trsextra = vec2(7., 0.);\n    return texelFetch(\n        iChannel1,\n        ivec2(o_trs)\n\n         + ivec2(o_trsextra*o_trs_sprt.x)\n         + ivec2(o_trs_sprt*o_scl_sprt)\n         + ivec2(o_offset_frst_sprt),\n        0\n    );\n}\nvec2 f_o_index_by_trn_scl(\n    vec2 o_trn, \n    vec2 o_scl\n){\n    float n_index = floor(o_trn.x)+floor(floor(o_trn.y)*floor(o_scl.x));\n    float n_index_nor = n_index / (floor(o_scl.x)*floor(o_scl.y));\n    return vec2(\n        n_index,\n        n_index_nor\n    );\n} \nvec3 f_o_distmin_distsum_distmul(\n    vec2 o_fragCoord, \n    vec2 o_iResolution,\n    float n_random,\n    float n_sphere_size_nor,\n    vec2 o_scale_kernel, \n    vec2 o_rnd_trns_inside_kernel_max_nor\n){\n\n    float n_size_kernel = o_scale_kernel.x * o_scale_kernel.y;\n    vec2 o_index = f_o_index_by_trn_scl(\n        o_fragCoord, \n        o_iResolution\n    );\n\n    float n_sphere_size_max = floor(o_scale_kernel.x/2.);\n    vec3 o_dist_sum = vec3(0.);\n    vec3 o_dist_mul = vec3(1.);\n    vec3 o_dist_min = vec3(1.);\n\n    vec3 o_col = vec3(0.);\n    for(float n_y = 0.; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.; n_x < o_scale_kernel.x; n_x+=1.){\n            vec2 o_fragCoord_offset = vec2(\n                        n_x-floor(o_scale_kernel.x/2.),\n                        n_y-floor(o_scale_kernel.y/2.)\n            );\n            vec2 o_index_current = f_o_index_by_trn_scl(\n                floor(o_fragCoord+o_fragCoord_offset),\n                o_iResolution\n               );\n               float n_rand = f_n_rand(o_index_current.x*n_random)-.5;\n               float n_rand2 = f_n_rand(o_index_current.x*n_rand*n_random)-.5;\n                vec2 o_diff = (\n                    (fract(o_fragCoord)-\n                      o_fragCoord_offset)\n                     + vec2(n_rand,n_rand2)*(vec2(floor(o_scale_kernel/2.))*o_rnd_trns_inside_kernel_max_nor)//*sin(iTime)))\n                    );\n                float n_dist = length(o_diff);\n                \n                o_dist_min = vec3(min(o_dist_min.r, n_dist));\n                o_dist_mul = vec3(o_dist_mul * vec3(n_dist));\n                float n = step(0., n_sphere_size_max-(n_dist*(1./(n_sphere_size_nor/2.))));\n                vec4 o_coltxtnyan = f_o_coltxtnyan(\n                    floor(o_fragCoord+o_fragCoord_offset) \n                        / floor(o_iResolution)\n                );\n                o_dist_sum+=o_coltxtnyan.rgb* vec3(n/n_size_kernel);\n                //n_dist_min = o_trpino_scld.x;\n        }\n    }\n    //return vec3(\n    \n        //n_dist_min, \n        //n_dist_sum,\n        //n_dist_mul\n    //);\n    return o_dist_sum;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_fragCoord_nor = fragCoord.xy /iResolution.xy;\n    vec4 o_col_last = texture(iChannel0, o_fragCoord_nor);\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        o_trmono = vec2(\n            n_t_x*2.,\n            n_t_y\n            //(f_n_rand(n_t)-0.5)*2.,\n            //f_n_rand(n_t*3.33)-0.5\n        );\n    }\n    float n_fadeout = 5.;\n    vec2 o_scale_factor = vec2(0.1);\n    vec3 o_distmin_distsum_distmul = f_o_distmin_distsum_distmul(\n        fragCoord.xy*o_scale_factor,//+vec2(sin(iTime)*20.),\n        iResolution.xy*o_scale_factor, \n        mod(floor(iTime*20.), 20.)+1., \n        1.-fract(iTime)*fract(iTime),//n_sphere_size_nor, \n        vec2(5.),//o_scale_kernel, \n        vec2(1.) //o_rnd_trns_inside_kernel_max_nor\n    );\n\n    fragColor = vec4(\n        o_distmin_distsum_distmul.rgb*5., 1.\n    );\n\n    fragColor = mix(vec4(o_col_last), fragColor, 0.09);\n\n    //fragColor = vec4(n_dist_min);\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 235]], "test": "untested"}
{"id": "dtf3RM", "name": "ChatGPT \"modern car\"", "author": "BeRo", "description": "Code mostly only from ChatGPT. That happens when a AI writes an raymarcher shader. :-)", "tags": ["raymarching", "car", "chatgpt"], "likes": 6, "viewed": 464, "published": 3, "date": "1671487788", "time_retrieved": "2024-07-30T16:12:05.818074", "image_code": "// Code mostly only from ChatGPT from a very long thread, where ChatGPT has \n// often corrected itself\n\n// GLSL function to calculate distance to a torus\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\n// GLSL function to calculate distance to a box\nfloat sdBox(vec3 p, vec3 b, vec3 r) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// GLSL function to calculate distance to a sphere\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\n\nvec2 sdModernCar(vec3 p) {\n  float dist = 10000.0;\n  float materialIndex = 0.0;\n\n  // Calculate distance to car body\n  float bodyDist = sdBox(p - vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.8), vec3(0.0));\n  dist = min(dist, bodyDist);\n  materialIndex = 1.0; // Body of car is material 1\n\n  // Calculate distance to front grill\n  float grillDist =\n      sdBox(p - vec3(0.0, 0.5, 1.8), vec3(1.0, 0.1, 0.2), vec3(0.0));\n  if (grillDist < dist) {\n    dist = grillDist;\n    materialIndex = 3.0; // Grill of car is material 3\n  }\n\n  // Calculate distance to front left headlight\n  float flhDist = sdSphere(p - vec3(0.9, 0.5, 1.8), 0.2);\n  if (flhDist < dist) {\n    dist = flhDist;\n    materialIndex = 4.0; // Headlights of car are material 4\n  }\n\n  // Calculate distance to front right headlight\n  float frhDist = sdSphere(p - vec3(-0.9, 0.5, 1.8), 0.2);\n  if (frhDist < dist) {\n    dist = frhDist;\n    materialIndex = 4.0; // Headlights of car are material 4\n  }\n\n  // Calculate distance to front left tire\n  float fltDist = sdTorus(p - vec3(0.7, 0.0, 1.0), vec2(0.2, 0.2));\n  if (fltDist < dist) {\n    dist = fltDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  // Calculate distance to front right tire\n  float frtDist = sdTorus(p - vec3(-0.7, 0.0, 1.0), vec2(0.2, 0.2));\n  if (frtDist < dist) {\n    dist = frtDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  // Calculate distance to back left tire\n  float bltDist = sdTorus(p - vec3(0.7, 0.0, -1.2), vec2(0.2, 0.2));\n  if (bltDist < dist) {\n    dist = bltDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  // Calculate distance to back right tire\n  float brtDist = sdTorus(p - vec3(-0.7, 0.0, -1.2), vec2(0.2, 0.2));\n  if (brtDist < dist) {\n    dist = brtDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  return vec2(dist, materialIndex);\n}\n\nvec3 sdNormal(vec3 p, float eps) {\n  vec3 n;\n  n.x = sdModernCar(p + vec3(eps, 0.0, 0.0)).x - sdModernCar(p - vec3(eps, 0.0, 0.0)).x;\n  n.y = sdModernCar(p + vec3(0.0, eps, 0.0)).x - sdModernCar(p - vec3(0.0, eps, 0.0)).x;\n  n.z = sdModernCar(p + vec3(0.0, 0.0, eps)).x - sdModernCar(p - vec3(0.0, 0.0, eps)).x;\n  return normalize(n);\n}\n\n// Main GLSL function\nvec2 raymarchCar(vec3 start, vec3 direction) {\n  float t = 0.0;\n  float dist = 0.0;\n  float minDist = 10000.0;\n  float materialIndex = 0.0;\n  int i = 0;\n  \n  while (i < 300 && t < 30.0) {\n    vec3 pos = start + t * direction;\n\n    // Calculate distance and material index using sdModernCar function\n    vec2 result = sdModernCar(pos);\n    dist = result.x;\n    float tempMaterialIndex = result.y;\n\n    // Check if current distance is the minimum distance\n    if (dist < minDist) {\n      minDist = dist;\n      materialIndex = tempMaterialIndex;\n    }\n\n    t += dist;\n    i++;\n  }\n\n  return (minDist < 1e-4) ? vec2(minDist, materialIndex) : vec2(0.0, 0.0);\n}\n\n// View ray generation\nvoid generateRay(out vec3 resultRayOrigin, out vec3 resultRayDirection,\n                 in vec3 viewOrigin, in vec3 viewTarget, in vec2 uv) {\n  vec2 p = (2.0 * uv - iResolution.xy) / iResolution.y;\n\n  resultRayOrigin = viewOrigin;\n\n  // camera matrix\n  vec3 ww = normalize(viewTarget - viewOrigin);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  // create view ray\n  resultRayDirection = normalize(p.x * uu + p.y * vv + 2.2 * ww);\n}\n\n// Main GLSL entry function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n  // Ray origin\n  vec3 rayOrigin = vec3(0.0, 1.5, -5.0);\n\n  // Rotate ray origin towards car middle point\n  mat3 rotate = mat3(cos(iTime), 0.0, sin(iTime), 0.0, 1.0, 0.0, -sin(iTime), 0.0, cos(iTime));\n  rayOrigin = rotate * rayOrigin;\n  \n  // Generate view ray\n  vec3 viewTarget = vec3(0.0, 0.0, 0.0);\n  vec3 rayDirection;\n  generateRay(rayOrigin, rayDirection, rayOrigin, viewTarget, fragCoord);\n\n  // Calculate distance and material index using raymarchCar function\n  vec2 result = raymarchCar(rayOrigin, normalize(rayDirection));\n  float dist = result.x;\n  float materialIndex = result.y;\n\n  // Calculate final color based on material index and simple lambert lighting\n  vec3 finalColor;\n  if (materialIndex == 1.0) {\n    // Body of car is silver\n    finalColor = vec3(0.75, 0.75, 0.75);\n  } else if (materialIndex == 2.0) {\n    // Wheels of car are black\n    finalColor = vec3(0.0, 0.0, 0.0);\n  } else if (materialIndex == 3.0) {\n    // Grill of car is chrome\n    finalColor = vec3(0.9, 0.9, 0.9);\n  } else if (materialIndex == 4.0) {\n    // Headlights of car are white\n    finalColor = vec3(1.0, 1.0, 1.0);\n  } else if (materialIndex == 5.0) {\n    // Tires of car are black\n    finalColor = vec3(0.0, 0.0, 0.0);\n  } else {\n    // Any other material is white\n    finalColor = vec3(1.0, 1.0, 1.0);\n  }\n  \n  // Calculate lighting using simple lambert lighting model\n  if (materialIndex > 0.0) {\n    vec3 lightDirection = normalize(vec3(0.5, 0.5, 0.5));\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    // If we hit an object, calculate surface normal  \n    normal = sdNormal(rayOrigin + rayDirection * dist, 0.001);\n    finalColor *= max(dot(lightDirection, normal), 0.0);\n  }\n  \n  fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtf3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 154, 185, 185, 255], [257, 305, 342, 342, 433], [435, 486, 519, 519, 543], [545, 545, 571, 571, 2404], [2406, 2406, 2440, 2440, 2742], [2744, 2766, 2812, 2812, 3421], [3423, 3446, 3588, 3588, 3928], [3930, 3958, 4015, 4033, 5733]], "test": "untested"}
{"id": "mlfGRM", "name": "Raytracing Booleans", "author": "iq", "description": "Top: intersection of some shapes. Bottom: subtraction. This works by doing boolean operations in \"ray space\" (ie, manipulating intervals of ray distances). I'm only tracking 1 segment, more should be added for deeper boolean trees.", "tags": ["3d", "raytracing", "intersection", "boolean", "subtraction"], "likes": 81, "viewed": 2213, "published": 3, "date": "1671485886", "time_retrieved": "2024-07-30T16:12:06.560090", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Raytracing boolean operations on shapes.\n//\n// Top: intersection of some shapes (box, sphere and plane)\n// Bottom: subtraction of same shapes\n//\n// This works by doing boolean operations in \"ray space\" (ie,\n// manipulating intervals of ray distances). I'm only tracking one\n// segment, more should be added for deeper boolean trees.\n//\n// When intersecting two solid intervals A and B, there are 6 possible\n// scenarios for their combination:\n//\n// 1     x---x  |             |\n// 2     x------|---x         |\n// 3     x------|-------------|--x\n// 4            |   x-----x   |\n// 5            |   x---------|--x\n// 6            |             |  x---x \n//\n// Subtraction in scenario 4 produces TWO segments, but I'm only tracking\n// ONE segment at a time in this shader, so I've got to take an arbitrary\n// decision as to what to do in that case (line 58).\n\n\nIntersection opIntersection( Intersection a, Intersection b, out int r )\n{\n    if( a.a.x<b.a.x )\n    {\n        /* 1 */ if( a.b.x<b.a.x ) return kEmpty;\n        /* 2 */ if( a.b.x<b.b.x ) { r=1; return Intersection(b.a,a.b); }\n        /* 3 */ { r=1; return b; }\n    }\n    else if( a.a.x<b.b.x )\n    {\n        /* 4 */ if( a.b.x<b.b.x ) { r=0; return a; }\n        /* 5 */ { r=0; return Intersection(a.a,b.b); }\n    }\n    else\n    {\n        /* 6 */ return kEmpty;\n    }\n}\n\nIntersection opSubtraction( Intersection b, Intersection a, out int r )\n{\n    if( a.a.x<b.a.x )\n    {\n        /* 1 */ if( a.b.x<b.a.x ) { r=0; return b; }\n        /* 2 */ if( a.b.x<b.b.x ) { r=1; return Intersection(a.b,b.b); }\n        /* 3 */ return kEmpty;\n    }\n    else if( a.a.x<b.b.x )\n    {\n        /* 4 */ if( a.b.x<b.b.x ) { r=0; return Intersection(b.a,a.a); } // hm.... difficult to choose\n        /* 5 */ { r=0; return Intersection(b.a,a.b); }\n    }\n    else\n    {\n        /* 6 */ { r=0; return b; }\n    }\n}\n\nvec4 raycast( in Ray r, ivec2 id, out int objID )\n{   \n    const vec4 pl = vec4(normalize(-vec3(1,1,1)),-0.1);\n\n    // transform one of the primitives\n   \tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), 0.5*iTime );\n\tmat4 tra = translate( 0.0, 0.0, 0.2*sin(iTime) );\n\tmat4 txx = tra * rot; \n\n    // by transforming the ray with its inverse\n    Ray rt = transform( r, inverse(txx) );\n\n    // intersect primitives\n    Intersection a, b;\n    \n    if( id.x==0 )\n    {\n        a = iSphere(r.o,r.d,0.3);\n        b = iPlane(rt.o,rt.d,pl);\n    }\n    else if( id.x==1 )\n    {\n        a = iSphere(r.o,r.d,0.3);\n        b = iBox(rt.o,rt.d,vec3(0.4,0.2,0.1) );\n    }\n    else if( id.x==2 )\n    {\n        a = iBox(r.o,r.d,vec3(0.3,0.2,0.1) );\n        //b = iPlane(rt.o,rt.d,pl);\n        b = iSphere(rt.o,rt.d,0.3);\n    }\n    else\n    {\n        a = iBox(r.o,r.d,vec3(0.4,0.1,0.2) );\n        b = iBox(rt.o,rt.d,vec3(0.3,0.3,0.2) );\n    }\n    \n    // bottom row subtraction, top row intersection\n    int o;\n    Intersection i;\n    if( id.y==0 ) i = opSubtraction( a,b,o);\n    else          i = opIntersection(a,b,o);\n    \n    // no intersection\n    if( isEmpty(i) ) { objID=-1; return vec4(-1.0); }\n\n    // intersection\n    objID = o; return vec4(i.a.x,i.a.yzw);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 1.0 + 0.0 * 0.8*sin(0.1*iTime);\n\tvec3 ro = vec3( 0.9*sin(an), 0.2+0.2*sin(1.0*an), 0.9*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // global normalize coordinates\n    vec2 gp = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // 4x2 screen tiles\n    ivec2 id = ivec2(vec2(4,2)*fragCoord/iResolution.xy);\n    vec2 res = iResolution.xy/vec2(4,2);\n    vec2 q   = mod(fragCoord,res);\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(q+o)-res.xy)/res.y;\n        #else    \n        vec2 p = (2.0*q-res.xy)/res.y;\n        #endif\n        \n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        \n        // background\n\t    vec3 col = vec3(0.07) * (1.0-0.3*length(gp));\n        //col += 0.1*cos( float(5*id.y+id.x)+vec3(0,2,4));\n\n        // raycast\n        int obj = -1;\n        vec4 tnor = raycast( Ray(ro,rd), id, obj);\n        if( tnor.x>0.0 )\n        {\n            float t = tnor.x;\n            vec3  pos = ro + t*rd;\n            vec3  nor = tnor.yzw;\n\n            // material\n            #if 1\n            vec3 pa = cos(60.0*pos); \n            vec3 mate = vec3(0.1,0.5,0.7) + vec3(0.9,0.5,0.3)*smoothstep(-1.0,1.0,pa.x+pa.y+pa.z); \n            #else\n            vec3 mate = vec3(0.0,0.5,0.5);\n            #endif\n            if( obj==1 ) mate =vec3(0.9,0.4,0.0);\n\n            // lighting\n            vec3  lig = normalize(vec3(0.7,0.5,-0.4));\n            vec3  hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            \n            col  = mate*vec3(0.20,0.25,0.30)*amb;\n            col += mate*vec3(1.00,0.90,0.70)*dif;\n            col += 0.2*pow(clamp(dot(hal,nor),0.0,1.0),24.0)*dif;\n            //col = pow(0.5 + 0.5*nor,vec3(2.2));\n        }\n\n        // gamma\n        col = pow( col, vec3(1.0/2.2) );\n\t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,17,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "// Intersection functions\n\n// Keeps track of only 1 segment of solid mass at the time\n// (form entry to exit of the ray and a primitive), but more\n// segments should be added in order to handle more complex\n// booleans\nstruct Intersection\n{\n    vec4 a;  // distance and normal at entry\n    vec4 b;  // distance and normal at exit\n};\n\nconst Intersection kEmpty = Intersection(vec4(1e20,0.0,0.0,0.0),vec4(-1e20,0.0,0.0,0.0));\n\nbool isEmpty( Intersection i )\n{\n    return i.b.x < i.a.x;\n}\n\n\n\n// https://iquilezles.org/articles/boxfunctions\nIntersection iBox( in vec3 ro, in vec3 rd, in vec3 siz ) \n{\n    vec3 m = 1.0/rd;\n    vec3 k = vec3(rd.x>=0.0?siz.x:-siz.x, rd.y>=0.0?siz.y:-siz.y, rd.z>=0.0?siz.z:-siz.z);\n    vec3 t1 = (-ro - k)*m;\n    vec3 t2 = (-ro + k)*m;\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n\tif( tN>tF || tF<0.0 ) return kEmpty;\n    return Intersection( vec4(tN, -sign(rd)*step(vec3(tN),t1)), \n                         vec4(tF, -sign(rd)*step(t2,vec3(tF))) );\n}\n\n// just solve for t, |ro+t*d|² = r²\nIntersection iSphere( in vec3 ro, in vec3 rd, float r )\n{   \n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return kEmpty;\n    h = sqrt( h );\n    float ta = -b-h; vec3 na = (ro+ta*rd)/r;\n    float tb = -b+h; vec3 nb = (ro+tb*rd)/r;\n    return Intersection(vec4(ta,na),vec4(tb,nb));\n}\n\n// just solve for t, < ro+t*d, nor > - k = 0\nIntersection iPlane( in vec3 ro, in vec3 rd, vec4 pla )\n{ \n    float k1 = dot(ro, pla.xyz);\n    float k2 = dot(rd, pla.xyz);\n    float t = (pla.w-k1)/k2;        \n    vec2 ab = (k2>0.0) ? vec2( t, 1e20 ) : vec2( -1e20, t );\n    return Intersection( vec4(ab.x, -pla.xyz), vec4(ab.y, pla.xyz) );\n}\n\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nRay transform( Ray r, mat4x4 m )\n{\n\treturn Ray( (m*vec4(r.o,1.0)).xyz, (m*vec4(r.d,0.0)).xyz );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfGRM.jpg", "access": "api", "license": "mit", "functions": [[1939, 1939, 2013, 2013, 2405], [2407, 2407, 2480, 2480, 2926], [2928, 2928, 2979, 2979, 4188]], "test": "untested"}
{"id": "mlXGzN", "name": "Quadtree Tapestry", "author": "fenix", "description": "This is debug draw for a new cloth engine I'm working on. Still early days on any kind of nice looking cloth, but this seemed interesting enough as a piece of abstract art to present on its own as a work-in-progress.", "tags": ["simulation", "dynamics", "physics", "quadtree", "cloth"], "likes": 9, "viewed": 268, "published": 3, "date": "1671480872", "time_retrieved": "2024-07-30T16:12:07.305098", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  This is debug draw for a new cloth engine I'm working on. Still early days on any\n//  kind of nice looking cloth, but this seemed interesting enough as a piece of abstract\n//  art to present on its own as a work-in-progress.\n//\n//  Define DEBUG_NUM_PROC to 0 to see the current state of my cloth shading. For some\n//  reason my performance goes in the toilet so far with every attempt I have made to\n//  get smooth shading. I'm hopeful of finding a solution, but ideas are welcome! Next\n//  I think I will try returning cloth UVs from the render (which would be useful for\n//  texturing the cloth anyway) and compute the normals separately from the quadtree\n//  traverasal, taking advantage of the texture hardware.\n//\n// ---------------------------------------------------------------------------------------\n\nstruct Span\n{\n    vec2 mins;\n    vec2 maxs;\n};\n\nfloat length2(vec2 v) { return dot(v, v); }\n\nvec2 bary(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    return vec2((d11 * d20 - d01 * d21) / denom,\n                (d00 * d21 - d01 * d20) / denom);\n}\n\nvec3 screen(vec3 p, mat4 w2c)\n{\n    vec3 s = (w2c * vec4(p,1.0)).xyz;\n    s.xy = s.xy / s.z;\n    return s;\n}\n\nvoid drawTri(vec3 p0, vec3 p1, vec3 p2, vec2 p, vec3 cameraPos, vec3 rayDir, inout float t, inout vec3 norm)\n{\n    vec2 bc = bary(p, p0.xy, p1.xy, p2.xy);\n    float z = p0.z + bc.x * (p1.z - p0.z) + bc.y * (p2.z - p0.z);\n    \n    if (all(lessThanEqual(bc, vec2(1))) && all(greaterThanEqual(bc, vec2(0))) && bc.x + bc.y < 1. && z < t)\n    {\n        norm = normalize(cross(p1 - p0, p2 - p0));\n        t = z;\n    }\n}\n\nconst float MAX_T = 1e6;\n\n#define CLOTH_POS(X) texture(iChannel0, (X+.5)/iResolution.xy).xyz\n\nvoid renderQuad(Span quad, mat4 w2c, vec2 p, vec3 cameraPos, vec3 rayDir, inout float t, inout vec3 norm)\n{\n    vec3 pos0 = screen(CLOTH_POS(quad.mins), w2c);\n    vec3 pos1 = screen(CLOTH_POS(vec2(quad.mins.x, quad.maxs.y)), w2c);\n    vec3 pos2 = screen(CLOTH_POS(quad.maxs), w2c);\n    vec3 pos3 = screen(CLOTH_POS(vec2(quad.maxs.x, quad.mins.y)), w2c);\n\n    t = MAX_T;\n    drawTri(pos0, pos1, pos2, p, cameraPos, rayDir, t, norm);\n    drawTri(pos2, pos3, pos0, p, cameraPos, rayDir, t, norm);\n}\n\nbool testQuad(Span quad, mat4 w2c, vec2 u)\n{\n    vec2 center = (quad.maxs + quad.mins) * .5;\n    vec2 size = (quad.maxs - quad.mins) * .5;\n    float radius = length(size)/float(CLOTH_SIDE_LEN);\n    vec3 worldPos = CLOTH_POS(center);\n    vec3 cameraPos = screen(worldPos, w2c);\n    \n    return length2(cameraPos.xy - u) < radius * radius;\n}\n\n#define DEBUG_NUM_PROC 1\n\n#if DEBUG_NUM_PROC\n#define DEBUG_NUM_PROC_ONLY(X) X\n#else\n#define DEBUG_NUM_PROC_ONLY(X)\n#endif\n\nDEBUG_NUM_PROC_ONLY(int numProc = 0;)\n\nconst int MAX_STACK = 20;\nvoid processQuad(Span quad, mat4 w2c, inout Span stack[MAX_STACK], inout int numStack, vec2 u, vec3 cameraPos, vec3 rayDir, inout vec4 fragColor)\n{\n    DEBUG_NUM_PROC_ONLY(++numProc);\n    if (all(lessThanEqual(quad.maxs - quad.mins, vec2(1))))\n    {\n        float t;\n        vec3 norm;\n        renderQuad(quad, w2c, u, cameraPos, rayDir, t, norm);\n        if (t < MAX_T)\n        {\n            const vec3 lightDir = normalize(vec3(1));\n            fragColor += vec4(vec3(1, 0, 0) * abs(dot(norm, lightDir)), t);\n        }\n    }\n    else if (testQuad(quad, w2c, u))\n    {\n        if (numStack < MAX_STACK)\n        {\n            stack[numStack++] = quad;\n        }\n    }\n}\n\nvoid quadtreeRender(mat4 w2c, vec2 u, vec3 cameraPos, vec3 rayDir, inout vec4 fragColor)\n{\n    const int MAX_STACK = 20;\n    Span stack[MAX_STACK];\n    int numStack = 1;\n    stack[0].mins = vec2(0);\n    stack[0].maxs = vec2(CLOTH_SIDE_LEN - 1);\n    \n    while (numStack > 0)\n    {\n        Span curr = stack[--numStack];\n        vec2 center = (curr.mins + curr.maxs) * .5;\n        \n        processQuad(Span(curr.mins, center), w2c, stack, numStack, u, cameraPos, rayDir, fragColor);\n        processQuad(Span(vec2(center.x, curr.mins.y), vec2(curr.maxs.x, center.y)), w2c, stack, numStack, u, cameraPos, rayDir, fragColor);\n        processQuad(Span(vec2(curr.mins.x, center.y), vec2(center.x, curr.maxs.y)), w2c, stack, numStack, u, cameraPos, rayDir, fragColor);\n        processQuad(Span(center, curr.maxs), w2c, stack, numStack, u, cameraPos, rayDir, fragColor);\n    }\n}\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = vec3(0,0,-3);\n    cameraLookAt = vec3(0);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvoid mainImage( out vec4 O, in vec2 fragCoord )\n{\n    DEBUG_NUM_PROC_ONLY(numProc = 0);\n    vec2 u = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    O = vec4(0,0,0,1e6);\n\n    quadtreeRender(w2c, u, cameraPos, rayDir, O);\n    DEBUG_NUM_PROC_ONLY(O = sin(float(numProc) + vec4(0, 5, 11, 0)) * sqrt(vec4(numProc)) / 10.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CLOTH_SIDE_LEN = 65;\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Cloth simulation. Left side is current position, right side is last position.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (any(greaterThan(ifc, CLOTH_SIDE_LEN * ivec2(2, 1))))\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    if (iFrame == 0)\n    {\n        fragCoord.x = mod(fragCoord.x, float(CLOTH_SIDE_LEN));\n        fragColor = vec4((((fragCoord) - float(CLOTH_SIDE_LEN - 1) * .5) - .5)*2./float(CLOTH_SIDE_LEN), 0, 0);\n        if (ifc.x >= CLOTH_SIDE_LEN * 2)\n        {\n            fragColor = vec4(0, 0, 1, 0);\n        }\n        return;\n    }\n   \n    if (ifc.x >= CLOTH_SIDE_LEN)\n    {\n        // store last position on right side\n        fragColor = texelFetch(iChannel0, ifc - ivec2(CLOTH_SIDE_LEN, 0), 0);\n        return;\n    }\n    \n    vec3 pos = texelFetch(iChannel0, ifc, 0).xyz;\n    if (ifc.y != CLOTH_SIDE_LEN - 1) // pinned\n    {\n        vec3 oldPos = texelFetch(iChannel0, ifc + ivec2(CLOTH_SIDE_LEN, 0), 0).xyz;\n        pos += (pos - oldPos);\n        pos += vec3(0, -.01, 0);\n        pos.z += sin(pos.x*3. + iTime*.5) * .002;\n\n        for (int i = 0; i < 3; ++i)\n        {\n            ivec2 nb = ifc + ivec2(0, i);\n            if (nb.y <= CLOTH_SIDE_LEN - 1)\n            {\n               vec3 nbPos = texelFetch(iChannel0, nb, 0).xyz;\n               vec3 delta = pos - nbPos;\n               float deltaLen = length(delta);\n               if (deltaLen > float(i) * 2. / float(CLOTH_SIDE_LEN - 1))\n               {\n                   pos = mix(nbPos + normalize(delta) * float(i) * 2. / float(CLOTH_SIDE_LEN - 1), pos, .5);\n               }\n            }\n        }\n    }\n    \n\n    fragColor = vec4(pos, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXGzN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1072, 1072, 1095, 1095, 1115], [1117, 1117, 1160, 1160, 1492], [1494, 1494, 1525, 1525, 1602], [1604, 1604, 1714, 1714, 2017], [2113, 2113, 2220, 2220, 2608], [2610, 2610, 2654, 2654, 2949], [3139, 3139, 3286, 3286, 3808], [3810, 3810, 3900, 3900, 4680], [4682, 4682, 4804, 4804, 5043], [5045, 5045, 5158, 5158, 5314], [5316, 5316, 5419, 5419, 5551], [5553, 5553, 5602, 5602, 6229]], "test": "untested"}
{"id": "ctf3zM", "name": "funny lines", "author": "jonasfrey", "description": "tau", "tags": ["tau"], "likes": 3, "viewed": 206, "published": 3, "date": "1671467713", "time_retrieved": "2024-07-30T16:12:08.103962", "image_code": "float f_n_dist_line_segment_byiq(\n    in vec2 p,\n    in vec2 a,\n    in vec2 b\n) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nfloat f_n_inout(float n){\n    if(n > .5){\n        return 0.5 - mod(n, 0.5); \n    }\n    return n;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = (fragCoord - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_fc_nor = fragCoord.xy / iResolution.xy;\n    o_trpino*=sin(iTime)*2.;\n    float n_tau = 6.2831;\n    vec3 o_col = vec3(1.);//0.12,0.3,0.8);\n    vec2 o_p = vec2(0., 0.);\n    vec2 o_diff = o_trpino-o_p;\n    float n_dist = length(o_diff);\n    float n_ang = (atan(o_diff.x, o_diff.y)+(n_tau/2.))/n_tau;\n    vec4 o = vec4((sin(n_ang*n_tau*10.)*sin(fract(n_dist+iTime)*n_tau)+0.5));\n    fragColor = o*vec4(o_col, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctf3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 81, 81, 201], [203, 203, 228, 228, 302], [303, 303, 360, 360, 857]], "test": "untested"}
{"id": "DtX3zM", "name": "spiral bowl of soup?", "author": "yonatan", "description": "idk", "tags": ["spiralfluid"], "likes": 15, "viewed": 311, "published": 3, "date": "1671465416", "time_retrieved": "2024-07-30T16:12:08.869914", "image_code": "#define PI 3.14159265\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t=mod(iTime, 6.);\n    vec3 o=vec3(0), rd, p;\n    for(float d,y,i,j,g,e,v,R,a,n;i++<1e2;o+=.01/exp(e*1e4/v*vec3(3,2,1)+vec3(4,5,9)/d/1e5)){\n        rd=normalize(vec3((.5*iResolution.xy-fragCoord)/iResolution.y,2)),\n        p=g*rd+i/4e4;\n        p.z-=1.5;\n        p.yz*=rotate2D(.6);\n        y=p.y;\n        e=atan(p.x,p.z);\n        p=vec3(log2(v=R=length(p))-t+e/PI,a*sin(4.5*e),a=.3*y/R)+.5;\n        for(j=n=0.;j++<9.;p=abs(p/a))\n            R*=a=dot(p-=round(p),p)*1.5+.09,\n            n+=sin(j/R+t*PI/3.);\n        g+=e=min(d=abs(.25*v-y+n*.01)*.4,max(-y,R))*.3;\n    }\n    o=pow(o,vec3(.3));\n    fragColor = vec4(o,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtX3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 45, 45, 97], [99, 99, 156, 156, 789]], "test": "untested"}
{"id": "ctX3RM", "name": "Chrome Dreams [458 chars]", "author": "kishimisu", "description": "Playing with rotations and space repetition", "tags": ["raymarching", "space", "repetition", "psychedelic", "code", "rotation", "golf", "golfing"], "likes": 24, "viewed": 637, "published": 3, "date": "1671461047", "time_retrieved": "2024-07-30T16:12:09.611931", "image_code": "/* \"Chrome Dreams\" by @kishimisu (2022) - https://www.shadertoy.com/view/ctX3RM\n   458 chars => 399 chars by @Xor in the comments\n\n   Playing with rotations and space repetition.\n   \n   If you have a good GPU you can increase the \n   \"2e2\" value (line 20) to \"3e2\" or more \n   in order to reduce aliasing.\n*/\n\n#define a(a,b,f,o) mix(a,b,sin(o+e*f)*.5+.5)\n#define s(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float c , \n          o , \n          d = 3., \n          e = iTime*.4;\n    vec2  r = iResolution.xy; \n    \n    for (;o++<2e2 && d>.001;) {\n        vec3 p = abs(.7*c*normalize(vec3((F+F-r)/r.y, 1)));\n        p.xy *= s(e);\n        p.zy += e + c*.2;\n        p = fract(p)-.5;\n        p.xy *= s(c);\n        p.xz *= s(e);\n        p.y = max(abs(p.y)-a(0.,.2,1.,),0.);\n        c += d = (length(vec2(length(p.xy)-.2,p.z)) \n                 -a(.04,.1,.5,4.) - c*.01)*.5;\n    }\n    \n    O.rgb = 1.2*(cos(c*6. + .8*vec3(0,1.+c*.04,2))+.2)/exp(c*.14);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctX3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mts3zN", "name": "Better R2 Sequence", "author": "MartyMcFly", "description": "Alternate variant of the ubiquitous R2 sequence, see Common for details\nYields about 2x-3x the amount of precision", "tags": ["goldenratio", "lowdiscrepancy", "quasirandom"], "likes": 10, "viewed": 568, "published": 3, "date": "1671459322", "time_retrieved": "2024-07-30T16:12:10.371899", "image_code": "/*\n    R2 sequence (http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/)\n    and ~100 shadertoys on the topic\n    \n    Improved variant with different coefficients covers the 0-1 domain more evenly before float\n    precision limits. Each frame, 100 points are added. Left side ends up with more holes that don't\n    disappear, right side is more uniform and has better coverage.\n    \n    Generated pattern is identical (just flipped) so there's no reason NOT to use this over the other.\n    Would be interesting to measure convergence properties with the given precision or if this is just\n    a purely visual difference.\n    \n    A possible total solution could be e.g. to calculate float error and add a second pass of the sequence\n    to cover exactly this width\n    \n*/\n\nvoid mainImage( out vec4 o, in vec2 vpos )\n{\n    vec2 uv = vpos / iResolution.xy; \n    o = texture(iChannel0, uv);\n    \n    float t = abs(uv.x - 0.5);\n    t /= abs(dFdx(t));\n    t = smoothstep(1.8,2.0,t);\n    \n    //o = mix(o, vec4(1.0), vec4(1.0 - t));   \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define NUM_POINTS_PER_FRAME    1000\n#define SAMPLE_SKIP             5000 // 262144//100000 //skip ahead to see problematic areas\n\nvoid mainImage( out vec4 o, in vec2 vpos )\n{\n    vec2 uv = vpos / iResolution.xy;\n    vec2 orig_uv = uv;\n    uv.x *= 2.0;\n    \n    bool side = uv.x > 1.0;    \n    uv.x = fract(uv.x);\n    \n    o = vec4(0.0);\n    \n    float halfaspect = iResolution.x * 0.5 / iResolution.y;\n    float radius2 = 7.0 / (iResolution.x * iResolution.x);    \n    const int N = NUM_POINTS_PER_FRAME;\n    \n    uv.y /= halfaspect;    \n    uv.y += 0.5 * (halfaspect - 1.0);\n    \n    uv = uv * 2.0 - 1.0;\n    uv *= 1.05;\n    uv = uv * 0.5 + 0.5;\n    \n    float border = step(0.5, max(abs(uv.x - 0.5), abs(uv.y - 0.5))) * \n                   step(max(abs(uv.x - 0.5), abs(uv.y - 0.5)), 0.5 + length(fwidth(uv)));\n    \n    o = vec4(border);\n    \n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    \n    if(side) //new\n    {\n        for(int j = 0; j < N; j++)\n        {\n            vec2 p = r2_modified(float(j + iFrame * N + SAMPLE_SKIP), vec2(0.5));  \n            vec2 d = p - uv;\n            d.x *= aspect;\n            o.rgb += smoothstep(radius2 * 2.0, radius2, dot(d, d));    \n        }\n        \n        //o.rgb *= vec3(0.6, 1.0, 0.6);\n    }\n    else //old\n    {\n        for(int j = 0; j < N; j++)\n        {\n            vec2 p = r2_canonical(float(j + iFrame * N + SAMPLE_SKIP), vec2(0.5));   \n            vec2 d = p - uv;\n            d.x *= aspect;\n            o.rgb += smoothstep(radius2 * 2.0, radius2, dot(d, d));    \n        }\n    }\n    \n    \n    o = max(o, texture(iChannel0, orig_uv));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*   \n    \n    Canonical variant (for 2D) uses plastic number as base, as such:\n    \n        xi = frac(0.5 + index / phi)\n        yi = frac(0.5 + index / (phi * phi))  \n\n    or when precalculating the values\n    \n        xi = frac(0.5 + index * 0.754877666)\n        yi = frac(0.5 + index * 0.569840290998) \n    \n    Now, since we are limited by float precision, points for high indices quickly become\n    imprecise. Apart from the integer solutions that others here invented, it would be better \n    to find other values that produce similar (or the same) patterns but are ... smaller so\n    we run out of precision later? Here's how:\n    \n              frac(0.5 + index * (1/phi))  \n    =     1 - frac(0.5 - index * (1/phi)) \n    =     1 - frac(0.5 - index * (1/phi) + index) //any integer can be added in frac / mod 1 \n    =     1 - frac(0.5 + index * (1 - 1/phi))\n    =     1 - frac(0.5 + index * 0.245122333753)\n    \n    which is just the pattern flipped, so we can omit the 1-part without any problem\n    \n    So we can substitute 1/phi and 1/(phi*phi) with 1 minus their value and end up with\n    smaller coefficients:\n    \n        xi = frac(0.5 + index * 0.245122333753)\n        yi = frac(0.5 + index * 0.4301597090025)             \n        \n        \n    Now, this is probably not a new concept, as the vogel spiral uses the same logic.\n    The golden angle isn't 1.618*2pi or 0.618*2phi, it's (1-0.618)*2pi even though all\n    of them produce the same spirals (except flipped). \n    But: smaller coefficients means that problematic float regions are reached after\n    a higher amount of samples, yielding lower quantization error overall. Without\n    sacrificing any ALU or losing any of the precious properties the sequence has.\n    \n    This scales well to higher dimensions as the roots become smaller and thus 1-rcp\n    of them also shrinks.\n\n*/\n\n\n\nvec2 r2_canonical(in float idx, in vec2 seed)\n{    \n    return fract(seed + float(idx) * vec2(0.7548776662467, 0.569840290998));\n}\n\nvec2 r2_modified(in float idx, in vec2 seed)\n{\n    return fract(seed + float(idx) * vec2(0.245122333753, 0.430159709002));\n}\n\nvec2 r2_skippy(in float idx, in vec2 seed)\n{\n     uint w = 4096u;\n     uint i = uint(idx);\n     \n     vec2 phi = vec2(0.245122333753, 0.430159709002); //original phis\n     \n     vec2 phi_skip_w = fract(seed + float(w) * phi);\n     \n     \n     return fract(fract(float(i/w) * phi_skip_w + seed) + float(i%w) * phi + seed);\n     \n     //return fract(seed + float(idx) * vec2(0.245122333753, 0.430159709002));\n}\n\n\nfloat r1_modified(in float idx, in float seed)\n{\n    //normally uses 1/1.61803398875 = 0.61803398875\n    //but just like in vogel spiral, 1-0.61803398875 = 0.38196601125 also works\n    return fract(seed + idx * 0.38196601125);    \n}\n\nvec3 r3_canonical(in float idx, in vec3 seed)\n{    \n    return fract(seed + float(idx) * vec3(0.8191725133961, 0.6710436067038, 0.5497004779019));\n}\n\nvec3 r3_modified(in float idx, in vec3 seed)\n{\n    return fract(seed + float(idx) * vec3(0.180827486604, 0.328956393296, 0.450299522098));\n}\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[806, 806, 850, 850, 1064]], "test": "untested"}
{"id": "cllGzr", "name": "Icosahedron Triangle Pattern", "author": "Shane", "description": "Attaching a common spiral pattern to the triangle cells of a subdivided icosahedron.", "tags": ["triangle", "spiral", "pattern", "icosahedron", "spherical", "polyhedron"], "likes": 90, "viewed": 1094, "published": 3, "date": "1671456596", "time_retrieved": "2024-07-30T16:12:13.503525", "image_code": "/*\n\n    Icosahedron Triangle Pattern\n    ----------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Icosahedron Triangle Pattern\n    ----------------------------\n    \n    Applying a common spiral pattern to the triangle cells of a subdivided \n    icosahedron. Attaching a suitable grid to a sphere, then rendering a \n    pattern into the cells is not what I'd call a common excercise amongst\n    the graphics crowd, but there are still plenty of examples out there. \n    There are examples on Shadertoy too, but far fewer than I would have \n    expected.\n    \n    I can understand why, since rendering to surfaces other than a plane \n    might seem a little daunting at first. However, the process is exactly \n    the same; You're simply rendering objects to a surface using familiar \n    rendering calls that involve line and shape distances, etc. For example, \n    a line between point A and B is just that, regardless of the surface \n    involved. Three line distance calls between triangle vertices will \n    result in a triangle, etc. Partitioning space into some kind of grid\n    is a little different in the sense that a plane is flat and goes on \n    forever, whereas a sphere is curved and wraps around on itself, but the \n    process still involves obtaining local cell coordinates, cell vertices, \n    etc, then using them to place objects within the cell.\n    \n    Writing spherical lines, spherical partitioning algorithms, etc, can be \n    simple or painful, but once they're done, you simply have to use them \n    however you see fit. The possibilities are endless.\n    \n    Admittedly, there's probably a little too much information in this \n    particular shader to sift through. However, if you're new to this and \n    would like to make a start, begin with rendering some line borders and \n    vertex points to the square or triangle cells of a sphere, then take \n    it from there.\n    \n    Anyway, as mentioned, this is just one of countless spherical grid \n    patterns possible. I'll post a few more in due course.   \n\n    \n\n\tRelated examples:\n\n    \n    // A really nice triangle spiral feedback example. It takes a little \n    // while to build up to the good stuff, but it's worth it. :) \n    [phreax] creation process - phreax\n    https://www.shadertoy.com/view/Dd2SWV\n    \n    // Looking at this example reminded me that I had several spiral\n    // polygon examples that I hadn't bothered finishing, so I finished\n    // one. :)\n    Nest of Polygons II - mla\n    https://www.shadertoy.com/view/cs2XWy\n    \n    // TDHooper's examples are all really popular. This one is \n    // simply, but elegantly rendered. \n    Icosahedron twist - tdhooper\n    https://www.shadertoy.com/view/Mtc3RX\n    \n    \n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n\n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 1\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n\n    p.xy *= rot2(-3.14159/12.);\n    p.xz *= rot2(-iTime/8.); \n\n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\nvec3 gVal;\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Flat plane back wall.\n    float wall = -p.z + 2.5;// - (length(p) - .5)*.1;\n    \n\n    // Perturbing the back wall with some cheap sinusoidal layers. You could leave the \n    // wall flat, but this will reflect light in a more interesting way.\n    vec3 pp = p*2. + vec3(0, 0, iTime/2.);\n    float pOffs = dot((sin(pp - cos(pp.yzx*2.2/2.4)*1.57)), vec3(.1));\n    pOffs = mix(pOffs, dot((sin(pp*2. - cos(pp.yzx*2.2/2.4*2.)*1.57)), vec3(.1)), .333);\n    wall -= pOffs;\n    \n    // Rotate the sphere.\n    vec3 qq = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(qq) - .5;\n    \n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n    \n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n} \n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI TAU*.5 // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482// (1. + sqrt(5.))/2.\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Direction vector.\nvec3 dir;\n//int sID, cID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout mat3x3 gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n    \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n/*    \n    cID = int(floor(ax/TAU*5.));\n    \n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    \n    sID = id;\n*/    \n    \n    return q;\n}\n\n \n/*\n// Sphere line distance between A and B.\nfloat sphereLineCapABDist(vec3 p, vec3 a, vec3 b, float rad){\n     \n     p = normalize(p); // Normalize p.\n     float ln = dot(p, cross(a, b))/length(a - b);\n     \n     vec3 perpA = a + cross(b - a, a);\n     vec3 perpB = b + cross(a - b, b);\n     float endA = dot(p, cross(perpA, a))/length(perpA - a);\n     float endB = dot(p, cross(perpB, b))/length(perpB - b);\n     \n     \n     return max(max(ln, endA), endB);\n      \n}\n*/\n\n// Sphere line distance.\nfloat sphereLineDist(vec3 p, vec3 a, vec3 b, float rad){\n     \n     p = normalize(p); // Normalize p. // Set radius: p /= rad; \n     return dot(p, cross(a, b))/length(a - b);\n\n}\n\n//////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .25, -1.85);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .5, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    //rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.25, 0.))));\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n    vec3 svVal = gVal;\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 12.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n             // Smoothing factor.\n            float sf = .003; \n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            mat3x3 v, vID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, vID, rad);\n    \n            v[0] = sphericalToWorld(vID[0]);//vec3(0, rad, 0);\n            v[1] = sphericalToWorld(vID[1]);\n            v[2] = sphericalToWorld(vID[2]);\n            \n            \n            \n            // Edge mid points, edge tangents and exit and entry points.\n            mat3x3 vE;\n             \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            \n            mat3x3 VNgbr2;\n            \n            float midTri = 0.;\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = 0; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    v[0] = vE[0]; v[2] = vE[1];\n                    //dir = -dir;\n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    v[0] = vE[2]; v[1] = vE[1];\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    v[1] = vE[0]; v[2] = vE[2];\n                }\n                else {\n                \n                    // Neighboring v2 point is the original point.\n                    VNgbr2 = v;\n                    \n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n                     //if(i==1){\n                    // if(sID%2==1) dir = -dir;\n                    // else dir *= vec3(1, -1, 1);\n                     //}\n                     midTri = 1.;\n                     \n                     \n                }\n               \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n                vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n                vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n                \n                \n            }\n            #endif\n            /////  \n            \n           \n            \n  \n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = v[0] + v[1] + v[2];\n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            vec3 ctr = normalize(id)*rad;\n            \n             \n            // Rendering the triangle spirals... The rushed logic needs some tidying up,\n            // but it works, so it'll do. You could almost ignore my approach and devise \n            // your own one. I've taken a brute force approach because I wanted an \n            // accumulated shadow effect, but a polar coordinate method would be faster. \n            mat3x3 pp, vv = v;\n            float per = 0.; \n            #if SCHEME == 0\n            const int N = 24; // More triangles, if there is no subdivision.\n            #else\n            const int N = 12; // Fewer triangles for smaller subdivided cells.\n            #endif\n            const float fN = float(N);\n            float lf = 1./fN;\n            \n            // Render a few layered spiraling triangles.\n            for(int j = 0; j<N; j++){//3\n                \n                \n                // The vertices. They're contracted and rotated each iteration.\n                pp[0] = mix(vv[0], vv[1], per);\n                pp[1] = mix(vv[1], vv[2], per);\n                pp[2] = mix(vv[2], vv[0], per); \n                \n                // Three line distances between vertices, which, not surprisingly,\n                // combine to form a triangle.\n                float pLn = sphereLineDist(lq, pp[0], pp[1], rad);\n                pLn = max(pLn, sphereLineDist(lq, pp[1], pp[2], rad));\n                pLn = max(pLn, sphereLineDist(lq, pp[2], pp[0], rad));\n                \n                // Triangle shade. It gets brighter each iteration, but you\n                // can do whatever you want.\n                float sh = pow(float(j)/(fN - 1.), 1.5)*.975 + .025;\n                \n                // Triangle color.\n                vec3 tCol = vec3(min(sh*2.5, 1.));\n                //vec3 tCol = (.5 + .45*cos(6.2831*sqrt(sh)/1. + vec3(0, 1, 2))); // Colors.\n                \n                // The colored moving triangle.\n                float rndJ = mod(floor(iTime*7. + hash31(ctr+.08)*(fN*3.)), fN*3. - 1.) + 1.;\n                if(j == int(rndJ)) tCol = (tCol*.5 + .5)*vec3(3, .6, .4)*2.;//vec3(.8, 1, .3);\n                \n                tCol = mix(tCol, tCol.xzy, -sn.x);\n                \n                // Darkening the central triangle.\n                if(j==N-1){\n                    tCol = vec3(.15);\n                    texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, pLn + .015));\n                }\n                \n                \n                //tCol = vec3(.35); // Debug.\n                \n                // Shadow facotr, line width and transparency.\n                #if SCHEME < 2\n                const float shF = 12.;\n                const float lw = .005;\n                const float alpha = .35;\n                #else\n                const float shF = 6.;\n                const float lw = .004;\n                const float alpha = .25;\n                #endif\n                \n                // Rendering the triangle layers.\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*shF, pLn))*alpha);\n                texCol = mix(texCol, tCol*.05, 1. - smoothstep(0., sf, pLn));\n                texCol = mix(texCol, tCol, 1. - smoothstep(0., sf, pLn + lw));\n\n                \n                //if(j==N-1) texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, pLn + .01));\n                 \n                // Edge contraction distance factor.\n                lf *= 1.125;//1.125/*(cos(iTime/1.)*.25 + 1.);\n                \n                // Set the new vertices to the adusted values.\n                vv = pp;\n                \n                // Edge contraction.\n                per = lf;\n                //per = lf*(cos(iTime/2.)*.5 + .75);\n                //per = lf*.55;\n            }\n            \n \n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z) - .012;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .007));\n            \n            // Extra global coloring.\n            texCol *= vec3(.85, 1, 1.1); // Blueish tinge.\n \n            \n        }\n        else if(objID==1){ \n        \n            //  Back wall.\n \n            \n            // Texture coordinates.\n            vec3 txP = sp;\n            txP.xy = rot2(3.14159/12.)*txP.xy + vec2(iTime/8., 0.);\n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            mat3x2 v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            vec4 p4 = getTriVerts(txP.xy, vID, v);\n            vec2 p = p4.xy;\n            vec2 id = p4.zw;\n            float tri = gTri;\n            vec2 triID = id + (vID[0] + vID[1] + vID[2])/3.;\n            \n            \n            // Smoothing factor.\n            float sf = .003*2.;\n            const float ew = .01;\n           \n            \n            // Nearest vertex ID.\n            float vert = 1e5;\n            //\n            vec2 vertID;\n            for(int i = 0; i<3; i++){\n                float vDist = length(p - v[i]);\n                if(vDist<vert){\n                    vert = vDist;\n                    vertID = id + vID[i];\n                }\n            }\n            \n   \n             \n            // Border triangles, bump highlights, etc. It was made up on the spot, and\n            // I'm pretty sure there'd be better ways to do it. 3D bump mapping would\n            // be better, but I'm keeping things simple and cheaper.\n            vec2 q = tri<.5? p*vec2(1, -1) : p;\n             \n            // Triangle.\n            float tr = getTri(q, scale*.57735);\n            \n            // Triangle shade and color.\n            float sh = pow(floor(hash21(p4.zw + .1)*11.999)/11., 1.5)*.025 + .025;\n            vec3 tCol = vec3(sh)*vec3(.9, 1, 1.1); \n            vec3 eCol = tCol;\n           \n            // Intial background triangle color.\n            texCol = vec3(0);\n            \n            // Triangle rendering.\n            #if 1\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., sf, tr + ew)));\n            #else\n            texCol = mix(texCol, eCol*1.25, (1. - smoothstep(0., sf, tr + ew)));\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, tr + .02 + ew)));\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., sf, tr + .02 + ew*2.)));\n            #endif\n             \n\n            // Vertex coloring.\n            vec3 vCol = vec3(hash21(vertID + .1)*.075 + .025);\n            vCol *= vec3(.9, 1, 1.1);\n             \n            // Blinking glowing vertices.\n            vec3 lCol2 = (vCol*.5 + .5)*vec3(3, .6, .4)/2.;//vec3(.8, 1, .3);\n            lCol2 = mix(lCol2, lCol2.xzy, -sp.x/2.);\n            float glow = smoothstep(.97, .99, sin(6.2831*hash21(vertID + .2) + iTime/4.));\n            vCol = mix(vCol, lCol2, glow);    \n            \n            // Vertex rendering.\n            float vw = .04;\n            vert -= vw;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert))*.35);\n            texCol = mix(texCol, texCol + vCol, (1. - smoothstep(0., sf*8., vert))*.05);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vCol, 1. - smoothstep(0., sf, vert + .01));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + vw - .01));\n            \n            // Adding some extra global coloring.\n            texCol *= vec3(.9, 1, 1.1)*vec3(.85, 1, 1.1);\n  \n        }\n\n      \n        //texCol *= vec3(.8, 1.2, 2.75); // More blue.\n        \n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n        \n        // Specular reflection.\n        vec3 hv = normalize(ld - rd); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        if(objID==0) ref.xz = rot2(-iTime/3./2.)*ref.xz;\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx;\n        refTx = (texCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n        float spRef = pow(max(dot(hv, sn), 0.), 8.); // Specular reflection.\n        float rf = objID == 1? .5 : 1.;\n        //\n        // Adding the specular reflection and glow for the inner light.\n        texCol += texCol*spRef*mix(refTx, refTx.zyx, rd.y*0.)*rf*4.;\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .8, .5)*spec*freS*sh*16. + vec3(.2, .4, 1)*fre*sh*0.);\n \n        // Ambient occlusion and light attenuation.\n        col *= ao*atten;\n        \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//////////////////////\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./9.;//1.333;\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n    // Rectangle scale.\n    const vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    \n    p.y = p.y + r/k; // This one has been reversed.\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n    \n    \n    \n}\n/////////////////", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 177, 248, 480]], "test": "untested"}
{"id": "cls3RN", "name": "Softpixels", "author": "hellotanjent", "description": "Tweaking the texture coordinates of a bilinear texture lookup to create upscaled pixels with soft edges.\nTry varying filter_width between 0.1 and 4.0.", "tags": ["pixelnearestbilinear"], "likes": 4, "viewed": 264, "published": 3, "date": "1671417548", "time_retrieved": "2024-07-30T16:12:14.356246", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float filter_width = sqrt(2.0);\n    const float upscale_factor = 7.37;\n    // In a real application, this constant should be precalculated\n    // and passed in as a uniform.\n    const float d = upscale_factor / filter_width;\n\n    float t1 = iTime * 0.031;\n\tvec2 uv = (fragCoord.xy / iResolution.x);\n    uv = mat2(sin(t1), cos(t1), -cos(t1), sin(t1)) * uv;\n    uv *= iResolution.x / upscale_factor;\n    \n    //----------\n\n    \n    if (fract(iTime / 4.0) > 0.5) {\n        // We reshape the fractional component of the texture coordinate\n        // so that it looks like this as it goes across a source pixel -\n        \n        //       /\n        //   ----    <-- 0.5\n        //  /\n        \n        // where the slopes of the end segments are equal to\n        // (upscale_factor / filter_width)\n        \n        vec2 uf = fract(uv) * d;\n        uf -= clamp(uf - 0.5, 0.0, d - 1.0);\n        \n        // And then we add our reshaped fractional component back to the\n        // integer component.\n        uv = floor(uv) + uf;\n    }\n\n    fragColor = texture(iChannel0,uv / iChannelResolution[0].x);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cls3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1162]], "test": "untested"}
{"id": "ctsGz4", "name": "[phreax] rainbow lounge ", "author": "phreax", "description": "Whole demo (ca. 4min)  >> Watch until the End <<\n\nSunday project.. I loved this track and thought I make small demo out of it learning more about camera & composition.\n\n", "tags": ["raymarching", "demo", "rainbow", "kifs"], "likes": 13, "viewed": 353, "published": 3, "date": "1671409912", "time_retrieved": "2024-07-30T16:12:15.195003", "image_code": "/*\n  Copyright Michael Thomas a.k.a phreax/jiagual, 2022\n  \n  I am the sole copyright owner of this Work.\n  You cannot host, display, distribute or share this Work in any form,\n  including physical and digital. You cannot use this Work in any\n  commercial or non-commercial product, website or project. You cannot\n  sell this Work and you cannot mint an NFTs of it.\n  I share this Work for educational purposes, and you can link to it,\n  through an URL, proper attribution and unmodified screenshot, as part\n  of your educational material. If these conditions are too restrictive \n  please contact me and we'll definitely work it out.\n  copyright statement borrowed from Inigo Quilez\n \n  Special thanks to: iq, evvvvil, nusan, bigwings, fabrice, flopine, yx \n  for their amazing content and learning material.\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n  Copyright Michael Thomas a.k.a phreax/jiagual, 2022\n  \n  I am the sole copyright owner of this Work.\n  You cannot host, display, distribute or share this Work in any form,\n  including physical and digital. You cannot use this Work in any\n  commercial or non-commercial product, website or project. You cannot\n  sell this Work and you cannot mint an NFTs of it.\n  I share this Work for educational purposes, and you can link to it,\n  through an URL, proper attribution and unmodified screenshot, as part\n  of your educational material. If these conditions are too restrictive \n  please contact me and we'll definitely work it out.\n  copyright statement borrowed from Inigo Quilez\n \n  Special thanks to: iq, evvvvil, nusan, bigwings, fabrice, flopine, yx \n  for their amazing content and learning material.\n*/\n\n#define PI 3.141592\n#define TAU PI*2.\n\n#define S(a, b) smoothstep(a, b, T)\n#define F(a, b, s) (S(a, a+s)-S(b, b+s))\n#define F2(a, b, s1, s2) (S(a, a+s1)-S(b, b+s2))\n#define F3(t, s1, s2) (F2(t, t, s1, s2))\n\n//#define USE_ITIME\n\nfloat tt, T;\nvec3 ro;\nvec2 beamId;\nfloat matId;\n\n\n// from \"Palettes\" by iq. https://shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getPal(float t) {\n    return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n}\n\nfloat repeat(inout float x, float n) {\n    float id = floor(n*x)/n;\n    x = fract(n*x);\n    return id;\n}\n\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 q = abs(p) - r;\n    return max(max(q.x, q.y),q.z);\n}\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n\nvec2 repeat(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat repeatSingle(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// adapted from the book of shaders\nfloat triangle(vec2 uv, float w, float blur) {   \n  int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulate the distance\n  float d = 1.-cos(floor(.5+a/r)*r-a)*length(uv);\n  return smoothstep(blur, .0, abs(d)-w)*(0.3/blur);\n}\n\n\nvoid transform(inout vec3 p) {\n    \n    float repz =8.;\n\n    float idz = repeatSingle(p.z,8.);  \n    p.xy *= rot(.25*PI*mod(idz, repz));\n}\n\nvec3 colorStripeTexture(vec3 p, vec2 matId, float off) {\n\n    matId = abs(matId);\n    int mat = int((matId.x*2.))+int(matId.y*2.);\n    \n    float dim = p.x*4.;\n    \n    if(mat % 3 == 1) dim = p.y*3.;\n    if(mat % 3 == 2) dim = p.z*.4;\n    \n    float id = repeat(dim, 4.2) + matId.y/10.;\n    vec3 col = getPal(id);\n    return col;\n}\n\n\nvec2 moda(vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*length(p);\n}\n\n\nvec3 kalei(vec3 p) {\n  float w = 1.;\n      p = abs(p) -.2;\n  for(float i=0.; i < 4.; i++) {\n        float t1 = 2.+sin(i+tt) + sin(.7*tt)*.4;\n        p.xy *= rot(.3*t1);\n        p -= 0.1 + .1*i;\n        p.y -= 0.25;\n        p = abs(p);\n    }\n    p /= w;\n    return p;\n}\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 5.));\n}\n\nvec2 foldSym(vec2 p, float N) {\n    float t = atan(p.x,-p.y);\n    t = mod(t+PI/N,2.0*PI/N)-PI/N;\n    p = length(p.xy)*vec2(cos(t),sin(t));\n    p = abs(p)-0.25;\n    p = abs(p)-0.25;\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 transformBlotter(vec3 p) {\n    p.z -= 6.;\n    p.y -= .3*S(30., 50.);\n    p.xz *= rot(T*.5);\n    \n    p.yz *= rot(.25*(T-37.5)*S(37.5, 39.));\n   \n    p *= mix(1., 10., S(30., 52.));\n    p *= mix(1., 5., S(50., 55.));\n\n    return p;\n}\n\nfloat mapBlotter(vec3 p) {\n            \n    p -= ro;\n    p = transformBlotter(p);\n\n    vec3 p1 = p;\n    p1.xy += sin(p.yx*4.5*TAU+vec2(2.5, 1.))*.04;\n    float d = box(p1, vec3(2., 2., .004));\n\n    float d2 = box(p, vec3(vec2(1.9), .2)-0.4);\n    d = smin(d, d2, .7);\n\n    float size =  mix(1., 10., S(30., 50.));\n    return d/size;\n    \n}\n\nfloat map(vec3 p) {\n    \n    vec3 bp = p;\n\n    float bl = 1e6;\n    \n    if(T < 54.) {\n      bl = mapBlotter(p);\n    }\n    if(T < 30.) {\n        matId = 1.;\n        return bl;\n    }\n\n    p.xy = foldSym(p.xy, 3.);\n    // p.xy *= rot(.5*PI);\n\n    p.y += 0.4*sin(p.z*TAU/4.+tt*TAU/3.);\n    p.xy *= (1.+abs(.1*p.x))*rot(curve(tt, 8.)*.5*PI);\n\n    transform(p);\n    p = kalei(p);\n    float blen = 2.4;\n\n    float outer = 1.45;\n    float inner = .9;\n    \n    float maskout = box(p, vec3(vec2(outer), blen));\n    float maskin = box(p, vec3(vec2(inner), blen + .3));\n   \n    beamId = repeat(p.xy, vec2(.39));\n    \n    float beam = max(box(p, vec3(vec2(.16), blen)), -box(p, vec3(vec2(.1), blen+.3)));\n    \n    \n    float frame = max(maskout, -maskin);\n    float d = max(beam, maskout);\n    d = max(d, frame);\n    \n\n    d = max(d, - (length(bp-ro)-0.3));  // collision avoidance\n    \n    matId = d < bl ? 0. : 1.; \n    d = min(d*.6, bl);\n    return d*.6;\n   \n}\n\nfloat getRT(float t) {\n    return (t-48.)*.25;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvoid camz(inout vec3 p ) {\n    p.z += 4.*tt;\n}\n\nvoid cam(inout vec3 ro, inout vec3 rd) {\n    bool sw = (T > 67.1 && T < 80.) || (T > 92.9 && T < 105.6) || T > 172.8 && T < 179.2\n               || T > 198.5 && T < 204.8;\n    if(sw) {\n        ro.y += 2.;\n        rd.zy *= rot(.3);\n        ro.x += .8*sin(1.*tt);\n        rd.xz *= rot(PI*sin(-.5*tt-.8));\n    }\n    if(T > 119. && T < 160.) {\n        rd.yz *= rot(.31*(tt-getRT(119.)));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    //uv *= rot(.5*PI);\n    T = iChannelTime[3];\n    #ifdef USE_ITIME\n    T = iTime;\n    #endif\n    \n    if(iResolution.y <= 300.) T = (iTime+160.);;  // preview\n    \n    tt = (T-48.)*.25;\n    \n    ro = vec3(0.,-1.5, 0.);\n    vec3 rd = normalize(vec3(uv, .5)),\n         lp = vec3(0., 4., -4.),\n         lp2 = vec3(0., -4., 3.);\n    \n    vec4 tex = texture(iChannel1, fragCoord/iResolution.xy);\n    if (tex.a != iResolution.x) tex = vec4(0); // reset buffer on resize\n    \n    camz(ro);\n    camz(lp);\n    camz(lp2);\n    cam(ro, rd);\n\n    float i, t, d = 0.1;\n\n    vec3 p = ro;\n    \n    vec2 beamIdTemp;\n    float matIdTemp;\n    \n    for(i=0.; i<400.; i++) {\n        d = map(p);\n        beamIdTemp = beamId; // save id\n        matIdTemp = matId;\n        \n        if(d < 0.001 || t >100.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    vec2 e = vec2(0.0035, -0.0035);\n    \n    vec3 fo, co;\n    co = fo = mix(vec3(0.722,1.000,0.976), vec3(1.), uv.y+.5);\n    \n    if(d < 0.001) {\n        vec3 al;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        al = colorStripeTexture(p, beamIdTemp,  tt*.6)*1.2;\n        \n        vec3 l = normalize(lp-p);\n        vec3 l2 = normalize(lp2-p);\n        float dif = max(dot(n, l), .0);\n        float dif2 = max(dot(n, l2), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4; \n        float ao = calcAO(p, n);\n \n        if(matIdTemp == 0.) {  // lounge\n            co =  .7*al*(.3+.8*spe+(.9*dif+1.5*sss));\n            co += al*(.7*vec3(1.000,0.886,0.780)*dif2);\n\n            rd = reflect(rd, n);\n\n\n            vec3 refl = texture(iChannel0, rd, 3.).rgb;\n\n            refl *= mix(vec3(1), getPal(n.x*n.y*20.), .4); // reflect rainbows too\n            co = mix(co, refl, .4);\n\n            float aof = S(137., 140.);\n            ao = mix(ao, 1.-ao, aof); // inverse AO for brilliance effect\n            co = mix(co, co*ao, mix(.6, .8, aof));\n\n            co = mix(co, fo, 1.-exp(-.0005*t*t));\n            co *= 1.3;\n                 \n         } else { // blotters\n             vec3 bp = p;\n             p -= ro;\n                          \n             p = transformBlotter(p);\n             vec3 c1 = mix(vec3(1), colorStripeTexture(p*.12-.4, vec2(0), 0.), .98);\n             c1 = mix(c1, getPal(tt), .4);\n       \n             vec3 c2 = clamp(1.-c1, vec3(0), vec3(1));\n        \n             // draw sun \n             vec2 tuv = p.xy;\n             \n             tuv.x -= .1;\n             vec2 tuv1 = tuv;\n   \n             tuv1 = moda(tuv1, 16.);\n             tuv1 *= vec2(2., 5.)*.7;        \n             tuv1 += sin(tuv1.yx*7.+tt*5.)*.08;\n             tuv1 *= rot(PI*.17);             \n             float tr = triangle(tuv1, .05, 0.1);\n             float ci = 1.-smoothstep(0. ,.02, abs(length(tuv)-.7)-.04);\n       \n             float isfront = smoothstep(.6, 1., .5+.5*cos(.5*T));\n             \n             co = mix(c1, c2, (tr*.5+ci*1.5)*isfront);\n             co = mix(vec3(1), co, .7);\n             co *= .7*(.2*spe+(.8*dif+.8*sss));\n             co = mix(co, co*(texture(iChannel2, (p.xy*.5))).x+.3, .5);\n         }    \n    }\n  \n    co = pow(co, vec3(1.2));\n \n    float feedback = 1.-S(23., 30.)+S(54., 56.)-S(130., 138.)+S(161., 164.)-F2(68., 76.7, 3., 3.)-F(94., 99., 3.)-S(210., 216.);\n\n    co = clamp(co, vec3(0), vec3(1));\n    co = mix(co, tex.rgb, .98*(1.-feedback));\n    \n    co = mix(co, fo, S(223., 233.));\n\n    // Output to screen\n    fragColor = vec4(co, iResolution.x);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31306, "src": "https://soundcloud.com/erichiltonmusic/more-beautiful-things?si=c56b5ee096cc4889b76693d80c111372&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGz4.jpg", "access": "api", "license": "proprietary-license", "functions": [[815, 815, 872, 872, 1000]], "test": "untested"}
{"id": "ctl3z4", "name": "Yet Another Audio Reactive Scene", "author": "kishimisu", "description": "The audio is very loud at the beginning, I apologize if it scared you!", "tags": ["raymarching", "music", "animation", "visualizer", "lights", "live", "neon", "song"], "likes": 18, "viewed": 585, "published": 3, "date": "1671403214", "time_retrieved": "2024-07-30T16:12:16.015808", "image_code": "/* @kishimisu - 2022 \n   Wait for the drop!\n\n   Another attempt at isolating frequencies in order to\n   animate parts of the scene separately, especially the\n   lighting & colors.\n   \n   Here the scene is animated using 5 distinct (hand-picked)\n   frequencies as well as the current audio volume.\n   \n   Restart the shader after the audio has loaded for a better experience.\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n*/\n\n#define st(t1, t2, v1, v2) mix(v1, v2, smoothstep(t1, t2, iTime))\n#define light(d, att) 1. / (1.+pow(abs(d*att), 1.3))\n\n// Hand-picked frequencies\n#define fBeat  1.215\n#define fBeat2 -.8\n#define fBass  -.615\n#define fHigh  2.26\n#define fBall  -1.\n\n/* Audio-related functions */\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\n\nfloat logisticAmp(float amp){\n   const float c = 0.8, a = 20.;  \n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\n}\nfloat getPitch(float smin ,float smax, float freq, float octave){\n   freq = pow(2., freq)   * 261.;\n   freq = pow(2., octave) * freq / 12000.;\n   return smoothstep(smin, smax, logisticAmp(getLevel(freq)));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\n    return avg / samples;\n}\n/* ----------------------- */\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// We don't need to query the audio texture at each step (it's expensive), \n// so they are calculated once and passed as parameters.\nfloat map(vec3 p, inout vec3 lgt, float v, float fbeat, float fbeat2, float fbass, float fhigh, float fball) {    \n    // ball\n    float d = length(p - vec3(0,0,8.+2.*sin(iTime))) - .5-v*.8;  \n    lgt += mix(vec3(.1,.8,.6), vec3(.2,.6,1.), fbeat2)\n           * light(d, 10.) * fball * smoothstep(19., 20., iTime);\n    \n    // pillars\n    vec3 q = p;\n    vec3 id = floor(p);\n    q.xz = fract(p.xz)-.5;\n    q.y = abs(q.y);\n    float h = .3*sin(id.x+id.z+iTime) + max(0., (length(id)-1.))*.05;\n    float d2 = sdBox(q - vec3(0,3,0), vec3(.1, 1.5 + v + h, .1));\n    d = min(d, d2);\n       \n    // front\n    d2 = sdBox(p - vec3(0,0,22), vec3(18., 18., 10));\n    d = min(d, d2);\n    lgt += vec3(2.,.1,.0) * light(d2, 20.) * fbeat;\n    \n    // edges\n    float g = -sdBox(p, vec3(14., 8., 14));\n    lgt += mix(vec3(.55,.55,1.), vec3(.2,.8,.8), fbass) * light(g, 10.) * (fbass+fhigh*2.5);\n    d = min(d,g);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col;\n    \n    if (abs(uv.x)>.9 || abs(uv.y)>.9) {\n        fragColor = vec4(0.);\n        return; \n    }\n    \n    float vol    = getVol(8.),\n          fbeat  = getPitch(st(17., 20., .05, 0.), st(17., 20., .8, .1), fBeat, 1.),\n          fbeat2 = getPitch(0., .8, fBeat2, 1.),\n          fbass  = getPitch(0., .8, fBass, 1.),\n          fhigh  = getPitch(0., .8, fHigh, 1.),\n          fball  = getPitch(0., .8, fBall, 1.);\n     \n    if (iChannelTime[0] <= 0.) fbeat  = fhigh = fball = .5;\n\n    for (float i = 0., t = 0.; i < 50.; i++) {\n        vec3 p = t*normalize(vec3(uv, 1.));        \n        t += map(p, col, vol, fbeat, fbeat2, fbass, fhigh, fball);\n    }\n\n    fragColor = vec4(col,1.0);   \n}", "image_inputs": [{"id": 31304, "src": "https://soundcloud.com/the-williver/the-williver-the-devourer", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctl3z4.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[951, 951, 980, 980, 1102], [1103, 1103, 1168, 1168, 1310], [1311, 1311, 1340, 1340, 1457], [1489, 1489, 1520, 1520, 1607], [1609, 1742, 1852, 1868, 2659], [2661, 2661, 2718, 2718, 3479]], "test": "untested"}
{"id": "DtsGR4", "name": "Greyscale with luminance balance", "author": "Rutvik_Tak", "description": "Shader which applies greyscale filter to image while balancing luminance.\nRef: https://en.wikipedia.org/wiki/Grayscale\n", "tags": ["greyscale"], "likes": 2, "viewed": 257, "published": 3, "date": "1671396932", "time_retrieved": "2024-07-30T16:12:16.793728", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 imagePixel = texture(iChannel0,uv);\n    // Output to screen\n    float luminance =0.2126*imagePixel.r+0.7152*imagePixel.g+0.0722*imagePixel.b;\n\n    fragColor = vec4(luminance);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 289]], "test": "untested"}
{"id": "fs3SzN", "name": "Audio Reactive Glitch Fire", "author": "MacroMachines", "description": "the self-advection is done purely rotational, therefore no need for divergence-free-step.\ntry changing RotNum.\npress i-key to init image (e.g. in fullscreen)", "tags": ["simulation", "fluid", "cfd", "fluiddynamics"], "likes": 6, "viewed": 303, "published": 3, "date": "1671389756", "time_retrieved": "2024-07-30T16:12:17.626502", "image_code": "// Fork of \"single pass CFD\" by flockaroo. https://shadertoy.com/view/MdKXRy\n// 2018-04-18 11:55:03\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n    fragColor *= fragColor;\n    fragColor.b = fragColor.g*0.5;\n    \n    fragColor.g *= fragColor.r*0.2;\n    //fragColor += texture(iChannel1, fragColor.rg).rrrr;\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2016\n// Modified with audio reactivity by www.axiom-crux.net\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 6 //cos(iTime*4.0)\n#define angRnd 0.01 //*cos(iTime*8.0) //*pow(fract(iTime*2.0)*2.0,4.50)\n#define posRnd -0.0\n#define intensity -10.0 //sin(iTime*0.5)+0.50)*2.50\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 1.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    //return getRand4(uv.y+uv.x*1234.567)-vec4(0.5);\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n        float fft = texture(iChannel2,fract(uv*2.1002)*2.51).x-0.125*10.;\n    float ang2 = angRnd*randS(uv).x*ang / fft;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        p2/= fft;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        v*= 4.5+fft*fft*fft;\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p*0.95;\n    } //while(RotNum > 0.0);\n    rot/=float(RotNum);\n    return rot+fft*.25;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / Res.xy;\n    fragColor = texture(iChannel2,uv);\n}\n\n\n#define INIT iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord.xy / Res.xy;\n    vec2 scr = uv*2.0-vec2(1.0);\n    float sc = 1.0/max(Res.x,Res.y);\n    vec2 v   = vec2(0);\n    vec2 uuvv = vec2(length(uv-0.5),length(uv-0.50));\n    vec2 puv = atan(uv-0.5,uuvv);//uuvv);//,uv+0.5);\n    //puv *= cos(uv*3.1415*2.);\n    //puv *= 0.0001;\n    vec4 fft = texture(iChannel2,(puv*vec2(0.0021,0.0)))*0.091253;\n    vec4 fft2= texture(iChannel2,uuvv*0.1)*0.051;\n    vec4 fft4= fft2+fft*40.0;\n    vec4 fft3= texture(iChannel2,puv+uv*vec2(0.25,2.0))*6.-1.05;\n    float fft33 = step(fft3.r,0.75);\n    \n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.27 ) break;\n       // if ( fft4.r > 0.21) break;\n        \n        float ang2 = angRnd * ang * randS(uv).y * fft3.r*0.15;\n        \n        vec2 p = vec2(cos(ang2),sin(ang2));\n        \n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2 = p*sc;\n            float rot = getRot(uv+p2, sc-0.51);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v += p2.yx * rot * vec2(-1,1.1); //maybe faster than above\n            p = m*p;\n        }\n        \n      \tsc *= 2.0 ;\n        sc /= fft4.r*0.25051;\n        sc *= 2.01;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor = texture(iChannel0,fract(uv+(v*2.0-4.)/Res.x));\n    \n    fragColor = mix(fragColor,texture(iChannel2, fragColor.xy).rrrr*2.0-0.5009,0.02);\n    \n    \n    if(uv.y < 0.03 || uv.y > 0.99){ fragColor.rgb += fft33*0.975; fragColor.gb *= fft33*0.75;\n    }\n    //if(uv.y > 0.29 && uv.y < 0.71){ \n    //fragColor.gb += fft33*0.15; fragColor.gb *= fft33*0.15;\n   // }\n   fragColor += fft2.rrrr*0.01;\n    \n    \n   // scr += fft.rr;\n   \n     // add a little \"motor\" in the center\n    fragColor.xy += (0.02*intensity*scr.xy / (dot(scr,scr)/0.15+0.3));\n\n   // fragColor.xy += 0.01*fft.rg-0.00015;\n    \n    if(iFrame<=4 || INIT<0.5) fragColor = uv.rgrg;//init(fragColor,fragCoord);\n    \n    //fragColor /= fft.rrrr*1.1;//uuvv.rgr;\n    fragColor.rg *= 0.959+uv*0.051;\n    //fragColor += 1.0-texture(iChannel2,uv/2.);//-uv.rgrg*-0.01;\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fft = texture(iChannel0,uv);//vec4(0.0,0.0,1.0,1.0);\n    vec4 old = texture(iChannel1,uv);\n    fragColor = mix(fft,old,0.950);\n    fragColor = max(fragColor,fft)*0.975;\n    \n}", "buffer_b_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3SzN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[864, 864, 921, 921, 1163]], "test": "untested"}
{"id": "dlX3RN", "name": "ChatGPT Octahedron SDF", "author": "alaula", "description": "It's doing something but I'm not sure what\n\nThis is a fork of iq's octahedron distance shader.", "tags": ["3d", "distancefield", "sdf", "distance", "octahedron"], "likes": 3, "viewed": 283, "published": 3, "date": "1671383087", "time_retrieved": "2024-07-30T16:12:18.511137", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// EXACT distance to an octahedron. Most of the distance functions you'll find\n// out there are not actually euclidan distances, but just approimxations that\n// act as bounds. This implementation, while more involved, returns the true\n// distance. This allows to do euclidean operations on the shape, such as \n// rounding (see https://iquilezles.org/articles/distfunctions)\n// while other implementations don't. Unfortunately the maths require us to do\n// one square root sometimes to get the exact distance to the octahedron.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    \n#if 0\n    // filbs111's version (see comments)\n    vec3 o = min(r, 0.0);\n    o = max(r*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n#elseif 1\n    // my original version\n\tvec3 q;\n         if( r.x < 0.0 ) q = p.xyz;\n    else if( r.y < 0.0 ) q = p.yzx;\n    else if( r.z < 0.0 ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k));\n#else\n    // ChatGPT version\n    // Compute the absolute value of the point coordinates\n    vec3 q = abs(p);\n\n    // Compute the distance from the point to the closest vertex\n    float d = min(max(q.x, max(q.y, q.z)), 0.0) + length(max(q - s, 0.0));\n\n    // Return the signed distance\n    return dot(vec3(1.0),sign(p) * d);\n#endif    \n}\n\n\nfloat map( in vec3 pos )\n{\n    float rad = 0.1*(0.5+0.5*sin(iTime*2.0));\n    return sdOctahedron(pos,0.5-rad) - rad;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 3.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlX3RN.jpg", "access": "api", "license": "mit", "functions": [[1733, 1733, 1770, 1770, 2624], [2627, 2627, 2653, 2653, 2745], [2747, 2793, 2825, 2825, 3064]], "test": "ok"}
{"id": "DtX3zN", "name": "Temari", "author": "yasuo", "description": "https://en.wikipedia.org/wiki/Temari_(toy)", "tags": ["cineshader", "temari"], "likes": 18, "viewed": 2371, "published": 3, "date": "1671362315", "time_retrieved": "2024-07-30T16:12:19.310001", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(kw*antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n\nvec3 RotAnim(vec3 p){\n    p.xz*=Rot(radians(5.*iTime));\n    p.xy*=Rot(radians(5.*iTime));\n    return p;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p = RotAnim(p);\n    float d = length(p)-0.5;\n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(1.0,1.0,0.95)*skyDiff*occ;\n    diffCol += col*vec3(1.)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\nfloat smallTex(vec2 p){\n    float d = abs(B(p,vec2(0.01)))-0.001;\n    return d;\n}\n\nvec3 topBottomTex(vec3 p, float kw){\n    vec2 uv = p.xz;\n    uv*=1.2;\n    vec2 prevUV2 = uv;\n    uv*=Rot(radians(iTime*-8.));\n    vec2 prevUV = uv;\n    \n    \n    vec3 col = vec3(0.);\n    \n    uv = DF(uv,3.0);\n    uv -= vec2(0.18);\n    uv*=Rot(radians(45.));\n    uv.x*=3.;\n    uv*=Rot(radians(45.));\n    \n    float d = abs(B(uv,vec2(0.1)))-0.005;\n    float d2 = abs(B(uv,vec2(0.05)))-0.005;\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.));\n    \n    uv = prevUV;\n    uv*=Rot(radians(15.5));\n    uv = DF(uv,3.0);\n    uv -= vec2(0.28);\n    uv*=Rot(radians(45.));\n    uv.x*=3.;\n    uv*=Rot(radians(45.));\n    d = abs(B(uv,vec2(0.1)))-0.005;\n    d2 = abs(B(uv,vec2(0.05)))-0.005;\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.));\n\n    uv = prevUV;\n    uv = DF(uv,3.0);\n    uv -= vec2(0.35);\n    uv*=Rot(radians(45.));\n    uv.x*=0.8;\n    uv*=Rot(radians(45.));\n    d = abs(B(uv,vec2(0.05)))-0.001;\n    d2 = abs(B(uv,vec2(0.02)))-0.001;\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.));\n\n    uv = prevUV;\n    uv*=Rot(radians(21.));\n    uv = DF(uv,3.0);\n    uv -= vec2(0.385);\n    d = smallTex(uv);\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.));\n\n    uv = prevUV;\n    uv*=Rot(radians(9.));\n    uv = DF(uv,3.0);\n    uv -= vec2(0.385);\n    d = smallTex(uv);\n    d = min(d,d2);\n    col = mix(col,vec3(1.),S(d,0.));\n    \n    uv = prevUV2;\n    uv*=Rot(radians(10.*iTime));\n    uv = DF(uv,2.0);\n    uv -= vec2(0.04);\n    d = abs(B(uv,vec2(0.025)))-0.002;\n    col = mix(col,vec3(1.),S(d,0.));    \n    \n    return col;\n}\n\nvec3 centerTex(vec3 p, float kw){\n    vec2 uv = vec2(1.572*atan(p.x,p.z)/6.2832,p.y/3.);\n    vec2 prevUV = uv;\n    float size = 2.;\n    uv*=size;\n    \n    uv.y+=sin(uv.x*20.)*0.05;\n    float d = abs(uv.y)-0.001;\n    uv = prevUV;\n    uv*=size;\n    uv.x+=0.16;\n    uv.y+=sin(uv.x*20.)*0.05;\n    float d2 = abs(uv.y)-0.001;\n    d = min(d,d2);\n    \n    uv = prevUV;\n    uv*=5.;\n    uv.y*=1.2;\n    uv.x = mod(uv.x,0.392)-0.191;\n    uv*=Rot(radians(sin(iTime*2.)*100.));\n    d2 = abs(length(uv)-0.06)-0.005;\n    d2 = max(-(abs(uv.x)-0.03),d2);\n    d = min(d,d2);\n    \n    uv = prevUV;\n    uv*=5.;\n    uv.y*=1.2;\n    uv.x = mod(uv.x,0.392)-0.191;\n    uv*=Rot(radians(20.*iTime));\n    uv = DF(uv,2.0);\n    uv -= vec2(0.08);\n    uv*=Rot(radians(45.));\n    d2 = abs(Tri(uv,vec2(0.026),radians(45.)))-0.003;\n    d = min(d,d2);\n    \n    uv = prevUV;\n    uv*=5.;\n    uv.y*=1.2;\n    uv.x = mod(uv.x,0.392)-0.191;\n    d2 = abs(length(uv)-0.035)-0.003;\n    d = min(d,d2);    \n    \n    uv = prevUV;\n    uv*=5.;\n    uv.y*=1.2;\n    uv.x+=0.2;\n    uv.x = mod(uv.x,0.393)-0.1965;\n    uv.y = abs(uv.y)-0.15;\n    d2 = abs(length(uv)-0.035)-0.003;\n    d = min(d,d2);    \n    \n    uv = prevUV;\n    uv*=5.;\n    uv.y*=1.2;\n    uv.x = mod(uv.x,0.392)-0.191;\n    uv.y = abs(uv.y)-0.32;\n    d2 = Tri(uv,vec2(0.12),radians(45.));\n    float d3 =Tri(uv-vec2(0.0,-0.06),vec2(0.12),radians(45.));\n    d2 = max(-d3,d2);\n    d = min(d,abs(d2)-0.003);        \n    \n    \n    uv = prevUV;\n    uv*=5.;\n    uv.y*=1.2;\n    uv.x+=0.2;\n    uv.x = mod(uv.x,0.393)-0.1965;\n    uv.y = abs(uv.y)-0.25;\n    uv.y*=-1.;\n    d2 = abs(Tri(uv,vec2(0.035),radians(45.)))-0.003;\n    d = min(d,d2);        \n    \n    return mix(vec3(0.0),vec3(1.8),S(d,0.0));\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col, float w){\n    col = diffuseMaterial(n,rd,p,vec3(0.01));\n    p = RotAnim(p);\n    col += centerTex(p,w);\n    col += topBottomTex(p,w);\n    \n    return col;\n}\n\nfloat bgItem1(vec2 p){\n    p*=Rot(radians(20.*iTime));\n    vec2 prevP = p;\n    p = DF(p,1.25);\n    p -= vec2(0.04);\n    float d = abs(length(p)-0.055)-0.002;\n    p = prevP;\n    d = max(-(length(p)-0.02),d);\n    p = DF(p,1.25);\n    p -= vec2(0.027);\n    float d2 = abs(length(p)-0.011)-0.001;\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(length(p)-0.015)-0.001;\n    d = min(d,d2);\n    return d;\n}\n\nfloat bgItem2(vec2 p){\n    p*=Rot(radians(-20.*iTime));\n    vec2 prevP = p;\n    p = DF(p,3.);\n    p -= vec2(0.04);\n    p*=Rot(radians(45.));\n    float d = abs(SimpleVesicaDistance(p,0.095,0.083))-0.001;\n    p = prevP;\n    d = max(-(length(p)-0.02),d);\n    float d2 = abs(length(p)-0.02)-0.001;\n    d = min(d,d2);\n    return d;\n}\n\nfloat background(vec2 p){\n    p*=1.5;\n    p.y-=iTime*0.1;\n    vec2 prevP = p;\n    p.x-=iTime*0.1;\n    p.x = mod(p.x,0.3)-0.15;\n    p.y = mod(p.y,0.5)-0.25;\n    float d = bgItem1(p);\n    \n    p = prevP;\n    p.x+=iTime*0.1;\n    p.x+=0.45;\n    p.y+=0.25;\n    p.x = mod(p.x,0.3)-0.15;\n    p.y = mod(p.y,0.5)-0.25;\n    \n    float d2 = bgItem2(p);\n    \n    return min(d,d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.35);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(iTime*10.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col,0.5/abs(dot(rd,p)) );\n    } else {\n        float d = background(uv);\n        float kw = 1.0;\n        col = mix(col,vec3(0.3),S(d,0.));\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.4545) );    \n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtX3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[543, 543, 564, 564, 648], [650, 650, 672, 672, 765], [767, 767, 825, 825, 1092], [1094, 1094, 1118, 1118, 1319], [1321, 1321, 1363, 1363, 1558], [1560, 1601, 1650, 1650, 1944], [1946, 1946, 2003, 2003, 2538], [2540, 2540, 2594, 2594, 2652], [2654, 2654, 2677, 2677, 2735], [2737, 2737, 2773, 2773, 4268], [4270, 4270, 4303, 4303, 5971], [5973, 5973, 6041, 6041, 6187], [6189, 6189, 6211, 6211, 6586], [6588, 6588, 6610, 6610, 6916], [6918, 6918, 6943, 6943, 7288], [7290, 7290, 7347, 7347, 8250]], "test": "untested"}
{"id": "mllGzH", "name": "Wedge - intersection", "author": "iq", "description": "Intersection of a ray and a wedge.", "tags": ["3d", "raycasting", "intersection", "wedge"], "likes": 31, "viewed": 1172, "published": 3, "date": "1671339873", "time_retrieved": "2024-07-30T16:12:20.165713", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersection of a ray and a wedge.\n//\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and https://iquilezles.org/articles/intersectors\n\n\n// takes:\n//  ro,rd = ray origin and direction\n//  s     = wedge length, height and width\n// returns:\n//  .x    = distance to intersection\n//  .yzw  = normal at intersection point\nvec4 iWedge( in vec3 ro, in vec3 rd, in vec3 s )\n{\n    // intersect box\n    vec3  m  = 1.0/rd;\n    vec3  z  = vec3(rd.x>=0.0?1.0:-1.0, rd.y>=0.0?1.0:-1.0, rd.z>=0.0?1.0:-1.0);\n    vec3  k  = s*z;\n    vec3  t1 = (-ro - k)*m;\n    vec3  t2 = (-ro + k)*m;\n    float tn = max(max(t1.x, t1.y), t1.z);\n    float tf = min(min(t2.x, t2.y), t2.z);\n    if( tn>tf ) return vec4(-1.0);\n\n    // boolean with plane\n    float k1 = s.y*ro.x - s.x*ro.y;\n    float k2 = s.x*rd.y - s.y*rd.x;\n    float tp = k1/k2;\n\n    // enable this ONLY if the ray origin can be inside the wedge\n    /*\n    if( tn<0.0 )\n    {\n        if( tp>0.0 && tp<tf ) return vec4(tp,normalize(vec3(-s.y,s.x,0.0))); // plane\n        if( k1<0.0 )          return vec4(tf,step(t2,vec3(tf))*z); // box\n        return vec4(-1.0);\n    }\n    */\n\n    if( k1>tn*k2 )       return vec4(tn,-step(tn,t1)*z); // box\n    if( tp>tn && tp<tf ) return vec4(tp,normalize(vec3(-s.y,s.x,0.0))); // plane\n    return vec4(-1.0);\n}\n\nvec3 pattern( in vec2 uv )\n{\n    return vec3(0.6 + 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)))\n           *smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.2*iTime;\n\tvec3 ro = vec3( 1.0*sin(an), 0.4*sin(1.6*an), 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, 0.01, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // wedge\n    const vec3 siz = vec3(0.5,0.2,0.4);\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // ray direction\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // background\n\t    vec3 col = vec3(0.08+0.02*rd.y)*(1.0-0.3*length(p));\n\n        // wedge\n        vec4 tnor = iWedge( ro, rd, siz );\n        if( tnor.x>0.0 )\n        {\n            float t = tnor.x;\n            vec3  pos = ro + t*rd;\n            vec3  nor = tnor.yzw;\n\n            // texture\n            vec3 mor = abs(nor);\n            vec2 uv = (mor.x>mor.y && mor.x>mor.z) ? pos.yz : \n                      (mor.y>mor.z)                ? pos.zx : \n                                                     pos.xy;\n            col = pattern( 47.0*uv );\n\n            // lighting\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.6 + 0.4*nor.y, 0.0, 1.0 );\n            col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n        }\n\n        // gamma\n        col = sqrt( col );\n\t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,17,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllGzH.jpg", "access": "api", "license": "mit", "functions": [[1254, 1434, 1484, 1505, 2395], [2397, 2397, 2425, 2425, 2584]], "test": "ok"}
{"id": "mts3RH", "name": "optimised dodecahdron sdf", "author": "ENDESGA", "description": "HUGE THANK YOU TO JT: https://www.shadertoy.com/view/ctX3zr , and MLA: https://www.shadertoy.com/view/DlfGR8\n\ncompressed the line function into the mesh, and optimised out the variables. more suggestions/corrections welcome!", "tags": ["sdf", "wireframe", "dodecahedron", "debugging"], "likes": 14, "viewed": 277, "published": 3, "date": "1671330672", "time_retrieved": "2024-07-30T16:12:21.030401", "image_code": "// https://www.shadertoy.com/view/ctX3zr debugging dodecahedron wireframe\n// using https://www.shadertoy.com/view/DdX3z4 euclidean distance sdf debugger\n\n// tags: debugging, dodecahedron, wireframe\n\n// MIT License, as in https://www.shadertoy.com/terms\n\n/*\n\nCopyright (c) 2022 Jakob Thomsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#define VERIFY_INTERIOR /* thanks to spalmer - detects broken SDFs (can cause more false alarms) */\n#define VERIFY_EXTERIOR /* thanks to spalmer - detects broken SDFs (can cause more false alarms) */\n// (See e.g. https://www.shadertoy.com/view/ddXGDr verify SDF error detection for test on deliberately incorrect SDF)\n// #define VERIFY_GRADIENT_CONTINUITY_ALONG /* WARNING: detects change of direction along gradients but causes false alarms e.g. outwards from box vertices */\n#define VERIFY_GRADIENT_CONTINUITY_SIDEWAYS /* WARNING: detects change of direction in \"parallel\" gradients but causes false alarms where gradients curve (e.g. towards sphere center) or at reflections/symmetries */\n\n#define AA 1\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n\n#define pi 3.1415926\n\n#define PHI ((1.0 + sqrt(5.0))/2.0)\n\nfloat slice_z()\n{\n    //return cos(iTime*0.5)*0.4-0.4; // TWEAK SLICE-PLANE HERE\n    return cos(iTime)*PHI; // TWEAK SLICE-PLANE HERE\n}\n\nfloat dodecahedron_mesh(vec3 p)\n{\n    float h = PHI-1.0;\n    p = abs(p);\n    p = (p.x > p.z && p.x > p.y) ? p.yzx : ((p.y > p.z && p.y > p.x) ? p.zxy : p);\n    float d = 1e8;\n    \n    vec3 a = vec3(0.,-h,1.0+h);\n    vec3 b = vec3(1.,1.,1.);\n    \n    vec3 d1 = vec3(0.,h+h,0.);\n    vec3 d2 = vec3(-1.,h-1.,h);\n    float dd2 = dot(d2, d2);\n    \n    d = min(min(min(d,\n        distance(p.xyz, a + clamp(dot(p.xyz - a, d1) / dot(d1, d1),0.,1.) * d1)),\n        distance(p.xyz, b + clamp(dot(p.xyz - b, d2) / dd2,0.,1.) * d2)),\n        distance(p.yzx, b + clamp(dot(p.yzx - b, d2) / dd2,0.,1.) * d2));\n    return d;\n}\n\nfloat map(vec3 p) // PLACE SDF TO DEBUG HERE\n{\n    return dodecahedron_mesh(p) - .1;\n}\n\nvec3 gradient(vec3 p) // NOT normalized so we can use it's length to detect errors in the SDF.\n{\n    vec2 h = vec2(EPSILON,0);\n    return (vec3(map(p+h.xyy) - map(p-h.xyy),\n                 map(p+h.yxy) - map(p-h.yxy),\n                 map(p+h.yyx) - map(p-h.yyx)))/EPSILON/2.0;\n}\n\nfloat trace(vec3 ro, vec3 rd, float t0, float t1)\n{\n    for(float t = t0; t < t1;)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return t1;\n}\n\nvec3 hash33(vec3 p3) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 trace_slice(vec3 ro, vec3 rd)\n{\n    vec3 planecolor = vec3(0);\n    // z = ro.z+d*rd.z\n    // z-ro.z = d*rd.z\n    // (z-ro.z)/rd.z = d\n    float dist = (slice_z()-ro.z)/rd.z;\n    if(dist > 0.0)\n    {\n        vec3 dst = ro + rd * dist;\n        float d = map(dst);\n        float n = length(gradient(dst));\n\n        d /= 5.0; // SCALE SDF VISUALIZATION\n\n        // iq's sdf visualization colors\n        planecolor = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n        planecolor *= 1.0 - exp(-24.0 * abs(d));\n        planecolor *= 0.8 + 0.2 * cos(240.0*d);\n        planecolor = mix(planecolor, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n\n        planecolor = mix(planecolor, vec3(0,1,0), smoothstep(1.0,1.0-EPSILON, n)); // gradient too small? GREEN\n        planecolor = mix(planecolor, vec3(1,0,0), smoothstep(1.0,1.0+EPSILON, n)); // gradient too large? RED\n        //planecolor = mix(planecolor, vec3(0,0,1), smoothstep(0.0+EPSILON,0.0, n)); // gradient zero? BLUE\n\n        // The error detection is basically, quoting spalmer,\n        // \"one iteration of snap-point-to-(nearest-)surface algorithm\".\n        // Jump the distance given by the SDF at the current position\n        // along the gradient given by the SDF at the current position\n        // (direction to the nearest surface) and evaluate the SDF there.\n        // Because the SDF is supposed to describe the distance to the surface,\n        // the result should be (close to) zero.\n        //float error = map(dst - gradient(dst) * map(dst)); // SDF error detection thanks to spalmer!\n        float distance_towards_nearest_surface = map(dst);\n        vec3 direction_towards_nearest_surface = gradient(dst);\n        float error = map(dst - direction_towards_nearest_surface * distance_towards_nearest_surface);\n#ifdef VERIFY_INTERIOR\n        planecolor += smoothstep(0.0, sqrt(EPSILON),-error) * (cos(iTime*2.0*pi)*0.5+0.5); // SDF interior otherwise broken? WHITE, BLINKING (can cause false alarms)\n#endif\n#ifdef VERIFY_EXTERIOR\n        planecolor += smoothstep(0.0, sqrt(EPSILON),+error) * (cos(iTime*2.0*pi)*0.5+0.5); // SDF exterior otherwise broken? WHITE, BLINKING (can cause false alarms)\n#endif\n        //planecolor += smoothstep(0.0,sqrt(EPSILON), abs(error)) * (cos(iTime*2.0*pi)*0.5+0.5); // SDF otherwise broken? WHITE, BLINKING\n#ifdef VERIFY_GRADIENT_CONTINUITY_ALONG\n        vec3 cross_surface_direction = gradient(dst - direction_towards_nearest_surface * (distance_towards_nearest_surface + sign(distance_towards_nearest_surface) * EPSILON));\n        float dir_error = dot(gradient(dst), cross_surface_direction);\n        planecolor += smoothstep(0.0,sqrt(EPSILON), abs(dir_error - 1.0)) * (cos(iTime*2.0*pi)*0.5+1.5); // SDF otherwise broken? WHITE, BLINKING\n#endif\n#ifdef VERIFY_GRADIENT_CONTINUITY_SIDEWAYS\n        //vec3 epsilon = (hash33(dst*100.0) * 2.0 - 1.0) * 0.1/*step-size*/;\n        vec3 epsilon = (hash33(dst*100.0) * 2.0 - 1.0) * 0.01/*step-size*/;\n        //if(abs(dot(gradient(dst-epsilon), gradient(dst+epsilon)) - 1.0) > 0.5/*sensitivity*/)\n        if(abs(dot(gradient(dst-epsilon), gradient(dst+epsilon)) - 1.0) > 0.05/*sensitivity*/)\n            //planecolor.z += 1.0;\n            planecolor += mix(vec3(1,0,1),vec3(0,1,1), 0.5 + 0.5 * cos(iTime * 5.0));\n#endif\n    }\n\n    return vec4(planecolor, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 o = ivec2(0);\n    vec3 sum = vec3(0);\n    for(o.y = 0; o.y < AA; o.y++)\n    {\n        for(o.x = 0; o.x < AA; o.x++)\n        {\n            vec2 uv = (fragCoord.xy + vec2(o) - vec2(AA-1)*0.5) / iResolution.xy;\n            vec2 ndc = 2.0 * uv - 1.0;\n            ndc.x *= float(iResolution.x) / float(iResolution.y);\n            float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n            float my = pi / 2.0 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n            mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.05);\n            my = (iMouse.y > 10.0) ? my : 1.25 * pi / 2.0;\n\n            mat2 yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n            vec3 ro = vec3(0.0, 0.0, -4.5 );//vec3(0.0, -10.0 * my, 0.0);\n            //mat2 Pitch = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0));\n            mat2 pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n            ro.yz = pitch * ro.yz;\n            ro.xy = yaw * ro.xy;\n\n            vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n            rd.yz = pitch * rd.yz;\n            rd.xy = yaw * rd.xy;\n\n            vec4 slice = trace_slice(ro, rd);\n            vec3 scenecolor = vec3(0);\n\n            float dist = trace(ro, rd, 0.0, DIST_MAX);\n            if(dist < DIST_MAX)\n            {\n                if(slice.w < 0.0)\n                    slice.w = DIST_MAX;\n                bool above = dist < slice.w;\n                if(above) // view only part above plane (comment-out to view whole shape)\n                {\n                    vec3 dst = ro + rd * dist;\n                    vec3 n = normalize(gradient(dst)); // NOTE: gradient is unnormalized in case of errors!\n\n                    //vec3 lightdir = normalize(vec3(1, 1, 1));\n                    vec3 lightdir = normalize(vec3(0, 0, 1));\n                    vec3 ambient = vec3(0.1);\n                    float diffuse = max(dot(lightdir, n), 0.0);\n                    float specular = pow(max(dot(normalize(lightdir - rd), n), 0.0), 50.0);\n\n                    scenecolor = vec3(.1); // object color\n                    scenecolor = /*specular+*/ (ambient + diffuse) * scenecolor;\n\n                    {\n                        // transform normal to local coordinates\n                        n.xy = n.xy*yaw;\n                        n.yz = n.yz*pitch;\n                        scenecolor = max(scenecolor, smoothstep(0.8, 1.0, length(n.xy))); // rim-light\n                    }\n\n                    scenecolor = sqrt(scenecolor); // approximate gamma\n                }\n            }\n\n            vec3 planecolor = 1.5*slice.xyz*exp2(-slice.w*slice.w/20.0); // workaround: \"fog\" hides moiree pattern\n\n            vec3 color = scenecolor + planecolor; // TRANSPARENT\n            //vec3 color = mix(scenecolor, planecolor, step(slice.w, dist)); // SOLID\n            sum += color;\n        }\n    }\n\n    fragColor = vec4(sum/float(AA*AA), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3RH.jpg", "access": "api", "license": "mit", "functions": [[2131, 2131, 2148, 2211, 2266], [2268, 2268, 2301, 2301, 2879], [2881, 2881, 2927, 2927, 2967], [2969, 2969, 3065, 3065, 3249], [3251, 3251, 3302, 3302, 3460], [3462, 3462, 3559, 3559, 3683], [3685, 3685, 3721, 3721, 6998], [7000, 7000, 7057, 7057, 10032]], "test": "ok"}
{"id": "dll3z8", "name": "Pixel Man!", "author": "SnoopethDuckDuck", "description": "Code needs neatening up but play around with the parameters, it's quite funny\n\nHeavily inspired by this:\nhttps://dan-ball.jp/en/javagame/ranger2/\n\nFork chain has some other stuff, the first one is the same as this\n", "tags": ["2d", "motion", "pixelart", "human", "stickman"], "likes": 27, "viewed": 333, "published": 3, "date": "1671319702", "time_retrieved": "2024-07-30T16:12:21.842230", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = .14;\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat pxLine(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float d = min((abs(f.x - round(dir.x/dir.y * f.y))),\n                  (abs(f.y - round(dir.y/dir.x * f.x))));\n                  \n    // Restrict to the box bounded by p and q           \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\nfloat test(float t) {\n    float f = min(1., mod(t, 2.)) + floor(t/2.);\n    return abs(sin(pi * f));\n}\n\n// Gets 3rd point on isosceles triangle with p, q\nvec2 getTriPoint(vec2 f, vec2 p, vec2 q, float v) {\n    vec2 m = (p+q)/2.;  \n    vec2 dir = normalize(vec2(p.y - q.y, q.x - p.x));\n    return round(m + v * dir); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n    vec2 res = iResolution.xy;\n    float t = 1.5 * iTime;\n    t = mod(t, 5.5 * pi);\n    // fragCoord must be offset by 0.5\n    f -= vec2(30,20) - 0.5;\n   // f.x = -abs(f.x);\n    float a = .5 * pi * cos(t);\n    \n    float sw = 4.;    // Stride width\n    float sh = 4.;    // Stride height\n    float vHip = -1.; // Vertical hip motion per step\n    float xHip = 2. * sin(4. * t);\n    float dHip = 2.;  // Hip length\n    float kd = 2.;//4. * cos(4.*t);   // Knee distance from centre of leg\n    \n    // Centre x coord (idk)\n    float x = sw * 0.5 * pi * t - 26.;\n    \n    // Centre of hip\n    vec2 p = round(vec2(x - xHip, 8. + vHip * cos(2.*pi*t))); //+w*test(t)));//+limp\n    \n    // Hip points\n    float aHip = 4. * t;// +.25 * pi * sin(4. * t);\n    vec2 p1 = round(p - dHip * vec2(cos(aHip), sin(aHip)));\n    vec2 p2 = round(p + dHip * vec2(cos(aHip), sin(aHip)));\n    \n    // Foot points\n    vec2 q1 = round(vec2(x - sw * cos(pi * t), \n                       -9. + sh * test(t)));\n    vec2 q2 = round(vec2(x + sw * cos(pi * t), \n                       -9. + sh * test(t+1.)));\n        \n    // Knee points\n    vec2 pq1 = getTriPoint(f, p1, q1, kd);\n    vec2 pq2 = getTriPoint(f, p2, q2, kd);\n      \n    // \"Body\" point  \n    vec2 pc = round(vec2(x + xHip, p.y + 14.));\n      \n    // Shoulder points\n    vec2 ps1 = round(pc - dHip * vec2(cos(aHip), sin(aHip)));\n    vec2 ps2 = round(pc + dHip * vec2(cos(aHip), sin(aHip)));\n      \n    // Elbow points\n    float aElb1 = -0.5 * pi -0.25 * pi * cos(4. * t);\n    float aElb2 = -0.5 * pi -0.25 * pi * cos(4. * t - pi/2.);\n    vec2 pe1 = round(ps1 + 7. * vec2(cos(aElb1), sin(aElb1)));\n    vec2 pe2 = round(ps2 + 7. * vec2(cos(aElb2), sin(aElb2)));\n      \n    // Hand points\n    float aH1 = -0.5 * pi -0.5 * pi * cos(4. * t);\n    float aH2 = -0.5 * pi -0.5 * pi * cos(4. * t - pi/2.);\n    vec2 ph1 = round(pe1 + 4. * vec2(cos(aH1), sin(aH1)));\n    vec2 ph2 = round(pe2 + 4. * vec2(cos(aH2), sin(aH2)));\n      \n    // Head base\n    vec2 phb = round(pc + vec2(1, 2));\n      \n    // Distance from head circle\n    float dhc = round(length(f - phb - vec2(0,3)));\n    float shc = step(dhc, 3.) - step(dhc,2.);\n    col.b += shc;\n      \n    col.r += pxLine(f, p1, pq1) + pxLine(f, pq1, q1);\n    col.g += pxLine(f, p2, pq2) + pxLine(f, pq2, q2);\n    col.b += pxLine(f, p1, p2);\n    col.b += pxLine(f, p, pc);\n    \n    col.b += pxLine(f, ps1, ps2);\n    col.r += pxLine(f, ps1, pe1);\n    col.g += pxLine(f, ps2, pe2);\n    \n    col.r += pxLine(f, pe1, ph1);\n    col.g += pxLine(f, pe2, ph2);\n\n    col.b += pxLine(f, pc, phb);\n\n    col += step(abs(f.y + 10.), 0.);\n \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dll3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 182]], "test": "untested"}
{"id": "mtsGR8", "name": "My SSD", "author": "mrange", "description": "CC0: Seven Segment Display\nWanted to create a seven segment display to show digits\nI have seen versions of this on shadertoy before but gave it a go myself\nas a fun little challenge.\n", "tags": ["2d", "ssd"], "likes": 31, "viewed": 465, "published": 3, "date": "1671309021", "time_retrieved": "2024-07-30T16:12:22.646081", "image_code": "// CC0: Seven Segment Display\n//  Wanted to create a seven segment display to show digits\n//  I have seen versions of this on shadertoy before but gave it a go myself\n//  as a fun little challenge.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat dsegmentx(vec2 p, vec2 dim) {\n  p.x = abs(p.x);\n  float o = 0.5*max(dim.x-dim.y, 0.0);\n  if (p.x < o) {\n    return abs(p.y) - dim.y;\n  }\n  return length(p-vec2(o, 0.0))-dim.y;\n}\n\nvec3 digit(vec3 col, vec2 p, float aa, float n) {\n  const int[16] digits = int[16](\n    0x7D // 0\n  , 0x50 // 1\n  , 0x4F // 2\n  , 0x57 // 3\n  , 0x72 // 4\n  , 0x37 // 5\n  , 0x3F // 2\n  , 0x51 // 7\n  , 0x7F // 8\n  , 0x77 // 9\n  , 0x7B // A\n  , 0x3E // B\n  , 0x2D // C\n  , 0x5E // D\n  , 0x2F // E\n  , 0x2B // F\n  ); \n  const vec2 dim = vec2(0.75, 0.075);\n  const float eps = 0.01;\n  vec2 ap = abs(p);\n  if (ap.x > (0.5+dim.y+eps)) return col;\n  if (ap.y > (1.0+dim.y+eps)) return col;\n  float m = mod(floor(n), 16.0);\n  int digit = digits[int(m)];\n\n  vec2 cp = (p-0.5);\n  vec2 cn = round(cp);\n\n  vec2 p0 = p;\n  p0.y -= 0.5;\n  p0.y = p0.y-0.5;\n  float n0 = round(p0.y);\n  p0.y -= n0;\n  float d0 = dsegmentx(p0, dim);\n\n  vec2 p1 = p;\n  vec2 n1 = sign(p1); \n  p1 = abs(p1);\n  p1 -= 0.5;\n  p1 = p1.yx;\n  float d1 = dsegmentx(p1, dim);\n  \n  vec2 p2 = p;\n  p2.y = abs(p.y);\n  p2.y -= 0.5;\n  p2 = abs(p2);\n  float d2 = dot(normalize(vec2(1.0, -1.0)), p2);\n\n  float d = d0;\n  d = min(d, d1);\n  const vec3 acol = vec3(1.0, 0., 0.25);\n  const vec3 icol = acol*0.1;\n\n  float sx = 0.5*(n1.x+1.0) + (n1.y+1.0);\n  float sy = -n0;\n  float s  = d2 > 0.0 ? (3.0+sx) : sy;\n  // Praying bit shift operations aren't TOO slow\n  vec3 scol = ((digit & (1 << int(s))) == 0) ? icol : acol;  \n\n  col = mix(col, scol, smoothstep(aa, -aa, d));\n  return col;\n}\nvec3 digit(vec3 col, vec2 p, float n) {\n  float aa = fwidth(p.y);\n  return digit(col, p, aa, n);\n}\n\nvec3 effect(vec2 p, vec2 cq) {\n  vec2 pp = p;\n  pp *= 0.33*(-length(cq)+5.0);\n  pp += 0.1*TIME;\n  pp *= 10.0;\n\n  float nx = mod1(pp.x, 1.5*3.0);\n  float hx = hash(nx+123.4);\n\n  pp.y += 8.0*(hx-0.25)*TIME;\n  float ny = mod1(pp.y, 3.0);  \n  float hy = hash(ny+456.7);\n  float n = TIME*(hx+hy)+16.0*fract(hx+hy);\n\n  vec3 col = vec3(0.025)*vec3(1.0, 0.0, 0.5);\n  col = digit(col, pp, n+1234.5);\n  col *= smoothstep(1.5, 0.5, length(cq));\n  col = sqrt(col.yxz);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);  \n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 318, 340, 340, 388], [390, 476, 515, 515, 640], [642, 642, 677, 677, 825], [2156, 2156, 2195, 2195, 2254], [2256, 2256, 2286, 2286, 2728], [2730, 2730, 2785, 2785, 2963]], "test": "untested"}
{"id": "Dts3zH", "name": "Draw with discard", "author": "fishy", "description": "Simple drawing shader using discard. Features include painting, erasing and clearing the entire canvas. Truly a next-gen drawing program!\nBackspace clears everything, shift toggles erasing mode", "tags": ["draw", "discard"], "likes": 5, "viewed": 199, "published": 3, "date": "1671306330", "time_retrieved": "2024-07-30T16:12:23.526727", "image_code": "#define k(b, c) texture(iChannel0, vec2(b, c)).r\nvoid mainImage( out vec4 r, in vec2 d )\n{\n    vec2 p = d/iResolution.y, m = iMouse.xy/iResolution.y;\n    r = vec4(0);\n    if(k(.032, 0.5) <= 0.)\n        if(distance(p, m) > .02 || iMouse.z < 0.) discard; else r = vec4(1.-k(0.063, 1));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dts3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 90, 90, 285]], "test": "untested"}
{"id": "ftSczt", "name": "Instanssilöylyt", "author": "iveks", "description": "Instanssi 25min shader kompo", "tags": ["instanssi"], "likes": 1, "viewed": 195, "published": 3, "date": "1671303386", "time_retrieved": "2024-07-30T16:12:24.279713", "image_code": "#define pi 3.14159\n\n// https://www.laurivan.com/rgb-to-hsv-to-rgb-for-shaders/\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Slow it down, geez.\n    float slow = iTime * 0.1;\n    \n    vec4 shader = texture(iChannel0, uv);\n    \n    vec4 shader2 = texture(iChannel1, uv).brga;\n    \n    vec4 col = vec4(0);\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv = floor(uv * (cos(slow*0.1) + 16.0 + cos(slow) * 16.0));\n    uv.x += sin(iTime);\n    \n    float t = atan(uv.y, uv.x);\n    \n    vec3 hsv = vec3(\n        (shader * mod(sin(t * pi) + slow, pi)).r,\n        (shader2 * mod(sin(t * pi) + 1.3478164 + 3.0*slow, pi)).r,\n        1.0\n    );\n    \n    vec3 rgb = hsv2rgb(hsv);\n    \n    // Output to screen\n    fragColor = vec4(rgb.r,rgb.g,rgb.b,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 rotate(vec2 uv, float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Slow it down, geez.\n    float slow = iTime * 0.1;\n    \n    vec4 buffer = texture(iChannel0, uv);\n\n    // Time varying pixel color\n    vec4 col = 0.5 + 0.5*cos(slow*10.0+uv.xyxy+vec4(0,2,4,6));\n    vec4 col2 = 0.5 + 0.5*cos(5.0 + slow*10.0+uv.xyxy+vec4(0,2,4,6));\n    \n    vec4 shader = vec4(0, 0, 1.0, 1.0).rgba * col;\n    \n    shader += vec4(0, 0, 1.0, 1.0).brga * col2;\n    \n    vec4 tex = texture(iChannel1, 2.0*uv*(sin(iTime)+1.0) + vec2(slow + sin(iTime), iTime + cos(iTime)));\n    \n    shader = max(shader, 0.2);\n    \n    shader = shader * tex * 0.8 + buffer * 0.8;\n    \n    shader += shader * vec4(0, 0, 1.0, 1.0);\n\n    // Output to screen\n    fragColor = shader;\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Slow it down, geez.\n    float slow = iTime * 0.1;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv = rotate(uv, slow);\n    \n    vec4 buffer = texture(iChannel0, uv);\n\n    // Time varying pixel color\n    vec4 col = 0.5 + 0.5*cos(iTime*10.0+uv.xyxy+vec4(0,2,4,6));\n    vec4 col2 = 0.5 + 0.5*cos(5.0 + iTime*10.0+uv.xyxy+vec4(0,2,4,6));\n    \n    vec4 shader = vec4(0, 0, 1.0, 1.0).rgba * col;\n    \n    shader += vec4(0, 0, 1.0, 1.0).brga * col2;\n    \n    vec4 tex = texture(iChannel1, 2.0*uv*(sin(iTime)+1.0) + vec2(iTime + sin(iTime), iTime + cos(iTime)));\n    \n    shader = max(shader, 0.2);\n    \n    shader = shader * tex * 0.8 + buffer * 0.8;\n    \n    shader += shader * vec4(0, 0, 1.0, 1.0);\n\n    // Output to screen\n    fragColor = mod(shader + iTime, 1.0);\n}", "buffer_b_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 79, 101, 101, 270], [272, 272, 329, 379, 1040]], "test": "untested"}
{"id": "Dls3R8", "name": "Emboss with Color Key", "author": "MysteryPancake", "description": "Made for a quick Discord demo", "tags": ["color", "greenscreen", "emboss", "key", "claude", "colorkey"], "likes": 7, "viewed": 257, "published": 3, "date": "1671291836", "time_retrieved": "2024-07-30T16:12:25.165345", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample foreground and background textures\n    vec4 fg = texture(iChannel0, uv);\n    vec4 bg = texture(iChannel1, uv);\n    \n    // Convert foreground color to greyscale\n\tfloat gray = length(fg.rgb);\n    // Emboss based on change in greyscale color\n    gray += 0.5 - (dFdy(gray) + dFdx(gray)) * 4.0 - gray;\n    \n    // Measure distance to green\n    float dist = distance(fg.rgb, vec3(0.0, 1.0, 0.0));\n    // Increase contrast, change 0.4 and 0.5 depending how close the green is\n    float factor = smoothstep(0.4, 0.5, dist);\n    \n    // Final composite, mix foreground and background\n    fragColor.rgb = mix(bg.rgb, vec3(gray), factor);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dls3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 748]], "test": "untested"}
{"id": "Ds2SzG", "name": "gay farts", "author": "nickbrick", "description": "Simple particle simulation from four basic oscillations: wide swaying, flocking and swelling, mild swimming, and \"turbulence\".\nImage is a composite of the colored particles and their voronoi cells. It is then blurred by averaging and shifted.", "tags": ["voronoi", "blur", "particle"], "likes": 5, "viewed": 304, "published": 3, "date": "1671282273", "time_retrieved": "2024-07-30T16:12:26.119793", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lots of things to twiddle, have fun\nfloat hash( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\n//HSV (hue, saturation, value) to RGB.\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\n#define saturate(v) clamp(v,0.,1.)\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n// https://math.stackexchange.com/a/2430837\n// https://graphtoy.com/?f1(x,t)=atan(%20cos(t)*sin(x)%20/%20(1.0-cos(t)*cos(x))%20)%20/%20cos(t)&v1=true&f2(x,t)=&v2=false&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0,0,12\nfloat smoothSaw(float x){\n    #define STEEP 0.7\n    return (1.2 + atan(STEEP * sin(x) / (1.0 - STEEP * cos(x))) / STEEP) / 2.4;\n}\n\n#define N 333u\nvec2 simulateParticle(uint i){\n    #define FLOCKAMP 0.8 \n    #define FLOCKFREQ 0.5 \n    #define SWAYAMP 0.3\n    #define SWAYFREQ 0.1\n    #define FART 0.1\n    #define side(i) (mod(float(i), 2.0) * 2.0 - 1.0)\n    #define TAU 6.283185307\n    float sway = SWAYAMP * sin(iTime * SWAYFREQ) + (iResolution.x / iResolution.y) / 2.0;\n    float flockNorm =  smoothSaw(iTime * FLOCKFREQ);\n    // seeding\n    float n  = hash(i);\n    float n1 = hash(i + 1u);\n    vec2 p = vec2(float(i) / float(N), n * 0.5 + 0.5);\n    // farting\n    p += vec2(sin(mod(iTime, 360.0) * pow(flockNorm, 4.0) * FART + TAU * n),\n              cos(mod(iTime, 360.0) * pow(flockNorm, 4.0) * FART + TAU * n)) *\n              side(i) * flockNorm * 0.008;\n    // swimming\n    p += vec2(sin(iTime + TAU * n ),\n              cos(iTime + TAU * n1)) * 0.2;\n    // flocking\n    p *= vec2(side(i) * FLOCKAMP * flockNorm, 1.0);\n    // swaying\n    p += vec2(sway, -0.21);\n    return p;\n}\n\nvec2 getNearestParticle(vec2 uv){\n    float d = 1000.0;\n    uint id = 0u;\n    for (uint i = 0u; i < N; i++)\n        {\n            vec2 p = simulateParticle(i);\n            if (length(uv - p) < d){\n                d = min(d, length(uv - p));\n                id = i;\n            }\n        }\n    return vec2(d, float(id)); //(distance, id)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    #define SIZE 0.002\n    #define FADE 0.975\n    #define CELL 0.004\n    #define GAY 0.69\n    #define BLUR 1\n    #define DRIFT ivec2(0 * int(iResolution.x) / 1000, 2 * int(iResolution.y) / 500)\n    #define getCol(offset) (texelFetch(iChannel0, ivec2(fragCoord)+offset+DRIFT, 0).rgb)\n\n    vec2 uv = fragCoord / min(iResolution.x, iResolution.y);\n    vec2 n = getNearestParticle(uv);\n    float d = n.x;\n    uint i = uint(n.y);\n    vec3 rgb0 = getCol(ivec2(0, 0));\n\n    if (BLUR > 0){\n        for (int x = -BLUR; x <= BLUR; x++)\n            for (int y = -BLUR; y <= BLUR; y++)\n            {\n                if (x == 0 && y == 0) continue;\n                rgb0 += getCol(ivec2(x, y));\n            }\n        rgb0 /= float((2 * BLUR + 1) * (2 * BLUR + 1) - 0);\n    }\n    \n    rgb0 *= FADE;\n    \n    float h = GAY * (sin(hash(i) + iTime + 6.28 * hash(i)) * 0.5 + 0.5);\n    vec3 rgb = hsv2rgb(vec3(h, GAY, 1.0));\n    rgb *= max(CELL, step(d, SIZE));\n    fragColor = vec4(rgb0 + rgb, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "mtX3RH", "name": "Fork Speedpaint Rutvik_Tak 984", "author": "Rutvik_Tak", "description": "Anime Speed Trails (30 min speed painting)", "tags": ["speedpaint"], "likes": 7, "viewed": 282, "published": 3, "date": "1671280313", "time_retrieved": "2024-07-30T16:12:26.940599", "image_code": "float hash( vec2 p ) {return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);} //Pseudo-random\nfloat smoothNoise( in vec2 p) { //Bilinearly interpolated noise (4 samples)\n    vec2 i = floor( p ); vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float a = hash( i + vec2(0.0,0.0) );\n\tfloat b = hash( i + vec2(1.0,0.0) );\n\tfloat c = hash( i + vec2(0.0,1.0) );\n\tfloat d = hash( i + vec2(1.0,1.0) );\n    return float(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y)/4.;\n}\n//Funciton to make the noise continuous while wrapping around angle \nfloat rotatedMirror(float t, float r){\n    //t : 0->1\n    t = fract(t+r);\n    return 2.*abs(t-0.5);\n}\n//Some continous radial perlin noise\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat radialPerlinNoise(float t, float d){\n    const float BUMP_MAP_UV_SCALE = 44.2;\n    d = pow(d,0.01); //Impression of speed : stretch noise as the distance increases.\n    float dOffset = -floor(iTime*10.)*0.1; //Time drift (animation)\n    vec2 p = vec2(rotatedMirror(t,0.1),d+dOffset);\n    float f1 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 2.1*vec2(rotatedMirror(t,0.4),d+dOffset);\n    float f2 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 3.7*vec2(rotatedMirror(t,0.8),d+dOffset);\n    float f3 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 5.8*vec2(rotatedMirror(t,0.0),d+dOffset);\n    float f4 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    return (f1+0.5*f2+0.25*f3+0.125*f4)*3.;\n}\n//Colorize function (transforms BW Intensity to color)\nvec3 colorize(float f,vec2 uv,vec2 altereduv){\n    \n    float d = distance(vec2(0.5),uv.xy); //Squared distance\n    float t = 0.1+atan(uv.y,uv.x)/4.28; //Normalized Angle\n    float v = radialPerlinNoise(t,d);\n    //Saturate and offset values\n    v = -2.5+v*5.;\n    //Intersity ramp from center\n    v = mix(0.,v,1.*smoothstep(0.1,10.,d));\n    float pointDistanceFromCenter = distance(vec2(0.5),vec2(v));\n   \n    uv*=( smoothstep(0.,0.9,pointDistanceFromCenter));\n  \n    vec4 iPixel = texture(iChannel0,uv);\n\n    f = clamp(f*.95,0.0,1.0);\n    vec3 c = mix(iPixel.rgb, iPixel.rgb, f); //Red-Yellow Gradient\n         c = mix(c, vec3(0.880,0.508,0.065), f);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f+1.);       //Intensity ramp\n    return cAttenuated;\n}\n/*vec3 colorize(float f){\n    f = clamp(f,0.0,1.0);\n    vec3 c = mix(vec3(1.1,0,0), vec3(1,1,0), f); //Red-Yellow Gradient\n         c = mix(c, vec3(1,1,1), f*10.-9.);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f);       //Intensity ramp\n    return cAttenuated;\n}*/\n//Main image.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 normaluv = fragCoord.xy/iResolution.xy;\n    vec2 uv = 2.5*(fragCoord-0.5*vec2(iResolution.xy))/iResolution.xx;\n    float d = dot(uv,uv); //Squared distance\n    float t = 0.1+atan(uv.y,uv.x)/4.28; //Normalized Angle\n    float v = radialPerlinNoise(t,d);\n    //Saturate and offset values\n    v = -2.5+v*5.;\n    //Intersity ramp from center\n    v = mix(0.,v,.8*smoothstep(0.1,0.65,d));\n    //Colorize (palette remap )\n    \n    vec3 colorized = colorize(v,normaluv,uv);\n    \n\n    \n    fragColor.rgb = colorized;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtX3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 81], [82, 98, 129, 173, 466], [467, 536, 574, 589, 637], [719, 719, 761, 761, 1400], [1401, 1456, 1502, 1502, 2227], [2228, 2527, 2583, 2583, 3102]], "test": "untested"}
{"id": "mtfGz8", "name": "Fork optimized Faknsnjd6 226", "author": "Faknsnjd6", "description": "Optimized", "tags": ["spirograph", "rollingfractal", "orbitfractal"], "likes": 3, "viewed": 182, "published": 3, "date": "1671268449", "time_retrieved": "2024-07-30T16:12:27.741457", "image_code": "//More Spirograph by eiffie\n//Trying (and failing) to make a better DE for parameterized curves.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col=texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    fragColor=vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define S 25\n#define I 7\nfloat s;\nfloat C(float t){\n    float sgn=1.0;if(mod(t,54.0)>27.0)sgn=-1.0;t=floor(mod(t,27.0));if(t<10.0)return(2.0+t*0.25)*sgn;t-=10.0;if(t<10.0)return(2.0+t*0.33333)*sgn;t-=10.0;if(t<1.0)return 3.82845*sgn;if(t<2.0)return 3.64575*sgn;if(t<3.0)return 3.44955*sgn;if(t<4.0)return 2.7913*sgn;if(t<5.0)return 2.5616*sgn;if(t<6.0)return 2.4495*sgn;return 2.30275*sgn;\n}\nvec2 F(float t){\n    float a=t,r=1.0;vec2 q=vec2(0.0);for(int j=0;j<I;j++){q+=vec2(cos(a),sin(a))*r;a*=s;r/=abs(s);}return q;\n}\nvec2 DF(vec2 p, float t){\n    float d1=length(p-F(t)),dt=0.1*d1,d2=length(p-F(t+dt));dt/=max(dt,d1-d2);return vec2(min(d1,d2),0.4*log(d1*dt+1.0));\n}\nvoid mainImage(out vec4 f,in vec2 g){\n    vec3 c=texture(iChannel0,g/iResolution.xy).rgb;vec2 p=(2.0*g-iResolution.xy)/iResolution.y;p*=1.75;float t=iTime*100.0,d=100.0;\n    float t1=(iTime+99.0)*0.2,t2=t1+1.0,l=smoothstep(0.5,1.0,fract(t1));s=mix(C(t1),C(t2),l);\n    for(int i=0;i<S;i++){vec2 v=DF(p,t);d=min(d,v.x);t+=v.y;}d=smoothstep(0.0,0.01,d);\n    c=mix(min(c,vec3(d*d*d,d*d,d)),vec3(1.0),0.01);f=vec4(c,1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfGz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 245]], "test": "untested"}
{"id": "mtf3R8", "name": "Circuit board patterns", "author": "jarble", "description": "A series of morphing fractal patterns that vaguely resemble circuit boards.", "tags": ["fractal", "circuit"], "likes": 4, "viewed": 242, "published": 3, "date": "1671264429", "time_retrieved": "2024-07-30T16:12:28.527356", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord)/iResolution.y*2.,\n    offset = vec2(0);\n    vec3 col = vec3(0);\n    vec2 uv1 = uv;\n    for(int k = 0; k < 6; k++){\n        offset =\n            abs(fract(vec2(-uv.x-.5,uv.y)-floor(iTime)/16./16.)-.5)\n        ;\n        uv =\n            abs(fract(uv.yx-offset-floor(iTime)/16.)-.5)\n        ;\n        if(uv.x > uv.y)col = vec3(col.yz,abs(uv.x-uv.y));\n    }  \n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      5.,\n\n  s2 = 7.,\n  t=\n      time\n  ,\n  m1 =\n      fmax(t*s1,t/s1+s1,s2)\n  ,\n  m4 =\n      fmax(t*s1,t*s1+s1,s2)\n  ,\n  m3 =\n      fmax(t*s1,(t+m4)*s1/(m1+.5),s2);  \n\n  float m2 =\n      1. + fmax(t/s1*2.,t/s1,s1);\n  ;\n  \n  float a=\n      pow((1.-sqrt(fract(t)))/4.,2.)\n  ,\n\n  nb = pow(2.,(m3+m2)/5.+7.);\n\n  return\n      vec2(fract(time*nb*.998)*a,fract(time*nb)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtf3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 517]], "test": "untested"}
{"id": "clfGRH", "name": "Pencil sphere", "author": "python273", "description": "-", "tags": ["sphere", "pencil"], "likes": 11, "viewed": 329, "published": 3, "date": "1671257810", "time_retrieved": "2024-07-30T16:12:29.390050", "image_code": "#define PI 3.141592653589793\n#define S .05\n\nvec2 rotate(vec2 v, float a) {\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a)) * v;\n}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nvec2 rand2(vec2 c) {\n    return vec2(rand(c), rand(c*13.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= 2.1;\n\n    vec2 c = floor(uv/S);  // current Voronoi cell \"index\"\n    vec2 b = uv - mod(uv, S);  // current cell coord\n\n    vec2 closest = vec2(0.);\n    float d = 999.;  // distance to closest point\n\n    for(float x = -1.; x <= 1.; x += 1.) {\n        for(float y = -1.; y <= 1.; y += 1.) {\n            vec2 i = vec2(x, y);\n            vec2 ic = b + i*S;\n            float idist = distance(\n                uv + (rand2(uv)-.5)*0.01,  // blend edges\n                ic + rand2(c + i)*S\n            );\n            if (idist < d) {\n                d = idist;\n                closest = ic;\n            }\n        }\n    }\n\n    vec2 cuv = length(uv) <= 1. ? closest : uv;\n\n    float l = length(cuv);\n    vec3 normal = vec3(cuv, sqrt(1.-l*l));\n    float na = dot(normal, normalize(vec3(1.)));\n    na = l <= 1. ? na : 0.;  // fix bg\n\n    float a = dot(normal, normalize(vec3(.7, .7, 1.)));\n\n    if (l <= 1.) {\n        a *= 1. + smoothstep(0.986, 1.015, a)*8.;\n    }\n\n    //vec2 suv = rotate(uv, rand(closest)*PI);  // cool too\n    vec2 suv = rotate(fragCoord/vec2(720.)*2.1, na * PI);  // stroke uv\n\n    float brightness = sin(\n        ((suv.x + suv.y) * (1.+na/1.8) + rand(uv)*.005) * 220.\n    ) /2.+.5;\n    /*\n    suv = rotate(suv, PI/3.);\n    brightness += sin(\n        ((suv.x + suv.y) * (1.+na/1.8) + rand(uv)*.005) * 220.\n    ) /2.+.5;\n    */\n    brightness *= max(0.08, a);\n    fragColor = vec4(vec3(brightness), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 74, 74, 127], [128, 128, 148, 148, 215], [216, 216, 236, 236, 277], [279, 279, 336, 336, 1842]], "test": "untested"}
{"id": "Dtf3RH", "name": "Dithered shading", "author": "Rutvik_Tak", "description": "Was playing around with my another dithering shader and ended up with this nice little shader which kinda gives a bold/dark shade to image", "tags": ["shading", "dithering"], "likes": 0, "viewed": 231, "published": 3, "date": "1671251681", "time_retrieved": "2024-07-30T16:12:30.270695", "image_code": "// Author: Rutvik Tak\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    // Output to screen\n   // uv+=dot(uv.x,uv.x);\n    \n    vec4 mycolor=vec4(uv.xyx,1.);\n        \n    vec2 res=iResolution.xy/3.;\n    vec2 pos=floor(uv*res)/res;\n    if(max(abs(pos.x-.5),abs(pos.y-.5))>.5){\n        fragColor=vec4(0.);\n    }\n    \n    //vec4 color = texture( iChannel0, uv.xy );\n    vec4 imagePixel=texture(iChannel0,uv.xy);\n    float ditheredR = sin(mycolor.x*1.)*1.;\n    float ditheredG = cos(mycolor.y*1.)*1.;\n    vec2 ditheredRG = vec2(ditheredR,ditheredG);\n    vec2 factorValue = step(1.,fract(ditheredRG));\n    vec4 bitRateColor = mix(vec4(ditheredRG * factorValue, 1., 1.), imagePixel, factorValue.x * factorValue.y);\n \n    vec4 imagetopixelcolor=vec4(bitRateColor.xy,imagePixel.x,imagePixel.x);\n    \n    float grayScaleValue=(imagetopixelcolor.x+imagetopixelcolor.y+imagetopixelcolor.z)/3.;\n    vec2 pixelColor = step(grayScaleValue+0.5,imagePixel.xy);\n\n    fragColor= vec4(pixelColor,imagePixel.b,1.);\n\n    \n    \n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtf3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 77, 127, 1114]], "test": "untested"}
{"id": "DlXGRH", "name": "flower lights", "author": "TestCoder", "description": "lights", "tags": ["lights"], "likes": 3, "viewed": 279, "published": 3, "date": "1671238402", "time_retrieved": "2024-07-30T16:12:31.344823", "image_code": "float lightCircle(vec2 uv, float radius, vec2 position, float radiusReduction) {\n    float d = length(uv-position)*radiusReduction;\n\n    d = smoothstep(d,0.,radius);\n    \n    return 1.-d;\n}\n\nvec2 getRotation(float spin, float itemsAmount, float d) {\n    float cosineTime = cos(iTime + spin / itemsAmount * 3.14 * 2.) * d;\n    float sineTime = sin(iTime + spin / itemsAmount * 3.14 * 2.) * d;\n    \n    return vec2(cosineTime, sineTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = vec3(0.);\n    float timeSpeed = .5;\n    vec3 rotatingColor = cos(iTime*timeSpeed+uv.xyx+vec3(0,2,4));\n    float itemsAmount = 20.;\n    float zoom = .25;\n    float amount = 20.;\n    float stretch = 4.;\n    float shineReduction = 7.;\n    float rotationDisplacement = 2. + sin(iTime * timeSpeed) * cos(iTime * timeSpeed);\n\n    for (float d = 0.; d < amount; d++) {\n        for (float index = 0.; index < itemsAmount; index++) {\n            float itemsDistance = d / amount * stretch * zoom;\n            color += rotatingColor*lightCircle(uv, .1, getRotation(index + d / rotationDisplacement, itemsAmount, itemsDistance), shineReduction / zoom);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 80, 80, 189], [191, 191, 249, 249, 437], [439, 439, 496, 546, 1400]], "test": "untested"}
{"id": "DtXGRH", "name": "morphing spheres", "author": "jonasfrey", "description": "multiplying the distance of each sphere results in a morphing effect\n\nleft, multiplied distance \nright: only the closest distance to the current coordinate of the image", "tags": ["morphing"], "likes": 5, "viewed": 243, "published": 3, "date": "1671236265", "time_retrieved": "2024-07-30T16:12:32.114765", "image_code": "float f_n_rand(float n){\n    return fract(sin(234.32)*123.3*cos(n*23.23)*23.33);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.z ==0.){o_trmono = vec2(0.);}\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    float n_tau = 6.2831;\n    float n_angle = n_tau / 3.;\n    float n_its = 50.;\n    float n_index = 0.;\n    float n_index_nor = 0.;\n    float n_dist_clst = 1.;\n    float n_t = iTime*2.;\n    float n_mixed = 0.;\n    float n_dist = 0.5;\n    float n_col_nor = 0.;\n    float n_dist_mul = 1.;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n        float n_itnor = n_it / n_its;\n        float n_rnd1 = f_n_rand(n_it);\n        float n_rnd2 = f_n_rand(n_rnd1);\n        vec2 o = o_trpino + vec2(\n            sin(n_rnd1*n_tau+iTime)*(iResolution.x/iResolution.y)*0.5,\n            cos(n_rnd2*n_tau+iTime)*0.5\n            //n_itnor\n            //(f_n_rand(n_it+iTime*0.00001)-0.5)*2.,\n            //(f_n_rand(n_it+iTime*0.00001)-0.5)*2.\n        );\n        n_dist = length(o);\n        n_dist_mul *= pow(n_dist, 0.2)*1.;\n        if(n_dist < n_dist_clst){\n            n_dist_clst = n_dist;\n        }\n    }\n    \n    fragColor = vec4(\n        n_dist_mul\n    );\n    if(o_trpino.x>o_trmono.x){\n     fragColor = vec4(n_dist_clst*10.);\n    }\n    fragColor = sqrt(fragColor);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 82], [83, 83, 140, 140, 1444]], "test": "untested"}
{"id": "ctf3z8", "name": "24-bit fixed * 12-mantis-bit mul", "author": "ttg", "description": "Multiply 24bit signed integer by float using 12 bits of mantissa into whole part and fract part without loss of precision over the integer argument's range.\nClick left/right to compare one at a time.", "tags": ["precision", "arithmetic"], "likes": 5, "viewed": 279, "published": 3, "date": "1671234980", "time_retrieved": "2024-07-30T16:12:32.961500", "image_code": "/*\n\n24-bit fixed * 12-mantissa-bit multiply\nhttps://www.shadertoy.com/view/ctf3z8\n\nMultiply 24-bit signed integer by float using 12 bits of mantissa into\nwhole part and fract part without loss of precision over the integer argument's\nrange.\nClick left/right to compare one at a time.\n\nCopyright 2022 Theron Tarigo.  All rights reserved.\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.\n\n*/\n\n// https://www.shadertoy.com/view/ctf3z8\n// requires abs(a) < (1<<24), recognizes only 12 significand bits of b\n// logical operation: returns fract(a*b+x), ret_n=floor(a*b+x)\nfloat frac_mad_i24_m12_f32 (out int ret_n, int a, float b, float x) {\n#ifdef SAFE\n  int _M=~0xFFF;\n  if (a!=(a&0xFFFFFF)) return 0.;\n  b = intBitsToFloat(floatBitsToInt(b)&_M);\n#endif\n  vec2 p = vec2(a&0xFFF,a&~0xFFF)*b,i=floor(p),f=p-i,r=f+f.y+x;\n  ret_n = int(i.x+i.y+(r.y=floor(r.x)));\n  return r.x-r.y;\n}\n\nvoid mainImage (out vec4 O, vec2 f) {\n  vec2 uv = f/iResolution.xy;\n  float yplt=fract(uv.y*2.);\n  int i=int(floor(uv.x*160.))+0x1000000; // index\n  float b=intBitsToFloat(0x3da3d000); // frequency = 7.9986572e-02\n  float x=.2; // phase shift\n  \n  float Af,Bf;\n  int Ai,Bi;\n  \n  // mad f32 result (imprecise)\n  Af=fract(float(i)*b+x);\n  Ai=int(floor(float(i)*b+x));\n  \n  // frac_mad_i24_m12_f32 result\n  Bf=frac_mad_i24_m12_f32(Bi,i,b,x);\n  \n  vec3 col=vec3(0.);\n  if(uv.y>.5){\n    col.r=float(yplt<Af);\n    col.g=float(yplt<Bf);\n  }\n  else{\n    int shift=1341950;\n    int range=20;\n    col.r=float(yplt<float(Ai-shift)/float(range));\n    col.g=float(yplt<float(Bi-shift)/float(range));\n  }\n  if(iMouse.z>0.){\n    float m=iMouse.x/iResolution.x;\n    if(m<.5)col=vec3(col.r);\n    else col=vec3(col.g);\n  }\n  \n  // sRGB output https://www.shadertoy.com/view/sl3cRs\n  {vec3 c=col;O.rgb=min(12.9*c,abs(1.054*pow(c,c-c+.4166)-.095)+.04);}\n}\n\n/*\nCopyright 2022 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctf3z8.jpg", "access": "api", "license": "isc", "functions": [[428, 603, 672, 672, 911], [913, 913, 950, 950, 1848]], "test": "ok"}
{"id": "mtlGzr", "name": "Untweetable Cosmic ", "author": "mrange", "description": "Inspired by Cosmic by Xor: https://www.shadertoy.com/view/msjXRK\nI am a big fan of high saturated glowin colors.\nSo I really liked Cosmic by Xor.\nThis is my untweetable take on it :)", "tags": ["2d", "saturation"], "likes": 24, "viewed": 643, "published": 3, "date": "1671214935", "time_retrieved": "2024-07-30T16:12:33.703517", "image_code": "// CC0: Untweetable Cosmic \n//  Inspired by Cosmic by Xor: https://www.shadertoy.com/view/msjXRK\n//  I am a big fan of high saturated glowin colors.\n//  So I really liked Cosmic by Xor.\n//  Making short shaders isn't part of my skill set but I was \n//  thinking I could maybe remove the need to loop for each ring.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n\n// We like the rings to interact with each other so create 4 \"frisbees\"\n// and add their colors together\nconst float overSample  = 4.0;\nconst float ringDistance= 0.075*overSample/4.0;\nconst float noOfRings   = 20.0*4.0/overSample;\nconst float glowFactor  = 0.05;\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan_approx(p.y, p.x));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 glow(vec2 pp, float h) {\n  float hh = fract(h*8677.0);\n  float b = TAU*h+0.5*TIME*(hh > 0.5 ? 1.0 : -1.0);\n  float a = pp.y+b;\n  float d = max(abs(pp.x)-0.001, 0.00125);\n  return \n    (   smoothstep(0.667*ringDistance, 0.2*ringDistance, d)\n      * smoothstep(0.1, 1.0, cos(a))\n      * glowFactor\n      * ringDistance\n      / d\n    )\n    * (cos(a+b+vec3(0,1,2))+vec3(1.0))\n    ;\n}\n\nvec3 effect(vec2 p) {\n  p += -0.1;\n  // Didn't really understand how the original Cosmic produced the fake projection.\n  // Took part of the code and tinkered\n  p = (p*mat2(1,-1, 2, 2));\n  p += vec2(0.0, 0.33)*length(p);\n  vec2 pp = toPolar(p);\n\n  vec3 col = vec3(0.0);\n  float h = 1.0;\n  const float nr = 1.0/overSample;\n\n  for (float i = 0.0; i < overSample; ++i) {\n    vec2 ipp = pp;\n    ipp.x -= ringDistance*(nr*i);\n    float rn = mod1(ipp.x, ringDistance); \n    h = hash(rn+123.0*i);\n    col += glow(ipp, h)*step(rn, noOfRings);\n  }\n  \n  col += (0.01*vec3(1.0, 0.25, 0.0))/length(p);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[729, 815, 852, 852, 959], [961, 1049, 1071, 1071, 1122], [1124, 1210, 1249, 1249, 1374], [1376, 1436, 1458, 1458, 1506], [1508, 1508, 1537, 1537, 1892], [1894, 1894, 1915, 1915, 2500], [2502, 2502, 2557, 2557, 2748]], "test": "untested"}
{"id": "DtsGRr", "name": "Glowing Bezier Curve  ", "author": "Rutvik_Tak", "description": "Quadratic Bezier curve SDF with glow. Using distance function from [url]https://www.shadertoy.com/view/MlKcDD[/url]\n\nAt sharp turns, the SDF has creases in the far field. Smooth minimum functions seem to distort low values. Is there a fix for this?", "tags": ["2d", "sdf", "bezier", "heart", "glow", "curve", "neon"], "likes": 4, "viewed": 403, "published": 3, "date": "1671208906", "time_retrieved": "2024-07-30T16:12:34.455506", "image_code": "// Bezier curve and glow functions used from https://www.shadertoy.com/view/WdK3Dz\n// Reworked it to show a single glowing trail with somewhat increasing glow and core width along the tip\n// of the trail\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nconst float speed=-.5;\nconst float len=.25;\nconst float scale=.012;\nfloat intensity=1.3;\nfloat radius=.002;\n\nvec2 point1=vec2(0.1,0.1);\nvec2 point2=vec2(0.2,0.5);\nvec2 point3=vec2(0.9,0.9);\n\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos,vec2 A,vec2 B,vec2 C){\n    vec2 a=B-A;\n    vec2 b=A-2.*B+C;\n    vec2 c=a*2.;\n    vec2 d=A-pos;\n    \n    float kk=1./dot(b,b);\n    float kx=kk*dot(a,b);\n    float ky=kk*(2.*dot(a,a)+dot(d,b))/3.;\n    float kz=kk*dot(d,a);\n    \n    float res=0.;\n    \n    float p=ky-kx*kx;\n    float p3=p*p*p;\n    float q=kx*(2.*kx*kx-3.*ky)+kz;\n    float h=q*q+4.*p3;\n    \n    if(h>=0.){\n        h=sqrt(h);\n        vec2 x=(vec2(h,-h)-q)/2.;\n        vec2 uv=sign(x)*pow(abs(x),vec2(1./3.));\n        float t=uv.x+uv.y-kx;\n        t=clamp(t,0.,1.);\n        \n        // 1 root\n        vec2 qos=d+(c+b*t)*t;\n        res=length(qos);\n    }else{\n        float z=sqrt(-p);\n        float v=acos(q/(p*z*2.))/3.;\n        float m=cos(v);\n        float n=sin(v)*1.732050808;\n        vec3 t=vec3(m+m,-n-m,n-m)*z-kx;\n        t=clamp(t,0.,1.);\n        \n        // 3 roots\n        vec2 qos=d+(c+b*t.x)*t.x;\n        float dis=dot(qos,qos);\n        \n        res=dis;\n        \n        qos=d+(c+b*t.y)*t.y;\n        dis=dot(qos,qos);\n        res=min(res,dis);\n        \n        qos=d+(c+b*t.z)*t.z;\n        dis=dot(qos,qos);\n        res=min(res,dis);\n        \n        res=sqrt(res);\n    }\n    \n    return res;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist,float radius,float intensity){\n    return pow(radius/dist,intensity);\n}\n\nfloat getSegment(float t,vec2 pos,float offset){\n    \n    float dist=10000.;\n    \n    dist=sdBezier(pos,point1,point2,point3);\n    return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    float widthHeightRatio=iResolution.x/iResolution.y;\n    vec2 centre=vec2(.5,.5);\n    vec2 pos=uv;\n    \n    float t=iTime;\n    \n    float dist=getSegment(t,pos,0.);\n    float glow=getGlow(dist,radius,intensity)*uv.x;\n    \n    vec3 col=vec3(0.);\n    \n    //White core\n    col+=1.*vec3(smoothstep(.00001,0.,dist));\n    //Pink glow\n    col+=glow*vec3(1.,.1,.58);\n    \n    col+=glow*vec3(1.,.899,0.);\n    \n    //Tone mapping\n    col=1.-exp(-col);\n    \n    //Gamma\n    col=pow(col,vec3(.4545));\n    \n    // Factor to check if pixel resides within the trail and its glowing region \n    float factorvalue=1.-smoothstep(0.,dot(uv,col.xy)*1. + 0.5,dist);\n    \n    //Output to screen\n    fragColor=vec4(col*factorvalue,1.);\n}", "image_inputs": [], "common_code": "/*\n    Copyright (c) 2019 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 524, 570, 570, 1718], [1720, 1760, 1815, 1815, 1856], [1858, 1858, 1906, 1906, 2003], [2005, 2005, 2059, 2059, 2822]], "test": "untested"}
{"id": "dtlGRn", "name": "x % k % j % i", "author": "FabriceNeyret2", "description": "x %k % j % i  allows for complex griding.\nMouse.x to scale.  Uncomment #10 for normalized version.\n( thanks SnoopethDuckDuck. [url]https://shadertoy.com/view/dsjXWt[/url]  for the idea )", "tags": ["maths", "short"], "likes": 9, "viewed": 378, "published": 3, "date": "1671202928", "time_retrieved": "2024-07-30T16:12:35.197522", "image_code": "// variant of https://shadertoy.com/view/Dts3zr\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n    ivec2 I = ivec2(U),\n          T = ivec2( U / ( iMouse.z>0. ? iMouse.x : iResolution.y*.1 )) +2;\n\n    O = vec4( I.x % I.y % T.x % T.y ); \n//  O /= float( max(1,min(I.y,min(T.x,T.y))-1) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlGRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 285]], "test": "untested"}
{"id": "Dts3zr", "name": "x % j % i", "author": "FabriceNeyret2", "description": "x % j % i allows for complex griding.   Uncomment #10 for normalized version.\nnote that the 1st column is different on OpenGL vs Windows.\n( thanks SnoopethDuckDuck. [url]https://shadertoy.com/view/dsjXWt[/url]  for the idea )", "tags": ["maths", "short"], "likes": 1, "viewed": 215, "published": 3, "date": "1671202258", "time_retrieved": "2024-07-30T16:12:35.969458", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    \n    ivec2 C = ivec2( U / iResolution.y/.1 );\n\n    O = vec4( int(U) % C.x % C.y ) ;\n // O /= float( max(1,min(C.x,C.y)-1) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dts3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 169]], "test": "untested"}
{"id": "Dts3Rr", "name": "morphing two circles", "author": "jonasfrey", "description": "morphing", "tags": ["circle"], "likes": 2, "viewed": 203, "published": 3, "date": "1671197496", "time_retrieved": "2024-07-30T16:12:36.748375", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_norperpix = vec2(1./iResolution.xy);\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n\n    vec2 o_scale = vec2(0.001);\n    float n_divisions = 10.;\n    float n_scale = floor(o_trpino_nooffset.x*n_divisions)/n_divisions;\n    //n_scale = n_scale * 0.1;\n    //o_scale = vec2(0.01+n_scale);\n    vec2 o1 = vec2(sin(iTime)*0.5, 0.0);\n    vec2 o2 = vec2(sin(-iTime)*0.5, 0.0);\n\n    float n1 = length(o1-o_trpino);\n    float n2 = length(o2-o_trpino);\n    \n    float n_min = min(n1, n2);\n    //float n_mixed = (n1*n2);\n    float ne1 = 2.;\n    float n_mixed = (pow(n1, ne1)*pow(n2,ne1));\n    float ne = 2.;\n    n_mixed = pow(n_mixed, ne);\n    n_mixed *= 1000.;\n    \n    float nstp = o_norperpix.x;\n    float n_smth = smoothstep(0., nstp, n_mixed);\n    fragColor = vec4(\n        n_mixed, \n        1.-n_mixed, \n        n_min, \n        1.\n    );\n    //fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dts3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1152]], "test": "untested"}
{"id": "Dll3Rn", "name": "Simpler Pinwheel Tiling - Golfed", "author": "FabriceNeyret2", "description": "minimal display of SnoopethDuckDuck's \"Pinwheel Tiling\" ( e.g. [url]https://shadertoy.com/view/dsjXWt [/url] )\n( Note that it is no longer a Pinwheel Tiling, BTW ;-)  )\nsee here for minimal UVs inside the tiles: https://www.shadertoy.com/view/dll3Rn", "tags": ["2d", "tilings", "short", "onetweet", "golf"], "likes": 20, "viewed": 360, "published": 3, "date": "1671182217", "time_retrieved": "2024-07-30T16:12:37.553224", "image_code": "// Fork of \"Simpler Pinwheel Tiling A\" by SnoopethDuckDuck. https://shadertoy.com/view/dsjXWt\n// see here for minimal UVs inside the tiles: https://www.shadertoy.com/view/dll3Rn\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    ivec2 I = ivec2( u / iResolution.y / .1 ),\n          m = ( I+I - I.y + 10 ) % 5; \n    O = vec4( ( I - ivec2(m.x>2, m%2) ) %3 , 0,0) /2.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dll3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 217, 217, 360]], "test": "untested"}
{"id": "dtXGRr", "name": "Moon Orbiting Planet", "author": "MaxShaders", "description": "Light direction = mouse click location to center of viewport. (hold click)\n\nPlanet texture based on https://www.shadertoy.com/view/lsyfWD\n\nMy first shader (that was worth posting)", "tags": ["space", "planet", "stars", "moon", "physics", "planets", "projectle"], "likes": 5, "viewed": 227, "published": 3, "date": "1671178549", "time_retrieved": "2024-07-30T16:12:38.379016", "image_code": "struct Circle {\n    vec3 center;\n    float radius;\n    vec4 color;\n};\n\nfloat Clamp(float a, float b, float x) {\n    return max(a, min(b, x));\n}\n\nvec4 DrawCircle(vec2 uv, Circle c, bool AA) {\n    float d = length(c.center.xy - uv) - c.center.z;\n    float blur = AA ? smoothstep(1.0, 0.985, 1. - clamp(0., 1., length(d - c.radius) / c.radius)) : 1.;\n    return d <= c.radius ? vec4(c.color.xyz, blur * c.color.w) : vec4(0.);\n}\n\nfloat N(vec2 i) {\n    float t = tan(sin(i.x)) + cos(i.y);\n    return fract(sin(t * 3456.) * 6547.);\n}\n\nvec4 depthSort(vec4 c1, float d1, vec4 c2, float d2) {\n    c1.w = clamp(0., 1., c1.w);\n    c2.w = clamp(0., 1., c2.w);\n    if(length(c1) != 0. && length(c2) != 0.)\n    {\n        return d1 < d2 ? c1 + c2 * (1. - c1.w) : c2 + c1 * (1. - c2.w);\n    }\n    return c1 + c2;\n}\n\nvec4 FresnelCircle(vec2 uv, Circle c, float ammount) {\n    float d = length(c.center.xy - uv);\n    float r = c.radius + c.center.z;\n    if(d > r) return vec4(0.);\n    return vec4(pow(d / (r), ammount));\n}\n\nvec4 bloomCircle(vec2 uv, Circle c, float scale, float intensity, bool hollow) {\n    float d = length(c.center.xy - uv);\n    if(hollow && d < c.radius) return vec4(0.);\n    d = clamp(0., 1., 1. - min(c.radius * scale, d - c.radius) / (c.radius * scale));\n    return vec4(vec3(1.) * intensity * d * d, intensity * d * d);\n}\n\nvec4 combineColors(vec4 c1, vec4 c2) {\n    return vec4(c1.xyz * c1.w + c2.xyz * c2.w, clamp(0., 1., c1.w + c2.w));\n}\n\n//Based on https://www.shadertoy.com/view/lsyfWD\nvec3 PlanetTexture(vec2 uv, float distToEdge, float tscale)\n{\n    float speed = 0.5;\n    vec2 scale = vec2(6., 2.) * tscale;\n    vec2 p = uv * scale / iResolution.xy;\n    \n    for(float i = 1.; i < 10.; i += 1.) \n    {\n        p.x += 0.3 / i * sin(i * 3.* p.y + iTime * speed) + iMouse.x / 1000.;\n        p.y += 0.3 / i * cos(i * 3.* p.x + iTime * speed) + iMouse.y / 1000.;\n    }\n    \n    float r = cos(p.x + p.y + 1.) * .3 + .5;\n    float g = sin(p.x + p.y + 1.) *.5 + .5;\n    float b = (sin(p.x + p.y) + cos(p.x + p.y)) * .8 + .5;\n    vec3 color = 0.4 + vec3(r,g,b) * 0.25;\n    return color * 3. * distToEdge;\n}\n\nfloat shadeCircle(vec2 uv, Circle c, vec2 dir, float scale, float offset) {\n    dir = normalize(dir);\n    float dist = c.radius;\n    vec2 center = vec2(c.center.xy - dist * -offset * dir);\n    return (scale / 2.) + max(1., scale) * max(0.0, (1. / dist - (length(uv - center) * dot(normalize(uv - center), dir) / dist)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ///Set true to keep light direction without holding mouse down\n    bool KeepLightDir = false; //<--------------------------------\n\n\n    float t = mod(iTime / 2., 3.);\n    vec2 uv = fragCoord;\n    float Z = iResolution.y / 10.;\n    vec2 lightDir = vec2(-1., -1.);\n    lightDir *= iMouse.z > 0. || KeepLightDir ? normalize(vec2(iMouse.x - iResolution.x / 2., iMouse.y - iResolution.y / 2.)) : vec2(1.);\n\n    //Moon orbit motion\n    float t_moon = t * 0.5;\n    vec3 g = vec3(0., -1., 0.) * iResolution.y;\n    vec3 A = g;\n    vec3 Vi = vec3(1.0, 2.2 , -0.1) * iResolution.y;\n    vec3 Pi = vec3(0.1, -0.1, 0.5) * vec3(iResolution.xy, Z);\n    \n    vec3 Vel = Vi + A * t_moon;\n    vec3 Pos = vec3(Pi + Vel * t_moon + 0.5 * A * t_moon * t_moon);\n    \n    //Moon\n    Circle m;\n    m.center = Pos.xyz;\n    m.radius = 0.1 * iResolution.y;\n    float moonD = -m.center.z / Z;\n    m.color = vec4(0.55, 0.5, 0.7, 1.) * (clamp(0., 1., 1.4 - moonD));\n    vec4 moon = DrawCircle(uv, m, false);\n    float moonR = m.radius + m.center.z;\n    moon = combineColors(moon, 1.5 * FresnelCircle(uv, m, 5.) *  vec4(0.2, 0.4, 0.5, 0.5));\n    \n    float distToEdge1 = 2. * FresnelCircle(uv, m, 4.).w;\n    moon.xyz *= 0.5 + PlanetTexture(uv - m.center.xy, distToEdge1, 10. * distToEdge1).xzy / 2.;\n    m.radius = moonR;\n    moon.xyz *= shadeCircle(uv, m, lightDir, 0.0, 0.2) / 2.;\n    moon += bloomCircle(uv, m, 0.3, 0.9, true) * vec4(0.1, 0.15, 0.25, 0.2) * pow(shadeCircle(uv, m, lightDir, 0.0, 0.8), 2.);\n    \n    //Planet\n    Circle w;\n    w.center = vec3(0.5, -1., 0.0) * vec3(iResolution.xy, 65.);\n    float planetD = -w.center.z / Z;\n    w.radius = 1.5 * iResolution.y;\n    w.color = vec4(0.5, 0.4, 0.3, 1.) * 1.;\n    vec4 planet = DrawCircle(uv, w, true);\n    \n    Circle Atmosphere;\n    Atmosphere.center = w.center - vec3(0., -2., 0.);\n    Atmosphere.radius = w.radius;\n    vec4 planetAtmosphere = FresnelCircle(uv, Atmosphere, 80.) + (bloomCircle(uv, Atmosphere, 0.015, 1., true));\n    planetAtmosphere *= vec4(0.4, 0.6, 0.9, 1.);\n    \n    planet.xyz *= shadeCircle(uv, w, lightDir, 0.2, 0.2);\n    planet.w = sign(planet.x);\n    \n    vec4 planetBloom = bloomCircle(uv, w, 0.4, 0.5, false) * vec4(0.4, 0.6, 0.9, 0.1);\n    planetBloom *= shadeCircle(uv, Atmosphere, lightDir, 0.0, 0.9) * 1.;\n    float distToEdge = FresnelCircle(uv, w, 12.).w;\n    planet.xyz *= PlanetTexture(uv.yx, distToEdge, 2. * distToEdge) / 1.;\n    planet += planetAtmosphere * max(0.1, shadeCircle(uv, Atmosphere, lightDir, 0.1, 0.0)) * 1.8;\n    \n    \n    moon += planetBloom * moon / 2.;\n    float shadow = Clamp(0.15, 1., 1. -dot(normalize(vec3(0, 1., 0.)), vec3(lightDir, 0.)) / 1.);\n    moon.xyz *= shadow;\n    \n    //Stars\n    vec4 stars = vec4(0.0);\n    float n = N(uv);\n    if(n >= 0.999)\n    {\n        stars += vec4(n * (.8 + sin(4. * iTime * N(uv.yx)) * 0.2));\n    }\n    \n    vec4 planet_moon = depthSort(moon, moonD, planet, planetD);\n    vec4 planets_bloom = depthSort(planet_moon, 0.0, planetBloom, 1.);\n    vec4 planets_stars = depthSort(planets_bloom, 0.0, stars, 1.);\n    fragColor = planets_stars;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 111, 111, 143], [145, 145, 190, 190, 424], [426, 426, 443, 443, 527], [529, 529, 583, 583, 798], [800, 800, 854, 854, 1004], [1006, 1006, 1086, 1086, 1328], [1330, 1330, 1368, 1368, 1446], [1448, 1497, 1558, 1558, 2111], [2113, 2113, 2188, 2188, 2435], [2437, 2437, 2494, 2561, 5566]], "test": "untested"}
{"id": "mtXGzr", "name": "Material Raymarching 2d", "author": "SONENEIS", "description": "a new 2d raymarcher", "tags": ["raymarching", "ray", "line", "circle", "normal", "material", "rect"], "likes": 9, "viewed": 289, "published": 3, "date": "1671175803", "time_retrieved": "2024-07-30T16:12:39.208797", "image_code": "//#define glow\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nfloat sdCirc(vec2 p,float r){\n\treturn length(p) - r;\n}\nfloat sdRect(vec2 p,vec2 s){\n\tvec2 q = abs(p)-s;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\nfloat sdLine(vec2 p,float r,vec2 p1,vec2 p2){\n\tvec2 d1 = p - p1;\n\tvec2 d2 = p2 - p1;\n\tfloat h = clamp(dot(d1,d2) / dot(d2,d2),0.0,1.0);\n  return length(d1 - d2*h) - r;\n}\n\nvec4 fUn(vec4 a,vec4 b){\n  if(a.w < b.w) return a;\n  else return b;\n}\n\nvec4 map(vec2 p){\n\tvec4 d = vec4(vec3(0),9999999999999.0);\n    \n\td = fUn(d,vec4(vec3(1,0,0.5),sdCirc(p - vec2(-0.2,0.4),0.1)));\n\td = fUn(d,vec4(vec3(1,0.1,0),sdCirc(p - vec2(0.3,0.1),0.1)));\n\n\td = fUn(d,vec4(vec3(0,0.5,1),sdLine(p,0.01,vec2(-0.2,0.4),vec2(0.3,0.1))));\n\n  {\n  vec2 q = (p - vec2(-0.15,0.0)) * rot(iTime);\n  d = fUn(d,vec4(vec3(0,1,0.1),sdRect(q,vec2(0.1))));\n  }\n\n\treturn d;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 mm = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n  \n  uv *= 0.5; uv.y += 0.125;\n  mm *= 0.5; mm.y += 0.125;\n  \n  vec4 d = map(uv);\n  #ifdef glow\n    col += d.rgb * smoothstep(4.0/iResolution.y,0.0,d.w) * 0.75;\n    col += abs(sin(100.0*d.w))*0.05;\n    col = mix(col,vec3(1),smoothstep(10.0/iResolution.y,0.0,abs(d.w)));\n    col *= clamp(abs(-d.w*10.0)*0.75+0.5,0.0,1.0);\n    col += d.rgb * abs(exp(-d.w*10.0));\n  #else\n    col += 0.1;\n    col += d.rgb * smoothstep(4.0/iResolution.y,0.0,d.w) * 0.75;\n    col += abs(sin(100.0*d.w))*0.05;\n    col *= clamp(abs(-d.w*10.0)*0.75+0.5,0.0,1.0);\n    col = mix(col,vec3(1),smoothstep(4.0/iResolution.y,0.0,abs(d.w)));\n  #endif\n\n  { //raymarching\n  \tvec2 ro = vec2(mm);\n  \tvec2 rd = normalize(vec2(1)*rot(iTime));\n\n  \tconst float num_steps = 25.0;\n  \tconst float max_dist = 100.0;\n  \tconst float min_dist = 0.001;\n\n  \tvec2 p = ro;\n  \tfor(float i=0.0;i<num_steps;i++){\n  \t\tfloat h = abs(map(p).w);\n  \t\tif(h < min_dist || h > max_dist) break;\n\n      col += 0.1 * smoothstep(4.0/iResolution.y,0.0,length(uv - p) - h);\n      col += 0.1 * smoothstep(4.0/iResolution.y,0.0,abs(length(uv - p) - h));\n      col += 0.2 * smoothstep(4.0/iResolution.y,0.0,length(uv - p) - 0.015);\n\n      vec2 e = vec2(-1,1) * min_dist;\n      vec2 normal = normalize(vec2(\n      \te.xx * map(p + e.xx).w +\n      \te.xy * map(p + e.xy).w +\n      \te.yx * map(p + e.yx).w +\n      \te.yy * map(p + e.yy).w\n      ));\n      vec2 n = p - normal*h;\n\n      col += 0.5 * smoothstep(4.0/iResolution.y,0.0,sdLine(uv,0.0025,p,n));\n\n  \t  p += rd * h;\n    }\n\n     vec2 e = vec2(-1,1) * min_dist;\n     vec2 normal = normalize(vec2(\n    \te.xx * map(p + e.xx).w +\n    \te.xy * map(p + e.xy).w +\n    \te.yx * map(p + e.yx).w +\n    \te.yy * map(p + e.yy).w\n    ));\n    vec2 n = p + normal*0.1;\n\n    col += 0.5 * smoothstep(4.0/iResolution.y,0.0,sdLine(uv,0.001,ro,p));\n    col += vec3(0.5,0.0,0.5) * smoothstep(4.0/iResolution.y,0.0,sdLine(uv,0.005,p,n));\n  }\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 34, 34, 77], [79, 79, 108, 108, 133], [134, 134, 162, 162, 236], [237, 237, 282, 282, 406], [408, 408, 432, 432, 477], [479, 479, 496, 496, 871], [873, 873, 923, 923, 2991]], "test": "untested"}
{"id": "dlfGRr", "name": "Recaman Sequence", "author": "oneshade", "description": "Based on this numberphile video [url=https://www.youtube.com/watch?v=FGC5TdIiT9U]The Slightly Spooky Recamán Sequence[/url].", "tags": ["sound", "sequence", "visual", "recaman"], "likes": 15, "viewed": 280, "published": 3, "date": "1671171712", "time_retrieved": "2024-07-30T16:12:39.954803", "image_code": "// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid drawInt(inout vec3 color, in vec3 fontColor, in vec2 uv, in vec2 pos, in vec2 digitSize, in int num, in int precis) {\n    float digitWidth = 0.5 * digitSize.x;\n    if (num < 0) drawChar(color, fontColor, uv, pos, digitSize, 45);\n    pos.x += digitWidth * float(precis);\n    num = abs(num);\n    for (int i=0; i < precis; i++) {\n        int digit = num % 10;\n        drawChar(color, fontColor, uv, pos, digitSize, 48 + digit);\n        num = (num - digit) / 10;\n        pos.x -= digitWidth;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    //drawInt(fragColor.rgb, vec3(1.0), uv, vec2(0.5), vec2(0.1), int(texelFetch(iChannel0, ivec2(min(99, iFrame), 0), 0).x), 3);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n    if (iFrame > 0) {\n        ivec2 addr = ivec2(fragCoord);\n        fragColor = texelFetch(iChannel0, addr, 0);\n        if (iFrame % DELAY == 0) {\n            int n = iFrame / DELAY;\n            if (n < 75) {\n                if (addr.x == n) {\n                    int prev = int(texelFetch(iChannel0, ivec2(n - 1, 0), 0).x);\n                    int cur = prev - n;\n                    if (cur > 0) {\n                        for (int i=0; i < n; i++) {\n                            int histVal = int(texelFetch(iChannel0, ivec2(i, 0), 0).x);\n                            if (cur == histVal) {\n                                cur = prev + n;\n                                break;\n                            }\n                        }\n                    }\n\n                    else {\n                        cur = prev + n;\n                    }\n\n                    fragColor = vec4(cur);\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float sdHalfCircle(in vec2 p, in float r) {\n    p.x = abs(p.x);\n    return p.y > 0.0 ? length(p - vec2(r, 0.0)) : abs(length(p) - r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(1.0);\n    if (iFrame > 0) {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texture(iChannel1, uv);\n        if (iFrame % DELAY == 0) {\n            int n = iFrame / DELAY;\n            if (n < 75) {\n                uv.y -= 0.5;\n                uv.x *= iResolution.x / iResolution.y;\n                float unit = 1.5 / iResolution.y;\n\n                float prev = 0.015 * texelFetch(iChannel0, ivec2(n - 1, 0), 0).x;\n                float cur = 0.015 * texelFetch(iChannel0, ivec2(n, 0), 0).x;\n\n                uv.y *= float(2 * (n % 2) - 1);\n                float newArc = sdHalfCircle(vec2(uv.x - (prev + cur) / 2.0, uv.y), abs(cur - prev) / 2.0);\n                fragColor.rgb = min(fragColor.rgb, smoothstep(0.0, unit, newArc));\n            }\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DELAY 10", "sound_code": "int[] sequence = int[](0, 1, 3, 6, 2, 7, 13, 20, 12, 21, 11, 22, 10, 23, 9, 24, 8, 25, 43, 62, 42, 63, 41, 18, 42, 17, 43, 16, 44, 15, 45, 14, 46, 79, 113, 78, 114, 77, 39, 78, 38, 79, 37, 80, 36, 81, 35, 82, 34, 83, 33, 84, 32, 85, 31, 86, 30, 87, 29, 88, 28, 89, 27, 90, 26, 91, 157, 224, 156, 225, 155, 226, 154, 227, 153);\nvec2 mainSound(int samp, float time) {\n    float noteLength = 0.167;//float(DELAY) * iTimeDelta;\n    float curVal = float(sequence[int(time / noteLength) % 75]);\n    time = mod(time, noteLength);\n\n    float note = sin(6.2831 * 10.0 * curVal * time);\n    note *= exp(-20.0 * noteLength * time);\n\n    float noteCenter = noteLength / 2.0;\n    note *= smoothstep(0.05, 0.0, abs(time - noteCenter) - noteCenter + 0.05);\n\n    return vec2(note);\n}", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 182, 182, 517], [519, 519, 641, 641, 1019], [1021, 1021, 1076, 1076, 1290]], "test": "untested"}
{"id": "DlX3zn", "name": "outlook ship shader", "author": "jonasfrey", "description": "manual", "tags": ["manual"], "likes": 12, "viewed": 200, "published": 3, "date": "1671144421", "time_retrieved": "2024-07-30T16:12:40.749677", "image_code": "\n    \nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat f_sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat f_n_dist_squircle(vec2 o, float n_exp){\n    float n = pow(\n        (\n          pow(abs(o.x), n_exp) +\n          pow(abs(o.y), n_exp)\n        ),\n        abs(1./n_exp)\n    );\n    return n; \n}\nvec2 f_o_rotd(vec2 o, float n_ang){\n    return vec2(\n        cos(n_ang)*o.x - sin(n_ang)*o.y, \n        sin(n_ang)*o.x + cos(n_ang)*o.y\n    );\n}\nfloat f_n_rand(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat f_sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    float k = c.x*q.y - c.y*q.x;\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat f_n_dist_cloud(\n    vec2 o, \n    float n_seed\n){\n\n    float n_its = 10.;\n    float n_dist = 0.;\n    float n_d_min = 1.;\n    float n_len_sum = 0.;\n    o*= 3.;\n    float n_x_min = -1.;\n    float n_x_max = 1.;\n    float n_x_rang = n_x_max - n_x_min;\n    float n_rad = f_n_rand(1.*0.2+n_seed)*0.2+0.2;\n    float n_grad = 0.01;\n    float n_d_mul = 1.;\n    //level 1\n    n_its = 8.;\n    for(float n_it = 0.; n_it<n_its; n_it+=1.){\n        float n_rand_x = (f_n_rand(n_it+n_seed)-0.5)*n_x_rang;\n        float n_rand_y = ((f_n_rand(n_it*1.32+n_seed))*0.2)+.2;\n        float n_len = length(vec2(n_rand_x, n_rand_y)-o);\n        float n_rad = f_n_rand(n_it*0.2+n_seed)*0.2+0.3;\n        float n_grad = 0.01;\n        \n        n_len = smoothstep(n_rad+n_grad, n_rad, n_len);\n        n_len_sum+=n_len*(f_n_rand(n_it*23.23+n_seed))*0.22;\n        n_d_min = min(n_d_min, n_len);\n    }\n    n_its = 10.;\n    //level 2\n    for(float n_it = 0.; n_it<n_its; n_it+=1.){\n        float n_rand_x = (f_n_rand(n_it+n_seed*2.)-0.5)*n_x_rang*0.8;\n        float n_rand_y = ((f_n_rand(n_it*1.32+n_seed*2.))*0.2)+.4;\n        float n_len = length(vec2(n_rand_x, n_rand_y)-o);\n        float n_rad = f_n_rand(n_it*0.2+n_seed)*0.2+0.2;\n        float n_grad = 0.01;\n        n_len = smoothstep(n_rad+n_grad, n_rad, n_len);\n        n_len_sum+=n_len*(f_n_rand(n_it*23.23+n_seed))*0.22;\n        n_d_mul*=n_len*22.;\n        n_d_min = min(n_d_min, n_len);\n    }\n    //level 3\n    n_its = 15.;\n    for(float n_it = 0.; n_it<n_its; n_it+=1.){\n        float n_rand_x = (f_n_rand(n_it+n_seed*4.)-0.5)*n_x_rang*0.5;\n        float n_rand_y = ((f_n_rand(n_it*1.32+n_seed*2.))*0.2)+.8;\n        float n_len = length(vec2(n_rand_x, n_rand_y)-o);\n        float n_rad = f_n_rand(n_it*0.2+n_seed)*0.1+0.1;\n        float n_grad = 0.01;\n        n_len = smoothstep(n_rad+n_grad, n_rad, n_len);\n        n_len_sum+=n_len*(f_n_rand(n_it*23.23+n_seed))*0.22;\n        n_d_mul*=n_len*22.;\n        n_d_min = min(n_d_min, n_len);\n    }\n    \n    float n_sc = 0.2;\n    //float n_caps = f_sdUnevenCapsule(o, vec2(n_x_min,0.0), vec2(n_x_max,0.0), n_sc, n_sc);\n    //float n_caps_smstp = smoothstep(0.11, 0.1, n_caps);\n    float n_white = step(0.01,n_len_sum);\n    return n_white;\n}\nvec3 f_o_col_cloud(vec2 o, float n_seed){\n    float n = f_n_dist_cloud(o, n_seed);\n    return vec3(\n        .5 * n, \n        .5 * n, \n        1. * n\n    );\n}\nvec3 f_o_col_whale(vec2 o){\n    o.x +=0.3;\n    vec2 o_orig = o;\n    float n = 1.;\n    float nl = 1.;\n    float nf = 2.;\n    float nb = 0.1;\n    float n1 = 0.01+nb;\n    float n2 = 0.02+nb;\n    vec2 o_rtd = vec2(o);\n    vec3 o_col = vec3(0.);\n    float n_ang = 0.;\n    \n\n    o = f_o_rotd(o, 0.2);\n    o.x /=nf;\n    n = f_n_dist_squircle(o, 5.);\n    n = smoothstep(n2, n1, n);\n    o.x *=nf;\n    o_col += vec3(n);\n\n\n    nl = n;\n    o = f_o_rotd(o_orig, -0.1);\n    o.x /=nf;\n    o.y *=2.8;\n    o.x +=-0.005;\n    o.x *=0.89;\n    o.y +=nb*3.8;\n    \n    n = f_n_dist_squircle(o, 5.);\n    n = smoothstep(n2, n1, n);\n    n = nl * n + n;\n    o.y /=nf;\n    o_col += vec3(n);\n    o = o_orig;\n    o +=vec2(-0.3,-0.3);\n    n = length(o);\n    n = smoothstep(n2*4., n1*4., n);\n    //o_col += vec3(n*0.5);\n    \n    nl = n;\n    o = o_orig;\n    o +=vec2(-0.2,-.95);\n    n = length(o);\n    n = smoothstep(n1*8.+0.001, n1*8., n);\n    n = nl-n;\n    \n    o_col += vec3(n);\n    //o_col *= 100.;\n    o = o_orig;\n    o +=vec2(-0.76,-.3);\n    n = length(o);\n    n = smoothstep(n1*2.+0.001, n1*2., n);\n    //o_col += vec3(n);\n    \n    nl = n;\n    o = o_orig;\n    o +=vec2(-0.9,-.7);\n    n = length(o);\n    n = smoothstep(n1*4.+0.001, n1*4., n);\n    n = nl-n;\n    o_col += vec3(n);\n    \n    \n    o_col *= 1.;\n    \n    o_col = clamp(vec3(0.9), vec3(1.), o_col);\n    \n    vec3 o_cwhale = vec3(0.288,0.363,0.414);\n    \n    o_col =  vec3(o_col*o_cwhale);\n    \n    \n    nl = n;\n    o = o_orig;\n    o +=vec2(-0.2, 0.05);\n    n = length(o);\n    n = smoothstep(n2*0.3, n1*0.3, n);\n    o_col += vec3(n);\n    \n    nl = n;\n    o = o_orig;\n    o +=vec2(-0.2+(sin(iTime)*0.5)*0.025, (cos(iTime)*0.5+0.5)*0.025+0.0375);\n    n = length(o);\n    n = smoothstep(n2*0.2, n1*0.2, n);\n    o_col -= vec3(n);\n\n    return o_col; \n}\n\nvec3 f_o_col_ship(\n    vec2 o\n){\n    vec3 o_col = vec3(0.);\n    vec3 o_cbrown = vec3(0.486,0.251,0.18);\n    vec3 o_cwhite = vec3(0.9, 0.85, 0.95);\n    float n ;\n    o.y-=0.25;\n    \n    o.y+=0.25;\n    \n    o.y+=0.25;\n    \n    n = f_sdTrapezoid(o, 0.25, 0.5, 0.2);\n        n = smoothstep(0.002, 0.001, n);\n    o_col += n * o_cbrown;\n    \n    o.y-=0.455;\n    n = f_sdTrapezoid(o, 0.02, 0.01, 0.25);\n    n = smoothstep(0.002, 0.001, n);\n    o_col += n * o_cbrown;\n    \n    \n    n = f_sdTrapezoid(o, 0.4, 0.23, 0.21);\n    n = smoothstep(0.002, 0.001, n);\n    o_col += vec3(n*0.8);\n    \n\n    return o_col;\n}\nvec3 f_o_cl_sun(\n    vec2 o\n){\n    float n = length(o);\n    n = smoothstep(0.2, 0.1,n);\n    vec3 o_csun = vec3(0.933,0.824,0.255);\n    \n    return vec3(o_csun * n); \n}\n\nfloat f_n_dist_wave(vec2 o, float n_its){\n\n    \n    vec2 o_trpino_scaled = (o*n_its);\n    vec2 o_trpino_scaled_fract = vec2(fract(o_trpino_scaled.x), o_trpino_scaled.y);\n    vec2 o_it = floor(o_trpino_scaled);\n    \n    float n_dist = length(o_trpino_scaled_fract-0.5);\n\n    return n_dist;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n_ang = 0.;\n    vec2 o_res_nor = vec2(1.) / iResolution.xy;\n    float o_rnx = o_res_nor.x;\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    vec3 o_col = vec3(0.);\n    float n_smth = 10.*o_rnx;\n    float n_h = 0.11;\n    float n_dist_stripe = abs(o_trpino.y);\n    n_dist_stripe = smoothstep(n_h+n_smth, n_h, n_dist_stripe);\n    o_col += vec3(n_dist_stripe*1.);\n    //fragColor = vec4(o_col,1.0);\n    //return;\n    float n_trnsy = -0.03;\n    float n_its = 10.;\n    n_smth = 100.*o_rnx;\n    float n_d = f_n_dist_wave(o_trpino+vec2(-iTime*0.1,0.+n_trnsy), 10.);\n    float n_dist = smoothstep(1.-n_smth, 1., n_d);\n    \n    float n_d2 = f_n_dist_wave(o_trpino+vec2(-iTime*0.12, 0.05+n_trnsy), 8.);\n    float n_dist2 = smoothstep( 1.-n_smth,1., n_d2);\n    \n    \n    vec3 o_col_blue = vec3(0.443,0.651,0.678);\n    vec3 o_col_blue_light = vec3(0.714,0.839,0.843);\n    \n    o_col *= mix(\n        vec3(n_dist2)*o_col_blue_light,\n        vec3(n_dist)*o_col_blue, \n        0.5\n    );\n    \n    //o_col += vec3(n_dist_stripe*.2);\n    \n    float n_b = float(smoothstep(1.-n_smth,  1., n_d2));\n    o_col += vec3(n_b < 1. && n_b > 0.);\n    \n    n_b = float(smoothstep(1.-n_smth,  1., n_d));\n    o_col += vec3(n_b < 1. && n_b > 0.);\n\n    o_col*=vec3(n_dist_stripe);\n    \n    vec2 o_ship = (o_trpino+vec2(0.4, sin(iTime*2.)*0.01-0.02))*10.;\n    n_ang = sin(iTime*2.)*0.1;\n    o_ship = f_o_rotd(o_ship, n_ang);\n    o_col += f_o_col_ship(o_ship);\n    \n    vec2 o_whale = o_trpino;\n    o_whale *= 5.;\n    o_whale += vec2(-sin(iTime*0.2)*1.2, (sin(iTime)*0.5+0.5)*0.2);\n    n_ang = sin(iTime*2.)*0.1;\n    o_whale = f_o_rotd(o_whale, n_ang);\n    o_col += f_o_col_whale(o_whale);\n    \n    \n    vec2 o_sun = o_trpino;\n    o_sun *= 3.;\n    o_sun += vec2(-2., -0.5);\n    n_ang = sin(iTime*2.)*0.1;\n    o_sun = f_o_rotd(o_sun, n_ang);\n    o_col += f_o_cl_sun(o_sun);\n    \n        \n    vec2 o_cloud1 = o_trpino;\n    float n_xt = iTime*0.05;\n    o_cloud1 *= 4.;\n    o_cloud1 += vec2((fract(n_xt)-0.5)*8., -0.1);\n    n_ang = sin(iTime*2.)*0.1;\n    o_cloud1 = f_o_rotd(o_cloud1, 0.);\n    o_col += f_o_col_cloud(o_cloud1, floor(n_xt));\n    \n    \n    fragColor = vec4(o_col, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlX3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 6, 30, 30, 49], [50, 50, 117, 117, 441], [442, 442, 487, 487, 637], [638, 638, 673, 673, 781], [782, 782, 806, 806, 891], [892, 892, 980, 980, 1471], [1473, 1473, 1527, 1527, 3687], [3688, 3688, 3729, 3729, 3845], [3846, 3846, 3873, 3873, 5623], [5625, 5625, 5657, 5657, 6226], [6227, 6227, 6257, 6257, 6394], [6396, 6396, 6437, 6437, 6686], [6687, 6687, 6744, 6744, 9120]], "test": "untested"}
{"id": "clfGzn", "name": "Longer Cosmic ", "author": "mrange", "description": "Inspired by Cosmic by Xor: https://www.shadertoy.com/view/msjXRK\nI am a big fan of high saturated glowin colors.\nSo I really liked Cosmic by Xor.\nMy contribution is making the shader longer while remove the loop", "tags": ["2d"], "likes": 5, "viewed": 248, "published": 3, "date": "1671138928", "time_retrieved": "2024-07-30T16:12:41.614365", "image_code": "// CC0: Longer Cosmic \n//  Inspired by Cosmic by Xor: https://www.shadertoy.com/view/msjXRK\n//  I am a big fan of high saturated glowin colors.\n//  So I really liked Cosmic by Xor.\n//  Making short shaders isn't part of my skill set but I was \n//  thinking I could maybe remove the need for loop for each ring.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n\nconst float ringDistance= 0.05;\nconst float noOfRings   = 30.0;\nconst float glowFactor  = 0.005;\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan_approx(p.y, p.x));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 glow(vec2 pp, float h) {\n  float hh = fract(h*8677.0);\n  float b = TAU*h+0.5*TIME*(hh > 0.5 ? 1.0 : -1.0);\n  float a = pp.y+b;\n  float d = max(abs(pp.x)-0.001, 0.00125);\n  return smoothstep(0.5*ringDistance, 0.2*ringDistance, d)*smoothstep(0.1, 1.0, cos(a))*(cos(a+b+vec3(0,1,2))+vec3(1.0))*glowFactor/d;\n}\n\nvec3 effect(vec2 p) {\n  p += -0.1;\n  // Didn't really understand how the original Cosmic produced the fake projection.\n  // Took part of the code and tinkered\n  p = (p*mat2(1,-1, 2, 2));\n  p += vec2(0.0, 0.33)*length(p);\n \n  vec2 pp = toPolar(p);\n  vec2 pp0 = pp;\n  float rn0 = mod1(pp0.x, ringDistance); \n  vec2 pp1 = pp;\n  pp1.x -= ringDistance*0.5;\n  float rn1 = mod1(pp1.x, ringDistance); \n  float d0 = abs(pp0.x);\n  float d1 = abs(pp1.x);\n  vec3 col = vec3(0.0);\n  float h0 = hash(rn0*1E5+3.0);\n  float h1 = hash(rn1+4.0);\n  col += glow(pp0, h0)*step(1.0, rn0)*step(rn0, noOfRings);\n  col += glow(pp1, h1)*step(rn1, noOfRings);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 645, 682, 682, 789], [791, 879, 901, 901, 952], [954, 1040, 1079, 1079, 1204], [1206, 1266, 1288, 1288, 1336], [1338, 1338, 1367, 1367, 1649], [1651, 1651, 1672, 1672, 2299], [2301, 2301, 2358, 2358, 2551]], "test": "untested"}
{"id": "DtfGzn", "name": "dvg_Moving_Tiles", "author": "david4jsus", "description": "Learning about tiling is fun.", "tags": ["tiled", "animation", "learning", "moving", "tile"], "likes": 3, "viewed": 205, "published": 3, "date": "1671138484", "time_retrieved": "2024-07-30T16:12:42.467086", "image_code": "#define PI 3.14159265358979323846\n\nvec2 Rotate2D( vec2 uv, float angle ) {\n\n    // Pivot point for rotation at the center\n    uv -= 0.5;\n    \n    // Apply rotation matrix\n    uv =\n        mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n        ) * uv;\n    \n    // Move back to origin point\n    uv += 0.5;\n    \n    // Return rotated space\n    return uv;\n}\n\nvec2 Tile1( vec2 uv, float zoom, vec2 offset ) {\n\n    // \"Zoom\" of tiling\n    uv *= zoom;\n    \n    // Tiling offset\n    uv += step(1.0, mod(uv.yx, 2.0)) * offset;\n    \n    // Return tiled space\n    return fract(uv);\n}\n\nvec2 Tile2( vec2 uv, float zoom, vec2 offset ) {\n\n    // \"Zoom\" of tiling\n    uv *= zoom;\n    \n    // Tiling offset\n    uv.x += step(1.0, mod(uv.y, 2.0)) * offset.x;\n    \n    // Return tiled space\n    return fract(uv);\n}\n\nvec3 Rectangle( vec2 uv, float x, float y, float width, float height ) {\n\n    // Results in 1.0 value for pixels inside borders\n    vec2 borders = step(vec2(x, y), uv) * 1.0 - step(vec2(x + width, y + height), uv);\n    \n    // Return vec3 with 1.0 inside borders\n    return vec3(borders.x * borders.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // Then adjust aspect ratio\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv2 = fragCoord/iResolution.xy;\n    uv2.x *= iResolution.x / iResolution.y;\n    \n    // Divide both spaces (tiling)\n    uv = Tile1(uv, 4.0, vec2(cos(iTime) + 0.5));\n    uv2 = Tile2(uv2, 16.0, vec2(sin(iTime) + 0.5));\n    \n    // Rotate the first space 45 degrees\n    uv = Rotate2D(uv, PI * 0.25);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n    vec3 col2 = 0.5 + 0.5 * cos(iTime + uv2.xyx + vec3(0, 2, 4));\n    \n    // Draw a square on each space\n    vec3 square = Rectangle(uv, 0.2, 0.2, 0.6, 0.6);\n    col *= square;\n    vec3 square2 = Rectangle(uv2, 0.0, 0.0, 0.7, 0.7);\n    col2 *= square2;\n\n    // Output to screen\n    fragColor = vec4(col * col2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 74, 121, 384], [386, 386, 434, 459, 603], [605, 605, 653, 678, 825], [827, 827, 899, 954, 1131], [1133, 1133, 1190, 1272, 2076]], "test": "untested"}
{"id": "mdjXDd", "name": "OSTSEE", "author": "pashafx", "description": "pashaFX", "tags": ["music"], "likes": 2, "viewed": 253, "published": 3, "date": "1671126611", "time_retrieved": "2024-07-30T16:12:43.211096", "image_code": "// Fork of \"Alien Rose\" by oseday. https://shadertoy.com/view/csjSWd\n// 2022-12-15 17:49:32\n\nstruct rayresult{\n    vec3 o; //origin\n    vec3 v; //direction\n    float dist; //distance\n};\n\n#define EPSILON 0.0005\n#define PI 3.1415928\n\nmat4 cam = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    0,0,0,1\n);\n\nmat4 addmv(mat4 mat, vec3 v){\n    mat4 n = mat;\n    n[3]=n[3]+vec4(v,0);\n    return n;\n}\n\nmat4 mat4v(vec3 v){\n    return mat4(\n        1,0,0,v.x,\n        0,1,0,v.y,\n        0,0,1,v.z,\n        0,0,0,1\n    );\n}\n\nvec3 matpos(mat4 mat){\n    return mat[3].xyz;\n}\n\nconst float planedist = 1.00;\n\n\nfloat map(vec3 p)\n{\n    float t = iTime;\n\n    vec3 b = 1.000*sin(1.*p.zxy + vec3(t,0.,0.));\n    \n    b = rotateabout(sin(b), p, length(p));\n    \n    b += 0.500*sin(8.0*b.zxy);\n    b += 0.225*sin((sin(t*0.975+5.345)+1.25) * 8.2*b.zxy);\n    \n    b = rotateabout(-b, p, length(p)+2.);\n    \n    b += 0.120*sin((sin(t*0.812+2.891)+0.23) * 16.8*b.zxy);\n    \n    return length(b*length(p*p)) * 0.009;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nconst int kRaymarchIterations = 1024;\nconst float mapddivisor = 1.100;\n\nconst vec3 sundir = normalize(vec3(0,1,1));\nconst vec3 suncol = vec3(0.8,0.8,0.8);\nconst vec3 objcol = vec3(0.9,0.9,0.8);\n\nvec3 manager(rayresult io){\n\n    vec3 skycol = texture(iChannel0,io.v).xyz;\n    \n\tfloat t = -1.00;\n    \n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n        vec3 pos = io.o + io.v * t;\n    \n\t\tfloat d = map(pos);\n        \n        if (d > 10.) {return skycol;}\n        \n\t\tif(d < 0.01){\n            \n            vec3 n = estimateNormal(pos);\n\n            float sundot = dot(n,sundir);\n            \n            vec3 col = suncol * sundot + objcol;\n                        \n            vec3 sdir = reflect(io.v,n);\n            col *= texture(iChannel0,sdir).xyz;\n            \n\t\t\treturn col;\n\t\t}\n        \n        t += d/mapddivisor;\n\t}\n    \n    return skycol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tick = iTime/5.;\n    \n    vec2 mouseuv = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx*2.;\n\n    mat4 ncam = cam\n        *build_transform(vec3(0,0,0),vec3(0,-mouseuv.x*PI + tick,0))\n        *build_transform(vec3(0,0,0),vec3(-mouseuv.y*PI,0,0))\n        ;\n        \n    ncam = ncam\n        *build_transform(vec3(0,0,-8.),vec3(0,0,0))\n        ;\n    \n    vec3 campos = matpos(ncam);\n        \n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.xx*2.;\n\n    vec3 v = normalize(uv.x*ncam[0].xyz+uv.y*ncam[1].xyz+ncam[2].xyz*planedist);\n\n    vec3 color = vec3(0,0,0);\n\n    rayresult ray;\n    \n    ray.o=campos;\n    ray.v=v;\n    ray.dist=0.10;\n\n    color += manager(ray);\n\n    color = clamp(color,0.,1.);\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31289, "src": "https://soundcloud.com/pashafx/ostsee", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "mat4 build_transform(vec3 pos, vec3 ang) \n{\n  float cosX = cos(ang.x);\n  float sinX = sin(ang.x);\n  float cosY = cos(ang.y);\n  float sinY = sin(ang.y);\n  float cosZ = cos(ang.z);\n  float sinZ = sin(ang.z);\n\n  mat4 m;\n\n  float m00 = cosY * cosZ + sinX * sinY * sinZ; \n  float m01 = cosY * sinZ - sinX * sinY * cosZ; \n  float m02 = cosX * sinY;\n  float m03 = 0.0;\n  \n  float m04 = -cosX * sinZ; \n  float m05 = cosX * cosZ; \n  float m06 = sinX;\n  float m07 = 0.0;\n  \n  float m08 = sinX * cosY * sinZ - sinY * cosZ;\n  float m09 = -sinY * sinZ - sinX * cosY * cosZ;\n  float m10 = cosX * cosY;\n  float m11 = 0.0;\n  \n  float m12 = pos.x;\n  float m13 = pos.y;\n  float m14 = pos.z;\n  float m15 = 1.0;\n\n  /*\n  //------ Orientation ---------------------------------\n  m[0] = vec4(m00, m01, m02, m03); // first column.\n  m[1] = vec4(m04, m05, m06, m07); // second column.\n  m[2] = vec4(m08, m09, m10, m11); // third column.\n\n  //------ Position ------------------------------------\n  m[3] = vec4(m12, m13, m14, m15); // fourth column.\n  */\n\n  //------ Orientation ---------------------------------\n  m[0][0] = m00; // first entry of the first column.\n  m[0][1] = m01; // second entry of the first column.\n  m[0][2] = m02;\n  m[0][3] = m03;\n  \n  m[1][0] = m04; // first entry of the second column.\n  m[1][1] = m05; // second entry of the second column.\n  m[1][2] = m06;\n  m[1][3] = m07;\n\n  m[2][0] = m08; // first entry of the third column.\n  m[2][1] = m09; // second entry of the third column.\n  m[2][2] = m10;\n  m[2][3] = m11;\n  \n  //------ Position ------------------------------------\n  m[3][0] = m12; // first entry of the fourth column.\n  m[3][1] = m13; // second entry of the fourth column.\n  m[3][2] = m14;\n  m[3][3] = m15;\n\n  return m;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotateabout(vec3 vec, vec3 axis, float angle) {\n    return (rotationMatrix(axis, angle) * vec4(vec, 1.0)).xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 333, 333, 392], [394, 394, 413, 413, 512], [514, 514, 536, 536, 561], [595, 595, 614, 614, 990], [993, 993, 1022, 1022, 1302], [1499, 1499, 1526, 1526, 2154], [2156, 2156, 2213, 2213, 2958]], "test": "untested"}
{"id": "ms2XWd", "name": "Lonely Batman", "author": "StanleySweet", "description": "A simple flat shaded Batman I made based on Z0rg's work.", "tags": ["2d", "batman", "creativecommons"], "likes": 16, "viewed": 280, "published": 3, "date": "1671123058", "time_retrieved": "2024-07-30T16:12:43.960094", "image_code": "// SPDX-License-Identifier: CC-BY-NC-SA-4.0\n// SPDX-FileCopyrightText: © 2022 Sébastien Maire\n// SPDX-FileCopyrightText: © 2022 Stanislas Daniel Claude Dolcini\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat lenny(vec2 v) { return abs(v.x)+abs(v.y); }\n\nfloat _cir(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat _nimal(vec2 uv)\n{\n    float timeOffset = 0.0075*sin(uv.y*30.-iTime* 0.5);\n    uv.x+=sin(uv.y*25.+iTime*2.)*0.01*sat(uv.y*5.);\n    vec2 tuv = (uv-vec2(0.14+timeOffset,-.015))*  r2d(3.3*PI);\n    tuv.x = abs(tuv.x);\n    tuv = (tuv-vec2(-.07,0.));\n    vec2 tuv2 = -((uv+vec2(0.04+timeOffset,0.015)) * r2d(1.7*PI));\n    tuv2.x = abs(tuv2.x);\n    tuv2 = (tuv2-vec2(-.07,0.));\n\n\n    uv -= vec2(0.05,-.04);\n    float body = 10.;\n    float anhears = 0.1;\n    vec2 offhears = vec2(0.01,0.);\n    body = min(body, _sqr(((uv+offhears)*r2d(anhears)), vec2(.025,.07)));\n    body = min(body, _sqr(((uv-offhears)*r2d(-anhears)), vec2(.025,.07)));\n    body = max(body, -_sqr(((uv-vec2(0.,.08))*r2d(PI/4.)), vec2(.03, .03)));\n    uv.x = abs(uv.x);\n    float tail = _cir(tuv, .11);\n    body = min(body, tail);\n    float tail2 = _cir(tuv2, .11);\n    body = min(body, tail2);\n\n\n    float carveCircle = _cir(uv - vec2(0.17,0.01), 0.065);\n    body = max(body, -carveCircle);\n    carveCircle = _cir(uv - vec2(0.09,-0.07), 0.066 );\n    body = max(body, -carveCircle);\n\n    return body;\n}\n\nfloat _eyes(vec2 uv)\n{\n    uv.x+=sin(uv.y*25.+iTime*2.)*0.01*sat(uv.y*5.);\n    uv -= vec2(0.05,-.012);\n    float body = 1.;\n    float square_width = 0.014;\n    float square_height = 0.007;\n    body = min(body, _sqr(((uv-vec2(0.0, 0.01))* r2d(0.0)), vec2(square_width, square_height)));\n    body = max(body, -_sqr(((uv-vec2(0.0, 0.02))*r2d(0.0)), vec2(square_width * 6.0,  0.019 )));\n    body = max(body, -_sqr(((uv-vec2(0.0, 0.02))*r2d(PI)), vec2(square_width * 0.9,  0.018 * 2.0)));\n    float square_width_01 = 0.045;\n    body = max(body, -_sqr(((uv-vec2(0.0, 0.05))*r2d(PI/4.)), vec2(square_width_01, square_width_01)));\n\n    return body;\n}\n\n\nfloat _star(vec2 p, vec2 s)\n{\n    float a = _sqr(p, s.xy);\n    float b = _sqr(p, s.yx);\n    return min(a, b);\n}\n\nfloat _stars(vec2 uv, vec2 szu)\n{\n    uv = r2d(PI/4.) * uv;\n    uv += vec2(0.5,0.5);\n    vec2 ouv = uv;\n    float th = 0.002;\n    vec2 rep = vec2(0.1,0.1);\n\n    vec2 idx = floor((uv+rep*.5)/rep);\n\n    uv = mod(uv+rep*.5, rep)-rep*.5;\n    float sz = sat(sin(idx.x*5.+idx.y+iTime))*sat(length(ouv*2.)-.5);\n    return _star(uv, vec2(20.*th, th)*.15*sz*szu);\n}\n\n\n\nvec3 rdr(vec2 uv)\n{\n    float shp = 400.;\n    vec3 background = vec3(0.431,0.114,0.647)*.2;\n\n    background = mix(background, vec3(1.000,0.761,0.239), 1.-sat(_stars(uv, vec2(1.,1.0))*shp));\n\n    vec3 sunCol = vec3(0.239,0.761,1.000);\n    vec3 foregroundBack = vec3(0.345,0.125,0.494);\n\n    vec3 foreground;\n\n    float sun = _cir(uv, .02);\n    float sstp = 0.05;\n    sun = floor(sun/sstp)*sstp;\n    foreground = mix(foregroundBack, sunCol, 1.-sat(sun*4.));\n\n    float mount = uv.y-asin(sin(uv.x*25.))*.01+.1;\n    foreground = mix(foreground, foreground*.3, 1.-sat(mount*shp*.5));\n\n    float mount2 = uv.y-(sin(uv.x*25.+2.))*.05+.1;\n    foreground = mix(foreground, foreground*.5, 1.-sat(mount2*shp*.1));\n\n\n    float hill = _cir(uv-vec2(0.,-.9), .8);\n    foreground = mix(foreground, vec3(0.,0.,0.), 1.-sat(hill*shp));\n\n    float nanimal = _nimal(uv);\n    foreground = mix(foreground, vec3(0.,0.,0.), 1.-sat(nanimal*shp));\n\n    float eyes = _eyes(uv);\n    vec3 eyecolor = vec3( 0., 0.6, 0.);\n    foreground = mix(foreground, eyecolor * 1.2, 0.35 -clamp( sat(eyes * shp * 0.15), 0.0, 0.35));\n    foreground = mix(foreground, eyecolor, 1.0 - max(sat(eyes * shp * 0.6), 0.6));\n    foreground = mix(foreground, eyecolor, 1.0 - max(sat(eyes * shp * 0.6), 0.6));\n    foreground = mix(foreground, eyecolor, 1.0 - max(sat(eyes * shp * 0.6), 0.6));\n\n    float mask = _cir(uv, .25);\n\n    vec3 col = mix(background, foreground, 1.-sat(mask*shp));\n    col += (1.-sat(length(uv*3.)))*sunCol*.7;\n    float flicker = .1;\n    col += pow(1.-sat(lenny(uv*vec2(1.,2.))),5.)*sunCol*.7\n        *mix(.95,1., sat(sin(iTime*25.)*2.+sin(iTime*40.)));\n    \n    col = mix(col, vec3(1.000,0.761,0.239), sat(length(uv)-.1)*(1.-sat(_stars(uv*.8, vec2(5.))*shp*.3))*.7);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    \n    col *= mix(-1.,1.,1.-sat(lenny(uv*2.)-.5));\n    col = sat(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2XWd.jpg", "access": "api", "license": "unknown-spdx", "functions": [[220, 220, 239, 239, 292], [293, 293, 314, 314, 342], [344, 344, 374, 374, 401], [403, 403, 431, 431, 482], [484, 484, 507, 507, 1551], [1553, 1553, 1575, 1575, 2195], [2198, 2198, 2227, 2227, 2309], [2311, 2311, 2344, 2344, 2667], [2671, 2671, 2690, 2690, 4426], [4429, 4429, 4486, 4486, 4688]], "test": "untested"}
{"id": "cdsSDS", "name": "caspar-klug sdf", "author": "remaindeer", "description": "- sdf for the equilateral triangular facet of capsid structures\n- sdf is a bound due to infinite plane clipping via opIntersection (max)", "tags": ["sdf", "tile", "construction", "schwarz", "wythoff", "casparklug"], "likes": 17, "viewed": 325, "published": 3, "date": "1671116745", "time_retrieved": "2024-07-30T16:12:44.812814", "image_code": "float scene(vec2 p) {\n    // Caspar-Klug parameters\n    float h = mod(round((iTime + 3.0 / 2.0) / 2.0), 3.0) + 1.0;\n    float k = mod(round((iTime + 6.0 + 3.0 / 2.0) / 3.0), 3.0);\n    \n    // Wythoff parameters\n    //// pick point within fundamental triangle\n    //// https://mathworld.wolfram.com/TrianglePointPicking.html\n    //// http://extremelearning.com.au/evenly-distributing-points-in-a-triangle/\n    float a1 = 0.5 + sin(0.25 * iTime) / 2.0;\n    float a2 = 0.5 + cos(2.00 * iTime) / 2.0;\n    //// generator point\n    vec2 g = (((a1 + a2) < 1.0) ? (a1 * v3 + a2 * v2) : ((1.0 - a1) * v3 + (1.0 - a2) * v2));\n    //// mirror\n    float m = mod(round((iTime - 2.0 / 2.0) / 2.0), 10.0);\n    //// wall\n    float w = 0.0;\n    \n    // distance\n    float s = 1.0 / length(mat2(1.5, cos30, 0.0, 2.0 * cos30) * vec2(h, k));\n    float d = sdCasparKlugFacet(p / s, h, k, g, m, w, 0.05) * s;\n    // float d = sdSchwartz632Plane(p, g, m, 0.05);\n    // d = opUnion(d, opOnion(sdCircle(p + vec2(+0.5, +(sqrt3 / 6.0)), 0.05), 0.0005));\n    // d = opUnion(d, opOnion(sdCircle(p + vec2(-0.5, +(sqrt3 / 6.0)), 0.05), 0.0005));\n    // d = opUnion(d, opOnion(sdCircle(p + vec2(+0.0, -(sqrt3 / 3.0)), 0.05), 0.0005));\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // uv\n\tvec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 q = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    p *= 1.5;\n    q *= 1.5;\n    p = rotmat2(iTime * -0.25) * p;\n    q = rotmat2(iTime * -0.25) * q;\n    \n    // dist\n    float d = scene(p);\n    \n    // color\n    vec3 col = vec3(0);\n    vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n  \n    col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-24.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(240.0 * d);\n    \n    {\n        if (iMouse.z > 0.001) {\n            float d = scene(q);\n            col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - q) - abs(d)) - 0.0005));\n            col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - q) - 0.0015));\n        }\n    }\n    \n    float aa = 2.0 / iResolution.y;\n    col = max(col, rnd * smoothstep(aa, 0.0, d));\n    \n    \n    \n    // output\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n#define v1 vec2(0, 0)\n#define v2 vec2(0, cos30)\n#define v3 vec2(0.5, cos30)\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat facetAltitude(float h, float k) {\n    return sqrt3 / 2.0 * length(mat2(1.5, cos30, 0.0, 2.0 * cos30) * vec2(h, k));\n}\n\nvec2 intersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    // http://paulbourke.net/geometry/pointlineplane/\n    float d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;\n    // float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;\n    return p1 + ua * (p2 - p1);\n}\n\nfloat opIntersection( float d1, float d2 ) { \n    // https://iquilezles.org/articles/distfunctions2d/\n    return max(d1, d2); \n}\n\nfloat opUnion(float d1, float d2) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return min(d1, d2); \n}\n\nfloat opOnion(in float sdf, in float thickness) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return abs(sdf) - thickness;\n}\n\nvec2 opRep(in vec2 p, in vec2 c) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 t0 = p  - p0, t1 = p  - p1, t2 = p  - p2;\n    vec2 pq0 = t0 - e0 * clamp(dot(t0, e0)/ dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = t1 - e1 * clamp(dot(t1, e1)/ dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = t2 - e2 * clamp(dot(t2, e2)/ dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x );\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (t0.x * e0.y - t0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (t1.x * e1.y - t1.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (t2.x * e2.y - t2.y * e2.x)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdEquilateralTriangle(in vec2 p, in float r) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    // r is half of the side\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0 * r, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nvec2 snub632() {\n    // fermat point\n    vec2 pf = intersection(vec2(-0.75, cos30 / 2.0), v3, vec2(1, 0), v2);\n    // reflect over side (y-axis)\n    vec2 q1 = vec2(-1.0 * pf.x, pf.y);\n    // vec2 q2 = vec2(pf.x, pf.y + 2.0 * (cos30 - pf.y));\n    // project to hypotenuse then double to obtain reflection\n    vec2 q3 = dot(pf, v3) / dot(v3, v3) * v3;\n    q3 = pf + 2.0 * (q3 - pf);\n    // snub point is at half the hypotenuse of the new right triangle (Thales's theorem)\n    return q1 + ((q3 - q1) / 2.0);\n}\n\nfloat sdSchwartz632Snub(vec2 p, float t) {\n    // p the uv\n    // t the thickness\n    // take advantage of symmetry\n    float a = atan(p.y, p.x);\n    float M = floor(mod(degrees(a) - 30.0, 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // central point\n    float d = sdCircle(p, t);\n    // snub point\n    vec2 g = snub632();\n    // rotate\n    vec2 G = rotmat2(radians(180.0)) * (g - v2) + v2;\n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdSegment(p, g, G) - t);\n    // fix by https://www.shadertoy.com/user/mla\n    d = opUnion(d, sdSegment(rotmat2(radians(-60.0)) * p, g, G) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(-60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+120.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+180.0)) * (G - g) + g) - t);\n    return d;\n}\n\nfloat sdSchwartz632DualSnub(vec2 p, float t) {\n    // p the uv\n    // t the thickness\n    // snub point\n    vec2 g = snub632();\n    // take advantage of symmetry\n    float a = atan(p.y, p.x) - (atan(g.y, g.x) - radians(60.0));\n    float M = floor(mod(degrees(a), 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // central point\n    float d = sdCircle(p, t);\n    float R3 = sqrt3 / 2.0 * length(g);\n    float r3 = sqrt3 / 6.0 * length(g); \n    vec2 n0 = normalize(rotmat2(radians(+30.0)) * g);\n    vec2 n1 = (R3 + r3) * n0;\n    vec2 n2 = n1 + rotmat2(radians(-60.0)) * (2.0 * r3 * n0);\n    vec2 n3 = n1 + rotmat2(radians(+60.0)) * (2.0 * r3 * n0);\n    d = opUnion(d, sdSegment(p, v1, n1) - t);\n    d = opUnion(d, sdSegment(p, n1, n2) - t);\n    d = opUnion(d, sdSegment(p, n1, n3) - t);\n    d = opUnion(d, sdSegment(p, n2, n1 + n2 + -n3) - t);\n    d = opUnion(d, sdSegment(p, n3, n1 + n3 + -n2) - t);\n    return d;\n}\n\nfloat sdSchwartz632(vec2 p, vec2 g, float m, float w, float t) {\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // w the wall toggle\n    // t the thickness\n    // snub case\n    if (m == 8.0) {\n        return sdSchwartz632Snub(p, t);\n    }\n    // snub case\n    else if (m == 9.0) {\n        return sdSchwartz632DualSnub(p, t);\n    }\n    p = abs(p);\n    if (p.y < 2.0 * cos30 * p.x) {\n        p = rotmat2(radians(-60.0)) * p;\n        p = abs(p);\n    }\n    float d = sdCircle(p, t); \n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdCircle(p - g, t));\n    d = bool(mod(m, 2.0)) ? opUnion(d, sdSegment(p, g, vec2(0, g.y)) - t) : d;\n    vec2 v = v3 - v1;\n    d = bool(mod(floor(m / 2.0), 2.0)) ? opUnion(d, sdSegment(p, g, dot(g, v) / dot(v, v) * v) - t) : d;\n    d = bool(mod(floor(m / 4.0), 2.0)) ? opUnion(d, sdSegment(p, g, vec2(g.x, v2.y)) - t) : d;\n    d = bool(mod(w, 2.0)) ? opUnion(d, sdSegment(p, v1, v2) - t) : d;\n    d = bool(mod(floor(w / 2.0), 2.0)) ? opUnion(d, sdSegment(p, v1, v3) - t) : d;\n    d = bool(mod(floor(w / 4.0), 2.0)) ? opUnion(d, sdSegment(p, v2, v3) - t) : d;\n    return d;\n}\n\nfloat sdSchwartz632Plane(vec2 p, vec2 g, float m, float w, float t) {\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // w the wall toggle\n    // t the thickness\n    vec2 v = vec2(3.0, 2.0 * cos30);\n    vec2 p1 = opRep(p, v);\n    vec2 p2 = opRep(p + v / 2.0, v);\n    return opUnion(\n        sdSchwartz632(p1, g, m, w, t),\n        sdSchwartz632(p2, g, m, w, t)\n    );\n}\n\nfloat sdCasparKlugFacet(vec2 p, float h, float k, vec2 g, float m, float w, float t) {\n    // @p vec2 the uv\n    // @h float the h-parameter (steps on plane)\n    // @k float the k-parameter (steps on plane after 60-degree turn)\n    // @g vec2 the generator point for Wythoff construction\n    // @m float the bits representing the activated mirrors for Wythoff construction\n    // @w float the bits representing the fundamental triangle wall display\n    // @t float the edge thickness\n    mat2 b = mat2(1.5, cos30, 0.0, 2.0 * cos30);\n    // vec2 t1 = vec2(0);\n    vec2 t2 = b * vec2(h, k);\n    vec2 t3 = rotmat2(radians(-60.0)) * t2;\n    \n    float s = length(t2); // side\n    // vec2 c = (t1 + t2 + t3) / 3.0; // centroid\n    vec2 c = (t2 + t3) / 3.0; // centroid\n    \n    float d = sdSchwartz632Plane((rotmat2(-atan(t2.y, t2.x)) * p) + c, g, m, w, t);\n    // d = opUnion(d, opOnion(sdCircle(p, 1.5 * t), t)); \n    // d = opUnion(d, opOnion(sdEquilateralTriangle(p, s / 2.0), t));\n    d = opIntersection(d, sdEquilateralTriangle(p, s / 2.0));\n\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdsSDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 51, 1218], [1220, 1220, 1275, 1285, 2250]], "test": "untested"}
{"id": "cdjSDd", "name": "my four raytracer", "author": "SONENEIS", "description": "my four raytracer!", "tags": ["raytracing", "ray", "shadow", "light", "sphere", "green", "reflections", "box", "occlusion", "flare", "chess", "dark", "raycaster", "softshadow", "crosshair"], "likes": 4, "viewed": 350, "published": 3, "date": "1671108482", "time_retrieved": "2024-07-30T16:12:45.978698", "image_code": "const float pi = 3.14159265;\nconst float tau = pi * 2.0;\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\nfloat dot2(vec3 v){return dot(v,v);}\n\nfloat hash(float v){return fract(sin(v*dot(vec2(737.873,777.873),vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec2 uv){return fract(sin(dot(uv,vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec3 uv){return fract(sin(dot(uv,vec3(173.873,515.526,726.873)))*82723.782);}\n\n#define BUFFERS\n\n// transformation matrices\nmat4 mDefault(){\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateX(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat4(\n\t\tvec4(c,-s,0,0),\n\t\tvec4(s,c,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateY(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat4(\n\t\tvec4(c,0,s,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(-s,0,c,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateZ(float a){\n\tfloat s=sin(a),c=cos(a);\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,c,-s,0),\n\t\tvec4(0,s,c,0),\n\t\tvec4(0,0,0,1)\n\t);\n}\nmat4 mRotateAll(float x,float y,float z){\n\treturn mRotateX(x) * mRotateY(y) * mRotateZ(z);\n}\nmat4 mTranslate(vec3 p){\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(p.x,p.y,p.z,1)\n\t);\n}\n\nstruct Hit{\n\tint id;\n\tfloat d;\n\tint type; // intersect primitive id\n\tvec3 nor;\n\tvec3 v3a;\n\tvec4 v4a;\n\tmat4 imat;\n\tmat4 mat;\n};\nstruct Hit2{\n\tint type;\n\tint id;\n\tvec3 v3a;\n\tvec4 v4a;\n\tmat4 imat;\n\tmat4 mat;\n};\n\nHit iUnion(Hit a,Hit b){\n if(b.d > 0.0 && b.d < a.d) return b;\n else return a;\n}\n\n// raytracer primitives\n\nHit iPlane(int id,vec3 ro,vec3 rd,vec4 pln){\n  Hit hit;\n  hit.d = -(dot(ro,normalize(pln.xyz))+pln.w)/dot(rd,pln.xyz);\n  hit.id = id;\n  hit.type = 0;\n  hit.v4a = pln;\n  return hit;\n}\n\nHit iSphere(int id,vec3 ro,vec3 rd,vec4 sph){\n\tHit hit;\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\thit.d = -b - sqrt(h);\n\tif(h < 0.0) hit.d = -1.0;\n\thit.id = id;\n  hit.type = 1;\n\thit.v4a = sph;\n  return hit;\n}\n\nHit iBox(int id,vec3 ro,vec3 rd,vec3 size,mat4 mat,mat4 imat){\n  rd = (imat*vec4(rd,0.0)).xyz;\n\tro = (imat*vec4(ro,1.0)).xyz;\n\tHit hit;\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*size;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x,t1.y),t1.z);\n\tfloat tF = min(min(t2.x,t2.y),t2.z);\n\thit.d = tN;\n\tif(tN>tF || tF<0.0) hit.d = -1.0;\n\thit.nor = (tN>0.0) ? step(vec3(tN),t1) : step(t2,vec3(tF));\n\thit.nor *= -sign(rd);\n\thit.nor = (mat*vec4(hit.nor,0.0)).xyz;\n\thit.id = id;\n\thit.type = 2;\n\thit.v3a = size;\n\thit.imat = imat;\n\thit.mat = mat;\n\treturn hit;\n}\n\n// call of the primitives to the scene\n\nHit2 objPlane(int id,vec4 pln){\n\tHit2 obj;\n\tobj.type = 0;\n\tobj.id = id;\n\tobj.v4a = pln;\n  return obj;\n}\n\nHit2 objSphere(int id,vec4 sph){\n\tHit2 obj;\n\tobj.type = 1;\n\tobj.id = id;\n\tobj.v4a = sph;\n  return obj;\n}\n\nHit2 objBox(int id,vec3 size,mat4 mat){\n\tHit2 obj;\n\tobj.type = 2;\n\tobj.id = id;\n\tobj.v3a = size;\n\tobj.imat = inverse(mat);\n\tobj.mat = mat;\n  return obj;\n}\n\n//scene\nconst int scnLen = 13;\nHit2[scnLen] scn;\nvoid initScene(){\n\tscn[0] = objPlane(0,vec4(0.0,1.0,0.0,1.0));\n\tscn[1] = objSphere(1,vec4(0.0,0.0,0.0,1.0));\n\tscn[2] = objSphere(2,vec4(1.0,-0.5,1.25,0.5));\n\tscn[3] = objSphere(3,vec4(-0.75,-0.75,1.0,0.25));\n\tscn[4] = objSphere(4,vec4(sin(-iTime*2.0),sin(iTime*0.5),cos(-iTime),0.3));\n  scn[5] = objSphere(3,vec4(0.0,3.0,0.0,0.5));\n  scn[6] = objSphere(2,vec4(sin(iTime*0.07)*1.5,0.8,cos(iTime*0.07)*1.5,0.25));\n\tscn[7] = objBox(5,vec3(0.5,0.25,0.75),mTranslate(vec3(1.75,-0.5,-1.0))*mRotateAll(iTime,iTime,iTime));\n\tscn[8] = objBox(5,vec3(1.0,0.25,1.0),mTranslate(vec3(3.0,-0.75,1.5))*mRotateY(iTime*0.5));\n\tscn[9] = objPlane(6,vec4(0.0,0.0,1.0,4.5));\n\tscn[10] = objBox(6,vec3(1.0),mTranslate(vec3(-3.5,0.0,-3.5)));\n\tscn[11] = objPlane(6,vec4(1.0,0.0,0.0,4.5));\n\tscn[12] = objBox(6,vec3(0.5),mTranslate(vec3(1.0,-0.5,-2.0)));\n}\n\nHit raycast(vec3 ro,vec3 rd){\n\tHit h;\n\th.d = 9999999999999999999.9;\n\th.id = -1;\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n  \tif(scn[i].type == 0){ //plane\n  \t\th = iUnion(h,iPlane(s.id,ro,rd,s.v4a));\n  \t}else if(scn[i].type == 1){ //sphere\n  \t\th = iUnion(h,iSphere(s.id,ro,rd,s.v4a));\n  \t}else if(scn[i].type == 2){ //box\n  \t\th = iUnion(h,iBox(s.id,ro,rd,s.v3a,s.mat,s.imat));\n  \t}\n  }\n\n\treturn h;\n}\n\nvec3 getNormal(Hit h,vec3 p){\n\tvec3 nor = vec3(0.0);\n\n  if(h.type == 0){ //plane\n  \tnor = h.v4a.xyz;\n  }else if(h.type == 1){ //sphere\n  \tnor = (p-h.v4a.xyz) / h.v4a.w;\n  }else if(h.type == 2){ //sphere\n  \tnor = h.nor;\n  }\n\n\treturn normalize(nor);\n}\n\nfloat getOcc(Hit h,vec3 n,vec3 p){\n  float res = 1.0;\n  float occBox = 1.0;\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n\n  \tif(scn[i].type == 2){ //box\n  \t  float occ = 0.0;\n\n      vec3 pp = (s.imat*vec4(p,1.0)).xyz;\n      vec3 nn = (s.imat*vec4(n,0.0)).xyz;\n\n      vec3 f = s.v3a * sign(pp);\n      vec3 i = sign(s.v3a - abs(pp));\n\n      vec3 v0 = normalize(vec3( 1.0, 1.0,-1.0)*f - pp);\n      vec3 v1 = normalize(vec3( 1.0, i.x, i.x)*f - pp);\n      vec3 v2 = normalize(vec3( 1.0,-1.0, 1.0)*f - pp);\n      vec3 v3 = normalize(vec3( i.z, i.z, 1.0)*f - pp);\n      vec3 v4 = normalize(vec3(-1.0, 1.0, 1.0)*f - pp);\n      vec3 v5 = normalize(vec3( i.y, 1.0, i.y)*f - pp);\n\n      occ += dot(nn,normalize(cross(v0,v1)))*acos(dot(v0,v1));\n      occ += dot(nn,normalize(cross(v1,v2)))*acos(dot(v1,v2));\n      occ += dot(nn,normalize(cross(v2,v3)))*acos(dot(v2,v3));\n      occ += dot(nn,normalize(cross(v3,v4)))*acos(dot(v3,v4));\n      occ += dot(nn,normalize(cross(v4,v5)))*acos(dot(v4,v5));\n      occ += dot(nn,normalize(cross(v5,v0)))*acos(dot(v5,v0));\n\n      occ = clamp(abs(occ)/tau,0.0,1.0);\n      occ = pow(occ,0.75);\n\n      occBox *= 1.0 - occ;\n    }\n  }\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n\n  \tif(scn[i].type == 0){ //plane\n  \t  float occ = 0.0;\n\n      float b = dot(p,s.v4a.xyz);\n      float a = 1.0-clamp(b+s.v4a.w,0.0,1.0);\n      if(a < 0.99999) occ = pow(a,2.0);\n\n      res *= 1.0 - occ;\n  \t}else if(scn[i].type == 1){ //sphere\n      vec3 r = s.v4a.xyz - p;\n      float l = length(r);\n      float d = dot(n,r);\n      float occ = d;\n\n  \t  if(d < s.v4a.w) occ = clamp((d+s.v4a.w)/(2.0*s.v4a.w),0.0,1.0) * s.v4a.w;\n      occ = clamp(occ*(s.v4a.w*s.v4a.w)/(l*l*l),0.0,1.0);\n\n      res *= 1.0 - occ;\n  \t}/*else if(scn[i].type == 2){ //box\n      //empty\n  \t}*/\n  }\n\n  if(h.type != 2) res *= occBox;\n\n  return clamp(res*res*res,0.0,1.0);\n}\n\nfloat segShadow(vec3 ro,vec3 rd,vec3 pa,float sh){\n  float dm = dot(rd.yz,rd.yz);\n  float k1 = (ro.x-pa.x)*dm;\n  float k2 = (ro.x+pa.x)*dm;\n  vec2 k5 = (ro.yz+pa.yz)*dm;\n  float k3 = dot(ro.yz+pa.yz,rd.yz);\n  vec2 k4 = (pa.yz+pa.yz)*rd.yz;\n  vec2 k6 = (pa.yz+pa.yz)*dm;\n\n  for(int i=0;i<4;i++){\n    vec2 s = vec2(i&1,i>>1);\n    float t = dot(s,k4) - k3;\n\n    if(t > 0.0)\n      sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n  }\n\n  return sh;\n}\n\nfloat getSoftShadow(Hit h,vec3 ro,vec3 rd,float sk){\n\tfloat sha = 1.0;\n\n  for(int i=0;i<scnLen;i++){\n  \tHit2 s = scn[i];\n\n    /*if(scn[i].type == 0){ //plane\n      //empty\n    }else*/if(scn[i].type == 1){ //sphere\n      vec3 oc = ro - s.v4a.xyz;\n      float b = dot(oc,rd);\n      float c = dot(oc,oc) - s.v4a.w*s.v4a.w;\n      float h = b*b - c;\n\n      float d = sqrt(max(0.0,s.v4a.w*s.v4a.w-h)) - s.v4a.w;\n      float t = -b - sqrt(max(h,0.0));\n      float s = (t<0.0) ? 1.0 : smoothstep(0.0,1.0,sk*d/t);\n\n      sha *= s;\n    }else if(scn[i].type == 2){ //box\n \t   vec3 rdd = (s.imat*vec4(rd,0.0)).xyz;\n\t    vec3 roo = (s.imat*vec4(ro,1.0)).xyz;\n\n      vec3 rad = s.v3a;\n      vec3 m = 1.0/rdd;\n      vec3 n = m*roo;\n      vec3 k = abs(m)*rad-0.00001;\n\n      vec3 t1 = -n - k;\n      vec3 t2 = -n + k;\n\n      float tN = max(max(t1.x,t1.y),t1.z);\n\t    float tF = min(min(t2.x,t2.y),t2.z);\n\n      float s = 1.0;\n      s = segShadow(roo.xyz,rdd.xyz,rad.xyz,s);\n      s = segShadow(roo.yzx,rdd.yzx,rad.yzx,s);\n      s = segShadow(roo.zxy,rdd.zxy,rad.zxy,s);\n      s = clamp(sk*sqrt(s),0.0,1.0);\n      s = s*s*(3.0-2.0*s);\n\n      if(tN<tF && tF>0.0) s = 0.0;\n\n      sha *= s;\n    }\n  }\n\n\treturn sha;\n}\n\nvec3 getMaterial(vec3 ro,vec3 rd,Hit h){\n\tvec3 pos = ro+rd*h.d;\n\tvec3 nor = getNormal(h,pos);\n  vec3 mate = vec3(0.0);\n\n  if(h.id == 0){\n    mate += 0.1+0.9*mod(floor(pos.x*5.0)+floor(pos.z*5.0),2.0);\n  }else if(h.id == 1){\n  \tmate += vec3(1.0,0.0,0.0);\n  }else if(h.id == 2){\n  \tmate += vec3(0.0,1.0,0.0);\n  }else if(h.id == 3){\n  \tmate += vec3(0.0,0.0,1.0);\n  }else if(h.id == 4){\n  \tmate += vec3(0.5,0.5,1.0) * mod(floor((atan(nor.z,nor.x)/pi)*8.0)+floor(nor.y*3.0),2.0);\n  }else if(h.id == 5){\n  \tvec3 q = (h.imat*vec4(pos,1.0)).xyz;\n  \tvec3 n = (h.imat*vec4(nor,0.0)).xyz;\n  \tvec3 x = texture(iChannel0,q.yz).rgb;\n  \tvec3 y = texture(iChannel0,q.xz).rgb;\n  \tvec3 z = texture(iChannel0,q.xy).rgb;\n  \tmate += x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n  \tmate = pow(mate,vec3(3.5))*2.0;\n  }else if(h.id == 6){\n  \tvec3 x = texture(iChannel1,pos.yz).rgb;\n  \tvec3 y = texture(iChannel1,pos.xz).rgb;\n  \tvec3 z = texture(iChannel1,pos.xy).rgb;\n  \tmate += x*abs(nor.x) + y*abs(nor.y) + z*abs(nor.z);\n  \tmate = pow(mate,vec3(2.2))*2.0;\n  }else mate += 1.0;\n\n  return mate;\n}\n\nfloat dirLight(vec3 rd,Hit h,vec3 lpos,float r){\n\tfloat lig = 1.0;\n\n\tfloat a = length(rd-normalize(lpos));\n\tif(h.id == -1) lig = a;\n\n\treturn r/250.0 / (lig*lig);\n}\n\nfloat pointLight(vec3 ro,vec3 rd,Hit h,vec3 lpos,float r){\n\tfloat lig = 1.0;\n\n\tfloat dt = dot(lpos-ro,rd);\n\tdt = clamp(dt,0.0,h.d);\n\tvec3 p = ro+rd*dt;\n\tlig = length(p-lpos);\n\n\treturn r/5.0 / (lig*lig);\n}\n\nvec3 render3D(vec2 uv){\n\tvec3 col = vec3(0.0);\n\n  initScene();\n\n  uv += hash(uv+iTime)*2.0 / iResolution.y;\n\n  vec3 ro = vec3(0.25,0.0,4.0);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  rd += hash(rd+iTime)*0.2/iResolution.y;\n\n  // \"\"\" realistic movement \"\"\"\n  #if 1\n  ro.y = abs(sin(iTime*5.0))*0.1-0.25;\n  rd.yz *= rot(cos(iTime*5.0)*0.025);\n  rd.xy *= rot(sin(iTime*10.0)*0.01);\n  rd.xz *= rot(sin(iTime*5.0)*0.025);\n  ro.z -= sin(iTime*7.0)*0.05;\n  ro.z -= sin(iTime)*0.05;\n  #endif\n\n  //orbit scene\n  ro.xz *= rot(iTime/3.0);\n  rd.xz *= rot(iTime/3.0);\n\n  Hit h = raycast(ro,rd);\n  vec3 pos = ro + rd*h.d;\n\n  vec3 bgCol = vec3(0.2,0.2,0.2);\n  vec3 fogCol = vec3(0.0,0.0,0.0);\n  vec3 bg = mix(fogCol,bgCol,clamp(rd.y,0.0,1.0));\n\n  vec3 ligPos = vec3(1.0);\n  vec3 ligDir = normalize(ligPos-pos); //pointlight\n  vec3 ligCol = vec3(0.9,0.7,0.8);\n\n  if(h.d > 0.0 && h.id != -1){\n  \tvec3 nor = getNormal(h,pos);\n    float occ = getOcc(h,nor,pos);\n  \tvec3 mate = getMaterial(ro,rd,h);\n    vec3 ref = reflect(rd,nor);\n\n    { // pink light point\n      float dif = clamp(dot(nor,ligDir),0.0,1.0);\n      float backdif = clamp(dot(nor,-ligDir),0.0,1.0);\n    \t//float sha = step(1.0,raycast(pos,ligDir).d); // It does not make infinite shadows.\n    \tfloat sha = getSoftShadow(h,pos,ligDir,4.0); // the projection is completely wrong.\n    \t//float sha = step(length(ligPos-pos),raycast(pos,ligDir).d); // 100% functional but does not soft shadow.\n    \tfloat spe = pow(clamp(dot(ref,ligDir),0.0,1.0),10.0);\n    \tfloat fre = clamp(pow(1.0-dot(nor,-rd),5.0),0.0,1.0);\n      float speref = getSoftShadow(h,pos,ref,1.0)*0.5;\n      vec3 lc = pow(ligCol,vec3(2.2));\n      dif *= sha;\n      dif += 0.01;\n      col += mate;\n      col = mix(col,bgCol,fre);\n      col *= dif;\n      col += lc * spe * sha * speref;\n      col *= lc;\n      col = clamp(col,0.0,1.0);\n    }\n\n    { //sky\n    \tfloat dif = clamp(nor.y*0.5+0.5,0.0,1.0);\n    \tfloat speref = getSoftShadow(h,pos,ref,4.0);\n    \tfloat spe = pow(clamp(ref.y*0.5+0.5,0.0,1.0),2.0);\n\n      col += 0.00075 * dif;\n    \tcol += 0.00075 * spe * speref;\n    }\n\n    { //back\n      float dif = clamp(dot(nor,-ligDir),0.0,1.0);\n    \tfloat spe = clamp(dot(ref,-ligDir),0.0,1.0);\n\n      col += mate * pow(dif,3.0)*0.0025;\n      col += mate * pow(spe,4.0)*0.00125;\n    }\n\n    { //bounce\n    \tfloat dif = clamp(-nor.y,0.0,1.0);\n      col.r += 0.00175 * pow(dif,2.0);\n    }\n\n    col = clamp(col,0.0,1.0) * occ;\n  }\n\n  //gamma correction\n  col = clamp(pow(col,vec3(1.0/2.2)),0.0,1.0);\n\n  //fog & background\n  col = mix(col,bg,clamp(1.0-exp(-0.025*h.d*h.d),0.0,1.0));\n\n  // draw lights //\n\n  //col = mix(col,ligCol,dirLight(rd,h,ligPos,0.125));\n  col = mix(col,ligCol,pointLight(ro,rd,h,ligPos,0.125));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  col += render3D(uv);\n\n  #ifdef BUFFERS\n  { //crosshair\n    vec2 p = uv * 0.5;\n    float b = sin(iTime*1.5)*1.0075;\n    float hb = sign(b) * pow(abs(b),64.0);\n    vec2 nuv = p * rot(hb);\n    vec2 q = abs(nuv.x)<abs(nuv.y)?nuv.xy:nuv.yx;\n    if(max(-(max(abs(q.x),abs(q.y))-0.005),max(abs(q.x)-0.002,abs(q.y)-0.01)) < 0.0) col = (1.0-col) * vec3(0,1,0);\n    uv *= rot(-hb);\n    if(max(-max(-(abs(p.y)-0.0075-abs(b*0.01)+0.005),-(abs(p.x)-0.0075-abs(b*0.01)+0.005)),abs(length(p)-0.02-(abs(b*b*b*b*b)*0.0025))-0.001) < 0.0) col = (1.0-col) * vec3(0,1,0);\n  }\n  //vignete\n  col += vec3(0,1,0)*length(fragCoord/iResolution.xy-0.5)*0.025;\n  #endif\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 76, 76, 119], [120, 120, 139, 139, 156], [158, 158, 178, 178, 259], [260, 260, 280, 280, 340], [341, 341, 361, 361, 429], [448, 475, 491, 491, 578], [579, 579, 602, 602, 716], [717, 717, 740, 740, 854], [855, 855, 878, 878, 992], [993, 993, 1034, 1034, 1085], [1086, 1086, 1110, 1110, 1203], [1414, 1414, 1438, 1438, 1494], [1521, 1521, 1565, 1565, 1703], [1705, 1705, 1750, 1750, 1977], [1979, 1979, 2041, 2041, 2552], [2594, 2594, 2625, 2625, 2697], [2699, 2699, 2731, 2731, 2803], [2805, 2805, 2844, 2844, 2959], [3010, 3010, 3027, 3027, 3838], [3840, 3840, 3869, 3869, 4246], [4248, 4248, 4277, 4277, 4497], [4499, 4499, 4533, 4533, 6355], [6357, 6357, 6407, 6407, 6819], [6821, 6821, 6873, 6873, 8016], [8018, 8018, 8058, 8058, 9083], [9085, 9085, 9133, 9133, 9248], [9250, 9250, 9308, 9308, 9454], [9456, 9456, 9479, 9479, 12187], [12189, 12189, 12239, 12239, 12998]], "test": "untested"}
{"id": "csjSWd", "name": "Alien Rose", "author": "oseday", "description": "high dimensional", "tags": ["raymarch", "fractals"], "likes": 5, "viewed": 438, "published": 3, "date": "1671104435", "time_retrieved": "2024-07-30T16:12:46.738665", "image_code": "struct rayresult{\n    vec3 o; //origin\n    vec3 v; //direction\n    float dist; //distance\n};\n\n#define EPSILON 0.0005\n#define PI 3.1415928\n\nmat4 cam = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    0,0,0,1\n);\n\nmat4 addmv(mat4 mat, vec3 v){\n    mat4 n = mat;\n    n[3]=n[3]+vec4(v,0);\n    return n;\n}\n\nmat4 mat4v(vec3 v){\n    return mat4(\n        1,0,0,v.x,\n        0,1,0,v.y,\n        0,0,1,v.z,\n        0,0,0,1\n    );\n}\n\nvec3 matpos(mat4 mat){\n    return mat[3].xyz;\n}\n\nconst float planedist = 1.00;\n\n\nfloat map(vec3 p)\n{\n    float t = iTime;\n\n    vec3 b = 1.000*sin(1.*p.zxy + vec3(t,0.,0.));\n    \n    b = rotateabout(sin(b), p, length(p));\n    \n    b += 0.500*sin(8.0*b.zxy);\n    b += 0.225*sin((sin(t*0.975+5.345)+1.25) * 8.2*b.zxy);\n    \n    b = rotateabout(-b, p, length(p)+2.);\n    \n    b += 0.120*sin((sin(t*0.812+2.891)+0.23) * 16.8*b.zxy);\n    \n    return length(b*length(p*p)) * 0.009;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nconst int kRaymarchIterations = 1024;\nconst float mapddivisor = 1.100;\n\nconst vec3 sundir = normalize(vec3(0,1,1));\nconst vec3 suncol = vec3(0.8,0.8,0.8);\nconst vec3 objcol = vec3(0.9,0.9,0.8);\n\nvec3 manager(rayresult io){\n\n    vec3 skycol = texture(iChannel0,io.v).xyz;\n    \n\tfloat t = -1.00;\n    \n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n        vec3 pos = io.o + io.v * t;\n    \n\t\tfloat d = map(pos);\n        \n        if (d > 10.) {return skycol;}\n        \n\t\tif(d < 0.01){\n            \n            vec3 n = estimateNormal(pos);\n\n            float sundot = dot(n,sundir);\n            \n            vec3 col = suncol * sundot + objcol;\n                        \n            vec3 sdir = reflect(io.v,n);\n            col *= texture(iChannel0,sdir).xyz;\n            \n\t\t\treturn col;\n\t\t}\n        \n        t += d/mapddivisor;\n\t}\n    \n    return skycol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tick = iTime/5.;\n    \n    vec2 mouseuv = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx*2.;\n\n    mat4 ncam = cam\n        *build_transform(vec3(0,0,0),vec3(0,-mouseuv.x*PI + tick,0))\n        *build_transform(vec3(0,0,0),vec3(-mouseuv.y*PI,0,0))\n        ;\n        \n    ncam = ncam\n        *build_transform(vec3(0,0,-6.),vec3(0,0,0))\n        ;\n    \n    vec3 campos = matpos(ncam);\n        \n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.xx*2.;\n\n    vec3 v = normalize(uv.x*ncam[0].xyz+uv.y*ncam[1].xyz+ncam[2].xyz*planedist);\n\n    vec3 color = vec3(0,0,0);\n\n    rayresult ray;\n    \n    ray.o=campos;\n    ray.v=v;\n    ray.dist=0.10;\n\n    color += manager(ray);\n\n    color = clamp(color,0.,1.);\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31288, "src": "https://soundcloud.com/wearekloud/virus", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "mat4 build_transform(vec3 pos, vec3 ang) \n{\n  float cosX = cos(ang.x);\n  float sinX = sin(ang.x);\n  float cosY = cos(ang.y);\n  float sinY = sin(ang.y);\n  float cosZ = cos(ang.z);\n  float sinZ = sin(ang.z);\n\n  mat4 m;\n\n  float m00 = cosY * cosZ + sinX * sinY * sinZ; \n  float m01 = cosY * sinZ - sinX * sinY * cosZ; \n  float m02 = cosX * sinY;\n  float m03 = 0.0;\n  \n  float m04 = -cosX * sinZ; \n  float m05 = cosX * cosZ; \n  float m06 = sinX;\n  float m07 = 0.0;\n  \n  float m08 = sinX * cosY * sinZ - sinY * cosZ;\n  float m09 = -sinY * sinZ - sinX * cosY * cosZ;\n  float m10 = cosX * cosY;\n  float m11 = 0.0;\n  \n  float m12 = pos.x;\n  float m13 = pos.y;\n  float m14 = pos.z;\n  float m15 = 1.0;\n\n  /*\n  //------ Orientation ---------------------------------\n  m[0] = vec4(m00, m01, m02, m03); // first column.\n  m[1] = vec4(m04, m05, m06, m07); // second column.\n  m[2] = vec4(m08, m09, m10, m11); // third column.\n\n  //------ Position ------------------------------------\n  m[3] = vec4(m12, m13, m14, m15); // fourth column.\n  */\n\n  //------ Orientation ---------------------------------\n  m[0][0] = m00; // first entry of the first column.\n  m[0][1] = m01; // second entry of the first column.\n  m[0][2] = m02;\n  m[0][3] = m03;\n  \n  m[1][0] = m04; // first entry of the second column.\n  m[1][1] = m05; // second entry of the second column.\n  m[1][2] = m06;\n  m[1][3] = m07;\n\n  m[2][0] = m08; // first entry of the third column.\n  m[2][1] = m09; // second entry of the third column.\n  m[2][2] = m10;\n  m[2][3] = m11;\n  \n  //------ Position ------------------------------------\n  m[3][0] = m12; // first entry of the fourth column.\n  m[3][1] = m13; // second entry of the fourth column.\n  m[3][2] = m14;\n  m[3][3] = m15;\n\n  return m;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotateabout(vec3 vec, vec3 axis, float angle) {\n    return (rotationMatrix(axis, angle) * vec4(vec, 1.0)).xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 240, 240, 299], [301, 301, 320, 320, 419], [421, 421, 443, 443, 468], [502, 502, 521, 521, 897], [900, 900, 929, 929, 1209], [1406, 1406, 1433, 1433, 2061], [2063, 2063, 2120, 2120, 2865]], "test": "untested"}
{"id": "cd2XWt", "name": "Looking for you", "author": "pashafx", "description": "https://soundcloud.com/pashafx\n\n", "tags": ["music"], "likes": 4, "viewed": 323, "published": 3, "date": "1671094968", "time_retrieved": "2024-07-30T16:12:47.806808", "image_code": "// Fork of \"The Drive Home\" by BigWIngs. https://shadertoy.com/view/MdfBRX\n// 2022-12-15 09:01:48\n\n// \"The Drive Home\" by Martijn Steinrucken aka BigWings - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n//\n// I was looking for something 3d, that can be made just with a point-line distance function.\n// Then I saw the cover graphic of the song I'm using here on soundcloud, which is a bokeh traffic\n// shot which is a perfect for for what I was looking for.\n//\n// It took me a while to get to a satisfying rain effect. Most other people use a render buffer for\n// this so that is how I started. In the end though, I got a better effect without. Uncomment the\n// DROP_DEBUG define to get a better idea of what is going on.\n//\n// If you are watching this on a weaker device, you can uncomment the HIGH_QUALITY define\n//\n// Music:\n// Mr. Bill - Cheyah (Zefora's digital rain remix) \n// https://soundcloud.com/zefora/cheyah\n//\n// Video can be found here:\n// https://www.youtube.com/watch?v=WrxZ4AZPdOQ\n//\n// Making of tutorial:\n// https://www.youtube.com/watch?v=eKtsY7hYTPg\n//\n\n#define S(x, y, z) smoothstep(x, y, z)\n#define B(a, b, edge, t) S(a-edge, a+edge, t)*S(b+edge, b-edge, t)\n#define sat(x) clamp(x,0.,1.)\n\n#define streetLightCol vec3(1., .7, .3)\n#define headLightCol vec3(.8, .8, 1.)\n#define tailLightCol vec3(1., .1, .1)\n\n#define HIGH_QUALITY\n#define CAM_SHAKE 1.\n#define LANE_BIAS .5\n#define RAIN\n//#define DROP_DEBUG\n\nvec3 ro, rd;\n\nfloat N(float t) {\n\treturn fract(sin(t*10234.324)*123423.23512);\n}\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd));\n}\n \nvec3 ClosestPoint(vec3 ro, vec3 rd, vec3 p) {\n    // returns the closest point on ray r to point p\n    return ro + max(0., dot(p-ro, rd))*rd;\n}\n\nfloat Remap(float a, float b, float c, float d, float t) {\n\treturn ((t-a)/(b-a))*(d-c)+c;\n}\n\nfloat BokehMask(vec3 ro, vec3 rd, vec3 p, float size, float blur) {\n\tfloat d = DistLine(ro, rd, p);\n    float m = S(size, size*(1.-blur), d);\n    \n    #ifdef HIGH_QUALITY\n    m *= mix(.7, 1., S(.8*size, size, d));\n    #endif\n    \n    return m;\n}\n\n\n\nfloat SawTooth(float t) {\n    return cos(t+cos(t))+sin(2.*t)*.2+sin(4.*t)*.02;\n}\n\nfloat DeltaSawTooth(float t) {\n    return 0.4*cos(2.*t)+0.08*cos(4.*t) - (1.-sin(t))*sin(t+cos(t));\n}  \n\nvec2 GetDrops(vec2 uv, float seed, float m) {\n    \n    float t = iTime+m*30.;\n    vec2 o = vec2(0.);\n    \n    #ifndef DROP_DEBUG\n    uv.y += t*.05;\n    #endif\n    \n    uv *= vec2(10., 2.5)*2.;\n    vec2 id = floor(uv);\n    vec3 n = N31(id.x + (id.y+seed)*546.3524);\n    vec2 bd = fract(uv);\n    \n    vec2 uv2 = bd;\n    \n    bd -= .5;\n    \n    bd.y*=4.;\n    \n    bd.x += (n.x-.5)*.6;\n    \n    t += n.z * 6.28;\n    float slide = SawTooth(t);\n    \n    float ts = 1.5;\n    vec2 trailPos = vec2(bd.x*ts, (fract(bd.y*ts*2.-t*2.)-.5)*.5);\n    \n    bd.y += slide*2.;\t\t\t\t\t\t\t\t// make drops slide down\n    \n    #ifdef HIGH_QUALITY\n    float dropShape = bd.x*bd.x;\n    dropShape *= DeltaSawTooth(t);\n    bd.y += dropShape;\t\t\t\t\t\t\t\t// change shape of drop when it is falling\n    #endif\n    \n    float d = length(bd);\t\t\t\t\t\t\t// distance to main drop\n    \n    float trailMask = S(-.2, .2, bd.y);\t\t\t\t// mask out drops that are below the main\n    trailMask *= bd.y;\t\t\t\t\t\t\t\t// fade dropsize\n    float td = length(trailPos*max(.5, trailMask));\t// distance to trail drops\n    \n    float mainDrop = S(.2, .1, d);\n    float dropTrail = S(.1, .02, td);\n    \n    dropTrail *= trailMask;\n    o = mix(bd*mainDrop, trailPos, dropTrail);\t\t// mix main drop and drop trail\n    \n    #ifdef DROP_DEBUG\n    if(uv2.x<.02 || uv2.y<.01) o = vec2(1.);\n    #endif\n    \n    return o;\n}\n\nvoid CameraSetup(vec2 uv, vec3 pos, vec3 lookat, float zoom, float m) {\n\tro = pos;\n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    float t = iTime;\n    \n    vec2 offs = vec2(0.);\n    #ifdef RAIN\n    vec2 dropUv = uv; \n    \n    #ifdef HIGH_QUALITY\n    float x = (sin(t*.1)*.5+.5)*.5;\n    x = -x*x;\n    float s = sin(x);\n    float c = cos(x);\n    \n    mat2 rot = mat2(c, -s, s, c);\n   \n    #ifndef DROP_DEBUG\n    dropUv = uv*rot;\n    dropUv.x += -sin(t*.1)*.5;\n    #endif\n    #endif\n    \n    offs = GetDrops(dropUv, 1., m);\n    \n    #ifndef DROP_DEBUG\n    offs += GetDrops(dropUv*1.4, 10., m);\n    #ifdef HIGH_QUALITY\n    offs += GetDrops(dropUv*2.4, 25., m);\n    //offs += GetDrops(dropUv*3.4, 11.);\n    //offs += GetDrops(dropUv*3., 2.);\n    #endif\n    \n    float ripple = sin(t+uv.y*3.1415*30.+uv.x*124.)*.5+.5;\n    ripple *= .005;\n    offs += vec2(ripple*ripple, ripple);\n    #endif\n    #endif\n    vec3 center = ro + f*zoom;\n    vec3 i = center + (uv.x-offs.x)*r + (uv.y-offs.y)*u;\n    \n    rd = normalize(i-ro);\n}\n\nvec3 HeadLights(float i, float t) {\n    float z = fract(-t*2.+i);\n    vec3 p = vec3(-.3, .1, z*40.);\n    float d = length(p-ro);\n    \n    float size = mix(.03, .05, S(.02, .07, z))*d;\n    float m = 0.;\n    float blur = .1;\n    m += BokehMask(ro, rd, p-vec3(.08, 0., 0.), size, blur);\n    m += BokehMask(ro, rd, p+vec3(.08, 0., 0.), size, blur);\n    \n    #ifdef HIGH_QUALITY\n    m += BokehMask(ro, rd, p+vec3(.1, 0., 0.), size, blur);\n    m += BokehMask(ro, rd, p-vec3(.1, 0., 0.), size, blur);\n    #endif\n    \n    float distFade = max(.01, pow(1.-z, 9.));\n    \n    blur = .8;\n    size *= 2.5;\n    float r = 0.;\n    r += BokehMask(ro, rd, p+vec3(-.09, -.2, 0.), size, blur);\n    r += BokehMask(ro, rd, p+vec3(.09, -.2, 0.), size, blur);\n    r *= distFade*distFade;\n    \n    return headLightCol*(m+r)*distFade;\n}\n\n\nvec3 TailLights(float i, float t) {\n    t = t*1.5+i;\n    \n    float id = floor(t)+i;\n    vec3 n = N31(id);\n    \n    float laneId = S(LANE_BIAS, LANE_BIAS+.01, n.y);\n    \n    float ft = fract(t);\n    \n    float z = 3.-ft*3.;\t\t\t\t\t\t// distance ahead\n    \n    laneId *= S(.2, 1.5, z);\t\t\t\t// get out of the way!\n    float lane = mix(.6, .3, laneId);\n    vec3 p = vec3(lane, .1, z);\n    float d = length(p-ro);\n    \n    float size = .05*d;\n    float blur = .1;\n    float m = BokehMask(ro, rd, p-vec3(.08, 0., 0.), size, blur) +\n    \t\t\tBokehMask(ro, rd, p+vec3(.08, 0., 0.), size, blur);\n    \n    #ifdef HIGH_QUALITY\n    float bs = n.z*3.;\t\t\t\t\t\t// start braking at random distance\t\t\n    float brake = S(bs, bs+.01, z);\n    brake *= S(bs+.01, bs, z-.5*n.y);\t\t// n.y = random brake duration\n    \n    m += (BokehMask(ro, rd, p+vec3(.1, 0., 0.), size, blur) +\n    \tBokehMask(ro, rd, p-vec3(.1, 0., 0.), size, blur))*brake;\n    #endif\n    \n    float refSize = size*2.5;\n    m += BokehMask(ro, rd, p+vec3(-.09, -.2, 0.), refSize, .8);\n    m += BokehMask(ro, rd, p+vec3(.09, -.2, 0.), refSize, .8);\n    vec3 col = tailLightCol*m*ft; \n    \n    float b = BokehMask(ro, rd, p+vec3(.12, 0., 0.), size, blur);\n    b += BokehMask(ro, rd, p+vec3(.12, -.2, 0.), refSize, .8)*.2;\n    \n    vec3 blinker = vec3(1., .7, .2);\n    blinker *= S(1.5, 1.4, z)*S(.2, .3, z);\n    blinker *= sat(sin(t*200.)*100.);\n    blinker *= laneId;\n    col += blinker*b;\n    \n    return col;\n}\n\nvec3 StreetLights(float i, float t) {\n\t float side = sign(rd.x);\n    float offset = max(side, 0.)*(1./16.);\n    float z = fract(i-t+offset); \n    vec3 p = vec3(2.*side, 2., z*60.);\n    float d = length(p-ro);\n\tfloat blur = .1;\n    vec3 rp = ClosestPoint(ro, rd, p);\n    float distFade = Remap(1., .7, .1, 1.5, 1.-pow(1.-z,6.));\n    distFade *= (1.-z);\n    float m = BokehMask(ro, rd, p, .05*d, blur)*distFade;\n    \n    return m*streetLightCol;\n}\n\nvec3 EnvironmentLights(float i, float t) {\n\tfloat n = N(i+floor(t));\n    \n    float side = sign(rd.x);\n    float offset = max(side, 0.)*(1./16.);\n    float z = fract(i-t+offset+fract(n*234.));\n    float n2 = fract(n*100.);\n    vec3 p = vec3((3.+n)*side, n2*n2*n2*1., z*60.);\n    float d = length(p-ro);\n\tfloat blur = .1;\n    vec3 rp = ClosestPoint(ro, rd, p);\n    float distFade = Remap(1., .7, .1, 1.5, 1.-pow(1.-z,6.));\n    float m = BokehMask(ro, rd, p, .05*d, blur);\n    m *= distFade*distFade*.5;\n    \n    m *= 1.-pow(sin(z*6.28*20.*n)*.5+.5, 20.);\n    vec3 randomCol = vec3(fract(n*-34.5), fract(n*4572.), fract(n*1264.));\n    vec3 col = mix(tailLightCol, streetLightCol, fract(n*-65.42));\n    col = mix(col, randomCol, n);\n    return m*col*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    vec3 col = vec3(0.);\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 pos = vec3(.3, .15, 0.);\n    \n    float bt = t * 5.;\n    float h1 = N(floor(bt));\n    float h2 = N(floor(bt+1.));\n    float bumps = mix(h1, h2, fract(bt))*.1;\n    bumps = bumps*bumps*bumps*CAM_SHAKE;\n    \n    pos.y += bumps;\n    float lookatY = pos.y+bumps;\n    vec3 lookat = vec3(0.3, lookatY, 1.);\n    vec3 lookat2 = vec3(0., lookatY, .7);\n    lookat = mix(lookat, lookat2, sin(t*.1)*.5+.5);\n    \n    uv.y += bumps*4.;\n    CameraSetup(uv, pos, lookat, 2., mouse.x);\n   \n    t *= .03;\n    t += mouse.x;\n    \n    // fix for GLES devices by MacroMachines\n    #ifdef GL_ES\n\tconst float stp = 1./8.;\n\t#else\n\tfloat stp = 1./8.\n\t#endif\n    \n    for(float i=0.; i<1.; i+=stp) {\n       col += StreetLights(i, t);\n    }\n    \n    for(float i=0.; i<1.; i+=stp) {\n        float n = N(i+floor(t));\n    \tcol += HeadLights(i+n*stp*.7, t);\n    }\n    \n    #ifndef GL_ES\n    #ifdef HIGH_QUALITY\n    stp = 1./32.;\n    #else\n    stp = 1./16.;\n    #endif\n    #endif\n    \n    for(float i=0.; i<1.; i+=stp) {\n       col += EnvironmentLights(i, t);\n    }\n    \n    col += TailLights(0., t);\n    col += TailLights(.5, t);\n    \n    col += sat(rd.y)*vec3(.6, .5, .9);\n    \n\tfragColor = vec4(col, 0.);\n}", "image_inputs": [{"id": 31287, "src": "https://soundcloud.com/pashafx/lookingforyou", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2XWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1541, 1541, 1559, 1559, 1607], [1608, 1608, 1627, 1663, 1835], [1836, 1836, 1854, 1910, 2053], [2056, 2056, 2098, 2098, 2133], [2136, 2136, 2181, 2234, 2279], [2281, 2281, 2339, 2339, 2372], [2374, 2374, 2441, 2441, 2619], [2623, 2623, 2648, 2648, 2703], [2705, 2705, 2735, 2735, 2806], [2810, 2810, 2855, 2855, 4153], [4155, 4155, 4226, 4226, 5229], [5231, 5231, 5266, 5266, 6041], [6044, 6044, 6079, 6079, 7492], [7494, 7494, 7531, 7531, 7939], [7941, 7941, 7983, 7983, 8693]], "test": "untested"}
{"id": "dsSSDd", "name": "3D Simplex Noise Contours", "author": "mla", "description": "Antialiasing noise contours with fwidth (press 'x' for unantialiased). Mouse rotates section through noise space. Press 'a' for a nice effect.\n\n3D Simplex Noise function from [url]https://github.com/ashima/webgl-noise[/url] by Ian McEwan and @stegu.", "tags": ["noise", "perlin", "simplex", "aa", "contour", "stegu"], "likes": 14, "viewed": 324, "published": 3, "date": "1671094269", "time_retrieved": "2024-07-30T16:12:48.810126", "image_code": "// 3D Simplex Noise Contours, mla, 2022\n\nvec3 colors[] =\n  vec3[](vec3(0.996078,0.152941,0.0705882),\n         vec3(0.988235,0.376471,0.0392157),\n         vec3(0.984314,0.6,0.00784314),\n         vec3(0.988235,0.8,0.101961),\n         vec3(0.996078,0.996078,0.2),\n         vec3(0.698039,0.843137,0.196078),\n\n         vec3(0.4,0.690196,0.196078),\n         vec3(0.203922,0.486275,0.596078),\n         vec3(0.00784314,0.278431,0.996078),\n         vec3(0.266667,0.141176,0.839216),\n         vec3(0.52549,0.00392157,0.686275),\n         vec3(0.760784,0.0784314,0.376471));\n\nvec3 getcol(int i, float shade) {\n  i = clamp(i,0,colors.length()-1);\n  if (key(CHAR_Z) && i == int(iTime)%13-1) return vec3(1);\n  vec3 col = colors[i];\n  col = pow(col,vec3(2.2)); // Linear space color\n  col *= mix(shade,1.0,0.2);\n  return col;;\n}\n\nfloat sstep(float from, float to, float x) {\n  if (key(CHAR_X)) return float(x >= 0.5*(to+from)); // Yuk!\n  // Cubic or linear smoothing both work well.\n  //return smoothstep(from,to,x);\n  return clamp((x-from)/(to-from),0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 uv = vec3((2.0*fragCoord-iResolution.xy)/iResolution.y,1);    \n    uv.xy *= 2.0;\n    if (key(CHAR_A)) uv.yz = rotate(uv.yz,-0.1*iTime);\n    vec3 p = vec3(uv.xy/uv.z,0.1*iTime);\n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.0) mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.xy;\n    p.yz = rotate(p.yz, PI*mouse.y);\n    p.xz = rotate(p.xz, PI*mouse.x);\n    float shade = 0.5*(1.0+snoise(p));\n    shade *= 12.0;\n    float px = 0.5*length(vec2(dFdx(shade),dFdy(shade))); // fwidth before fract\n    int ix = int(floor(shade));\n    shade = fract(shade);\n    // Find nearest boundary and adjust shade and index.\n    if (shade > 0.5) { shade--; ix++; }\n    vec3 ltcol = getcol(ix-1,shade+1.0); // 'less than' color\n    vec3 gtcol = getcol(ix,shade);       // 'greater than' color\n    vec3 col = mix(ltcol,gtcol,sstep(-px,px,shade));\n    vec3 distcol = vec3(0.8);\n    col = mix(distcol,col,pow(clamp(abs(uv.z),0.0,1.0),0.5)); // Hide aliasing in the distance\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst float PI = 3.14159265;\n\n// Code from: https://github.com/ashima/webgl-noise\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// mla: return value is in range [-1,1]\nfloat snoise(vec3 v) { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[564, 564, 597, 597, 812], [814, 814, 858, 858, 1046], [1048, 1048, 1100, 1100, 2131]], "test": "untested"}
{"id": "msBXDd", "name": "Little Man Computer Simulator", "author": "oneshade", "description": "See comment in the Image tab.", "tags": ["computer", "simulator", "assembly", "interpreter", "programming", "lmc"], "likes": 19, "viewed": 597, "published": 3, "date": "1671086773", "time_retrieved": "2024-07-30T16:12:49.790505", "image_code": "/*\nThis is a simulation of a \"little man computer\", an educational model of a computer.\nI recommend reading the details on wikipedia (https://en.wikipedia.org/wiki/Little_man_computer).\nYou can slow down the simulation by increasing INSTRUCTION_DELAY in the\nCommon tab.\n\nInstructions for this implementation:\n+-----------+---------+-------------------------------------------------------------+\n| Assembled | Syntax  | Operation                                                   |\n+-----------+---------+-------------------------------------------------------------+\n| 000       | HLT     | \"halt\", stop the program                                    |\n+-----------+---------+-------------------------------------------------------------+\n| 1xx       | ADD xx  | add the value at RAM address x to the accumulator           |\n+-----------+---------+-------------------------------------------------------------+\n| 2xx       | SUB xx  | subtract the value at RAM address x from the accumulator    |\n+-----------+---------+-------------------------------------------------------------+\n| 3xx       | STA xx  | store the accumulator's value in RAM at address x           |\n+-----------+---------+-------------------------------------------------------------+\n| 4xx       | LDA xx  | load the value at RAM address x into the accumulator        |\n+-----------+---------+-------------------------------------------------------------+\n| 5xx       | BRA xx  | \"branch\", jump to RAM address x and start executing the     |\n|           |         | program from there on                                       |\n+-----------+---------+-------------------------------------------------------------+\n| 6xx       | BRZ xx  | same as BRA, but only if the accumulator equals 0           |\n+-----------+---------+-------------------------------------------------------------+\n| 7xx       | BRP xx  | same as BRA, but only if the accumulator is positive (>= 0) |\n+-----------+---------+-------------------------------------------------------------+\n| 8xx       | INP     | load the value in the inbox into the accumulator            |\n+-----------+---------+-------------------------------------------------------------+\n| 9xx       | OUT     | store the accumulator's value in the outbox                 |\n+-----------+---------+-------------------------------------------------------------+\n| xxx       | DAT xxx | store x at this instruction's address in RAM (should be     |\n|           |         | at the end of your program and is only executed by the      |\n|           |         | assembler)                                                  |\n+-----------+---------+-------------------------------------------------------------+\n\nNote that the program reads from and writes to RAM but is also stored in RAM\nitself and as a result, can modify itself. Believe it or not, this is a pretty\nuseful feature.\n\nChallenges:\n - Count from 0 to 10\n - Compute the fibonacci sequence\n - Compute prime numbers (I suggest brute force first, its easier and also\n   probably more efficient for the amount of RAM you have available)\n - Write a \"functional\" program (emulate functions with branching)\n   Hint: your program will have to modify itself\n - Implement a recursive algorithm, this is not well charted territory for me\n   but I am certain that indefinite (THEORETICALLY indefinite, you do have\n   limited RAM) recursion can be implemented\n*/\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 uv, in vec2 pos, in vec2 size, in int char) {\n    uv = (uv - pos) / size + 0.5;\n    vec2 charUv = uv / 16.0;\n    vec2 dfdx = dFdx(charUv);\n    vec2 dfdy = dFdy(charUv);\n    if (all(lessThan(abs(uv - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, charUv + fract(vec2(char, 15 - char / 16) / 16.0), dfdx, dfdy).r;\n        color = mix(color, charColor, val);\n    }\n}\n\nvoid drawInt(inout vec3 color, in vec3 fontColor, in vec2 uv, in vec2 pos, in vec2 digitSize, in int num, in int precis) {\n    float digitWidth = 0.5 * digitSize.x;\n    if (num < 0) drawChar(color, fontColor, uv, pos, digitSize, 45);\n    pos.x += digitWidth * float(precis);\n    num = abs(num);\n    for (int i=0; i < precis; i++) {\n        int digit = num % 10;\n        drawChar(color, fontColor, uv, pos, digitSize, 48 + digit);\n        num = (num - digit) / 10;\n        pos.x -= digitWidth;\n    }\n}\n\nconst int MAX_STR = 7;\nvoid drawString(in int[MAX_STR] str, in int len, inout vec3 color, in vec3 fontColor, in vec2 uv, in vec2 pos, in vec2 size, in float space) {\n    for (int i=0; i < len; i++) {\n        drawChar(color, fontColor, uv, pos, size, str[i]);\n        pos.x += space;\n    }\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Load registers\n    ivec4 registers = ivec4(texelFetch(iChannel0, ivec2(100, 0), 0));\n    int counter = registers.x;\n    int accum = registers.y;\n    int inbox = registers.z;\n    int outbox = registers.w;\n\n    // Display RAM\n    vec2 padding = vec2(0.015 * aspect, 0.05);\n    vec2 cellSize = vec2(0.084375 * aspect, 0.1);\n    vec2 halfCellSize = cellSize / 2.0;\n\n    // Grid\n    vec2 cellUv = uv + halfCellSize;\n    vec2 cellId = clamp(floor(cellUv / cellSize), 0.0, 10.0);\n    cellUv -= cellId * cellSize + halfCellSize;\n    drawSDF(abs(cellUv.x), vec3(1.0));\n    if (uv.x < 10.0 * cellSize.x) drawSDF(abs(cellUv.y), vec3(1.0));\n\n    // Draw memory cells\n    cellId = floor(uv / cellSize);\n    if (cellId.x >= 0.0 && cellId.x < 10.0 && cellId.y >= 0.0 && cellId.y < 10.0) {\n        // Load mailbox\n        int mailAddr = 10 * (9 - int(cellId.y)) + int(cellId.x);\n        int mailbox = int(texelFetch(iChannel0, ivec2(mailAddr, 0), 0).x);\n\n        // Display RAM address\n        vec2 drawPos = cellId * cellSize + padding;\n        drawPos.y += 0.02;\n        drawInt(color, vec3(1.0), uv, drawPos, vec2(0.05), mailAddr, 2);\n\n        // Display value\n        drawPos.y -= 0.04;\n        drawInt(color, vec3(0.0, 1.0, 0.0), uv, drawPos, vec2(0.05), mailbox, 3);\n        if (mailAddr == counter) color.r += 0.5;\n    }\n\n    // Display registers\n    vec2 drawPos = vec2(0.87890625 * aspect, 0.875);\n\n    // Counter\n    drawString(int[7](C, o, u, n, t, e, r), 7, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    drawInt(color, vec3(1.0), uv, drawPos, vec2(0.1), counter, 3);\n    drawPos.y -= 0.15;\n\n    // Accumulator\n    drawString(int[7](A, c, c, u, m, PERIOD, -1), 6, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    drawInt(color, vec3(1.0), uv, drawPos, vec2(0.1), accum, 3);\n    drawPos.y -= 0.15;\n\n    // Inbox (unused)\n    drawString(int[7](I, n, b, o, x, -1, -1), 5, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    drawInt(color, vec3(1.0), uv, drawPos, vec2(0.1), inbox, 3);\n    drawPos.y -= 0.15;\n\n    // Outbox\n    drawString(int[7](O, u, t, b, o, x, -1), 6, color, vec3(0.0, 0.0, 1.0), uv, drawPos + vec2(0.0, 0.0675), vec2(0.05), 0.025);\n    vec2 outboxUv = uv - drawPos;\n    float outboxIdx = round(-outboxUv.y / 0.15);\n    if (uv.x > 10.0 * cellSize.x && outboxIdx >= 0.0 && outboxIdx < 3.0) {\n        outboxUv.y += outboxIdx * 0.15;\n        int outboxHist = int(texelFetch(iChannel0, ivec2(outbox - int(outboxIdx) - 1, 1), 0).x);\n        drawInt(color, vec3(exp2(-outboxIdx)), outboxUv, vec2(0.0), vec2(0.1), outboxHist, 3);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 mailbox, in vec2 fragCoord) {\n    mailbox = vec4(0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int mailAddr = iFragCoord.x;\n    if (iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            // Assemble program\n            if (iFragCoord.y == 0 && iFragCoord.x < program.length()) {\n                ivec2 instr = program[mailAddr];\n                if (instr.x == DAT) { // Store variable\n                    mailbox.x = float(instr.y);\n                } else { // Encode and store instruction\n                    mailbox.x = float(instr.x * 100 + instr.y);\n                }\n            }\n\n            // Initialize registers\n            // program counter, accumulator, inbox, outbox\n            if (iFragCoord.y == 0 && iFragCoord.x == 100) {\n                mailbox = vec4(0, 0, 0, 0);\n            }\n        }\n\n        if (iFrame > 0) {\n            mailbox = texelFetch(iChannel0, iFragCoord, 0);\n            if (iFrame % INSTRUCTION_DELAY == 0 && iFragCoord.x <= 100) {\n                // Load registers\n                ivec4 registers = ivec4(texelFetch(iChannel0, ivec2(100, 0), 0));\n                int counter = registers.x;\n                int accum = registers.y;\n                int inbox = registers.z;\n                int outbox = registers.w;\n\n                if (inbox != -1) {\n                    // Load RAM\n                    int[100] mailboxes;\n                    for (int i=0; i < 100; i++) {\n                        mailboxes[i] = int(texelFetch(iChannel0, ivec2(i, 0), 0).x);\n                    }\n\n                    // Load current instruction\n                    int instr = mailboxes[counter];\n                    counter++;\n\n                    // Decode current instruction\n                    int addr = instr % 100;\n                    int opcode = (instr - addr) / 100;\n\n                    // Execute current instruction\n                    switch(opcode) {\n                        case HLT:\n                            inbox = -1;\n                            counter--;\n                            break;\n\n                        case ADD:\n                            accum += mailboxes[addr];\n                            break;\n\n                        case SUB:\n                            accum -= mailboxes[addr];\n                            break;\n\n                        case STA:\n                            mailboxes[addr] = accum;\n                            break;\n\n                        case LDA:\n                            accum = mailboxes[addr];\n                            break;\n\n                        case BRA:\n                            counter = addr;\n                            break;\n\n                        case BRZ:\n                            if (accum == 0) {\n                                counter = addr;\n                            } break;\n\n                        case BRP:\n                            if (accum >= 0) {\n                                counter = addr;\n                            } break;\n\n                        case INP:\n                            accum = inbox;\n                            break;\n\n                        case OUT:\n                            if (iFragCoord.y == 1 && iFragCoord.x == outbox) mailbox.x = float(accum);\n                            outbox++;\n                            break;\n                    }\n\n                    // Store updated state\n                    if (iFragCoord.y == 0 && iFragCoord.x < 100) mailbox.x = float(mailboxes[mailAddr]);\n                    if (iFragCoord.y == 0 && iFragCoord.x == 100) mailbox = vec4(counter, accum, inbox, outbox);\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define INSTRUCTION_DELAY 1\n\n// Opcodes\nconst int HLT = 0;\nconst int ADD = 1;\nconst int SUB = 2;\nconst int STA = 3;\nconst int LDA = 4;\nconst int BRA = 5;\nconst int BRZ = 6;\nconst int BRP = 7;\nconst int INP = 8;\nconst int OUT = 9;\nconst int DAT = 10;\n\n// Program to output the Recaman sequence\n// See https://en.wikipedia.org/wiki/Recam%C3%A1n's_sequence\n#define NUM 35 // Number of values to print out\nconst ivec2[] program = ivec2[](\n    ivec2(LDA,  55),\n    ivec2(SUB,  54),\n    ivec2(BRP,  52),\n    ivec2(LDA,  59),\n    ivec2(ADD,  60),\n    ivec2(STA,  10),\n    ivec2(LDA,  59),\n    ivec2(ADD,  64),\n    ivec2(STA,  59),\n    ivec2(LDA,  53),\n    ivec2(STA,  53),\n    ivec2(OUT,   0),\n    ivec2(LDA,  55),\n    ivec2(ADD,  64),\n    ivec2(STA,  55),\n    ivec2(LDA,  53),\n    ivec2(SUB,  55),\n    ivec2(STA,  56),\n    ivec2(LDA,  58),\n    ivec2(STA,  62),\n    ivec2(LDA,  63),\n    ivec2(STA,  57),\n    ivec2(LDA,  62),\n    ivec2(SUB,  59),\n    ivec2(BRP,  39),\n    ivec2(LDA,  62),\n    ivec2(ADD,  61),\n    ivec2(STA,  28),\n    ivec2(LDA,  53),\n    ivec2(SUB,  56),\n    ivec2(BRZ,  32),\n    ivec2(BRA,  35),\n    ivec2(LDA,  64),\n    ivec2(STA,  57),\n    ivec2(BRA,  39),\n    ivec2(LDA,  62),\n    ivec2(ADD,  64),\n    ivec2(STA,  62),\n    ivec2(BRA,  22),\n    ivec2(LDA,  63),\n    ivec2(SUB,  56),\n    ivec2(BRP,  48),\n    ivec2(LDA,  57),\n    ivec2(SUB,  64),\n    ivec2(BRZ,  48),\n    ivec2(LDA,  56),\n    ivec2(STA,  53),\n    ivec2(BRA,  51),\n    ivec2(LDA,  53),\n    ivec2(ADD,  55),\n    ivec2(STA,  53),\n    ivec2(BRA,   0),\n    ivec2(HLT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT, NUM),\n    ivec2(DAT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,  65),\n    ivec2(DAT,  65),\n    ivec2(STA,   0),\n    ivec2(LDA,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,   0),\n    ivec2(DAT,   1)\n);\n\n/*\n// For those interested, here's my original pseudocode\n// from before I wrote the final program (if you can understand it :))\n// I have converted the original program to store all variables after\n// the rest of the program\n00 dat 0     cur_val = 0\n01 dat 20    max_val = 20\n02 dat 0     index = 0\n03 dat 0     tent_val = 0\n04 dat 0     in_hist = 0\n05 dat 65    hist_start = 65\n06 dat 65    hist_end = 65\n07 dat 300   mod_1 = 300 \"18 sta ? :MODIFY_1:\"\n08 dat 400   mod_2 = 400 \"32 lda ? :MODIFY_2:\"\n09 dat 0     hist_index = 0\n10 dat 0     const_0 = 0\n11 dat 1     const_1 = 1\nmainloop:\n12 lda cur_val\n13 sub max_val\n14 brp end(mainloop)\n15 lda hist_end\n16 add mod_1\n17 sta MODIFY_1\n18 lda hist_end\n19 add const_1\n20 sta hist_end\n21 lda cur_val\n22 sta ? :MODIFY_1:\n23 out\n24 lda index\n25 add const_1\n26 sta index\n27 lda cur_val\n28 sub index\n29 sta tent_val\n30 lda hist_start\n31 sta hist_index\n32 lda const_0\n33 sta in_hist\ncheck_loop:\n34 lda hist_index\n35 sub hist_end\n36 brp end(check_loop)\n37 lda hist_index\n38 add mod_2\n39 sta MODIFY_2\n40 lda ? :MODIFY_2:\n41 sub tent_val\n42 brz jmp_pt_1\n43 bra jmp_pt2\n:jmp_pt_1:\n44 lda const_1\n45 sta in_hist\n46 bra end(check_loop)\n:jmp_pt_2:\n47 lda hist_index\n48 add const_1\n49 sta hist_index\n50 bra check_loop\n:end(check_loop)\n51 lda const_0\n52 sub tent_val\n53 brp other_case\n54 lda in_hist\n55 sub const_1\n56 brz other_case\n57 lda tent_val\n58 sta cur_val\n59 bra skip_point\nother_case:\n60 lda cur_val\n61 add index\n62 sta cur_val\n:skip_point:\n63 bra mainloop\n:end(mainloop)\n64 hlt\n65 HIST_START\n*/\n\n// Character codes for convenience\n// Generated with a python script I wrote to save me the trouble ;)\n// I had to change some of the names manually though.\nconst int SPACE = 32;\nconst int EXCLAMATION = 33;\nconst int DOUBLE_QUOTE = 34;\nconst int HASHTAG = 35;\nconst int DOLLAR = 36;\nconst int PERCENT = 37;\nconst int AMPERSAND = 38;\nconst int SINGLE_QUOTE = 39;\nconst int OPEN_PARENTHESIS = 40;\nconst int CLOSE_PARENTHESIS = 41;\nconst int ASTERISK = 42;\nconst int PLUS = 43;\nconst int COMMA = 44;\nconst int HYPHEN = 45;\nconst int PERIOD = 46;\nconst int SLASH = 47;\nconst int ZERO = 48;\nconst int ONE = 49;\nconst int TWO = 50;\nconst int THREE = 51;\nconst int FOUR = 52;\nconst int FIVE = 53;\nconst int SIX = 54;\nconst int SEVEN = 55;\nconst int EIGHT = 56;\nconst int NINE = 57;\nconst int COLON = 58;\nconst int SEMICOLON = 59;\nconst int LESS_THAN = 60;\nconst int EQUAL = 61;\nconst int GREATER_THAN = 62;\nconst int QUESTION = 63;\nconst int AT = 64;\nconst int A = 65;\nconst int B = 66;\nconst int C = 67;\nconst int D = 68;\nconst int E = 69;\nconst int F = 70;\nconst int G = 71;\nconst int H = 72;\nconst int I = 73;\nconst int J = 74;\nconst int K = 75;\nconst int L = 76;\nconst int M = 77;\nconst int N = 78;\nconst int O = 79;\nconst int P = 80;\nconst int Q = 81;\nconst int R = 82;\nconst int S = 83;\nconst int T = 84;\nconst int U = 85;\nconst int V = 86;\nconst int W = 87;\nconst int X = 88;\nconst int Y = 89;\nconst int Z = 90;\nconst int OPEN_BRACKET = 91;\nconst int BACKSLASH = 92;\nconst int CLOSE_BRACKET = 93;\nconst int CIRCUMFLEX = 94;\nconst int a = 97;\nconst int b = 98;\nconst int c = 99;\nconst int d = 100;\nconst int e = 101;\nconst int f = 102;\nconst int g = 103;\nconst int h = 104;\nconst int i = 105;\nconst int j = 106;\nconst int k = 107;\nconst int l = 108;\nconst int m = 109;\nconst int n = 110;\nconst int o = 111;\nconst int p = 112;\nconst int q = 113;\nconst int r = 114;\nconst int s = 115;\nconst int t = 116;\nconst int u = 117;\nconst int v = 118;\nconst int w = 119;\nconst int x = 120;\nconst int y = 121;\nconst int z = 122;\nconst int OPEN_BRACE = 123;\nconst int PIPE = 124;\nconst int CLOSE_BRACE = 125;\nconst int TILDE = 126;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3421, 3499, 3603, 3603, 3938], [3940, 3940, 4062, 4062, 4440], [4814, 4814, 4869, 4869, 7719]], "test": "untested"}
{"id": "DdBXDt", "name": "DDA Raytracing", "author": "FifthStateOfMatter", "description": "3D", "tags": ["3d", "raytracing"], "likes": 10, "viewed": 620, "published": 3, "date": "1671063964", "time_retrieved": "2024-07-30T16:12:50.562441", "image_code": "const float PI = 3.1415926535;\nconst float degreesToRadians = PI/180.0;\nconst float FOV = 90.0*degreesToRadians;\nconst float fogDensity = 1.5;\nconst float f = 1.0/tan(FOV/2.0);\n\nfloat random3(vec3 p){\n    return fract((sin(p.x*203.24 + 20398.243)*sin(p.y*834.29 + 2382.2033)*sin(p.z*405.09))*20384.043);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = smoothstep(0.0, 1.0, frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\nstruct camera{\n    vec3 o;\n    vec3 d;\n};\n\n//Thanks to @fb39ca4 for the idea to use an SDF to detect block hits\nfloat yPlaneSDF(vec3 p, float y){\n    return p.y - y;\n}\n\nbool hitCube(ivec3 p, out int type){\n    float check = yPlaneSDF(vec3(p), -5.0);\n    check -= noise3(vec3(p)*0.1)*20.0;\n    p.y > 10 ? type = 4 : (p.y <= 10 && p.y > 1 ? type = 1 : (p.y <= 1 && p.y > -1 ? type = 3 : type = 2));\n    bool outBool;\n    type == 2 ? outBool = true : outBool = int(check) < 1;\n    if(!outBool){\n        type = 0;\n    }\n    return outBool;\n}\n\nbool raytrace(vec3 o, vec3 d, out vec3 normal, out float t, out int type){\n    bool hit;\n    ivec3 oCell = ivec3(floor(o));\n    vec3 delta1 = d.yxx/d;\n    vec3 delta2 = d.zzy/d;\n    vec3 stepLength = sqrt(1.0 + delta1*delta1 + delta2*delta2);\n    \n    bvec3 dSign = lessThan(d, vec3(0));\n    \n    vec3 rayLength;\n    ivec3 stepSign;\n        \n    if(dSign.x){\n        stepSign.x = -1;\n        rayLength.x = (o.x - float(oCell.x))*stepLength.x;\n    }else{\n        stepSign.x = 1;\n        rayLength.x = (float(oCell.x) + 1.0 - o.x)*stepLength.x;\n    }\n    \n    if(dSign.y){\n        stepSign.y = -1;\n        rayLength.y = (o.y - float(oCell.y))*stepLength.y;\n    }else{\n        stepSign.y = 1;\n        rayLength.y = (float(oCell.y) + 1.0 - o.y)*stepLength.y;\n    }\n    \n    if(dSign.z){\n        stepSign.z = -1;\n        rayLength.z = (o.z - float(oCell.z))*stepLength.z;\n    }else{\n        stepSign.z = 1;\n        rayLength.z = (float(oCell.z) + 1.0 - o.z)*stepLength.z;\n    }\n    \n    for(int i = 0; i < 200 && !hit; i++){\n        if(min(rayLength.x, min(rayLength.y, rayLength.z)) == rayLength.x){\n            oCell.x += stepSign.x;\n            rayLength.x += stepLength.x;\n            normal = vec3(-1.0*sign(d.x), 0, 0);\n            t = rayLength.x - stepLength.x;\n        }else if(min(rayLength.x, min(rayLength.y, rayLength.z)) == rayLength.y){\n            oCell.y += stepSign.y;\n            rayLength.y += stepLength.y;\n            normal = vec3(0, -1.0*sign(d.y), 0);\n            t = rayLength.y - stepLength.y;\n        }else if(min(rayLength.x, min(rayLength.y, rayLength.z)) == rayLength.z){\n            oCell.z += stepSign.z;\n            rayLength.z += stepLength.z;\n            normal = vec3(0, 0, -1.0*sign(d.z));\n            t = rayLength.z - stepLength.z;\n        }\n        \n        //if(!(oCell.x < 0 || oCell.x > sceneLength.x - 1 || oCell.y < 0 || oCell.y > sceneLength.y - 1 || oCell.z < 0 || oCell.z > sceneLength.z - 1)){\n            //blocks[int(oCell.x + (sceneLength.y*sceneLength.y - oCell.y*sceneLength.y - sceneLength.y) + oCell.z*sceneLength.x*sceneLength.y)] != 0 ? hit = true : hit = false;\n            //type = blocks[oCell.x + (sceneLength.y*sceneLength.y - oCell.y*sceneLength.y - sceneLength.y) + oCell.z*sceneLength.x*sceneLength.y];\n        //}\n        \n        if(hitCube(oCell, type)){\n            hit = true;\n        }\n    }\n    \n    return hit;\n}\n\nfloat getLighting(vec3 h, vec3 normal, vec3 lpos){\n    vec3 lRay = normalize(lpos - h);\n    float c = dot(normal, lRay);\n    \n    vec3 ln;\n    float lt;\n    int lType;\n    bool rl = raytrace(h, lRay, ln, lt, lType);\n    \n    if(rl){\n        c -= 0.4;\n    }else{\n        c = dot(normal, lRay);\n    }\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    float v = 15.0;\n    camera cam = camera(vec3(0, 16.0, iTime*3.0), vec3(10.0*degreesToRadians, 0, 0));\n    vec3 lPos = cam.o + vec3(100, 100, -100);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 fogColor = mix(vec3(0.2, 0.4, 1), vec3(0.7, 0.9, 1), min(1.0 - uv.y, 1.0));\n    \n    mat3 projection;\n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    vec3 col = fogColor;\n    \n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(cam.d.x), -sin(cam.d.x));\n    xRotation[2] = vec3(0, sin(cam.d.x), cos(cam.d.x));\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cos(cam.d.y), 0, -sin(cam.d.y));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(cam.d.y), 0, cos(cam.d.y));\n    \n    vec3 o = cam.o;\n    vec3 d = normalize(vec3(uv, 1)*(xRotation*yRotation)*projection);\n    vec3 normal;\n    float t;\n    int type;\n    \n    bool r = raytrace(o, d, normal, t, type);\n    \n    if(r){\n        float c = getLighting(o + d*t, normal, lPos);\n        vec3 sideCol;\n        if(type == 1){\n            if(normal.y == 1.0){\n                sideCol = vec3(0.2, 0.8, 0.4);\n            }else{\n                sideCol = vec3(0.7, 0.5, 0.35);\n            }\n        }else if(type == 2){\n            sideCol = vec3(0, 0.3, 0.8);\n        }else if(type == 3){\n            sideCol = vec3(1, 0.9, 0.6);\n        }else if(type == 4){\n            sideCol = vec3(0.85);\n        }\n        col = mix(sideCol*max(c, 0.1), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBXDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 200, 200, 305], [307, 307, 328, 328, 1164], [1209, 1278, 1311, 1311, 1333], [1335, 1335, 1371, 1371, 1703], [4089, 4089, 4139, 4139, 4408], [4410, 4410, 4461, 4461, 6100]], "test": "untested"}
{"id": "DsBXWd", "name": "dist square with swiggles", "author": "jonasfrey", "description": "square", "tags": ["square"], "likes": 6, "viewed": 194, "published": 3, "date": "1671059618", "time_retrieved": "2024-07-30T16:12:51.319417", "image_code": "float n_tau = 6.2831;\n    \nfloat f_n_dist_sqr_swiggle(vec2 o, float n_amp){\n\n    float n_max = max(abs(o.x), abs(o.y));\n    float n_min = min(abs(o.x), abs(o.y));\n    return n_max + sin(n_min*n_tau)*n_amp;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    o_trpino*= (sin(iTime*0.1)*0.5+0.5)*20.+2.;\n    float n_dist = length(o_trpino);\n    float n = f_n_dist_sqr_swiggle(o_trpino, sin(iTime*n_tau*0.5+n_dist*0.5)*0.5);\n    \n    fragColor = vec4(sin(n*n_tau*2.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 75, 75, 207], [208, 208, 265, 265, 740]], "test": "untested"}
{"id": "DsSXWd", "name": "desktop bg", "author": "jonasfrey", "description": "just a quick desktop bg", "tags": ["desktopbg"], "likes": 2, "viewed": 205, "published": 3, "date": "1671058578", "time_retrieved": "2024-07-30T16:12:52.109305", "image_code": "float f_n_dist_sqr(vec2 o){\n    return max(abs(o.x), abs(o.y));\n}\nfloat f_nor_inout(float n){\n    float b_gt1 = float((n*2.)>1.);\n    return (1.-b_gt1)*(n*2.) + b_gt1 * (2. - (n*2.)); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trpino = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    \n    float n = f_n_dist_sqr(o_trpino);\n    n = f_nor_inout(n);\n\n    float n_its = 5.;\n    float n_min = 1.;\n    vec2 o = o_trpino;\n    float n_tau = 6.2831;\n    vec3 o_col = vec3(0.);\n    for(float n_it_nr = 0.; n_it_nr < 1.; n_it_nr+=1./n_its){\n        float n_ang = n_tau*n_it_nr;\n        vec2 o_rtdt = vec2(\n            cos(n_ang)*o.x + -sin(n_ang)*o.y,\n            sin(n_ang)*o.x + cos(n_ang)*o.y\n        );\n        n = f_n_dist_sqr(o_rtdt);\n        n = f_nor_inout(n);\n        n = fract(n*n_its);\n        if(n < n_min){\n            n_min = n;\n            o_col = vec3(n_it_nr);\n        }\n    }\n    float n_dist = length(o_trpino);\n    fragColor = vec4(\n        n_min*n_dist,\n        0., \n        o_col.b*n_dist*n_dist*n_dist*n_min+sin(n_dist*n_its*n_tau)*0.2, \n        1.\n    );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 65], [66, 66, 93, 93, 186], [187, 187, 244, 294, 1154]], "test": "untested"}
{"id": "csSSWd", "name": "Mouseable selection rectangle", "author": "fishy", "description": "By nsf, all I did was add mouse functionality. Click-drag for selection box", "tags": ["2d", "effect", "animation", "rectangle", "outline", "selection"], "likes": 10, "viewed": 261, "published": 3, "date": "1671053902", "time_retrieved": "2024-07-30T16:12:52.866281", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 m = iMouse.xyzw/iResolution.xyxy;\n    \n    if(m.z <= 0.)\n    {\n        m.xy = vec2(0.5);\n        m.zw = 0.5+vec2(sin(iTime), cos(iTime))*0.5;\n    }\n    \n    m.zw = abs(m.zw);\n    \n    // rect boundaries\n    vec2 rectMin = m.xy;\n    vec2 rectMax = m.zw;\n    \n    if(rectMin.x>rectMax.x)\n    {\n        rectMin.x += rectMax.x;\n        rectMax.x = rectMin.x-rectMax.x;\n        rectMin.x = rectMin.x-rectMax.x;\n    }\n    \n    if(rectMin.y>rectMax.y)\n    {\n        rectMin.y += rectMax.y;\n        rectMax.y = rectMin.y-rectMax.y;\n        rectMin.y = rectMin.y-rectMax.y;\n    }\n    \n    // some people prefer \"min + (max - min) / 2\", but for floating point UV space it\n    // doesn't matter\n    vec2 center = (rectMin + rectMax) / 2.;\n    vec2 halfSize = center - rectMin;\n    vec2 fw = fwidth(uv);\n    \n    vec2 dist = abs(uv - center);\n    \n    float col = 0.0;\n    if (all(lessThan(dist, halfSize)) && any(greaterThan(dist, halfSize - fw))) {\n        // for pixel here I could use fragCoord.xy, but on textures you don't have it\n        // using fwidth is a tricky way to operate in screenspace sizes on all surfaces\n        // of course it's an approximation, but it's a pretty good one, here, uncomment this \n        // line to try fragCoord, it gives almost the same result:\n        //vec2 pixel = fragCoord.xy;\n        vec2 pixel = uv / fw;\n        float aspect = halfSize.y / halfSize.x;\n        float dir = (dist.x * aspect > dist.y) ?\n              -sign(uv.x - center.x) : sign(uv.y - center.y);\n        float dash = step(0.5, fract((pixel.x + pixel.y) * dir / 10.0 + iTime));\n        col = mix(1.0, 0.0, dash);\n    }\n    \n\tfragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1776]], "test": "untested"}
{"id": "cdjSDc", "name": "[phreax] being synced", "author": "phreax", "description": "Music synced version of an older project of mine (https://www.shadertoy.com/view/WtG3Rd)\n\nWatch at least 90 seconds in fullscreen - enjoy the ride!", "tags": ["2d", "rainbow", "kifs"], "likes": 12, "viewed": 337, "published": 3, "date": "1671044156", "time_retrieved": "2024-07-30T16:12:53.667140", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2020\n\n   Elaboration of by previous experiment https://www.shadertoy.com/view/wlV3zy\n   and https://shadertoy.com/view/WtG3Rd\n\n   Introducing more kaleidoscopic shapes as attractor for the basic kifs pattern.\n   The attractor idea goes to evvvvil - it's very interesting method to shape your kifs.\n*/\n\n#define PI 3.141592\n#define TAU 2.*PI\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define COUNT 40.\n#define N 10.\n#define DISTORT .6\n#define SQR(x) ((x)*(x))\n#define SIN(x) sin(x)*.5+.5\n#define T iChannelTime[0]\n#define S(a, b) smoothstep(a, b, T)\n#define F(a, b, s) (S(a, a+s)-S(b, b+s))\n#define F2(a, b, s1, s2) (S(a, a+s1)-S(b, b+s2))\n#define F3(t, s1, s2) (F2(t, t, s1, s2))\n\nfloat tt;\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 5.));\n}\n\nfloat flower(vec2 uv) {\n    float n = 3.;\n    float a = atan(uv.y,uv.x);\n\n    float d = length( uv) - cos(a*n);\n    \n    float emph = .1*F2(20.6, 21., .2, 2.)+.07*F3(35.4, .2, 1.5);\n    emph += .03*F2(50.4, 50.4, .2, 1.);\n    emph += .05*F3(64., .2, 1.);\n    emph += .07*F3(65., .2, 1.);\n    emph += .1*F3(79.8, .2, 1.);\n    emph += .1*F3(88.8, .2, 1.);\n    emph += .15*F3(57.4, .2, 1.);\n    emph += .1*F3(72.4, .2, 1.);\n    emph += .1*F3(93.4, .2, 1.);\n    emph += .15*F3(109.3, .2, 1.);\n    emph += .1*F3(118.3, .2, 1.);\n    emph += .1*F3(124., .2, 1.);\n    emph += .1*F3(133.3, .2, 1.);\n    emph += .1*F3(138.8, .2, 1.);\n    emph += .1*F3(153.7, .2, 1.);\n    emph += .1*F3(183., .2, 1.);\n    emph += .1*F3(257., .2, 1.5);\n    emph += .07*F3(271.8, .2, 1.);\n    return smoothstep(fwidth(d)+.01, -.07, abs(d+.2)-emph);    \n}\n\n\n// from \"Palettes\" by iq. https://shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getPal(int id, float t) {\n\n    id = id % 7;\n\n    vec3          col = pal( t, vec3(.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,-0.33,0.33) );\n    if( id == 1 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( id == 2 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( id == 3 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( id == 4 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( id == 5 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( id == 6 ) col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    return col;\n}\n\n\n\nfloat entity(vec2 uv) {\n    \n\tuv *= mix(.1, .7, smoothstep(0., 14., tt));       // transition effect in the beginning\n \tuv = mix(fract(uv*.2-.5)-.5, uv, smoothstep(14., 14., tt));\n    \n\n    uv *= rot(PI/2.);\n\n    vec2 bp = uv;\n    \n    uv = abs(uv)-.2;\n        \n    uv *= rot(-0.5*tt);\n    uv = abs(uv-.2*SIN(tt))-.2;\n    uv *= rot(0.93*tt);\n    \n    if(tt < 14.) bp.x = abs(bp.x);\n    uv += smoothstep(0.0, 1., bp.x);\n\n    \n    float r = length(uv);\n    float a = atan(uv.y,uv.x);\n\n    float f = cos(a*4.);\n    \n    return smoothstep(f, (f+.1), r); \n}\n\nvec2 kalei(vec2 uv) { \n    vec2 bp = uv;\n\n    float n = N;\n    float r = TAU/n;\n    \n    float at = entity(uv);\n    for(float i=0.; i<n; i++) {     \n    \tuv = abs(uv);\n        uv.x -= (.2*i*at)+.2;\n    \tuv *= rot(r*i-.2*tt-.1*at);\n    }\n\n    uv = abs(uv) - (sin(.15*tt)+1.2);\n    \n    return uv;\n}\n\n\nvec3 spiral(vec2 uv, float i) {  \n    uv *= rot(i*PI+tt*.3);\n    uv += DISTORT*sin(5.*uv.yx);\n\treturn flower(uv)*SQR(getPal(0, i+tt*.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n   // uv *= rot(-.5*PI);\n\n    if(T < 20.) tt = .7*T;\n    else tt = (.7*20.) + (T*0.99-20.)*.5;\n    \n    if(T > 50.35 && T < 79.8) {\n        tt += 2.*curve(T+.3 ,1.);\n    }\n    uv = kalei(uv*5.);\n\n    float s = 1./COUNT;\n\t\n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        float fade = smoothstep(0., .2, 1.-abs(2.*z-1.));\n        col += spiral(uv*z, i)*fade;\n    }\n\n    \n    col = sqrt(col);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 31284, "src": "https://soundcloud.com/thordavid1968/abakus-igmatik", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjSDc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[838, 850, 881, 881, 965], [967, 967, 990, 990, 1792], [1795, 1855, 1923, 1923, 1966], [1968, 1968, 1998, 1998, 2803], [2807, 2807, 2830, 2830, 3359], [3361, 3361, 3382, 3382, 3658], [3661, 3661, 3692, 3692, 3800], [3802, 3802, 3859, 3859, 4397]], "test": "untested"}
{"id": "mdjXDc", "name": "Shifting Shader Fractal Fun", "author": "trafficone", "description": "Every once in a while I get the \"Mandelbrot Set\" by Jonathan Coulton stuck in my head and I get the desire to write an implementation.\nThis one shifts the constant *c* over time to create swirling patterns.\n\nThis one is my favorite so far! Enjoy!", "tags": ["2d", "fractal", "colorful", "juliaset", "mandlebrotset", "joco"], "likes": 2, "viewed": 222, "published": 3, "date": "1671043812", "time_retrieved": "2024-07-30T16:12:54.421124", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define cx_mul(a,b) mat2(a,-a.y,a.x) * b\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec2 z = 2.* ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n  vec2 c = 0.36+0.02*vec2(sin(0.35*iTime),\n  \tcos(0.13*iTime));\n  for (int i=0;i<80;i++) {\n  \tz = cx_mul(z,z) + c;\n  }\n  vec3 color = fract(vec3(z.x/100.0,z.y,length(z)));\n  \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 195, 195, 508]], "test": "untested"}
{"id": "NtyyWt", "name": "Psychedelic plasma rogo1965", "author": "rogo1965", "description": "Psytrance plasma", "tags": ["voronoi", "plasma"], "likes": 3, "viewed": 203, "published": 3, "date": "1671043591", "time_retrieved": "2024-07-30T16:12:55.188073", "image_code": "\n#define DISCO 1\n#define time iTime*.05+300.\n#define tau 6.2831\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    \n    return fract(sin(p)*18.5453);\n}\n\n\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(time+tau*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    p-=20.;\n    p.x+=22.*sin(0.1*iTime)/15.;\n    p.y+=22.*cos(0.1*iTime)/15.;\n    p *= .9;\n    //p.y+=.45;\n    // compute voronoi patterm\n    vec2 c = p/20.*voronoi( (8.0+2.0*sin(0.2*time))*p*fbm(p) );\n    //c = c-voronoi( (8.0+2.0*sin(0.2*time))*p*fbm(p) );\n\n    vec2 stt =  vec2(atan(c.x,p.y), length(p));\n    #if DISCO\n    stt = stt+voronoi( (1.0+2.0*sin(0.2*time))*p*fbm(p) );\n    #endif\n    // colorize\n    //vec3 col =  vec3(c.y,c.x,1.-p.x) ;\t\n    vec3 col = 0.5 + 0.5*cos( stt.y*stt.x*6.2831 + vec3(0.0,smoothstep( 0.08, 0.7, fbm(stt)),smoothstep( 0.7, 0.9, fbm(stt))) );\t\n    // gradient\n    //col *= clamp(1.0 - 0.4*c.x*c.x,0.0,1.0);\n    col *= vec3(0.5+0.5*cos(44.*time),0.5+0.5*sin(22.*time),0.5+0.5*sin(11.*time));\n    // dots\n    //col -= (1.0-smoothstep( 0.08, 0.09, c.x));\n    \n    // the matrix color effect\n    col.r = pow(col.r,3./2.);\n    col.g = pow(col.g,4./5.);\n    col.g = pow(col.g,3./2.);\n\t\n    fragColor = vec4( col, 1.0 );\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 116, 236], [241, 309, 327, 434, 922], [923, 1001, 1019, 1019, 1092], [1095, 1127, 1154, 1154, 1577], [1579, 1579, 1636, 1636, 2652]], "test": "untested"}
{"id": "ms2SW3", "name": "[Gegell] Boids", "author": "Gegell", "description": "Learnt voronoi tracking from https://shadertoyunofficial.wordpress.com/ and https://www.shadertoy.com/view/3ty3Dy\nImplemented simple boids with it. Mouse down -> add swirl force.", "tags": ["boids", "voronoitracking"], "likes": 18, "viewed": 655, "published": 3, "date": "1671043576", "time_retrieved": "2024-07-30T16:12:56.258212", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec4 closest_indices = floatBitsToUint(texelFetch(iChannel1, ivec2(fragCoord), 0));\n   \n    float overlapping = 0.;\n    for (int i = 3; i >= 0; i--) {\n        uint id =  closest_indices[i];\n        if (id == -1u)\n            break;\n            \n        Entity e = decodeEntity(iChannel0, id);\n        float new_dist = distanceWrapping(e.position, fragCoord, iResolution.xy);\n        overlapping += smoothstep(1., 0., new_dist - BOID_RADIUS);\n    }\n    \n    // Closest id color\n    vec4 closest_color = entityColor(closest_indices.x);\n    fragColor = closest_color;\n    \n    // UV position of closest particle in data buffer (iChannel0)\n    fragColor = vec4(vec2(toMultiID(closest_indices.x, textureSize(iChannel0, 0))) / iResolution.xy, 0., 1.);\n    \n    // All ids mapped to a 0-1 color\n    fragColor = vec4(closest_indices) / float(PARTICLE_COUNT);\n    \n    // Raw data\n    Entity e = decodeEntity(iChannel0, ivec2(fragCoord));\n    fragColor = vec4(e.position / iResolution.xy, 0., 0.);\n    \n    // Overlapping count view\n    fragColor = vec4(overlapping / 4.);\n    \n    // Colored particles\n    fragColor = mix(vec4(0), closest_color, smoothstep(0., 1., overlapping));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const uint PARTICLE_COUNT = 10000u;\nconst float TIMESTEP_MULT = 2.0;\nconst float MAX_VELOCITY = 150.0;\n\nconst float BOID_RADIUS = 1.0;\nconst float BOID_MASS = 0.02;\n\nconst float COHESION_STRENGTH = 0.6;\nconst float COHESION_MAX_DIST = 100.;\n\nconst float ALIGNMENT_STRENGTH = 0.05;\nconst float ALIGNMENT_MAX_VEL = 50.;\n\nconst float SEPARATION_STRENGTH_COLLISION = 10.0;\nconst float SEPARATION_STRENGTH_SIMILARITY = 1.0;\nconst float SEPARATION_DISTANCE_SIMILAR = 4.;\nconst float SEPARATION_DISTANCE_DISSIMILAR = 12.;\n\nconst float DESIRE_STRENGTH = 0.002;\nconst vec2  DESIRE_MIN_MAX_VEL = vec2(20., 50.);\n\nconst float MOUSE_BRUSH_RADIUS = 200.;\nconst float MOUSE_BRUSH_STRENGTH = 1.;\nconst vec2  MOUSE_BRUSH_DIV_CURL_WEIGHTS = vec2(-0.2, 1);\n\n\n#define FLOAT_INF uintBitsToFloat(0x7f800000u)\n\n// Randomization and hashes\nuint murmur3( in uint u )\n{\n  u ^= ( u >> 16 ); u *= 0x85EBCA6Bu;\n  u ^= ( u >> 13 ); u *= 0xC2B2AE35u;\n  u ^= ( u >> 16 );\n\n  return u;\n}\n\n// RNG from https://de.wikipedia.org/wiki/Xorshift\nuint rngSeed = 314159265u;\n\nuint xorshift(in uint value) {\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nuint nextUint(inout uint state) {\n    state = xorshift(state);\n    return state;\n}\nuint nextUint() {return nextUint(rngSeed);}\n\nfloat nextFloat(inout uint state) {return float(nextUint(state)) / float(uint(-1));}\nfloat nextFloat() {return nextFloat(rngSeed);}\n\nvec3 nextVec3(inout uint state) {return vec3(nextFloat(state), nextFloat(state), nextFloat(state));}\nvec3 nextVec3() {return nextVec3(rngSeed);}\n\n// Color functions\t\nvec3 hue(float h)\t{\n    h = fract(h);\n    float r = abs(h * 6. - 3.) - 1.;\n    float g = 2. - abs(h * 6. - 2.);\n    float b = 2. - abs(h * 6. - 4.);\n    return clamp(vec3(r, g, b), 0., 1.);\n}\n\nvec4 HSVtoRGB(vec3 hsv) {\n    return vec4(((hue(hsv.x) - 1.) * hsv.y + 1.) * hsv.z, 1.);\n}\n\n// 1D / 2D index handling\nuint wrapFlatID(uint flatID) {\n    return flatID % PARTICLE_COUNT;\n}\n\nvec2 wrapMultiID(vec2 id, vec2 resolution) {\n    return fract(id / resolution) * resolution;\n}\n\nuint toFlatID(vec2 id, vec2 resolution) {\n    return uint(id.x + id.y * resolution.x);\n}\n\nivec2 toMultiID(uint flatID, ivec2 resolution) {\n    return ivec2(flatID, flatID / uint(resolution.x)) % resolution;\n}\n\n// Entity datastructure definition\nstruct Entity {\n    vec2 position;\n    vec2 velocity;\n};\n\nEntity decodeEntity(sampler2D sampler, ivec2 id) {\n    vec4 raw = texelFetch(sampler, id, 0);\n    Entity e;\n    e.position = raw.rg;\n    e.velocity = raw.ba;\n    return e;\n}\n\nEntity decodeEntity(sampler2D sampler, uint flatID) {\n    return decodeEntity(sampler, toMultiID(flatID, textureSize(sampler, 0)));\n}\n\nvec4 encodeEntity(Entity e) {\n    return vec4(e.position, e.velocity);\n}\n\nconst Entity INVALID_ENTITY = Entity(vec2(-FLOAT_INF), vec2(0));\n\n// Procedural entity fields\nvec2 entityInterpolants(uint flatID) {\n    uint state = murmur3(murmur3(flatID));\n    return vec2(nextFloat(state), nextFloat(state));\n}\n\nvec2 desireMotion(vec2 t) {\n    float angle = t.x * 3.1415629 * 2.;\n    return vec2(sin(angle), cos(angle)) * mix(DESIRE_MIN_MAX_VEL.x, DESIRE_MIN_MAX_VEL.y, t.y);\n}\n\nvec2 desireMotion(uint flatID) {\n    return desireMotion(entityInterpolants(flatID));\n}\n\nvec4 entityColor(vec2 t) {\n    return HSVtoRGB(vec3(t.x, t.y*.6+.4, t.y*.4+.8));\n}\n\nvec4 entityColor(uint flatID) {\n    return entityColor(entityInterpolants(flatID));\n}\n\n// Buffer specific functions\nuvec4 fetchClosest(vec2 position, sampler2D voro_buffer) {\n    return floatBitsToUint(texelFetch(voro_buffer, ivec2(wrapMultiID(position, vec2(textureSize(voro_buffer, 0)))), 0));\n}\n\n// Wrapping distance\nvec2 diffWrapping(vec2 a, vec2 b, vec2 bounds) {\n    vec2 d = a-b;\n    return d - round(d/bounds) * bounds;\n}\n\nfloat distanceWrapping(vec2 a, vec2 b, vec2 bounds) {\n    return length(diffWrapping(a,b,bounds));\n}", "buffer_a_code": "// Data pass\n// Every pixel corresponds to a single entity somewhere in space\n\n#define clampLength(v, l) ((v)/max(length(v)/l, 1.))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint flatID = toFlatID(floor(fragCoord), vec2(textureSize(iChannel0, 0)));\n    fragColor = encodeEntity(INVALID_ENTITY);\n    if (flatID >= PARTICLE_COUNT)\n        return;\n    \n    Entity current;\n    if (iFrame <= 3) {\n        // Init a random particle entity\n        uint state = murmur3(flatID);\n        current.position = vec2(nextFloat(state), nextFloat(state)) * iResolution.xy;\n        current.velocity = (vec2(nextFloat(state), nextFloat(state)) * 2. - 1.) * .5;\n    } else {\n        // Fetch the current entity\n        current = decodeEntity(iChannel0, flatID);\n    }\n    vec2 interpolants = entityInterpolants(flatID);\n    vec2 desire = desireMotion(interpolants);\n    \n    //\n    // Boid computations\n    //\n    vec2 force = vec2(0);\n    uvec4 closest = fetchClosest(current.position, iChannel1);\n    \n    float counted = 0.;\n    vec2 average_offset   = vec2(0.);\n    vec2 average_velocity = vec2(0.);\n    \n    for (int i = 0; i < 4; i++) {\n        if (closest[i] == flatID || closest[i] == -1u)\n            continue;\n        Entity other = decodeEntity(iChannel0, closest[i]);\n        vec2 otherInterpolants = entityInterpolants(closest[i]);\n        \n        // Separation\n        vec2 diff = diffWrapping(other.position, current.position, iResolution.xy);\n        float dissimiliarity = interpolants.x - otherInterpolants.x;\n        dissimiliarity = abs(dissimiliarity - round(dissimiliarity)) * 2.;\n        \n        float sep_dist = 2. * BOID_RADIUS;\n        float strength = max(1. - length(diff) / sep_dist, 0.) * SEPARATION_STRENGTH_COLLISION;\n        sep_dist += mix(SEPARATION_DISTANCE_SIMILAR, SEPARATION_DISTANCE_DISSIMILAR, dissimiliarity);\n        strength += max(1. - length(diff) / sep_dist, 0.) * SEPARATION_STRENGTH_SIMILARITY; \n        force += -diff * strength;\n        \n        // Averaging\n        counted ++;\n        average_offset += diffWrapping(other.position, current.position, iResolution.xy);\n        average_velocity += other.velocity;\n    }\n    average_offset /= counted;\n    average_velocity /= counted;\n    \n    // Cohesion\n    force += clampLength(average_offset, COHESION_MAX_DIST) * COHESION_STRENGTH;\n    \n    // Alignment\n    force += clampLength(average_velocity - current.velocity, ALIGNMENT_MAX_VEL) * ALIGNMENT_STRENGTH;\n    \n    // Desired velocity\n    force += clampLength(desire - current.velocity, DESIRE_MIN_MAX_VEL.y) * DESIRE_STRENGTH;\n    \n    // Mouse interactivity\n    if (sign(iMouse.z) > 0.) {\n        vec2 diff = diffWrapping(iMouse.xy, current.position, iResolution.xy) / MOUSE_BRUSH_RADIUS;\n        float strength = 1. - length(diff);\n        if (strength > 0.) {\n            vec2 brush_force = mat2(-diff.x, -diff.y, diff.y, -diff.x) * MOUSE_BRUSH_DIV_CURL_WEIGHTS * MOUSE_BRUSH_STRENGTH;\n            force = mix(force, brush_force, smoothstep(0., 1., strength));\n        }\n    }\n    \n    //\n    // Actually update the position\n    //\n    float dt = iTimeDelta * TIMESTEP_MULT;\n    vec2 acceleration = force / BOID_MASS;\n    \n    current.velocity += acceleration * dt;\n    current.velocity = clampLength(current.velocity, MAX_VELOCITY);\n    current.position += current.velocity * dt;\n    current.position = fract(current.position / iResolution.xy) * iResolution.xy;\n    \n    // Write back to the same location\n    fragColor = encodeEntity(current);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Voronoi pass\n// Every pixel contains the ID of the 4 closest entities in Buffer A\n\n\n// Merge the distances & current best found entity indices with a neighbouring indice vector\nvoid listInsert( inout vec4 distances, inout uvec4 id_list, in uint id_to_insert, in vec2 cell_center ) {\n    if (id_to_insert == uint(-1) || any(equal(id_list, uvec4(id_to_insert)))) {\n        return;\n    } \n\n    Entity e = decodeEntity(iChannel0, id_to_insert);\n    float dist = distanceWrapping(cell_center, e.position, iResolution.xy);\n    \n    if (dist < distances[0]) {\n        distances = vec4(dist, distances.xyz);             id_list = uvec4(id_to_insert, id_list.xyz);\n    } else if (dist < distances[1]) {\n        distances = vec4(distances.x, dist, distances.yz); id_list = uvec4(id_list.x, id_to_insert, id_list.yz);\n    } else if (dist < distances[2]) {\n        distances = vec4(distances.xy, dist, distances.z); id_list = uvec4(id_list.xy, id_to_insert, id_list.z);\n    } else if (dist < distances[3]) {\n        distances = vec4(distances.xyz, dist);             id_list = uvec4(id_list.xyz, id_to_insert);\n    }\n}\n\nvoid mergeVoroCell( inout vec4 distances, inout uvec4 id_list, in vec2 sample_point, in vec2 cell_center ) {\n    uvec4 ids = fetchClosest(sample_point, iChannel1);\n    for (int i = 0; i < 4; i++) {\n        listInsert(distances, id_list, ids[i], cell_center);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get current\n    uvec4 closest_indices = uvec4(-1);\n    vec4 best_distances = vec4(FLOAT_INF);\n    \n    // Merge with the closest from all 4 neighbors\n    mergeVoroCell(best_distances, closest_indices, fragCoord, fragCoord);\n    mergeVoroCell(best_distances, closest_indices, fragCoord + vec2( 0, -1), fragCoord);\n    mergeVoroCell(best_distances, closest_indices, fragCoord + vec2( 0,  1), fragCoord);\n    mergeVoroCell(best_distances, closest_indices, fragCoord + vec2(-1,  0), fragCoord);\n    mergeVoroCell(best_distances, closest_indices, fragCoord + vec2( 1,  0), fragCoord);\n    \n    rngSeed = murmur3(floatBitsToUint(fragCoord.x)) ^ murmur3(floatBitsToUint(fragCoord.y)) ^ murmur3(floatBitsToUint(iTime));\n#if 0\n    // Merge with random nearby neighbor in larger neighborhood\n    for (int i = 0; i < 16; i++) {\n        vec2 neighborTap = vec2(nextFloat(), nextFloat()) * 8. - 4.;\n        neighborTap *= float(i + 1);\n        mergeVoroCell(best_distances, closest_indices, fragCoord + neighborTap, fragCoord);\n    }\n#endif\n    \n#if 1\n    // Merge with a random particle (via simulation id) to compensate for particle loss\n    uint id = wrapFlatID(nextUint());\n    for (int i = 0; i < 1; i++) {\n        listInsert(best_distances, closest_indices, id++, fragCoord);\n    }\n#endif\n\n    // Write back\n    fragColor = uintBitsToFloat(closest_indices);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2SW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1236]], "test": "untested"}
{"id": "ddjSWc", "name": "Coloring of objects", "author": "CodeJUN", "description": "个人练习", "tags": ["3dshadowcolour"], "likes": 3, "viewed": 193, "published": 3, "date": "1671035826", "time_retrieved": "2024-07-30T16:12:57.083007", "image_code": "\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.14159265\n\nvec2 fixUV(in vec2 c)\n{\n    return(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n}\n\nfloat sdfSphere(in vec3 p)//球体\n{\n    return length(p) - 0.8 ;\n}\n\nfloat sdfRect(in vec3 p, in vec3 b)//方形\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,-.1))+min(max(d.x,max(d.y,d.z)),0.);//奇奇怪怪的\n\n}\nfloat sdfBox(in vec3 p, in vec3 r)\n{\n    vec3 b=abs(p)-r;\n    return length(max(b,0.))+min(max(max(b.x,b.y),b.z),0.);\n\n}\n\n/*float sdfPlane(in vec3 p)\n{\n    return p.y;    \n}*/\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 map(in vec3 p)//合并\n{\n    vec2 d=vec2(sdfSphere(p-vec3(0.,.8,0.)),2.);//球体位置\n    //d =opU(d,vec2(sdfPlane(p+vec3(0.,1.,0.)),1.));\n    /*float h=sdfRect(p,vec3(0.));\n    d =min(d,sdfPlane(p+vec3(0.,1.,0.))+(h,sdfRect(p,vec3(1.))));*/\n    d=opU(d,vec2(sdfBox(p-vec3(2.,1.,0.),vec3(1.,1.,1.)),3.));//box Transfrem\n    d=opU(d,vec2(sdfRect(p-vec3(-2.,.5,2.),vec3(.5,.5,1.)),4.));//方形 位置\n    return d;\n\n}\nvec2 rayMarch(in vec3 ro, in vec3 rd)//射线方向和源头\n{\n    float t=0.1;\n    float tmax=40.;\n    vec2 res=vec2(-1.);\n    if(rd.y<0.)\n    {\n        float tp=-ro.y/rd.y;\n        tmax=min(tmax,tp);\n        res=vec2(tp,1.);\n    }\n    for(int i=0;i<RAYMARCH_TIME &&t<tmax;i++)\n    {\n        vec3 p=ro+t*rd;\n        //float d=sdfSphere(p);//输出球体\n        //float d=sdfRect(p,vec3(.8+.1*sin(iTime),.3+.2*cos(iTime),.3));//输出方形\n        vec2 d=map(p);\n        if(d.x<PRECISION)\n        {\n            //return t;\n            res =vec2(t,d.y);\n            break;\n           \n        }\n        t += d.x;\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)//光照\n{\n    const float h=0.0001;;\n    const vec2 k= vec2 (1,-1);\n  /* return normalize(k.xyy * sdfSphere(p + k.xyy * h) +\n        k.yyx * sdfSphere(p + k.yyx * h) +\n        k.yxy * sdfSphere(p + k.yxy * h) +\n        k.xxx * sdfSphere(p + k.xxx * h));*/ \n     return normalize(k.xyy * map(p + k.xyy * h).x +\n        k.yyx * map(p + k.yyx * h).x +\n        k.yxy * map(p + k.yxy * h).x +\n        k.xxx * map(p + k.xxx * h).x);\n}\n\nmat3 setCamera(vec3 ta,vec3 ro,float cr)//摄像机围绕球体旋转\n{\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr) , cos(cr),0.);\n    vec3 x= normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro,in vec3 rd,float k)//软阴影\n{\n    float res=1.0;\n    float ph=1e20;\n    float tmin=.1;\n    float tmax = 10.;\n    for(float t=tmin;t<tmax;)\n    {\n        \n        float h =map(ro+rd*t).x;\n        if(h<.001)//光线过度，h越小，过度越平滑\n            return 0.0;\n        float y =h*h/(2.0*ph);\n        float d=sqrt(h*h-y*y);\n        res=min(res,k*d/max(0.0,t-y));\n        ph=h;\n        t+=h;\n    }\n    return res;\n}\nvec2 tri (in vec2 x)\n{\n    vec2 h=fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nfloat checkersGrad(in vec2 uv,in vec2 ddx, in vec2 ddy)\n{\n    vec2 w =max(abs(ddx),abs(ddy))+0.01;\n    vec2 i=(tri(uv+0.5*w)-tri(uv-0.5*w))/w;\n    return 0.5-0.5*i.x*i.y;\n} \n\nvec3 render(in vec2 uv ,in vec2 px, in vec2 py)\n{\n    float ca=3.f;\n    //vec3 color =vec3(.05);//背景颜色\n    vec3 ro =vec3 (4.*cos(.1*iTime),ca,4.*sin(.1*iTime));//球体旋转\n    if(iMouse.z>0.01)//鼠标控制\n    {\n        float theta=iMouse.x/iResolution.x*2.*PI;\n        ro=vec3(2.*cos(theta),ca+0.2*cos(iTime),2.*sin(theta));  \n    } \n    vec3 ta=vec3(0.,1.,0.);//摄像机位置\n    mat3 cam=setCamera(ta,ro,.1*sin(iTime));//摄像机运动\n    float fl=1.;\n    vec3 rd =normalize(cam*vec3 (uv,fl));//球体大小\n    vec3 bg=vec3(.7,.7,.9);\n    vec3 color = bg-rd.y*vec3(.1);//背景颜色\n    vec2 t=rayMarch(ro,rd);\n    if(t.y>0.)\n    {\n        vec3 p=ro+t.x*rd;\n        vec3 n= (t.y<1.1)?vec3(0.,1.,0.):calcNormal(p);\n        // vec3 light =vec3 (2.*cos(iTime),2.,2.*sin(iTime+2.));//光线移动\n        vec3 light =vec3 (5.,5.,2.);\n        float dif=clamp(dot(normalize(light-p),n),0.,1.);\n        p+=PRECISION*n;\n       // float st = softShadow(p,normalize(light-p),2.);//明显交界线\n        \n        dif *=softShadow(p,normalize(light-p),2.);//光线平滑\n       /*float st=rayMarch(p,normalize(light-p));\n        if(st<TMAX)//假阴影\n        {\n            dif*=.1; \n        }*/\n\n        float amd=0.5+0.5*dot(n,vec3(0.,1.,0));//环境灯光亮度\n        vec3 c=vec3(0.);\n        if(t.y>1.9&&t.y<2.1)\n        {\n            c=vec3(1.,0.,0.);//Sphere\n\n        }else if (t.y>2.9&&t.y<3.1)\n        {\n            c=vec3(1.,1.,0.);//box\n        }\n        else if(t.y>0.9&&t.y<1.1)\n        {\n           /* vec2 grid =floor(p.xz);\n            c=vec3(.23)+.2*mod(grid.x+grid.y,2.);//Plane*/\n            vec3 rdx = normalize(cam*vec3 (px,fl));\n            vec3 rdy = normalize(cam *vec3(py, fl));\n            vec3 ddx=ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 ddy=ro.y*(rd/rd.y-rdy/rdy.y);\n            c=vec3(.3)+vec3(0.2)*checkersGrad(p.xz,ddx.xz,ddy.xz);\n            \n\n        }\n        else if(t.y>3.9&&t.y<4.1)\n        {\n            c=vec3(0.,1.,0.);//Rect\n        }\n\n        color=amd*c+dif*vec3(.6);\n\n    }\n    return sqrt(color);//幂\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 color=vec3(0.);\n    for(int m =0;m<AA;m++)\n    {\n        for(int n=0; n<AA;n++)\n        {\n            vec2 offset=2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            //vec2 uv = fixUV(fragCoord+offset)+offset;\n            vec2 uv = fixUV(fragCoord+offset+offset);\n            vec2 px=fixUV (fragCoord+vec2(1.,0.)+offset);\n            vec2 py=fixUV (fragCoord+vec2(0.,1.)+offset);\n            color += render(uv,px,py);\n        }\n    }\n    fragColor=vec4(color/float(AA*AA),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 109, 109, 178], [180, 180, 216, 216, 247], [249, 249, 294, 294, 396], [397, 397, 433, 433, 517], [574, 574, 600, 600, 626], [628, 628, 657, 657, 1051], [1052, 1052, 1114, 1114, 1689], [1691, 1737, 1773, 1773, 2192], [2194, 2194, 2265, 2265, 2420], [2422, 2467, 2527, 2527, 2922], [2923, 2923, 2945, 2945, 2999], [3001, 3001, 3058, 3058, 3173], [3176, 3176, 3225, 3225, 5241], [5243, 5243, 5297, 5297, 5790]], "test": "untested"}
{"id": "dd2XW3", "name": "rects #3", "author": "jonasfrey", "description": "rects", "tags": ["rects"], "likes": 11, "viewed": 233, "published": 3, "date": "1671032900", "time_retrieved": "2024-07-30T16:12:58.063386", "image_code": "float f_n_dist_square(vec2 o){\n    return max(abs(o.x), abs(o.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 o_trpino = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    float n_ndx_px = fragCoord.x + (fragCoord.y*iResolution.x);\n    float n_ndx_px_nor = n_ndx_px / (iResolution.x*iResolution.y);\n    float n_scl = 20.;\n    o_trpino *= n_scl;\n    vec2 o_reprate = vec2(1.);\n     \n    vec2 o = mod(o_trpino, o_reprate);\n    o-=0.5;\n    vec2 o_id = ((o_trpino - o)+n_scl)/(n_scl*2.);\n    float n_id = o_id.x+(o_id.y*(1./n_scl/2.));\n    // Time varying pixel color\n    \n    float n = f_n_dist_square(o);\n    \n    fragColor = vec4(\n        sin(n*6.28*100.*n_id+iTime)\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2XW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 68], [70, 70, 127, 177, 753]], "test": "untested"}
{"id": "Ds2SDc", "name": "Truchet Tiling (MAYBE!)", "author": "SnoopethDuckDuck", "description": "This probably could have been done in a regular grid, I've used a tiling of big and small squares. \n\nclick the left or right sides to see the grid\n", "tags": ["tiling"], "likes": 33, "viewed": 306, "published": 3, "date": "1671022720", "time_retrieved": "2024-07-30T16:12:58.823353", "image_code": "#define pi 3.14159\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define mlength(a) max(abs(a.x), abs(a.y))\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat box(in vec2 p, in vec2 b) {\n    // Circle (sloppy)\n    float d1 = length(p) - .56; \n    \n    // Box\n    vec2 d = abs(p)-b;\n    float d2 = length(max(d,0.)) + min(max(d.x,d.y),0.);\n    \n    // Mix between them\n    return mix(d1, d2, .5 + .5 * thc(4., iTime));\n}\n\nvec2 tile(vec2 fpos, vec2 ipos, float k) { \n    // Rotate tile randomly\n    float h = floor(2. * h21(ipos));  \n    fpos *= rot(h * pi / 2.);\n\n    // Outlines of 2 boxes\n    vec2 off = vec2(1.-.25, .25).xy;\n    float s = smoothstep(-k, k, -abs(box(fpos+off,vec2(.5)))+.075);\n    s = max(s,smoothstep(-k, k, -abs(box(fpos-off,vec2(.5)))+.075));                         \n    \n    // Checkerboard pattern\n    float chk = mod(ipos.x + ipos.y, 2.);\n    \n    // Split the tiling into \"in\" and \"out\" parts\n    // In by default\n    float s2   = smoothstep(-k, k, -box(fpos + off, vec2(.5)));\n    s2 = max(s2, smoothstep(-k, k, -box(fpos - off, vec2(.5))));  \n    \n    // Out if [checkerboard, rotate] == [0,0] or [1,1]\n    if (chk == h)\n        s2 = 1. - s2;\n\n    // Return outline and in/out regions\n    return vec2(s, s2);\n}\n\nvec3 layer(vec2 uv, float sc) {\n    float k = sc / iResolution.y;\n\n    uv += 1.5 * k * vec2(.25, .75) * iTime;\n    \n    // Split into grid\n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);\n       \n    // Split into grid of big and small tiles\n    float m = mod(2. * ipos.x - ipos.y, 5.);    \n    vec2 o = vec2(0);\n    if (m != 3.) {\n        fpos *= 0.5;   \n        if (m == 2.)      o = vec2(1,0); \n        else if (m == 4.) o = vec2(0,1); \n        else if (m == 1.) o = vec2(1);  \n    }   \n    fpos += .5 * o - .5;\n    ipos -= o;\n    \n    if (m == 3.) { // Small tile\n        float h = h21(ipos);\n        float d = length(fpos) - .5 * h;\n        float s = smoothstep(-k, k, -d + .25 * (1.-h));\n        return vec3(0, 1. - mod(ipos.x + ipos.y, 2.), 1. - s);\n    } else {       // Big tile     \n        vec2 s = tile(fpos, ipos, .5 * k);\n        float md = mod(ipos.x + ipos.y, 5.) / 5.;\n        return vec3(s, 1);\n    }\n}\n\nfloat clickLayer(vec2 uv, float sc) {\n    float k = sc / iResolution.y;\n\n    uv += 1.5 * k * vec2(.25, .75) * iTime;\n    \n    // Split into grid\n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);\n       \n    // Split into grid of big and small tiles\n    float m = mod(2. * ipos.x - ipos.y, 5.);    \n    vec2 o = vec2(0);\n    if (m != 3.) {\n        fpos *= 0.5;   \n        if (m == 2.)      o = vec2(1,0); \n        else if (m == 4.) o = vec2(0,1); \n        else if (m == 1.) o = vec2(1);  \n    }   \n    fpos += .5 * o - .5;\n    ipos -= o;\n    \n    float md = mod(ipos.x + ipos.y, 5.);\n    \n    if (m == 3.) { // Small tile\n        float d = mlength(fpos) - .48;\n        float s = smoothstep(-k, k, d);\n        return s;\n    } else {       // Big tile     \n        float d = mlength(fpos) - .48;\n        float s = smoothstep(-.5*k, .5*k, d);\n        float a = step(.5 * iResolution.x, iMouse.x);\n        if (md == 0.)\n            a *= thc(2., iTime + 32. * length(fpos));\n        else if (md == 1.)\n            a *= thc(2., iTime + 32. * mlength(fpos));\n        else if (md == 2.)\n            a *= thc(2., iTime + 32. * fpos.x);\n        else if (md == 3.)\n            a *= thc(2., iTime + 32. * fpos.y);\n        else if (md == 4.)\n            a *= thc(2., iTime + 32. * (fpos.x / (1. + fpos.y)));\n        return max(s, a);   \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Detect mouse\n    float z = 0.;\n    if (iMouse.z > 0.)\n        z = 8.;\n    \n    // Layers\n    float sc = 18. - z;\n    vec3   s = layer(uv, sc);\n    vec3  s2 = layer(uv + vec2(.432/sc), sc);\n    float s3 = clickLayer(uv, sc);\n\n    vec3 col = .75 + .25 * cos(2. * pi * \n               (.65 * s.y + .05 * uv.x + vec3(0,1,2)/6.));\n    \n    // Dots\n    col -= .1 * s.y * (1. - s.z) + .02 * s2.x;\n    \n    // Shadow\n    col -= .3 * s2.y;\n    \n    // Thick outline\n    col = mix(col, vec3(.1, 0, .15), s.x - .28 * s.y);   \n    \n    if (iMouse.z > 0. && iMouse.x > 0.5 * iResolution.x)\n        col *= 0.5;\n\n    // Click layer\n    col += step(1., z) * s3;\n       \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2SDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 172, 172, 247], [249, 249, 282, 305, 515], [517, 517, 559, 588, 1334], [1336, 1336, 1367, 1367, 2271], [2273, 2273, 2310, 2310, 3617], [3619, 3619, 3676, 3676, 4433]], "test": "untested"}
{"id": "ddSXD3", "name": "2022_1214_VR_oilPainting_Tours", "author": "yunChenLee_329", "description": "test for VR", "tags": ["phong", "vr", "oilpainting"], "likes": 4, "viewed": 279, "published": 3, "date": "1670985802", "time_retrieved": "2024-07-30T16:12:59.577338", "image_code": "// Author: RJean Lee\n// fork from:CMH\n// Title: Basic Raymarching_2(normal, camera) \n// Reference: 20220414_glsl Breathing Circle_v5A(BRDF).qtz\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n\n\n\n\nfloat map(in vec3 p)\n{\n//return sdSphere(p+vec3(0.,0.,0.0), 0.5);\n//return sdTorus(p+vec3(0.,0.,0.0),vec2(0.4,0.2));\n//return sdBox(p+vec3(0.0,0.0,0.0), vec3(0.4, 0.4, 0.4));\nmat3 rot=fromEuler(vec3(0.0,0.0,iTime*0.2));\nvec3 p1=(p+vec3( 0.0, -0.0, 1.2))*rot;\nvec3 p2=(p+vec3( 1.2, -0.0, 0.0))*rot;\nvec3 p3=(p+vec3(-1.2, -0.0, 0.0))*rot;\nvec3 p4=(p+vec3( 0.0, -0.0,-1.2))*rot;\nvec3 p5=(p+vec3( 0.0, -1.2, 0.0))*rot;\n\nvec2 op = vec2(0.4,0.2);\nreturn min(min(min(min(sdTorus(p1,op),sdTorus(p2,op)),sdTorus(p3,op)),sdTorus(p4,op)),sdTorus(p5,op));\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<32; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.5; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n//noise \n// 2D Random\n// float random (in vec2 st) {\n//     return fract(sin(dot(st.xy,\n//                          vec2(12.9898,78.233)))\n//                  * 43758.5453123);\n// }\n\n// // 2D Noise based on Morgan McGuire @morgan3d\n// // https://www.shadertoy.com/view/4dS3Wd\n// float noise (in vec2 st) {\n//     vec2 i = floor(st);\n//     vec2 f = fract(st);\n\n//     // Four corners in 2D of a tile\n//     float a = random(i);\n//     float b = random(i + vec2(1.0, 0.0));\n//     float c = random(i + vec2(0.0, 1.0));\n//     float d = random(i + vec2(1.0, 1.0));\n\n//     // Smooth Interpolation\n\n//     // Cubic Hermine Curve.  Same as SmoothStep()\n//     vec2 u = f*f*(3.0-2.0*f);\n//     // u = smoothstep(0.,1.,f);\n\n//     // Mix 4 coorners percentages\n//     return mix(a, b, u.x) +\n//             (c - a)* u.y * (1.0 - u.x) +\n//             (d - b) * u.x * u.y;\n// }\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n\nvec4 render(vec3 RayOri,vec3 RayDir){\n    vec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n\t\t\n\n    float Ka=1.0;   // Ambient reflection coefficient\n    float Kd=1.0;   // Diffuse reflection coefficient\n    float Ks=1.0;   // Specular reflection coefficient\n    float shininessVal=80.0; // Shininess\n    // Material color\n    vec3 ambientColor = vec3(0.15,0.1,0.05);\n    vec3 diffuseColor = vec3(0.8,0.25,0.0);\n    vec3 specularColor = vec3(1.0,1.0,1.0);\n   \tvec3 backgroundClr = vec3(0.0,0.25,0.7); \n\tvec3 lightPos = vec3(1.0,1.0,1.0); // Light position\n    \n    // \n    vec3 N = n+vec3(fbm(n.yz*40.0),fbm(n.xz*20.0),fbm(n.xy*20.0))*0.1;\n    vec3 L = normalize(lightPos-p);\n    //\n    float lambertain = max(dot(N,L),0.0);\n    float specular = 0.0;\n    if(lambertain > 0.0){\n        vec3 R = reflect(-L,N);\n        vec3 V = normalize(-p);\n        float specAngle = max(dot(R,V),0.0);\n        specular = pow(specAngle,shininessVal);\n    }\n    \n    vec3 result = vec3(Ka*ambientColor+Kd*lambertain*diffuseColor+Ks*specular*specularColor);\n\n    if(t<3.5) result = result; else result = backgroundClr;\n    return vec4(result,t);\n}\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    //uv = uv+vec2(fbm(uv*40.0),fbm(uv*20.0))*0.1;\n\n// camera option1  (模型應在原點，適用於物件)\n\tvec3 CameraRot=vec3(0.0, -mouse.y*1.6, -mouse.x*6.28);\n\tvec3 ro= vec3(0.0, 0.0, 0.0);\n\tvec3 ta =vec3(0.0, 0.0, -1.0)*fromEuler(CameraRot);\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 1.5));\n\tvec3 RayOri = ro;\n\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t/*\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n\t\t\n\n    float Ka=1.0;   // Ambient reflection coefficient\n    float Kd=1.0;   // Diffuse reflection coefficient\n    float Ks=1.0;   // Specular reflection coefficient\n    float shininessVal=80.0; // Shininess\n    // Material color\n    vec3 ambientColor = vec3(0.15,0.1,0.05);\n    vec3 diffuseColor = vec3(0.8,0.25,0.0);\n    vec3 specularColor = vec3(1.0,1.0,1.0);\n   \tvec3 backgroundClr = vec3(0.0,0.25,0.7); \n\tvec3 lightPos = vec3(1.0,1.0,1.0); // Light position\n    \n    // \n    vec3 N = n;\n    vec3 L = normalize(lightPos-p);\n    //\n    float lambertain = max(dot(N,L),0.0);\n    float specular = 0.0;\n    if(lambertain > 0.0){\n        vec3 R = reflect(-L,N);\n        vec3 V = normalize(-p);\n        float specAngle = max(dot(R,V),0.0);\n        specular = pow(specAngle,shininessVal);\n    }\n    \n    vec3 result = vec3(Ka*ambientColor+Kd*lambertain*diffuseColor+Ks*specular*specularColor);\n\n\n*/\n    vec4 result = render(RayOri, RayDir);\n    \n    float t = result.a;\n    //gl_FragColor = vec4(vec3(result),1.0);    \n    //if(t<3.5) fragColor = vec4(vec3(result),1.0); ///else fragColor = vec4(backgroundClr,1.0);\n\n    fragColor = vec4(vec3(result),1.0);\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n \n    vec4 col = render( fragRayOri + vec3(0.0,0.0,0.0), fragRayDir );\n    fragColor = vec4( col.xyz, 1.0 );}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSXD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 299, 334, 334, 360], [361, 361, 392, 392, 479], [480, 480, 513, 513, 578], [581, 589, 615, 615, 985], [992, 992, 1014, 1166, 1537], [1539, 1568, 1614, 1614, 1832], [1835, 1864, 1905, 1905, 2047], [2049, 2076, 2128, 2128, 2305], [3181, 3181, 3208, 3208, 3315], [3317, 3395, 3421, 3421, 3801], [3821, 3821, 3845, 3867, 4121], [4125, 4125, 4162, 4162, 5277], [5279, 5299, 5356, 5356, 7313], [7317, 7317, 7411, 7411, 7521]], "test": "untested"}
{"id": "cdBXWc", "name": "rocket league grid", "author": "jonasfrey", "description": "rocketleague", "tags": ["rocketleague"], "likes": 11, "viewed": 315, "published": 3, "date": "1670972949", "time_retrieved": "2024-07-30T16:13:00.829989", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( abs(n-1.), n_sharpness))*pow(2., n_sharpness);\n}\nfloat f_n_dist_hexagon(\n    vec2 o\n){\n    vec2 o_abs = vec2(abs(o.x), abs(o.y));\n    float n_sqrtof3 = sqrt(3.);\n    vec2 o_angle = vec2(1.,n_sqrtof3);\n    float n = dot(o_abs, normalize(o_angle));\n    n = max(n, o_abs.x);\n    return n;\n}\nfloat f_n_dist_hexgrid(\n    vec2 o_trpino, \n    float n_size\n){\n    \n\n    o_trpino*= n_size;\n    vec2 o_reprate = vec2(1., sqrt(3.));\n    vec2 o_repratehalf = o_reprate*0.5;\n    \n    vec2 o_trpino_scld_frct_a = mod(o_trpino, o_reprate)-o_repratehalf;\n    vec2 o_trpino_scld_frct_b = mod(o_trpino-o_repratehalf, o_reprate)-o_repratehalf;\n    vec2 o_xy = floor((o_trpino+vec2(0.9,0.5)*n_size) / o_reprate);\n\n    \n    float n_dist_a = length(o_trpino_scld_frct_a);\n    float n_dist_b = length(o_trpino_scld_frct_b);\n    float n_dist_a_bigger_than_b = float(n_dist_a>n_dist_b);\n    \n    vec2 o = \n        (1.-n_dist_a_bigger_than_b)*o_trpino_scld_frct_a +\n        n_dist_a_bigger_than_b*o_trpino_scld_frct_b;\n    vec2 o_id = ((((o_trpino)-o)/2.)+n_size*0.5)/n_size;\n\n    float n_dist_hex = f_n_dist_hexagon(o);\n    float n = n_dist_hex;\n    //float n = length(o);\n    return n;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.xy;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    \n    float ndhg1 = f_n_dist_hexgrid(o_trpino, 50.);\n    float n_min = 0.45;\n    float n_max = 0.55;\n    float n_delta = abs(n_max-n_min);\n    float n_ndhg1_smst = smoothstep(n_min, n_max,ndhg1)/n_delta;\n    \n    float ndhg2 = f_n_dist_hexgrid(o_trpino, 5.);\n    n_min = 0.45;\n    n_max = 0.55;\n    n_delta = abs(n_max-n_min);\n    float n_ndhg2_smst = smoothstep(n_min, n_max,ndhg2)/n_delta;\n    \n\n\n    vec3 o_col_orange = vec3(0.8,0.322,0.098);\n    vec3 o_col_blue = vec3(0.071,0.145,0.443);\n    float n_gradient = smoothstep(0.4, 0.6,o_trpino_nooffset.x);\n    vec3 o_col_ndhg2 = vec3(n_ndhg2_smst);\n\n    float n_dist_circ = length(o_trpino);\n    n_dist_circ= fract(iTime*0.8+n_dist_circ*2.);\n    n_dist_circ = f_n_inoutexp(n_dist_circ, 5.)*2.;\n    \n    o_col_ndhg2 = o_col_ndhg2 * mix(o_col_orange, o_col_blue, n_gradient)*0.5;\n    o_col_ndhg2 += o_col_ndhg2*n_dist_circ*0.5;\n    fragColor = vec4(o_col_ndhg2,1.);\n\n    fragColor += (1.-clamp(0.,1.,n_ndhg2_smst*0.5))*vec4(n_ndhg1_smst);\n    //fragColor = vec4(n_ndhg2_smst);\n    //fragColor += vec4(n_ndhg1_smst);\n    //fragColor = vec4(0.);\n    //fragColor.g = n_x/n_fact;\n    \n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 258], [259, 259, 296, 296, 497], [498, 498, 561, 561, 1378], [1379, 1379, 1436, 1436, 2840]], "test": "untested"}
{"id": "csSSWc", "name": "Neon city for Windows Terminal", "author": "mrange", "description": "CC0: Neon city for Windows Terminal\nBased on an older shader of mine seems to have some fans that really seem to like it.\nI personally feel I evolved beyond the techniques of the shader but it seems to appeal\nto some people.\n", "tags": ["2d", "neonwave"], "likes": 32, "viewed": 940, "published": 3, "date": "1670962902", "time_retrieved": "2024-07-30T16:13:02.003850", "image_code": "// CC0: Neon city for Windows Terminal\n//  Based on an older shader of mine seems to have some fans that really seem to like it.\n//  I personally feel I evolved beyond the techniques of the shader but it seems to appeal\n//  to some people.\n//  This is a recreation for windows terminal\n//  Hopefully I didn't destroy what people like about it in the process :)\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 shineCol = HSV2RGB(vec3(0.55, 0.5, 0.75));\nconst vec3 gridCol  = HSV2RGB(vec3(0.60, 0.5, 1.0));\nconst vec3 cityCol  = HSV2RGB(vec3(0.55, 0.25, 0.4));\nconst vec3 skyCol1  = HSV2RGB(vec3(283.0/360.0, 0.83, 0.16));\nconst vec3 skyCol2  = HSV2RGB(vec3(297.0/360.0, 0.79, 0.43));\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  vec2 cp = p;\n  mod1(cp.y, ch*6.0);\n\n  float d0 = circle(sp, 0.5);\n  float d1 = planex(cp, ch);\n  float d2 = p.y+ch*3.0;\n\n  float d = d0;\n  d = pmax(d, -max(d1, d2), ch*2.0);\n\n  return d;\n}\n\nfloat city(vec2 p) {\n  float fd = -(p.y+0.4);\n  float cd = 1E6;\n\n  const float count = 5.0;\n  const float width = 0.1;\n\n  for (float i = 0.0; i < count; ++i) {\n    vec2 pp = p;\n    pp.x += i*width/count;\n    float nn = mod1(pp.x, width);\n    float rr = hash(nn+sqrt(3.0)*i);\n    float dd = box(pp-vec2(0.0, -0.5), vec2(0.02, 0.35*(1.0-smoothstep(0.0, 10.0, abs(nn)))*rr+0.1));\n    cd = min(cd, dd);\n  }\n  \n  return max(fd, cd);\n}\n\nvec3 cityEffect(vec2 p, float dc) {\n  float aa = 2.0 / RESOLUTION.y;\n  dc = abs(dc)-aa;\n  vec3 col = vec3(0.0);\n  col = mix(col, cityCol*0.75, smoothstep(aa, -aa, dc));\n  return col;\n}\n\nvec3 sunEffect(vec2 p, float dc) {\n  float aa = 4.0 / RESOLUTION.y;\n\n  vec3 col = vec3(0.1);\n  col = mix(skyCol1, skyCol2, pow(clamp(0.5*(1.0+p.y+0.1*sin(4.0*p.x+TIME*0.5)), 0.0, 1.0), 4.0));\n  \n  p.y -= 0.49;\n  float ds = sun(p);\n\n  float dd = circle(p, 0.5);\n \n  vec3 sunCol = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), clamp(0.5 - 1.0*p.y, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  vec3 cityCol = sunCol*sunCol;\n  \n  col += glareCol*(exp(-30.0*ds))*step(0.0, ds);\n  \n\n  float t1 = smoothstep(0.0, 0.075, -dd);\n  float t2 = smoothstep(0.0, 0.3, -dd);\n  col = mix(col, sunCol, smoothstep(-aa, 0.0, -ds));   \n  col = mix(col, glareCol, smoothstep(-aa, 0.0, -dc)*t1);   \n  col += vec3(0.0, 0.25, 0.0)*(exp(-90.0*dc))*step(0.0, dc)*t2;\n  return col;\n}\n\nfloat ground(vec2 p) {\n  p.y += TIME*40.0;\n  p *= 0.075;\n  vec2 gp = p;\n  gp = fract(gp) - vec2(0.5);\n  float d0 = abs(gp.x);\n  float d1 = abs(gp.y);\n  float d2 = circle(gp, 0.05);\n\n  const float rw = 2.5;\n  const float sw = 0.0125;\n\n  vec2 rp = p;\n  mod1(rp.y, 12.0);\n  float d3 = abs(rp.x) - rw;\n  float d4 = abs(d3) - sw*2.0;\n  float d5 = box(rp, vec2(sw*2.0, 2.0));\n  vec2 sp = p;\n  mod1(sp.y, 4.0);\n  sp.x = abs(sp.x);\n  sp -= vec2(rw - 0.125, 0.0);\n  float d6 = box(sp, vec2(sw, 1.0));\n\n  float d = d0;\n  d = pmin(d, d1, 0.1);\n  d = max(d, -d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d = min(d, d6);\n  \n  return d;\n}\n\nvec3 groundEffect(vec2 p) {\n  vec3 ro = vec3(0.0, 20.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.025, 1.0));\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  float distg = (-9.0 - ro.y)/rd.y;\n\n  vec3 col = vec3(0.0);\n  if (distg > 0.0) {\n    vec3 pg = ro + rd*distg;\n    float aa = length(dFdx(pg))*0.0002*RESOLUTION.x;\n    \n    float dg = ground(pg.xz);\n    \n    col = mix(col, gridCol, smoothstep(-aa, 0.0, -(dg+0.0175)));   \n    col += shineCol*(exp(-10.0*clamp(dg, 0.0, 1.0)));\n    col = clamp(col, 0.0, 1.0);\n    \n    col *= pow(1.0-smoothstep(ro.y*3.0, 220.0+ro.y*2.0, distg), 2.0);\n  }\n  \n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q)  {\n  col = clamp(col,0.0,1.0);\n  // No Gamma correction\n  // col = pow(col, 1.0/vec3(2.2));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec3 col = vec3(0.0);\n\n  vec2 off = vec2(0.0, 0.15);\n  \n  float dc = city(p-vec2(0.0, 0.375)+off);\n  col += cityEffect(p+off,dc );\n  col += sunEffect(p+off,dc);\n  col += groundEffect(p+off);\n\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x / RESOLUTION.y;\n \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[636, 636, 658, 658, 804], [1386, 1446, 1468, 1468, 1516], [1518, 1518, 1539, 1539, 1568], [1570, 1656, 1695, 1695, 1820], [1822, 1822, 1853, 1853, 1879], [1881, 1999, 2026, 2026, 2102], [2104, 2104, 2135, 2135, 2160], [2162, 2162, 2201, 2201, 2290], [2292, 2292, 2331, 2331, 2360], [2362, 2362, 2381, 2381, 2614], [2616, 2616, 2636, 2636, 3045], [3047, 3047, 3082, 3082, 3231], [3233, 3233, 3267, 3267, 3989], [3991, 3991, 4013, 4013, 4613], [4615, 4615, 4642, 4642, 5319], [5321, 5408, 5445, 5445, 5699], [5701, 5701, 5730, 5730, 5969], [5971, 5971, 6028, 6028, 6192]], "test": "untested"}
{"id": "DdSXWK", "name": "oled display", "author": "jonasfrey", "description": "template", "tags": ["template"], "likes": 8, "viewed": 353, "published": 3, "date": "1670951196", "time_retrieved": "2024-07-30T16:13:03.010159", "image_code": "float f_n_dist_redled(\n    vec2 o\n){\n    float n_tau = 6.2831;\n    float n_angle = n_tau/8.;\n    vec2 o_rotated = vec2(\n        cos(n_angle)*o.x+-sin(n_angle)*o.y, \n        sin(n_angle)*o.x+cos(n_angle)*o.y\n    );\n    \n    float n = length(o_rotated*o_rotated);\n    float n_intensity = 4.;\n    n = pow((pow(abs(o_rotated.x), n_intensity))+(pow(abs(o_rotated.y), n_intensity)), 1./n_intensity);\n    n = smoothstep(0.2, 0.23, n);\n    \n    float n_dist_circle = length(o_rotated)*3.;//glow\n    n = n * n_dist_circle;\n    return 1.-n;\n}\nfloat f_n_dist_greenled(\n    vec2 o\n){\n    float n_tau = 6.2831;\n    float n_angle = n_tau/8.;\n    vec2 o_rotated = vec2(\n        (cos(n_angle)*o.x+-sin(n_angle)*o.y), \n        (sin(n_angle)*o.x+cos(n_angle)*o.y)*1.2\n    );\n    \n    float n = length(o_rotated);\n    n = smoothstep(0.2, 0.23, n);\n    //n = max(abs(o_rotated.x), abs(o_rotated.y));\n    return 1.-n;\n    //return 1.-length(o)*2.;\n}\nfloat f_n_dist_blueled(\n    vec2 o\n){\n    float n_tau = 6.2831;\n    float n_angle = n_tau/8.;\n    vec2 o_rotated = vec2(\n        cos(n_angle)*o.x+-sin(n_angle)*o.y, \n        sin(n_angle)*o.x+cos(n_angle)*o.y\n    );\n    \n    float n = length(o_rotated*o_rotated);\n    float n_intensity = 8.;\n    n = pow((pow(abs(o_rotated.x), n_intensity))+(pow(abs(o_rotated.y), n_intensity)), 1./n_intensity);\n    n = smoothstep(0.3, 0.33, n);\n    \n    float n_dist_circle = length(o_rotated)*2.;//glow\n    n = n * n_dist_circle;\n    return 1.-n;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    vec2 o_scale = vec2(0.09);\n    \n    if(iMouse.z == 0.0){\n        o_trmono = vec2(sin(iTime), cos(iTime)*0.2);\n    }\n    if(o_trpino.x > o_trmono.x){\n        o_scale = vec2(o_trmono.y);\n    }\n    \n\n\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n    vec2 o_trpino_scaled = (o_fragCoord_scaled.xy - o_iResolution_scaled.xy*0.5)/ o_iResolution_scaled.y;\n    vec2 o_trpino_nooffset_scaled = (o_fragCoord_scaled.xy)/ o_iResolution_scaled.xy;\n    \n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n    vec2 o_pixels_per_coord = vec2(iResolution.xy*(vec2(1.)/o_scale.xy));\n    vec2 o = iResolution.xy/o_iResolution_scaled;\n    \n    o_fragCoord_scaled = ((fragCoord.xy+vec2(mod(o_fragCoord_scaled_floor.y, 2.)*o.x*0.5, 0.))*o_scale);\n    o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n        \n    o_trpino_scaled = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    o_trpino_nooffset_scaled = (o_fragCoord_scaled_floor.xy)/ o_iResolution_scaled_floor.xy;\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    float b_red = float(\n        bool(mod(o_fragCoord_scaled_floor.y,2.))\n        &&\n        bool(mod(o_fragCoord_scaled_floor.x+float(mod(o_fragCoord_scaled_floor.y,4.)<=1.),2.))\n    );\n    float b_blue = float(\n        bool(mod(o_fragCoord_scaled_floor.y,2.))\n        &&\n        bool(1.-b_red)\n    );\n    float b_green = float(\n        bool(mod(o_fragCoord_scaled_floor.y+1.,2.))\n    );\n    float b_green_rotated = float (\n     bool(b_green)\n     &&\n     bool(mod(o_fragCoord_scaled_floor.x,2.))\n    );\n    \n    float n_dist = length(o_fragCoord_scaled_fract-vec2(0.5));//shape\n\n    n_dist = sqrt(n_dist);\n    n_dist = 1.-n_dist;\n    n_dist -= (1.*b_red+1.*b_green+1.*b_blue);//size\n    n_dist *= (.8*b_red+0.5*b_green+1.0*b_blue);//brightness\n    \n    vec4 o_col_texture = texture(iChannel0, o_trpino_nooffset_scaled);\n    \n    vec2 o_led = o_fragCoord_scaled_fract-vec2(0.5);\n    \n    float n_tau = 6.2831;\n    float n_angle = n_tau/4.;\n    o_led = vec2(\n        cos(b_green_rotated*n_angle)*o_led.x+-sin(b_green_rotated*n_angle)*o_led.y, \n        sin(b_green_rotated*n_angle)*o_led.x+cos(b_green_rotated*n_angle)*o_led.y\n    );\n    \n    //o_col_texture *= o_col_texture; //gamma for stronger effect\n    fragColor = vec4(\n        o_col_texture.r*f_n_dist_redled(o_led)*b_red,\n        o_col_texture.g*f_n_dist_greenled(o_led)*b_green,\n        o_col_texture.b*f_n_dist_blueled(o_led)*b_blue,\n        1.\n    );\n    //fragColor = sqrt(fragColor);\n    \n\n\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 532], [533, 533, 571, 571, 928], [929, 929, 966, 966, 1467], [1468, 1468, 1525, 1525, 5000]], "test": "untested"}
{"id": "dsjSDK", "name": "Enhanced Graphics Adaptation", "author": "ruojake", "description": "A fork of my shader Time Gem (https://www.shadertoy.com/view/7tK3Wd) but using the EGA palette", "tags": ["3d", "raytracing", "palette", "abstract", "ega"], "likes": 7, "viewed": 240, "published": 3, "date": "1670939594", "time_retrieved": "2024-07-30T16:13:04.354565", "image_code": "// Enhanced Graphics Adaptation by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define LUM_COEFFS vec3(.2126, .7152, .0722)\n#define ANIMATE_DITHER + float(iFrame & 15) * 13.\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 erot(vec3 p, vec3 ax, float a)\n{\n  return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\n// https://iquilezles.org/articles/intersectors\n// axis aligned box centered at the origin, extruded by radius r\nfloat rbi(vec3 ro, vec3 rd, float r)\n{\n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * (r + 1.);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.)\n        return -1.;\n    float t = tN;\n    \n    vec3 pos = ro + rd * t;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    pos -= 1.;\n    pos = max(pos.xyz, pos.yzx);\n    if(min(min(pos.x, pos.y), pos.z) < 0.) \n        return t;\n        \n    vec3 oc = ro - 1.;\n    vec3 dd = rd * rd;\n    vec3 oo = oc * oc;\n    vec3 od = oc * rd;\n    float ra2 = r * r;\n\n    t = 1e20;        \n\n    // corner\n    {\n        float b = od.x + od.y + od.z;\n        float c = oo.x + oo.y + oo.z - ra2;\n        float h = b * b - c;\n        if(h > 0.) t = -b - sqrt(h);\n    }\n    // edge X\n    {\n        float a = dd.y + dd.z;\n        float b = od.y + od.z;\n        float c = oo.y + oo.z - ra2;\n        float h = b * b - a * c;\n        if(h > 0.)\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.x + rd.x * h) < 1.)\n                t = h;\n        }\n    }\n    // edge Y\n    {\n        float a = dd.z + dd.x;\n        float b = od.z + od.x;\n        float c = oo.z + oo.x - ra2;\n        float h = b * b - a * c;\n        if(h > 0.)\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.y + rd.y * h) < 1.)\n                t = h;\n        }\n    }\n    // edge Z\n    {\n        float a = dd.x + dd.y;\n        float b = od.x + od.y;\n        float c = oo.x + oo.y - ra2;\n        float h = b * b - a * c;\n        if( h > 0. )\n        {\n            h = (-b - sqrt(h)) / a;\n            if(h > 0. && h < t && abs(ro.z + rd.z * h) < 1.)\n                t = h;\n        }\n    }\n\n    if( t > 1e19 ) t = -1.;\n    \n    return t;\n}\n\nvec4 render(vec3 ro, vec3 rd, float time)\n{\n    ro.xz *= -rot(time * .5);\n    ro.yx *= -rot(time * .4);\n    \n    rd.xz *= -rot(time * .5);\n    rd.yx *= -rot(time * .4);\n    \n    float t = rbi(ro, rd, .1);\n    if (t < 0.)\n        t = 100.;\n    vec3 p = ro + rd * t;\n    \n    return vec4(p, t);\n}\n\nvec3 normal(vec3 p, float t)\n{\n\treturn sign(p) * normalize(max(abs(p) - 1., 0.));\n}\n\nfloat lum(vec3 c)\n{\n    return dot(c, LUM_COEFFS);\n}\n\nvec3 color(float t)\n{\n    vec3 c = vec3(.4,.7,.01);\n    c *= LUM_COEFFS;\n    c = c * 2. - 1.;\n    c = erot(c, normalize(vec3(1, 1, 1)), -t) * .5 + .5;\n    c /= LUM_COEFFS;\n    return c;\n}\n\nvec3 palette[16] = vec3[]\n(\n    vec3(0),\n    vec3(1),\n    vec3(.3333),\n    vec3(.6666),\n    vec3(0, 0, .6666),\n    vec3(0, .6666, 0),\n    vec3(0, .6666, .6666),\n    vec3(.6666, 0, 0),\n    vec3(.6666, 0, .6666),\n    vec3(.6666, .3333, 0),\n    vec3(.3333, .3333, 1),\n    vec3(.3333, 1, .3333),\n    vec3(.3333, 1, 1),\n    vec3(1, .3333, .3333),\n    vec3(1, .3333, 1),\n    vec3(1, 1, .3333)\n);\n\nvec3 palettize(vec3 c, vec2 fc)\n{\n    c = clamp(\n        c + fract(dot(fc ANIMATE_DITHER, vec2(.11592,.60233)) + vec3(.666, .333, 0)) * .667 - .333,\n        0., 1.);\n    vec3 res = vec3(1,0,1);\n    float minDist = 1000000.;\n    for(int i = 0; i < 16; ++i)\n    {\n        vec3 pc = palette[i];\n        float d = length((c - pc));\n        if (d < minDist)\n        {\n            minDist = d;\n            res = pc;\n        }\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0, 0, -4);\n    vec3 rd = normalize(vec3(uv, 1.3));\n    \n    float t = iTime;\n    vec4 p = vec4(0);\n    for(int i = 0; i < 6; ++i)\n    {\n        ro -= rd * .3;\n        p = render(ro, rd, t);\n        t += p.w * (.5 + .5 * sin(iTime * .02));\n        if (p.w > 10.)\n            break;\n    }\n    \n    ro.xz *= -rot(t * .5);\n    ro.yx *= -rot(t * .4);\n    \n    rd.xz *= -rot(t * .5);\n    rd.yx *= -rot(t * .4);\n    \n    vec3 n = normal(p.xyz, t);\n    vec3 ld = normalize(vec3(1,0,1));\n    \n    ld.xz *= -rot(t * .5);\n    ld.yx *= -rot(t * .4);\n    \n    float l = dot(n, ld) * .5 + .5;\n    float spec = pow(dot(ld, reflect(rd, n)) * .5 + .5, 40.);\n    vec3 col = mix(color(iTime * .01) * l, vec3(l * 5.), l * l);\n    col += spec * 5.;\n    if (length(p.xyz) > 8.)\n        col = vec3(.85);\n    \n    \n    // saturation\n    col = mix(vec3(lum(col)), col, 1.5);\n    \n    // gamma\n    col = pow(col, vec3(1./2.2));\n    \n    // vignette\n    col *= smoothstep(1.5, .5, length(fragCoord - iResolution.xy * .5) / iResolution.y);\n    \n    col = palettize(col, fragCoord);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjSDK.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[225, 225, 244, 244, 320], [322, 322, 359, 359, 427], [429, 542, 580, 580, 2393], [2395, 2395, 2438, 2438, 2689], [2691, 2691, 2721, 2721, 2774], [2776, 2776, 2795, 2795, 2828], [2830, 2830, 2851, 2851, 3017], [3855, 3855, 3910, 3910, 5082]], "test": "untested"}
{"id": "msjSWK", "name": "Truchet Tiling (NOT!)", "author": "SnoopethDuckDuck", "description": "cool pattern idk what its called", "tags": ["tiling"], "likes": 21, "viewed": 254, "published": 3, "date": "1670935108", "time_retrieved": "2024-07-30T16:13:06.692315", "image_code": "#define pi 3.14159\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat box(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat tile(vec2 uv, vec2 fpos, vec2 ipos, float k, float i, float c) {\n    float h = h21(ipos);  \n    float t = .5 * iTime + 0. * i;\n    \n    fpos *= rot(floor(2. * h) * pi /2.);\n    float v = .0125 * cos(uv.x * 100. + t);\n    v += .025 * cos(5. * (2. * uv.x - uv.y) - 4. * t);\n    float o = c * (.25 - v);\n    vec2 off = vec2(o, 1.-o);\n    float s = smoothstep(-c*k, c*k,\n                         -abs(box(fpos+off,vec2(.5)))+(2.-.1*i)*c*.0675);\n    s = max(s,smoothstep(-c*k, c*k,\n                         -abs(box(fpos-off,vec2(.5)))+(2.-.1*i)*c*.0675));                         \n    return s;\n}\n\nfloat layer(vec2 uv, float i) {\n    float xt = mix(0.1,0.35,.5+.5*thc(6., uv.y + .5*i*pi/10. + .5*iTime)) * i;\n    float sc = 10. + xt;\n    float k = sc / iResolution.y;\n    vec2 ouv = uv;\n    uv += vec2(.75, .25) * (iTime + 0. * i) / sc;\n    \n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);\n       \n    float m = mod(2. * ipos.x - ipos.y, 5.);\n    \n    float id = 2.;\n    vec2 o = vec2(0);\n    \n    if (m != 3.) { fpos *= 0.5;  id = 1.; }    \n    if (m == 2.)      o = vec2(1,0); \n    else if (m == 4.) o = vec2(0,1); \n    else if (m == 1.) o = vec2(1);  \n    \n    fpos += 0.5 * o - 0.5;\n    ipos -= o;\n    \n    // should use id here but fpos.yx is an issue\n    if (m==3.) {\n        return tile(ouv, fpos.yx, ipos, k, i, 1.);\n    } else {\n        return tile(ouv, fpos, ipos, k, i, .5);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float s = 0.;\n    for (float i = 0.; i < 10.; i++) {\n        s = max(s, (1.-i/10.)*layer(uv, i));\n    }\n\n    vec3 col = .75 + .25 * cos(2.*pi*(s +.5*vec3(0,1,2)/3.));\n    col = mix(col, vec3(.1,0,.15), s);\n    vec2 p = .4 * vec2(cos(.87 * iTime), sin(.31 * iTime));\n    float d = length(uv - p);\n    float xp  = min(1., exp(2.-4.*d));\n    float xp2 = min(1., exp(.1-4.*d));\n    col = mix(col, vec3(.15,0,0), 1.-xp);\n    col = s * mix(col, vec3(1), xp2);\n    \n    float k = 1. / iResolution.y;\n    float s2 = smoothstep(-k, k, -d + mix(4., 6., .5+.5*cos(2.*iTime)) * k);\n    \n    col = mix(col, vec3(1), s2);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjSWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 129, 129, 204], [206, 206, 239, 239, 319], [321, 321, 391, 391, 919], [921, 921, 952, 952, 1732], [1734, 1734, 1791, 1791, 2497]], "test": "untested"}
{"id": "md2SWK", "name": "BraKi vertical lines convolution", "author": "braki", "description": "Inspired by xavierseb's shader \"Edge detection and other filters\", this shader demonstrates simple feature extraction using convolution filter", "tags": ["convolution", "vertical", "xavierseb"], "likes": 3, "viewed": 396, "published": 3, "date": "1670932620", "time_retrieved": "2024-07-30T16:13:07.741510", "image_code": "// basic convolutional filtering\n//\n//\n// vertical edge detection:\n// [  +2  0  -2 ]\n// [  +2  0  -2 ]\n// [  +2  0  -2 ]\n\n// set the convolution filter 0(none) - 1(vertical lines) other(sharpen)\n#define FILTER 1\n\n// adjust the distance used in the filter convolution\n#define STEP .005\n\n#define BOT 1.-STEP\n#define TOP 1.+STEP\n#define CEN 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = \n#if FILTER==0        \n        // none\n          \t\ttexture(iChannel0, uv*vec2(1));               \n#elif FILTER==1\n       // my filter\n       // vertcical lines enhanced\n              // column 1\n         \t\t+texture(iChannel0, uv*vec2(BOT, BOT)) *2.0\n         \t\t+texture(iChannel0, uv*vec2(BOT, CEN)) *2.0\n         \t\t+texture(iChannel0, uv*vec2(BOT, TOP)) *2.0\n              // column 2\n                -texture(iChannel0, uv*vec2(CEN, BOT)) *0.0\n                -texture(iChannel0, uv*vec2(CEN, CEN)) *0.0\n                -texture(iChannel0, uv*vec2(CEN, TOP)) *0.0\n              // column 3\n         \t\t-texture(iChannel0, uv*vec2(TOP, BOT)) *2.0\n         \t\t-texture(iChannel0, uv*vec2(TOP, CEN)) *2.0\n         \t\t-texture(iChannel0, uv*vec2(TOP, TOP)) *2.0;\n#else \n       // sharpen\n        \t\ttexture( iChannel0, uv) *5.\n         \t\t-texture(iChannel0, uv*vec2(CEN, BOT))\n         \t\t-texture(iChannel0, uv*vec2(BOT, CEN))\n         \t\t-texture(iChannel0, uv*vec2(TOP, CEN))\n         \t\t-texture(iChannel0, uv*vec2(CEN, TOP));\n\n#endif\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2SWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dd2SWV", "name": "[phreax] creation process", "author": "phreax", "description": "A twitter user asked of how this was made all from triangles. I thought, it'd be cool to show and animate the whole creation process of the \"Universe\"\n\nWatch at least until 90 sec - enjoy! \n\nbased on: https://www.shadertoy.com/view/dslSRf\n", "tags": ["fft", "spiral", "multipass", "zucconi"], "likes": 19, "viewed": 382, "published": 3, "date": "1670919341", "time_retrieved": "2024-07-30T16:13:08.690971", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n   \n   Based on: https://www.shadertoy.com/view/dslSRf\n*/\n\n#define PI 3.141592\n#define TAU 2.*PI\n#define SIN(x) (sin(x)*.5+.5)\n#define BEND .8     \n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define COUNT 100.\n#define S(a, b) smoothstep(a, b, TIME)\n\n//#define WATERCOLOR\n\nfloat tt, bass;\nfloat TIME;\n\n\nfloat bassFFT() {\n    int bandLimit = 5;\n    \n    float avg = 0.;\n    for(int i=0; i<bandLimit; i++) {\n        avg += texelFetch(iChannel1, ivec2(i, 0), 0).x;\n    }\n    return avg/float(bandLimit);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\nfloat triangle(vec2 uv, float w, float blur) {   \n  int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulate the distance\n  float d = 1.-cos(floor(.5+a/r)*r-a)*length(uv);\n  return smoothstep(blur, .0, abs(d)-w)*(0.3/blur);\n}\n\nvec3 spiral(vec2 uv, float z) {  \n\n    float spiralAmp = (3.*SIN(.5*PI+iMouse.y/360.*2.*PI)); \n    spiralAmp = 3.*S(9.5, 15.)+.3*S(52., 53.);\n    \n    uv *= rot((z*TAU-.2*tt)*spiralAmp);\n    \n    uv += vec2(1.7*sin(.4*z+2.4*tt), -.9*sin(.3*z+1.8*tt))*S(83., 83.3);\n\n    float soundMod = bass*(3.*sqrt(z)+.2);\n    \n    float dist = 2.5*S(35., 42.) -.5*S(52., 52.3);\n    dist += sin(soundMod);\n    uv += dist*sin(vec2(5)*uv.yx+.2*tt);//.3*pow(sin(.2*tt+z+uv.x), 2.);\n\n    float blur = exp(-19.*z);\n    float luma = exp(-19.5*z);\n    vec3 col = spectral_zucconi6(fract(2.*z+.2*tt+uv.x*.2+bass*sqrt(z)*2.))*.8;\n    \n    col = mix(vec3(1), col, S(61.2, 61.2));\n    \n    float size = mix(.02, .05, S(61.2, 61.2)) +.08*S(8., 2.);\n    luma *= 1.+5.*S(8., 2.);\n    blur = mix(0.01, blur, S(25., 35.))+.015*(1.-blur);\n    return triangle(uv, size, blur)*luma*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    //uv *= rot(-.5*PI);\n    vec3 col = vec3(0);\n    vec4 tex = texture(iChannel0, fragCoord/iResolution.xy);\n    if (tex.a != iResolution.x) tex = vec4(0);\n    tt = iTime*.2;\n    TIME = iChannelTime[1];\n    \n    if(iResolution.y <= 400.) TIME = iTime+90.;  // preview\n    \n    bass = bassFFT()*S(83., 83.3);\n\n    uv *= 100.;\n    \n    float count = 4.+S(5.4, 10.)*COUNT;\n    float s = 1./count; \n    \n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        float fade = smoothstep(1., .9, z);\n        vec2 UV = uv;\n        col += spiral(UV*z, z)*fade;\n        \n    }\n    col = pow(col, vec3(0.5));\n    #ifdef WATERCOLOR\n    col = 1.05-col;\n    col = pow(col, vec3(2.2));\n    col = clamp(col, vec3(0), vec3(1));\n    #endif\n    \n    col *= S(82., 80.)+S(83., 83.3);;\n    \n    float feedback = S(42., 42.5);\n    col = mix(col, tex.rgb, 0.98*feedback);\n    \n\n    //col = vec3(1);\n    // Output to screen\n    fragColor = vec4(col, iResolution.x);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35697, "src": "https://soundcloud.com/tycho/into-the-woods", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2SWV.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[86, 86, 143, 143, 271]], "test": "untested"}
{"id": "DsjXDK", "name": "Triangular pattern", "author": "python273", "description": "-", "tags": ["pattern"], "likes": 17, "viewed": 429, "published": 3, "date": "1670915354", "time_retrieved": "2024-07-30T16:13:09.746149", "image_code": "#define PI 3.141592653589793\n\nvec3 sp(vec2 uv) {\n    float l = length(uv) / length(vec2(.5));\n\n    float a = (1. + atan(uv.y, uv.x) / PI) / 2.;\n\n    //a = fract(a + cos(l) / 5.0 + iTime / 60.0);\n    a = fract(a + l / 1. - iTime / 30.);\n    \n    float r = smoothstep(1., sin(a * PI * 6. + 0.0) / PI, l * 1.4);\n    float g = smoothstep(1., sin(a * PI * 6. + 1.1) / PI, l * 1.5);\n    float b = smoothstep(1., sin(a * PI * 6. + 2.2) / PI, l * 1.5);\n\n    return vec3(r, g, b);\n}\n\n#define S 0.04\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec2 gv = vec2(\n        mod(uv.x + floor(uv.y / S) * S/2., S),\n        mod(uv.y, S)\n    );\n    vec2 sc = uv - gv;  // center of triangle kinda\n    gv /= S;\n\n    if ((gv.y <= gv.x * 2.) && (gv.y <= (gv.x * -2. + 2.))) {  // center triangle\n         sc += vec2(S/2., S/3.);\n         sc += ((gv-vec2(0.5, 1./3.))*S)/1.2;\n    } else {  // left and right halfs\n        sc += vec2(round(gv.x)*S, S-(S/3.));\n        sc += vec2(0.01);\n    }\n\n    fragColor = vec4(sp(sc), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjXDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 48, 48, 473], [491, 491, 548, 548, 1103]], "test": "untested"}
{"id": "cd2SDK", "name": "CM_Sub VR", "author": "CMH", "description": "20221206_2ndRaymarch_v1.qtz", "tags": ["subsurface", "vr"], "likes": 17, "viewed": 526, "published": 3, "date": "1670914949", "time_retrieved": "2024-07-30T16:13:10.706581", "image_code": "// Author:CMH\n// learning shader from iq's code, thanks iq!\n\n//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n\nvec3 normalMap(vec3 p, vec3 n);\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat noise_3(in vec3 p); //亂數範圍 [0,1]\nvec3 FlameColour(float f);\nmat3 fromEuler(vec3 ang);\n\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p)\n{\n  vec3 b=vec3(0.4);\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nmat3 rot=fromEuler(vec3(0.0,0.0,iTime*0.2));\nvec3 p1=(p+vec3( 0.0, -0.0, 1.2))*rot;\nvec3 p2=(p+vec3( 1.2, -0.0, 0.0))*rot;\nvec3 p3=(p+vec3(-1.2, -0.0, 0.0))*rot;\nvec3 p4=(p+vec3( 0.0, -0.0,-1.2))*rot;\nvec3 p5=(p+vec3( 0.0, -1.2, 0.0))*rot;\nreturn min(min(min(min(sdBox(p1),sdBox(p2)),sdBox(p3)),sdBox(p4)),sdBox(p5));\n//return sdSphere(p1+vec3(0.,0.,0.0), 0.5);\n//return sdTorus(p+vec3(0.,0.,0.0),vec2(0.4,0.2))+bump;\n//return udRoundBox(p+vec3(0.0,0.0,0.0), vec3(0.3, 0.3, 0.3), 0.1)+bump;\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<32; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.8; //影響輪廓精準程度\n\t}\nreturn t;\n}\n// === raytrace functions===\nfloat traceInner(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.01;\nfor (int i=0; i<32; ++i)\n{\n\tp= o+r*t;\n\td=-map(p);\n\tif(d<0.001 || t>10.0) break;\n\tt += d*0.5; //動手腳\n\t}\nreturn t;\n}\n\n\n//=== sky ===\nfloat fbm(in vec2 uv);\nvec3 getSkyFBM(vec3 e) {\t//二維雲霧\n\tvec3 f=e;\n\tfloat m = 2.0 * sqrt(f.x*f.x + f.y*f.y + f.z*f.z);\n\tvec2 st= vec2(-f.x/m + .5, -f.y/m + .5);\n\t//vec3 ret=texture2D(iChannel0, st).xyz;\n\tfloat fog= fbm(0.6*st+vec2(-0.2*iTime, -0.02*iTime))*0.5+0.3;\n    return vec3(fog);\n}\n\nvec3 sky_color(vec3 e) {\t//漸層藍天空色\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret=FlameColour(e.y);\n    return ret;\n}\n\nvec3 getSkyALL(vec3 e)\n{\t\n\treturn sky_color(e);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\nvec3 render( in vec3 RayOri, in vec3 RayDir ){\n\n    //First Ray\n    vec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n    vec3 bump=normalMap(p*3.0,n);\n    n=n+bump*0.05;\n    float edge= dot(-RayDir, n);\n    edge = smoothstep(-.20, 0.5, edge);\n    \n    //Second Ray\n    vec3 p2,n2;\n    float IOR=1.33;\n    vec3 Rd_2=refract(RayDir,n,1.0/IOR);\n\tfloat t2 = traceInner(p, Rd_2, p2);\n    n2=normalize(gradient(p2));\n    //3rd Ray\n    vec3 Rd_3=refract(Rd_2,-n2,IOR/1.0);//注意方向性    \n    vec3 refl=getSkyALL(reflect(RayDir,n));\n    vec3 refr=getSkyALL(Rd_3)+FlameColour(t2*1.0);\n    float F=1.0-0.8*dot(n,-RayDir); //edge=0 center=1\n    vec3 final = mix(refr,refl, F);\n\t\t\n//SHADING\n    vec3 result;\n    result=final*edge;\n   \n//SKY Background\n\tvec3 BG=getSkyALL(RayDir);\t   //或getSkyFBM(RayDir)\n\nif(t<4.) return result; else return BG;\n}\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy/iResolution.xy;\nuv = uv*2.0-1.0;\nuv.x*= iResolution.x/iResolution.y;\nvec2 mouse=iMouse.xy/iResolution.xy;\n\n// camera option1  (模型應在原點，適用於物件)\n\tvec3 CameraRot=vec3(0.0, -mouse.y*1.6, -mouse.x*6.28);\n\tvec3 ro= vec3(0.0, 0.0, 0.0);\n\tvec3 ta =vec3(0.0, 0.0, -1.0)*fromEuler(CameraRot);\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 1.5));\n\tvec3 RayOri = ro;\n\n\tvec3 col = render(RayOri,RayDir);\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n \n    vec3 col = render( fragRayOri + vec3(0.0,0.0,0.0), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n//=== glow functions ===\nfloat glow(float d, float str, float thickness){\n    return thickness / pow(d, str);\n}\n\n//=== 2d noise functions ===\nvec2 hash2( vec2 x )\t\t\t//亂數範圍 [-1,1]\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat gnoise( in vec2 p )\t\t//亂數範圍 [-1,1]\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     \t    dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                \t     mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     \t    dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fbm(in vec2 uv)\t\t//亂數範圍 [-1,1]\n{\n\tfloat f;\t\t\t\t//fbm - fractal noise (4 octaves)\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf   = 0.5000*gnoise( uv ); uv = m*uv;\t\t  \n\tf += 0.2500*gnoise( uv ); uv = m*uv;\n\tf += 0.1250*gnoise( uv ); uv = m*uv;\n\tf += 0.0625*gnoise( uv ); uv = m*uv;\n\treturn f;\n}\n\n//=== 3d noise functions p/n ===\nvec3 smoothSampling2(vec2 uv)\n{\n    const float T_RES = 32.0;\n    return vec3(gnoise(uv*T_RES)); //讀取亂數函式\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return  (abs(n.x)*smoothSampling2(p.yz).x\n            +abs(n.y)*smoothSampling2(p.xz).x\n            +abs(n.z)*smoothSampling2(p.xy).x)/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n    float px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n    float pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)/d,\n                          (py-po)/d,\n                          (pz-po)/d));\n}\n\n\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2SDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 344, 379, 379, 405], [406, 406, 437, 437, 524], [525, 525, 547, 547, 654], [655, 655, 688, 688, 753], [754, 754, 797, 840, 884], [886, 886, 908, 908, 1401], [1403, 1432, 1478, 1478, 1696], [1698, 1727, 1768, 1768, 1910], [1911, 1940, 1986, 1986, 2127], [2167, 2167, 2191, 2206, 2440], [2442, 2442, 2466, 2487, 2569], [2571, 2571, 2595, 2595, 2620], [2622, 2649, 2701, 2701, 2878], [2880, 2888, 2914, 2914, 3284], [3286, 3286, 3332, 3349, 4153], [4155, 4175, 4232, 4232, 4732], [4734, 4734, 4828, 4828, 4935], [4953, 4982, 5005, 5005, 5055], [5056, 5056, 5078, 5078, 5158], [5159, 5159, 5181, 5181, 5269], [5271, 5283, 5309, 5309, 5930], [5931, 5956, 6004, 6004, 6042], [6044, 6073, 6119, 6119, 6257], [6258, 6258, 6308, 6308, 6729], [6730, 6730, 6776, 6776, 7034], [7036, 7069, 7100, 7100, 7188], [7190, 7190, 7231, 7231, 7427], [7473, 7473, 7511, 7511, 7910], [7912, 7912, 7944, 7944, 8260], [8264, 8333, 8367, 8367, 8545], [8547, 8547, 8588, 8588, 8703], [8705, 8705, 8732, 8732, 8805]], "test": "untested"}
{"id": "7lVcR1", "name": "corals", "author": "lomateron", "description": "7 layers across time of 3x3 pixel grids\nforgot to publish this\n", "tags": ["automata"], "likes": 9, "viewed": 229, "published": 3, "date": "1670906603", "time_retrieved": "2024-07-30T16:13:11.619141", "image_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = texelFetch(iChannel0,ivec2(u),0);\n    uint b = floatBitsToUint(a.x)&255U;\n    int i = iFrame&7;\n    b = (b>>i)|(b<<(8-i));\n    fragColor = cos(float(b&255U)*77.1111+vec4(3,1,2,4))*.5+.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "uint read(vec2 u, vec2 m)\n{\n    vec2 o = mod(u+m,iResolution.xy);\n    return floatBitsToUint(texelFetch(iChannel0,ivec2(o),0).x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    int  tz  = 7;//layers across time\n    int  sz  = 1;//3x3 pixel grids\n    uint sum = 0U;\n    for(int t= 0 ; t< tz; ++t){\n    for(int i=-sz; i<=sz; ++i){\n    for(int j=-sz; j<=sz; ++j){ sum += (read(u,vec2(i,j))>>t)&1U;\n    }}}\n    uint a = +16U*8U*16U*8U* ((3U<<10U)|(1U<<3U))\n             +16U*8U*16U*    2U\n             +16U*8U*        0U\n             +16U*           1U\n             +               15U;\n    if(sum>=32U){a = ((1U<<13U)-1U)<<3U;}\n    uint o = read(u,vec2(0));\n         o = (o<<1U) | ((a>>(sum&31U))&1U);\n\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2  v = (u*2.-iResolution.xy)/iResolution.y;\n        float r = fract(cos(dot(u,vec2(11.76543,iTime+22.5363)))*3467.5678)*256.;\n              r*= step(dot(v,v),.7);\n              r*= step(.6,dot(v,v));\n        o = uint(r);\n    }\n    fragColor = vec4(uintBitsToFloat(o));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 251]], "test": "untested"}
{"id": "msBXDV", "name": "Cubemap reflections", "author": "SONENEIS", "description": "raymarching with reflections", "tags": ["raymarching", "distancefield", "reflection", "phong", "sdf", "cube", "shadow", "sphere", "cubemap", "occlusion", "plane", "smoothminimum", "softshadow", "goursat", "occ"], "likes": 11, "viewed": 308, "published": 3, "date": "1670901030", "time_retrieved": "2024-07-30T16:13:12.563617", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nfloat smin(float a,float b,float k){\n\tfloat h = clamp(0.5-0.5*(b-a)/k,0.0,1.0);\n\treturn mix(a,b,h) - k*h*(1.0-h);\n}\n\nfloat smax(float a,float b,float k){\n\tfloat h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n\treturn mix(a,b,h) + k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p,float r){\n\treturn length(p) - r;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 p,vec3 n,float d){\n\treturn dot(p,n) + d;\n}\n\nfloat sdCylinderInf(vec3 p,float r){\n\treturn length(p.xy) - r;\n}\n\nfloat scene(vec3 p){\n\tfloat d = 99999.99999;\n\n\td = min(d,mix(sdBox(p,vec3(0.4))-0.1,sdSphere(p,0.5),-1.0));\n  d = smax(d,-sdSphere(p,0.43),0.5);\n  d = min(d,sdSphere(p,0.5));\n\td = smin(d,sdPlane(p,vec3(0,1,0),0.5),0.25);\n\n\td = smin(d,sdSphere(p-vec3(1,-0.25,-1),0.3),0.05);\n\n\treturn d;\n}\n\nfloat raymarch(vec3 ro,vec3 rd){\n\tfloat d = 0.001;\n\n\tfor(int i=0;i<128;i++){\n\t\tvec3 p = ro + rd*d;\n\t\tfloat h = scene(p);\n\t\td += h*0.45;\n\t\tif(h < 0.001 || d > 20.0) break;\n\t}\n\n\tif(d > 20.0) return 20.0;\n\treturn d;\n}\n\nfloat calcSoftShadow(vec3 ro,vec3 rd,float k){\n\tfloat mint = 0.001;\n\tfloat tmax = 256.0;\n\n\tfloat res = 1.0;\n  float t = mint;\n  float ph = 1e10;\n\n  for(int i=0;i<512;i++){\n\t\tfloat h = scene(ro + rd*t);\n\n    float y = (i==0) ? 0.0 : h*h/(2.0*ph);\n    float d = sqrt(h*h-y*y);\n    res = min(res,k*d/max(0.0,t-y));\n    ph = h;\n\n    t += h*0.45;\n\n    if(res<0.0001 || t>tmax) break;\n  }\n\n  res = clamp(res,0.0,1.0);\n  return res*res*(3.0-2.0*res);\n}\n\nfloat calcAO(vec3 pos,vec3 nor){\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n  for(int i=0;i<5;i++){\n    float h = 0.1*float(i)/10.0;\n    float d = scene(pos + h*nor);\n    occ += (h-d)*sca;\n    sca *= 0.95;\n    if(occ > 0.35) break;\n  }\n\n  return clamp(1.0-7.0*occ,0.0,1.0);\n}\n\nvec3 calcNormal(vec3 p){\n\tvec2 e = vec2(1,-1) * 0.001;\n\treturn normalize(vec3(\n\t\te.yyx * scene(p + e.yyx) +\n\t\te.xyy * scene(p + e.xyy) +\n\t\te.yxy * scene(p + e.yxy) +\n\t\te.xxx * scene(p + e.xxx)\n\t));\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  vec3 ro = vec3(0.0,0.0,3.0);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  ro.y += 1.0;\n  rd.yz *= rot(-0.25);\n\n  ro.xz *= rot(iTime*0.5);\n  rd.xz *= rot(iTime*0.5);\n\n  vec3 bg = vec3(0.7,0.8,1.0);\n  //vec3 bg = 0.5+mix(vec3(0.2,0.1,0.05),vec3(0.1,0.5,1.0),clamp(rd.y*0.5+0.25,0.0,1.0));\n  //bg = pow(clamp(bg,0.0,1.0),vec3(1.5))*1.0+0.5;\n\n  float d = raymarch(ro,rd);\n  if(d > 0.0 && d < 20.0){\n  \tvec3 pos = ro + rd*d;\n  \tvec3 nor = calcNormal(pos);\n  \tvec3 mate = vec3(0.0);\n  \tvec3 ref = reflect(rd,nor);\n  \tfloat occ = calcAO(pos,nor);\n\n    //mate = 0.2*vec3(1.0);\n  \tmate = clamp(texture(iChannel0,ref).rgb,0.0,1.0);\n  \t//mate *= vec3(1.0,0.7,0.5);\n  \t//mate += vec3(1.0,0.7,0.5);\n\n    mate = pow(mate,vec3(2.2));\n    mate *= pow(bg,vec3(2.2));\n    //mate *= bg;\n\n  \t{\n  \t\tvec3 lig = normalize(vec3(0.5));\n  \t\tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n  \t\tfloat spe = 2.0*pow(clamp(dot(ref,lig),0.0,1.0),10.0);\n  \t  dif *= calcSoftShadow(pos,lig,8.0);\n  \t  col += mate * dif;\n  \t  spe *= calcSoftShadow(pos,ref,4.0);\n  \t  col += mate * 5.0*spe * dif;\n  \t  col += clamp(0.001*pow(spe,10.0),0.0,1.0) * dif;\n  \t}\n\n  \t{\n  \t\tfloat dif = clamp(nor.y*0.5+0.5,0.0,1.0);\n  \t\tfloat spe = clamp(ref.y*0.5+0.5,0.0,1.0);\n  \t  col += 0.05 * mate * vec3(0.2,0.4,1.0) * dif;\n  \t  spe *= calcSoftShadow(pos,ref,1.0);\n  \t  col += 0.05 * vec3(0.2,0.4,1.0) * spe;\n  \t}\n\n   col = clamp(col,0.0,1.0) * occ*occ*occ;\n  }\n\n  col = clamp(pow(col,vec3(1.0/2.2)),0.0,1.0);\n\n  col = mix(col,clamp(texture(iChannel0,rd).rgb*bg,0.0,1.0),clamp(0.000001*d*d*d*d*d,0.0,1.0));\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 99, 99, 178], [180, 180, 216, 216, 295], [297, 297, 328, 328, 353], [355, 355, 382, 382, 467], [469, 469, 506, 506, 530], [532, 532, 568, 568, 596], [598, 598, 618, 618, 885], [887, 887, 919, 919, 1101], [1103, 1103, 1149, 1149, 1548], [1550, 1550, 1582, 1582, 1819], [1821, 1821, 1845, 1845, 2020], [2022, 2022, 2072, 2072, 3731]], "test": "untested"}
{"id": "msBXDK", "name": "disco target", "author": "tieutieu", "description": "playing with fract sin and the mouse. Add antialiasing thx to mla.", "tags": ["interactivecolor"], "likes": 4, "viewed": 267, "published": 3, "date": "1670884220", "time_retrieved": "2024-07-30T16:13:13.377440", "image_code": "\n//PUT THE ORIGINE AT THE CENTER OF THE SCREEN & NORMALIZE\nvec2 map(vec2 pcoord) {\n  return (pcoord-0.5*iResolution.xy)/iResolution.y;\n}\n\n/*\nfloat sfract(float x) {\n  float px = fwidth(x);\n  x -= round(x);\n  return mix( x+1.0 , x ,smoothstep(-px,px,x));\n}\n*/\nfloat sfract(float x) {\n  //WITHOUT ANTIALIASING\n  //return fract(x);\n  //WITH ANTIALIASING\n  float px = fwidth(x);\n  x -= round(x);\n  return mix( x+1.0 , x , smoothstep(-px,px,x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime;\n    vec2 uv = map(fragCoord);                         \n\n    vec2 mouseN = iMouse.x <= 0.0 ? vec2(0): map(iMouse.xy);\n    uv -= mouseN;\n    fragColor.r = sfract(length( uv.xy*10. )*float(1.0*sin(t*0.1)));\n    fragColor.g = sfract(length( uv.xy*10. )*float(1.0*sin(t*0.2)));\n    fragColor.b = sfract(length( uv.xy*10. )*float(1.0*sin(t*0.3))) ; \n\n}\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBXDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 59, 82, 82, 136], [138, 259, 282, 350, 442], [445, 445, 502, 502, 871]], "test": "untested"}
{"id": "msBXWK", "name": "Reflective 4D Julia", "author": "mrange", "description": "CC0: Reflection 4D Julia\nLate to the party experimenting with 4D julias.\nDistance function from IQ's Quaternion 1 : https://www.shadertoy.com/view/MsfGRr\n", "tags": ["julia", "4d"], "likes": 17, "viewed": 338, "published": 3, "date": "1670879511", "time_retrieved": "2024-07-30T16:13:14.192262", "image_code": "// CC0: Reflective 4D Julia\n// Late to the party experimenting with 4D julias.\n// Distance function from IQ's Quaternion 1 : https://www.shadertoy.com/view/MsfGRr\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  24.0\n#define MAX_RAY_MARCHES 100\n#define MAX_REF_MARCHES 30\n#define MAX_SHADOW_MARCHES 20\n#define NORM_OFF        0.001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 skylineCol = HSV2RGB(vec3(hoff+0.35, 0.85, 0.0025));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.60, 0.75, 0.2));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\nconst mat2 rot0 = ROT(0.0); \n\nfloat g_zoff = 0.0;\nmat2 g_rot0 = rot0; \nmat2 g_rot1 = rot0; \nmat2 g_rot2 = rot0; \n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n\n  col += skylineCol/abs(abs(rd.y));\n  col += 0.5*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat dot2(vec4 p) {\n  return dot(p, p);\n}\n\nvec4 q2(vec4 a) {\n    return vec4(a.x*a.x - dot(a.yzw,a.yzw), 2.0*a.x*(a.yzw));\n}\n\n// From IQ's - Quaternion 1 : https://www.shadertoy.com/view/MsfGRr\nfloat julia(vec3 p, vec4 c) {\n  vec4 z = vec4(p, g_zoff);\n  z.wz *= g_rot0;\n  z.wx *= g_rot1;\n  z.wy *= g_rot2;\n  float md2 = 1.0;\n  float mz2 = dot2(z);\n\n  for(int i=0; i<8; ++i) {\n    md2 *= 4.0*mz2;\n    z = q2(z) + c;  \n\n    mz2 = dot2(z);\n    if(mz2>40.0) break;\n  }\n    \n  return 0.25*sqrt(mz2/md2)*log(mz2);  // d = 0.5·|z|·log|z|/|z'|\n}\n\n\nfloat df(vec3 p) {\n  const vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + 0.9*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n  float d0 = p.x+3.0;\n  const float z = 3.0;\n  float d1 = julia(p/z, c)*z;\n  float d= d0;\n  d = min(d, d1);\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\nfloat shadowMarch(in vec3 ps, in vec3 ld, in float mint, in float k) {\n  float res = 1.0;\n  float t = mint*2.0;\n  for (int i=0; i<MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = df(p);\n    res = min(res, k*d/t);\n    if (res < TOLERANCE) break;\n    \n    t += max(d, mint);\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  float t = rayMarch(ro, rd);\n  vec3 col = vec3(0.0);\n\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  float sd = shadowMarch(p, sunDir1, 0.025, 8.0);\n  float rf = shadowMarch(p, r, 0.025, 4.0);\n  \n  float dif = max(dot(sunDir1, n), 0.0);\n  dif *= dif;\n  dif *= dif;\n  vec3 rcol = render0(p, r);\n  if (t < MAX_RAY_LENGTH) {\n    col = diffCol;\n    col *= mix(0.2, 1.0, dif);\n    col *= mix(0.2, 1.0, abs(sd));\n    col += rcol*rf;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const vec3 ro = vec3(5.0, 0.5, 1.2);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\n  const vec3 ww = normalize(la - ro);\n  const vec3 uu = normalize(cross(up, ww ));\n  const vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n\n  g_zoff = 0.25*sin(0.06*TIME);\n  g_rot0 = ROT(0.1*TIME);\n  g_rot1 = ROT(0.21*TIME);\n  g_rot2 = ROT(0.32*TIME);\n\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n  vec3 col = render1(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n//  col *= smoothstep(1.75, 1.0-0.5, length(pp));\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[691, 691, 713, 713, 859], [1664, 1764, 1783, 1783, 1870], [1872, 1979, 2005, 2005, 2189], [2191, 2284, 2326, 2326, 2373], [2375, 2493, 2520, 2520, 2596], [2598, 2598, 2630, 2630, 3255], [3257, 3257, 3277, 3277, 3299], [3301, 3301, 3318, 3318, 3382], [3384, 3452, 3481, 3481, 3797], [3800, 3800, 3818, 3818, 4044], [4046, 4046, 4069, 4069, 4277], [4279, 4279, 4313, 4313, 4645], [4647, 4647, 4717, 4717, 4972], [4974, 4974, 5006, 5006, 5479], [5481, 5481, 5502, 5502, 5991], [5993, 5993, 6048, 6048, 6331]], "test": "untested"}
{"id": "msSSWK", "name": "Strangey eYeS", "author": "z0rg", "description": "Made during a livecoding party in paris with cookie collective : LaFarbiqueACookie#03\nCode is as is, simply ported from veda.", "tags": ["eyes", "strange", "mystery"], "likes": 23, "viewed": 429, "published": 3, "date": "1670876232", "time_retrieved": "2024-07-30T16:13:15.026033", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FFTI(a) time\n\n#define sat(a) clamp(a, 0., 1.)\n\n#define PI 3.14159265\n#define TAU (PI*2.0)\nfloat hash(float seed)\n{\n    return fract(sin(seed*123.456)*123.456);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x, max(l.y, l.z));\n}\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n\n    return max(min(min(x, y), z), cube);\n}\nfloat _seed;\n\nfloat rand()\n{\n    _seed++;\n    return hash(_seed);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*3.);\n}\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\nfloat _cir(vec2 uv, float sz)\n{\n  return length(uv)-sz;\n}\n\nfloat _loz(vec2 uv,float sz)\n{\n  return lenny(uv)-sz;\n}\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\nvec2 _max(vec2 a, vec2 b)\n{\n  if (a.x > b.x)\n      return a;\n  return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000., -1.);\n\n    acc = _min(acc, vec2(length(p)-1., 0.));\n\n    return acc;\n}\n\n\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01, 0.);\n  return  normalize(vec3(d) - vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec3 res, vec2 id)\n{\n  vec3 col = n *.5+.5;\n\n  vec3 ldir = normalize(vec3(1.));\n\n  if (res.z == 0.)\n  {\n\n    col = vec3(.3,.1,.1)+mix(vec3(1.), vec3(.5,.6,.3), .5)*sat(dot(-rd, n));\n    vec3 p2 = p;\n    float speed = 2.;\n    float it = float(int(iTime));\n    float t=iTime*2.+length(id);\n    float hangle = clamp(sin(t)*2., -1.,1.);\n    p2.xy *= r2d(length(id)*10.+id.x+iTime*.2);\n    p2.xz *= r2d((smoothstep(-1.,1.,hangle)-.5));\n    p2.yz *= r2d(sin(t*.3)*.5);\n    vec2 uv = p2.xy;\n    float border = abs(length(uv)-.4)-.2+.1*sin(iTime);\n    float eyemask = length(uv)-.5;\n    border = max(border, eyemask);\n    col = mix(col, vec3(0.), 1.-sat(eyemask*400.));\n    float an = atan(uv.y, uv.x);\n    vec2 uvi = vec2(an*.1, .05*length(uv));\n    vec3 rgb = vec3(0.);\n    vec3 iriscol = mix(vec3(0.,.4,.2), vec3(0.,0.5,0.8), texture(iChannel0, uvi).x);\n    iriscol.yz *= r2d(texture(iChannel0, id*.1).x*15.+iTime);\n    iriscol = abs(iriscol.zxy);\n    rgb = iriscol\n    *(pow(texture(iChannel0, uvi*.5).x, 2.)+.5)\n    *pow(sat(-dot(rd, n)), 2.);\n\n    col = mix(col, rgb, 1.-sat(border*400.));\nvec3 h = normalize(rd+ldir);\n    col += vec3(.2)*pow(sat(-dot(h, n)), 45.);\n  }\n\n  return col;\n}\n\nvec3 rdrback(vec2 uv)\n{\n    vec2 ouv = uv;\n  vec3 col = vec3(0.);\n  float t = iTime*.1;\n  uv += vec2(sin(t), cos(t))*.25;\n  vec2 uv2 = vec2(atan(uv.y, uv.x)/PI, length(uv))*.25;\n  col = pow(texture(iChannel0, uv2+vec2(0., -iTime*.125)).xxx, vec3(6.))*.45*vec3(.9,.2,.1);\n  col += vec3(.1,.2,.5)*pow(texture(iChannel0, uv2*.5+vec2(0., -iTime*.0125)).xxx, vec3(16.))*.45;\n  col.xy *= r2d(iTime+13.*length(uv));\n  col = abs(col);\n  col *= 2.5;\n  return col.zxy*sat(length(ouv)*5.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  uv *= r2d(.5);\n  vec2 rep = vec2(.25);\n  vec2 id = floor((uv+rep*.5)/rep);\n  uv = mod(uv+rep*.5,rep)-rep*.5;\n  uv *= 1.-.2*sin(length(id)*10.+iTime);\n    vec3 ro = vec3(0.,0., -5.);\n    vec3 ta = vec3(sin(iTime*.5+id.y*3.)*.5,sin(iTime*.25+id.x*2.)*.5,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec3 col = vec3(0.);\n\n\n\n    col = rdrback(uv);\n\n\n    vec3 res = trace(ro, rd);\n    float depth = 100.;\n    if (res.y > 0.)\n    {\n      depth = res.y;\n        vec3 p = ro + rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(p, n, rd, res, id);\n\n        float spec = .1;\n        vec3 refl = normalize(reflect(rd, n)+spec*(vec3(rand(), rand(), rand())-.5));\n        vec3 resrefl = trace(p+n*0.01, refl);\n    }\n\n    return col;\n}\nuniform sampler2D backbuffer;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.xx;\n    //uv *= vec2(.66, 1.);\n    //uv -= vec2(.1,0.);\n    uv *= 1.+length(uv)*5.;\n    uv *= .5;\n    _seed = iTime+texture(iChannel0, uv).x;\n   vec3 col = rdr(uv);\n   col += pow(rdr(uv+(vec2(rand(), rand())-.5)*.05), vec3(1.4))*1.7;\n   col = sat(col);\n   col *= (1.-sat((length(uv)-.5)*2.));\n   col = mix(col, texture(iChannel1, ouv).xyz, .7);\n//   col += texture2D(ziconTex, (uv*4.+.5)).xyz;\n    fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSSWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 173]], "test": "untested"}
{"id": "cdSXDV", "name": "Three sine waves with less code", "author": "fishy", "description": "199 chars vs 248. Note: I am terrible at making code small", "tags": ["sine"], "likes": 5, "viewed": 248, "published": 3, "date": "1670874686", "time_retrieved": "2024-07-30T16:13:15.829883", "image_code": "// Original (248 chars)\n/*#define s(a, b, c, d) 0.003/abs(sin(uv.x*a+iTime*c)*b-uv.y)*d\nvoid mainImage( out vec4 r, in vec2 d )\n{\n    vec2 uv = ((d.yx-iResolution.xy*0.5)/iResolution.y);\n    r = vec4(vec3(s(20., 0.05, 2.0, vec3(1, 0, 0))+s(20., 0.05, 2.1, vec3(0, 1, 0))+s(20., 0.05, 2.2, vec3(0, 0, 1))),1.0);\n}*/\n\n// New (199 chars)\n#define s(c) 0.03/(abs(sin(p.x*20.+iTime*c)*0.2-p.y)+0.03)\nvoid mainImage( out vec4 r, in vec2 d )\n{\n    vec2 p = (d.xy-iResolution.xy*0.5)/iResolution.y;\n    r = vec4(s(2.0),s(2.1),s(2.2),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 435, 435, 529]], "test": "untested"}
{"id": "DdSXDV", "name": "Simple Lossless Compression", "author": "PrzemyslawZaworski", "description": "Very simple example of packing and unpacking data into / from single bits. In this way, visible image can be encoded and stored in 512 bytes.\nCommon -  C# utils to generate uint array from input data;\nImage - standalone shader", "tags": ["2d", "3d", "compression", "image", "maze", "packing", "byte", "data", "labyrinth", "unpacking"], "likes": 5, "viewed": 266, "published": 3, "date": "1670873563", "time_retrieved": "2024-07-30T16:13:16.744438", "image_code": "const uint _GridSize = 64u;\nconst uint _ArraySize = _GridSize * _GridSize / 32u;\n\nconst uint _Uints[_ArraySize] = uint[_ArraySize] // encoded 4096 bools (grid 64x64) into 128 uints (512 bytes)\n(\n    4294967295u,4294967295u,2022752772u, 805611218u, 807649868u,2422235486u, 617628712u, 674267525u,\n      16843524u,1218593956u, 408045258u, 312478641u,2300022620u,   2625664u,4065866000u,1354350920u,\n    2731248654u, 380895556u, 436773154u, 547168963u,1275069056u,1338098820u,  11437153u,1620887856u,\n       5353090u,1111556240u, 321151776u,3259016449u,1359055398u,1681674306u,   7864399u,2167451699u,\n    1786987028u,  12622017u,3447744647u,   6402882u, 585619981u,2634056076u,2204677856u, 304111648u,\n        590662u,1074794509u,2446460050u,2168524822u,2032271492u,    524742u,3087008129u,1786774730u,\n     317342018u,2954723368u,2215656512u, 607195249u,1879614210u, 268505090u,2919512668u, 805314955u,\n    1361658995u,   6508808u,    550914u,1142166144u,  34106416u,2160592900u,4026550282u, 550506638u,\n    1208766584u, 307233192u, 276825679u,2874216528u,2889925676u,  37848390u,1061831056u,  37296276u,\n      71843844u, 210334280u,2793821323u,3239383041u,1363759144u,3700818508u,1222674144u, 946149378u,\n     226800320u,1075923008u, 675828103u,   4472993u,1837174788u,3793494088u, 671187209u, 994054848u,\n    2315543076u,1175150603u,2286231874u,3004049667u,2424307796u, 712125506u,1145569282u,  43091074u,\n     806846880u, 771769098u, 598696275u, 369174722u, 942752805u, 220467270u,1879401800u,2778859568u,\n     557974913u, 549605409u,  15280150u, 612412544u,  98631960u,2196827776u,  42214569u,2974073100u,\n    3347605521u,  42289222u,2281734146u,1683049841u,1228145186u,3502760977u,2492137608u,2213622508u,\n     272957579u,   8620386u,1543544984u, 311982149u, 148783232u,2244608106u,4294967295u,4294967295u\n);\n\n// extract single byte from four-bytes unsigned int number, index must have values from 0 to 3\nuint GetByteFromUint(uint number, uint index)\n{\n    return (number >> (index << 3u)) & 0xFFu;\n}\n\n// extract single bit from single byte, index must have values from 0 to 7\nuint GetBitFromByte(uint byte, uint index)\n{\n    return ((byte >> index) & 0x01u);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = floor(fragCoord.xy / iResolution.xy * float(_GridSize));\n    uint instance = uint(uv.x) + _GridSize * uint(uv.y);\n    uint number = _Uints[instance / 32u];\n    uint byte = GetByteFromUint(number, (instance / 8u) % 4u);\n    uint bit = GetBitFromByte(byte, instance % 8u);\n    fragColor = (bit == 1u) ? vec4(0.8) : vec4(0.0);\n}", "image_inputs": [], "common_code": "//////////////////////////////////////////////////////////////////////////////////////\n// C# utils to generate uint array from input data\n// See also: https://www.dotnetperls.com/bitarray\n// Set _GridSize in Image (line of code nr 1)\n// Set _Uints array content in Image (from line of code nr 6)\n//////////////////////////////////////////////////////////////////////////////////////\n/*\nbyte[] BitArrayToBytes(BitArray bits)\n{\n    byte[] bytes = new byte[(bits.Length - 1) / 8 + 1];\n    bits.CopyTo(bytes, 0);\n    return bytes;\n}\n\nuint[] BytesToUints(byte[] bytes)\n{\n    uint[] uints = new uint[bytes.Length / 4];\n    System.Buffer.BlockCopy(bytes, 0, uints, 0, bytes.Length);\n    return uints;\n}\n\nstring[] PrintUints (uint[] uints)\n{\n    List<string> lines = new List<string>();\n    string line = \"\";\n    for (int i = 0; i < uints.Length; i++) \n    {\n        line = line + uints[i].ToString() + \"u,\";\n        if ((i+1) % 8 == 0)\n        {\n            lines.Add(line);\n            line = \"\";\n        }\n    }\n    return lines.ToArray();\n}\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1814, 1909, 1956, 1956, 2004], [2006, 2081, 2125, 2125, 2165], [2167, 2167, 2224, 2224, 2564]], "test": "untested"}
{"id": "NdjcWK", "name": "Lvls of Detail", "author": "Dirk", "description": "LOD ~ Levels of detail, prototype on simple terrain with basic lighting and fog.", "tags": ["raymarch", "lod"], "likes": 5, "viewed": 281, "published": 3, "date": "1670866606", "time_retrieved": "2024-07-30T16:13:17.499419", "image_code": "vec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\n\nfloat getNoise( in vec3 pos, float t ){\n\n\n\tvec2 uv = pos.xz*0.2 + iTime*0.05;\n\t\n\tfloat f = 0.0;\n\t\n    uv *= 16.0;\n        \n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\t\n\tif( t<12.0 )\n\t{\n\t\tf *= 0.9000*noise( uv ); uv = m*uv;\n\t}\n    if( t<6.0)\t\n\t{\n\t\tf -= 0.6000*noise( uv ); uv = m*uv;\n\t}\n    if( t<4.0)\t\n\t{\n\t\tf += 0.3000*noise( uv ); uv = m*uv;\n\t}\n    if( t<3.0)\t\n\t{\n\t\tf -= 0.2000*noise( uv ); uv = m*uv;\n\t}\n    if( t<2.5)\t\n\t{\n\t\tf += 0.1000*noise( uv ); uv = m*uv;\n\t}\n    if( t<2.0)\t\n\t{\n\t\tf -= 0.0500*noise( uv ); uv = m*uv;\n\t}\n    if( t<1.5)\t\n\t{\n\t\tf += 0.0100*noise( uv ); uv = m*uv;\n\t\tf -= 0.0050*noise( uv ); uv = m*uv;\n\t}\n    if( t<1.0)\t\n\t{\n\t\tf += 0.0001*noise( uv ); uv = m*uv;\n\t}\n    \n\n\treturn 0.3 + 0.7*f;\n}\n\n\n\n\n\n\nfloat map( in vec3 pos, float t ){\n\n\tvec2 uv = pos.xz*0.2 + iTime*0.05;\n\n    float d = length(pos) - 0.0;\n    \n    float d2 = pos.y+noise(uv)*0.5 - ( -0.25 - 0.03*getNoise(pos,t) );\n\n    return min(d,d2);\n\n}\n\nvec3 calcNormal( in vec3 pos, float t ){\n\n    vec2 e = vec2( 0.001, 0.0 );\n\n    return normalize(vec3(map(pos+e.xyy,t)-map(pos-e.xyy,t),\n                          map(pos+e.yxy,t)-map(pos-e.yxy,t),\n                          map(pos+e.yyx,t)-map(pos-e.yyx,t)));\n\n}\n\nfloat castRay( in vec3 ro, vec3 rd ){\n\n    float t = 0.0;\n\n    for( int i=0; i<60; i++ ){\n        \n        vec3 pos = ro + rd*t;\n        float h = map(pos,t); \n        \n        if(h<0.001)break;\n        t += h;\n        if(t>12.0)break;\n    }\n    if(t>12.0) t=-1.0;\n    \n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y; //center screen\n    \n    float an = 10.0*iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(0.5*sin(an),castRay(vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0))*0.5, 0.5*cos(an)); //Camera Location\n    \n    vec3 ta = vec3(0.0,0.0,0.0);\n    \n    vec3 ww = normalize( ta- ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu,ww) );\n    \n\n    vec3 rd = normalize( p.x*uu + p.y*vv + ww ); //Camera Direction\n    \n    vec3  col = vec3(0.3,0.5,0.8) - 0.7*rd.y;\t\t\t\t//Sky Color\n    col = mix( col,vec3(0.8,0.8,0.7), exp(-10.0*rd.y));\t\t//Sky Color 2 + Gradient Mixture\n    \n    float t = castRay(ro,rd);\n\n    if( t>0.0 ){\n        vec3 pos = ro + rd*t;\n        vec3 nor = calcNormal(pos,t);\n\n        vec3 mate = vec3(0.18);\t\n         \tmate = vec3(0.0,0.5,0.0);\n            float f = 1.0-getNoise(pos,t);\n            mate += vec3(0.2,0.5,0.4)*nor;\n\t\n    \n\tvec2 uv = pos.xz*0.2 + iTime*0.05;\n       \n        vec3 light_dir = normalize( vec3(0.8,0.4,0.1) );\n        float light_dif = clamp( dot(nor,light_dir),0.0,1.0);\n        float light_sha = step( castRay( pos+nor*0.001, light_dir ), 0.0 );\n        \n        if(t<3.0){\n            light_sha = step( castRay( pos+nor*0.001, light_dir ), 0.0 );\n        }else{\n            light_sha = 1.0;\n        }\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.2,1.0,0.2)), 0.0, 1.0);\n        \n        vec3 light_col = vec3( 0.2,0.4,0.3 );\n        vec3 sky_col = vec3(0.0,0.1,0.3);\n        \n        vec3 fog = vec3(0.03,0.1,0.05);\n              \n        \n        col  = mix(light_col*light_dif*light_sha,fog*0.5,t-3.0);\n        col += sky_col*sky_dif;\n        col += mate*vec3(0.0,pos.y*1.2,0.1)*0.1;\n    }\n\n    fragColor = vec4(col,(0.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 77, 131, 611], [613, 613, 639, 639, 1080], [1085, 1085, 1124, 1124, 1799], [1806, 1806, 1840, 1840, 2013], [2015, 2015, 2055, 2055, 2278], [2280, 2280, 2317, 2317, 2566], [2568, 2568, 2625, 2625, 4384]], "test": "untested"}
{"id": "msjXWy", "name": "squares: #2", "author": "jonasfrey", "description": "template", "tags": ["template"], "likes": 1, "viewed": 141, "published": 3, "date": "1670860397", "time_retrieved": "2024-07-30T16:13:18.327206", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( abs(n-1.), n_sharpness))*pow(2., n_sharpness);\n}\nfloat f_n_dist_square(vec2 o){\n    return max(abs(o.x), abs(o.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    vec2 o_scale = vec2(0.001);\n    float n_divisions = 10.;\n    float n_scale = floor(o_trpino_nooffset.x*n_divisions)/n_divisions;\n    //n_scale = n_scale * 0.1;\n    //o_scale = vec2(0.01+n_scale);\n    if(iMouse.z == 0.0){\n        o_trmono_nooffset = vec2(sin(iTime), cos(iTime*0.2)*0.2+0.2);\n    }\n    o_scale= vec2(o_trmono_nooffset.y);\n    if(o_trpino.x > o_trmono.x){\n        o_scale= vec2(0.1);\n    }\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    vec2 o_trpino_nooffset_scaledfloor = (o_fragCoord_scaled_floor.xy)/ o_iResolution_scaled_floor.xy;\n    float n_tau = 6.2831;\n    float n_squares = 44.;\n    float n_dist_min = 1.;\n    float n = 0.;\n    float n_square_nor_clst = 0.;\n    for(float n_square_nor = 0.; n_square_nor<1.; n_square_nor+=1./n_squares){\n        float n_square = n_square_nor*n_squares;\n        vec2 o = vec2(\n            sin(n_tau*n_square_nor+iTime)*0.4,\n            cos(n_tau*n_square_nor+iTime)*0.4\n        );\n        float n_dist_square = f_n_dist_square(\n            o_trpino+o\n        )+0.5;\n        //float n = f_n_inoutexp(n_dist_square+n_square_nor*0.8, 2.);\n        if(n_dist_square < n_dist_min){\n        \n            n_dist_min = n_dist_square;\n            n = f_n_inoutexp(n_dist_min,2.);\n            //n=n*n_square_nor;\n            n_square_nor_clst = n_square_nor;\n\n        }\n        \n    }\n\n    fragColor = vec4(\n        n*n*0.5, \n        1.-n*n*n*10., \n        (sin(n_tau*n_square_nor_clst)*0.5+0.5)*0.1, \n        1.\n    );\n    //fragColor = sqrt(fragColor);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 258], [259, 259, 289, 289, 327], [328, 328, 385, 385, 2634]], "test": "untested"}
{"id": "cdSSWK", "name": "different look on AMD - NVIDIA?", "author": "jonasfrey", "description": "i dont know why but this look different on my nvidia compared to amd gpu", "tags": ["squircle"], "likes": 9, "viewed": 289, "published": 3, "date": "1670858716", "time_retrieved": "2024-07-30T16:13:19.081191", "image_code": "float f_n_inoutexp_bad(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( (n-1.), n_sharpness))*pow(2., abs(n_sharpness));\n}\nfloat f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( abs(n-1.), n_sharpness))*pow(2., abs(n_sharpness));\n}\nfloat f_n_dist_square(vec2 o){\n    return max(abs(o.x), abs(o.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    o_trpino*=1.2;\n    float n_tau = 6.2831;\n    float n_its = 20.;\n    float n_index = floor(o_trpino.x*n_its);\n    float n_index_nor = n_index / n_its;\n    float n_dist_clst = 0.;\n    float n_t = iTime*2.;\n    float n_mixed = 0.;\n    float n_dist = 0.5;\n    float n_col_nor = 0.;\n    for(float n_it = 0.; n_it < n_its; n_it+=1.){\n        float n_it_nor = n_it/ n_its;\n\n        float n_amp = 1./n_its/2.;\n        \n        o_trpino += vec2(\n            //n_it_nor*0.1\n            sin(n_t+n_it_nor*n_tau*n_t)*n_amp, \n            cos(n_t+n_it_nor*n_tau*n_t)*n_amp\n        );\n\n \n        float n = 3.;\n        //n = (sin(n_t+n_it*0.2)*0.5+0.5)*5.+1.;\n        //float n_dist = length(pow(o_trpino,vec2(n))*pow(n, n));\n        n_dist = pow((pow(abs(o_trpino.x), n))+(pow(abs(o_trpino.y), abs(n))), 1./n);\n        n_dist = f_n_dist_square(o_trpino);\n        //n_dist *= 10.-(floor(abs(o_trpino.x)*10.));\n        //n_dist *=(n_it*0.01);\n        n_dist += n_it*(1./n_its/2.);\n        //n_dist = length(o_trpino);\n        if(o_trpino.x>0.){\n            n_dist = f_n_inoutexp_bad(n_dist, 8.);\n        }else{\n            n_dist = f_n_inoutexp(n_dist, 8.);\n        }\n        n_mixed = mix(n_mixed, n_dist, n_dist);\n        if(n_dist > n_dist_clst){\n            n_col_nor = fract((n_it/n_its)+n_t*0.1);\n        }\n        n_dist_clst = max(n_dist_clst, n_dist);\n\n    }\n    \n    fragColor = vec4(\n        n_dist_clst\n    );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSSWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 264], [265, 265, 312, 312, 528], [529, 529, 559, 559, 597], [598, 598, 655, 655, 2265]], "test": "untested"}
{"id": "cs2XWy", "name": "Nest of Polygons II", "author": "mla", "description": "Some nested overlapping pentagons. At each pixel, draw K polygons to handle overlaps.", "tags": ["simple", "sdf", "polygon", "dihedral"], "likes": 26, "viewed": 318, "published": 3, "date": "1670838006", "time_retrieved": "2024-07-30T16:13:19.891025", "image_code": "// Nest of Polygons II, mla, 2022\n\nfloat N = 5.0;  // Number of sides\nfloat M = 12.0; // Radial density.\nfloat K = 4.0;  // Number of polygons to draw\n\nconst float PI = 3.141592654;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Signed distance from p segment qr. Positive distance for\n// points on the left of the line looking from q to r.\nfloat ssegment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  k = clamp(k,0.0,1.0);\n  vec2 closestpoint = k*r;\n  float dist = distance(p,closestpoint);\n  vec2 normal = vec2(-r.y,r.x);\n  float s = dot(p,normal) >= 0.0 ? 1.0 : -1.0; // Don't want sign() here (since sign(0) == 0)\n  return s*dist;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nfloat polydist(float N, vec2 p, float r) {\n    float phi = PI/N; // angle of half sector\n    float theta = atan(p.x,-p.y);// negative y-axis is theta = 0\n    theta = mod(theta+phi,2.0*phi)-phi;\n    //theta /= 2.0*phi; theta -= round(theta); theta *= 2.0*phi; // Equivalent\n    theta = abs(theta); // Mirror symmetry\n    // With dihedral symmetry, the closest point is always in the\n    // fundamental region, so can limit attention just to there\n    // for finding the SDF.\n    vec2 p1 = length(p)*vec2(cos(theta),sin(theta));\n    vec2 q0 = r*vec2(cos(phi),sin(phi)), q1 = r*vec2(cos(phi),0);\n    return ssegment(p1,q0,q1);\n}\n\nfloat poly(float k, vec2 p) {\n    float k0 = k;\n    k /= M;\n    k += 0.25*iTime;\n    k = exp(k);\n    //p = rotate(p,0.5*iTime*sin(0.05*k0-0.1*sin(0.01*iTime)));\n    //p = rotate(p,0.5*sin(3.0*iTime+0.1*k0));\n    p = rotate(p,0.5*iTime*sin(0.05*k0));\n    float d = polydist(N,p,k);\n    return d;\n}\n\nvec3 getcol(float k) {\n  return 0.2+0.8*h2rgb(0.5*fract(100.0*sin(10.0*k)));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 2.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = fwidth(p.x);\n    float lwidth = 0.002;\n    float k = length(p)-px-lwidth;\n    k = log(k);\n    k -= 0.25*iTime;\n    k *= M;\n    k = ceil(k);\n\n    float d = 1e8;\n    vec3 col = getcol(k+K);\n    for (float i = K-1.0; i >= 0.0; i--) {\n      float d0 = poly(k+i,p);\n      if (d0 < 0.0) { \n        d = -d0; \n        col = mix(col,getcol(k+i),smoothstep(-px,px,d)); \n      } else if (d0 < d) {\n        d = d0;\n        // mix(a,b,x) = (1-x)a+xb = a+x(b-a) = a-x(a-b)\n        col *= 1.0-0.5*(1.0-smoothstep(-8.0*px, 8.0*px, abs(d) - lwidth)); // Shane's shading\n      }\n    }\n    col *= smoothstep(-px,px,abs(d)-lwidth);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2XWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 214, 244, 244, 289], [291, 406, 446, 446, 732], [734, 734, 755, 755, 888], [890, 890, 932, 932, 1515], [1517, 1517, 1546, 1546, 1813], [1815, 1815, 1837, 1837, 1893], [1895, 1895, 1947, 1947, 2703]], "test": "untested"}
{"id": "ds2SRw", "name": "Codevember #30 The End", "author": "Etidou", "description": "Day 30 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["3d", "raymarching", "sdf", "polygon", "codevember"], "likes": 3, "viewed": 214, "published": 3, "date": "1670830589", "time_retrieved": "2024-07-30T16:13:20.731777", "image_code": "//Inspiration : https://www.shadertoy.com/view/4dXGRM\n\n#define FOV_MORPH 1\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 rot(vec3 p, float f) {\n\tfloat s = sin(f);\n\tfloat c = cos(f);\n\tp.xy *= mat2(c, -s, s, c);\n\tp.yz *= mat2(c, -s, s, c);\n\treturn p;\n}\n\n\nvec3 trans(vec3 p, out float rotout) {\n\tp.zx += iTime*2.0;\n\n\tvec3 b = vec3(4.);\n\tvec3 rep = floor(p/b);\n\n\tp = mod(p,b)-.5*b;\n\t\n\trotout = iTime*1.88 + (rep.x+rep.z+rep.y)*.3;\n\tp = rot(p, rotout);\n\treturn p;\t\n}\n\nfloat scene(vec3 p) {\n\tfloat dummy;\n\treturn sdOctahedron(trans(p,dummy), 0.75);\n}\n\n\nvec3 normal(vec3 p, float d) {\n\tvec3 e = vec3(0.04,.0,.0);\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-d,\n\t\tscene(p+e.yxy)-d,\n\t\tscene(p+e.yyx)-d));\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n\txy.y *= -iResolution.y / iResolution.x;\n\n\tfloat time = iTime*0.5;\n\tvec3 ro = 1.5*normalize(vec3(cos(time),cos(time)*1.2,sin(time)));\n    vec3 eyed = normalize(vec3(0.6667, 0.0549, 0.0549) - ro);\n    vec3 ud = normalize(cross(vec3(0.0,1.0,0.0), eyed));\n    vec3 vd = normalize(cross(eyed,ud));\n\n#if FOV_MORPH\n\tfloat fov = 3.14 * 0.8 + sin(time*1.334)*1.45;\n#else\n\tfloat fov = 3.14 * 0.7;\n#endif\n\t\n\tfloat f = fov * length(xy);\n\tvec3 rd = normalize(normalize(xy.x*ud + xy.y*vd) + (1.0/tan(f))*eyed);\n\n\n\tvec3 p = ro + rd;\n\n\tfloat dall,d;\n\tfor(int i = 0; i < 64; i++) {\n\t\td = scene(p);\n\t\tif(d < 0.06) break;\n\t\tp += d*rd;\n\t\tdall += d;\n\t}\n\n\tvec3 bg = normalize(p).zzz + .1;\n\n\tif(d < 0.06) {\n\t\tvec3 n = normal(p,d); \n\t\tvec3 col = vec3(dot(vec3(0.0,0.0,1.0), n));\n\t\tfloat objrot;\n\t\tvec3 objp = trans(p,objrot);\n\t\tvec3 objn = abs(rot(n,objrot));\n\t\t\n\t\tvec2 uv = \n\t\t\t(objn.y > 0.707) ? vec2(objp.zx) : \n\t\t\t(objn.x > 0.707) ? vec2(objp.zy) :\n\t\t\t\t\t\t\t   vec2(objp.xy) ;\n\t\tvec3 hl = smoothstep(0.2, 1.0, col);\n\n\t\tcol = col + hl*.4;\n\t\tfloat fog = clamp(dall/mix(90.0,40.0,((rd.z+1.0)*0.5)), 0.0, 1.0);\n\n\t\tfragColor = vec4(mix(abs(n + 0.2).xyz, bg, fog),1.0);\n\t}\n\telse {\n\t\tfragColor = vec4(bg, 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2SRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 114, 114, 167], [169, 169, 196, 196, 303], [306, 306, 344, 344, 514], [516, 516, 537, 537, 597], [600, 600, 630, 630, 748], [750, 750, 807, 807, 2053]], "test": "untested"}
{"id": "dd2SRw", "name": "Codevember #29 Texture 3", "author": "Etidou", "description": "Day 29 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["displacement", "texture", "codevember"], "likes": 6, "viewed": 271, "published": 3, "date": "1670830586", "time_retrieved": "2024-07-30T16:13:21.590481", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(1.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  float time = iTime * 0.05;\n  float progressHover = 1.;\n  vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n  float offX = uv.x * 0.5 - time * .15;\n  float offY = uv.y + sin(uv.x * 1.) * .1 - sin(time * 0.25) + snoise(vec3(uv.x, uv.y, time) * .5);\n  offX += snoise(vec3(offX, offY, time) * 5.) * .3;\n  offY += snoise(vec3(offX, offX, time * 0.3)) * .1;\n  float nc = (snoise(vec3(offX, offY, time * .75) * 2.)) * progressHover;\n  float nh = (snoise(vec3(offX, offY, time * .25) * 2.)) * .3;\n\n  nh *= smoothstep(nh, 2.5, 3.0);\n\n\n  vec4 image = texture(iChannel0, uv + vec2(nc + nh) * 1.);\n  vec4 hover = texture(iChannel0, uv + vec2(nc + nh) * 1. * 1.);\n\n  vec4 finalImage = mix(image, hover, clamp(nh * 10. + 1., 0., 1.));\n\n  fragColor = vec4(finalImage.rgb, 1.);\n\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2SRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 93, 93, 142], [144, 144, 166, 166, 206], [208, 208, 236, 236, 288], [290, 290, 314, 314, 1978], [1980, 1980, 2037, 2037, 2827]], "test": "untested"}
{"id": "dsjSRw", "name": "Codevember #28 Texture 2", "author": "Etidou", "description": "Day 28 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["fractal", "texture", "codevember"], "likes": 5, "viewed": 254, "published": 3, "date": "1670830582", "time_retrieved": "2024-07-30T16:13:22.415276", "image_code": "#define NUM_OCTAVES 5\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.75;\n\tvec2 shift = vec2(1000000);\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    float strength = 4.5;\n\n    vec2 surface = strength * vec2(mix(-0.1, 0.1, fbm(4.0 * uv + (0.5 * iTime))));\n\n    uv += refract(vec2(0.0), surface, 1.0 / 1.333);\n\n    vec4 color = texture(iChannel0, uv);\n   \n    fragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 43, 43, 110], [112, 112, 132, 132, 341], [343, 343, 362, 362, 638], [641, 641, 698, 698, 1008]], "test": "untested"}
{"id": "mdjSRw", "name": "Codevember #27 Texture 1", "author": "Etidou", "description": "Day 27 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["fractal", "texture", "codevember"], "likes": 4, "viewed": 257, "published": 3, "date": "1670830579", "time_retrieved": "2024-07-30T16:13:23.358753", "image_code": "#define NUM_OCTAVES 5\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    vec2 surface = vec2(fbm(5.0 * uv + 0.2 *iTime));\n\n    uv += refract(vec2(0.0), surface, 1.0 / 1.333);\n\n    vec4 color = texture(iChannel0, uv);\n   \n    fragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 43, 43, 110], [112, 112, 132, 132, 341], [343, 343, 362, 362, 601], [604, 604, 661, 661, 914]], "test": "untested"}
{"id": "ddjSRw", "name": "Codevember #26 Random Spiral 6", "author": "Etidou", "description": "Day 26 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["spiral", "random", "codevember"], "likes": 2, "viewed": 116, "published": 3, "date": "1670830575", "time_retrieved": "2024-07-30T16:13:24.181553", "image_code": "float SEGMENT_TIME = 4.0;\n\nconst float PI = 3.1415926535;\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nfloat segmentAngle;\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(.3+a/v)*v-a)*r;\n    return final;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    vec2 rot = rotate(uv, PI + (iTime * 0.075));\n    uv = rot;    \n    \n    float radius = length(uv -0.5);\n\n    float poly = polySDFScale(\n        uv,\n        vec2(2.7),\n        3\n    ); \n\n    float segmentAngle = ((PI + 40.0) / SEGMENT_TIME);\n\n    poly *= segmentAngle + floor((cos(iTime) + poly) - segmentAngle);\n\n    poly = min(-poly, segmentAngle * poly);\n\n    vec2 st = vec2(sin((cos(-poly / -iTime), sin(poly * -iTime)) + radius * segmentAngle))  ;\n\n    st = max(min(st, 3.0 * st), st);\n\n    vec3 color = vec3(0.0, cos(sin(-iTime) / -st));\n\n    float len = length(uv - 0.5);\n\n    color.r += sin(len * 40.0 + poly * 4.0 * -sin((iTime / 10.0)));\n    color.g = cos(len * 30.0 + poly * 6.0 * -sin((iTime / 10.0)));\n    color.b *= sin(len * 50.0 + poly * 5.0 * - 0.5);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 190, 190, 361], [363, 363, 394, 394, 482], [484, 484, 541, 541, 1425]], "test": "untested"}
{"id": "DdjSDG", "name": "Antialiased Colored Mandelbrot", "author": "dankcatlord", "description": "I made an algorithm to anti-alias the mandelbrot set.", "tags": ["fractal", "mandelbrot", "antialiasing"], "likes": 2, "viewed": 275, "published": 3, "date": "1670818545", "time_retrieved": "2024-07-30T16:13:24.943516", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 a = texture(iChannel0, uv).rgb;\n    vec3 b = iTime + uv.xyx + vec3(0.0, 2.0, 4.0);\n\n    vec3 col = sqrt((a.x * cos(b) + a.y * sin(b) - a.z) * 0.5 + 0.5);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "precision highp float;\nprecision highp int;\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nvec2 noise(uvec2 p) {\n    float U = uintBitsToFloat(\n        hash(0x717bc129u ^ hash(uint(iFrame) ^ hash(p.x ^ hash(p.y)))) & 0x007fffffu | 0x3f800000u\n    ) - 1.5;\n    float V = uintBitsToFloat(\n        hash(0xf00d5a7cu ^ hash(uint(iFrame) ^ hash(p.x ^ hash(p.y)))) & 0x007fffffu | 0x3f800000u\n    ) - 1.5;\n    return vec2(U,V);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 info = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    float frame = info.w;\n    if (info.xy != iResolution.xy) frame = float(iFrame - 1);\n    if (fragCoord == vec2(0.5)) {\n        fragColor.xy = iResolution.xy;\n        fragColor.z = 0.0;\n        fragColor.w = frame;\n        return;\n    }\n    vec2 uv = ((vec2(fragCoord.x, fragCoord.y - 0.5) + noise(uvec2(fragCoord))) * 2.0 - iResolution.xy) *\n        max(1.35 / iResolution.x, 1.15 / iResolution.y);\n    uv.x -= 0.75;\n    \n    vec2 z = uv;\n    vec2 z2 = z * z;\n    vec2 c = uv;\n    \n    int i;\n    for (i = 0; i < 1024; i++) {\n        if ((z2.x + z2.y) > 256.0) break;\n        z.y = (z.x + z.x) * z.y + c.y;\n        z.x = z2.x - z2.y + c.x;\n        z2 = z * z;\n    }\n    float iter = sqrt(float(i) - log2(log2(z2.x + z2.y)) + 4.0);\n    \n    fragColor = vec4(mix(\n        texture(iChannel0, fragCoord / iResolution.xy).rgb,\n        i == 1024 ? vec3(0.0, 0.0, 1.0) : vec3(cos(iter), sin(iter), 0.0),\n        1.0 / (float(iFrame) - frame)\n    ),0.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 297]], "test": "untested"}
{"id": "dsjSR1", "name": "extruded caspar-klug theory", "author": "remaindeer", "description": "- tetrahedron version\n- calculations: https://www.geogebra.org/3d/he2gnb8p\n- ray marching boilerplate: https://inspirnathan.com/posts/60-shadertoy-tutorial-part-14/\n- thanks @mla for useful comments\n- is there a simpler way to arrange triangles?", "tags": ["raymarch", "tetrahedron", "construction", "schwarz", "wythoff", "casparklug"], "likes": 19, "viewed": 327, "published": 3, "date": "1670813196", "time_retrieved": "2024-07-30T16:13:25.967777", "image_code": "float scene(vec3 p) {\n    // dynamic scene parameters\n    //// Caspar-Klug\n    float h = mod(round((iTime + 3.0 / 2.0) / 2.0), 3.0) + 1.0;\n    float k = mod(round((iTime + 6.0 + 3.0 / 2.0) / 3.0), 3.0);\n    //// Wythoff\n    ////// pick point within fundamental triangle\n    ////// https://mathworld.wolfram.com/TrianglePointPicking.html\n    ////// http://extremelearning.com.au/evenly-distributing-points-in-a-triangle/\n    float a1 = 0.5 + sin(0.25 * iTime / 1.5) / 2.0;\n    float a2 = 0.5 + cos(2.00 * iTime / 1.5) / 2.0;\n    ////// generator point\n    vec2 g = (((a1 + a2) < 1.0) ? (a1 * v3 + a2 * v2) : ((1.0 - a1) * v3 + (1.0 - a2) * v2));\n    ////// mirrors\n    float m = mod(round((iTime - 2.0 / 1.5) / 2.0), 10.0);\n    ////// walls\n    float w = 0.0;\n    \n    float t = 0.0025;\n    float s = distance(TET_V[0], TET_V[1]) / length(mat2(1.5, cos30, 0.0, 2.0 * cos30) * vec2(h, k));    \n        \n    // distance\n    vec3 c1 = (TET_V[0].xyz + TET_V[1].xyz + TET_V[2].xyz) / 3.0;\n    vec3 c2 = (TET_V[1].xyz + TET_V[4].xyz + TET_V[2].xyz) / 3.0;\n    vec3 c3 = (TET_V[0].xyz + TET_V[2].xyz + TET_V[4].xyz) / 3.0;\n    vec3 c4 = (TET_V[0].xyz + TET_V[4].xyz + TET_V[1].xyz) / 3.0;\n    p = rotmat3(vec3(iTime * 0.25)) * p;\n    vec4 q = M1 * vec4(p - c1, 1);\n    float d = opExtrusion(q.z, sdCasparKlugFacet(q.xy / s, h, k, g, m, w, t) * s, t);\n    q = M2 * vec4(p - c2, 1);\n    d = min(\n        d,\n        opExtrusion(q.z, sdCasparKlugFacet(q.xy / s, h, k, g, m, w, t) * s, t)\n    );\n    q = M3 * vec4(p - c3, 1);\n    d = min(\n        d,\n        opExtrusion(q.z, sdCasparKlugFacet(q.xy / s, h, k, g, m, w, t) * s, t)\n    );\n    q = M4 * vec4(p - c4, 1);\n    d = min(\n        d,\n        opExtrusion(q.z, sdCasparKlugFacet(q.xy / s, h, k, g, m, w, t) * s, t)\n    );\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d;\n\n  for (int i = 0; i < MAX_ITER; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n\n    if (m == vec2(0.0)) m = vec2(0.5);\n\n    vec3 col = vec3(0);\n    vec3 lp = vec3(0);\n    vec3 ro = vec3(0, 0, 1);\n\n    float camRadius = 1.0;\n    ro.yz = ro.yz * camRadius * rotmat2(mix(-PI/2., PI/2., m.y));\n    ro.xz = ro.xz * rotmat2(mix(-PI, PI, m.x)) + vec2(lp.x, lp.z);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(p, -1));\n\n    float d = march(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = COLOR_BACKGROUND;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 norm = normal(p);\n\n        vec3 lightPos = vec3(0, 2, 2);\n        vec3 lightDir = normalize(lightPos - p) * 0.65;\n\n        float diff = clamp(dot(norm, lightDir), 0.0, 1.0) * 0.5 + 0.5;\n\n        vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n        col = vec3(diff) + rnd;    \n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "// math\n//// constants\n#define PI 3.14159265359\n#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n//// schwarz triangle\n#define v1 vec2(0, 0)\n#define v2 vec2(0, cos30)\n#define v3 vec2(0.5, cos30)\n\n// ray marching\n#define MAX_ITER 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define EPSILON 0.0005\n#define COLOR_BACKGROUND vec3(0, 0, 0)\n#define COLOR_AMBIENT vec3(0.42, 0.20, 0.1);\n\n//// tetrahedron\n////// radius\n#define TET_R 0.25\n////// vertexes\n#define TET_V vec4[] (               \\\n    vec4(+TET_R, +TET_R, +TET_R, 1), \\\n    vec4(-TET_R, +TET_R, -TET_R, 1), \\\n    vec4(+TET_R, -TET_R, -TET_R, 1), \\\n    vec4(-TET_R, +TET_R, -TET_R, 1), \\\n    vec4(-TET_R, -TET_R, +TET_R, 1), \\\n    vec4(+TET_R, -TET_R, -TET_R, 1)  \\\n)                                    \\\n////// faces\n#define TET_F vec3[] ( \\\n    vec3(0, 1, 2),     \\\n    vec3(1, 4, 2),     \\\n    vec3(0, 2, 4),     \\\n    vec3(0, 4, 1)      \\\n)                    \n////// transformation matrices\n/*\nM' = {{0.7071, 0.4082, 0.5774, 0.0833}, {-0.7071, 0.4082, 0.5774, 0.0833}, {0, 0.8165, -0.5774, -0.0833}, {0, 0, 0, 1}}\nM' = {{0.7071, -0.4082, -0.5774, -0.0833}, {0, 0.8165, -0.5774, -0.0833}, {-0.7071, -0.4082, -0.5774, -0.0833}, {0, 0, 0, 1}}\nM' = {{-0.7071, 0.4082, -0.5774, 0.0833}, {0, 0.8165, 0.5774, -0.0833}, {0.7071, 0.4082, -0.5774, 0.0833}, {0, 0, 0, 1}}\nM' = {{0, 0.8165, 0.5774, -0.0833}, {0.7071, 0.4082, -0.5774, 0.0833}, {-0.7071, 0.4082, -0.5774, 0.0833}, {0, 0, 0, 1}}\n*/\nconst mat4 M1 = mat4(0.7071, 0.4082, 0.5774, 0.0833, -0.7071, 0.4082, 0.5774, 0.0833, 0, 0.8165, -0.5774, -0.0833, 0, 0, 0, 1);\nconst mat4 M2 = mat4(0.7071, -0.4082, -0.5774, -0.0833, 0, 0.8165, -0.5774, -0.0833, -0.7071, -0.4082, -0.5774, -0.0833, 0, 0, 0, 1);\nconst mat4 M3 = mat4(-0.7071, 0.4082, -0.5774, 0.0833, 0, 0.8165, 0.5774, -0.0833, 0.7071, 0.4082, -0.5774, 0.0833, 0, 0, 0, 1);\nconst mat4 M4 = mat4(0, 0.8165, 0.5774, -0.0833, 0.7071, 0.4082, -0.5774, 0.0833, -0.7071, 0.4082, -0.5774, 0.0833, 0, 0, 0, 1);\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotmat3(vec3 angle) {\n    float sintht = sin(angle.x), sinpsi = sin(angle.y), sinphi = sin(angle.z);\n    float costht = cos(angle.x), cospsi = cos(angle.y), cosphi = cos(angle.z);\n    return mat3(\n        costht * cospsi, sintht * cospsi, -sinpsi, \n        costht * sinpsi * sinphi - sintht * cosphi, sintht * sinpsi * sinphi + costht * cosphi, cospsi * sinphi,\n        costht * sinpsi * cosphi + sintht * sinphi, sintht * sinpsi * cosphi - costht * sinphi, cospsi * cosphi\n    );\n}\n\nvec2 intersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    // http://paulbourke.net/geometry/pointlineplane/\n    float d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;\n    // float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;\n    return p1 + ua * (p2 - p1);\n}\n\nfloat opIntersection( float d1, float d2 ) { \n    // https://iquilezles.org/articles/distfunctions2d/\n    return max(d1, d2); \n}\n\nfloat opUnion(float d1, float d2) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return min(d1, d2); \n}\n\nfloat opOnion(in float sdf, in float thickness) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return abs(sdf) - thickness;\n}\n\nvec2 opRep(in vec2 p, in vec2 c) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat opExtrusion(in float p, in float d, in float h)\n{\n    // modified: https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2(d, abs(p) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 t0 = p  - p0, t1 = p  - p1, t2 = p  - p2;\n    vec2 pq0 = t0 - e0 * clamp(dot(t0, e0)/ dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = t1 - e1 * clamp(dot(t1, e1)/ dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = t2 - e2 * clamp(dot(t2, e2)/ dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x );\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (t0.x * e0.y - t0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (t1.x * e1.y - t1.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (t2.x * e2.y - t2.y * e2.x)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sdEquilateralTriangle(in vec2 p, in float r) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    // r is half of the side\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0 * r, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nvec2 snub632() {\n    // fermat point\n    vec2 pf = intersection(vec2(-0.75, cos30 / 2.0), v3, vec2(1, 0), v2);\n    // reflect over side (y-axis)\n    vec2 q1 = vec2(-1.0 * pf.x, pf.y);\n    // vec2 q2 = vec2(pf.x, pf.y + 2.0 * (cos30 - pf.y));\n    // project to hypotenuse then double to obtain reflection\n    vec2 q3 = dot(pf, v3) / dot(v3, v3) * v3;\n    q3 = pf + 2.0 * (q3 - pf);\n    // snub point is at half the hypotenuse of the new right triangle (Thales's theorem)\n    return q1 + ((q3 - q1) / 2.0);\n}\n\nfloat sdSchwartz632Snub(vec2 p, float t) {\n    // p the uv\n    // t the thickness\n    // take advantage of symmetry\n    float a = atan(p.y, p.x);\n    float M = floor(mod(degrees(a) - 30.0, 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // central point\n    float d = sdCircle(p, t);\n    // snub point\n    vec2 g = snub632();\n    // rotate\n    vec2 G = rotmat2(radians(180.0)) * (g - v2) + v2;\n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdSegment(p, g, G) - t);\n    // fix by https://www.shadertoy.com/user/mla\n    d = opUnion(d, sdSegment(rotmat2(radians(-60.0)) * p, g, G) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(-60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+120.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+180.0)) * (G - g) + g) - t);\n    return d;\n}\n\nfloat sdSchwartz632DualSnub(vec2 p, float t) {\n    // p the uv\n    // t the thickness\n    // snub point\n    vec2 g = snub632();\n    // take advantage of symmetry\n    float a = atan(p.y, p.x) - (atan(g.y, g.x) - radians(60.0));\n    float M = floor(mod(degrees(a), 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // central point\n    float d = sdCircle(p, t);\n    float R3 = sqrt3 / 2.0 * length(g);\n    float r3 = sqrt3 / 6.0 * length(g); \n    vec2 n0 = normalize(rotmat2(radians(+30.0)) * g);\n    vec2 n1 = (R3 + r3) * n0;\n    vec2 n2 = n1 + rotmat2(radians(-60.0)) * (2.0 * r3 * n0);\n    vec2 n3 = n1 + rotmat2(radians(+60.0)) * (2.0 * r3 * n0);\n    d = opUnion(d, sdSegment(p, v1, n1) - t);\n    d = opUnion(d, sdSegment(p, n1, n2) - t);\n    d = opUnion(d, sdSegment(p, n1, n3) - t);\n    d = opUnion(d, sdSegment(p, n2, n1 + n2 + -n3) - t);\n    d = opUnion(d, sdSegment(p, n3, n1 + n3 + -n2) - t);\n    return d;\n}\n\nfloat sdSchwartz632(vec2 p, vec2 g, float m, float w, float t) {\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // w the wall toggle\n    // t the thickness\n    // snub case\n    if (m == 8.0) {\n        return sdSchwartz632Snub(p, t);\n    }\n    // snub case\n    else if (m == 9.0) {\n        return sdSchwartz632DualSnub(p, t);\n    }\n    p = abs(p);\n    if (p.y < 2.0 * cos30 * p.x) {\n        p = rotmat2(radians(-60.0)) * p;\n        p = abs(p);\n    }\n    float d = sdCircle(p, t); \n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdCircle(p - g, t));\n    d = bool(mod(m, 2.0)) ? opUnion(d, sdSegment(p, g, vec2(0, g.y)) - t) : d;\n    vec2 v = v3 - v1;\n    d = bool(mod(floor(m / 2.0), 2.0)) ? opUnion(d, sdSegment(p, g, dot(g, v) / dot(v, v) * v) - t) : d;\n    d = bool(mod(floor(m / 4.0), 2.0)) ? opUnion(d, sdSegment(p, g, vec2(g.x, v2.y)) - t) : d;\n    d = bool(mod(w, 2.0)) ? opUnion(d, sdSegment(p, v1, v2) - t) : d;\n    d = bool(mod(floor(w / 2.0), 2.0)) ? opUnion(d, sdSegment(p, v1, v3) - t) : d;\n    d = bool(mod(floor(w / 4.0), 2.0)) ? opUnion(d, sdSegment(p, v2, v3) - t) : d;\n    return d;\n}\n\nfloat sdSchwartz632Plane(vec2 p, vec2 g, float m, float w, float t) {\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // w the wall toggle\n    // t the thickness\n    vec2 v = vec2(3.0, 2.0 * cos30);\n    vec2 p1 = opRep(p, v);\n    vec2 p2 = opRep(p + v / 2.0, v);\n    return opUnion(\n        sdSchwartz632(p1, g, m, w, t),\n        sdSchwartz632(p2, g, m, w, t)\n    );\n}\n\nfloat sdCasparKlugFacet(vec2 p, float h, float k, vec2 g, float m, float w, float t) {\n    // @p vec2 the uv\n    // @h float the h-parameter (steps on plane)\n    // @k float the k-parameter (steps on plane after 60-degree turn)\n    // @g vec2 the generator point for Wythoff construction\n    // @m float the bits representing the activated mirrors for Wythoff construction\n    // @w float the bits representing the fundamental triangle wall display\n    // @t float the edge thickness\n    mat2 b = mat2(1.5, cos30, 0.0, 2.0 * cos30);\n    // vec2 t1 = vec2(0);\n    vec2 t2 = b * vec2(h, k);\n    vec2 t3 = rotmat2(radians(-60.0)) * t2;\n    \n    float s = length(t2); // side\n    // vec2 c = (t1 + t2 + t3) / 3.0; // centroid\n    vec2 c = (t2 + t3) / 3.0; // centroid\n    \n    float d = sdSchwartz632Plane((rotmat2(-atan(t2.y, t2.x)) * p) + c, g, m, w, t);\n    // d = opUnion(d, opOnion(sdCircle(p, 1.5 * t), t)); \n    // d = opUnion(d, opOnion(sdEquilateralTriangle(p, s / 2.0), t));\n    d = opIntersection(d, sdEquilateralTriangle(p, s / 2.0));\n\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjSR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 74, 1783], [1785, 1785, 1816, 1816, 2044], [2046, 2046, 2070, 2070, 2262], [2264, 2264, 2311, 2311, 2473], [2475, 2475, 2530, 2530, 3443]], "test": "untested"}
{"id": "dsSSDy", "name": "squircles 2", "author": "jonasfrey", "description": "squircle\n", "tags": ["squircle"], "likes": 7, "viewed": 202, "published": 3, "date": "1670802731", "time_retrieved": "2024-07-30T16:13:27.415906", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( abs(n-1.), n_sharpness))*pow(2., n_sharpness);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    o_trpino*=1.2;\n    float n_tau = 6.2831;\n    float n_angle = n_tau / 3.;\n    float n_squircles = 20.;\n    float n_index = floor(o_trpino.x*n_squircles);\n    float n_index_nor = n_index / n_squircles;\n    float n_dist_clst = 0.;\n    float n_t = iTime*2.;\n    float n_mixed = 0.;\n    float n_dist = 0.5;\n    float n_col_nor = 0.;\n    for(float n_squircle = 0.; n_squircle < n_squircles; n_squircle+=1.){\n        float n_squircle_nor = n_squircle/ n_squircles;\n        n_angle = 0.;//-n_squircle_nor;\n        float n_amp = 1./n_squircles/2.;\n        \n        o_trpino += vec2(\n            //n_squircle_nor*0.1\n            sin(n_t+n_squircle_nor*n_tau*n_t)*n_amp, \n            cos(n_t+n_squircle_nor*n_tau*n_t)*n_amp\n        );\n        o_trpino = vec2(\n            cos(n_angle)*o_trpino.x-sin(n_angle)*o_trpino.y,\n            sin(n_angle)*o_trpino.x+cos(n_angle)*o_trpino.y\n        );\n \n        //float n = floor((sin(iTime)*0.5+0.5)*5.+3.);\n        //float n = 2. + floor(fract(iTime*.5)*3.);\n        float n = 3.;\n        //n = (sin(n_t+n_squircle*0.2)*0.5+0.5)*5.+1.;\n        //float n_dist = length(pow(o_trpino,vec2(n))*pow(n, n));\n        n_dist = pow((pow(abs(o_trpino.x), n))+(pow(abs(o_trpino.y), n)), 1./n);\n        //n_dist *= 10.-(floor(abs(o_trpino.x)*10.));\n        //n_dist *=(n_squircle*0.01);\n        n_dist += n_squircle*(1./n_squircles/2.);\n        //n_dist = length(o_trpino);\n        n_dist = f_n_inoutexp(n_dist, 8.);\n        n_mixed = mix(n_mixed, n_dist, n_dist);\n        if(n_dist > n_dist_clst){\n            n_col_nor = fract((n_squircle/n_squircles)+n_t*0.1);\n        }\n        n_dist_clst = max(n_dist_clst, n_dist);\n\n    }\n    \n    fragColor = vec4(\n        sqrt(n_mixed*n_mixed),\n        n_dist_clst, \n        n_col_nor*n_mixed,\n        1.\n    );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsSSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 258], [259, 259, 316, 316, 2296]], "test": "untested"}
{"id": "ddBXWy", "name": "squircle ?", "author": "jonasfrey", "description": "squircle\n", "tags": ["squircle"], "likes": 3, "viewed": 150, "published": 3, "date": "1670800054", "time_retrieved": "2024-07-30T16:13:28.230728", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( n-1., n_sharpness))*pow(2., n_sharpness);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    //float n = floor((sin(iTime)*0.5+0.5)*5.+3.);\n    //float n = 2. + floor(fract(iTime*.5)*3.);\n    float n = (sin(iTime)*0.5+0.5)*6.;\n    //float n_dist = length(pow(o_trpino,vec2(n))*pow(n, n));\n    float n_dist = pow((pow(abs(o_trpino.x), n))+(pow(abs(o_trpino.y), n)), 1./n);\n    //n_dist *= 10.-(floor(abs(o_trpino.x)*10.));\n    n_dist *=2.;\n    //n_dist = length(o_trpino);\n    n_dist = f_n_inoutexp(n_dist, 2.);\n    fragColor = vec4(n_dist);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 253], [254, 254, 311, 311, 966]], "test": "untested"}
{"id": "ddSXDG", "name": "last frame rkernel: snowflake", "author": "jonasfrey", "description": "trying to reproduce a snowflake with a kernel \ni think i never will find it ...", "tags": ["kernel"], "likes": 2, "viewed": 188, "published": 3, "date": "1670795353", "time_retrieved": "2024-07-30T16:13:28.988700", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat n_tau = 6.283185;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat f_n_dist_hexagon(vec2 a, vec2 b){\n    const float TAU = 6.283185;\n    float deg30 = TAU/12.0;\n\tvec2 p = abs(b-a);\n\tfloat s = sin(deg30);\n\tfloat c = cos(deg30);\n\t\n\tfloat diagDist = s*p.x + c*p.y;\n\treturn max(diagDist, p.x)/c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    \n    \n    vec2 o_p_mouse_data = vec2(0.0, 0.0);\n    vec2 o_trmono_delta = vec2(0.);\n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(o_trmono, 0.0, 0.0);\n    }else{\n        vec4 o_trmono_last = texture(iChannel0, o_p_mouse_data);\n        o_trmono_delta = abs(o_trmono.xy - o_trmono_last.xy);\n    }\n    \n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        o_trmono_delta = vec2(0.1);\n        o_trmono = vec2(\n            sin(iTime)*0.8,\n            cos(iTime)*0.3\n        );\n    }\n    vec2 o_scale = vec2(0.9);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_radius_rkernel = vec2(\n        12.,\n        12.\n    );\n    \n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n\n    vec4 o_kernel_sum = vec4(0.0);\n\n    \n    int n_index_a_o_col_last_krnl = 0;\n    float n_kernel_sum_count = 0.;\n    for(float n_x = 0.0; n_x < floor(o_radius_rkernel.x/2.); n_x+=1.){\n        float n_radius = n_x;\n\n        float n_angle_step_x = n_tau / (n_tau * n_x);\n        //float n_angle_steps_y = n_tau * o_radius_rkernel.y;\n        \n        for(float n_angle = 0.0; n_angle < n_tau; n_angle+=n_angle_step_x){\n            vec2 o_p_on_kernel = vec2(\n                sin(n_angle)*n_radius,\n                cos(n_angle)*n_radius\n            );\n            vec2 o_off = vec2(\n                o_p_on_kernel.x * (1./o_iResolution_scaled_floor.x),\n                o_p_on_kernel.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            float n_dist_hex = f_n_dist_hexagon(\n                o_p_on_kernel,\n                vec2(0.0)\n            );\n            if(n_dist_hex < ((o_radius_rkernel.x/2.)*0.81)\n            ){\n                o_kernel_sum += o_col_last_on_kernel;\n                n_kernel_sum_count+=1.;            \n            }\n\n        }\n    }\n  \n    vec4 o_kernel_sum_nor = o_kernel_sum / n_kernel_sum_count;\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n            float n_start = 0.21;\n            float n_size = 0.7;\n            float n_end = n_start+n_size;\n            float n_between = n_start + n_size*0.9;\n            if(o_kernel_sum_nor.x>n_start){\n                fragColor = vec4(0.);\n            }\n            if(o_kernel_sum_nor.x>n_between){\n                fragColor = vec4(o_kernel_sum_nor.x);\n            }\n            if(o_kernel_sum_nor.x>n_end){\n                fragColor = vec4(0.9);\n            }\n            \n            vec4 o_col_delta = o_col_last - fragColor;\n            fragColor = (o_col_last) - (o_col_delta*0.29);\n                       \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_thresh = 0.1+o_trmono_delta.x;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    //n_dist = f_n_dist_hexagon(o_trpino,o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4((n_dist_nor)*f_n_rand(n_index+iTime));\n\n    }\n\n    fragColor = (fragColor);\n    \n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(o_trmono, 0.0, 0.0);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "ddSSWy", "name": "RayTracing PBR with Free Camera", "author": "shaofun", "description": "next ver: https://www.shadertoy.com/view/Dtj3DG\n\nA very simple physics-based ray-tracing renderer.\nWASDQE to move, SHIFT to accelerate, SPACE to refresh.\n\ngithub: https://github.com/HK-SHAO/RayTracingPBR", "tags": ["3d", "interactive", "sdf", "camera", "pathtracing", "ibl", "pbr"], "likes": 11, "viewed": 1143, "published": 3, "date": "1670794820", "time_retrieved": "2024-07-30T16:13:30.062828", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    fragColor = vec4(color.rgb / color.a, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Modified by HK-SHAO - 2022\n\n// Upgraded from genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define key(K)  texelFetch(iChannel0, ivec2(K, 0), 0).x\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// Keyboard constants definition\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_Q     = 81;\nconst int KEY_SHIFT = 16;\nconst int KEY_SP    = 32;\n\nvec3 KeyboardInput() {\n\tvec3 i = vec3(key(KEY_D) - key(KEY_A), \n                  key(KEY_E) - key(KEY_Q),\n                  key(KEY_S) - key(KEY_W));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 m) {\n    return CameraRotation(m) * KeyboardInput();\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) discard;\n    \n    fragColor = load(fragCoord);\n    \n    if (iFrame == 0) {\n        store(POSITION, vec4(0.0, 0.2, 4.0, 0.0));\n        store(ROTATION, vec4(0.0));\n        \n        store(TARGET,   vec4(0.0, -0.2, 4.0, 0.0));\n        store(TMOUSE,   vec4(0.0));\n        store(PMOUSE,   vec4(0.0));\n        \n        return;\n    }\n\n    vec2 resolution  = load(RESOLUTION).xy;\n    \n    vec3 position    = load(POSITION).xyz;\n    vec2 rotation    = load(ROTATION).xy;\n\n    vec3 target      = load(TARGET).xyz;\n    vec3 tm          = load(TMOUSE).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    \n    float dt = clamp(iTimeDelta, 0.0, 0.1);\n    \n    const float rt_acc = 16.0;\n    const float mv_acc = 5.0;\n    float velocity =  5.0 + 15.0 * key(KEY_SHIFT);\n    \n    rotation += (tm.xy - rotation) * dt * rt_acc;\n    target   += CameraDirInput(rotation) * dt * velocity;\n    position += (target - position) * dt * mv_acc;\n    \n    bvec4 moving = bvec4(\n        length(tm.xy - rotation) * iResolution.x > 1.0,\n        length(target - position) * iResolution.x > 1.0,\n        any(notEqual(resolution, iResolution.xy)),\n        key(KEY_SP) > 0.0\n    );\n    \n    store(TARGET,     vec4(target, 0.0));\n    store(POSITION,   vec4(position, 0.0));\n    store(ROTATION,   vec4(rotation, 0.0, 0.0));\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    store(MOVING,     vec4(any(moving), 0.0, 0.0, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n        vec2 new_tm  = pm + (abs(iMouse.zw) - iMouse.xy) / iResolution.x;\n        \n        float clamp_y = float(new_tm.y > -PI*0.5+0.01 && new_tm.y < PI*0.5-0.01);\n        new_tm.y = mix(tm.y, new_tm.y, clamp_y);\n        \n        store(TMOUSE, vec4(new_tm, 1.0, 0.0));\n\t} else if (tm.z != 0.0) {\n        store(PMOUSE, vec4(tm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n// 数学常量\nconst float ZERO = 0.0;\nconst float PI   = 3.141592653589;\nconst float TAU  = 2.0 * PI;\n\n// Buffer A Shared\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 PMOUSE     = ivec2(0, 0);\nconst ivec2 TARGET     = ivec2(1, 0);\nconst ivec2 TMOUSE     = ivec2(2, 0);\n\nconst ivec2 RESOLUTION = ivec2(0, 1);\nconst ivec2 POSITION   = ivec2(1, 1);\nconst ivec2 ROTATION   = ivec2(2, 1);\n\nconst ivec2 MOVING     = ivec2(0, 2);\n\nmat3 CameraRotation(vec2 m) {\n    m *= mat2(vec2(0, -1), vec2(1, 0));\n    vec2 s = sin(m), c = cos(m);\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, -s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0, -s.y, 0.0, 1.0, 0.0, s.y, 0.0, c.y);\n    \n    return rotY * rotX;\n}\n\n// Update History\n\n// next: https://www.shadertoy.com/view/Dtj3DG\n\n// 2023.01.12\n// 1. ~~use a cheaper way for calculating orthonormal basis.~~\n// 2. use branchlessONB to building an Orthonormal Basis.\n\n// 2022.12.30\n// 1. fix blackened colors caused by incorrect light absorption.\n// 2. that also improved the frame rate.\n// 3. correct cumulative brightness in the alpha channel instead of always being one.\n// 4. which reduces noise.\n// 5. ~~discard pixels that are too dark, it brighten the pixel quality.~~\n\n// 2022.12.26\n// 1. enables metal to be used in IOR.\n// 2. small optimization of performance.\n// 3. simplified reflection operations.\n// 4. use plain black background.\n\n// 2022.12.24\n// 1. fixed camera jamming when looking up and down.\n\n// 2022.12.23\n// 1. fix the blackening of rough transparent material, it improved the frame rate.\n// 2. fix the camera misalignment when full screen.\n// 3. fix the inability to propagate reflected light inside an object.\n// 4. optimize the judgment about self-luminous light source.\n// 5. some formatting optimizations and minor efficiency optimizations.\n// 6. gamma correction for skybox.\n\n// 2022.12.21\n// 1. make the rotation of the view smooth.\n// 2. automatically perform noise reduction when stopping movement.\n// 3. hold down space to force a screen refresh.", "buffer_b_code": "// Copyright © 2019-2023 HK-SHAO\n// MIT Licensed: https://shao.fun/blog/w/taichi-ray-tracing.html\n\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n\n// 摄像机参数\nconst float camera_vfov       = 30.0;                 // 摄像机的纵向视野\nconst float camera_focus      = 2.0;                  // 摄像机的对焦距离\nconst float camera_aperture   = 0.002;                // 摄像机的光圈大小\nconst float camera_exposure   = 0.6;                  // 摄像机曝光值\nconst float light_quality     = 128.0;                // 间接光质量\nconst float gamma             = 2.2;                  // 伽马矫正值\n\n// 配置常量\nconst float TMIN         = 0.005;                     // 光开始传播的起始偏移，避免光线自相交\nconst float TMAX         = 2000.0;                    // 最大单次光线传播距离 (相当于可见范围)\nconst float PRECISION    = 0.0005;                    // 需小于 TMIN，否则光线无法正常离开物体表面\nconst float VISIBILITY   = pow(1.0 / 256.0, gamma);   // 亮度可见度\n\nconst uint  MAX_RAYMARCH = 512U;                      // 最大光线步进次数\nconst uint  MAX_RAYTRACE = 128U;                      // 最大光线追踪次数\n\nconst float ENV_IOR      = 1.000277;                  // 环境的折射率 （空气）\n\n// 枚举形状\nconst int SHAPE_SPHERE   = 0;\nconst int SHAPE_BOX      = 1;\nconst int SHAPE_CYLINDER = 2;\n\n// 物体材质\nstruct material {\n    vec3  albedo;       // 反照率\n    vec3  emission;     // 自发光\n    vec3  normal;       // 切线空间法线\n    float roughness;    // 粗糙度\n    float metallic;     // 金属度\n    float transmission; // 透明度\n    float ior;          // 折射率\n};\n\n// 物体变换\nstruct transform {\n    vec3 position;      // 位置\n    vec3 rotation;      // 旋转\n    vec3 scale;         // 缩放\n};\n\n// SDF 物体\nstruct object {\n    int       shape;    // 形状\n    float     dis;      // 距离物体表面\n    transform trs;      // 变换\n    material  mtl;      // 材质\n};\n\n// 光线\nstruct ray {\n    vec3 origin;        // 光的起点\n    vec3 direction;     // 光的方向\n    vec3 color;         // 光的颜色\n};\n\n// 光子击中的记录\nstruct record {\n    object obj;         // 物体\n    vec3   pos;         // 击中的位置\n    vec3   normal;      // 世界空间法线\n    bool   hit;         // 是否击中\n};\n\n// 摄像机\nstruct camera {\n    vec3  lookfrom;     // 视点位置\n    vec3  lookat;       // 目标位置\n    vec3  vup;          // 向上的方向\n    float vfov;         // 视野\n    float aspect;       // 传感器长宽比\n    float aperture;     // 光圈大小\n    float focus;        // 对焦距离\n};\n\n// SDF 球体\nfloat sd_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n// SDF 盒子\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.02;\n}\n\n// SDF 圆柱\nfloat sd_cylinder(vec3 p, vec2 rh) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - rh;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// 地图列表\nconst object[] map = object[] (\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0, -100.501, 0),\n                    vec3(0, 0, 0),\n                    vec3(100, 100, 100)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.6, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.9, // 粗糙度\n                    0.1, // 金属度\n                    0.0, // 透明度\n                    1.635  // 折射率 （沥青）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0, 0, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.5, 0.5, 0.5)\n        ),\n        material(   vec3(1.0, 1.0, 1.0), // 基础色\n                    vec3(0.1, 1.0, 0.1)*10.0, // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.000  // 折射率 （真空）\n        )\n    ),\n    object(SHAPE_CYLINDER, ZERO,\n        transform(  vec3(-1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 0.2, 0.2), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.1, // 粗糙度\n                    0.0, // 金属度\n                    0.0, // 透明度\n                    1.460  // 折射率 （塑料）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(1.0, -0.2, 0),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(0.2, 0.2, 1.0), // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.2, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    1.100  // 折射率 （铜）\n        )\n    ),\n    object(SHAPE_SPHERE, ZERO,\n        transform(  vec3(0.0, -0.2, 2),\n                    vec3(0, 0, 0),\n                    vec3(0.3, 0.3, 0.3)\n        ),\n        material(   vec3(1.0, 1.0, 1.0)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    0.0, // 金属度\n                    1.0, // 透明度\n                    1.500  // 折射率 （玻璃）\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, 5),\n                    vec3(0, 0, 0),\n                    vec3(2, 1, 0.2)\n        ),\n        material(   vec3(1.0, 1.0, 0.2)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    0.470  // 折射率 （金）\n        )\n    ),\n    object(SHAPE_BOX, ZERO,\n        transform(  vec3(0, 0, -1),\n                    vec3(0, 0, 0),\n                    vec3(2, 1, 0.2)\n        ),\n        material(vec3(1.0, 1.0, 1.0)*0.9, // 基础色\n                    vec3(1), // 自发光\n                    vec3(0, 0, 1), // 切线空间法线\n                    0.0, // 粗糙度\n                    1.0, // 金属度\n                    0.0, // 透明度\n                    2.950  // 折射率 （铁）\n        )\n    )\n);\n\nfloat seed; // 随机数种子\n\n// 用随机数种子产生归一化的随机数\nfloat rand13(vec3 x) {\n    uvec3 p = floatBitsToUint(x);\n    p = 1103515245U * ((p.xyz >> 1U) ^ (p.yzx));\n    uint h32 = 1103515245U * ((p.x ^ p.z) ^ (p.y >> 3U));\n    uint n = h32 ^ (h32 >> 16U);\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nfloat rand11() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    uint q = (n.x ^ n.y) * 1597334673U;\n    return float(q) * (1.0 / float(0xffffffffU));\n}\n\nvec2  rand21() {\n    uvec2 n = floatBitsToUint(seed++) * uvec2(1597334673U, 3812015801U);\n    n = (n.x ^ n.y) * uvec2(1597334673U, 3812015801U);\n    return vec2(n) * (1.0 / float(0xffffffffU));\n}\n\n// 光子在射线所在的位置\nvec3 at(ray r, float t) {\n    return r.origin + t * r.direction;\n}\n\n// 单位圆内随机取一点\nvec2 random_in_unit_disk() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n    return sqrt(r.x) * vec2(sin(r.y), cos(r.y));\n}\n\n// 从摄像机获取光线\nray get_ray(camera c, vec2 uv, vec3 color) {\n    // 根据 VFOV 和显示画布长宽比计算传感器长宽\n    float theta = radians(c.vfov);\n    float half_height = tan(theta * 0.5);\n    float half_width = c.aspect * half_height;\n    \n    // 以目标位置到摄像机位置为 Z 轴正方向\n    vec3 z = normalize(c.lookfrom - c.lookat);\n    // 计算出摄像机传感器的 XY 轴正方向\n    vec3 x = normalize(cross(c.vup, z));\n    vec3 y = cross(z, x);\n    \n    vec3 hwfx = half_width  * c.focus * x;\n    vec3 hhfy = half_height * c.focus * y;\n    \n    vec3 lower_left_corner = c.lookfrom - hwfx - hhfy - c.focus * z;\n    \n    vec3 horizontal = 2.0 * hwfx;\n    vec3 vertical   = 2.0 * hhfy;\n    \n    // 模拟光进入镜头光圈\n    float lens_radius = c.aperture * 0.5;\n    vec2 rud = lens_radius * random_in_unit_disk();\n    vec3 offset = x * rud.x + y * rud.y;\n    \n    // 计算光线起点和方向\n    vec3 ro = c.lookfrom + offset;\n    vec3 po = lower_left_corner + uv.x * horizontal\n                                + uv.y * vertical;\n    vec3 rd = normalize(po - ro);\n    \n    return ray(ro, rd, color);\n}\n\n// 从欧拉角计算旋转矩阵\nmat3 angle(vec3 a) {\n    vec3 s = sin(a), c = cos(a);\n    return mat3(vec3( c.z,  s.z,    0),\n                vec3(-s.z,  c.z,    0),\n                vec3(   0,    0,    1)) *\n           mat3(vec3( c.y,    0, -s.y),\n                vec3(   0,    1,    0),\n                vec3( s.y,    0,  c.y)) *\n           mat3(vec3(   1,    0,    0),\n                vec3(   0,  c.x,  s.x),\n                vec3(   0, -s.x,  c.x));\n}\n\n// 计算有向距离 (物体内部距离为负)\nfloat signed_distance(object obj, vec3 pos) {\n    vec3 position = obj.trs.position;\n    vec3 rotation = obj.trs.rotation;\n    vec3 scale    = obj.trs.scale;\n    \n    vec3 p = pos - position;\n    \n    // 会重复的将欧拉角转换成旋转矩阵，实际上只用在第一次计算就行了\n    // 也有可能被编译器优化掉了\n    p *= angle(radians(rotation));\n    \n    switch(obj.shape) {\n        case SHAPE_SPHERE:\n            return sd_sphere(p, scale.x);\n        case SHAPE_BOX:\n            return sd_box(p, scale);\n        case SHAPE_CYLINDER:\n            return sd_cylinder(p, scale.xy);\n        default:\n            return sd_sphere(p, scale.x);\n    }\n}\n\n// 找到最近的物体并计算距离\nobject nearest_object(vec3 p) {\n    object o; o.dis = TMAX;\n    for (int i = 0; i < map.length(); i++) {\n        object oi = map[i];\n        oi.dis = abs(signed_distance(oi, p));\n        if (oi.dis < o.dis) o = oi;\n    }\n    return o;\n}\n\n// 计算物体法线 from https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal(object obj, vec3 p) {\n    vec2 e = vec2(1, -1) * 0.5773 * 0.0005;\n    return normalize( e.xyy*signed_distance(obj, p + e.xyy) + \n                      e.yyx*signed_distance(obj, p + e.yyx) + \n                      e.yxy*signed_distance(obj, p + e.yxy) + \n                      e.xxx*signed_distance(obj, p + e.xxx) );\n}\n\n// 构建正交基旋转矩阵 from https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nmat3 TBN(vec3 N) {\n    float s = N.z >= 0.0 ? 1.0 : -1.0;\n    float a = -1.0 / (s + N.z);\n    float b = N.x * N.y * a;\n    vec3  T = vec3(1.0 + s * N.x * N.x * a, s * b, -s * N.x);\n    vec3  B = vec3(b, s + N.y * N.y * a, -N.y);\n    \n    return mat3(T, B, N);\n}\n\n// 使用光线步进 (Ray March) 检测第一个交点\nrecord raycast(ray r) {\n    record rec; float t = TMIN;\n    for(uint i = 0U; i < MAX_RAYMARCH && t < TMAX && !rec.hit; i++) {\n        rec.pos = at(r, t);\n        rec.obj = nearest_object(rec.pos);\n        rec.hit = rec.obj.dis < PRECISION;\n        t      += rec.obj.dis;\n    }\n    return rec;\n}\n\n// 采样立方体贴图\nvec4 mix_cube_lod(samplerCube sharp, samplerCube blur, vec3 dir, float lod) {\n    return mix(textureLod(sharp, dir, lod), textureLod(blur, dir, lod), lod);\n}\n\n// 采样天空\nvec3 sky(ray r, float brightness, float lod) {\n    vec4 ibl = mix_cube_lod(iChannel2, iChannel3, r.direction, lod); // 天空盒 IBL 照明\n    return pow(ibl.rgb * ibl.a * brightness, vec3(gamma)); // gamma 矫正\n}\n\n// 菲涅尔反射近似值\nfloat fresnel_schlick(float cosine, float F0) {\n    return mix(pow(abs(1.0 - cosine), 5.0), 1.0, F0);\n}\n\n// 用粗糙度计算菲涅尔\nfloat fresnel_schlick(float cosine, float F0, float roughness) {\n    return mix(fresnel_schlick(cosine, F0), F0, roughness);\n}\n\n// 在切线空间半球采样\nvec3 hemispheric_sampling() {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt(r.x);\n    vec2 xy = sqrt(1.0 - r.x) * v; \n\n    return vec3(xy, z);\n}\n\n// 用粗糙度在切线空间半球采样\nvec3 hemispheric_sampling(float roughness) {\n    vec2 r = rand21() * vec2(1.0, TAU);\n\n    float shiny = pow(roughness, 5.0); // 光感越大高光越锐利\n    // ToDo: 除零怎么办 ????!!\n    r.x = shiny < 0.000001 ? 1.0 : (1.0 - r.x) / (1.0 + (shiny - 1.0) * r.x);\n    \n    vec2  v = vec2(cos(r.y), sin(r.y));\n    float z = sqrt(r.x);\n    vec2 xy = sqrt(1.0 - r.x) * v;\n    \n    return vec3(xy, z);\n}\n\n// 应用 PBR 材质\nray BSDF(ray r, record rec) {\n    // 材质参数\n    vec3  albedo       = rec.obj.mtl.albedo;\n    float roughness    = rec.obj.mtl.roughness;\n    float metallic     = rec.obj.mtl.metallic;\n    float transmission = rec.obj.mtl.transmission;\n    vec3  normal       = rec.obj.mtl.normal;\n    float ior          = rec.obj.mtl.ior;\n    \n    normal = TBN(rec.normal) * normal; // 将切线空间法线转换到世界空间\n    float outer = -sign(dot(normal, r.direction)); // 光正在从外面穿入物体表面\n    \n    // 光线和物体表面参数\n    vec3 I  =  r.direction;\n    vec3 V  = -r.direction;\n    vec3 N  =  normal *= outer; // 如果处于 SDF 物体内部就反过来\n    vec3 C  =  r.color;\n    vec3 L;\n    \n    N = TBN(N) * hemispheric_sampling(roughness); // 用粗糙度半球采样\n    float NoV = dot(N, V);\n\n    float eta = outer > 0.0 ? ENV_IOR / ior : ior / ENV_IOR; // 计算折射率之比\n    float k   = 1.0 - eta * eta * (1.0 - NoV * NoV); // 小于 0 为全反射\n    float F0  = (eta - 1.0) / (eta + 1.0); F0 *= 3.0*F0; // 让透明材质的反射更明显一些\n    float F   = fresnel_schlick(NoV, F0, roughness); // 菲涅尔\n\n    vec2 rand2 = rand21(); // 取两个随机数\n    if (rand2.y < F + metallic || k < 0.0) {\n            L = I + 2.0 * NoV * N; // 包含镜面反射、菲涅尔反射、全反射\n            // 下面可以提高帧数，但是会导致透明材质发黑，需要优化\n            C *= float(dot(L, normal) > 0.0); // 如果光穿入或穿出表面就直接吸收掉\n    } else {\n        if (rand2.x < transmission) {\n            L = eta * I - (sqrt(k)- eta * NoV) * N; // 斯涅尔折射\n        } else {\n            L = TBN(normal) * hemispheric_sampling(); // 漫反射\n        }\n    }\n\n\n    C *= albedo;\n\n    // 更新光的方向和颜色\n    r.color     = C;\n    r.direction = L;\n    \n    return r;\n}\n\n// RGB 亮度\nfloat brightness(vec3 rgb) {\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\n}\n\n// 光线追踪\nray raytrace(ray r) {\n    for (uint i = 0U; i < MAX_RAYTRACE; i++) {\n        // 俄罗斯轮盘赌概率，防止光线过分的反复反射\n        float inv_pdf = exp(float(i) / light_quality);\n        float roulette_prob = 1.0 - (1.0 / inv_pdf);\n    \n        // 光线被毙掉就不用继续了\n        if (rand11() < roulette_prob) { // discard;\n            r.color *= roulette_prob;\n            break;\n        }\n        \n        // 能量守恒\n        r.color *= inv_pdf;\n        \n        // 与地图求交\n        record rec = raycast(r);\n        \n        // 没击中物体就肯定击中天空\n        if (!rec.hit) {\n            r.color *= sign(float(i)); // 纯黑色背景\n            r.color *= sky(r, 2.0, 1.0 - 1.0 / (1.0 + 0.1 * float(i)));\n            break;\n        }\n        \n        // 计算法线\n        rec.normal = calc_normal(rec.obj, rec.pos);\n        \n        // 更新光子的位置\n        r.origin = rec.pos;\n        \n        // 应用 PBR 材质更新光线\n        r = BSDF(r, rec);\n        \n        // 处理自发光\n        float intensity = brightness(r.color);\n        r.color *= rec.obj.mtl.emission;\n        float visible   = brightness(r.color);\n        \n        // 光太暗或者击中光源\n        if (intensity < visible || visible < VISIBILITY) break;\n    }\n\n    return r;\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color *= mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color  = a / b;\n\t// Back to color space\n    color *= mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\n// 片段着色器程序入口\nvec4 fragment(vec2 uv, vec2 SCREEN_PIXEL_SIZE) {\n    // 计算摄像机方位和视线\n    vec3  lookfrom  = load(POSITION).xyz;\n    vec2  rotation  = load(ROTATION).xy;\n    vec3  direction = CameraRotation(rotation) * vec3(0, 0, -1);\n    vec3  lookat    = lookfrom + direction;\n    float aspect    = SCREEN_PIXEL_SIZE.y / SCREEN_PIXEL_SIZE.x;;\n    \n    // 初始化摄像机\n    camera cam;\n    cam.lookfrom = lookfrom;\n    cam.lookat   = lookat;\n    cam.aspect   = aspect;\n    cam.vfov     = camera_vfov;\n    cam.vup      = vec3(0, 1, 0);\n    cam.focus    = camera_focus;\n    cam.aperture = camera_aperture;\n    \n    // 用 UV 和时间初始化随机数发生器种子\n    seed = rand13(vec3(uv, iTime*iTimeDelta));\n\n    // 超采样\n    uv += rand21() * SCREEN_PIXEL_SIZE;\n    \n    // 对每个光子经过的表面采样一次\n    ray r = get_ray(cam, uv, vec3(1));\n    \n    // 处理颜色\n    vec3 color = raytrace(r).color;\n\n    // 色调映射\n    color *= camera_exposure;\n    color  = ACESFitted(color);\n    \n    // 伽马矫正\n    color = pow(color, vec3(1.0 / gamma));\n\n    return vec4(color, brightness(r.color));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 SCREEN_PIXEL_SIZE = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * SCREEN_PIXEL_SIZE;\n    \n    fragColor = fragment(uv, SCREEN_PIXEL_SIZE); // 获取片元颜色\n    \n    if (bool(load(MOVING).x)) return; // 如果正在移动就不积累上一帧\n    \n    fragColor += texture(iChannel0, uv); // 积累帧进行降噪\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 188]], "test": "untested"}
{"id": "msjXRd", "name": "today i learned: squircles", "author": "jonasfrey", "description": "inspiration https://www.shadertoy.com/view/mdjXRd\nsquircles = mixture square and circle", "tags": ["template"], "likes": 5, "viewed": 179, "published": 3, "date": "1670791439", "time_retrieved": "2024-07-30T16:13:30.847730", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( n-1., n_sharpness))*pow(2., n_sharpness);\n}\nfloat f_n_dist_square(vec2 o_p){\n    vec2 o_delta = vec2(0.)-o_p;\n    return min(o_delta.x, o_delta.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    \n    float n_tau = 6.2831;\n    float n_squircles = 10.; \n    vec2 o_delta = vec2(0.0) - o_trpino;\n    float n_ang = atan(o_delta.y, o_delta.x)+(n_tau/2.);\n    float n_ang_nor = n_ang / n_tau;\n    float n_ang_nor_snapped = (floor(n_ang_nor * n_squircles)+0.5) / n_squircles;\n    \n    float n_radius = 0.3;\n    \n    vec2 o_p = vec2(\n        cos(n_ang_nor_snapped*n_tau)*n_radius, \n        sin(n_ang_nor_snapped*n_tau)*n_radius\n    );\n    \n\n    float n_speed = iTime*n_tau+n_ang_nor_snapped*n_tau;\n    float n_dist_squircle = length(\n        pow(o_p-o_trpino, vec2(2.))\n    );\n    n_dist_squircle *= 1000.+sin(n_speed)*900.;\n    float n_dist_square = f_n_dist_square(o_p);\n    //float n = smoothstep(0.1, 0.11, n_dist_squircle);\n    //float n = sin(n_dist_squircle*6.2831*10.);\n    float n = f_n_inoutexp(n_dist_squircle, 2.);\n    n = n*0.1+n*(sin(n_speed+n_tau/2.)*0.5+0.5)*2.;\n    vec4 o_col = vec4(\n        //0.1+0.9*n,\n        //0.1-n*0.2, \n        //0.1-n*0.3, \n        //1.\n        n\n    );\n    fragColor = o_col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 253], [254, 254, 286, 286, 359], [360, 360, 417, 417, 1641]], "test": "untested"}
{"id": "ms2Szd", "name": "normalizing a square aka circle", "author": "jonasfrey", "description": "i dont know how but i know by dividing the distance to an edge of the square by the maximum distance it should become a circle", "tags": ["normalizing"], "likes": 3, "viewed": 161, "published": 3, "date": "1670791169", "time_retrieved": "2024-07-30T16:13:31.602712", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( n-1., n_sharpness))*pow(2., n_sharpness);\n}\nfloat f_n_dist_square(\n    vec2 o_p\n){\n    return max(abs(o_p.x), abs(o_p.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    o_trpino *=1.5;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    float n_dist_square = f_n_dist_square(o_trpino);\n    float n_dist_circ = length(o_trpino);\n    n_dist_circ = f_n_inoutexp(n_dist_circ, 2.);\n    n_dist_square*= n_dist_circ*(sin(iTime*2.)*0.5+0.5+1.0);\n\n    float n = n_dist_square*1.;\n    \n    n = f_n_inoutexp(n, 2.);\n\n    fragColor = vec4(\n        //sin(n*6.2831*10.)\n        n\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2Szd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 253], [254, 254, 292, 292, 334], [335, 335, 392, 392, 953]], "test": "untested"}
{"id": "csBXWy", "name": "Riders On The Storm Remix", "author": "pashafx", "description": "alcattes.com", "tags": ["music"], "likes": 11, "viewed": 456, "published": 3, "date": "1670782403", "time_retrieved": "2024-07-30T16:13:32.360685", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    vec3 col = baseCol*m;\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 31246, "src": "https://soundcloud.com/pashafx/riders_on_the_storm", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBXWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 100, 100, 235], [237, 237, 279, 279, 436], [438, 438, 476, 476, 502], [504, 504, 544, 544, 591], [593, 593, 642, 642, 758], [760, 760, 797, 797, 1011], [1013, 1013, 1056, 1056, 1913], [1915, 1915, 1972, 1972, 2974]], "test": "untested"}
{"id": "Ds2XRd", "name": "[phreax] diffraction grating", "author": "phreax", "description": "First test with implementing physical based diffraction grating by Alan Zucconi (great article):\nhttps://www.alanzucconi.com/2017/07/15/the-mathematics-of-diffraction-grating/\n\nCheck out my follow up: https://www.shadertoy.com/view/dd2SRd\n", "tags": ["raymarching", "metal", "moebius", "iridescent", "torusknot"], "likes": 31, "viewed": 542, "published": 3, "date": "1670776459", "time_retrieved": "2024-07-30T16:13:33.172514", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n   \n   Implementing physical diffraction grating by Alan Zucconi (great article):\n   \n   https://www.alanzucconi.com/2017/07/15/the-mathematics-of-diffraction-grating/\n   \n   This shader was of great help, as I was too stupid to compute the tangent vector\n   https://www.shadertoy.com/view/7dVGzz\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n\n\nfloat tt, g_mat;\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\nvec3 waveSpectrum(float w){\n\n    if(w > 700.0 || w < 400.0){\n        return vec3(0);\n    }\n    \n\tfloat x = fract((w - 400.0)/ 300.0);\n    \n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\tvec3 col = bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2);\n\n    // https://twitter.com/Atrix256/status/1019359890660192256\n    // Undo gamma\n    col = invGamma(col);\n\n    return col;\n}\n\nvec3 diffraction(vec3 rd, vec3 n, vec3 td, vec3 l, float d) {\n\n    vec3 col = vec3(0);\n\n    float cos_ThetaL = dot(l, td);\n    float cos_ThetaV = dot(rd, td);\n   \n    float u = abs(cos_ThetaL - cos_ThetaV);\n    \n    if(u == 0.) {\n        return vec3(0);\n    }\n    \n    for(float i=1.; i < 2.; i++) {\n        float wavelength = u * d / i;\n        col += waveSpectrum(wavelength);\n    }\n    col = clamp(col, vec3(0), vec3(1));\n    return col;\n}\n\nvec3 transform(vec3 p) {\n   p.yz *= rot(PI*.25 + tt);\n   p.yx *= rot(PI*.25 + .75*tt);\n    return p;\n}\n\nvec2 torusUV(vec3 p) {\n\n    p = transform(p);\n    float a = atan(p.z, p.x);\n    float r = length(p.zx);\n    \n    return vec2(r, a);  \n}\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\n\nfloat map(vec3 p) {   \n  \n    vec3 bp = p;\n    float edge = 0.02;\n  \n    p = transform(p);\n\n    float r = 1.4;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n\n    float rev = .5;\n    float a = atan(p.z, p.x);\n    \n\n\n\n    cp *= rot(rev*a);\n    cp = abs(cp) - 1.*SIN(tt);\n        cp = abs(cp) - SIN(tt);\n\n    \n    float dr = rect(cp.xy, vec2(.3), edge);\n\n    float d= dr;\n    return .3*d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat gridSurf( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*2., 1.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = gridSurf(p);                 \n    vec3 grad = vec3( gridSurf(vec3(p.x-eps, p.y, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y-eps, p.z))-ref,\n                      gridSurf(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        if(abs(d) < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    return vec2(t, mat);\n}\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    tt = .6*iTime;\n    vec3 ro = vec3(uv*6.,-4.),\n          rd = vec3(0,0,1.),\n          lp = vec3(3., 0., -5),\n          lp2 = vec3(-3., 0., -5);\n\n    vec3 col;\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.122,0.467,0.518);\n    vec3 c2 = vec3(0.192,0.122,0.278);\n    \n    // light color\n    vec3 lc1 = vec3(0.745,0.761,0.976);\n    vec3 lc2 = vec3(0.573,0.922,0.969);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 200.;\n        vec2 rm = raymarch(ro, rd, steps);\n        mat = rm.y;\n        \n        \n        vec3 p = ro + rm.x*rd;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n        vec2 tuv = torusUV(p);\n\n        n = doBumpMap(vec3(tuv.x, 0., tuv.y*2.*PI), n, .001);\n    \n     \n        if(rm.x < 50.) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n            float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n\n            vec3 td = vec3(tuv.x, tuv.y, 0.).yxz;\n            vec3 tangent;\n            vec3 bitangent;\n\n            pixarONB(n, tangent, bitangent);\n            tangent = normalize(tangent);\n            bitangent = normalize(bitangent);\n\n            mat3 tbn = mat3(tangent, bitangent, n);\n            l = normalize(vec3(0., 1, 0));\n            vec3 difr = diffraction(-rd, n, normalize(tbn*td), l, 700.);\n            col += .6*(lc1*dif + lc2*dif2)+ difr;\n            \n          \n            col = mix(col, col*(smoothstep(0., 1., sin(tuv.y*150.+10.*tt))), .5);\n          \n            if(mat == 0.) {\n                rd = reflect(rd, n);\n                \n                rd.yz *= rot(PI*.8);\n         \n                vec3 refl = texture(iChannel0, rd).rgb;\n                \n                refl = invGamma(refl);\n                \n               // refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .5); // reflect rainbows too\n               col = mix(col, .7*refl, .5);\n    \n              \n            } \n\n        } else {\n          //  col =  mix(c1+.2, c2-.2, (pow(dot(uv, uv), .8)))*.5+.1; // background\n            \n            //col = texture(iChannel0, ro).rgb;\n            col = invGamma(col);\n        } \n    \n    }\n\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv));\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    col = gamma(col); // gamma\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2XRd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[495, 495, 514, 514, 562], [565, 565, 590, 590, 621], [623, 716, 752, 752, 839], [1008, 1008, 1047, 1047, 1140], [1143, 1143, 1191, 1191, 1388], [1391, 1391, 1416, 1416, 1450], [1451, 1451, 1473, 1473, 1510], [1512, 1512, 1539, 1539, 2200], [2202, 2202, 2263, 2263, 2644], [2646, 2646, 2670, 2670, 2748], [2750, 2750, 2772, 2772, 2885], [2888, 2888, 2915, 2915, 3006], [3009, 3009, 3048, 3048, 3134], [3137, 3137, 3156, 3156, 3519], [3522, 3522, 3546, 3546, 3821], [3823, 3823, 3850, 3850, 3995], [3997, 4059, 4116, 4116, 4536], [4537, 4548, 4625, 4625, 4951], [4953, 4953, 4999, 4999, 5322], [5324, 5324, 5343, 5343, 5412], [5414, 5414, 5435, 5435, 5638], [5640, 5640, 5697, 5697, 8505]], "test": "untested"}
{"id": "dd2SRd", "name": "[phreax] escher's dream", "author": "phreax", "description": " Implementing physical diffraction grating by Alan Zucconi (great article):\n\n https://www.alanzucconi.com/2017/07/15/the-mathematics-of-diffraction-grating/\n\n", "tags": ["escher", "bumpmapping", "isometric", "diffractiongrating"], "likes": 19, "viewed": 316, "published": 3, "date": "1670775299", "time_retrieved": "2024-07-30T16:13:33.926498", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n   \n   Implementing physical diffraction grating by Alan Zucconi (great article)\n   \n   https://www.alanzucconi.com/2017/07/15/the-mathematics-of-diffraction-grating/\n   \n   This was of great help, as I was to stupid to compute the tangent vectors\n   https://www.shadertoy.com/view/7dVGzz\n   \n   Based on https://www.shadertoy.com/view/dd2SRd\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define BUMP_EPS 0.004\n#define tt iTime\n\n\nfloat g_mat;\nvec2 g_uv;\n\n// first time to use a struct in my shaders (;\nstruct ObjectInfo {\n    float t;\n    float mat;\n    vec2 uv;\n};\n\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, vec3(0), vec3(1));\n}\n\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 invGamma(vec3 col) {\n    return pow(col, vec3(2.2));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(1./2.2));\n}\n\nvec3 spectralZucconi6(float x) {\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\tvec3 col =  bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2);\n    col = invGamma(col);\n    return col;\n}\n\n// wrapped map\nvec3 wrappedSpectralZucconi6(float x) {\n    x = fract(x);\n    return spectralZucconi6(x);\n}\n\n// wavelength normalized for diffraction grading\nvec3 waveZucconi6(float w) {\n\n    if(w > 700.0 || w < 400.0){\n        return vec3(0);\n    }\n    \n\tfloat x = fract((w - 400.0)/ 300.0);\n\n    return spectralZucconi6(x);\n}\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n// from: https://www.shadertoy.com/view/7dVGzz\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 diffraction(vec3 rd, vec3 n, vec3 td, vec3 l, float d) {\n\n    vec3 col = vec3(0);\n   \n    float cos_ThetaL = dot(l, td);\n    float cos_ThetaV = dot(rd, td);\n   \n    float u = abs(cos_ThetaL - cos_ThetaV);\n    \n    if(u == 0.) {\n        return vec3(0);\n    }\n    \n    for(float i=1.; i < 2.; i++) {\n        float wavelength = u * d / i;\n        col += waveZucconi6(wavelength);\n    }\n    col = clamp(col, vec3(0), vec3(1));\n    return col;\n}\n\n// iq\nfloat sdBoxFrame( vec3 p, vec3 b, float e ){\n\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat box(vec3 p, vec3 r) {\n  vec3 d = abs(p) - r;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nvec3 transform(vec3 p) {\n   p.z -= 5.;\n   p.yz *= rot(.3*PI*sin(0.25*tt));\n   p.yx *= rot(PI*.25 );\n   return p;\n}\n\n// polar coords\nvec2 torusUV(vec3 p) {\n    float a = atan(p.z, p.x);\n    float r = length(p.zx);\n    \n    return vec2(r, a);  \n}\n\n// adapted from https://www.shadertoy.com/view/4sjXW1\nvec2 cubeUV(in vec3 p) {\n    vec2 x = p.zy/p.x;\n    vec2 y = p.xz/p.y;\n    vec2 z = p.xy/p.z;\n    \n    //select face\n    p = abs(p);\n    if (p.x > p.y && p.x > p.z) return x;\n    else if (p.y > p.x && p.y > p.z) return y;\n    else return z;\n}\n\nfloat map(vec3 p) {     \n  \n    vec3 bp = p;\n    float edge = 0.005;\n    \n    p = transform(p);\n\n    vec3 p1 = abs(p)- mix(.0, 1.9, SIN(0.5*tt));\n    float f1 = sdBoxFrame(p1, vec3(1.0), .15)-edge;\n\n    vec3 p2 = abs(p)- mix(.0, 1.9*2., SIN(.25*tt))-edge;\n    float f2 = sdBoxFrame(p2, vec3(1.+.5*SIN(.25*tt)), .15)*.75;\n    \n    g_uv = f1 < f2 ? cubeUV(p1) : cubeUV(p2);  // save uv's for texture and bump mapping\n\n    float d = min(f1, f2); \n    return d;\n    \n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\n// Shane's bump mapping\nfloat gridSurface( in vec3 p){\n    p = abs(mod(p*2., 1.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = gridSurface(p);                 \n    vec3 grad = vec3( gridSurface(vec3(p.x-eps, p.y, p.z))-ref,\n                      gridSurface(vec3(p.x, p.y-eps, p.z))-ref,\n                      gridSurface(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nObjectInfo raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n          \n    vec2 uv; // object uv\n          \n    vec3 p = ro;\n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material infos\n        uv = g_uv;\n        \n        if(abs(d) < 0.0001 || t > 100.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n    \n    return ObjectInfo(t, mat, uv);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv*9.,-4.),      // ray origin and ray direction swapped, for isometric /\n         rd = vec3(0,0,1.),         // orhographic perspective\n         lp = vec3(3., 4., -4),\n         lp2 = vec3(-3., -4., -2);\n\n    vec3 col;\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n\n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.478,1.000,0.914);\n    vec3 c2 = vec3(0.922,0.784,0.976);\n    \n    float steps = 200.;\n\n    ObjectInfo objectInfo = raymarch(ro, rd, steps);\n    mat = objectInfo.mat;\n\n    vec3 p = ro + objectInfo.t*rd;\n\n    vec3 n = normalize(e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                       e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n\n    vec2 tuv = objectInfo.uv;\n\n    n = doBumpMap(vec3(tuv*.5, 0.), n, .009);\n\n    if(objectInfo.t < 50.) {\n\n        vec3 l = normalize(lp-p);\n        vec3 l2 = normalize(lp2-p);\n        float dif = max(dot(n, l), .0);\n        float dif2 = max(dot(n, l2), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n\n        float shd = softshadow(p, l2, 0.1, 50., 5.0);\n\n        float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n        float height = atan(n.y, n.x);\n\n        // some none physical iridescence\n        vec3 iri = spectralZucconi6(height*1.11)*smoothstep(.8, .2, abs(n.z))-.08;\n\n        // get tangent vector for diffraction grating\n        vec3 tangent;\n        vec3 bitangent;\n\n        pixarONB(n, tangent, bitangent);\n        tangent = normalize(tangent);\n        bitangent = normalize(bitangent);\n        \n        mat3 tbn = mat3(tangent, bitangent, n);\n        vec3 td = normalize(tbn * vec3(tuv, 0.));\n        \n        l = normalize(vec3(0, 1, 0));\n        vec3 difr = diffraction(-rd, n, td, l, 780.); // zucconis diffraction grating\n        col += .5*(c1*dif + c2*dif2)+ 1.8*difr + .9*iri + .4*sss + .2;\n\n        float grids = 60.;\n\n        vec2 grid = smoothstep(.0, .1, SIN(grids*(tuv+.5)));\n        col *= dot(grid, vec2(.5));\n        \n        if(mat == 0.) {\n            vec3 refld = reflect(ro, n);\n\n            vec3 refl = texture(iChannel0, refld, 5.).rgb;\n            \n            refl = invGamma(refl);\n            col = mix(col, refl, .5);\n        } \n\n        col *= 1.3; // brighten\n        \n        // fog\n        float t = objectInfo.t;\n        float fog = 1.-exp(-t*t*0.005);\n        \n        col = mix(col, c1, fog);\n        col = mix(col, col*shd, .7);\n\n    } else {\n        col =  mix(c1, c2, (pow(dot(uv, uv), .8)))*.9; // background\n        col = invGamma(col);\n\n    } \n    \n\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv)); // dither\n    col *= mix(.2, 1., (1.5-pow(dot(uv, uv), .5))); // vignette\n    col = gamma(col); // gamma\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31248, "src": "https://soundcloud.com/carbonbasedlifeforms/accede?si=871fd3cc13664e3982d54125d484e1e9&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2SRd.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[678, 678, 697, 697, 745], [747, 747, 772, 772, 803], [805, 805, 828, 828, 869], [872, 965, 1001, 1001, 1088], [1256, 1256, 1281, 1281, 1315], [1317, 1317, 1339, 1339, 1376], [1378, 1378, 1410, 1410, 1877], [1879, 1894, 1933, 1933, 1985], [1987, 2036, 2064, 2064, 2205], [2207, 2207, 2246, 2246, 2339], [2342, 2495, 2543, 2543, 2740], [2742, 2742, 2803, 2803, 3187], [3189, 3195, 3239, 3239, 3520], [3523, 3523, 3550, 3550, 3641], [3644, 3644, 3668, 3668, 3758], [3760, 3776, 3798, 3798, 3888], [3890, 3944, 3968, 3968, 4186], [4188, 4188, 4207, 4207, 4652], [4655, 4655, 4679, 4679, 4954], [4956, 4980, 5010, 5010, 5134], [5136, 5198, 5255, 5255, 5687], [5689, 5700, 5777, 5777, 6103], [6105, 6105, 6157, 6157, 6565], [6568, 6568, 6625, 6625, 9461]], "test": "untested"}
{"id": "mdSXRt", "name": "imagemorphwowcool", "author": "AlreadyTaken", "description": "if this works out i have a beier neely like morphing. if not i have something else. \nLater:  I have something else. xD\nUpdate: wow. ok this really kinda works.", "tags": ["morph"], "likes": 3, "viewed": 292, "published": 3, "date": "1670772328", "time_retrieved": "2024-07-30T16:13:34.718381", "image_code": "\n#define maxmorph 800\n#define pi 3.1415926\n\nfloat avg(vec3 v) { return (v.x + v.y + v.z) / 3.0; }\n\nbool inRange(vec2 coord, vec2 iRes) {\nreturn ((coord.x/iRes.x) > 0. && !((coord.x/iRes.x)> 1.0) && (coord.y/iRes.y) > 0. && !((coord.y/iRes.y)> 1.0) );\n\n}\n\nbool isContour(vec2 fragCoord, sampler2D sam, vec2 iRes, float limit) {\n\n    float src = avg(texture(sam, fragCoord/iRes).rgb);\n    float src_sx = avg(texture(sam, (fragCoord + vec2(2.0, 0.0))/iRes).rgb);\n    float src_sy = avg(texture(sam, (fragCoord + vec2(0.0, 2.0))/iRes).rgb);\n    vec2 edges = vec2(src - src_sx, src - src_sy);\n    \n    float mag = length(edges);\n    \n    vec3 contour = vec3(mag/src);\n    bool result = false;\n    if (contour.r >= limit) result = true;\n    return result;\n}\n\nvec2 distortPos (vec2 current, vec2 target) {\nfloat radius = 10.;\nfloat dist = distance(current,target);\nfloat radiusDist = 0.5*abs(radius-dist);\nfloat distort = 1.- ((sin(radiusDist)+1.0)*0.5);\nreturn current*distort;\n}\n\n\nvec2 pointAtAngle(vec2 pos, float radius, float angle) {\nvec2 result = pos;\nresult.x = pos.x + (radius*cos(angle));\nresult.y = pos.y +(radius*sin(angle));\nreturn result;\n\n}\n\n\n\nvec4 wrapping(sampler2D origin, vec2 fragCoord, sampler2D morphSource, vec2 iRes, float limit) {\n     \nvec4 result = vec4(0.,0.,0.,0.);\n result = vec4(texture(origin, fragCoord/iRes).rgb, 1.);\nbool cont = isContour(fragCoord, morphSource, iRes, limit);\n//nothing to do\n\n\nif(cont) {\nresult = vec4(texture(origin, fragCoord/iRes).rgb, 1.);\nreturn result;\n}\nelse {\nvec2 pos = fragCoord/iRes;\nbool abort = false;      \nfor(int r = 2; r < maxmorph+2;r++ ) {\n \n  for(int deg = 0; deg<180; deg+=45) {\n   float rad = (float(deg)*(pi/180.));\n  vec2 fRad = pointAtAngle(fragCoord,float(r),rad);  \n\n  if(inRange(fRad, iRes) && isContour(fRad, morphSource, iRes, limit)) {\n   vec2 distortPos = distortPos(pos,fRad/iRes.xy);\n   result = vec4(texture(origin,distortPos).rgb, 1.0);\n   abort = true;  \n}\n if(abort) break;\n}\n\n if(abort) break;\n  \n}\n\nreturn result;\n\n}\n\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n     vec4 greenTest = vec4(0.0,1.,0.,1.);\n     float timeforward = 1.0 - ((1.+cos(iTime))*0.5);\n     vec4 origA= texture(iChannel1,fragCoord/iResolution.xy );\n     vec4 contA = wrapping(iChannel1, fragCoord, iChannel0, iResolution.xy, 0.125);\n     vec4 origB= texture(iChannel0,fragCoord/iResolution.xy );\n     vec4 contB = wrapping(iChannel0, fragCoord, iChannel1, iResolution.xy, 0.0625);\n     vec4 from = mix(origA,contB, timeforward);\n     vec4 to = mix(contA,origB, timeforward);\n     fragColor = mix(from,to,1.*timeforward);\n     vec4 m = iMouse / iResolution.x;\n     if(m.z > 0.) { \n      //sanity check\n          fragColor = mix(origA,origB,1.*timeforward);\n     }else {\n          fragColor = mix(from,to,1.*timeforward);\n     }\n\n    \n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 63, 63, 97], [99, 99, 136, 136, 253], [255, 255, 326, 326, 751], [753, 753, 798, 798, 973], [976, 976, 1032, 1032, 1148], [2008, 2008, 2063, 2063, 2808]], "test": "untested"}
{"id": "cdSSWG", "name": "Reflective Raytracing", "author": "01000001", "description": "Just learning how raytracing works, and also simultaneously figuring out how materials are done properly\n\nSignificant credit to Zavie's shaders for allowing me to understand light transport better than ever before.\n\nSmoothness doesn't do anything... yet", "tags": ["raytracing"], "likes": 2, "viewed": 110, "published": 3, "date": "1670770842", "time_retrieved": "2024-07-30T16:13:35.500290", "image_code": "//Significant credit goes to Zavie, for creating https://www.shadertoy.com/view/llBGz1 which is \n//the shader I learned from for how to manage colours properly\n\n\nrayHit sphereRay(vec3 o, vec3 dirV, sphere sp)\n{    \n    rayHit hit;\n    hit.incoming = dirV;\n    hit.sphere = sp;\n\n    float t = dot(sp.pos - o, dirV);\n    vec3 p = o + dirV*t;\n    \n    float y = length(sp.pos - p);\n    \n    hit.t1 = cameraFarPlane;\n    hit.t2 = cameraFarPlane;\n    \n    if (y < sp.radius && t > 0.)//hit && in front of camera\n    {\n        float x = sqrt(sp.radius*sp.radius - y*y);\n        hit.t1 = t-x;\n        hit.t2 = t+x;\n        \n        vec3 p1 = o + dirV*hit.t1;\n        vec3 n = normalize(p1 - sp.pos);\n        hit.normal = n;\n        hit.hit = true;\n        hit.pos = o + dirV*hit.t1;\n        hit.mat = sp.mat;\n\n    }\n    else if (y < sp.radius)\n    {\n        hit.hit = false;\n        sphere nullSphere;\n        nullSphere.mat.col = vec3(0);\n        hit.sphere = nullSphere;\n    }\n    return hit;\n\n}\n\nrayHit planeRay(vec3 o, vec3 dirV, vec3 pos, vec3 normal)\n{\n    rayHit hit;\n    hit.incoming = dirV;\n    \n    float dist = abs(dot(normal, pos-o));\n    dist /= dot(dirV, -normal);\n    \n    \n    hit.t1 = cameraFarPlane;\n    hit.t2 = cameraFarPlane;\n\n    if (dist > 0.0)\n    {\n        hit.t1 = dist;\n        hit.hit = true;\n        hit.pos = o + hit.t1 * dirV;\n        hit.normal = normal;\n    }\n    \n    \n    if (length(hit.pos-pos-vec3(0, 0, 1.0)) > 4.0){\n        hit.hit = false;\n        /*hit.t1 = cameraFarPlane;\n        hit.t2 = cameraFarPlane;//*/\n    }\n    \n    return hit;\n    \n}\n\nrayHit ray(vec3 o, vec3 dirV)\n{\n\n    float time = iTime;\n    float metallic = 0.04;\n    float smoothness = 0.8;\n    \n    \n    sphere sp1;\n    sp1.pos = vec3(cos(time), 0, sin(time)); \n    sp1.radius = 1.0;\n    sp1.mat.col = vec3(0.0, 0.5, 1); \n    sp1.mat.metallic = metallic;\n    sp1.mat.smoothness = smoothness;\n    \n    sphere sp2;\n    sp2.radius = 100000.;\n    sp2.pos = vec3(0, -sp2.radius-sp1.radius*1.0, 0);\n    sp2.mat.col = vec3(0.5, 1, 0.5); \n    sp2.mat.metallic = metallic;\n    sp2.mat.smoothness = smoothness;\n    \n    sphere sp3;\n    sp3.pos = vec3(sin(time*2.0)*2.0, cos(time), 0); \n    sp3.radius = 0.5;\n    sp3.mat.col = vec3(1.0, 0.3, 0.2); \n    sp3.mat.metallic = metallic;\n    sp3.mat.smoothness = smoothness;\n    \n    \n    rayHit hits[3];\n    \n    hits[0] = sphereRay(o, dirV, sp1);\n    \n    //rayHit h2 = sphereRay(o, dirV, sp2);\n    \n    hits[2] = planeRay(o, dirV, vec3(0, -1.0, 0), vec3(0, 1, 0));\n    hits[2].mat.col = vec3(0.2, 0.7, 0.4);\n    vec3 p = hits[2].pos;\n    hits[2].mat.col *= mod(floor(p.x) + floor(p.y+0.1) + floor(p.z), 2.)*0.8 + 0.2;\n    hits[2].mat.metallic = metallic;\n    hits[2].mat.smoothness = smoothness;\n    \n    hits[1] = sphereRay(o, dirV, sp3);\n    \n    \n    \n    rayHit data;\n    data.t1 = -1.0;\n    float minDist = cameraFarPlane;\n    \n    for (int i = 0; i<3; i++){\n        if (minDist > hits[i].t1 && hits[i].hit){\n            minDist = hits[i].t1;\n            data = hits[i];\n        }\n    }\n    \n    if (data.t1 < 0.0)\n    {\n        data = hits[0];\n    }\n\n        \n    return data;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 lightDir = normalize(vec3(sin(time), 1., cos(time)));\n    \n    vec3 o = vec3(0, 0, -4);\n    //vec3 dirV = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 mouse = iMouse.z > 0.0?(iMouse.xy/iResolution.xy) * 2.0 - 1.0:vec2(0.0, -0.03);\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= mouseSensitivity*fieldOfView;    \n\n    vec2 p = (-iResolution.xy + fieldOfView*fragCoord.xy) / iResolution.y;\n    float an = mouse.x*mouseSensitivity - pi/2.0;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, (mouse.y*mouseSensitivity) +1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 dirV = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\n\n    vec3 colTotal = vec3(0.0);\n    \n    for (int i = 0; i<1; i++){\n    \n        //o is origin of ray, aka camera position\n        rayHit data;\n        \n        /*\n        Random rng = seed(seed(fragCoord), iFrame); vec3 randVec = uniform_sphere_area(rng);         \n        dirV = normalize(mix(dirV, randVec, 1.0/iResolution.x));\n        //*/\n        \n        data.incoming = dirV;\n        data.pos = o;\n        data.reflection = data.incoming;\n\n        float light;\n        rayHit lightData;\n\n    \n        vec3 energy = vec3(1.0);\n        float f = 0.0;\n        col = vec3(0);\n\n        for (int i = 0; i<DEPTH; i++)\n        {\n            data = ray(data.pos, data.reflection);       \n            data.reflection = reflect(data.incoming, data.normal);\n\n\n            lightData = ray(data.pos, lightDir);\n            light = lightData.hit?0.0:1.0;\n            light = light * max(0.0, dot(data.normal, lightDir));\n\n            f = pow(1.0-clamp(dot(data.incoming, -data.normal), 0.0, 1.0), 5.0) * (1.0-data.mat.metallic) + data.mat.metallic ;\n\n            vec3 diffuse = (data.hit?\n                data.mat.col * light * energy * (1.0-f):\n                energy * background(time, data.reflection)\n            );\n\n            energy *= f * mix(vec3(1.0), data.mat.col, data.mat.metallic);\n\n\n            col = col + diffuse;\n            if (!data.hit){ break; }\n        }\n        \n        colTotal = colTotal + col;\n    }\n    colTotal = colTotal/1.0;\n    col = colTotal;\n\n    //col = vec3(energy);\n    //col = vec3((data.hit?0:1));\n    \n    \n    \n    // uniform reinhard\n    //*\n    vec3 O = col;\n    O *= 1.5;\n    float lum = dot(O.rgb, vec3(.2126, .7152, .0722));\n    O.rgb /= lum + 1.;\n    float whiteFac = max(log2(lum) / 5.0, 0.0);\n    O = mix(O, vec3(1.0), whiteFac);\n    col = O;\n    //*/\n    \n    col = pow(col, vec3(1.0/2.2)) * 1.055 - vec3(0.055);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define DEPTH 5\n\nstruct material\n{\n    float metallic;\n    float smoothness;\n    vec3 col;\n    \n};\n\nstruct sphere\n{\n    vec3 pos;\n    float radius;\n    material mat;\n};\n\nstruct rayHit\n{\n    float t1;\n    float t2;\n    vec3 pos;\n    vec3 normal;\n    vec3 incoming;\n    vec3 reflection;\n    bool hit;\n    sphere sphere;\n    material mat;\n};\n\nfloat remap01(float a, float b, float t)\n{\n    return (t-a)/(b-a);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5)*vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\n\nconst float pi = 3.14159;\nfloat cameraFarPlane = 10000000.0;\nfloat fieldOfView = 2.;\nfloat mouseSensitivity = 2.;\n\n\n\n\n\n\n\n\n\n\n\n\n///RNG LIBRARY FROM https://www.shadertoy.com/view/ssGXDd by paniq\nuint uhash(uint a, uint b) { \n    uint x = ((a * 1597334673U) ^ (b * 3812015801U));\n#ifdef RNGL_HIGH_QUALITY\n    // from https://nullprogram.com/blog/2018/07/31/\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n#else\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n#endif\n    return x;\n}\nfloat unorm(uint n) { return float(n) * (1.0 / float(0xffffffffU)); }\n#define RNGL_HIGH_QUALITY\nstruct Random { uint s0; uint s1; };\nuint uhash(uint a, uint b);\nRandom seed(uint s) { return Random(s, uhash(0x1ef7c663u, s)); }\nRandom seed(uvec2 s) { return Random(s.y, uhash(s.x, s.y)); }\nRandom seed(Random a, uint b) { return Random(b, uhash(a.s1, b)); }\nRandom seed(Random a, uvec2 b) { return seed(a, uhash(b.x, b.y)); }\nRandom seed(Random a, uvec3 b) { return seed(a, uhash(uhash(b.x, b.y), b.z)); }\nRandom seed(Random a, uvec4 b) { return seed(a, uhash(uhash(b.x, b.y), uhash(b.z, b.w))); }\nRandom seed(uvec3 s) { return seed(seed(s.xy), s.z); }\nRandom seed(uvec4 s) { return seed(seed(s.xy), s.zw); }\nRandom seed(int s) { return seed(uint(s)); }\nRandom seed(ivec2 s) { return seed(uvec2(s)); }\nRandom seed(ivec3 s) { return seed(uvec3(s)); }\nRandom seed(ivec4 s) { return seed(uvec4(s)); }\nRandom seed(Random a, int b) { return seed(a, uint(b)); }\nRandom seed(Random a, ivec2 b) { return seed(a, uvec2(b)); }\nRandom seed(Random a, ivec3 b) { return seed(a, uvec3(b)); }\nRandom seed(Random a, ivec4 b) { return seed(a, uvec4(b)); }\nRandom seed(float s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec2 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec3 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec4 s) { return seed(floatBitsToUint(s)); }\nRandom seed(Random a, float b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec2 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec3 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec4 b) { return seed(a, floatBitsToUint(b)); }\nuint urandom(inout Random rng) {\n    uint last = rng.s1;\n    uint next = uhash(rng.s0, rng.s1);\n    rng.s0 = rng.s1; rng.s1 = next;\n    return last;\n}\nuvec2 urandom2(inout Random rng) { return uvec2(urandom(rng),urandom(rng)); }\nuvec3 urandom3(inout Random rng) { return uvec3(urandom2(rng),urandom(rng)); }\nuvec4 urandom4(inout Random rng) { return uvec4(urandom2(rng),urandom2(rng)); }\nint irandom(inout Random rng) { return int(urandom(rng)); }\nivec2 irandom2(inout Random rng) { return ivec2(urandom2(rng)); }\nivec3 irandom3(inout Random rng) { return ivec3(urandom3(rng)); }\nivec4 irandom4(inout Random rng) { return ivec4(urandom4(rng)); }\nfloat unorm(uint n);\nfloat random(inout Random rng) { return unorm(urandom(rng)); }\nvec2 random2(inout Random rng) { return vec2(random(rng),random(rng)); }\nvec3 random3(inout Random rng) { return vec3(random2(rng),random(rng)); }\nvec4 random4(inout Random rng) { return vec4(random2(rng),random2(rng)); }\nint range(inout Random rng, int mn, int mx) { return mn + (irandom(rng) % (mx - mn)); }\nivec2 range(inout Random rng, ivec2 mn, ivec2 mx) { return mn + (irandom2(rng) % (mx - mn)); }\nivec3 range(inout Random rng, ivec3 mn, ivec3 mx) { return mn + (irandom3(rng) % (mx - mn)); }\nivec4 range(inout Random rng, ivec4 mn, ivec4 mx) { return mn + (irandom4(rng) % (mx - mn)); }\nuint range(inout Random rng, uint mn, uint mx) { return mn + (urandom(rng) % (mx - mn)); }\nuvec2 range(inout Random rng, uvec2 mn, uvec2 mx) { return mn + (urandom2(rng) % (mx - mn)); }\nuvec3 range(inout Random rng, uvec3 mn, uvec3 mx) { return mn + (urandom3(rng) % (mx - mn)); }\nuvec4 range(inout Random rng, uvec4 mn, uvec4 mx) { return mn + (urandom4(rng) % (mx - mn)); }\nfloat range(inout Random rng, float mn, float mx) { float x=random(rng); return mn*(1.0-x) + mx*x; }\nvec2 range(inout Random rng, vec2 mn, vec2 mx) { vec2 x=random2(rng); return mn*(1.0-x) + mx*x; }\nvec3 range(inout Random rng, vec3 mn, vec3 mx) { vec3 x=random3(rng); return mn*(1.0-x) + mx*x; }\nvec4 range(inout Random rng, vec4 mn, vec4 mx) { vec4 x=random4(rng); return mn*(1.0-x) + mx*x; }\n\n\nvec3 uniform_sphere_area (inout Random rng) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 210, 210, 990], [992, 992, 1051, 1051, 1578], [1580, 1580, 1611, 1611, 3122], [3124, 3124, 3181, 3181, 6061]], "test": "untested"}
{"id": "ds2Xzd", "name": "cassette wall", "author": "yasuo", "description": "cassette wall", "tags": ["cineshader", "cassette"], "likes": 24, "viewed": 2188, "published": 3, "date": "1670770293", "time_retrieved": "2024-07-30T16:13:36.426813", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n#define FS 0.05 // font size\n#define FGS FS/5. // font grid size\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinderZ( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat baseBox(vec3 p, vec3 s, vec4 r){\n    float d = sdRoundedBox(p.xy,vec2(s.x,s.y),r);\n    d = max(abs(p.z)-s.z,d);\n    return d;\n}\n\nfloat charA(vec3 p){\n    vec2 prevP = p.xy;\n    float d = B(p.xy-vec2(0.0,FGS*4.),vec2(FS,FGS));\n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    p.x = abs(p.x);\n    d2 = B(p.xy-vec2(FGS*4.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    d = max(abs(p.z)-0.01,d);\n    return d;\n}\n\nfloat charB(vec3 p) {\n    vec2 prevP = p.xy;\n    p.y = abs(p.y);\n    float d = B(p.xy-vec2(0.0,FGS*4.),vec2(FS,FGS));\n    p.xy= prevP;\n    float d2 = B(p.xy-vec2(-FGS,0.0),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p.xy-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    \n    p.y = abs(p.y);\n    p.xy-=vec2(FGS*2.,FGS*2.);\n    p.xy*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    d = max(abs(p.z)-0.01,d);\n    return d;\n}\n\nfloat tapeGear(vec3 p){\n    p.xy*=Rot(radians(20.*iTime*2.));\n    p.xy = DF(p.xy,2.);\n    p.xy -= vec2(0.042);\n    float d = B(p.xy*Rot(radians(45.0)),vec2(0.008,0.01));\n    d = max(abs(p.z)-0.01,d);\n    \n    return d;\n}\n\nfloat cassette(vec3 p){\n    vec3 prevP = p;\n    float d = baseBox(p,vec3(0.49,0.28,0.03),vec4(0.03));\n    p.z = abs(p.z)-0.05;\n    p.y-=0.06;\n    float d2 = baseBox(p,vec3(0.47,0.2,0.03),vec4(0.03));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.y+=0.23;\n    d2 = sdBox(p,vec3(0.37,0.06,0.03));\n    float a = radians(15.);\n    p.x = abs(p.x)-0.35;\n    d2 = max(dot(p,vec3(cos(a),sin(a),0.0)),d2);\n    d = smin(d,d2,0.03);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    d2 = sdCappedCylinderZ(p-vec3(0.18,-0.23,0.0),0.1,0.02);\n    d = max(-d2,d);\n    d2 = sdCappedCylinderZ(p-vec3(0.27,-0.25,0.0),0.1,0.02);\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.z = abs(p.z)-0.04;\n    p.y-=0.04;\n    d2 = baseBox(p,vec3(0.25,0.07,0.03),vec4(0.07));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    d2 = sdCappedCylinderZ(p-vec3(0.18,0.04,0.0),0.1,0.06);\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.z = abs(p.z)-0.03;\n    p.y-=0.04;\n    d2 = baseBox(p,vec3(0.1,0.04,0.03),vec4(0.01));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    d2 = tapeGear((p-vec3(0.18,0.04,0.0)) * vec3(sign(prevP.x),1,1));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = charA(p-vec3(-0.36,0.15,-0.03));\n    d = min(d,d2);\n    \n    p.x*=-1.;\n    d2 = charB(p-vec3(0.36,0.15,0.03));\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    p.y-=iTime*0.3;\n    vec3 prevP = p;\n    p.x-=iTime*0.2;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,1.2)-0.6;\n    float d = cassette(p);\n    \n    p = prevP;\n    \n    p.x+=iTime*0.2;\n    p.x+=0.5;\n    p.y += 1.8;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,1.2)-0.6;\n    \n    p.xz*=Rot(radians(180.));\n    float d2 = cassette(p);\n    d = min(d,d2);\n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*occ;\n    diffCol += col*vec3(1.0,1.0,0.95)*skyDiff*occ;\n    diffCol += col*vec3(1.)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.3));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0., -2.);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float scene = mod(iTime,15.);\n        float rotY = 0.;\n        float rotX = 0.;\n        if(scene>=5. && scene<10.){\n            rotY = -20.;\n            rotX = -30.;\n        } else if(scene>=10.){\n            rotY = -20.;\n            rotX = 30.;\n        }\n        \n        ro.yz *= Rot(radians(rotY));\n        ro.xz *= Rot(radians(rotX));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2Xzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[605, 663, 706, 706, 806], [808, 866, 897, 897, 988], [990, 1050, 1105, 1105, 1262], [1264, 1322, 1375, 1375, 1486], [1488, 1488, 1526, 1526, 1621], [1623, 1623, 1643, 1643, 1904], [1906, 1906, 1927, 1927, 2369], [2371, 2371, 2394, 2394, 2591], [2593, 2593, 2616, 2616, 3910], [3912, 3912, 3934, 3934, 4314], [4316, 4316, 4374, 4374, 4641], [4643, 4643, 4667, 4667, 4868], [4870, 4870, 4912, 4912, 5107], [5109, 5150, 5199, 5199, 5493], [5495, 5495, 5552, 5552, 6087], [6089, 6089, 6148, 6148, 6211], [6213, 6213, 6270, 6270, 7305]], "test": "untested"}
{"id": "mdjSzd", "name": "Reaction Diffusion Visualizer", "author": "DigitalShadow", "description": "The result of me playing through several iterations of buffer feedback effects as a learning exercise to get acquainted with shadertoy ", "tags": ["visualizer", "reactiondiffusion", "microphone"], "likes": 7, "viewed": 355, "published": 3, "date": "1670768387", "time_retrieved": "2024-07-30T16:13:37.275544", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI2 6.28318530718\n#define M1 1597334677U\n#define M2 3812015801U\n\n//blur quality (lower is faster, higher looks better)\nconst int samples = 6;\n\n//determines blob shape\nconst float blurSize1 = 0.5;\nconst float blurSize2 = 25.0;\n\n//\nconst float clampWindow = 1.0;\n\nconst float sigma = float(samples) * 0.25;\n\n\n//Fast Hash\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\n\n\n\n//Gaussian Function\nfloat gaussian(vec2 i){\n    return exp(-0.5 * dot(i /= sigma, i)) / (PI2 * sigma * sigma);\n}\n\n\n\n//Gaussian Blur w/ alpha channel\nvec4 gaussBlur(sampler2D channel, vec2 uv, vec2 scale){\n    vec4 result = vec4(0.0);\n    vec2 d;\n    for(int i=0; i < samples * samples; i++){\n        d = vec2(i%samples, i/samples) - float(samples) / 2.0;\n        result += gaussian (d) * texture(channel, uv + scale * d);\n    }\n    return result / result.a;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //generate noise layer\n    vec3 noise = vec3(1.0,1.0,1.0) * hash(uvec2(fragCoord*iTime));\n\n    //get fft, mirrored version, and composite across the X dimension\n    float fft = texture(iChannel1,vec2(uv.x, 0.25)).r;\n    float fft2 = texture(iChannel1,vec2(1.0 - uv.x, 0.25)).r;\n    float fft3 = (fft+fft2)/2.0;\n    \n    //get waveform across the Y dimension\n    float wave = texture(iChannel1, vec2(uv.y, 0.75)).r;\n    \n    //alternate uv coordinates used to zoom and warp buffer feedback \n    vec2 uv2 = (uv - 0.5);\n    uv2 *= 0.995 * (1.0+(length(uv2/2.0) / 200.0));\n    uv2.x += 0.0001 * cos(fft3 * 100.);\n    uv2.y += 0.0001 * sin(wave * 100.);\n    uv2 = uv2 + 0.5;\n    \n    //get feedback layer\n    vec3 prev = texture(iChannel0, uv2).rgb;\n   \n    //dymamic blur radius, does most of the work for the desired reaction to sound\n    float vB = (blurSize2 / 4.0) + (2.0 * wave * wave * blurSize2) + (2.0 * fft3 * -blurSize2 * noise.r);\n    \n    //get two versions of blurred image\n    vec3 blur1 = gaussBlur(iChannel0, uv, blurSize1 / iChannelResolution[0].xy).rrr;\n    vec3 blur2 = gaussBlur(iChannel0, uv, vB / iChannelResolution[0].xy).rrr;\n    \n    //reaction diffusion acheived by subtracting heavily blurred version from lightly blurred copy\n    vec3 col = prev - (blur2 - blur1)*.5;\n    \n    //prevent value runaway\n    col = clamp(col, -clampWindow, 1.0 + clampWindow);\n    \n    //seed new noise\n    col = mix(col, noise * (fft*wave), 0.20).rrr;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 192]], "test": "untested"}
{"id": "md2Szd", "name": "neon step", "author": "jonasfrey", "description": "neon\nhttps://www.desmos.com/calculator/mjeivvpxz5?lang=de", "tags": ["neon"], "likes": 3, "viewed": 179, "published": 3, "date": "1670766618", "time_retrieved": "2024-07-30T16:13:38.118291", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( n-1., n_sharpness))*pow(2., n_sharpness);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 o_trpino = (fragCoord.xy - (iResolution.xy/2.)) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float n_dist = length(o_trpino)/0.5;\n    n_dist = fract(n_dist+iTime);\n    float n_dist_modified = f_n_inoutexp(n_dist, 2.);\n    // Output to screen\n    fragColor = vec4(n_dist_modified);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2Szd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 253], [254, 254, 311, 361, 764]], "test": "untested"}
{"id": "cdSXRd", "name": "Horn and Schunck flow estimation", "author": "Gegell", "description": "Its the method of Horn and Schunck for flow estimation. This happens between 2 frames of the input in Buffer A.\nMight need more time to fully diffuse and obtain a stable result, thus the video might need to be paused, for this system to settle.", "tags": ["global", "iterative", "opticalflow"], "likes": 9, "viewed": 328, "published": 3, "date": "1670766521", "time_retrieved": "2024-07-30T16:13:38.975000", "image_code": "/*\n * This shader tries to implement the Horn and Schunk method for global flow estimation.\n * Especially it tries to minimize following energy functional:\n *\n *   E(u, v) = ∫_Ω (f_x u + f_y v + f_t)^2 + α (|∇u|^2 + |∇v|^2) dx dy\n *                 `----- data term -----´   `--- smoothness ---´\n *\n * Where the variable assignments are as follows:\n *   - Ω the image domain\n *   - f_x, f_y, f_t the spatial and temporal derivatives of the image grayscale values\n *   - u, v the flow amount in x and y direction\n *   - α the smoothness regularisation parameter\n *\n * From this functional the following Euler-Lagrange equations are derived:\n *\n *   2 f_x (f_x u + f_y v + f_t) - α Δ u = 0\n *   2 f_y (f_x u + f_y v + f_t) - α Δ v = 0\n *\n * These are then discretized and solved for iteratively with the Jacobi method.\n * This solves a matrix A by decomposing it to A = D-N, which means that for Ax = b\n * we obtain the iterative step:\n *\n *   x = D^-1 (b + Nx)\n *\n * Here D are the diagonal entries, and N is the rest. This method is especially suited\n * for sparse matrices and parallel computation. (Which both applies here).\n * To find the fully employed method in this shader, see Buffer C.\n */\n \n/*\n * The shader is structured as follows:\n * - Common     Defines some of the parameters regarding RENDERING and flow COMPUTATION.\n * - Buffer A   Contains the current input frame.\n * - Buffer B   Contains a snapshot of Buffer A taken at a set interval (see common tab).\n * - Buffer C   Iteratively computes the minimizing flow.\n * - Image      Contains various rendering methods for the computed flow.\n *\n * To actually see a complete solution, the solver needs a lot of iterations (~10 000)\n * Thus it's advisable to pause the input video in Buffer A to obtain a pair of images\n * for which the full flow is then computed.\n */\n\n#define PI 3.1415926\n#define TAU (PI*2.)\n\nvec3 hue(float h)\t{\n    h = fract(h);\n    float r = abs(h * 6. - 3.) - 1.;\n    float g = 2. - abs(h * 6. - 2.);\n    float b = 2. - abs(h * 6. - 4.);\n    return clamp(vec3(r, g, b), 0., 1.);\n}\n\nvec4 HSVtoRGB(vec3 hsv) {\n    return vec4(((hue(hsv.x) - 1.) * hsv.y + 1.) * hsv.z, 1.);\n}\n\nvec3 dirToHSV(vec2 dir) {\n    return vec3(atan(dir.y, dir.x) / TAU, 1., min(length(dir) * HSV_BACKDROP_BRIGHTNESS_SCALE * FLOW_SCALE, 1.));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 renderFlowArrows(vec2 fragCoord) {    \n    vec2 cellID = floor(fragCoord / ARROW_GRID_SPACE) * ARROW_GRID_SPACE;\n    vec2 cellPos = fragCoord - cellID - ARROW_GRID_SPACE / 2.;\n    \n    \n    // Sample at the center of the cell and render a line pointing in the direction of the flow\n    vec2 cellFlow = texelFetch(iChannel0, ivec2(cellID), 0).xy * ARROW_GRID_SCALE * FLOW_SCALE;\n    cellFlow /= max(length(cellFlow), 1.);\n    float d = sdSegment(cellPos, vec2(0.), cellFlow * ARROW_GRID_SPACE / 2.1) - ARROW_GRID_THICKNESS;\n\n    float mask = smoothstep(-.7, .7, -d);\n    return vec4(vec3(1.), mask);\n}\n\nvec4 renderMouseFlowLine(vec2 fragCoord) {\n    vec2 oldPos = iMouse.xy;\n    float d = 1e20;\n    vec3 col = vec3(1);\n    for (int i = 0; i < 20; i++) {\n        vec2 flow = texelFetch(iChannel0, ivec2(oldPos), 0).xy;\n        vec2 _step = flow / max(length(flow), 1.0) * MOUSE_FLOW_LINE_STEP_SIZE;\n        vec2 newPos = oldPos + _step;\n        float newD = sdSegment(fragCoord, oldPos, newPos) - MOUSE_ARROW_THICKNESS;\n        if (newD < d) {\n            d = newD;\n            col = HSVtoRGB(dirToHSV(flow / FLOW_SCALE)).rgb;\n        }\n        oldPos = newPos;\n    }\n    float mask = smoothstep(-.7, .7, -d + 1.0);\n    float colMask = smoothstep(-.7, .7, -d);\n    col = mix(vec3(0), col, colMask);\n    return vec4(col, mask);\n}\n\nvec4 renderMovedImage(vec2 fragCoord) {\n    // Actually move the source image according to the computed flow field\n    vec2 flow = texelFetch(iChannel0, ivec2(fragCoord), 0).xy * FLOW_SCALE;\n    \n    float t1 = fract(iTime * DEFORMATION_SPEED);\n    vec2 sourcePoint1 = fragCoord - t1 * flow;\n    vec4 c1 = texture(iChannel1, sourcePoint1 / iResolution.xy);\n    \n    float t2 = fract(iTime * DEFORMATION_SPEED + 0.5);\n    vec2 sourcePoint2 = fragCoord - t2 * flow;\n    vec4 c2 = texture(iChannel1, sourcePoint2 / iResolution.xy);\n    \n    float alpha1 = smoothstep(0.1, 0.4, abs(t1 - 0.5));\n    float alpha2 = smoothstep(0.1, 0.4, abs(t2 - 0.5));\n    \n    float alpha = alpha1 / (alpha1 + alpha2);\n    return mix(c1, c2, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Render the flow direction as HSV color\n    vec2 flow = texture(iChannel0, uv).xy;\n    vec3 hsv = dirToHSV(flow);\n    fragColor = HSVtoRGB(hsv);\n    \n    // Render the original image animated along flow\n    vec4 movedImage = renderMovedImage(fragCoord);\n    fragColor = movedImage;\n    \n    // Render composite of direction as HSV and animated image\n    hsv = vec3(hsv.x, .6 *hsv.z, luminance(movedImage.rgb));\n    fragColor = HSVtoRGB(hsv);\n    \n    // Direction line grid\n    vec4 lines = renderFlowArrows(fragCoord);\n    fragColor.rgb = mix(fragColor.rgb, lines.rgb, lines.a);\n    \n    // Flow at mouse location\n    vec4 mouseLine = renderMouseFlowLine(fragCoord);\n    fragColor.rgb = mix(fragColor.rgb, mouseLine.rgb, mouseLine.a);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if (all(equal(ivec2(fragCoord), ivec2(0, 0)))) {\n        fragColor = vec4(iChannelTime[0], 0., 0., 1.);\n    }\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 metadata = texelFetch(iChannel1, ivec2(0,0), 0);\n    vec4 metadataNew = texelFetch(iChannel0, ivec2(0,0), 0);\n\n    float currentTime = metadataNew.x;\n    float lastSnapshotTime = metadata.x;\n    \n    if (currentTime > lastSnapshotTime + TIME_BETWEEN_SNAPSHOTS || currentTime == 0.0) {\n        if (all(equal(ivec2(fragCoord), ivec2(0, 0)))) {\n            fragColor = vec4(currentTime, 0., 0., 1.);\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec3 sampleFlow(ivec2 coord) {\n    if (   any(lessThan(coord, ivec2(0))) \n        || any(greaterThan(coord, ivec2(iResolution.xy)))\n        ) {\n        return vec3(0.);\n    }\n    return vec3(texelFetch(iChannel2, coord, 0).rg, 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipos = ivec2(fragCoord);\n\n    // Sample from both the A and B buffer to get a frame delta\n    vec4 colNow = texelFetch(iChannel0, ipos, 0);\n    vec4 colPrev = texelFetch(iChannel1, ipos, 0);\n    \n    vec4 metadataNow = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 metadataPrev = texelFetch(iChannel1, ivec2(0,0), 0);\n    \n    vec3 gradient = vec3(\n        dFdx(luminance(colNow.rgb)),\n        dFdy(luminance(colPrev.rgb)),\n         (luminance(colNow.rgb) - luminance(colPrev.rgb)) / (metadataNow.x - metadataPrev.x)\n    );\n    \n    vec3 flowNeighbors = vec3(0.);\n    flowNeighbors += sampleFlow(ipos + ivec2( 0, -1));\n    flowNeighbors += sampleFlow(ipos + ivec2( 0,  1));\n    flowNeighbors += sampleFlow(ipos + ivec2( 1,  0));\n    flowNeighbors += sampleFlow(ipos + ivec2(-1,  0));\n    \n    vec2 curFlow = sampleFlow(ipos).xy;\n    \n    vec2 newFlow = vec2(\n        - gradient.x * (gradient.y * curFlow.y + gradient.z) + SMOOTHNESS_REGULARISATION * flowNeighbors.x,\n        - gradient.y * (gradient.x * curFlow.x + gradient.z) + SMOOTHNESS_REGULARISATION * flowNeighbors.y\n    ) / vec2(\n        gradient.x * gradient.x + SMOOTHNESS_REGULARISATION * flowNeighbors.z,\n        gradient.y * gradient.y + SMOOTHNESS_REGULARISATION * flowNeighbors.z\n    );\n    \n    if (metadataNow.x == metadataPrev.x) {\n        fragColor = vec4(0.);\n    } else {\n        fragColor = vec4(newFlow, 0., 0.);\n    }\n}\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * COMPUTATIONAL SETTINGS\n */\n\n// How much to punish non smooth areas in the energy functional\n#define SMOOTHNESS_REGULARISATION 5.0\n\n// The maximum time between the input video time and the time of the taken snapshot\n#define TIME_BETWEEN_SNAPSHOTS 1.0\n\n/*\n * RENDER SETTINGS\n */\n\n// How much to globally scale the flow vector before rendering\n#define FLOW_SCALE 20.\n\n// How many pixels between the arrows in the grid view\n#define ARROW_GRID_SPACE 20.\n#define ARROW_GRID_THICKNESS 0.7\n#define ARROW_GRID_SCALE 1.\n\n// Settings for the arrow attached to the mouse\n#define MOUSE_ARROW_THICKNESS 0.7\n#define MOUSE_FLOW_LINE_STEP_SIZE 10.0\n\n// Backdrop settings\n#define HSV_BACKDROP_BRIGHTNESS_SCALE 1.\n#define DEFORMATION_SPEED .1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Shared code\nfloat luminance(vec3 col) {\n    return sqrt(dot(vec3(0.299, 0.587, 0.114), col * col));\n}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1889, 1889, 1908, 1908, 2080], [2082, 2082, 2107, 2107, 2172], [2174, 2174, 2199, 2199, 2315], [2317, 2317, 2369, 2369, 2488], [2490, 2490, 2529, 2529, 3095], [3097, 3097, 3139, 3139, 3821], [3823, 3823, 3862, 3937, 4552], [4554, 4554, 4611, 4661, 5450]], "test": "untested"}
{"id": "mdjXRd", "name": "Neon Squircles [262 chars]", "author": "kishimisu", "description": "Squircles are a mix between a square and a circle.\nSuper simple to do in shaders : length(u) is a circle, length(u*u) is a squircle.", "tags": ["animation", "code", "squircle", "golf", "golfing"], "likes": 63, "viewed": 1712, "published": 3, "date": "1670763675", "time_retrieved": "2024-07-30T16:13:39.855645", "image_code": "/* \"Neon Squircles\" by @kishimisu (2022) - https://www.shadertoy.com/view/mdjXRd\n   [262 chars]\n   \n   No raymarching this time as I wanted to stay\n   below 300 chars, I tried to reduce the number\n   of instructions to the minimum to avoid having\n   a body with brackets in the for loop.\n   \n   The layout of the code was inspired by @Xor's \n   codegolfing shaders: for(..; ..; O.rgb += *magic*); \n*/\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2 r = iResolution.xy, u = (F+F-r)/r.y;    \n    O.rgb*=0.;\n    \n    for (float i; i<20.; O.rgb +=\n    .004/(abs(length(u*u)-i*.04)+.005)                   // shape distance\n    * (cos(i+vec3(0,1,2))+1.)                            // color\n    * smoothstep(.35,.4,abs(abs(mod(iTime,2.)-i*.1)-1.)) // animation\n    ) u*=mat2(cos((iTime+i++)*.03 + vec4(0,33,11,0)));   // rotation\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 401, 437, 437, 823]], "test": "untested"}
{"id": "ds2XRt", "name": "Reflective hexes", "author": "mrange", "description": "CC0: Reflective hexes\nBit of weekend tinkering\nSome shadow artefacts which are irritating but felt it was overall good enough to share.\n", "tags": ["raymarching", "hex"], "likes": 79, "viewed": 1116, "published": 3, "date": "1670756075", "time_retrieved": "2024-07-30T16:13:40.660493", "image_code": "// CC0: Reflective hexes\n//  Bit of weekend tinkering\n//  Some shadow artefacts which are irritating but felt it was overall good enough to share.\n\n#define TIME                iTime\n#define RESOLUTION          iResolution\n\n#define PI                  3.141592654\n#define TAU                 (2.0*PI)\n\n#define TOLERANCE           0.0001\n#define MAX_RAY_LENGTH      24.0\n#define MAX_RAY_MARCHES     60\n#define MAX_SHADOW_MARCHES  20\n#define NORM_OFF            0.001\n#define ROT(a)              mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.0;\nconst float stepf     = 0.8;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 sunCol1    = HSV2RGB(vec3(hoff+0.60, 0.50, 0.5));\nconst vec3 sunCol2    = HSV2RGB(vec3(hoff+0.05, 0.75, 25.0));\nconst vec3 diffCol    = HSV2RGB(vec3(hoff+0.60, 0.75, 0.25));\nconst vec3 sunDir1    = normalize(vec3(3., 3.0, -7.0));\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat hexPrism(vec3 p, vec2 h) {\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat df(vec3 p) {\n  vec3 p0 = p.zyx;\n  p0.xy -= 0.1*TIME;\n  vec2 n0 = hextile(p0.yx);\n  float pp = n0.x-0.25*n0.y-0.5*TIME;\n  p0.z  += 0.2*sin(pp);\n  p0.zy *= ROT(-0.2*cos(pp));\n  return hexPrism(p0, vec2(0.425, 0.25))-0.075; \n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float initt) {\n  float t = initt;\n  const float tol = TOLERANCE;\n  vec2 dti = vec2(1e10,0.0);\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; ++i) {\n    float d = df(ro + rd*t);\n    if (d<dti.x) { dti=vec2(d,t); }\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) {\n      break;\n    }\n    t += stepf*d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; };\n  return t;\n}\n\nfloat softShadow(vec3 ps, vec3 ld, float mint, float k) {\n  float res = 1.0;\n  float t = mint*3.0;\n  for (int i=0; i<MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = df(p);\n    res = min(res, k*d/t);\n    if (res < TOLERANCE) break;\n    \n    t += max(d, mint);\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  float sd = max(dot(sunDir1, rd), 0.0);\n  float sf = 1.0001-sd;\n  col += 0.5*skyCol*pow((1.0-abs(rd.y)), 8.0);\n  col += sunCol1*pow(sd, 100.0);\n  col += sunCol2*pow(sd, 800.0);\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  float initt = -(ro.x-2.0/3.0)/rd.x;\n  float t = rayMarch(ro, rd, initt);\n  vec3 p = ro+rd*t;\n  vec3 n = normal(p);\n  vec3 r = reflect(rd, n);\n  vec3 ld = sunDir1;\n  const float soff = 0.0001;\n  float sd = softShadow(p+soff*n, ld, 0.0125, 3.0);\n  float dif = max(dot(ld, n), 0.0);\n  dif *= dif;\n  dif *= dif;\n  vec3 rcol = render0(p, r);\n  vec3 col = vec3(0.0);\n  if (t < MAX_RAY_LENGTH) {\n    col = diffCol;\n    col *= mix(0.2, 1.0, dif);\n    col *= mix(0.2, 1.0, abs(sd));\n    col += rcol*sd;\n  }\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  const vec3 ro = .66*vec3(5.0, -1., 1.3);\n//  const vec3 ro = 0.8*vec3(5.0, 0.0, 0.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = normalize(vec3(0.0, 1.0, 0.3));\n  const vec3 ww = normalize(la - ro);\n  const vec3 uu = normalize(cross(up, ww));\n  const vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(1.5, 0.75, length(pp));\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2XRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[684, 684, 706, 706, 852], [1509, 1609, 1628, 1628, 1715], [1717, 1824, 1850, 1850, 2034], [2036, 2129, 2171, 2171, 2218], [2220, 2338, 2365, 2365, 2441], [2443, 2544, 2572, 2671, 2998], [3000, 3093, 3125, 3125, 3408], [3410, 3410, 3428, 3428, 3639], [3641, 3641, 3664, 3664, 3872], [3874, 3874, 3921, 3921, 4261], [4263, 4263, 4320, 4320, 4575], [4577, 4577, 4609, 4609, 5199], [5201, 5201, 5232, 5232, 5748], [5750, 5750, 5771, 5771, 6192], [6194, 6194, 6251, 6251, 6528]], "test": "untested"}
{"id": "Dd2Xzd", "name": "Primary rendering", "author": "CodeJUN", "description": "日常练习", "tags": ["rendering", "softsgadow"], "likes": 4, "viewed": 156, "published": 3, "date": "1670750546", "time_retrieved": "2024-07-30T16:13:41.494264", "image_code": "#define TMIN 0.1\n#define TMAX 150.\n#define RAYMARCH_TIME 128\n#define PRECISION .001\n#define AA 3\n#define PI 3.14159265\n\nvec2 fixUV(in vec2 c)\n{\n    return(2.*c-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n}\n\nfloat sdfSphere(in vec3 p)//球体\n{\n    return length(p) - .8 ;\n}\n\nfloat sdfRect(in vec3 p, in vec3 b)//方形\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,-.2))+min(max(d.x,max(d.y,d.z)),0.);//奇奇怪怪的\n\n}\n\nfloat sdfPlane(in vec3 p)\n{\n    return p.y;    \n}\n\nfloat map(in vec3 p)//合并\n{\n    float d=sdfSphere(p);\n    d =min(d,sdfPlane(p+vec3(0.,1.,0.)));\n    /*float h=sdfRect(p,vec3(0.));\n    d =min(d,sdfPlane(p+vec3(0.,1.,0.))+(h,sdfRect(p,vec3(1.))));*/\n  \n    return d;\n\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd)//射线方向和源头\n{\n    float t=TMIN;\n    for(int i=0;i<RAYMARCH_TIME &&t<TMAX;i++)\n    {\n        vec3 p=ro+t*rd;\n        //float d=sdfSphere(p);//输出球体\n        //float d=sdfRect(p,vec3(.8+.1*sin(iTime),.3+.2*cos(iTime),.3));//输出方形\n        float d=map(p);\n        if(d<PRECISION)\n        {\n            //return t;\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p)//光照\n{\n    const float h=0.0001;;\n    const vec2 k= vec2 (1,-1);\n  /* return normalize(k.xyy * sdfSphere(p + k.xyy * h) +\n        k.yyx * sdfSphere(p + k.yyx * h) +\n        k.yxy * sdfSphere(p + k.yxy * h) +\n        k.xxx * sdfSphere(p + k.xxx * h));*/ \n     return normalize(k.xyy * map(p + k.xyy * h) +\n        k.yyx * map(p + k.yyx * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.xxx * map(p + k.xxx * h));\n}\n\nmat3 setCamera(vec3 ta,vec3 ro,float cr)//摄像机围绕球体旋转\n{\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr) , cos(cr),0.);\n    vec3 x= normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro,in vec3 rd,float k)//软阴影\n{\n    float res=1.0;\n    float ph=1e20;\n    for(float t=TMIN;t<TMAX;)\n    {\n        \n        float h =map(ro+rd*t);\n        if(h<.01)\n            return 0.0;\n        float y =h*h/(2.0*ph);\n        float d=sqrt(h*h-y*y);\n        res=min(res,k*d/max(0.0,t-y));\n        ph=h;\n        t+=h;\n    }\n    return res;\n}\n\nvec3 render(vec2 uv )\n{\n    vec3 color =vec3(.05);//背景颜色\n    vec3 ro =vec3 (2.*cos(iTime),1.,2.*sin(iTime));//球体旋转\n    if(iMouse.z>0.001)//鼠标控制\n    {\n        float theta=iMouse.x/iResolution.x*2.*PI;\n        ro=vec3(2.*cos(theta),1.+0.2*cos(iTime),2.*sin(theta));\n    }\n    vec3 ta=vec3(0.);//摄像机位置\n    mat3 cam=setCamera(ta,ro,.1*sin(iTime));//摄像机运动\n    vec3 rd =normalize(cam*vec3 (uv,1.));//球体大小\n    float t=rayMarch(ro,rd);\n    if(t<TMAX)\n    {\n        vec3 p=ro+t*rd;\n        vec3 n= calcNormal(p);\n        vec3 light =vec3 (2.*cos(iTime),2.,2.*sin(iTime+2.));//光线移动\n        //vec3 light =vec3 (2.,2.,2.);\n       \n        float dif=clamp(dot(normalize(light-p),n),0.,1.);\n        p+=PRECISION*n;\n       // float st = softShadow(p,normalize(light-p),2.);//明显交界线\n        \n        dif *=softShadow(p,normalize(light-p),2.);//光线平滑\n       /*float st=rayMarch(p,normalize(light-p));\n        if(st<TMAX)//假阴影\n        {\n            dif*=.1; \n        }*/\n\n        float amd=0.5+0.5*dot(n,vec3(0.,1.,0));//环境灯光亮度\n\n        color=amd*vec3(0.05)+dif*vec3(.6);\n\n    }\n    return sqrt(color);//幂\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec3 color=vec3(0.);\n    for(int m =0;m<AA;m++)\n    {\n        for(int n=0; n<AA;n++)\n        {\n            vec2 offset=2.*(vec2(float(m),float(n))/float(AA)-0.5);\n            vec2 uv = fixUV(fragCoord+offset);\n            color += render(uv);\n        }\n    }\n    fragColor=vec4(color/float(AA*AA),1.);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2Xzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 143, 143, 212], [214, 214, 250, 250, 280], [282, 282, 327, 327, 429], [431, 431, 458, 458, 480], [482, 482, 512, 512, 703], [705, 705, 768, 768, 1144], [1146, 1192, 1228, 1228, 1639], [1641, 1641, 1712, 1712, 1867], [1869, 1914, 1974, 1974, 2283], [2285, 2285, 2308, 2308, 3471], [3473, 3473, 3527, 3527, 3835]], "test": "untested"}
{"id": "Ds2XRV", "name": "Superposition Weave WFC", "author": "fenix", "description": "Wave function collapse-like shader of an abstract weave pattern. The blurry tiles show all the remaining possible matches given the existing neighbors, superimposed.\n\n*mouse camera*\n*key up/down zoom* \n*space to reset*", "tags": ["wfc", "wavefunctioncollapse"], "likes": 17, "viewed": 300, "published": 3, "date": "1670746113", "time_retrieved": "2024-07-30T16:13:42.444723", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another in my series trying to do something similar to the \"simple tiled model\" of \n//  Wave Function Collapse:\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                     https://shadertoy.com/view/ds2XzD\n//      Raymarched Circuit Board WFC      https://shadertoy.com/view/mdjSDz\n//\n//  Both renderer and solver should be much more optimized in this version! On the render\n//  side, I converted to a traditional sprite drawing method following 4rknova's\n//\n//      Sprite Encoding Tutorial          https://www.shadertoy.com/view/XtlGzN\n//\n//  This allows the rendering of the \"superposition\" tiles, which show all the remaining\n//  tile choices for that square, superimposed. On the down side I lost smooth zooming and\n//  scrolling. You can still zoom by powers of 2 using the up and down arrow keys,\n//  which I tried to make less jarring with a fade transition.\n//\n//  The solver now computes and records the remaining possible values for each square,\n//  which is like the \"entropy\" of the original WFC, I think. Actual tile placement choices\n//  are not that different from before, but they no longer use arrays, compressing the\n//  data into bitfields in uvec4s instead. Array usage was also removed from all tile\n//  shape and rendering lookups which was a huge speedup.\n//\n//  Note that none of my WFC shaders are true implementations of Wave Function Collapse.\n//  My excuse is that some of the steps in the the original version, such as serially\n//  collapsing tiles in order of \"minimal nonzero entropy\", are not practial on shadertoy,\n//  and my shaders are attempting to emulate the functionality within the constraints\n//  given. Specifically, I feel like the relaxation that is done inside of \"real\" WFC is\n//  comparable in some way to the random backtracking walks.\n//\n//  But, this new shader, which tracks the \"entropy\" in Buffer A, I feel gets a bit closer\n//  than the previous ones. I was particularly trying to get a similar effect as you see\n//  in the original WFC videos where the tiles get less blurry as they collapse. It mostly\n//  works, but clearly I'm still getting much less efficient transfer of entropy across\n//  tiles. I did some experiments trying to look at neighboring tiles that had not fully,\n//  collapsed yet, but it was really slow and didn't seem to help convergence much. But\n//  maybe I just need to try harder.\n//  \n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// color palette\nvec3 subtileColor(uint value)\n{\n    if (value == 0u) return vec3(.25,.3,.25);\n    if (value == 1u) return vec3(.0,.3,.2);\n    if (value == 2u) return vec3(.25,.15,.0);\n    /*if (value == 3u)*/ return vec3(.3,.0,.2);\n}\n\n// From 4rknova's Sprite Encoding Tutorial: https://www.shadertoy.com/view/XtlGzN\n#define Q(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n#define START vec2 gv = floor(p); int y=int(7.-gv.y);float m=0.\n#define END return subtileColor(uint(mod(m/pow(4.,gv.x),4.)))\n\n// cell sprites\nvec3 spEmpty(vec2 p)\n{\n    return subtileColor(0u);\n}\n\nvec3 spOpen(vec2 p)\n{\n    return subtileColor(0u);\n}\n\nvec3 spAS(vec2 p)\n{\n    START;\n    Q(0, _,B,A,A,A,A,B,_)\n    Q(1, _,B,A,A,A,A,B,_)\n    Q(2, _,B,A,A,A,A,B,_)\n    Q(3, _,B,A,A,A,A,B,_)\n    Q(4, _,B,A,A,A,A,B,_)\n    Q(5, _,B,A,A,A,A,B,_)\n    Q(6, _,B,A,A,A,A,B,_)\n    Q(7, _,B,A,A,A,A,B,_)\n    END;\n}\n\nvec3 spAC(vec2 p)\n{\n    START;\n    Q(0, _,B,A,A,A,A,B,_)\n    Q(1, _,B,A,A,A,A,A,B)\n    Q(2, _,B,A,A,A,A,A,A)\n    Q(3, _,B,A,A,A,A,A,A)\n    Q(4, _,_,B,A,A,A,A,A)\n    Q(5, _,_,_,B,A,A,A,A)\n    Q(6, _,_,_,_,B,B,B,B)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spAE(vec2 p)\n{\n    START;\n    Q(0, _,_,B,B,B,B,_,_)\n    Q(1, _,B,A,A,A,A,B,_)\n    Q(2, _,B,A,B,B,A,B,_)\n    Q(3, _,B,A,B,B,A,B,_)\n    Q(4, _,B,A,A,A,A,B,_)\n    Q(5, _,_,B,B,B,B,_,_)\n    Q(6, _,_,_,_,_,_,_,_)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spBS(vec2 p)\n{\n    START;\n    Q(0, _,C,B,B,B,B,C,_)\n    Q(1, _,C,B,B,B,B,C,_)\n    Q(2, _,C,B,B,B,B,C,_)\n    Q(3, _,C,B,B,B,B,C,_)\n    Q(4, _,C,B,B,B,B,C,_)\n    Q(5, _,C,B,B,B,B,C,_)\n    Q(6, _,C,B,B,B,B,C,_)\n    Q(7, _,C,B,B,B,B,C,_)\n    END;\n}\n\nvec3 spBC(vec2 p)\n{\n    START;\n    Q(0, _,C,B,B,B,B,C,_)\n    Q(1, _,C,B,B,B,B,B,C)\n    Q(2, _,C,B,B,B,B,B,B)\n    Q(3, _,C,B,B,B,B,B,B)\n    Q(4, _,_,C,B,B,B,B,B)\n    Q(5, _,_,_,C,B,B,B,B)\n    Q(6, _,_,_,_,C,C,C,C)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spBE(vec2 p)\n{\n    START;\n    Q(0, _,_,C,C,C,C,_,_)\n    Q(1, _,C,B,B,B,B,C,_)\n    Q(2, _,C,B,C,C,B,C,_)\n    Q(3, _,C,B,C,C,B,C,_)\n    Q(4, _,C,B,B,B,B,C,_)\n    Q(5, _,_,C,C,C,C,_,_)\n    Q(6, _,_,_,_,_,_,_,_)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spCS(vec2 p)\n{\n    START;\n    Q(0, _,A,C,C,C,C,A,_)\n    Q(1, _,A,C,C,C,C,A,_)\n    Q(2, _,A,C,C,C,C,A,_)\n    Q(3, _,A,C,C,C,C,A,_)\n    Q(4, _,A,C,C,C,C,A,_)\n    Q(5, _,A,C,C,C,C,A,_)\n    Q(6, _,A,C,C,C,C,A,_)\n    Q(7, _,A,C,C,C,C,A,_)\n    END;\n}\n\nvec3 spCC(vec2 p)\n{\n    START;\n    Q(0, _,A,C,C,C,C,A,_)\n    Q(1, _,A,C,C,C,C,C,A)\n    Q(2, _,A,C,C,C,C,C,C)\n    Q(3, _,A,C,C,C,C,C,C)\n    Q(4, _,_,A,C,C,C,C,C)\n    Q(5, _,_,_,A,C,C,C,C)\n    Q(6, _,_,_,_,A,A,A,A)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spCE(vec2 p)\n{\n    START;\n    Q(0, _,_,A,A,A,A,_,_)\n    Q(1, _,A,C,C,C,C,A,_)\n    Q(2, _,A,C,A,A,C,A,_)\n    Q(3, _,A,C,A,A,C,A,_)\n    Q(4, _,A,C,C,C,C,A,_)\n    Q(5, _,_,A,A,A,A,_,_)\n    Q(6, _,_,_,_,_,_,_,_)\n    Q(7, _,_,_,_,_,_,_,_)\n    END;\n}\n\nvec3 spAxB(vec2 p)\n{\n    START;\n    Q(0, _,B,A,A,A,A,B,_)\n    Q(1, _,B,A,A,A,A,B,_)\n    Q(2, C,B,A,A,A,A,B,C)\n    Q(3, B,B,A,A,A,A,B,B)\n    Q(4, B,B,A,A,A,A,B,B)\n    Q(5, C,B,A,A,A,A,B,C)\n    Q(6, _,B,A,A,A,A,B,_)\n    Q(7, _,B,A,A,A,A,B,_)\n    END;\n}\n\nvec3 spBxC(vec2 p)\n{\n    START;\n    Q(0, _,C,B,B,B,B,C,_)\n    Q(1, _,C,B,B,B,B,C,_)\n    Q(2, A,C,B,B,B,B,C,A)\n    Q(3, C,C,B,B,B,B,C,C)\n    Q(4, C,C,B,B,B,B,C,C)\n    Q(5, A,C,B,B,B,B,C,A)\n    Q(6, _,C,B,B,B,B,C,_)\n    Q(7, _,C,B,B,B,B,C,_)\n    END;\n}\n\nvec3 spCxA(vec2 p)\n{\n    START;\n    Q(0, _,A,C,C,C,C,A,_)\n    Q(1, _,A,C,C,C,C,A,_)\n    Q(2, B,A,C,C,C,C,A,B)\n    Q(3, A,A,C,C,C,C,A,A)\n    Q(4, A,A,C,C,C,C,A,A)\n    Q(5, B,A,C,C,C,C,A,B)\n    Q(6, _,A,C,C,C,C,A,_)\n    Q(7, _,A,C,C,C,C,A,_)\n    END;\n}\n\nvec3 spCell(vec2 p, int type)\n{\n    if (type == EMPTY) return spEmpty(p);\n    if (type == OPEN)  return spOpen(p);\n    if (type == AS)    return spAS(p);\n    if (type == AC)    return spAC(p);\n    if (type == AE)    return spAE(p);\n    if (type == BS)    return spBS(p);\n    if (type == BC)    return spBC(p);\n    if (type == BE)    return spBE(p);\n    if (type == CS)    return spCS(p);\n    if (type == CC)    return spCC(p);\n    if (type == CE)    return spCE(p);\n    if (type == AxB)   return spAxB(p);\n    if (type == BxC)   return spBxC(p);\n    /*if (type == CxA)*/ return spCxA(p);\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\nvec4 render( vec2 u, fxState state, float zoom )\n{\n    u = (u - .5 * iResolution.xy) * zoom + state.center * iResolution.y + .5 * iResolution.xy;\n    vec2 p = fract(u) * 8.;\n    \n    if (u.x < 1. ||\n        u.x >= iResolution.x - 1. ||\n        u.y < 1. ||\n        u.y >= iResolution.y - 1.) return vec4(subtileColor(0u), 1);\n\n    uvec4 valid = floatBitsToUint(texelFetch(iChannel0, ivec2(u), 0));\n    if (valid == uvec4(0)) return vec4(subtileColor(0u), 1);\n    \n    vec4 c = vec4(0);\n    for (int rot = 0; DONT_UNROLL && rot < 4; ++rot)\n    {\n        uint bit = 1u;\n        for (int type = 0; DONT_UNROLL && type < NUM_TILES; ++type)\n        {\n            if ((valid[rot] & bit) != 0u)\n            {\n                c += vec4(spCell(rot90(p,rot), type), 1);\n            }\n            bit <<= 1;\n        }\n    }\n\n    return c / c.a;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState state = fxGetState();\n    if (state.zoomFade > 0.)\n    {\n        vec4 c = render(u, state, state.zoom);\n        vec4 n = render(u, state, state.nextZoom);\n        O = mix(n, c, state.zoomFade);\n    }\n    else\n        O = render(u, state, state.zoom);\n        \n    O = sqrt(O);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\nconst int EMPTY = 0;\nconst int OPEN = 1;\nconst int AS = 2;\nconst int AC = 3;\nconst int AE = 4;\nconst int BS = 5;\nconst int BC = 6;\nconst int BE = 7;\nconst int CS = 8;\nconst int CC = 9;\nconst int CE = 10;\nconst int AxB = 11;\nconst int BxC = 12;\nconst int CxA = 13;\nconst int NUM_TILES = 14;\n\n#define _ 0. // Color Palette Index 0\n#define A 1. // Color Palette Index 1\n#define B 2. // Color Palette Index 2\n#define C 3. // Color Palette Index 3\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    vec2 center;\n    float resolution;\n    float zoom;\n    float nextZoom;\n    float zoomFade;\n    float time;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.center = data0.xy;\n    state.resolution = data0.z;\n    state.attract = data0.w != 0.;\n    state.zoom = data1.x;\n    state.time = data1.y;\n    state.nextZoom = data1.z;\n    state.zoomFade = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.center, state.resolution, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.zoom, state.time, state.nextZoom, state.zoomFade);\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(_,_,_,\n         _,_,_,\n         _,_,_);\n         \nconst mat3 S_OPEN =\n    mat3(_,_,_,\n         _,_,_,\n         _,_,_);\n         \nconst mat3 S_AS =\n    mat3(_,A,_,\n         _,A,_,\n         _,A,_);\n                \nconst mat3 S_AC =\n    mat3(_,A,_,\n         _,A,A,\n         _,_,_);\n               \nconst mat3 S_AE =\n    mat3(_,A,_,\n         _,A,_,\n         _,_,_);\n               \nconst mat3 S_BS =\n    mat3(_,B,_,\n         _,B,_,\n         _,B,_);\n                \nconst mat3 S_BC =\n    mat3(_,B,_,\n         _,B,B,\n         _,_,_);\n                \nconst mat3 S_BE =\n    mat3(_,B,_,\n         _,B,_,\n         _,_,_);\n                \nconst mat3 S_CS =\n    mat3(_,C,_,\n         _,C,_,\n         _,C,_);\n                \nconst mat3 S_CC =\n    mat3(_,C,_,\n         _,C,C,\n         _,_,_);\n                \nconst mat3 S_CE =\n    mat3(_,C,_,\n         _,C,_,\n         _,_,_);\n                \nconst mat3 S_AxB =\n    mat3(_,A,_,\n         B,A,B,\n         _,A,_);\n                \nconst mat3 S_BxC =\n    mat3(_,B,_,\n         C,B,C,\n         _,B,_);\n                \nconst mat3 S_CxA =\n    mat3(_,C,_,\n         A,C,A,\n         _,C,_);\n                                \nmat3 shCell(int type)\n{\n    if (type == EMPTY) return S_EMPTY;\n    if (type == OPEN)  return S_OPEN;\n    if (type == AS)    return S_AS;\n    if (type == AC)    return S_AC;\n    if (type == AE)    return S_AE;\n    if (type == BS)    return S_BS;\n    if (type == BC)    return S_BC;\n    if (type == BE)    return S_BE;\n    if (type == CS)    return S_CS;\n    if (type == CC)    return S_CC;\n    if (type == CE)    return S_CE;\n    if (type == AxB)   return S_AxB;\n    if (type == BxC)   return S_BxC;\n    /*if (type == CxA)*/ return S_CxA;\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY) return 0.;\n    if (type == OPEN)  return 1.;\n    if (type == AS)    return .7;\n    if (type == AC)    return .2;\n    if (type == AE)    return .05;\n    if (type == BS)    return .7;\n    if (type == BC)    return .2;\n    if (type == BE)    return .05;\n    if (type == CS)    return .7;\n    if (type == CC)    return .2;\n    if (type == CE)    return .05;\n    if (type == AxB)   return 1.;\n    if (type == BxC)   return 1.;\n    /*if (type == CxA)*/ return 1.;\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == OPEN || type == AS || type == BS || type == CS;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 1u;\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            for (int d = 0; d < 4; ++d)\n            {\n                if (tilesMatch(rotShape(myShape, d), nShape))\n                {\n                    valid[(d + 4 - r) % 4] |= bit;\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, -1);\n    /*if (d == 0)*/ return ivec2(-1, 0);\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 ||\n        state.resolution < 0. ||\n        ifc.x == 0 || // establish boundary so we don't have to check during simulation\n        ifc.x == int(iResolution.x) - 1 ||\n        ifc.y == 0 ||\n        ifc.y == int(iResolution.y) - 1)\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        // seed one pixel in the middle of the field\n        if (ifc == ivec2(iResolution.xy * vec2(.280, .652))) fragColor = ubtf(uvec4(2, 0, 0, 0));\n        \n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n    \n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-6)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    const float START_ZOOM = 1./128.;\n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.center = vec2(0);\n        state.resolution = -iResolution.x * iResolution.y;\n        state.nextZoom = state.zoom = START_ZOOM;\n        state.time = 0.;\n        state.zoomFade = 0.;\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        state.time += iTimeDelta;\n        if (state.zoomFade > 0.)\n        {\n            state.zoomFade -= iTimeDelta;\n            if (state.zoomFade < 0.)\n            {\n                state.zoomFade = 0.;\n                state.zoom = state.nextZoom;\n            }\n        }\n        \n        if (iMouse.z > 0.)\n        {\n            state.attract = false;\n            state.center = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n        }\n        \n        if (keyClick(KEY_UP))\n        {\n            state.nextZoom = min(state.nextZoom, state.zoom) * .5;\n            state.zoomFade = 1.;\n            state.attract = false;\n        }\n        if (keyClick(KEY_DOWN))\n        {\n            state.nextZoom = max(state.nextZoom, state.zoom) * 2.;\n            state.nextZoom = min(1., state.nextZoom);\n            state.zoomFade = 1.;\n            state.attract = false;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(state.time*.005 - 1.2), cos(state.time*.005 - 1.2));\n            float zoom = pow(.5, floor(5. - mod(state.time / 4., 5.))) * 16. * START_ZOOM;\n            if (zoom != state.zoom && zoom != state.nextZoom)\n            {\n                state.nextZoom = zoom;\n                state.zoomFade = 1.;\n            }\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2XRV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3061, 3078, 3109, 3109, 3295], [3597, 3613, 3635, 3635, 3666], [3668, 3668, 3689, 3689, 3720], [6737, 6737, 6768, 6768, 7326], [7328, 7328, 7355, 7355, 7502], [7504, 7504, 7554, 7554, 8338], [8340, 8340, 8378, 8378, 8669]], "test": "untested"}
{"id": "Dd2SRt", "name": "3D aurora veins", "author": "lomateron", "description": "key W to restart\nclick to move camera\n3D version similar to https://www.shadertoy.com/view/fltGW7\n2 years ago chrome using opneGL flag was fastest\nnow chrome using direc11on12 flag is 6x faster than opneGL flag\ni dont know why\nshadertoy.com/view/cdjXWK", "tags": ["3d", "simulation", "bloom", "physics"], "likes": 25, "viewed": 455, "published": 3, "date": "1670724827", "time_retrieved": "2024-07-30T16:13:43.313401", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  u = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec3  camPos = step(iMouse.z,.5)*vec3(cos(cos(iTime*.11)*3.),cos(iTime*.7)*.3,sin(sin(iTime*.15)*3.))*3.;\n          camPos+= step(.5,iMouse.z)*vec3(cos(m.x*2.),m.y,sin(m.x*2.))*3.;\n    vec3  camDir = -normalize(camPos);\n    \n    mat3 mtx;  mtx[0] = normalize(vec3(camDir.z,0.,-camDir.x));\n               mtx[1] = cross(camDir,mtx[0]);\n               mtx[2] = camDir;\n    vec3 ray = mtx*normalize(vec3(u,2.));//direction of ray from camera\n    vec3 ray2= 1./ray;\n    vec3 ray3= step(vec3(0),ray)*2.-1.;\n    \n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3); //side length of simulationCube\n    float x3d= 2./x3;\n    float x4 = x3*2.;//max voxels the ray will transverse inside simulationCube\n    \n        vec3  inc  = step(camPos,vec3( 1))*  //inside cube\n                     step(vec3(-1),camPos);\n        vec3  tMin = (vec3(-1)-camPos)*ray2;\n        vec3  tMax = (vec3( 1)-camPos)*ray2;    ray2 = abs(ray2);\n        vec3  t1 = min(tMin, tMax);\n        vec3  t2 = max(tMin, tMax);\n        float tN = max(max(t1.x, t1.y), t1.z);//length of ray between camera and simulationCube\n        float tF = min(min(t2.x, t2.y), t2.z);\n              tF = float(tF>tN);\n              \n    vec3 p = camPos+ray*tN*(1.-inc.x*inc.y*inc.z)*1.001;//collision position of ray on simulationCube \n         p = (p*.5+.5)*x3;      //transform to voxels coordinates, range 0 to x3\n    fragColor = vec4(0);\n    for(float i=0.; i<x4; ++i)//ray will transverse simulationCube's voxels\n    {\n        vec3  g = (1.-fract(p*ray3))*ray2;\n        float l = min(min(g.x,g.y),g.z);//length to transverse one voxel\n        vec4  t = texelFetch(iChannel0, ivec2(c32(floor(p),x2,x3)), 0);//voxel value at \"p\"\n        fragColor += abs(t)*l;\n        p += ray*l;//make ray transverse one voxel\n        \n        vec3 o = abs(p*x3d-1.);\n        if(o.x>=1.||o.y>=1.||o.z>=1.){break;}//ray got out of simulationCube\n    }\n    fragColor = (fragColor*.05+fragColor.w*.006+.1)*tF;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//.xyz = new forces created in this timestep\n//.w   = empty\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3);            //side length of simulationCube\n    vec3  u3 = c23(floor(u), x2, x3);//transform 2D to 3D coordinates\n    \n    vec3  r = vec3(0);\n    vec4  t = texelFetch(iChannel0, ivec2(u), 0);//value of voxel of simulationCube\n    float z = 2.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n    for(float k=-z; k<=z; ++k){\n        vec3  ijk = vec3(i,j,k);\n        float l   = length(ijk);\n        if((i==0.&&j==0.&&k==0.) || l>z-.1){continue;}\n        vec3  um = mod(u3+ijk,vec3(x3));//make 3D space wrap around\n              um = floor(um);           //floor() makes c32() compute correctly\n        vec4  t2 = texelFetch(iChannel0, ivec2(c32(um,x2,x3)), 0);//value of neighbor voxel of simulationCube\n        float t3 = length(t2.xyz)-length(t.xyz);//amount of velocity in neighbor voxel - my voxel\n        r += ijk/l*t3*exp(-dot(ijk,ijk)*.3);//create velocity pointing to bigger neighbor velocity\n    }}}\n    fragColor = vec4(r,0)*-.04;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//.xyz = computed NewVelocity\n//.w   = value to normalize translated 2D gaussianFunction\n//normalized 2D gaussianFunction is used in BufferC to\n//translate velocity and mass in the direction of NewVelocity\nvoid mainImage(out vec4 fragColor, in vec2 u)\n{\n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3);            //side length of simulationCube\n    vec3  u3 = c23(floor(u), x2, x3);//transform 2D to 3D coordinates\n\n    vec3 m = +texelFetch(iChannel0, ivec2(u), 0).xyz  //velocity from previous frame\n             +texelFetch(iChannel1, ivec2(u), 0).xyz; //velocity created this frame\n    float s = 0.;//value to normalize translated 2D gaussianFunction\n    float z = 4.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n    for(float k=-z; k<=z; ++k){\n        vec3 ijk = vec3(i,j,k);\n        if(length(ijk)>z-.1){continue;}\n        vec3 c = m+ijk;      //translate 2D gaussianFunction by \"m\"\n        s += exp(-dot(c,c)); //add 2D gaussianFunction\n    }}}\n    if(s!=0.){s = 1./s;}//avoid division by zero\n    fragColor = vec4(m,s);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//.xyz = velocity after translating it in the direction of velocity\n//.w   = mass     after translating it in the direction of velocity\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float x2 = iResolution.x;\n    float x3 = iResolution.x*iResolution.y+.001;\n          x3 = pow(x3,1./3.);\n          x3 = floor(x3);            //side length of simulationCube\n    vec3  u3 = c23(floor(u), x2, x3);//transform 2D to 3D coordinates\n\n    fragColor = vec4(0);\n    float z = 4.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n    for(float k=-z; k<=z; ++k){\n        vec3 ijk = vec3(i,j,k);\n        if(length(ijk)>z-.1){continue;}\n        vec3  um = mod(u3+ijk,vec3(x3));//make 3D space wrap around\n              um = floor(um);           //floor() makes c32() compute correctly\n        ivec2 u2 = ivec2(c32(um,x2,x3));\n        vec4  t = texelFetch(iChannel0, u2, 0);\n        vec4  m = texelFetch(iChannel1, u2, 0);\n        vec3  c = m.xyz-ijk;\n        float w = m.w*exp(-dot(c,c));\n        fragColor.xyz += w*m.xyz;\n        fragColor.w   += w*t.w;\n    }}}\n    float keyW = texture(iChannel2, vec2(87.5/256.,.25)).x;\n    if(iFrame==0||keyW>0.)//reset simulationCube's voxels values if frame 0 or if pressing key W\n    {\n        vec3 uv = (floor(u3)/x3-.5)*5.;\n        fragColor = vec4(0,0,0,.1)-vec4(uv.zxy,0)*exp(-dot(uv,uv));\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 c23(vec2 u, float x2, float x3)//transform 2D to 3D coordinates\n{\n    float i = dot(u,vec2(1,x2))+.5;\n    return vec3(mod(i,x3), mod(i/x3,x3), i/(x3*x3));\n}\nvec2 c32(vec3 u, float x2, float x3)//transform 3D to 2D coordinates\n{\n    float i = dot(u,vec3(1, x3, x3*x3))+.5;\n    return vec2(mod(i,x2), i/x2);\n}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2SRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2200]], "test": "untested"}
{"id": "msSSzd", "name": "invert breakout", "author": "jonasfrey", "description": "inspired by a rocket league shader \nhttps://youtu.be/xel__eVBWy0?t=109", "tags": ["inverted"], "likes": 5, "viewed": 155, "published": 3, "date": "1670718548", "time_retrieved": "2024-07-30T16:13:44.096307", "image_code": "float f_n_rand(vec2 o){\n\n    return fract(sin(o.x*32.123+o.y*13.17+o.x*o.y)*323.231);\n}\n\n\nvec2 o_scale = vec2(0.02);\nfloat n_tau = 6.2831;\nfloat f_n_rand_interpolated(\n    vec2 fragCoord, \n    vec3 iResolution\n){\n\n\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    \n    \n    float n_col_xp1yp0 = f_n_rand(o_fragCoord_scaled_floor+vec2(1., 0.));\n    float n_col_xp0yp1 = f_n_rand(o_fragCoord_scaled_floor+vec2(0., 1.));\n    float n_col_xp0yp0 = f_n_rand(o_fragCoord_scaled_floor);\n    float n_col_xp1yp1 = f_n_rand(o_fragCoord_scaled_floor+vec2(1., 1.));\n\n    float n_mixed_xp0yp0andxp1yp0 = mix(n_col_xp0yp0, n_col_xp1yp0, o_fragCoord_scaled_fract.x);\n    float n_mixed_xp0yp1andxp1yp1 = mix(n_col_xp0yp1,n_col_xp1yp1, o_fragCoord_scaled_fract.x);\n    float n_mixed_xp0yp0andxp1yp0_and_n_mixed_xp0yp1andxp1yp1 = \n        mix(\n            n_mixed_xp0yp0andxp1yp0, \n            n_mixed_xp0yp1andxp1yp1, \n            o_fragCoord_scaled_fract.y\n        );\n    return n_mixed_xp0yp0andxp1yp0_and_n_mixed_xp0yp1andxp1yp1;\n        \n}\n\nfloat f_n_rand_interpolated_layered(\n    vec2 fragCoord, \n    vec3 iResolution\n){\n    float n_start = 1.;\n    vec2 o_freq_amp1 = vec2(\n        n_start*1., \n        n_start/1.\n    );\n    vec2 o_freq_amp2 = vec2(\n        n_start*2., \n        n_start/2.\n    );\n    vec2 o_freq_amp3 = vec2(\n        n_start*4., \n        n_start/4.\n    );\n    vec2 o_freq_amp_sum = \n        o_freq_amp1 + \n        o_freq_amp2 + \n        o_freq_amp3;\n        \n    float n_rand_interpolated1 = f_n_rand_interpolated(fragCoord*o_freq_amp1.x, iResolution)*o_freq_amp1.y;\n    float n_rand_interpolated2 = f_n_rand_interpolated(fragCoord*o_freq_amp2.x, iResolution)*o_freq_amp2.y;\n    float n_rand_interpolated3 = f_n_rand_interpolated(fragCoord*o_freq_amp3.x, iResolution)*o_freq_amp3.y;\n\n    float n_sum_rand_interpolated = \n        n_rand_interpolated1+\n        n_rand_interpolated2+\n        n_rand_interpolated3;\n    float n_rand_interpolated_layered = n_sum_rand_interpolated/o_freq_amp_sum.y;\n    return n_rand_interpolated_layered;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    \n\n\n    \n    // blur\n    // float n_sum_kernel = 0.;\n    // float n_count_kernel = 0.;\n    // vec2 o_scale_kernel = vec2(10.);\n    // for(float n_x = 0.; n_x < o_scale_kernel.x; n_x+=1.){\n    //     for(float n_y = 0.; n_y < o_scale_kernel.y; n_y+=1.){\n    //         n_sum_kernel += f_n_rand_by_fragCoord(fragCoord+vec2(n_x, n_y));\n    //         n_count_kernel += 1.;\n    //     }   \n    // }\n    // float n_sum_kernel_nor = n_sum_kernel / n_count_kernel;\n    \n\n    // float o_col = f_n_hash12(o_coo_big_flo);\n    // float o_col_xp1 = f_n_hash12(o_coo_big_flo + vec2(1,0));\n    // float o_col_mix_xp1 = mix(o_col, o_col_xp1, o_coo_big_mod.x);\n    \n    // float o_col_yp1 = f_n_hash12(o_coo_big_flo+ vec2(0, 1));\n    // float o_col_xp1_yp1 = f_n_hash12(o_coo_big_flo + vec2(1,1));\n    // float o_col_mix_yp1_xp1_yp1 = mix(o_col_yp1, o_col_xp1_yp1, o_coo_big_mod.x);\n    \n    //float o_col_mix = mix(o_col_mix_xp1, o_col_mix_yp1_xp1_yp1, o_coo_big_mod.y);\n    float n_rand_interpolated_layered = f_n_rand_interpolated_layered(fragCoord, iResolution);\n    vec2 o_delta = o_trpino-vec2(0.);\n    float n_ang = atan(o_delta.y, o_delta.x)+(n_tau/2.);\n    float n_ang_nor = n_ang / n_tau;\n    \n    float n_rnd_intrplt_lrd = f_n_rand_interpolated_layered(\n        vec2(\n            n_ang_nor*iResolution.x,\n            1.-n_ang_nor*iResolution.y+iTime*111.\n            ),\n        iResolution\n    );\n  \n    fragColor = vec4(n_rand_interpolated_layered);\n    \n    float n_dist = length(o_trpino);\n    //n_dist*= n_rand_interpolated_layered*9.;\n    //n_dist = pow(n_dist, n_rand_interpolated_layered*2.);\n    float n_speed = 0.9;\n    float n_radius = fract(iTime*n_speed);\n    n_radius = float(fract(iTime*n_speed/2.) > 0.5) - n_radius; \n    n_radius*=2.;\n    n_radius = pow(n_radius,2.);\n    n_dist = n_dist+(n_rnd_intrplt_lrd-0.5)*n_dist;\n    float n_mask = smoothstep(n_radius, n_radius+0.05, n_dist);\n    //fragColor = vec4(smoothstep(n_radius, n_radius+0.1, n_dist));\n    vec4 o_col_text =  texture(iChannel0, o_trpino_nooffset);\n    vec4 o_col_text_inverted = 1.-o_col_text;\n\n    fragColor = \n        vec4(n_mask)*o_col_text + \n        vec4(1.-n_mask)*o_col_text_inverted;\n\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 87], [139, 139, 212, 212, 1714], [1716, 1716, 1797, 1797, 2728], [2730, 2730, 2787, 2787, 5959]], "test": "untested"}
{"id": "mdjSRc", "name": "ProjectRayOnOctahedralMap", "author": "EvilRyu", "description": "Project a 3d ray to octahedral map, useful when you need to do raymarching on the octahedral map", "tags": ["projection", "octahedron", "octahedral"], "likes": 12, "viewed": 291, "published": 3, "date": "1670688021", "time_retrieved": "2024-07-30T16:13:44.962990", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A simple visualizer\n// Project a ray from world space to octahedral map, useful when you need to do raymarching on the octahedral map\n// Update: added projecting a sphere to the octahedral map\n\nvec3 gRayStart;\nvec3 gRayEnd;\n\nvec3 gSpherePos;\nfloat gSphereRadius;\n\nvoid updateRayAndSphere()\n{\n    gRayStart = vec3(-5., -1., -1.) + cos(iTime);\n    gRayEnd = vec3(5., 1., 2.) + sin(iTime);\n    \n    gSpherePos = vec3(10., .2, 1.) + sin(iTime);\n    gSphereRadius = 2.;\n}\n\n// octahedral mapping: https://jcgt.org/published/0003/02/01/\nvec2 signNotZero(vec2 v)\n{\n    return vec2(v.x >= 0. ? 1. : -1., v.y >= 0. ? 1. : -1.);\n}\n\nvec2 encodeOct(vec3 v)\n{\n    v.xy /= dot(abs(v), vec3(1));\n    if(v.z <= 0.)\n    {\n       v.xy = (1. - abs(v.yx)) * signNotZero(v.xy);\n    }\n    return v.xy;\n}\n\nvec3 decodeOct(vec2 octUv) \n{\n    vec3 v = vec3(octUv, 1.0 - dot(abs(octUv), vec2(1)));\n    if (v.z < 0.) \n    {\n        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n    }\n    return normalize(v);\n}\n\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    return mat3(r,u,f);\n}\n\nfloat deSegment(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat map(vec3 p)\n{\n    float d = deSegment(p, gRayStart, gRayEnd, 0.05);\n    d = min(d, length(p - gSpherePos) - gSphereRadius);\n    return d;\n}\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t = 0.1;\n    float d = 1e10;\n    for(int i = 0; i < 128; ++i)\n    {\n        if(d < 0.001 || t > 100.)\n            break;\n            \n        d = map(ro + t * rd);\n        t += d;\n    }\n    \n    return t;\n}\n\n// the 3d scene\nvec3 renderLeftScreen(vec2 fragCoord)\n{\n    vec3 col = vec3(0.);\n    \n    // xy: left bottom coord\n    // zw: right top coord\n    vec4 viewport;\n    //viewport.xy = vec2(0., iResolution.y/4.);\n    //viewport.zw = vec2(viewport.xy + iResolution.xy / 2.1);\n    viewport.xy = vec2(0., (iResolution.y - iResolution.x/2.1)/2.);\n    viewport.zw = vec2(viewport.xy + iResolution.xx / 2.1);\n    if(any(lessThan(fragCoord, viewport.xy)) || any(greaterThan(fragCoord, viewport.zw)))\n        return col;\n        \n    vec2 uv = (fragCoord - viewport.xy) / vec2(viewport.z - viewport.x, viewport.w - viewport.y);\n\n    vec2 p = uv * 2. - 1.;\n    p.x *= (viewport.z - viewport.x) / (viewport.w - viewport.y);\n    \n    float time = iTime * 2.;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0);\n    vec3 ta = vec3(cos(0.1*time + 7.0*mo.x), -5.*(mo.y*2. - 1.), sin(0.1*time + 7.0*mo.x) )*-3.;\n    vec3 rd = normalize(cam(ro, ta) * vec3(p.x, p.y, 2.3));\n    \n    col = texture(iChannel0, rd).rgb;\n    \n    float t = intersect(ro, rd);\n    \n    if(t < 100.)\n    {\n        col = vec3(1., 0., 0.);\n    }\n\n    return col;\n}\n\nfloat deSegment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n\treturn length(pa - ba * h);\n}\n\nvec3 addLine(vec3 acc, vec2 p, vec2 a, vec2 b, vec3 col)\n{\n    return mix(col, acc, smoothstep(0.01, 0.02, deSegment(p, a, b)));\n}\n\n\n// https://www.shadertoy.com/view/XtVcDh\nvec3 cuteSort(vec3 n)\n{\n   float a = min(min(n.x,n.y),n.z);\n   float b = max(max(n.x,n.y),n.z);\n   return vec3(a, n.x+n.y+n.z-a-b, b);\n}\n\n// 3d line projects to at most 4 segments\nvoid getRaySegments(vec3 rayOrg, vec3 rayEnd, out float rayT[5])\n{\n    vec3 rayDir = rayEnd - rayOrg;\n    float maxDist = length(rayDir);\n\n    rayDir /= maxDist;\n\n    rayT[0] = 0.;\n    rayT[4] = maxDist;\n\n    vec3 distToPlanes = rayOrg / -max(vec3(1e-5), rayDir);\n    distToPlanes = cuteSort(distToPlanes);\n\n    for(int i = 0; i < 3; ++i)\n    {\n        rayT[i + 1] = clamp(distToPlanes[i], 0., maxDist);\n    }\n}\n\n\n// the octahedral map\nvec3 renderRightScreen(vec2 fragCoord)\n{\n     vec3 col = vec3(0.);\n    \n    // xy: left bottom coord\n    // zw: right top coord\n    vec4 viewport;\n    viewport.xy = vec2(iResolution.x - iResolution.x / 2., (iResolution.y - iResolution.x/2.1)/2.);\n    viewport.zw = vec2(viewport.xy + iResolution.xx / 2.1);\n    if(any(lessThan(fragCoord, viewport.xy)) || any(greaterThan(fragCoord, viewport.zw)))\n        return col;\n        \n    vec2 uv = (fragCoord - viewport.xy) / vec2(viewport.z - viewport.x, viewport.w - viewport.y);\n\n    vec2 p = uv * 2. - 1.;\n    \n    vec3 v = decodeOct(p);\n    \n    col = texture(iChannel0, v).rgb;\n\n    // draw the boundaries of different faces\n    col = addLine(col, p, vec2(-1.,0.), vec2(1., 0.), vec3(1., .8, 0.));\n    col = addLine(col, p, vec2(0.,-1.), vec2(0., 1.), vec3(1., .8, 0.));\n    col = addLine(col, vec2(abs(p.x)-1.,1.-abs(p.y)), vec2(-1.,0.), vec2(0., 1.), vec3(1., .8, 0.));\n    \n    // project ray in world space to octahedral map\n    float rayT[5];\n    getRaySegments(gRayStart, gRayEnd, rayT);\n    \n    vec3 rayDir = normalize(gRayEnd - gRayStart);\n    \n    vec3 rayStart = gRayStart, rayEnd;\n    vec2 rayStartUv = encodeOct(normalize(gRayStart)), rayEndUv;\n    \n    for(int i = 1; i < 5; ++i)\n    {\n        rayEnd = gRayStart + rayT[i] * rayDir;\n        rayEndUv = encodeOct(normalize(rayEnd));\n    \n        col = addLine(col, p, rayStartUv, rayEndUv, vec3(1., 0., 0.));\n        \n        rayStart = rayEnd;\n        rayStartUv = rayEndUv;\n    }\n    \n    // draw the projected sphere\n    float sphereDist = length(gSpherePos);\n    if(dot(normalize(gSpherePos), v) > (sphereDist / sqrt(gSphereRadius * gSphereRadius + sphereDist * sphereDist)))\n        col = mix(col, vec3(1., 0., 1.), 1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    updateRayAndSphere();\n    \n    vec3 col = renderLeftScreen(fragCoord);\n    col += renderRightScreen(fragCoord);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjSRc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[377, 377, 404, 404, 579], [581, 643, 669, 669, 732], [734, 734, 758, 758, 893], [895, 895, 924, 924, 1094], [1097, 1097, 1125, 1125, 1261], [1263, 1263, 1313, 1313, 1421], [1423, 1423, 1442, 1442, 1568], [1570, 1570, 1605, 1605, 1822], [1824, 1840, 1879, 1879, 2958], [2960, 2960, 3001, 3001, 3119], [3121, 3121, 3179, 3179, 3251], [3254, 3295, 3318, 3318, 3431], [3433, 3475, 3541, 3541, 3886], [3889, 3911, 3951, 3951, 5665], [5667, 5667, 5724, 5724, 5878]], "test": "untested"}
{"id": "DdBSRt", "name": "last rkernel frame: ice", "author": "jonasfrey", "description": "round kernel\nuse the mouse to play around", "tags": ["ice"], "likes": 2, "viewed": 171, "published": 3, "date": "1670679012", "time_retrieved": "2024-07-30T16:13:45.737918", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat n_tau = 6.283185;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    \n    \n    vec2 o_p_mouse_data = vec2(0.0, 0.0);\n    vec2 o_trmono_delta = vec2(0.);\n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(o_trmono, 0.0, 0.0);\n    }else{\n        vec4 o_trmono_last = texture(iChannel0, o_p_mouse_data);\n        o_trmono_delta = abs(o_trmono.xy - o_trmono_last.xy);\n    }\n    \n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        o_trmono_delta = vec2(0.1);\n        float n_speed = 0.1;\n        float n_toggle = float(fract(iTime*n_speed)>0.15);\n        float n_ratio = iResolution.x / iResolution.y;\n        if(n_toggle == 0.){\n            o_trmono = vec2(-0.5-((n_ratio-1.)/2.), -.5);\n        }else{\n            o_trmono = vec2(.5+((n_ratio-1.)/2.), .5);\n        }\n\n    }\n    vec2 o_scale = vec2(0.9);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_radius_rkernel = vec2(\n        4.,\n        4.\n    );\n    \n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n\n    vec4 o_kernel_sum = vec4(0.0);\n\n    \n    int n_index_a_o_col_last_krnl = 0;\n    float n_kernel_sum_count = 0.;\n    for(float n_x = 0.0; n_x < floor(o_radius_rkernel.x/2.); n_x+=1.){\n        float n_radius = n_x;\n\n        float n_angle_step_x = n_tau / (n_tau * n_x);\n        //float n_angle_steps_y = n_tau * o_radius_rkernel.y;\n        \n        for(float n_angle = 0.0; n_angle < n_tau; n_angle+=n_angle_step_x){\n            vec2 o_p_on_kernel = vec2(\n                sin(n_angle)*n_radius,\n                cos(n_angle)*n_radius\n            );\n            vec2 o_off = vec2(\n                o_p_on_kernel.x * (1./o_iResolution_scaled_floor.x),\n                o_p_on_kernel.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_on_kernel;\n            n_kernel_sum_count+=1.;\n        }\n    }\n  \n    vec4 o_kernel_sum_nor = o_kernel_sum / n_kernel_sum_count;\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n\n            if(o_kernel_sum_nor.x>0.01){\n                fragColor = vec4(o_kernel_sum_nor.x);\n            }\n            if(o_kernel_sum_nor.x>0.2){\n                fragColor = vec4(1.-o_kernel_sum_nor.x*0.3*o_trmono.y);\n            }\n            \n            vec4 o_col_delta = o_col_last - fragColor;\n            fragColor = o_col_last - (o_col_delta * 0.2);\n            //fragColor.r = fragColor.r*0.9;\n            //fragColor.g = o_kernel_sum_nor.x*f_n_rand(n_index+iTime);\n            //fragColor.b = o_kernel_sum_nor.x*0.2;\n\n                       \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_thresh = 0.1+o_trmono_delta.x;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4((n_dist_nor*n_dist_nor*o_trmono_delta.x*f_n_rand(n_index)));\n\n    }\n\n    fragColor = (fragColor);\n    \n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(o_trmono, 0.0, 0.0);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "mdjXzc", "name": "3D Noise Visual 2", "author": "SnoopethDuckDuck", "description": "Lots of overstepping and very slow :)))\n\nIncrements ray direction in constant amounts. You can distort the ray direction as it moves which is cool", "tags": ["3d", "raymarching", "noise", "kinda"], "likes": 27, "viewed": 269, "published": 3, "date": "1670676057", "time_retrieved": "2024-07-30T16:13:46.537779", "image_code": "#define MAX_STEPS 180\n\nfloat map(vec3 p) {\n    vec3 q  = vec3(0);\n   \n    //float a = 0.1;\n    //p += mod(p + a, 2. * a) - a;\n    p *= 0.7;\n   \n    q = texture(iChannel0, 0.25 * p).rgb;\n    q = mix(q, texture(iChannel0, 0.5 * p.yzx).rgb, 0.5);\n    q = mix(q, texture(iChannel0, p.zyx).rgb, 0.25);\n    q = mix(q, texture(iChannel0, 2. * p).rgb, 0.125);\n    return clamp(q.z, 0., 1.);\n}\n\n// overstepping past edges/corners maybe inevitable\nvec4 march(vec3 ro, vec3 rd) {\t\n    float d = 0.;\n    int steps = MAX_STEPS;\n    float o = pi/3.;\n    vec3 off = thc(2., vec3(-o,0,o) + 0.15 * iTime);\n    //off = normalize(off);\n    vec3 p = ro;\n    float inc = 0.005;\n    for(int i = 0; i < MAX_STEPS; i++) {\n       p = ro + off * rd * d;\n       float dd = map(p);\n       rd = erot(rd, off, 0.01 * cos(8. * d + 0.2 * iTime));            \n       d += inc;      \n       \n       \n       if (1.5 * dd < d * (0.99 + 0.02 * hash(p.x,hash(p.y,p.z)))) {\n           steps = i;\n           //inc *= 0.8; // remove break, use linear filter\n           break;\n       }\n       //*/\n       \n       // slower but less overstepping\n       /*if (1.5 * dd < d) { \n           steps = i;\n           for (int j = 0; j < 4; j++) {\n               d -= 0.25 * inc;\n               p -= 0.25 * inc * rd;\n               dd = map(p);\n               if (1.5 * dd > d)\n                   break;\n           }\n           break;\n       }\n       //*/\n       \n    }    \n    return vec4(p, steps);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //uv = fract(2. * uv) - 0.5;\n\n    vec3 off = 0.15 * iTime * vec3(1, 0.9, 0.95);   \n    vec3 ro = 1. - off;\n    vec3 rd = dir(uv, ro, -off, 1.);\n\n    vec4 m = march(ro, rd);   \n    vec3 p = m.xyz;\n    \n    // d != distance travelled, since rd gets distorted\n    float d = length(p - ro); \n  \n    vec3 n = norm(p);\n\n    vec3 ld = normalize(vec3(1,2,3));\n    float dif = .9 + .1 * dot(n,ld);\n    \n    vec3 col = pal(0.25 + 0.4 * mlength(p), 0.5 * vec3(0,1,2)/3.);\n    // col = vec3(map(p + vec3(0,0.01,0)));\n    \n    // fog\n    // float xp = exp(.7-2.*d);\n    // xp = clamp(xp, 0., 1.);\n\n    // linear fog\n    float mx = m.w / float(MAX_STEPS);\n    mx = pow(mx, 3.);\n   \n    // using v as overstepping \"texture\", buggy\n    float v = mix(dif, 1., mx); \n    v = clamp(v, 0., 1.);       \n    col -= 0.12 * v;\n    \n    // fade to grey with fog\n    col = mix(col, vec3(.5,.5,1), mx);\n    \n    // fade to red with 1-fog (looks good without)\n    col = mix(col, vec3(1,0,0), max(0., 1.-2.*mx));\n    \n    // diffuse/shadowy stuff\n    // (this looks buggy because rays stop inside blocks, they \n    //  don't stop at the surface)\n    col *= 2. * map(p - 0.004 * rd);\n       \n    //float mx2 = pow(.5+.5*thc(4., (length(ro-p)) + pi/4.5), 64.);\n    //col = mix(col, vec3(1,0.8,1), mx2);\n    \n    // White square\n    float d2 = mlength(uv);\n    float k = 1. / iResolution.y;\n    float s2 = smoothstep(-k, k, -abs(-d2 + 0.45) + 2. * k);\n    col += tanh(.5*iTime) * .8 * s2 * smoothstep(-4.*k, 4.*k, d - 0.3);\n    \n    // gamma correction\n    col = clamp(col, 0., 1.);\n    col = pow(col, vec3(1./2.2));\t\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 384], [386, 438, 468, 468, 1450], [1452, 1452, 1496, 1496, 1687], [1689, 1689, 1708, 1708, 1882], [1884, 1884, 1941, 1941, 3628]], "test": "untested"}
{"id": "dd2SRc", "name": "last kernel frame: round kernel", "author": "jonasfrey", "description": "round kernel", "tags": ["kernel"], "likes": 3, "viewed": 126, "published": 3, "date": "1670669147", "time_retrieved": "2024-07-30T16:13:47.294755", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat n_tau = 6.283185;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    \n    \n    vec2 o_p_mouse_data = vec2(0.0, 0.0);\n    vec2 o_trmono_delta = vec2(0.);\n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(o_trmono, 0.0, 0.0);\n    }else{\n        vec4 o_trmono_last = texture(iChannel0, o_p_mouse_data);\n        o_trmono_delta = abs(o_trmono.xy - o_trmono_last.xy);\n    }\n    \n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        o_trmono_delta = vec2(0.1);\n        o_trmono = vec2(\n            sin(iTime)*0.8,\n            cos(iTime)*0.3\n        );\n    }\n    vec2 o_scale = vec2(0.9);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_radius_rkernel = vec2(\n        10.,\n        10.\n    );\n    \n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n\n    vec4 o_kernel_sum = vec4(0.0);\n\n    \n    int n_index_a_o_col_last_krnl = 0;\n    float n_kernel_sum_count = 0.;\n    for(float n_x = 0.0; n_x < floor(o_radius_rkernel.x/2.); n_x+=1.){\n        float n_radius = n_x;\n\n        float n_angle_step_x = n_tau / (n_tau * n_x);\n        //float n_angle_steps_y = n_tau * o_radius_rkernel.y;\n        \n        for(float n_angle = 0.0; n_angle < n_tau; n_angle+=n_angle_step_x){\n            vec2 o_p_on_kernel = vec2(\n                sin(n_angle)*n_radius,\n                cos(n_angle)*n_radius\n            );\n            vec2 o_off = vec2(\n                o_p_on_kernel.x * (1./o_iResolution_scaled_floor.x),\n                o_p_on_kernel.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_on_kernel;\n            n_kernel_sum_count+=1.;\n        }\n    }\n  \n    vec4 o_kernel_sum_nor = o_kernel_sum / n_kernel_sum_count;\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n\n            if(o_kernel_sum_nor.x>0.5){\n                fragColor = vec4(o_kernel_sum_nor.x);\n            }\n            \n            vec4 o_col_delta = o_col_last - fragColor;\n            fragColor = o_col_last - (o_col_delta * o_trmono.y);\n                       \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_thresh = 0.1+o_trmono_delta.x;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4((n_dist_nor));\n\n    }\n\n    fragColor = (fragColor);\n    \n    if(ivec2(fragCoord.xy) == ivec2(o_p_mouse_data)){\n        fragColor = vec4(o_trmono, 0.0, 0.0);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2SRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "ds2SRc", "name": "Max Drekker Triangles", "author": "mrange", "description": "CC0: Max Drekker Triangles\n I liked Max's tweet: https://twitter.com/MaxDrekker/status/1601166513079484416?s=20&t=utQa4fiuhtOThlkZv7Rvig\n Simple and sweet.\n Inspired by the tweet I created this shader.", "tags": ["triangles", "twitter"], "likes": 17, "viewed": 482, "published": 3, "date": "1670667432", "time_retrieved": "2024-07-30T16:13:48.064697", "image_code": "// CC0: Max Drekker Triangles\n//  I liked Max's tweet: https://twitter.com/MaxDrekker/status/1601166513079484416?s=20&t=utQa4fiuhtOThlkZv7Rvig\n//  Simple and sweet.\n//  Inspired by the tweet I created this shader.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define LW          0.00666\n#define MOD         0.025\n#define MAX         20.0 \n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pref(inout vec2 p, vec2 r, float sm) {\n  float d = dot(p, r);\n  p -= r*pmin(0.0, d, sm)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 dtri(vec2 p) {\n  const vec2 n = SCA(PI/3.0);\n  const float sm = 0.02;\n  vec2 p0 = p;\n  p0.y = -pabs(p0.y, sm);\n  pref(p0, n, 0.5*sm);\n  float n0 = mod1(p0.x, MOD);\n  float d0 = abs(p0.x)-(LW*n0/MAX);\n  float d = d0;\n  return vec2(d, n0);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  \n  vec3 col = vec3(0.025*smoothstep(2.0, 0.25, length(p-vec2(0.0, -0.2))));\n  const mat2 r =ROT(PI/6.0);\n  p -= vec2(0.15, -0.2);\n  p *= r;\n  vec3 bcol = vec3(1.0, 0.0, 0.25);\n  const vec2 off = vec2(4.0*MOD, 0.)+vec2(0.0, MOD/3.0)*r;\n  for (int i = 0; i < 3; ++i) {\n    bcol = bcol.yzx;\n    vec2 tp = p+off*float(i);\n    \n    vec2 d2 = dtri(tp);\n    vec3 tcol = bcol;\n    tcol *= smoothstep(0.0, MAX, d2.y);\n    tcol *= step(d2.y, MAX);\n    tcol *= smoothstep(aa, -aa, d2.x);\n    col += tcol;\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, pp);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2SRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[516, 616, 655, 655, 740], [742, 742, 772, 772, 800], [802, 890, 934, 934, 1020], [1022, 1108, 1147, 1147, 1272], [1274, 1274, 1293, 1293, 1518], [1520, 1520, 1550, 1550, 2097], [2099, 2099, 2156, 2156, 2353]], "test": "untested"}
{"id": "ddjXR3", "name": "[phreax] the universe within", "author": "phreax", "description": "Inspired by my dear labradorite, which I obtained from an amazing artesanian in Mexico.\nHe told me, it would support me to focus my creativity -- well, here we are (\n\nPlay with the mouse to scrub the universe!\n\nAnti aliasing could be better..", "tags": ["raymarching", "reflection", "refraction"], "likes": 22, "viewed": 258, "published": 3, "date": "1670666177", "time_retrieved": "2024-07-30T16:13:48.996206", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n   \n   Some fusion of my previous work.\n   \n   \n   The refraction is based on https://www.shadertoy.com/view/fl23Ww\n   Which it self is based on an awesome tutorial by BigWIngs\n   \n   The spiral is from https://www.shadertoy.com/view/dslSRf\n*/\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n#define tt (iTime*.7)\n\n// reduce if too slow\n#define AA 2 \n\nfloat g_mat;\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float h21(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(53.839,144.53))) * 2341.532);\n}\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 d = abs(p) - r;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nvec3 transform(vec3 p) {\n\n    float a = PI*.5 + iTime;\n    p.xz *= rot(a);\n    p.xy *= rot(a);\n    \n    return p;\n}\n\n\nfloat cornet(vec3 p) {\n\n    p.x *= 1.23;\n    p.y -= .5;\n    p.yz *= rot(.5*PI);\n    \n    float r = 2.2;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n\n    vec2 CP = cp;\n\n    float rev = 5.5;\n    float a = atan(p.z, p.x);\n \n    cp *= rot(rev*a);\n\n    cp *= rot(.5+sin(0.2*cp.x*2.*cp.x*2.*PI));\n    cp= abs(cp) - .1 - .05*SIN(p.z*.7+p.x*.3);\n    cp *= rot(.2+sin(0.9*CP.x*2.*PI)+.3*tt);\n    cp= abs(cp) - .1;\n    cp *= rot(.4);\n    \n    float ri = .01+0.04*SIN(CP.x*2.);\n   \n    return rect(cp.xy, vec2(ri), 0.01)*.8;\n}\n\nvec3 transformGem(vec3 p) {\n    p.y -= .5;\n    p.z -= .9;\n    p.x *= 1.23;\n    p.z *= 1.5;\n    p.xz *= rot(-sin(tt)*.2);\n    \n    return p;\n}\n\nfloat gem(vec3 p) {\n\n    p = transformGem(p);\n    float d = length(p) -2.1;\n    return d*.8;\n}\n\nfloat map(vec3 p) {\n\n    vec3 bp = p;\n    p *= 1.1;\n   \n    float gem = gem(p);\n     p.xz *= rot(-sin(tt)*.2);\n    float corn = cornet(p);\n    \n    \n    g_mat = gem < corn ? 0. : 1.;\n    \n    p = bp;\n    p.z -= 5.;\n    float bg = box(p, vec3(10, 10, .1));\n\n    \n    float d = min(gem, corn);\n    \n    g_mat = bg < d ? 2. : g_mat;\n    \n    d = min(d, bg)*.9;\n    return d;\n    \n}\n\n// used for reflection\nfloat rayMarchGem(vec3 ro, vec3 rd, out vec3 p) {\n    float i, t, d = 0.1;\n    p = ro;\n  \n    for(i=0.; i<100.; i++) {\n        d = -gem(p);\n        \n        if(abs(d) < 0.001 || t > 2.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    return d;\n\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.0035, -0.0035);\n \n    vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                        e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n    return n;\n}\n\nvec3 refractCol(vec3 p, vec3 rd, vec3 n, float ior) {\n\n        vec3 rdIn = refract(rd, n, 1./ior);\n        \n        vec3 pEnter = p - n * 0.003;\n        \n        vec3 pExit;\n       \n        float dIn = rayMarchGem(pEnter, rdIn, pExit );\n        \n        vec3 nExit = -getNormal(pExit);\n        vec3 rdOut = refract(rdIn, nExit, ior);\n        \n        if(dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n\n        vec3 env = texture(iChannel1, rdOut).rgb;\n        return env;\n}\n\nvec3 refractRGB(vec3 p, vec3 rd, vec3 n, float ior) {\n    float roff = 0.04;\n\n    vec3 colR = refractCol(p, rd, n, ior);\n    vec3 colG = refractCol(p, rd, n, ior+roff);\n    vec3 colB = refractCol(p, rd, n, ior+2.*roff);\n\n    vec3 col;\n    col.r = colR.r;\n    col.g = colG.g;\n    col.b = colB.b;\n    return col;\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 cam(in vec3 p) {\n    p.x += .3*sin(tt);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 col;\n    vec3 totCol = vec3(0);\n    #if AA\n    for(int i=0; i < AA; i++) {\n        vec2 subPix = .4*vec2(cos(2.*PI*float(i)/float(AA)),\n                                sin(2.*PI*float(i)/float(AA)));\n\n        vec2 uv = (fragCoord+subPix-.5*iResolution.xy)/iResolution.y;\n        \n    #else\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    #endif\n    \n    //uv *= rot(-.5*PI);\n    \n    vec3 ro = vec3(0, .5, -5.1),\n         rd = normalize(vec3(uv, 1.)),\n         lp = vec3(-1., 1., -8);\n         \n    vec3 p = ro;\n \n\n    p = cam(p);\n\n    float t, d = 0.1;\n    \n    float mat = 0.;\n    \n    for(float i=.0; i<200.; i++) {\n    \n        d = map(p);\n        mat = g_mat;\n        \n        if(d < 0.001 || t > 20.) break;\n        \n        t += d;\n        p += rd*d;\n    }\n\n     \n    vec3 c1 = vec3(0.149,0.094,0.925);\n    vec3 c2 = vec3(0.141,0.678,0.718);\n\n    vec3 bg = vec3(0.043,0.247,0.298);\n    vec3 gold = vec3(0.886,0.769,0.173);\n    \n    if(d < 0.001) {\n        vec3 n = getNormal(p);\n       \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 200.);\n        \n        float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n\n        vec3 refd = reflect(rd, n) + vec3(.2, 0, 0); \n        vec3 refl = texture(iChannel0, refd).rgb;\n       \n       \n        if(mat == 0.) { // gem\n            p = transformGem(p);\n\n            col = mix(c1, .7*refl*(c2+.2), .5);\n      \n            col *= .8*(mix(1., dif, .5)+.5*sss);\n            rd.y += .5;\n           \n            vec3 refr = refractRGB(p, rd, n, 1.45);\n            \n            vec2 tuv = fragCoord.xy / iResolution.xy;\n    \n            vec3 galaxy = texture(iChannel2, (tuv)).rgb;\n             \n            col = mix(col, refr*(c2), .7);\n            col = mix(col, (refr+0.4*refl)*c1*mix(1.3, 0.1, clamp(pow(length(p.xy), 0.8), 0., 1.)), .5);\n            \n            col = mix(col, col+2.9*galaxy*mix(1.3, 0.1, clamp(pow(length(p.xy), .6), 0., 1.)), .3);\n            col += .2*spe;\n            \n        } else if(mat==1.) { // cornet\n            float shd = softshadow(p, l, 0.1, 1., 20.0);\n            col = .2*spe+ gold * refl*mix(.6, 1., shd);\n            \n        } else { // background\n            float shd = softshadow(p, l, 2., 10., 15.0);\n            col += 1.5*bg*mix(.1, 1., (1.-length(uv)));\n            col *= mix(.6, 1., shd);\n            #if AA\n            col *= 1./pow(float(AA), .45); // convert to linear\n            #endif\n        }\n    } \n    \n    #if AA\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, h21(uv)); // dithering\n    totCol += col;\n    }\n    \n    col = totCol/float(AA);\n    #else\n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, h21(uv)); // dithering\n    #endif\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU 2.*PI\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define SIN(x) (sin(x)*.5+.5)\n#define BEND .8     \n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define COUNT 50.\n#define DISTORT 2.5\n#define COLOR 1.\n#define SPIRAL 2.\n\n//#define WATERCOLOR\n//#define TUNNEL\nfloat tt;\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset) {\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n\nfloat triangle(vec2 uv, float w, float blur) {   \n  int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulate the distance\n  float d = 1.-cos(floor(.5+a/r)*r-a)*length(uv);\n  return smoothstep(blur, .0, abs(d)-w)*(0.3/blur);\n}\n\nvec3 spiral(vec2 uv, float z) {  \n\n    uv *= rot((z*TAU-.2*tt)*(SPIRAL+3.*sin(.5*PI+iMouse.y/360.*2.*PI)));\n    #ifdef TUNNEL\n    uv.y += 1.7*sin(.4*z+2.4*tt);\n    uv.x -= .9*sin(.3*z+1.8*tt);\n    #endif\n    \n    float dist = DISTORT * sin(.25*PI+iMouse.x/640.*2.*PI);\n    uv += dist*sin(vec2(5)*uv.yx+.2*tt);\n\n    float blur = exp(-19.*z);\n    float luma = exp(-18.5*z);\n    return triangle(uv, 0.05, blur)*spectral_zucconi6(fract(2.*z+.2*tt+uv.x*.2))*luma*.8;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec4 tex = texture(iChannel0, fragCoord/iResolution.xy);\n    if (tex.a != iResolution.x) tex = vec4(0);\n    \n    tt = iTime*.2;\n    uv *= 100.;\n\n    float s = 1./COUNT;\n    \n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        float fade = smoothstep(1., .9, z);\n        vec2 UV = uv;\n        col += spiral(UV*z, z)*fade; \n    }\n    \n    col = pow(col, vec3(0.5));\n    #ifdef WATERCOLOR\n    col = 1.05-col;\n    col = pow(col, vec3(2.2));\n    col = clamp(col, vec3(0), vec3(1));\n    #endif\n    col = mix(col, tex.rgb, 0.98);\n    \n   \n   \n    // Output to screen\n    fragColor = vec4(col, iResolution.x);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjXR3.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[610, 610, 629, 629, 677], [679, 679, 718, 718, 811], [813, 813, 840, 840, 941], [944, 944, 968, 968, 1059], [1062, 1062, 1084, 1084, 1574], [1576, 1576, 1603, 1603, 1717], [1719, 1719, 1738, 1738, 1813], [1815, 1815, 1834, 1834, 2193], [2195, 2218, 2267, 2267, 2483], [2485, 2485, 2509, 2509, 2695], [2697, 2697, 2750, 2750, 3179], [3181, 3181, 3234, 3234, 3493], [3495, 3506, 3583, 3583, 3909], [3911, 3911, 3932, 3932, 3971]], "test": "untested"}
{"id": "csjSz3", "name": "Dark mode truchet tiling", "author": "fishy", "description": "I did something. Looks pretty good in my opinion", "tags": ["truchet"], "likes": 4, "viewed": 163, "published": 3, "date": "1670632155", "time_retrieved": "2024-07-30T16:13:49.751188", "image_code": "#define SCALE 10.\n#define FLIP_CHANCE 0.5\n#define COLOR_A vec3(0.3, 0.3, 0.5)*0.3\n#define COLOR_B vec3(0.3, 0.3, 0.5)\n\nfloat hash21(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat tile(vec2 p, float thickness, float aa)\n{\n    float d = abs(abs(p.x+p.y)-0.5);\n    return smoothstep(aa*-0.5, aa*0.5, (d-thickness));\n}\n\nmat2 rotMat(float t) { return mat2(cos(t), -sin(t), sin(t), cos(t)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord-iResolution.xy*0.5)/iResolution.y)*rotMat(iTime*0.1)+iTime*vec2(0.2, 0.1);\n    float aa = 2.5/iResolution.y;\n    \n    vec2 suv = fract(uv*SCALE)-0.5;\n    vec2 id = floor(uv*SCALE);\n    if(hash21(id+floor(iTime*0.5+id.x*0.02))<FLIP_CHANCE) suv.x = -suv.x;\n\n    // Output to screen\n    fragColor = vec4(mix(COLOR_A, COLOR_B, vec3(tile(suv, 0.4, aa*SCALE))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjSz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 141, 141, 260], [262, 262, 309, 309, 403], [405, 405, 427, 427, 475], [477, 477, 534, 584, 974]], "test": "untested"}
{"id": "Dd2XR3", "name": "led screen #3 bayer pattern", "author": "jonasfrey", "description": "led", "tags": ["led"], "likes": 8, "viewed": 209, "published": 3, "date": "1670630869", "time_retrieved": "2024-07-30T16:13:50.516143", "image_code": "\nfloat f_n_limited(\n    float n_min, \n    float n_max, \n    float n\n){\n    return \n        max(min(n_min,n_max), min(max(n_min, n_max),n));\n}\nfloat f_n_limited2(\n    float n_min, \n    float n_max, \n    float n\n){\n    float n_tmp = n_min;\n    n_min = min(n_min,n_max);\n    n_max = max(n_max, n_tmp);\n    if(n < n_min) return 0.;\n    if(n < n_max) return n ;\n    if(n > n_max) return 1.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n\n    vec2 o_scale = vec2(0.01);\n    float n_divisions = 10.;\n    float n_scale = floor(o_trpino_nooffset.x*n_divisions)/n_divisions;\n    //n_scale = n_scale * 0.1;\n    //o_scale = vec2(0.01+n_scale);\n    if(iMouse.z == 0.0){\n        o_trmono_nooffset = vec2(sin(iTime), cos(iTime*0.2)*0.2+0.2);\n    }\n    o_scale= vec2(o_trmono_nooffset.y);\n    if(o_trpino.x > o_trmono.x){\n        o_scale= vec2(0.1);\n    }\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    vec2 o_trpino_nooffset_scaledfloor = (o_fragCoord_scaled_floor.xy)/ o_iResolution_scaled_floor.xy;\n\n    \n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    vec4 o_col = texture(iChannel0, o_trpino_nooffset_scaledfloor);\n    float n_radius = length(vec2(0.5)-o_fragCoord_scaled_fract);\n    n_radius *=2.;\n    n_radius = pow(n_radius,5.);\n    float b_ymod2 = mod(o_fragCoord_scaled_floor.y, 2.);\n    float b_xmod2 = mod(o_fragCoord_scaled_floor.x, 2.);\n\n    float n_r = float(b_ymod2 == 0. && b_xmod2 == 0.);\n    float n_g = float(b_ymod2 == 0. && b_xmod2 == 1. || b_ymod2 == 1. && b_xmod2 == 0.);\n    float n_b = float(b_ymod2 == 1. && b_xmod2 == 1.);\n\n    \n    //n_radius = f_n_limited2(0.4, 0.8, n_radius);\n    vec4 o_col_mixed = mix(o_col, vec4(0.), n_radius);\n    fragColor = o_col*vec4(\n        n_r, \n        n_g/2.,\n        n_b,\n        1.\n    );\n    fragColor = sqrt(fragColor);\n    //fragColor = vec4(n_radius);\n\n\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2XR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 70, 70, 141], [142, 142, 212, 212, 387], [388, 388, 445, 445, 2731]], "test": "untested"}
{"id": "csjXR3", "name": "led screen #2", "author": "jonasfrey", "description": "led", "tags": ["led"], "likes": 8, "viewed": 219, "published": 3, "date": "1670629796", "time_retrieved": "2024-07-30T16:13:51.330964", "image_code": "\nfloat f_n_limited(\n    float n_min, \n    float n_max, \n    float n\n){\n    return \n        max(min(n_min,n_max), min(max(n_min, n_max),n));\n}\nfloat f_n_limited2(\n    float n_min, \n    float n_max, \n    float n\n){\n    float n_tmp = n_min;\n    n_min = min(n_min,n_max);\n    n_max = max(n_max, n_tmp);\n    if(n < n_min) return 0.;\n    if(n < n_max) return n ;\n    if(n > n_max) return 1.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    vec2 o_scale = vec2(0.01);\n    o_scale = vec2(0.1);\n\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    vec2 o_trpino_nooffset_scaledfloor = (o_fragCoord_scaled_floor.xy)/ o_iResolution_scaled_floor.xy;\n\n    \n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    vec4 o_col = texture(iChannel0, o_trpino_nooffset_scaledfloor);\n    float n_radius = length(vec2(0.5)-o_fragCoord_scaled_fract);\n    n_radius *=2.;\n    n_radius = pow(n_radius,5.);\n    //n_radius = f_n_limited2(0.4, 0.8, n_radius);\n    vec4 o_col_mixed = mix(o_col, vec4(0.), n_radius);\n    fragColor = o_col_mixed;\n    //fragColor = vec4(n_radius);\n\n\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 70, 70, 141], [142, 142, 212, 212, 387], [388, 388, 445, 445, 1906]], "test": "untested"}
{"id": "cdjXR3", "name": "led screen #1", "author": "jonasfrey", "description": "led", "tags": ["led"], "likes": 2, "viewed": 154, "published": 3, "date": "1670627534", "time_retrieved": "2024-07-30T16:13:52.092927", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    vec2 o_scale = vec2(0.1);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    vec2 o_trpino_nooffset_scaledfloor = (o_fragCoord_scaled_floor.xy)/ o_iResolution_scaled_floor.xy;\n\n    \n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    vec4 o_col = texture(iChannel0, o_trpino_nooffset_scaledfloor);\n    float n_radius = length(vec2(0.5)-o_fragCoord_scaled_fract);\n    vec4 o_col_mixed = mix(o_col, vec4(0.), n_radius);\n    fragColor = o_col_mixed;\n\n\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1355]], "test": "untested"}
{"id": "ddBSRc", "name": "Pixelated Transition v2", "author": "animtor120", "description": "fork of https://www.shadertoy.com/view/4tfBR8 with some better annotated controls", "tags": ["squares"], "likes": 2, "viewed": 169, "published": 3, "date": "1670616449", "time_retrieved": "2024-07-30T16:13:52.867854", "image_code": "\n\n//const float amt = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    float squares = 36.;\n    float speed = 1.2;\n    vec2 tc = uv;\n    float m = .9;\n    // move texcoords to center\n    tc -= 0.5;\n    \n    // adjust for perfect circle\n    tc.x *= aspect;    \n    \n    // pixellate\n    tc = floor(tc * squares + 0.5) / squares;\n    \n    // create the circle mask\n    float mask = mod(length(tc), m);\n\n    // mod the mask so that we get alternating rings\n    mask =  mod(mask - iTime*speed, 2.0);\n    \n    // step the mask to threshold it to black and white\n    mask = step(mask, 1.0);\n    \n    vec2 ttc = uv;\n  \tttc.x *= aspect;\n    //ttc = ttc * 2.0 - 1.0;\n    //vec2 tile = mod( ttc * squares - vec2(aspect*2.0,0.5) , 1.0) *amt;\n    \n\t//tile = tile *0.5 + 0.5;\n    \n    //uv = uv + tile;\n    // sample textures and choose mask\n\tfragColor =mix(texture(iChannel0, uv ), texture(iChannel1, uv), mask);\n\n}\n\n\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBSRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 1014]], "test": "untested"}
{"id": "Ds2Xzm", "name": "Codevember #25 Random Spiral 5", "author": "Etidou", "description": "Day 25 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["spiral", "random", "codevember"], "likes": 2, "viewed": 163, "published": 3, "date": "1670573113", "time_retrieved": "2024-07-30T16:13:53.682677", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\n\nuniform float u_time;\n\nfloat SEGMENT_TIME = 4.0;\n\nconst float PI = 3.1415926535;\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nfloat segmentAngle;\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(.3+a/v)*v-a)*r;\n    return final;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    vec2 rot = rotate(uv, PI + (u_time * 0.075));\n    uv = rot;    \n    \n    float radius = length(uv - 0.5);\n\n    float poly = polySDFScale(\n        uv,\n        vec2(2.7),\n        8\n    ); \n\n    float segmentAngle = ((PI + 40.0) / SEGMENT_TIME);\n\n    poly -= segmentAngle + floor((cos(iTime) + poly) - segmentAngle);\n\n    poly = min(-poly, segmentAngle * poly);\n\n    vec2 st = vec2(sin((cos(-poly / -iTime), sin(poly + iTime)) + radius * segmentAngle))  ;\n\n    st = max(min(st, 3.0 * st), st);\n\n    vec3 color = vec3(0.0, cos(sin(-iTime) / -st));\n\n    float len = length(uv - 0.5);\n\n    color.r += sin(len * 40.0 + poly * 4.0 * sin((iTime / 5.0)));\n    color.g = cos(len / 30.0 + poly * 6.0 * -sin((iTime / 5.0)));\n    color.b *= sin(len * 5.0 + poly * 5.0 * cos(iTime / 5.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2Xzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 287, 287, 458], [460, 460, 491, 491, 579], [581, 581, 638, 638, 1533]], "test": "untested"}
{"id": "cs2Xzm", "name": "Codevember #24 Random Spiral 4", "author": "Etidou", "description": "Day 24 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["spiral", "random", "codevember"], "likes": 2, "viewed": 144, "published": 3, "date": "1670573108", "time_retrieved": "2024-07-30T16:13:54.514452", "image_code": "float SEGMENT_TIME = 4.0;\n\nconst float PI = 3.1415926535;\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nfloat segmentAngle;\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(.3+a/v)*v-a)*r;\n    return final;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    vec2 rot = rotate(uv, PI + (iTime * 0.075));\n    uv = rot;\n\n    float radius = length(uv);\n\n    float poly = polySDFScale(\n        uv,\n        vec2(2.7),\n        6\n    ); \n    vec2 st = vec2(cos(poly + iTime), sin(poly - iTime)) * 7.3;\n\n    st = max(min(st, 2.3 / st), st - 2.0);\n\n    vec3 color = vec3(0.0, st);\n\n    float len = length(uv - 0.5);\n\n    color.r = sin(len * 40.0 + poly * 40.0 * - 0.5);\n    color.g += cos(len * 30.0 + poly * 60.0 * -sin((iTime / 15.0)));\n    color.b += sin(len * 50.0 + poly * 50.0 * -sin((iTime / 15.0)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2Xzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 190, 190, 361], [363, 363, 394, 394, 482], [484, 484, 541, 541, 1201]], "test": "untested"}
{"id": "DsjXzm", "name": "Codevember #23 Random Spiral 3", "author": "Etidou", "description": "Day 23 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["spiral", "random", "codevember"], "likes": 1, "viewed": 144, "published": 3, "date": "1670573104", "time_retrieved": "2024-07-30T16:13:55.342239", "image_code": "float SEGMENT_TIME = 4.0;\n\nconst float PI = 3.1415926535;\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nfloat segmentAngle;\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(.3+a/v)*v-a)*r;\n    return final;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    vec2 rot = rotate(uv, PI + (iTime * 0.075));\n    uv = rot;\n\n    float radius = length(uv);\n\n    float poly = polySDFScale(\n        uv,\n        vec2(2.7),\n        7\n    ); \n    vec2 st = vec2(cos(poly + iTime), sin(poly - iTime)) * radius;\n\n    st = max(min(st, 2.3 / st), st - 2.0);\n\n    vec3 color = vec3(0.0, st);\n\n    float len = length(uv - 0.5);\n\n    color.r = sin(len * 40.0 + poly * 40.0 * - 0.5);\n    color.g += cos(len * 30.0 + poly * 60.0 * -sin((iTime / 5.0)));\n    color.b += sin(len * 50.0 + poly * 50.0 * -sin((iTime / 5.0)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 190, 190, 361], [363, 363, 394, 394, 482], [484, 484, 541, 541, 1202]], "test": "untested"}
{"id": "csjXzm", "name": "Codevember #22 Random Spiral 2", "author": "Etidou", "description": "Day 22 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["spiral", "random", "codevember"], "likes": 2, "viewed": 136, "published": 3, "date": "1670573100", "time_retrieved": "2024-07-30T16:13:56.484186", "image_code": "float SEGMENT_TIME = 4.0;\n\nconst float PI = 3.1415926535;\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nfloat segmentAngle;\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(3.3+a/v)*v-a)*r;\n    return final;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    vec2 rot = rotate(uv, PI + (iTime * 0.075));\n    uv = rot;\n\n    float radius = length(uv);\n\n    vec2 st = vec2(cos(7.0 / 360.0 + iTime), sin(7.0 / 360.0 - iTime)) * radius;\n\n    st = max(min(st, 2.3 / st), st);\n\n    vec3 color = vec3(0.0, st);\n\n    float len = length(uv - 0.5);\n\n\n    float poly = polySDFScale(\n        uv,\n        vec2(2.7),\n        4\n    ); \n\n    color.r = sin(len * 40.0 + poly * 40.0 * - 0.5);\n    color.g += cos(len * 30.0 + poly * 60.0 * -sin((iTime / 2.5)));\n    color.b += sin(len * 50.0 + poly * 50.0 * -sin((iTime / 2.5)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 190, 190, 362], [364, 364, 395, 395, 483], [485, 485, 542, 542, 1213]], "test": "untested"}
{"id": "DdjXzm", "name": "Codevember #21 Random Spiral 1", "author": "Etidou", "description": "Day 21 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["spiral", "random", "codevember"], "likes": 1, "viewed": 140, "published": 3, "date": "1670573095", "time_retrieved": "2024-07-30T16:13:57.573274", "image_code": "float SEGMENT_TIME = 4.0;\n\nconst float PI = 3.1415926535;\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nfloat segmentAngle;\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(.3+a/v)*v-a)*r;\n    return final;\n}\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),\n              sin(a),cos(a))*(st-.5);\n    return st+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    vec2 rot = rotate(uv, PI + (iTime * 0.075));\n    uv = rot;\n\n    float radius = length(uv);\n\n    vec2 st = vec2(cos(7.0 / 360.0 + iTime), sin(7.0 / 360.0 - iTime)) * radius;\n\n    st = max(min(st, 2.3 / st), st);\n\n    vec3 color = vec3(0.0, st);\n\n    float len = length(uv - 0.5);\n\n\n    float poly = polySDFScale(\n        uv,\n        vec2(2.7),\n        7\n    ); \n    color.r = sin(len * 40.0 + poly * 40.0 * - 0.5);\n    color.g += cos(len * 30.0 + poly * 60.0 * -sin((iTime / 5.0)));\n    color.b += sin(len * 50.0 + poly * 50.0 * -sin((iTime / 5.0)));\n\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 190, 190, 361], [363, 363, 394, 394, 482], [484, 484, 541, 541, 1209]], "test": "untested"}
{"id": "mdjXzK", "name": "Many Sprite Particles", "author": "animtor120", "description": "Fork of https://www.shadertoy.com/view/MtXBDS. I'm a bit of a noob so I changed the syntax used in the original version to something I found more legible Also added some comments. You can get interesting new textures this way.", "tags": ["2d", "sprites", "splatting"], "likes": 2, "viewed": 212, "published": 3, "date": "1670569200", "time_retrieved": "2024-07-30T16:14:01.628431", "image_code": "// --- creates icons height + render (NB: limited overlap management ).\n\n#define SpMult .5\n//not using this\n\nvec4 getT(sampler2D tex, float y, vec2 pos){\n vec4 t = texelFetch(tex, ivec2(pos)+ivec2(0,y), 0);\n return t;\n}\n\nvec4 s(vec2 pos,float time, float xSpeed){\n  float imageSize = L*SpMult;\n  vec2 tz = (pos+imageSize)/(2.*imageSize);\n  float ttt = .2;\n  float jitterXMoveFreq = 1.;\n  float xoff = mod(floor(time),jitterXMoveFreq);\n  vec2 texCoord = tz*vec2(ttt,1)+vec2((xoff+.13*sin(time))*ttt,0);\n  //c2 texCoord = tz*vec2(40./256.,1)+vec2((mod(floor(time),1.)+.13*sin(time))*40./256.,0);\n  //vec2 texCoord = (pos+imageSize)/(2.*imageSize)*vec2(40./256.,1)+vec2((mod(floor(time),1.)+.13*sin(time))*40./256.,0);\n  //vec2 texCoord = (pos+L)/(2.*L)*vec2(40./256.,1)+vec2((mod(floor(time),1.)+.13*sin(time))*40./256.,0);\n  return texture(iChannel1, texCoord);\n  //return texture(iChannel1, (pos+L)/(2.*L)*vec2(40./256.,1)+vec2((mod(floor(time),1.)+.13*sin(time))*40./256.,0));\n}\n//(shape( vec2(T(h).y,-h), ( iTime-T(h).x)*10. ).a > 0. || iMouse.z > 0. ) // check transp for less collision\nbool optimize(sampler2D tex, float y, vec2 pos){\n    //not really sure whats going on here\n    vec2 z =  vec2(getT(tex,y, pos).y,-y);\n    float f2 = iTime-getT(tex, y, pos).x*10.;\n    vec4 sval = s(z, f2, .1);\n    return sval.a>0.;\n}\nvoid mainImage( out vec4 O,  vec2 U )\n{   \n    O -= O;\n \n    for (float y=0.; y<L; y++) {\n        vec4 t1 = getT(iChannel0, y, U);\n        //if ( T( y).x > 0. && optim( y) ) { O.xy =  T( y).xy; O.z = -y ; break; }\n        if (t1.x > 0. && optimize(iChannel0, y, U)){\n         O.xy =  t1.xy;\n         O.z = -y ;\n         break;\n        }\n        //if ( T(-y).x > 0. && optim(-y) ) { O.xy =  T(-y).xy; O.z =  y ; break; }\n        vec4 t2 = getT(iChannel0, -y, U);\n        if (t2.x > 0. && optimize(iChannel0, -y, U)){\n         O.xy =  t2.xy; \n         O.z =  y ; \n         break;\n        }\n        \n        \n    }\n    \n    O = O.x == 0. ? O-O : s(O.yz, (iTime-O.x)*10., .1 );\n    O *= O.a;\n    //uncomment to see what buffer b looks like\n    //O = texture(iChannel0, U/iResolution.xy);\n    //if (iMouse.z<=0.) O *= O.a;\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --- creates point distribution + value (used as time offset)\n\n\nfloat rand(vec2 p){\n    return( 3758.5453 * sin(dot(p, vec2(12.9898, 78.233))) );\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{  \n    vec2 seed = vec2(.1, .5);\n    float basicScatter = fract(3758.5453 * sin(dot(fragCoord, vec2(12.9898, 78.233)+seed)) );\n    float wiggle = rand(fragCoord+.5);\n    //how many sprites to scatter\n    float fillPercent = .1;\n    fragColor = vec4(basicScatter > 1.- fillPercent*.1);\n    //fragColor = vec4( rnd(fragCoord) > .998 ) *  rnd(fragCoord+.5); \n    //fragColor = vec4( basicScatter > .998 ) *  wiggle;\n}", "buffer_a_inputs": [], "buffer_b_code": "// --- creates icons width\n\n\n\n\n\nvec4 getIt(sampler2D tex, vec2 p, float x){\n    return texelFetch( tex, ivec2(p)+ivec2(x,0), 0 );\n    \n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{   \n    //fragColor -= fragColor;\n    for (float x=0.; x<L; x++) {\n        if(getIt(iChannel0, fragCoord, x).x >0.){\n            fragColor.x = getIt(iChannel0, fragCoord, x).x;\n            //O.x =  T( x).x;\n            fragColor.y = -x;\n            break;\n        }\n        if(getIt(iChannel0, fragCoord, -x).x >0.){\n            fragColor.x = getIt(iChannel0, fragCoord, -x).x;\n            //O.x =  T(-x).x;\n            fragColor.y =  x;\n            break;\n        }\n        \n        \n        //if ( T( x).x > 0. ) { O.x =  T( x).x; O.y = -x; break; }\n        //if ( T(-x).x > 0. ) { O.x =  T(-x).x; O.y =  x; break; }\n    }\n  //vec2 uv = fragCoord/iResolution.xy;\n   //fragColor= texture(iChannel0,uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define L 16.", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 153, 153, 219], [221, 221, 263, 263, 979], [980, 1090, 1138, 1180, 1323], [1324, 1324, 1363, 1363, 2143]], "test": "untested"}
{"id": "cd2Xzy", "name": "triangle-triangle point mapping", "author": "remaindeer", "description": "Click-and-drag within the middle triangle to map that point to the other triangles (https://stackoverflow.com/a/55550712).\nDoes this work for 3d? Would it then have to be a 4x4 transformation matrix?\n", "tags": ["sdf", "triangle", "random", "map", "matrix", "transform"], "likes": 8, "viewed": 202, "published": 3, "date": "1670550995", "time_retrieved": "2024-07-30T16:14:02.798303", "image_code": "const mat3 M0 = mat3(+0.00, (sqrt3 / 3.0) + 0.00, 1, +0.50, -(sqrt3 / 6.0) - 0.00, 1, -0.5, -(sqrt3 / 6.0) + 0.0, 1);\nconst mat3 M1 = mat3(-1.75, (sqrt3 / 3.0) + 0.25, 1, -1.50, -(sqrt3 / 6.0) - 0.25, 1, -1.0, -(sqrt3 / 3.0) + 0.5, 1);\nconst mat3 M2 = mat3(+1.50, (sqrt3 / 3.0) + 0.25, 1, +1.75, -(sqrt3 / 6.0) - 0.25, 1, +1.0, -(sqrt3 / 6.0) + 0.5, 1);\n\n    \nfloat scene(vec2 p, mat3 T0, mat3 T1, mat3 T2) {\n    float d = sdTriangle(p, T0[0].xy, T0[1].xy, T0[2].xy);\n    d = min(d, sdTriangle(p, T1[0].xy, T1[1].xy, T1[2].xy));\n    d = min(d, sdTriangle(p, T2[0].xy, T2[1].xy, T2[2].xy));\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // uv\n\tvec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 q = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    if (iMouse.z <= 0.0) q = vec2(0);\n    //// zoom\n    p *= 2.5;\n    q *= 2.5;\n    \n    // reposition triangles\n    mat3 T0 = mat3(rotmat2(iTime * 0.5)) * M0;\n    mat3 T1 = M1 + mat3(-mod(iTime / 8.0, 0.25), 0, 0, 0, mod(iTime / 8.0, 0.5), 0, 0, -mod(iTime / 8.0, 0.25), 0);\n    mat3 T2 = M2 + mat3(+mod(iTime / 8.0, 0.25), 0, 0, 0, -mod(iTime / 8.0, 0.5), 0, 0, -mod(iTime / 8.0, 0.25), 0);\n    \n    // dist\n    float d = scene(p, T0, T1, T2);\n    \n    // color\n    vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-24.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(240.0 * d);\n    \n    col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - q) - abs(scene(q, T0, T1, T2))) - 0.0075));\n    vec2 q1 = (T1 * inverse(T0) * vec3(q, 1)).xy;\n    col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - q1) - abs(scene(q1, T0, T1, T2))) - 0.0075));\n    vec2 q2 = (T2 * inverse(T0) * vec3(q, 1)).xy;\n    col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - q2) - abs(scene(q2, T0, T1, T2))) - 0.0075));\n    col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(sdSegment(p, q, q1)) - 0.0075));\n    col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(sdSegment(p, q, q2)) - 0.0075));\n    \n    float aa = 2.0 / iResolution.y;\n    col = max(col, rnd * smoothstep(aa, 0.0, d));\n    \n    // output\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "#define sqrt3 sqrt(3.0)\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 t0 = p  - p0, t1 = p  - p1, t2 = p  - p2;\n    vec2 pq0 = t0 - e0 * clamp(dot(t0, e0)/ dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = t1 - e1 * clamp(dot(t1, e1)/ dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = t2 - e2 * clamp(dot(t2, e2)/ dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x );\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (t0.x * e0.y - t0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (t1.x * e1.y - t1.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (t2.x * e2.y - t2.y * e2.x)));\n    return -sqrt(d.x) * sign(d.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2Xzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 408, 408, 605], [607, 607, 662, 672, 2304]], "test": "untested"}
{"id": "cd2XRV", "name": "grid wave effect", "author": "jonasfrey", "description": "template", "tags": ["template"], "likes": 7, "viewed": 391, "published": 3, "date": "1670547893", "time_retrieved": "2024-07-30T16:14:03.763722", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.xy;\n    if(iMouse.z == 0.){\n        o_trmono = vec2(0.2, 0.05);\n    }\n\n    vec2 o_scale = vec2(0.2*o_trmono.x);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    vec2 o_amp = vec2(0.2*o_trmono.y*2.);\n    vec2 o_freq = vec2(\n        //o_fragCoord_scaled_floor.y+iTime*10.,\n        //o_fragCoord_scaled_floor.x+iTime*10.\n        o_fragCoord_scaled_floor.x+iTime*10.+o_fragCoord_scaled_floor.y, \n        o_fragCoord_scaled_floor.x+iTime*10.\n    );\n    o_trpino_nooffset += vec2(\n        sin(o_freq.x),\n        cos(o_freq.y)\n    )*o_amp;\n    vec4 o_col_texture = texture(iChannel0, o_trpino_nooffset);\n    fragColor = o_col_texture;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2XRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1633]], "test": "untested"}
{"id": "csjSzK", "name": "Crude 3D Noise Visual", "author": "SnoopethDuckDuck", "description": "Explanation: \nMap 3D noise to [0,1]. \nEvery step move an amount in the ray direction proportional to the noise value at the current point. \nIf mapped value is less than a threshold, stop.\n\nOverstepping + performance cost are issues. Try nearest filter!", "tags": ["h"], "likes": 7, "viewed": 213, "published": 3, "date": "1670538892", "time_retrieved": "2024-07-30T16:14:04.637386", "image_code": "#define MAX_STEPS 500\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(1);\n    ro += 0.1 * iTime * vec3(1, 0.9, 0.95);\n    //vec3 ro = vec3(0,1,-1);\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\n// Map noise values [0,1]^3->[0,1]\nfloat map(vec3 p) {\n    float sc = 0.3;//2. - 1.7 * tanh(0.2 * iTime);\n    vec3 q = texture(iChannel0, sc * p).rgb;\n    float d = dot(q,q);\n    return d * d;\n}\n\n// Map noise values [0,1]^3->[0,1]^3 (unused)\nvec3 map2(vec3 p) {\n    vec3 q = texture(iChannel0, 0.3 * p).rgb;\n    return pow(q, vec3(4));\n}\n\n// (not traditional raymarching)\nvec2 march(vec3 ro, vec3 rd) {\t\n    float d = 0.;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n       vec3 p = ro + rd * d;\n            \n       // dd reads noise from 3D texture, value in [0,1]\n       float dd = map(p);\n\n       // hide overstepping with noise (slow)\n       // dd *= 0.9 + 0.1 * hash(p.x, hash(p.y, p.z));\n      \n       // smaller increments -> less overstepping      \n       d += 0.01 * dd;\n            \n       // maybe replace c with function based on distance from ro?\n       // if p is close to ro, set threshold to 0. idk\n       float c = .5 + .5 * thc(4., 10. * d + p.y - iTime);\n       \n       // threshold for where to draw noise\n       // (dd > 1.5), (abs(dd - 0.5)< 0.004) look cool\n       if (dd < mix(0.1, 0.18, c)) {\n           steps = i;\n           break;\n       }\n    }\n    \n    return vec2(d, steps);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();    \n    vec3 rd = dir(uv, ro, vec3(0), 1.5);\n      \n    // m.x = distance\n    // m.y = number of steps\n    vec2 m = march(ro, rd);\n    \n    vec3 p = ro + m.x * rd;\n    \n    vec3 col = vec3(.9,.1,.1);\n    \n    //float y = exp(-20.*(.5+.5*cos(80. * p.x + iTime)));    \n    vec3 col1 = vec3(1,.5,.2);\n    //vec3 col2 = clamp(col1 + y, 0., 1.);\n    //col = mix(col, col2, 1.-exp(-0.01 * m.y));\n    \n    // surface colors\n    col *= pal(map(p + 0.02) - 0.2 * iTime, 0.5 * vec3(0,1,2)/3.);\n    \n    // fog\n    col = mix(col, col1, 1.-clamp(exp(1.-1.4*m.x), 0., 1.));\n    \n    // gamma correction\n    col = pow(col, vec3(1./2.2));\t\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 35, 35, 255], [257, 292, 311, 311, 451], [453, 499, 518, 518, 594], [596, 629, 659, 659, 1483], [1485, 1485, 1529, 1529, 1720], [1722, 1722, 1779, 1779, 2524]], "test": "untested"}
{"id": "DdjSzK", "name": "Fractal Optical Illusion", "author": "SnoopethDuckDuck", "description": "I made this earlier thinking it wasn't anything special, but now I genuinely can't see how this is makes sense in 3D. Really weird!\n\nedit\n\nclick to drag the camera", "tags": ["h"], "likes": 15, "viewed": 229, "published": 3, "date": "1670537230", "time_retrieved": "2024-07-30T16:14:05.586848", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat box( vec3 p, vec3 b, float e ) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec3 ori() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\n//float mat = 1.;\nvec2 map(vec3 p) {\n    vec3 op = p;\n    p.xz *= rot(iTime);\n    float m = 0.7;\n    float o = 2.*pi/3.;\n    vec3 off = normalize(cos(vec3(-o,0,o) + iTime));\n    vec3 pl = normalize(vec3(1,2,3));\n    float d = length(p) + m;\n    for (float i = 0.; i < 6.; i++) {\n        vec3 q = p;\n        p = abs(p) - m;\n        p = erot(p, off, pi/2.);\n        d = min(d, abs(length(p) - m) + 0.01 + 0.4 * m);//, 0. * m);\n        m *= 0.25 * sqrt(2.);\n    }\n    \n    //d = min(d, abs(length(op) - 1.8) + 0.01);\n    \n    //d += 0.1;\n    //p = erot(p, (off), pi);\n    float mat = 1.; \n    float d1 = length(p.xz) - 0.1;\n    float d2 = abs(length(vec2(d1, p.y)) - 0.1) + 0.05;\n    //d2 = length(p) + 0.01;\n    d = min(d, d2);\n    return vec2(d, mat);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\t\n    float d = 0.;\n    float steps = 0.;\n    float mat = 0.;\n    float retd = 0.;\n    bool hasHit = false;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        m.x *= 0.8 + 0.2 * hash(hash(p.x,p.z), p.y); // for glow\n        steps = 0.9 * (steps + exp(-10. * m.x + 2./(1.+d)));//0.01 / (0.01 + m.x * m.x);\n        if (!hasHit && abs(m.x) < SURF_DIST) {\n            hasHit = true;\n            retd = 1.;\n        }\n        else if (d > MAX_DIST) { \n            mat = m.y;\n            break;\n        }\n        d += m.x; \n    }\n    \n    return vec3(min(d, MAX_DIST), steps, retd);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);    \n    vec3 n = d - vec3(map(p-e.xyy).x,\n                      map(p-e.yxy).x,\n                      map(p-e.yyx).x);   \n    return normalize(n);\n}\n\nvec3 dir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.015 * i;\n        float d = map(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = ori();\n    \n    vec3 rd = dir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    vec3 m = march(ro, rd);  \n    float d = m.x;\n    float mat = m.z;\n    vec3 p = ro + rd * d;\n    \n    //if (d<MAX_DIST) {        \n        vec3 n = norm(p);\n        n = normalize(n);\n        vec3 r = reflect(rd, n);        \n\n        vec3 ld = normalize(vec3(1,2,3));\n        float dif  = dot(n,  ld)*.5+.5;\n        float spec = pow(dif, 16.);\n        col = vec3(dif);   \n        \n       // col *= 1.-vec3(0, m.z, m.z);\n    //}\n\n    col = vec3(pow(0.1 * m.y, 6.));\n    col *= 200. * 15.;\n    col = clamp(col,0.,1.);\n    \n    vec3 q = ro + rd * m.z;\n    n = norm(q);\n    //dif = dot(n,  ld)*.5+.5;\n  //  if (m.z < MAX_DIST)\n  //      col = vec3(exp(-0.2*length(q)));\n   // col *= pal(p.y,vec3(0,1,2)/3.);\n    col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Thanks to (everyone I've copied code + ideas from):\n// TheArtOfCode - raymarching\n//  BlackleMori - hash, erot\n//      Sizertz - AO, shadow\n//        NuSan - materials\n//         Leon - raymarching hash trick\n//           iq - pal, smin, most things!\n\n#define tau 6.2831853071\n#define pi 3.1415926535\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define pal(a,b) .5+.5*cos(2.*pi*(a+b))\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat h21(vec2 a) { return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123); }\nfloat mlength(vec2 uv) { return max(abs(uv.x), abs(uv.y)); }\nfloat mlength(vec3 uv) { return max(max(abs(uv.x), abs(uv.y)), abs(uv.z)); }\n\n// Maybe remove this\nfloat sfloor(float a, float b) { return floor(b-.5)+.5+.5*tanh(a*(fract(b-.5)-.5))/tanh(.5*a); }\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 106, 106, 393], [395, 395, 407, 407, 556], [558, 576, 594, 594, 1310], [1312, 1312, 1342, 1342, 1969], [1971, 1971, 1990, 1990, 2188], [2190, 2190, 2234, 2234, 2425], [2427, 2427, 2459, 2459, 2694], [2696, 2696, 2734, 2734, 3077], [3079, 3079, 3136, 3136, 4088]], "test": "untested"}
{"id": "DdjXRK", "name": "Nest of Polygons", "author": "mla", "description": "Some nested 11-gons.", "tags": ["simple", "sdf", "polygon", "dihedral"], "likes": 12, "viewed": 184, "published": 3, "date": "1670536153", "time_retrieved": "2024-07-30T16:14:06.475472", "image_code": "// Nest of Polygons, mla, 2022\n\nfloat N = 11.0; // Number of sides\nfloat M = 18.0; // Radial density.\n\nconst float PI = 3.141592654;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Signed distance from p segment qr. Positive distance for\n// points on the left of the line looking from q to r.\nfloat ssegment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  k = clamp(k,0.0,1.0);\n  vec2 closestpoint = k*r;\n  float dist = distance(p,closestpoint);\n  vec2 normal = vec2(-r.y,r.x);\n  float s = dot(p,normal) >= 0.0 ? 1.0 : -1.0;\n  return s*dist;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nfloat polydist(float N, vec2 p, float r) {\n    float phi = PI/N; // angle of half sector\n    float theta = atan(p.x,-p.y);// negative y-axis is theta = 0\n    theta = mod(theta+phi,2.0*phi)-phi;\n    //theta /= 2.0*phi; theta -= round(theta); theta *= 2.0*phi; // Equivalent\n    theta = abs(theta); // Mirror symmetry\n    // With dihedral symmetry, the closest point is always in the\n    // fundamental region, so can limit attention just to there\n    // for finding the SDF.\n    vec2 p1 = length(p)*vec2(cos(theta),sin(theta));\n    vec2 q0 = r*vec2(cos(phi),sin(phi)), q1 = r*vec2(cos(phi),0);\n    return ssegment(p1,q0,q1);\n}\n\nfloat poly(float k, vec2 p, float px) {\n    float k0 = k;\n    k /= M;\n    k += 0.25*iTime;\n    k = exp(k);\n    float r = exp(k+0.1*iTime);\n    //p = rotate(p,0.5*iTime*sin(0.05*k0-0.1*sin(0.01*iTime)));\n    //p = rotate(p,0.5*sin(3.0*iTime+0.1*k0));\n    p = rotate(p,0.5*iTime*sin(k0));\n    float d = polydist(N,p,k);\n    return d;\n}\n\nvec3 getcol(float k) {\n  return 0.25+0.75*h2rgb(0.01*iTime+0.5*fract(100.0*sin(k)));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 p = 2.0*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = fwidth(length(p));\n    float k = length(p);\n    k = log(k);\n    k -= 0.25*iTime;\n    k *= M;\n    k = round(k);\n    float d0 = poly(k-0.5,p,px);\n    float d1 = poly(k+0.5,p,px);\n    \n    float d = min(abs(d0),abs(d1));\n    vec3 col;\n    if (d0 < 0.0) col = getcol(k-0.5);\n    else if (d1 < 0.0) col = getcol(k+0.5);\n    else col = getcol(k+1.5);\n    col = mix(vec3(0),col,vec3(smoothstep(0.0,px,abs(d)-0.0015)));\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 165, 195, 195, 240], [242, 357, 397, 397, 636], [638, 638, 659, 659, 792], [794, 794, 836, 836, 1419], [1421, 1421, 1460, 1460, 1754], [1756, 1756, 1778, 1778, 1842], [1844, 1844, 1896, 1896, 2452]], "test": "untested"}
{"id": "ddBXzV", "name": "polygons like 11235 #3?", "author": "jonasfrey", "description": "challange: \nwho can make 1000 polygons rotating seperatly without calculating 1000 polygons and taking the min distance\nmatrix transformation is oviously not working?\n", "tags": ["polygon"], "likes": 4, "viewed": 158, "published": 3, "date": "1670534083", "time_retrieved": "2024-07-30T16:14:07.347141", "image_code": "// signed distance to a regular n-gon\nfloat f_n_dist_ngon( \n    float n_sides,\n    float n_radius,\n    vec2 o_trpino\n    )\n{\n    vec2 o_delta = -o_trpino;\n    float n_tau = 6.2831;\n    float n_ang_rad = atan(o_delta.y, o_delta.x)+(n_tau/2.);\n    float n_rad_per_side = n_tau / n_sides;\n    float n_side = floor(n_ang_rad / n_rad_per_side);\n    if(fract(n_ang_rad / n_rad_per_side) > 0.5){\n        n_side +=1.;\n    }\n    float n_radius_plusminus = (0.5-abs(fract(n_ang_rad / n_rad_per_side)-0.5));\n\n    float n_ang_rad_side = n_rad_per_side * n_side;\n    vec2 o_delta_side = \n        o_trpino - \n        vec2(\n            cos(n_ang_rad_side)*(n_radius+n_radius_plusminus), \n            sin(n_ang_rad_side)*(n_radius+n_radius_plusminus) \n        );\n    float n_dist_side = length(o_delta_side);\n    float n_dist = length(o_trpino);\n    return length(o_trpino)+sin(n_radius_plusminus*n_tau)*n_dist*0.14;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n    vec2 o_scale = vec2(0.032);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n    float n_tau = 6.2831;\n    //float rot = (sin(length(o_trpino)+iTime));\n    float n_radians_matrot = (sin(length(o_trpino)*10.+iTime));\n    //n_radians_matrot = 0.;\n    // algebra formula for rotation by matrix , https://en.wikipedia.org/wiki/Rotation_matrix\n    mat2 o_mat = mat2(cos(n_radians_matrot), -sin(n_radians_matrot), sin(n_radians_matrot), cos(n_radians_matrot));\n    o_trpino = o_mat*o_trpino;\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n\n    float n_dist = f_n_dist_ngon(\n        3., \n        length(o_trpino)/2., \n        o_trpino\n    );\n    fragColor = vec4(sin(n_dist*n_tau*20.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 124, 124, 902], [904, 904, 961, 961, 2269]], "test": "untested"}
{"id": "ddSSRK", "name": "vsync glitch", "author": "jonasfrey", "description": "mouse xaxis intesity\nmouse yaxis y strips", "tags": ["glitch"], "likes": 3, "viewed": 241, "published": 3, "date": "1670515955", "time_retrieved": "2024-07-30T16:14:08.174928", "image_code": "\nfloat f_n_rand(float n){\n    return fract(sin(n*323.23)*33123.123 + 32.23*sin(32.23*n));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.xy;\n\n    vec2 o_scale = vec2(0.02+o_trmono_nooffset);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n       \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    \n    vec2 o_scale_rand = vec2(f_n_rand(o_fragCoord_scaled_floor.y*iTime)*0.02+0.004);\n    vec2 o_fragCoord_scaled_rand = ((fragCoord.xy)*o_scale_rand);\n    vec2 o_iResolution_scaled_rand = (iResolution.xy * o_scale_rand);\n\n    vec2 o_fragCoord_scaled_floor_rand = floor(o_fragCoord_scaled_rand);\n    vec2 o_iResolution_scaled_floor_rand = floor(o_iResolution_scaled_rand);\n    vec2 o_fragCoord_scaled_fract_rand = fract(o_fragCoord_scaled_rand);\n    vec2 o_iResolution_scaled_fract_rand = fract(o_iResolution_scaled_rand);\n\n\n    vec2 o_offset = vec2(\n        (f_n_rand(iTime*o_fragCoord_scaled_floor_rand.y)-0.5)*(0.02+o_trmono_nooffset.x),\n        0.\n    );\n    vec4 o_col = texture(iChannel0, o_trpino_nooffset);\n    vec4 o_col_offset = texture(iChannel0, o_trpino_nooffset+(o_offset));\n    vec4 o_col_offset2 = texture(iChannel0, o_trpino_nooffset-(o_offset));\n    fragColor = o_col_offset;\n    if(o_trpino.x > -.5){\n        fragColor = vec4(\n            o_col_offset.r, \n            o_col.g, \n            o_col.b, \n            1.\n        );\n        if(o_trpino.x - -0.5 < 0.01){\n            fragColor = vec4(0.);\n        }\n    }\n    if(o_trpino.x > 0.0){\n        fragColor = vec4(\n            o_col.r, \n            o_col_offset.g, \n            o_col_offset2.b, \n            1.\n        );\n        if(o_trpino.x - 0. < 0.01){\n            fragColor = vec4(0.);\n        }\n    }\n    if(o_trpino.x > 0.5){\n        fragColor = o_col;\n        if(o_trpino.x - 0.5 < 0.01){\n            fragColor = vec4(0.);\n        }\n\n    }\n\n\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 91], [92, 92, 149, 149, 2717]], "test": "untested"}
{"id": "csSXzV", "name": "last frame kernel: #3", "author": "jonasfrey", "description": "explosion", "tags": ["template"], "likes": 2, "viewed": 136, "published": 3, "date": "1670514618", "time_retrieved": "2024-07-30T16:14:08.978779", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        float n_speed = 3.;\n        o_trmono = vec2(\n            0.\n            //sin(iTime*n_speed*10.)*0.6,\n            //cos(iTime*n_speed*0.8)*0.3\n            //n_t_x*2.,\n            //n_t_y\n            //(f_n_rand(n_t)-0.5)*2.,\n            //f_n_rand(n_t*3.33)-0.5\n        );\n    }\n    vec2 o_scale = vec2(0.9);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_scale_kernel = vec2(\n        5.,\n        5.\n    );\n    float n_size_kernel = o_scale_kernel.x * o_scale_kernel.y;\n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n    \n    vec4 a_o_col_last_krnl[100];\n    \n    vec4 a_o_sum_xaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_xaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 o_kernel_sum = vec4(0.0);\n    int n_index_a_o_col_last_krnl = 0;\n    for(float n_y = 0.0; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.0; n_x < o_scale_kernel.x; n_x+=1.){\n            int n_index_a_o_sum_xaxis = int(n_x);\n            int n_index_a_o_sum_yaxis = int(n_y);\n\n            vec2 o_speed = vec2(0.0);\n            vec2 o = vec2(\n               floor(n_x - floor(o_scale_kernel.x/2.)),\n               floor(n_y - floor(o_scale_kernel.y/2.)) \n            ) + o_speed;\n            vec2 o_off = vec2(\n                o.x * (1./o_iResolution_scaled_floor.x),\n                o.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_on_kernel;\n\n            a_o_sum_xaxis[n_index_a_o_sum_xaxis] += o_col_last_on_kernel;\n            a_o_sum_xaxis_nor[n_index_a_o_sum_xaxis]+= (o_col_last_on_kernel / o_scale_kernel.x);\n            a_o_sum_yaxis[n_index_a_o_sum_yaxis] += o_col_last_on_kernel;\n            a_o_sum_yaxis_nor[n_index_a_o_sum_yaxis]+= (o_col_last_on_kernel / o_scale_kernel.y);\n            \n            n_index_a_o_col_last_krnl+=1;\n            a_o_col_last_krnl[n_index_a_o_col_last_krnl] = o_col_last_on_kernel;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n    \n\n    vec4 a_o_sum_xring_nor[100];\n    vec4 a_o_sum_yring_nor[100];\n    for(float n_x =0.0; n_x < (o_scale_kernel.x/2.); n_x+=1.){\n        vec4 n_sum1 = a_o_sum_xaxis_nor[int(n_x)];\n        vec4 n_sum2 = a_o_sum_xaxis_nor[int(o_scale_kernel.x - n_x)];\n        a_o_sum_xring_nor[int(n_x)] = (n_sum1 + n_sum2)/2.;\n    };\n    for(float n_y =0.0; n_y < (o_scale_kernel.y/2.); n_y+=1.){\n        vec4 n_sum1 = a_o_sum_yaxis_nor[int(n_y)];\n        vec4 n_sum2 = a_o_sum_yaxis_nor[int(o_scale_kernel.y - n_y)];\n        a_o_sum_xring_nor[int(n_y)] = (n_sum1 + n_sum2)/2.;\n    };\n    //00000\n    //01110\n    //01.10\n    //01110\n    //00000 \n    vec4 a_o_sum_xyring_nor[100];\n    float n_scale_kernel_bigger = max(o_scale_kernel.x, o_scale_kernel.y);\n    for(float n_index =0.0; n_index < n_scale_kernel_bigger; n_index+=1.){\n        a_o_sum_xyring_nor[int(n_index)] = \n            (a_o_sum_xring_nor[int(n_index)] + \n            a_o_sum_yring_nor[int(n_index)]) /2.;\n    }\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n            float n_tau = 6.283185;\n            if(o_kernel_sum_nor.x > 0.71){\n                fragColor = vec4(o_kernel_sum_nor.x*o_kernel_sum_nor.x);\n            }else{\n                fragColor = vec4(f_n_rand(o_kernel_sum_nor.x)*o_kernel_sum_nor.x);\n            }\n\n            vec4 o_col_delta_last = (fragColor - o_col_last);\n            fragColor = fragColor + o_col_delta_last*1.001;\n            \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_toggle = float(mod(iTime*0.6,2.0) > 1.0);\n    float n_thresh = n_toggle*0.1+(1.-n_toggle)*0.9;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4((n_dist_nor-.5));\n\n    }\n    if(mod(float(iFrame), 1000.) == 0.){\n        fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y+fragCoord.x));\n    }\n    \n    fragColor = (fragColor);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "cdBSzV", "name": "last frame kernel: rectangulator", "author": "jonasfrey", "description": "rectangulator", "tags": ["template"], "likes": 1, "viewed": 144, "published": 3, "date": "1670512576", "time_retrieved": "2024-07-30T16:14:09.878374", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        float n_speed = 10.;\n        o_trmono = vec2(\n            sin(iTime*n_speed),\n            cos(iTime*(n_speed/5.))*0.5\n            //n_t_x*2.,\n            //n_t_y\n            //(f_n_rand(n_t)-0.5)*2.,\n            //f_n_rand(n_t*3.33)-0.5\n        );\n    }\n    vec2 o_scale = vec2(0.9);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_scale_kernel = vec2(\n        5.,\n        5.\n    );\n    float n_size_kernel = o_scale_kernel.x * o_scale_kernel.y;\n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n    \n    vec4 a_o_col_last_krnl[100];\n    \n    vec4 a_o_sum_xaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_xaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 o_kernel_sum = vec4(0.0);\n    int n_index_a_o_col_last_krnl = 0;\n    for(float n_y = 0.0; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.0; n_x < o_scale_kernel.x; n_x+=1.){\n            int n_index_a_o_sum_xaxis = int(n_x);\n            int n_index_a_o_sum_yaxis = int(n_y);\n\n            vec2 o_speed = vec2(0.0);\n            vec2 o = vec2(\n               floor(n_x - floor(o_scale_kernel.x/2.)),\n               floor(n_y - floor(o_scale_kernel.y/2.)) \n            ) + o_speed;\n            vec2 o_off = vec2(\n                o.x * (1./o_iResolution_scaled_floor.x),\n                o.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_on_kernel;\n\n            a_o_sum_xaxis[n_index_a_o_sum_xaxis] += o_col_last_on_kernel;\n            a_o_sum_xaxis_nor[n_index_a_o_sum_xaxis]+= (o_col_last_on_kernel / o_scale_kernel.x);\n            a_o_sum_yaxis[n_index_a_o_sum_yaxis] += o_col_last_on_kernel;\n            a_o_sum_yaxis_nor[n_index_a_o_sum_yaxis]+= (o_col_last_on_kernel / o_scale_kernel.y);\n            \n            n_index_a_o_col_last_krnl+=1;\n            a_o_col_last_krnl[n_index_a_o_col_last_krnl] = o_col_last_on_kernel;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n    \n\n    vec4 a_o_sum_xring_nor[100];\n    vec4 a_o_sum_yring_nor[100];\n    for(float n_x =0.0; n_x < (o_scale_kernel.x/2.); n_x+=1.){\n        vec4 n_sum1 = a_o_sum_xaxis_nor[int(n_x)];\n        vec4 n_sum2 = a_o_sum_xaxis_nor[int(o_scale_kernel.x - n_x)];\n        a_o_sum_xring_nor[int(n_x)] = (n_sum1 + n_sum2)/2.;\n    };\n    for(float n_y =0.0; n_y < (o_scale_kernel.y/2.); n_y+=1.){\n        vec4 n_sum1 = a_o_sum_yaxis_nor[int(n_y)];\n        vec4 n_sum2 = a_o_sum_yaxis_nor[int(o_scale_kernel.y - n_y)];\n        a_o_sum_xring_nor[int(n_y)] = (n_sum1 + n_sum2)/2.;\n    };\n    //00000\n    //01110\n    //01.10\n    //01110\n    //00000 \n    vec4 a_o_sum_xyring_nor[100];\n    float n_scale_kernel_bigger = max(o_scale_kernel.x, o_scale_kernel.y);\n    for(float n_index =0.0; n_index < n_scale_kernel_bigger; n_index+=1.){\n        a_o_sum_xyring_nor[int(n_index)] = \n            (a_o_sum_xring_nor[int(n_index)] + \n            a_o_sum_yring_nor[int(n_index)]) /2.;\n    }\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n            if(o_kernel_sum_nor.x > 0.59){\n                fragColor = vec4(1.);\n            }else{\n                fragColor = vec4(0.);\n            }\n\n            //vec4 o_col_delta_last = abs(fragColor - o_col_last);\n            //fragColor = o_col_delta_last*0.29;\n            \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_thresh = 0.20;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4((n_dist_nor));\n\n    }\n    \n    fragColor = (fragColor);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "msf3Wl", "name": "BasicRnT", "author": "RaXnTraX", "description": "+/- 60Fps", "tags": ["empty"], "likes": 1, "viewed": 190, "published": 3, "date": "1670494449", "time_retrieved": "2024-07-30T16:14:10.686214", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /*int tx = int(uv.x*512.0);    \n    float waveL = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\n    float waveR = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    vec2 Mouse = vec2(waveL*iResolution.x, waveR*iResolution.y);*/\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = iMouse.xy/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    float x = pos.x;\n    float xpx = 1.0-smoothstep(0.,0.01, abs(x-uv.x));\n    float xpy = 1.0-smoothstep(0.,0.01, abs(0.5-uv.y));\n    vec2 xp = vec2(xpx, xpy);\n\n    float y = pos.y;\n    float ypx = 1.0-smoothstep(0.,0.01, abs(0.5-uv.x));\n    float ypy = 1.0-smoothstep(0.,0.01, abs(y-uv.y));\n    vec2 yp = vec2(ypx, ypy);\n    // Output to screen\n    col.g += (xpx*xpy) + (ypx*ypy);\n    \n    vec2 xyd = xp+yp/2.;\n    //col.r += xyd.x * xyd.y;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30175, "src": "https://soundcloud.com/matryx/xy_stereo?si=a2b1c03eb8394a44945572aa329c7817&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msf3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 957]], "test": "untested"}
{"id": "dd2XRy", "name": "hyperbolic swirl distortion", "author": "andywolff", "description": "Apply a spherical / hyperbolic swirl distortion to the camera feed at the last mouse click position. Adjustable swirl amount, radius, distortion falloff, and inflation dampening. Optional distorted rectangular checkerboard or polar checkerboard grid.", "tags": ["grid", "swirl", "distortion", "camera", "polar"], "likes": 1, "viewed": 446, "published": 3, "date": "1670488401", "time_retrieved": "2024-07-30T16:14:11.440198", "image_code": "// Radius of the sphere distortion (normalized to 0-1 range across the screen size)\nconst float RADIUS = 0.15;\n// Exponent applied to the falloff which dampens the distortion outside the radius of the sphere\nconst float FALLOFF_EXPONENT = 3.0;\n// How many degrees the swirl distortion should rotate back and forth\nconst float SWIRL_DEGREES = 120.0;\n// The normal sphere inflation is a bit strong for faces, increase this to dampen it\nconst float CENTER_DISTORTION_DAMPENING = 0.2;\n\n// Size of the checkerboard grid (only drawn if DRAW_GRID is true)\nconst vec2 GRID_SIZE = vec2(0.03, 0.03);\n// Draw a white and black checkerboard grid when true, else distort iChannel0\n#define DRAW_GRID 0\n// If drawing a grid, draw it with polar coordinates instead of distorting rectangular coordinates\n#define GRID_IS_POLAR 0\n\n\n// return polar coordinates (distance, angle in radians)\nvec2 to_polar(vec2 from_rectangular) {\n  return vec2(length(from_rectangular), atan(from_rectangular.y, from_rectangular.x));\n}\n\n// transform polar coordinates (distance, angle in radians) to rectangular coordinates\nvec2 to_rectangular(vec2 from_polar) {\n  return vec2(cos(from_polar.y)*from_polar.x, sin(from_polar.y)*from_polar.x);\n}\n\n// checkerboard grid\nbool grid(vec2 coords, vec2 grid_size) {\n\n  return (\n      // (x mod grid size * 2.0) is less than grid size exactly half the time\n      mod(coords.x, grid_size.x * 2.0) < grid_size.x\n      // (XOR to achieve alternating squares)\n      ^^\n      // similar condition for y\n      mod(coords.y, grid_size.y * 2.0) < grid_size.y\n      );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize frag coordinates to range 0-1\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // initialize center variable to center of screen as a fallback, otherwise normalized mouse position\n    vec2 center = vec2(0.5);\n    center = iMouse.xy / iResolution.xy;\n    \n    // normalize to center\n    uv -= center;\n    \n    // Transform to polar coordinates (before applying rotation)\n    vec2 polar_uv = to_polar(uv);\n       \n    // falloff to apply to rotation and sphere inflation outside the radius of the sphere\n    //   We want to multiply other operands by this amount,\n    //   so we want it to go from 1.0 to near 0.0 as it gets further away from the sphere\n    //\n    //   `max(1.0, polar_uv.x / RADIUS)` will be 1.0 everywhere in the sphere, then >1 outside the sphere\n    //   to make that trend toward 0.0 while still starting at 1.0, we subtract it from 2.0\n    //   we don't want to apply negative rotation or distortion due to this falloff, so max it with 0.0\n    //   finally, we want the falloff to happen quickly outside of the sphere, so apply exponent FALLOFF_EXPONENT\n    float falloff_amount = pow(max(0.0, 2.0 - max(1.0, polar_uv.x / RADIUS)), FALLOFF_EXPONENT);\n    \n    // radians by which to rotate the current coordinate around the center\n    //   Swirl it back and forth by SWIRL_DEGREES\n    //   \n    //   `polar_uv.x / RADIUS * 2.0 - 1.0` gives us 0.0 near the center of the radius of the sphere, 1.0 at the outside edge, and -1.0 at the inside edge\n    //   `cos(iTime)` causes the value to swing between -1.0 and 1.0 periodically\n    //   multiplying by `radians(SWIRL_DEGREES)` gives us the desired range\n    float rot_amount = (polar_uv.x / RADIUS * 2.0 - 1.0)*cos(iTime)*radians(SWIRL_DEGREES);\n    // Apply falloff to rotation amount\n    rot_amount *= falloff_amount;\n    // Apply rotation by multiplying by a 2x2 rotation matrix\n    mat2 rot = mat2(cos(rot_amount), -sin(rot_amount), sin(rot_amount), cos(rot_amount));\n    uv *= rot;\n    \n    // undo normalization to center\n    uv += center;\n    \n    // Transform to polar coordinates (again after applying rotation)\n    polar_uv = to_polar(uv - center);\n\n    // Determine how much we want to inflate the sphere based on the distance of this coordinate from the center:\n    //   `cosh(polar_uv.x / RADIUS * radians(90.0))` would give us 1.0 at the center of the sphere, \n    //       then follow a nearly circular hyperbolic path towards infinity at the edge of the sphere (90 degrees)\n    //   However, this distortion would be a bit much, so we stretch it forward a little by adding \n    //       CENTER_DISTORTION_DAMPENING to the numerator and denominator both.\n    //   Finally, we subtract 1.0 because we want to do no inflation near the center of the sphere.\n    float sphere_inflation_amount = \n      cosh((polar_uv.x+CENTER_DISTORTION_DAMPENING) / (RADIUS+CENTER_DISTORTION_DAMPENING) * radians(90.0)) - 1.0;\n    // Apply the spherical inflation:\n    //  `polar_uv.x *= sphere_inflation_amount` would apply the sphere inflation everywhere,\n    //    but we want to fall off outside the sphere. So we perform a linear interpolation\n    //    so that when falloff_amount is 1.0, it fully applies the inflation,\n    //    and as falloff_amount trends toward 0.0, it applies none of the inflation.\n    polar_uv.x = mix(polar_uv.x, polar_uv.x * sphere_inflation_amount, falloff_amount);\n\n\n    fragColor = texture(iChannel0, to_rectangular(polar_uv)+center);\n\n# if DRAW_GRID\n  # if GRID_IS_POLAR\n    fragColor = grid(polar_uv, GRID_SIZE)\n      ? vec4(1.0,1.0,1.0,1.0)\n      : vec4(0.0,0.0,0.0,1.0);\n  # else\n    fragColor = grid(to_rectangular(polar_uv)+center, GRID_SIZE)\n      ? vec4(1.0,1.0,1.0,1.0)\n      : vec4(0.0,0.0,0.0,1.0);\n  # endif\n# endif\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2XRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[813, 870, 908, 908, 997], [999, 1086, 1124, 1124, 1205], [1565, 1565, 1622, 1669, 5366]], "test": "untested"}
{"id": "mdjSDz", "name": "Raymarched Circuit Board WFC", "author": "fenix", "description": "A printed circuit board is assembled by nanobots, while a three-color optical scanner looks on, checking for defects.\n*mouse to reset tiles*\n*WASD/QE/RF to fly*\n*space to reset*", "tags": ["raymarch", "shadow", "lights", "circuit", "wfc", "wavefunctioncollapse"], "likes": 29, "viewed": 464, "published": 3, "date": "1670485139", "time_retrieved": "2024-07-30T16:14:12.386667", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiement with my interpretation of Wave Function Collapse, this time with\n//  a 3D raymarched renderer.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders (all 2D):\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                     https://www.shadertoy.com/view/ds2XzD\n//\n//  The wave function collapse didn't change much here, only the rendering. Starting with\n//  the tiles in Circuit Board WFC, I just added a few (CHIP2, RESISTOR, CAPACITOR) to\n//  complement the new look.\n//\n//  The rendering has nothing really revolutionary either. I started by with this:\n//\n//      Slime Mold Terrain                https://www.shadertoy.com/view/Dd23z3\n//\n//  because it already had raymarching against a \"terrain texture\". Then I replaced the\n//  height field with consulting an SDF per tile type. After that I implemented materials\n//  and multiple local light sources. The tilt-shift lens effect is borrowed from my\n//  Dynamic Editable Terrain series:\n//\n//      Dynamic Editable Terrain          https://www.shadertoy.com/view/flVBRw\n//      Dynamic Editable Terrain 2        https://www.shadertoy.com/view/7tKBDm\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//  Buffer C does the main scene render\n//  Image applies blur effect and renders lights on top\n//\n// ---------------------------------------------------------------------------------------\n\n// based on gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  7;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid swap(inout vec3 a, inout vec3 b)\n{\n    vec3 temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float centerDepth = texelFetch(iChannel0, ivec2(iResolution.xy*vec2(0.5, .6)), 0).w;\n    vec4 pixel = texelFetch(iChannel0, ivec2(u), 0);\n    float depth = pixel.w;\n    \n    // Blur based on depth, the farther from the depth of the center pixel, the more blur,\n    // to create a tilt-shift lens effect.\n    w = (abs(depth-centerDepth)) * iResolution.y / 2000.;\n    \n    if (w > 0.002)\n    {\n        init\n        vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n        {\n            vec2 U = u / R.y;  \n            O = convol2D(U);\n        }\n    }\n    else\n    {\n        O = pixel;\n    }\n    \n    fxState state = fxGetState();\n    \n    // render lights after blur\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 lightPos[3] = calcLightPos(iTime, iResolution, cameraPos, cameraFwd);\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    lightPos[0] = (w2c * vec4(lightPos[0],1.0)).xyz;\n    lightPos[0].xy = lightPos[0].xy / lightPos[0].z;\n    lightPos[1] = (w2c * vec4(lightPos[1],1.0)).xyz;\n    lightPos[1].xy = lightPos[1].xy / lightPos[1].z;\n    lightPos[2] = (w2c * vec4(lightPos[2],1.0)).xyz;\n    lightPos[2].xy = lightPos[2].xy / lightPos[2].z;\n    \n    vec3 lightColors[3] = LIGHT_COLORS;\n\n    for (int i = 0; i < 3; ++i)\n    {\n        float d= distance(lightPos[i].xy, (u - .5*iResolution.xy) / iResolution.y);\n        O.xyz = max(O.xyz, lightColors[i] * smoothstep(.04, .02, d));\n    }\n    \n    O.a = 1.;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SHADOW 1\nconst float MAX_Y = 0.01;\nconst float CHIP_NOISE_SCALE = 15000.;\nconst float CHIP_NOISE_HEIGHT = .003;\nconst float TRACE_SMIN_K = .05;\nconst float MAX_T = 2.2;\nconst float SDF_EPSILON = 0.00001;\nconst int MAX_MARCH_ITER = 100;\n\n// symmetry types\n#define S_X 0x1\n#define S_I 0x3\n#define S_L 0xf\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    int sym; // symmetry type\n    bool selfConnect; // can connect to self\n};\n\n// tile definitions\nconst Tile T_EMPTY =\n    Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         0., S_X, true);\n         \nconst Tile T_BOARD =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .9, S_X, true);\n                \nconst Tile T_CHIP =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .2, S_X, true);\n                \nconst Tile T_CHIP2 =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .02, S_X, true);\n                \nconst Tile T_NODE =\n    Tile(mat3(1, 1, 1,\n              1, 1, 2,\n              1, 1, 1),\n         0., S_L, false);\n                \nconst Tile T_WIRE =\n    Tile(mat3(1, 1, 1,\n              4, 4, 4,\n              1, 1, 1),\n         0.03, S_I, true);\n                \nconst Tile T_EDGE =\n    Tile(mat3(3, 1, 1,\n              3, 2, 2,\n              3, 1, 1),\n         .1, S_L, true);\n                \nconst Tile T_CORNER =\n    Tile(mat3(3, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .001, S_L, false);\n                \nconst Tile T_TRACE =\n    Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.5, S_I, true);\n                \nconst Tile T_CROSS =\n    Tile(mat3(1, 4, 1,\n              2, 4, 2,\n              1, 4, 1),\n         0.1, S_I, true);\n                \nconst Tile T_JUNCT =\n    Tile(mat3(1, 4, 1,\n              1, 4, 1,\n              1, 2, 1),\n         0.03, S_L, false);\n                \nconst Tile T_T =\n    Tile(mat3(1, 2, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.2, S_L, false);\n                \nconst Tile T_ACROSS =\n    Tile(mat3(1, 2, 1,\n              1, 2, 2,\n              1, 1, 1),\n         .2, S_L, true);\n                \nconst Tile T_ACROSS2 =\n    Tile(mat3(1, 2, 1,\n              2, 1, 2,\n              1, 2, 1),\n         .2, S_I, true);\n         \nconst Tile T_INODE =\n    Tile(mat3(1, 1, 1,\n              2, 1, 2,\n              1, 1, 1),\n         0.2, S_I, false);\n                \nconst Tile T_CAPACITOR =\n    Tile(mat3(1, 1, 1,\n              2, 1, 5,\n              1, 5, 1),\n         0.1, S_L, true);\n                \nconst Tile T_RESISTOR =\n    Tile(mat3(1, 1, 1,\n              6, 1, 2,\n              1, 1, 1),\n         0.1, S_L, true);\n                \nconst int EMPTY = 0;\nconst int BOARD = 1;\nconst int CHIP = 2;\nconst int CHIP2 = 3;\nconst int NODE = 4;\nconst int WIRE = 5;\nconst int EDGE = 6;\nconst int CORNER = 7;\nconst int TRACE = 8;\nconst int CROSS = 9;\nconst int JUNCT = 10;\nconst int T = 11;\nconst int ACROSS = 12;\nconst int ACROSS2 = 13;\nconst int INODE = 14;\nconst int CAPACITOR = 15;\nconst int RESISTOR = 16;\nconst int NUM_TILES = 17;\n\nconst Tile[NUM_TILES] TILES =\n    Tile[](\n        T_EMPTY,\n        T_BOARD,\n        T_CHIP,\n        T_CHIP2,\n        T_NODE,\n        T_WIRE,\n        T_EDGE,\n        T_CORNER,\n        T_TRACE,\n        T_CROSS,\n        T_JUNCT,\n        T_T,\n        T_ACROSS,\n        T_ACROSS2,\n        T_INODE,\n        T_CAPACITOR,\n        T_RESISTOR\n    );\n\n// material definitions\n#define M_BLACK 0\n#define M_BOARD 1\n#define M_CHIP 2\n#define M_WIRE 3\n#define M_TRACE 4\n#define M_BASE 5\n\nvec3 matColor(int m)\n{\n    if (m == M_BLACK) return vec3(0);\n    if (m == M_BOARD) return vec3(.05, .4, .05);\n    if (m == M_CHIP)  return vec3(.05);\n    if (m == M_WIRE)  return vec3(1.);\n    if (m == M_TRACE) return vec3(.3,.8,.3);//vec3(.6,.5,.0);\n    if (m == M_BASE)  return vec3(.3,.3,.2);//vec3(.6,.5,.0);\n}\n\nfloat matShiny(int m)\n{\n    if (m == M_BLACK) return 0.;\n    if (m == M_BOARD) return .3;\n    if (m == M_CHIP)  return .6;\n    if (m == M_WIRE)  return .99;\n    if (m == M_TRACE) return .9;\n    if (m == M_BASE)  return .3;\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\nvec2 rot90(vec2 v) { return v.yx * vec2(1, -1); }\n\nconst float PI = 3.141592653589793;\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_R 82\n#define KEY_F 70\n#define KEY_Q 81\n#define KEY_E 69\n\nstruct fxState\n{\n    vec3 camPos;\n    vec2 lastMouse;\n    float camDir;\n    float resolution;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.attract = data0.y != 0.;\n    state.lastMouse = data0.zw;\n    state.camPos = data1.xyz;\n    state.camDir = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.attract ? 1. : 0., state.lastMouse);\n    }\n    \n    return vec4(state.camPos, state.camDir);\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct Result \n{\n    float dist;\n    int mat;\n};\n\nResult minResult(Result a, Result b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// distance functions\nResult sdEmpty(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    return Result(sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5)), M_BLACK);\n}\n\nResult sdBoard(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    return Result(sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5)), M_BOARD);\n}\n\nResult sdChip(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    return Result((sdBox(p + vec3(0,.4,0), vec3(1.,.2,.5)) + noise.x), M_CHIP);\n}\n\nResult sdChip2(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    float dHole = sdCappedCylinder(p + vec3(0,.03,0), .4, .2);\n    return Result(max(-dHole, sdBox(p + vec3(0,.4,0), vec3(1.,.2,.5)) + noise.x), M_CHIP);\n}\n\nResult sdNode(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.7,0), vec3(1.,.1,.5));\n    float dTrace = sdBox(p + vec3(0,.6,.35), vec3(0.09,.005,.2));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    Result result = Result(sdCappedCylinder(p + vec3(0,1.07,0), .2, .5), M_WIRE);\n    if (dBT < result.dist)\n    {\n        result.dist = dBT;\n        result.mat = dBoard < dTrace ? M_BOARD : M_TRACE;\n    }\n    float dHole = sdCappedCylinder(p + vec3(0,1.0,0), .1, 1.);\n    if (-dHole > result.dist)\n    {\n        result.dist = -dHole;\n        result.mat = M_BLACK;\n    }\n    return result;\n}\n\nResult sdWire(vec3 p, bool forShadow)\n{\n    float dWire = sdCappedCylinder(p.xzy + vec3(0,0,.403), .11,.6);\n    if (forShadow) return Result(dWire, M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    if (dBoard < dWire) return Result(dBoard, M_BOARD);\n    return Result(dWire, M_WIRE);\n}\n\nResult sdEdge(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 pr = p;\n    pr.yz *= rot2(PI*.25);\n    float dChip = max(sdBox(p + vec3(0,.4,-.3), vec3(1.,.2,.3)), -sdBox(pr + vec3(0,.1,.1), vec3(1.2,.2,.3)));\n    Result rWire1 = Result(sdBox(p + vec3(0,.35,.1), vec3(0.15,.01,.2)), M_WIRE);\n    Result rWire2 = Result(sdBox(p + vec3(0,.55,.3), vec3(0.15,.2,.01)), M_WIRE);\n    if (forShadow) return minResult(minResult(rWire1, rWire2), Result(dChip, M_CHIP));\n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    Result rChip = Result(noise.x + dChip, M_CHIP);\n    Result rSolder = Result(sdSphere(p + vec3(0,.67,.3), .2), M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,.4), vec3(0.08,.005,.1));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    Result rBT = Result(dBT, dBoard < dTrace ? M_BOARD : M_TRACE);\n    return minResult(minResult(minResult(minResult(rBT, rChip), rWire1), rWire2), rSolder);\n}\n\nResult sdCorner(vec3 p, vec3 gp, bool forShadow)\n{\n    vec3 pra = p;\n    pra.yz *= rot2(PI*.25);\n    vec3 prb = p;\n    prb.xy *= rot2(PI*.25);\n    float dChip = max(max(\n        sdBox(p + vec3(-.3,.4,-.3), vec3(.3,.2,.3)),\n        -sdBox(pra + vec3(0,.1,.1), vec3(.675,.2,.3))),\n        -sdBox(prb + vec3(.1,.0,0), vec3(.11,.2,1.2)));\n    if (forShadow) return Result(dChip, M_CHIP);        \n    vec3 noise = hash3(uvec3(abs(gp)*CHIP_NOISE_SCALE)) * CHIP_NOISE_HEIGHT;\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    dChip += noise.x;\n    if (dBoard < dChip) return Result(dBoard, M_BOARD);\n    return Result(dChip, M_CHIP);\n}\n\nResult sdTrace(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.55));\n    float dist = smin(dBoard, dTrace, TRACE_SMIN_K);\n    if (dBoard < dTrace) return Result(dist, M_BOARD);\n    return Result(dist, M_TRACE);\n}\n\nResult sdCross(vec3 p, bool forShadow)\n{\n    float dWire = sdCappedCylinder(p.zxy + vec3(0,0,.403), .11,.5);\n    if (forShadow) return Result(dWire, M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.5));\n    float dBT = smin(dBoard, dTrace, 1e-5);\n    if (dBoard < dTrace && dBoard < dWire) return Result(dBT, M_BOARD);\n    if (dTrace < dWire) return Result(dBT, M_TRACE);\n    return Result(dWire, M_WIRE);\n}\n\nResult sdJunct(vec3 p, bool forShadow)\n{\n    const vec2 sc = vec2(sin(.25*PI), cos(.25*PI));\n    vec3 pr = p;\n    pr.xy *= rot2(PI*.25);\n    float dWire = sdCappedTorus(pr + vec3(.05,.8,.0), sc, .2, .11);\n    if (forShadow) return Result(dWire, M_WIRE);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(.25,.6,0), vec3(0.5,.005,.09));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    if (dBoard < dTrace && dBoard < dWire) return Result(dBT, M_BOARD);\n    if (dTrace < dWire) return Result(dBT, M_TRACE);\n    return Result(dWire, M_WIRE);\n}\n\nResult sdT(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace1 = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.54));\n    float dTrace2 = sdBox(p + vec3(-.25,.6,0), vec3(.3,.005,.09));\n    float dBT1 = smin(dBoard, dTrace1, TRACE_SMIN_K);\n    float dBT2 = smin(dBoard, dTrace2, TRACE_SMIN_K);\n    int mat = dBoard < dTrace1 && dBoard < dTrace2 ? M_BOARD : M_TRACE;\n    if (dBT1 < dBT2) return Result(dBT1, mat);\n    return Result(dBT2, mat);\n}\n\nResult sdAcross(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    p.xz *= rot2(PI*-.25);\n    float dTrace = sdBox(p + vec3(-.355,.6,.0), vec3(0.055,.005,.55));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    if (dBoard < dTrace) return Result(dBT, M_BOARD);\n    return Result(dBT, M_TRACE);\n}\n\nResult sd2Across(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    p.xz *= rot2(PI*-.25);\n    float dTrace1 = sdBox(p + vec3(-.353,.6,.0), vec3(0.055,.005,.5));\n    float dTrace2 = sdBox(p + vec3(.35,.6,.0), vec3(0.055,.005,.5));\n    float dBT1 = smin(dBoard, dTrace1, TRACE_SMIN_K);\n    float dBT2 = smin(dBoard, dTrace2, TRACE_SMIN_K);\n    int mat = dBoard < dTrace1 && dBoard < dTrace2 ? M_BOARD : M_TRACE;\n    if (dBT1 < dBT2) return Result(dBT1, mat);\n    return Result(dBT2, mat);\n}\n\nResult sdINode(vec3 p, bool forShadow)\n{\n    if (forShadow) return Result(1e6, M_BLACK);\n    float dBoard = sdBox(p + vec3(0,.7,0), vec3(1.,.1,.5));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.5));\n    float dBT = smin(dBoard, dTrace, TRACE_SMIN_K);\n    int mat = dBoard < dTrace ? M_BOARD : M_TRACE;\n    Result result = Result(sdCappedCylinder(p + vec3(0,1.05,0), .2, .5), M_WIRE);\n    if (dBT < result.dist)\n    {\n        result.dist = dBT;\n        result.mat = mat;\n    }\n    float dHole = sdCappedCylinder(p + vec3(0,1.0,0), .1, 1.);\n    if (-dHole > result.dist)\n    {\n        result.dist = -dHole;\n        result.mat = M_BLACK;\n    }\n    return result;\n}\n\nResult sdCapacitor(vec3 p, bool forShadow)\n{\n    Result result = Result(sdCappedCylinder(p + vec3(.5,.25,.5), .4, 1.) -.0001, M_WIRE);\n    if (forShadow) return result;\n    float dBoard = sdBox(p + vec3(0,.7,0), vec3(1.,.1,.5));\n    float dBase = sdBox(p + vec3(.1,.6,.1), vec3(.45,.1,.45));\n    float dTrace = sdBox(p + vec3(0,.6,0), vec3(0.09,.005,.5));\n    float dBT = smin(smin(dBoard, dBase, TRACE_SMIN_K), dTrace, TRACE_SMIN_K);\n    int mat = dBoard < dTrace && dBoard < dBase ? M_BOARD : (dTrace < dBase ? M_TRACE : M_BASE);\n    if (dBT < result.dist)\n    {\n        result.dist = dBT;\n        result.mat = mat;\n    }\n    return result;\n}\n\nResult sdResistor(vec3 p, bool forShadow)\n{\n    Result rChip = Result(sdBox(p + vec3(0,.5,-.3), vec3(.3,.1,.2)), M_CHIP);\n    float dWire = sdBox(p + vec3(0,.5,.0), vec3(0.33,.11,.1));\n    float dSolder = sdSphere(p + vec3(0,.7,.2), .27);\n    Result rMetal = Result(smin(dWire, dSolder, .0001), M_WIRE);\n    if (forShadow) return minResult(rMetal, rChip);\n\n    float dBoard = sdBox(p + vec3(0,.8,0), vec3(1.,.2,.5));\n    float dTrace = sdBox(p + vec3(0,.6,.4), vec3(0.1,.01,.1));\n    float dBT = smin(smin(dBoard, dTrace, 1e-5), dTrace, 1e-5);\n    Result rBT = Result(dBT, dBoard < dTrace ? M_BOARD : M_TRACE);\n    return minResult(minResult(rMetal, rChip), rBT);\n}\n\nResult sdCell(vec4 value, vec3 p, vec3 gp, bool forShadow)\n{\n    p.xz = rot90(p.xz);\n    if (value.y == 1.) p.xz = rot90(p.xz);\n    if (value.y == 2.) p.xz = rot90(rot90(p.xz));\n    if (value.y == 3.) p.xz = rot90(rot90(rot90(p.xz)));\n    \n    if (int(value.x) == EMPTY)     return sdEmpty(p, forShadow);\n    if (int(value.x) == BOARD)     return sdBoard(p, forShadow);\n    if (int(value.x) == CHIP)      return sdChip(p, gp, forShadow);\n    if (int(value.x) == CHIP2)     return sdChip2(p, gp, forShadow);\n    if (int(value.x) == NODE)      return sdNode(p, forShadow);\n    if (int(value.x) == WIRE)      return sdWire(p, forShadow);\n    if (int(value.x) == EDGE)      return sdEdge(p, gp, forShadow);\n    if (int(value.x) == CORNER)    return sdCorner(p, gp, forShadow);\n    if (int(value.x) == TRACE)     return sdTrace(p, forShadow);\n    if (int(value.x) == CROSS)     return sdCross(p, forShadow);\n    if (int(value.x) == JUNCT)     return sdJunct(p, forShadow);\n    if (int(value.x) == T)         return sdT(p, forShadow);\n    if (int(value.x) == ACROSS)    return sdAcross(p, forShadow);\n    if (int(value.x) == ACROSS2)   return sd2Across(p, forShadow);\n    if (int(value.x) == INODE)     return sdINode(p, forShadow);\n    if (int(value.x) == CAPACITOR) return sdCapacitor(p, forShadow);\n    if (int(value.x) == RESISTOR)  return sdResistor(p, forShadow);\n        \n    return Result(1e6, M_BLACK);\n}\n\nResult scene(sampler2D sampler, vec3 res, vec3 p, bool forShadow)\n{\n    vec2 addr = (p.xz + .5) * res.y;\n    vec2 subaddr = (fract(addr) - .5);\n    vec3 subp = vec3(subaddr.x, p.y * res.y, subaddr.y);\n    vec4 value = texelFetch(sampler, ivec2(addr), 0);\n    Result minDist = sdCell(value, subp, p, forShadow);\n    minDist.dist /= res.y;\n    return minDist;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 grad( sampler2D sampler, vec3 res, in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(sampler, res, pos + e.xyy, false ).dist + \n\t\t\t\t\t  e.yyx*scene(sampler, res, pos + e.yyx, false ).dist + \n\t\t\t\t\t  e.yxy*scene(sampler, res, pos + e.yxy, false ).dist + \n\t\t\t\t\t  e.xxx*scene(sampler, res, pos + e.xxx, false ).dist );\n}\n\nResult rayMarch(sampler2D sampler, vec3 res, vec3 pos, vec3 dir, bool forShadow, out vec3 hitPos)\n{\n    float t = 0.;\n    \n    if (pos.y > MAX_Y) // skip immediately down to the max Y so we don't do unnecessary texture fetches\n    {\n        if (dir.y > 0.) { t = MAX_T; return Result(1e6, M_BLACK); }\n        t = (MAX_Y - pos.y) / dir.y;\n        pos += dir * t;\n    }\n    \n    int mat = M_BLACK;\n    for (int i = 0; i < MAX_MARCH_ITER; ++i)\n    {\n        Result d = scene(sampler, res, pos, forShadow);\n        mat = d.mat;\n        \n        if (d.dist < SDF_EPSILON || t > MAX_T)\n        {\n            break;\n        }\n        \n        t += d.dist * .5;\n        pos += dir * d.dist * .5;\n    }\n    \n    hitPos = pos;\n    return Result(t, mat);\n}\n\nvec3[3] calcLightPos(float time, vec3 res, vec3 cameraPos, vec3 cameraFwd)\n{\n    vec3 lightCenter = cameraPos;\n    lightCenter.y = 10. / res.y;\n    lightCenter.xz += cameraFwd.xz * 40. / res.y;\n\n    vec3[3] pos = vec3[]((15. / res.y) * vec3(sin(time),.0,cos(time)),\n                          (15. / res.y) * vec3(sin(time + PI*2./3.),.0,cos(time + PI*2./3.)),\n                          (15. / res.y) * vec3(sin(time + PI*4./3.),.0,cos(time + PI*4./3.)));\n    \n    pos[0].xy *= rot2(.2 * sin(time*.5));\n    pos[0].yz *= rot2(.2 * cos(time*.5));\n    pos[1].xy *= rot2(.2 * sin(time*.5));\n    pos[1].yz *= rot2(.2 * cos(time*.5));\n    pos[2].xy *= rot2(.2 * sin(time*.5));\n    pos[2].yz *= rot2(.2 * cos(time*.5));\n\n    pos[0] += lightCenter;\n    pos[1] += lightCenter;\n    pos[2] += lightCenter;\n\n    return pos;\n}\n\nconst vec3 LIGHT_COLORS[3] = vec3[](vec3(.7,0,0), vec3(0,.3,0), vec3(0,0,1));\n//const vec3 LIGHT_COLORS[3] = vec3[](vec3(1), vec3(1), vec3(1));  // white lights\n\nvec4 pixelInternal(sampler2D sampler, float time, vec3 res, vec3 cameraPos, vec3 cameraFwd, vec3 rayDir, out vec3 hitPos, out vec3 normal)\n{    \n    Result r = rayMarch(sampler, res, cameraPos, rayDir, false, hitPos);\n    normal = grad(sampler, res, hitPos);\n\n    // compute color\n    vec3 mColor = matColor(r.mat);\n    float mShiny = matShiny(r.mat);\n    \n    const float AMBIENT = .02;\n    vec3 color = (1.-mShiny) * mColor * AMBIENT;    \n\n    // apply light and shadow\n    vec3 lightPos[3] = calcLightPos(time, res, cameraPos, cameraFwd);\n                              \n    vec3 lightDir[3] = vec3[](normalize(lightPos[0] - hitPos),\n                              normalize(lightPos[1] - hitPos),\n                              normalize(lightPos[2] - hitPos));\n                              \n    for (int i = 0; i < 3; ++i)\n    {\n#if SHADOW\n        float shadowT = MAX_T;    \n        vec3 offsetPos = hitPos + normal * SDF_EPSILON * 3.;\n        vec3 shadowHit;\n        Result sResult = rayMarch(sampler, res, offsetPos, lightDir[i], true, shadowHit);\n        shadowT = sResult.dist;\n\n        if (shadowT >= MAX_T)\n#endif // SHADOW\n        {\n            float dp = max(0., dot(normal, lightDir[i]));\n            color += (1.-mShiny)*LIGHT_COLORS[i] * mColor * dp / (res.y * length2(lightPos[i] - hitPos));\n\n            vec3 reflection = reflect(lightDir[i], normal);\n            dp = max(0., dot(cameraFwd, reflection));\n\n            color.rgb += LIGHT_COLORS[i] * mShiny * .1 * pow(abs(dp), 15.0) / (res.y * length2(lightPos[i] - hitPos));\n        }\n    }\n    \n    // fade at distance\n    if (r.dist >= MAX_T*.75)\n    {\n        vec3 sky = vec3(.01);\n        color = mix(color, sky, smoothstep(MAX_T*.75, MAX_T, r.dist));\n    }\n    \n    return vec4(color.xyz, r.dist);\n    return vec4(normal, r.dist)*vec4(1,.1,1,1);\n}\n\n#define pixel(A, B, C, D, E) pixelInternal(iChannel0, iTime, iResolution, A, B, C, D, E)\n\nvoid fxCalcCamera(fxState state, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraPos = state.camPos;\n    vec3 delta = vec3(0,-.01,.015);\n    delta.xz *= rot2(state.camDir);\n    cameraLookAt = cameraPos + delta;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-cameraLeft, 0.0),\n        vec4(-cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// The room where it happens\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        if (TILES[i].selfConnect == false && int(n.x) == i) continue;\n        \n        mat3 myShape = TILES[i].shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if ((TILES[i].sym & (1 << ((d + 4 - r) % 4))) != 0 && tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES[g_ValidTiles[i]].shape, g_ValidTileRs[i] + r);\n        if (TILES[g_ValidTiles[i]].selfConnect == false && int(n.x) == g_ValidTiles[i]\n            || !tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)// || distance(fragCoord, vec2(0)) > 100.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    vec3 h = hash3(uvec3(fragCoord, iFrame));\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        if (h.x > .5)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 0.;\n            fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        }\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n       if (h.x < 1e-5)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    // Handle mouse input\n    if (iMouse.z > 0. && iMouse.w < 0. && state.lastMouse != vec2(0))\n    {\n        vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n        fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n        vec3 rayTo = fxCalcRay(iMouse.xy, iResolution, cameraFwd, cameraUp, cameraLeft);\n        float toT = cameraPos.y / rayTo.y;\n        vec3 toHit = cameraPos - toT * rayTo;\n        vec2 proj = (toHit.xz + .5) * iResolution.y;\n\n        if (distance(proj, fragCoord) < 5.)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 2.;\n            return;\n        }\n    }\n\n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + 1.1;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (g_NumValidTiles == 1 || h.z < TILES[g_ValidTiles[choice]].prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and direction\n// ---------------------------------------------------------------------------------------\n\nvoid updateCamera(inout fxState state)\n{\n    const float MOVE_SPEED = 0.0002;\n    vec3 camMove = vec3(0);\n    if (keyDown(KEY_W))\n    {\n        camMove.z += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_S))\n    {\n        camMove.z -= MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_A))\n    {\n        camMove.x += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_D))\n    {\n        camMove.x -= MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_R))\n    {\n        camMove.y += MOVE_SPEED;\n        state.attract = false;\n    }\n    if (keyDown(KEY_F))\n    {\n        camMove.y -= MOVE_SPEED;\n        state.attract = false;\n    }\n\n    if (state.attract)\n    {\n        state.camPos.x = .25*sin(iTime*.02);\n        state.camPos.z = .25*cos(iTime*.01);\n        state.camDir = iTime*.01*PI;\n    }\n\n    const float TURN_RATE = 0.02;\n    if (keyDown(KEY_Q))\n    {\n        state.camDir += TURN_RATE;\n        state.attract = false;\n    }\n    if (keyDown(KEY_E))\n    {\n        state.camDir -= TURN_RATE;\n        state.attract = false;\n    }\n\n    camMove.xz *= rot2(state.camDir);\n    state.camPos += camMove;\n\n    float MAX_HEIGHT = 0.6;\n    state.camPos.y = clamp(state.camPos.y, -MAX_HEIGHT, MAX_HEIGHT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { fragColor = vec4(0); return; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.attract = true;\n        state.camPos = vec3(0, 20. / iResolution.y, 0);\n        state.camDir = 0.;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        updateCamera(state);\n    }\n    \n    state.lastMouse = iMouse.xy;\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// Main render: RGB color A depth\n// ---------------------------------------------------------------------------------------\n\nvec4 render(vec2 u, fxState state)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(state, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 hitPos, normal;\n    return pixel(cameraPos, cameraFwd, rayDir, hitPos, normal);\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fxState state = fxGetState();\n\n    vec4 colorDepth = render(fragCoord, state);\n    fragColor.xyz = pow(ACESFilm(colorDepth.xyz), vec3(1./2.2));\n    fragColor.w = colorDepth.w;\n\n    // debug terrain texture\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * 10.;\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjSDz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2312, 2312, 2335, 2335, 2941], [2949, 2949, 2988, 2988, 3034]], "test": "untested"}
{"id": "msjSzG", "name": "Foobar's Sphere", "author": "FoobarBigTime", "description": "My first shader! I followed The Art of Code's tutorials for the camera and pixel coordinate setup, but I did manage to us my own method for calculating the surface normals.", "tags": ["raymarcher", "spheretracing", "firstshader"], "likes": 1, "viewed": 179, "published": 3, "date": "1670479533", "time_retrieved": "2024-07-30T16:14:13.141648", "image_code": "const float MAX_DIST = 100.;\nconst int MAX_STEPS = 50;\nconst float MIN_DIST = .01;\n\nvec4 normSDF_Sph(vec3 obsPoint, vec3 orig, float size){\n    vec3 disp_vec = orig - obsPoint;\n    float dist = length(disp_vec)-size;\n    return vec4 (disp_vec, dist);\n}\n\nvec4 sceneSDF(vec3 obsPoint){\n    return normSDF_Sph(obsPoint, vec3(0., 0., 0.), 1.);\n}\n\nvec4 rayMarcher(vec3 rayOrig, vec3 rayDir){\n    vec4 sdfValues = sceneSDF(rayOrig);\n    float dist = sdfValues.w;\n\n    for(int i = 0; i < MAX_STEPS; i ++){\n        vec3 p = rayOrig + rayDir*dist;\n        vec4 sdfValues = sceneSDF(p);\n\n        float newDist = sdfValues.w;\n        if(newDist < MIN_DIST){\n            return(sdfValues);\n        }\n        dist += newDist;\n        if(dist > MAX_DIST){\n            return vec4(.7, .2, .2, MAX_DIST);\n        }\n    }\n    return(vec4(rayDir, dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float FoVy = radians(45.);\n    \n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float turnSpeed = 0.005;\n    \n    vec3 camPos = vec3(4. * (sin(.01 * iMouse.x)), 0., 4. * (cos(.01 * iMouse.x)));\n    \n    //.5 is size of screen from center to edge\n    float camZoom = 1. / (tan(FoVy));\n    \n    vec3 camTarget = vec3(0., 0., 0.);\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camRight = cross(vec3(0., 1., 0.), camDir);\n    vec3 camUp = cross(camDir,camRight);\n    \n    vec3 camCenter = camPos + camDir*camZoom;\n    vec3 rayIntersect = camCenter + uv.x*camRight + uv.y*camUp;\n    \n    vec3 rayDir = rayIntersect-camPos;\n\n    //Draw Scene.\n    vec4 sceneView = rayMarcher(camPos, rayDir);\n    float hit = sceneView.w;\n    vec3 hitNormal = normalize(sceneView.xyz);\n    \n    vec3 col = vec3(1., 0., 1.);\n    vec3 lightDir = vec3(0., -.65, 2);\n    float lit = dot(lightDir, hitNormal);\n    fragColor = vec4(col*lit, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 139, 139, 252], [254, 254, 283, 283, 341], [343, 343, 386, 386, 838], [840, 840, 897, 897, 1898]], "test": "untested"}
{"id": "msBXzy", "name": "Hermite step", "author": "grinist", "description": "Fits a cubic curve to the unit interval, satisfying slopes k0 at x = 0 and k1 at x = 1, derived from Hermite basis functions.\nMouse x and y control k0 and k1.", "tags": ["graph", "cubic", "ramp", "hermite", "step", "interpolate"], "likes": 14, "viewed": 239, "published": 3, "date": "1670454663", "time_retrieved": "2024-07-30T16:14:13.895633", "image_code": "// Fits a cubic curve to the unit interval, satisfying slopes k0 at x = 0 and k1 at x = 1,\n// derived from Hermite basis functions.\n// One powerhouse of a function - you can get many family favorites with\n// just two extra slope parameters! \\:D/\n// The function values will escape the [0, 1] range with steep / negative slopes.\n// Mouse x and y control k0 and k1\n\n// For (k0, k1):\n// (1, 1) lerp\n// (0, 0) smoothstep\n// (0, 2) squared\n// (2, 0) inv squared\n// (3, 0) cubed\n// (0, 3) inv cubed\n// (0, 1) almost unit identity\n// (6, 0) a nice bounce to 1.25 at center\n\nfloat hermiteStep(float x, float k0, float k1)\n{\n    return x * (k0 + x * (3.0 - k0 - k0 - k1 + x * (k0 - 2.0 + k1)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setupGraph(vec2(0.5), vec2(1.6), fragCoord, iResolution);\n\n    // background\n\tfcol = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.8, 0.8, 0.8, 1.0), sqrlength(xy - graphCenter) / sqrlength(graphSize * 0.5));\n    \n\t// grid\n    drawGrid(0.1, px, vec4(0.0, 0.0, 0.0, 0.125));\n\tdrawGrid(0.5, px, vec4(0.0, 0.0, 0.0, 0.25));\n\tdrawGrid(1.0, px, vec4(0.0, 0.0, 0.0, 0.5));\n    \n    // curves\n    \n    // slope parameters\n    vec2 k = vec2(2.0, 0.0);\n    if (iMouse.z > 0.0)\n    {\n        k = graphPos + iMouse.xy / iResolution.xy * graphSize;\n        k *= 10.0;\n    }\n    else\n    {\n        float t = (iTime + 15.0) * 1.257; // nice initial values and a 25 sec loop\n        k = vec2(cos(t * 0.8), sin(t * 0.6)) * 0.5 + 0.5;\n        k *= 3.0;\n    }\n\n    // slopes around unit interval\n    vec3 col = vec3(0.15, 0.55, 0.9);\n    vec2 d = xy * 2.0;\n    float a = max(0.0, 0.5 - dot(d, d));\n    drawFunc(k.x * xy.x, px, vec4(col, a));\n    d = (xy - vec2(1, 1)) * 2.0;\n    a = max(0.0, 0.5 - dot(d, d));\n    drawFunc(k.y * (xy.x - 1.0) + 1.0, px, vec4(col, a));\n\n    // hermite step\n    vec2 unit = (step(xy, vec2(-px)) - step(xy, vec2(1.0 + px)));\n    a = 0.2 + 0.8 * (unit.x * unit.y);\n\tdrawFunc(hermiteStep(xy.x, k.x, k.y), 3.0 * px, vec4(col, a));\n\n\tfragColor = fcol;\n}\n", "image_inputs": [], "common_code": "vec2 graphSize;\nvec2 graphCenter;\nvec2 graphPos; // bottom left\n\nvec2 xy;\t// current graph coords\nfloat px;\t// pixel size in graph units, assumes uniform graph\nfloat aa;\t// aa falloff radius\nvec4 fcol;\t// current fragment color\n\nfloat lerpstep(float a, float b, float x)\n{\n    return (a == b) ? step(x, a) : clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nfloat sqrlength(vec2 v)\n{\n    return dot(v, v);\n}\n\nvoid mixColor(vec4 col, float alpha)\n{\n    fcol = vec4(mix(fcol.rgb, col.rgb, alpha * col.a), 1.0);\n}\n\nvoid drawGrid(float stepSize, float r, vec4 col)\n{\n\tvec2 grid = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) / stepSize));\n    float d = min(grid.x, grid.y) * stepSize;\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\nvoid drawCircle(vec2 pos, float r, vec4 col)\n{\n    float d = length(pos - xy);\n    mixColor(col, lerpstep(r + aa, r - aa, d));\n}\n\n// Draws an explicit function of x with a known derivative.\n// Uses y distance to curve, breaks with great derivatives and discontinuities.\nvoid drawFunc(float y, float dy, float r, vec4 col)\n{\n    float d = abs(y - xy.y);\n    float yspan = sqrt(1.0 + dy * dy); // accurate, decent approximate: abs(dy) + 1.0 / (abs(dy) + 1.0)\n\tmixColor(col, lerpstep(yspan * (r + aa), yspan * (r - aa), d));\n}\n\n// Draws an explicit function of x, uses screen space derivative.\nvoid drawFunc(float y, float r, vec4 col)\n{\n    drawFunc(y, dFdx(y) / px, r, col);\n}\n\n// Draws an explicit function of x with a known inverse.\n// Uses distance to curve in both y and x.\nvoid drawFuncWithInverse(float y, float x, float r, vec4 col)\n{\n    vec2 d = abs(vec2(xy.x - x, xy.y - y));\n    mixColor(col, lerpstep(r + aa, r - aa, max(d.x, d.y) / length(d) * min(d.x, d.y)));\n}\n\nvoid setupGraph(vec2 center, vec2 size, vec2 fragcoord, vec3 resolution)\n{\n    graphSize = size * (resolution.xy / resolution.y);\n    graphCenter = center;\n    graphPos = graphCenter - 0.5 * graphSize;\n    xy = graphPos + fragcoord / resolution.xy * graphSize;\n\tpx = graphSize.y / resolution.y;\n    aa = 0.5 * px;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msBXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 615, 615, 687], [689, 689, 744, 744, 2001]], "test": "untested"}
{"id": "cdjXzm", "name": "Codevember #20 Water Color 3", "author": "Etidou", "description": "Day 20 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["color", "watercolor", "codevember"], "likes": 4, "viewed": 188, "published": 3, "date": "1670452388", "time_retrieved": "2024-07-30T16:14:14.707462", "image_code": "const int AMOUNT = 2;\n\nfloat rand (vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 rotate (vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = 10.0 * (iResolution.xy / 2.0 - fragCoord.xy) / min(iResolution.x, iResolution.y);\n\n    float len;\n\n    for(int i = 0; i < AMOUNT; i++){\n        len = length(vec2(coord.x, coord.y));\n\n        coord.x = coord.x * 1.2 - cos(coord.y + sin(len)) + iTime / 1.0;\n        coord.y = coord.y + 1.8 - sin(coord.x + cos(len)) + iTime / 1.5;\n    }\n\n    fragColor = vec4(cos(len * 2.0), cos(len - 1.0), cos(len / 2.0) , 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 111], [113, 113, 144, 144, 228], [229, 229, 286, 286, 717]], "test": "untested"}
{"id": "cs2Szm", "name": "Codevember #19 Water Color 2", "author": "Etidou", "description": "Day 19 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["color", "watercolor", "codevember"], "likes": 3, "viewed": 180, "published": 3, "date": "1670452377", "time_retrieved": "2024-07-30T16:14:15.647947", "image_code": "const int AMOUNT = 6;\n\n\nfloat rand (vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 rotate (vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = 7.5 * fragCoord.xy / iResolution.xy;\n\n    for(int n = 1; n < 125; n++){\n        float i = float(n);\n        coord += vec2(1.5 / i * sin(i * coord.y + iTime + 10.3 * i) + 0.8, 0.4 / i * sin(coord.x + iTime + 0.3 * i) + 100.6);\n    }\n\n    vec3 color = vec3(0.5 * sin(coord.x) + 0.5, 0.5 * sin(coord.y) + 0.5, sin(coord.x + coord.y));\n\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2Szm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 45, 45, 112], [114, 114, 145, 145, 229], [231, 231, 288, 288, 675]], "test": "untested"}
{"id": "Dd2Szm", "name": "Codevember #18 Water Color 1", "author": "Etidou", "description": "Day 18 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["color", "watercolor", "codevember"], "likes": 6, "viewed": 188, "published": 3, "date": "1670452361", "time_retrieved": "2024-07-30T16:14:16.493686", "image_code": "float rand (vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 rotate (vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = 6.0 * fragCoord.xy / iResolution.xy;\n\n    for(int n = 1; n < 7; n++){\n        float i = float(n);\n        coord += vec2(2.0 / i * sin(i * coord.y + iTime + 0.3 * i) + 0.8, 0.4 / i * sin(coord.x + iTime + 0.3 * i) + 10.6);\n    }\n\n    vec3 color = vec3(0.5 * sin(coord.x) + 0.5, 0.5 * sin(coord.y) + 0.5, sin(coord.x + coord.y));\n\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2Szm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 88], [90, 90, 121, 121, 205], [207, 207, 264, 264, 647]], "test": "untested"}
{"id": "DsjSzm", "name": "Codevember #17 Vasarely", "author": "Etidou", "description": "Day 17 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "vasarely", "codevember", "reproduction"], "likes": 3, "viewed": 122, "published": 3, "date": "1670452349", "time_retrieved": "2024-07-30T16:14:17.313494", "image_code": "// Inspiration: https://www.shadertoy.com/view/WlscD2\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n#define DIVS 20.0\n\n\nfloat rand (vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 rotate (vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nbool approx (float a, float b, float d)\n{\n    return abs(a-b)<=d;\n}\n\nfloat circleSquare (vec2 uv, float t)\n{\n    float power = 4./(cos(t*PI/8.)+1.);\n    float lhs =\n        pow(abs(uv.x-uv.y), power) +\n        pow(abs(uv.y+uv.x), power)\n    ;\n    float rhs = 1.;\n    \n    return smoothstep(0.4, 0.5, rhs - lhs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n    uv.x*= iResolution.x / iResolution.y;\n    \n    // grid\n    vec2 div = uv * DIVS;\n    vec2 sq = fract(div) - .5;\n    vec2 id = floor(div);\n    \n    // rotation\n    float rot = clamp(cos(iTime + id.x *.2 + id.y * .2), -.5, .5) + .5;\n    sq = rotate(sq, rot * PI * .25);\n    \n    // rectangles\n    vec2 asq = abs(sq);\n\tfloat rect = circleSquare(asq * 2., iTime * 2. + id.x);\n    \n    vec2 idc = id / DIVS;\n    vec3 col = vec3(0);\n    col = mix(vec3(1., 0., 1.), vec3(0.1, 0.025, 0.5), min(1.0, idc.x - idc.y + .5)) * rect;\n    col-= .5 - length((id+.5) / DIVS);\n    \n    vec2 ptc1 = vec2(cos(iTime*.5) * .4, sin(iTime*.5) * .4);\n    col.rgb+= vec3(0.5, 1., 0) * (1. - length(ptc1 - idc)) * (1. - rect);\n    \n    vec2 ptc2 = vec2(cos(iTime*.5 + PI) * .4, sin(iTime*.5 + PI) * .4);\n    col.rgb+= vec3(.8, 0., .5) * (1. - length(ptc2 - idc)) * (1. - rect);\n    vec2 ptc3 = vec2(cos(iTime*1.0 + PI*.5) * .4, sin(iTime*1.0 + PI*.5) * .4);\n    col.rgb+= vec3(1., 1., 1.) * (1. - length(ptc3 - idc)) * (1. - rect) * (cos(iTime)*.2 + .4);\n    \n    col*= rand(uv) * .25 + .9;\n    \n\t\n    float visible = step(abs(id.x), DIVS);\n    \n    col+= rand(uv) * .1;\n    \n    col+= (1. - visible) * clamp(pow(max(0., (1.-length(uv))), .2)* 1.1, .2, 1.);\n    col.b*= .92;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 160, 160, 227], [229, 229, 260, 260, 344], [346, 346, 387, 387, 413], [415, 415, 454, 454, 659], [661, 661, 718, 768, 2100]], "test": "untested"}
{"id": "DdjSzm", "name": "Codevember #16 Vasarely", "author": "Etidou", "description": "Day 16 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "vasarely", "codevember"], "likes": 3, "viewed": 106, "published": 3, "date": "1670452330", "time_retrieved": "2024-07-30T16:14:18.184167", "image_code": "// Inspiration : https://www.shadertoy.com/view/WllcWj\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\n#define DIVS 20.0\n#define SMOOTH 0.02\n\nvec2 r2d (vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy-.5;\n    uv.x*= iResolution.x / iResolution.y;\n    \n    // space is divided into a grid\n    vec2 div = uv * DIVS;\n    vec2 sq = fract(div) - .35;\n    vec2 id = floor(div);\n    \n    // rotation of some squares given their distance to 2 moving points\n    float rot = 0.;\n    \n    vec2 p1 = vec2(cos(iTime*1.) * sin(iTime*1.4) * .2, sin(iTime*1.) * .5);\n    vec2 dr = p1 - id/DIVS;\n    float lp1 = smoothstep(0.4, -.01, abs(dr.x));\n    lp1*= smoothstep(0.4, -.1, abs(dr.y));\n    rot+= lp1 * cos(iTime) * cos(iTime*2.+4.) * cos(iTime*8.-0.2) * 8.;\n    \n    \n    vec2 p2 = vec2(cos(iTime*1.3 + 2.) * cos(iTime*.2+6.) * .3, sin(iTime*2. + 1.) * .35);\n    dr = p2 - id/DIVS;\n    float lp2 = smoothstep(0.4, -.01, abs(dr.x));\n    lp2*= smoothstep(0.4, -.1, abs(dr.y));\n    rot+= lp2 * cos(iTime) * cos(iTime*1.+4.6) * cos(iTime*12.+.7) * 4.;\n\n    \n    // rotate some of the divs\n    sq = r2d((sq - 0.15), rot);\n    \n    // the inner rectangle\n    vec2 asq = abs(sq + 0.25);\n    float s = sqrt(2. * pow(.5*.65, 2.));\n    float rect = smoothstep(s+SMOOTH, s-SMOOTH, (asq.x + 0.15)) * smoothstep(s+SMOOTH, s-SMOOTH, (asq.y + 0.15));\n    \n\n    // half is inverted\n    // rect = mix(rect, 1. - rect, sign(p2.y) * sign(p1.y) * sign(uv.y)*.5+.5);\n    vec3 col = vec3(rect, rect, rect);\n    \n    // we step on x to only have a visible square\n    float visible = step(uv.x, .5) * step(-.5, uv.x);\n    // and the outer cells\n    visible*= step(abs(id.x), DIVS*.5);\n    visible*= step(abs(id.y+.5), DIVS*.5);\n    \n    col*= visible;\n    \n    // // the background\n    // col+= 1. - visible;\n    // col*= clamp(pow(max(0., (1.-length(uv))), .2)* 1.1, .2, 1.) + visible;\n\n    col.b*= 0.12;\n    \n    \n    // we add the dots\n    // col.r+= smoothstep(0.4, 0.015, (length(p1 - uv) + 0.2));\n    // col.r+= smoothstep(0.4, 0.015, (length(p2 - uv) + 0.2));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 252, 252, 336], [339, 339, 396, 446, 2378]], "test": "untested"}
{"id": "ddSSRG", "name": "Line draw", "author": "oseday", "description": "buffer", "tags": ["buffer"], "likes": 2, "viewed": 152, "published": 3, "date": "1670439086", "time_retrieved": "2024-07-30T16:14:18.962086", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec2 mousePixel = vec2(0.5, 0.5);\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (mousePixel == fragCoord) {\n        fragColor = iMouse;\n        return;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb * 0.95;\n    \n    if (iMouse.z > 0. && iMouse.w < 0.) {\n        vec4 prevMouse = texture(iChannel0, mousePixel-0.5);\n        if (prevMouse.z > 0.) {\n            float d = distanceToSegment(iMouse.xy, prevMouse.xy, fragCoord);\n            if (d < 3.) {\n                col += 1.;\n            }\n        }\n    }\n    \n    col = min(col, 1.);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 153]], "test": "untested"}
{"id": "cdSXzy", "name": "Blackbody Temperature To RGB", "author": "Remming_Senegal", "description": "Black body temperature to RGB.\n\nThe hotter it is, the more it tends to blue", "tags": ["vector", "wavelength", "linearalgebra", "calculus", "researchpaper"], "likes": 3, "viewed": 215, "published": 3, "date": "1670435579", "time_retrieved": "2024-07-30T16:14:19.757958", "image_code": "// a VERY SPECIAL THANKS to this research paper:\n// https://www.fourmilab.ch/documents/specrend/\n// Needless to say this shader used so many pieces of that paper that this shader is basically a ripoff of all that work\n// I learned alot though! Will use this somewhere!\n\n#define LAMBDA_RED 780.0\n#define LAMBDA_VIOLET 380.0\n\n#define NMTOM(a) (a)*pow(10.0,-9.0)\n#define MTONM(a) (a)*pow(10.0,+9.0)\n\nconst mat3 NTSC_Chromaticity = \nmat3(\n    0.67, 0.21, 0.14,\n    0.33, 0.71, 0.08,\n    0.00, 0.08, 0.78\n);\nconst vec3 NTSC_White = vec3 (0.3101,0.3162, 1.0 - (0.3101 + 0.3162) );\n\n// Calculate spectra of a blackbody when a given wavelength is plugged into it\nfloat bb_spectrum(float wavelength, float bbTemp)\n{\n    float wlm = NMTOM(wavelength);\n\n    return (3.74183e-16 * pow(wlm, -5.0)) / (exp(1.4388e-2 / (wlm * bbTemp)) - 1.0);\n}\n\nvec3 XYZ(float bbTemp) {\n\n    // delta lambda is equal to 5nm\n    // stolen from https://www.fourmilab.ch/documents/specrend/\n    const int cie_colour_match_length = 81;\n    vec3 cie_colour_match[81] = vec3[](\n        vec3(0.0014,0.0000,0.0065), vec3(0.0022,0.0001,0.0105), vec3(0.0042,0.0001,0.0201),\n        vec3(0.0076,0.0002,0.0362), vec3(0.0143,0.0004,0.0679), vec3(0.0232,0.0006,0.1102),\n        vec3(0.0435,0.0012,0.2074), vec3(0.0776,0.0022,0.3713), vec3(0.1344,0.0040,0.6456),\n        vec3(0.2148,0.0073,1.0391), vec3(0.2839,0.0116,1.3856), vec3(0.3285,0.0168,1.6230),\n        vec3(0.3483,0.0230,1.7471), vec3(0.3481,0.0298,1.7826), vec3(0.3362,0.0380,1.7721),\n        vec3(0.3187,0.0480,1.7441), vec3(0.2908,0.0600,1.6692), vec3(0.2511,0.0739,1.5281),\n        vec3(0.1954,0.0910,1.2876), vec3(0.1421,0.1126,1.0419), vec3(0.0956,0.1390,0.8130),\n        vec3(0.0580,0.1693,0.6162), vec3(0.0320,0.2080,0.4652), vec3(0.0147,0.2586,0.3533),\n        vec3(0.0049,0.3230,0.2720), vec3(0.0024,0.4073,0.2123), vec3(0.0093,0.5030,0.1582),\n        vec3(0.0291,0.6082,0.1117), vec3(0.0633,0.7100,0.0782), vec3(0.1096,0.7932,0.0573),\n        vec3(0.1655,0.8620,0.0422), vec3(0.2257,0.9149,0.0298), vec3(0.2904,0.9540,0.0203),\n        vec3(0.3597,0.9803,0.0134), vec3(0.4334,0.9950,0.0087), vec3(0.5121,1.0000,0.0057),\n        vec3(0.5945,0.9950,0.0039), vec3(0.6784,0.9786,0.0027), vec3(0.7621,0.9520,0.0021),\n        vec3(0.8425,0.9154,0.0018), vec3(0.9163,0.8700,0.0017), vec3(0.9786,0.8163,0.0014),\n        vec3(1.0263,0.7570,0.0011), vec3(1.0567,0.6949,0.0010), vec3(1.0622,0.6310,0.0008),\n        vec3(1.0456,0.5668,0.0006), vec3(1.0026,0.5030,0.0003), vec3(0.9384,0.4412,0.0002),\n        vec3(0.8544,0.3810,0.0002), vec3(0.7514,0.3210,0.0001), vec3(0.6424,0.2650,0.0000),\n        vec3(0.5419,0.2170,0.0000), vec3(0.4479,0.1750,0.0000), vec3(0.3608,0.1382,0.0000),\n        vec3(0.2835,0.1070,0.0000), vec3(0.2187,0.0816,0.0000), vec3(0.1649,0.0610,0.0000),\n        vec3(0.1212,0.0446,0.0000), vec3(0.0874,0.0320,0.0000), vec3(0.0636,0.0232,0.0000),\n        vec3(0.0468,0.0170,0.0000), vec3(0.0329,0.0119,0.0000), vec3(0.0227,0.0082,0.0000),\n        vec3(0.0158,0.0057,0.0000), vec3(0.0114,0.0041,0.0000), vec3(0.0081,0.0029,0.0000),\n        vec3(0.0058,0.0021,0.0000), vec3(0.0041,0.0015,0.0000), vec3(0.0029,0.0010,0.0000),\n        vec3(0.0020,0.0007,0.0000), vec3(0.0014,0.0005,0.0000), vec3(0.0010,0.0004,0.0000),\n        vec3(0.0007,0.0002,0.0000), vec3(0.0005,0.0002,0.0000), vec3(0.0003,0.0001,0.0000),\n        vec3(0.0002,0.0001,0.0000), vec3(0.0002,0.0001,0.0000), vec3(0.0001,0.0000,0.0000),\n        vec3(0.0001,0.0000,0.0000), vec3(0.0001,0.0000,0.0000), vec3(0.0000,0.0000,0.0000)\n    );\n    \n    vec3 xyz = vec3(0.0);\n    float lambda = LAMBDA_VIOLET;\n    int i = 0;\n    while(lambda <= LAMBDA_RED) {\n        // get the specular intensity of the color matching function\n        float spec_intens = bb_spectrum(lambda,bbTemp);\n        xyz += spec_intens*cie_colour_match[i];\n        i++;\n        lambda += 5.0;\n    }\n    \n    return xyz;\n}\n\nvec3 ChromaticityValue(vec3 CIE) {\n    float x = CIE.x / (CIE.x + CIE.y + CIE.z);\n    float y = CIE.y / (CIE.x + CIE.y + CIE.z);\n    float z = CIE.z / (CIE.x + CIE.y + CIE.z);\n    \n    return vec3(x,y,z);\n}\n\nvec3 constrainRGB(vec3 col) {\n    vec3 ret = col;\n    float w = -min(0.0, min(col.r,min(col.g,col.b)));\n    \n    w = (0.0 < col.r) ? 0.0 : col.r;\n    w = (0.0 < col.g) ? w : col.g;\n    w = (0.0 < col.b) ? w : col.b;\n    w = -w;\n    \n    if(w > 0.0) {\n        ret.r += w;\n        ret.g += w;\n        ret.b += w;\n    }\n    \n    return ret;\n}\n\nvec3 normalizeRGB(vec3 col) {\n#define MAX(a , b) ((a) > (b)) ? (a) : (b)\n    float greatest = MAX(col.r, MAX(col.g, col.b));\n    \n    if(greatest > 0.0) {\n        return col/greatest;\n    }\n    \n    return col;\n\n}\n\nvec3 getJVector(vec3 w, mat3 table, vec3 xyz) {\n    // linear algebra moment\n    \n    float xc = xyz.x;\n    float yc = xyz.y;\n    float zc = xyz.z;\n\n    float xr, yr, zr, xg, yg, zg, xb, yb, zb;\n    float xw, yw, zw;\n    float rx, ry, rz, gx, gy, gz, bx, by, bz;\n    float rw, gw, bw;\n    \n    // values from table\n    xr = table[0][0];\n    yr = table[1][0];\n    zr = 1.0 - (xr + yr);\n    \n    xg = table[0][1];\n    yg = table[1][1];\n    zg = 1.0 - (xg + yg);\n    \n    xb = table[0][2];\n    yb = table[1][2];\n    zb = 1.0 - (xb + yb);\n    \n    // white values\n    xw = w.x;\n    yw = w.y;\n    zw = w.z;\n    \n    // More declarations\n    rx = (yg * zb) - (yb * zg);  ry = (xb * zg) - (xg * zb);  rz = (xg * yb) - (xb * yg);\n    gx = (yb * zr) - (yr * zb);  gy = (xr * zb) - (xb * zr);  gz = (xb * yr) - (xr * yb);\n    bx = (yr * zg) - (yg * zr);  by = (xg * zr) - (xr * zg);  bz = (xr * yg) - (xg * yr);\n    \n    // Declaring the white factor\n    rw = ((rx * xw) + (ry * yw) + (rz * zw)) / yw;\n    gw = ((gx * xw) + (gy * yw) + (gz * zw)) / yw;\n    bw = ((bx * xw) + (by * yw) + (bz * zw)) / yw;\n    \n    // scale by the white factor\n    rx = rx / rw;  ry = ry / rw;  rz = rz / rw;\n    gx = gx / gw;  gy = gy / gw;  gz = gz / gw;\n    bx = bx / bw;  by = by / bw;  bz = bz / bw;\n    \n    float r = (rx * xc) + (ry * yc) + (rz * zc);\n    float g = (gx * xc) + (gy * yc) + (gz * zc);\n    float b = (bx * xc) + (by * yc) + (bz * zc);\n    \n    return vec3(r,g,b);\n}\n\n// The almighty\nvec3 getRGB(float bbTemp) {\n    vec3 cc = XYZ(bbTemp);\n    \n    vec3 col = ChromaticityValue(cc);\n    \n    vec3 J = getJVector(NTSC_White, NTSC_Chromaticity, col);\n    \n    vec3 constrained = constrainRGB(J);\n    \n    vec3 n = normalizeRGB(constrained);\n    \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Left side of the screen is RGB at 1000 Kelvin\n    // Right side of the screeen is RGB at 10000 Kelvin\n    uv.x *= 9000.0;\n    uv.x += 1000.0;\n    \n    vec3 col = getRGB(uv.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 655, 706, 706, 829], [3884, 3884, 3918, 3918, 4090], [4092, 4092, 4121, 4121, 4431], [4433, 4433, 4462, 4462, 4646], [4648, 4648, 4695, 4724, 6106], [6108, 6124, 6151, 6151, 6398], [6400, 6400, 6457, 6507, 6789]], "test": "untested"}
{"id": "DsBSDw", "name": "The Sniff (Spectrogram Image)", "author": "Retard_Gaming", "description": "restart after the audio loads for the full effect\nuses a spectrogram to draw funny cat picture", "tags": ["image", "cat", "spectrogram"], "likes": 2, "viewed": 182, "published": 3, "date": "1670427419", "time_retrieved": "2024-07-30T16:14:20.607687", "image_code": "// go to buffer A\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 info = texture(iChannel0, uv);\n\n    fragColor = info;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// set to 0 if you want it to stay still\n#define scroll 1\n\n\n//spectrogram\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n#if scroll\n    if(fragCoord.x > iResolution.x - 1.) {\n        fragColor = texture(iChannel1, vec2(uv.y, 0)).rrrr;\n    } else {\n        fragColor = texture(iChannel0, uv + vec2(0.01, 0.));\n    }\n#else\n    if(uv.x > iTime/3.) {\n        fragColor = texture(iChannel1, vec2(uv.y, 0)).rrrr;\n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n#endif\n    \n    \n\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31125, "src": "https://soundcloud.com/retardgaming1967/result-15/s-GmUqsW2xAdl?si=a869038115f94fe99fa88d0289d5d54c&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// useless buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBSDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 75, 75, 185]], "test": "untested"}
{"id": "dsjXDm", "name": "SphericalFibonacci", "author": "EvilRyu", "description": "Just a simple visualizer", "tags": ["sphericalfibonacci", "hemisphericalfibonacci"], "likes": 8, "viewed": 571, "published": 3, "date": "1670423388", "time_retrieved": "2024-07-30T16:14:21.439463", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.1415926535\n\n\n// set to 0 for spherical fibonacci\n#define HEMISPHERICAL 1\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nconst float gNum = 64.;\n\n// from http://gec.di.uminho.pt/psantos/Publications_ficheiros/SF_CGF2013.pdf\n\n// unoptimized version\n\n// j: index of the point to generate\nvec3 sphericalFibonacci(float j)\n{\n    //float phi = 2. * PI * j * (2. / (1. + sqrt(5.)));\n    float phi = 2. * PI * j * (2. / (3. - sqrt(5.)));\n    float theta = acos(1. - 2. * j / gNum);\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nvec3 HemisphericalFibonacci(float j)\n{\n    float phi = 2. * PI * j * (2. / (3. - sqrt(5.)));\n    float theta = acos(1. - (2. * j + 1.) / (2. * gNum));\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nfloat gRayId = 0.;\n\nfloat map(vec3 p)\n{\n    p.xyz = p.xzy;\n    float d = 100.;\n    for(float i = 1.; i < gNum; i += 1.)\n    {\n    \n    #if HEMISPHERICAL\n        vec3 q = HemisphericalFibonacci(i);\n    #else\n        vec3 q = sphericalFibonacci(i);\n    #endif\n        \n        float dd = length(p-q) - 0.05;\n        if(d > dd)\n        {\n            gRayId = i;\n            d = dd;\n        }\n    }\n    \n    float d0 = length(p) - .99;\n    if(d > d0)\n    {\n        gRayId = -1.;\n        d = d0;\n    }\n    return d;\n}\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t = 0.1;\n    float d = 1e10;\n    for(int i = 0; i < 128; ++i)\n    {\n        if(d < 0.001 || t > 100.)\n            break;\n            \n        d = map(ro + t * rd);\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps=vec2(0.001,0.);\n    return normalize(vec3(map(p+eps.xyy)-map(p-eps.xyy),\n                    map(p+eps.yxy)-map(p-eps.yxy),\n                    map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    return mat3(r,u,f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * 2.;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 ta = vec3(0);\n    vec3 ro = vec3(cos(0.1*time + 7.0*mo.x), mo.y*2. - 1., sin(0.1*time + 7.0*mo.x) )*-3.;\n    vec3 rd = normalize(cam(ro, ta) * vec3(p.x, p.y, 2.3));\n    \n    float t = intersect(ro, rd);\n    \n    vec3 col = vec3(1., 0.98, 0.94);\n    \n    if(t < 100.)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = getNormal(pos);\n        \n        if(gRayId < 0.)\n            col = vec3(.3);\n        else\n            col = hsv2rgb(vec3(gRayId / gNum, 1., 1.));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjXDm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[197, 197, 219, 219, 345], [476, 513, 547, 603, 778], [780, 780, 818, 818, 1007], [1029, 1029, 1048, 1048, 1521], [1524, 1524, 1559, 1559, 1776], [1778, 1778, 1802, 1802, 1994], [1996, 1996, 2024, 2024, 2160], [2162, 2162, 2219, 2219, 2924]], "test": "untested"}
{"id": "NltyRN", "name": "chaotic lines", "author": "Jormala", "description": "where are the lines and what's chaotic?", "tags": ["lines"], "likes": 2, "viewed": 205, "published": 3, "date": "1670421647", "time_retrieved": "2024-07-30T16:14:22.244311", "image_code": "#define PI acos(-1.)\n#define TAU 2.0*PI\n\n#define LINE_COUNT 16\n#define SCALE 6.0\n\n#define nsin(x) sin(x*TAU)*0.5+0.5\n\nstruct Line\n{\n    vec2 pos;\n    float ang;\n    float seed;\n};\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(float x, float seed)\n{\n    float noiseVal = 0.;\n    noiseVal += texture(iChannel0, vec2(x, seed)     ).r;\n    noiseVal += texture(iChannel0, vec2(x+1./1024., seed) ).r;\n    noiseVal += texture(iChannel0, vec2(x+2./1024., seed) ).r;\n    noiseVal += texture(iChannel0, vec2(x+3./1024., seed) ).r;\n    return noiseVal/4.0;\n}\n\nvoid rotate(inout vec2 point, float ang)\n{\n    point *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\nfloat distFromLine(Line l, vec2 point)\n{\n    point -= l.pos;\n    rotate(point, -l.ang);\n\n    float off = sin(point.x*TAU)*0.25*(nsin(iTime*0.05)+0.1);\n    off += noise(point.x/4.0, l.seed)*.2-0.1;\n    \n    float dist = abs(point.y - off);\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(0.5, 0.5*iResolution.y/iResolution.x);\n\n    vec2 raw_point = fragCoord.xy/iResolution.xx;\n    vec2 raw_p = raw_point-center;\n    float raw_dist = length(raw_p);\n    float raw_p_ang = atan(raw_p.y, raw_p.x)+TAU;\n    \n    float cx = iTime*TAU*0.09;\n    vec2 off = vec2( cos(cx), sin(cx) );\n    \n    vec2 noiseCoord = vec2( cos(raw_p_ang), sin(raw_p_ang) )*0.01+off*0.01;\n    \n    float r = center.y/2.;\n    float r_off = r/10.0;\n    float r_off_off = (noise(noiseCoord.x, noiseCoord.y)*0.2);\n    r += r_off_off*0.2;\n    r_off += r_off_off;\n    \n    float nadd = 7.;\n    float nmult = -3.;\n    float outNoise = noise(noiseCoord.x, noiseCoord.y);\n    \n    outNoise *= nmult;\n    outNoise += nadd;\n    \n    if (raw_dist > r)\n    {\n        float alpha = abs(raw_dist-r);\n        alpha *= outNoise;\n        alpha = clamp(1.-alpha, 0., 1.);\n        alpha = smoothstep(0., 1., alpha);\n        \n        fragColor = vec4(alpha);\n        return;\n    }\n    \n    vec2 point = normalize(raw_p)*acos(raw_dist/r)/TAU*0.25+center;\n    \n    float t = iTime*0.05;\n    t = abs(1.-mod(t, 2.));\n    t = smoothstep(0., 1., t);\n    point = mix(raw_point, point, t);\n    \n    point *= SCALE;\n    center *= SCALE;\n    vec2 p = point-center;\n    float dist = length(p);\n    \n    Line[LINE_COUNT] lines;\n    for (int i=0; i<LINE_COUNT; i++)\n    {\n        float seed = float(i+1)*1000.6874;\n        \n        vec2 pos = vec2(noise(float(i+1)*0.1, seed), noise(float(i+1)*0.2, seed));\n        vec2 dir = vec2(noise(float(i+1)*0.3, seed), noise(float(i+1)*0.4, seed));\n        dir -= pos;\n        \n        pos += dir*iTime*0.001;\n        pos.x = abs(abs(mod(pos.x*2.0, 2.0)-1.0)-1.0)*SCALE;\n        pos.y = abs(abs(mod(pos.y*2.0, 2.0)-1.0)-1.0)*center.y*2.;\n        \n        float ang = noise(float(i+1)*0.5, seed)*TAU+iTime*0.05;\n        \n        lines[i] = Line(pos, ang, seed);\n    }\n    \n    \n    float min_dfl = distFromLine(lines[0], point);\n    for (int i=1; i<LINE_COUNT; i++)\n    {\n        Line l = lines[i];\n        float dfl = distFromLine(l, point);\n        if (dfl < min_dfl)\n            min_dfl = dfl;\n    }\n    \n    /*\n    min_dist = abs(mod(min_dist*2.0, 2.)-1.);\n    min_dist = clamp(min_dist, 0.0, 1.0);\n    min_dist = smoothstep(0., 1., 1.0-min_dist);\n    */\n    \n    float hue = min_dfl*0.1*SCALE;\n    \n    hue += (point.x+point.y/2.)*0.1*SCALE;\n    hue += sin(hue*TAU*6.0)*0.015;\n    \n    float bright = sin(4.*(p.x+p.y)-iTime*2.)*0.15+0.85;\n    \n    vec2 sp = p + off*center.y/2.;\n    float s = atan(sp.y, sp.x)*5.;\n    s += (dist+sin(dist*TAU*6.0)*0.03)*5./SCALE;\n    s += iTime*0.05*TAU;\n    \n    s = clamp(sin(s), 0., 1.);\n    \n    hue += s*2./6.;\n    \n    vec2 uv = raw_p*5.5+vec2(0.55, 0.5);\n    uv = clamp(uv, vec2(0.), vec2(1.));\n    if (texture(iChannel1, uv) == vec4(vec3(0.), 1.))\n    {\n        hue += .5;\n        bright -= 0.1;\n    }\n    \n    float sat = abs(mod(min_dfl*2.0, 2.)-1.);\n    sat = clamp(sat, 0.0, 1.0);\n    sat = smoothstep(0., 1., 1.0-sat);\n    sat = 0.7-sat*0.2;\n    \n    vec3 col = vec3(hue, sat, bright);\n    col = hsv2rgb(col);\n    \n    if (raw_dist > r-r_off)\n    {\n        float t = abs(raw_dist-r);\n        t *= outNoise;\n        t = clamp(1.-t, 0., 1.);\n        t *= (raw_dist-r+r_off)/r_off;\n        t = smoothstep(0., 1., t);\n        \n        float hue = raw_p_ang/PI/2.+iTime*0.09;\n        vec3 nc = hsv2rgb( vec3(hue, 0.8, 1.) );\n        \n        col = mix(col, nc, t);\n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 203, 203, 372], [374, 374, 394, 394, 464], [466, 466, 500, 500, 799], [801, 801, 843, 843, 905], [907, 907, 947, 947, 1169]], "test": "untested"}
{"id": "ftGcRV", "name": "deep well", "author": "Jormala", "description": "looking well", "tags": ["mirror"], "likes": 4, "viewed": 191, "published": 3, "date": "1670421595", "time_retrieved": "2024-07-30T16:14:23.127948", "image_code": "#define BASE 2.\n#define lb(x) log(x)/log(BASE)\n#define TAU acos(-1.)*2.\n\n\nvec4 toTexture(vec2 uv)\n{\n    // This renders one 'tile'\n    \n    float a = iTime/10.0*TAU;\n    uv -= cos(a*sqrt(2.));\n    \n    uv *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    uv *= sin(a)*0.5+0.6;\n    \n    uv += 0.5;\n    \n    return texture(iChannel0, uv);\n}\n\nvec4 sampleCoord(vec2 coord)\n{\n    float dirX = floor( lb(coord.x) );\n    float dirY = floor( lb(coord.y) );\n    \n    float lenX = pow(BASE, dirX);\n    float lenY = pow(BASE, dirY);\n    \n    float ux = (coord.x-lenX) / lenX / (BASE - 1.);\n    float uy = (coord.y-lenY) / lenY / (BASE - 1.);\n    \n    if (dirX > dirY)\n    {\n        uy = (coord.y+lenX-lenX) / lenX / (BASE - 1.);\n        dirY = dirX+1.;\n    }\n    \n    else if (dirY > dirX)\n    {\n        ux = (coord.x+lenY-lenY) / lenY / (BASE - 1.);\n        dirX = dirY+1.;\n    }\n    \n    if (int(mod(abs(dirX), 2.)) == 0)\n        ux = ux*-1.+1.;\n    \n    if (int(mod(abs(dirY), 2.)) == 0)\n        uy = uy*-1.+1.;\n    \n    vec2 uv = vec2(ux, uy);\n    \n    return toTexture(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord/iResolution.yy;\n    coord -= vec2(0.5*iResolution.x/iResolution.y, 0.5);\n    \n    float m = pow(BASE, mod(iTime*2., 2.));\n    coord *= 1./m;\n    \n    float a = iTime/10.0*TAU;\n    coord *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    vec4 col = sampleCoord(abs(coord));\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 99, 130, 339], [341, 341, 371, 371, 1070], [1072, 1072, 1129, 1129, 1452]], "test": "untested"}
{"id": "ddjXWm", "name": "Ectoplasmic Penguins", "author": "dr2", "description": "Another family trip. But can they leave footprints?", "tags": ["ghost", "tux", "footprint"], "likes": 12, "viewed": 232, "published": 3, "date": "1670420522", "time_retrieved": "2024-07-30T16:14:24.120295", "image_code": "// \"Ectoplasmic Penguins\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// (Starting from \"Tux Family Trip\" ...)\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\n#define N_PENG 6\n\nstruct Leg {\n  vec2 cs1, cs2, cs3;\n  float zFoot;\n};\nstruct Walker {\n  Leg leg[2];\n  vec3 wPos;\n  vec2 csHead, csBod;\n  float szFac, hHip, lLeg, stride, tPhs;\n};\nWalker wlk[N_PENG];\n\nvec3 sunDir, qHit, wPos;\nfloat tCur, dstFar, spd, fAng;\nint idObj;\nconst int idLeg = 1, idFoot = 2, idBod = 3, idHead = 4, idBk = 5, idEye = 6, idFlp = 7;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetWlkConf ()\n{  // (based on \"Walkers\")\n  vec2 w;\n  float sDir, t, tH, tt, tV, limT, fUp, limEx, a1, a2, fh, sz, x;\n  tH = 0.01;\n  tV = 0.3;\n  limT = 0.5;\n  limEx = 0.95;\n  fUp = 1.;\n  x = 10.5;\n  sz = 1.;\n  for (int j = 0; j < N_PENG; j ++) {\n    wlk[j].szFac = sz;\n    wlk[j].lLeg = 0.9;\n    wlk[j].hHip = limEx * 4. * wlk[j].lLeg * cos (atan (limT));\n    wlk[j].tPhs = mod (tCur * spd * (3./2.) / (wlk[j].szFac * wlk[j].hHip * limT), 4.);\n    for (int k = 0; k < 2; k ++) {\n      t = mod (wlk[j].tPhs + float (2 * k), 4.);\n      if (t > 1.) {\n        sDir = -1.;\n        t = (t - 1.) / 3.;\n      } else sDir = 1.;\n      tt = 0.5 - abs (t - 0.5);\n      a1 = atan (limT * (((tt < tH) ? tt * tt / tH : 2. * tt - tH) / (1. - tH) - 1.)) *\n         sign (0.5 - t) * sDir;\n      fh = wlk[j].hHip;\n      if (sDir > 0.) fh -= fUp * smoothstep (0., tV, tt);\n      a2 = - acos (fh / (4. * wlk[j].lLeg * cos (a1)));\n      wlk[j].leg[k].cs1 = CosSin (-0.5 * pi + a1 + a2);\n      wlk[j].leg[k].cs2 = CosSin (-2. * a2);\n      wlk[j].leg[k].cs3 = CosSin (0.5 * pi - a1 + a2);\n      w = Rot2Cs (vec2 (0., -2. * wlk[j].lLeg), wlk[j].leg[k].cs2);\n      w.y -= 2. * wlk[j].lLeg + 0.1;\n      wlk[j].leg[k].zFoot = Rot2Cs (w, wlk[j].leg[k].cs3).y - 0.8;\n    }\n    wlk[j].stride = 4.08;\n    wlk[j].csBod = CosSin (0.05 * pi * sin (0.5 * pi * wlk[j].tPhs + pi));\n    wlk[j].csHead = CosSin (0.2 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       mod (0.4 * tCur / wlk[j].szFac, 1.)) - 1.));\n    wlk[j].wPos = wPos - vec3 (x, -0.3 * wlk[j].szFac, 0.);\n    x -= 8.5 * wlk[j].szFac;\n    sz *= 0.75;\n  }\n}\n\nfloat PengDf (vec3 p, float dMin, Walker wk)\n{  // (based on \"Tux the Penguin\")\n  vec3 pp, q, qq, fSize;\n  float d, legRad;\n  p.y -= wk.hHip;\n  if (! isSh) d = PrSphDf (p, 7.);\n  if (isSh || d < dMin) {\n    legRad = 0.12;\n    pp = p;\n    p.xy = Rot2Cs (p.xy, wk.csBod);\n    p.y -= 0.9;\n    p.xz = - p.xz;\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (2.6, 2.4, 2.8));\n    DMINQ (idBod);\n    q = p;\n    q.xz = Rot2Cs (q.xz, wk.csHead);\n    qq = q;\n    q.y -= 3.;\n    d = PrEllipsDf (q.xzy, vec3 (1.6, 1.2, 2.6));\n    q.x = abs (q.x);\n    q -= vec3 (0.6, 1., -0.8);\n    d = max (d, - PrCylDf (q, 0.3, 0.5));\n    DMINQ (idHead);\n    q = qq;\n    q.x = abs (q.x);\n    q -= vec3 (0.6, 4., -0.8);\n    d = PrSphDf (q, 0.3);\n    DMINQ (idEye);\n    q = qq;\n    q.yz -= vec2 (3., -1.2);\n    d = max (PrEllipsDf (q, vec3 (0.8, 0.4, 1.2)), 0.01 - abs (q.y));\n    DMINQ (idBk);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (2.2, 0.6, -0.4);\n    q.yz = Rot2Cs (q.yz, CosSin (-0.25 * pi));\n    q.xy = Rot2Cs (q.xy, CosSin (fAng)) - vec2 (0.2, -0.8);\n    d = PrEllipsDf (q.xzy, vec3 (0.2, 0.5, 1.8));\n    DMINQ (idFlp);\n    for (int k = 0; k < 2; k ++) {\n      p = pp;\n      p.x += 1. * sign (float (k) - 0.5);\n      p.y -= -0.2;\n      q = p.yxz;\n      q.xz = Rot2Cs (q.xz, wk.leg[k].cs1);\n      q.z -= wk.lLeg;\n      d = PrCapsDf (q, legRad, wk.lLeg);\n      DMINQ (idLeg);\n      q.z -= wk.lLeg;\n      q.xz = Rot2Cs (q.xz, wk.leg[k].cs2);\n      q.z -= wk.lLeg;\n      d = PrCapsDf (q, legRad, wk.lLeg);\n      DMINQ (idLeg);\n      q.z -= wk.lLeg + 0.1;\n      q.xy = q.yx;\n      q.yz = Rot2Cs (q.yz, wk.leg[k].cs3);\n      q.z = - q.z;\n      q.xz = Rot2Cs (q.xz, CosSin (0.05 * pi * sign (float (k) - 0.5))) + vec2 (0., 0.8);\n      fSize = vec3 (0.3, 0.13, 1.);\n      d = SmoothMin (PrEllipsDf (vec3 (Rot2Cs (vec2 (abs (q.x), q.z - 0.8),\n         CosSin (-0.15 * pi)) + vec2 (0., 0.8), q.y).xzy, fSize), PrEllipsDf (q, fSize), 0.05);\n      DMINQ (idFoot);\n    }\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  for (int j = VAR_ZERO; j < N_PENG; j ++) {\n    dMin = min (wlk[j].szFac * PengDf ((p - wlk[j].wPos) / wlk[j].szFac, dMin / wlk[j].szFac,\n       wlk[j]), dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.75, 0.75, 0.8);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.7 * Fbm2 (0.1 * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nfloat FootSil (vec2 s)\n{\n  s.x = abs (s.x);\n  return min (length (vec2 (3.3, 1.) * (Rot2Cs (s + vec2 (0., 0.8),\n     CosSin (0.15 * pi)) - vec2 (0., 0.8))), length (vec2 (3.3, 1.) * s)) - 0.9;\n}\n\nfloat PengFoot (vec3 p)\n{\n  vec3 q;\n  float dMin, s;\n  dMin = 1.;\n  for (int j = VAR_ZERO; j < N_PENG; j ++) {\n    for (int k = 0; k < 2; k ++) {\n      if (mod (wlk[j].tPhs + float (2 * k), 4.) > 1.) {\n        s = sign (float (k) - 0.5);\n        dMin = min (dMin, FootSil (Rot2Cs (((p.xz - wlk[j].wPos.xz) / wlk[j].szFac +\n           vec2 (1.1 * s, wlk[j].leg[k].zFoot)), CosSin (-0.05 * pi * s))));\n      }\n    }\n    for (int k = 0; k < 2; k ++) {\n      q = p;\n      if (q.z < wlk[j].wPos.z) {\n        q.x -= wlk[j].wPos.x;\n        q /= wlk[j].szFac;\n        s = sign (float (k) - 0.5);\n        dMin = min (dMin, FootSil (Rot2Cs (vec2 (q.x + 1.1 * s, wlk[j].stride *\n           (fract ((q.z + (0.25 * s + 0.5) * wlk[j].stride - 0.3) /\n           wlk[j].stride + 0.5) - 0.5)), CosSin (-0.05 * pi * s))));\n      }\n    }\n  }\n  return 1. - smoothstep (0., 0.01, dMin);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, colB;\n  float dstObj, dstGrnd, sh, nDotL, fadeFac;\n  fadeFac = SmoothBump (0.25, 0.75, 0.22, fract (0.03 * tCur));\n  fAng = -0.2 * pi + 0.15 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (8. * pi * tCur);\n  SetWlkConf ();\n  roo = ro;\n  if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col = mix (vec3 (1., 1., 1.), vec3 (0.95, 0.97, 1.),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * ro.xz)));\n    col *= 1. - 0.2 * PengFoot (ro) * (1. - smoothstep (0.8, 1., dstGrnd / dstFar));\n    vn = GrndNf (ro);\n    isSh = true;\n    sh = (dstGrnd < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    sh = mix (sh, 1., min (1., 1.5 * fadeFac));\n    col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.2, 0.5, 0.9), 0.9 * pow (abs (rd.y), 12.));\n    if (dstGrnd >= dstFar) col = mix (col, vec3 (0.75, 0.75, 0.8), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  colB = col;\n  ro = roo;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (idObj == idBod) {\n      col4 = mix (vec4 (0.15, 0.15, 0.25, 0.1), vec4 (0.95, 0.95, 0.95, 0.05),\n         step (qHit.z, -1.3));\n      col4 = mix (vec4 (1., 0.9, 0., 0.2), col4, smoothstep (0., 0.05,\n         min (2.25 - qHit.y, abs (qHit.z + 1.2) - 0.15)));\n    } else if (idObj == idHead) {\n      col4 = (qHit.z < 0.5 && length (qHit.xy) < 0.4) ? vec4 (0.95, 0.95, 0.95, 0.05) :\n         vec4 (0.15, 0.15, 0.25, 0.1);\n      col4 = mix (vec4 (1., 0.9, 0., 0.2), col4, smoothstep (0., 0.05, qHit.y + 1.4));\n    } else if (idObj == idBk) {\n      col4 = vec4 (1., 0.8, 0.2, 0.2);\n    } else if (idObj == idEye) {\n      col4 = vec4 (0., 0., 0., -1.);\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.8, 0.8, 0.2, 0.2) * (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05,\n         fract (8. * qHit.z)));\n    } else if (idObj == idFoot) {\n      col4 = vec4 (0.4, 0.4, 1., 0.2);\n    } else if (idObj == idFlp) {\n      col4 = mix (vec4 (0.95, 0.95, 0.95, 0.05), vec4 (0.15, 0.15, 0.25, 0.1),\n         step (-0.05, qHit.x));\n    }\n    vn = ObjNf (ro);\n  }\n  col = colB;\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      isSh = true;\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      nDotL = max (dot (vn, sunDir), 0.);\n      nDotL *= nDotL;\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    } else col = mix (vec3 (0., 0.3, 0.), SkyBgCol (ro, reflect (rd, vn)), 0.5);\n    col = mix (col, colB, clamp (1.2 * fadeFac - 0.1 + 0.1 * (Fbm1 (16. * tCur) - 0.5), 0., 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 5.;\n  spd = 3.;\n  wPos = vec3 (0., 0., spd * tCur);\n  az = - pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az +=  0.3 * pi * (2. * SmoothBump (0.25, 0.75, 0.22, fract (0.02 * tCur)) - 1.);\n  }\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = wPos + vuMat * vec3 (0., 3.5, -45.);\n  zmFac = 4.;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjXWm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1191, 1191, 1211, 1236, 2776], [2778, 2778, 2824, 2857, 4765], [4767, 4767, 4789, 4789, 5003], [5005, 5005, 5038, 5038, 5285], [5287, 5287, 5308, 5308, 5563], [5565, 5565, 5602, 5602, 5845], [5847, 5847, 5881, 5881, 6640], [6642, 6642, 6665, 6665, 6701], [6703, 6703, 6725, 6725, 6869], [6871, 6871, 6895, 6895, 7065], [7067, 7067, 7092, 7092, 7934], [7936, 7936, 7971, 7971, 10702], [10704, 10704, 10760, 10760, 11939], [11941, 11941, 11974, 11974, 12001], [12003, 12003, 12045, 12045, 12096], [12098, 12098, 12141, 12141, 12205], [12207, 12207, 12242, 12242, 12304], [12306, 12306, 12351, 12351, 12443], [12445, 12445, 12502, 12502, 12585], [12587, 12587, 12623, 12623, 12829], [12831, 12831, 12861, 12861, 12974], [12976, 12976, 13007, 13007, 13071], [13105, 13105, 13129, 13129, 13182], [13184, 13184, 13208, 13208, 13320], [13322, 13322, 13347, 13347, 13493], [13495, 13495, 13520, 13520, 13706], [13708, 13708, 13730, 13730, 13884], [13886, 13886, 13907, 13907, 14062]], "test": "untested"}
{"id": "ds2SDw", "name": "28 Tauri Aa", "author": "darkeclipz", "description": "Attempt at deforming a plane to create some kind of gravity field. Ended up by adjusting the step size, but this only works if the deformation is small.\n\nIs there a better method to do this, and get clean results? ", "tags": ["sphereuvmapplane"], "likes": 5, "viewed": 240, "published": 3, "date": "1670415696", "time_retrieved": "2024-07-30T16:14:25.026871", "image_code": "#define AA 2.\n#define R iResolution.xy\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\nvec4 map( in vec3 pos, float time )  \n{\n    float id = 0.;\n    float sphere = sdSphere(pos, 0.5);\n    float nearestDistanceToSphere = 1e20;\n    \n    // F = G m1 m2 / r2\n    float G = 0.192;\n    float F = G / dot(pos, pos);\n    \n    float plane = (pos.y + F);\n    float d = min(sphere, plane);\n    \n    nearestDistanceToSphere = min(nearestDistanceToSphere, sphere);\n    \n    if(plane < sphere) {\n    \tid = 1.;  \n    }\n    \n    return vec4(d, id, F, nearestDistanceToSphere);\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,\n                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,\n                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.00;\n    for( int i=0; i< 100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos, time ).x;\n        res = min( res, 16.0*h/t );\n        if ( res<0.001 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nvec3 castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.00;\n    int i=0;\n    float w = 1e20;\n    for( i=0; i<100; i++ )\n    {\n        float precis = 0.001;\n        vec3 pos = ro + t*rd;        \n\n        vec4 h = map( pos, time );\n        m = h.y;\n        w = min(w, h.w);\n        if( h.x<precis )\n            break;\n            \n        float stepSize = 1.0 / max(1.0, 1.0 + h.z);\n            \n        t += h.x * stepSize;\n        if( t>20.0 )\n            break;\n    } \n    if( t>20.0 ) m=-1.0;\n    return vec3(t, m, w);\n}\n\nvec3 rgb(int r, int g, int b) {\n    return vec3(r,g,b) / 255.;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime/4.;\n\n    vec3 col = vec3(0);\n    vec3 res = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*(U + vec2(aax, aay) / AA)-R)/R.y;\n        \n        vec3 ta = vec3(0,0,0);\n        vec3 ro = vec3(0, 1.0 + (-sin(time) * .5 + .5), -1);\n        ro.xz *= rot(time);\n        \n        vec3 ww = normalize( ta-ro );\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n        vec3 vv = normalize( cross(uu,ww) );\n\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n \n        vec3 col = vec3(0.0);\n\n        vec3 tm = castRay(ro, rd, time); \n        \n        #if 1\n        vec3 starGlowColor = rgb(252, 120, 49);\n        vec3 starColor1 = rgb(254, 235, 164);\n        vec3 starColor2 = rgb(158, 40, 0);\n        #else\n        vec3 starGlowColor = rgb(61, 181, 255);\n        vec3 starColor1 = rgb(124, 191, 254);\n        vec3 starColor2 = rgb(0, 90, 173);\n        #endif\n\n        if( tm.x < 20. )\n        {\n            float t = tm.x;\n            float id = tm.y;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, time);\n            \n            vec3 mate = vec3(0.6); \n            \n            if(id < 0.5) { // sphere\n                \n            \tmate = vec3(.8); \n                \n                //calculate uv coordinates for the sphere:\n                // https://en.wikipedia.org/wiki/UV_mapping\n                \n                // posn is the normalized vector from P to the sphere center\n                // which in this example is at (0, 0, 0).\n                vec3 posn = normalize(pos);\n                float u = 0.5 + atan(posn.z, posn.x) / (2.*3.1415);\n                float v = 0.5 - asin(posn.y) / 3.1415;\n                \n                // trick from Fabrice to avoid the discontinuity at Greenwich.\n                vec2 uv = vec2(u,v),\n                     df = fwidth(uv);\n               \tif(df.x > 0.5) df.x = 0.;\n                \n                mate = 4.0 * starGlowColor * exp(-30.0 * tm.z);\n                \n                float r = textureLod(iChannel0, uv, log2(max(df.x, df.y)*1024.)).r;\n                \n                mate *= mix(starColor1, starColor2, r);\n                \n                \n                \n                \n                // reuse mate \n                //nor += 0.05*length(mate);\n                 \n            }\n            else if(id < 1.5) { // floor\n                \n            \tmate = vec3(0.02);   \n                float s = 12.;\n                float w = 0.05;\n                \n                if(fract(pos.x*s) < w) {\n                \tmate = vec3(.3);    \n                }\n                \n                if(fract(pos.z*s) < w) {\n                \tmate = vec3(.3);    \n                }\n                \n                mate += 1.5 * starGlowColor * exp(-8.0 * tm.z);\n                mate += 2.0 * starGlowColor * exp(-15.0 * tm.z);\n                mate += 0.5 * starGlowColor * exp(-30.0 * tm.z);\n                mate += 0.25 * starGlowColor * exp(-60.0 * tm.z);\n                \n                //mate = dot(nor, normalize(vec3(1,1,1))) * vec3(1.0);\n            }\n            \n            \n\n            vec3  light1 = vec3( 0, 1, 1 );\n            vec3  light2 = vec3( 1, 3, 1 );\n\n            float key = clamp( 1.0, 0.0, 1.0 );\n            float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n            float amb = (0.7+0.3*nor.y);\n            float shadow = 1.0;// clamp(castShadow(pos + nor*.1, light1 - pos, time), 0., 1.);\n\n            vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*shadow;\n            brdf += 1.0*vec3(1.00,1.00,1.00)*key*shadow;\n            brdf += 1.0*vec3(0.40,0.40,0.40)*bac;\n\n            col = mate * brdf * exp(-0.6*t);\n        }\n        \n        // col = vec3(tm.x / 20.);\n\n        res += clamp(col, 0.0, 1.0);\n    }\n    \n    \n    col = pow( res/(AA*AA), vec3(0.4545) );\n    \n    vec2 uv = U / R.xy;\n    uv *= 1.0 - uv.yx;\n    float v = pow(uv.x * uv.y * 10.0, 0.25);\n    col *= v;\n    \n    O = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2SDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 59, 59, 119], [121, 121, 154, 154, 183], [185, 185, 224, 224, 661], [663, 663, 705, 705, 940], [942, 942, 995, 995, 1296], [1299, 1299, 1348, 1348, 1851], [1853, 1853, 1884, 1884, 1917], [1919, 1919, 1960, 1960, 5979]], "test": "untested"}
{"id": "cdjXWw", "name": "Complex Quartic Equation Solver", "author": "mla", "description": "Take four complex numbers as roots of a quartic equation, compute the equation, then solve and compare with the original roots. The solved roots are marked by rings and the contours show the roots of the equation directly.\n\nUse mouse to drag roots around.", "tags": ["function", "complex", "quartic", "equation", "rational"], "likes": 21, "viewed": 303, "published": 3, "date": "1670408317", "time_retrieved": "2024-07-30T16:14:26.229656", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Complex Quartic Equations, mla, 2022.\n//\n// Take four complex numbers as roots of a quartic equation, compute the equation,\n// then solve and compare with the original roots. The solved roots are marked\n// by rings and the contours show the roots of the equation directly.\n//\n// The roots of the resolvent cubic are shown as solid points.\n//\n// Use mouse to drag roots around.\n// 'a': hide axes\n// 'r': rotation\n// 'h': hide hud\n// 's': clamp roots to real line\n// 'n': apply final Newton-Raphson correction to roots\n//\n// Quartic solver is from Hall and Knight, Higher Algebra (1887) and\n// is a version of Ferrari's solution from 1540:\n//\n// Given x⁴+2px³+qx²+2rx+s = 0, rewrite as (x²+px+k)² = (ax+b)², so the\n// quartic roots are the roots of quadratics: x² + (p±a)x + (k±b) = 0\n//\n// Comparing coefficients and simplifying, we get:\n// p² + 2k = q + a²\n// pk = r + ab\n// k² = s + b²\n// \n// Now eliminate a and b (using a² = p² + 2k - q, a²b² = (pk-r)², b² = k² - s)\n// to get cubic in k:\n//\n// 2k³ - qk² + 2(pr-s)k - p²s + qs - r² = 0\n//\n// Solve cubic to get k, then a² and a (the sign of a is immaterial), then\n// finally b from b = (pk-r)/a\n//\n// This is the same as the Lanczos solution, except he constructs a cubic in a\n// rather than k (possibly this is superior - he didn't reveal reasons for\n// doing it this way).\n//\n// Tricks for accuracy: use Newton-Raphson to improve root of resolvent cubic\n// (we only need one root, so we pick the first, a more intelligent strategy\n// might be better), and also to improve the result of complex square root.\n// We can also apply NR to refine the final roots, but this is less necessary\n// if the previous refinements have been done (and there is always the\n// possiblity of being led astray).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 csqrt(vec2 z) {\n  if (z == vec2(0)) return vec2(0);\n  float t = carg(z)/2.0;\n  vec2 u = vec2(cos(t),sin(t));\n  float r = length(z);\n  z /= r;\n  u -= cdiv(cmul(u,u)-z,2.0*u); // NR step\n  return sqrt(r)*u;\n}\n\nvec2 ccuberoot(vec2 z) {\n  float t = carg(z)/3.0;\n  vec2 u = vec2(cos(t),sin(t));\n  float r = length(z);\n  z /= r;\n  if (false) {\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2); // NR step\n  }\n  return pow(r,1.0/3.0)*u;\n}\n\nmat2 solvequadratic(vec2 B, vec2 C) {\n  vec2 D = csqrt(cmul(B,B)-4.0*C);\n  return 0.5*mat2(-B+D,-B-D);\n}\n\nmat3x2 solvecubic(vec2 p, vec2 q) {\n  // Solve depressed cubic: x³+3px+q = 0 - note factor of 3!\n  // Put x = u+v and get x³ = u³+v³+3xuv\n  // Substitute in original equation and get:\n  // u³+v³+(3uv+3p)x + q = 0\n  // Now let's constrain u,v so that uv+p = 0, and then:\n  // uv = -p ie. u³v³ = -p³ and u³+v³ = -q\n  // This gives a quadratic equation in t with roots u³ and v³:\n  // t²+qt-p³ = 0 so try to solve as:\n  // u³ = -q + sqrt(q²+4p³), v³ = -q - sqrt(q²+4p³)\n  // and take cube roots to get solution x = u+v.\n  //\n  // HOWEVER, we can't just combine any cube roots of the\n  // quadratic solutions, the condition uv+p = 0 above must also\n  // hold, so what we do is take either one of the quadratic\n  // solutions with its three cube roots as the three values\n  // of u, and derive the corresponding v's directly as v = -p/u.\n  // As with solving a real quadratic equation, it seems prudent\n  // to use the quadratic root with the largest absolute magnitude,\n  // and given one cube root, we can easily find the others by\n  // multiplying by the cube roots of unity, ω and ω².\n  vec2 q2 = cmul(q,q);\n  vec2 p3 = cmul(p,cmul(p,p));\n  vec2 s = csqrt(q2+4.0*p3);\n  float sign = dot(q,s) > 0.0 ? -1.0 : 1.0; // Get largest magnitude root\n  vec2 u3 = 0.5*(-q+sign*s);\n  vec2 u = ccuberoot(u3);\n  vec2 u1 = cmul(u,omega); // Get other cuberoots by multiplying by ω and ω².\n  vec2 u2 = cmul(u,omega2);\n  return mat3x2(u-cdiv(p,u), u1-cdiv(p,u1), u2-cdiv(p,u2));\n}\n\nmat3x2 solvecubic(vec2 B, vec2 C, vec2 D) {\n  // Solve x³+Bx²+Cx+D = 0\n  B /= 3.0; C /= 3.0;  // Simplifies sums\n  vec2 B2 = cmul(B,B); // Depress with x->x+B\n  // p = c-b*b\n  vec2 p = C-B2;\n  // q = 2.0*b*b*b - 3.0*b*c + d\n  vec2 q = cmul(B,2.0*B2-3.0*C) + D;\n  mat3x2 res = solvecubic(p,q);\n  // Undepress by subtracting B\n  return mat3x2(res[0]-B,res[1]-B,res[2]-B);\n}\n\nmat3x2 croots;\n\nvec2 qcubic(vec2 B, vec2 C, vec2 D) {\n  croots = solvecubic(B,C,D);\n  vec2 k = croots[0]; // Any root will do - use 'best' one somehow?\n  k -= cdiv(D+cmul(k,C+cmul(k,B+k)),C+cmul(k,2.0*B+3.0*k)); // Refine cubic root\n  return k;\n}\n\nmat4x2 solvequartic(vec2 p, vec2 q, vec2 r, vec2 s) {\n  p *= 0.5; r *= 0.5;\n  vec2 B = -0.5*q;\n  vec2 C = cmul(p,r)-s;\n  vec2 D = 0.5*(cmul(q-cmul(p,p),s)-cmul(r,r));\n  vec2 k = qcubic(B,C,D);\n  vec2 a = csqrt(cmul(p,p)+2.0*k-q); // The sign is immaterial\n  vec2 b = cdiv(cmul(p,k)-r,a); // Get b from a directly\n  mat2 roots0 = solvequadratic(p-a,k-b);\n  mat2 roots1 = solvequadratic(p+a,k+b);\n  return mat4x2(roots0[0],roots0[1],roots1[0],roots1[1]);\n}\n\n// The Lanczos quartic method\nmat4x2 solvequartic0(vec2 c1, vec2 c2, vec2 c3, vec2 c4) {\n  vec2 alpha = 0.5*c1;\n  vec2 A = c2-cmul(alpha,alpha);\n  vec2 B = c3-cmul(alpha,A);\n  vec2 a,b,beta;\n  vec2 psi = qcubic(2.0*A-cmul(alpha,alpha),\n                    cmul(A,A)+2.0*cmul(B,alpha)-4.0*c4,\n                    -cmul(B,B));\n  a = csqrt(psi);\n  beta = 0.5*(A + psi);\n  b = 0.5*cmul(a,alpha-cdiv(B,psi));\n  mat2 roots0 = solvequadratic(alpha+a,beta+b);\n  mat2 roots1 = solvequadratic(alpha-a,beta-b); \n  return mat4x2(roots0[0],roots0[1],roots1[0],roots1[1]);  \n}\n\nvec2 evalcubic(vec2 a, vec2 b, vec2 c, vec2 z) {\n  // (x-a)(x-b)(x-c)\n  vec2 res = z-a;\n  res = cmul(res,z-b);\n  res = cmul(res,z-c);\n  return res;\n}\n\nvec2 eval(vec2 a, vec2 b, vec2 c, vec2 d, vec2 z) {\n  //(x-a)(x-b)(x-c)\n  vec2 res = z-a;\n  res = cmul(res,z-b);\n  res = cmul(res,z-c);\n  res = cmul(res,z-d);\n  return res;\n}\n\nvec2 eval(mat4x2 coeffs, vec2 z) {\n return eval(coeffs[0],coeffs[1],coeffs[2],coeffs[3],z);\n}\n\nint NROOTS = 4;\n\nfloat hud(vec2 fragCoord, mat4x2 rootsin, mat4x2 rootsout) {\n  const int digits = 7;\n  const int nrows = 16, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1;\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  float x = 1.234;\n  if (row >= NROOTS) return 0.0;\n  for (int i = 0; i < NROOTS; i++) {\n    if (row == i) {\n      if (column == 0) x = rootsin[i].x;\n      if (column == 1) x = rootsin[i].y;\n      if (column == 2) x = rootsout[i].x;\n      if (column == 3) x = rootsout[i].y;\n      //if (column == 4) x = length(eval(rootsin,rootsout[i]));\n    }\n  }\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = floatchar(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c < 0) return 0.0;\n  float charstart = charwidth*float(charpos); // character start\n  uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  return t.x;  \n}\n\nvoid swap(inout vec2 x, inout vec2 y) {\n  vec2 t = x; x = y; y = t;\n}\n\nmat4x2 sort(mat4x2 a) {\n  if (a[0].x > a[1].x) swap(a[0],a[1]); //tmp = a[0], a[0] = a[1], a[1] = tmp;\n  if (a[1].x > a[2].x) swap(a[1],a[2]); //tmp = a[1], a[1] = a[2], a[2] = tmp;\n  if (a[0].x > a[1].x) swap(a[0],a[1]); //tmp = a[0], a[0] = a[1], a[1] = tmp;\n  if (a[2].x > a[3].x) swap(a[2],a[3]); //tmp = a[2], a[2] = a[3], a[3] = tmp;\n  if (a[0].x > a[1].x) swap(a[0],a[1]); //tmp = a[0], a[0] = a[1], a[1] = tmp;\n  if (a[1].x > a[2].x) swap(a[1],a[2]); //tmp = a[1], a[1] = a[2], a[2] = tmp;\n  if (a[0].x > a[1].x) swap(a[0],a[1]); //tmp = a[0], a[0] = a[1], a[1] = tmp;\n  return a;\n}\n\nfloat showkeys(vec2 fragCoord) {\n  float K = 30.0;\n  if (fragCoord.y > K) return 0.0;\n  int box = int(fragCoord.x/K);\n  bool t = false;\n  if (box == 0 && key(CHAR_N)) t = true;\n  //if (box == 1 && key(CHAR_C)) t = true;\n  if (!t) return 0.0;\n  vec2 boxcoord = mod(fragCoord,K)/K-0.5;\n  float px = 0.5/K;\n  return 1.0-smoothstep(-px,px,length(boxcoord)-0.4);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 col1 = vec3(1,1,0);\n    vec3 col2 = vec3(0,1,1);\n    vec3 neutral = vec3(1,0,0);\n\n    setscale();\n    vec2 z = map(fragCoord);\n    vec2 a = getselection(0);\n    vec2 b = getselection(1);\n    vec2 c = getselection(2);\n    vec2 d = getselection(3);\n    if (key(CHAR_S)) a.y = b.y = c.y = d.y = 0.0; \n    mat4x2 rootsin = mat4x2(a,b,c,d);\n\n    vec2 w = eval(rootsin,z);\n    if (!key(CHAR_R)) {\n      float t = 0.25*iTime;\n      w = cmul(w,vec2(cos(t),sin(t)));\n    }\n    w = clog(w);\n    float alpha = w.y/PI;\n    vec3 basecol = alpha < 0.0 ? col1 : col2;\n    vec3 color = mix(neutral,basecol,abs(alpha));\n    \n    float px = fwidth(length(z));\n    if (!key(CHAR_A)) {\n      // Draw axes\n      float eps = 0.05;\n      float d = min(abs(z.x),abs(z.y));\n      float x = z.x-round(z.x);\n      float y = z.y-round(z.y);\n      d = min(d,segment(vec2(x,z.y),vec2(0,-eps),vec2(0,eps)));\n      d = min(d,segment(vec2(z.x,y),vec2(-eps,0),vec2(eps,0)));\n      color = mix(vec3(0),color,smoothstep(0.0,px,d));\n    }\n    float t = 0.5+atan(w.x)/PI;\n    vec2 uv = 10.0*w/PI;\n    float px2 = fwidth(uv.x);// fwidth for function result\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    color = mix(vec3(t),color,smoothstep(0.0,px2,min(uv.x,uv.y)));\n    // Now let's solve the quartic and see if we get the original roots back.\n    // x⁴+Ax³+Bx²+Cx+D = 0\n    vec2 ab = cmul(a,b), ac = cmul(a,c), ad = cmul(a,d);\n    vec2 bc = cmul(b,c), bd = cmul(b,d), cd = cmul(c,d);\n    vec2 A = -(a+b+c+d);\n    vec2 B = ab+ac+ad+bc+bd+cd;\n    vec2 C = -(cmul(ab,c)+cmul(ab,d)+cmul(a,cd)+cmul(b,cd));\n    vec2 D = cmul(ab,cd);\n    mat4x2 roots = solvequartic(A,B,C,D);\n    if (key(CHAR_N)) {\n     for (int i = 0; i < NROOTS; i++) {\n        vec2 z = roots[i];\n        z -= cdiv(D+cmul(z,C+cmul(z,B+cmul(z,A+z))),C+cmul(z,2.0*B+cmul(z,3.0*A+4.0*z)));\n        roots[i] = z;\n      }\n    }\n    float de = 1e8;\n    for (int i = 0; i < NROOTS; i++) {\n      // Draw a little circle around each root.\n      de = min(de,abs(distance(z,roots[i])-0.05));\n      // Roots of resolvent cubic, just out of interest\n      if (i < 3) de = min(de,distance(z,croots[i])-0.05);\n    }\n    color *= smoothstep(0.0,px,de);\n    if (!key(CHAR_H)) {\n      color = mix(color,vec3(0),hud(fragCoord,sort(rootsin),sort(roots)));\n      color = mix(color,vec3(0),showkeys(fragCoord));\n    }\n    \n    color = pow(color,vec3(0.4545));\n    if (alert) color.r = 1.0;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n#define SELECTIONS\nconst int nselections = 4;\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-sqrt(3.0),1);\n  if (i == 1) return vec2( sqrt(3.0),1);\n  if (i == 2) return vec2(0,-2);\n  return vec2(0);\n}\n\nconst float PI = 3.14159265;\nconst float TWOPI = 2.0*PI;\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\n\nvec2 ccbrt0(vec2 z) {\n  // Trigless Newton Raphson verson\n  float r = length(z);\n  z /= r; // Normalize z\n  vec2 u = z+vec2(1,0); // First approximation (when normalized)\n  for (int i = 0; i < 4; i++) {\n    u = normalize(u);\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return pow(r,1.0/3.0)*u;\n}\n\n// cuberoots of 1.\nconst vec2 omega = 0.5*vec2(-1,sqrt(3.0));\nconst vec2 omega2 = omega*vec2(1,-1);\n\n\nfloat scale = 1.0;\nvoid setscale() {\n  scale = 2.5;\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\nconst int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n#define SIGN(x) { if ((x) < 0.0) CHAR(MINUS) else CHAR(SPACE) } \n\n// Format x to digits precision and return the character at cindex,\n// or -1 if cindex is out of range.\nint floatchar(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return -1;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int SPACE = 0x20, ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  if (isinf(x)) {\n    SIGN(x);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    // Maybe show the bits\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    SIGN(x);\n    CHAR(ZERO);\n  } else {\n    SIGN(x);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    // This is a delicate business if we aren't to\n    // lose too much precision\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have a correctly rounded integer representation together\n    // with the correct exponent. The rest is just formatting.\n\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return -1;\n}", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0 && iFrame != 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.z = 1234.0;\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1945, 1945, 1965, 1965, 2156], [2158, 2158, 2182, 2182, 2392], [2394, 2394, 2431, 2431, 2498], [2500, 2500, 2535, 3607, 3990], [3992, 3992, 4035, 4064, 4365], [4383, 4383, 4420, 4420, 4613], [4615, 4615, 4668, 4668, 5069], [5071, 5101, 5159, 5159, 5633], [5635, 5635, 5683, 5704, 5784], [5786, 5786, 5837, 5857, 5960], [5962, 5962, 5996, 5996, 6055], [6074, 6074, 6134, 6134, 7474], [7476, 7476, 7515, 7515, 7545], [7547, 7547, 7570, 7570, 8137], [8139, 8139, 8171, 8171, 8498], [8500, 8500, 8552, 8552, 10996]], "test": "untested"}
{"id": "cs2SDm", "name": "Disappearing Horseshoe", "author": "DoozyKiddo", "description": "CS4450", "tags": ["horseshoe"], "likes": 1, "viewed": 126, "published": 3, "date": "1670407518", "time_retrieved": "2024-07-30T16:14:27.182108", "image_code": "float sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n/*float mix( float a, float b, float t)\n{\n    return (1.0 - t) * a + t * b;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float time = 0.5 + 0.5*cos(iTime);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= (iResolution.y/iResolution.x);\n    float dist = sdHorseshoe(uv-vec2(0.55,0.3), vec2(0.5, 0.5), 0.1, vec2(0.05, 0.05));\n    float dist2 = sdCircle(uv-vec2(0.55,0.3),0.1);\n    float interpolated = mix(dist, dist2, time);\n    vec3 mixedColor = mix(vec3(1.0 * ((iResolution.xy - fragCoord) / fragCoord), 0.0), vec3(0.0, 1.0 * ((iResolution.xy - fragCoord) / fragCoord)), time);\n    \n    vec3 col = mix(mixedColor, vec3(0.0, 1.0 * ((iResolution.xy - fragCoord) / fragCoord)), step(0.0, interpolated));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2SDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 63], [65, 65, 131, 131, 386], [469, 469, 526, 576, 1221]], "test": "untested"}
{"id": "cd2XWm", "name": "last frame kernel: #1", "author": "jonasfrey", "description": "programmed in 60hz", "tags": ["template"], "likes": 1, "viewed": 131, "published": 3, "date": "1670407029", "time_retrieved": "2024-07-30T16:14:28.065746", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        o_trmono = vec2(\n            n_t_x*2.,\n            n_t_y\n            //(f_n_rand(n_t)-0.5)*2.,\n            //f_n_rand(n_t*3.33)-0.5\n        );\n    }\n    vec2 o_scale = vec2(0.4);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_scale_kernel = vec2(\n        3.,\n        3.\n    );\n    float n_size_kernel = o_scale_kernel.x * o_scale_kernel.y;\n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n    \n    vec4 a_o_col_last_krnl[100];\n    \n    vec4 a_o_sum_xaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_xaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 o_kernel_sum = vec4(0.0);\n    int n_index_a_o_col_last_krnl = 0;\n    for(float n_y = 0.0; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.0; n_x < o_scale_kernel.x; n_x+=1.){\n            int n_index_a_o_sum_xaxis = int(n_x);\n            int n_index_a_o_sum_yaxis = int(n_y);\n\n            vec2 o_speed = vec2(0.0);\n            vec2 o = vec2(\n               floor(n_x - floor(o_scale_kernel.x/2.)),\n               floor(n_y - floor(o_scale_kernel.y/2.)) \n            ) + o_speed;\n            vec2 o_off = vec2(\n                o.x * (1./o_iResolution_scaled_floor.x),\n                o.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_on_kernel;\n\n            a_o_sum_xaxis[n_index_a_o_sum_xaxis] += o_col_last_on_kernel;\n            a_o_sum_xaxis_nor[n_index_a_o_sum_xaxis]+= (o_col_last_on_kernel / o_scale_kernel.x);\n            a_o_sum_yaxis[n_index_a_o_sum_yaxis] += o_col_last_on_kernel;\n            a_o_sum_yaxis_nor[n_index_a_o_sum_yaxis]+= (o_col_last_on_kernel / o_scale_kernel.y);\n            \n            n_index_a_o_col_last_krnl+=1;\n            a_o_col_last_krnl[n_index_a_o_col_last_krnl] = o_col_last_on_kernel;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n    \n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n\n            fragColor = vec4(\n               ((a_o_sum_yaxis_nor[0].x)*1.1)\n            );\n            if(o_kernel_sum_nor.x > 1.){\n                //fragColor = vec4(f_n_rand(iTime)*0.01);\n                fragColor = vec4(o_kernel_sum_nor.x*0.2);\n            }\n            float n_fact = 0.1;\n            float n_rand = f_n_rand(iTime)*n_fact+n_fact;\n            float n_rand2 = f_n_rand(iTime)*n_fact+n_fact;\n            n = 0.2;\n            if(\n                a_o_sum_xaxis_nor[0].x < n\n                ||\n                a_o_sum_xaxis_nor[2].x < n\n                \n            ){\n                fragColor = vec4(n_rand2*1.);\n            }\n            if(floor(o_kernel_sum_nor.x*100.) == floor(o_col_last.x*100.)){\n                fragColor = o_col_last;\n            }\n            //if(o_kernel_sum_nor.x > 0.9){\n            //    fragColor = vec4(f_n_rand(floor(iTime*10.)));\n            //}\n\n            //vec4 o_col_delta_last = abs(fragColor - o_col_last);\n            //fragColor = o_col_delta_last*o_col_delta_last;\n            \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_thresh = 0.3;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4(sqrt(n_dist_nor));\n\n    }\n    \n    fragColor = (fragColor);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2XWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "DsjSWm", "name": "60hz: last frm krnl explosion", "author": "jonasfrey", "description": "60hz version of \n", "tags": ["template"], "likes": 1, "viewed": 157, "published": 3, "date": "1670404493", "time_retrieved": "2024-07-30T16:14:28.828706", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\n#define f_b_keydown(n_ascii)    ( texelFetch(iChannel1,ivec2(n_ascii,0),0).x > 0.)\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        o_trmono = vec2(\n            n_t_x*2.,\n            n_t_y\n            //(f_n_rand(n_t)-0.5)*2.,\n            //f_n_rand(n_t*3.33)-0.5\n        );\n    }\n    int n_key_spacebar = 32;\n    int n_key_enter = 13;\n    if(f_b_keydown(n_key_spacebar)){\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    if(f_b_keydown(n_key_enter)){\n        o_trmono = vec2(-1.);\n    }\n    vec2 o_scale = vec2(0.5);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_scale_kernel = vec2(\n        3.,\n        3.\n    );\n    float n_size_kernel = o_scale_kernel.x * o_scale_kernel.y;\n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n    \n    vec4 a_o_col_last_krnl[100];\n    \n    vec4 a_o_sum_xaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_xaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 o_kernel_sum = vec4(0.0);\n    int n_index_a_o_col_last_krnl = 0;\n    for(float n_y = 0.0; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.0; n_x < o_scale_kernel.x; n_x+=1.){\n            int n_index_a_o_sum_xaxis = int(n_x);\n            int n_index_a_o_sum_yaxis = int(n_y);\n\n            vec2 o_speed = vec2(0.0);\n            vec2 o = vec2(\n               floor(n_x - floor(o_scale_kernel.x/2.)),\n               floor(n_y - floor(o_scale_kernel.y/2.)) \n            ) + o_speed;\n            vec2 o_off = vec2(\n                o.x * (1./o_iResolution_scaled_floor.x),\n                o.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_on_kernel;\n\n            a_o_sum_xaxis[n_index_a_o_sum_xaxis] += o_col_last_on_kernel;\n            a_o_sum_xaxis_nor[n_index_a_o_sum_xaxis]+= (o_col_last_on_kernel / o_scale_kernel.x);\n            a_o_sum_yaxis[n_index_a_o_sum_yaxis] += o_col_last_on_kernel;\n            a_o_sum_yaxis_nor[n_index_a_o_sum_yaxis]+= (o_col_last_on_kernel / o_scale_kernel.y);\n            \n            n_index_a_o_col_last_krnl+=1;\n            a_o_col_last_krnl[n_index_a_o_col_last_krnl] = o_col_last_on_kernel;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n            if(o_kernel_sum_nor.x > 0.01){\n                fragColor = vec4(1.);\n            }\n            if(o_kernel_sum_nor.x > 0.1){\n                fragColor = vec4(0.);\n            }\n            if(o_kernel_sum_nor.x > 0.40){\n                fragColor = vec4(1.);\n            }\n            if(o_kernel_sum_nor.x > 0.44){\n                fragColor = vec4(0.);\n            }\n            if(o_kernel_sum_nor.x > 0.5){\n                fragColor = vec4(f_n_rand(floor(iTime*10.)));\n            }\n\n            vec4 o_col_delta_last = abs(fragColor - o_col_last);\n            fragColor = o_col_delta_last*0.99;\n            \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_thresh = 0.25;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4(sqrt(n_dist_nor));\n\n    }\n    \n    fragColor = (fragColor);\n    //fragColor = vec4(1.,1.,1.,.1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "cs2XWD", "name": "[phreax] alien gem1", "author": "phreax", "description": "More iridescent gems", "tags": ["raymarching", "metal", "moebius", "iridescent", "zucconi", "torusknot"], "likes": 12, "viewed": 314, "published": 3, "date": "1670401217", "time_retrieved": "2024-07-30T16:14:29.725309", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2022\n*/\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define SIN(x) (sin(x)*.5+.5)\n#define PHI 1.618033988749895\n#define BUMP_EPS 0.004\n#define FAR 100.\n\n\nfloat tt, g_mat;\nfloat closest = FAR;\n\n\nmat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nfloat fadeInOut(float t1, float t2, float fadeTime) {\n    return smoothstep(t1, t1+fadeTime, iTime)-smoothstep(t2-fadeTime, t2, iTime);\n}\n\n// zucconis spectral palette https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n    vec3 y = 1. - x * x;\n    y = clamp((y-yoffset), vec3(0), vec3(1));\n    return y;\n}\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(highp vec2 coords) {\n   return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 spectral_zucconi6(float x) {\n    x = fract(x);\n    const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n    const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n    const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n    const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n    const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n    const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n    return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2) ;\n}\n\n// Amazing fractal texture from jarble https://www.shadertoy.com/view/csl3zl\nvec2 triangle_wave(vec2 a){\n    \n    vec2 a2 = vec2(1.,0.5),\n    \n    a1 = a-a2;\n    \n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nfloat getDepth(sampler2D sampler, vec2 uv) {\n    uv = clamp(uv, vec2(.0), vec2(1.));\n    vec2 eps = vec2(0.004, 0); \n    float vc = texture(sampler, uv).r;\n    float vu = texture(sampler, uv-eps.yx).r;\n    float vb = texture(sampler, uv+eps.yx).r;\n    float vr = texture(sampler, uv+eps.xy).r;\n    float vl = texture(sampler, uv-eps.xy).r;\n    \n    return clamp((vc + vu + vb + vr + vl)/5., 0., .4);\n    \n}\n\nfloat rect( vec2 p, vec2 b, float r ) {\n    vec2 d = abs(p) - (b - r);\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.) - r;\n}\n\n\nvec3 kalei(vec3 p) {\n    float iter = 3.;\n\n\n    float s= 1.;\n    for(float i=0.; i< iter; i++) {\n        p = abs(p);  \n        p.xz *= rot(i/iter*PI+.2*tt);\n        p -= .1;\n         \n    }\n\n    return clamp(p, -1e5, 1e5);\n\n}\n\n\n// n-fold symmetry by mla\nvec2 foldSym(vec2 p, float N) {\n\n    float t = atan(p.x,-p.y);\n    t = mod(t+PI/N,2.0*PI/N)-PI/N;\n    return length(p)*vec2(cos(t),sin(t));\n}\n\nvec3 transform(vec3 p) {\n\n    p *= 1.5;\n    \n    p.xy = foldSym(p.xy, 6.);\n    p.xy = abs(p.xy)-0.25*SIN(.3*tt);\n\n    p = kalei(p);\n    \n    \n    p.yz *= rot(PI*.5);\n    p.xz *= rot(.2*tt);\n\n    float r = 1.;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n    \n\n    float rev = 2.;\n    float a = atan(p.z, p.x);\n    \n \n    cp *= rot(rev*a+.3*tt);\n    cp= abs(cp) - mix(.4, 1., SIN(tt));\n    cp= mix(cp, abs(cp) - .2, smoothstep(10., 11., iTime));\n    cp *= rot(.5*tt);\n\n\n    return vec3(cp, p.z);\n}\n\nvec3 transform2(vec3 p) {\n\n    p *= .8;\n\n    p.xy = foldSym(p.xy, 3.); \n    p.xy = abs(p.xy)-0.3*SIN(-.3*tt);  \n    p.yz *= rot(PI*.25);\n    \n\n    float r = 1.;\n    vec2 cp = vec2(length(p.xz)-r, p.y);\n \n\n    float rev = 1.;\n    float a = atan(p.z, p.x);\n    \n \n    cp *= rot(rev*a+.3*tt);\n    cp= abs(cp) - mix(.4, 1., SIN(tt));\n    // cp=abs(cp) - .5;\n    cp *= rot(-.5*tt);\n\n    return vec3(cp, p.z);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp((a-b)/k * .5 + .5, 0.0, 1.0);\n  return mix(a, b, h) - h*(1.-h)*k;\n}\n\nfloat map(vec3 p) {   \n  \n    vec3 bp = p;\n    float edge = 0.05;\n   \n\n    vec2 cp = transform(p).xy;\n    vec2 cp2 = transform2(p).xy;\n   \n    float dr = rect(cp.xy, vec2(.3, .3), edge);\n    float dr2 = rect(cp2.xy, vec2(.08), 0.02);\n   \n    float d = smin(dr, dr2,.8);\n    \n    g_mat = dr < dr2 ? 0. : 1.;\n    \n    return .5*d;\n}\n\n\nvec3 getNormal(vec3 p) {\n\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                          map(p + eps.yxy) - map(p - eps.yxy),\n                          map(p + eps.yyx) - map(p - eps.yyx)\n                         )\n                     );\n}\n\nfloat bumpSurf3D( in vec3 p){\n\n    p.z += .3*tt;\n    p = abs(mod(p*4., 2.*0.125)-0.0125);\n    \n    float x = min(p.x,min(p.z, p.y))/0.03125;\n\n    return clamp(x, 0., 1.);\n\n\n}\n\n// Standard function-based bump mapping function (from Shane)\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = BUMP_EPS;\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = vec3( bumpSurf3D(vec3(p.x-eps, p.y, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y-eps, p.z))-ref,\n                      bumpSurf3D(vec3(p.x, p.y, p.z-eps))-ref )/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec2 raymarch(vec3 ro, vec3 rd, float steps) {\n\n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n    vec3 p = ro;\n    \n    \n    for(float i=.0; i<steps; i++) {\n    \n        d = map(p);\n        mat = g_mat;  // save global material\n        \n        closest = min(closest, d/t);\n        if(abs(d) < 0.0001 || t > FAR) break;\n \n        t += d;\n        p += rd*d;\n       \n    }\n    \n    return vec2(t, mat);\n}\n\nfloat n21(vec2 p) {\n      return fract(sin(dot(p, vec2(524.423,123.34)))*3228324.345);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0., 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(n21(b), n21(b + d.yx), f.x), mix(n21(b + d.xy), n21(b + d.yy), f.x), f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    tt = .5*iTime;\n    vec3 ro = vec3(uv*6.,-4.),\n          rd = vec3(0,0,1.),\n          lp = vec3(3., 0., -2),\n          lp2 = vec3(-3., 0., -2);\n\n    vec3 col;\n    \n\n       \n    float mat = 0.,\n          t   = 0.,\n          d   = 0.;\n \n\n    vec2 e = vec2(0.0035, -0.0035);\n     \n    // background color\n    vec3 c1 = vec3(0.165,0.208,0.298);\n    vec3 c2 = vec3(0.180,0.337,0.337);\n    \n    // light color\n    vec3 lc1 = vec3(0.573,0.424,0.976);\n    vec3 lc2 = vec3(0.573,0.922,0.969);\n    \n    \n    // currently only one pass\n    for(float i = 0.; i < 1.; i++) {\n        float steps = i > 0. ? 50. : 250.;\n        vec2 rm = raymarch(ro, rd, steps);\n        mat = rm.y;\n        \n        vec3 p = ro + rm.x*rd;\n        \n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                                e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n\n\n        \n        if(mat == 1.) {\n        \n            vec3 pt = transform2(p);\n            vec3 np = transform2(n);\n            n = doBumpMap(pt, n, mix(0., .001, length(p.xy)-.5));\n        }\n    \n     \n        if(rm.x < 50.) {\n        \n            vec3 l = normalize(lp-p);\n            vec3 l2 = normalize(lp2-p);\n            float dif = max(dot(n, l), .0);\n            float dif2 = max(dot(n, l2), .0);\n            float spe = pow(max(dot(reflect(-rd, n), -l), .0),40.);\n\n            float sss = smoothstep(0., 1., map(p + l * .4)) / .4;\n            vec3 n2 = n;\n            n2.xy += noise(p.xy) * .5 - .025;\n            n2 = normalize(n2);\n            float height = atan(n2.y, n2.x);\n\n            vec3 iri = spectral_zucconi6(height*1.11)*smoothstep(.8, .2, abs(n2.z))-.02;\n       \n          \n            col += dif*lc1*.5 + .5*dif2*lc2 + .5*iri ;\n           \n          \n            if(mat > 0.) {\n                n += .4*texture(iChannel1, n.xy*200.).rgb;\n                rd = reflect(rd, n);\n                \n               // rd.yz *= rot(PI*.8);\n         \n                vec3 refl = texture(iChannel0, rd).rgb;\n                \n                refl *= mix(vec3(1), spectral_zucconi6(n.x*n.y*3.), .3); // reflect rainbows too\n                col = mix(col, refl, .6);\n    \n              \n            } \n            if(mat == 1.)\n              col = mix(col, col*spectral_zucconi6(p.z*.2+length(p.xy*.2)*.2+.05*tt), .95);\n            if(mat == 0.) \n              col = mix(col, col*(mix(.6, .0, length(p*.5)-.3+.3*sin(tt))+vec3(1.000,0.506,0.239)*spectral_zucconi6(length(p.xy*.4)+.6+.1*tt)), 1.);\n\n        } else {\n            col =  mix(c1-.2, c2, (.3-pow(dot(uv, uv), .8)))*.2+.04; // background\n            // outer glow (inspired from https://www.shadertoy.com/view/ldB3Rz)\n            float f = 1.0 - clamp(closest * 0.5, 0.0, 1.0);\t\t\n\n            float glowAmount = 0.0;\n       \n            glowAmount +=  pow(f, 400.0) * (0.08+.1*SIN(tt));\n            vec3 glowColor = spectral_zucconi6(length(p.xy*.2)+.6);\n            col += glowColor * glowAmount;\n        } \n    \n    }\n\n    \n    col += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(uv)); // dithering\n    \n    col *= 1.8;\n    col *= mix(.2, 1., (1.3-pow(dot(uv, uv), .5))); // vignette\n    col = pow(col, vec3(.7)); // gamma\n    \n\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2XWD.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[267, 267, 286, 286, 334], [336, 336, 389, 389, 473], [475, 568, 604, 604, 691], [859, 859, 892, 892, 1351], [1353, 1430, 1457, 1457, 1561], [1563, 1563, 1607, 1607, 1969], [1971, 1971, 2010, 2010, 2103], [2106, 2106, 2126, 2126, 2331], [2334, 2360, 2391, 2391, 2501], [2503, 2503, 2527, 2527, 2995], [2997, 2997, 3022, 3022, 3402], [3404, 3404, 3443, 3443, 3529], [3531, 3531, 3550, 3550, 3861], [3864, 3864, 3888, 3888, 4163], [4165, 4165, 4194, 4194, 4339], [4341, 4403, 4460, 4460, 4888], [4889, 4900, 4977, 4977, 5303], [5306, 5306, 5352, 5352, 5722], [5724, 5724, 5743, 5743, 5812], [5814, 5814, 5835, 5835, 6038], [6040, 6040, 6097, 6097, 9369]], "test": "untested"}
{"id": "DdBXWw", "name": "Snowtoy", "author": "fishy", "description": "snow!", "tags": ["snow"], "likes": 9, "viewed": 272, "published": 3, "date": "1670375892", "time_retrieved": "2024-07-30T16:14:30.483282", "image_code": "#define TAU 6.28318530718\n#define PI 3.14159265359\n#define START 3\n#define LAYERS 7\n\n#define iTime (iTime*0.4)\n\nfloat mRange(float ai, float aa, float bi, float ba, float x) { return (x-ai)/(aa-ai)*(ba-bi)+bi; } // Maps x between a range of ai-aa to bi-ba\nfloat mRange(vec2 a, vec2 b, float x) { return mRange(a.x, a.y, b.x, b.y, x); }\nfloat sRange(float i, float a, float x) { return x*(a-i)+i; } // Maps x between a range of 0-1 to i-a\nfloat sRange(vec2 a, float x) { return sRange(a.x, a.y, x); }\nfloat eRange(float i, float a, float x) { return (x-i)/(a-i); } // Maps x between a range of i-a to 0-1\nfloat eRange(vec2 a, float x) { return eRange(a.x, a.y, x); }\n\nfloat maxcomp(vec2 p) { return max(p.x, p.y); }\nfloat mincomp(vec2 p) { return min(p.x, p.y); }\n\nfloat atan2(vec2 p) { return atan(p.y, p.x); }\n\nfloat getSnow(vec2 p, float scale, float jitter, vec2 softness, vec2 size, vec4 lobes, vec2 rotRate, float moveFreq, vec2 moveAmp, float moveRand, vec2 opacity, float fill, float t)\n{\n    vec2 lp = fract(p*scale)-0.5;\n    vec2 cell = mod(floor(p*scale), 100.);\n    vec2 flakePos = (hash22(cell)-0.5)*jitter+sin(hash22(cell)*TAU*moveRand+t*moveFreq)*moveAmp;\n    float o = sRange(softness, hash21(cell))*0.5;\n    vec2 hm = vec2(floor(sRange(lobes.xy, hash21(cell+5.))), sRange(lobes.zw, hash21(cell+3.)));\n    float i = sRange(size, hash21(hash22(cell)))+sin(atan2(lp-flakePos)*4.0*hm.x + t*sRange(rotRate, hash21(cell+10.)))*hm.y;\n    return hash21(hash22(cell)) < fill? sRange(opacity, hash21(cell+7.))*smoothstep(i+o, i-o, length(lp-flakePos)) : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 suv = fragCoord/iResolution.xy;\n    vec2 mo = (iMouse.xy-iResolution.xy*0.5)/iResolution.y;\n\n    float snow = 0.;\n    for(float i = -float(START); i < float(LAYERS-START); i++)\n    {\n        float scale = exp2(-i);\n        snow += getSnow(uv/scale-iTime*vec2(0.2, -0.3)+i*1.141, 10., 0.4, vec2(0.0, 0.01)+(9.-scale-iMouse.x/iResolution.x)*0.03, vec2(0., 0.1), vec4(1., 3., 0.001, 0.005), vec2(20., 40.), 4., vec2(0.1, 0.1),1., vec2(0.2, 0.8), exp2(-i-float(START)), iTime);\n    }\n    \n    float light = max(0., 2.-length(suv-1.))+sRange(0.1, 0.15, 1.-suv.y);\n    snow += light*0.1;\n    \n    vec3 col = dither(vec3(snow), fragCoord);\n\n    // Output to screen\n    fragColor = displayVar(col);\n}", "image_inputs": [], "common_code": "vec4 displayVar(bool a) { return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(float a){ return vec4(vec3(a), 1.0); }\n\nvec4 displayVar(vec2 a) { return vec4(a, 0.0, 1.0); }\n\nvec4 displayVar(vec3 a) { return vec4(a, 1.0); }\n\nvec4 displayVar(vec4 a) { return vec4(a.xyz, 1.0); }\n\nvoid join(inout float a, float b)\n{\n    a = min(a, b);\n}\n\nvoid subt(inout float a, float b)\n{\n    a = max(a, -b);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n    return max((abs(p)-s).x,(abs(p)-s).y);\n}\n\nfloat digit(vec2 p, int d)\n{\n    #define join(a) join(r, a)\n    #define subt(a) subt(r, a)\n    float r = 100000000.0;\n    switch(d)\n    {\n        case(0):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p, vec2(0.05, 0.1)));\n            break;\n        case(1):\n            join(box(p, vec2(0.025, 0.15)));\n            break;\n        case(2):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(3):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.15, -0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15, 0.06), vec2(0.2, 0.035)));\n            break;\n        case(4):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.09), vec2(0.05, 0.085)));\n            break;\n        case(5):\n            join(box(p, vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.15, 0.06), vec2(0.2, 0.035)));\n            subt(box(p-vec2(-0.15,-0.06), vec2(0.2, 0.035)));\n            break;\n        case(6):\n            p = -p;\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n        case(7):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(-0.05), vec2(0.1, 0.15)));\n            break;\n        case(8):\n            join(box(p-vec2(0.0), vec2(0.1, 0.15)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            subt(box(p-vec2(0.0, -0.05), vec2(0.05, 0.05)));\n            join(box(p-vec2(0.0), vec2(0.1, 0.025)));\n            break;\n        case(9):\n            join(box(p-vec2(0.075, 0.0), vec2(0.025, 0.15)));\n            join(box(p-vec2(0.0, 0.05), vec2(0.1, 0.1)));\n            subt(box(p-vec2(0.0, 0.05), vec2(0.05, 0.05)));\n            break;\n    }\n    #undef subt\n    return r;\n}\n\nfloat getDig(float num, float d)\n{\n    float a = floor(num/pow(10., d));\n    return a - floor(a/10.)*10.;\n}\n\nfloat print(vec2 p, float num, float spacing)\n{\n    float r = 10000.0;\n    int fig = int(ceil(log2(num) / 3.32192809489)); // log base 10 of x equals log base 2 of x divided by log base 2 of 10\n    for(int i = 0; i < fig; i++)\n    {\n        int di = int(getDig(num, float(i)));\n        join(digit(p+vec2(i, 0)*spacing, di));\n    }\n    return r;\n    #undef join\n}\n\nvec3 printFR(vec2 p, float iFrameRate)\n{\n    return 1.-vec3(step(0., print((p-vec2(0.474, 0.25))*9., iFrameRate, 0.3)));\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash21(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat shash(float x)\n{\n    return mix(hash11(floor(x)), hash11(floor(x)+1.), fract(x));\n}\n\nvec3 dither(vec3 color, vec2 coord, float steps)\n{\n    vec3 reduce = floor(color*steps)/steps;\n    vec3 error = color-reduce;\n    float noise = hash21(coord);\n    return reduce+step(vec3(noise), error*steps)/steps;\n}\n\nvec3 dither(vec3 color, vec2 coord)\n{\n    return dither(color, coord, 256.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 175, 175, 211], [212, 256, 295, 295, 335], [336, 336, 377, 377, 397], [398, 438, 469, 469, 499], [500, 500, 541, 541, 563], [564, 604, 635, 635, 665], [667, 667, 690, 690, 714], [715, 715, 738, 738, 762], [764, 764, 785, 785, 810], [812, 812, 995, 995, 1566], [1568, 1568, 1625, 1675, 2437]], "test": "untested"}
{"id": "DsBSDm", "name": "kernel last frame: explosions", "author": "jonasfrey", "description": "looks like small explosions , maybe this only works with my 240 hz screen", "tags": ["template"], "likes": 1, "viewed": 148, "published": 3, "date": "1670372146", "time_retrieved": "2024-07-30T16:14:31.345976", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl const 1000;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        float n_t = floor(iTime * 1.0);\n        float n_t_x = fract(n_t/5.)-.5;\n        float n_t_y = fract(n_t/10.)-.5;\n        o_trmono = vec2(\n            n_t_x*2.,\n            n_t_y\n            //(f_n_rand(n_t)-0.5)*2.,\n            //f_n_rand(n_t*3.33)-0.5\n        );\n    }\n    vec2 o_scale = vec2(0.5);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_scale_kernel = vec2(\n        3.,\n        3.\n    );\n    float n_size_kernel = o_scale_kernel.x * o_scale_kernel.y;\n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n    \n    vec4 a_o_col_last_krnl[100];\n    \n    vec4 a_o_sum_xaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_xaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 a_o_sum_yaxis_nor[100];// 100 is static , because a varbiable as array size is not working 'array size must be a constant integer expression'...\n    vec4 o_kernel_sum = vec4(0.0);\n    int n_index_a_o_col_last_krnl = 0;\n    for(float n_y = 0.0; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.0; n_x < o_scale_kernel.x; n_x+=1.){\n            int n_index_a_o_sum_xaxis = int(n_x);\n            int n_index_a_o_sum_yaxis = int(n_y);\n\n            vec2 o_speed = vec2(0.0);\n            vec2 o = vec2(\n               floor(n_x - floor(o_scale_kernel.x/2.)),\n               floor(n_y - floor(o_scale_kernel.y/2.)) \n            ) + o_speed;\n            vec2 o_off = vec2(\n                o.x * (1./o_iResolution_scaled_floor.x),\n                o.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_on_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_on_kernel;\n\n            a_o_sum_xaxis[n_index_a_o_sum_xaxis] += o_col_last_on_kernel;\n            a_o_sum_xaxis_nor[n_index_a_o_sum_xaxis]+= (o_col_last_on_kernel / o_scale_kernel.x);\n            a_o_sum_yaxis[n_index_a_o_sum_yaxis] += o_col_last_on_kernel;\n            a_o_sum_yaxis_nor[n_index_a_o_sum_yaxis]+= (o_col_last_on_kernel / o_scale_kernel.y);\n            \n            n_index_a_o_col_last_krnl+=1;\n            a_o_col_last_krnl[n_index_a_o_col_last_krnl] = o_col_last_on_kernel;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        fragColor = vec4((f_n_rand(float(n_index))));\n    }else{\n        if(mod(float(iFrame), 1.) > 1.){\n            fragColor = o_col_last;\n        }else{\n            float n = 0.5;\n            if(o_kernel_sum_nor.x > 0.1){\n                fragColor = vec4(1.);\n            }\n            if(o_kernel_sum_nor.x > 0.2){\n                fragColor = vec4(0.);\n            }\n            if(o_kernel_sum_nor.x > 0.3){\n                fragColor = vec4(1.);\n            }\n            if(o_kernel_sum_nor.x > 0.4){\n                fragColor = vec4(0.);\n            }\n            if(o_kernel_sum_nor.x > 0.5){\n                fragColor = vec4(f_n_rand(floor(iTime*10.)));\n            }\n\n            vec4 o_col_delta_last = abs(fragColor - o_col_last);\n            fragColor = o_col_delta_last*0.2;\n            \n        }\n    \n    }\n    \n    //float n_thresh = (sin(iTime*0.2)*0.5+0.5);\n    float n_thresh = 0.25;\n    //if(iMouse.w == 0.0){\n    //    n_thresh = 1.-(float(mod(iTime, 20.)))*0.1;\n    //}\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        float n_dist_nor = n_dist/n_thresh;\n        //fragColor = vec4(sin(n_dist*6.2831)*0.5+0.5);\n        //fragColor = mix(o_col_last, fragColor,n_dist);\n        //fragColor = mix(o_col_last, fragColor,2.*n_dist_nor);\n        //fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        //fragColor = vec4(f_n_rand(fragCoord.x*fragCoord.y));\n        fragColor = vec4(sqrt(n_dist_nor));\n\n    }\n    \n    fragColor = (fragColor);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "md2XDh", "name": "Britney Galore", "author": "ilia87", "description": "A britney spears fractal. Use WASD to move", "tags": ["menger", "britney"], "likes": 3, "viewed": 196, "published": 3, "date": "1670363039", "time_retrieved": "2024-07-30T16:14:32.410130", "image_code": "#define MENGER_STEPS 6\n\nconst vec3 ambientColor = vec3(1.0,0,0);\nconst vec3 diffuseColor = vec3(0,1.0,0);\nconst vec3 specularColor = vec3(1.0,1.0,1.0);\nconst float shininessVal = 3.0;\nconst float Ka = 0.3;\nconst float Kd = 0.6;\nconst float Ks = 0.4;\nconst vec3 boxPos = vec3(0,0,0);\nvec3 boxWidth = vec3(3.);\nconst float SMALL_DIST = .0001;\n\n\nfloat sdBox(vec3 p, vec3 boxWidth)\n{\n    vec3 q = abs(p) - boxWidth;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox2d(vec2 p, vec2 boxWidth)\n{\n    vec2 q = abs(p) - boxWidth;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdCross(vec3 p, vec3 crossWidth)\n{\n    return min(min(\n        sdBox2d(p.xy,crossWidth.xy),\n        sdBox2d(p.yz,crossWidth.yz)),\n        sdBox2d(p.zx,crossWidth.zx));\n}\n\nfloat GetDist(vec3 pos)\n{\n    vec3 p = pos;\n    p -= boxPos;\n    float b = sdBox(p, boxWidth);\n    float d = b;\n    vec3 crossWidth = boxWidth * .333333333333;\n    for ( int i=0;i<MENGER_STEPS;++i)\n    {\n        float c = sdCross(p,crossWidth);\n        d = max(d,-c);\n        p += crossWidth;\n        p = mod(p,2.*crossWidth);\n        p -= crossWidth;\n        crossWidth *= .3333333333333;\n    }    \n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001,0.);\n    return normalize(GetDist(p) - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float dist0)\n{\n    float dist = dist0;\n    for (int iStep = 0;iStep < 150;++iStep)\n    {\n        float ddist = GetDist(ro+rd*dist);\n        dist += ddist;\n    }\n    return dist;\n}\n\nvec3 Phong(vec3 pos, vec3 N, vec3 L, vec3 camPos)\n{\n    //vec3 L = lightSrc-pos;\n    //float lightDist = length(L);\n    //L /= lightDist;\n    float lambertian = max(dot(N, L), 0.0);\n    float specular = 0.0;\n    if(lambertian > 0.0) {\n      vec3 R = reflect(-L, N);      // Reflected light vector\n      vec3 V = normalize(camPos-pos); // Vector to viewer\n      // Compute the specular term\n      float specAngle = max(dot(R, V), 0.0);\n      specular = pow(specAngle, shininessVal);\n    }\n    return Ka * ambientColor +\n                   (Kd * lambertian * diffuseColor +\n                   Ks * specular * specularColor)\n                   ;// /pow(lightDist * lightDistFact,lightDistPow);\n}\n\nvec4 SampleCell(vec2 uv, ivec2 cellNum)\n{\n    vec2 cellSize = floor(iResolution.xy / vec2(numCells));\n    int buffNum = cellNum.x / numCells.x;\n    cellNum.x -= buffNum*numCells.x;\n    if ( buffNum == 0)\n        return texelFetch(iChannel1,ivec2((vec2(cellNum)+uv)*cellSize),0);\n    else if (buffNum == 1)\n        return texelFetch(iChannel2,ivec2((vec2(cellNum)+uv)*cellSize),0);\n    else\n        return texelFetch(iChannel3,ivec2((vec2(cellNum)+uv)*cellSize),0);\n}\n\nvec3 MengerColor(vec3 p)\n{\n    vec3 cmap[6] = vec3[6](\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1),\n        vec3(.6,.6,0),\n        vec3(.6,0,.6),\n        vec3(0,.6,.6));\n    p -= boxPos;\n    float b = sdBox(p, boxWidth);\n    if (b > SMALL_DIST )\n        return vec3(0);\n    vec3 crossWidth = boxWidth * .333333333333;\n    for ( int i=0;i<MENGER_STEPS;++i)\n    {\n        float c = sdCross(p,crossWidth);\n        if ( abs(c)<SMALL_DIST)\n        {\n            vec2 p2;\n            vec2 c2;\n            int dir;\n            if      (abs(p.z-crossWidth.z)<SMALL_DIST || abs(p.z+crossWidth.z)<SMALL_DIST)\n            {\n                p2 = p.xy;\n                c2 = crossWidth.xy;\n                dir = 0;\n            }\n            else if (abs(p.x-crossWidth.x)<SMALL_DIST || abs(p.x+crossWidth.x)<SMALL_DIST)\n            {\n                p2 = p.yz;\n                c2 = crossWidth.yz;\n                dir = 1;\n            }\n            else if (abs(p.y-crossWidth.y)<SMALL_DIST || abs(p.y+crossWidth.y)<SMALL_DIST)\n            {\n                p2 = p.zx;\n                c2 = crossWidth.zx;\n                dir = 2;\n            }\n            else\n            {\n                return vec3(0,0,1);\n            }\n            //p2 = abs(p2);\n            p2 += c2;\n            //p2 = mod(p,c2);\n            vec2 uv = fract(p2/c2*.5);\n            //vec2 uv = mod(p2,c2)/c2;\n            //return vec3(uv,0.);\n            //return texture(iChannel2,1.-uv.yx).xyz;\n            return SampleCell(1.-uv.yx,ivec2((MENGER_STEPS-i-1)*3+dir,0)).xyz;\n            //p/=crossWidth;\n            //if ( \n            //return cmap[i%6];\n        }\n        p += crossWidth;\n        p = mod(p,2.*crossWidth);\n        p -= crossWidth;\n        crossWidth *= .3333333333333;\n    }\n    return vec3(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat3 camRot = GetCamRot(iMouse,iResolution);\n\n    //mat2 R = Rotation(iTime*.3);\n    vec3 camPos = GetCamPos(iChannel0);\n    //camPos.xz *= R;\n    \n    vec3 rd;\n    rd.xy = (fragCoord*2.0 - iResolution.xy) / iResolution.x;\n    rd.z = 1.0;\n    //rd.xz *= R;\n    rd = camRot * rd;\n    vec3 ro = camPos;\n    rd = normalize(rd);\n    float dist = RayMarch(ro,rd,0.);\n    //if(  dist < -1.)\n    //{\n    //    fragColor.xyz=vec3(1,0,0);\n    //    return;\n    //    \n    //}\n    vec3 p = ro + rd*dist;\n    float finalDist = GetDist(p);\n    if (finalDist<SMALL_DIST)\n    {\n        vec3 n = GetNormal(p);\n        //fragColor = vec4(Phong(p,n,normalize(vec3(3,2,-3)),camPos),1);\n        //fragColor.xyz = .5*MengerColor(p) + .5*fragColor.xyz;\n        fragColor.xyz = MengerColor(p);\n    }\n    else\n    {\n        fragColor = vec4(0,0,0,1);\n    }    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    if (iFrame < 10 )\n        return;\n    if (int(fragCoord.x) > 0 || int(fragCoord.y) > 0)\n        return;\n    vec3 camPos = GetCamPos(iChannel0);\n    mat3 camRot = GetCamRot(iMouse,iResolution);\n    float speed = .02;\n    if ( texelFetch(iChannel3,ivec2(87,0),0).x != 0. )\n    {\n        camPos += camRot[2]*speed;\n    }\n    if ( texelFetch(iChannel3,ivec2(83,0),0).x != 0. )\n    {\n        camPos -= camRot[2]*speed;\n    }\n    if ( texelFetch(iChannel3,ivec2(65,0),0).x != 0. )\n    {\n        camPos -= camRot[0]*speed;\n    }\n    if ( texelFetch(iChannel3,ivec2(68,0),0).x != 0. )\n    {\n        camPos += camRot[0]*speed;\n    }\n    fragColor.xyz = camPos;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat2 Rotation(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nmat3 Rotation3(float theta, float phi, float psi)\n{\n    float ct = cos(theta);\n    float st = sin(theta);\n    float cp = cos(phi);\n    float sp = sin(phi);\n    float cs = cos(psi);\n    float ss = sin(psi);\n    return \n        mat3(cp,0,-sp,0,1,0,sp,0,cp) *\n        mat3(1,0,0,0,ct,-st,0,st,ct) *\n        mat3(cs,-ss,0,ss,cs,0,0,0,1);\n        \n}\n\nmat3 GetCamRot(vec4 iMouse, vec3 iResolution)\n{\n    return Rotation3(\n        (.5+iMouse.y/iResolution.y)*radians(180.),\n        -iMouse.x/iResolution.x*radians(360.),\n        0.);\n}\n\nvec3 GetCamPos(sampler2D s)\n{\n    return texelFetch(s,ivec2(0,0),0).xyz;\n}\n\nconst ivec2 numCells = ivec2(6,4);\nconst int frameDilution = 3;\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame%frameDilution != 0)\n    {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n        return;\n    }\n    vec2 cellSize = floor(iResolution.xy / vec2(numCells));\n    fragColor = vec4(0,0,0,1);\n    vec2 cellCoord = floor(fragCoord/cellSize);\n    vec2 coordInCell = fragCoord - cellCoord*cellSize;\n    \n    if ( cellCoord.x == 0. && cellCoord.y == 0.)\n    {\n        fragColor = texture(iChannel2,coordInCell/cellSize);\n        return;\n    }\n    ivec2 prevCell = ivec2(cellCoord);\n    prevCell.y--;\n    if (prevCell.y < 0)\n    {\n        prevCell.y = numCells.y-1;\n        prevCell.x--;\n    }\n    fragColor = texelFetch(iChannel0,prevCell * ivec2(cellSize) + ivec2(coordInCell),0);\n}", "buffer_b_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame%frameDilution != 0)\n    {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n        return;\n    }\n    vec2 cellSize = floor(iResolution.xy / vec2(numCells));\n    fragColor = vec4(0,0,0,1);\n    vec2 cellCoord = floor(fragCoord/cellSize);\n    vec2 coordInCell = fragCoord - cellCoord*cellSize;\n    \n    if ( cellCoord.x == 0. && cellCoord.y == 0.)\n    {\n        fragColor = texelFetch(iChannel1,(numCells-ivec2(1,1))*ivec2(cellSize) + ivec2(coordInCell),0);\n        return;\n    }\n    ivec2 prevCell = ivec2(cellCoord);\n    prevCell.y--;\n    if (prevCell.y < 0)\n    {\n        prevCell.y = numCells.y-1;\n        prevCell.x--;\n    }\n    fragColor = texelFetch(iChannel0,prevCell * ivec2(cellSize) + ivec2(coordInCell),0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame%frameDilution != 0)\n    {\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n        return;\n    }\n    vec2 cellSize = floor(iResolution.xy / vec2(numCells));\n    fragColor = vec4(0,0,0,1);\n    vec2 cellCoord = floor(fragCoord/cellSize);\n    vec2 coordInCell = fragCoord - cellCoord*cellSize;\n    \n    if ( cellCoord.x == 0. && cellCoord.y == 0.)\n    {\n        fragColor = texelFetch(iChannel1,(numCells-ivec2(1,1))*ivec2(cellSize) + ivec2(coordInCell),0);\n        return;\n    }\n    ivec2 prevCell = ivec2(cellCoord);\n    prevCell.y--;\n    if (prevCell.y < 0)\n    {\n        prevCell.y = numCells.y-1;\n        prevCell.x--;\n    }\n    fragColor = texelFetch(iChannel0,prevCell * ivec2(cellSize) + ivec2(coordInCell),0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2XDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 379, 379, 477], [479, 479, 517, 517, 606], [608, 608, 648, 648, 783], [785, 785, 810, 810, 1205], [1207, 1207, 1231, 1231, 1388], [1390, 1390, 1437, 1437, 1602], [1604, 1604, 1655, 1741, 2296], [2298, 2298, 2339, 2339, 2764], [2766, 2766, 2792, 2792, 4559], [4561, 4561, 4618, 4618, 5462]], "test": "untested"}
{"id": "DsSXDw", "name": "can you make the screen white?", "author": "jonasfrey", "description": "can you wipe all of the black stuff so the screen gets light gray/ white ? \nhint: dont go to fast\n", "tags": ["template"], "likes": 2, "viewed": 170, "published": 3, "date": "1670360213", "time_retrieved": "2024-07-30T16:14:33.177080", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define n_size_max_a_o_col_last_krnl 1000;\nfloat f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n\n\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        o_trmono = vec2(sin(iTime*2.)*0.5, 0.33);\n    }\n    vec2 o_scale = vec2(0.5);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec2 o_scale_kernel = vec2(\n        5.,\n        10.\n    );\n    float n_size_kernel = o_scale_kernel.x * o_scale_kernel.y;\n    //vec4[3] a_o_col_last_krnl = vec4[3];\n    //vec3[32] palette = vec3[32];\n    //vec4 a_o_col_last_krnl[n_size_max_a_o_col_last_krnl];\n    vec4 o_kernel_sum = vec4(0.0);\n    int n_index_a_o_col_last_krnl = 0;\n    for(float n_y = 0.0; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.0; n_x < o_scale_kernel.x; n_x+=1.){\n            vec2 o_speed = vec2(0.1,0.1);\n            vec2 o = vec2(\n               floor(n_x - floor(o_scale_kernel.x/2.)),\n               floor(n_y - floor(o_scale_kernel.y/2.)) \n            ) + o_speed;\n            vec2 o_off = vec2(\n                o.x * (1./o_iResolution_scaled_floor.x),\n                o.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_kernel;\n            n_index_a_o_col_last_krnl+=1;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        if(\n            mod(n_index, 2.) == mod(o_fragCoord_scaled_floor.y,2.)\n        ){\n            fragColor = vec4(1.);\n        }else{\n            fragColor = vec4(0.);\n        }\n    }else{\n        if(mod(float(iFrame), 3.) > 1.){\n            fragColor = o_col_last;\n\n        }else{\n            fragColor = vec4(0.);\n\n            if(o_kernel_sum_nor.x > sqrt(0.305)){//f_n_rand(iTime)){\n                fragColor = vec4(1.);\n            }else{\n                fragColor = vec4(0.0);\n            }\n            float n = 0.01;\n            if(o_kernel_sum_nor.x > (1.-n) || o_kernel_sum_nor.x < n){\n                fragColor = vec4(f_n_rand(iTime+n_index));\n            }\n        }\n\n        //fragColor = o_col_last;\n        //fragColor += (o_kernel_sum_nor*0.001);\n    \n    }\n    \n    float n_thresh = 0.1;\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        fragColor = vec4(sin(n_dist*6.2831*20.)*0.5+0.5);\n        fragColor = mix(o_col_last, fragColor,n_dist);\n        fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        fragColor = vec4(f_n_rand(n_dist*2.));\n    }\n    \n    fragColor = sqrt(fragColor);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "mdjSDh", "name": "Multi-layer perlin noise", "author": "bsodium", "description": "A basic multi-layered perlin noise shader implementation", "tags": ["noise", "perlin", "gradient"], "likes": 1, "viewed": 96, "published": 3, "date": "1670352791", "time_retrieved": "2024-07-30T16:14:34.226274", "image_code": "/*\n * Interpolation function between a0 and a1\n * The weight w should be in the range [0.0, 1.0]\n */\nfloat interpolate(float a0, float a1, float w) {\n    if (0.0 > w) return a0;\n    if (1.0 < w) return a1;\n\n    //return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n    return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;\n    //return (a1 - a0) * w + a0;\n}\n\n/* \n * Generate a random direction vector.\n */\nvec2 randomGradient(int ix, int iy, float seed) {\n    float random = fract(sin(dot(vec2(ix, iy), vec2(12.9898, 78.233))) * 43758.5453 + seed);\n    return normalize(vec2(cos(random * 2.0 * 3.14159265359), sin(random * 2.0 * 3.14159265359)));\n}\n\n/* \n * Compute the dot-product of the distance and gradient vectors.\n */\nfloat dotGridGradient(int ix, int iy, float x, float y) {\n    // Get gradient from integer coordinates\n    vec2 gradient = randomGradient(ix, iy, iTime);\n\n    // Compute the distance vector\n    float dx = x - float(ix);\n    float dy = y - float(iy);\n\n    // Compute the dot-product\n    return (dx*gradient.x + dy*gradient.y);\n}\n\n// Compute Perlin noise at coordinates x, y\nfloat perlin(float x, float y) {\n    // Grid cell coordinates\n    int x0 = int(floor(x));\n    int x1 = x0 + 1;\n    int y0 = int(floor(y));\n    int y1 = y0 + 1;\n\n    // Interpolation weights\n    float sx = x - float(x0);\n    float sy = y - float(y0);\n\n    // Interpolate between grid point gradients\n    float n0, n1, ix0, ix1, value;\n\n    n0 = dotGridGradient(x0, y0, x, y);\n    n1 = dotGridGradient(x1, y0, x, y);\n    ix0 = interpolate(n0, n1, sx);\n\n    n0 = dotGridGradient(x0, y1, x, y);\n    n1 = dotGridGradient(x1, y1, x, y);\n    ix1 = interpolate(n0, n1, sx);\n\n    value = interpolate(ix0, ix1, sy);\n    return value; // Return value in range -1 to 1.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    uv *= 10.0; // Control grid resolution\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Low frequency\n    float n1 = perlin(uv.x, uv.y);\n    \n    uv *= 2.0;\n    \n    // Medium frequency\n    float n2 = perlin(uv.x, uv.y);\n    \n    uv *= 2.0;\n    \n    // High frequency\n    float n3 = perlin(uv.x, uv.y);\n    \n    // Compute average\n    float n = (n1 + n2 + n3) / 3.0;\n    \n    fragColor = vec4(n, n, n, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 101, 149, 149, 369], [371, 418, 467, 467, 660], [662, 735, 792, 837, 1062], [1064, 1108, 1140, 1169, 1767], [1769, 1769, 1826, 1826, 2325]], "test": "untested"}
{"id": "ddjSzW", "name": "Cel raymarcher", "author": "raymarchingenthusiast", "description": "A raymarcher. Drag your mouse to look around. W/S to move the camera forward and backward. M to switch modes. R to reset your camera position and modes. CEL shaded. Advanced skybox.     #--Expect this to be broken many times.--#", "tags": ["raymarching", "clouds", "cel"], "likes": 9, "viewed": 387, "published": 3, "date": "1670352260", "time_retrieved": "2024-07-30T16:14:35.085976", "image_code": "#define MAX_STEPS 250\n#define MAX_DIST 500.\n#define SURF_DIST .01\n#define OFFSET SURF_DIST*1.05\n#define LIGHT Light(.1,vec3(-50.*sin(iTime/3.),60.+50.*cos(iTime/9.),-50.*cos(iTime/3.)),vec3(1.,.9,.7),5.)\n#define OW .15\n\n//////\nvec3 skybox(in vec3 rd, vec3 cam) {\n    //vec3 skybox = texture(iChannel1,rd).xxx;\n    vec3 skybox = vec3(.5,.8,.95);  //blue sky\n    float sun = pow(dot(normalize(LIGHT.pos),rd)*.5+.5,100.)*2.;\n    vec2 cloudMove = iTime/25.*vec2(.1,.3);\n    vec3 cloud = texture(iChannel1,vec3(rd.xz/(rd.y*.5)-cloudMove+cam.xz/25.,iTime/160.)).xxx;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*1.5)-cloudMove+cam.xz/75.,iTime/160.)).xxx*3.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*4.5)-cloudMove+cam.xz/225.,iTime/160.)).xxx*9.;\n    cloud += texture(iChannel1,vec3(rd.xz/(rd.y*13.5)-cloudMove+cam.xz/675.,iTime/160.)).xxx*27.;\n    cloud /= 40.;\n    //cloud = vec3(0.);  //remove clouds if not commented out\n    cloud = 3.*pow(cloud,vec3(3.));\n    if(rd.y>.03) {skybox = mix(skybox,vec3(1.,.8,.4),clamp(sun,0.,1.));skybox = mix(skybox,vec3(1.),cloud);}\n    else {\n    }\n    return skybox;\n}\n//maxabs3(rd)==rd.y&&\n//rd.y*\n//if(rd.y>0.) \nfloat toon(float d,float a) {\n    float dif = mix(a,.95,round(sat(d)));\n    return dif;\n}\n\n/////SDFs\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = sat(dot(pa,ba)/dot(ba,ba));\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 a, vec4 b) {\n    vec3 q = abs(p-a)-b.xyz;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-b.w;\n}\n\n\n/////World\nfloat map(in vec3 p, bool il){\n    float d0 = sdSphere(p,vec4(-2.,4.,0.,1.));\n    float d1 = sdBox(p,vec3(0.),vec4(9.8,1.3,9.8,.2));\n    float d = min(d0,d1);\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    float d0 = map(p,true);\n    vec2 e = vec2(.01,0.);\n    vec3 n = d0-vec3(\n    map(p-e.xyy,true),\n    map(p-e.yxy,true),\n    map(p-e.yyx,true));\n    \n    return normalize(n);\n}\n\nvec3 trimap(vec3 p, sampler2D s, float k, float rk) {\n    vec3 n = pow(getNormal(p),vec3(k));\n    vec3 tx = texture(s, p.yz/rk).xyz;\n    vec3 ty = texture(s, p.xz/rk).xyz;\n    vec3 tz = texture(s, p.xy/rk).xyz;\n    return (tx*n.x + ty*n.y+tz*n.z)/(n.x+n.y+n.z);\n}\n\n\nvoid map(in vec3 p, out Mat mat) {\n    float d0 = sdSphere(p,vec4(-2.,4.,0.,1.));\n    float d1 = sdBox(p,v(0.),vec4(4.8,1.3,4.8,.2));\n    float d = min(d0,d1);\n                                                  //Materials\n    if(d==d0) mat = Mat(0,v(1.)*.2,.6,.2,20.);\n    if(d==d1) mat  = Mat(0,vec3(.4,.8,1.)*.2,.6,.08,40.);\n    \n}\n\n\nfloat raymarch(in vec3 rd, in vec3 ro, out bool hit,out bool outline) {  \n    float h = 0.;  \n    hit = false;\n    outline = false;\n    float oldD = MAX_DIST;\n    float oldH = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        float d = map(p,true);\n        \n        if (d < SURF_DIST) {\n            hit = true;\n            break;\n        }\n        if(oldD <= OW && d >= OW && d > oldD) {outline=true;}\n        if (h > MAX_DIST) break;\n        oldD = d;\n        oldH = h;\n        h += d;\n    }\n    \n    return h;\n}\n\nfloat shadow(vec3 p, vec3 rd, float len) {\n    float ss = 1.;\n    float h = 0.;\n    for(int t = 0; t < MAX_STEPS && h < len; t++) {\n       vec3 cp = p+rd*h;\n       float d = map(cp,false);\n       if(d < SURF_DIST) return 0.;\n       h += d;\n    }\n    return 1.;\n}\n\nfloat diffuse(vec3 p,vec3 lp0) {\n    vec3 n = getNormal(p);\n    vec3 l = normalize(lp0);\n    \n    float ss = shadow(p+n*OFFSET,l,length(lp0));\n    float dif = dot(l,n);\n    return max(dif,0.)*ss;\n}\n\nfloat specular(vec3 n,vec3 ev, vec3 lv, float a) {\n    //vec3 n = getNormal(p);\n    vec3 h = normalize(lv + ev);\n    float spec = pow(sat(dot(n,h)),a);\n    return spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rd = crd(fragCoord,iResolution,iMouse,false);\n    vec3 ro = texture(iChannel0,fragCoord).xyz;\n    if(bool(texture(iChannel0,fragCoord).w)) ro = -25.*crd(vec2(iResolution.xy/2.),iResolution,iMouse,false);\n    ro.y += 3.;\n    //vec3 rdOrig = rd;\n    \n    vec3 col = v(0.);\n\n    bool hit = false;\n    bool outline;\n    float d = raymarch(rd,ro,hit,outline);\n    vec3 p = ro+rd*d;\n    Mat mat;\n    map(p,mat);\n    float brightness;\n    \n    if (hit == true) {\n    switch (mat.lt) {\n    case 0: \n        vec3 n = getNormal(p);\n        float dif = diffuse(p,LIGHT.pos-p);\n        float spec = specular(n,-rd,normalize(LIGHT.pos-p),mat.sa);\n        \n        float diffusePower = toon(dif*.5+.5,LIGHT.ai)*mat.di*LIGHT.str;\n        vec3 diffuseLight = diffusePower*mat.col*LIGHT.col;\n        \n        float specPower = toon(spec,.0)*mat.si*LIGHT.str;\n        vec3 specLight = specPower*(dif*.5+.5)*LIGHT.col;\n        \n        float fresnelPower = (1.-dot(n,rd))*.05;\n        vec3 baseLight = v(sat(fresnelPower));\n        \n        col += diffuseLight + specLight + baseLight;\n        brightness += clamp(fresnelPower,0.,.1)+specPower*(dif*.5+.5)+diffusePower;\n        break;\n    }\n    } else {\n        vec3 sky = skybox(rd,ro);\n        col = sky;\n        brightness = 1.;\n    }\n    if(outline) col = v(0.);\n    \n    //col = rd;\n    fragColor = vec4(pow(sat(col),v(1./2.2)),brightness);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define FOV 90.\n#define sat(d) clamp(d,0.,1.)\n\nstruct Light {\n    float ai;\n    vec3 pos;\n    vec3 col;\n    float str;\n};\n\nstruct Mat {\n    int lt;\n    vec3 col;\n    float di;\n    float si;\n    float sa;\n};\n\nvec2 rot(vec2 p,float a) {\n    return vec2(p.x*cos(a)+p.y*sin(a),p.x*sin(a)-p.y*cos(a));\n}\n\nvec3 crd(vec2 fragCoord, vec3 iResolution, vec4 iMouse, bool sideways) {\n    vec2 mouse = PI*((vec2(iMouse.x*3.,iMouse.y*1.1)/iResolution.xy)-.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(iMouse.xy == vec2(0.)) mouse.xy = vec2(PI/2.,0.);\n    \n    vec3 rd = normalize(vec3(uv.xy,1./tan(FOV*PI/360.)));\n    \n    vec2 rotAmt = vec2(sideways?-1.5*PI-mouse.x:PI-mouse.x,mouse.y-PI);\n    rd = vec3(rd.x,rot(rd.yz,rotAmt.y));\n    rd.y = -rd.y;\n    vec2 rotRd = rot(rd.zx,rotAmt.x);\n    rd = vec3(-rotRd.y,rd.y,rotRd.x);\n    return rd;\n}\n\nfloat maxabs3(vec3 p) {\n    float o = abs(p.x)>abs(p.y) ? p.x : p.y;\n    return abs(o)>abs(p.z) ? o : p.z;\n}\n\nvec3 v(float f) {return vec3(f);}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 l = texture(iChannel0,fragCoord);\n    vec3 j = l.xyz;\n    float m = l.w;\n    bvec3 reset = bvec3(texelFetch(iChannel1,ivec2(82,0),0).x > 0.,iFrame < 5,texelFetch(iChannel1,ivec2(77,1),0).x > 0.);\n    vec2 k = vec2(texelFetch(iChannel1,ivec2(87,0),0).x > 0.) - float(texelFetch(iChannel1,ivec2(83,0),0).x > 0.);\n    k.y = float(texelFetch(iChannel1,ivec2(68,0),0).x > 0.) - float(texelFetch(iChannel1,ivec2(65,0),0).x > 0.);\n    if(reset.z) m = 1.-m;\n    \n    vec3 d = crd(vec2(iResolution.xy/2.),iResolution,iMouse,false);\n    vec3 a = crd(vec2(iResolution.xy/2.),iResolution,iMouse,true);\n    \n    j += .8*60.*k.x*iTimeDelta*d;\n    j += .8*60.*k.y*iTimeDelta*a;\n    if(reset.x || reset.y || reset.z) j = vec3(0.,4.,-25.);\n    if(reset.x || reset.y) m = 1.;\n    l = vec4(j,m);\n    fragColor = vec4(l);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjSzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 227, 262, 309, 1112], [1113, 1158, 1187, 1187, 1247], [1260, 1260, 1297, 1297, 1341], [1343, 1343, 1395, 1395, 1502], [1504, 1504, 1541, 1541, 1636], [1639, 1650, 1680, 1680, 1824], [1826, 1826, 1850, 1850, 2029], [2031, 2031, 2084, 2084, 2294], [2297, 2297, 2331, 2331, 2630], [2633, 2633, 2704, 2704, 3176], [3178, 3178, 3220, 3220, 3440], [3442, 3442, 3474, 3474, 3639], [3641, 3641, 3691, 3720, 3811], [3813, 3813, 3870, 3870, 5258]], "test": "untested"}
{"id": "csjSDh", "name": "Wavy flag of Finland", "author": "maksy", "description": "The flag of Finland\n\nI followed a tutorial from The Art of Code to make it:\nhttps://www.youtube.com/watch?v=t4XnK50ocMk", "tags": ["flag"], "likes": 4, "viewed": 277, "published": 3, "date": "1670351475", "time_retrieved": "2024-07-30T16:14:35.893816", "image_code": "vec3 WHITE = vec3(1);\nvec3 BLUE = vec3(0, 47.0/255.0, 108.0/255.0);\n\nvec3 flag(vec2 uv)\n{\n    // Finnish flag ratios y: 4:3:4, x: 5:3:10.\n    \n    // Resolution independent width.\n    float w = fwidth(uv.y)*3.;\n    float stripeVert = smoothstep(0.894, 0.894+w, sin(uv.y * 3.14));\n    \n    w = fwidth(uv.x)*3.;\n    float stripeHoriz = smoothstep(0.966, 0.966+w, sin(uv.x * 3.14 + .434));\n    \n    vec3 col = mix(WHITE, BLUE, stripeVert); \n    col *= mix(WHITE, BLUE, stripeHoriz); \n    col = mix(WHITE, BLUE, max(stripeHoriz, stripeVert));\n    \n    // The flag goes outside of zero to one range when it waves. Make the bottom edge to rest at zero.\n    col *= smoothstep(w, 0.0, abs(uv.y - 0.5) - 0.5);\n    \n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Make it wavy.\n    float t = uv.x*4.5-1.4*iTime+uv.y*2.0;\n    uv.y -= sin(t)*0.1;\n    \n    vec3 col = flag(uv);\n\n    // Add shading. The light comes from the side, so it should be dark when it's going\n    // down and bright when it's going up. We get that by taking the derivate of the value\n    // set to uv.y which is cosine of t.   \n    col *= 0.8 + cos(t) * 0.2;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 89, 179, 723], [724, 724, 779, 830, 1283]], "test": "untested"}
{"id": "msjXWD", "name": "Pimple Wave", "author": "SnoopethDuckDuck", "description": "Very messy, couldn't quite get the colors right but it looks okay.\n\nAO and shadows taken from here:\nhttps://www.shadertoy.com/view/cdSXDW\n\nMaterials inspired by this:\nhttps://www.shadertoy.com/view/ttsXWr", "tags": ["skin"], "likes": 16, "viewed": 321, "published": 3, "date": "1670345276", "time_retrieved": "2024-07-30T16:14:36.734568", "image_code": "// was 400, 100, 0.001\n#define MAX_STEPS 100\n#define MAX_DIST 25.\n#define SURF_DIST .005\n\nvec3 rayOri() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 8.;\n    float t = 0.1 * iTime;\n    vec3 ro = r * vec3(cos(t), 0.4, sin(t));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat dist1(vec3 p) {\n    float pd = p.y - 3. * texture(iChannel0, 0.01 * p.xz + iTime * 0.01).r;\n    return pd;\n}\n\nvec3 norm1(vec3 p) {\n\tfloat d = dist1(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        dist1(p-e.xyy),\n        dist1(p-e.yxy),\n        dist1(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat mat = 0.;\nvec2 dist(vec3 p) {\n    p.x += iTime;\n    p.y += 0.15*cos(1.5 * p.x + iTime);\n    float d1 = dist1(p);\n    //vec3 n1 = norm1(p);\n\n    vec2 ipos = floor(p.xz) + 0.5;\n    vec2 fpos = p.xz - ipos;\n   \n    float h = dist1(vec3(ipos.x,p.y,ipos.y));\n    float rnd = h21(ipos);\n    float r = 0.11 + 0.06 * rnd;\n    vec3 p2 = vec3(fpos.x, 0, fpos.y);\n    float a = 2. * pi * rnd;\n    float b = cos(a)*p2.x+sin(a)*p2.z;\n    float c = (.5+.5*cos(ipos.x * ipos.y + 32. * b + 4. * iTime));\n    vec3 q = vec3(0, r - h + 0.25 * h * c, 0);\n    float sd = length(p2 - q) - r;\n    sd *= 0.5;\n    if (rnd < 0.025) {\n        sd = length(vec3(fpos.x,p.y * 0.5,fpos.y)) -0.5;\n    }\n    float d = d1;\n    float mat = 0.;\n    if (sd < d1) {\n        mat = 1.;\n        d = sd;\n    }\n    //d = smin(d1, sd, .1 + .1 * (1.-c)); // pimples :)\n    return vec2(d, mat);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d=0.;\n    float s = sign(z);\n    float steps = 0.;\n    vec2 dmat = vec2(0);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*d;\n        dmat = dist(p);        \n        if (s != sign(dmat.x)) { z *= 0.5; s = sign(dmat.x); }\n        if(abs(dmat.x)<SURF_DIST || d>MAX_DIST) break;\n        d += dmat.x*z; \n        steps++;\n    }\n    \n    return vec3(min(d, MAX_DIST), steps, dmat.y);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = dist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy).x,\n        dist(p-e.yxy).x,\n        dist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// Stolen from Sizertz (cool shader)\n// https://www.shadertoy.com/view/cdSXDW\nfloat AO(in vec3 p, in vec3 n) {\n\tfloat occ = 0.;\n    float sc = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        float h = 0.015 + 0.015 * i;\n        float d = dist(p+h*n).x;\n        occ += (h-d)*sc;\n        sc *= 0.95;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd) {\n    float res = 1.;\n    float t = SURF_DIST;\n    for (int i=0; i<24; i++)\n    {\n\t\tfloat h = dist(ro + rd * t).x;\n        float s = clamp(32. * h / t, 0., 1.);\n        res = min(res, s);\n        t += clamp(h, 0.01, 0.2);\n        if(res<SURF_DIST || t>MAX_DIST ) break;\n    }\n    res = clamp(res, 0.0, 1.0);\n    return smoothstep(0., 1., res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = rayOri();\n    \n    vec3 rd = rayDir(uv, ro, vec3(0), 1.4);\n    vec3 col = vec3(0);\n   \n    vec3 m = march(ro, rd, 1.);\n    float d = m.x;\n    \n    vec3 p = ro + rd * d;\n    float IOR = 1.2;\n    if(d<MAX_DIST) {        \n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n        float ao = AO(p, n);\n        \n        vec3 ld = normalize(vec3(1,1,-1) * rayOri());//vec3(-1,2,-3));\n        float dif  = dot(n,  ld)*.5+.5;\n        float fres = pow(1. + dot(rd, n), 3.);\n        \n        vec3 col1 = vec3(dif);//pal(0.25,vec3(0,1,2)/3.);\n \n        //col = mix(vec3(0), .5+.5*vec3(abs(rd.x),rd.y,abs(rd.z)), abs(mat-at));\n        vec3 pl = pal(p.y + iTime, vec3(0,1,2)/3.);\n        vec3 tx = texture(iChannel0, 0.01 * p.xz).rgb;\n        //col *= tx;\n       // col = mix(col, pl, at*fres);\n        col = col1;\n       // col *= ao * ao;\n        col.r += 0.4;\n      \n        vec2 ipos = floor(p.xz + vec2(iTime,0)) + 0.5;\n        vec2 fpos = fract(p.xz + vec2(iTime,0)) - 0.5;\n        float xp = 1./cosh(4. * length(fpos));\n        vec3 q = p - vec3(ipos.x, 0, ipos.y);\n        \n        q.y += 0.015 - dist1(q);\n    \n        float a = atan(p.y - q.y, p.x - q.x);\n        //col = mix(col, vec3(.5+.5 * cos(100. * a)), m.z);\n        \n        //col *= pal(m.z, 0.25 * vec3(0,1,2)/3.);\n        vec3 tx1 = texture(iChannel1, 0.05 * (p.xz + vec2(iTime,0))).rgb;\n        vec3 tx2 = texture(iChannel2, 0.05 * (p.xz + vec2(iTime,0))).rgb;\n        col = mix(col, tx1, 0.35);\n        col = mix(col, tx2, 1.-xp);\n        col = mix(col, vec3(1,0.5,0.5), 1.-exp(-0.01 * m.y));\n        ao = clamp(ao, 0., 1.);\n        col = mix(col, mix(tx1,tx2,0.3), 1.-ao * ao);\n        \n        float s = shadow(p + 4. * SURF_DIST * n, ld);\n        col *= .5 + 0.8* s;\n        float spec = pow(dif, 32.);\n        col = mix(col, vec3(1), spec);\n        col.gb *= 0.6;\n        col *= 1.-exp(-4.*abs(p.y));\n        vec3 c1 = texture(iChannel1, .5*(p.xy+vec2(iTime,-q.y))).rgb;\n        vec3 c2 = texture(iChannel2, .5*(p.yz+vec2(0,-q.y))).rgb;\n        vec3 c3 = texture(iChannel2, .5*(p.zx+vec2(0,iTime))).rgb;\n        vec3 c = abs(n).z*c1+abs(n).x*c2+abs(n).y*c3;\n       // col = mix(col, c, .5-.5*n.y);\n    }\n    else\n        col = .5+.5*vec3(abs(rd.x),rd.y,abs(rd.z));\n    \n    col = mix(col, vec3(0.05,0.013,0.01), 1.-clamp(exp(1.-0.5 * length(p.xz)), 0., 1.));\n    col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 105, 105, 318], [320, 320, 341, 341, 434], [436, 436, 456, 456, 638], [656, 656, 675, 675, 1496], [1498, 1498, 1537, 1537, 1940], [1942, 1942, 1963, 1963, 2149], [2151, 2151, 2198, 2198, 2389], [2391, 2469, 2501, 2501, 2737], [2739, 2739, 2777, 2777, 3121], [3123, 3123, 3180, 3180, 5681]], "test": "untested"}
{"id": "Dd2SWh", "name": "Loxodrome Spiral Projection", "author": "Shane", "description": "Casting a Mobius shadow pattern from a spinning loxodromic spherical spiral object.", "tags": ["spiral", "sphere", "mobius", "projection", "glow", "loxodrome", "mercator", "rhumb"], "likes": 93, "viewed": 1155, "published": 3, "date": "1670333707", "time_retrieved": "2024-07-30T16:14:37.657102", "image_code": "/*\n\n    Loxodrome Spiral Projection\n    ---------------------------    \n    \n    I don't have a lot to do with math these days, but I still get a kick out \n    of visual art demonstrations that convey mathematical ideas. Casting \n    shadows onto planes from spherical objects to illustrate various \n    projection patterns is one such example.\n    \n    In this case, an extruded dashed spherical loxodrome spiral path has been \n    light projected to a back plane to form a Mobius spiral shadow -- I think a \n    loxodrome is a form of Mobius transformation, so I guess that's not \n    surprising. At any rate, in various circles, it's a fairly common \n    demonstration, and there's already at least one such example on Shadertoy, \n    for whch I've provided a link to below.\n    \n    My first attempts some time ago involved mapping out a spiral onto a sphere \n    using standard spherical coordinates, which kind of produced a Mobius spiral \n    looking shadow, but wasn't what I was after. After inquiring into MLA's \n    mercator coordinate examples, I realized that I wasn't using an angle \n    preserving formula, so once I adjusted for that, everything came together. \n    By the way, if you're interested in spherical spiral mapping, I've provided \n    a link to one of MLA's examples below, which is written in a much nicer way.\n    \n    I did originally have a very simple spiral projected onto a plain background,\n    but since there were already a few of those on the internet, I applied some\n    CSG to create dashed lines, then got carried away with glow, etc. The idea to \n    give the inner sphere a different color to the outside came from Kamoshika's \n    \"Cubic Shell with Slits\" example, which is a interesting in its own right.\n    \n    I've seen some really nice spherical spiral imagery on the internet that \n    doesn't involve projection, and I'd like to make one of those at some point.\n    In regard to shadow projection, I intend to post one of the common polyhedral \n    to Poincare disk presentations. By the way Neozhaoliang has a beautiful \n    example along those lines that I'll provide a link to below.\n    \n    \n    \n\n    // Other examples:\n    \n    // A very cool shader. Unfortunately, I wrote most of the code to this\n    // before looking at MLA's example, which is written in a much nicer way. \n    // The one line I \"borrowed\" from it is the reason I got my example to \n    // work properly, so I'm thankful anyway. :)\n    Indexed Mercator Spiral - mla\n    https://www.shadertoy.com/view/NsdBzn\n    \n    // More of a classy rendering, and reminiscent of Paul Nylander's \n    // classic loxodrome projection image.\n    Loxodrome - fb39ca4\n    https://www.shadertoy.com/view/MsX3D2\n\n    // Beautiful example.\n    Hyperbolic Group Limit Set - Neozhaoliang\n    https://www.shadertoy.com/view/NstSDs\n    \n    // Nice and concise. Kamoshika's other examples are worth\n    // looking at too.\n    Cubic Shell with Slits - Kamoshika\n    https://www.shadertoy.com/view/ftj3WG\n    \n\n*/\n\n\n// Dashed lines. Commenting this out will display the more\n// traditional connected spiral arms.\n#define DASHED\n\n// Outer and inner glow colors.\n#define glowCol1 vec3(3, 1, .2)\n#define glowCol2 vec3(1, 3, .2) // vec3(.3, 2.5, 5)\n\n// Maximum ray distance.\n#define FAR 20.\n\n// Trying to stop the loop from unrolling to reduce compile times.\n#define ZERO min(iFrame, 0)\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.617, 57.643)))*43758.5453); }\n\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// The smooth maximum equivalent.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n/*\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(.8)); \n    //n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n*/\n\n// Global object ID and 2D line distance.\nfloat gOID, gLn;\n\n// Global lattitudinal and logitudinal (sphere surface) texture coordinates.\nvec2 gSUV;\n\n// Global glow and glow color variables.\nvec3 glow, lCol; \n\n\n// Loxodromic sphere scene.\nfloat map(vec3 p){\n\n    // Back plane.\n    float pln = -p.z + 2.;//abs(p.z - 2. + .01) - .01;\n    \n    // Sphere rotation.\n    p.xy *= rot2(3.14159/3.);\n    p.xz *= rot2(-iTime/2.);\n    //p.yz *= rot2(-iTime/4.);\n \n                    \n\n    // Sphere coordinates. \n    vec3 sphP = p;\n    // Coordinates for the polar caps. Note the abs(Y) to draw both poles with one call. \n    vec3 q = vec3(sphP.x, abs(sphP.y), sphP.z) - vec3(0, 1, 0);\n\n    // The X value controls the number of dashes per revolution and the Y value\n    // dictates the number of spiral arms.\n    const vec2 sSc = vec2(3, 3);\n    float ax = atan(sphP.z, sphP.x)/6.2831; // Longitudinal coordinate.\n    float ay = asin(sphP.y/length(sphP));// Or atan(sphP.y, length(sphP.xz)); // Latitude. \n    // The above are only spherical coordinates, which you can arrange to spiral around\n    // a sphere. However, to spiral along a spherical rhumb line in an angle preserving\n    // manner, the following adjustment needs to be applied. I knew something was necessary,\n    // but didn't know what it was. Thankfully, MLA did, so I was able to use his calculation. \n    // I usually prefer to derive these things myself, but I'm going to take it at face value. \n    // I'm guessing it'd be an application of differential surface geometry, or something \n    // along those lines.\n    // \n    // Indexed Mercator Spiral - mla\n    // https://www.shadertoy.com/view/NsdBzn\n    //\n    // The following are equivalent. I'm not sure which one the GPU likes best, \n    // but I'm going to go with the most concise one. :)\n    ay = asinh(tan(ay))/6.2831;\n    //ay = log(tan(3.14159265/4. + ay/2.))/6.2831; // Mercator\n    //ay = sign(ay)*acosh(1./cos(ay))/6.2831;// + .5;\n    \n    // The number of spirals per arm.\n    const float spirals = 5.; \n    // Spiral lines running perpendicular to one another. You can combine\n    // these to form objects, provide texture coordinates, etc.\n    vec2 spir = vec2(ax*spirals + ay, ax - ay*spirals);\n    \n    gSUV = spir*sSc;\n    \n    // Unique dash line UV. Not used here.\n    //vec2 ia = floor(gSUV)*sSc + .5;\n    \n    // Line thickness. The first line arranges for increased thickness near the poles.\n    float th = 1./(.001 + pow(length(sphP - sign(sphP)*vec3(0, 1, 0)), .5)*256.);\n    th += .04; // Constant thickness.\n    \n    // Divisor much be a factor of the scale (sSc) above.\n    vec2 ln = abs(mod(spir, 1./sSc) - .5/sSc) - th;\n\n    \n    \n    #ifdef DASHED\n    ln.x = smax(ln.y, -(ln.x - .01), .02); // Using the other spiral to cut out holes.\n    #else \n    ln.x = smax(ln.y, -(ln.x + .044), .015); // Closing the gaps.\n    //ln.x = ln.y; // The less interesting continuous spiral arms.\n    #endif\n    \n    // Smoothly blending in the polar caps.\n    ln.x = smin(ln.x, length(q) - .05, .1);\n      \n    // Saving the 2D dashed line (the rounded rectangle shape) object to a global\n    // to be used later.\n    gLn = ln.x;\n\n \n    // Unit sphere.\n    float sph = length(p) - 1.;\n    // Extruded dashed line distance one.\n    float d = max(ln.x, abs(sph) - .01);// + (abs(fract(oAx*64. + iTime*1.) - .5) + .1)*.01*0.\n    // Putting a frame around the dashed line.\n    float d2 = max(abs(ln.x) - .01, abs(sph) - .02);\n    \n    \n    // Object ID: Plane, extruded inner rectangle, extruded rectangle frame.\n    gOID = pln<d && pln<d2? 0. : d<d2? 1. : 2.;\n    \n    // Glow tubes.\n    lCol = vec3(0);\n    if((d2<.2 + hash31(p)*.1) && gOID>.5){\n       // Glow color. Reddish on the outside, and aqua on the inside.\n       vec3 gCol = sph>.0? glowCol1 : glowCol2;\n       \n       // Record the glow distance for this iteration. \"ln\" is just a\n       // tube running through the yellow inner rectangle in the direction\n       // of the normal.\n       lCol = gCol*clamp(-(ln.x +.01), 0., .5);\n    }\n    \n    \n    // Return the minimum distance.\n    return min(pln, min(d, d2));\n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    // Adding some jitter to the jump off point to alleviate banding.\n    float t = hash31(fract(ro/7.319 + iTime) + rd)*.1, d;\n    \n    glow = vec3(0);\n    \n    for(int i = ZERO; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        \n        // Accumulate the glow color.\n        glow += lCol;///(1. + t);\n        \n        // Note that the ray is capped (to .1). It's slower, but is necessary for the\n        // glow to work. I guess it could also help with overstepping the mark a bit.\n        t += min(d*.5, .1); //d*.5;// \n    }\n\n    return min(t, FAR);\n}\n\n\n// fb39ca4's inverse mix function.\n// Inverse mix takes a value between \"a\" and \"b\" and maps it to zero to one range.\nfloat invMix(float a, float b, float x) {\n\tx = (x - a)/(b - a);\n    return x*x; // Returning the square for darker tones... My tweak, and not correct.\n}\n\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k) {\n\t\n    // Use penumbra modifications.\n    #define PENUM\n \n\t// More would be nicer. More is always nicer, but not always affordable. :)\n    const int iter = 64; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.; // Initialize the shadow to 1., or no shadow.\n    float t = 0.;//hash31(fract(ro/7.319) + n)*.01; // Scene distance.\n    float maxD = max(length(rd), .0001); // Max light distance.\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= maxD; // Normalize.\n\t\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n\tfor (int i = ZERO; i<iter; i++) {\n \t \n\t\tfloat d = map(ro + rd*t); // Distance to the scene.\n        #ifdef PENUM\n        // This is a tweak I found in fb39ca4's Loxodrom example. It makes sense,\n        // but I'd need to investigate further. The shadows are more succint, but lighter.\n        // https://www.shadertoy.com/view/MsX3D2\n\t\tfloat penumbraDist = t/k;\n\t\tshade = min(shade, invMix(-penumbraDist, penumbraDist, d));\n\t\tt += min((d + penumbraDist)*.5, .2);\n        #else\n        // IQ's simpler calculation. If feel the shade itself is more constistant, but\n        // the shape isn't perfect. Emulating soft shadows isn't easy, if not impossible.\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        t += clamp(d, .005, .2);\n        #endif\n\t\t\n        // Early exit, and not exceeding the maximum light distance.\n        if(d<0. || t>maxD) break;\n\t}\n\t\n    #ifdef PENUM\n    // Another one of fb39ca4's additions. Penumbra stuff. :) \n    shade = max(shade, 0.)*2. - 1.;\n\treturn ((sqrt(1. - shade*shade)*shade + asin(shade)) + 3.14159265/2.)/3.14159265;\n    #else\n    return max(shade, 0.);\n    #endif\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(d>1e5) break; // Fake break.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 norm(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Pixel coordinates.\n    vec2 uv = (fragCoord  - iResolution.xy*.5)/iResolution.y;\n    \n    // Unit direction ray and ray origin.\n    vec3 rd = normalize(vec3(uv, .5));\n    vec3 ro = vec3(sin(iTime/2.)*.1, 0, -1.7);\n    \n    // The inner light. The shadow from this creates the Mobius shadow pattern.\n    // Where you place it depends on the shadow pattern you're after.\n    vec3 lp = vec3(0, 0, -.85);\n    // Outer light, just to light the spherical object a bit. Without this\n    // some things would be dark.\n    vec3 lp2 =  vec3(0, .5, -1.5);\n    \n    // Rotate the camera slightly.\n    rd.yz *= rot2(sin(iTime/2.)*.05);\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    \n    // Object ID. \n    float oID = gOID;\n    \n    // Saving the spherical texture coordinates, and 2D dashed line field.\n    vec2 sUV = gSUV;\n    float ln = gLn;\n    \n    // Scene color. Initialized to zero.\n    vec3 col = vec3(0);\n   \n    \n    if(t<FAR){\n        \n        // Surface hit point and normal.\n        vec3 p = ro + rd*t;\n        vec3 n = norm(ro);\n        \n        // Light distances.\n        float lDst = length(lp - p);\n        float lDst2 = length(lp2 - p);\n        \n        // Unit direction lights -- Inner and outer.\n        vec3 ld = (lp - p)/lDst;\n        vec3 ld2 = (lp2 - p)/lDst2;\n\n        float dif = max(dot(ld, n), 0.);\n        float dif2 = max(dot(lp2, n), 0.);\n        \n        \n        // Object color.\n        vec3 oCol;\n        \n        #ifndef DASHED\n        // If not dashed, tone the glow down a little.\n        glow *= .7;\n        #endif\n        \n        if(oID>0.){\n        \n            // Sphere object. \n            \n            if(oID == 1.){ \n            \n                // Inner face.\n            \n                // Inside and outside sphere colors.\n                if(length(p)<1.){ oCol = glowCol2 + glow/2.; }\n                else oCol = glowCol1 + glow/2.;\n            \n                // Dotted LED pattern on the face.\n                const float sc = 1./16.;\n                vec2 q = sUV + sc/2.;\n                if(mod(floor(q.y/sc), 2.)<.5) q.x += .5*sc;\n                vec2 iq = floor(q/sc) + .5;\n                q -= iq*sc;\n                \n                // Slight random colorization to each cell.\n                oCol = mix(oCol, oCol*vec3(2, .5, .5), hash21(iq + .2));\n                \n                // Cell edging and application.\n                float d = -(smax(abs(q.x), abs(q.y), .01) - .4*sc);\n                oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., 2./iResolution.y, d)); \n            \n                // Dark edges on the frame using the saved 2D rectangle distance\n                // from the distance function.\n                oCol = mix(oCol, oCol*.1, 1. - smoothstep(0., .001, abs(ln + .01) - .0025));\n              \n            }\n            else {\n            \n                // Outer frame.\n                \n                // The purple outer frames with edging.\n                oCol = vec3(3, 1, .2).yzx/2.5 + glow;\n                oCol = mix(oCol, oCol*.1, 1. - smoothstep(0., .003, abs(ln - .0075) - .0025));\n                oCol = mix(oCol, oCol*.1, 1. - smoothstep(0., .003, abs(ln + .01) - .0025));\n                \n              \n            }\n            \n            // Texturing. Not necessary here.\n            //vec3 tx = tex3D(iChannel1, vec3(sUV + .5, length(p)), n);\n            //oCol *= tx*2. + .5;\n\n\n        }\n        else {\n        \n            // Backgournd plane.\n            \n            // Dark purple.\n            oCol = vec3(1, .2, 3)/3.5;\n            \n            // Apply a repeat hexagonal dot pattern.\n            vec2 sc = vec2(1./.8660254, 1)*1./7.;\n            vec2 q = p.xy;\n            if(mod(floor(q.y/sc.y), 2.)<.5) q.x -= .5*sc.x;\n            vec2 iq = floor(q/sc) + .5;\n            q -= iq*sc;\n            \n            // Subtle random coloring from cell to cell.\n            oCol = mix(oCol, vec3(1, .3, .05)/3.5, hash21(iq + .06)*.35);\n            \n            // The dot background edges and application.\n            float d = length(q) - .4*sc.y;\n            oCol = mix(oCol*.2, oCol, 1. - smoothstep(0., 1./sc.y/iResolution.y, d));\n            //oCol = mix(oCol, oCol*.5, 1. - smoothstep(0., 1./sc.y/iResolution.y, d + .15*sc.y));\n            \n            // Background texture. Not used.\n            //vec3 tx = texture(iChannel1, p.xy/8.).xyz; tx *= tx;\n            //oCol *= tx*3. + .2;\n           \n        \n        }\n        \n        \n\n        // Shadows and ambient self shadowing.\n        float sh = softShadow(p, lp, n, 128.);\n        float ao = calcAO(p, n);\n\n        // Inner and outer light attenuation.\n        float att = 1./(1. + lDst*lDst*.05);\n        float att2 = 1./(1. + lDst2*lDst2*.05);\n        \n        // Specular lighting.\n\t    float spe = pow(max(dot(reflect(ld, n), rd ), 0.), 16.); \n\t    float spe2 = pow(max(dot(reflect(ld2, n), rd ), 0.), 16.);\n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld2); // Half vector.\n        vec3 ref = reflect(rd, n); // Surface reflection.\n        vec3 refTx = texture(iChannel0, ref).xyz; refTx *= refTx;\n        refTx = (oCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n        float spRef = pow(max(dot(hv, n), 0.), 8.); // Specular reflection.\n        float rf = oID == 0.? oCol.z*.5 : oID == 1.? oCol.x : oCol.z;\n        \n        // Adding the specular reflection and glow for the inner light.\n        oCol += spRef*refTx*rf*.25;\n        oCol += glow/1.5;         \n\n        // Combining all terms for the inner light.\n        col = oCol*(dif*sh + vec3(1, .5, .8)*spe*sh + .2)*att*ao;\n        \n        // Placing another light on the outside of the sphere. Technically, there should\n        // be another shadow calculation, but it'd doesn't have much effect, so we're\n        // saving the extra calculations.\n        oCol += spRef*refTx*rf*.25; // Add more reflection to the outside.\n        col += oCol*((dif2*.15 + .05 + glow*2.) + vec3(1, .5, .8)*spe2*2.)*att2*ao;\n        \n       \n    \n    }\n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2SWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3391, 3424, 3446, 3446, 3504], [3507, 3535, 3556, 3556, 3618], [3621, 3649, 3670, 3670, 3748], [3750, 3973, 4011, 4011, 4088], [4090, 4124, 4162, 4162, 4239], [5497, 5525, 5543, 5563, 9391], [9394, 9415, 9451, 9570, 10341], [10344, 10462, 10503, 10503, 10614], [10616, 10616, 10669, 10706, 12631], [12633, 12785, 12820, 12820, 13108], [13110, 13201, 13223, 13566, 13838], [13843, 13843, 13897, 13924, 19959]], "test": "untested"}
{"id": "csjSDD", "name": "neighbour pixels buffer: firebal", "author": "jonasfrey", "description": "this is the fundament of how game of life works,\nit looks what is the sum of the pixel values  \n", "tags": ["template"], "likes": 7, "viewed": 183, "published": 3, "date": "1670330318", "time_retrieved": "2024-07-30T16:14:38.412083", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    float n_resrat = iResolution.x /iResolution.y;\n    vec2 o_scale_kernel = vec2(\n        3., \n        10.\n    );\n\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        o_trmono = vec2(sin(iTime*0.1)*0.5, 0.0);\n        if(mod(float(iFrame), 500.) > 250.){\n            o_trmono = vec2(sin(iTime*5.)*0.2, cos(iTime*10.)*0.2);\n        }\n    }\n    vec2 o_scale = vec2(0.5);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec4 o_kernel_sum = vec4(0.0);\n    for(float n_y = 0.0; n_y < (o_scale_kernel.y); n_y+=1.){\n        for(float n_x = 0.0; n_x < (o_scale_kernel.x); n_x+=1.){\n\n            //vec2 o_speed = vec2(f_n_rand(iTime)*20.-10.,f_n_rand(iTime)*10.-5., );\n            vec2 o_speed = vec2(0.,-3.);\n            vec2 o_off1 = vec2(\n                (n_x - floor(o_scale_kernel.x/2.)),\n                (n_y - floor(o_scale_kernel.y/2.))\n            )+ o_speed;\n            vec2 o_off = vec2(\n                o_off1.x * (1./o_iResolution_scaled_floor.x),\n                o_off1.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_kernel;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        if(\n            mod(n_index, 2.) == mod(o_fragCoord_scaled_floor.y,2.)\n        ){\n            fragColor = vec4(1.);\n        }else{\n            fragColor = vec4(0.);\n        }\n    }else{\n        if(mod(float(iFrame), 2.) > 0.){\n            fragColor = o_col_last;\n        }else{\n            fragColor = vec4(0.);\n\n            if(o_kernel_sum_nor.x > 0.5){//f_n_rand(iTime)){\n                fragColor = vec4(o_kernel_sum_nor.x+0.1);\n            }else{\n                fragColor = vec4(0.0);\n            }\n            \n            float n = 0.1;\n            if(o_kernel_sum_nor.x > (1.-n)){\n             fragColor = vec4(f_n_rand(iTime)*(1.-n));\n            }\n            if(o_kernel_sum_nor.x < n){\n                fragColor = vec4(f_n_rand(iTime)*(n));\n            }\n        }\n\n        //fragColor = o_col_last;\n        //fragColor += (o_kernel_sum_nor*0.001);\n    \n    }\n    \n    float n_thresh = 0.1;\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        fragColor = vec4(sin(n_dist*6.2831*20.)*0.5+0.5);\n        fragColor = mix(o_col_last, fragColor,n_dist);\n        fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        fragColor = vec4(f_n_rand(n_dist*2.));\n    }\n    \n    //fragColor = sqrt(fragColor);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "DsjSWW", "name": "❤", "author": "slj", "description": "for hmh.", "tags": ["cineshader"], "likes": 3, "viewed": 1963, "published": 3, "date": "1670311455", "time_retrieved": "2024-07-30T16:14:39.222916", "image_code": "vec3 square(vec3 v){return v*v;}\n\nvec3 cube(vec3 v){return v*v*v;}\n\nfloat num_cube(float f){return f*f*f;}\n\nfloat heart_function(vec3 v){return num_cube(square(v).x + 2.25 * square(v).y + square(v).z - 1.0) - (square(v).x + 0.1125 * square(v).y) * cube(v).z;}\n\nfloat h(float x, float z){\n    float a = 0.0, b = 0.75, y = 0.5;\n    for (int i = 0; i < 10; i++){\n        if (heart_function(vec3(x, y, z)) <= 0.0) a = y;\n        else b = y;\n        y = (a + b) * 0.5;\n    }\n    return y;\n}\n\nvec3 nml(vec2 p){\n    vec3 v = vec3(p.x, h(p.x, p.y), p.y);\n    float a = -1.0 + dot(square(v), vec3(1, 2.25, 1));a *= a;   \n    float x = -2.0 * v.x * cube(v).z +  6.0 * v.x * a;\n    float y = -0.225 * v.y * cube(v).z + 13.5 * v.y * a;\n    float z = v.z * (-3.0 * square(v).x * v.z - 0.3375 * square(v).y * v.z + 6.0 * a);\n  \treturn normalize(vec3(x, y, z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col;\n    float t = sin(iTime * 4.0);\n    t = t * t * t * t * -0.1;\n    vec3 p = vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x),0);\n    vec3 itime_p = p * vec3(1.0 + t, 1.0 + t, 0.0) * 4.5;\n    if (heart_function(itime_p.xzy) <= 0.0){\n        vec3 n = nml(itime_p.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float rim = 1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        col = diffuse * vec3(1.0, 0, 0) + rim * vec3(0.5);\n    }\n\telse\n        col = vec3(1, 0.75, 0.8) * (1.1 - 0.25 * length(p));\n\tfragColor = vec4(col, 1.0);\n}\n/** SHADERDATA\n{\n\t\"title\": \"❤\",\n\t\"description\": \"for hmh.\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 32], [34, 34, 52, 52, 66], [68, 68, 92, 92, 106], [108, 108, 137, 137, 259], [261, 261, 287, 287, 485], [487, 487, 504, 504, 848], [850, 850, 904, 904, 1502]], "test": "untested"}
{"id": "dsBXWD", "name": "fractal moire w/mouse", "author": "timmaffett", "description": "added some simple mouse interactiive kaleidoscope action to @sleeplessmonk's nice shader - kind of fun.\nall credits to @sleeplessmonk", "tags": ["fractal", "mouse", "interactive"], "likes": 6, "viewed": 265, "published": 3, "date": "1670303337", "time_retrieved": "2024-07-30T16:14:40.554355", "image_code": "// Fork of \"fractal moire\" by sleeplessmonk. https://shadertoy.com/view/ms2SWz\n// 2022-12-06 05:03:34\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    \n// Set up coordinates\n//vec2 coord = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;  // does not compensate for screen aspect ratio\nvec2 coord = ( 2.* fragCoord - iResolution.xy ) / iResolution.y;  // no distortion adjust - thanks @FabriceNeyret2\n\n// Set up moire pattern\nfloat moire = 0.001;\nfloat t = iTime / 20.0;// * (mouse.x/5.);\nvec2 c = vec2(0.5, 0.5);\nfor (int i = 1; i < 44; i++)\n{\n    c = vec2(c.x + sin(t + c.y) * 0.2, c.y + sin(t + c.x) * 0.2);\n    moire += sin(length(c) * 1.0);//*mouse.y;\n}\nmoire = moire / 3.0;\n\n// Set up fractal geometry\nfloat f = 0.05;\nvec3 p = vec3(coord, 0.0);\nfor (int i = 0; i < 10; i++)\n{\n    f += 0.5 / length(p);\n    p = abs(p)*mouse.y / dot(p, p)*mouse.x - 0.5;\n}\n\n// Set up psychedelic colors\nvec3 color = vec3(0.0, 0.0, 0.0);\ncolor += vec3(1.0, 0.5, 0.0) * sin(f * 1.0 + moire * 5.0 + t * 1.0);\ncolor += vec3(0.0, 0.5, 1.0) * sin(f * 2.0 + moire * 10.0 + t * 2.0);\ncolor += vec3(0.5, 1.0, 0.0) * sin(f * 3.0 + moire * 15.0 + t * 3.0);\n\n// Set output color\nfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBXWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 160, 1274]], "test": "untested"}
{"id": "ddSSWD", "name": "Broken CRT", "author": "fishy", "description": "I tried to make a piece of 3D art. Mouse orbits. W/ stochastic AA, which actually gives really good results with only 2-4 samples. Locked 144 fps on rtx 3080, Firefox w/ angle. Now with dithering!", "tags": ["tv", "crt", "raymarcher", "aa"], "likes": 27, "viewed": 485, "published": 3, "date": "1670297690", "time_retrieved": "2024-07-30T16:14:41.509800", "image_code": "float hash21(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 dither(vec3 color, vec2 coord, float steps)\n{\n    vec3 reduce = floor(color*steps)/steps;\n    vec3 error = color-reduce;\n    return reduce+step(vec3(hash21(coord)), error*steps)/steps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dither = dither(texture(iChannel0, fragCoord/iResolution.xy).rgb, fragCoord, 256.);\n    fragColor = vec4(dither, 1.0);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define iTime mod(iDate.w, 50.)\n\n#define AA 2.0\n#define FOCAL_LEN 20.\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash12(float p)\n{\n    vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash21(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat shash(float x)\n{\n    return mix(hash11(floor(x)), hash11(floor(x)+1.), fract(x));\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat sharpstep(float a, float b, float x)\n{\n    return saturate((x-a)/(b-a));\n}\n\nfloat peak(float a, float b, float x)\n{\n    return saturate(1.-abs((x-b)/a));\n}\n\nfloat peak2(float a, float b, float m, float x)\n{\n    x = saturate((x-a)/(b-a));\n    return saturate(1.-abs((x-m)/mix(m, 1.-m, step(0., x-m))));\n}\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 rot(vec3 v, in vec3 k, float t) // rotates point v t radians around axis k. See https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n{\n    k = normalize(k);\n    return mix(k*dot(k,v), v, cos(t)) + cross(k, v)*sin(t);\n}\n\nstruct marchMat\n{\n    vec3 color;\n    int id;\n};\n\nstruct marchRes\n{\n    bool hit;\n    float depth;\n    vec3 pos;\n    marchMat mat;\n};\nvoid join(inout float a, float b) { a = min(a, b); }\nvoid sub(inout float a, float b) { a = max(a, -b); }\nvoid intersect(inout float a, float b) { a = max(a, b); }\n\nvoid sjoin(inout float a, float b, float k ) // by iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    a = min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvoid ssub(inout float d2, float d1, float k ) // by iq\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    d2 = mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec2 opRepLim2( in vec2 p, in float c, in vec2 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nvec3 opRepLim3( in vec3 p, in float c, in vec3 l) // by iq\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) // by iq\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n    return sdBox(p, b-r)-r;\n}\n\nvec3 planeIntersect(in vec3 ro, vec3 rd, float y, out bool hit)\n{\n    hit = sign(-rd.y) == sign(ro.y-y);\n    ro.xz = ro.xz+rd.xz*(y-ro.y)/rd.y;\n    return vec3(ro.x, y, ro.z);\n}\n\nfloat sceneDist(vec3 p, out marchMat outMat)\n{\n    p = rotX(p, -0.1);\n    float d = 1e20;\n    join(d, sdBox(p, vec3(0.3, 0.25, 0.1), 0.05)); // main body\n    sjoin(d, sdBox(p-vec3(0.0, -0.025, 0.22), vec3(0.25, 0.2, 0.2), 0.05), smoothstep(0.0, 0.2, p.z)*0.1+0.02); // the thing that sticks out the back\n    ssub(d, sdBox(p-vec3(0.0, 0.0, -0.25), vec3(0.25, 0.2, 0.2), 0.03), 0.02);\n    \n    float s0 = 1e20;\n    join(s0, sdSphere(p-vec3(0.0, 0.0, 1.4), 1.5));\n    intersect(s0, sdBox(p-vec3(0.0, 0.0, -0.25), vec3(0.28, 0.23, 0.2), 0.03));\n    outMat = marchMat(s0 > d? vec3(0.93, 0.9, 0.75) : vec3(0.25, 0.25, 0.25), int(s0 < d));\n    \n    join(d, s0);\n    \n    float s1 = 1e20;\n    \n    vec3 tp = p;\n    tp.x = abs(tp.x);\n    tp = tp - vec3(0.25, -0.025, 0.22);\n    vec2 lim = opRepLim2(tp.yz, 0.02, vec2(7,7));\n\n    join(s1, sdSphere(vec3(tp.x, lim)-vec3(0.0, 0.0, 0.00), 0.00));\n    ssub(d, s1, 0.01);\n    return d;\n}\n\nfloat sceneDist(vec3 p)\n{\n    marchMat m;\n    return sceneDist(p, m);\n}\n\nvec3 screenColor(vec2 p, float b)\n{\n    return vec3(hash21(floor(iTime*40.)*20.+floor(p.xy*150.))*0.3+0.7*((cos((p.y-iTime*0.2)*400.0)+cos((p.y+iTime*0.1)*25.0))*0.25+0.5))*b;\n}\n\nfloat planeColor(vec3 p, float b)\n{\n    float ao = 0.14/(abs(sceneDist(p)+0.2));\n    float a = peak2(-1., 0., 0.7, p.z);\n    a = smoothstep(-0.1, 1.0, pow(a, 3.))*(1.-smoothstep(0., 0.4, abs(p.x)))*0.2*b+0.1/(length(p.xz)+1.);\n    return a*(1.-ao);\n}\n\nmarchRes march(vec3 ro, vec3 rd, float margin, float maxDist, int maxIt)\n{\n    float depth = 0.0;\n    vec3 cp;\n    marchRes mres;\n    for(int i = 0; i < maxIt && depth < maxDist; i++)\n    {\n        cp = ro + depth*rd;\n        float cd = sceneDist(cp, mres.mat);\n        if(cd < margin)\n        {\n            return marchRes(true, depth, cp, mres.mat);\n        }\n        depth += cd;\n    }\n    \n    return marchRes(false, depth, ro + depth*rd, mres.mat);\n}\n\nvec3 calcNormal( in vec3 p ) // by iq\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h);\n    }\n    return normalize(n);\n}\n\nvec4 getColorAtPix(vec2 fc, vec4 m)\n{\n    vec2 uv = (fc-iResolution.xy*0.5)/iResolution.y;\n    vec2 mouse = (m.xy-iResolution.xy*0.5)/iResolution.y*step(0.01, m.z)*3.0;\n\n    vec2 cr = vec2(0.6154729, 0.7853982) - mouse.yx;\n    vec3 ro = rotY(rotX(vec3(0.1, 0.05, -2.*FOCAL_LEN), cr.x), cr.y);\n    vec3 rd = rotY(rotX(normalize(vec3(uv, FOCAL_LEN)), cr.x), cr.y);\n    \n    marchRes res = march(ro, rd, 0.001, 100.0, 512);\n    vec3 n = calcNormal(res.pos);\n    bool ph;\n    vec3 plane = planeIntersect(ro, rd, -0.25, ph);\n    float pd = distance(plane, ro);\n    float brightness = shash(floor(iTime)+smoothstep(0.0, 1.0, fract(iTime))*10.);\n    brightness = (0.6+0.4*sqrt(brightness));\n\n    float lighting = dot(max(rot(n, vec3(1,1,0)*0.707106781187, 0.96), 0.0), vec3(0.33))*0.5+0.5;\n    lighting = lighting*lighting*lighting*lighting-0.03;\n\n    vec3 screenColor = screenColor(res.pos.xy, brightness);\n\n    return sqrt(vec4(vec3(pd < res.depth && ph? vec3(planeColor(plane, brightness)):float(res.hit)*(res.mat.id == 1? screenColor : res.mat.color*lighting)), 1.));\n\n}\n\nvec4 simpleAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 2.0/AA;\n    for(float x = -1.; x < 1.; x += st) { for(float y = -1.; y < 1.; y += st)\n    {\n        res += getColorAtPix(fc + (vec2(x,y)+0.5), m);\n    }}\n    return res/(AA*AA);\n}\n\nvec4 stochasticAA(vec2 fc, vec4 m)\n{\n    vec4 res = vec4(0);\n    float st = 1.0/AA;\n    for(float x = 0.; x < 1.; x += st)\n    {\n        res += getColorAtPix(fc + (hash22(x+iTime+fc)-0.5), m);\n    }\n    return res/AA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = stochasticAA(fragCoord, iMouse);\n    fragColor = mix(col, texture(iChannel1, fragCoord/iResolution.xy), 0.5);\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 141], [143, 143, 193, 193, 334], [336, 336, 393, 393, 524]], "test": "untested"}
{"id": "ddBXWW", "name": "ChatGPT bug in Gaussian blur", "author": "starea", "description": "ChatGPT bug in Gaussian blur", "tags": ["chatgpt"], "likes": 2, "viewed": 321, "published": 3, "date": "1670288119", "time_retrieved": "2024-07-30T16:14:42.319635", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 sum = vec3(0.0);\n    vec2 offs = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n\n    sum += texture(iChannel0, uv + offs * vec2(-2, -2)).rgb * 0.0044299121055113265;\n    sum += texture(iChannel0, uv + offs * vec2(-1, -2)).rgb * 0.00895781211794;\n    sum += texture(iChannel0, uv + offs * vec2( 0, -2)).rgb * 0.0215963866053;\n    sum += texture(iChannel0, uv + offs * vec2( 1, -2)).rgb * 0.00895781211794;\n    sum += texture(iChannel0, uv + offs * vec2( 2, -2)).rgb * 0.0044299121055113265;\n\n    sum += texture(iChannel0, uv + offs * vec2(-2, -1)).rgb * 0.00895781211794;\n    sum += texture(iChannel0, uv + offs * vec2(-1, -1)).rgb * 0.0189897948556;\n    sum += texture(iChannel0, uv + offs * vec2( 0, -1)).rgb * 0.04200594931922;\n    sum += texture(iChannel0, uv + offs * vec2( 1, -1)).rgb * 0.0189897948556;\n    sum += texture(iChannel0, uv + offs * vec2( 2, -1)).rgb * 0.00895781211794;\n\n    sum += texture(iChannel0, uv + offs * vec2(-2,  0)).rgb * 0.0215963866053;\n    sum += texture(iChannel0, uv + offs * vec2(-1,  0)).rgb * 0.04200594931922;\n    sum += texture(iChannel0, uv + offs * vec2( 0,  0)).rgb * 0.0944703978506;\n    sum += texture(iChannel0, uv + offs * vec2( 1,  0)).rgb * 0.04200594931922;\n    sum += texture(iChannel0, uv + offs * vec2( 2,  0)).rgb * 0.0215963866053;\n\n    sum += texture(iChannel0, uv + offs * vec2(-2,  1)).rgb * 0.00895781211794;\n    sum += texture(iChannel0, uv + offs * vec2(-1,  1)).rgb * 0.0189897948556;\n    sum += texture(iChannel0, uv + offs * vec2( 0,  1)).rgb * 0.04200594931922;\n    sum += texture(iChannel0, uv + offs * vec2( 1, 1)).rgb * 0.0189897948556;\n    sum += texture(iChannel0, uv + offs * vec2( 2, 1)).rgb * 0.00895781211794;\n    \n    sum += texture(iChannel0, uv + offs * vec2(-2,  2)).rgb * 0.0044299121055113265;\n    sum += texture(iChannel0, uv + offs * vec2(-1,  2)).rgb * 0.00895781211794;\n    sum += texture(iChannel0, uv + offs * vec2( 0,  2)).rgb * 0.0215963866053;\n    sum += texture(iChannel0, uv + offs * vec2( 1,  2)).rgb * 0.00895781211794;\n    sum += texture(iChannel0, uv + offs * vec2( 2,  2)).rgb * 0.0044299121055113265;\n\n    fragColor = vec4(sum, 1.0);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2241]], "test": "untested"}
{"id": "ddSXWW", "name": "[ChatGPT] Draw a rainbow", "author": "starea", "description": "rainbow", "tags": ["rainbow", "chatgpt"], "likes": 1, "viewed": 231, "published": 3, "date": "1670286722", "time_retrieved": "2024-07-30T16:14:43.158393", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    // create the rainbow shape\n    float rainbow = 1.0 - length(p);\n\n    // add color\n    if (rainbow > 0.0) {\n        col = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.5, 0.0), rainbow);\n        col = mix(col, vec3(1.0, 1.0, 0.0), rainbow);\n        col = mix(col, vec3(0.0, 1.0, 0.0), rainbow); // add the green color\n        col = mix(col, vec3(0.0, 1.0, 1.0), rainbow);\n        col = mix(col, vec3(0.0, 0.0, 1.0), rainbow);\n        col = mix(col, vec3(1.0, 0.0, 1.0), rainbow);\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 685]], "test": "untested"}
{"id": "DsBXDD", "name": "Simple denoise", "author": "NinjaKoala", "description": "Simple denoising based on https://www.shadertoy.com/view/7lcyWM, which is a simplified variant of https://www.shadertoy.com/view/3dd3Wr\n\nLeft is unaltered, right is denoised.", "tags": ["2d", "filter", "denoise"], "likes": 6, "viewed": 209, "published": 3, "date": "1670284518", "time_retrieved": "2024-07-30T16:14:43.904398", "image_code": "/*\nThe idea is to use a gaussian filter, but falling off\nby the difference of the currently sampled value\nto the value in the center of the kernel instead\nof spatial distance to the center.\n\nThis leads to edges to be much better preserved.\n\nMy changes are:\n\n* Using Vogel disk sampling for calculating sample positions\n* Additionally fall of based on spatial distance\n* Rename all variables to names i like more\n*/\n\nconst float num = 32.;\nconst float radius = 5.;\nconst float sigma = .3;\nconst float sigma2 = .05;\n\nvec4 denoise(sampler2D tex, vec2 uv, float num, float radius, float sigma, float sigma2)\n{\n\tfloat weight_sum = 0.;\n\tvec4 weighted_sum = vec4(0);\n    vec2 tex_size = vec2(textureSize(tex, 0));\n\n\tfor(float i=0.; i<num; i++){\n\t\tfloat angle = 2.3999629 * i;\n        float radius_squared = i / num;\n\n\t\tvec2 pos = sqrt(radius_squared) * vec2(sin(angle),cos(angle));\n\t\tvec4 value =  texture(tex, uv + radius * pos / tex_size);\n\n\t\tvec4 value_diff = value - texture(tex, uv);\n\t\tfloat weight = exp( -dot(value_diff, value_diff) * sigma -radius_squared * sigma2);\n\n\t\tweight_sum += weight;\n\t\tweighted_sum += weight * value;\n\t}\n\n    return weighted_sum / weight_sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(uv.x < .5){\n        fragColor = texture(iChannel0, uv);\n    }\n    else{\n        fragColor = denoise(iChannel0, uv, num, radius, sigma, sigma2);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float stripe_width = .1;\nconst float noise_amplitude = 1.7;\n\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\nfloat hash(vec2 uv)\n{\n    return float(iqint3(floatBitsToUint(uv))) / float(0xffffffffu) - .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspect_ratio = vec2(iResolution.x / iResolution.y, 1);\n    float col = .5 + .5 * sign(mod(uv.x + uv.y, stripe_width) - stripe_width * .5);\n    col *= step(distance(uv * aspect_ratio, vec2(.5) * aspect_ratio) - .2, .2);\n    col += noise_amplitude * hash(uv + iTime);\n    fragColor = vec4(col);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 515, 605, 605, 1170], [1172, 1172, 1229, 1229, 1433]], "test": "untested"}
{"id": "ms2XW1", "name": "Circle of Fifths (Sound)", "author": "MysteryPancake", "description": "An experiment with fifths and transposition :) I haven't slept for 7 hours", "tags": ["sound", "music", "circle", "audio", "piano", "piano", "kick", "jazz", "gpusound", "drum", "epiano", "fifths"], "likes": 19, "viewed": 410, "published": 3, "date": "1670282325", "time_retrieved": "2024-07-30T16:14:44.670350", "image_code": "// From https://www.shadertoy.com/view/ltfSRr\nfloat message(vec2 uv) {\n\tuv -= vec2(1.0, 10.0);\n\tif ((uv.x < 0.0) || (uv.x >= 32.0) || (uv.y < 0.0) || (uv.y >= 3.0)) return -1.0;\n\tint i = 1, bit = int(exp2(floor(32.0 - uv.x)));\n\tif (int(uv.y) == 2) i = 928473456 / bit;\n\tif (int(uv.y) == 1) i = 626348112 / bit;\n\tif (int(uv.y) == 0) i = 1735745872 / bit;\n\treturn float(i - 2 * (i / 2));\n}\n\n// From https://www.shadertoy.com/view/4sBfRd\nvec4 char(vec2 p, int c) {\n    if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) {\n        return vec4(0.0);\n    }\n    vec2 scaled = p / 16.0;\n\treturn textureGrad(iChannel0, scaled + fract(vec2(c, 15 - c / 16) / 16.0), dFdx(scaled), dFdy(scaled));\n}\n\n// Modified from https://iquilezles.org/articles/distfunctions2d/\nfloat line(vec2 p, vec2 dir) {\n    return length(p - dir * max(dot(p, dir) / dot(dir, dir), 0.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iResolution.y < 2000.0) {\n\t\tfloat c = message(fragCoord / 8.0);\n\t\tif (c >= 0.0){\n\t\t\tfragColor = vec4(c);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    // Center UV coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Start with white background\n    fragColor = vec4(1.0);\n    float id = floor(iTime / SPB / 4.0);\n    \n    // Draw each note\n    for (int i = 0; i < 12; i++) {\n        float phase = float(i) / 12.0 * TAU;\n        float radius = 5.0 - sin(PI_4 * (float(i % 2) + iTime) / SPB) * 0.25;\n        if (id >= 16.0) {\n            radius -= mod(iTime, SPB * 2.0);\n        }\n        vec2 offset = vec2(cos(phase), sin(phase)) * radius;\n        \n        // Draw lines around circle\n        vec2 dir = vec2(cos(phase + PI_4), sin(phase + PI_4));\n        fragColor *= mix(smoothstep(0.0, length(uv) * 0.03, line(uv, dir)), 1.0, 0.7);\n        \n        // Draw note letters\n        int charIndex = 65 + (5 + i) * 3 % 7;\n        fragColor -= char(0.5 + uv * 14.0 + offset, charIndex).r;\n        \n        // Draw sharp symbols\n        if (i <= 6) {\n            fragColor -= char(uv * 14.0 + offset, 15).r;\n        }\n    }\n    \n    // Draw vignette\n    fragColor *= smoothstep(0.0, 0.1, 0.5 - length(uv));\n    \n    // Draw red highlight\n    vec4 red = vec4(1.0, 0.5 * length(uv), 0.0, 1.0);\n    float phase = id * PI / 6.0;\n    vec2 angle = vec2(sin(phase), cos(phase));\n    float factor = smoothstep(0.0, 0.01, line(uv, angle) - length(uv) * 0.25);\n    fragColor += red * (1.0 - factor);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define msin(x,m) sin(TAU * (x) + (m))\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2((note - 69.0) / 12.0);\n}\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// From https://www.shadertoy.com/view/3scfD2\nvec2 epiano(float freq, float t, float nuance) {\n    vec2 f0 = vec2(freq * 0.998, freq * 1.002);\n    vec2 glass = msin((f0 + 3.0) * t, msin(14.0 * f0 * t, 0.0) * exp(-30.0 * t) * nuance) * exp(-4.0 * t) * nuance;\n    glass = sin(glass);\n    vec2 body = msin(f0 * t, msin(f0 * t, 0.0) * exp(-0.5 * t) * nuance * pow(440.0 / f0.x, 0.5)) * exp(-t) * nuance;\n    return (glass + body) * smoothstep(0.0, 0.001, t) * 0.1;\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash(float(si)), hash(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float Q) {\n    return sin(TAU * freq * fract(time)) * noise(time * Q);\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time) {\n    const float df = 512.0, dftime = 0.01, freq = 60.0;\n    float phase = TAU * (freq * time - df * dftime * exp(-time / dftime));\n    float body = sin(phase) * smoothstep(0.3, 0.0, time) * 1.5;\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.007, 0.0, time);\n    return body + click;\n}\n\nvec2 noiseHit(float time, float fade) {\n\treturn (vec2(hash(time * 2048.0), hash(time * 1024.0)) * 2.0 - 1.0) * exp(-fade * time);\n}\n\n// Notes are auto-transposed using modulo, so they wrap to the same octave\nvec2 chord(float time, float offset, float minor, float funk, float hats) {\n\n    // Bass\n    const float bass = 57.0;\n    vec2 result = epiano(noteFreq(bass + mod(offset, 12.0) - 24.0), time, 2.0);\n    \n    // Root (bass plus 2 octaves)\n    result += epiano(noteFreq(bass + mod(offset, 12.0)), time - SPB * 0.5, 1.25);\n    // Third\n    result += epiano(noteFreq(bass + mod(offset + 4.0 - minor, 12.0)), time - SPB * funk, 1.5);\n    // Fifth\n    result += epiano(noteFreq(bass + mod(offset + 7.0, 12.0)), time - SPB * 0.5, 1.25);\n    // Seventh\n    result += epiano(noteFreq(bass + mod(offset + 11.0 - minor, 12.0)), time - SPB * funk, 1.5);\n    // Ninth\n    result += epiano(noteFreq(bass + mod(offset + 14.0, 12.0)), time - SPB * funk, 1.5);\n    \n    // Hi-hats\n    result += noiseHit(mod(time, SPB), 30.0) * hats;\n    return result;\n}\n\nvec2 mainSound(int samp, float time) {\n\n    // Unique identifier for current beat\n    float id = floor(time / SPB / 4.0);\n    // Circle of fifths, move up a fifth each step (7 MIDI notes)\n    float offset = id * 7.0;\n    // Play a minor chord for every 3 major chords\n    float minor = mod(id, 4.0) >= 3.0 ? 1.0 : 0.0;\n    // Funkier timing every 4 chords\n    float funk = mod(id, 8.0) >= 4.0 ? 1.5 : 1.0;\n    // Add hi-hats after a bit\n    float hats = id >= 8.0 ? 0.08 : 0.0;\n    \n    float t = mod(time, SPB * 4.0);\n    vec2 result = chord(t, offset, minor, funk, hats);\n    // Two tap ping-pong delay\n    result += vec2(0.5, 0.2) * chord(t - SPB * 0.5, offset, minor, funk, hats);\n    result += vec2(0.05, 0.1) * chord(t - SPB, offset, minor, funk, hats);\n    \n    // Kick drum\n    if (id >= 16.0) {\n        result += kick(mod(time, SPB * 2.0)) * 0.45;\n    }\n    return result;\n}", "sound_inputs": [], "common_code": "const float PI = 3.1415926;\nconst float PI_4 = PI * 0.25;\nconst float TAU = 6.28318530;\n\nconst float BPM = 200.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2XW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 70, 70, 387], [389, 435, 461, 461, 688], [690, 756, 786, 786, 856]], "test": "untested"}
{"id": "cdSSWW", "name": "Different sampling method", "author": "fishy", "description": "By @oneshade. All I did was implement @Poisson's sampling method (instead of the seed being set per-pixel, it's set per-frame)\nLeft=per-frame, center=alternating (suggested by @ENDESGA, right=per-pixel. At few samples it gives a nice paint stylized effect", "tags": ["globalillumination", "pathtracer", "stochastic"], "likes": 18, "viewed": 695, "published": 3, "date": "1670270164", "time_retrieved": "2024-07-30T16:14:45.563961", "image_code": "// Based on https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n// and https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy\n\n// https://64.github.io/tonemapping/#uncharted-2\nvec3 Uncharted2(in vec3 color) {\n    color *= 2.0;\n\n    float A = 0.15, B = 0.50, C = 0.10;\n    float D = 0.20, E = 0.02, F = 0.30;\n    color = (((A * color + C * B) * color + D * E) / ((A * color + B) * color + D * F)) - E / F;\n\n    //float whiteMax = 4.0;\n    //color /= (((A * whiteMax + C * B) * whiteMax + D * E) / ((A * whiteMax + B) * whiteMax + D * F)) - E / F;\n    color *= 1.9335;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.rgb /= fragColor.a; // Average\n    fragColor.rgb = Uncharted2(fragColor.rgb); // Tonemap\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545)); // Gamma correct\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Settings\n#define MAX_BOUNCES 16\n#define EPSILON 0.001\n\n// Constants\n#define TAU 6.28318530718\n#define PI 3.14159265359\n#define RHO 1.57079632679\n\n// Structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct HitInfo {\n    float hitDist;\n    vec3 hitPos;\n    vec3 surfNor;\n    vec2 surfUv;\n    int objId;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float percentSpecular;\n    float roughness;\n    vec3 specularColor;\n};\n\n// RNG utilities\nuint wangHash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat rand01(inout uint state) {\n    return float(wangHash(state)) / 4294967296.0;\n}\n \nvec3 randUnitVec(inout uint state) {\n    float z = rand01(state) * 2.0 - 1.0;\n    float a = rand01(state) * TAU;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// Camera basis matrix\nmat3 getCameraBasis(in vec2 an) {\n    vec2 c = cos(an), s = sin(an);\n    return mat3(       c.x, 0.0,        s.x,  // Right\n                s.x * -s.y, c.y,  c.x * s.y,  // Up\n                 s.x * c.y, s.y, -c.x * c.y); // Forward\n}\n\n// Update with closest intersection\nvoid addRayHit(inout HitInfo curHit, in HitInfo newHit) {\n    if (newHit.hitDist > 0.0) {\n        if (curHit.hitDist < 0.0) curHit = newHit;\n        else if (newHit.hitDist < curHit.hitDist) curHit = newHit;\n    }\n}\n\n// Transformations\nmat4 Translate(in vec3 t) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                t.x, t.y, t.z, 1.0);\n}\n\nmat4 Scale(in vec3 s) {\n    return mat4(s.x, 0.0, 0.0, 0.0,\n                0.0, s.y, 0.0, 0.0,\n                0.0, 0.0, s.z, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateX(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0,  co,  si, 0.0,\n                0.0, -si,  co, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateY(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4( co, 0.0,  si, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                -si, 0.0,  co, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 RotateZ(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat4( co,  si, 0.0, 0.0,\n                -si,  co, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// Primitive intersectors\n// Ray vs. Plane intersection\nHitInfo planeIsect(in Ray ray, in mat4 mat, in int objId) {\n    mat4 matInv = inverse(mat);\n    ray.pos = (matInv * vec4(ray.pos, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float hitDist = -ray.pos.y / ray.dir.y;\n    vec3 hitPos = ray.pos + ray.dir * hitDist;\n    vec3 surfNor = transpose(matInv)[1].xyz; // To worldspace\n    vec2 surfUv = hitPos.xz;\n    hitPos = (mat * vec4(hitPos, 1.0)).xyz; // To worldspace\n\n    return HitInfo(hitDist, hitPos, surfNor, surfUv, objId);\n}\n\n// Ray vs. Sphere intersection\nHitInfo sphereIsect(in Ray ray, in mat4 mat, in int objId) {\n    mat4 matInv = inverse(mat);\n    ray.pos = (matInv * vec4(ray.pos, 1.0)).xyz;\n    ray.dir = (matInv * vec4(ray.dir, 0.0)).xyz;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.pos, ray.dir);\n    float c = dot(ray.pos, ray.pos) - 1.0;\n\n    float dis = b * b - a * c;\n    if (dis < 0.0) return HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    float hitDist = (-b - sign(c) * sqrt(dis)) / a;\n    vec3 hitPos = ray.pos + ray.dir * hitDist;\n    vec3 surfNor = (transpose(matInv) * vec4(hitPos, 0.0)).xyz; // Convert normal to worldspace\n    vec2 surfUv = vec2(atan(hitPos.z, hitPos.x), atan(hitPos.y, length(hitPos.xz)));\n    hitPos = (mat * vec4(hitPos, 1.0)).xyz; // Convert position to worldspace\n\n    return HitInfo(hitDist, hitPos, surfNor, surfUv, objId);\n}", "buffer_a_code": "HitInfo traceRay(in Ray ray) {\n    HitInfo hit = HitInfo(-1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    // Ground plane\n    addRayHit(hit, planeIsect(ray, mat4(1.0), 1));\n\n    // Big sphere light\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 1.0, -5.0)), 2));\n\n    // Silver metallic spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-2.0, 0.5, -5.0)) * Scale(vec3(0.5)), 3));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(2.0, 0.5, -5.0)) * Scale(vec3(0.5)), 3));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.15, -4.05)) * Scale(vec3(0.15)), 3));\n\n    // Green metallic spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-2.0, 0.4, -3.0)) * Scale(vec3(0.4)), 4));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-1.0, 0.4, -3.0)) * Scale(vec3(0.4)), 5));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.4, -3.0)) * Scale(vec3(0.4)), 6));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.0, 0.4, -3.0)) * Scale(vec3(0.4)), 7));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(2.0, 0.4, -3.0)) * Scale(vec3(0.4)), 8));\n\n    // Small sphere lights\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-2.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-1.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(0.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(1.0, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(2.1, 0.2, -2.25)) * Scale(vec3(0.2)), 2));\n\n    // Large opaque glass spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.0, 0.75, -4.0)) * Scale(vec3(0.75)), 9));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-3.0, 0.75, -4.0)) * Scale(vec3(0.75)), 9));\n\n    // Sphere lights over the opaque glass spheres\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(3.0, 1.9, -4.0)) * Scale(vec3(0.2)), 2));\n    addRayHit(hit, sphereIsect(ray, Translate(vec3(-3.0, 1.9, -4.0)) * Scale(vec3(0.2)), 2));\n\n    return hit;\n}\n\nMaterial getMaterial(in vec2 surfUv, in int objId) {\n    Material mtl = Material(vec3(0.0), vec3(0.0), 0.0, 0.0, vec3(0.0));\n\n    // Ground plane\n    if (objId == 1) mtl = Material(vec3(1.0, 0.4, 0.2), vec3(0.0), 0.5, 0.7, vec3(1.0, 0.4, 0.2));\n\n    // Big sphere light\n    if (objId == 2) mtl = Material(vec3(0.0), vec3(2.0), 0.0, 0.0, vec3(0.0));\n\n    // Silver metallic spheres\n    if (objId == 3) mtl = Material(vec3(0.0), vec3(0.0), 1.0, 0.0, vec3(1.0));\n\n    // Green metallic spheres with increasing roughness\n    if (objId == 4) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.0, vec3(0.0, 1.0, 0.0));\n    if (objId == 5) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.25, vec3(0.0, 1.0, 0.0));\n    if (objId == 6) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.5, vec3(0.0, 1.0, 0.0));\n    if (objId == 7) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 0.75, vec3(0.0, 1.0, 0.0));\n    if (objId == 8) mtl = Material(vec3(0.0, 1.0, 0.0), vec3(0.0), 1.0, 1.0, vec3(0.0, 1.0, 0.0));\n\n    // Large opaque glass spheres\n    if (objId == 9) mtl = Material(vec3(1.0), vec3(0.0), 0.5, 0.0, vec3(1.0));\n\n    return mtl;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    float fc = fragCoord.x - (iMouse.x==0.? 0. : (iMouse.x-iResolution.x*0.5));\n    if((iFrame % 2 == 0) && (fc > iResolution.x*0.33) && (fc < iResolution.x*0.66)) rngState = uint(iFrame);\n    if(fc < iResolution.x*0.33) rngState = uint(iFrame);\n\n\n\n    // Load last frame\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // Jitter UVs for antialiasing\n    fragCoord += vec2(rand01(rngState), rand01(rngState));\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera ray\n    mat3 cam = getCameraBasis(vec2(0.0, -0.8));\n    Ray ray = Ray(vec3(0.0, 4.0, -0.5), normalize(cam * vec3(uv, 1.0)));\n\n    // Pathtrace!\n    vec3 acc = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    for (int bounce=0; bounce < MAX_BOUNCES; bounce++) {\n        HitInfo hit = traceRay(ray);\n        if (hit.hitDist < 0.0) break;\n        Material mtl = getMaterial(hit.surfUv, hit.objId);\n\n        hit.surfNor = normalize(hit.surfNor); // Normalize the surface normal as a final step\n        hit.surfNor *= sign(dot(hit.surfNor, -ray.dir)); // Flip towards the camera\n\n        // Accumulate bounce light\n        acc += mtl.emissive * throughput;\n\n        // Step to the surface\n        ray.pos = hit.hitPos + hit.surfNor * EPSILON;\n\n        // Choose specular reflection with chance percentSpecular\n        if (rand01(rngState) < mtl.percentSpecular) {\n            vec3 diffuseRay = normalize(hit.surfNor + randUnitVec(rngState));\n            vec3 specularRay = reflect(ray.dir, hit.surfNor);\n            ray.dir = normalize(mix(specularRay, diffuseRay, mtl.roughness * mtl.roughness));\n            throughput *= mtl.specularColor;\n        }\n\n        // Reflect diffusely otherwise\n        else {\n            ray.dir = normalize(hit.surfNor + randUnitVec(rngState));\n            throughput *= mtl.albedo;\n        }\n\n        // Russian roulette optimization\n        float stopChance = max(throughput.r, max(throughput.g, throughput.b));\n        if (rand01(rngState) > stopChance) break;\n        throughput /= stopChance;\n    }\n\n    // Accumulate frame\n        if (iMouse.z > 0.0) {\n        fragColor = vec4(0.0);    \n    }\n    fragColor.rgb += acc;\n    fragColor.a += 1.0;\n\n\n    // Restart on mouse down\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 265, 297, 297, 676], [678, 678, 733, 733, 973]], "test": "untested"}
{"id": "Ds2XRm", "name": "Codevember #15 Vasarely", "author": "Etidou", "description": "Day 15 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "vasarely", "codevember", "reproduction"], "likes": 3, "viewed": 169, "published": 3, "date": "1670266790", "time_retrieved": "2024-07-30T16:14:46.576254", "image_code": "// Inspiration: https://www.shadertoy.com/view/wlsyDl\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\n#define DIVS 19.0\n#define CIRCLES 0.0\n#define rot(a)   mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n\n\n// @author sam hocevar\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)  / iResolution.y;\n\n    float c = 0.;\n    \n    // timer [0; 1]\n    float t = iTime / 60.;\n    if (t > .5) {\n        uv*= rot((t-.5) * 10.);\n    }\n    t = min(1., t);\n    \n    \n    // the grid\n    vec2 dv = uv * DIVS + .5; // we add .5 for odd centering\n    vec2 gd = fract(dv) - .5;\n    vec2 id = floor(dv);\n    \n    // checkboard\n    float dm = mod(id.x + id.y, 2.);\n    \n    // hue\n    float hue = mix(0.22, dm, 0.35);\n    \n    // manhattan distance\n    float mand = sin(((abs(id.x) + abs(id.y)) / DIVS * 2. - iTime*(0.1+t*.4)) * 1.5) * .5;\n    \n    \n    vec3 color = vec3(hue, .025, mix(mand, 0.8 - mand, dm));\n    \n    \n    // the border, source of all motion\n    float bd = smoothstep(0.35, 0.5, abs(gd.x));\n    bd = max(bd, smoothstep(0.35, 0.5, abs(gd.y)));\n    float a = atan(gd.y, gd.x)*2. + cos(iTime * .5) * (t*10.+3.) + (mod(id.x, 2.)*4.-2.) * cos(iTime);\n    a = mod(a, 4.*PI);\n    color = mix(color, color*pow((cos(a)*.5+.5), 2.), bd);\n    \n    \n    // adding circles\n    float cir = smoothstep(0.3, 0.20, length(gd));\n    color-= cir * CIRCLES;\n\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2XRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 364, 386, 386, 555], [559, 559, 616, 616, 1763]], "test": "untested"}
{"id": "cs2XRm", "name": "Codevember #14 Vasarely", "author": "Etidou", "description": "Day 14 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "vasarely", "codevember", "reproduction"], "likes": 4, "viewed": 145, "published": 3, "date": "1670266787", "time_retrieved": "2024-07-30T16:14:47.471860", "image_code": "#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nconst float grid = 12.;\n#define pixel_width 1.5/iResolution.y*grid\n#define slowt iTime/3.\n\nfloat easeInOut(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat stroke(float d, float size, float width) {\n\treturn smoothstep(pixel_width,0.0,abs(d-size)-width/2.);\n}\n\nfloat fill(float d, float size) {\n\treturn smoothstep(pixel_width,0.0,d-size);\n}\n\nfloat circleSDF(vec2 uv) {\n\treturn length(uv);\n}\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(0.5+a/v)*v-a)*r;\n    return min( abs(final/s.x),\n                abs(final/s.y));\n}\n\nvec2 rotate(vec2 _uv, float _angle){\n    _uv =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _uv + 0.5;\n    return _uv;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    uv *= grid;\n    uv.y += mod(grid,2.)* .25;\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv)*3.-2.;\n    \n    float a = floor(random(id*floor(slowt))*8.)/8.;\n    float next_a = floor(random(id*(floor(slowt)+1.))*8.)/8.;\n    float angle = mix(a,next_a,easeInOut(linearstep(.5,1.,fract(slowt))));\n    gv = rotate(gv+0.5,(angle-0.2)*TAU);\n    \n    float col = fill(polySDFScale(gv, vec2(2.9), 6), .9);\n    col = min(col,smoothstep(pixel_width,0.,gv.x-0.5));\n    col = min(col, step(uv.x,grid-1.));\n    col = min(col, 1.-step(uv.x,-grid+1.));\n\n\n    vec3 c2 = vec3(0.015, 0.0235, 0.735);\n    vec3 gradient = mix(\n        vec3(col),\n        c2,\n        1.25\n    );\n    \n    // Output to screen\n    fragColor = vec4(gradient,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs2XRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 296, 296, 426], [428, 428, 479, 479, 538], [540, 540, 588, 588, 648], [650, 650, 683, 683, 729], [731, 731, 757, 757, 779], [781, 781, 825, 825, 1044], [1046, 1046, 1082, 1082, 1196], [1198, 1198, 1222, 1222, 1294], [1296, 1296, 1353, 1353, 2143]], "test": "untested"}
{"id": "Dd2XRm", "name": "Codevember #13 Vasarely", "author": "Etidou", "description": "Day 13 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "vasarely", "codevember", "reproduction"], "likes": 3, "viewed": 137, "published": 3, "date": "1670266782", "time_retrieved": "2024-07-30T16:14:48.489140", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nconst float grid = 12.;\n#define pixel_width 1.5/iResolution.y*grid\n#define slowt iTime/3.\n\nfloat easeInOut(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat stroke(float d, float size, float width) {\n\treturn smoothstep(pixel_width,0.0,abs(d-size)-width/2.);\n}\n\nfloat fill(float d, float size) {\n\treturn smoothstep(pixel_width,0.0,d-size);\n}\n\nfloat circleSDF(vec2 uv) {\n\treturn length(uv);\n}\n\nfloat polySDFScale(vec2 uv, vec2 s, int V) {\n    uv = uv*2.-1.;\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(V);\n    float final = cos(floor(0.5+a/v)*v-a)*r;\n    return min( abs(final/s.x),\n                abs(final/s.y));\n}\n\nvec2 rotate(vec2 _uv, float _angle){\n    _uv =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _uv + 0.5;\n    return _uv;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    uv *= grid;\n    uv.y += mod(grid,2.)* .25;\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv)*3.-2.;\n    \n    float a = floor(random(id*floor(slowt))*8.)/8.;\n    float next_a = floor(random(id*(floor(slowt)+1.))*8.)/8.;\n    float angle = mix(a,next_a,easeInOut(linearstep(.5,1.,fract(slowt))));\n    gv = rotate(gv+0.5,(angle-0.2)*TAU);\n    \n    float col = fill(polySDFScale(gv, vec2(1.4), 3), .9);\n    col = min(col,smoothstep(pixel_width,0.,gv.x-1.5));\n    col = min(col, step(uv.x,grid-1.));\n    col = min(col, 1.-step(uv.x,-grid+1.));\n\n\n    vec3 c2 = vec3(0.4, 0.0235, 0.0235);\n    vec3 gradient = mix(\n        vec3(col),\n        c2,\n        1.25\n    );\n    \n    // Output to screen\n    fragColor = vec4(gradient,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2XRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[316, 316, 342, 342, 472], [474, 474, 525, 525, 584], [586, 586, 634, 634, 694], [696, 696, 729, 729, 775], [777, 777, 803, 803, 825], [827, 827, 871, 871, 1090], [1092, 1092, 1128, 1128, 1242], [1244, 1244, 1268, 1268, 1340], [1342, 1342, 1399, 1399, 2188]], "test": "untested"}
{"id": "cd2XRm", "name": "Codevember #12 Vasarely", "author": "Etidou", "description": "Day 12 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "vasarely", "codevember", "reproduction"], "likes": 2, "viewed": 148, "published": 3, "date": "1670266777", "time_retrieved": "2024-07-30T16:14:49.498441", "image_code": "// Inspiration: https://www.shadertoy.com/view/WlX3Rl\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nconst float grid = 9.;\n#define pixel_width 2./iResolution.y*grid\n#define slowt iTime/5.\n\nfloat easeInOut(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nvec2 rotate(vec2 _uv, float _angle){\n    _uv =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _uv;\n    return _uv;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    uv *= grid;\n    uv.y += mod(grid,20.)* .5;\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    float a = floor(random(id*floor(slowt))*4.)/4.;\n    float next_a = floor(random(id*(floor(slowt)+1.))*4.)/4.;\n    float angle = mix(a,next_a,easeInOut(linearstep(.5,1.,fract(slowt))));\n    gv = rotate(gv,angle*TAU);\n\n    vec3 color = vec3(0.);\n    vec3 c1 = vec3(1.0, 0.9333, 0.0157);\n    vec3 c2 = vec3(0.4, 0.0235, 0.0235);\n\n    float col = smoothstep(pixel_width,0.,.5-gv.y);\n\n    vec3 gradient = mix(\n        vec3(col),\n        c2,\n        1.25\n    );\n    \n    fragColor = vec4(vec3(col),1.0);\n\n    fragColor = vec4(gradient,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2XRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 349, 349, 479], [481, 481, 532, 532, 591], [593, 593, 629, 629, 737], [739, 739, 763, 763, 835], [837, 837, 894, 894, 1599]], "test": "untested"}
{"id": "DsjXRm", "name": "Codevember #11 Optical Illusion", "author": "Etidou", "description": "Day 11 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["optical", "illusion", "codevember"], "likes": 7, "viewed": 144, "published": 3, "date": "1670266772", "time_retrieved": "2024-07-30T16:14:50.347172", "image_code": "#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n\nvec2 rotate2D( in vec2 uv, in float alpha )\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    uv =  mat2(c, -s, s, c) * (uv - 0.5) + 0.5;\n    return uv;\n}\n\nvec2 tile(in vec2 uv, in float zoom)\n{\n    return fract(uv * zoom);\n}\n\nfloat box( in vec2 uv, in vec2 size, in float smoothEdges )\n{\n  size = 0.5 - size * 0.5;\n  vec2 aa = vec2( smoothEdges*0.5 );\n  vec2 st = smoothstep( size, size+aa, uv)\n          * smoothstep( size, size+aa, 1.0 - uv);    \n  return st.x * st.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 invRes = 1.0 / iResolution.xy;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    float shiftAngle = PI * 0.25;\n    float angle = mod( 1.0 * iTime, PI) + shiftAngle;\n    float doShift = step(angle, PI-shiftAngle);\n    vec2 shiftOffset = vec2(-0.5, 0.5) / 5.0;\n    \n    uv += doShift * shiftOffset;\n    uv = tile(uv, 5.0);\n    uv = rotate2D(uv, angle);\n\n    float ic = abs(box(uv, vec2(0.71), 0.012) - doShift);\n    fragColor = vec4(vec3(0.85*ic , 0.1, 0.55), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 110, 110, 227], [229, 229, 267, 267, 298], [300, 300, 361, 361, 546], [548, 548, 605, 605, 1110]], "test": "untested"}
{"id": "ddjSW1", "name": "Warping stuff (sound)", "author": "me_123", "description": "2d noise warping on a plain in the middle of nowhere. ", "tags": ["2d", "3d", "noise", "reflection", "sound", "music", "warping", "art"], "likes": 10, "viewed": 377, "published": 3, "date": "1670261910", "time_retrieved": "2024-07-30T16:14:51.137060", "image_code": "const bool flatt = false;\nconst int msaa = 5;\nfloat plane(in vec3 ro, in vec3 rd, in vec2 s, in int ax) {\n    float d = -ro[ax]/rd[ax];\n    if (d < 0.0) return 1000.;\n    vec3 p = ro+rd*d;\n    if (p[(ax+2)%3] > s.x || p[(ax+2)%3] < -s.x || p[(ax+1)%3] > s.y || p[(ax+1)%3] < -s.y) return 1000.;\n    return d;\n}\nfloat hash(vec3 p)\n{\n\tvec3 p3 = fract(p * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract(p3.xy*p3.z+p3.z*p3.z*10.).x;\n}\nvec2 hash2(vec3 p)\n{\n\tvec3 p3 = fract(p * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract(p3.xy*p3.z+p3.z*p3.z*10.).xy;\n}\nfloat noise(in vec3 p) {\n    vec3 f = fract(p);\n    f = f*f*(3.-2.*f);\n    vec3 ff = floor(p);\n    return mix(mix(mix(hash(ff), hash(ff+vec3(1, 0, 0)), f.x),\n               mix(hash(ff+vec3(0, 1, 0)), hash(ff+vec3(1, 1, 0)), f.x), f.y),\n               mix(mix(hash(ff+vec3(0, 0, 1)), hash(ff+vec3(1, 0, 1)), f.x),\n               mix(hash(ff+vec3(0, 1, 1)), hash(ff+vec3(1, 1, 1)), f.x), f.y), f.z);\n}\nfloat fn(in vec3 p) {\n    return (noise(p*0.5)+noise(p)*0.5+noise(p*2.0)*0.25)*2.0;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    float r = iResolution.x/iResolution.y;\n    float d = plane(ro, rd, vec2(r, 1.0), 1);\n    float k = -(ro.z+1.0)/rd.z;\n    if (k < 0.0) k = 1000.;\n    d = min(d, k);\n    vec3 p = ro+rd*d;\n    if (d > 100.) return vec3(0.01/(rd.z+0.01)*vec3(1.0, 0.5, 0.3));\n    if (p.z > -0.9999) {\n        vec3 t = texture(iChannel0, (p.xz/vec2(r, 1)+1.0)*0.5).xyz;\n        return vec3(t);\n    }\n    else if (p.z < -0.0) {\n        vec3 roo = p;\n        vec3 pp = vec3(p.xy*20., iTime*2.0);\n        float h = fn(pp);\n        vec3 n = normalize(vec3((h-fn(pp-vec3(0.01, 0, 0)))*100., (h-fn(pp-vec3(0, 0.01, 0)))*100., 10.0));\n        vec3 rdd = reflect(rd,n);\n        d = plane(roo, rdd, vec2(r, 1.0), 1);\n        if (d >100.) return vec3(0.01/((rdd.z)+0.001)*vec3(1.0, 0.5, 0.3));\n        vec3 p = roo+rdd*d;\n        if (p.y > -0.000001) return 0.5*vec3(texture(iChannel0, (p.xz/vec2(r, 1)+1.0)*0.5).xyz);\n        return vec3(roo+rdd*d);\n    }\n    return vec3(sin(ro+rd*d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    if (flatt) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    }\n    else {\n        for (int i = 0; i < msaa; i += 1) {\n            vec2 uv = ((fragCoord.xy+(hash2(vec3(fragCoord.xy*0.1, i+iFrame*msaa))-0.5))/iResolution.xy)-0.5;\n            uv *= vec2((iResolution.x/iResolution.y)*2.0, 2.0);\n            vec3 ro = mix(vec3(0, -2.0, 0), vec3(sin(iTime*0.5)*0.05, -0.5, -(sin(iTime)*0.5)*0.0625)*5.0, clamp(iTime*0.1-0.5, 0.0, 1.0));\n            vec3 rd = normalize(vec3(uv.x, 2.0, uv.y));\n            fragColor += vec4(clamp(getColor(ro, rd), 0.0, 1.0), 0);\n        }\n        fragColor /= float(msaa);\n    }\n    fragColor.xyz = 1.-exp(-fragColor.xyz*3.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 hash33(vec3 p3)\n{ //by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec2 hash(vec2 p)\n{\n\tvec3 p3 = fract(p.xyy * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract(p3.xy*p3.z);//fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec2 noise(in vec2 p) {\n    vec2 f = fract(p);\n    vec2 ff = floor(p);\n    return mix(mix(hash(ff), hash(ff+vec2(1, 0)), f.x), mix(hash(ff+vec2(0, 1)), hash(ff+vec2(1, 1)), f.x), f.y);\n}\nconst float PI = 3.14159265359*4.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = float(iFrame)*0.02;\n    vec2 uv = (fragCoord.xy/iResolution.xy)-0.5;\n    float r = 0.02;//(length(uv)*10.)*0.02;//0.025*sin(t*2.0);\n    uv *= mat2(cos(r), -sin(r), sin(r), cos(r));\n    uv += 0.01*(noise(uv*20.+t*5.0)-0.5);\n    uv *= 1.0-(0.1-0.1*length(uv))*0.5;\n    fragColor = texture(iChannel0, uv+0.5+(0.5-hash33(vec3(fragCoord.xy, t)).xy)*0.002)+vec4(0, 0, 0, 1);//vec4(0.0,0.0,1.0,1.0);\n    vec3 h = hash33(vec3(fragCoord.xy, t));\n    if (fract((t/PI)+1.0) < 0.1) {\n        fragColor.xyz *= 0.99;//1.-exp(-h*5.);\n        if (length(uv) < (0.05-fract((t/PI)+1.0)) || iFrame == 0) {\n            fragColor.xyz += 0.4*hash33(vec3(t+10.));\n        }\n    }\n    if (h.x < 0.005) {\n        fragColor = vec4(pow(hash33(vec3(fragCoord.xy, t+100.0))*2.0, vec3(6.)), 0)*0.1;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 old = texelFetch(iChannel1, ivec2(fragCoord.xy), 0).xyz;\n    vec2 uv = (fragCoord.xy/iResolution.xy)-0.5;\n    vec4 t = texture(iChannel0, uv+0.5);\n    float f = pow(cos(iTime*0.5)*0.5+0.5, 10.)*0.25+0.5;\n    fragColor.xyz = old*f+(1.-f)*(1.-exp(-(10.*mix(1.-exp(-0.05/pow(t.xyz, vec3(8.0))), vec3(0), 1.-min(iTime*0.5, 1.0)))));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float hash(float p)\n{\n\tvec3 p3 = fract(p * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract(fract(fract(p3.x)*100.*p3.y)*1000.*p3.z+dot(fract(p3), fract(p3.xzy)));//fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat noise(float p) {\n    float f = fract(p);\n    f = f*f*(3.-2.*f);\n    return mix(hash(floor(p)*0.001), hash(0.001*floor(p+1.)), f);\n}\nvec2 h(in float time) {\n    float t = time*iSampleRate;\n    float k = mod(floor(time*0.5), 3.0);\n    float fa = t*0.01*floor(1.0+log2(fract(time-1.0)*(64.0+64.*mod(floor(time*(k+1.0)+0.125*k), 2.0))+1.0));\n    float a = 1.5*cos(t*0.01)*(sin(fa*0.5));\n    float p = sin(t*0.1*(k+1.0))*pow(fract(time*0.25)*0.9+fract(time+0.1)*0.1, 5.0)+a*1.3;\n    float p1 = mix(0.1, 0.0, 0.5*(sin(time*0.5)+1.0))*sin(time*iSampleRate*(0.2-0.02*mod(floor(10.*fract((time)*0.2)), 3.0)));\n    float z = (1./(noise(t)+0.5)*0.4)*exp(-fract(time)*20.)+abs(fract(t*0.002)-0.5)*2.0-0.5+noise(t*(0.02+0.01*mod(floor(time*8.0), 3.0)))*exp(-fract(time))+noise(t*(0.03+0.01*mod(floor(time*4.0), 3.0)))*exp(-fract(time));\n    if (time < 4.0) return vec2(z);\n    return vec2(mix(z, p, mix(0.25, 0.6, sin(time*0.5)*0.5+0.5))+p1*0.25);\n\n}\nvec2 mainSound( int samp, float time ) {\n    return h(time);\n}", "sound_inputs": [], "common_code": "", "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjSW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 105, 105, 310], [311, 311, 331, 331, 461], [462, 462, 482, 482, 613], [614, 614, 638, 638, 1014], [1015, 1015, 1036, 1036, 1100], [1101, 1101, 1140, 1140, 2107], [2108, 2108, 2165, 2165, 2874]], "test": "untested"}
{"id": "DdjSW1", "name": "buffer drawback neighbours", "author": "jonasfrey", "description": "this is the fundament of how game of life works,\nit looks what is the sum of the pixel values  \n", "tags": ["template"], "likes": 5, "viewed": 167, "published": 3, "date": "1670258735", "time_retrieved": "2024-07-30T16:14:52.046628", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    fragColor = texture(iChannel0, o_trpino_nooffset);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float f_n_rand(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino_nooffset = (fragCoord.xy)/ iResolution.xy;\n    vec2 o_trmono_nooffset = (iMouse.xy)/ iResolution.xy;\n    \n    vec4 o_col_last = texture(iChannel0, o_trpino_nooffset);\n    \n    vec2 o_scale_kernel = vec2(\n        10.,\n        10.\n    );\n\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    if(iMouse.w == 0.0){\n        o_trmono = vec2(sin(iTime*2.)*0.5, 0.33);\n    }\n    vec2 o_scale = vec2(0.5);\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    \n    vec4 o_kernel_sum = vec4(0.0);\n    for(float n_y = 0.0; n_y < o_scale_kernel.y; n_y+=1.){\n        for(float n_x = 0.0; n_x < o_scale_kernel.x; n_x+=1.){\n            vec2 o_speed = vec2(0.1,0.1);\n            vec2 o = vec2(\n               floor(n_x - floor(o_scale_kernel.x/2.)),\n               floor(n_y - floor(o_scale_kernel.y/2.)) \n            ) + o_speed;\n            vec2 o_off = vec2(\n                o.x * (1./o_iResolution_scaled_floor.x),\n                o.y * (1./o_iResolution_scaled_floor.y)\n            );\n            vec4 o_col_last_kernel = texture(iChannel0, o_trpino_nooffset+o_off);\n            o_kernel_sum += o_col_last_kernel;\n        }\n    }\n    vec4 o_kernel_sum_nor = o_kernel_sum / (o_scale_kernel.x*o_scale_kernel.y);\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    if(iFrame == 0){\n        if(\n            mod(n_index, 2.) == mod(o_fragCoord_scaled_floor.y,2.)\n        ){\n            fragColor = vec4(1.);\n        }else{\n            fragColor = vec4(0.);\n        }\n    }else{\n        if(mod(float(iFrame), 5.) > 1.){\n            fragColor = o_col_last;\n\n        }else{\n            fragColor = vec4(0.);\n\n            if(o_kernel_sum_nor.x > 0.505){//f_n_rand(iTime)){\n                fragColor = vec4(1.);\n            }else{\n                fragColor = vec4(0.0);\n            }\n            float n = 0.01;\n            if(o_kernel_sum_nor.x > (1.-n) || o_kernel_sum_nor.x < n){\n                fragColor = vec4(f_n_rand(iTime+n_index));\n            }\n        }\n\n        //fragColor = o_col_last;\n        //fragColor += (o_kernel_sum_nor*0.001);\n    \n    }\n    \n    float n_thresh = 0.1;\n    float n_dist = length(o_trpino-o_trmono);\n    if(n_dist< n_thresh){\n        fragColor = vec4(sin(n_dist*6.2831*20.)*0.5+0.5);\n        fragColor = mix(o_col_last, fragColor,n_dist);\n        fragColor = mix(fragColor, vec4(f_n_rand(n_dist)), 0.9);\n        fragColor = vec4(f_n_rand(n_dist*2.));\n    }\n    \n    //fragColor = sqrt(fragColor);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjSW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 234]], "test": "untested"}
{"id": "csjSD1", "name": "2D Action Chess", "author": "finalman", "description": "Knight takes Shroom", "tags": ["trippy", "spin", "checkers"], "likes": 27, "viewed": 405, "published": 3, "date": "1670247329", "time_retrieved": "2024-07-30T16:14:52.791636", "image_code": "float distanceField(vec2 p, float t)\n{\n    float t1 = t * 1.4 - sqrt(length(p));\n    float t2 = t * 3.0 - length(p) * 0.4;\n    float a = sin(t2 / 20.0) * 20.0 + sin(t2) * 1.5;\n\n    p *= (exp(sin(t1) * -2.0) * 2.0) + 0.5;\n\n    p *= mat2x2(\n        cos(a), sin(a),\n        -sin(a), cos(a)\n    );\n    \n    p = p - floor(p) - 0.5;\n\n    p *= mat2x2(\n        0.5, 0.5,\n        -0.5, 0.5\n    );\n\n    return max(abs(p.x) - 0.25, abs(p.y) - 0.25);\n}\n\nfloat fill(vec2 screen, float t) {\n    // Fill distance field\n    float d = distanceField(screen, t);\n    float d2 = distanceField(screen, t + 0.001);\n    float v = length(vec2(dFdx(d), dFdy(d))) * max(1.0, abs(d2 - d) * 700.0);\n    float c = smoothstep(-v, v, d);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pixel coordinate (from -1 to 1)\n    vec2 screen = (fragCoord - iResolution.xy * 0.5) / (iResolution.y * 0.5);\n    \n    // Draw with temporal chromatic abberation\n    vec3 c = vec3(\n        fill(screen, iTime + 0.000),\n        fill(screen, iTime + 0.003),\n        fill(screen, iTime + 0.006)\n    );\n    \n    // Gamma correct\n    c = pow(c, vec3(1.0/2.2));\n\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 440], [442, 442, 476, 503, 722], [724, 724, 779, 818, 1174]], "test": "untested"}
{"id": "csBXDh", "name": "ChatGPT Raymarcher Attempt", "author": "oneshade", "description": "Experimenting with ChatGPT.", "tags": ["raymarcher", "shadertoy", "chatgpt"], "likes": 14, "viewed": 671, "published": 3, "date": "1670194167", "time_retrieved": "2024-07-30T16:14:53.604463", "image_code": "// I didn't think to record the conversation, but this is what\n// I remember of my side of the conversation:\n// Prompt: \"how do i write a raymarcher to draw a sphere in shadertoy?\"\n// Prompt: \"could you integrate those pieces of code?\"\n// (ChatGPT presented snippets of code for the different steps)\n// Prompt: \"how do i choose the step size?\"\n// (ChatGPT did not create a variable for setting the step size)\n// Prompt: \"line 19 results in this message \"'*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform highp int' and a right operand of type 'const float' (or there is no acceptable conversion)\". how can i fix this?\"\n// Prompt: \"is there a better way to choose step size? i'm getting a grey screen from the code you provided.\"\n\n#define MAX_STEPS 100 // [added by me]\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // viewport dimensions\n  float aspect = iResolution.x / iResolution.y;\n  vec2 viewport = vec2(aspect, 1.0);\n  fragColor = vec4(0.0, 0.0, 0.0, 1.0); // [added by me]\n\n  // camera position and direction\n  vec3 cameraPos = vec3(0.0, 0.0, 5.0);\n  vec3 cameraDir = normalize(vec3(0.0, 0.0, 0.0) - cameraPos);\n\n  // light position and color\n  //vec3 lightPos = vec3(0.0, 10.0, 5.0);\n  vec3 lightPos = vec3(-5.0, 10.0, 5.0); // [changed by me]\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n  // Sphere properties [added by me]\n  vec3 spherePos = vec3(0.0);\n  float sphereRadius = 1.0;\n\n  // material properties\n  vec3 ambientColor = vec3(0.1, 0.1, 0.1);\n  //float shininess = 16.0;\n  float shininess = 64.0; // [changed by me]\n\n  // ChatGPT had some interesting solutions including using sin(iFrame) lol [added by me]\n  // step size\n  //float stepSize = 0.1; [removed by me]\n\n  // raymarch loop\n  vec3 rayPos = cameraPos;\n  vec3 rayDir = normalize(vec3((fragCoord - 0.5 * iResolution.xy) / iResolution.y, -1.0));//cameraDir;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    // calculate distance to sphere\n    float distance = length(rayPos - spherePos) - sphereRadius;\n\n    // adjust step size based on distance\n    //stepSize = min(stepSize, distance * 0.1); [removed by me]\n\n    // check for intersection\n    if (distance <= 0.0) {\n      // calculate normal at point of intersection\n      vec3 normal = normalize(rayPos - spherePos);\n\n      // use Phong lighting model to shade surface of sphere\n      vec3 lightDir = normalize(lightPos - rayPos);\n      float diffuse = max(dot(normal, lightDir), 0.0);\n      vec3 diffuseColor = diffuse * lightColor;\n      vec3 viewDir = normalize(cameraPos - rayPos);\n      vec3 reflectDir = reflect(-lightDir, normal);\n      float specular = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n      vec3 specularColor = specular * lightColor;\n      vec3 finalColor = ambientColor + diffuseColor + specularColor;\n\n      // output final color\n      fragColor = vec4(finalColor, 1.0);\n      return;\n    }\n\n    // move ray along view direction\n    rayPos += rayDir * distance;//stepSize; [fixed by me]\n  }\n\n  // output background color\n  //fragColor = vec4(0.0, 0.0, 0.0, 1.0); [removed by me]\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[819, 819, 874, 899, 3092]], "test": "untested"}
{"id": "mdjXDz", "name": "subpixels pixels VA panel", "author": "jonasfrey", "description": "use the mouse on x-axis to zoom", "tags": ["template"], "likes": 3, "viewed": 217, "published": 3, "date": "1670184120", "time_retrieved": "2024-07-30T16:15:00.389322", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n    if(iMouse.z == 0.){\n        o_trmono_nooffset = vec2(0.1, 0.0);\n    }\n    float n_ratio = (iResolution.x / iResolution.y);\n    float n_channels = 3.;\n    float n_res = floor(2000.*o_trmono_nooffset.x);\n    vec2 o_res = vec2(n_res*n_channels, n_res/n_ratio);\n    \n    vec2 n_sc = vec2((vec2(1.)/iResolution.xy) * o_res);\n    vec2 o_scale = n_sc;\n\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n\n    \n\n    float n_index = o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x;\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    float n_index_channel = mod(n_index,3.);\n    float n_index_pixel = floor(n_index_channel /3.);\n    \n    vec2 o_pixel = vec2(floor(o_fragCoord_scaled_floor.x/3.), o_fragCoord_scaled_floor.y);\n    \n//texelFetch(iChannel0, ivec2(int(uv.x * 512./scale), 0), 0);\n    vec4 o_texture_col = texelFetch(iChannel0, ivec2(o_pixel), 0);\n    fragColor = vec4(\n        o_texture_col.r*float(n_index_channel == 0.),\n        o_texture_col.g*float(n_index_channel == 1.),\n        o_texture_col.b*float(n_index_channel == 2.),\n        1.\n    );\n\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1877]], "test": "untested"}
{"id": "dd2XWR", "name": "Ocean Wanderer", "author": "SnoopethDuckDuck", "description": "a creepy lil dude, inspired by this shader:\nhttps://www.shadertoy.com/view/DdjSDR", "tags": ["f"], "likes": 35, "viewed": 400, "published": 3, "date": "1670182778", "time_retrieved": "2024-07-30T16:15:01.910256", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 rayOri() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 1.18, -2);\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat dist(vec3 p) {\n   // p.x += iTime;\n   vec3 op = p;\n    float pd = p.y;\n    float m = 1.;\n    float xp = exp(-length(p.xz));\n    float h = 0.;\n    float n = 5.;\n    for (float i = 0.; i <n; i++) {\n        p.xz *= rot(pi/n);\n        h += (n-i) * texture(iChannel0, 0.04 * i * i * (p.xz + 0.2 * iTime)).r;\n       // h = smoothstep(0.3,0.7, h);\n        //pd -= m * h;\n    }\n    pd -= h/ 15.;   \n    op -= vec3(.75*cos(1. * p.y+iTime), \n               .8,\n               2.+2.*cos(0.2 * iTime) + .5*sin(iTime));\n   \n    float sd = length(op) - 0.1;\n    return smin(sd, 0.4 * pd, 0.35);\n}\n\nvec2 march(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    float steps = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = dist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        steps++;\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return vec2(min(dO, MAX_DIST), steps);\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = dist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy),\n        dist(p-e.yxy),\n        dist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = rayOri();\n    \n    vec3 rd = rayDir(uv, ro, vec3(0,0.8,0), 3.);\n    vec3 col = vec3(0);\n   \n    vec2 m = march(ro, rd, 1.);\n    float d = m.x;\n    \n    vec3 p = ro + rd * d;\n    float IOR = 1.2;\n    if(d<MAX_DIST) {        \n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 lightDir = normalize(vec3(1,2,3));\n        float dif  = dot(n,  lightDir)*.5+.5;\n          \n       \n        float fres  = pow(1. + dot(rd, n),  5.);\n    \n       // col = vec3(0);\n        //col += exp(-0.03 * m.y);\n        float xp = exp(-0.0025 * m.y);\n        col = mix(vec3(dif), vec3(1,0,0), xp);\n        col = pow(4.*col*(1.-col),vec3(2));\n        col = mix(col, vec3(0.5,0.7,1), 1.-xp);\n        float mx = .5+.5*thc(4., log(length(p.yz)) + pi);\n        //mx *= .75+.25*cos(4. * p.z+iTime);\n        //col = mix(col, vec3(0.7,0.8,0.1), fres * (1.-mx)); // <- interesting\n        col = mix(col, vec3(1), mx);\n        \n     }\n    \n    col = pow(col, vec3(1./2.2));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2XWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 207, 207, 283], [285, 285, 323, 323, 388], [390, 390, 409, 409, 492], [494, 494, 523, 523, 604], [606, 606, 640, 640, 716], [718, 718, 733, 733, 889], [891, 891, 911, 931, 1479], [1481, 1481, 1520, 1520, 1876], [1878, 1878, 1899, 1899, 2077], [2079, 2079, 2126, 2126, 2317], [2319, 2319, 2376, 2376, 3474]], "test": "untested"}
{"id": "md2XWz", "name": "F# in space", "author": "mrange", "description": "CC0: F# in space\nTried porting another shader to DirectX but failed due to subtle \ndifference between WebGL and DirectX.\nGot bored and tinkered with an older shader + F# logos\n//  This is the result\n", "tags": ["2d", "f"], "likes": 14, "viewed": 305, "published": 3, "date": "1670180279", "time_retrieved": "2024-07-30T16:15:02.916565", "image_code": "// CC0: F# in space\n//  Tried porting another shader to DirectX but failed due to subtle \n//  difference between WebGL and DirectX.\n//  Got bored and tinkered with an older shader + F# logos\n//  This is the result\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define TTIME       (TAU*TIME)\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define COLORTUNE   0.\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pabs(float a, float k) {\n  return -pmin(-a, a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 pmin(vec2 a, vec2 b, float k) {\n  vec2 h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 pabs(vec2 a, float k) {\n  return -pmin(-a, a, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  p = abs(p);\n  return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 dfsharpWeekly(vec2 p, vec2 off) {\n  const vec2 refN = SCA(-PI/4.0);\n  const float r = 0.125;\n  const float rr = 2.0*r*sqrt(2.0);\n  vec2 p0 = p;\n  vec2 p1 = p-off;\n  p0 = abs(p0);\n  ref(p0, refN);\n  p0.y -= rr;\n  float d0 = roundedX(p0, rr, r);\n  float d1 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.0, 1.0))-r;\n  float d2 = segment(p1, rr*vec2(0.5, -0.5), rr*vec2(0.0, -1.0))-r;\n  float d3 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.5, -1.5))-r;\n  float d = d0;\n  float dd = d1;\n  dd = min(dd, d2);\n  dd = min(dd, d3);\n  \n  return vec2(d, dd);\n}\n\nvec2 dfsharp(vec2 p) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  vec2 p3 = p;\n  const float sm = 0.03;\n  p0 = pabs(p0, sm);\n  const vec2 n = normalize(vec2(1.0));\n  float d0 = abs(dot(n, p0)-0.38)-0.12;\n  float d1 = abs(p1.x)-0.025;\n  float d2 = dot(n, p0)-0.19;\n  float d3 = -p3.x-0.025;\n  d2 = pmax(d2, -d3, sm);\n  float d = d0;\n\n  d = pmax(d, -d1, sm);\n  d = min(d,  d2);\n  return vec2(d, p.x > 0.0 ? 1.0 : 0.0);\n}\n\nvec3 df(vec2 p) {\n  vec2 op = p;\n\n  vec2 ph = op;\n  ph.y -= -0.025;\n  ph = ph.yx;\n  float dh = -hexagon(ph, 1.99);\n\n  const float fz = 2.0;\n  vec2 df = dfsharp(p/fz)*vec2(fz, 1.0);\n  float d0 = df.y > 0.0 ? abs(df.x)-0.0125 : df.x;;\n  \n  float d = d0;\n  \n  return vec3(d, length(p), dh);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nvec2 transform(vec2 p) {\n  float a = TTIME/400.0;\n  p *= 1.25;\n  p *= ROT(a);\n  vec2 p0 = toSmith(p);\n  p0 += 1.0*vec2(0.5, -1.0);\n  p = fromSmith(p0);\n  p.y += 0.05*TIME;\n  return p;\n}\n\nvec3 effect(vec2 p, vec2 pp, float r) {\n  const float iz = 4.0;\n  const float zf = 0.5;\n  const float hoff = COLORTUNE;\n  const vec3 bcol  = HSV2RGB(vec3(hoff+0.61, 0.9, 1.5));\n  const vec3 gcol  = HSV2RGB(vec3(hoff+0.55, 0.9, 1.0));\n  const vec3 bbcol = HSV2RGB(vec3(hoff+0.55, 0.75, 0.66));\n  const vec3 scol  = HSV2RGB(vec3(hoff+0.50, 0.95, 2.0));\n\n  vec2 pf = p;\n  pf -= vec2(r, -1.0)-0.4*vec2(1.0,-1.0);\n  pf /= zf;\n  pf *= ROT(-PI/4.0);\n\n  vec2 dfw = dfsharpWeekly(pf, vec2(-0.8, -0.35))*zf;\n  float dfs = min(dfw.x, dfw.y);\n  float aaa = 2.0/RESOLUTION.y;\n  p = transform(p);\n  float aa = iz*length(fwidth(p))*sqrt(0.5);\n  vec2 n = hextile(p);\n  p *= iz;\n  vec3 d3 = df(p);\n  float d = d3.x;\n  float g = d3.y;\n  float dd = d3.z;\n \n  float amb = mix(0.025, 0.1, tanh_approx(0.1+0.25*g+0.33*p.y));\n\n  vec3 col = vec3(0.0);\n  \n  col = mix(col, 5.0*sqrt(amb)*bcol, smoothstep(aa, -aa, d));\n  col = mix(col, 4.0*sqrt(amb)*bbcol, smoothstep(aa, -aa, dd));\n  col += 0.125*bcol*exp(-12.0*max(min(d, dd), 0.0));\n  col += gcol*amb;\n  col += scol*aa;\n  col *= mix(vec3(0.5), vec3(1.0),smoothstep(-0.9, 0.9, sin(0.33*TAU*p.y/aa+TAU*vec3(0.0, 1., 2.0)/3.0)));\n  col = mix(col, 1.2*sqrt(bcol), smoothstep(aaa, -aaa, dfs));\n  col *= smoothstep(1.5, 0.5, length(pp));\n\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  float r = RESOLUTION.x/RESOLUTION.y; \n  p.x *= r;\n  vec3 col = effect(p, pp, r);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md2XWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[642, 642, 664, 664, 810], [1105, 1205, 1224, 1224, 1311], [1313, 1420, 1446, 1446, 1630], [1632, 1732, 1771, 1771, 1856], [1858, 1958, 1997, 1997, 2026], [2028, 2128, 2158, 2158, 2186], [2188, 2288, 2324, 2324, 2408], [2410, 2510, 2538, 2538, 2566], [2568, 2628, 2656, 2722, 2798], [2800, 2918, 2950, 2950, 3136], [3138, 3138, 3171, 3171, 3252], [3254, 3372, 3414, 3414, 3473], [3475, 3593, 3632, 3632, 3744], [3746, 3746, 3769, 3849, 3988], [3990, 3990, 4015, 4094, 4233], [4235, 4235, 4273, 4273, 4786], [4788, 4788, 4810, 4810, 5195], [5197, 5197, 5214, 5214, 5486], [5488, 5589, 5617, 5716, 6043], [6045, 6045, 6069, 6069, 6230], [6232, 6232, 6271, 6271, 7553], [7555, 7555, 7612, 7612, 7803]], "test": "untested"}
{"id": "ddjXDR", "name": "Mandelbrot set, i²=a, ∀a∈[-2;2] ", "author": "iluha168", "description": "Black and white render", "tags": ["fractal", "mandelbrot"], "likes": 2, "viewed": 140, "published": 3, "date": "1670173860", "time_retrieved": "2024-07-30T16:15:03.948805", "image_code": "#define MAX_ITER 100\n#define i_sq (2.*sin(iTime))\n\nint mandelbrot(vec2 c){\n    vec2 z = c;\n    int i = 0;\n    while(length(z) <= 2. && i < MAX_ITER){\n        //z = z*z + c;\n        z = vec2(\n            z[0]*z[0]+i_sq*z[1]*z[1],\n            2.*z[0]*z[1]\n        ) + c;\n        i++;\n    }\n    return i;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    //x [-2; 1]\n    //y [-1; 1]\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*3. - 2.;\n    uv.y = uv.y*2. - 1.;\n    // Output to screen\n    float col = 1.-float(mandelbrot(uv))/float(MAX_ITER);\n    fragColor.rgb = vec3(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 74, 74, 303], [305, 305, 360, 428, 633]], "test": "untested"}
{"id": "ms2XWR", "name": "Neon Scaffolding", "author": "MysteryPancake", "description": "Accidentally made this while working on a tic-tac-toe shader. Click to move camera :)", "tags": ["noise", "sdf", "line", "cellular", "pattern", "cell", "pathfinding", "path", "neon", "scaffold", "cineshader"], "likes": 25, "viewed": 739, "published": 3, "date": "1670172307", "time_retrieved": "2024-07-30T16:15:04.796538", "image_code": "const float scale = 32.0;\nconst float lineWidth = 0.1;\n\n// Posterized noise\nfloat noise(vec2 p, float levels) {\n    return floor(fract(sin(dot(floor(p), vec2(1.989, 2.233))) * 43758.54) * levels) / levels;\n}\n\n// From https://www.shadertoy.com/view/3tdSDj, shortened by FabriceNeyret2\nfloat line(vec2 p, vec2 dir) {\n    return length(p - dir * max(0.0, dot(p, dir) / dot(dir, dir)));\n}\n\n// Modified from https://www.shadertoy.com/view/lsS3Wc\nvec3 hue2rgb(float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 pos = (iMouse.z > 0.0 ? fragCoord - iMouse.xy : fragCoord + iTime * 60.0) / scale;\n    \n    // Number of color subdivisions, ideally a whole number\n    float colors = 3.0 + cos(iTime * 0.2);\n    \n    // Add nice rainbow colors\n    float self = noise(pos, colors);\n    vec3 bg = hue2rgb(self);\n    float bgMix = 1.0;\n    \n    // 3 x 3 kernel, checks all 8 neighbors\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n        \n            // Ignore self\n            if (x == 0 && y == 0) continue;\n            vec2 offset = vec2(x, y);\n            \n            // Check neighbor has matching color\n            if (self == noise(pos + offset, colors)) {\n                // Draw a line from the center to the neighbor\n                float dist = line(fract(pos) - 0.5, offset);\n                bgMix = min(bgMix, dist / lineWidth);\n            }\n        }\n    }\n    \n    // Combine background and lines, clip a little\n    fragColor = vec4(mix(0.8 + bg, bg * 0.2, bgMix), 1.0 - bgMix * 0.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms2XWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 76, 111, 111, 207], [209, 284, 314, 314, 384], [386, 441, 466, 466, 556], [558, 558, 613, 613, 1642]], "test": "untested"}
{"id": "csjXRm", "name": "Codevember #10 Optical Illusion", "author": "Etidou", "description": "Day 10 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["optical", "illusion", "codevember"], "likes": 5, "viewed": 145, "published": 3, "date": "1670169688", "time_retrieved": "2024-07-30T16:15:05.730042", "image_code": "// inspiration: https://www.shadertoy.com/view/lsX3zM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 vCoord = fragCoord.xy / iResolution.xy;\n\tvCoord.x *= iResolution.x / iResolution.y;\n\t\n\tvec2 vTilePos = vCoord * 10.0;\n\t\n\tfloat fScroll = iTime + 0.25;\n\t\n\tfloat fIsOddRow = (mod(vTilePos.y, 2.0) > 1.0) ? 0.0 : 1.0;\n\tvTilePos.x += fScroll / (fIsOddRow * 2.0 - 1.0);\n\t\n\tfloat fShade = (mod(vTilePos.x, 2.0) > 1.0) ? 0.0 : 1.0;\t\n\t\n\tvec2 vTileFract = fract(vTilePos);\n\n\tvec3 color1 = vec3(0.0, 0.0157, 1.0);\n\tvec3 color2 = vec3(0.0, 0.0196, 0.2039);\n\n\tvec3 color = vec3(0.0);\n\t\n\tfloat fBorderShade = 0.5;\n\tfloat fBorderWidth = 0.05;\n\tfShade = mix(fShade, fBorderShade, step(vTileFract.x, fBorderWidth));\n\tfShade = mix(fShade, fBorderShade, step(vTileFract.y, fBorderWidth));\n\n\tcolor += mix(\n        color1,\n        color2,\n        length(vCoord-0.75)\n    ) + fShade;\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 112, 112, 915]], "test": "untested"}
{"id": "DdjXRm", "name": "Codevember #9 Optical Illusion", "author": "Etidou", "description": "Day 9 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["optical", "illusion", "codevember"], "likes": 2, "viewed": 124, "published": 3, "date": "1670169683", "time_retrieved": "2024-07-30T16:15:06.480037", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.yy + 0.5;\n\n    float movement = 0.125 * sin(uv.y * 13.0 + iTime * 0.2) + 0.15 * sin(uv.y * 17.0 + iTime * 1.);\n\n    uv.x += movement * pow(uv.y, 0.5);\n\n    uv.x *= 15.0;\n\n    uv.x = fract(uv.x); \n\n    vec4 color1 = vec4(0.0, 0.0157, 1.0, 1.0);\n    vec4 color2 = vec4(0.0, 0.0196, 0.2039, 1.0);\n\n    float t = smoothstep(0.2, 0.3, uv.x) - smoothstep(0.7, 0.8, uv.x);\n\n    vec4 color = mix(color1, color2, t);\n   \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 611]], "test": "untested"}
{"id": "cdjXRm", "name": "Codevember #8 Square Random 2", "author": "Etidou", "description": "Day 8 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["random", "square", "motion", "codevember"], "likes": 3, "viewed": 110, "published": 3, "date": "1670169676", "time_retrieved": "2024-07-30T16:15:07.221056", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\n\nfloat square(vec2 uv, float d) {\n    uv = uv*0.75-1. * (sin(iTime) / 4.0);\n    return max(abs(uv.x * 2.0), abs(uv.y * -2.0)) - d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 1.5;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 35.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n\ttime = smootheststep(0.0, 1.0, time);\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  time; // attempt 1\n        // float animTime =  quadraticInOut(time); // attempt 2\n        // float animTime =  qinticInOut((time / 2.0)); // attempt 3\n        // float animTime =  exponentialInOut(time); // attempt 4\n\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 400.0) / 400.;\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, square(rotate(uv, -(rotateAmount + PI / 2.0) * time), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 206, 206, 318], [320, 320, 376, 376, 478], [481, 481, 513, 513, 612], [614, 614, 671, 671, 6166]], "test": "untested"}
{"id": "Dd2SRm", "name": "Codevember #7 Square Random 1", "author": "Etidou", "description": "Day 7 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["random", "square", "motion", "codevember"], "likes": 3, "viewed": 118, "published": 3, "date": "1670169669", "time_retrieved": "2024-07-30T16:15:07.972048", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nuniform float number;\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\n\nfloat poly(vec2 uv, float d) {\n    uv = uv*2.-1.;\n    return max(abs(uv.x), abs(uv.y)) - d;\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 1.5;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 35.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n\ttime = smootheststep(0.0, 1.0, time); // attempt 1 2\n\n    // time = mod((time / 2.0), 1.0);\n\t// time = smootheststep(0.0, 1.0, time); // attempt 3\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  time;\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 25.) / 25.; // 25\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, poly(rotate(uv, -(rotateAmount + PI / 2.0) * time), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2SRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 279, 279, 391], [394, 394, 424, 424, 487], [489, 489, 545, 545, 647], [650, 650, 707, 707, 6049]], "test": "untested"}
{"id": "DsjSRm", "name": "Codevember #6 Pentagone", "author": "Etidou", "description": "Day 6 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "codevember", "pentagone"], "likes": 3, "viewed": 105, "published": 3, "date": "1670169659", "time_retrieved": "2024-07-30T16:15:08.718054", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\nfloat poly(vec2 uv, float d) {\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(5);\n    float final = cos(floor(.5+a/v)*v-a)*r;\n    return max(abs(final), abs(final)) - d;\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2. - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 1.85;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 25.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n\ttime = smootheststep(0.0, 1.0, time);\n\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  time;\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 25.) / 25.; // 25\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, poly(rotate(uv, -(rotateAmount + PI / 2.0) * time), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 206, 206, 318], [320, 320, 350, 350, 528], [530, 530, 586, 586, 688], [690, 690, 747, 747, 5981]], "test": "untested"}
{"id": "ddjXWR", "name": "Gold and White Grids", "author": "SnoopethDuckDuck", "description": "Two scenes overlapping, i forget how it works", "tags": ["scene", "idk", "grids"], "likes": 7, "viewed": 148, "published": 3, "date": "1670169420", "time_retrieved": "2024-07-30T16:15:09.459073", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 15.\n#define SURF_DIST .02\n\n#define oriRadius 0.8\n\nvec3 rayOri() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = 0.5 * iTime;\n    vec3 ro = vec3(4. * cos(t),\n                   4. * cos(0.8 * t),\n                   4. * sin(t));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat dist(vec3 p, float o) {\n    float sd = length(p - rayOri()) - oriRadius;\n    p += cos(vec3(0.25 * p.zxy + iTime));\n    p += o;\n    p.z -= 1.5 * iTime;\n    vec3 fpos  = mod(p, 4.) - 2.;\n    vec3 fpos2 = mod(p + 2., 4.) - 2.;\n    float o2 = .2 + .05 * thc(2., 10. * p.y - 0.5 * iTime);\n    float d1 = sdBoxFrame(fpos, vec3(2), 0.05) - o2 + 0.1 * o;\n    float d2 = sdBoxFrame(fpos2, vec3(2), 0.05) - o2 + 0.1 * o;\n    return -min(sd, -min(d1,d2));\n}\n\nfloat march(vec3 ro, vec3 rd, float z, float o) {\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = dist(p, o);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 normal(vec3 p, float o) {\n\tfloat d = dist(p, o);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        dist(p-e.xyy, o),\n        dist(p-e.yxy, o),\n        dist(p-e.yyx, o));\n    \n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = rayOri();\n    \n    vec3 rd = rayDir(uv, ro, vec3(0), 0.6);\n    vec3 col = vec3(0);\n   \n    float d1 = march(ro, rd, 1., 1.);\n    float d2 = march(ro, rd, 1., 0.);\n    vec3 p1 = ro + rd * d1;\n    vec3 p2 = ro + rd * d2;\n    vec3 n1 = normal(p1, 1.);\n    vec3 n2 = normal(p2, 0.);\n    vec3 r1 = reflect(rd, n1);\n    vec3 r2 = reflect(rd, n2);\n    vec3 ld = normalize(vec3(1,2,3));\n    float dif1 = .5+.5*dot(abs(n1),ld);\n    float dif2 = .5+.5*dot(abs(n2),ld);\n    float spec1 = pow(dif1, 256.);\n    float spec2 = pow(dif2, 256.);\n    float sp = -0.1 * (spec1 + spec2);\n    vec3 pl1 = pal(sp + -0.2 * length(p1) + 0.1 * d1, 0.5 * vec3(.5,1,2)/3.);   \n    vec3 pl2 = pal(sp + 0.5 + 0.1 * d2, 0.5 * vec3(.5,1,2)/3.);   \n    col = clamp(col, 0., 1.);\n    col = mix(vec3(1.-1./cosh(-.2*d1)),\n              vec3(1.-1./cosh(-.2*d2)*pl2),\n              clamp(d1/d2,0.,1.5));\n    col *= pl1;\n    col *= .96 \n         + .02 * step(mod(fragCoord.x + fragCoord.y + iTime, 14.), 7.)\n         + .02 * step(mod(fragCoord.x - fragCoord.y + iTime, 14.), 7.);   \n    col *= 1. - 0.2 * abs(dif1-dif2);  \n    col *= 1. + 0.4 * vec3(spec1 + spec2);\n    \n    vec3 tx = texture(iChannel0, (r1+r2)).rgb;\n    vec3 tx2 = texture(iChannel1, (r1+r2)).rgb;\n    tx  = mix(tx,  vec3(1), 1.- 1./cosh(-0.1 * (d1+d2)));\n    tx2 = mix(tx2, vec3(1), 1.- 1./cosh(-0.1 * (d1+d2)));\n    col *= 1.4 * tx2;\n    col = mix(col, tx, .5+.5*thc(4., 0.25 * iTime + 0.1 * p1.y));\n    col = pow(col, vec3(1./2.4));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 104, 104, 357], [359, 359, 404, 404, 691], [693, 693, 722, 722, 1145], [1147, 1147, 1196, 1196, 1502], [1504, 1504, 1534, 1534, 1724], [1726, 1726, 1773, 1773, 1964], [1966, 1966, 2023, 2023, 3621]], "test": "untested"}
{"id": "DsjSDz", "name": "random sdf functions", "author": "jonasfrey", "description": "just playing around", "tags": ["template"], "likes": 3, "viewed": 183, "published": 3, "date": "1670168133", "time_retrieved": "2024-07-30T16:15:10.208070", "image_code": "float f_n_dist11(vec2 o_1, vec2 o_2){\n\n    vec2 o_delta = abs(o_1-o_2);\n    float n_angle = atan(o_delta.y, o_delta.x);\n\n    return fract(n_angle);\n}\nfloat f_n_dist10(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    vec2 o_3 = o_delta * o_1 * o_2;\n    return fract(o_3.x+o_3.y);\n}\nfloat f_n_dist9(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    float n = sqrt(o_delta.x*o_delta.y + o_delta.x * o_delta.y);\n    return n;\n}\nfloat f_n_dist8(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    float n_length = sqrt(o_delta.x*o_delta.x + o_delta.y * o_delta.y);\n    return n_length;\n}\nfloat f_n_dist7(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    return abs(o_delta.x-o_delta.y);\n}\nfloat f_n_dist6(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    return (o_delta.x+o_delta.y);\n}\nfloat f_n_dist5(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    return pow(o_delta.x,o_delta.y);\n}\nfloat f_n_dist4(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    return o_delta.x / o_delta.y;\n}\nfloat f_n_dist3(vec2 o_1, vec2 o_2){\n    vec2 o_delta = (o_1-o_2);\n    return o_delta.x * o_delta.y;\n}\nfloat f_n_dist2(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    return max(o_delta.x, o_delta.y);\n}\nfloat f_n_dist1(vec2 o_1, vec2 o_2){\n    vec2 o_delta = abs(o_1-o_2);\n    return min(o_delta.x, o_delta.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n\n\n    vec2 o_scale = vec2(0.009);\n\n    vec2 o_fragCoord_scaled = (fragCoord.xy*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n\n    \n\n    float n_index = o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x;\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n\n    float n_t = iTime * 0.;\n    vec2 o_tanim = fract(o_fragCoord_scaled_fract+n_t);\n    \n    float[] a_n_dist = float[](\n        (f_n_dist1(o_tanim, vec2(0.))),\n        (f_n_dist1(o_tanim, vec2(0.5))),\n        (f_n_dist1(o_tanim, vec2(1.0))), \n        (f_n_dist2(o_tanim, vec2(0.))),\n        (f_n_dist2(o_tanim, vec2(0.5))),\n        (f_n_dist2(o_tanim, vec2(1.0))),\n        (f_n_dist3(o_tanim, vec2(0.))),\n        (f_n_dist3(o_tanim, vec2(0.5))),\n        (f_n_dist3(o_tanim, vec2(1.0))),\n        (f_n_dist4(o_tanim, vec2(0.))),\n        (f_n_dist4(o_tanim, vec2(0.5))),\n        (f_n_dist4(o_tanim, vec2(1.0))),\n        (f_n_dist5(o_tanim, vec2(0.))),\n        (f_n_dist5(o_tanim, vec2(0.5))),\n        (f_n_dist5(o_tanim, vec2(1.0))),\n        (f_n_dist6(o_tanim, vec2(0.))),\n        (f_n_dist6(o_tanim, vec2(0.5))),\n        (f_n_dist6(o_tanim, vec2(1.0))),\n        (f_n_dist7(o_tanim, vec2(0.))),\n        (f_n_dist7(o_tanim, vec2(0.5))),\n        (f_n_dist7(o_tanim, vec2(1.0))),\n        (f_n_dist8(o_tanim, vec2(0.))),\n        (f_n_dist8(o_tanim, vec2(0.5))),\n        (f_n_dist8(o_tanim, vec2(1.0))),\n        (f_n_dist9(o_tanim, vec2(0.))),\n        (f_n_dist9(o_tanim, vec2(0.5))),\n        (f_n_dist9(o_tanim, vec2(1.0))),\n        (f_n_dist10(o_tanim, vec2(0.))),\n        (f_n_dist10(o_tanim, vec2(0.5))),\n        (f_n_dist10(o_tanim, vec2(1.0))),\n        (f_n_dist11(o_tanim, vec2(0.))),\n        (f_n_dist11(o_tanim, vec2(0.5))),\n        (f_n_dist11(o_tanim, vec2(1.0)))\n        \n    );\n    \n    float n_index_mod = mod(n_index, float(a_n_dist.length()));\n    float n_dist = a_n_dist[int(n_index_mod)];\n    float n_dist_tanim = fract(n_dist+iTime);\n    fragColor = vec4( n_dist_tanim);\n    \n    fragColor = sqrt(fragColor);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 149], [150, 150, 187, 187, 289], [290, 290, 326, 326, 440], [441, 441, 477, 477, 605], [606, 606, 642, 642, 714], [715, 715, 751, 751, 820], [821, 821, 857, 857, 929], [930, 930, 966, 966, 1035], [1036, 1036, 1072, 1072, 1138], [1139, 1139, 1175, 1175, 1248], [1249, 1249, 1285, 1285, 1358]], "test": "untested"}
{"id": "cd2XWz", "name": "Fork Viscosity PyThrrrown 089", "author": "PyThrrrown", "description": "Some soapy slimy colorfull liquid", "tags": ["slimy"], "likes": 4, "viewed": 238, "published": 3, "date": "1670163118", "time_retrieved": "2024-07-30T16:15:10.948091", "image_code": "// Created by Alex Kluchikov\n#define PI 3.141592654\nvec2 rot(vec2 p,float a)\n{\n    float c=sin(a*35.83);\n    float s=cos(a*35.83);\n    return p*mat2(s,c,c,-s);\n}\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xy;\n    uv=vec2(2.1,.5)+(uv-vec2(2.1,.5))*(.008);\n    \n    float T=iTime*.5;\n\n    vec3 c = clamp(1.-.58*vec3(\n        length(uv-vec2(1.,1)),\n        length(uv-vec2(1.,1)),\n        length(uv-vec2(1.,1))\n        ),0.,1.)*2.-1.;\n    vec3 c0=vec3(0);\n    float w0=0.;\n    const float N=10.;\n    for(float i=0.;i<N;i++)\n    {\n        float wt=(i*i/N/N-.01)*0.01;\n        float wp=0.5+(i+1.)*(i+1.5)*0.001;\n        float wb=.03+i/N*0.03;\n    \tc.zx=rot(c.zx,.8*wb+T*0.85*wt+(uv.x+.7)*3.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+5.7+T*wt+(uv.y+1.1)*14.*wp);\n    \tc.yz=rot(c.yz,c.x*c.y*wb+8.4-T*0.79*wt+(uv.x+uv.y*(fract(i/2.)-0.25)*4.)*16.*wp);\n    \tc.zx=rot(c.zx,c.y*c.z*wb+8.6-T*0.65*wt+(uv.x+.7)*2.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+8.7-T*wt+(uv.y+1.1)*2.*wp);\n        float w=(.000005-i/N);\n        c0+=c*w;\n        w0+=w;\n    }\n    c0=c0/w0*(1.-pow(uv.y-.5,2.)*2.)*-1.2+.9;\n    //c0=c0/w0*(1.-pow(uv.y-.5,2.)/1.-pow(uv.x-.5,2.)*1.5)*.98+.1;\n    c0*=.5+dot(c0,vec3(1,1,1))/sqrt(3.)*.3;\n    c0+=pow(length(sin(c0*PI*7.))/sqrt(7.)*1.1,25.1)*(.01+.3*c0);\n\to=vec4(c0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2XWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 78, 78, 161], [162, 162, 202, 202, 1284]], "test": "untested"}
{"id": "ds2XzD", "name": "Tiny Town WFC", "author": "fenix", "description": "Another wave function collapse experiment, trying to portray a town, or maybe an endless resort?\n\n*mouse drag up/left: zoom out*\n*mouse drag down/right: re-center and zoom in*\n*shift+mouse drag: pan* \n*space to reset*\n*up/down to zoom*", "tags": ["terrain", "simulation", "random", "map", "automata", "tile", "tiles", "wfc", "wavefunctioncollapse", "roads"], "likes": 23, "viewed": 314, "published": 3, "date": "1670146545", "time_retrieved": "2024-07-30T16:15:11.878603", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiement with my interpretation of Wave Function Collapse.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//\n//  There have been a couple of significant simulation upgrades since the last one:\n//\n//  * Tiles are now marked by how they are symmetric, so that different orientations of\n//    the same tiles are not treated as unique tiles. Also useful for creating directional\n//    effects like the bridge supports.\n//\n//  * You can now specify that a tile cannot connect to itself. This is useful for keeping\n//    lake corners from forming lots of tiny islands, and building corners from making wee\n//    buildings. Also keeps roads from being excessively wiggly.\n//\n//  I'm aware that this takes ages to fully converge, and I hope you will excuse me for\n//  that. My excuse is that enough of the map is finished to give you something to look\n//  at while construction is finished on the harder areas. Some of the situations, like\n//  long bridges meeting in the middle of a lake, are pretty tricky to resolve. In this\n//  case sometimes it comes up a solution that I didn't expect, so I'd almost consider it\n//  \"novel\"...it makes an island.\n//\n//  The entire buffer is simulated, so you're only looking at the center 1/64th of the\n//  buffer when the shader boots, chosen so that the 8x8 tile pixels are 1:1 with screen\n//  pixels. Click and drag the mouse up/left to zoom out.\n//\n//  The tiles are defined in the Common tab, and are designed to be easy to change. Forks\n//  of this shader are welcome if you draw your own tiles and make something intereting\n//  and new out of it. But please post a comment here so I don't miss it!\n//\n//  The rendering was probably harder to get working than the simulation, because I\n//  wanted to be able to zoom out and watch the simulation from farther away. My first\n//  attempt had horrible aliasing artifacts so I had to add this box clipping system.\n//\n//  I'm curious if the mouse camera controls are effective or not for other people. Once\n//  you get used to it, it's handy for zooming in on specific details, I think.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// compute the overlapping area between two axis aligned boxes\nfloat boxClip(vec4 a, vec4 b)\n{\n    vec4 i = vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n    vec2 e = i.zw - i.xy;\n    return any(lessThanEqual(e, vec2(0))) ? 0. : e.x * e.y;\n}\n\n// rotate a pixel index\nivec2 rotIdx(ivec2 v, int r)\n{\n    if (r == 0) return ivec2(v.x, 8 - v.y);\n    if (r == 1) return v.yx;\n    if (r == 2) return ivec2(8 - v.x, v.y);\n    if (r == 3) return 8 - v.yx;\n}\n\n#define GET_SUBTILE(T, U) ((TILES[T].image[U.y] >> ((8 - U.x) * 3)) % 8u)\n\n// compute the color contribution of a single tile, clipped to the screen pixel\nvec3 tileClip(int type, int rot, vec4 clipBox, bool parity)\n{\n    vec3 sum = vec3(0);\n    for (ivec2 v = ivec2(0); v.x < 9; ++v.x)\n    for (v.y = 0; v.y < 9; ++v.y)\n    {\n        uint value = GET_SUBTILE(type, rotIdx(v, rot));\n        sum += subtileColor(value, parity ^^ ((v.x + v.y) & 1) == 0) * boxClip(clipBox, vec4(vec2(v) / 9., (vec2(v) + 1.) / 9.));\n    }\n    return sum;// * vec3(float(rot + 1) * .25);\n}\n\n// From FabriceNeyret2's  iResolution, iMouse, iDate, etc  https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\n\nvec3 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .4 )\n        v += char(p, 48+ i%10 );\n    return v.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n\n    fragCoord -= .5 * iResolution.xy;\n    fragCoord *= state.zoom;\n    fragCoord += state.center * iResolution.y;\n    fragCoord += .5 * iResolution.xy;\n    \n    // compute the tile address and coordinates within the tile for the lower left and upper right corners of the pixel\n    vec2 llc = fragCoord - .5 * state.zoom;\n    ivec2 llt = ivec2(llc);\n    llc = fract(llc);\n    vec2 urc = fragCoord + .5 * state.zoom;\n    ivec2 urt = ivec2(urc);\n    urc = fract(urc);\n    \n    vec3 sum = vec3(0);\n    \n    // loop over all the tiles, clipping as we go\n    for (ivec2 tile = llt; tile.x <= urt.x; ++tile.x)\n    for (tile.y = llt.y; tile.y <= urt.y; ++tile.y)\n    {\n        if (all(greaterThan(tile, ivec2(0))) && all(lessThan(tile, ivec2(iResolution.xy))))\n        {\n            vec4 v = texelFetch(iChannel0, tile, 0);\n            int type = int(v.x);\n            int rot = int(v.y);\n\n            vec4 clipBox = vec4(0, 0, 1, 1);\n\n            // clip one or more sides if necessary\n            if (tile.x == llt.x) clipBox.x = llc.x;\n            if (tile.y == llt.y) clipBox.y = llc.y;\n            if (tile.x == urt.x) clipBox.z = urc.x;\n            if (tile.y == urt.y) clipBox.w = urc.y;\n\n            sum += tileClip(type, rot, clipBox, ((tile.x + tile.y) & 1) != 0);\n            \n            // debug draw tile values\n            //sum = max(sum, pInt(llc*4. - vec2(.3, 0), v.x));\n        }\n    }\n    \n    fragColor = sqrt(vec4(sum / (state.zoom * state.zoom), 1));\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec3 subtileColor(uint value, bool parity)\n{\n    if (value == 0u) return vec3(0);\n    if (value == 1u) return vec3(.05,.3,0);\n    if (value == 2u) return vec3(.3);\n    if (value == 3u) return parity ? vec3(.7,.6,0) : vec3(.3);\n    if (value == 4u) return vec3(.1,.4,1.);\n    if (value == 5u) return parity ? vec3(.5,.1,.1) : vec3(.3,.1,.1);\n    if (value == 6u) return parity ? vec3(.05,.1,0) : vec3(.0,.2,.0);\n    if (value == 7u) return vec3(.7,.6,0);\n    return vec3(1,0,1);\n}\n\n// symmetry types\n#define S_X 0x1\n#define S_I 0x3\n#define S_L 0xf\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    int sym; // symmetry type\n    bool selfConnect; // can connect to self\n    uint image[9]; // 8-color octal array defining how to render the tile, referencing the above colors\n};\n\nconst Tile T_EMPTY =\n    Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         .5,\n         S_X, true,\n         uint[](0222272222u,\n                0222272222u,\n                0222707222u,\n                0222707222u,\n                0227777722u,\n                0227707722u,\n                0277777772u,\n                0222222222u,\n                0222222222u));\n         \nconst Tile T_GRASS =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         1.,\n         S_X, true,\n         uint[](0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u,\n                0111111111u));\n                \nconst Tile T_ROAD_STRAIGHT =\n    Tile(mat3(1, 2, 1,\n              1, 2, 1,\n              1, 2, 1),\n         .2,\n         S_I, true,\n         uint[](0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u,\n                0122232221u));\n                \nconst Tile T_ROAD_TURN =\n    Tile(mat3(1, 1, 1,\n              1, 2, 2,\n              1, 2, 1),\n         .01,\n         S_L, false,\n         uint[](0111111111u,\n                0111222222u,\n                0112222222u,\n                0122222222u,\n                0122233333u,\n                0122232222u,\n                0122232222u,\n                0122232222u,\n                0122232221u));\n                \nconst Tile T_ROAD_T =\n    Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              1, 2, 1),\n         .01,\n         S_I, false,\n         uint[](0111111111u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0333333333u,\n                0222232222u,\n                0222232222u,\n                0222232222u,\n                0122232221u));\n                \nconst Tile T_ROAD_X =\n    Tile(mat3(1, 2, 1,\n              2, 2, 2,\n              1, 2, 1),\n         .01,\n         S_I, false,\n         uint[](0122232221u,\n                0222232222u,\n                0222232222u,\n                0222232222u,\n                0333333333u,\n                0222232222u,\n                0222232222u,\n                0222232222u,\n                0122232221u));\n                \nconst Tile T_REDB =\n    Tile(mat3(5, 5, 5,\n              5, 5, 5,\n              5, 5, 5),\n         .06,\n         S_X, true,\n         uint[](0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u,\n                0555555555u));\n\nconst Tile T_REDB_EDGE =\n    Tile(mat3(1, 5, 5,\n              1, 5, 5,\n              1, 5, 5),\n         .03,\n         S_L, true,\n         uint[](0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u,\n                0111220555u));\n\nconst Tile T_REDB_CORNER =\n    Tile(mat3(1, 1, 1,\n              1, 5, 5,\n              1, 5, 5),\n         .03,\n         S_L, false,\n         uint[](0111111111u,\n                0111111111u,\n                0111111111u,\n                0111222222u,\n                0111222222u,\n                0111220000u,\n                0111220555u,\n                0111220555u,\n                0111220555u));\n\nconst Tile T_REDB_ICORNER =\n    Tile(mat3(5, 5, 5,\n              5, 5, 5,\n              5, 5, 1),\n         .03,\n         S_L, true,\n         uint[](05555555555u,\n                05555555555u,\n                05555555555u,\n                05555000000u,\n                05555055555u,\n                05555051111u,\n                05555051111u,\n                05555051111u,\n                05555051111u));\n\nconst Tile T_REDB_ENTR =\n    Tile(mat3(1, 5, 5,\n              2, 5, 5,\n              1, 5, 5),\n         .0,\n         S_L, false,\n         uint[](0111220005u,\n                0222222220u,\n                0222222220u,\n                0222222220u,\n                0333333330u,\n                0222222220u,\n                0222222220u,\n                0222222220u,\n                0111220005u));\n\nconst Tile T_REDB_T_ENTR_A =\n    Tile(mat3(1, 5, 5,\n              3, 5, 5,\n              1, 5, 5),\n         .0,\n         S_L, false,\n         uint[](0141410555u,\n                0000000000u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0000000000u,\n                0141410555u));\n\nconst Tile T_REDB_T_ENTR_B =\n    Tile(mat3(1, 5, 5,\n              4, 5, 5,\n              1, 5, 5),\n         .0,\n         S_L, false,\n         uint[](0141410555u,\n                0000000000u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0141414140u,\n                0000000000u,\n                0141410555u));\n\nconst Tile T_TREE =\n    Tile(mat3(1, 1, 1,\n              1, 6, 6,\n              1, 6, 6),\n         .1,\n         S_L, true,\n         uint[](0111111111u,\n                0111111116u,\n                0111111611u,\n                0111166666u,\n                0111666666u,\n                0116166666u,\n                0161666666u,\n                0116666666u,\n                0166666666u));\n\nconst Tile T_PARK_ENTR =\n    Tile(mat3(1, 2, 1,\n              8, 7, 1,\n              10, 7, 10),\n         .1,\n         S_L, false,\n         uint[](0122232221u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_END =\n    Tile(mat3(1, 1, 1,\n              8, 7, 1,\n              10, 7, 10),\n         .0,\n         S_L, false,\n         uint[](01111111111u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_CORN =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              10, 9, 1),\n         .0,\n         S_L, false,\n         uint[](0111111111u,\n                0277777777u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0277777777u));\n\nconst Tile T_PARK_AISLE_A =\n    Tile(mat3(10, 7, 10,\n              9, 7, 8,\n              1, 9, 1),\n         .3,\n         S_L, false,\n         uint[](0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_AISLE_B =\n    Tile(mat3(1, 9, 1,\n              8, 7, 9,\n              10, 7, 10),\n         .3,\n         S_L, false,\n         uint[](0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u,\n                0222222222u));\n\nconst Tile T_PARK_SPOT_A =\n    Tile(mat3(1, 8, 10,\n              1, 8, 9,\n              1, 1, 1),\n         0.,\n         S_L, false,\n         uint[](0222222222u,\n                0722222277u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u));\n                \nconst Tile T_PARK_SPOT_B =\n    Tile(mat3(10, 9, 1,\n              9, 8, 1,\n              1, 1, 1),\n         0.,\n         S_L, false,\n         uint[](0222222222u,\n                0722222277u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u,\n                0722222272u));\n\nconst float LAKE_PROB = .02;\nconst Tile T_LAKE =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .3,\n         S_X, true,\n         uint[](0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u));\n\nconst Tile T_LAKE_EDGE =\n    Tile(mat3(1, 1, 1,\n              3, 3, 3,\n              3, 3, 3),\n         LAKE_PROB,\n         S_L, true,\n         uint[](0111111111u,\n                0111111111u,\n                0111117777u,\n                0711177777u,\n                0777774444u,\n                0477744444u,\n                0444444444u,\n                0444444444u,\n                0444444444u));\n\nconst Tile T_LAKE_CORNER =\n    Tile(mat3(1, 1, 1,\n              1, 3, 3,\n              1, 3, 3),\n         LAKE_PROB,\n         S_L, false,\n         uint[](0111111111u,\n                0111117711u,\n                0111777777u,\n                0117744477u,\n                0177444444u,\n                0177444444u,\n                0177444444u,\n                0177444444u,\n                0117744444u));\n\nconst Tile T_LAKE_ICORNER =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 1),\n         LAKE_PROB,\n         S_L, false,\n         uint[](0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444444u,\n                0444444447u,\n                0444444477u,\n                0444444771u,\n                0444447711u));\n\nconst Tile T_BRIDGE =\n    Tile(mat3(3, 2, 3,\n              3, 2, 3,\n              3, 2, 3),\n         LAKE_PROB,\n         S_I, true,\n         uint[](0002232244u,\n                0442232244u,\n                0442232244u,\n                0002232244u,\n                0442232244u,\n                0442232244u,\n                0002232244u,\n                0442232244u,\n                0442232244u));\n\nconst Tile T_BRIDGE_ENTR =\n    Tile(mat3(3, 2, 3,\n              3, 2, 3,\n              1, 2, 1),\n         .001,\n         S_L, false,\n         uint[](0442232244u,\n                0442232244u,\n                0442232244u,\n                0442232244u,\n                0772232277u,\n                0722232227u,\n                0122232221u,\n                0122232221u,\n                0122232221u));\n\nconst int NUM_TILES = 23;\n\nconst Tile[NUM_TILES] TILES = Tile[](\n    T_EMPTY,\n    T_GRASS,\n    T_ROAD_STRAIGHT,\n    T_ROAD_TURN,\n    T_ROAD_T,\n    T_ROAD_X,\n    T_REDB,\n    T_REDB_EDGE,\n    T_REDB_CORNER,\n    T_REDB_ENTR,\n    T_TREE,\n    T_PARK_ENTR,\n    T_PARK_CORN,\n    T_PARK_AISLE_A,\n    T_PARK_AISLE_B,\n    T_PARK_SPOT_A,\n    T_PARK_SPOT_B,\n    T_LAKE,\n    T_LAKE_EDGE,\n    T_LAKE_CORNER,\n    T_LAKE_ICORNER,\n    T_BRIDGE,\n    T_BRIDGE_ENTR\n);\n\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    float resolution;\n    float zoom;\n    float oldZoom;\n    vec2 center;\n    vec2 oldCenter;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.zoom = data0.y;\n    state.oldZoom = data0.z;\n    state.attract = data0.w != 0.;\n    state.center = data1.xy;\n    state.oldCenter = data1.zw;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.zoom, state.oldZoom, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.center, state.oldCenter);\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// The room where it happens.\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        if (TILES[i].selfConnect == false && int(n.x) == i) continue;\n        \n        mat3 myShape = TILES[i].shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if ((TILES[i].sym & (1 << ((d + 4 - r) % 4))) != 0 && tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES[g_ValidTiles[i]].shape, g_ValidTileRs[i] + r);\n        if (TILES[g_ValidTiles[i]].selfConnect == false && int(n.x) == g_ValidTiles[i]\n            || !tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    vec3 h = hash3(uvec3(fragCoord, iFrame));\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        if (h.x > .5)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 0.;\n            fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        }\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n       if (h.x < 1e-5)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + 1.1;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (g_NumValidTiles == 1 || h.z < TILES[g_ValidTiles[choice]].prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.zoom = 1./8.;\n        state.oldZoom = 1./8.;\n        state.center = vec2(0);\n        state.oldCenter = vec2(0);\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0. && iMouse.w < 0.)\n        {\n            state.attract = false;\n            if (keyDown(KEY_SHIFT))\n            {\n                vec2 delta = state.zoom * (iMouse.zw * vec2(1, -1) - iMouse.xy) / iResolution.y;\n                state.center = state.oldCenter + delta;\n            }\n            else\n            {\n                float mouseZoom = (iMouse.y + iMouse.w + iMouse.z - iMouse.x) / iResolution.y;\n                state.zoom = state.oldZoom * pow(2., 4. * mouseZoom);\n                if (mouseZoom < 0.)\n                {\n                    vec2 mouseCenter = (vec2(iMouse.z, -iMouse.w) - .5 * iResolution.xy) / iResolution.y;\n                    mouseCenter *= state.oldZoom;\n                    mouseCenter += state.oldCenter;\n                    state.center = mix(state.oldCenter, mouseCenter, min(1.,-5.*mouseZoom));\n                }\n            }\n        }\n        else\n        {\n            if (keyDown(KEY_UP))\n            {\n                state.zoom *= .9;\n            }\n            else if (keyDown(KEY_DOWN))\n            {\n                state.zoom *= 1.1;\n            }\n            \n            state.oldZoom = state.zoom;\n            state.oldCenter = state.center;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(iTime*.02), cos(iTime*.02));\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2XzD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2746, 2809, 2840, 2840, 2981], [2983, 3007, 3037, 3037, 3189], [3760, 3857, 3883, 3883, 4220], [4222, 4222, 4250, 4287, 4411], [4413, 4413, 4470, 4470, 5973]], "test": "untested"}
{"id": "DsSXWz", "name": "Flappybird on a 3d console?!", "author": "import_shader_steve", "description": "Controls:\nUp Arrow - Jump\nF - Toggle in/out screen mode\nMouse drag - pan around the console\n\nWait what?!?!", "tags": ["aweoifjew"], "likes": 6, "viewed": 187, "published": 3, "date": "1670143282", "time_retrieved": "2024-07-30T16:15:12.837041", "image_code": "#define MAX_STEPS 100\n#define SURF_DIST 0.01\n#define MAX_DIST 100.\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat degToRad(float deg) {\n    return deg / 180. * PI;\n}\n\nstruct Hit {\n    float d;\n    int id;\n};\n\nHit sdSphere( vec3 p, float s )\n{\n  float d = length(p)-s;\n  return Hit(d, 2);\n}\n\nHit sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  float x = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return Hit(x, 3);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return d;\n}\n\nHit sdBaseBox( vec3 p, vec3 b )\n{\n    //p.x -= abs(p.y + 1.);\n    //p.x -= abs(p.y);\n    //p.x -= abs(p.y) * abs(p.z);\n    //p.x -= 2.;\n    if (p.y > 0. && p.z < 0.) {\n       p.z += p.y; \n    }\n    float d = sdBox(p, b);\n    return Hit(d, 0);\n}\n\nHit sdMidBox1(vec3 p, vec3 b) {\n    if (p.z < 0.) {\n        p.z -= p.y;\n    }\n    float d = sdBox(p, b);\n    return Hit(d, 0);\n}\n\nHit sdMidBox2(vec3 p, vec3 b) {\n    if (p.z < 0.) {\n        p.z -= p.y * .3;\n    }\n    float d = sdBox(p, b);\n    return Hit(d, 0);\n}\n\nHit sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Hit(d, 0);\n}\n\nHit sdGround(vec3 p) {\n    float d = p.y;\n    return Hit(d, -1);\n}\n\nHit minWithId(Hit a, Hit b) {\n    if (a.d < b.d) return a;\n    return b;\n}\n\n// function to transform the screen\nvec3 transformScreen(vec3 p) {\n    p -= vec3(0., 3.3, 5.48);\n    p.yz *= Rot(degToRad(-16.5)); // transform the screen, need to rotate the textureUV to the same degree in mainImage()\n    return p;\n}\n\nHit GetDist(vec3 p) {\n    vec3 bp1 = p - vec3(0., 1., 6.);\n    //bp.xy *= Rot(iTime);\n    Hit dBaseBox = sdBaseBox(bp1, vec3(1.));\n    \n    vec3 bp2 = vec3(0., 2.3, 6.);\n    Hit dMidBox1 = sdMidBox1(p - bp2, vec3(1., .3, 1.));\n    \n    vec3 bp3 = vec3(0., 3.3, 5.8);\n    Hit dMidBox2 = sdMidBox2(p - bp3, vec3(1., .7, .3));\n    \n    vec3 bp4 = vec3(0., 4., 6.8);\n    Hit dTopBox = sdBaseBox(p - bp4, vec3(1.));\n    \n    vec3 bp5 = vec3(0., 2., 6.8);\n    Hit dBackBox = Hit(sdBox(p - bp5, vec3(1., 2., 1.)), 0);\n    \n    // sphere joystick tops\n    vec3 pSphere1 = vec3(-.5, 2.35, 4.5);\n    Hit dSphere1 = sdSphere(p - pSphere1, .07);\n    vec3 pSphere2 = vec3(.5, 2.35, 4.5);\n    Hit dSphere2 = sdSphere(p - pSphere2, .07);\n    \n    // cylinder joystick sticks\n    vec3 pCylinder1 = vec3(-.5, 2.2, 4.5);\n    Hit dCylinder1 = sdCappedCylinder(p - pCylinder1, .03, .2);\n    vec3 pCylinder2 = vec3(.5, 2.2, 4.5);\n    Hit dCylinder2 = sdCappedCylinder(p - pCylinder2, .03, .2);\n    \n    vec3 bpScreen = transformScreen(p);\n    float dScreen = sdBox(bpScreen, vec3(1., 1.*(iResolution.y/iResolution.x), .01));\n    int idScreen = 1;\n    Hit hitScreen = Hit(dScreen, idScreen);\n    \n    vec3 pGround = vec3(0., 0., 3.);\n    Hit dGround = sdGround(p - pGround);\n    \n    //float dScene = dSphere;\n    Hit dScene = minWithId(dBaseBox, dGround);\n    dScene = minWithId(dScene, dMidBox1);\n    dScene = minWithId(dScene, dMidBox2);\n    dScene = minWithId(dScene, dTopBox);\n    dScene = minWithId(dScene, dBackBox);\n    dScene = minWithId(dScene, dSphere1);\n    dScene = minWithId(dScene, dSphere2);\n    dScene = minWithId(dScene, dCylinder1);\n    dScene = minWithId(dScene, dCylinder2);\n    dScene = minWithId(dScene, hitScreen);\n    \n    return dScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = GetDist(p).d;\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy).d,\n        GetDist(p - e.yxy).d,\n        GetDist(p - e.yyx).d);\n    return normalize(n);\n}\n\n// make a light above the sphere\nvec3 lightPos = vec3(-2, 5, 3);\n\nfloat GetLight(vec3 p) {\n    //lightPos.xz = vec2(sin(iTime*2.), cos(iTime*2.)) * 5.;\n    vec3 lv = normalize(lightPos - p);\n    vec3 nv = GetNormal(p);\n    float rawLight = dot(lv, nv);\n    float finalLight = clamp(rawLight, 0., 1.);\n    return finalLight;\n}\n\n// old ray march function, cannot return Hit id. Further investigate what went wrong\n//Hit RayMarch(vec3 ro, vec3 rd) {\n//    Hit d0;\n//    for (int i = 0; i < MAX_STEP; i++) {\n//        vec3 p = ro + rd * d0.d;\n//        Hit ds = GetDist(p);\n//        d0.d += ds.d;\n//        if (ds.d < SURF_DIST || d0.d > MAX_DIST) break;\n//    }\n//    return d0;\n//}\n\nHit RayMarch(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n  Hit co; // closest object\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = GetDist(p);\n    depth += co.d;\n    if (co.d < SURF_DIST || depth > MAX_DIST) break;\n  }\n  \n  co.d = depth;\n  \n  return co;\n}\n\nfloat GetShadow(vec3 p) {\n    vec3 rd = normalize(lightPos - p);\n    vec3 pOffset = p + GetNormal(p) * SURF_DIST * 2.;\n    float ds = RayMarch(pOffset, rd).d;\n    float dl = length(p - lightPos);\n    if (ds < dl) {\n        return 0.1;\n    } else {\n        return 1.;\n    }\n}\n\n// input camera position, lookAt point, & zoomFactor, output camera ray direction\nvec3 makeCamera(vec3 ro, vec3 lookAt, float zoomFactor, vec2 uv) {\n    vec3 fVect = normalize(lookAt - ro);\n    vec3 rVect = normalize(cross(vec3(0., 1., 0.), fVect));\n    vec3 uVect = normalize(cross(fVect, rVect));\n    vec3 rd = normalize(uv.x * rVect + uv.y * uVect + zoomFactor * fVect);\n    return rd;\n}\n\nvec3 backgroundColor = vec3(1., 169./256., 20./256.);\nvec3 arcadeMachineColor = vec3(39./256., 73./256., 127./256.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy; //[0, 1]\n    vec3 col = vec3(0.);\n    \n    vec3 r0 = vec3(0., 5., -3.);\n    //ro.yz *= Rot(-m.y+.4);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    //vec3 lookAt = vec3(0., 3., 6.);\n    vec3 lookAt = vec3(0., 3.3, 5.48);\n    float rho = length(lookAt - r0);\n    // calculate camera origin based on mouse input, using sphere coordinates\n    vec3 r1 = vec3(0., 0., -3.);\n    float phi = (phiHigh-phiLow) * m.y + phiHigh;\n    r1.y = r0.y + rho * cos(phi);\n    float theta = (thetaHigh-thetaLow) * m.x + thetaLow;\n    theta *= 1.2;\n    r1.x = r0.x + length(lookAt-r1) * sin(theta);\n    r1.z = r0.z - length(lookAt-r1) * cos(theta);\n    // lookAt.x = sin(sin(iTime)*PI/6.);\n    // lookAt.y = sin((sin(iTime)/2.+0.5)*(PI*2.));\n    \n    float zoomFactor = texelFetch( iChannel1, ivec2(0,0), 0).x;\n    \n    vec3 rd = makeCamera(r1, lookAt, zoomFactor, uv);\n    \n    Hit d = RayMarch(r1, rd);\n    if (d.d > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        vec3 p = r1 + rd * d.d;\n        //float l = GetLight(p) * GetShadow(p);\n        float diff = GetLight(p); // diffuse lighting\n        vec3 differentColors = arcadeMachineColor;\n        if (d.id == 1) {\n            vec3 absNormals = abs(GetNormal(p));\n            // fiddle with the screen texture uv coords to get BufferB mapped onto the screen\n            // further investigate on what relationship between transformed 3D -> 2D coords\n            p = transformScreen(p);\n            vec2 textureUV = vec2(p.x*.5 + .5, p.y*.85-.52);\n            vec3 colXY = texture(iChannel0, textureUV).rgb;\n            differentColors = colXY * absNormals.z;\n        } else if (d.id == 2) {\n            differentColors = vec3(1., 0., 0.);\n        } else if (d.id == 3) {\n            differentColors = vec3(10.);\n        } else if (d.id == -1) {\n            vec3 floorColor = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n            differentColors = floorColor;\n        }\n        col += diff * differentColors + backgroundColor * .2;\n    }\n    \n    float fDigits = 6.0;\n\tfloat fDecimalPlaces = 4.0;\n    float printValue1 = phi;\n    col = mix(col, vec3(1.0, 0.5, 0.0), PrintValue(fragCoord, grid(-2,0), fontSize, printValue1, fDigits, fDecimalPlaces));\n    float printValue2 = theta;\n    //col = mix(col, vec3(1.0, 0.5, 0.0), PrintValue(fragCoord, grid(10,0), fontSize, printValue2, fDigits, fDecimalPlaces));\n    \n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec4 handleKeyboard(vec4 info) {\n    \n    float pressed = texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x;\n    // info.x -> pressedTime\n    // info.y -> elapsedTime\n    if (pressed == 1.) {\n        info.x = iTime;\n        info.y = 0.;\n    } else {\n        info.y += iTimeDelta;\n    }\n    // info.z -> current velocity\n    if (pressed == 1.) {\n        info.z = vJump;\n    } else {\n        info.z -= 30. * info.y / 1000.;\n    }\n    // info.w -> current height\n    info.w = clamp(info.w + info.z * iTimeDelta, low, high);\n\n    return info;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec4 info = texelFetch( iChannel0, ivec2(69, 0), 0).xyzw;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    info = handleKeyboard(info);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(info);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// Multiples of 4x5 work best\nconst vec2 fontSize = vec2(4,5) * vec2(5,5);\nvec2 grid(int x, int y) {\n    return fontSize.xx * vec2(1,ceil(fontSize.y/fontSize.x)) * vec2(x,y) + vec2(2);\n}\n\nconst float vJump = 0.6;\nconst float high = 0.9;\nconst float low = -0.9;\n\n\n\nconst float phiLow = PI*.375; // phi value when iMouse.y == 0.\nconst float phiHigh = PI*.5; // phi value when iMouse.y == 1.\n\nconst float thetaLow = PI*.5; // theta value when iMouse.x == 0.\nconst float thetaHigh = -PI*.5; // theta value when iMouse.x == 1.", "buffer_b_code": "float sdfCircle(vec2 uv, float r, float offset) {\n    float x = uv.x + iResolution.x/iResolution.y - r * 2.;\n    float y = uv.y - offset;\n    \n    float d = length(vec2(x, y)) - r;\n    \n    return step(0., -d);\n}\n\nvec3 drawCircle(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    // Fetch the offset from the XY part of the pixel values returned by Buffer A\n    float offset = texelFetch( iChannel0, ivec2(34,0), 0 ).w;\n    \n    float blueCircle = sdfCircle(uv, 0.1, offset);\n    \n    col = mix(col, vec3(0, 0, 1.), blueCircle);\n    \n    return col;\n}\n\nfloat sdfBox(vec2 uv, float width, float height) {\n    float horizontal = 1. - step(height/2., abs(uv.y));\n    float vertical = 1. - step(width/2., abs(uv.x));\n    return horizontal * vertical;\n}\n\nfloat drawPillars(vec2 uv, float x, float y, float width, float height) {\n    uv -= vec2(x, y);\n    return sdfBox(uv, width, height);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // [0.0 ~ 1.0]\n    uv -= 0.5; // [-0.5 ~ 0.5]\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    uv *= 2.; // [-1.0 ~ 1.0]\n\n    // draw the blue circle\n    vec3 col = drawCircle(uv);\n    \n    float fDigits = 6.0;\n\tfloat fDecimalPlaces = 4.0;\n    float pressedTime = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    //col = mix(col, vec3(1.0, 0.5, 0.0), PrintValue(fragCoord, grid(-2,0), fontSize, pressedTime, fDigits, fDecimalPlaces));\n    float elapsedTime = texelFetch(iChannel0, ivec2(0, 0), 0).y;\n    //col = mix(col, vec3(0.0, 0.5, 1.0), PrintValue(fragCoord, grid(10,0), fontSize, elapsedTime, fDigits, fDecimalPlaces));\n    float currentVelocity = texelFetch(iChannel0, ivec2(0, 0), 0).z;\n    //col = mix(col, vec3(0.5, 0.0, 1.0), PrintValue(fragCoord, grid(25,0), fontSize, currentVelocity, fDigits, fDecimalPlaces));\n    float currentHeight = texelFetch(iChannel0, ivec2(0, 0), 0).w;\n    //col = mix(col, vec3(0.0, 1.0, 0.0), PrintValue(fragCoord, grid(40,0), fontSize, currentHeight, fDigits, fDecimalPlaces));\n    \n    // draw the moving pillars\n    uv *= 1.5; // [-1.5, 1.5]\n    uv.x += iTime * 1.;\n    \n    float id = floor(uv.x);\n    float nXoffset = fract(sin(id * 234.12) * 5463.3) * 2. - 1.; // [-1., 1.]\n    \n    // the actual total height of top & bottom pillars on screen is actually half the totalHeight\n    // b/c half of both pillars are outside of the screen, not visible\n    const float totalHeight = 3.;\n    float nBottomHeight = fract(sin(id * 345.67) * 7891.2) * totalHeight; // [0., 2.5]\n    float nTopHeight = totalHeight - nBottomHeight;\n    \n    uv.x = fract(uv.x) - .5; // [-0.5, 0.5]\n    const float width = .3;\n    float x = .35 * nXoffset; // [-.35, .35], b/c 0.5 - 0.3/2 = 0.35\n    float y1 = -1.5;\n    float bottom_pillars = drawPillars(uv, x, y1, width, nBottomHeight);\n    col += mix(col, vec3(1., 1., 0.), bottom_pillars);\n    float y2 = 1.5;\n    float top_pillars = drawPillars(uv, x, y2, width, nTopHeight);\n    col += mix(col, vec3(1., 1., 0.), top_pillars);\n    \n    // if col == 'white', then means circle collides with pillars\n    if (col == vec3(1., 1., 1.)) {\n        col = vec3(0.);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// handle F - toggle zoomFactor\n\nconst float KEY_F = 70.5;\nconst float zoomSpeed = 10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoomFactor = texelFetch( iChannel0, ivec2(0,0), 0).x;\n    float toggle = texelFetch( iChannel1, ivec2(KEY_F,2),0 ).x;\n    if (toggle == 1.) {\n        zoomFactor = clamp(zoomFactor + iTimeDelta * zoomSpeed, 3., 15.);\n    } else {\n        zoomFactor = clamp(zoomFactor - iTimeDelta * zoomSpeed, 3., 15.);\n    }\n    fragColor = vec4(zoomFactor);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSXWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 163], [165, 165, 192, 192, 222], [266, 266, 299, 299, 346], [348, 348, 398, 398, 528], [530, 530, 559, 559, 667], [669, 669, 702, 804, 913], [915, 915, 946, 946, 1043], [1045, 1045, 1076, 1076, 1178], [1180, 1180, 1211, 1211, 1305], [1307, 1307, 1329, 1329, 1373], [1375, 1375, 1404, 1404, 1449], [1451, 1487, 1517, 1517, 1685], [1687, 1687, 1708, 1708, 3429], [3431, 3431, 3455, 3455, 3653], [3721, 3721, 3745, 3806, 3980], [4337, 4337, 4369, 4369, 4623], [4625, 4625, 4650, 4650, 4899], [4901, 4983, 5049, 5049, 5291], [5411, 5411, 5468, 5468, 7973]], "test": "untested"}
{"id": "dsBXWR", "name": "Graphic Design Experiment 5", "author": "yasuo", "description": "y2k fractal", "tags": ["graphicdesign", "cineshader", "y2k"], "likes": 14, "viewed": 2371, "published": 3, "date": "1670131429", "time_retrieved": "2024-07-30T16:15:13.783510", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SPEED 200.\n#define ZERO (min(iFrame,0))\n#define PI 3.141592653589793\n\n#define FS 0.1 // font size\n#define FGS FS/5. // font grid size\n\n#define char_0 0\n#define char_1 1\n#define char_2 2\n#define char_3 3\n#define char_4 4\n#define char_5 5\n#define char_6 6\n#define char_7 7\n#define char_8 8\n#define char_9 9\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat char1(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p,vec2(FGS,FS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(0.,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char2(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    d2 = B(p-vec2(FGS*2.,0.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(0.,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    p-=vec2(-FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat char3(vec2 p) {\n    vec2 prevP = p;\n    \n    p.y = abs(p.y);\n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    p = prevP;\n    p.x = abs(p.x);\n    float d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(FGS*2.,0.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n\n    p-=vec2(FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);   \n\n    return d;\n}\n\nfloat char4(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,-FGS*2.),vec2(FS,FGS));\n    \n    float d2 = B(p-vec2(-FGS*2.,0.),vec2(FGS,FS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(FGS*2.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n\n    return d;\n}\n\nfloat char5(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(0.,FGS*4.),vec2(FS,FGS));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p-vec2(-FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(-FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char6(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    \n    float d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p = prevP;\n    d2 = B(p-vec2(0.,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char7(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p,vec2(FS,FGS));\n    \n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    p = prevP;\n\n    \n    d2 = B(p-vec2(0., FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char8(vec2 p) {\n    vec2 prevP = p;\n    \n    p.y = abs(p.y);\n    float d = B(p-vec2(0., FGS*4.),vec2(FS,FGS));\n    \n    p = prevP;\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(FGS,FS*1.2));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char9(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(FGS*4.,FGS*2.),vec2(FGS,FGS*3.));\n    \n    p = prevP;\n    float d2 = B(p-vec2(FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(-FGS*2.,-FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n    \n    d2 = B(p,vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(-FGS*2.,FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p =prevP;    \n    p-=vec2(FGS*2.,-FGS*2.);\n    p*=Rot(radians(45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat char0(vec2 p) {\n    vec2 prevP = p;\n    \n    float d = B(p-vec2(-FGS*4.,0.),vec2(FGS,FS));\n    \n    float d2 = B(p-vec2(-FGS*2.,FGS*4.),vec2(FGS*3.,FGS));\n    d = min(d,d2);\n\n    d2 = B(p-vec2(0.0,-FGS*4.),vec2(FS,FGS));\n    d = min(d,d2);\n    \n    p-=vec2(FGS*2.,FGS*2.);\n    p*=Rot(radians(-45.));\n    d2 = B(p,vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    p =prevP;  \n    d2 = B(p-vec2(FGS*4.,-FGS*2.),vec2(FGS,FGS*3.));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat charMask(vec2 p, float d){\n    float a = radians(45.);\n    p = abs(p)-0.08;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    return d;\n}\n\nfloat drawFont(vec2 p, int char){\n    float d = char0(p)*checkChar(char_0,char);\n    d += char1(p)*checkChar(char_1,char);\n    d += char2(p)*checkChar(char_2,char);\n    d += char3(p)*checkChar(char_3,char);\n    d += char4(p)*checkChar(char_4,char);\n    d += char5(p)*checkChar(char_5,char);\n    d += char6(p)*checkChar(char_6,char);\n    d += char7(p)*checkChar(char_7,char);\n    d += char8(p)*checkChar(char_8,char);\n    d += char9(p)*checkChar(char_9,char);\n    \n    d = charMask(p,d);\n    \n    #ifdef OUTLINE\n        return abs(d)-0.005;\n    #endif\n    \n    return d;\n}\n\nfloat y2kItem0(vec2 p){\n    vec2 prevP = p;\n    float thick = 0.005;\n    float size = 0.1;\n    float d = abs(length(p)-size)-thick;\n    p.x*=2.0;\n    p.x = abs(p.x)-0.06;\n    float d2 = length(p)-0.02;\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(length(p)-0.08)-thick;\n    d2 = max(p.y+0.03,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat y2kItem1(vec2 p){\n    vec2 prevP = p;\n    float thick = 0.005;\n    float size = 0.1;\n    float d = abs(length(p)-size)-thick;\n    p.x*=2.0;\n    float d2 = abs(length(p)-size)-thick;\n    d = min(d,d2);\n    p = prevP;\n    \n    p.y*=2.0;\n    d2 = abs(length(p)-size)-thick;\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    d2 = max(abs(p.x)-size,abs(p.y)-thick);\n    d = min(d,d2);\n    d2 = max(abs(p.y)-size,abs(p.x)-thick);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat y2kItem2_1(vec2 p){\n    p.x*=2.;\n    vec2 prevP = p;\n    float size = 0.1;\n    p.x*=1.5;\n    float d = length(p)-size;\n    p-=vec2(0.025,-0.01);\n    p.x*=1.1;\n    float mask = length(p)-(size);\n    d = max(-mask,d);\n    return d;\n}\n\nfloat y2kItem2_2(vec2 p){\n    vec2 prevP = p;\n    p-=vec2(-0.01,0.015);\n    float d = y2kItem2_1(p);\n    p = prevP;\n    p+=vec2(-0.01,0.015);\n    p*=-1.;\n    float d2 = y2kItem2_1(p);\n    d = min(d,d2);\n    return d;\n}\n\nfloat y2kItem2(vec2 p){\n    p*=Rot(radians(5.));\n    vec2 prevP = p;\n    p*=Rot(radians(45.));\n    float d = y2kItem2_2(p);\n    p = prevP;\n    p*=Rot(radians(-45.));\n    float d2 = y2kItem2_2(p);\n    d = min(d,d2);\n    return d;\n}\n\nfloat y2kItem3(vec2 p){\n    p*=Rot(radians(20.*iTime));\n    vec2 prevP = p;\n    float thick = 0.005;\n    float size = 0.1;\n    p.x*=3.;\n    float d = abs(length(p)-size)-thick;\n    p = prevP;\n   \n    p.y*=3.;\n    float d2 = abs(length(p)-size)-thick;\n    d = min(d,d2);\n    p = prevP;\n    p*=Rot(radians(-45.));\n    p.x*=3.;\n    d2 = abs(length(p)-size)-thick;\n    d = min(d,d2);\n    p = prevP;\n    p*=Rot(radians(45.));\n    p.x*=3.;\n    d2 = abs(length(p)-size)-thick;\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat y2kItem4(vec2 p){\n    vec2 prevP = p;\n    float size = 0.1;\n    \n    float d = B(p,vec2(size));\n    p = abs(p)-size;\n    float d2 = length(p)-size;\n    d = max(-d2,d);\n    \n    return d;\n}\n\nfloat y2kItem5_1(vec2 p){\n    vec2 prevP = p;\n    float size = 0.1;\n    \n    float d = B(p,vec2(size*2., size));\n    float a = radians(-45.);\n    p.x = abs(p.x)-0.2;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    return d;\n}\n\nfloat y2kItem5(vec2 p){\n    vec2 prevP = p;\n    float size = 0.1;\n\n    float d = B(p,vec2(size*5.5, size));\n    float a = radians(-20.);\n    p.x-=0.5;\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    a = radians(-20.);\n    p.x+=0.5;\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    p = prevP;\n    d = max(-y2kItem5_1(p-vec2(-0.25,0.13)),d);\n    p-=vec2(0.25,-0.13);\n    p.y*=-1.;\n    d = max(-y2kItem5_1(p),d);\n    \n    p = prevP;\n    \n    p*=Rot(radians(45.));\n    p.x = abs(p.x)-0.04;\n    d = max(-(abs(p.x)-0.02),d);\n    \n    return abs(d)-0.005;\n}\n\nfloat y2kItem6(vec2 p, float dir){\n    p*=2.;\n    p.x+=iTime*0.2*dir;\n    p.x = mod(p.x,0.4)-.2;\n    p.x = abs(p.x)-0.1;\n    p.x*=-1.;\n    vec2 prevP = p;\n    float d = B(p,vec2(0.05,0.01));\n    p-=vec2(0.04,0.03);\n    float d2 = B(p,vec2(0.01,0.02));\n    d = min(d,d2);\n    p = prevP;\n    p-=vec2(-0.01,0.04);\n    d2 = B(p,vec2(0.06,0.01));\n    d = min(d,d2);\n    p = prevP;\n    p-=vec2(-0.08,0.0);\n    d2 = B(p,vec2(0.01,0.05));\n    d = min(d,d2);\n    p = prevP;\n    p-=vec2(0.01,-0.04);\n    d2 = B(p,vec2(0.08,0.01));\n    d = min(d,d2);\n    p = prevP;\n    p-=vec2(0.08,0.0);\n    d2 = B(p,vec2(0.01,0.05));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat y2kItem7(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(iTime*-25.));\n    p = DF(p,1.25);\n    p -= vec2(0.032);\n    p*=Rot( radians(45.));\n    float d = B(p,vec2(0.02,0.05));\n    p.x-=0.015;\n    p.y-=0.02;\n    p.y*=-1.;\n    float d2 = Tri(p,vec2(0.04,0.03),radians(45.));\n    d = min(d,d2);\n    \n    return abs(d)-0.005;\n}\n\nfloat y2kItem8(vec2 p){\n    vec2 prevP = p;\n    \n    p.x+=iTime*0.05;\n    p.x+=0.02;\n    p.x = mod(p.x,0.04)-0.02;\n    p.x+=0.02;\n    p*=Rot(radians(-90.));\n    float d = Tri(p,vec2(0.04,0.03),radians(45.));\n    p = prevP;\n    p.x+=iTime*0.05;\n    p.x+=0.02;\n    p.x = mod(p.x,0.04)-0.02;\n    p.x+=0.02;\n    p.x-=0.015;\n    p*=Rot(radians(-90.));\n    float d2 = Tri(p,vec2(0.04,0.03),radians(45.));\n    d = max(-d2,d);\n    \n    p = prevP;\n    d = max(abs(p.x)-0.06,d);\n    float a = radians(-45.);\n    p.x+=0.02;\n    p.y=abs(p.y);\n    d = max(-dot(p,vec2(cos(a),sin(a))),d);\n    \n    return d;\n}\n\nfloat y2kLine(vec2 p){\n    vec2 prevP = p;\n    \n    p*=3.;\n    p.x-=iTime*0.3;\n    p.x = mod(p.x,2.2)-1.1;\n    p.x-=0.45;\n    p.x+=1.;\n    float d = y2kItem5(p);\n    p.x-=0.65;\n    float d2 = y2kItem0(p);\n    d = min(d,d2);\n    p.x-=0.22;\n    \n    d2 = char0(p);\n    d2 = charMask(p,d2);\n    d = min(d,d2);\n    p.x-=0.22;\n    d2 = drawFont(p,int(mod(iTime*5.+3.,10.0)));\n    d = min(d,d2);\n    p.x-=0.22;\n    d2 = drawFont(p,int(mod(iTime*6.+4.,10.0)));\n    d = min(d,d2);\n    p.x-=0.23;\n    d2 = y2kItem7(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat y2kFractal(vec2 p){\n    vec2 prevP = p;\n    float d = 10.;\n    for(float i = 0.; i<3.; i++){\n        p*=Rot(radians(i*30.0+sin(i)*20.));\n        p = abs(p)-0.2;\n        p.y+=0.05;\n        float d2 = y2kLine(p);\n        d = min(d,d2);\n    }\n    \n    p = prevP;\n    d = max(abs(p.y)-0.42,d);\n    \n    return d;\n}\n\nfloat drawGraphic(vec2 p){\n    vec2 prevP = p;\n    float d = y2kFractal(p);\n    p.y+=0.45;\n    p.y*=-1.;\n    float d2 = y2kItem6(p,1.);\n    d = min(d,d2);\n    p = prevP;\n    p.y-=0.45;\n    d2 = y2kItem6(p,-1.);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x=abs(p.x)-0.35;\n    p*=1.8;\n    d2 = y2kItem1(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x=abs(p.x)-0.72;\n    p*=1.8;\n    d2 = y2kItem0(p);\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.y=abs(p.y)-0.31;\n    p*=1.2;\n    d2 = y2kItem2(p);\n    d = min(d,d2);\n    p.x=abs(p.x)-0.15;\n    p*=2.5;\n    d2 = y2kItem4(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x=abs(p.x)-0.58;\n    p.y = abs(p.y)-0.3;\n    p*=1.5;\n    d2 = y2kItem3(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x=abs(p.x)-0.47;\n    p.y = abs(p.y)-0.25;\n    p*=Rot(radians(45.));\n    p*=3.;\n    d2 = y2kItem4(p);\n    d = min(d,d2);\n        \n    p = prevP;\n    p.x=abs(p.x)-0.69;\n    p.y = abs(p.y)-0.37;\n    p*=3.;\n    d2 = y2kItem4(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x=abs(p.x)-0.23;\n    d2 = y2kItem8(p);\n    d = min(d,d2);\n    \n    p = prevP;\n    d = max(abs(p.x)-0.842,d);\n    return d;\n}\n\nfloat getRotAnimationValue(){\n    float frame = mod(iTime,15.0);\n    float time = frame;\n    float val = 0.;\n    float duration = 1.2;\n    if(frame>=1. && frame<4.){\n        time = getTime(time-1.,duration);\n        val = cubicInOut(time)*90.;\n    } else if(frame>=4. && frame<7.){\n        time = getTime(time-4.,duration);\n        val = 90.+cubicInOut(time)*90.;\n    } else if(frame>=7. && frame<10.){\n        time = getTime(time-7.,duration);\n        val = 180.+cubicInOut(time)*90.;\n    } else if(frame>=10. ){\n        time = getTime(time-10.,duration);\n        val = 270.+cubicInOut(time)*90.;\n    }\n    return val;\n}\n\nfloat getGlitchAnimationValue(){\n    float frame = mod(iTime,15.0);\n    float time = frame;\n    float val = 0.;\n    float duration = 1.6;\n    if(frame>=1. && frame<4.){\n        time = getTime(time-1.,duration);\n        val = 1.0-cubicInOut(time)*1.0;\n    } else if(frame>=4. && frame<7.){\n        time = getTime(time-4.,duration);\n        val = 1.0-cubicInOut(time)*1.0;\n    } else if(frame>=7. && frame<10.){\n        time = getTime(time-7.,duration);\n        val = 1.0-cubicInOut(time)*1.0;\n    } else if(frame>=10. ){\n        time = getTime(time-10.,duration);\n        val = 1.0-cubicInOut(time)*1.0;\n    }\n    return val;\n}\n\nvec3 boxAnim(vec3 p){\n    float val = getRotAnimationValue();\n    p.xz *= Rot(radians(val));\n    \n    return p;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p = boxAnim(p);\n    float d = sdBox(p,vec3(0.211,0.12,0.211));\n    \n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = vec3(0.0);\n    p = boxAnim(p);\n    vec2 uv = p.xy;\n    vec2 prevUV = uv;\n    \n    if(p.z>=0.){\n        // back\n        uv.x*=-1.;\n        float d = drawGraphic(uv*4.);\n        col = mix(col,vec3(1.),S(d,0.0));\n    } else {\n        // front\n        float d = drawGraphic(uv*4.);\n        col = mix(col,vec3(1.),S(d,0.0));\n    }\n    \n    uv = p.yz;\n    \n    if(p.x>=0.){\n        // right\n        uv.y*=-1.;\n        uv*=Rot(radians(90.));\n        float d = drawGraphic(uv*4.);\n        col = mix(col,vec3(1.),S(d,0.0));   \n    } else {\n        // left\n        uv*=Rot(radians(90.));\n        float d = drawGraphic(uv*4.);\n        col = mix(col,vec3(1.),S(d,0.0)); \n    }\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -0.45);\n    \n    /* // for debug\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    */\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );   \n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[824, 824, 851, 851, 935], [937, 937, 976, 976, 1021], [1023, 1083, 1126, 1126, 1226], [1228, 1286, 1317, 1317, 1408], [1410, 1410, 1431, 1431, 1658], [1660, 1660, 1681, 1681, 2244], [2246, 2246, 2267, 2267, 2697], [2699, 2699, 2720, 2720, 2964], [2966, 2966, 2987, 2987, 3421], [3423, 3423, 3444, 3444, 3897], [3899, 3899, 3920, 3920, 4177], [4179, 4179, 4200, 4200, 4517], [4519, 4519, 4540, 4540, 5106], [5108, 5108, 5129, 5129, 5578], [5580, 5580, 5622, 5622, 5682], [5684, 5684, 5716, 5716, 5824], [5826, 5826, 5859, 5859, 6397], [6399, 6399, 6422, 6422, 6737], [6739, 6739, 6762, 6762, 7206], [7208, 7208, 7233, 7233, 7445], [7447, 7447, 7472, 7472, 7665], [7667, 7667, 7690, 7690, 7897], [7899, 7899, 7922, 7922, 8408], [8410, 8410, 8433, 8433, 8604], [8606, 8606, 8631, 8631, 8835], [8837, 8837, 8860, 8860, 9400], [9402, 9402, 9436, 9436, 10050], [10052, 10052, 10075, 10075, 10381], [10383, 10383, 10406, 10406, 10978], [10980, 10980, 11002, 11002, 11529], [11531, 11531, 11556, 11556, 11847], [11849, 11849, 11875, 11875, 12987], [12989, 12989, 13018, 13018, 13610], [13612, 13612, 13644, 13644, 14238], [14240, 14240, 14261, 14261, 14353], [14355, 14355, 14377, 14377, 14498], [14500, 14500, 14558, 14558, 14825], [14827, 14827, 14851, 14851, 15052], [15054, 15054, 15096, 15096, 15291], [15293, 15293, 15352, 15352, 16054], [16056, 16056, 16113, 16113, 16830]], "test": "untested"}
{"id": "DdSXWz", "name": "a very weird EQ", "author": "jonasfrey", "description": "template", "tags": ["template"], "likes": 4, "viewed": 189, "published": 3, "date": "1670117590", "time_retrieved": "2024-07-30T16:15:14.542481", "image_code": "float f_n_dist_square(vec2 o, vec2 o_2){\n    vec2 o_delta = abs(o - o_2);\n    \n    return max(o_delta.x, o_delta.y);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n\n\n    vec2 o_scale = vec2(0.1);\n\n    vec2 o_fragCoord_scaled = (fragCoord.xy*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n    vec2 o_trpino_scaled = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    vec2 o_trpino_scaled_nooffset = (o_fragCoord_scaled_floor.xy)/ o_iResolution_scaled_floor.xy;\n\n    float n_index = o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x;\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    float n_amp_freqdomain = texture(iChannel0, vec2(o_trpino_scaled_nooffset.x, 0.0)).x;\n    float n_amp_timedomain = texture(iChannel0, vec2(o_trpino_scaled_nooffset.x, 1.0)).x;\n    //n_amp_freqdomain = abs(n_amp_freqdomain - 0.5);\n    float n_t = n_index_nor*n_amp_timedomain*1.+0.5;\n    float n_dist_square_tmod = fract(f_n_dist_square(o_fragCoord_scaled_fract, vec2(0.5))+n_t);\n\n    float n_dist_square_scaled_fract = f_n_dist_square(o_fragCoord_scaled_fract, vec2(0.5));\n    //n_dist_square_scaled_fract += texture(iChannel0, vec2(0.0,n_index_nor)).x;\n    //n_dist_square_scaled_fract += n_amp_freqdomain;\n    \n    n_dist_square_scaled_fract = fract(n_dist_square_scaled_fract);\n    fragColor = vec4(n_dist_square_tmod, n_index_nor,n_dist_square_scaled_fract,1.);\n    \n    //fragColor *= n_amp_freqdomain;\n\n}", "image_inputs": [{"id": 31103, "src": "https://soundcloud.com/richarddjames/aphex-twin-syro-009-syro-u473t8e-14198piezoluminescence-mix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSXWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 123], [124, 124, 181, 181, 1986]], "test": "untested"}
{"id": "csBSWz", "name": "square stuff", "author": "jonasfrey", "description": "just playing with colors", "tags": ["square", "warning"], "likes": 5, "viewed": 118, "published": 3, "date": "1670115804", "time_retrieved": "2024-07-30T16:15:15.285494", "image_code": "\nfloat f_n_dist_square(vec2 o, vec2 o2){\n    vec2 o_delta = abs(o2-o);\n    return max(o_delta.x, o_delta.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n\n    vec2 o_scale = vec2(0.02);\n\n    vec2 o_fragCoord_scaled = (fragCoord.xy*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n\n    \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n\n    \n\n    float n_index = o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x;\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    float n_t = sin(iTime)*0.5+0.5;\n    n_t = (iTime*.1);\n    float n_dist_sqr = f_n_dist_square(o_trpino, vec2(0.0));\n    n_dist_sqr = fract(sin(n_t)*0.5+0.5+n_dist_sqr);\n    n_dist_sqr = 1.-n_dist_sqr;\n    vec2 o_p = o_fragCoord_scaled_fract+vec2(-o_trmono);\n\n    float n_dist_sqr_scaled_fract = f_n_dist_square(o_fragCoord_scaled_fract+vec2(-0.5), vec2(0.0));\n    n_dist_sqr_scaled_fract = fract(n_t+n_dist_sqr_scaled_fract+n_index+n_t*10.);\n    \n    float n_dists_delta = abs(n_dist_sqr - n_dist_sqr_scaled_fract);\n    float n_dists_sum = n_dist_sqr + n_dist_sqr_scaled_fract;\n    float n_dists_product = n_dist_sqr * n_dist_sqr_scaled_fract;\n\n    \n    fragColor = vec4(\n        mix(n_dist_sqr,n_dist_sqr_scaled_fract, fract(n_dists_sum)),\n        mix(n_dist_sqr,n_dist_sqr_scaled_fract, (n_dists_delta)), \n        n_dists_product, \n        1.\n        \n    );\n    //fragColor = sqrt(fragColor);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 110], [111, 111, 168, 168, 1982]], "test": "untested"}
{"id": "cdlSDl", "name": "lower resolution template", "author": "jonasfrey", "description": "template", "tags": ["template"], "likes": 4, "viewed": 385, "published": 3, "date": "1670113070", "time_retrieved": "2024-07-30T16:15:16.031500", "image_code": "float f_n_inoutexp(float n, float n_sharpness){\n    n_sharpness = floor(n_sharpness) + mod(floor(n_sharpness),2.); // must be dividable by 2.\n    n = max(0.,min(1., n));\n    return min(pow(n, n_sharpness),pow( n-1., n_sharpness))*pow(2., n_sharpness);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 o_trpino = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trpino_nooffset = (fragCoord.xy )/ iResolution.y;\n    vec2 o_trmono = (iMouse.xy - iResolution.xy*0.5)/ iResolution.y;\n    vec2 o_trmono_nooffset = (iMouse.xy )/ iResolution.y;\n\n\n    vec2 o_scale = vec2(0.001);\n    float n_divisions = 10.;\n    float n_scale = floor(o_trpino_nooffset.x*n_divisions)/n_divisions;\n    //n_scale = n_scale * 0.1;\n    //o_scale = vec2(0.01+n_scale);\n    if(iMouse.z == 0.0){\n        o_trmono_nooffset = vec2(sin(iTime), cos(iTime*0.2)*0.2+0.2);\n    }\n    o_scale= vec2(o_trmono_nooffset.y);\n    if(o_trpino.x > o_trmono.x){\n        o_scale= vec2(0.1);\n    }\n    vec2 o_fragCoord_scaled = ((fragCoord.xy)*o_scale);\n    vec2 o_iResolution_scaled = (iResolution.xy * o_scale);\n\n    vec2 o_fragCoord_scaled_floor = floor(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_floor = floor(o_iResolution_scaled);\n    vec2 o_fragCoord_scaled_fract = fract(o_fragCoord_scaled);\n    vec2 o_iResolution_scaled_fract = fract(o_iResolution_scaled);\n       \n    vec2 o_trpino_scldfloor = (o_fragCoord_scaled_floor.xy - o_iResolution_scaled_floor.xy*0.5)/ o_iResolution_scaled_floor.y;\n    vec2 o_trpino_nooffset_scaledfloor = (o_fragCoord_scaled_floor.xy)/ o_iResolution_scaled_floor.xy;\n\n    float n_index = floor(o_fragCoord_scaled_floor.y * o_iResolution_scaled_floor.x + o_fragCoord_scaled_floor.x);\n    float n_index_nor = n_index / (o_iResolution_scaled_floor.x * o_iResolution_scaled_floor.y);\n    \n    \n    fragColor = vec4(\n        length(o_fragCoord_scaled_fract-vec2(0.5))\n    );\n    if(mod(n_index, 2.) == 1.){\n        fragColor = vec4(n_index_nor);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdlSDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 253], [254, 254, 311, 311, 1980]], "test": "untested"}
{"id": "msjSzm", "name": "Houndstooth with step()", "author": "mla", "description": "Variation showing fix for irregular 45° shape boundaries. LHS (cyan) shows artefacts on 45° slope, RHS (cream) offsets x by the magic quantity 0.382, and no artefacts appear. Other magic numbers should work too, but this one is nice.", "tags": ["procedural", "branchless", "houndstooth"], "likes": 3, "viewed": 139, "published": 3, "date": "1670095691", "time_retrieved": "2024-07-30T16:15:16.776508", "image_code": "//////////////////////////////////////////////////////////////////////////////\n//\n// Original code by @Offline, https://www.shadertoy.com/view/dsBSzw\n//\n// We should be able to get a 45° line on the screen by doing, eg:\n//\n// fragColor = vec4(step(x,p.x-p.y));\n//\n// but rounding errors in scaling mean that we might not get\n// a regular 1 up, 1 along pixel pattern, because sometimes\n// p.x and p.y are mathematically equal, but in fact are slightly different\n//\n// One fix is to round the difference to the nearest pixel boundary,\n// but an easier fix is to offset one coordinate so mathematical\n// equality is unlikely. Here we subtract 0.382 from the x-coordinate,\n// 0.382 = 1-0.618 and 0.618 = 1/φ, the Golden Ratio, is particularly hard\n// to approximate as a rational (of course, we are using an approximation\n// ourselves, but such is life and 0.382 seems to work well).\n//\n// 'x' uses 1-1 pixel scaling\n// <mouse> moves around image.\n//\n//////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    fragCoord -= 0.5*iResolution.xy;\n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.0) mouse = iMouse.xy - 0.5*iResolution.xy;\n    fragCoord -= mouse.xy;\n    if (!key(CHAR_X)) fragCoord = floor(fragCoord/4.0); // Bigger pixels\n    // 0.382 = 1-0.618\n    if (fragCoord.x > 0.0) fragCoord.x -= 0.382; // Offset one dimension\n    vec2 uv = fract(fragCoord / iResolution.y * ceil(1.0+mod(iTime,32.0)));\n    vec2 mask = step(0.5, uv);\n    float color = step(0.5, fract(abs(uv.x - uv.y) * 2.0));\n    color = max(color, min(mask.x, mask.y)) * max(mask.x, mask.y);\n    fragColor = vec4(color);\n    if (fragCoord.x > 0.0) fragColor.b *= 0.9; else fragColor.r *= 0.9;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1028, 1082, 1082, 1742]], "test": "untested"}
{"id": "mdjXRm", "name": "Three sine waves", "author": "fishy", "description": "This is so simple yet actually looks super cool", "tags": ["sine"], "likes": 7, "viewed": 190, "published": 3, "date": "1670093335", "time_retrieved": "2024-07-30T16:15:17.517527", "image_code": "#define s(a, b, c, d) 0.003/abs(sin(uv.x*a+iTime*c)*b-uv.y)*d\nvoid mainImage( out vec4 r, in vec2 d )\n{\n    vec2 uv = ((d.yx-iResolution.xy*0.5)/iResolution.y);\n    r = vec4(vec3(s(20., 0.05, 2.0, vec3(1, 0, 0))+s(20., 0.05, 2.1, vec3(0, 1, 0))+s(20., 0.05, 2.2, vec3(0, 0, 1))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 103, 103, 286]], "test": "untested"}
{"id": "DsSSzm", "name": "Trip simulation video filter", "author": "ilia87", "description": "A simulation of a trip. TRIP_HARDNESS can be modified in the Common tab\n\nFluid simulation adapted from:\n\nChimera's Breath\nby nimitz 2018\n", "tags": ["simulation", "fluid", "curl", "smoke", "dust", "navierstokes", "vorticity"], "likes": 3, "viewed": 410, "published": 3, "date": "1670092219", "time_retrieved": "2024-07-30T16:15:18.455020", "image_code": "// Adapted from:\n//\n// Chimera's Breath\n// by nimitz 2018 (twitter: @stormoid)\n// https://www.shadertoy.com/view/4tGfDW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSimulation code is in the \"common\" tab (and extra defines)\n\n\tThe main interest here is the addition of vorticity confinement with the curl stored in\n\tthe alpha channel of the simulation texture (which was not used in the paper)\n\tthis in turns allows for believable simulation of much lower viscosity fluids.\n\tWithout vorticity confinement, the fluids that can be simulated are much more akin to\n\tthick oil.\n\t\n\tBase Simulation based on the 2011 paper: \"Simple and fast fluids\"\n\t(Martin Guay, Fabrice Colin, Richard Egli)\n\t(https://hal.inria.fr/inria-00596050/document)\n\n\tThe actual simulation only requires one pass, Buffer A, B and C\tare just copies \n\tof each other to increase the simulation speed (3 simulation passes per frame)\n\tand Buffer D is drawing colors on the simulated fluid \n\t(could be using particles instead in a real scenario)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = textureLod(iChannel0, fragCoord/iResolution.xy, 0.);\n    if (fragCoord.y < 1. || fragCoord.y >= (iResolution.y-1.))\n        col = vec4(0);\n    fragColor = col;\n    vec4 vidCol = texture(iChannel2,uv);\n    //fragColor = mix(col,vidCol,clamp(1.-col.w+.5,0.,1.));\n    fragColor = mix(col,vidCol*1.0,clamp(0.24-TRIP_HARDNESS*.03*col.w,0.,1.));\n    //fragColor.xyz += mix(col.xyz,vidCol.xyz,(1.-length(col.xyz)*col.w));\n    //fragColor.xyz = vec3(col.w*.3);\n    //fragColor += texture(iChannel3,uv)*10.;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n/*\n\tThe main interest here is the addition of vorticity confinement with the curl stored in\n\tthe alpha channel of the simulation texture (which was not used in the paper)\n\tthis in turns allows for believable simulation of much lower viscosity fluids.\n\tWithout vorticity confinement, the fluids that can be simulated are much more akin to\n\tthick oil.\n\t\n\tBase Simulation based on the 2011 paper: \"Simple and fast fluids\"\n\t(Martin Guay, Fabrice Colin, Richard Egli)\n\t(https://hal.inria.fr/inria-00596050/document)\n\n\tThe actual simulation only requires one pass, Buffer A, B and C\tare just copies \n\tof each other to increase the simulation speed (3 simulation passes per frame)\n\tand Buffer D is drawing colors on the simulated fluid \n\t(could be using particles instead in a real scenario)\n*/\n\n#define TRIP_HARDNESS 1.5\n\n#define dt 0.15\n#define USE_VORTICITY_CONFINEMENT\n#define MOUSE_ONLY\n\n//Recommended values between 0.03 and 0.2\n//higher values simulate lower viscosity fluids (think billowing smoke)\n#define VORTICITY_AMOUNT 0.18\n\n\nconst int LaplacianKernelDeg = 5;\nconst int LaplacianKernelHalfDeg = 2;\n\nconst float LaplacianKernel[25] = float[25]\n(-0.00833333,  0.        , -0.06666667,  0.        , -0.00833333,\n 0.        ,  0.13333333,  1.06666667,  0.13333333,  0.        ,\n-0.06666667,  1.06666667, -4.5       ,  1.06666667, -0.06666667,\n 0.        ,  0.13333333,  1.06666667,  0.13333333,  0.        ,\n-0.00833333,  0.        , -0.06666667,  0.        , -0.00833333);\n\n//const int LaplacianKernelDeg = 3;\n//const int LaplacianKernelHalfDeg =1;\n//const float LaplacianKernel[9] = float[9]\n//(0.,.25,0.,\n// .25,-1.,.25,\n// 0.,.25,0.);\n\nfloat mag2(vec2 p){return dot(p,p);}\nvec2 point1(float t) {\n    t *= 0.62;\n    return vec2(0.12,0.5 + sin(t)*0.2);\n}\nvec2 point2(float t) {\n    t *= 0.62;\n    return vec2(0.88,0.5 + cos(t + 1.5708)*0.2);\n}\n\nvec4 CalcLaplacian(sampler2D smp, vec2 uv, vec2 w)\n{\n    vec4 L = vec4(0.);\n    for ( int i=0;i<LaplacianKernelDeg;++i)\n    {\n        for ( int j=0;j<LaplacianKernelDeg;++j)\n        {\n            vec2 coords = uv + vec2(w.x*float(i-LaplacianKernelHalfDeg),w.y*float(j-LaplacianKernelHalfDeg));\n            L += LaplacianKernel[i*LaplacianKernelDeg+j] * texture(smp,coords);\n        }\n    }\n    return L;\n}\n\nvec4 solveFluid(sampler2D smp, vec2 uv, vec2 w, float time, vec3 mouse, vec3 lastMouse, sampler2D smpForce)\n{\n\tconst float K = 0.1;\n\tconst float v = 0.85-TRIP_HARDNESS*.1;\n    \n    vec4 data = textureLod(smp, uv, 0.0);\n    vec4 tr = textureLod(smp, uv + vec2(w.x , 0), 0.0);\n    vec4 tl = textureLod(smp, uv - vec2(w.x , 0), 0.0);\n    vec4 tu = textureLod(smp, uv + vec2(0 , w.y), 0.0);\n    vec4 td = textureLod(smp, uv - vec2(0 , w.y), 0.0);\n    \n    vec3 dx = (tr.xyz - tl.xyz)*0.5;\n    vec3 dy = (tu.xyz - td.xyz)*0.5;\n    vec2 densDif = vec2(dx.z ,dy.z);\n    \n    data.z -= dt*dot(vec3(densDif, dx.x + dy.y) ,data.xyz); //density\n    data.z *= 0.95-.02*TRIP_HARDNESS; //density damp\n\n    vec2 laplacian = CalcLaplacian(smp,uv,w).xy;\n        \n    //vec2 laplacian =  tu.xy + td.xy + tr.xy + tl.xy - 4.0*data.xy;\n\n    vec2 viscForce = vec2(v)*laplacian;\n    data.xyw = textureLod(smp, uv - dt*data.xy*w, 0.).xyw; //advection\n    \n    vec2 newForce = vec2(0);\n    #ifndef MOUSE_ONLY\n    #if 1\n    newForce.xy += 0.75*vec2(.0003, 0.00015)/(mag2(uv-point1(time))+0.0001);\n    newForce.xy -= 0.75*vec2(.0003, 0.00015)/(mag2(uv-point2(time))+0.0001);\n    #else\n    newForce.xy += 0.9*vec2(.0003, 0.00015)/(mag2(uv-point1(time))+0.0002);\n    newForce.xy -= 0.9*vec2(.0003, 0.00015)/(mag2(uv-point2(time))+0.0002);\n    #endif\n    #endif\n    \n    if (mouse.z > 1. && lastMouse.z > 1.)\n    {\n        vec2 vv = clamp(vec2(mouse.xy*w - lastMouse.xy*w)*400., -6., 6.);\n        newForce.xy += .001/(mag2(uv - mouse.xy*w)+0.001)*vv;\n        data.z += exp(-mag2(uv - mouse.xy*w)*100.); //density addition\n    }\n    \n    vec4 forcePixel = texture(smpForce,uv);\n    float fpl = length(forcePixel.xyz);\n    float dfpx = dFdx(fpl);\n    float dfpy = dFdy(fpl);\n    //newForce.xy += 35.1*clamp(fpl,0.,1.)*vec2(dfpx,dfpy);\n    data.z += (2.5+.5*TRIP_HARDNESS)*fpl;\n    data.z = clamp(data.z,0.,1.);\n    \n    data.xy += dt*(viscForce.xy - K/dt*densDif + newForce); //update velocity\n    data.xy = max(vec2(0), abs(data.xy)-1e-4)*sign(data.xy); //linear velocity decay\n    \n    #ifdef USE_VORTICITY_CONFINEMENT\n   \tdata.w = (tr.y - tl.y - tu.x + td.x);\n    data.w += (1.5+.5*TRIP_HARDNESS)*fpl;\n    vec2 vort = vec2(abs(tu.w) - abs(td.w), abs(tl.w) - abs(tr.w));\n    vort *= VORTICITY_AMOUNT/length(vort + 1e-9)*data.w;\n    data.xy += vort;\n    #endif\n    \n    data.y *= smoothstep(.5,.48,abs(uv.y-0.5)); //Boundaries\n    data.x *= smoothstep(.5,.48,abs(uv.x-0.5)); //Boundaries\n    \n    data = clamp(data, vec4(vec2(-10), 0.5 , -10.), vec4(vec2(10), 3.0 , 10.));\n    \n    return data;\n}\n\n", "buffer_b_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nfloat length2(vec2 p){return dot(p,p);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveFluid(iChannel0, uv, w, iTime, iMouse.xyz, lastMouse.xyz, iChannel3);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n    if (fragCoord.y < 1./* && fragCoord.x<1.*/)\n        data = iMouse;\n    \n    fragColor = data;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\nfloat length2(vec2 p){return dot(p,p);}\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data = solveFluid(iChannel0, uv, w, iTime, iMouse.xyz, lastMouse.xyz, iChannel3);\n    \n    if (iFrame < 20)\n    {\n        data = vec4(0.5,0,0,0);\n    }\n    \n    if (fragCoord.y < 1./* && fragCoord.x<1.*/)\n        data = iMouse;\n    \n    fragColor = data;\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Chimera's Breath\n//by nimitz 2018 (twitter: @stormoid)\n\n//see \"Common\" tab for fluid simulation code\n\n#define COLOR_DAMP 0.0\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n//shader incoming relating to this palette\nvec3 getPalette(float x, vec3 c1, vec3 c2, vec3 p1, vec3 p2)\n{\n    float x2 = fract(x/2.0);\n    x = fract(x);   \n    mat3 m = mat3(c1, p1, c2);\n    mat3 m2 = mat3(c2, p2, c1);\n    float omx = 1.0-x;\n    vec3 pws = vec3(omx*omx, 2.0*omx*x, x*x);\n    return clamp(mix(m*pws, m2*pws, step(x2,0.5)),0.,1.);\n}\n\nvec4 pal(float x)\n{\n    vec3 pal = getPalette(-x, vec3(0.2, 0.5, .7), vec3(.9, 0.4, 0.1), vec3(1., 1.2, .5), vec3(1., -0.4, -.0));\n    return vec4(pal, 1.);\n}\n\nvec4 pal2(float x)\n{\n    vec3 pal = getPalette(-x, vec3(0.4, 0.3, .5), vec3(.9, 0.75, 0.4), vec3(.1, .8, 1.3), vec3(1.25, -0.1, .1));\n    return vec4(pal, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    vec4 simData = textureLod(iChannel0, uv, 0.);\n    vec2 velo = simData.xy;\n    vec4 col = textureLod(iChannel1, uv - dt*velo*w*3., 0.); //advection\n    if (fragCoord.y < 1. && fragCoord.x < 1.)\n        col = vec4(0);\n    vec4 lastMouse = texelFetch(iChannel1, ivec2(0,0), 0).xyzw;\n    \n    //if (iMouse.z > 1. && lastMouse.z > 1.)\n    //{\n    //    float str = smoothstep(-.5,1.,length(mo - lastMouse.xy/iResolution.xy));   \n    //    col += str*0.0009/(pow(length(uv - mo),1.7)+0.002)*pal2(-iTime*0.7);\n    //}\n    \n    #ifndef MOUSE_ONLY\n    col += .0025/(0.0005+pow(length(uv - point1(iTime)),1.75))*dt*0.12*pal(iTime*0.05 - .0);\n    col += .0025/(0.0005+pow(length(uv - point2(iTime)),1.75))*dt*0.12*pal2(iTime*0.05 + 0.675);\n    #endif\n    \n    \n    if (iFrame < 20)\n    {\n        col = vec4(0.);\n    }\n    \n    col = clamp(col, 0.,5.);\n    col = max(col - (col*0.004)*COLOR_DAMP, 0.); //decay\n    \n    if (fragCoord.y < 1. && fragCoord.x < 1.)\n        col = iMouse;\n\n    vec4 vidCol = texture(iChannel2,uv);\n    \n    //fragColor = mix(col,vidCol,0.01);\n    fragColor = mix(col,vidCol,clamp(.24-.08*(1. + TRIP_HARDNESS)*simData.z,0.,1.));\n    fragColor.w = simData.z;\n    \n}\n", "buffer_d_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 w = 1.0/iResolution.xy;\n    \n    //fragColor = texture(iChannel0,uv);\n    fragColor.xyz = CalcLaplacian(iChannel2,uv,w).xyz;\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSSzm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1107, 1107, 1164, 1164, 1720]], "test": "untested"}
{"id": "csjSRm", "name": "Codevember #5 Triangle", "author": "Etidou", "description": "Day 5 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["triangle", "motion", "codevember"], "likes": 9, "viewed": 187, "published": 3, "date": "1670082857", "time_retrieved": "2024-07-30T16:15:19.199031", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\nfloat poly(vec2 uv, float d) {\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(3);\n    float final = cos(floor(.5+a/v)*v-a)*r;\n    return max(abs(final), abs(final)) - d;\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2. - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 2.;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 25.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n\ttime = smootheststep(0.0, 1.0, time);\n\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  time;\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 25.) / 25.; // 25\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, poly(rotate(uv, -(rotateAmount + PI / 2.0) * time), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 206, 206, 318], [320, 320, 350, 350, 528], [530, 530, 586, 586, 688], [690, 690, 747, 747, 5979]], "test": "untested"}
{"id": "Ds2Xzw", "name": "Codevember #4 Octogone", "author": "Etidou", "description": "Day 4 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["motion", "codevember", "octogone"], "likes": 7, "viewed": 147, "published": 3, "date": "1670082837", "time_retrieved": "2024-07-30T16:15:19.997895", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\nfloat poly(vec2 uv, float d) {\n    float a = atan(uv.x,uv.y)+PI;\n    float r = length(uv);\n    float v = TAU/float(8);\n    float final = cos(floor(.5+a/v)*v-a)*r;\n    return max(abs(final), abs(final)) - d;\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 1.5;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 25.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n\ttime = smootheststep(0.0, 1.0, time);\n\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  time;\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, poly(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 25.) / 25.; // 25\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, poly(rotate(uv, -(rotateAmount + PI / 2.0) * time), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2Xzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 206, 206, 318], [320, 320, 350, 350, 528], [530, 530, 586, 586, 688], [691, 691, 748, 748, 5982]], "test": "untested"}
{"id": "cd2Xzw", "name": "Codevember #3 Expo Ease", "author": "Etidou", "description": "Day 3 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["square", "motion", "motion", "codevember", "ease"], "likes": 5, "viewed": 161, "published": 3, "date": "1670082786", "time_retrieved": "2024-07-30T16:15:20.761852", "image_code": "#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\nfloat square(vec2 uv, float d) {\n\treturn max(abs(uv.x), abs(uv.y)) - d;\t\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 1.5;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 15.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n\ttime = smootheststep(0.0, 1.0, time);\n\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  exponentialInOut((time / 2.0));\n\n        float animTimeB =  quadraticInOut(time);\n\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 40.) / 40.0;\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, square(rotate(uv, -(rotateAmount + PI / 2.0) * animTimeB), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd2Xzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 95, 95, 207], [209, 209, 241, 241, 283], [285, 285, 341, 341, 443], [445, 445, 476, 476, 548], [550, 550, 583, 583, 730], [733, 733, 790, 790, 6153]], "test": "untested"}
{"id": "csjXzw", "name": "Codevember #2 Quintic Ease", "author": "Etidou", "description": "Day 2 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["square", "motion", "codevember", "ease"], "likes": 4, "viewed": 133, "published": 3, "date": "1670082770", "time_retrieved": "2024-07-30T16:15:21.505863", "image_code": "#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n\nuniform float u_time;\nuniform vec2 u_resolution;\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\nfloat square(vec2 uv, float d) {\n\treturn max(abs(uv.x), abs(uv.y)) - d;\t\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 1.5;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 15.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n    time = mod((time / 2.0), 1.0);\n\ttime = smootheststep(0.0, 1.0, time);\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  qinticInOut(time);\n\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 40.) / 40.;\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, square(rotate(uv, -(rotateAmount + PI / 2.0) * time), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csjXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 145, 145, 257], [259, 259, 291, 291, 333], [335, 335, 391, 391, 493], [495, 495, 523, 523, 612], [616, 616, 673, 673, 6001]], "test": "untested"}
{"id": "cdjXzw", "name": "Codevember #1 Square", "author": "Etidou", "description": "Day 1 of Codevember 2022\n\nInstagram : https://www.instagram.com/etidouu/\nTwitter : https://twitter.com/EPEtidou", "tags": ["square", "motion", "codevember"], "likes": 4, "viewed": 103, "published": 3, "date": "1670082746", "time_retrieved": "2024-07-30T16:15:22.296748", "image_code": "#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n\n\nuniform float number;\n\nvec2 rotate(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA); \t\n}\n\nfloat square(vec2 uv, float d) {\n\treturn max(abs(uv.x), abs(uv.y)) - d;\t\n}\n\nfloat smootheststep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0) * 3.14159265;\n    return 0.5 - (cos(x) * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv *= 1.5;\n\t\n    float blurAmount = -0.005 * 1080.0 / iResolution.y;\n    \n\tfloat period = 15.0;\n\tfloat time = iTime / period;\n\ttime = mod(time, 1.0);\n\ttime = smootheststep(0.0, 1.0, time);\n\n\t\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n\tfor (int i = 0; i < 25; i++) {\n\t\tfloat n = float(i);\n\t\tfloat size = 1.0 - n / 25.0;\n\t\tfloat rotateAmount = (n * 0.5 + 0.25) * PI * 2.0; \n\n        float animTime =  time;\n\n        if(n < 1.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 2.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.184, 0.047, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 3.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.11, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 4.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.345, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 5.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.6, 0.941), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 6.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.051, 0.663, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 7.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0047, 0.835, 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 8.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 1., 0.808), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 9.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0., 0.91, 0.471), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 10.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.063, 0.91, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 11.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.369, 1.0, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 12.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.651, 0.91, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 13.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.98, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 14.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.808, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 15.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.78, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 16.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.62, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 17.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.6, 0.051), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 18.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.424, 0.047), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 19.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.29, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 20.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.125, 0.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 21.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(1., 0.051, 0.078), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 22.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.91, 0.047, 0.506), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 23.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.98, 0., 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 24.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.647, 0., 0.91), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        } else if(n < 25.) {\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.467, 0.051, 1.), smoothstep(0.0, blurAmount, square(rotate(uv, -rotateAmount * animTime), size)));\n        }\n\n\t\tfloat blackOffset = mix(1.0 / 4.0, 1.0 / 2.0, n / 4000.) / 4000.;\n\n\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(0.0, blurAmount, square(rotate(uv, -(rotateAmount + PI / 2.0) * time), size - blackOffset)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 118, 118, 230], [232, 232, 264, 264, 306], [308, 308, 364, 364, 466], [468, 468, 525, 525, 5807]], "test": "untested"}
{"id": "cdjSzm", "name": "Hyperdrive", "author": "kishimisu", "description": "Can you make it shorter ;) ?", "tags": ["raymarching", "colorful", "psychedelic", "rgb", "code", "golf", "golfing"], "likes": 31, "viewed": 669, "published": 3, "date": "1670079925", "time_retrieved": "2024-07-30T16:15:23.038764", "image_code": "/* @kishimisu - 2022\n\n   Code golfing time!\n   \n   A nice mix between an intended result and\n   happy bugs integrated as features along the way.\n   I only wish there was less aliasing.\n   \n   '#define k length(' could save 2 chars but it adds 4\n   spaces and less visibility so I didn't changed it\n*/\n\n#define t(g,o,l,f) mix(g, o, cos(l*(f+iTime*.1))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 F) {\n    float   g   , \n            o   , \n            l   , \n            f   = 3.;\n    vec2    i   = iResolution.xy,\n            n   = (F+F-i)/i.y;\n    for (;  g   ++ < 2e2 && f > .001;) {\n    \n        vec3 e = o*normalize(vec3(n, 1.));\n        e.z   += iTime*.5;\n        l      = floor(e.z+.5);\n        f      = 2.-length(e.xy)-o*.1;\n        e      = fract(e+.5)-.5;\n        o += f = .5*max(f, length(vec2(length(e.xy)\n                    -t(.1 ,.5,2.,l), e.z))\n                    -t(.05, t(.1,.4,.5,), 1., 1.6+l));       \n    } \n    O.rgb = (cos(o*8.+vec3(0,1,2)*.8)*5.) / exp(o*.2 + length(n));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Dd2Xzw", "name": "Another F# windows terminal", "author": "mrange", "description": "Another F# windows terminal shader\nRevisiting an old shader to see if it fits as a terminal background\n\n", "tags": ["2d", "complex"], "likes": 22, "viewed": 254, "published": 3, "date": "1670076965", "time_retrieved": "2024-07-30T16:15:23.790754", "image_code": "// Another F# windows terminal shader\n//  Revisiting an old shader to see if it fits as a terminal background\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define DOT2(x)     dot(x, x)\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n\n\nconst int max_iter = 5;\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 pmin(vec2 a, vec2 b, float k) {\n  vec2 h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 pabs(vec2 a, float k) {\n  return -pmin(-a, a, k);\n}\nfloat ref(inout vec2 p, vec2 r) {\n  float d = dot(p, r);\n  p -= r*min(0.0, d)*2.0;\n  return d < 0.0 ? 0.0 : 1.0;\n}\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat roundedX(vec2 p, float w, float r) {\n  p = abs(p);\n  return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec2 dfsharp(vec2 p) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  vec2 p3 = p;\n  const float sm = 0.03;\n  p0 = pabs(p0, sm);\n  const vec2 n = normalize(vec2(1.0));\n  float d0 = abs(dot(n, p0)-0.38)-0.12;\n  float d1 = abs(p1.x)-0.025;\n  float d2 = dot(n, p0)-0.19;\n  float d3 = -p3.x-0.025;\n  d2 = pmax(d2, -d3, sm);\n  float d = d0;\n\n  d = pmax(d, -d1, sm);\n  d = min(d,  d2);\n  return vec2(d, p.x > 0.0 ? 1.0 : 0.0);\n}\n\nconst mat2 rot45 = ROT(PI/4.0);\nconst mat2 irot45 = transpose(rot45);\nconst mat2 rot = ROT(-1.22);\nvec2 dfsharpWeekly(vec2 p, vec2 off) {\n  const vec2 refN = SCA(-PI/4.0);\n  const float r = 0.125;\n  const float rr = 2.0*r*sqrt(2.0);\n  vec2 p0 = p;\n  vec2 p1 = p-off;\n  p0 = abs(p0);\n  ref(p0, refN);\n  p0.y -= rr;\n  float d0 = roundedX(p0, rr, r);\n  float d1 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.0, 1.0))-r;\n  float d2 = segment(p1, rr*vec2(0.5, -0.5), rr*vec2(0.0, -1.0))-r;\n  float d3 = segment(p1, rr*vec2(-1.0, 0.0), rr*vec2(0.5, -1.5))-r;\n  float d = d0;\n  float dd = d1;\n  dd = min(dd, d2);\n  dd = min(dd, d3);\n  \n  return vec2(d, dd);\n}\n\nvec2 cell(vec2 p, float w) {\n  p *= irot45;\n  float z = 1.8*w;\n  p /= z;\n  vec2 d2 = dfsharp(p);\n  return vec2(d2.x*z, d2.y);;\n}\n\nfloat shape(vec2 p) {\n  const float z =2.8;\n  p *= rot;\n  p /= z;\n  vec2 off = vec2(-0.75,-0.35);\n  vec2 d2 = dfsharpWeekly(p+0.5*off, off)*z;\n  float d = d2.x;\n  d = min(d, d2.y);\n  return d;\n}\n\nfloat df(vec2 p, float zz, out int ii, out bool inside, out bool side) {\n  p /= zz;\n  const float or = 10.0;\n  vec2 off = sin(0.125*vec2(1.0, sqrt(0.5))*TIME/or)*or;\n  p += off;\n  p *= rot45;\n\n  float sz = 0.9;\n  vec2 pp = p;\n\n  float r = 0.0;\n\n  ii = max_iter;\n  for (int i=0; i<max_iter; ++i) {\n    pp = p;\n    vec2 nn = mod2(pp, vec2(sz));\n  \n    vec2 cp = nn*sz;\n    float d = shape(cp-off*rot45);\n    \n    r = sz*0.5; \n\n    if (abs(d) > 0.5*sz*sqrt(2.0)) {\n      ii = i;\n      inside = d < 0.0;\n      break;\n    }\n\n    sz /= 3.0;\n  }\n  \n  float w = 0.9*r;\n  vec2 d2 = cell(pp, w);\n  side = d2.y > 0.0;\n  return d2.x*zz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  const float r = 25.0;\n  float a = 0.05*TAU*TIME/r;\n  const float z = 1.0;\n  p /= z;\n  int i;\n  bool inside;\n  float zz = 1.0-0.5;\n\n  bool side;\n  float d = df(p, zz, i, inside, side)*z;\n  float ii = float(i)/float(max_iter);\n\n//  if (!inside) d = abs(d)-0.0075*smoothstep(1.0, 0.0, sqrt(ii));\n\n  vec3 col = vec3(0.0);\n\n  vec3 bcol0 = vec3(1.0, 0.0, 0.5).yzx;\n  vec3 bcol1 = sqrt(bcol0);\n  vec3 bcol = side ? bcol1 : bcol0;\n  if (!inside) bcol = 0.1*bcol.yyy;\n  bcol *= smoothstep(1.0, 0.125, ii);\n\n  col = mix(col, bcol, smoothstep(aa, -aa, d));\n  \n  col *= 1.*smoothstep(1.5, 0., length(pp));\n\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2Xzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 535, 571, 571, 665], [667, 767, 806, 806, 891], [894, 894, 933, 933, 962], [964, 964, 1000, 1000, 1084], [1086, 1086, 1114, 1114, 1142], [1143, 1143, 1176, 1176, 1257], [1258, 1376, 1418, 1418, 1477], [1479, 1597, 1636, 1636, 1748], [1750, 1750, 1772, 1772, 2157], [2258, 2258, 2296, 2296, 2809], [2811, 2811, 2839, 2839, 2939], [2941, 2941, 2962, 2962, 3135], [3137, 3137, 3209, 3209, 3763], [3765, 3765, 3820, 3820, 4613]], "test": "untested"}
{"id": "DdjSRw", "name": "impossible cube stack", "author": "FabriceNeyret2", "description": "maybe I should add 1 constraint between the 3 local relative order to avoid the hexagon case.\n\ngood luck for the smart-antialiasing version ;-)", "tags": ["2d", "cube", "escher", "tiling", "short", "golf", "3tweets"], "likes": 13, "viewed": 270, "published": 3, "date": "1670071860", "time_retrieved": "2024-07-30T16:15:24.581639", "image_code": "#define H(P) int( 1e3* sin( dot(P,R-17.) - ceil(iTime) )) % 2  < 1 // boolean rand \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, I,F,\n         U = 4.* u / R.y; // + .1*iTime;\n   U.x += .5*U.y;                                       // tilted 2D tiling\n   U.y /= .87;\n   I = ceil(U);                                         // tile Id\n   U = 3.*fract(U);                                     // subtiles\n   F = fract(U);\n   int c = 2*int(U) + 6*int(U.y) + int( F.x > F.y );    // subtile Id ( 18 triangles )\n   O = vec4(\n       U.x < U.y ?  c<8 ? .5 :  c>11 && c<15 ? 1. : .2  // up semi-tile\n                 :  c<3 ? H(I   ) ? 1. : c<2 ? .5 : .2  // down semi-tile\n                  : c<4 ? 1.\n                  : c<6 ? H(I+.3) ? .5 : c<5 ? 1. : .2  // H(): random relative order\n                  : c<10 ? .2                           //      of the 3 cubes\n                  : c==11? .5\n                  :       H(I+.7) ? .2 : c<17 ? .5 : 1.\n           );\n\n// O = vec4(c)/18.;\n// if (iMouse.z>0.) O += .3*vec4( mod(I.x+I.y,2.) ,0, U.x-U.y < 0. ,0);  // debug\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdjSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 123, 123, 1086]], "test": "untested"}
{"id": "ddSSRm", "name": "Tracing ray", "author": "Lincac", "description": "Violent pursuit", "tags": ["raytracing"], "likes": 3, "viewed": 158, "published": 3, "date": "1670058193", "time_retrieved": "2024-07-30T16:15:25.519133", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926535\n\n#define MAT_LAMBERTIAN 0\n#define MAT_METALLIC 1\n#define MAT_DIELECTRIC 2\n\nvec3 GammaCorrection(vec3 c){\n\treturn pow(c, vec3(1.0 / 2.2));\n}\n\nfloat pow5(float u){\n    float m2 = u * u;\n    return m2 * m2 * u;\n}\n\nvec3 lerp(vec3 x1,vec3 x2,float t){\n    return x1 + abs(x2 - x1) * t;\n}\n\nmat3 GetTransformMatrix(vec3 normal)\n{\n    // Choose a helper vector for the cross product\n    vec3 helper = vec3(1, 0, 0);\n    if (abs(normal.x) > 0.99f)\n        helper = vec3(0, 0, 1);\n\n    // Generate vectors\n    vec3 tangent = normalize(cross(normal, helper));\n    vec3 binormal = normalize(cross(normal, tangent));\n    return mat3(tangent, binormal, normal);\n}\n\nvec3 DiffuseBRDF(vec3 albedo)\n{\n    return albedo / PI;\n}\n\n//SampleHemisphere alpha = 1\nfloat CosinSamplingPDF(float NdotL)\n{\n    return NdotL / PI;\n}\n\nvec3 FresnelSchlick(float cosTheta, vec3 F0) // 近似反射程度\n{\n    return F0 + (1.0 - F0) * pow5(1.0 - cosTheta);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float nom = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = abs(dot(N, V));\n    float NdotL = abs(dot(N, L));\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nfloat Calculatefresnel(const vec3 I, const vec3 N, const float ior) // 计算折射率和反射率\n{\n    float kr;\n    float cosi = clamp(-1., 1., dot(I, N));\n    float etai = 1., etat = ior;\n    if (cosi > 0.)\n    {\n        //std::swap(etai, etat);\n        float temp = etai;\n        etai = etat;\n        etat = temp;\n    }\n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.f, 1. - cosi * cosi));\n    // Total internal reflection\n    if (sint >= 1.)\n    {\n        kr = 1.;\n    }\n    else\n    {\n        float cost = sqrt(max(0.f, 1. - sint * sint));\n        cosi = abs(cosi);\n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n        kr = (Rs * Rs + Rp * Rp) / 2.;\n    }\n    return kr;\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, vec3 V, float roughness)\n{\n    float a = roughness * roughness;\n\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\n    // from tangent-space vector to world-space sample vector\n    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\n    vec3 halfVec = tangent * H.x + bitangent * H.y + N * H.z;\n    halfVec = normalize(halfVec);\n    \n    return halfVec;\n\n}\n\nfloat ImportanceSampleGGX_PDF(float NDF, float NdotH, float VdotH)\n{\n    return NDF * NdotH / (4.0 * VdotH);\n}\n\nvec3 RefractionBTDF(float D, float G, vec3 F, vec3 V, vec3 L, vec3 N, vec3 H, float etaIn, float etaOut)\n{ //Not reciprocal! be careful about direction!\n    \n    float NdotL = abs(dot(N, L));\n    float NdotV = abs(dot(N, V));\n            \n    float VdotH = abs(dot(V, H));\n    float LdotH = abs(dot(L, H));\n            \n    \n    float term1 = VdotH * LdotH / (NdotV * NdotL);\n    vec3 term2 = etaOut * etaOut * (1. - F) * G * D;\n            //term1 = 1;\n            //term2 = 1;\n    float term3 = (etaIn * VdotH + etaOut * LdotH) * (etaIn * VdotH + etaOut * LdotH) + 0.001f;\n            //term3 = 1;\n    vec3 refractionBrdf = term1 * term2 / term3;\n    \n    return refractionBrdf;\n} \n\nvec3 SpecularBRDF(float D, float G, vec3 F, vec3 V, vec3 L, vec3 N)\n{        \n    float NdotL = abs(dot(N, L));\n    float NdotV = abs(dot(N, V));\n            \n    //specualr\n    //Microfacet specular = D * G * F / (4 * NoL * NoV)\n    vec3 nominator = D * G * F;\n    float denominator = 4.0 * NdotV * NdotL + 0.001;\n    vec3 specularBrdf = nominator / denominator;\n    \n    return specularBrdf;\n}\n\n", "buffer_a_code": "#define INF 114514.0\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nuint GetUintCore(inout uint u, inout uint v){\n\tv = uint(36969) * (v & uint(65535)) + (v >> 16);\n\tu = uint(18000) * (u & uint(65535)) + (u >> 16);\n\treturn (v << 16) + u;\n}\nfloat GetUniformCore(inout uint u, inout uint v){\n\tuint z = GetUintCore(u, v);\n\t\n\treturn float(z) / float(uint(4294967295));\n}\nfloat GetUniform(){\n    uint m_u = uint(521288629);\n    uint m_v = uint(362436069);\n\treturn GetUniformCore(m_u, m_v);\n}\nfloat rand(){\n\treturn GetUniform();\n}\n\nvec3 SampleHemisphere(vec3 normal, float alpha)\n{\n    // Sample the hemisphere, where alpha determines the kind of the sampling\n    float cosTheta = pow(rand(), 1.0f / (alpha + 1.0f));\n    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);\n    float phi = 2.0 * PI * rand();\n    vec3 tangentSpaceDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\n    // Transform direction to be centered around whatever noraml we need\n    return tangentSpaceDir * GetTransformMatrix(normal);\n}\n\nvec3 hdrColor(vec3 rd){\n    return texture(iChannel1,rd).rgb;\n}\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    float specular;\n    float specTrans;\n    float IOR;\n    vec3 transColor;\n    vec3 emission;\n};\n\nstruct Sphere{\n    float radius;\n    vec3 position;\n    \n    Material material;\n}sphere;\n\nstruct Hit{\n    bool is_hit;\n\n    float t;\n    vec3 position;\n    vec3 normal;\n    bool front;\n    \n    Material material;\n};\n\nbool HitSphere(Ray ray,inout Hit hit){\n    vec3 oc = ray.origin - sphere.position;\n\t\n\tfloat a = dot(ray.direction, ray.direction);\n\tfloat b = 2.0 * dot(oc, ray.direction);\n\tfloat c = dot(oc, oc) - sphere.radius * sphere.radius;\n\n\tfloat delta = b * b - 4. * a * c;\n\n    if(delta > 0.){\n        float temp = (-b - sqrt(delta)) / (2.0 * a);  \n        if(temp > 0. && temp < hit.t){\n            hit.is_hit = true;\n            \n            hit.t = temp;\n            hit.position = ray.origin + temp * ray.direction;\n            hit.normal = normalize((hit.position - sphere.position) / sphere.radius);\n            hit.front = dot(hit.normal,ray.direction) > 0. ? false : true;\n            \n            hit.material = sphere.material;\n            \n            return true;\n        }\n        temp = (-b + sqrt(delta)) / (2.0 * a);  \n        if(temp > 0. && temp < hit.t){\n            hit.is_hit = true;\n            \n            hit.t = temp;\n            hit.position = ray.origin + temp * ray.direction;\n            hit.normal = normalize((hit.position - sphere.position) / sphere.radius);\n            hit.front = dot(hit.normal,ray.direction) > 0. ? false : true;\n            \n            hit.material = sphere.material;\n            \n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 raymarch(Ray ray,in Hit hit){\n    vec3 result = vec3(0);\n    vec3 throughput = vec3(1);\n    \n    for(int i=0;i<4;i++){\n        float roulette = rand();\n        float blender = rand();//used to blend BSDF and BRDF\n        if(blender < 1.0 - hit.material.specTrans){ // just BRDF          \n        }\n        else{ // BSDF\n            vec3 N = hit.front ? hit.normal : -hit.normal;\n            vec3 bias = N * 0.001;\n            \n            float etai = 1.0;\n            float etat = hit.material.IOR;\n            \n            vec3 V = normalize(-ray.direction);\n            vec3 H = ImportanceSampleGGX(vec2(rand(),rand()),N,V,hit.material.roughness);\n            \n            vec3 F0 = vec3(0.08);\n            F0 = F0 * hit.material.specular;\n            vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);\n            \n            float kr = Calculatefresnel(ray.direction, hit.normal, etat);\n            float specularRoatio = kr;\n            float refractionRatio = 1.0 - kr;     \n            \n            vec3 L;\n            if (roulette <= specularRoatio)\n            {\n                ray.origin = hit.position + bias;\n                L = reflect(ray.direction, H);\n                ray.direction = L;\n            }\n            else\n            {\n                float eta = hit.front ? etai / etat : etat / etai;\n                L = normalize(refract(ray.direction, H, eta));\n                ray.origin = hit.position - bias;\n                ray.direction = L;\n                if (!hit.front)\n                {\n                    vec3 temp = L;\n                    L = V;\n                    V = temp;\n                    N = -N;\n                    H = -H;\n                }\n            }\n            float NdotL = abs(dot(N, L));\n            float NdotV = abs(dot(N, V));\n            \n            float NdotH = abs(dot(N, H));\n            float VdotH = abs(dot(V, H));\n            float LdotH = abs(dot(L, H));  \n            \n            float NDF = DistributionGGX(N, H, hit.material.roughness);\n            float G = GeometrySmith(N, V, L, hit.material.roughness);\n            \n             //specualr\n            vec3 specularBrdf = SpecularBRDF(NDF, G, F, V, L, N);\n            float speccualrPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            \n            //refraction\n            float etaOut = etat;\n            float etaIn = etai;\n            vec3 refractionBtdf = RefractionBTDF(NDF, G, F, V, L, N, H, etaIn, etaOut);\n            float refractionPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            \n            //BSDF = BRDF + BTDF\n            vec3 totalBrdf = (specularBrdf + refractionBtdf * hit.material.transColor) * NdotL;\n            float totalPdf = specularRoatio * speccualrPdf + refractionRatio * refractionPdf;\n            if(totalPdf < 0.0) break;\n            \n            throughput *= totalBrdf / totalPdf;\n            \n            vec3 Le = hit.material.emission;\n            result += Le * throughput;\n            \n            hit.is_hit = false;\n            hit.t = INF;\n            HitSphere(ray,hit);\n            if(!hit.is_hit){\n                return hdrColor(ray.direction) * result;\n            }\n        }\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Material material;\n    material.emission = vec3(0);          \n    material.albedo = vec3(1, 0.73, 0.25);\n    material.metallic = 0.0;\n    material.specular = 0.0;\n    material.specTrans = 1.0;\n    material.roughness = 0.0;\n    material.IOR = 1.5;\n    material.transColor = material.albedo;\n    \n    sphere.radius = 1.;\n    sphere.position = vec3(0);\n    sphere.material = material;\n    \n    vec2 uv = ((fragCoord + vec2(rand(),rand())) - .5 * iResolution.xy) / iResolution.y;\n    Ray ray;\n    ray.origin = vec3(0,0,5);\n    ray.direction = normalize(vec3(uv,ray.origin.z - 1.) - ray.origin);\n    \n    Hit hit;\n    hit.is_hit = false;\n    hit.t = INF;\n    HitSphere(ray,hit);\n    if(hit.is_hit){\n        vec3 col = raymarch(ray,hit);\n        col = GammaCorrection(col);\n\n        // average the frames together\n        vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        col = mix(lastFrameColor, col, 1.0f / float(iFrame+1));\n\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }else{\n        fragColor = vec4(hdrColor(ray.direction),1);\n    }\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 163]], "test": "untested"}
{"id": "dsBSzw", "name": "Branchless Houndstooth Pattern", "author": "Offline", "description": "A short and simple procedural Houndstooth pattern in both branched and branchless variations. \nBranchless variation has built in Anti-Aliasing as a side effect.", "tags": ["procedural", "branchless", "houndstooth"], "likes": 4, "viewed": 206, "published": 3, "date": "1670049871", "time_retrieved": "2024-07-30T16:15:26.260151", "image_code": "#define SHARPNESS 100.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fract(fragCoord / iResolution.y * 8.);\n\n    //vec2 mask = step(.5, uv); // With step()\n    vec2 mask = clamp((uv - .5) * SHARPNESS, 0., 1.); // Without step()\n   \n    //float color = step(.5, fract(abs(uv.x - uv.y) * 2.)); // With step()\n    float color = clamp((abs((fract(abs(uv.x-uv.y)*2.+.25)-.5)*2.)-.5)*SHARPNESS/5.,0.,1.); // Without step() \n    \n    color = max(color, min(mask.x, mask.y)) * max(mask.x, mask.y); // Masking\n    \n    fragColor = vec4(color);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 564]], "test": "untested"}
{"id": "msSXRw", "name": "animated pseudo-random noise", "author": "centucore", "description": "Created a prompt for ChatGPT and got a simple static noise output. Changed a bit to make it animated.", "tags": ["noise", "pseudorandom", "staticnoise", "chatgpt"], "likes": 2, "viewed": 267, "published": 3, "date": "1670039031", "time_retrieved": "2024-07-30T16:15:27.002168", "image_code": "float noise(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise2(vec2 co, float seed)\n{\n    vec4 s = vec4(seed, seed, seed, seed);\n    seed = fract(sin(dot(s.xyzw, vec4(123456789.0, 362436069.0, 521288629.0, 88675123.0))) * 43758.5453);\n    return fract(sin(dot(co.xy + s.xz ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Define the main function for the shader, which will be called once for each pixel on the screen\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the current position of the pixel in the coordinate space of the shader\n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    // Get noise for prev frame and current\n    float n1 = noise(st * (iTime - iTimeDelta));\n    float n2 = noise(st * iTime);\n\n    // Blend between prev & current -> animated\n    vec4 c1 = vec4(n1, n1, n1, 1.0);\n    vec4 c2 = vec4(n2, n2, n2, 1.0);\n    \n\n    fragColor = mix(c1, c2, n1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 95], [97, 97, 132, 132, 360], [362, 461, 518, 607, 942]], "test": "untested"}
{"id": "ddSXRw", "name": "Simple Absorb Effect", "author": "Cirno", "description": "A simple 2D effect.", "tags": ["2d"], "likes": 7, "viewed": 182, "published": 3, "date": "1670037653", "time_retrieved": "2024-07-30T16:15:27.743186", "image_code": "\nvec2 hash2(vec2 p)\n{\n    return fract(sin(p * mat2(1.29898, 8.1314, 7.8233,  1.5926)) * 4375.85453);\n}\n\nconst float PHASEGAP = 0.7f;\n\nfloat mapTime(float x) \n{\n    if(x<PHASEGAP)\n    {    \n        x = x/PHASEGAP;\n    }\n    else\n        x = 1.-(x-PHASEGAP)/(1.-PHASEGAP);\n    return x;\n}\n\nconst vec4 basicColor = vec4(0.2f,0.7f,1.0f,1.0f);\nconst vec4 dark1Color = vec4(0.867,0.247,0.914,1.0);\nconst vec4 dark2Color = vec4(0.);\n\nvec4 colorMap(float factor)\n{\n    vec4 color;\n    float f = 1.0f; //left values\n    float tempF;\n\n    tempF = smoothstep(0.0,0.85,factor);\n    color = tempF*basicColor;\n    f-=tempF;\n\n    tempF = smoothstep(0.0,0.45,factor)*f;\n    color += tempF*dark1Color;\n    f-=tempF;\n\n    color += f* dark2Color;\n\n    return color;\n}\n\nfloat dotSelf(vec2 v)\n{\n    return dot(v,v);\n}\n\nvoid frostBoomEffect(in vec2 uv, in float t,in float forks, out vec4 color) \n{\n    \n    \n    float centerDisNorm = length(uv)*0.7071067;// normalize distance to [0,1]\n    float deg = atan(uv.y,uv.x)*1.5915494580+t*t*2.+centerDisNorm*(1.+2.*t)*.5;\n    vec2 dir = uv;\n    vec2 vdir = vec2(uv.y,-uv.x);\n    color = vec4(0.);\n    // lines\n    {\n    float puv = fract(deg*forks*0.3);\n    float particlesEnergyLevel = step(0.7f,puv);\n    puv = (puv-0.7f)*3.333f;//[0,1]\n    float timeFactor = max(0.,t-0.4f);\n    float x2 = centerDisNorm*1.-(t-0.4f)*1.5;\n    float distanceFactor = (max(0.,-x2*(x2-0.4)*100.))*(1.2-centerDisNorm*1.75); //[0,0.2]\n    float edgeFactor = (.5-abs(.5-puv))*2.;\n    \n    float totalFactor = max(0.,timeFactor*distanceFactor)*edgeFactor;\n    particlesEnergyLevel*=totalFactor;\n    color += vec4(particlesEnergyLevel)*vec4(0.6,0.7,0.9,1.0);\n    }\n    \n    // the circle\n    {\n    float x = min(t*1.5f-centerDisNorm,1.0f); // to build a circle effect\n    float t2=mapTime(x);\n    \n    float distanceDecay = 1.-(centerDisNorm+.5)*t;\n    float energyLevel = max(0.,t2*distanceDecay);\n    energyLevel*=sin(deg*forks)*0.1+0.9;\n    \n    color+=colorMap(energyLevel)*vec4(0.2,0.7,0.9,1.0);\n    }\n    \n    \n    \n    //shinings\n    {\n    const float PXSIZE=10.0;\n    vec2 newUV = (uv+normalize(dir+vdir*t*t*10.)*4./(t*10.+1.))*PXSIZE;\n   \n    vec2 suv = fract(newUV);\n    newUV=floor(newUV)/PXSIZE;\n    vec2 noise = hash2(newUV);\n    float v = noise.x*noise.y*forks*0.3;\n    float distanceFactor = max(0.,1.-centerDisNorm*1.3);\n    float shiningFactor = step(0.5,v);\n    float smoothEdgeFactor = max(0.,.5*shiningFactor-dotSelf(suv-vec2(0.5))*2.);\n    smoothEdgeFactor*=smoothEdgeFactor;\n    float timeFadeFactor = mapTime(t);\n    float totalFactor=max(0.,shiningFactor*distanceFactor*smoothEdgeFactor*timeFadeFactor);\n    color += totalFactor*vec4(0.6,0.7,0.9,1.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x*=aspectRatio;\n    \n    uv = uv*2.0-1.0;\n    uv.x-=aspectRatio-1.;\n    float time = fract(-iTime*0.33f);\n    if(uv.x>1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    frostBoomEffect(uv,time,5.0,fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 103], [135, 135, 160, 160, 287], [428, 428, 457, 457, 749], [751, 751, 774, 774, 797], [799, 799, 877, 877, 2684], [2687, 2687, 2744, 2744, 3068]], "test": "untested"}
{"id": "mdSSRw", "name": "wet hair", "author": "lomateron", "description": "click to interact\nkey W to reset\n.xy = velocity\n.z = mass\nBuffer A tab applies some convolution and the result is in .xy\nthis result is added to the velocity in Buffer B tab\nBuffer C tab moves the velocity and mass using the velocity", "tags": ["fluid", "convolution"], "likes": 17, "viewed": 246, "published": 3, "date": "1670036647", "time_retrieved": "2024-07-30T16:15:28.489191", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = (vec4(length(a.xy),a.xy,0)*.4+.5)*pow(a.z,.3)*.8;\n    //fragColor = a;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec2  b = a2.xy-a.xy;\n        float d = length(a2.xy)-length(a.xy)*1.15;\n        r.xy += c*abs(d)*exp(-l*l*.16);\n        r.xy += c*dot(c,b)*exp(-l*l*.16)*.8;\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = u/iResolution.xy;\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*.25\n             -float(v.x<.01)*vec2(1,0)  //wall\n             -float(v.y<.01)*vec2(0,1)  //wall\n             +float(v.x>.99)*vec2(1,0)  //wall\n             +float(v.y>.99)*vec2(0,1); //wall;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j));\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j));\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/450.;\n        a += vec4(m*.5,0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        //vec2 m = 4.*(u*2.-iResolution.xy)/iResolution.y;\n        a = vec4(0,0,1,0);//-vec4(m,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdSSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 220]], "test": "untested"}
{"id": "DsBXRm", "name": " psychedelic scope", "author": "timmaffett", "description": "mouse reactive psychedelic fun", "tags": ["colors", "shading", "transparent"], "likes": 8, "viewed": 257, "published": 3, "date": "1670023568", "time_retrieved": "2024-07-30T16:15:29.240184", "image_code": "// Fork of \"transparent\" by pequalsnp. https://shadertoy.com/view/4sVfD3\n// 2022-12-02 23:20:40\n\nvec2 mouse;\n\nfloat Angle(vec3 v,vec3 u)\n{\n    return dot(v,u)/(length(v)*length(u));\n}\n\nfloat Delta(vec3 pos,vec3 spos)\n{\n    float a = Angle(pos,vec3(sin(iTime*0.15),cos(iTime*0.1),sin(iTime*0.1)));\n    \n\treturn  abs(length(pos-spos)\n               - 1.0\n               + 0.15*sin(mouse.x/mouse.y*13.0*pos.y + iTime)\n               - 0.15*sin(91.0*mouse.x*pos.x*pos.y + iTime)\n        \t   + 0.15*sin(71.0*mouse.y*a));\n}\n\nvec3 Normal(vec3 pos,vec3 spos) {\n    return normalize(pos-spos);\n}\n\nvec3 Col(vec3 pos,vec3 spos)\n{\n    vec3 norm = Normal(pos,spos);\n    return norm*Angle(norm,vec3(1.0,0.5,0.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n mouse = (iMouse.xy == vec2(0.)) ? vec2(0.75,0.25) : (iMouse.xy/iResolution.xy)-0.5;\n    \n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    \n\tvec3 pos = vec3(uv,0.0);\n    vec3 dir = pos - vec3(0.0,0.0,-1.5);\n    \n    vec3 spos = vec3(sin(iTime)*0.1,cos(iTime)*0.1,1.);\n    \n\tvec3 color  = vec3(0.0);\n    \n    int steps = 60;\n    for(int i = 0; i < steps; i++)\n    {\n        if(Delta(pos,spos) < 0.015)\n        {\n            color += Col(pos,spos)*(float(i)/float(steps));\n        }\n        pos += 0.01*dir;\n    }\n    \n\tcolor *= 0.35;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 138, 138, 183], [185, 185, 218, 218, 517], [519, 519, 552, 552, 586], [588, 588, 618, 618, 701]], "test": "untested"}
{"id": "DsBSRm", "name": "Fog #987413285", "author": "AmenShadertoy", "description": "Fog Particales", "tags": ["fog"], "likes": 1, "viewed": 86, "published": 3, "date": "1670021022", "time_retrieved": "2024-07-30T16:15:29.993170", "image_code": "float Circle(vec2 uv, float r1, float r2)\n{\n    float d = length(uv);\n    return smoothstep(r1, r2, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //float random = abs(sin(iTime));\n    \n    float cos1 = -cos(iTime / 2.1);\n    float cos2 = cos(iTime / 4.1) / 2.;\n    float cos3 = -cos(iTime / 6.4);\n    float cos4 = cos(iTime / 3.4) / 4.;\n    \n    float sin1 = sin(iTime / 8.1) / 8.;\n    float sin2 = -sin(iTime / 4.7);\n    float sin3 = sin(iTime / 1.5) / 16.;\n    float sin4 = -sin(iTime / 3.2);\n    \n    uv *= 3.;\n    \n    float circle = Circle(uv + vec2(cos1, sin1), .25 + abs(mix(0., sin(iTime / 7.5) * 2.1, .001)), .09  - abs(sin(iTime / 7.5)));\n    circle += Circle(uv + vec2(.5 + cos2, .1 + sin2), .5 + abs(mix(0., sin(iTime / 1.8) * 3.1, .09)), .02  - abs(sin(iTime / 1.8)));\n    circle += Circle(uv + vec2(-.5 + cos3, .1 + sin3), .75 + abs(mix(0., sin(iTime / 9.8) * 3.1, .03)), .02  - abs(sin(iTime / 9.8)));\n    circle += Circle(uv + vec2(0. + cos4, -.1 + sin4), .125 + abs(mix(0., sin(iTime / 5.2) * 3.1, .8)), .06  - abs(sin(iTime / 5.2)));\n    \n    circle += Circle(uv + vec2(1. + cos3, -.01 + sin3), .9 + abs(mix(0., sin(iTime / 9.1) * 3.1, .3)), .03  - abs(sin(iTime / 9.1)));\n    circle += Circle(uv + vec2(-1. + cos4, .19 + sin4), .4 + abs(mix(0., sin(iTime / 4.6) * 3.5, .02)), .06  - abs(sin(iTime / 4.6)));\n    circle += Circle(uv + vec2(0.63 + cos2, .9 + sin2), .3 + abs(mix(0., sin(iTime / 15.6) * 3.7, .09)), .04  - abs(sin(iTime / 15.6)));\n    circle += Circle(uv + vec2(0.08 + cos1, -.25 + sin1), .75 + abs(mix(0., sin(iTime / 2.5) * 5.3, .04)), .01  - abs(sin(iTime / 2.5)));\n    \n    circle += Circle(uv + vec2(1.5 + cos3, -.91 + sin3), .9 + abs(mix(0., sin(iTime / 9.1) * 3.9, .2)), .01  - abs(sin(iTime / 9.1)));\n    circle += Circle(uv + vec2(-1.9 + cos4, 2.19 + sin4), .35 + abs(mix(0., sin(iTime / 4.6) * 3.4, .07)), .1  - abs(sin(iTime / 4.6)));\n    circle += Circle(uv + vec2(1.63 + cos2, 2.1 + sin2), .6 + abs(mix(0., sin(iTime / 10.6) * 3.2, .03)), .09  - abs(sin(iTime / 10.6)));\n    circle += Circle(uv + vec2(2.28 + cos1, -3.85 + sin1), .1 + abs(mix(0., sin(iTime / 3.5) * 3.7, .001)), .025  - abs(sin(iTime / 3.5)));\n    \n    //if(d < .1)\n    //    c += smoothstep(.25, .05, d + 0.1);\n  \n    //float c = smoothstep(.5, 0., d + randomNum_D);\n\n    // Output to screen\n    fragColor = vec4(vec3(circle), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 105], [107, 107, 164, 214, 2615]], "test": "untested"}
{"id": "csBSzw", "name": "Lost memory", "author": "Issam_X_Mhadhbi", "description": "Lost memory", "tags": ["lostmemory"], "likes": 2, "viewed": 140, "published": 3, "date": "1670016438", "time_retrieved": "2024-07-30T16:15:30.771090", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 c = vec3(uv.x , cos(uv.x) + sin(uv.y) , uv.y ) ; \n    vec3 i = vec3(cos(uv.x*200.0 * iTime ) + sin(uv.y*200.0 * iTime)) ; \n\n    // Output to screen\n    fragColor = vec4(i,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 424]], "test": "untested"}
{"id": "csSXRw", "name": "rocka-byteless baby", "author": "timmaffett", "description": "A small experiment with my loved glowing neon lines.\ntweeked and made mouse-able - bounces, mouse effects hertz\nall credits to @bitless", "tags": ["2d", "lines", "glow", "neon"], "likes": 2, "viewed": 200, "published": 3, "date": "1670014175", "time_retrieved": "2024-07-30T16:15:31.582920", "image_code": "// Fork of \"Strange Wave no white\" by timmaffett. https://shadertoy.com/view/DdSXRw\n// 2022-12-02 20:46:18\n\n// Fork of \"Strange Wave\" by bitless. https://shadertoy.com/view/NdK3R3\n// 2022-12-02 20:34:36\n\n// Author: bitless\n// Title: Strange Wave\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define r( n ) fract(sin(n)*43758.5453) //random\n#define n(v) mix(r(floor(v)),r(floor(v)+1.),smoothstep(0.,1.,fract(v))) \n#define h(v) ( .6 + .6 * cos(6.3*(v) + vec4(0,23,21,0) ) ) //hue\n\nfloat myTime;\n\nvoid w(vec2 u, float s, inout vec4 C)\n{\n    float   t = n(u.x)*n(u.x-s-myTime)+.4 //top edge\n            ,b = n(u.x+5.)*n(u.x-9.-s-myTime)-.8; //bottom edge\n \n    C = mix(C, \n            h(s*.2+myTime*.3+u.x*.1), \n            pow(abs((u.y*0.4-b*1.1)/(t-b)-.5)*1.9,19.)+.15)*smoothstep(0.,115./iResolution.y,myTime*(t-u.y)*(u.y-b*0.9));\n}\n\nvoid mainImage( out vec4 C, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,u = (g+g-r)/r.y;\n  \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    \n    myTime = cos(iTime)*sin(iTime)* 3.4 * mouse.x/mouse.y;\n    u.x-=myTime/(5.*mouse.x);\n    for (float s = 1.5; s > 0.; s-=.1) {\n        w(u*vec2(4.,0.4+s),-s*0.4,C);\n        if(s>0.2) {\n            C.x = clamp(C.x,0.0,0.9/s+fract(iTime/71.0));\n            C.y = clamp(C.y,0.0,0.9/s+fract(iTime/91.0));\n            C.z = clamp(C.z,0.0,0.9/s+fract(iTime/93.0));\n        }\n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[727, 727, 766, 766, 1064], [1066, 1066, 1106, 1106, 1630]], "test": "untested"}
{"id": "cdSSRw", "name": "Interactive Kaleidoscope 2", "author": "timmaffett", "description": "A stranger symmetry.\nSome trippy places there with the mouse.. \nadded mouse and color action - tmm", "tags": ["kaleidoscope"], "likes": 1, "viewed": 208, "published": 3, "date": "1670011249", "time_retrieved": "2024-07-30T16:15:32.385773", "image_code": "// Fork of \"Simple Kaleidoscope 2\" by TekF. https://shadertoy.com/view/Xll3Wj\n// 2022-12-02 19:47:33\n\nconst float tau = 6.2831853;\n    \n  \nvec4 hsb2rgb( in vec4 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return vec4(c.z * mix( vec3(1.0), rgb, c.y), 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) * 7.2 / iResolution.y;\n    \n vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(1.0) : iMouse.xy/iResolution.xy;\n    mouse.x = clamp(mouse.x, 0.25, 0.75 );\n    mouse.y = clamp(mouse.y, 0.25, 0.75 );\n    float r = 1.0 * 1./fract(cos(iTime/10.0/41.*31.));\n    r = clamp( r, 0.5, 1.0 );\n    float a = iTime*.1;\n    float c = cos(a)*r * clamp(mouse.x/mouse.y, 0.4, 1.0);\n    float s = sin(a)*r * clamp(mouse.y/mouse.x, 0.4, 1.0);\n    for ( int i=0; i<10; i++ )\n    {\n    \t//uv = abs(uv);\n        \n        // higher period symmetry\n        float t = atan(uv.x,uv.y);\n        const float q = 7. / tau;\n\t\tt *= q;\n        t = abs(fract(t*.5+.5)*2.0-1.0);\n        t /= q;\n        uv = length(uv)*vec2(sin(t),cos(t));\n        \n        uv -= .7;\n        uv = uv*c + s*uv.yx*vec2(1,-1);\n    }\n    vec4 ff = hsb2rgb( vec4(length(uv)*c*s*a, 1., 1., 1.) );\n    vec4 fc = .5+.5*sin(iTime+vec4(13,17,23,1)*texture( iChannel0, uv*vec2(1,-1)+.5, -1.0 ));\n     fragColor = mix( ff, fc, 0.7 );\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) * 5. / iResolution.y;\n\n    float r = 1.0;\n    float a = iTime*.1;\n    float c = cos(a)*r;\n    float s = sin(a)*r;\n    for ( int i=0; i<32; i++ )\n    {\n    \tuv = abs(uv);\n        uv -= exp(float(-2*i))+.1;\n        uv = uv*c + s*uv.yx*vec2(1,-1);\n    }\n        \n    fragColor = .5+.5*sin(iTime+vec4(13,17,23,1)*texture( iChannel0, clamp( uv*vec2(1,-1)+.5, .0, 1. ), -1.0 ));\n}*/", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdSSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 166, 166, 409], [412, 412, 469, 469, 1481]], "test": "untested"}
{"id": "dd2SzD", "name": "A colorful, Beautiful Mind", "author": "timmaffett", "description": "A signed distance field font experiment\n-just added some mouse interaction and color to original -tmm", "tags": ["sdf", "font", "hsb"], "likes": 7, "viewed": 344, "published": 3, "date": "1670008997", "time_retrieved": "2024-07-30T16:15:33.206579", "image_code": "// Fork of \"A Beautiful Mind\" by azirafail. https://shadertoy.com/view/td3SRf\n// 2022-12-02 19:02:54\n\nfloat letter(float ix, vec2 uv)\n{\n    vec2 ixOffset = vec2(mod(ix, 16.), -floor(ix/16.)) + vec2(0.5,-0.5);\n    \n    vec2 ixUv = (ixOffset + clamp(uv, -0.5,0.5))/16.;\n    \n    float texD = texture(iChannel0, ixUv).a;\n\n    return smoothstep(0.5,0.499,texD);\n}\n\nfloat noise(float x)\n{\n    return fract(sin(x * 523.) * 757.);\n}\nfloat noise2(vec2 uv)\n{\n    return fract(sin(uv.x * 523.) * 757. + cos(uv.y * 871.) * 721.);\n}\nvec3 noise3(float x)\n{\n    return vec3(\n    \tnoise(x * 23. + 61.),\n        noise(x * 41. + 31.),\n        noise(x * 93. + 37.)\n    );\n}\n\nfloat symbol(float i) {\n    float n = floor(i * 52.);\n    if (n < 32.) {\n\t    return 128. + n;\n    }\n    return 48. + mod(n - 32., 10.);\n}\n\nstruct ray {\n    vec3 o, d;\n};\n\nray camera(vec2 uv, vec3 o, vec3 t, vec3 up, float zoom) {\n\n    vec3 d = normalize(t - o);\n    vec3 camRight = -cross(d, normalize(up));\n    vec3 camUp = cross(d, camRight);\n\n    ray r;\n    r.d = normalize(d + (camRight * uv.x + camUp * uv.y) / zoom);\n    r.o = o;\n    return r;\n}\n\nstruct prox {\n    vec3 o, p;\n    float d, r;\n};\n    \nprox proximity(ray r, vec3 p) {\n    prox pr; \n    pr.r = dot(r.d, p);\n    pr.p = r.o + r.d * pr.r;\n    pr.o = pr.p - p;\n    pr.d = length(pr.o);\n    pr.o /= pr.d;\n    return pr;\n}\n\nfloat sphere(prox p, float r) {\n    return sqrt(abs(r * r - p.d * p.d));\n}\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * iResolution.xy/iResolution.y; \n    \n    vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.5,0.2) : iMouse.xy/iResolution.xy;\n    \n    mouse.x *= mod(iTime,23.)/10.0;\n    mouse.y *= mod(iTime,31.)/10.0;\n    \n\tray cam = camera(uv, vec3( mouse.x* sin(0. * iTime/17.) * 5.,1.3, mouse.y* cos(0. * iTime / 17.) * 5.), vec3(0.+mouse.x,1.+mouse.y,0.), vec3(0.+mouse.y,1.+mouse.x,0.), mouse.x*1.); \n    \n    vec3 col;\n    \n    for (float i = 0.; i < 7.; i++) {\n        float n = noise(i);\n\n        vec3 p = vec3(20. * cos(iTime / (19. + n) + n * 37.),2.,20. * sin(iTime / (23. - n) + n * 91.));\n        prox pr = proximity(cam, p);\n\n        float d = sphere(pr, sin(iTime / 41. + n * 53.) * 4. + 5.);\n\n        vec3 s = cam.o + cam.d * (pr.r - d);\n\n        vec2 wuv = (s-p).xy;\n        float off = noise(floor(wuv.x)) - 0.5;\n        wuv += vec2(0., off * iTime * 3.);\n\n        float ix = symbol(noise2(floor(wuv) + n));\n\n\n        vec2 tuv = fract(wuv) - 0.5;// * pr.d;\n            tuv.y *= -1.;\n\n        float f = step(0.5, noise2(floor(mod(wuv,100.)) * 341.));\n\n        // pick hue based on ix and off, brightness to 2. so mix is brighter\n        vec3 letterColor = hsb2rgb( vec3(ix*off, 1., 3.) );\n\n        // Time varying pixel color\n        col += vec3(letter(ix, tuv)) / (0.2 * abs(pr.d)) * f * mix(noise3(i), letterColor, 0.7);\n        //col.rg = tuv;\n    }\n    //col.r = noise2(floor(ouv * scale));\n\n    // Output to screen\n    fragColor = vec4(col,1.0) * (1.- length(uv) / 2.);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd2SzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 135, 135, 359], [361, 361, 383, 383, 425], [426, 426, 449, 449, 520], [521, 521, 543, 543, 655], [657, 657, 680, 680, 795], [829, 829, 887, 887, 1109], [1164, 1164, 1195, 1195, 1343], [1345, 1345, 1376, 1376, 1419], [1422, 1422, 1449, 1449, 1684], [1687, 1687, 1744, 1744, 3267]], "test": "untested"}
{"id": "mdjXzD", "name": "chatGPT: six 'hearts'", "author": "elenzil", "description": "six results from prompts like \"a shadertoy glsl program that uses polar coordinates to render a cardioid heart. please include variable names in the style of john donne.\"", "tags": ["chatgpt"], "likes": 6, "viewed": 240, "published": 3, "date": "1670008585", "time_retrieved": "2024-07-30T16:15:33.948595", "image_code": "// via https://chat.openai.com/chat\n\n// version 2 needed a little human help (defining pi, changing '3' to '3.0'),\n// but all the others are unmodified.\n\n// the first few were simple \"shadertoy to draw a heart\",\n// then I added a request for john donne style (hilarious that version 4 mistook TS Eliot for J. Donne!)\n// and then threw in some hints like \"polar coordinates\" or \"cardioid\".\n\n\n\n\n\n/////////////////////////////////////////////////////////////////////////\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x);\n    float f = abs(sqrt(abs(cos(r * 10.0 - theta * 3.0))) - 0.9);\n    fragColor = vec4(f, f, f, 1.0);\n}\n\n\n/////////////////////////////////////////////////////////////////////////\n\nconst float pi = 3.14159265359;\n\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // create a heart shape using bezier curves\n    float x = pow(sin(uv.x*pi),3.0);\n    float y = (13.0*cos(uv.x*pi) - 5.0*cos(2.0*uv.x*pi) - 2.0*cos(3.0*uv.x*pi) - cos(4.0*uv.x*pi))/16.0;\n\n    // color the heart\n    vec3 col = vec3(1.0, 0.5+0.5*y, 0.5+0.5*x);\n\n    // output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n/////////////////////////////////////////////////////////////////////////\n\n// This is a simple GLSL shader that uses the distance function\n// to create a heart shape.\n\nvoid mainImage3(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Calculate the distance from the center of the screen.\n  float d = distance(uv, vec2(0.0));\n\n  // Use the distance to create a heart shape.\n  float heart = smoothstep(0.8, 0.5, d) - smoothstep(0.5, 0.3, d);\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(heart, 0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// Let us go then, you and I,\n// When the evening is spread out against the sky\n// Like a patient etherized upon a table;\n\nvoid mainImage4(out vec4 fragColor, in vec2 fragCoord) {\n  // Let us go, through certain half-deserted streets,\n  // The muttering retreats\n  // Of restless nights in one-night cheap hotels\n  // And sawdust restaurants with oyster-shells:\n\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Convert the cartesian coordinates to polar coordinates.\n  float r = length(uv);\n  float theta = atan(uv.y, uv.x);\n\n  // Use the polar coordinates to create a heart shape.\n  float heart = smoothstep(0.8, 0.5, r) - smoothstep(0.5, 0.3, r);\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(heart, 0.0, 0.0, 1.0);\n\n  // Streets that follow like a tedious argument\n  // Of insidious intent\n  // To lead you to an overwhelming question ...\n  // Oh, do not ask, \"What is it?\"\n  // Let us go and make our visit.\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// Oh heart, so bright and red,\n// Thou dost beat within my chest,\n// And fill my every thought with zest,\n// Oh heart, how bold thou art.\n\nvoid mainImage5(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Convert the Cartesian coordinates to polar coordinates.\n  vec2 polar = vec2(length(uv), atan(uv.y, uv.x));\n\n  // Use the polar coordinates to create a heart shape.\n  float heart = smoothstep(0.8, 0.5, polar.x) - smoothstep(0.5, 0.3, polar.x);\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(heart, 0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// Oh heart, my heart, thy name doth lend\n// A thousand virtues to that simple word,\n// And all thy pulses do but speak and mend\n// The love and admiration that is stirred.\n\nvoid mainImage6(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize the fragment coordinates to be in the range [-1, 1].\n  vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n  // Convert the Cartesian coordinates to polar coordinates.\n  vec2 polar = vec2(length(uv), atan(uv.y, uv.x));\n\n  // Use the polar coordinates to create a cardioid shape.\n  float cardioid = (1.0 + cos(polar.y)) * polar.x;\n\n  // Set the color based on the distance from the center.\n  fragColor = vec4(cardioid, 0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    float t = iTime * 0.4 + 0.5;\n\n    uint n = uint(t) % 6u;\n    \n    switch(n + 1u) {\n        case 1u:\n            mainImage1(RGBA, XY);\n            break;\n        case 2u:\n            mainImage2(RGBA, XY);\n            break;\n        case 3u:\n            mainImage3(RGBA, XY);\n            break;\n        case 4u:\n            mainImage4(RGBA, XY);\n            break;\n        case 5u:\n            mainImage5(RGBA, XY);\n            break;\n        case 6u:\n            mainImage6(RGBA, XY);\n            break;\n    }\n    \n    float f = fract(t + 0.5);\n    float m = smoothstep(0.1, 0.0, abs(f - 0.5));\n    RGBA.rgb = mix(RGBA.rgb, vec3(0.8), m);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjXzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[469, 469, 527, 527, 795], [907, 907, 965, 994, 1355], [1526, 1526, 1582, 1650, 2011], [2211, 2211, 2267, 2518, 3105], [3322, 3322, 3378, 3446, 3844], [4095, 4095, 4151, 4219, 4595], [4672, 4672, 4715, 4715, 5359]], "test": "untested"}
{"id": "ds2SzD", "name": "Julia Set Fractal 1337", "author": "ahmetsait", "description": "https://en.wikipedia.org/wiki/Julia_set", "tags": ["fractal"], "likes": 1, "viewed": 133, "published": 3, "date": "1670008059", "time_retrieved": "2024-07-30T16:15:34.691608", "image_code": "const vec2 speed = vec2(0.65, 1.05);\nconst float animCosPercent = 0.85;\nconst vec2 offset = vec2(2.8, 1.8);\n\nconst int maxIterations = 32;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 time = iTime * speed;\n\tvec2 scale = iResolution.xy / (offset * 2.0);\n\t\n\tvec2 cet = cos(time) * animCosPercent;\n\tvec2 pos = fragCoord / scale - offset;\n\tvec2 quad = pow(pos, vec2(2.0));\n\t\n\tint i;\n\tfor (i = 0; i < maxIterations; i++)\n\t{\n\t\tpos.y = 2.0 * pos.x * pos.y + cet.y;\n\t\tpos.x = quad.x - quad.y + cet.x;\n\t\tquad.x = pow(pos.x, 2.0);\n\t\tquad.y = pow(pos.y, 2.0);\n\t\tif ((quad.x + quad.y) > 4.0)\n\t\t\tbreak;\n\t}\n\tfloat depth = float(i) / float(maxIterations);\n\t\n\tfragColor = vec4(vec3(depth), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds2SzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 195, 195, 699]], "test": "untested"}
{"id": "ddjSzD", "name": "Shortest 3D Checkers - 111 chars", "author": "GregRostami", "description": "Shortest 3D Checkers ... Can you make it shorter?!", "tags": ["2d", "fake3d", "short"], "likes": 12, "viewed": 325, "published": 3, "date": "1670004301", "time_retrieved": "2024-07-30T16:15:35.447587", "image_code": "// 111 chars - iq makes a char DISAPPEAR!!\n/**/\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o = sin( iTime - 8.*vec4(1,1,1,u = u/iResolution.x - .6 ) / u.y );\n    o = .5 + (o+o.w)/fwidth(o);\n}\n/**/\n\n// 112 chars - Fabrice uses the magical \"fwidth()\" to add anti-aliasing!!\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o = sin( iTime - 8.*vec4(1,1,1,u = u/iResolution.x - .6 ) / u.y);\n    o += o.w;\n    o = .5 + o/fwidth(o);\n}\n/**/\n\n\n// 99 chars - Fabrice (once again) makes the small, SMALLER!!\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{\n    o = 3e3 * sin( iTime - 8.*vec4(1,1,1,u = u/iResolution.x - .6 ) / u.y );\n    o += o.w;\n}\n/**/\n\n\n// 108 chars - Shortest 3D Checkers (B&W)\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u = u/iResolution.x - .6;\n    u = 3e3 * sin(iTime - 7.*vec2(u.x,1)/u.y);\n    o = vec4(u.x+u.y);\n}\n/**/\n\n\n// 97 chars - Shorter 3D Checkers (Color)\n/**\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u = u/iResolution.x-.6;\n    o = 1e3 * sin(iTime - 5.*vec2(u.x,1)/u.y).xyxy;\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjSzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 48, 84, 84, 189]], "test": "untested"}
{"id": "ddSXzW", "name": "Roguelike Dungeon WFC", "author": "fenix", "description": "Another WFC shader, implementing a roguelike dungeon, maybe. Inspired by one of the patterns in the original WFC research.\n\n*mouse drag up/left: zoom out*\n*mouse drag down/right: re-center and zoom in*\n*shift+mouse drag: pan* \n*space to reset*", "tags": ["wfc", "wavefunctioncollapse"], "likes": 17, "viewed": 327, "published": 3, "date": "1669967125", "time_retrieved": "2024-07-30T16:15:36.404029", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another in what looks like it might be a series using \"simple tiled model\" wave\n//  function collapse, because these are fun to play with.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  Previous WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://www.shadertoy.com/view/mdBSRW\n//\n//  Another patterns heavily inspired by the original WFC research:\n//\n//      https://raw.githubusercontent.com/mxgmn/WaveFunctionCollapse/master/images/rooms.png\n//\n//  The entire buffer is simulated, so you're only looking at the center 1/64th of the\n//  buffer when the shader boots, chosen so that the 8x8 tile pixels are 1:1 with screen\n//  pixels. Click and drag the mouse up/left to zoom out.\n//\n//  The tiles are defined in the Common tab, and are designed to be easy to change. Forks\n//  of this shader are welcome if you draw your own tiles and make something intereting\n//  and new out of it. But please post a comment here so I don't miss it!\n//\n//  The rendering was probably harder to get working than the simulation, because I\n//  wanted to be able to zoom out and watch the simulation from farther away. My first\n//  attempt had horrible aliasing artifacts so I had to add this box clipping system.\n//\n//  I'm curious if the mouse camera controls are effective or not for other people. Once\n//  you get used to it, it's handy for zooming in on specific details, I think.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// compute the overlapping area between two axis aligned boxes\nfloat boxClip(vec4 a, vec4 b)\n{\n    vec4 i = vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n    vec2 e = i.zw - i.xy;\n    return any(lessThanEqual(e, vec2(0))) ? 0. : e.x * e.y;\n}\n\n// rotate a pixel index\nivec2 rotIdx(ivec2 v, int r)\n{\n    if (r == 0) return ivec2(v.x, 7 - v.y);\n    if (r == 1) return v.yx;\n    if (r == 2) return ivec2(7 - v.x, v.y);\n    if (r == 3) return 7 - v.yx;\n}\n\n#define GET_SUBTILE(T, U) ((TILES(T).image[U.y] >> ((7 - U.x) * 3)) % 8u)\n\n// compute the color contribution of a single tile, clipped to the screen pixel\nvec3 tileClip(int type, int rot, vec4 clipBox)\n{\n    vec3 sum = vec3(0);\n    for (ivec2 v = ivec2(0); v.x < 8; ++v.x)\n    for (v.y = 0; v.y < 8; ++v.y)\n    {\n        uint value = GET_SUBTILE(type, rotIdx(v, rot));\n        sum += subtileColor(value, ((v.x + v.y) & 1) == 0) * boxClip(clipBox, vec4(vec2(v) / 8., (vec2(v) + 1.) / 8.));\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n\n    fragCoord -= .5 * iResolution.xy;\n    fragCoord *= state.zoom;\n    fragCoord += state.center * iResolution.y;\n    fragCoord += .5 * iResolution.xy;\n    \n    // compute the tile address and coordinates within the tile for the lower left and upper right corners of the pixel\n    vec2 llc = fragCoord - .5 * state.zoom;\n    ivec2 llt = ivec2(llc);\n    llc = fract(llc);\n    vec2 urc = fragCoord + .5 * state.zoom;\n    ivec2 urt = ivec2(urc);\n    urc = fract(urc);\n    \n    vec3 sum = vec3(0);\n    \n    // loop over all the tiles, clipping as we go\n    for (ivec2 tile = llt; tile.x <= urt.x; ++tile.x)\n    for (tile.y = llt.y; tile.y <= urt.y; ++tile.y)\n    {\n        if (all(greaterThan(tile, ivec2(0))) && all(lessThan(tile, ivec2(iResolution.xy))))\n        {\n            vec4 v = texelFetch(iChannel0, tile, 0);\n            int type = int(v.x);\n            int rot = int(v.y);\n\n            vec4 clipBox = vec4(0, 0, 1, 1);\n\n            // clip one or more sides if necessary\n            if (tile.x == llt.x) clipBox.x = llc.x;\n            if (tile.y == llt.y) clipBox.y = llc.y;\n            if (tile.x == urt.x) clipBox.z = urc.x;\n            if (tile.y == urt.y) clipBox.w = urc.y;\n\n            sum += tileClip(type, rot, clipBox);\n        }\n    }\n    \n    fragColor = sqrt(vec4(sum / (state.zoom * state.zoom), 1));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec3 subtileColor(uint value, bool parity)\n{\n    if (value == 0u) return vec3(1,0,0);\n    if (value == 1u) return vec3(0);\n    if (value == 2u) return vec3(.3);\n    if (value == 3u) return vec3(.8,.7,0);\n    if (value == 4u) return vec3(.5,.7,0);\n    if (value == 5u) return parity ? vec3(.5,.1,.1) : vec3(.3,.1,.1);\n    if (value == 6u) return vec3(0,0,.5);\n    if (value == 7u) return parity ? vec3(.1,.1,.5) : vec3(.1,.1,.3);\n    return vec3(1,0,1);\n}\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    uint image[8]; // 8-color octal array defining how to render the tile, referencing the above colors\n};\n\nconst Tile T_EMPTY = \n    Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         0.,\n         uint[](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u));\n         \nconst Tile T_WALL =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .5,\n         uint[](011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_TURN =\n    Tile(mat3(1, 1, 1,\n              1, 2, 2,\n              1, 2, 1),\n         .1,\n         uint[](011111111u,\n                011111111u,\n                011111111u,\n                011122222u,\n                011122222u,\n                011122111u,\n                011122111u,\n                011122111u));\n                \nconst Tile T_STRAIGHT =\n    Tile(mat3(1, 2, 1,\n              1, 2, 1,\n              1, 2, 1),\n         .5,\n         uint[](011122111u,\n                011122111u,\n                011122111u,\n                011122111u,\n                011122111u,\n                011122111u,\n                011122111u,\n                011122111u));\n                \nconst Tile T_EDGE =\n    Tile(mat3(1, 1, 2,\n              1, 1, 2,\n              1, 1, 2),\n         .5,\n         uint[](011111122u,\n                011111122u,\n                011111122u,\n                011111122u,\n                011111122u,\n                011111122u,\n                011111122u,\n                011111122u));\n                \nconst Tile T_ENTRY =\n    Tile(mat3(1, 1, 2,\n              2, 2, 2,\n              1, 1, 2),\n         .5,\n         uint[](011111122u,\n                011111122u,\n                011111122u,\n                022222222u,\n                022222222u,\n                011111122u,\n                011111122u,\n                011111122u));\n                \nconst Tile T_T =\n    Tile(mat3(1, 2, 1,\n              2, 2, 1,\n              1, 2, 1),\n         .5,\n         uint[](011122111u,\n                011122111u,\n                011122111u,\n                022222111u,\n                022222111u,\n                011122111u,\n                011122111u,\n                011122111u));\n                \nconst Tile T_CORNER =\n    Tile(mat3(1, 1, 2,\n              1, 1, 1,\n              1, 1, 1),\n         .5,\n         uint[](011111122u,\n                011111122u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_ROOM =\n    Tile(mat3(2, 2, 2,\n              2, 2, 2,\n              2, 2, 2),\n         .5,\n         uint[](022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u));\n                \nconst Tile T_ICORNER =\n    Tile(mat3(2, 2, 2,\n              1, 1, 2,\n              1, 1, 2),\n         .5,\n         uint[](022222222u,\n                022222222u,\n                011111122u,\n                011111122u,\n                011111122u,\n                011111122u,\n                011111122u,\n                011111122u));\n                \nconst int NUM_TILES = 10;\n\nTile TILES(int i)\n{\n    switch(i)\n    {\n        case 0: return T_EMPTY;\n        case 1: return T_WALL;\n        case 2: return T_TURN;\n        case 3: return T_STRAIGHT;\n        case 4: return T_EDGE;\n        case 5: return T_ENTRY;\n        case 6: return T_T;\n        case 7: return T_CORNER;\n        case 8: return T_ROOM;\n        case 9: return T_ICORNER;\n    }\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nstruct fxState\n{\n    float resolution;\n    float zoom;\n    float oldZoom;\n    vec2 center;\n    vec2 oldCenter;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.zoom = data0.y;\n    state.oldZoom = data0.z;\n    state.attract = data0.w != 0.;\n    state.center = data1.xy;\n    state.oldCenter = data1.zw;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.zoom, state.oldZoom, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.center, state.oldCenter);\n}\n\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// The room where it happens.\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES(int(n.x)).shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        mat3 myShape = TILES(i).shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES(int(n.x)).shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES(g_ValidTiles[i]).shape, g_ValidTileRs[i] + r);\n        if (!tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        // seed one pixel in the middle of the field\n        if (ifc == ivec2(iResolution.xy * vec2(.5, .925))) fragColor = vec4(1, 0, 0, 0);\n               \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        fragColor.x = 0.;\n        fragColor.y = 0.;\n        fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n        vec3 h = hash3(uvec3(fragCoord, iFrame));\n        if (h.x < 1e-6)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + .01;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (h.z < TILES(g_ValidTiles[choice]).prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.zoom = 1./8.;\n        state.oldZoom = 1./8.;\n        state.center = vec2(0);\n        state.oldCenter = vec2(0);\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0. && iMouse.w < 0.)\n        {\n            state.attract = false;\n            if (keyDown(KEY_SHIFT))\n            {\n                vec2 delta = state.zoom * (iMouse.zw * vec2(1, -1) - iMouse.xy) / iResolution.y;\n                state.center = state.oldCenter + delta;\n            }\n            else\n            {\n                float mouseZoom = (iMouse.y + iMouse.w + iMouse.z - iMouse.x) / iResolution.y;\n                state.zoom = state.oldZoom * pow(2., 4. * mouseZoom);\n                if (mouseZoom < 0.)\n                {\n                    vec2 mouseCenter = (vec2(iMouse.z, -iMouse.w) - .5 * iResolution.xy) / iResolution.y;\n                    mouseCenter *= state.oldZoom;\n                    mouseCenter += state.oldCenter;\n                    state.center = mix(state.oldCenter, mouseCenter, min(1.,-5.*mouseZoom));\n                }\n            }\n        }\n        else\n        {\n            state.oldZoom = state.zoom;\n            state.oldCenter = state.center;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(iTime*.02), cos(iTime*.02));\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSXzW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1872, 1935, 1966, 1966, 2107], [2109, 2133, 2163, 2163, 2315], [2392, 2472, 2520, 2520, 2829], [2831, 2831, 2888, 2888, 4247]], "test": "untested"}
{"id": "mdBSRW", "name": "Circuit Board WFC", "author": "fenix", "description": "Another wave function collapse shader. This one takes a few minutes to converge completely, but I think it's interesting to watch!\n\n*mouse drag up/left: zoom out*\n*mouse drag down/right: re-center and zoom in*\n*shift+mouse drag: pan* \n*space to reset*", "tags": ["wfc", "wavefunctioncollapse"], "likes": 25, "viewed": 481, "published": 3, "date": "1669963274", "time_retrieved": "2024-07-30T16:15:37.330552", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another in what looks like it might be a series using \"simple tiled model\" wave\n//  function collapse, because these are fun to play with.\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//\n//  This one converges quite a lot slower, mainly because it takes a while to \"figure\n//  out\" that the chips have to be rectangular. It's also inspired directly by one of \n//  the original WFC patterns:\n//\n//    https://raw.githubusercontent.com/mxgmn/WaveFunctionCollapse/master/images/circuit-1.png\n//\n//  The entire buffer is simulated, so you're only looking at 1/64th of the buffer when\n//  the shader boots, chosen so that the 8x8 tile pixels are 1:1 with screen pixels. Click\n//  and drag the mouse up/left to zoom out.\n//\n//  The tiles are defined in the Common tab, and are designed to be easy to change. Forks\n//  of this shader are welcome if you draw your own tiles and make something intereting\n//  and new out of it. But please post a comment here so I don't miss it!\n//\n//  The rendering was probably harder to get working than the simulation, because I\n//  wanted to be able to zoom out and watch the simulation from farther away. My first\n//  attempt had horrible aliasing artifacts so I had to add this box clipping system.\n//\n//  I'm curious if the mouse camera controls are effective or not for other people. Once\n//  you get used to it, it's handy for zooming in on specific details, I think.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// compute the overlapping area between two axis aligned boxes\nfloat boxClip(vec4 a, vec4 b)\n{\n    vec4 i = vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n    vec2 e = i.zw - i.xy;\n    return any(lessThanEqual(e, vec2(0))) ? 0. : e.x * e.y;\n}\n\n// rotate a pixel index\nivec2 rotIdx(ivec2 v, int r)\n{\n    if (r == 0) return ivec2(v.x, 7 - v.y);\n    if (r == 1) return v.yx;\n    if (r == 2) return ivec2(7 - v.x, v.y);\n    if (r == 3) return 7 - v.yx;\n}\n\n#define GET_SUBTILE(T, U) ((TILES[T].image[U.y] >> ((7 - U.x) * 3)) % 8u)\n\n// compute the color contribution of a single tile, clipped to the screen pixel\nvec3 tileClip(int type, int rot, vec4 clipBox)\n{\n    vec3 sum = vec3(0);\n    for (ivec2 v = ivec2(0); v.x < 8; ++v.x)\n    for (v.y = 0; v.y < 8; ++v.y)\n    {\n        uint value = GET_SUBTILE(type, rotIdx(v, rot));\n        sum += subtileColor(value, ((v.x + v.y) & 1) == 0) * boxClip(clipBox, vec4(vec2(v) / 8., (vec2(v) + 1.) / 8.));\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n\n    fragCoord -= .5 * iResolution.xy;\n    fragCoord *= state.zoom;\n    fragCoord += state.center * iResolution.y;\n    fragCoord += .5 * iResolution.xy;\n    \n    // compute the tile address and coordinates within the tile for the lower left and upper right corners of the pixel\n    vec2 llc = fragCoord - .5 * state.zoom;\n    ivec2 llt = ivec2(llc);\n    llc = fract(llc);\n    vec2 urc = fragCoord + .5 * state.zoom;\n    ivec2 urt = ivec2(urc);\n    urc = fract(urc);\n    \n    vec3 sum = vec3(0);\n    \n    // loop over all the tiles, clipping as we go\n    for (ivec2 tile = llt; tile.x <= urt.x; ++tile.x)\n    for (tile.y = llt.y; tile.y <= urt.y; ++tile.y)\n    {\n        if (all(greaterThan(tile, ivec2(0))) && all(lessThan(tile, ivec2(iResolution.xy))))\n        {\n            vec4 v = texelFetch(iChannel0, tile, 0);\n            int type = int(v.x);\n            int rot = int(v.y);\n\n            vec4 clipBox = vec4(0, 0, 1, 1);\n\n            // clip one or more sides if necessary\n            if (tile.x == llt.x) clipBox.x = llc.x;\n            if (tile.y == llt.y) clipBox.y = llc.y;\n            if (tile.x == urt.x) clipBox.z = urc.x;\n            if (tile.y == urt.y) clipBox.w = urc.y;\n\n            sum += tileClip(type, rot, clipBox);\n        }\n    }\n    \n    fragColor = sqrt(vec4(sum / (state.zoom * state.zoom), 1));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec3 subtileColor(uint value, bool parity)\n{\n    if (value == 0u) return vec3(0);\n    if (value == 1u) return vec3(0,.1,0);\n    if (value == 2u) return vec3(.3,.8,.3);\n    if (value == 3u) return vec3(.05);\n    if (value == 4u) return vec3(.5);\n    if (value == 5u) return parity ? vec3(.5,.1,.1) : vec3(.3,.1,.1);\n    if (value == 6u) return vec3(0,0,.5);\n    if (value == 7u) return parity ? vec3(.1,.1,.5) : vec3(.1,.1,.3);\n    return vec3(1,0,1);\n}\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    uint image[8]; // 8-color octal array defining how to render the tile, referencing the above colors\n};\n\nconst Tile T_EMPTY =\n    Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         0.,\n         uint[](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u));\n         \nconst Tile T_BOARD =\n    Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .9,\n         uint[](011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_CHIP =\n    Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .7,\n         uint[](033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u,\n                033333333u));\n                \nconst Tile T_NODE =\n    Tile(mat3(1, 1, 1,\n              1, 1, 2,\n              1, 1, 1),\n         0.1,\n         uint[](011111111u,\n                011144111u,\n                011444411u,\n                014444442u,\n                014444442u,\n                011444411u,\n                011144111u,\n                011111111u));\n                \nconst Tile T_WIRE =\n    Tile(mat3(1, 1, 1,\n              4, 4, 4,\n              1, 1, 1),\n         0.5,\n         uint[](011111111u,\n                011111111u,\n                044444444u,\n                044444444u,\n                044444444u,\n                044444444u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_EDGE =\n    Tile(mat3(3, 1, 1,\n              3, 2, 2,\n              3, 1, 1),\n         1.,\n         uint[](033111111u,\n                033111111u,\n                033411111u,\n                033444422u,\n                033444422u,\n                033411111u,\n                033111111u,\n                033111111u));\n                \nconst Tile T_CORNER =\n    Tile(mat3(3, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         .5,\n         uint[](033111111u,\n                033111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_TRACE =\n    Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.1,\n         uint[](011111111u,\n                011111111u,\n                011111111u,\n                022222222u,\n                022222222u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_CROSS =\n    Tile(mat3(1, 4, 1,\n              2, 4, 2,\n              1, 4, 1),\n         0.7,\n         uint[](011444411u,\n                011444411u,\n                011444411u,\n                022444422u,\n                022444422u,\n                011444411u,\n                011444411u,\n                011444411u));\n                \nconst Tile T_JUNCT =\n    Tile(mat3(1, 4, 1,\n              1, 4, 1,\n              1, 2, 1),\n         0.7,\n         uint[](011444411u,\n                011444411u,\n                011444411u,\n                011444411u,\n                011444411u,\n                011144111u,\n                011144111u,\n                011122111u));\n                \nconst Tile T_T =\n    Tile(mat3(1, 2, 1,\n              2, 2, 2,\n              1, 1, 1),\n         0.5,\n         uint[](011122111u,\n                011122111u,\n                011122111u,\n                022222222u,\n                022222222u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_ACROSS =\n    Tile(mat3(1, 2, 1,\n              1, 2, 2,\n              1, 1, 1),\n         .3,\n         uint[](011122111u,\n                011112211u,\n                011111221u,\n                011111122u,\n                011111112u,\n                011111111u,\n                011111111u,\n                011111111u));\n                \nconst Tile T_2ACROSS =\n    Tile(mat3(1, 2, 1,\n              2, 1, 2,\n              1, 2, 1),\n         .3,\n         uint[](011122111u,\n                011112211u,\n                011111221u,\n                021111122u,\n                022111112u,\n                012211111u,\n                011221111u,\n                011122111u));\n                \nconst Tile T_INODE =\n    Tile(mat3(1, 1, 1,\n              2, 1, 2,\n              1, 1, 1),\n         0.01,\n         uint[](011111111u,\n                011144111u,\n                011444411u,\n                024444442u,\n                024444442u,\n                011444411u,\n                011144111u,\n                011111111u));\n                \nconst int NUM_TILES = 14;\n\nconst Tile[NUM_TILES] TILES =\n    Tile[](\n        T_EMPTY,\n        T_BOARD,\n        T_CHIP,\n        T_NODE,\n        T_WIRE,\n        T_EDGE,\n        T_CORNER,\n        T_TRACE,\n        T_CROSS,\n        T_JUNCT,\n        T_T,\n        T_ACROSS,\n        T_2ACROSS,\n        T_INODE\n    );\n\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nstruct fxState\n{\n    float resolution;\n    float zoom;\n    float oldZoom;\n    vec2 center;\n    vec2 oldCenter;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.zoom = data0.y;\n    state.oldZoom = data0.z;\n    state.attract = data0.w != 0.;\n    state.center = data1.xy;\n    state.oldCenter = data1.zw;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.zoom, state.oldZoom, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.center, state.oldCenter);\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// The room where it happens.\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        mat3 myShape = TILES[i].shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES[g_ValidTiles[i]].shape, g_ValidTileRs[i] + r);\n        if (!tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        // seed one pixel in the middle of the field\n        if (ifc == ivec2(iResolution.xy * vec2(.5, .925))) fragColor = vec4(1, 0, 0, 0);\n        \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec3 h = hash3(uvec3(fragCoord, iFrame));\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        if (h.x > .5)\n        {\n            fragColor.x = 0.;\n            fragColor.y = 0.;\n            fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        }\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n        if (h.x < 1e-6)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + 1.1;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (h.z < TILES[g_ValidTiles[choice]].prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.zoom = 1./8.;\n        state.oldZoom = 1./8.;\n        state.center = vec2(0);\n        state.oldCenter = vec2(0);\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0. && iMouse.w < 0.)\n        {\n            state.attract = false;\n            if (keyDown(KEY_SHIFT))\n            {\n                vec2 delta = state.zoom * (iMouse.zw * vec2(1, -1) - iMouse.xy) / iResolution.y;\n                state.center = state.oldCenter + delta;\n            }\n            else\n            {\n                float mouseZoom = (iMouse.y + iMouse.w + iMouse.z - iMouse.x) / iResolution.y;\n                state.zoom = state.oldZoom * pow(2., 4. * mouseZoom);\n                if (mouseZoom < 0.)\n                {\n                    vec2 mouseCenter = (vec2(iMouse.z, -iMouse.w) - .5 * iResolution.xy) / iResolution.y;\n                    mouseCenter *= state.oldZoom;\n                    mouseCenter += state.oldCenter;\n                    state.center = mix(state.oldCenter, mouseCenter, min(1.,-5.*mouseZoom));\n                }\n            }\n        }\n        else\n        {\n            state.oldZoom = state.zoom;\n            state.oldCenter = state.center;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(iTime*.02), cos(iTime*.02));\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdBSRW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1995, 2058, 2089, 2089, 2230], [2232, 2256, 2286, 2286, 2438], [2515, 2595, 2643, 2643, 2952], [2954, 2954, 3011, 3011, 4370]], "test": "untested"}
{"id": "ddSXRW", "name": "gumball rain", "author": "timmaffett", "description": "adding some color to fooling around with circles", "tags": ["2d"], "likes": 16, "viewed": 310, "published": 3, "date": "1669956991", "time_retrieved": "2024-07-30T16:15:38.076558", "image_code": "// Fork of \"Uplifting Units\" by andremichelle. https://shadertoy.com/view/tdtXWf\n// 2022-12-02 04:53:13\n\n// cleanup by https://www.shadertoy.com/user/FabriceNeyret2\nfloat rand(vec2  n){ return fract(sin(n.x*11.+n.y*17.) * 43758.5453123);}\nfloat rand(float n){ return fract(sin(n)               * 43758.5453123);}\n\nfloat sdRoundBox( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,q.y),0.) - r;\n}\n\nvec4 hsb2rgb( in vec4 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return vec4(c.z * mix( vec3(1.0), rgb, c.y), 1.);\n}\n\nvoid mainImage( out vec4 O, vec2 u ) {\n\nfloat myTime = iTime+31.*71.;\n\n    O = vec4(0);\n    vec2  R = iResolution.xy,\n          U = ( u - R*.5 ) / R.y;\n    float t = -myTime;\n    U.x += sin(t*.05)*.25;\n    U.y += sin(t*.10)*.25;\n    for(float i = 0. ; i < 1. ; i += .2) {\n        float u = fract(t*.125+i),\n              q = rand(i+10.)*9. + u*2. + sin(t*.3)*2.;\n        vec2  P = U *u*90. * mat2(cos(q), -sin(q), sin(q), cos(q)),\n              f = 2.*fract(P)-1.;\n        float rn = rand(floor(P)),\n              c = pow( abs(sin( (iTime*.04+rn)*3.14159 )) ,16.),\n              s = smoothstep(.02, .01, length(f) - c);\n        vec4 gumball = hsb2rgb(vec4(  1.7*u* c*U.x*q,1.,1.,1.)*s*(1.-u));\n        O = max(O, gumball);//(vec4(1,1, .2*c,1)*s*(1.-u)));\n    }\n    \n    O *= min(1., iTime*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 165, 185, 185, 238], [239, 239, 259, 259, 312], [314, 314, 359, 359, 439], [441, 441, 468, 468, 711], [713, 713, 751, 751, 1508]], "test": "untested"}
{"id": "DdfSzj", "name": "Simple Wave Function Collapse", "author": "fenix", "description": "Attempting to implement the \"simple tiled model\" of wave function collapse. Should take about 20 seconds to fully converge at 30 FPS.\n\n*mouse drag up/left: zoom out*\n*mouse drag down/right: re-center and zoom in*\n*shift+mouse drag: pan* \n*space to reset*", "tags": ["wfc", "wavefunctioncollapse"], "likes": 7, "viewed": 400, "published": 3, "date": "1669956619", "time_retrieved": "2024-07-30T16:15:39.004078", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Trying to make a roadless random city for a roguelike game maybe, using the \"simple\n//  tiled model\" idea from Wave Function Collapse:\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  The entire buffer is simulated, so you're only looking at the center 1/64th of the\n//  buffer when the shader boots, chosen so that the 8x8 tile pixels are 1:1 with screen\n//  pixels. Click and drag the mouse up/left to zoom out.\n//\n//  The tiles are defined in the Common tab, and are designed to be easy to change. Forks\n//  of this shader are welcome if you draw your own tiles and make something intereting\n//  and new out of it. But please post a comment here so I don't miss it!\n//\n//  The rendering was probably harder to get working than the simulation, because I\n//  wanted to be able to zoom out and watch the simulation from farther away. My first\n//  attempt had horrible aliasing artifacts so I had to add this box clipping system.\n//\n//  I'm curious if the mouse camera controls are effective or not for other people. Once\n//  you get used to it, it's handy for zooming in on specific details, I think.\n//\n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\n// compute the overlapping area between two axis aligned boxes\nfloat boxClip(vec4 a, vec4 b)\n{\n    vec4 i = vec4(max(a.xy, b.xy), min(a.zw, b.zw));\n    vec2 e = i.zw - i.xy;\n    return any(lessThanEqual(e, vec2(0))) ? 0. : e.x * e.y;\n}\n\n// rotate a pixel index\nivec2 rotIdx(ivec2 v, int r)\n{\n    if (r == 0) return ivec2(v.x, 7 - v.y);\n    if (r == 1) return v.yx;\n    if (r == 2) return ivec2(7 - v.x, v.y);\n    if (r == 3) return 7 - v.yx;\n}\n\n#define GET_SUBTILE(T, U) ((TILES[T].image[U.y] >> ((7 - U.x) * 3)) % 8u)\n\n// compute the color contribution of a single tile, clipped to the screen pixel\nvec3 tileClip(int type, int rot, vec4 clipBox)\n{\n    vec3 sum = vec3(0);\n    for (ivec2 v = ivec2(0); v.x < 8; ++v.x)\n    for (v.y = 0; v.y < 8; ++v.y)\n    {\n        uint value = GET_SUBTILE(type, rotIdx(v, rot));\n        sum += subtileColor(value, ((v.x + v.y) & 1) == 0) * boxClip(clipBox, vec4(vec2(v) / 8., (vec2(v) + 1.) / 8.));\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n\n    fragCoord -= .5 * iResolution.xy;\n    fragCoord *= state.zoom;\n    fragCoord += state.center * iResolution.y;\n    fragCoord += .5 * iResolution.xy;\n    \n    // compute the tile address and coordinates within the tile for the lower left and upper right corners of the pixel\n    vec2 llc = fragCoord - .5 * state.zoom;\n    ivec2 llt = ivec2(llc);\n    llc = fract(llc);\n    vec2 urc = fragCoord + .5 * state.zoom;\n    ivec2 urt = ivec2(urc);\n    urc = fract(urc);\n    \n    vec3 sum = vec3(0);\n    \n    // loop over all the tiles, clipping as we go\n    for (ivec2 tile = llt; tile.x <= urt.x; ++tile.x)\n    for (tile.y = llt.y; tile.y <= urt.y; ++tile.y)\n    {\n        if (all(greaterThan(tile, ivec2(0))) && all(lessThan(tile, ivec2(iResolution.xy))))\n        {\n            vec4 v = texelFetch(iChannel0, tile, 0);\n            int type = int(v.x);\n            int rot = int(v.y);\n\n            vec4 clipBox = vec4(0, 0, 1, 1);\n\n            // clip one or more sides if necessary\n            if (tile.x == llt.x) clipBox.x = llc.x;\n            if (tile.y == llt.y) clipBox.y = llc.y;\n            if (tile.x == urt.x) clipBox.z = urc.x;\n            if (tile.y == urt.y) clipBox.w = urc.y;\n\n            sum += tileClip(type, rot, clipBox);\n        }\n    }\n    \n    fragColor = sqrt(vec4(sum / (state.zoom * state.zoom), 1));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec3 subtileColor(uint value, bool parity)\n{\n    if (value == 0u) return vec3(0);\n    if (value == 1u) return vec3(1,0,0);\n    if (value == 2u) return vec3(.3,.3,.3);\n    if (value == 3u) return vec3(0,0,1);\n    if (value == 4u) return vec3(.5,0,0);\n    if (value == 5u) return parity ? vec3(.5,.1,.1) : vec3(.3,.1,.1);\n    if (value == 6u) return vec3(0,0,.5);\n    if (value == 7u) return parity ? vec3(.1,.1,.5) : vec3(.1,.1,.3);\n    return vec3(1,0,1);\n}\n\nstruct Tile\n{\n    mat3 shape; // defines how this tile matches to neighbors\n    float prob; // lower numbers will cause this tile to be chosen less often\n    uint image[8]; // 8-color octal array defining how to render the tile, referencing the above colors\n};\n\nconst int NUM_TILES = 15;\n\n\nconst Tile T_0 = Tile(mat3(0, 0, 0,\n              0, 0, 0,\n              0, 0, 0),\n         0.,\n         uint[](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u));\n         \nconst Tile T_1 = Tile(mat3(1, 1, 1,\n              1, 1, 1,\n              1, 1, 1),\n         1.,\n         uint[](022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u,\n                022222222u));\n                \nconst Tile T_2 = Tile(mat3(2, 2, 2,\n              2, 2, 2,\n              2, 2, 2),\n         .5,\n         uint[](045555554u,\n                055555555u,\n                055555555u,\n                055555555u,\n                055555555u,\n                055555555u,\n                055555555u,\n                045555554u));\n                \nconst Tile T_3 = Tile(mat3(2, 2, 2,\n              2, 2, 2,\n              2, 2, 2),\n         .05,\n         uint[](045555554u,\n                055555555u,\n                053333555u,\n                053663555u,\n                053663555u,\n                053333555u,\n                055555555u,\n                045555554u));\n                \nconst Tile T_4 = Tile(mat3(1, 1, 1,\n              1, 2, 2,\n              1, 2, 2),\n         .5,\n         uint[](022222222u,\n                021111111u,\n                021444444u,\n                021455555u,\n                021455555u,\n                021455555u,\n                021455555u,\n                021455554u));\n                \nconst Tile T_5 = Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              2, 2, 2),\n         .5,\n         uint[](022222222u,\n                011111111u,\n                044444444u,\n                055555555u,\n                055555555u,\n                055555555u,\n                055555555u,\n                045555554u));\n                \nconst Tile T_6 = Tile(mat3(1, 1, 1,\n              2, 2, 2,\n              2, 2, 2),\n         .5,\n         uint[](022222222u,\n                011122111u,\n                044144144u,\n                055555555u,\n                055555555u,\n                055555555u,\n                055555555u,\n                045555554u));\n                \nconst Tile T_7 = Tile(mat3(1, 2, 2,\n              2, 2, 2,\n              2, 2, 2),\n         .5,\n         uint[](021455554u,\n                011455555u,\n                044455555u,\n                055555555u,\n                055555555u,\n                055555555u,\n                055555555u,\n                045555554u));\n                \nconst Tile T_8 = Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .5,\n         uint[](077777777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u));\n                \nconst Tile T_9 = Tile(mat3(3, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .2,\n         uint[](017177777u,\n                071777777u,\n                017177777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u));\n\nconst Tile T_10 = Tile(mat3(1, 1, 1,\n              1, 3, 3,\n              1, 3, 3),\n         .4,\n         uint[](022222222u,\n                023333333u,\n                023666666u,\n                023677677u,\n                023677777u,\n                023667777u,\n                023677777u,\n                023677777u));\n\nconst Tile T_11 = Tile(mat3(1, 1, 1,\n              3, 3, 3,\n              3, 3, 3),\n         .4,\n         uint[](022222222u,\n                033333333u,\n                066666666u,\n                076777767u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u));\n                \nconst Tile T_12 = Tile(mat3(1, 1, 1,\n              3, 3, 3,\n              3, 3, 3),\n         .4,\n         uint[](022222222u,\n                033333333u,\n                066666666u,\n                076711767u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u));\n                \nconst Tile T_13 = Tile(mat3(1, 1, 1,\n              3, 3, 3,\n              3, 3, 3),\n         .4,\n         uint[](022222222u,\n                033322333u,\n                066366366u,\n                076777767u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u));\n                \nconst Tile T_14 = Tile(mat3(1, 3, 3,\n              3, 3, 3,\n              3, 3, 3),\n         .4,\n         uint[](023677777u,\n                033677777u,\n                066677777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u,\n                077777777u));\n                \nconst Tile[NUM_TILES] TILES = Tile[]( T_0, T_1, T_2, T_3, T_4, T_5, T_6, T_7, T_8, T_9, T_10, T_11, T_12, T_13, T_14 );\n\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nstruct fxState\n{\n    float resolution;\n    float zoom;\n    float oldZoom;\n    vec2 center;\n    vec2 oldCenter;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.resolution = data0.x;\n    state.zoom = data0.y;\n    state.oldZoom = data0.z;\n    state.attract = data0.w != 0.;\n    state.center = data1.xy;\n    state.oldCenter = data1.zw;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.resolution, state.zoom, state.oldZoom, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.center, state.oldCenter);\n}\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// The room where it happens.\n// ---------------------------------------------------------------------------------------\n\nint g_NumValidTiles;\nconst int MAX_VALID_TILES = NUM_TILES * 4;\nint g_ValidTiles[MAX_VALID_TILES];\nint g_ValidTileRs[MAX_VALID_TILES];\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// find the full array of tiles that could be compatible with a particular tile already placed\nvoid findValidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n    \n    for (int i = 0; i < NUM_TILES; ++i)\n    {\n        mat3 myShape = TILES[i].shape;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (tilesMatch(rotShape(myShape, d), nShape))\n            {\n                g_ValidTiles[g_NumValidTiles] = i;\n                g_ValidTileRs[g_NumValidTiles] = (d + 4 - r) % 4;\n                g_NumValidTiles++;\n            }\n        }\n    }\n}\n\n// remove any tiles from the array that do not match the particular tile already placed\nvoid removeInvalidTiles(vec4 n, int r)\n{\n    mat3 nShape = rotShape(TILES[int(n.x)].shape, int(n.y) + r);\n\n    for (int i = 0; i < g_NumValidTiles; ++i)\n    {\n        mat3 myShape = rotShape(TILES[g_ValidTiles[i]].shape, g_ValidTileRs[i] + r);\n        if (!tilesMatch(myShape, nShape))\n        {\n            g_ValidTiles[i] = g_ValidTiles[g_NumValidTiles - 1];\n            g_ValidTileRs[i] = g_ValidTileRs[g_NumValidTiles - 1];\n            g_NumValidTiles--;\n            i--;\n        }        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // reset\n        fragColor = vec4(0);\n        \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update in an alternating checkerboard pattern, so no tile is updating on the same tick as any neighbor\n    if (((ifc.x + ifc.y) & 1) == (iFrame & 1)) return;\n\n    vec4 ns[4] = vec4[]( texelFetch(iChannel0, ifc + ivec2(0, 1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(1, 0), 0),\n                         texelFetch(iChannel0, ifc + ivec2(0, -1), 0),\n                         texelFetch(iChannel0, ifc + ivec2(-1, 0), 0) );\n\n    // reset when requested by neighbor that can't find a solution\n    if (ns[0].z > 0. || ns[1].z > 0. || ns[2].z > 0. || ns[3].z > 0. || fragColor.z > 0.)\n    {\n        fragColor.x = 0.;\n        fragColor.y = 0.;\n        fragColor.z = max(0., max(max(max(max(fragColor.z, ns[0].z), ns[1].z), ns[2].z), ns[3].z) - 1.);\n        return;\n    }\n    \n    // empty cells with no neighbors have a chance to spontaneously collapse\n    if (fragColor.x == 0. && ns[0].x == 0. && ns[1].x == 0. && ns[2].x == 0. && ns[3].x == 0.)\n    {\n        vec3 h = hash3(uvec3(fragCoord, iFrame));\n        if (h.x < 1e-5)\n        {\n            fragColor.x = floor(h.y * float(NUM_TILES));\n            fragColor.y = floor(h.y * 4.);\n            fragColor.z = 0.;\n        }\n        return;\n    }\n    \n    if (fragColor.x == 0.)\n    {\n        // we're empty but one of our neighbors is not, look for a value for ourselves\n        g_NumValidTiles = 0;\n        bool noSolution = false;\n        for (int d = 0; d < 4; ++d)\n        {\n            if (ns[d].x != 0.)\n            {\n                if (g_NumValidTiles == 0)\n                {\n                    // whichever direction is first non-empty will find all its valid tiles\n                    findValidTiles(ns[d], d);\n                }\n                else\n                {\n                    // every other direction then gets a chance to remove invalid options\n                    removeInvalidTiles(ns[d], d);\n                    if (noSolution = g_NumValidTiles == 0) break;\n                }\n            }\n        }\n\n        if (noSolution)\n        {\n            // if we're stuck, ask our neighbors to revert\n            fragColor.z = fragColor.z + 1.01;\n        }\n        else if (g_NumValidTiles > 0)\n        {\n            vec3 h = hash3(uvec3(fragCoord, iFrame));\n            int choice = int(h.y * float(g_NumValidTiles));\n            \n            // last chance rejection by probability, just try again next frame\n            if (h.z < TILES[g_ValidTiles[choice]].prob)\n            {\n                // install the chosen valid tile\n                fragColor.x = float(g_ValidTiles[choice]);\n                fragColor.y = float(g_ValidTileRs[choice]);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.resolution = -iResolution.x * iResolution.y;\n        state.zoom = 1./8.;\n        state.oldZoom = 1./8.;\n        state.center = vec2(0);\n        state.oldCenter = vec2(0);\n        state.attract = true;\n    }\n    else\n    {\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0. && iMouse.w < 0.)\n        {\n            state.attract = false;\n            if (keyDown(KEY_SHIFT))\n            {\n                vec2 delta = state.zoom * (iMouse.zw * vec2(1, -1) - iMouse.xy) / iResolution.y;\n                state.center = state.oldCenter + delta;\n            }\n            else\n            {\n                float mouseZoom = (iMouse.y + iMouse.w + iMouse.z - iMouse.x) / iResolution.y;\n                state.zoom = state.oldZoom * pow(2., 4. * mouseZoom);\n                if (mouseZoom < 0.)\n                {\n                    vec2 mouseCenter = (vec2(iMouse.z, -iMouse.w) - .5 * iResolution.xy) / iResolution.y;\n                    mouseCenter *= state.oldZoom;\n                    mouseCenter += state.oldCenter;\n                    state.center = mix(state.oldCenter, mouseCenter, min(1.,-5.*mouseZoom));\n                }\n            }\n        }\n        else\n        {\n            state.oldZoom = state.zoom;\n            state.oldCenter = state.center;\n        }\n        \n        if (state.attract)\n        {\n            state.center = .42*vec2(sin(iTime*.02), cos(iTime*.02));\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdfSzj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1513, 1576, 1607, 1607, 1748], [1750, 1774, 1804, 1804, 1956], [2033, 2113, 2161, 2161, 2470], [2472, 2472, 2529, 2529, 3888]], "test": "untested"}
{"id": "cdBSRD", "name": "ChatGPT PerlinNoise", "author": "PauloFalcao", "description": "ChatGPT (2022-12-02) for \"make a shader that does a perlin noise with octaves in shadertoy\"", "tags": ["chatgpt"], "likes": 5, "viewed": 267, "published": 3, "date": "1669947405", "time_retrieved": "2024-07-30T16:15:39.786985", "image_code": "// ChatGPT (2022-12-02) for\n\n// \"make a shader that does a perlin noise with octaves in shadertoy\"\n\n// The original shader had a function called cnoise(vec2)\n// \"please detail the function cnoise\"\n// \"cnoise is a built-in function in Shadertoy that generates Perlin noise\" LOL\n// \"show a glsl implementation of cnoise\"\n// It worked! But used a function called random(vec2)\n// \"please provide a random(i) function implementation\"\n// And the shader was complete\n// I only added two lines of code with the comments \"Human code\" :)\n\n\n// Generates a random value at the specified position.\n//\n// The \"position\" parameter is a two-dimensional vector that specifies the position\n// at which the random value should be calculated. The return value is a\n// floating-point number in the range [0, 1] that represents the random value at\n// the input position.\nfloat random(vec2 position)\n{\n    // Calculate a random number for each coordinate of the input position.\n    float x = fract(sin(dot(position, vec2(12.9898, 78.233))) * 43758.5453);\n    float y = fract(sin(dot(position, vec2(56.9898, 23.233))) * 43758.5453);\n\n    // Return the random number as the result of the function.\n    return x * y;\n}\n\n\n// Generates Perlin noise at the specified position.\n//\n// The \"position\" parameter is a two-dimensional vector that specifies the position\n// at which the Perlin noise value should be calculated. The return value is a\n// floating-point number in the range [-1, 1] that represents the Perlin noise\n// value at the input position.\nfloat cnoise(vec2 position)\n{\n    // Calculate the integer and fractional parts of the input position.\n    vec2 i = floor(position);\n    vec2 f = fract(position);\n\n    // Calculate the four corner values of the unit square that contains the\n    // input position. These values are used as the \"random\" values that are\n    // interpolated to generate the final noise value.\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Interpolate the four corner values using a smooth Hermite curve. This\n    // produces a smooth, natural-looking noise pattern.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    float v = mix(a, b, u.x);\n    float w = mix(c, d, u.x);\n    float noise = mix(v, w, u.y);\n\n    // Return the noise value, scaled to the range [-1, 1].\n    return noise * 2.0 - 1.0;\n}\n\n\n\n// This is a Shadertoy shader that generates a 2D image using Perlin noise with\n// multiple octaves.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the position of the current pixel in the range [0, 1].\n    vec2 uv = fragCoord / iResolution.xy;\n    \n//Human code start\nuv-=0.5;\nuv*=sin(iTime)*10.0+15.0;\n//Human code end\n\n    // Initialize the Perlin noise value to 0.0.\n    float noise = 0.0;\n\n    // Calculate Perlin noise with 4 octaves. Each octave adds additional detail\n    // to the noise pattern, increasing the overall complexity of the pattern.\n    for (int i = 0; i < 4; i++)\n    {\n        // Scale the position by a factor of 2 for each octave. This causes the\n        // noise pattern to appear at a higher frequency for each octave.\n        vec2 position = uv * pow(2.0, float(i));\n\n        // Calculate the Perlin noise value at the current position.\n        float value = cnoise(position);\n\n        // Add the noise value to the total noise value, scaled by a factor of 1/2\n        // for each octave. This reduces the contribution of each octave, which\n        // produces a more natural-looking noise pattern.\n        noise += value / pow(2.0, float(i));\n    }\n\n    // Map the Perlin noise value from the range [-1, 1] to the range [0, 1]\n    // by adding 1.0 and dividing by 2.0.\n    float value = (noise + 1.0) / 2.0;\n\n    // Set the color of the pixel based on the Perlin noise value.\n    fragColor = vec4(value, value, value, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBSRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[530, 849, 878, 954, 1192], [1195, 1525, 1554, 1627, 2408], [2514, 2514, 2571, 2643, 3896]], "test": "untested"}
{"id": "DdBXzW", "name": "ChatGPT - Renders a circle", "author": "PauloFalcao", "description": "ChatGPT Output (2022-12-02) for \"please make a shadertoy shader that renders a circle\"", "tags": ["chatgpt"], "likes": 3, "viewed": 245, "published": 3, "date": "1669943738", "time_retrieved": "2024-07-30T16:15:40.569891", "image_code": "// ChatGPT Output (2022-12-02) for \"please make a shadertoy shader that renders a circle\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate the distance from the center of the screen to the current pixel\n    float dist = distance(fragCoord, vec2(0.5 * iResolution.x, 0.5 * iResolution.y));\n\n    // Set the color of the circle based on its distance from the center\n    if (dist < 0.25 * iResolution.x)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0); // red\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // black\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdBXzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 148, 229, 569]], "test": "untested"}
{"id": "DsSXzW", "name": "OpenAI ChatGPT raymarching", "author": "PauloFalcao", "description": "So ChatGPT can generate Shadertoy Shaders! This one does not work... yet... :P\nSimple shadertoy shader that does a raymarching of a red sphere on top of a checkerboard with reflections\nGenerated with ChatGPT 2022-12-02\n", "tags": ["chatgpt"], "likes": 3, "viewed": 322, "published": 3, "date": "1669942964", "time_retrieved": "2024-07-30T16:15:41.363769", "image_code": "// So OpenAI ChatGPT can generate Shadertoy Shaders!\n// This one does not work... yet... :P\n//\n// Simple shadertoy shader that does a raymarching of a red sphere on top of a checkerboard with reflections\n//\n// Generated with ChatGPT 2022-12-02\n\n\n// Raymarch the scene\nvec3 raymarch(vec3 dir, vec3 spherePos, float sphereRadius)\n{\n    // Initialize raymarching variables\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    float dist = 0.0;\n    float minDist = 0.001;\n\n    // Max number of iterations\n    int maxIter = 64;\n\n    // Raymarch loop\n    for (int i = 0; i < maxIter; i++)\n    {\n        // Get distance to sphere\n        dist = distance(pos, spherePos) - sphereRadius;\n\n        // Stop raymarching if minimum distance is reached\n        if (dist < minDist)\n            break;\n\n        // Advance ray position\n        pos += dir * dist;\n    }\n\n    // Return final ray position\n    return pos;\n}\n\n// Compute checkerboard color at a given position\nvec3 getCheckerColor(vec2 pos, vec3 color1, vec3 color2)\n{\n    // Compute checkerboard pattern\n    float checker = mod(floor(pos.x) + floor(pos.y), 2.0);\n\n    // Blend checkerboard colors\n    vec3 color = mix(color1, color2, checker);\n\n    // Return checkerboard color\n    return color;\n}\n\n// Compute normal at a given position on the sphere\nvec3 getNormal(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    // Compute normal\n    vec3 norm = normalize(pos - spherePos);\n\n    // Return normal\n    return norm;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Camera ray direction\n    vec3 dir = normalize(vec3(uv, 1.0));\n\n    // Sphere position and radius\n    vec3 spherePos = vec3(0.0, 0.0, 2.0);\n    float sphereRadius = 0.5;\n\n    // Raymarch the scene\n    vec3 hitPos = raymarch(dir, spherePos, sphereRadius);\n    vec3 hitNorm = getNormal(hitPos, spherePos, sphereRadius);\n\n    // Compute checkerboard color\n    vec3 checkerColor1 = vec3(0.9, 0.9, 0.9);\n    vec3 checkerColor2 = vec3(0.1, 0.1, 0.1);\n    vec3 checkerColor = getCheckerColor(hitPos.xz, checkerColor1, checkerColor2);\n\n    // Compute reflection direction\n    vec3 reflDir = reflect(dir, hitNorm);\n\n    // Raymarch the reflection\n    vec3 reflHitPos = raymarch(reflDir, spherePos, sphereRadius);\n    vec3 reflHitNorm = getNormal(reflHitPos, spherePos, sphereRadius);\n\n    // Compute reflection color\n    vec3 reflColor = getCheckerColor(reflHitPos.xz, checkerColor1, checkerColor2);\n\n    // Blend checkerboard and reflection colors\n    vec3 color = mix(checkerColor, reflColor, 0.5);\n\n    // Set fragment color\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSXzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 268, 329, 369, 890], [892, 942, 1000, 1036, 1230], [1232, 1284, 1346, 1368, 1453], [1455, 1455, 1512, 1562, 2664]], "test": "untested"}
{"id": "DdSXzW", "name": "Smooth min mouse interactable", "author": "fishy", "description": "Entirely by @iq, all I did was copy the mouse interaction code from his other SDF visualization programs. Anyway, you can now see how space gets distorted around the upper right intersection point (as indicated by the isolines)", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "smooth", "smoothminimum"], "likes": 6, "viewed": 335, "published": 3, "date": "1669940906", "time_retrieved": "2024-07-30T16:15:42.147673", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient of the quadratic smooth minimum.\n// (https://iquilezles.org/articles/smin)\n//\n// Please note that the smooth-minimum is not a SDF preserving\n// operator. It's a good approximation when far enough from the\n// surfaces, but quickly distorts near them. However, the gradient\n// stays smaller than 1, which explains why it does NOT break\n// raymarchers, but just slows them down.\n//\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ < 1 unfortunatelly\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    float m = 0.25*h*h/k; // [0 - k/4] for [|a-b|=k - |a-b|=0]\n    float n = 0.50*  h/k; // [0 - 1/2] for [|a-b|=k - |a-b|=0]\n    return vec3( min(a.x,  b.x) - m, \n                 mix(a.yz, b.yz, (a.x<b.x)?n:1.0-n) );\n}\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgMin( in vec3 a, in vec3 b )\n{\n    return (a.x<b.x) ? a : b;\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l   : g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d,q/d);\n}\n\nvec3 map(vec2 p)\n{\n    // sdf(p) and gradient(sdf(p))\n    vec3 dg1 = sdgBox(p,vec2(0.8,0.3));\n    vec3 dg2 = sdgSegment( p, vec2(-1.0,-0.5), vec2(0.7,0.7) ) - vec3(0.15,0.0,0.0);\n    \n    return sdgSMin(dg1,dg2,0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // sdf(p) and gradient(sdf(p))\n\n  //vec3 dg = sdgMin(dg1,dg2);\n    vec3 dg = map(p);\n    float d = dg.x;\n    vec2  g = dg.yz;\n    \n    // central differenes based gradient, for validation\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-16.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    if( iMouse.z>0.001 )\n    {\n        d = map(m).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSXzW.jpg", "access": "api", "license": "mit", "functions": [[1648, 1758, 1808, 1808, 2068], [2070, 2165, 2202, 2202, 2234], [2236, 2236, 2273, 2273, 2534], [2536, 2536, 2588, 2588, 2756], [2758, 2758, 2776, 2811, 2976], [2978, 2978, 3035, 3035, 3932]], "test": "ok"}
{"id": "cdBXRW", "name": "sinc(x) around zero.", "author": "mla", "description": "An amusing discovery made with Hatchling's graph plotter framework. Nvidia seems just as bad as Intel on this one.", "tags": ["graph", "aa", "sinc"], "likes": 7, "viewed": 228, "published": 3, "date": "1669933951", "time_retrieved": "2024-07-30T16:15:42.971470", "image_code": "bool alert = false;\n\nconst vec4 BackgroundColor = vec4(0.0, 0.05, 0.1, 1);\n\n//#define sin(x) (abs(x) < 0.0002 ? (x) : sin(x))\nconst float PI = 3.141592654;\n\nfloat f(float x) {\n //return x;\n float k = exp2(23.0); \n //k /= 0.5*PI; // Nvidia\n //if (abs(x) < 1.0/k) alert = true;\n //if (x < 0.0) return floor(abs(x)*k)/k*sign(x); // Identical to sin(x) for small x\n return(sin(x));\n //return asinh(x);\n //return exp2(x)-1.0;\n}\n\nfloat scale;\nfloat myFunc(float x) \n{ \n    x /= scale;\n    // Write your custom function to plot here.\n    return f(x)/x; \n} \n\nfloat myFunc2(float x) \n{ \n    // Write your custom function to plot here.\n    x /= scale; // Zoom in\n    return 4.0*scale*f(x); \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scale = exp2(26.0*(0.5-0.5*cos(0.5*iTime))-3.0); // Zoom in\n\n    gFragCoord = fragCoord;\n    gResolution = iResolution.xy;\n    \n    fragColor = BackgroundColor;\n    \n    // Draw grids.\n    drawGrid(fragColor, vec2(0.1), vec4(1,0.5,0.5,0.02), vec4(0.5, 1, 0.5, 0.02));\n    drawGrid(fragColor, vec2(1), vec4(1,0.5,0.5,0.1), vec4(0.5, 1, 0.5, 0.1));\n    drawGraph(fragColor, tf(myFunc, fragCoord), vec4(1,1,0,1));\n    drawGraph(fragColor, tf(myFunc2, fragCoord), vec4(1,0,0,1));\n    if (alert) fragColor.b = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Displayed range of the graph.\nconst vec2 mini = vec2(-5, -2);\nconst vec2 maxi = vec2(5, 2);\n\n#define StLine 0\n#define StSolid 1\n#define Style StLine\n\n// Global vars used by overloads when you're lazy.\nvec2 gFragCoord;\nvec2 gResolution;\n\nvec2 fragToView(vec2 fragCoord, vec2 resolution)\n{\n    return mix(mini, maxi, fragCoord / resolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord, vec2 resolution)\n{\n    return (viewCoord - mini) / (maxi - mini) * resolution;\n}\n\nvec2 fragToView(vec2 fragCoord)\n{\n    return fragToView(fragCoord, gResolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord)\n{\n    return viewToFrag(viewCoord, gResolution);\n}\n\nfloat fragToViewX(float fragCoordX, float resolutionX)\n{\n    return mix(mini.x, maxi.x, fragCoordX / resolutionX);\n}\n\nfloat viewToFragY(float viewCoordY, float resolutionY)\n{\n    return (viewCoordY - mini.y) / (maxi.y - mini.y) * resolutionY;\n}\n\nfloat fragToViewX(float fragCoordX)\n{\n    return fragToViewX(fragCoordX, gResolution.x);\n}\n\nfloat viewToFragY(float viewCoordY)\n{\n    return viewToFragY(viewCoordY, gResolution.y);\n}\n\n#define tf(func, fragCoord) (viewToFragY(func(fragToViewX(fragCoord.x))))\n\nfloat getGraphOpacity( in float fragHeight, in float graphHeight )\n{\n    if(isnan(graphHeight) || isinf(graphHeight)) \n        return 0.0;\n    \n    float range = (1.0 + abs(dFdx(graphHeight)));\n    \n    #if Style == StLine\n        range *= 2.0;\n    #endif\n    \n    float upper = graphHeight + range;\n    float lower = graphHeight - range;\n    \n    float value = (fragHeight - lower) / (upper - lower);\n    \n    #if Style == StLine\n        value = (abs(value - 0.5) * 2.0);\n    #endif\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float fragHeight, in float graphHeight, in vec4 color )\n{\n    float opacity = getGraphOpacity(fragHeight, graphHeight);\n    \n    vec4 c = color;\n    c.a *= opacity;\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float graphHeight, in vec4 color )\n{\n    drawGraph(fragColor, gFragCoord.y, graphHeight, color);\n}\n\nvec2 getGridOpacity(in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing)\n{\n    vec2 viewCoord = fragToView(fragCoord, resolution) / gridSpacing;\n    vec2 nearestGridViewCoord = round(viewCoord) * gridSpacing;\n    vec2 nearestGridFragCoord = viewToFrag(nearestGridViewCoord);\n    \n    const vec2 range = vec2(2);\n    \n    vec2 upper = nearestGridFragCoord + range;\n    vec2 lower = nearestGridFragCoord - range;\n    \n    vec2 value = (fragCoord - lower) / (upper - lower);\n    \n    value = (abs(value - 0.5) * 2.0);\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    vec2 opacity = getGridOpacity(fragCoord, resolution, gridSpacing);\n    \n    vec4 cH = colorHorizLines;\n    cH.a *= opacity.y;\n    vec4 cV = colorVertLines;\n    cV.a *= opacity.x;\n    \n    float ratio = cV.a / (cV.a + cH.a);\n    \n    if(isnan(ratio) || isinf(ratio)) ratio = 0.5;\n    \n    vec4 c;\n    c.rgb = mix(cH.rgb, cV.rgb, ratio);\n    c.a = mix(cH.a, 1.0, cV.a);\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    drawGrid(fragColor, gFragCoord, gResolution, gridSpacing, colorHorizLines, colorVertLines);\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n#define assert(x)\nint printfloat(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return 0;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  const int SPACE = 0x20;\n  if (isinf(x)) {\n    if (x < 0.0) CHAR(MINUS);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    if (1.0/x < 0.0) CHAR(MINUS);\n    CHAR(ZERO);\n  } else {\n    if (x < 0.0) CHAR(MINUS) // No semicolon!\n    else CHAR(SPACE);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return 0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdBXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 175, 188, 422], [437, 437, 461, 461, 548], [551, 551, 576, 625, 682], [685, 685, 742, 742, 1258]], "test": "untested"}
{"id": "csSXRW", "name": "sun set cloud hhhh", "author": "Issam_X_Mhadhbi", "description": "coma tag", "tags": ["tagcoma"], "likes": 3, "viewed": 170, "published": 3, "date": "1669933401", "time_retrieved": "2024-07-30T16:15:43.726451", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +(c - a)* u.y * (1.0 - u.x) +(d - b) * u.x * u.y;\n}\n\n#define OCTAVES 8\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(st);\n        st *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\nvec3 draw_sky(vec2 uv ){\n    vec3 c0 = vec3(0.996,0.868,0.297) ; \n    vec3 c1  = vec3(0.996,0.711,0.515) ; \n    vec3 c2 = vec3(0.151,0.694,0.996) ; \n    float h1 = 0.02; \n    if(uv.y <  h1 ){\n        if(uv.y <  0.5*h1 ){\n        float gradient = (uv.y - h1 ) / (h1) ; \n        return mix(c1 , c0  , gradient)  ;  \n        }\n        else\n        {\n        float gradient = (uv.y - h1 ) / (h1) ; \n        return mix(c1 , c0  , gradient)  ;     \n        }\n    }else{\n        float gradient = (uv.y - h1 ) / (h1) ; \n        return mix(c1 , c2  , gradient)  ;       \n    }\n}\n\nfloat sunR = 0.05 ; \nvec3 sunColor = vec3(1.0,1.0,0.8) ; \nvec2 sunpos = vec2(0.5, 0.5  ) ; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x / iResolution.y ; \n\n\tvec3 sky  = draw_sky(st) ; \n    vec3 white = vec3(0.971,1.000,0.785) ; \n    float r = fbm(st*4.0);\n    vec3 color = mix(sky,white,r) ; \n    vec2 uv = st ; \n    float distance_cubic = (uv.x - sunpos.x)*(uv.x - sunpos.x) + (uv.y - sunpos.y)*(uv.y - sunpos.y) ; \n    if (distance_cubic < sunR*sunR ){\n\n    \tcolor = vec4(sunColor,1.0).xyz ; \n    }\n    else{\n\n    \tcolor = vec4(mix(color , sunColor, 1.2*(sunR*sunR)/distance_cubic),1).xyz ; \n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSXRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 99], [102, 102, 128, 128, 443], [463, 463, 487, 509, 760], [762, 762, 786, 786, 1331], [1425, 1425, 1482, 1532, 2121]], "test": "untested"}
{"id": "mdjSz1", "name": "White Flower Transition", "author": "4Axion", "description": "simple transition to white", "tags": ["flower", "transition"], "likes": 0, "viewed": 161, "published": 3, "date": "1669927016", "time_retrieved": "2024-07-30T16:15:44.479438", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 bg = texture(iChannel0,uv);\n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-uv;\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n    vec3 col = 0.7 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float clTime = 3.;\n    if (iTime < 4.)\n    clTime = iTime-1.;\n    \n    float f = cos(a*(clTime*clTime)*40.)+clTime;\n    color = vec3( 1.-smoothstep(f,f+0.02,r) );\n\n    fragColor = bg + vec4(color, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdjSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 526]], "test": "untested"}
{"id": "ddjSz1", "name": "Pixel waves.", "author": "OzoneOnYou", "description": "I really do like it, especially because this was the first time I actually created the thing I wanted to. Also I recomend checking this out on cineshader.", "tags": ["waves", "effect", "rgb", "pixels", "cineshader"], "likes": 9, "viewed": 2078, "published": 3, "date": "1669926259", "time_retrieved": "2024-07-30T16:15:45.237412", "image_code": "#define xPixels 20. //how many horizontal pixels are there\n#define yPixels 45. //how many vertical pixels are there\n#define xSpeed 8. //speed of horiozontal wave movement\n#define ySpeed 1. //speed of vertical movement, lower = faster\n#define yRange 60. //how much will the waves change height, everything above 50 vill result in mirroring (but that's kinda cool)\n\nvec3 hsvToRgb(float h, float s, float v){\n    h = mod(h, 360.);\n    float M = 255. * v;\n    float m = M * (1.-s);\n    float z = (M - m) * (1.- abs(mod(h/60., 2.)-1.));\n    if (h < 60.) return vec3(M/255., (z+m)/255., m/255.);\n    else if (h >= 60. && h<120.) return vec3((z+m)/255., M/255., m/255.);\n    else if (h >= 120. && h<180.) return vec3(m/255., M/255., (z+m)/255.);\n    else if (h >= 180. && h<240.) return vec3(m/255., (m+z)/255., M/255.);\n    else if (h >= 240. && h<300.) return vec3((z+m)/255., m/255., M/255.);\n    else if (h >= 300. && h<360.) return vec3(M/255., m/255., (z+m)/255.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = hsvToRgb(10.*(time*2.+(uv.x+uv.y)), 1., 1.); //makes a hue scroll\n    \n    float sine = ceil(uv.y*yPixels)/yPixels*(25.+sin(time*3.+3.14)*yRange)-(25.+sin(time*3.+3.14)*yRange)/2.+sin(time/ySpeed)*3. - sin(ceil(uv.x*xPixels)/(xPixels*0.083)+time*xSpeed); //creates pixel effect by making a sine and taking a ceil of that\n    \n    col = mix(col, vec3(1), step(sine, 0.5));\n\n    // Output to screen\n    fragColor = vec4(col,sine*sin(time)+cos(time));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddjSz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 405, 405, 965], [967, 967, 1024, 1024, 1609]], "test": "untested"}
{"id": "msjXzh", "name": "watchish", "author": "timmaffett", "description": "还原桌面效果\ni just removed the use of the buffer and fixed to center clock, add 12 hour time option  -tmm\ncustomize with :\n#define TWELVE_HOUR_CLOCK\n#define HOUR_LEADING_ZERO\n", "tags": ["shaderlearn"], "likes": 9, "viewed": 240, "published": 3, "date": "1669922128", "time_retrieved": "2024-07-30T16:15:45.991396", "image_code": "#define TWELVE_HOUR_CLOCK\n//#define HOUR_LEADING_ZERO\n\n//#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 23.;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.5,1.6) * scale;\nvec2 positon=vec2(0.035,0.02);\nvec3 glowColor=vec3(0.23,0.26,1.0);\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n\n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n\n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 positon, float num, vec2 uv)\n{\n\tuv -= positon;\n\tfloat dist = 1e6;\n\tfloat offs = 0.;\n\tfloat space=1.1;\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\n        float a=num / pow(10.0,i);\n\t\tfloat d = mod(a,10.0);\n\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+.9,0.1)*1.46, 0.04,uv));\n\t\t}\n        if(i==2.&&floor(a)>=0.){\n            \n            \n        \tdist = min(dist, dfCircle(vec2(offs+.9,0.1)*1.46, 0.04,uv));\n        }\n\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs+=space;\n\t\t} else if (i==3.||i==2.) {\n#ifdef HOUR_LEADING_ZERO\n            dist = min(dist, dfDigit(pos, 0., uv));\n\t\t\toffs+=space;\n#else\n            if(i==2.&&floor(d)==0.) {\n                dist = min(dist, dfDigit(pos, 0., uv));\n                offs+=space;\n            } else {\n                offs+=space/2.0;\n            }\n#endif\n        }\n\t}\n\n\tfloat shade = 0.0;\n\n\t\tshade = 0.004 / (dist);\n\treturn shade;\n}\n\nfloat CalTime( vec2 origin, float num, vec2 uv){\n\n\tfloat shade ;\n\tfloat h=floor(num/3600.)*100.;\n#ifdef TWELVE_HOUR_CLOCK\n    //h = 0.; //test\n    if(h==0.) h=1200.0;\n    if( h>1200. ) {\n        h -= 1200.;\n    }\n#endif\n\tfloat t=floor( fract(num/3600.)*60.);\n\tfloat s= fract(fract(num/3600.)*60.)*60./100.;\n\tshade=dfNumber(origin,h+t+s,uv);\n\t//shade+=dfNumber(origin+vec2(0.3,0),t,uv);\n//\tshade+=dfNumber(origin+vec2(0.6,0),s,uv);\n\n\n\treturn shade;\n}\n\n\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid timeFont( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\n\tuv-=positon;\n\tfloat n = iDate.w;\n\n\tvec3 color = vec3(0);\n\n\tfloat nsize = numberLength(n);\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n\n\n\tfloat time=CalTime(pos, n, uv);\n\tcolor += glowColor * time;\n\n\n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n\n    color *= 0.25+vec3(smoothstep(0.0,95.0 / iResolution.y,grid))*0.75;\n    #endif\n\n\tfragColor = vec4( color , 1.0 );\n}\n\n\n\n\n\n// Fork of \"myscreen\" by hswangrui. https://shadertoy.com/view/3tdGWS\n// 2022-12-01 19:11:56\n\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n\n\n\nfloat N21(vec2 i){\n\n\n\treturn fract(sin(i.x*45.+i.y*281.)*2363.);\n\n}\n\nvec2 N22(vec2 i){\n\n\tfloat n=N21(i);\n\treturn vec2(n,N21(vec2(n+i+1.)));\n}\n\n\nvec2 GetPos(vec2 id,vec2 offset){\n\tvec2 t =iTime*N22(id+offset)+sin(2.*iTime+sin(iTime))+cos(2.*iTime+cos(iTime));\n\tvec2 dir=vec2(sin(t.x+sin(t.x+sin(t.x))),cos(t.y+cos(t.y-cos(t.x))))*.4;\n\n\treturn dir+offset;\n}\n\nfloat calLineDis(vec2 uv,vec2 p1,vec2 p2){\n\n\t vec2 dir=normalize( p2-p1);\n\t vec2 s=uv-p1;\n\t float l=dot(s,dir);\n\t float d=1.;\n\tvec2 p=l*dir+p1;\n\tvec2 pp1=p-p1;\n\tvec2 pp2=p-p2;\n\t if(dot(pp1,pp2)<0.)\n\t\t  d=sqrt(dot(s,s)-l*l);\n\t float c=S(0.015,0.004,d)*S(1.6,1.1,length(p1-p2));\n\n\n\t return c;\n\n}\n\nvec3 drawLines(vec2 uv,vec2 id){\n\tvec3 col=vec3(0.);\n\t vec2 ray[9];\n\t\t\t int i=0;\n\t\t\t for(int y=-1;y<=1;y++){\n\t\t\t\t for(int x=-1;x<=1;x++){\n\t\t\t\t\t ray[i++]=GetPos(id,vec2(x,y));\n\n\t\t\t\t }\n\n\t\t\t }\n\t\t\t for(int k=0;k<=8;k++){\n\t\t\t\t if(k==4) continue;\n\t\t\t\t col+= calLineDis(uv,ray[4],ray[k]);\n\n\t\t\t }\n\t\t\t col+= calLineDis(uv,ray[3],ray[1]);\n\t\t\t col+= calLineDis(uv,ray[3],ray[7]);\n\t\t\t col+= calLineDis(uv,ray[5],ray[1]);\n\t\t\t col+= calLineDis(uv,ray[5],ray[7]);\n\treturn col;\n\n}\n\nvec3 drawPoints(vec2 uv,vec2 id){\n\n\tvec3 col=vec3(0.);\n\n\tfloat dis=length(uv-GetPos(id,vec2(0.)));\n\tfloat p=S(0.07,0.03,dis); //Point\n\t//glow\n\tvec3 glow=pow(S(0.35,0.01,dis),3.)*vec3(0.3,0.4,1.)*0.64;\n\n\t col=vec3(p);\n\treturn col+glow;\n}\n\nvec3 Background(vec2 uv){\n\n\tvec3 col=vec3(0.);\n\n\tvec3 color1=vec3(vec3(sin(iTime/2.)*0.19,0.2,.35));\n\tvec3 color2=vec3(cos(iTime/2.)*0.42,0.35,0.7);\n\tcol=mix(color1,color2,S(-0.9,0.35,uv.y)) ;\n\n\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragcolor,in vec2 fragcoord){\n\n\tvec2 tile=vec2(15.);\n\tfloat maskradius=0.14;\n\tfloat blur=0.1;\n\n\t\tvec3 col;\n\t\tvec2 uv=(fragcoord/iResolution.xy-.5)* 0.6;\n\t\tuv.x*=iResolution.x/iResolution.y;\n\n\t\tvec2 tileuv=uv*tile;\n\t\tvec2 id=floor(tileuv);\n\t\t  tileuv=fract(tileuv)-0.5;\n\t\t  //mask\n\t\t  vec2 mousepos=iMouse.xy/iResolution.xy-0.5;\n\t\t  mousepos.x*=iResolution.x/iResolution.y;\n\n         vec4 fontfragcolor = vec4(0.);\n\n         timeFont(fontfragcolor,fragcoord);\n         col += fontfragcolor.rgb;\n#ifdef TWOCHANNEL\n\t\t  //font\n\t\t  vec4 font= texture( iChannel0, vec2(uv+0.5) );\n\t\t  \tcol+=font.rgb;\n#endif\n\n\t\t  float mask=S(maskradius+blur,maskradius-blur-0.01,length(uv-mousepos));\n\t\tcol+=drawPoints(tileuv,id)*mask*0.6; //Point\n\t\tcol+=drawLines(tileuv,id)*mask*0.4;\n\n\n\t\t col+=Background(uv);\n\n\t\t  //grid\n\t\tfloat grid = 0.5-max(abs(mod(uv.x*50.0,1.0)-0.5), abs(mod(uv.y*50.0,1.0)-0.5));\n\t\tcol *= 0.95*(uv.y+.9)+vec3(S(-1.5,1.5- uv.y,grid))*0.15;\n\n\n\t\t//circle\n\t\tfloat g=S(0.25,0.3,length(uv));\n\t\tfloat circle1=S(0.30,0.29,length(uv))*g*0.2;\n\t\tfloat circle=S(0.35,0.03,length(uv))*pow(g*3.,2.);\n\t\tcol+=vec3(circle)*vec3(0.5,0.7,1.)*0.5+circle1;\n\t\t//move\n\n\t\tvec2 dir=vec2(0.29*sin(iTime),0.29*cos(iTime));\n\t\tfloat m=pow(S(0.02,0.0001,length(uv+dir)),2.)*0.3;\n\t\t m+=pow(S(0.02,0.0001,length(uv-dir)),2.)*0.3;\n\t\tcol+=m;\n\t\tfragcolor=vec4(col,1.);\n\n\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjXzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 342, 387, 387, 561], [563, 599, 651, 651, 733], [735, 757, 832, 832, 1148], [1150, 1185, 1231, 1231, 3498], [3500, 3523, 3573, 3573, 4516], [4518, 4518, 4566, 4566, 4967], [4971, 5002, 5031, 5031, 5090], [5092, 5092, 5148, 5148, 5674], [5815, 5815, 5833, 5833, 5882], [5884, 5884, 5901, 5901, 5956], [5959, 5959, 5992, 5992, 6170], [6172, 6172, 6214, 6214, 6465], [6467, 6467, 6499, 6499, 6931], [6933, 6933, 6966, 6966, 7169], [7171, 7171, 7196, 7196, 7381], [7383, 7383, 7436, 7436, 8747]], "test": "untested"}
{"id": "msjXzR", "name": "Neon Bridge", "author": "kishimisu", "description": "1. / (1. + pow(abs(d*att), n)) really sums up this scene", "tags": ["raymarching", "light", "bloom", "glow", "shiny", "bright", "glowing", "intensity", "neons"], "likes": 46, "viewed": 931, "published": 3, "date": "1669920440", "time_retrieved": "2024-07-30T16:15:46.766324", "image_code": "/* \"Neon Bridge\" by @kishimisu (2022) - https://www.shadertoy.com/view/msjXzR\n                       \n   Playing around with neon lights and raymarching in 2022 chars =)\n   \n   The light is accumulated at each step of the raymarching\n   and uses this intensity falloff : 1. / (1. + pow(abs(d*att), n))\n   that allow to produce such shiny and glowing colors.\n   \n   The drawback is that I need a fixed number in the raymarching\n   loop as breaking early when hitting a surface don't produce nice\n   results.\n   Fortunately, with 40 steps it already looks really good and doesn't\n   require a top-tier graphic card.\n   \n   I could optimize it more but I currently have exams and not much \n   time so I'm happy with this result !\n*/\n\n// If you find color values that look better for  \n// this scene don't hesitate to share them!\n#define bridgeCol      vec3(.1,1,.8)\n#define bridgePillars  vec3(1,.7,.4)\n#define pillarsCol     vec3(1,.1,.1)\n#define patternsCol    vec3(.8,.6,.3)\n\nfloat box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat rect( vec2 p, vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define rep(p,r) (mod(p+r/2.,r)-r/2.)\n#define lrep(p,c,l) (p-c*clamp(round(p/c),-l,l))\n#define rid(p,r) floor((p+r/2.)/r)\n\nfloat light(float d, float att, float n) {\n    return 1. / (1. + pow(abs(d*att), n));\n}\n\nfloat map(vec3 p, float t, inout vec3 lgt) {\n    float d, b1, b2, lb2, b3, b4, r;\n    vec2 id0, id1;\n    vec3 id3, q, c = cos(p)*.25+.75;\n\n    // Bridge\n    d = rect(p.xy + vec2(0,2), vec2(1.4, 1));\n    \n    // Floor & Ceiling\n    d = min(d, abs(abs(p.y) - 4.));\n    \n    if (abs(p.x) < 1.5) {\n        // Bridge steps\n        q   = p;\n        q.z = lrep(q.z, .7, floor(iTime*8. - 14.));\n        b1  = box(q - vec3(0, -1.1 ,0), vec3(1., .1, .08));\n        d   = min(d, b1);\n        lgt += c*bridgeCol * light(b1, 60., 2.);\n\n        // Bridge pillars\n        q = p;\n        q.x = abs(q.x);\n        q.z = rep(q.z, 1.5);\n        id3 = rid(p, 1.5);\n        b2  = rect(q.xz - vec2(1.2,0), vec2(.1));\n        q.z = lrep(p.z, 1.5, floor(iTime*8.));\n        lb2 = box(q - vec3(1.2,2. + sin(iTime + id3.z)*.5,0), vec3(.1,.3,.1));\n        d   = min(d, b2);        \n        lgt += c*bridgePillars * light(lb2, 80., 2.)*t*.5;\n    }\n    \n    // Ground/Ceiling pattern\n    if (abs(p.y) > 2.) {\n        const float br = 1.5;\n        q     = p;\n        id1   = rid(p.xz, br);\n        r     = fract(dot(sin(id1), (id1+41.21)*24.77));\n        q.xz  = rep(p.xz, br);\n        q.y   = abs(q.y)-4.;\n        q.xz *= rot(1.570796*(.5 + floor(r*2.)));\n        q.x   = abs(q.x)-br*.35;\n        b3    = box(q, vec3(.01,.2,br*.4));\n        d     = min(d, b3);\n        lgt  += c*patternsCol * light(b3, 20., 2.) * exp(-t*.1 - (cos(max(0., iTime - 8.)*.5)*.5+.5)*10.);\n    }  \n    \n    // Distant pillars\n    q    = p;\n    id0  = rid(p.xz, 7.);\n    q.xz = rep(p.xz, 7.);\n    b3   = rect(q.xz, vec2(.5));\n    b3   = max(b3, -abs(p.x) +2.);\n    q.y  = rep(q.y, .5);\n    b4   = box(q, vec3(.5,.04,.5));\n    b4   = max(b4, -abs(p.x) +2.);\n    d    = min(d, b3);\n    if (fract((id0.x+41.11)*sin(id0.y*44.7)) < smoothstep(5., 8., iTime))\n        lgt += c*pillarsCol * light(b4, 40., 2.) * (sin(iTime+p.y*(2.*fract(id0.x*id0.y*47.44))+id0.x*id0.y)*.5+.5);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 O, vec2 F ) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec3 lgt = vec3(0);\n    vec3 ro = vec3(0,0,iTime);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float t = 0.;\n    \n    for (int i = 0; i < 40; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p, t, lgt);\n        t += d;\n    }\n    \n    O = vec4(pow(lgt, vec3(.45)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjXzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[976, 976, 1005, 1005, 1090], [1092, 1092, 1122, 1122, 1200], [1378, 1378, 1420, 1420, 1465], [1467, 1467, 1511, 1511, 3405], [3407, 3407, 3445, 3445, 3781]], "test": "untested"}
{"id": "Dd2Sz1", "name": "Morphing Gilded mosaic", "author": "timmaffett", "description": "A morphing mosaic pattern, *Use mouse*(!) and you can find some cool spots :)\nAll credits to @jarble, I just added some mouse interactivity to morph parameters", "tags": ["fractal", "knot", "mosaic"], "likes": 4, "viewed": 169, "published": 3, "date": "1669918445", "time_retrieved": "2024-07-30T16:15:47.522303", "image_code": "// Fork of \"Gilded mosaic\" by jarble. https://shadertoy.com/view/fscfWB\n// 2022-12-01 17:14:21\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a*iTime);\n\tfloat c = cos(a*iTime);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\nvec2 mouse;\nvec2 triangle_wave(vec2 a){\n    //a = rotate(a,num*radians(180.));\n    vec2 to_return = abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n    //to_return /= 1.5; //makes another interesting pattern\n    return to_return;\n    //return abs(fract((a+vec2(1.,1.5)+num)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n  \n  float theTime = iTime+71.0*59.0;\n#define ONEWAY\n#ifdef ONEWAY\n    vec2 mMouse = (iMouse.xy == vec2(0.)) ? vec2(116.0,292.0) : iMouse.xy;\n    mouse = (mMouse.xy/iResolution.xy)*fract(theTime/73.0);\n    //mouse.x = clamp(mouse.x,-10.,0.5);\n    //mouse.y = clamp(mouse.y,-10.,0.5);\n#else\n    mouse = (iMouse.xy == vec2(0.)) ? vec2(116.0/1280.0,292.0/720.0)*fract(theTime/73.0) : (iMouse.xy/iResolution.xy)*fract(theTime/73.0);\n    //if(mouse.x>0.05&& mouse.y>0.05) mouse = abs(mouse/39.0);\n#endif\n \n     float time1 = iTime/64.;\n//time1 *=(mouse.x);\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 9; k++){\n\n            uv += t2;\n            uv /= scale;\n            t2 = triangle_wave(uv)+mouse;\n            t3 = -triangle_wave(uv.yx-.5)+mouse.yx;\n            uv = t2-t3;\n            \n            col.x = (col.x+max(mouse.x-mouse.y,max(uv.y-uv.x,col.x)))/(2.);\n            \n            //col.y = (col.y+min(mouse.x-mouse.y,max(uv.x-uv.y,col.y)))/(2.);\n            \n            col.x = abs(col.x-.5+mouse.y);\n            col = abs(col.yzx-vec3(col.x/sqrt(2.)))*2.;\n        }\n\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2Sz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 126, 126, 222], [235, 235, 262, 301, 499], [501, 501, 558, 558, 1989]], "test": "untested"}
{"id": "Ds2Sz1", "name": "Square Interlacing", "author": "MysteryPancake", "description": "Creates a cool glassy effect", "tags": ["video", "buffer", "interlace", "interlacing"], "likes": 7, "viewed": 236, "published": 3, "date": "1669916082", "time_retrieved": "2024-07-30T16:15:48.285263", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int scale = 32;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int modFrame = iFrame % scale;\n    vec2 uv = fragCoord / iResolution.xy;\n    if (int(fragCoord.x) % scale == modFrame || int(fragCoord.y) % scale == modFrame) {\n        fragColor = texture(iChannel1, uv);\n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds2Sz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "cdjSz1", "name": "Voronoi Farms", "author": "dr2", "description": "Bird flying over Voronoi-based rural landscape", "tags": ["voronoi", "landscape", "field", "bird", "flight"], "likes": 47, "viewed": 460, "published": 3, "date": "1669913382", "time_retrieved": "2024-07-30T16:15:49.274617", "image_code": "// \"Voronoi Farms\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Note how the patterns and buildings are aligned relative to\n  the ground slope; mousing may be needed fo find bird.\n\n  No. 52 in \"Voronoi\" series - listed at end\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct VVec {\n  vec2 d;\n  float r;\n};\nVVec vVec[7];\n\nmat3 flyerMat;\nvec4 vVal;\nvec3 flyerPos, sunDir, qHit, trkAx, trkFx, trkAy, trkFy;\nvec2 gVec[7], hVec[7], ipp, csCen;\nfloat tCur, dstFar, gScale, szFacFl, fGrnd, wngAng, bkAng;\nint idObj;\nconst int nwSeg = 5;\nconst int idGrnd = 1, idWall = 2, idHut = 3, idTree = 4, idLeaf = 5, idBdy = 6, idTail = 7, \n   idEye = 8, idBk = 9, idWing = 10, idWTip = idWing + nwSeg - 1;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{  // (from \"Painted Bird\")\n  vec3 q;\n  float wSeg, wChord, wSpar, fTap, bkLen, dMin, d, a, wr, wf, ws, ww;\n  wSeg = 0.15;\n  wChord = 0.3;\n  wSpar = 0.02;\n  fTap = 8.;\n  bkLen = 0.2;\n  dMin = dstFar / szFacFl;\n  p = flyerMat * (p - flyerPos) / szFacFl;\n  q = p;\n  q.z -= 0.5;\n  q.x = abs (q.x) - 0.1;\n  a = wngAng;\n  wf = 1.;\n  ws = 0.02 * wChord;\n  for (int k = 0; k < nwSeg; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSeg;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSeg));\n    ww = ws - 0.01 * (q.z / wChord) * (q.z / wChord);\n    q.z += 0.4 * wr * wChord;\n    if (k < nwSeg - 1) {\n      d = length (max (abs (vec3 (q.xz, q.y - 0.5 * ww).xzy) - vec3 (wSeg, ww, wr * wChord),\n         0.)) - wr * wSpar;\n      q.x -= wSeg;\n      DMINQ (idWing + k);\n    } else {\n      q.x += wSeg;\n      d = max (length (abs (max (vec2 (length (q.xz) - wr * wChord,\n         abs (q.y - 0.5 * ww) - ww), 0.))) - wr * wSpar, - q.x);\n      DMINQ (idWTip);\n    }\n    q.z -= 0.4 * wr * wChord;\n    a *= 1.03;\n    wf *= (1. - 1. / fTap);\n    ws *= 0.8 * (1. - 1. / fTap);\n  }\n  q = p;\n  wr = q.z - 0.5;\n  if (wr > 0.) {\n    wr = 0.17 - 0.44 * wr * wr;\n  } else {\n    wr = clamp (0.667 * wr, -1., 1.);\n    wr *= wr;\n    wr = 0.17 - wr * (0.34 - 0.18 * wr); \n  }\n  d = PrCapsDf (q, wr, 1.);\n  DMINQ (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  wr = (q.z + 1.) * (q.z + 1.);\n  q -= vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCapsDf (q, 0.009, 0.2);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.07, 0.05, 0.9);\n  d = PrSphDf (q, 0.04);\n  DMINQ (idEye);\n  q = p;\n  q -= vec3 (0., -0.015, 1.15);\n  q.yz = Rot2D (vec2 (abs (q.y), q.z + 0.8 * bkLen), bkAng);\n  q.z -= 0.8 * bkLen;\n  wr = clamp (0.4 - 0.3 * q.z / bkLen, 0., 1.);\n  d = max (abs (length (max (abs (q) - vec3 (0., 0.25 * wr * bkLen, bkLen), 0.)) -\n     0.25 * wr * bkLen) - 0.002, - q.y);\n  DMINQ (idBk);\n  return 0.8 * szFacFl * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec3 col, c1, c2, c3;\n  float a, r, s, t, sx, spec;\n  spec = 0.2;\n  c1 = vec3 (0.9, 0.8, 0.8);\n  c2 = vec3 (0.3, 0.3, 0.8);\n  c3 = vec3 (0.1, 0.3, 0.1);\n  if (idObj == idEye) {\n    col = vec3 (0., 0., 1.);\n    spec = -1.;\n  } else if (idObj == idBdy || idObj == idTail) {\n    a = atan (abs (qHit.x), qHit.y) / pi;\n    col = mix (c3, mix (c1, c2, smoothstep (0.5, 0.7, a)), smoothstep (0.1, 0.3, a));\n    if (idObj == idBdy && qHit.z > 0. && length (max (abs (vec2 (qHit.x, qHit.y + 0.017)) -\n       vec2 (0., 0.035), 0.)) < 0.025) col = vec3 (1., 0.7, 0.2);\n  } else if (idObj == idBk) {\n    col = vec3 (0.9, 0.4, 0.1);\n  } else if (idObj >= idWing && idObj <= idWTip) {\n    col = (qHit.y > -0.006) ? c3 : c2;\n    t = 0.3 * float (idObj - idWing);\n    sx = 6.66 * qHit.x - 0.52;\n    if (idObj < idWTip || idObj == idWTip && qHit.x < 0.075) col = mix (col, c1, smoothstep (0.,\n       0.01, qHit.z - 0.54 * (abs (cos (pi * sx)) - 0.5) * (1. - 0.4 * t)));\n    r = (length (qHit.xz) - 0.165);\n    a = atan (qHit.z, - qHit.x) / (2. * pi) + 0.5;\n    t = 0.11 * (qHit.x + t) - 0.29;\n    s = (idObj < idWTip) ? step (0., qHit.z + t) * (1. - smoothstep (0.1, 0.2, fract (8. * sx))) :\n       step (0.021, r) * smoothstep (0.8, 0.9, fract (64. * a));\n    col *= 1. - 0.2 * s;\n    s = (idObj == idWTip) ? smoothstep (0., 0.005, r) * (1. - smoothstep (0.3, 0.4, fract (32. * a))) :\n       (1. - smoothstep (0.01, 0.016, qHit.z - t)) * smoothstep (0.6, 0.7, fract (4. * sx));\n    col = mix (col, c1, s);\n  }\n  return vec4 (col, spec);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvoid SetVorp (vec2 ip)\n{\n  vec2 u;\n  ipp = ip;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    vVec[k].d = hVec[k] + 0.5 * (0.4 + 0.6 * u.x) * sin (2. * pi * (u.y - 0.5) +\n       vec2 (0.5 * pi, 0.));\n    vVec[k].r = Hashfv2 (u);\n  }\n}\n\nvec4 HexVor (vec2 fp)\n{\n  vec4 sd;\n  vec2 d, dm;\n  float r;\n  sd = vec4 (4.);\n  dm = vec2 (4.);\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    d = vVec[k].d - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      dm = d;\n      r = vVec[k].r;\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.05) - sd.x, dm, r);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float f, a, aSum;\n  p *= 0.01;\n  f = 0.;\n  a = 1.;\n  aSum = 0.;\n  for (int j = 0; j < 3; j ++) {\n    f += a * Noisefv2 (p);\n    aSum += a;\n    a *= 0.4;\n    p *= 2.5;\n  }\n  return 40. * f / aSum;\n}\n\nfloat VObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 u, pCen, pp, ip;\n  float dMin, d, db, h;\n  dMin = dstFar;\n  pp = p.xz / gScale;\n  ip = PixToHex (pp);\n  if (ipp != ip) SetVorp (ip);\n  vVal = HexVor (pp - HexToPix (ip));\n  pCen = (pp + vVal.yz) * gScale;\n  h = GrndHt (pCen);\n  u = vec2 (GrndHt (pCen + vec2 (0., 0.1)), GrndHt (pCen + vec2 (0.1, 0.))) - h;\n  csCen = sin (atan (u.y, u.x) + vec2 (0.5 * pi, 0.));\n  q = p;\n  q.y -= GrndHt (p.xz);\n  d = q.y;\n  DMIN (idGrnd);\n  d = length (max (abs (vec2 (abs (vVal.x - 0.1), abs (q.y - 0.15))) -\n     vec2 (0., 0.15), 0.)) - 0.03;\n  DMIN (idWall);\n  q = p;\n  q -= vec3 (pCen, h).xzy;\n  q.xz = Rot2Cs (q.xz, csCen);\n  d = max (PrRoundBox2Df (q.xz, vec2 (0.4, 0.2), 0.05), dot (vec2 (q.y, - abs (q.z)),\n     sin (-0.25 * pi + vec2 (0.5 * pi, 0.))) - 0.5);\n  DMINQ (idHut);\n  q.xz -= vec2 (sign (vVal.w - 0.5), 0.7);\n  d = max (length (q.xz) - 0.07, q.y - 1.);\n  DMINQ (idTree);\n  d = PrConCapsDf ((q - vec3 (0., 1., 0.)).xzy, sin (0.08 * pi + vec2 (0.5 * pi, 0.)), 0.17, 0.3);\n  DMINQ (idLeaf);\n  return 0.8 * dMin;\n}\n\nfloat VObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = VObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 VObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = VObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat VObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = VObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, qHitT;\n  vec2 vf, u;\n  float dstObj, dstObjF, sh, f, nDotL;\n  int idObjT;\n  wngAng = -0.03 * pi * (1. + 2. * cos (pi * tCur));\n  bkAng = 0.02 * pi * (1. + sin (3. * pi * tCur));\n  HexVorInit ();\n  ipp = vec2 (-999.);\n  vf = vec2 (0.);\n  dstObjF = ObjRay (ro, rd);\n  idObjT = idObj;\n  qHitT = qHit;\n  dstObj = VObjRay (ro, rd);\n  sh = 1.;\n  if (dstObj < min (dstObjF, dstFar)) {\n    ro += dstObj * rd;\n    vn = VObjNf (ro);\n    f = smoothstep (0.2, 0.4, dstObj / dstFar);\n    if (idObj == idWall) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.) * mix (0.85 + 0.15 * smoothstep (0.4, 0.5,\n         Noisefv3 (16. * vec3 (1., 1., 2.) * ro.xzy)), 0.9, f);\n      vf = vec2 (16., 8.);\n    } else if (idObj == idGrnd) {\n      if (vVal.x < 0.1) {\n        col4 = vec4 (1., 1., 0.5, 0.) * mix (0.7 + 0.3 * Fbm2 (32. * ro.xz), 0.75, f);\n        vf = vec2 (32., 1.);\n      } else {\n        u = Rot2Cs (vVal.yz * gScale, csCen);\n        if (min (PrRoundBox2Df (u, vec2 (0.4, 0.2) - 0.02, 0.02),\n           length (u + vec2 (sign (vVal.w - 0.5), 0.7))) < 0.12) {\n          col4 = vec4 (0.7, 0.7, 0.6, 0.) * (0.5 + 0.5 * Fbm2 (128. * ro.xz));\n          vf = vec2 (32., 1.);\n        } else {\n          col4 = vec4 (HsvToRgb (vec3 (0.15 + 0.25 * vVal.w, 0.9, 1.)), 0.);\n          col4 *= mix (0.85 + 0.15 * sin (fGrnd * dot (ro.zx, csCen)), 0.92,\n             max (f, 1. - smoothstep (0.2, 0.3, - dot (rd, vn))));\n          vf = vec2 (8., 2.);\n        }\n      }\n    } else if (idObj == idHut) {\n      col4 = vec4 (HsvToRgb (vec3 (mod (0.9 + 0.25 * vVal.w, 1.), 0.8, 1.)), 0.1);\n      if (vn.y < 0.01) col4 = mix (vec4 (0.8, 0.7, 0., -1.), col4, smoothstep (0., 0.01,\n         PrRoundBox2Df (vec2 (((abs (qHit.x) < 2. * abs (qHit.z)) ? abs (qHit.x) - 0.18 : qHit.z),\n         qHit.y - 0.25), vec2 (0.1, 0.07), 0.01)));\n      else col4.rgb = mix (col4.rgb, vec3 (1.), 0.5);\n      vf = vec2 (32., 0.1);\n    } else if (idObj == idTree) {\n      col4 = vec4 (0.6, 0.2, 0., 0.);\n      vf = vec2 (32., 0.5);\n    } else if (idObj == idLeaf) {\n      col4 = vec4 (HsvToRgb (vec3 (0.2 + 0.15 * (1. - vVal.w), 1., 0.8)), 0.);\n      vf = vec2 (16., 4.);\n    }\n    sh = VObjSShadow (ro + 0.01 * vn, sunDir);\n    sh = min (sh, 0.6 + 0.4 * smoothstep (0., 0.2, Fbm2 (0.04 * ro.xz - 0.05 * tCur) - 0.4));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * (1. - f));\n    nDotL = max (dot (vn, sunDir), 0.);\n  } else if (dstObjF < dstFar) {\n    dstObj = dstObjF;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n    idObj = idObjT;\n    qHit = qHitT;\n    col4 = ObjCol ();\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n  } else col = SkyCol (rd);\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) col = col4.rgb * (0.3 + 0.7 * sh * nDotL) +\n       col4.a * step (0.95, sh) * sh * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    else col = col4.rgb * (0.2 + 0.8 * max (- dot (rd, vn), 0.));\n    col = mix (col, SkyCol (rd), smoothstep (0.8, 1., dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), abs (dot (trkAy, sin (trkFy * t))), t);\n}\n\nvec3 TrackDir (float t)\n{\n  return vec3 (dot (trkFx * trkAx, cos (trkFx * t)), dot (trkFy * trkAy, cos (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkFx * trkFx * trkAx, - sin (trkFx * t)), 0., 0.);\n}\n\nvoid FlyerPM (float t, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, va, ori, ca, sa;\n  float el, az, rl;\n  flPos = TrackPath (t);\n  vel = TrackDir (t);\n  el = (vu != 0.) ? 0. : -0.2 * sign (vu);\n  el -= ((vu == 0.) ? 1. : 0.3) * asin (vel.y / length (vel));\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  va = cross (TrackAcc (t), vel) / length (vel);\n  rl = ((vu == 0.) ? 10. : 3.) * length (va) * sign (va.y);\n  if (vu < 0.) {\n    el *= -1.;\n    rl *= -1.;\n    az += pi;\n  }\n  ori = vec3 (el, az, rl);\n  ca = cos (ori);\n  sa = sin (ori);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\n#define N_WIN  2\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, vuOrMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float az, el, asp, zmFac, vel, sr, dir;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 600.);// + 1.1 * floor (dateCur.w / 3600.);\n  asp = canvas.x / canvas.y;\n  mSize = (1./4.5) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (- asp, -1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  fGrnd = (vuId == 0) ? 32. : 12.;\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  szFacFl = 0.3;\n  gScale = 4.;\n  trkAx = 8. * vec3 (1.9, 2.9, 4.3);\n  trkFx = 0.15 * vec3 (0.23, 0.17, 0.13);\n  trkAy = 0.2 * vec3 (1.7, 3.7, 0.);\n  trkFy = 0.1 * vec3 (0.21, 0.15, 0.);\n  vel = 1.5;\n  FlyerPM (vel * tCur, 0., flyerPos, flyerMat);\n  flyerPos.y += 10. + GrndHt (flyerPos.xz);\n  dir = (vuId == 0) ? 1. : -1.;\n  FlyerPM (vel * tCur - 2. * dir, dir, ro, vuOrMat);\n  ro.y += 10. + GrndHt (ro.xz);\n  if (vuId != 2) {\n    az = 0.;\n    el = -0.1 * pi;\n    if (mPtr.z > 0. && vuId == regId) {\n      az += 2. * pi * msw.x;\n      el += 0.5 * pi * msw.y;\n    }\n    el = clamp (el, -0.4 * pi, 0.4 * pi);\n    zmFac = 3.;\n  } else {\n    vd = flyerPos - ro;\n    az = 0.5 * pi + atan (- vd.z, vd.x);\n    el = asin (vd.y / length (vd));\n    zmFac = 4.;\n    if (mPtr.z > 0. && vuId == regId) {\n      az += 0.2 * pi * msw.x;\n      el += 0.2 * pi * msw.y;\n    }\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * sin (2. * pi * 0.01 * tCur));\n  if (dir < 0.) sunDir.xz *= -1.;\n  dstFar = 40. * gScale;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    rd = vuMat * rd;\n    if (vuId != 2) rd = rd * vuOrMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.8, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n \"Voronoi\" series:\n   \"Rainbow Cavern\"                  (XsfBWM)\n   \"Honeycomb Voronoi\"               (XsXfDX)\n   \"Desert Town\"                     (XslBDl)\n   \"Smoothed Honeycomb Voronoi\"      (4dsBWl)\n   \"Smoothed Voronoi Landscape\"      (lsffWs)\n   \"Smoothed Voronoi Tunnel\"         (4slfWl)\n   \"Island Flight\"                   (XdBBRR)\n   \"Voronoi Rocks\"                   (ldSBzz)\n   \"Voronoi Towers\"                  (XdBBRh)\n   \"Chocolate Dominoes\"              (ldBfz1)\n   \"Voronoi of the Week\"             (lsjBz1)\n   \"Arctic Patrol\"                   (lsBfzy)\n   \"Twisted Time\"                    (XlsyWH)\n   \"White Folly\"                     (ll2cDG)\n   \"White Folly 2\"                   (ltXfzr)\n   \"Lightweight Lighthouse\"          (XtfBz4)\n   \"Magic Tree 2\"                    (MllBzH)\n   \"Succulent Forest\"                (MlsBzN)\n   \"Voronoi Vegetation\"              (XtlfRM)\n   \"Backlit Lighthouse\"              (4lfBWB)\n   \"Lighthouse with Ship\"            (MtSBR1)\n   \"Into the Woods\"                  (Mddczn)\n   \"Rock Garden\"                     (XdccWn)\n   \"One-Pass Voronoi\"                (Xsyczh)\n   \"Book of the Woods\"               (XsVyRw)\n   \"Metallic Polyhedron\"             (lsGcWm)\n   \"Scrolling Texture Heightmap\"     (MdGBWz)\n   \"River Flight 2\"                  (4l3cz8)\n   \"Penguins Can't Fly\"              (ltVyzh)\n   \"One-Pass Voronoi with Spirals\"   (tsfXDl)\n   \"Voronoi Comparison\"              (WsSXzz)\n   \"Varying Mesh\"                    (tlfXWH)\n   \"Riding the Textured Tunnel\"      (WdVXzD)\n   \"Dynamic Space Rocks\"             (WsGSzt)\n   \"Planet Reboot\"                   (wldGD8)\n   \"Caged Kryptonite\"                (3ltSDn)\n   \"Cave Dolphins\"                   (wdSyRD)\n   \"Big Momavirus\"                   (Wd2yzm)\n   \"Channeling Marbles\"              (wtfcRr)\n   \"Gliders Over Voropolis\"          (WdKcz1)\n   \"Balls In Motion\"                 (WdGBRG)\n   \"Wobbly Blob 2\"                   (tsGfzV)\n   \"Floppy Column\"                   (wtccR4)\n   \"Soup Can Dynamics\"               (3tKyRt)\n   \"Dolphin Orb\"                     (sdBXRD)\n   \"Channeling Slime\"                (NdSSR3)\n   \"Flaming Asteroids\"               (NtSGzt)\n   \"Mesh Dome\"                       (ssKXRt)\n   \"Melange\"                         (slKXD3)\n   \"Voronoi Farms\"                   (cdjSz1)\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdjSz1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1590, 1590, 1612, 1638, 3493], [3495, 3495, 3528, 3528, 3711], [3713, 3713, 3734, 3734, 3984], [3986, 3986, 4023, 4023, 4252], [4254, 4254, 4270, 4270, 5795], [5797, 5797, 5817, 5817, 6037], [6039, 6039, 6063, 6063, 6303], [6305, 6305, 6328, 6328, 6731], [6733, 6733, 6756, 6756, 6956], [6958, 6958, 6981, 6981, 8012], [8014, 8014, 8048, 8048, 8253], [8255, 8255, 8277, 8277, 8533], [8535, 8535, 8573, 8573, 8803], [8805, 8805, 8828, 8828, 8991], [8993, 8993, 9028, 9028, 12075], [12077, 12077, 12103, 12103, 12190], [12192, 12192, 12217, 12217, 12315], [12317, 12317, 12342, 12342, 12416], [12418, 12418, 12484, 12484, 13155], [13175, 13175, 13231, 13231, 16237], [16239, 16239, 16286, 16286, 16333], [16335, 16335, 16368, 16368, 16395], [16397, 16397, 16440, 16440, 16504], [16506, 16506, 16561, 16561, 16827], [16829, 16829, 16853, 16853, 17083], [17085, 17085, 17109, 17109, 17169], [17171, 17171, 17207, 17207, 17413], [17415, 17415, 17445, 17445, 17558], [17560, 17560, 17591, 17591, 17655], [17657, 17657, 17679, 17679, 17706], [17708, 17708, 17730, 17730, 17757], [17759, 17759, 17804, 17804, 17896], [17898, 17898, 17922, 17922, 18044], [18078, 18078, 18102, 18102, 18162], [18164, 18164, 18188, 18188, 18300], [18302, 18302, 18326, 18326, 18469], [18471, 18471, 18496, 18496, 18682], [18684, 18684, 18709, 18709, 18934], [18936, 18936, 18957, 18957, 19112], [19114, 19114, 19143, 19143, 19355], [19357, 19357, 19396, 19396, 19648]], "test": "untested"}
{"id": "DsjXRh", "name": "Ellipse lagrange multiplier", "author": "NinjaKoala", "description": "An ellipse and a curve derived from the lagrange multiplier with respect to the distance to the mouse point.\nBackground is the visualization of the basins of attraction for an iteration which computes the intersection of both curves.", "tags": ["2d", "distancefield", "distance", "curve", "implicit", "ellipse", "lagrange"], "likes": 5, "viewed": 219, "published": 3, "date": "1669906430", "time_retrieved": "2024-07-30T16:15:50.044559", "image_code": "/*\nThe lagrange multiplier is used to optimize some function f(x,y), where all points\nhave to evaluate to zero for another function g(x,y).\n(See https://en.wikipedia.org/wiki/Lagrange_multiplier)\n\nIt can be used to compute the distance of a point p to an implicit curve g(x,y)\nby setting f(x,y) = distance((x,y), p). (Squared distance is a better idea, though ;))\n\nYou get a system of three equations in three variables x,y,λ:\n\nx-p.x + λ*diff(g,x) = 0\ny-p.y + λ*diff(g,y) = 0\ng(x,y) = 0\n\nYou can compute the resultant of the first two equations with respect\nto λ to get another implicit curve g1(x,y) (this is the green one).\n(See https://en.wikipedia.org/wiki/Resultant)\n\nThe intersection of both curves are the points on the ellipse\nwith local minimal distance to p.\n\nYou could compute another resultant to get those intersection points,\nbut here i'm using a simple iterative approach.\n(Gradient descent to both curves alternatingly)\n\nThe blue curve is the ellipse, the green curve the curve derived\nfrom the lagrange multiplier.\n\nIn the background you can see for each pixel where the iteration\nconverges there. (Basins of attraction)\n(This is based on https://www.shadertoy.com/view/3sScWR)\n\n\n\nBy uncommenting the define, you can get the distance to the ellipse\ncomputed this way.\n\nYou could probably get the exact distance by cleverly choosing the starting\npoint of the iteration (or several starting points),\nif you just use the current pixel coordinate (like i do),\nthe distance field is broken in the middle of the ellipse\n\n*/\n//#define SHOW_DISTANCE_FIELD\n\nvec3 bg_col = vec3(1);\nvec3 ellipse_col = vec3(0,0,1);\nvec3 lag_curve_col = vec3(0,1,0);\nvec3 dot_col = vec3(0);\n\nfloat line_width = .001;\nfloat dot_size = .01;\n\nfloat zoom = 2.;\n\nfloat ellipse_param = 3.;\n\nconst int num_iterations = 16;\nint aa = 2;\n\nfloat pi = 3.1415925;\n\nfloat ellipse(vec2 p, out vec2 grad){\n\tgrad = vec2(2,2.*ellipse_param) * p;\n\treturn p.x*p.x + ellipse_param*p.y*p.y - 1.;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n\tgrad = vec2(-2.*p2.y + (2. - 2.*ellipse_param)*p.y, 2.*ellipse_param*p2.x + (2. - 2.*ellipse_param)*p.x);\n\treturn 2.*ellipse_param*p2.x*p.y - 2.*p2.y*p.x + (2. - 2.*ellipse_param)*p.x*p.y;\n}\n\nvec2 iteration(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1 = ellipse(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\tp_val2 = lagrange_curve(p,p2,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\treturn p;\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n    mouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 2./iResolution.y;\n\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tuv *= zoom;\n\tmouse *= zoom;\n\tborder *= zoom;\n\n\tconst mat2 aa_rot = mat2(1.,.5,-.5,1.);\n\n\tvec3 col_sum = vec3(0);\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\taa = 1;\n\tmouse = uv;\n\t#endif\n\n\tvec2 p1;\n\tfor(int x = 0;x<aa;x++){\n\t\tfor(int y = 0;y<aa;y++){\n\t\t\tvec2 aa_offset = (vec2(x,y)-.5*(float(aa)-1.))/float(aa);\n\t\t\taa_offset *= zoom*vec2(aspect_ratio,1)/iResolution.xy;\n\t\t\tp1 = uv+aa_offset;\n\n\t\t\tfor(int i = 0;i<num_iterations;i++){\n\t\t\t\tp1 = iteration(p1, mouse);\n\t\t\t}\n\n\t\t\tcol_sum += pow(to_col(p1),vec3(2.2));\n\t\t}\n\t}\n\n\tbg_col = pow(col_sum/(float(aa)*float(aa)),vec3(1.0/2.2));\n\tbg_col *= .75;\n\n\tvec3 color = bg_col;\n\tfloat dis = 1e38;\n\n\tvec2 ellipse_grad;\n\tfloat ellipse_val = ellipse(uv, ellipse_grad);\n\n\tdis = min(dis, abs(ellipse_val / length(ellipse_grad)) - line_width);\n\tcolor = mix(ellipse_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n\tvec2 lag_curve_grad;\n\tfloat lag_curve_val = lagrange_curve(uv,mouse,lag_curve_grad);\n\n\tdis = min(dis, abs(lag_curve_val / length(lag_curve_grad)) - line_width);\n\tcolor = mix(lag_curve_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n\tdis = min(dis, distance(uv,p1) - dot_size);\n\tcolor = mix(dot_col,color,smoothstep(0.,border,dis));\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\tdis = distance(uv,p1);\n\tfloat sgn = 1.;\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\t#endif\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsjXRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1844, 1844, 1881, 1881, 1967], [1969, 1969, 2022, 2022, 2214], [2216, 2216, 2248, 2248, 2471], [2473, 2473, 2497, 2497, 2573], [2575, 2575, 2595, 2595, 2715]], "test": "untested"}
{"id": "dsBXR1", "name": "water dragons", "author": "lomateron", "description": "click to interact\nkey W to reset\n.xy = velocity\n.z = mass\nBuffer A tab applies some convolution and the result is in .xy\nthis result is added to the velocity in Buffer B tab\nBuffer C tab moves the velocity and mass using the velocity", "tags": ["fluid"], "likes": 25, "viewed": 382, "published": 3, "date": "1669896315", "time_retrieved": "2024-07-30T16:15:51.020948", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    vec4 a = texture(iChannel0,u);\n    fragColor = (vec4(length(a.xy),a.xy,0)*.3+.5)*a.z*.6;\n    //fragColor = a;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4  r = vec4(0);\n    vec4  a = A(u);\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        float l = length(vec2(i,j));\n        if((i==0.&&j==0.)|| l>z-.1){continue;}\n        vec2  c = normalize(vec2(i,j));\n        vec4  a2= A(u+vec2(i,j));\n        vec2  b = a2.xy-a.xy;\n        float d = length(a2.xy)-length(a.xy)*1.3;\n        r.xy += c*abs(d)*exp(-l*l*.16)*1.2;\n        r.xy += c*(a2.z-a.z)*exp(-l*l*.16);\n    }}\n    fragColor = r;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec2 v = u/iResolution.xy;\n    vec4 t = A(u);\n    vec2 m = +t.xy\n             +B(u).xy*.1\n             -float(v.x<.01)*vec2(1,0)  //wall\n             -float(v.y<.01)*vec2(0,1)  //wall\n             +float(v.x>.99)*vec2(1,0)  //wall\n             +float(v.y>.99)*vec2(0,1); //wall;\n    float s = 0.;\n    float z = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec2 c = (m+vec2(i,j))*.9;\n        s += exp(-dot(c,c));\n    }}\n    if(s==0.){s = 1.;}\n    s = 1./s;\n    \n    fragColor = vec4(m,s,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define B(u) texture(iChannel1,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float tz = 0.;\n    vec4  a  = vec4(0);\n    float z  = 6.;//kernel convolution size\n    for(float i=-z; i<=z; ++i){\n    for(float j=-z; j<=z; ++j){\n        if(length(vec2(i,j))>z-.1){continue;}\n        vec4 t = A(u+vec2(i,j));\n        vec4 m = B(u+vec2(i,j));\n        vec2 c = (m.xy-vec2(i,j))*.9;\n        float z = t.z*exp(-dot(c,c));\n        a.xy += z*m.xy;\n        a.z  += z*m.z;\n        tz   += z;\n    }}\n    if(tz==0.){tz = 1.;}\n    a.xy /= tz;\n    //a = A(u);\n    if(iMouse.z>0.)\n    {\n        vec2 m = 22.*(u-iMouse.xy)/450.;\n        a += vec4(m,0,0)*exp(-dot(m,m));\n    }\n    float keyW = texture( iChannel2, vec2(87.5/256.,.25) ).x;\n    if(iFrame==0||keyW!=0.)\n    {\n        vec2 m = 4.*(u*2.-iResolution.xy)/iResolution.y;\n        a = vec4(0,0,1,0)-vec4(m,0,0)*exp(-dot(m,m));\n    }\n    fragColor = a;\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsBXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 212]], "test": "untested"}
{"id": "Dd2SRz", "name": "Mandelbrot set for arbitrary pow", "author": "iluha168", "description": "Black and white render\nDrag your mouse across the output!", "tags": ["fractal", "mandelbrot"], "likes": 4, "viewed": 211, "published": 3, "date": "1669895600", "time_retrieved": "2024-07-30T16:15:51.782911", "image_code": "#define MAX_ITER 100\n\nconst float halfPI = 1.57079632679;\n\nfloat atan2(vec2 xy){\n    if(xy.x>0.) return atan(xy.y/xy.x);\n    if(xy.y>0.) return halfPI-atan(xy.x/xy.y);\n    if(xy.y<0.) return -halfPI-atan(xy.x/xy.y);\n    if(xy.x<0.) return atan(xy.y/xy.x) + 2.*halfPI;\n}\n\nvec2 cis(float t){\n    return vec2(cos(t), sin(t));\n}\n\nvec2 toPolar(vec2 ab){\n    return vec2(length(ab), atan2(ab));\n}\nvec2 toCartesian(vec2 rt){\n    return cis(rt[1]) * rt[0];\n}\n\nvec2 complexPow(vec2 rt, vec2 ab){\n    //polar\n    return vec2(exp(ab[0]*log(rt[0])-rt[1]*ab[1]), ab[1]*log(rt[0])+rt[1]*ab[0]);\n}\n\nint mandelbrot(vec2 c){\n    vec2 z = c;\n    int i = 0;\n    vec2 m = iMouse.xy;\n    if(m == vec2(0)) m = (vec2(sin(iTime), cos(iTime/2.+1.9))+2.)*100.;\n    vec2 two = vec2(2,0) + (m/iResolution.xy*2.-1.);\n    while(abs(z.x*z.x + z.y*z.y) <= 4. && i < MAX_ITER){\n        z = toCartesian(complexPow(toPolar(z), two)) + c;\n        i++;\n    }\n    return i;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    //x [-2; 1]\n    //y [-1; 1]\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*3. - 2.;\n    uv.y = uv.y*2. - 1.;\n    // Output to screen\n    float col = 1.-float(mandelbrot(uv))/float(MAX_ITER);\n    fragColor.rgb = vec3(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2SRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 80, 80, 269], [271, 271, 289, 289, 324], [326, 326, 348, 348, 390], [391, 391, 417, 417, 450], [452, 452, 486, 498, 582], [584, 584, 607, 607, 937], [939, 939, 994, 1062, 1267]], "test": "untested"}
{"id": "ddBXR1", "name": "Mandelbrot set out of Julia sets", "author": "iluha168", "description": "Drag mouse to set size of grid element", "tags": ["fractal", "julia", "grid", "mandelbrot"], "likes": 5, "viewed": 179, "published": 3, "date": "1669895585", "time_retrieved": "2024-07-30T16:15:52.536895", "image_code": "#define MAX_ITER 100\n#define JULIA_SCALE 1.7\n#define I_SQUARED -1.\n\nfloat julia(vec2 z, vec2 c){\n    int i = 0;\n    while(dot(z,z) <= 4. && i < MAX_ITER){\n        z = vec2(z.x*z.x + I_SQUARED*z.y*z.y, 2.*z.x*z.y) + c;\n        i++;\n    }\n    return float(i)/float(MAX_ITER);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    vec2 uv = 2.*(fragCoord - .5*iResolution.xy)/iResolution.y - vec2(.5,0);\n    // Output to screen\n    float s = iMouse.x/1000.;\n    if(s == 0.) s = (sin(iTime)+1.)/2.0;\n    float m = julia((fract(uv/s)-0.5)*JULIA_SCALE, s*floor(uv/s));\n    float col = 1.-m;\n    fragColor.rgb = vec3(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddBXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 96, 96, 275], [277, 277, 332, 368, 662]], "test": "untested"}
{"id": "DsBXz1", "name": "Jellyroid - v2 ( 210 chars )", "author": "FabriceNeyret2", "description": "(golfed) variant of \"Jellyroid \" by Alpaga.  [url] https://shadertoy.com/view/dsXSRs  [/url]\n", "tags": ["transparency", "2tweets", "gyroid", "jelly", "short", "golf"], "likes": 47, "viewed": 597, "published": 3, "date": "1669884872", "time_retrieved": "2024-07-30T16:15:53.364682", "image_code": "// (golfed) variant of \"Jellyroid \" by Alpaga. https://shadertoy.com/view/dsXSRs\n\nvoid mainImage( out vec4 O, vec2 I ) {\n    float t = .5*iTime, w = 1.;\n    vec3  d = normalize( vec3( I+I, 0 ) - iResolution.xyy ), // Ray direction\n          p = 5.*( vec3(sin(t), -t, cos(t)) + d );           // Ray origin\n // p += d*fract(sin(dot(d + p, vec3(1)))*1e5)*.1;           // optional dithering (Shane)\n      \n    for( O*=0.; O.a++ < 1e2; w*=.98 )                        // March\n        abs( dot( sin( p +=.1*d ), cos(p.yzx) ) ) < .1 ? O += w/20. : O;\n}             // Gyroid\n          // variant:  abs ( dot(,)  - 1.4 ) < .1 ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBXz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 120, 120, 548]], "test": "untested"}
{"id": "csBXz1", "name": "some pb wth floor(-x), fract(-x)", "author": "FabriceNeyret2", "description": "at some fragCoord scaling, uv can be plain interger, which can cause artifacts with floor, fract, ceil", "tags": ["artifacts"], "likes": 3, "viewed": 212, "published": 3, "date": "1669883462", "time_retrieved": "2024-07-30T16:15:54.176511", "image_code": "void mainImage( out vec4 O,  vec2 U ) {\n    bool bottom = U.y < iResolution.y/2.;\n\n // U /= .1*iResolution.y;                 // issue with resolution x * 281\n    U /= 140.5;                            // some U values give plain integers\n    float x = U.x; \n    O = vec4( floor(x) + floor(-x) +1. );  // ... there, floor(-x) != -floor(x)\n  //O = vec4( fract(x)+ fract(-x) );       // so there, fract(-x) != 1-fract(x)\n  \n    if (bottom) O = vec4(fract(x), fract(-x) ,0,0); \n // O = vec4( fract(x), bottom ? 1.-fract(x) : fract(-x) ,0,0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csBXz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 540]], "test": "untested"}
{"id": "mslSzj", "name": "the flag of Romania - 006", "author": "catafest", "description": "... a simple flag of Romania build for 1 december 2022, with the test of iChannel0: the anthem of Romania.\n", "tags": ["math", "flag", "romania", "catafest"], "likes": 2, "viewed": 236, "published": 3, "date": "1669874454", "time_retrieved": "2024-07-30T16:15:55.029231", "image_code": "//The flag is coincidentally very similar to the civil flag of Andorra and \n//the state flag of Chad. \n//The similarity with Chad's flag, which is identical apart from allowing a broader range of shades of \n//blue, yellow and red, has caused international discussion. \n//see https://en.wikipedia.org/wiki/Flag_of_Romania\n//the gl_FragColor is a vec4 type of float values in the range 0 to 1.\n\n// 01 december 2022\n\n// based on my old shader https://www.shadertoy.com/view/tsGXRy\n// but rebuild to understand \n// how the time, shadow and colors can be linked \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    \n    // defined time \n    float t = 1.5*iTime;\n    \n    // defined wave time\n\tuv.y += 0.131*sin(3.0*uv.x-t);\n    \n    // defined shadows formula\n    float formula_waves_sim = 1.0+0.4*sin(5.0*(uv.x*+uv.y+cos(1.0*texture(iChannel0, uv).y+5.1*uv.y)+0.012*t));\n    \n   \n    // create gray color \n    vec4 col = vec4(0.9,0.9,0.9,1)*vec4(formula_waves_sim);\n    \n    // multiply with each color of flag \n    \n    // fill the screen with red\n    fragColor = vec4(1,0,0,0)*col;\n    // fill the 2/3 of size with yellow color\n    if(uv.x<(1.0/1.5))\n    fragColor = vec4(1,1,0,0)*col;\n    // fill the last 1/3 with the blue color \n    if(uv.x<1.0/3.0)\n    fragColor = vec4(0,0,1,0)*col;\n}\n\n", "image_inputs": [{"id": 30581, "src": "https://soundcloud.com/nationalanthems/desteapta-te-romane", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mslSzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 616, 666, 1412]], "test": "untested"}
{"id": "dsjSRz", "name": "Mipmaps & textureGrad()", "author": "mla", "description": "Two set of rings rotating in opposing directions, at different speeds. Original shader by @hamoid.\n\nThe rotation breaks the antialiasing if texture() is used (on the left). Solution - use textureGrad() (on the right).", "tags": ["circles", "rings"], "likes": 2, "viewed": 222, "published": 3, "date": "1669850018", "time_retrieved": "2024-07-30T16:15:55.840063", "image_code": "const int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nmat2 rot(float a) {\n    return mat2(sin(a), cos(a), -cos(a), sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos ) {\n    vec2 uv = (pos-0.5*iResolution.xy)/iResolution.y;\n    float l = 55.*length(uv);\n    vec4 ring = vec4(smoothstep(-0.1, 0.1, sin(l)));\n    \n    float l2 = l / 6.2831855 - 5.;\n    l2 = iTime * floor(l2) * .02;\n    vec2 dx = vec2(1.0/iResolution.y,0.0); // same as dFdx(uv);\n    vec2 dy = vec2(0.0,1.0/iResolution.y); // same as dFdy(uv);\n    mat2 m = rot(l2); // Pre and post rotation give opposite rotations\n    if (uv.x < 0.0) {\n      fragColor = mix(\n              texture(iChannel0,m*uv),\n              texture(iChannel0,uv*m),\n              ring);\n    } else {\n      mat2 m1 = key(CHAR_X) ? m : mat2(1);\n      fragColor = mix(\n              textureGrad(iChannel0,m*uv,m1*dx,m1*dy),\n              textureGrad(iChannel0,uv*m,dx*m1,dy*m1),\n              ring);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsjSRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 166, 166, 218], [220, 220, 271, 271, 1043]], "test": "untested"}
{"id": "dssXWN", "name": "2023", "author": "catafest", "description": "Happy New Year 2023! \nmy shader builds for the year 2023.", "tags": ["catafest", "2023"], "likes": 7, "viewed": 162, "published": 3, "date": "1672523526", "time_retrieved": "2024-07-30T18:38:27.968761", "image_code": "mat2 rotate2d(float angle){\n   return mat2(\n       cos(angle),-sin(angle),\n       sin(angle),cos(angle)\n   );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //f = texelFetch(iChannel0, ivec2(g),0);\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    float a = 3.1415/6.;\n    float a_cos = cos(a);\n    float a_sin = sin(a);\n    mat2 rot = mat2(a_cos, -a_sin, a_sin, a_cos); \n    for (float i=0.0; i<3.; i++ )\n        uv = abs(uv*rot);  \n    for (int i = 0; i <11; i++) {\n        float a = atan(uv.y, uv.x)*(0.5 + cos(iTime*0.2)*uv.y);\n        a_sin = sin(a);\n        a_cos = cos(a);\n        uv = uv * mat2(a_cos, -a_sin, a_sin, a_cos);\n        uv.y = abs(uv.y) + sin(iTime)*0.4 *uv.x;\n        uv.x += 0.2+ sin(iTime)*0.02 + 0.02;\n    }\n    uv /= 3.1;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    uv *= rotate2d(iTime)*12.0; // Scale the coordinate system by 10\n    vec2 int_pos = floor(uv);  // get the integer coords\n    vec2 float_pos = fract(uv);  // get the fractional coords\n\n    // rand for cell\n    vec3 color = a+vec3(uv.x-uv.y);\n\n    // color\n    color =vec3(0);\n    color *= vec3(11.0, 11.0, 11.0);\n    // Time varying pixel color\n    vec3 col = sin(uv.xyx+vec3(cos(1.0/iTime),sin(1.0/iTime),(int_pos/iTime).x*cos(1.0/iTime)));\n        fragColor = vec4(\n        smoothstep((int_pos/iTime).x, (int_pos/iTime).y, fract(abs(uv.y-(float_pos/iTime).x)+iTime)),\n        smoothstep((int_pos/iTime).x, (int_pos/iTime).y, fract(abs(uv.y-(float_pos/iTime).x)+iTime)),\n        smoothstep((int_pos/iTime).x, (int_pos/iTime).y, fract(abs(uv.y-(float_pos/iTime).x)+iTime)),\n    1.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31793, "src": "https://soundcloud.com/mdindir16/abba-happy-new-year-www", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssXWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 111], [113, 113, 170, 216, 1772]], "test": "untested"}
{"id": "Dlf3Df", "name": "Swetugg for Windows Terminal", "author": "mrange", "description": "CC0: Swetugg for Windows Terminal\nPorting the Swetugg logo to windows terminal\nLots of random hacking to make the colors pop a bit.\n\nhttps://mrange.github.io/windows-terminal-shader-gallery/", "tags": ["2d", "swetugg"], "likes": 13, "viewed": 341, "published": 3, "date": "1672514754", "time_retrieved": "2024-07-30T18:38:28.923209", "image_code": "// CC0: Swetugg for Windows Terminal\n//  Porting the Swetugg logo to windows terminal\n//  Lots of random hacking to make the colors pop a bit.\n\n// https://mrange.github.io/windows-terminal-shader-gallery/\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangle(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat polygon5(vec2 p, vec2[5] v) {\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=5-1; i<5; j=i, i++ ) {\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n    bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n    if( all(c) || all(not(c)) ) s*=-1.0;  \n  }\n  return s*sqrt(d);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat polygon8(vec2 p, vec2[8] v) {\n  float d = dot(p-v[0],p-v[0]);\n  float s = 1.0;\n  for( int i=0, j=8-1; i<8; j=i, i++ ) {\n    vec2 e = v[j] - v[i];\n    vec2 w =    p - v[i];\n    vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n    d = min( d, dot(b,b) );\n    bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n    if( all(c) || all(not(c)) ) s*=-1.0;  \n  }\n  return s*sqrt(d);\n}\n\nvec3 swetugg(vec2 p) {\n  const vec2[8] p2 = vec2[8](\n    vec2(0.98, 0.965)-0.98*vec2(1.0, 0.67)\n  , vec2(0.98, 0.965)\n  , vec2(1.245, 0.935)\n  , vec2(1.13, 0.165)\n  , vec2(1.18, -0.09)\n  , vec2(0.91, -0.625)\n  , vec2(0.405, -0.97)\n  , vec2(0.00, 0.08)\n  ); \n\n  const vec2[5] p3 = vec2[5](\n    vec2(-0.1, -0.8)\n  , vec2(0.082, -0.42)\n  , vec2(0.045, 0.18)\n  , vec2(0.1, 0.38)\n  , vec2(-0.1, 0.4)\n  );\n  \n  p.x = abs(p.x);\n  float d3 = polygon5(p, p3);\n\n  p.x *= mix(0.95, 1.05, (0.5+0.5*sin(TAU*TIME*5.0))*smoothstep(0.9, 1.0, sin(TAU*TIME/10.0)));\n  float d0 = triangle(p, vec2(0.055, -0.07), vec2(0.405, -0.97), vec2(0.91, -0.625));\n  float d1 = triangle(p, vec2(1.13, 0.165)-1.18*vec2(1.0, 0.0375), vec2(1.245, 0.935), vec2(1.13, 0.165));\n  float d2 = polygon8(p, p2);\n\n  float dx = d0;\n  dx = min(dx, d1);\n  float dy = d2;\n  float dz = d3;\n  \n  return vec3(dx, dy, dz);\n}\n\nvec3 df(vec2 p) {\n  const float z = 0.5;\n  const mat2 rot = ROT(radians(7.0));\n  p /= z;\n  p.xy *= rot;\n  return swetugg(p)*z;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 dd = df(p);\n  float dt = min(min(dd.x, dd.y), dd.z);\n\n  const vec3 col0 = vec3(104.0, 0.0, 19.0)/255.0;\n  const vec3 col1 = vec3(166.0, 0.0, 31.0)/255.0;\n  const vec3 col2 = vec3(16.0, 16.0, 17.0)/255.0;\n\n  vec3 col  = 0.1*sqrt(col0);\n  col += col1*exp(-20.0*dd.z*dd.z);\n  col = mix(col, col1*2.0, smoothstep(aa, -aa, abs(dt)-0.005));\n  col = mix(col, col1*mix(0.5, 1.0, 40.0*dd.y*dd.y), smoothstep(aa, -aa, dd.y));\n  col = mix(col, col0*mix(0.5, 1.0, 30.0*-dd.x), smoothstep(aa, -aa, dd.x));\n  col = mix(col, col2*20.0*-dd.z, smoothstep(aa, -aa, dd.z));\n  \n  col *= 1.5*smoothstep(1.25, 0.0, length(pp));\n  col = sqrt(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, pp);\n \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlf3Df.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 560, 560, 706], [1001, 1119, 1170, 1170, 1735], [3637, 3637, 3654, 3654, 3765], [3767, 3767, 3797, 3797, 4477], [4479, 4479, 4536, 4536, 4714]], "test": "untested"}
{"id": "mts3Wj", "name": "kiosk", "author": "spqr", "description": "a", "tags": ["a"], "likes": 9, "viewed": 249, "published": 3, "date": "1672509805", "time_retrieved": "2024-07-30T18:38:29.790890", "image_code": "\n\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nfloat hash12(vec2 p ) {\n  float a = fract(sin(p.x * 4321.531) * 9831.113);\n float b = fract(sin(p.y * 5959.951) * 7891.517);\n float c = fract(\n sin(a * 4523.232 + b * 5490.954) * 9954.234);\n return c;\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\nfloat fbm(in vec3 p)\n{   \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise(freq * p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nfloat bi_fbm(in vec3 p)\n{\n    return 2.0 * fbm(p) - 1.0;\n}\n\nvec3 warp(in vec3 p)\n{\n    p = p + bi_fbm(0.4*p + mod(0.5*iTime, 100.0));\n    p = p + bi_fbm(0.4*p - mod(0.3*iTime, 100.0));\n    return p;\n}\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\nfloat wave(vec3 p) {\n\n   float elv = 0.;\n   for (float i = 0.; i < 11.; i++) {\n     p.xz *= rot(rnd(i ));\n     p.yz *= rot(rnd(i+1.)*.32*2.);\n     p.xy *= rot(i*5.);\n    \n     float q = 1.3 + abs(sin(11.1/30.)/10.);\n     elv += cos((p.x + (i *171.9))/(10./pow(q,i))) * (4./pow(q,i));\n     elv += cos((p.z * .61 + (i *61.2))/(10./pow(q,i))) *  (4./pow(q,i));\n  \n   \n\n   }\n   \n   return pow(elv,.3);\n}\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\nvec3 bezier( float t ){\n  vec3 one = lattice(floor(t));\n  vec3 two = lattice(floor(t+1.));\n  float per = fract(t);\n  \n  return mix(one,two,per);\n  \n}\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\nfloat slomo ( float x) {\n  x = mod(x,10.);\n  \n  float z = (pow(x-5.,6.)/( pow(x-5.,6.) + 1. ) );\n  return z;\n}\n\n\n\n\n\n\n\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s =10.;\n  for ( float i = 0.; i <5.; i++ ) {\n \n    p.yz *= rot((t + i));\n    p.xz *= rot((t - i) * .7);\n    \n   \n    p = abs(p);\n    \n    p -= s;\n    s *= 0.7;\n  }\n  return p;\n}\nfloat box(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n    //pt.xz=pt.x<pt.z?pt.zx:pt.xz;\n  }\n  return pt;\n}\n\n\nfloat chassi (vec3 p) {\n   p.z *= .5;\n   float a = tor(vec3(p.x/1.,p.y/1.,p.z/2.) , vec2(3.,1.)) + box(p,vec3(3.4));\n   return a * .5;\n}\nfloat body (vec3 p) {\n    float a =box(p, vec3(3.,0.9,4.));\n    float b =box(p - vec3(0,0.5,4.), vec3(3.,0.9,4.) * .9);\n    \n    vec3 pa = p;\n    pa.zy *= rot(.3);\n    float c= box(pa - vec3(0,4.4,0), vec3(3.,0.9,4.) * .4);\n    \n    vec3 pb = p;\n    pb.zy *= rot(22.2);\n    float d= sph(pb - vec3(0,0.7,0), 2.2);\n    float e= sph(pb - vec3(0,0.7,-1.5), 3.0);\n    return smin(e,smin(d, smin(c,smin(a,b,2.),5.), 2.),.2);\n}\n\nfloat grav ( vec3 p) {\n  \n  float a = sph(p + vec3(2.,0,8), 1.2);\n  float b = sph(p + vec3(-2.,0,8), 1.2);\n  float c = sph(p + vec3(2.,0,-8), 1.2);\n  float d = sph(p + vec3(-2.,0,-8), 1.2);\n  \n  return min(d,min(c,min(a,b)));\n}\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\nfloat runner (vec3 pt) {\n\n   pt= pt * 4.;\n   pt.z *= 1.;\n   vec3 p = pt + vec3(0,15.,0);\n\n   \n    float ch  = chassi(p);\n    float bo = body(p);\n    float gr = grav(p);\n    return smin(gr,smin(ch,bo,.5),1.4) * .8;\n}\n\n\n\n\n\n\nfloat highway (vec3 p , vec3 shape, vec3 off, vec3 dir, float prob) {\n\n  prob *= .4;\n  dir *= .47;\n  shape *= .11;\n  p += off + dir * iTime * 3.11; \n  vec3 q = opRep(p, vec3(30,30,30)) ;\n  vec3 qid = opId(p, vec3(30,30,30));\n  float lim = fract(hash(qid * 1.7));\n  float s;\n  \n  prob *=1.;\n  \n  if ( lim < prob ) {\n      return runner(q);\n  } else {\n      return 10.;\n  }\n\n\n}\nint matter = 0;\nfloat artifact(vec3 p, float f1) {\n\n\n  \n  vec3 p1 = p;\n  vec3 p2 = p;\n  vec3 p3 = p;\n  vec3 p4 = p;\n  vec3 p5 = p;\n  vec3 p6 = p;\n\n\n\n \n  //float final = R;\n  float final=10000.;\n  \n vec3 pt=p;\n  \n  //vec3 pr = p;\n  //pr = p + vec3(10,-27.565,243.7 * time)/3.3; \n  //pr = rep(pr, vec3(20,50,20));\n  //float run = runner(pr);\n  \n  \n  \n  //float width = mix(5.,15., abs(sin(iTime/100.)));\n  float width = 13.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n \n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(pt,vec3(3.6,3.0+0.4+(iTime + f1 * 321.1)/11.,3.1),vec3(3.0,2.3,3.5));\n\n  vec3 seed = floor(p/width);\n\n  float dist;\n  \n  dist=box(pt,vec3(1.)*.17);\n\n  dist=max(dist,clampBox);\n\n  return dist;\n \n}\nvec3 polar ( vec3 p ) {\n  float pi = 3.141592;\n  p =  vec3(atan(p.x,p.y)*pi*(1.), length(p.xy) - 8. , p.z );\n  return p;\n}\n\nfloat map(vec3 p) {\n  \n  p = polar(p);//mix(p, polar(p), sin(iTime)*.5+.5);\n    // geo\n  \n \n  float domx = 4.5;\n  float domy = 14.;\n  vec2 id = floor(p.xz/domx);\n  float f1 = hash12(id);\n  \n  p.x = mod(p.x, domx) - domx/2.;\n  p.z = mod(p.z, domy) - domy/2.;\n \n float a = artifact(p,f1);\n  return a;\n}\n\n\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\n\n\nvec3 flitfbm(float t) {\n    vec3 z = vec3(0);\n    float amp = 1.;\n    float freq = 1.;\n    for (float a = 0.; a < 5.; a++) {\n      z += flit((t+a) * freq) * amp;\n      freq *= 1.5;\n      amp /=1.4;\n    }\n    \n    return z;;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n  \n  // nav\n  \n  float tt = iTime * 1.;\n  \n  //tt = sin(tt) + tt;\n\n  \n  vec3 adv = vec3(0.,0.,21.) * iTime;\n  \n \n  vec3 s = vec3(0.,0.,0.) + adv;\n  vec3 t = vec3(0.,0.,100.) + adv;\n  \n  s+= bezier(iTime*2.1)*1.;\n  t+= bezier(iTime*3.1)*1.;\n \n  s += sin(iTime)* vec3(4,0,0);\n  s += sin(iTime*.81) * vec3(0,2,0);\n  \n  s += flitfbm(iTime*1.41)*.4;\n  //t += flitfbm(iTime*1.71)*.01;\n  \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz -= dot(uv,uv)/6.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  r.xy *= rot(noise(s/100.)*3.);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n \n  for(float z=0.;z<200.;z++){ \n  \n    i = z;\n    d = map(p);\n\n    if ( d < .0001 ) {\n      hit = true;\n      break;\n    } \n    \n    dd += d;\n    p += r * d;\n  \n\n  }\n \n  \n  \n  // hue\n  \n  vec3 col = vec3(.8, .5, .2);\n\n\n\n  n2 = norm(p, vec2(0.0, 1.0E-2 ));\n  n1 = norm(p, vec2(0.0, 2.5E-2 ));\n\n\n  edge = saturate(length(n1-n2)/0.1);\n  \n  col -= edge*22.;\n\n  \n  if (! hit){\n      col = vec3(.93, .95, .90);\n      //col = vec3(1);\n  }\n  \n  \n \n  fragColor = vec4(col, 1.0);\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mts3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 208, 208, 311], [312, 312, 334, 334, 542], [544, 544, 567, 567, 746], [748, 748, 802, 857, 1081], [1083, 1083, 1107, 1107, 1309], [1313, 1313, 1342, 1342, 1407], [1408, 1408, 1450, 1450, 1557], [1559, 1559, 1582, 1582, 1690], [1692, 1692, 1716, 1716, 2263], [2265, 2265, 2287, 2287, 2495], [2497, 2497, 2522, 2522, 2555], [2557, 2557, 2579, 2579, 2697], [2701, 2701, 2722, 2722, 2771], [2772, 2772, 2792, 2792, 2841], [2843, 2843, 2864, 2864, 2911], [2912, 2912, 2931, 2931, 3000], [3001, 3001, 3021, 3021, 3400], [3401, 3401, 3426, 3426, 3895], [3897, 3897, 3920, 3920, 3998], [3999, 3999, 4019, 4019, 4203], [4205, 4205, 4228, 4228, 4354], [4357, 4357, 4386, 4386, 4415], [4419, 4419, 4444, 4444, 4484], [4489, 4489, 4503, 4503, 4543], [4546, 4546, 4582, 4582, 4635], [4659, 4659, 4683, 4683, 4738], [4741, 4741, 4765, 4765, 4851], [4860, 4860, 4880, 4880, 5094], [5095, 5095, 5121, 5121, 5170], [5174, 5174, 5213, 5213, 5290], [5293, 5293, 5323, 5323, 5349], [5352, 5352, 5390, 5390, 5713], [5716, 5716, 5739, 5739, 5852], [5853, 5853, 5874, 5874, 6273], [6275, 6275, 6297, 6297, 6502], [6504, 6504, 6531, 6531, 6557], [6559, 6559, 6587, 6587, 6618], [6619, 6619, 6643, 6643, 6834], [6841, 6841, 6910, 6910, 7216], [7233, 7233, 7267, 7267, 8047], [8048, 8048, 8071, 8071, 8170], [8172, 8172, 8191, 8191, 8472], [8477, 8477, 8503, 8503, 8628], [8631, 8631, 8651, 8651, 8770], [8776, 8776, 8797, 8797, 8820], [8824, 8824, 8847, 8847, 9049], [9052, 9052, 9109, 9109, 10462]], "test": "untested"}
{"id": "DtfGDX", "name": "Time Sync Demo", "author": "lennyjpg", "description": "machine sync testing", "tags": ["realtime"], "likes": 1, "viewed": 170, "published": 3, "date": "1672504625", "time_retrieved": "2024-07-30T18:38:30.643610", "image_code": "// test sync for multiple machines via time\n//\n//\n// related shaders\n// https://www.shadertoy.com/view/ldKGRR\n// https://www.shadertoy.com/view/Ms3XzM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = round(fract(iDate.w * .5));\n    fragColor = vec4(t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 209, 209, 278]], "test": "untested"}
{"id": "ctX3DX", "name": "MMXXIII", "author": "mla", "description": "The complete tripartite graph K(17,51,17) has 2023 (= 7.17²) edges, so here it is. Best full screen.\n\nHappy New Year to all!", "tags": ["complete", "2023", "tripartite"], "likes": 16, "viewed": 274, "published": 3, "date": "1672504534", "time_retrieved": "2024-07-30T18:38:31.393604", "image_code": "vec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// Signed distance from p segment qr. Positive distance for\n// points on the left of the line looking from q to r.\nfloat ssegment(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float k = dot(p,r)/dot(r,r);\n  k = clamp(k,0.0,1.0);\n  vec2 closestpoint = k*r;\n  float dist = distance(p,closestpoint);\n  vec2 normal = vec2(-r.y,r.x);\n  float s = dot(p,normal) >= 0.0 ? 1.0 : -1.0;\n  return s*dist;\n}\n\nvec3 diagram(vec2 p, float N) {\n  p.y = abs(p.y);\n  float px = fwidth(p.x);\n  float d = 1e8;\n  float imin;\n  vec3 col = vec3(1,1,0.5);\n  float k = iResolution.y/iResolution.x*25.5;\n  float M = 3.0*N+1.0;\n  for (float i = -N, j = M; i <= N && j >= -M; ) {\n    float d1 = ssegment(p,vec2(3.0*i,k),vec2(j,0)+vec2(0.5*sign(j),0));\n    if (abs(d1) < d) { d = abs(d1); imin = i; }\n    if (d1 > 0.0) i++;\n    else j--;\n  }\n  col = mix(h2rgb(float(imin+N)/float(2.0*N+1.0)),col,smoothstep(0.0,px,d));\n  d = 1e8;\n  for (float i = -N, j = N; i <= N && j >= -N; ) {\n    float d1 = ssegment(p,vec2(3.0*i,k),vec2(3.0*j,-k));\n    if (abs(d1) < d) { d = abs(d1); imin = i; }\n    if (d1 > 0.0) i++;\n    else j--;\n  }\n  //col = mix(h2rgb(float(imin+8)/17.0),col,smoothstep(0.0,px,d));\n  col = mix(vec3(0),col,smoothstep(0.0,px,d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 25.5;\n  vec2 p = scale*(2.0*fragCoord-iResolution.xy)/iResolution.x;\n  float t = mod(iTime,40.0);\n  if (t > 20.0) { p.x = -p.x; t -= 20.0; }\n  t = min(t,20.0-t)-1.0;\n  t = clamp(t,0.0,8.0);\n  vec3 col = diagram(p,t);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctX3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 154], [156, 271, 311, 311, 550], [552, 552, 583, 583, 1382], [1384, 1384, 1437, 1437, 1730]], "test": "untested"}
{"id": "dts3D2", "name": "Foggy laser tunnel", "author": "Virgill", "description": "Have a nice party tonight. Here´s a laser tunnel for you :)\n", "tags": ["tunnel", "madtracer", "madtracing"], "likes": 14, "viewed": 448, "published": 3, "date": "1672489235", "time_retrieved": "2024-07-30T18:38:32.454767", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n    float flicker = 0.15*fract(iFrameRate*iTime*0.333)+0.8;\n    fragColor = texture(iChannel0, uv)*flicker;\n    vec2 uv_border = (fragCoord.xy/iResolution.xy)*vec2(1.0,-1.0);\n    if (uv_border.y<-0.80||uv_border.y>-0.20) fragColor= vec4(0.0);  // black borders\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31782, "src": "https://soundcloud.com/virgill/nihil-admirari", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "\n#define FAR 10.0\n#define ITER 25\n#define BOUNCES 3\n\n\n// palette calculation (IQ)\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 col( in float t)\n{\nreturn pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n\n}\n\n// hemispherical hash function (fizzer+slerpy)\nvec3 hashHs( vec3 n, uint seed )\n{\n    float a=(float((seed*0x73493U)&0xfffffU)/float(0x100000))*2.-1.;\n    float b=6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float c=sqrt(1.-a*a);\n    vec3 r=vec3(c*cos(b),a,c*sin(b));\n    return dot(r,n)>0.?r:-r;\n    //return r;\n}\n\n\n// 3d noise function (shane)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\n\n// smooth minimum function (iq)\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// signed distance box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.));\n\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// 3d rotation function\nvoid pR(inout vec2 p,float a) \n{\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n// sphere\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// min for the map function\nvoid dmin(inout vec3 d, in float x, in float y, in float z)\n{\n    if(x < d.x) d = vec3(x,y,z);\n}\n\nvec3 map(vec3 p)\n{\n    vec3 d = vec3(1e+31,0,0); \n    float floornoise = noise(3.*p+0.2*iTime)+0.1*noise(20.*p+0.1*iTime); \n    \n    dmin(d,smin(7.-p.z,8.,8.),1.,.0);\n    vec3 q=p;\n\n    pR(q.yz,(3.1415*.5));\n    float cylinder = max(-sdCylinder(q,vec3(0.0,0.0,1.)),sdCylinder(q,vec3(0.0,0.0,1.)));\n    dmin(d,cylinder,2.-2.*floornoise,1.0);\n    \n    float random = iTime*iFrameRate;\n   // random=0.;\n    float beam = sdCylinder(q,vec3(sin(random),cos(random),.005));\n    dmin(d,beam,4.-2.*floornoise,0.);\n\n    return d;\n}\n\n// normal calculation function\nvec3 normal(vec3 p, float k)\n{\n    float m = map(p).x;\n\tvec2 e = vec2(0.,k);\n\treturn normalize(m-vec3(map(p - e.yxx).x,map(p - e.xyx).x,map(p - e.xxy).x));\n}\n\n\n// standard ray marching function\nvec3 tracer(vec3 ro, vec3 rd)\n{    \n    vec3 m;\n    float t=.001;\n    for(int i=0; i < ITER; i++)\n    {\n        m = map(ro + rd*t);\n        if(t > FAR)break;\n        if(m.z!=0.) t += abs(m.x); else t += m.x; \n    }\n    return vec3(t, m.yz);\n}\n\n\n// set up a very basic camera (ro= ray origin, rd=ray direction)\nvoid camera(out vec3 ro, out vec3 rd, in vec2 p)\n{\n\n\tvec2 uv = (2.*p.xy-iResolution.xy)/iResolution.x*vec2(1.0,-1.0);\n\tro =  vec3(0,0, -3);\n    rd =  normalize(vec3(uv, 1));\n    pR(ro.yz,0.15*sin(0.1*iTime));    \n    pR(ro.xz,0.15*cos(0.1*iTime));   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // feedbak noise (with buffer a)\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n   \tuv.x-=0.0002*noise(uv.yxx*32.-iTime)-0.00002; \n   \tuv.y+=0.0002*noise(uv.yxx*32.+iTime)-0.00002; \n    vec4 buffer= texture(iChannel0,uv);\t\t  \n\n    uint seed = uint(fragCoord) * uint(fragCoord.y); \n    vec3 emit = vec3(0), ro, rd, t, sp, sn;\n    \n    camera(ro, rd, fragCoord); \n    \n    for(int i=0; i<BOUNCES; i++)\n    {\n        t = tracer(ro, rd);\n        sp = ro + rd*t.x; \n\t\tsn = normal(sp,0.001); \n        if(t.y > 1.) emit = t.y * col(t.z+0.25*iTime); \n        seed *= uint(iTime*112.); \n        rd = mix(reflect(rd, sn), hashHs(sn, seed), clamp(t.y,0.,1.));  \n        ro = sp;\n    }\n    float blur=.97; \t\t\t\n    float amplify =.02; \n    \n    emit*=amplify;\n    \n    fragColor = vec4(emit.x,emit.y,emit.z, 1.)+buffer*blur;\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dts3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 363]], "test": "untested"}
{"id": "dlsGW2", "name": "matrix order, matrix mul", "author": "FabriceNeyret2", "description": "guessing matrix order and vec*matrix order in computer languages is always a nightmare.\nA quick test to check: U * mat2(1,0,0,0) ,  U * mat2(0,1,0,0), etc.\n→ vec * mat =  horizontal * mat( vertical v1,v2 ) = vec2( dot(vec,v1), dot(vec,v2) ).", "tags": ["matrix", "short"], "likes": 8, "viewed": 264, "published": 3, "date": "1672478243", "time_retrieved": "2024-07-30T18:38:33.299509", "image_code": "#define S(v)  smoothstep( 6./R.y, 0., v )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n     vec2 R = iResolution.xy, U = u/R, V;\n  // O = vec4( U * mat2( 1,0, 0,0 ) , 0,0 );  //  red horizontal gradient\n  // O = vec4( U * mat2( 0,1, 0,0 ) , 0,0 );  //  red vertical gradient\n  // O = vec4( U * mat2( 0,0, 1,0 ) , 0,0 );  //  green horizontal gradient\n  // O = vec4( U * mat2( 0,0, 0,1 ) , 0,0 );  //  green vertical gradient\n     \n  // O = vec4( mat2( 1,0, 0,0 ) * U , 0,0 );  //  red horizontal gradient\n  // O = vec4( mat2( 0,1, 0,0 ) * U , 0,0 );  //  green horizontal gradient\n  // O = vec4( mat2( 0,0, 1,0 ) * U , 0,0 );  //  red vertical gradient\n  // O = vec4( mat2( 0,0, 0,1 ) * U , 0,0 );  //  green vertical gradient\n  \n     int i = ( iFrame/60) % 4;\n     O *= 0.; O[i]++;                         // set a matrix component to one, rest = 0\n     O = vec4( U * mat2(O) , 0,0);\n\n     U = 2.*( u+u - R ) / R.y;                // --- draw the boxes\n     if ( U.y > 1. && abs(U.x) < 2. ) {\n         V = abs(fract(U)-.5);\n         float a = max(V.x,V.y)-.2;\n         O += S( abs(a) );                    // frame box\n         if ( int(U.x+2.) == i ) O += S( a ); // plain box\n     }\n     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 81, 81, 1188]], "test": "untested"}
{"id": "dllGW2", "name": "2023 new year", "author": "lasoy", "description": "2023", "tags": ["noise", "effect", "2023"], "likes": 10, "viewed": 371, "published": 3, "date": "1672474344", "time_retrieved": "2024-07-30T18:38:34.099370", "image_code": "// segment function modified from https://www.shadertoy.com/view/MdfGzf\nfloat segment(vec2 uv, bool On)\n{\n\tif (!On) return 0.0;\n\tfloat seg = (1.0-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t    (1.0-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)));\n\tif (On) seg *= (1.0-length(uv*vec2(3.8,0.9)));//-sin(iTime*25.0*6.26)*0.04;\n\telse seg *= -(0.05+length(uv*vec2(0.2,0.1)));\n\treturn seg;\n}\n\n// sevenSegment function modified from https://www.shadertoy.com/view/MdfGzf\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    seg += segment(uv.yx+vec2(-1.0, 0.0),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-0.5,-0.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( 0.5,-0.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0.0, 0.0),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-0.5, 0.5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( 0.5, 0.5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1.0, 0.0),num!=-1 && num!=1 && num!=4 && num!=7          );\n\t\n\treturn seg;\n}\n\n// showNum function modified from https://www.shadertoy.com/view/MdfGzf\nfloat showNum(vec2 uv,int nr)\n{\n\tif (abs(uv.x)>1.5 || abs(uv.y)>1.2) return 0.0;\n\tfloat seg= 0.0;\n\tif (uv.x>0.0){\n\t\tnr /= 10;\n\t\tseg += sevenSegment(uv+vec2(-0.75,0.0),nr);\n\t} else seg += sevenSegment(uv+vec2( 0.75,0.0),int(mod(float(nr),10.0)));\n\treturn seg;\n}\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 colorPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(2.*3.1415926*(c*t+d));\n}\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    float a = hash12(i);\n    float b = hash12(i + vec2(1, 0));\n    float c = hash12(i + vec2(0, 1));\n    float d = hash12(i + vec2(1, 1));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec3 color0 = 0.1 + 0.2*cos(iTime*2.+uv.xyx+vec3(0,2,4));\n\n\tuv *= vec2(-4, 4);\n\tuv.x += uv.y/12.0*sin(iTime*2.);\n    uv = rotate2d(noise((uv + vec2(iTime*.5)) * 2.5 + .5) * .2) * uv;\n\n    uv.x += 1.5;\n\tfloat seg = 0.0;\n\tseg += showNum(uv,23);\n    uv.x -= 3.;\n    seg += showNum(uv,20);\n    \n    vec3 color1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 finalColor = vec3(0);\n    finalColor = colorPalette(uv.x*.1 + iTime*.5, vec3(.5), vec3(.5), vec3(1.), vec3(0, .33, .67));\n\tfinalColor *= seg;\n    finalColor = smoothstep(color1, finalColor, 1. - vec3(seg));\n    finalColor += smoothstep(0.8, 0.9, 1. - seg) * color0;\n\n\tfragColor = vec4(finalColor,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllGW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 72, 105, 105, 404], [406, 483, 520, 520, 1179], [1181, 1253, 1284, 1284, 1513], [1515, 1580, 1602, 1602, 1722], [1724, 1724, 1784, 1784, 1832], [1834, 1834, 1857, 1857, 2146], [2148, 2148, 2175, 2175, 2257], [2260, 2260, 2317, 2317, 3051]], "test": "untested"}
{"id": "mtXGR2", "name": "JenKai Liu “The Reversal”", "author": "JenKaiLiu", "description": "▶️Demo Video:\nhttps://youtu.be/r4oCbazujmY\n\nReferences:\n[1]Cloudy Shapes by kaneta\n[2]Heartfelt by BigWIngs\n[3]Heart SDF Base Code by gracegi", "tags": ["raymarching", "volumetriccloud"], "likes": 45, "viewed": 730, "published": 3, "date": "1672474034", "time_retrieved": "2024-07-30T18:38:35.056810", "image_code": "// 【Raindrop amount】0. ~ 1.\n#define RAINAMOUNT 0.25\n\n\n\n\n// [2]Raindrop filter\n// https://www.shadertoy.com/view/ltffzl\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define USE_POST_PROCESSING\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainBlur( out vec4 fragColor, in vec2 fragCoord ,float focus)\n{\n    float thresh = 1.;//depth threshold\n    vec2 dir = vec2(0.1,-0.1);//blur direction\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n\n    float dist = focus;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color/=totalw;\n\tfragColor = vec4(color,dist);\n}\n\nvec3 N13(float p) {\n    //  from DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\nfloat N(float t) {\n    return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n\treturn S(0., b, t)*S(1., b, t);\n}\n\nvec2 DropLayer2(vec2 uv, float t) {\n    vec2 UV = uv;\n    \n    uv.y += t*0.75;\n    vec2 a = vec2(6., 1.);\n    vec2 grid = a*2.;\n    vec2 id = floor(uv*grid);\n    \n    float colShift = N(id.x); \n    uv.y += colShift;\n    \n    id = floor(uv*grid);\n    vec3 n = N13(id.x*35.2+id.y*2376.1);\n    vec2 st = fract(uv*grid)-vec2(.5, 0);\n    \n    float x = n.x-.5;\n    \n    float y = UV.y*20.;\n    float wiggle = sin(y+sin(y));\n    x += wiggle*(.5-abs(x))*(n.z-.5);\n    x *= .7;\n    float ti = fract(t+n.z);\n    y = (Saw(.85, ti)-.5)*.9+.5;\n    vec2 p = vec2(x, y);\n    \n    float d = length((st-p)*a.yx);\n    \n    float mainDrop = S(.4, .0, d);\n    \n    float r = sqrt(S(1., y, st.y));\n    float cd = abs(st.x-x);\n    float trail = S(.23*r, .15*r*r, cd);\n    float trailFront = S(-.02, .02, st.y-y);\n    trail *= trailFront*r*r;\n    \n    y = UV.y;\n    float trail2 = S(.2*r, .0, cd);\n    float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n    y = fract(y*10.)+(st.y-.5);\n    float dd = length(st-vec2(x, y));\n    droplets = S(.3, 0., dd);\n    float m = mainDrop+droplets*r*trailFront;\n    \n    //m += st.x>a.y*.45 || st.y>a.x*.165 ? 1.2 : 0.;\n    return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv, float t) {\n\tuv *= 40.;\n    \n    vec2 id = floor(uv);\n    uv = fract(uv)-.5;\n    vec3 n = N13(id.x*107.45+id.y*3543.654);\n    vec2 p = (n.xy-.5)*.7;\n    float d = length(uv-p);\n    \n    float fade = Saw(.025, fract(t+n.z));\n    float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n    return c;\n}\n\nvec2 Drops(vec2 uv, float t, float l0, float l1, float l2) {\n    float s = StaticDrops(uv, t)*l0; \n    vec2 m1 = DropLayer2(uv, t)*l1;\n    vec2 m2 = DropLayer2(uv*1.85, t)*l2;\n    \n    float c = s+m1.x+m2.x;\n    c = S(.3, 1., c);\n    \n    return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 M = iMouse.xyz/iResolution.xyz;\n    float T = iTime+M.x*2.;  \n    float t = T*.2;\n    \n    float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7; // 雨水濃度\n    rainAmount = RAINAMOUNT;\n    \n    float maxBlur = mix(3., 6., rainAmount);\n    float minBlur = 2.;   \n    float story = 0.;\n  \n    float staticDrops = S(-.5, 1., rainAmount)*2.;\n    float layer1 = S(.25, .75, rainAmount);\n    float layer2 = S(.0, .5, rainAmount);\n       \n    vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n\n    vec2 e = vec2(.001, 0.);\n    float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n    float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n    vec2 n = vec2(cx-c.x, cy-c.x);\t\t// expensive normals\n   \n    float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n    focus = 1.-clamp(pow(focus,1.5)/15.,0.,1.); // 模糊程度，clamp到0~1\n    vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n    vec4 fragcol = vec4(col,1.);\n    mainBlur(fragcol,fragCoord, focus*rainAmount);\n    //col *= fragcol.rgb; 模糊\n    //col =  vec3(focus*rainAmount);\n    \n    #ifdef USE_POST_PROCESSING\n    //t = (T+3.)*.5;\t\t\t\t\t\t\t\t\t\t// make time sync with first lightnoing\n    //float colFade = sin(t*.2)*.5+.5+story;\n    //col *= mix(vec3(1.), vec3(.8, .9, 1.3), colFade);\t// subtle color shift\n    float fade = S(0., 10., T);\t\t\t\t\t\t\t// fade in at the start\n    \n    //float lightning = sin(t*sin(t*10.));\t\t\t\t// lighting flicker\n    //lightning *= pow(max(0., sin(t+sin(t))), 10.);\t\t// lightning flash\n    //col *= 1.+lightning*fade*mix(1., .1, story*story);\t// composite lightning\n    //col *= fade*mix(1., .1, story*story);\t// composite lightning\n    \n    //col *= 1.-dot(UV-=.5, UV);\t\t\t\t\t\t\t// vignette    \t\t\t\t\t\t\t\t\t\t\t   \n    //col *= fade;\t\t\t\t\t\t\t\t\t\t// composite start and end fade\n    #endif\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// 【How the sky looks】\n// 0: Cloudy\n// 1: Rainy\n// 2: Sunny\n#define LOOK 2\n\n\n\n\n// [1]\n// Cloud simulation  \n// https://www.shadertoy.com/view/WdXGRj\n\n// noise\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n/////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// [3]Heart SDF\n// https://www.shadertoy.com/view/3ldXD7\nfloat sdHeart( vec3 p, float t )\n{\n    float y = 1.3 * p.y - abs(p.x) * sqrt(1.0 - abs(p.x));\n    vec3 p2 = vec3(p.x, y, p.z);\n    return length(p2) - t;\n}\n\n\nfloat map( in vec3 p )\n{\n    float n_speed = 0.5; // 雲霧noise變化速度 _________ default: 1., Bad Wheather: 0.5,\n\tvec3 q = p - vec3(0.0,0.5,1.0)*iTime*n_speed;\n    float f = fbm(q);\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    \n    vec3 cp = p;\n    cp.yz *= Rot(0.25);\n    float cloud = 1.0 - length(cp * vec3(0., 5., 0.12)+ vec3(0.0, -2.5, 0.7)) + f * 3.5;\n    cloud = 1.0 - length(p * vec3(0.1, 1., 0.2)) + f * 2.2;\n    //float cloud = 1.0 - length(cp * vec3(0., 5., 0.12)+ vec3(0.0, -2.5, 0.7)) + f * 3.5;\n    \n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n    float s3 = 1.0 - smin(smin(\n                           length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),\n                           length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),\n                           length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\n    \n    // Heart SDF function:\n    vec3 hp = p/3.5;\n    float sadHeart = 1. - sdHeart(hp, 0.7)*8.+ f * 4.5;\n    \n    \n    vec3 smp = hp;\n    smp.xy *= Rot(0.3+sin(iTime+2.)*0.05);\n    smp.xz *= Rot(0.2);\n    smp.zy *= Rot(0.5);\n    float smilehHeart = 1. - sdHeart(smp, 0.7)*8.+ f *1.5;\n    smp = hp;\n    smp.xy *= Rot(-0.2+sin(iTime)*0.05);\n    float smilehHeart2 = 1. - sdHeart(smp-vec3(-0.6,-0.1,0.8), 0.15)*8.+ f *1.;    \n    smp = hp;\n    smp.xy *= Rot(0.9);\n    smp.xz *= Rot(iTime);\n    float smilehHeart3 = 1. - sdHeart(smp-vec3(-0.9,0.5,0.5), 0.02)*15.+ f *2.;\n    smp = hp;\n    smp.xy *= Rot(-1.);\n    smp.yz *= Rot(-0.5);\n    smp.xz *= Rot(-iTime-1.);\n    float smilehHeart4 = 1. - sdHeart(smp-vec3(-0.9,0.5,0.2), 0.02)*15.+ f *2.;\n    \n    vec3 fp = p;\n    fp.yz *= Rot(-0.2);\n    s1 = 1.0 - length(fp * vec3(0.4, 8.0, 1.1)+vec3(0.,23.,-2.8)) + f * 5.5;\n    float smile = max(max(max(max(smilehHeart,smilehHeart2),smilehHeart3),smilehHeart4),s1);\n    \n    \n    float t = mod(stepUp(iTime, 3.0, 1.0), 3.0);\n    \n\tfloat d = mix(smile, sadHeart, clamp(t, 0.0, 1.0));\n    d = mix(d, cloud, clamp(t - 1.0, 0.0, 1.0));\n    d = mix(d, smile, clamp(t - 2.0, 0.0, 1.0));\n    \n    // A to B\n\t//d = mix(sadHeart, cloud, clamp(t, 0.0, 1.0));\n    //d= cloud;\n    //d = smilehHeart;\n    //d= cloud;\n\treturn min(max(0.0, d), 1.0);\n}\n\nfloat jitter;\n\n#if LOOK==2\n#define MAX_STEPS 48  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2. // 越小雲霧明暗對比越大 _________ default: 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n            sum.a *= 1.-density;\n\n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\n#if LOOK==1\n#define MAX_STEPS 128  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 1.25 // 越小雲霧明暗對比越大 _________ default: 2.\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n            \n            float DensityStrength = 100.; // 雲霧密度，數值越大立體感越明顯 _________ default: 20.\n            density = clamp((d / float(MAX_STEPS)) * DensityStrength, 0.0, 1.0);\n            \n            \n            vec3 HighlightColor = vec3(0.946,0.980,1.000) *1.1; // 雲霧高光顏色 _________ default: vec3(1.1, 0.9, .5)         \n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.5);\n            sum.rgb += vec3(s * density) * HighlightColor * sum.a;\n            sum.a *= 1.-density;\n            \n            vec3 DiffuseColor = vec3(-0.01); // 雲霧底色 _________ default: vec3(0.15, 0.45, 1.1)       \n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * DiffuseColor * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\n#if LOOK==0\n#define MAX_STEPS 128  // marching步數，越大噪點越少 _________ default: 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 1.25 // 越小雲霧明暗對比越大 _________ default: 2.\n\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n            \n            float DensityStrength = 100.; // 雲霧密度，數值越大立體感越明顯 _________ default: 20.\n            density = clamp((d / float(MAX_STEPS)) * DensityStrength, 0.0, 1.0);\n            \n            \n            vec3 HighlightColor = vec3(1.); // 雲霧高光顏色 _________ default: vec3(1.1, 0.9, .5)         \n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * HighlightColor * sum.a;\n            sum.a *= 1.-density;\n            \n            vec3 DiffuseColor = vec3(0.0); // 雲霧底色 _________ default: vec3(0.15, 0.45, 1.1)       \n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * DiffuseColor * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n#endif  \n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if LOOK==2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0);\n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\n    vec3 sunPos = vec3(2., 3.5, -2.); // 太陽光位置 _________\n    float sundot = clamp(dot(ray,normalize(sunPos)),0.0,1.0);\n    result += 1.7*vec3(0.9,0.624,0.)*pow( sundot, 14.0 ); // 太陽光顏色 _________\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}\n#endif  \n#if LOOK==1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0); // 相機位置 _________ default: vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0)  \n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    \n    vec3 lowerSkyColor = vec3(0.1,0.140,0.15); // 下半天空顏色 _________ default: vec3(0.3, 0.6, 1.0) Logo: vec3(0.98,0.98,1.0)\n    vec3 upperSkyColor = vec3(0.2,0.240,0.25); // 上半天空顏色 _________ default: vec3(0.05, 0.35, 1.0) Logo:vec3(0.73,0.81,0.81)\n    \n    vec3 result = col.rgb + mix(lowerSkyColor, upperSkyColor, p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);  \n}\n#endif  \n#if LOOK==0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(476.45 * .333) * 8.0, -2.5, sin(476.45 * .333) * 8.0); // 相機位置 _________ default: vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0)  \n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    \n    vec3 lowerSkyColor = vec3(0.98,0.98,1.0); // 下半天空顏色 _________ default: vec3(0.3, 0.6, 1.0)\n    vec3 upperSkyColor = vec3(0.73,0.81,0.81); // 上半天空顏色 _________ default: vec3(0.05, 0.35, 1.0)\n    \n    vec3 result = col.rgb + mix(lowerSkyColor, upperSkyColor, p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}\n#endif  ", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 214, 214, 237], [239, 239, 307, 307, 967], [969, 969, 988, 1014, 1186], [1188, 1188, 1207, 1207, 1295], [1297, 1297, 1315, 1315, 1361], [1363, 1363, 1392, 1392, 1427], [1429, 1429, 1464, 1464, 2616], [2618, 2618, 2655, 2655, 2931], [2933, 2933, 2993, 2993, 3212], [3214, 3214, 3271, 3271, 5211]], "test": "untested"}
{"id": "dll3Wj", "name": "ChatGPT's Sphere", "author": "FoobarBigTime", "description": "Wow, it took some teeth pulling, but this code is nearly completely from chatGPT. I only had to port some of the syntax and Shadertoy specific things to make it work. That and it had a difficult time normalizing the fragment coordinates. ", "tags": ["raymarching", "sphere", "chatgpt"], "likes": 0, "viewed": 200, "published": 3, "date": "1672462390", "time_retrieved": "2024-07-30T18:38:35.884597", "image_code": "// Define a function that calculates the signed distance from a point to a sphere\nfloat sphereSDF(vec3 point, vec3 sphereCenter, float sphereRadius) {\n  return length(point - sphereCenter) - sphereRadius;\n}\n\n// Define the main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  \n  // Define the position and radius of the sphere\n  vec3 sphereCenter = vec3(0, 0, 0);\n  float sphereRadius = 1.0;\n\n  // Define the camera position and field of view\n  vec3 cameraPosition = vec3(0, 0, -2);\n  float fieldOfView = 90.0;\n\n  // Normalize the fragment coordinates\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  \n  float z = tan(radians(fieldOfView) / 2.0);\n  \n  // Calculate the direction of the ray from the camera to the fragment\n  vec3 rayDirection = normalize(vec3(uv, z));\n\n  // Define the maximum number of iterations\n  int maxIterations = 100;\n\n  // Define the distance from the ray origin to the nearest point on the ray that intersects with the sphere\n  float dist = 0.001; // Initialize the distance to a small value\n\n  // Iterate until the ray intersects with the sphere or the maximum number of iterations is reached\n  for (int i = 0; i < maxIterations; i++) {\n    // Calculate the current position of the ray\n    vec3 rayPosition = cameraPosition + dist * rayDirection;\n\n    // Calculate the signed distance from the current position to the sphere\n    float sdf = sphereSDF(rayPosition, sphereCenter, sphereRadius);\n\n    // Check if the distance to the surface of the sphere is smaller than the threshold\n    if (sdf < 0.001){\n      // The distance to the surface of the sphere is smaller than the threshold, so we can calculate the point of intersection and the surface normal\n      vec3 intersectionPoint = rayPosition;\n      vec3 surfaceNormal = normalize(intersectionPoint - sphereCenter);\n\n      // Use the surface normal to shade the pixel corresponding to the point of intersection\n      fragColor = vec4(surfaceNormal, 1);\n      return;\n    }\n\n    // The distance to the surface of the sphere is larger than the threshold, so we can move the ray along its direction by the distance to the surface of the sphere\n    dist += sdf;\n  }\n\n  // The ray does not intersect with the sphere within the maximum number of iterations, so we can return a background color\n  fragColor = vec4(0, 0, 0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dll3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 150, 150, 206], [208, 236, 292, 346, 2339]], "test": "untested"}
{"id": "ctsGD2", "name": "that thing i see in my coffe cup", "author": "jonasfrey", "description": "coffe", "tags": ["coffe"], "likes": 3, "viewed": 199, "published": 3, "date": "1672447689", "time_retrieved": "2024-07-30T18:38:36.696426", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_trn_fc_nor = fragCoord.xy / iResolution.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    \n    vec2 o_diff = vec2(0.)-o_trn_fc_nor_offset;\n    float n_tau = 6.2831;\n    float n_ang_nor = fract(((atan(o_diff.y, o_diff.x)+(n_tau/2.))/n_tau));\n    \n    float n_its = 200.;\n    \n    float n_ang_nor_snapped = floor(n_ang_nor * n_its)/n_its;\n\n    float n_it = floor(n_ang_nor * n_its);\n    float n_radius = (sin(iTime+(n_tau/n_its)*n_it)*0.5+0.5)*0.4;\n    vec2 o_p = vec2(\n        cos((n_ang_nor_snapped+(1./n_its/2.))*n_tau)*n_radius, \n        sin((n_ang_nor_snapped+(1./n_its/2.))*n_tau)*n_radius\n    );\n    \n    float n_dist = length(o_p-o_trn_fc_nor_offset);\n    \n    \n    fragColor = vec4(n_dist);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1015]], "test": "untested"}
