{"id": "mtXBWX", "name": "Raw Meat on TV", "author": "misol101", "description": "Mashup of https://www.shadertoy.com/view/wdB3R3 by denosya, and CRT effect https://www.shadertoy.com/view/Xtccz4 by luka712.\n\nPress mouse to remove CRT/distortion.\n\nHold SPACE to stop \"wobbling\"", "tags": ["crt", "red", "bumpmapping", "raw", "meat"], "likes": 12, "viewed": 267, "published": 3, "date": "1693510891", "time_retrieved": "2024-07-30T17:36:00.534779", "image_code": "/*\n* Mashup of:\n* Object:     https://www.shadertoy.com/view/wdB3R3 by denosya\n* CRT effect: https://www.shadertoy.com/view/Xtccz4 by luka712\n* by misol101\n*\n* Press mouse to remove CRT/distortion\n*\n* Hold SPACE to stop \"wobbling\"\n*\n*/\n\nvec2 crt_coords(vec2 uv, float bend)\n{\n\tuv -= 0.5;\n    uv *= 2.;\n    uv.x *= 1. + pow(abs(uv.y)/bend, 2.);\n    uv.y *= 1. + pow(abs(uv.x)/bend, 2.);\n    \n    uv /= 2.5;\n    return uv + .5;\n}\n\nfloat vignette(vec2 uv, float size, float smoothness, float edgeRounding)\n{\n \tuv -= .5;\n    uv *= size;\n    float amount = sqrt(pow(abs(uv.x), edgeRounding) + pow(abs(uv.y), edgeRounding));\n    amount = 1. - amount;\n    return smoothstep(0., smoothness, amount);\n}\n\nfloat scanline(vec2 uv, float lines, float speed)\n{\n    return sin(uv.y * lines + iTime * speed) * 0.66;\n}\n\nfloat random(vec2 uv)\n{\n \treturn fract(sin(dot(uv, vec2(15.5151, 42.2561))) * 12341.14122 * sin(iTime * 0.03));   \n}\n\nfloat noise(vec2 uv)\n{\n \tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.,0.));\n\tfloat c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1.));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a,b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y; \n                     \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if (iMouse.z > 0.) {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n\n    vec2 crt_uv = crt_coords(uv, 4.);\n    \n    float s1 = scanline(uv, 400., -10.) * 1.1;\n    float s2 = scanline(uv, 10.+sin(iTime*0.33)*16., -3.) * 0.8;\n    \n    vec4 col;\n    col = texture(iChannel0, crt_uv);\n    \n    col = mix(col, vec4(s1 + s2), 0.05);\n\tfragColor = mix(col, vec4(noise(uv * 75.)), 0.05) * vignette(uv, 1.9, .6, 8.);;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float zNear = 1.0;\nconst float zFar  = 400.0;\n\nconst vec2 TEXTURE_ANIM = vec2(0.3, 0.13);\nconst float EMBOSS = 0.9;\nconst float MATERIAL_SCALE = 1.0;\n\nconst int KEY_SPACE = 32;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat map(in vec3 m) {\n\n \tvec3 sphereCenter = vec3(0.0, 0.0, 10.);\n    float radius = 4.0;\n\n    float pulse = 0.0;\n\n    vec3 normal = normalize(m - sphereCenter);\n    vec2 UV = ((normal.xy + 1.0) * 0.5) * MATERIAL_SCALE + iTime*TEXTURE_ANIM;\n    \n    float h = (texture(iChannel0, UV).x+sin(iTime)*1.0-1.) * EMBOSS;\n   \n    return length(m - sphereCenter) - radius - h; \n}\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n    float   stepMul      = 1.0;\n    if (readKey(KEY_SPACE)) stepMul = 0.5;\n\n    for(int i = 0; i<500; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist1 = map(m);\n        \n        if(dist1 < 0.01) {\n            return true;\n        }\n\n\t\tif(dist1 < 0.1) {\n            float eps = 0.005;\n            float dist2 = map(m + ray * eps);    \n            float gradient = (dist2 - dist1) / eps;\n\n            if(gradient > 0.0) {\n                marchingDist += dist1;\n            }\n            else {\n                marchingDist += min(-(dist1 / gradient), 0.1);\n            }\n        }\n        else {\n            marchingDist += dist1 * stepMul;\n\n            if(marchingDist >= zFar) {\n                break;\n            }            \n        }\n    }\n    \n\treturn false;    \n}\n\n// IQ's func <3\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.033, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n    \n    vec3 n = normalize(m-vec3(0.0, 0.0, 10.));\n    vec2 UV = ((n.xy + 1.0) * 0.5) * MATERIAL_SCALE + iTime*TEXTURE_ANIM;\n    vec3 pixel = texture(iChannel0, UV).xyy;\n    \n    vec3 lightRay = normalize(m - light);\n    float diffuse = max(0.0, dot(normal, -lightRay));\n    \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight \t\t = pow(max(dot(reflectedLight, -ray),0.0), 35.0);\n    \n    float ambiant = 0.2;       \n    \n    vec3 render = pixel * (diffuse + ambiant) + hilight;\n    return vec4(render, 1.0);\n}\n\nvec4 run(in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    viewportCoord.x+=+sin(iTime*2.)*0.25;\n    \n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= vec3(5.0*cos(iTime*0.5), 3.0, -10.0);\n    \n    vec3\tm;\n    \n    if(rayMarching(eye, ray, m)) {\n        vec3 normal = computeNormal(m);\n        return computeColor(ray, m, normal, light, eye);\n    }\n    else {\n        return vec4(0.0, 0, 0, 1.0);        \n    }\n    \n}\n    \n//#define SUPERSAMPLING\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    #ifdef SUPERSAMPLING\n    // 5x5 supersampling\n    for(float dx=-0.5; dx<=0.5; dx+=0.25) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.25) {\n            fragColor += run(fragCoord + vec2(dx, dy));\n        }\n    }\n    \n    fragColor /= 25.0;\n    \n    #else\n    fragColor = run(fragCoord);\n    #endif\n} \n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 275, 275, 427], [429, 429, 504, 504, 693], [695, 695, 746, 746, 801], [803, 803, 826, 826, 919], [921, 921, 943, 943, 1279], [1282, 1282, 1339, 1339, 1813]], "test": "untested"}
{"id": "mtsBWj", "name": "Fork Simple Sin zyc 776", "author": "zyc", "description": "Simple Sin wave distortion just to show the basics of shaders to one lonely man on the gamedev subreddit.", "tags": ["2d", "sin"], "likes": 0, "viewed": 155, "published": 3, "date": "1693478788", "time_retrieved": "2024-07-30T17:36:01.294747", "image_code": "#define MAX_AMPLITUDE 0.013\n#define MIN_AMPLITUDE 0.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Get the UV Coordinate of your texture or Screen Texture, yo!\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float progress = fract(0.8*iTime);\n    float intensity = mix(MAX_AMPLITUDE, MIN_AMPLITUDE, progress);\n    \n\t// Flip that shit, cause shadertool be all \"yolo opengl\"\n\tuv.y = -1.0 - uv.y;\n\t\n\t// Modify that X coordinate by the sin of y to oscillate back and forth up in this.\n\tuv.x += intensity * sin(uv.y*100.0 + iTime*10.0);\n\n\t// Get the pixel color at the index.\n\tvec4 color = texture(iChannel0, uv);\n\t\n\tfragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 178, 649]], "test": "untested"}
{"id": "cllfD2", "name": "Compleat Mandelbox 2", "author": "dr2", "description": "Explore the amazingly beautiful mandelbox (updated, see the source)", "tags": ["fractal", "interactive"], "likes": 33, "viewed": 471, "published": 3, "date": "1693475331", "time_retrieved": "2024-07-30T17:36:02.229248", "image_code": "// \"Compleat Mandelbox 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Detailed exploration of periodic mandelbox (narrow tunnel drilled through\n  solid regions).\n\n  Updates include changed path for improved coverage of interior.\n\n  Control panel appears when ring (or a hidden control) clicked; panel fades\n  automatically; use mouse to look around.\n\n  Sliders:\n   red: forward speed (stop anywhere)\n   green: zoom\n   blue: fractal scale factor (2.5--3.5)\n\n  Button: color scheme (several fixed and varying)\n\n  No. 9 in \"Mandelbox\" series\n    \"Mandelbox Tunnel\"            (MlfSWX)\n    \"Mandelmaze\"                  (MtXXDl)\n    \"Mandelmaze in Daylight\"      (MdVGRc)\n    \"Endless Mandelbox Tunnel\"    (XdjfRz)\n    \"Palladio's Detector\"         (Ms3fWB)\n    \"Compleat Mandelbox\"          (ld3fDl)\n    \"Mandalay Fractal\"            (wstXD8)\n    \"Fractal Tomography\"          (3dlfDH)\n*/\n\n#define AA  1   // (= 0/1) optional antialiasing\n\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec3 HsvToRgb (vec3 c);\nfloat Maxv2 (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (int idVar);\n\nvec3 ltPos[2], ltAx, pathMid;\nfloat tCur, dstFar, mScale, chCol, pathRad;\nint nFrame, isPer;\nconst float pi = 3.1415927;\nconst float itMax = 12.;\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat ObjDf (vec3 p)\n{\n  vec4 q4, q4o;\n  vec3 q;\n  float d;\n  q = p;\n  q4o = (isPer > 0) ? vec4 (6. * (fract (q / 6. + 0.5) - 0.5), 1.) : vec4 (q, 1.);\n  q4 = q4o;\n  for (float j = 0.; j < itMax; j ++) {\n    q4.xyz = 2. * clamp (q4.xyz, -1., 1.) - q4.xyz;\n    q4 = mScale * q4 / clamp (dot (q4.xyz, q4.xyz), 0.25, 1.) + q4o;\n  }\n  d = length (q4.xyz) / q4.w;\n  q = p;\n  d = max (d, - PrTorusDf ((q - pathMid).xzy, 0.02, pathRad));\n  return d;\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec4 col4;\n  vec3 q, q3, col;\n  float qq, qqMin, cn, cr;\n  q = (isPer > 0) ? 6. * (fract (p / 6. + 0.5) - 0.5) : p;;\n  q3 = q;\n  cn = 0.;\n  cr = 0.;\n  qqMin = 1.;\n  for (float j = 0.; j < itMax; j ++) {\n    if (any (greaterThan (q3, vec3 (1.)))) ++ cr;\n    q3 = 2. * clamp (q3, -1., 1.) - q3;\n    qq = dot (q3, q3);\n    if (qq < qqMin) {\n      cn = j;\n      qqMin = qq;\n    }\n    if (abs (qq - 0.625) > 0.375) ++ cr;\n    q3 = mScale * q3 / clamp (qq, 0.25, 1.) + q;\n  }\n  if      (chCol == 0.) col4 = vec4 (0.03 * cr, mix (0.15, 0.05, mod (cn, 2.)), 1., 0.3);\n  else if (chCol == 1.) col4 = vec4 (0.04 * tCur + 0.06 * cn, 0.8, 1., 0.4);\n  else if (chCol == 2.) col4 = vec4 (0.3 + 0.2 * cn, 0.7, 1., 0.3);\n  else if (chCol == 3.) col4 = vec4 (0.13 + 0.004 * cn, 0.8, 1., 0.4);\n  else if (chCol == 4.) col4 = vec4 (0.1 * cn, 0.8, 1., 0.2);\n  col4.r = fract (col4.r);\n  col4.rgb = HsvToRgb (col4.rgb);\n  return col4;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi, eps;\n  eps = 0.0005;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    h = ObjDf (ro + s * rd);\n    if (h < eps || s > dstFar) {\n      sHi = s;\n      break;\n    }\n    sLo = s;\n    s += h;\n  }\n  if (h < eps) {\n    for (int j = VAR_ZERO; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (ObjDf (ro + s * rd) > eps) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (3. * h, 0.04, 0.3);\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (float j = 1. + float (VAR_ZERO); j < 4.; j ++) {\n    d = 0.02 * j;\n    ao += max (0., d - ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - 5. * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir;\n  vec2 q;\n  float dstObj, ltDist, atten, dfSum, spSum, nDotL, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    dfSum = 0.;\n    spSum = 0.;\n    for (int k = 0; k < 2; k ++) {\n      ltDir = ltPos[k] - ro;\n      ltDist = length (ltDir);\n      ltDir /= ltDist;\n      atten = smoothstep (0.3, 0.5, dot (ltAx, - ltDir)) / (1. + 0.01 * ltDist * ltDist);\n      nDotL = max (dot (vn, ltDir), 0.);\n      dfSum += atten * nDotL * sqrt (nDotL);\n      spSum += atten * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    }\n    ltDir = normalize (0.5 * (ltPos[0] + ltPos[1]) - ro);\n    sh = ObjSShadow (ro + 0.01 * ltDir, ltDir, max (dstObj - 0.2, 0.));\n    col4 = ObjCol (ro);\n    col = col4.rgb * (0.3 + 0.4 * sh * dfSum) + vec3 (1., 1., 0.5) * step (0.95, sh) *\n       col4.a * 0.5 * spSum;\n    col *= ObjAO (ro, vn);\n    col += vec3 (0.2, 0.2, 0.) * max (dot (- rd, vn), 0.) *\n       (1. - smoothstep (0., 0.03, abs (dstObj - 0.5 * mod (tCur, 6.))));\n    col *= mix (1., smoothstep (0., 1., Maxv3 (col)), 0.5);\n  } else col = vec3 (0.1, 0.1, 0.15);\n  return col;\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec3 parmV)\n{\n  vec4 wgBx[4];\n  vec3 cc[4], col;\n  vec2 ut, ust;\n  float asp;\n  cc[0] = vec3 (0.9, 0.5, 0.5);\n  cc[1] = cc[0].grb;\n  cc[2] = cc[0].bgr;\n  cc[3] = cc[0].rrg;\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k <= 2; k ++)\n     wgBx[k] = vec4 ((0.38 + 0.04 * float (k)) * asp, -0.21, 0.014 * asp, 0.18);\n  wgBx[3] = vec4 (0.42 * asp, -0.44, 0.018, 0.018);\n  col = vec3 (0.);\n  for (int k = 0; k <= 2; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (Maxv2 (ust) < 0.) {\n      col = cc[k];\n      if (Minv2 (abs (ust)) * canvas.y < 2.) col *= 0.3;\n      else col *= (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? 0.3 : 0.6;\n    }\n    ut.y -= (parmV[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 1.4);\n    if (Maxv2 (abs (ut)) < 0.02 && Maxv2 (ut) > 0.013) col = cc[k];\n  }\n  for (int k = 3; k <= 3; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw;\n    if (Maxv2 (ust) < 0.) {\n      col = cc[k] * (1. - 0.4 * step (2., Minv2 (abs (ust)) * canvas.y));\n    }\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvec3 TrkPath (float t)\n{\n  return pathMid + vec3 (Rot2D (vec2 (0., pathRad), 2. * pi * t / pathRad), 0.).xzy;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr, wgBxC, c4;\n  vec3 ro, rd, col, vd, parmV;\n  vec2 canvas, uv, uvv;\n  float el, az, sr, zmFac, asp, tCurM, vuTr;\n  int wgSel, noInt;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  isPer = 1;\n  stDat = Loadv4 (0);\n  parmV = stDat.xyz;\n  zmFac = mix (1.2, 12., parmV.y);\n  mScale = mix (2.5, 3.5, parmV.z);\n  stDat = Loadv4 (1);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (2);\n  el = stDat.x;\n  az = stDat.y;\n  tCurM = stDat.w;\n  stDat = Loadv4 (3);\n  vuTr = stDat.x;\n  chCol = stDat.y;\n  noInt = int (stDat.z);\n  pathRad = mix (1.5, 2.5, 0.5 + 0.5 * sin (0.03 * pi * vuTr));\n  pathMid = vec3 (0., 0.7 * sin (0.05 * pi * vuTr), 0.);\n  ro = TrkPath (vuTr);\n  vd = normalize (TrkPath (vuTr + 0.1) - ro);\n  az += atan (vd.z, - vd.x) - 0.5 * pi;\n  vuMat = StdVuMat (el, az);\n  ltPos[0] = ro + vuMat * vec3 (-0.3, 0.2, -0.02);\n  ltPos[1] = ro + vuMat * vec3 (0.3, 0.2, -0.02);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 80.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi);\n    rd = normalize (vec3 (uvv, zmFac));\n    rd.xy = Rot2D (rd.xy, 0.5 * pi * vuTr);\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (tCur - tCurM < 10. || noInt > 0) {\n    c4 = ShowWg (uv, canvas, parmV);\n    c4 = vec4 (mix (col, c4.rgb, c4.a),\n       ((noInt > 0) ? 0. : 0.2 + 0.8 * smoothstep (9., 10., tCur - tCurM)));\n  } else {\n    wgBxC = vec4 (0.48 * asp, -0.46, 0.022, 0.);\n    c4 = vec4 (0., 0.7, 0.7, 0.3 + 0.7 * smoothstep (1., 2.,\n       abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y));\n  }\n  col = mix (c4.rgb, col, c4.a);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Compleat Mandelbox 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Maxv2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nint nFrame;\nconst float txRow = 32.;\nconst float pi = 3.1415927;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[5], mPtr, mPtrP, stDat;\n  vec3 parmV;\n  vec2 iFrag, canvas, mt;\n  float tCur, tCurM, tCurP, asp, el, az, spd, vuTr, chCol;\n  int pxId, wgSel, wgReg, noInt;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  asp = canvas.x / canvas.y;\n  wgSel = -1;\n  wgReg = -2;\n  noInt = 1;\n  if (nFrame <= 1) {\n    parmV = vec3 (0.2, 0.3, 0.3);\n    mPtrP = mPtr;\n    el = 0.;\n    az = 0.;\n    tCurM = tCur;\n    tCurP = tCur;\n    vuTr = 0.;\n    chCol = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    parmV = stDat.xyz;\n    stDat = Loadv4 (1);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (2);\n    el = stDat.x;\n    az = stDat.y;\n    tCurP = stDat.z;\n    tCurM = stDat.w;\n    stDat = Loadv4 (3);\n    vuTr = stDat.x;\n    chCol = stDat.y;\n    noInt = int (stDat.z);\n  }\n  if (mPtr.z > 0.) {\n    for (int k = 0; k <= 2; k ++)\n       wgBx[k] = vec4 ((0.38 + 0.04 * float (k)) * asp, -0.21, 0.014 * asp, 0.18);\n    wgBx[3] = vec4 (0.42 * asp, -0.44, 0.018, 0.018);\n    wgBx[4] = vec4 (0.48 * asp, -0.46, 0.022, 0.);\n    mt = mPtr.xy * vec2 (asp, 1.);\n    for (int k = 0; k <= 4; k ++) {\n      if (Maxv2 (abs (mt - wgBx[k].xy) - wgBx[k].zw) < 0.) wgReg = k;\n    }\n    if (length (mt - wgBx[4].xy) < wgBx[4].z) wgReg = 4;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    if (wgSel >= 0) tCurM = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * clamp (1.1 * mPtr.x, -0.5, 0.5);\n      el = pi * clamp (1.1 * mPtr.y, -0.5, 0.5);\n    } else {\n      az *= 0.992;\n      el *= 0.992;\n    }\n  } else {\n    if (wgSel < 3) {\n      parmV[wgSel] = clamp (0.5 + 0.5 * (mPtr.y - wgBx[wgSel].y) / wgBx[wgSel].w, 0., 0.999);\n    } else if (mPtrP.z <= 0.) {\n      if (wgSel == 3) chCol = mod (++ chCol, 5.);\n    }\n    noInt = 0;\n  }\n  spd = 0.2 * parmV.x;\n  vuTr += spd * (tCur - tCurP);\n  if      (pxId == 0) stDat = vec4 (parmV, 0.);\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 2) stDat = vec4 (el, az, tCur, tCurM);\n  else if (pxId == 3) stDat = vec4 (vuTr, chCol, float (noInt), 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllfD2.jpg", "access": "api", "license": "cc-by-nc-sa-2.0", "functions": [[1392, 1392, 1414, 1414, 1836], [1838, 1838, 1860, 1860, 2778], [2780, 2780, 2813, 2813, 3267], [3269, 3269, 3290, 3290, 3546], [3548, 3548, 3597, 3597, 3862], [3864, 3864, 3896, 3896, 4098], [4100, 4100, 4135, 4135, 5286], [5288, 5288, 5336, 5336, 6472], [6474, 6474, 6498, 6498, 6585], [6587, 6587, 6643, 6643, 8593], [8595, 8595, 8641, 8641, 8698], [8700, 8700, 8724, 8724, 8841], [8843, 8843, 8865, 8865, 8892], [8894, 8894, 8916, 8916, 8943], [8945, 8945, 8967, 8967, 9005], [9007, 9007, 9043, 9043, 9249], [9251, 9251, 9281, 9281, 9394], [9487, 9487, 9512, 9512, 9635]], "test": "untested"}
{"id": "mtffD2", "name": "Rainbow Camera Draw Thing", "author": "Supercooldude", "description": "uh you click tge screen\n(turn camera on)", "tags": ["interactive", "camera", "rainbow"], "likes": 0, "viewed": 239, "published": 3, "date": "1693455610", "time_retrieved": "2024-07-30T17:36:03.068006", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (0.5 + 0.5*cos(iTime + uv.xyx * 2.0 + vec3(0,2,4))) * vec3(texture(iChannel0, uv)) * vec3(texture(iChannel1, uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.y/iResolution.x;\n    ivec2 fragCoordInt = ivec2(int(fragCoord.x), int(fragCoord.y));\n    vec3 col = vec3(texelFetch(iChannel0, fragCoordInt, 0));\n    \n    \n    \n    float dx = fragCoord.x - float(iMouse.x);\n    float dy = fragCoord.y - float(iMouse.y);\n    if (sqrt(dx*dx + dy*dy) < 5.0 && iMouse.z > 0.0)\n    {\n        col = vec3(1.0, 1.0, 1.0);\n    }\n    \n    fragColor = vec4(col, 1.0);\n\n    \n\n    if (iFrame == 0)\n    {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtffD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 368]], "test": "untested"}
{"id": "dlfBD2", "name": "r e d", "author": "Supercooldude", "description": "red\ni am as disappointed in myself as you are when you clicked on this project", "tags": ["red"], "likes": 0, "viewed": 125, "published": 3, "date": "1693453186", "time_retrieved": "2024-07-30T17:36:03.826976", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(1.0, 0.0, 0.0,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 215]], "test": "untested"}
{"id": "dlffW2", "name": "eindacor_cool_thing", "author": "Eindacor_DS", "description": "It's a cool thing, you dolt!", "tags": ["cool"], "likes": 0, "viewed": 14, "published": 3, "date": "1693452066", "time_retrieved": "2024-07-30T17:36:04.682688", "image_code": "#define AA .002f\n#define TWOPI 6.28318530718f\n\n// from here: https://discord.com/channels/318590007881236480/350444715142938625/1146550299474001960\nfloat de ( vec3 p ) {\n    float s = 3.0f, e;\n    for ( int i = 0; i++ < 8; ) {\n      p = mod( p - 1.0f, 2.0f ) - 1.0f;\n      s *= e = 1.4f / dot( p, p );\n      p *= e;\n    }\n    return length( p.yz ) / s;\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nvec3 rotateVec3(vec3 v, float angleX, float angleY, float angleZ) {\n    mat3 rotationX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(angleX), -sin(angleX),\n        0.0, sin(angleX), cos(angleX)\n    );\n\n    mat3 rotationY = mat3(\n        cos(angleY), 0.0, sin(angleY),\n        0.0, 1.0, 0.0,\n        -sin(angleY), 0.0, cos(angleY)\n    );\n\n    mat3 rotationZ = mat3(\n        cos(angleZ), -sin(angleZ), 0.0,\n        sin(angleZ), cos(angleZ), 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    return rotationZ * rotationY * rotationX * v;\n}\n\nfloat getRadialVal(vec2 center, vec2 p) {\n    float offsetAngle = getOffsetAngle(center, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x += ((.5 / aspectRatio) - .5);\n    uv.x *= aspectRatio;\n    \n    float scale = 3.;\n    uv *= scale;\n    \n    vec3 pos = vec3(uv.x, uv.y, sin(iTime * .02));\n    pos = rotateVec3(pos, .0, iTime * .025, 0.);\n    \n    float deVal = pow(de(pos), 2.);\n    \n    float resultCoeff = .1;\n    \n    float rVal = 1. - pow(deVal, resultCoeff);\n    float gVal = deVal;\n    \n    float rOut = pow(mix(rVal, gVal, (1. + sin(iTime * .25)) / 2.), 2.5);\n    float gOut = pow(mix(gVal, rVal, (1. + sin(iTime * .25))), 2.);\n    float bOut = pow((1. + sin(iTime * .5)) / 2., .5);\n    \n    vec3 colorOut = vec3(mix(.5, 1., rOut), mix(.35, .95, gOut), mix(0.2, .8, bOut));\n    \n    fragColor = vec4(colorOut, 1.);\n    \n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlffW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 148, 169, 169, 354], [356, 356, 403, 403, 662], [664, 664, 731, 731, 1191], [1193, 1193, 1234, 1234, 1390], [1392, 1392, 1449, 1449, 2260]], "test": "untested"}
{"id": "dtXfWj", "name": "Fork Voronoi fe Blindman67 766", "author": "Blindman67", "description": "Just messing with shaders... Added specular light and bump map.", "tags": ["voronoi"], "likes": 6, "viewed": 174, "published": 3, "date": "1693440853", "time_retrieved": "2024-07-30T17:36:05.542390", "image_code": "vec2 inRes;\nconst float PIXEL_SIZE = 3.0;\nconst float HEIGHT_SCALE = 1.0;\nvec3 lightPow = vec3(1000, 1000, 1000);\nvec3 lightPos = vec3(-12.5, 14.5, 12.5);\nvec3 camPos = vec3(0.5, 5, 0.5);\n\nvec4 GetColor(in vec2 fragCoord) {\n    vec2 uv = fragCoord * inRes;\n    vec4 cc = texture(iChannel0, uv);\n    vec2 offset = vec2(cos(cc.a * TAU * 2.0), sin(cc.a * TAU * 2.0)) / iResolution.xy;        \n    vec4 cc1 = texture(iChannel1, cc.xy * offset);\n    vec4 cc2 = texture(iChannel2, cc.xz + cc.yz + offset);\n    return sqrt((cc1 * cc1 + cc2 * cc2) * 0.5) ;\n\n}\n\nfloat GetLevel(vec4 col) {\n    \n    return (col.x + col.y + col.z + col.a) * HEIGHT_SCALE;\n}\n\nvec4 PixelColor(in vec2 fragCoord) {\n    vec2 uv = fragCoord * inRes;\n    vec4 colA = GetColor(fragCoord);\n\n    \n    float A  = GetLevel(colA);\n    float B = GetLevel(GetColor(fragCoord + vec2(PIXEL_SIZE,  0)));\n    float C = GetLevel(GetColor(fragCoord + vec2(0,  PIXEL_SIZE))); \n    vec3 norm = normalize(cross(vec3(1.0, B - A, 0), vec3(0, C - A, 1.0)));\n    vec3 L = vec3(uv.x, A, uv.y) - lightPos;\n    float dist = length(L);\n    L = normalize(L);\n    vec4 l = vec4((lightPow/ (dist * dist)) * clamp(dot(norm, L), 0.0, 1.0), 0) ;\n    vec3 R = reflect(L, norm);\n    float spec = pow(clamp(dot(normalize(camPos), R), 0.0, 1.0), 15.0);\n    return colA * l + vec4(spec) * (1.0 - A * 0.25);\n\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    inRes = 1.0 / iResolution.xy;\n    \n    fragColor = pow(PixelColor(fragCoord), vec4(1.2));  // push up the contrast a bit\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_POINTS 100u\n#define MAX_POINTS_F 100.0\n#define INV_11 (1.0 / 11.0)\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float ANG_90 = PI * 0.5;\nconst float INV_PI = 1.0 / PI;\nconst float INV_ANG_90 = 1.0 / ANG_90;\nconst float INV_TAU = 1.0 / TAU;\nconst float INV_60 = 1.0 / 60.0;\nconst float INV_64 = 1.0 / 64.0;\nconst float INV_255 = 1.0 / 255.0;\n\n\n#define MIN_SEED 0x1FFu\nconst float INV_RND_RANGE = 1.0 / float(0xFFFFFFFFu);\nuint seed = MIN_SEED;\nuint Rnd() { seed ^= seed << 13; seed ^= seed >> 17; seed ^= seed << 5; return seed; }\nuint Rnd(in uint range) { return Rnd() % range; }\nfloat RndUnit() { return float(Rnd()) * INV_RND_RANGE; }\nvec2 RndCoord() { return vec2(RndUnit(), RndUnit()); }\nbool Odds(in uint oneIn) { return (Rnd() % oneIn) == 0u; }\nvoid Seed(in uint val) { seed = MIN_SEED + val; }\nmat2 Rot2D(float ang) { return mat2(cos(ang), sin(ang), -sin(ang), cos(ang)); }\n\nvec4 colorRef[11] = vec4[](\n    vec4(0.0,  0.0,  0,  INV_11 * 0.0),\n    vec4(0.1,  0.1,  0,  INV_11 * 1.0),\n    vec4(0.2,  0.2,  0,  INV_11 * 2.0),\n    vec4(0.3,  0.3,  0,  INV_11 * 3.0),\n    vec4(0.4,  0.4,  0,  INV_11 * 4.0),\n    vec4(0.5,  0.5,  0,  INV_11 * 5.0),\n    vec4(0.6,  0.6,  0,  INV_11 * 6.0),\n    vec4(0.7,  0.7,  0,  INV_11 * 7.0),\n    vec4(0.8,  0.8,  0,  INV_11 * 8.0),\n    vec4(0.9,  0.9,  0,  INV_11 * 9.0),\n    vec4(1.0,  1.0,  0,  INV_11 * 10.0)\n);\nvec4 colorSet[11] = vec4[](\n    vec4(1,  0,  0,  1),\n    vec4(1,  0.5,0,  1),\n    vec4(1,  1,  0,  1),\n    vec4(0,  1,  0,  1),\n    vec4(0,  1,  1,  1),\n    vec4(0,  1,  0.5,1),\n    vec4(0,  0.5,1,  1),\n    vec4(0,  0,  1,  1),\n    vec4(0.5,0,  1,  1),\n    vec4(1,  0,  1,  1),\n    vec4(1,  0,  0.5,1)\n);\n\nvec4 color;\nfloat IsNear(uint idx, float mdist, vec2 xy) {\n    float dist = distance(xy, RndCoord());\n    if (dist < mdist) {\n        color = colorRef[idx % uint(colorSet.length())];\n        color.a = float(idx) / MAX_POINTS_F;\n        return dist;\n    }\n    return mdist;\n    \n}\nvec4 Vonoroi(vec2 xy, float dist) {\n    color = vec4(0);\n    uint idx = 0u;\n    while (idx < MAX_POINTS) {\n        dist = IsNear(idx++, dist, xy);\n    }\n    return color;\n}\n", "buffer_a_code": "#define RESET 1500\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 px = ivec2(fragCoord);\n    if (px.x == 0 && px.y == 0 && (iFrame % RESET) == 0) {\n\n        if (iFrame  % RESET == 0) {\n            fragColor = vec4(0,0,0,1);\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(0,0), 0);\n        } \n\n    } else if ((iFrame % RESET) == 1) {\n        Seed(uint(iResolution.x * iResolution.y) + uint(iFrame));\n        vec4 dd = texelFetch(iChannel0, ivec2(0,0), 0);\n        float dist = dd.x;\n        fragColor = Vonoroi(fragCoord / iResolution.xy, 1.0);\n    } else {\n        float turn = sin(float(iFrame - 100) / 100.0) * PI;\n        vec4 cc = texelFetch(iChannel0, px, 0);\n        const float d1 = 1.1;\n        const float d2 = 3.2;\n        vec4 cc1 = texture(iChannel0, (fragCoord + vec2(cos((cc.g * 0.5 + cc.a * 0.5) * TAU + turn) * d1, sin((cc.g * 3.0 + cc.a* 7.0) * TAU + turn) * d1)) / iResolution.xy);\n        vec4 cc2 = texture(iChannel0, (fragCoord + vec2(cos((cc.b + cc.a) * TAU + turn) * d2, sin((cc.b + cc.a)  * TAU + turn) * d2)) / iResolution.xy);\n\n        fragColor = vec4(sqrt((\n                cc.rgba  * cc.rgba  + \n                cc1.rgba * cc1.rgba + \n                cc2.rgba * cc2.rgba \n            ) * (1.0 / 3.0)));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 223, 223, 551], [553, 553, 579, 579, 645], [647, 647, 683, 683, 1339], [1342, 1342, 1397, 1397, 1524]], "test": "untested"}
{"id": "clfBW2", "name": "🐷🐷🐷", "author": "SnoopethDuckDuck", "description": "🐖\nhttps://pixelartmaker-data-78746291193.nyc3.digitaloceanspaces.com/image/e6f0391c9b3c097.png\n🐖", "tags": ["creepy", "peppa", "piggy"], "likes": 16, "viewed": 221, "published": 3, "date": "1693433273", "time_retrieved": "2024-07-30T17:36:06.308342", "image_code": "#define pi 3.14159\n#define dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec3 black    = vec3(0);\nvec3 white    = vec3(1);\nvec3 pink     = vec3(250, 170, 170)/255.;\nvec3 midPink  = vec3(250, 150, 135)/255.;\nvec3 darkPink = vec3(255, 120, 120)/255.;\nvec3 red      = vec3(255, 0, 0)/255.;\nvec3 bg       = vec3(225, 225, 225)/255.;\n\n// Set color = draw color for pixels inside box\n#define b(X,Y,W,H) if (X<=f.x&&f.x<X+W&&Y<=f.y&&f.y<Y+H) \\\n                       col = vec4(draw, 1);\n\nvec4 drawPiggy(ivec2 f, int x, int y) {\n    vec4 col;  // Output color\n    vec3 draw; // Draw color\n    \n    f -= ivec2(x, y);\n    ivec2 f0 = f;\n    ivec2 fabs = ivec2(abs(f.x), f.y);\n    \n    f = f0;\n    draw = pink;\n    b(-4,-3,10,6);\n    b(-5,3,7,1);\n    b(-6,4,4,1);\n    b(-5,5,1,1);\n    b(3,0,6,3);\n    b(7,1,4,3);\n    b(-5,-3,1,3);\n    b(-4,-4,9,1);\n    b(-3,-5,7,1);\n    b(-2,-6,5,1);\n    b(-1,-7,3,1);\n    b(2,-19,1,4);\n    b(-3,-19,1,4);\n    \n    f = f0;\n    draw = white;\n    b(-1,-1,3,3);\n\n    draw = black;\n    b(0,0,1,1);\n    b(2,-20,3,1);\n    b(-3,-20,3,1);\n\n    draw = red;\n    b(2,-2,1,1);\n    b(3,-3,3,1);\n    \n    draw = midPink;\n    b(-2,-4,2,2);\n\n    f = fabs;\n    draw = darkPink;\n    b(0,-15,4,1);\n    b(0,-14,6,3);\n    b(0,-11,5,3);\n    b(0,-8,4,1);\n    b(2,-7,2,1);\n    \n    draw = pink;\n    b(4,-8,3,1);\n    b(6,-12,1,4);\n    b(7,-13,1,1);\n    b(5,-13,1,1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = (U+U-R)/R.y;\n    \n    float t = iTime;\n        \n    // Background\n    O.rgb = bg;\n    \n    float sc = mix(200., 30., tanh(.4*t));   \n\n    ivec2 f = ivec2(floor(.5*sc*vec2(u.x/sin(u.y+iTime), u.y)));\n    vec4 pig = drawPiggy(f, 0, 6);\n    pig.a *= .6 + .4 * sin(u.y+iTime);\n    O = mix(O, pig, .6*pig.a);\n\n    float n = 8.;\n    for (float i; i++ < n;) {\n        float o = 2. * pi * i / n;\n        float sc2 = sc * (1.2 + .2 * cos(u.y*10.-4.*iTime+o));\n        float s = sin(iTime - .5*u.y*cos(iTime-2.*o) + o);\n        float c = cos(iTime - .5*u.y*cos(iTime-2.*o) + o);\n        ivec2 f = ivec2(floor(sc2*vec2((u.x-s)/c, u.y - .2 * c * cos(iTime))));\n        vec4 pig = drawPiggy(f, 0, 4);\n        pig.a *= .5 - .5 * c;\n        O = mix(O, pig, pig.a);\n    }    \n}", "image_inputs": [{"id": 34586, "src": "https://soundcloud.com/quarkimo/pomegranate-patch?si=27a8b8392f284c15bc04d8e3b205ef13&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[514, 514, 553, 553, 1419], [1421, 1421, 1459, 1459, 2263]], "test": "untested"}
{"id": "dlsfWB", "name": "polyhedral torus", "author": "FabriceNeyret2", "description": "mouse controls camera. \n\nok ok, it's maybe not now you make a polyedral torus :-p\n( at least #19:  r - 4.*z.x seems wrong )\n→ better solution by spalmer here: http://shadertoy.com/view/ctffWl  ", "tags": ["short", "golf"], "likes": 21, "viewed": 306, "published": 3, "date": "1693423366", "time_retrieved": "2024-07-30T17:36:07.102220", "image_code": "// better solution by spalmer here: http://shadertoy.com/view/ctffWl\n\n\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r,a;\n    vec3  R = iResolution, z,\n          D = normalize( vec3(U+U, -2.*R.y) - R ),            // ray direction\n          p = vec3(0,0,12), q,P,                              // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.             // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0)); // demo mode\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.005 )           // march scene\n        q = p, \n        q.yz *= rot(-C.y),                                    // rotations\n        q.xz *= rot(-C.x),\n        r = length(q.yz), a = atan(q.x,r-4.),                                                       \n        P = vec3( atan(q.z,q.y) , a , 0 ) /.628,              // surface parameterization \n        z = sin(fract(P)*.628-.314),                          // polygonalize \n        z = sqrt(1.+z*z),\n        t = length(vec2( q.x, r - 4.*z.x )) - z.y,            // polygonal torus surface     \n        p += .2*t*D;                                          // step forward = dist to obj  \n \n    O *= O*O*O*2.;                                            // color scheme\n // P = floor(P), O *= .6 + .6 * cos( P.x+11.7*P.y  + vec4(0,23,21,0) ); // coloring quads\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 182, 182, 1410]], "test": "untested"}
{"id": "dllfDS", "name": "rgb distorcion", "author": "nictemeral", "description": "rgb", "tags": ["rgb"], "likes": 1, "viewed": 128, "published": 3, "date": "1693417375", "time_retrieved": "2024-07-30T17:36:07.859195", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float distancia = sin(iTime)*.5+.5;\n    float fuerza = 0.05; \n    vec2 uvR=uv+smoothstep(0.,distancia,distance(uv,vec2(0.5)))*fuerza;\n    vec2 uvG=uv;\n    vec2 uvB=uv-smoothstep(0.,distancia,distance(uv,vec2(0.5)))*fuerza;\n   \n    float r = texture(iChannel0,uvR).r;\n    float g = texture(iChannel0,uvG).g;\n    float b = texture(iChannel0,uvB).b;\n\n    vec3 col = vec3(r,g,b);\n // col.rgb=vec3(pow(smoothstep(0.,distancia,distance(uv,vec2(0.5))),));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n} ", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 607]], "test": "untested"}
{"id": "clsfDB", "name": "🐷🐷", "author": "SnoopethDuckDuck", "description": "🐖\nhttps://twitter.com/pixelartideas/status/761795605047963648\n🐖", "tags": ["sexy", "fashion", "piggy", "sophistication"], "likes": 10, "viewed": 197, "published": 3, "date": "1693414403", "time_retrieved": "2024-07-30T17:36:08.622155", "image_code": "#define pi 3.14159\n#define dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec3 outline = vec3(0);\nvec3 pink = vec3(250, 171, 195)/255.;\nvec3 bg = vec3(0.639,0.796,0.914);\n\n// Set color = draw color for pixels inside box\n#define b(X,Y,W,H) if (X<=f.x&&f.x<X+W&&Y<=f.y&&f.y<Y+H) \\\n                       col = vec4(draw, 1);\n\nvec4 drawPiggy(ivec2 f, int x, int y) {\n    vec4 col;  // Output color\n    vec3 draw; // Draw color\n    \n    f -= ivec2(x, y);\n    ivec2 f0 = f;\n    ivec2 fabs = ivec2(abs(f.x), f.y);      \n   \n    draw = pink;\n    f = fabs;   \n    b(0,0,9,12);\n    b(0,-3,7,3);\n    b(7,10,3,3);\n    \n    f = f0;\n    b(-2,-5,25,10);\n    b(1,-8,22,3);\n    b(19,-16,2,8);\n    b(17,-16,2,1);\n    b(2,-16,2,8);\n    b(0,-16,2,1);\n    b(-4,-11,2,7);\n    b(-6,-11,2,1);\n    b(13,-11,2,3);\n    b(11,-11,2,1);\n    \n    draw = outline;\n    f = fabs;\n    b(1,0,1,1);\n    b(0,-2,2,1);\n    b(2,-1,2,1);\n    b(0,3,2,1);\n    b(2,2,1,1);\n    b(3,0,1,2);\n    b(0,-4,6,1);\n    b(6,-3,1,1);\n    b(7,-2,1,2);\n    b(8,0,1,9);\n    b(9,9,1,1);\n    b(10,10,1,3);\n    b(7,13,3,1);\n    b(6,12,1,1);\n    b(3,11,3,1);\n    b(0,12,3,1);\n    b(3,5,1,1);\n    b(7,10,1,1);\n    b(8,10,1,2);\n    \n    f = f0;\n    b(9,5,13,1);\n    b(22,4,4,1);\n    b(26,5,3,1);\n    b(28,6,1,2);\n    b(29,7,1,2);\n    b(27,9,2,1);\n    b(26,7,1,3);\n    b(23,-6,1,10);\n    b(22,-8,1,2);\n    b(21,-17,1,9);\n    b(17,-17,4,1);\n    b(16,-16,1,1);\n    b(17,-15,2,1);\n    b(18,-14,1,7);\n    b(5,-8,13,1);\n    b(4,-17,1,11);\n    b(0,-17,4,1);\n    b(-1,-16,1,1);\n    b(0,-15,2,1);\n    b(1,-14,1,8);\n    b(-2,-6,3,1);\n    b(-3,-5,1,1);\n    b(-2,-12,1,6);\n    b(-6,-12,4,1);\n    b(-7,-11,1,1);\n    b(-6,-10,2,1);\n    b(-5,-9,1,5);\n    b(15,-12,1,4);\n    b(11,-12,4,1);\n    b(10,-11,1,1);\n    b(11,-10,2,1);\n    b(12,-9,1,1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = (U+U-R)/R.y;\n    \n    float t = iTime;\n    \n    u.x += .1 * cos(u.y+t);   \n    \n    // Background\n    O.rgb = bg;\n     \n    O *= .95+.05*smoothstep(-.01, 0.2, .25-abs(fract(.75*(u.x-u.y)+.1*t)-.5));\n\n    float sc = mix(1000., 20., tanh(t));   \n    vec2 o = vec2(0, 2.-2.*tanh(.8*t));\n    vec4 pig;\n    \n    //pink = mix(bg, pink, tanh(.2*t));\n    \n    float n = 9.;\n    for (float i; i++ < n;) {\n        float fr = fract(i/n);\n\n        float tx = texture(iChannel0, .2*u+i/n+.02*t).r;\n        ivec2 f = ivec2(floor(sc*(u + o - \n                              .1*tanh(.1*t)*fr*dir(t+2.*tx))));\n        vec4 tempPig = drawPiggy(f, -9, 0);\n        pig = max(pig, (1.-fr) * tempPig);\n    }\n\n    O = mix(O, pig, pig.a) * exp(.1 - .06 * dot(u,u));\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34581, "src": "https://soundcloud.com/producerspace/fashion-words?si=15b8a85358b3475da0229fd0d4b4b313&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 355, 394, 394, 1819], [1821, 1821, 1859, 1859, 2644]], "test": "untested"}
{"id": "DtsfDB", "name": "bloody river ( 215 chars )", "author": "FabriceNeyret2", "description": "inspired bt the look of https://www.shadertoy.com/view/wdB3R3", "tags": ["transparency", "phong", "specular", "short", "1tweet"], "likes": 18, "viewed": 400, "published": 3, "date": "1693414326", "time_retrieved": "2024-07-30T17:36:09.526737", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = 1. - texture(iChannel0, u/=iResolution.xy).rrrr;                     // depth\n    \n          // vec4(.7,.85,.9,1) // water\n    O = pow( vec4(.8,.2,0,1), 6.*O + 3.*sin(.3*iTime -u.x) )                 // fluid volumetric color\n      + .7* pow( max(0., dot( normalize(vec2(dFdx(O.x),dFdy(O.x))) , cos(iTime+vec2(0,11)) )), 99. ); // specular\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 389]], "test": "untested"}
{"id": "clsfWS", "name": "diamboy's very simple raymarcher", "author": "Diamboy", "description": "just some simple math", "tags": ["raymarching"], "likes": 5, "viewed": 162, "published": 3, "date": "1693409741", "time_retrieved": "2024-07-30T17:36:10.299671", "image_code": "float sdf(vec3 p)\n{\n    p.z -= 2.3;\n    float c1 = cos(iTime);\n    float s1 = sin(iTime);\n    float c2 = cos(iTime*2.0);\n    float s2 = sin(iTime*2.0);\n    vec3 q = vec3(c2*p.x+s2*p.z, s1*s2*p.x+c1*p.y-c2*s1*p.z, -c1*s2*p.x+s1*p.y+c1*c2*p.z);\n    \n    vec2 r = vec2(length(q.xz) - 1.0, q.y);\n    return length(r) - 0.25;\n}\n\nvec3 ray_march(vec3 rd)\n{\n    vec3 o = vec3(0.0);\n    for (int i = 0; i < 20; i++)\n        o += sdf(o) * rd;\n    return o;\n}\n\nfloat get_color(vec2 uv)\n{\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 d = ray_march(rd);\n    return 1.0 / dot(d,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float col = get_color(uv);\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 322], [324, 324, 349, 349, 448], [450, 450, 476, 476, 573], [575, 575, 632, 632, 770]], "test": "untested"}
{"id": "ctXfDS", "name": "Tangent Space Matrix Spheremap", "author": "gehtsiegarnixan", "description": "This translates a vector from tangent space to world space or back from a sphere mapping.", "tags": ["3d", "uv", "mapping", "matrix", "tangent", "tangentspace", "tbn"], "likes": 7, "viewed": 392, "published": 3, "date": "1693408646", "time_retrieved": "2024-07-30T17:36:11.075596", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis demo shows the process of translating a vector between tangent \nand world space for sphere mapping without relying on any vertices.\nThis methodology proves particularly valuable for tasks like \ntranslating wind directions between world and tangent space.\n\nTo achieve this, it is necessary to generate the normal, tangent, \nand bitangent vectors corresponding to your mapping. The normal \nvector points upwards from the surface of the mapping, while the \ntangent vector aligns with the +X direction of your UV mapping in \nworld space. Similarly, the bitangent vector corresponds to the +Y \ndirection of your UV mapping.\n\nThese vectors are combined within a 3x3 matrix. When this matrix is \nmultiplied by a vector, it effectively transforms the vector to \nworld space. Conversely, the inverse of this matrix facilitates the \ntranslation of a vector from world space back to the tangent space \nof your mapping.\n\nThe visual representation is a fusion of a flow plot, which showcases \n3D coordinates in world space on a surface by displacing flowlines. \nThe wind direction is oriented perpendicular to this surface, \nmimicking the behavior of water waves. The arrows within the plot \nare in tangent space, indicating the direction of the vector in \ntangent space.\n\nSee here how the quiverplot works:\nhttps://www.shadertoy.com/view/dssyzf\n\nSee here how the flow plot works:\nhttps://www.shadertoy.com/view/dlSyDw\n\nThis plot has mouse controls to look around. Play with the constants\nbelow to edit the visualized vectors.\n*/\n\n// Define your custom direction here\n#define DIRECTION vec3(1.,1.,1.)\n\n// enable DIRECTION is worldspace, disable DIRECTION is tangent space\n//#define DIRECTIONWORLDSPACE\n\n//Spherical mapping\nvec2 sphereMap(vec3 uvw) {\n    // merkator projection\n    float u = 0.5 + atan(uvw.y, uvw.x) / (2.*3.1415);\n    float v = 0.5 + asin(uvw.z) / 3.1415;\n    return vec2(u, v);\n}\n\n// TBN Matrix for the spheremapping above\nmat3 sphereTBNMatrix(vec3 normal) {\n    // vec3 poleAxis = vec3(0,0,1.);\n    // vec3 tangent = normalize(cross(poleAxis, normal));\n    vec3 tangent = safeNormalize(vec3(-normal.y, normal.x, 0.), vec3(1,0,0));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\n// sphere normals form morgan3d https://www.shadertoy.com/view/4dsGD2\nvec3 inverseSphereMap(vec2 uv) {\n    // Inverse mapping for u\n    float theta = uv.y * 3.1415;\n\tfloat phi   = uv.x * 3.1415 * 2.0;     \n    float sinTheta = sin(theta);  \n\n    // Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = - vec3(sinTheta * cos(phi),                     \n                    sinTheta * sin(phi),\n                    cos(theta));\n    return dir;\n}\n\n// TBN Matrix finite difference to find the TBN matrix for the spheremap above\nmat3 sphereTBNMatrixApprox(vec3 normal) {\n    // Tiny offset in UV coordinates\n    vec2 offsetUV = sphereMap(normal) + vec2(0.001, 0.); \n    vec3 normalOffset = inverseSphereMap(offsetUV);\n    vec3 tangent = safeNormalize(normalOffset - normal, vec3(1,0,0));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\nvec3 TangentSpacePlot(vec3 uvw, vec3 direction) {\n    // generate mercator projection\n    vec2 uv = sphereMap(uvw);\n       \n    // tangent space matrix\n    mat3 tbnMatrix = sphereTBNMatrix(uvw);\n    \n    #ifdef DIRECTIONWORLDSPACE\n        // translate world space vector to tangent space\n        vec3 directionWS = direction;\n        vec2 directionTS = vec3(inverse(tbnMatrix) * direction).xy;\n    #else\n        // translate tangent space vector to world space\n        vec3 directionWS = tbnMatrix * vec3(direction.xy,0);\n        vec2 directionTS = direction.xy;\n    #endif\n        \n    // quiver plot in tangent space\n    float arrowscale = 20.;\n    float tsPlot = quiverPlot(uv, directionTS, arrowscale);   \n    \n    // World Space flow plot\n    float time = iTime * 0.25;\n    vec3 wsPlot = flowPlot(uvw, directionWS, time);\n\n    return max(wsPlot, vec3(tsPlot));\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n    } else {\n        mx = mm2(iTime*.1+um.x*5.);\n        my = mm2(iTime*0.05+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float t = iSphere(ro,rd);\n    vec3 col = vec3(0);\n    \n    if (t > 0.)\n    {\n    \tvec3 pos = ro+rd*t;\n        // Sphere mapping\n    \tcol = TangentSpacePlot(pos, DIRECTION);\n    } else {\n        // Background mapping\n        vec3 pos = rd;  \n        col = DIRECTION;\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Generic Functions _________________________________________\n\n// Safe Normalization avoiding division by zero with alternate\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec3 safeNormalize(vec3 vector, vec3 alternate) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a alternate vector\n        return alternate;\n    }\n}\n\n//_____________________Flow Plot______________________________\n\n// 3D cube grid with lines in RGB for XYZ axes\nvec3 cubeGrid(vec3 uvw, float lineThickness) {\n    // Side distance of the cube\n    vec3 sideDistBig = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Smaller scaled side distance of the cube\n    float detailScale = 4.0;\n    uvw *= detailScale;\n    vec3 sideDistDetail = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Merge grids\n    vec3 joined = min(sideDistBig, sideDistDetail);\n    \n    // Create hard outlines of sides\n    return step(joined, vec3(lineThickness)); \n}\n\n// viszalizes 3D Vector\nvec3 flowPlot(vec3 uvw, vec3 direction, float time) {\n    // should probably be input paramters\n    float gridScale = 1.3;\n    float lineThickness = 0.02;\n    float vectorScale = 0.15;\n    \n    direction *= vectorScale;\n    \n    uvw *= gridScale;\n    \n    // Static grid (looks calmer)\n    vec3 grid = cubeGrid(uvw, lineThickness);\n    \n    // Animated grid\n    int count = 7;\n    for (int index = 1; index < count; index += 1) {\n        // Unique percentage of each individual grid \n        float percent = fract(float(index) / float(count - 1) + time);        \n        // Fading brightness\n        float brightness = 1.0 - percent;\n        \n        // Scale offset\n        vec3 offset = percent * direction;\n        \n        // Sample grid\n        vec3 aniGrid = cubeGrid(uvw - offset, lineThickness);\n        \n        // Apply brightness which fades with distance\n        aniGrid *= brightness;\n\n        // Add to the existing grid color output\n        grid = max(grid, aniGrid);\n    }\n    \n    return grid;\n}\n\n//_____________________Quiver Plot______________________________\n\n// Rotate coordinates in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n    float lineThickness = 0.03;    // Thickness of the arrow line\n    float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    float maxSize = 0.9;           // Maximum arrow length (1 should be the max)\n    float minSize = 0.2;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        return step(arrowDist, 0.0); // no AA\n        //float blur = (gridSize * 1.0)/(size * 720.);\n        //return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXfDS.jpg", "access": "api", "license": "mit", "functions": [[2778, 2798, 2824, 2851, 2972], [2974, 3016, 3051, 3146, 3316], [3318, 3388, 3420, 3449, 3767], [3769, 3848, 3889, 3926, 4198], [4200, 4200, 4249, 4285, 5067], [5214, 5214, 5235, 5235, 5287], [5289, 5289, 5328, 5328, 5481], [5483, 5483, 5540, 5540, 6371]], "test": "untested"}
{"id": "DtffDB", "name": "Voronoi feedback", "author": "Blindman67", "description": "Just messing with shaders...", "tags": ["voronoi"], "likes": 4, "viewed": 169, "published": 3, "date": "1693390850", "time_retrieved": "2024-07-30T17:36:11.863489", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 cc = texture(iChannel0, uv);\n    vec4 cc1 = texture(iChannel1, cc.xy * vec2(cos(cc.a * TAU), sin(cc.a * TAU)) / (iResolution.xy * 0.1));\n    vec4 cc2 = texture(iChannel2, cc.yx + vec2(cos(cc.a * TAU), sin(cc.a * TAU)) / (iResolution.xy * 1.2));\n    fragColor = sqrt((cc1 * cc1 + cc2 * cc2) * 1.5) - cc2.brga;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_POINTS 190u\n#define MAX_POINTS_F 190.0\n#define INV_11 (1.0 / 11.0)\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float ANG_90 = PI * 0.5;\nconst float INV_PI = 1.0 / PI;\nconst float INV_ANG_90 = 1.0 / ANG_90;\nconst float INV_TAU = 1.0 / TAU;\nconst float INV_60 = 1.0 / 60.0;\nconst float INV_64 = 1.0 / 64.0;\nconst float INV_255 = 1.0 / 255.0;\n\n\n#define MIN_SEED 0x1FFu\nconst float INV_RND_RANGE = 1.0 / float(0xFFFFFFFFu);\nuint seed = MIN_SEED;\nuint Rnd() { seed ^= seed << 13; seed ^= seed >> 17; seed ^= seed << 5; return seed; }\nuint Rnd(in uint range) { return Rnd() % range; }\nfloat RndUnit() { return float(Rnd()) * INV_RND_RANGE; }\nvec2 RndCoord() { return vec2(RndUnit(), RndUnit()); }\nbool Odds(in uint oneIn) { return (Rnd() % oneIn) == 0u; }\nvoid Seed(in uint val) { seed = MIN_SEED + val; }\nmat2 Rot2D(float ang) { return mat2(cos(ang), sin(ang), -sin(ang), cos(ang)); }\n\nvec4 colorRef[11] = vec4[](\n    vec4(0.0,  0.0,  0,  INV_11 * 0.0),\n    vec4(0.1,  0.1,  0,  INV_11 * 1.0),\n    vec4(0.2,  0.2,  0,  INV_11 * 2.0),\n    vec4(0.3,  0.3,  0,  INV_11 * 3.0),\n    vec4(0.4,  0.4,  0,  INV_11 * 4.0),\n    vec4(0.5,  0.5,  0,  INV_11 * 5.0),\n    vec4(0.6,  0.6,  0,  INV_11 * 6.0),\n    vec4(0.7,  0.7,  0,  INV_11 * 7.0),\n    vec4(0.8,  0.8,  0,  INV_11 * 8.0),\n    vec4(0.9,  0.9,  0,  INV_11 * 9.0),\n    vec4(1.0,  1.0,  0,  INV_11 * 10.0)\n);\nvec4 colorSet[11] = vec4[](\n    vec4(1,  0,  0,  1),\n    vec4(1,  0.5,0,  1),\n    vec4(1,  1,  0,  1),\n    vec4(0,  1,  0,  1),\n    vec4(0,  1,  1,  1),\n    vec4(0,  1,  0.5,1),\n    vec4(0,  0.5,1,  1),\n    vec4(0,  0,  1,  1),\n    vec4(0.5,0,  1,  1),\n    vec4(1,  0,  1,  1),\n    vec4(1,  0,  0.5,1)\n);\n\nvec4 color;\nfloat IsNear(uint idx, float mdist, vec2 xy) {\n    float dist = distance(xy, RndCoord());\n    if (dist < mdist) {\n        color = colorRef[idx % uint(colorSet.length())];\n        color.a = float(idx) / MAX_POINTS_F;\n        return dist;\n    }\n    return mdist;\n    \n}\nvec4 Vonoroi(vec2 xy, float dist) {\n    color = vec4(0);\n    uint idx = 0u;\n    while (idx < MAX_POINTS) {\n        dist = IsNear(idx++, dist, xy);\n    }\n    return color;\n}\n", "buffer_a_code": "#define RESET 1500\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 px = ivec2(fragCoord);\n    if (px.x == 0 && px.y == 0 && (iFrame % RESET) == 0) {\n\n        if (iFrame  % RESET == 0) {\n            fragColor = vec4(0,0,0,1);\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(0,0), 0);\n        } \n\n    } else if ((iFrame % RESET) == 1) {\n        Seed(uint(iResolution.x * iResolution.y) + uint(iFrame));\n        vec4 dd = texelFetch(iChannel0, ivec2(0,0), 0);\n        float dist = dd.x;\n        fragColor = Vonoroi(fragCoord / iResolution.xy, 1.0);\n    } else {\n        float turn = sin(float(iFrame - 100) / 100.0) * PI;\n        vec4 cc = texelFetch(iChannel0, px, 0);\n        const float d1 = 1.1;\n        const float d2 = 3.2;\n        vec4 cc1 = texture(iChannel0, (fragCoord + vec2(cos((cc.g * 3.0 + cc.a* 7.0) * TAU + turn) * d1, sin((cc.g * 3.0 + cc.a* 7.0) * TAU + turn) * d1)) / iResolution.xy);\n        vec4 cc2 = texture(iChannel0, (fragCoord + vec2(cos((cc.b + cc.a) * TAU + turn) * d2, sin((cc.b + cc.a)  * TAU + turn) * d2)) / iResolution.xy);\n\n        fragColor = vec4(sqrt((\n                cc.rgba  * cc.rgba  + \n                cc1.rgba * cc1.rgba + \n                cc2.rgba * cc2.rgba \n            ) * (1.0 / 3.0)));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtffDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 420]], "test": "untested"}
{"id": "ctXBWS", "name": "Film Grain Projection", "author": "wilkie", "description": "This combines a few techniques together, some gifted from others, to form a film grain effect. This caps the frame rate of the incoming source to 10 frames per second while adding film lines, specs, and scratches.", "tags": ["retro", "film", "vintage"], "likes": 4, "viewed": 384, "published": 3, "date": "1693372368", "time_retrieved": "2024-07-30T17:36:12.628444", "image_code": "// Based loosely on the Godot Shaders version.\n// : https://godotshaders.com/shader/old-movie-shader/ (CC0)\n// My changes remain as CC0.\n\n// These define the intended width of the bezier curves serving as film scratches\nconst float grain_edge_width = 0.01; // 0.005 for a smooth line (but pft, it looks cooler a little too fat)\nconst float grain_smooth = 0.0025;\n\n// from: https://hhoppe.com/ravg.pdf?from=https://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf&type=path\n// and referencing: https://www.shadertoy.com/view/MtS3Dy\n// This calculates the distance vector from the origin to the given curve where:\n// b0: is the start point\n// b1: is the control point\n// b2: is the end point\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n    float a = determinant(mat2(b0, b2));\n    float b = 2.0 * determinant(mat2(b1, b0));\n    float d = 2.0 * determinant(mat2(b2, b1)); // 𝛼,𝛽,𝛿(𝑝)\n    float f = (b * d) - (a * a); // 𝑓(𝑝)\n\n    vec2 d21 = b2 - b1;\n    vec2 d10 = b1 - b0;\n    vec2 d20 = b2 - b0;\n\n    vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\n\n    gf = vec2(gf.y, -gf.x); // ∇𝑓(𝑝)\n\n    vec2 pp = -f * gf / dot(gf, gf); // 𝑝′\n\n    vec2 d0p = b0 - pp; // 𝑝′ to origin\n\n    float ap = determinant(mat2(d0p, d20)); //  𝛼,𝛽(𝑝′)\n\n    float bp = 2.0 * determinant(mat2(d10, d0p)); // 𝑡̅\n\n    // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n    float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0); // 𝑡̅\n\n    return mix(mix(b0, b1, t), mix(b1, b2, t), t); // 𝑣𝑖 = 𝑏(𝑡̅)\n}\n\n// Get the approximate distance from the point 'p' to the curve defined as\n// it is above in 'get_distance_vector'.\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n    return length(get_distance_vector(b0 - p, b1 - p, b2 - p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Get our UV coordinate\n    vec2 UV = fragCoord.xy / iResolution.xy;\n    \n\t// Get the film grained and slowed buffer\n\tvec4 frame = texture(iChannel1, UV);\n\t\n\tif (saturation < 1.0) {\n\t\tfloat desat = clamp(frame.r * 0.2126 + frame.g * 0.7152 + frame.b * 0.0722, 0., 1.);\n\t\tframe.rgb = mix(vec3(desat, desat, desat), frame.rgb, saturation);\n\t}\n\n\t// Make 'constrast' go from 0.0 to 2.0 instead of -1.0 to 1.0\n\tfloat contrast_multiplier = (contrast < 0.0) ? (1.0 / (-contrast + 1.0)) : (contrast + 1.0);\n\n\t// Ensure gamma is similarly used\n\tfloat gamma_multiplier = (gamma < 0.0) ? (-gamma + 1.0) : (1.0 / (gamma + 1.0));\n\n    // Determine seed for random film grain location based on frame time\n    float stepped_time = float(int(floor(iTime * 10.0)));\n    \n    // Obscure via noise\n    vec4 grain_color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // Compute the aspect ratio and a UV relative to the aspect ratio (relative_uv)\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 relative_uv = UV * aspectRatio;\n    \n    // Randomly pick a starting point\n    float RTIME = stepped_time * PI;\n    vec2 A3 = (clamp(vec2(\n        texture(iChannel2, vec2(RTIME, RTIME)).r,\n        texture(iChannel2, vec2(RTIME/2.0, RTIME/2.0)).g\n    ), 0.2, 0.8) - 0.2) * (1.0 / 0.6) * aspectRatio;\n\n    // Randomly pick a control point near the start\n    RTIME *= PI;\n    vec2 B3 = A3 + vec2(\n        texture(iChannel2, vec2(RTIME, RTIME)).r - 0.5,\n        texture(iChannel2, vec2(RTIME/2.0, RTIME/2.0)).g - 0.5\n    ) * 0.1;\n    RTIME *= PI;\n    \n    // Randomly pick an end point near the start\n    vec2 C3 = A3 + vec2(\n        texture(iChannel2, vec2(RTIME, RTIME)).r - 0.5,\n        texture(iChannel2, vec2(RTIME/2.0, RTIME/2.0)).g - 0.5\n    ) * 0.5;\n    \n    // Calculate the distance (smudged a bit for better effect) to this bezier curve\n    float dist = approx_distance(relative_uv, A3, B3, C3);\n    if (dist < grain_edge_width + grain_smooth) {\n        dist = smoothstep(grain_edge_width - grain_smooth, grain_edge_width + grain_smooth, dist);\n        grain_color += 1.0 - dist;\n    }\n    \n    // Randomly pick a new start\n    A3 = (clamp(vec2(\n        texture(iChannel2, vec2(RTIME, RTIME)).r,\n        texture(iChannel2, vec2(RTIME/2.0, RTIME/2.0)).g\n    ), 0.2, 0.8) - 0.2) * (1.0 / 0.6) * aspectRatio;\n\n    // Randomly pick a control point near the start\n    RTIME *= PI;\n    B3 = A3 + vec2(\n        texture(iChannel2, vec2(RTIME, RTIME)).r - 0.5,\n        texture(iChannel2, vec2(RTIME/2.0, RTIME/2.0)).g - 0.5\n    ) * 0.1;\n    RTIME *= PI;\n    \n    // Randomly pick an end point near the start\n    C3 = A3 + vec2(\n        texture(iChannel2, vec2(RTIME, RTIME)).r - 0.5,\n        texture(iChannel2, vec2(RTIME/2.0, RTIME/2.0)).g - 0.5\n    ) * 0.5;\n    \n    // Calculate the distance (smudged a bit for better effect) to this bezier curve\n    dist = approx_distance(relative_uv, A3, B3, C3);\n    if (dist < grain_edge_width + grain_smooth) {\n        dist = smoothstep(grain_edge_width - grain_smooth, grain_edge_width + grain_smooth, dist);\n        grain_color += 1.0 - dist;\n    }\n    \n    // Mix in film grain scratch lines\n    frame.rgb = mix(frame.rgb, grain_color.rgb * 0.2 + frame.rgb, texture(iChannel2, UV).r);\n\n    // Apply gamma\n\tframe = vec4(\n\t\tpow(\n\t\t\tframe.rgb,\n\t\t\tvec3(gamma_multiplier, gamma_multiplier, gamma_multiplier)\n\t\t) * contrast_multiplier + brightness,\n\t\tframe.a\n\t);\n\n\t// Compute the vignette filter 'power'\n    // (not capped by frame rate... this is the projector bulb flicker)\n\tfloat vignette_power = vignette + 0.5 * (\n        texture(iChannel2, vec2(iTime / 60.0, iTime / 59.0)).x\n    );\n    \n    // Compute the amount of light via the distance to the center\n\tfloat vig = -vignette_power * ((UV.x - 0.5) * (UV.x - 0.5) + (UV.y - 0.5) * (UV.y - 0.5));\n    \n    // Essentially an amount of light we will be adding into the frame.\n\tvec4 vignette_value = vec4(vig, vig, vig, 1.0);\n\n\t// Return result through vignette\n\tfragColor = mix(frame, vignette_value, vignette_amount);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// We want to encode how 'close' we are to 10fps interval and which frame in\n// the second we are within. So, we encode the iTime value to a quantized value\n// and encode it in every pixel of our buffer.\n\nfloat encode_time() {\n\t// TIME might be 150402.45 (seconds), so we can get the distance from\n\t// the 10fps range by knowing that a frame is happening every 100ms (0.1).\n\tint current_frame = int(floor((iTime - 0.05) * 10.0)) % 9;\n\t\n\t// Now we can get a frame number between 0 and 8 (as a fraction between\n\t// 0.1 and 0.9).\n\treturn 0.1 + (float(current_frame) * 0.1);\n}\n\n// This really actually computes the current frame information for each\n// step of our 'slowed' down video stream.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float encoded = encode_time();\n\n\t// Encode it into 4 floats\n\tfragColor = vec4(encoded, 1.0, 1.0, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// This is the shader that computes the capped frame. This essentially gives you the\n// last frame until buffer A tells us that we should be making a new frame.\n\nfloat encode_time() {\n\t// TIME might be 150402.45 (seconds), so we can get the distance from\n\t// the 10fps range by knowing that a frame is happening every 100ms (0.1).\n\tint current_frame = int(floor(iTime * 10.0)) % 9;\n\t\n\t// Now we can get a frame number between 0 and 8 (as a fraction between\n\t// 0.1 and 0.9).\n\treturn 0.1 + (float(current_frame) * 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 UV = fragCoord / iResolution.xy;\n   \n\t// Get the encoded time\n    float encoded = encode_time();\n\t\n\t// Get last encoded value\n\tfloat last_encoded = texture(iChannel0, vec2(0.5, 0.5)).r;\n\t\t\n\t// We should slow down the fps?\n\t// We need to truncate the frames per second to 10fps (just output the prior frame)\n\tif ((encoded + 0.05 > last_encoded && encoded - 0.05 < last_encoded) && last_encoded != 0.0) {\n\t\t// Copy over old frame\n\t\tfragColor = texture(iChannel1, UV);\n\t}\n\telse {\n        // Adjust for texture resolution to stretch it\n    \n\t\t// Apply vertical \"flutter\"\n\t\tfloat flutter_max = (1.0 / iResolution.y) * y_flutter_power;\n\t\tfloat flutter = mod(iTime, flutter_max) - (flutter_max / 2.0);\n\t\tfragColor = texture(iChannel3, UV + vec2(0.0, flutter));\n\t\t\n\t\t// Small speckles:\n\t\tfloat RTIME1=iTime;\n\t\tvec4 speckle = vec4(0.0, 0.0, 0.0, 0.0);\n\t\tfloat energy = 1000000.0 * (1.0 + 0.5 * texture(iChannel2, vec2(RTIME1,RTIME1)).r);\n\t\tfor (int i = 0; i < speckle_count; i++) {\n\t\t\tRTIME1 *= PI;\n\t\t\tvec2 position1=(clamp(vec2(\n                texture(iChannel2, vec2(RTIME1, RTIME1)).r,\n                texture(iChannel2, vec2(RTIME1/2.0, RTIME1/2.0)).g\n            ), 0.2, 0.8) - 0.2) * (1.0 / 0.6);\n\t\t\t\n\t\t\tfloat xdev1=(UV.x-position1.x);\n\t\t\tfloat ydev1=(UV.y-position1.y);\n\t\t\t\n\t\t\tenergy = 1000000.0 * (1.0 + 0.5 * texture(iChannel2, vec2(RTIME1,RTIME1)).r);\n\t\t\tfloat spec=energy*(xdev1*xdev1+0.5*ydev1*ydev1)+.1*texture(iChannel2, vec2(UV.x,UV.y)).r;\n\t\t\tspeckle+=vec4(max(0.0,20.0-spec),max(0.0,20.0-spec),max(0.0,20.0-spec),1.0);\n\t\t}\n\t\t\n\t\tspeckle *= speckle_power;\n\t\t\n\t\t// lines:\n\t\tfloat RTIME2=iTime;\n\t\tvec2 positionline = vec2(\n\t\t\ttexture(iChannel2, vec2(RTIME2,RTIME2)).r,\n\t\t\ttexture(iChannel2, vec2(RTIME2,RTIME2)).g\n\t\t);\n\t\t\n\t\t// Distance between us and the line\n\t\tfloat xline=(UV.x-positionline.x);\n\t\tfloat yline=(UV.y-positionline.y);\n\t\t\n\t\tenergy = 1000000.0 * (1.0 + 0.5 * texture(iChannel2, vec2(RTIME2,RTIME2)).r);\n\t\tfloat lin = energy * (xline*xline+0.00001*yline*yline) + 0.1 * texture(iChannel2, vec2(UV.x,UV.y)).r;\n\t\tvec4 line=vec4(max(0.0,8.0-lin),max(0.0,8.0-lin),max(0.0,8.0-lin),1.0);\n\t\tline *= line_power;\n\t\t\n\t\tvec4 dirt=mix(speckle,line,0.5) / 5.0;\n\t\tfragColor += dirt; //, frame, 0.7);\n\t}\n}\n", "buffer_b_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float line_power = 0.1;\nconst int speckle_count = 2;\nconst float speckle_power = 0.1;\nconst float y_flutter_power = 1.2;\n\nconst float PI = 3.14159;\n\nconst float vignette = 0.7;\nconst float vignette_amount = 0.2;\nconst float saturation = 0.0;\nconst float contrast = 0.3;\nconst float brightness = -0.4;\nconst float gamma = 0.7;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 695, 748, 748, 1558], [1560, 1676, 1734, 1734, 1800], [1802, 1802, 1859, 1888, 5856]], "test": "untested"}
{"id": "mlsfzs", "name": "translation without blur", "author": "lomateron", "description": "mouse changes direction-speed, also keyW \nbeen intensly searching for convolution with this property\nsolution was in front of my face without knowing\nthe solu is method1 from here https://www.shadertoy.com/view/Ws2czy\nwhich works in 1D here to work in 2D", "tags": ["convolution"], "likes": 3, "viewed": 140, "published": 3, "date": "1693371037", "time_retrieved": "2024-07-30T17:36:13.674647", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy)*.5+.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 C = texture(iChannel0, (u+vec2(0,0))/iResolution.xy);\n    vec4 R = texture(iChannel0, (u+vec2(1,0))/iResolution.xy);\n    vec4 L = texture(iChannel0, (u-vec2(1,0))/iResolution.xy);\n    vec4 U = texture(iChannel0, (u+vec2(0,1))/iResolution.xy);\n    vec4 D = texture(iChannel0, (u-vec2(0,1))/iResolution.xy);\n    vec2 m = 1.*(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n         m = clamp(m,vec2(-.5),vec2(.5));\n    float pi = 3.14159265359;\n    if((iFrame&1) == 0){C.x += +(+L.y -C.y)*m.x\n                               +(+D.y -C.y)*m.y;}\n    if((iFrame&1) != 0){C.y += +(-R.x +C.x)*m.x\n                               +(-U.x +C.x)*m.y;}\n    vec2 uf = u-iResolution.xy*.5;\n    if(iFrame == 0) C = 1./exp(dot(uf,uf)*.01)*vec4(1,1,0,0);\n    float keyW = texture(iChannel2, vec2(87.5/256.,.25)).x;\n    if(keyW!=0.) C = (texture(iChannel1, u/iResolution.xy).x*2.-1.)*vec4(1,1,0,0);\n    fragColor = C;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 126]], "test": "untested"}
{"id": "dtsfRs", "name": "Distortion Ripples t1", "author": "zyc", "description": "More playing with distortion effects - based on Musgrave chapter from Texturing & Modeling book.", "tags": ["ripples"], "likes": 0, "viewed": 205, "published": 3, "date": "1693364098", "time_retrieved": "2024-07-30T17:36:14.481490", "image_code": "// Fork of \"Distortion Ripples\" by mba105. https://shadertoy.com/view/XtsSzN\n// 2023-08-30 02:54:39\n\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; \n    vec3 x3 = x0 - D.yyy;     \n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    float n_ = 0.142857142857; \n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    \n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fBm(vec3 coords)\n{\n    const int octaves = 2;\n    \n    float smoothness = 2.0; // should be between 0.0 and 1.0?\n    float lacunarity = 2.0;\n    \n    float result = 0.0;\n    float totalAmplitude = 0.0;\n    \n    for (int o = 0; o != octaves; ++o)\n    {\n        float amplitude = pow(lacunarity, -smoothness * float(o));\n        \n        result += snoise(coords) * amplitude;\n        totalAmplitude += amplitude;\n        \n        coords *= lacunarity;\n    }\n    \n    return result / totalAmplitude;\n}\n\nfloat turbulence(vec3 coords)\n{\n    const float f_low = 1.0;\n    const int octaves = 8;\n    \n    float t = 0.0;\n    \n    for (int o = 0; o != octaves; ++o)\n    {\n        float f = f_low * pow(2.0, float(o));\n        \n        t += abs(snoise(coords)) / f;\n        \n        coords *= 2.0;\n    }\n    \n    return t; // - 0.3;\n}\n\nvoid mainImage(out vec4 result, in vec2 fragCoord)\n{\n    float time_scale = 0.5;\n    float time = iTime * time_scale;\n    \n\tvec2 uv = fragCoord.xy / min(iResolution.x, iResolution.y);\n    \n    \n    vec2 fbm_scale = vec2(1.0);\n    vec2 t_scale = vec2(5.0);\n    \n    vec2 x_offset = vec2(123.456, 0.0);\n    vec2 y_offset = vec2(349.234, 1704.2);\n    \n    \n    vec2 x_coords = (uv + x_offset) * fbm_scale;\n    float xo = fBm(vec3(x_coords, time));\n    \n    vec2 y_coords = (uv + y_offset) * fbm_scale;\n    float yo = fBm(vec3(y_coords, time));\n    \n    vec2 pixel = 1.0 / iChannelResolution[0].xy;\n    float max_po = 5.0;\n    vec2 po = max_po * vec2(xo, yo) * pixel;\n    vec2 tc = fragCoord.xy / iResolution.xy;\n    \n    \n    vec2 uv2 = tc + po;\n    uv2.y = 1.0 - uv2.y;\n    uv2 = clamp(uv2, vec2(0.0), vec2(1.0));\n    \n\tresult = texture(iChannel0, uv2);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 123, 123, 174], [176, 176, 197, 197, 248], [250, 250, 272, 272, 311], [313, 313, 341, 341, 395], [397, 397, 419, 419, 2293], [2295, 2295, 2319, 2319, 2799], [2801, 2801, 2832, 2832, 3124], [3126, 3126, 3178, 3178, 3979]], "test": "untested"}
{"id": "mtlfRs", "name": "Local Sorting Challenge", "author": "beans_please", "description": "What's the fastest way to sort a local float array? (in practice this array will be different for each pixel)\nKeep in mind we can't use recursion or dynamic memory allocation unless we emulate them which would probably slow things down more.", "tags": ["sort", "sorting"], "likes": 1, "viewed": 130, "published": 3, "date": "1693363623", "time_retrieved": "2024-07-30T17:36:15.243452", "image_code": "const int N = 90;\nfloat arr[N] = float[](17., 16., 19., 4., 32., 7., 9., 500., 21., 54., 33., 35., 47., 96., 64., 17., 16., 19., 4., 32., 7., 9., 500., 21.,  31., 1., -5., 7., 30., 22., 97., 4., 44., 79., 799., 9973., 64., -47., -8520., -9., 974., 34., 21., 54., 35., 47., 96., 64., 31., 1., -5., 7., 30., 22., 97., 4., 44., 79., 799., 9973., 64., -47., -8520., -9., 974., 21., 54., 35., 47., 96., 64., 31., 1., -5., 7., 30., 22., 97., 4., 44., 79., 799., 9973., 64., -47., -8520., -9., 974., 21., 54.);\n\n\n\n// Bubble Sort\n// https://www.geeksforgeeks.org/bubble-sort\nvoid bubble_sort()\n{\n    bool swapped;\n    float temp;\n    for (int i = 0; i < N - 1; i++)\n    {\n        swapped = false;\n        for (int j = 0; j < N - i - 1; j++)\n        {\n            if (arr[j] > arr[j + 1])\n            {\n                    // Swap\n                arr[j] += arr[j + 1];\n                arr[j + 1] = arr[j] - arr[j + 1];\n                arr[j] -= arr[j + 1];\n                swapped = true;\n            }\n        }\n\n        // If no two elements were swapped by inner loop, then break.\n        if (!swapped)\n            break;\n    }\n}\n\n\n\n// Insertion Sort\n// https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c\nvoid insertion_sort()\n{\n    int i, j;\n    float key;\n    for (i = 1; i < N; i++)\n    {\n        key = arr[i];\n        j = i - 1;\n\n        /* Move elements of arr[0..i-1], that are greater than key, to one position ahead \n        of their current position */\n        while (j >= 0 && arr[j] > key)\n        {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\n\n\n// Selection Sort\n// https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c\nvoid selection_sort()\n{\n    int i, j, min0;\n    float temp;\n    for (i = 0; i < N - 1; i++)\n    {\n        min0 = i;\n        for (j = i + 1; j < N; j++) if (arr[j] < arr[min0])\n            {\n                min0 = j;\n            }\n        temp = arr[i];\n        arr[i] = arr[min0];\n        arr[min0] = temp;\n    }\n}\n\n\n\n// Shaker Sort\n// Suggested by Envy24\n// https://www.shadertoy.com/view/stVfDV\nvoid shaker_sort()\n{\n    for (int L = N - 1, E = 1, C = -1; L > E; --L, ++E)\n    {\n        while (++C < L)\n        {\n            if (arr[C] > arr[C + 1])\n            {\n                float A = arr[C];\n                arr[C] = arr[C + 1];\n                arr[C + 1] = A;\n            }\n        }\n\n        while (--C >= E)\n        {\n            if (arr[C - 1] > arr[C])\n            {\n                float A = arr[C - 1];\n                arr[C - 1] = arr[C];\n                arr[C] = A;\n            }\n        }\n    }\n}\n\n\n\n// Radix Sort\n// Suggested by Envy24\n// https://www.shadertoy.com/view/stVfDV\nvoid radix_sort()\n{\n    const int max_num_of_digits = 3; // base 10 digits for max element value 255.\n    const int base = 10;\n\n    int temp[N];\n    int digits_arr[10];\n    int power = 1;\n    float inv = 1. / 255.;\n\n    for (int k = 0; k < max_num_of_digits; ++k)\n    {\n        for (int i = 0; i < 10; ++i)\n        {\n            digits_arr[i] = 0;\n        }\n\n        for (int i = 0; i < N; ++i)\n        {\n            int value = int(arr[i] * 255.);\n            int digit = (value / power) % base;\n            ++digits_arr[digit];\n            temp[i] = value;\n        }\n\n        for (int i = 0; i < 9; ++i)\n        {\n            digits_arr[i + 1] += digits_arr[i];\n        }\n\n        for (int i = N - 1; i >= 0; --i)\n        {\n            float value = float(temp[i]) * inv;\n            int digit = (temp[i] / power) % base;\n            arr[--digits_arr[digit]] = value;\n        }\n\n        power *= base;\n    }\n}\n\n\n\n// Quick Sort\n// Suggested by Envy24\n// https://www.shadertoy.com/view/stVfDV\nvoid quick_sort()\n{\n    int pairs[2 * N], rw_offset = 0;\n\n    pairs[rw_offset++] = 0;\n    pairs[rw_offset++] = N - 1;\n\n    while (rw_offset != 0)\n    {\n        /* Tony Hoare's partition. */\n        int high = pairs[--rw_offset], low = pairs[--rw_offset];\n\n        float pivot = (arr[low] + arr[high]) * 0.5;\n        int i = low, j = high;\n\n        for (int k = 0; k < N; ++k)\n        {\n            while (arr[i] < pivot)\n            {\n                ++i;\n            }\n            while (arr[j] > pivot)\n            {\n                --j;\n            }\n\n            if (i >= j)\n            {\n                break;\n            }\n\n            float t = arr[i];\n            arr[i] = arr[j];\n            arr[j] = t;\n            ++i;\n            --j;\n        }\n        /* Tony Hoare's partition. */\n\n        if (low < j)\n        {\n            pairs[rw_offset++] = low;\n            pairs[rw_offset++] = j;\n        }\n        if (j + 1 < high)\n        {\n            pairs[rw_offset++] = j + 1;\n            pairs[rw_offset++] = high;\n        }\n    }\n}\n\n\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Sort arr in increasing order\n\n    //bubble_sort();      // 10.6 fps\n    //insertion_sort();   // 18.9 fps\n    //selection_sort();   // 12.9 fps\n    //shaker_sort();      // 12.3 fps\n    quick_sort();       // 60.0 fps (maxed out, the real FPS may be higher)\n\n    frag_col = vec4(arr[0]);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[507, 567, 587, 587, 1123], [1127, 1232, 1255, 1255, 1631], [1635, 1740, 1763, 1763, 2054], [2058, 2137, 2157, 2157, 2653], [2657, 2735, 2754, 2754, 3646], [3650, 3728, 3747, 3747, 4772], [4776, 4776, 4831, 5020, 5128]], "test": "untested"}
{"id": "mlsfzl", "name": "🐷", "author": "SnoopethDuckDuck", "description": "🐖\nhttps://www.nicepng.com/ourpic/u2e6y3a9a9o0y3i1_easy-pixel-art-pig/\n🐖", "tags": ["sexy", "piggy"], "likes": 16, "viewed": 224, "published": 3, "date": "1693359833", "time_retrieved": "2024-07-30T17:36:16.504082", "image_code": "#define pi 3.14159\n#define dir(a) vec2(cos(a),sin(a))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define black vec3(0)\n#define pink vec3(236, 192, 209) / 255.\n#define blue vec3(133, 192, 234) / 255.\n\n// Set color = draw color for pixels inside box\n#define b(X,Y,W,H) if (X<=f.x&&f.x<X+W&&Y<=f.y&&f.y<Y+H) \\\n                       col = vec4(draw, 1);\n\nvec4 drawPiggy(ivec2 f, int x, int y) {\n    vec4 col;  // Output color\n    vec3 draw; // Draw color\n    \n    f -= ivec2(x, y);\n    f.x = abs(f.x);\n     \n    draw = pink;\n    b(0, -1, 7, 9);\n    b(0, -6, 6, 12);\n    \n    draw = black;\n    b(1, 0, 1, 1);\n    b(0, 2, 3, 1);\n    b(0, -2, 3, 1);\n    b(3, -1, 1, 3);\n    b(3, 3, 2, 2);\n    b(3, 6, 2, 1);\n    b(5, 5, 2, 1);\n    b(6, 4, 1, 1);\n    b(0, 7, 4, 1);\n    b(4, 8, 3, 1);\n    b(7, 6, 1, 2);\n    b(7, -1, 1, 5);\n    b(6, -3, 1, 2);\n    b(5, -7, 1, 4);       \n    b(2, -7, 4,  1);\n    b(0, -6, 3,  1);\n    b(3, -5, 1,  1);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = (U+U-R)/R.y;\n    \n    // Background\n    O.rgb = blue;        \n    O *= .95+.05*smoothstep(-.01, 0.01, .25-abs(fract(.75*(u.x-u.y)+.1*iTime)-.5));\n\n    // Little piggies\n    for (float i; i++ < 10.;) {\n        float io = 2. * pi * i / 10.;\n        vec2 v = fract(u + iTime * (.2 + .02*i*dir(io))) - .5;\n        ivec2 f = ivec2(floor(77. * v));\n        vec4 pig = drawPiggy(f, 0, 0);\n        O = mix(O, pig, .1 * pig.a);\n    }\n    \n    // Big piggy\n    u *= rot(pi/32.*cos(iTime));\n    u += .13 * dir(-iTime);\n    ivec2 f = ivec2(floor(11.*u));\n    vec4 pig = drawPiggy(f, 0, -2);\n    O = mix(O, pig, pig.a);\n    \n    // Vignette\n    float xp = exp(.1 - .12 * dot(u,u));\n    O.rgb = xp * mix(pink, O.rgb, xp);\n}", "image_inputs": [{"id": 34555, "src": "https://soundcloud.com/producerspace/provocative-whispers?si=b843ddfcbe104549ae11a73fe4da7875&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 399, 399, 957], [959, 959, 997, 997, 1749]], "test": "untested"}
{"id": "DllfRs", "name": "Blue Quadratics", "author": "fouad", "description": "two blue quadratic curves", "tags": ["curve"], "likes": 1, "viewed": 415, "published": 3, "date": "1693347459", "time_retrieved": "2024-07-30T17:36:17.334860", "image_code": "vec3 palette(float t){\n    vec3 a = vec3(0.11,0.176,0.357);\n    vec3 b = vec3(0.106,0.29,0.529);\n    vec3 c = vec3(0.18,0.486,0.898);\n    vec3 d = vec3(0.18,0.486,0.898);\n\n    return a + b*cos(.28318*(c+t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n\n    float d = abs(length(uv.y));\n    \n    vec3 col = palette(d) * (sin(iTime) + 2.);\n    \n    d+= length(uv.x) * -abs(uv.x) * (cos(iTime * .1) + 1.);\n    \n    d = abs(d);\n    \n    d = ((cos(iTime * .5)+1.2) * .003)/d;\n    \n    col *= d;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 211], [213, 213, 270, 270, 634]], "test": "untested"}
{"id": "ctsBRs", "name": "Warp Speed + Blocks (revision)", "author": "fouad", "description": "Warp Speed + Fluid Blocks", "tags": ["warp"], "likes": 1, "viewed": 209, "published": 3, "date": "1693344137", "time_retrieved": "2024-07-30T17:36:18.085853", "image_code": "/*\n\n'Warp Speed' by David Hoskins 2013.\nInspired by Kali: https://www.shadertoy.com/view/ltl3WS\n\n--- Combined with:\n\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n\nI've replaced the sdCuboid() and sdCylinder() distance functions with the exact ones\nfrom Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions)\nfor nicer blending.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Signed Distance Functions (SDFs):\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    vec3 q = abs(p) - 0.5 * vec3(w, h, d);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, 0.5 * h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface SmoothUnion(in Surface surface1, in Surface surface2, in float smoothness) {\n    float interpolation = clamp(0.5 + 0.5 * (surface2.signedDistance - surface1.signedDistance) / smoothness, 0.0, 1.0);\n    return Surface(mix(surface2.ambientColor, surface1.ambientColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.diffuseColor, surface1.diffuseColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.specularColor, surface1.specularColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.shininess, surface1.shininess, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.signedDistance, surface1.signedDistance, interpolation) - smoothness * interpolation * (1.0 - interpolation));\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    vec4 metashapeInfo1 = vec4(vec2(sin(iTime * 0.75), cos(iTime * 1.0)) * 200.0, 0.0, 80.0);\n    vec4 metashapeInfo2 = vec4(vec2(cos(iTime * 1.0), cos(iTime * 1.25)) * 200.0, 0.0, 90.0);\n    vec4 metashapeInfo3 = vec4(vec2(sin(iTime * 1.25), cos(iTime * 0.5)) * 200.0, 0.0, 120.0);\n\n    Surface metashape1 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(0.2, 0.2, 0.4), // color\n                                 vec3(0.0, 0.0, 0.0), 8.0,\n                                 sdCuboid(Rotate(Translate(p, metashapeInfo1.xyz), vec3(0.0, 0.0, iTime * 40.0)), 2.0 * metashapeInfo1.w, 2.0 * metashapeInfo1.w, 2.0 * metashapeInfo1.w) - 10.0);\n\n    Surface metashape2 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(0.2, 0.2, 0.4), // color\n                                 vec3(0.0, 0.0, 0.0), 64.0,\n                                 sdCylinder(Rotate(Translate(p, metashapeInfo2.xyz), vec3(0.0, 0.0, iTime * -20.0)), 2.0 * metashapeInfo2.w, metashapeInfo2.w) - 10.0);\n\n    Surface metashape3 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(0.2, 0.2, 0.4), // color\n                                 vec3(0.0, 0.0, 0.0), 0.0,\n                                 sdSphere(Translate(p, metashapeInfo3.xyz), metashapeInfo3.w));\n\n    return SmoothUnion(metashape1, SmoothUnion(metashape2, metashape3, 70.0), 70.0);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n    return illuminationAmbient + illuminationDiffuse + illuminationSpecular;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 color = shadeSurface(sceneSurface, ray, normal);\n            return vec4(color, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = (iTime+29.0) * 60.0;\n\n    float s = 0.0, v = 0.0;\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y * 1.5;\n\tfloat t = time*0.005;\n\tuv.x += sin(t) * .3;\n\tfloat si = sin(t*1.25); // ...Squiffy rotation matrix!\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * .1, time * 0.0008);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z, 3.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\tcol +=  vec3(v * 0.3, 0.15 + s * 0.45, 0.8 + v * 0.2) * v * 0.0075;\n\t\ts += .01;\n\t}\n\tfragColor = vec4(col, 1.0);\n    \n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = fragColor + (rayMarch(Ray(rayOrigin, rayDirection)) * 0.85);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1220, 1257, 1320, 1320, 1433], [1435, 1435, 1488, 1488, 1610], [1612, 1612, 1651, 1651, 1679], [1681, 1729, 1813, 1813, 2639], [2641, 2661, 2699, 2699, 2719], [2721, 2721, 2756, 2756, 3367], [3369, 3396, 3425, 3425, 4787], [4789, 4838, 4871, 4871, 5291], [5293, 5348, 5415, 5415, 5949], [5951, 5972, 5999, 5999, 6665], [6667, 6667, 6724, 6724, 7800]], "test": "untested"}
{"id": "ctlBRl", "name": "imagen binaria", "author": "nictemeral", "description": "binaria", "tags": ["bianria"], "likes": 0, "viewed": 124, "published": 3, "date": "1693338740", "time_retrieved": "2024-07-30T17:36:18.848813", "image_code": "\n//esta es una cuenta quizas algo avanzada para obtener algo cercano a la luminosidad de la imagen\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n  //return dot(color.rgb, vec3(0.333));\n}\n//en cambio podemos usar el promedio del rgb\nfloat promedio(vec4 color) {\n  return (color.r+color.g+color.b)/3.;\n}\n//y por ultimo podemos convertir la imagen rgb y hsb y extraer de estas el canal del brillo\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float umbral = sin(iTime*0.5)*0.5+0.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    float px =1./iChannelResolution[1].x;\n    \n    // Time varying pixel color\n    \n    vec4 tex = texture(iChannel1, uv +vec2(px,0));\n    //float sum +=;\n     \n    float v = step(umbral,luma(tex));\n    //float v = step(umbral,promedio(tex));\n    //float v = step(umbral,rgb2hsb(tex.rgb).b);\n      \n    \n    vec3 col = vec3(v);\n    //para ver las diferentes formas de generar una imagen en b/n\n   //  col = vec3(promedio(tex));\n     //col = vec3(luma(tex));\n    //col = vec3(rgb2hsb(tex.rgb).b);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 99, 123, 123, 217], [218, 263, 291, 291, 332], [333, 425, 451, 451, 881], [884, 884, 941, 991, 1627]], "test": "untested"}
{"id": "DllfRl", "name": "dilate simple", "author": "nictemeral", "description": "binaria", "tags": ["bianria"], "likes": 0, "viewed": 137, "published": 3, "date": "1693338730", "time_retrieved": "2024-07-30T17:36:19.597810", "image_code": "\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float puntoDeCorte =sin(iTime*0.5)*0.5+0.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    float px =1./iChannelResolution[1].x;\n    \n    // Time varying pixel color\n    \n    vec3 col = texture(iChannel1, uv).rgb;\n    \n    float sum =0.;\n    \n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(-px,0))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(0,px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(0,-px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(px,0))));\n    \n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(-px,px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(px,px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(px,-px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(-px,-px))));\n      \n\n    if(sum>0.)col= vec3(1.);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 79], [83, 83, 140, 190, 1097]], "test": "untested"}
{"id": "DtsfRl", "name": "erode simple", "author": "nictemeral", "description": "binaria", "tags": ["bianria"], "likes": 0, "viewed": 107, "published": 3, "date": "1693338717", "time_retrieved": "2024-07-30T17:36:20.370743", "image_code": "\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float puntoDeCorte =sin(iTime*0.5)*0.5+0.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    float px =1./iChannelResolution[1].x;\n    \n    // Time varying pixel color\n    \n    vec3 col = texture(iChannel1, uv).rgb;\n    \n    float sum =0.;\n    //kernel en forma de cruz\n    // -x-\n    // x-x\n    // -x-\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(-px,0))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(0,px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(0,-px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(px,0))));\n    /*\n    //kernel de casillas aledañas\n    // xxx\n    // x-x\n    // xxx\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(-px,px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(px,px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(px,-px))));\n    sum +=step(puntoDeCorte,luma(texture(iChannel1, uv +vec2(-px,-px))));\n      */\n\n    if(sum<3.)col= vec3(0);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 79], [83, 83, 140, 190, 1226]], "test": "untested"}
{"id": "mtffRl", "name": "Motion Noise", "author": "Weirdo", "description": "My Test_01", "tags": ["test"], "likes": 0, "viewed": 148, "published": 3, "date": "1693325434", "time_retrieved": "2024-07-30T17:36:21.316216", "image_code": "vec2 direction = vec2(1.0, 1.0);\nfloat speed = 5.0;\n\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv, vec2(12.985489, 5.889))) * 155894.);\n}\n\nfloat noise(vec2 uv){\n    vec2 i_uv = floor(uv);  //取整数\n    vec2 d_uv = fract(uv);  //取小数\n    d_uv = d_uv*d_uv*(3.-2.*d_uv); //smoothstep\n    \n    float shade_x0 = mix(rand(i_uv), rand(i_uv + vec2(1.,0.)), d_uv.x);\n    float shade_x1 = mix(rand(i_uv+vec2(0., 1.)), rand(i_uv + vec2(1.,1.)), d_uv.x);\n    float shade = mix(shade_x0, shade_x1, d_uv.y);\n    \n    return shade * shade;\n    \n}\n\nfloat motion_noise(vec2 uv, float s){\n    float shade;\n    shade = noise(uv + iTime * direction * speed * s) * max(0., cos(iTime));\n    shade += 0.5 * noise(uv) * max(0., cos(iTime));\n    \n    float addition_wave = noise(uv + direction * speed * s * 1.5 * sin(iTime));\n    \n    shade += addition_wave * max(0., cos(iTime));\n    \n    return shade * .4;\n}\n\nfloat recursive_noise(vec2 uv){\n    return motion_noise(uv + motion_noise(uv + motion_noise(uv, 0.3), 0.2), 0.5);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col = vec3(noise(uv * vec2(10., 1.) + vec2(iTime, 0.)));\n    vec3 col = vec3(recursive_noise(uv * vec2(10., 10.)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtffRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 73, 73, 141], [143, 143, 164, 164, 543], [545, 545, 582, 582, 898], [900, 900, 931, 931, 1015], [1019, 1019, 1076, 1126, 1447]], "test": "untested"}
{"id": "Dlffzl", "name": "bluenoise texture graph + revers", "author": "FabriceNeyret2", "description": "path between the successive values in 64x64 Void And Cluster Bluenoise.\nAlso, illustrates how to use GeneralPurpose MIPmap to reverse a map n=T(uv) into uv=T(n).\n\nUncomment buffD:19 to compare with regular noise", "tags": ["noise", "cubemap", "bluenoise", "gpmipmap"], "likes": 4, "viewed": 274, "published": 3, "date": "1693319106", "time_retrieved": "2024-07-30T17:36:22.078178", "image_code": "// path between the successive points in 64x64 Void And Cluster Bluenoise = buffA,B,C, using https://shadertoy.com/view/mt2cWR\n//                     ( simplifying \"Void And Cluster Bluenoise\" by krax. https://shadertoy.com/view/cdfSD8\n//                       from ref: https://alister-chowdhury.github.io/posts/20221230-bluenoise-generator/ )\n//   ( prev attempt with shadertoy bluenoise failed bcz ids are not unique https://www.shadertoy.com/view/ctXfzl )\n// Also, illustrates how to inverse n=T(uv) using GeneralPurpose MIPmap:\n//   see CubeA: we output only at matching coordinate * 2^2lod, and MIPmap(lod) will find it.\n//   here we inverse 1+1 value per frame within 64x64, but we could do 6*16²*2 = 3072 ( so the whole 64² map in 2 frames )\n//                                                                  or  ''' *4 = 6144 if we encode UVs in one float\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy;\n    float t = fract(float(iFrame)/4096.);   \n    O = texelFetch(iChannel0, ivec2(u), 0);\n    if ( u.y < 5. ) O = vec4(1, u.x/R.x > t, 0,1);               // progress bar = value\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int S = 64;           // bluenoiseSize = SxS , cycling tile\nfloat s = float(S),         // note that more buffers are needed if S > 64 : clone C , S/8^(i+1)\n      sigma = 2.5;          // NB: krax used 1.9 \n\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y) % S, 0)\n\nfloat H( uvec3 x ) {        // from iq https://www.shadertoy.com/view/XlXcW4\n    uint k = 1103515245U;   // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n // x = ((x>>8U)^x.yzx)*k;  // but this version only return 10⁻¹⁹ amplitude\n    return uintBitsToFloat( ((((x.x>>8U)^x.y)*k )  & 0x1fffffffU) ); // why ?\n // return 1e-19* float(((x.x>>8U)^x.y)*k   )  /float(0xffffffffU);  // Uniform\n}\n\n#define M(S,c)                                                                                  \\\nvoid mainImage( out vec4 O, vec2 U ) {                                                          \\\n    if( U.x > float(S/8) || U.y > float(S/8) ) return; /* we only simulate a small square    */ \\\n    O = vec4( 0,1e35,0,0);                                                                      \\\n    ivec2   start = min( ivec2(U)*8, S - 1 ),          /* to reduce a 8x8 above subtile to 1 */ \\\n              end = min( start + 8, S );                                                        \\\n    for( int y=start.y; y<end.y; ++y)                                                           \\\n      for( int x=start.x; x<end.x; ++x) {                                                       \\\n        vec4 E = T(x,y);                                                                        \\\n        c;                                             /* store result */                       \\\n}   } \n\n\n// CubeMap utils from  https://www.shadertoy.com/view/3tGBDz\nvec3 E;\n#define C(U,n,l) ( E =   vec3( 2.*fract(U) -1., 1 )                                             \\\n                       * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),                     \\\n                   E = (n)%3 != 2 ? E.yzx : E.xzy,                                              \\\n                   textureLod( iChannel1, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) , float(l) ) \\\n                 )\n                 ", "buffer_a_code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background energy.\n// output: .x = bluenoise, .y = energy.   \n// input:  D.yz = location or largest void.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if( U.x>s || U.y>s ) return; // we only simulate a small (cyclicling) square\n\n    if(iFrame == 0)              // init: noise = 0, energy = random\n    {   O.xy = vec2( 0, H(uvec3(U, 2111)) );\n        return;\n    }\n    \n    O = T(U.x,U.y);              // previous state\n    if(iFrame > S*S-1) return;   // max iteration reached\n \n \n    // Get the result from downscaling and finding the smallest void center\n    U = abs( floor(U) - texelFetch(iChannel1, ivec2(0), 0).zw ) / s;  // delta to target\n\n    float v = 1. - float(iFrame-1) / (s*s-1.); // noise value = normalized iterations\n\n    // Wrap around logic : max energy around optimal void center modulo s : https://www.desmos.com/calculator/zuopknqihy\n    vec2 d = ( abs( U - .5 ) - .5 )  * s / sigma;\n    O.xy += vec2( U==vec2(0) ? v : 0.,            // we are at the optimum : store noise\n                  v * exp( -dot(d,d) ) );         // energy += gaussian to optimum\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Void and cluster reduce init\n// input:  .xy = SxS state noise,energy.\n// output: .xyz = lowest energy value + position on SxS /8   ( and not already chosen )\n\nM( S , \n   if( E.x == 0. && E.y < O.y ) O = vec4( 0, E.y, x, y )\n )", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Void and cluster reduce iteration\n// input:  .xy = SxS /8 state energy,location\n// output: .xyz = lowest energy value + position on SxS /8²  ( and not already chosen )\n//                note that with S = 64 this is only 1 pixel.\n\nM( S/8 ,                                            \n   if( E.y < O.y ) O = E\n )", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 O, vec2 u, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2;   // faceID\n    if (D[n]<0.) n += 3;\n    \n    O *= 0.;\n    if (n>0) return;                                             // we only use Face 0                                  \n    if (u.x > s || u.y > s ) return; \n    \n    int S2 = S*S; \n    float s2 = float(S2);\n    float t = 1. - float(iFrame)/s2;\n    if (iFrame<2) return;\n   \n    int m = int(s2*texelFetch( iChannel0, ivec2(u), 0 )),        // bluenoise mask\n        T = int(s2*t) % S2;                                      // selected value\n \n    O *= 0.;\n    u *= s*s / s;                                                // so that MIPmap 6 directly read the normalized coordinate\n    m == T ? O.xy = u : m == (T+1) % S2 ? O.zw = u : u;\n}    ", "cube_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// === draw the lines between value t and t+1\n\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) ); \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = texelFetch(iChannel0, ivec2(u), 0);                   // previous state\n    vec4 T = C( vec2(32./1024.),0,6 );                        // .xy and .zw = reversed map values iFrame & iFrame+1\n    \n                                                              // populate the texture with the inverse map n = T(uv)\n // ivec2 n = ivec2(u); O = n.x+int(iResolution)*n.y == iFrame ? C( vec2(32./1024.),0,6 ) : O;\n\n                                                              // uncomment the 2 next to compare with pure random hash\n // #define H(i) fract(1e4*sin( ( 1.- float(i+iFrame)/s/s )*vec2(71.3,97.7) ))\n // T = vec4(H(),H(1));\n    \n    T *= iResolution.xyxy;\n    O =  O *.99                                               // fade previous image\n      + smoothstep( 1., 0., line( u, T.xy, T.zw ) );          // and draw line between the 2 last nodes\n\n}", "buffer_d_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlffzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[869, 869, 907, 907, 1117]], "test": "untested"}
{"id": "clffRs", "name": "Edged-Zebra-Patterns", "author": "2w435", "description": "Rough Black and White Patterns created from Bilinear Interpolation of a Grid with randomly generated 'Heights'.\nThe patterns can get wierd after long times due to the RNG.", "tags": ["bw", "stripes", "white", "black"], "likes": 3, "viewed": 159, "published": 3, "date": "1693319025", "time_retrieved": "2024-07-30T17:36:22.926909", "image_code": "#define PI 3.14159265359\n\nconst vec2 GRID_SIZE = vec2(12, 14);\nconst vec2 TRIG_SPEED = vec2(0.08, 0.05);\nconst vec2 LINEAR_SPEED = vec2(0.1, 0.15);\nconst vec2 FORM_PARAMS = vec2(0.11, 4);\n\n// RNG functions stolen from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord) / iResolution.y;\n    uv += vec2(sin(iTime), cos(iTime)) * TRIG_SPEED + LINEAR_SPEED * iTime;\n    \n    vec2 gridCord = uv * GRID_SIZE;\n    \n    // Nearest grid coords\n    vec2 brCorner = floor(gridCord);\n    \n    float A = noise( brCorner + vec2(0, 0) );\n    float B = noise( brCorner + vec2(0, 1) );\n    float C = noise( brCorner + vec2(1, 1) );\n    float D = noise( brCorner + vec2(1, 0) );\n    \n    // 1. Layer lerps\n    float t = fract(gridCord.x);\n    float E = mix(A, D, t);\n    float F = mix(B, C, t);\n    \n    // 2. Layer lerp\n    float G = mix(E, F, fract(gridCord.y));\n\n    // G(0.5) = sin(0.5 * b - c) = 0.5    therefor c = pi/6 - b\n    G = sin( FORM_PARAMS.y * G - PI / 6.0  - 0.5 * FORM_PARAMS.y);\n    // v(0.5) = 0, v'(x)= x / a\n    float v = (-0.125 + 0.5 * G * G) / FORM_PARAMS.x;\n    vec3 col = vec3( smoothstep( -FORM_PARAMS.x, FORM_PARAMS.x, v ) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clffRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 285, 305, 305, 369], [371, 371, 392, 392, 590], [592, 592, 649, 685, 1640]], "test": "untested"}
{"id": "mtsfzf", "name": "SampleSphere ByMrRice", "author": "MrRice", "description": "一个简单的小球demo，还未完善，算半成品吧", "tags": ["3d", "sphere"], "likes": 0, "viewed": 158, "published": 3, "date": "1693307987", "time_retrieved": "2024-07-30T17:36:23.758685", "image_code": "//作者：MRRice\n//github:https://github.com/soBigRice\n//喜欢图形的小伙伴认识一下吧\n\n\n\n//开始计算法线，normal\nvec3 computerNormal(vec3 position,vec3 center){\nvec3 normalColor=normalize(position-center);\nreturn normalColor;\n}\n\n//开始计算光照\n\n\n\n\n//开始创建小球球\nvec3 createSphere(vec2 uvs,vec3 center,float radius){\nvec2 uv=uvs*center.x;\n   float val=distance(center.yz,uv);\n   vec3 outColor=vec3(0.);\n   if(val<=radius){\n   //开始计算到屏幕的距离（假设屏幕距离是1）\n   float sDis=sqrt(radius*radius-val*val);\n   vec3 position=vec3(sDis+center.x,uv.x,uv.y);\n   vec3 normal=computerNormal(position,vec3(center));\n   outColor=normal;\n \n  } \n   return outColor;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=vec2(0.5);\n    uv.x*=iResolution.x/iResolution.y;\n    //uv*=2.;//uv缩放一下\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col;\n\n    float tDis=cos(iTime*2.)*6.;\n    //计算中心点\n    for(int a=0;a<4;a++){\n     if(col==vec3(0.)){\n     col+= createSphere(uv,vec3(3.+float(a)/2.,sin(iTime)/tDis*float(a),cos(iTime)/tDis*float(a)),0.4);\n     }\n    }\n\n   \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 131, 178, 178, 245], [272, 296, 349, 349, 713], [719, 719, 776, 826, 1354]], "test": "untested"}
{"id": "dlsBzX", "name": "Arcball with Bulbs", "author": "dr2", "description": "Virtual rotation controller (Shoemake's Arcball) used to orient Mandelbulb and varying Juliabulb fractals", "tags": ["fractal", "interactive", "mandelbulb", "navigation", "juliabulb", "trackball", "pentakis"], "likes": 24, "viewed": 391, "published": 3, "date": "1693296521", "time_retrieved": "2024-07-30T17:36:25.136003", "image_code": "// \"Arcball with Bulbs\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Implementation of Shoemake's Arcball (based on some old C code); extended to\n  control rotation speed in addition to angle.\n  Ball shows object orientation.\n  Click in green circle and drag yellow/red cursor to control rotation axis,\n  and angle (yellow) or speed (red); if cursor is on either green line then\n  rotation plane is one of the two marked great circles on the ball.\n  Yellow/red button sets controller function - either rotation angle or speed.\n  White button selects fractal type - Mandelbulb or varying Juliabulb.\n  Blue button resets controller and view.\n  Otherwise, mouse rotates and zooms overall view.\n  Behavior reverts to default if no user interaction detected.\n*/\n\n#define AA  1  // (= 0/1) optional antialiasing\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nmat3 objMat;\nvec3 qHit, ltDir;\nfloat dstFar, tCur;\nint nFrame, idObj, juMode;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec4 MJBulbDf (vec3 p)\n{ // (from \"Interactive Mandelbulb 2\")\n  vec4 aa, sa, ca;\n  vec3 c, q, qd, qm;\n  float d, qLen, qdLen, q2, q4, phi, theta, thetad, phid;\n  q = p.xzy;\n  c = (juMode > 0) ? normalize (vec3 (1., 1., 0.2 + 0.8 * SmoothBump (0.25, 0.75, 0.15,\n     fract (0.04 * tCur)))) : q;\n  qLen = length (q);\n  phi = atan (q.y, q.x);\n  theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n  thetad = 0.;\n  phid = 0.;\n  qdLen = 1.;\n  for (int n = VAR_ZERO; n < 5; n ++) {\n    qm = q;\n    q2 = qLen * qLen;\n    q4 = q2 * q2;\n    aa.xy = 8. * vec2 (theta, phi);\n    aa.zw = 7. * vec2 (theta, phi) + vec2 (thetad, phid);\n    sa = sin (aa);\n    ca = cos (aa);\n    q = q4 * q4 * vec3 (sa.x * vec2 (ca.y, sa.y), ca.x) + c;\n    qd = 8. * q4 * q2 * qLen * qdLen * vec3 (sa.z * vec2 (ca.w, sa.w), ca.z) + vec3 (1.);\n    qLen = length (q);\n    phi = atan (q.y, q.x);\n    theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n    qdLen = length (qd);\n    phid = atan (qd.y, qd.x);\n    thetad = (qdLen > 0.) ? asin (qd.z / qdLen) : 0.;\n    if (qLen > 3.1623) break;\n  }\n  d = (qLen > 0.) ? 0.5 * qLen * log (qLen) / qdLen : 0.;\n  return vec4 (d, qm);\n}\n\nvec3 DodecSymP (vec3 p)\n{   // (from \"Chinese Puzzle Balls 2\")\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n    if (j < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat PentakEdgeDf (vec3 p)\n{  // (from \"Pentakis Dodecahedron\")\n  vec3 q;\n  float d, a;\n  q = DodecSymP (p);\n  a = 0.5 * acos (-1. / sqrt (5.));\n  d = max (abs (length (q) - 1.), min (dot (q.yz, sin (a - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.))))) - 0.007;\n  return d;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 db4;\n  vec3 q;\n  float dMin, d, sz;\n  dMin = dstFar;\n  q = p;\n  d = PrSphDf (q, 2.5);\n  if (d < 0.1) {\n    sz = 2.;\n    db4 = MJBulbDf (objMat * q / sz);\n    d = sz * db4.x;\n    q = db4.yzw;\n    DMINQ (1);\n    sz = 2.3;\n    q = p;\n    d = sz * PentakEdgeDf (objMat * q / sz);\n    DMINQ (2);\n  } else dMin = min (dMin, d);\n  q = p;\n  q.x += 3.5;\n  q = objMat * q;\n  d = PrSphDf (q, 0.5);\n  DMINQ (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-5 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 BallCol ()\n{\n  vec3 col;\n  vec2 a;\n  col = (qHit.y > 0.) ? vec3 (1., 0.7, 0.7) : vec3 (0.7, 1., 0.7);\n  col *= 0.5 + 0.5 * step (0.01, Minv3 (abs (qHit)));\n  col *= 0.7 + 0.3 * step (0.05, Minv3 (vec3 (length (qHit.xy), length (qHit.yz),\n     length (qHit.zx))));\n  a = 2. * pi * floor (24. * atan (vec2 (qHit.z), - qHit.yx) / (2. * pi) + 0.5) / 24.;\n  col *= mix (0.5 + 0.5 * step (0.01, abs (dot (qHit.yz, sin (a.x + vec2 (0., 0.5 * pi))))), 1.,\n     step (0.07, abs (qHit.x)));\n  col *= mix (0.5 + 0.5 * step (0.01, abs (dot (qHit.xz, sin (a.y + vec2 (0., 0.5 * pi))))), 1.,\n     step (0.07, abs (qHit.y)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (HsvToRgb (vec3 (0.05 + mod (0.2 * log (length (qHit)), 1.), 1., 1)), 0.2);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (BallCol (), 0.2);\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj > 1) nDotL *= nDotL;\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.2);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col)\n{\n  vec4 stDat;\n  vec3 wgBx[4], cg;\n  vec2 cVec, w;\n  float mPtrz, s[2];\n  int wgSel, rtMode, noInt;\n  wgBx[0] = vec3 (1.4, -0.6, 0.25);\n  wgBx[1] = vec3 (1.65, -0.85, 0.04);\n  wgBx[2] = vec3 (1.65, -0.35, 0.04);\n  wgBx[3] = vec3 (1.7, 0.9, 0.05);\n  stDat = Loadv4 (0);\n  mPtrz = stDat.z;\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (2);\n  cVec = stDat.xy;\n  rtMode = int (stDat.z);\n  noInt = int (stDat.w);\n  s[0] = wgBx[0].x - wgBx[0].z;\n  s[1] = wgBx[1].x + wgBx[1].z;\n  w = uv - vec2 (0.5 * (s[0] + s[1]), wgBx[0].y);\n  col = mix (vec3 (0.35), col, 0.5 + 0.5 * smoothstep (4., 8., PrRoundBox2Df (w,\n     vec2 (0.5 * (s[1] - s[0]), wgBx[0].z + 0.03), 0.03) * canvas.y));\n  cg = (rtMode == 0) ? vec3 (1., 1., 0.) : vec3 (1., 0., 0.);\n  w = uv - wgBx[0].xy;\n  col = mix (vec3 (0., 1., 0.), col, smoothstep (3., 4., abs (length (w) - wgBx[0].z) * canvas.y));\n  if (length (w) < wgBx[0].z) col = mix (vec3 (0., 1., 0.), col,\n       smoothstep (3., 4., Minv2 (abs (w) * canvas.y)));\n  if ((mPtrz > 0. && wgSel == 0 || noInt > 0) && length (cVec) < 1.) col = mix (cg, col,\n     smoothstep (13., 15., length (w - cVec * wgBx[0].z)* canvas.y));\n  w = uv - wgBx[1].xy;\n  col = mix (vec3 (0., 0., 1.), col, smoothstep (3., 4., abs (length (w) - wgBx[1].z) * canvas.y));\n  w = uv - wgBx[2].xy;\n  col = mix (cg, col, smoothstep (3., 4., abs (length (w) - wgBx[2].z) * canvas.y));\n  w = uv - wgBx[3].xy;\n  col = mix (vec3 (0.9), col, smoothstep (3., 4., abs (length (w) - wgBx[3].z) * canvas.y));\n  if (juMode > 0) col = mix (vec3 (0.9), col, smoothstep (3., 4.,\n     abs (length (w) - 0.5 * wgBx[3].z) * canvas.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, qtCur, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  stDat = Loadv4 (1);\n  qtCur = stDat;\n  objMat = QtToRMat (qtCur);\n  stDat = Loadv4 (3);\n  juMode = int (stDat.y);\n  el = stDat.z;\n  az = stDat.w;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  zmFac = 8. - 4. * cos (az);\n  dstFar = 40.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi);\n    rd = vuMat * normalize (vec3 (uvv, zmFac));\n    col += (1. / naa) * ShowWg (uvv, canvas, ShowScene (ro, rd));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Arcball with Bulbs\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float txRow = 32.;\nconst float pi = 3.1415927;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, mPtr, mPtrP, qtCur;\n  vec3 wgBx[4], mVec, mVecP;\n  vec2 iFrag, canvas, mt, cVec, w;\n  float tCur, el, az, asp,tCurM, aSpd;\n  int pxId, wgSel, wgReg, nFrame, rtMode, noInt, juMode;\n  bool reset;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4) discard;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec3 (1.4, -0.6, 0.25);\n  wgBx[1] = vec3 (1.65, -0.85, 0.04);\n  wgBx[2] = vec3 (1.65, -0.35, 0.04);\n  wgBx[3] = vec3 (1.7, 0.9, 0.05);\n  wgSel = -1;\n  wgReg = -2;\n  reset = false;\n  noInt = 1;\n  if (nFrame <= 1) {\n    rtMode = 0;\n    juMode = 1;\n    mPtrP = mPtr;\n    reset = true;\n    tCurM = tCur;\n    el = 0.;\n    az = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    qtCur = stDat;\n    stDat = Loadv4 (2);\n    cVec = stDat.xy;\n    rtMode = int (stDat.z);\n    noInt = int (stDat.w);\n    stDat = Loadv4 (3);\n    tCurM = stDat.x;\n    juMode = int (stDat.y);\n    el = stDat.z;\n    az = stDat.w;\n  }\n  mt = 2. * mPtr.xy * vec2 (asp, 1.);\n  if (noInt > 0) rtMode = 1;\n  if (rtMode == 0) {\n    if (mPtr.z > 0. && mPtrP.z <= 0.) cVec = (mt - wgBx[0].xy) / wgBx[0].z;\n    if (length (cVec) < 1.) mVecP = vec3 (cVec, sqrt (max (0., 1. - dot (cVec, cVec))));\n    aSpd = 1.;\n  } else {\n    cVec = vec2 (0.);\n    mVecP = vec3 (0., 0., 1.);\n    aSpd = 0.01;\n  }\n  if (mPtr.z > 0.) {\n    if (length (mt - wgBx[0].xy) < wgBx[0].z) {\n      cVec = (mt - wgBx[0].xy) / wgBx[0].z;\n      wgReg = 0;\n    }\n    if (length (mt - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) reset = true;\n      wgReg = 1;\n    }\n    if (length (mt - wgBx[2].xy) < wgBx[2].z) {\n      if (mPtrP.z <= 0.) rtMode = 1 - rtMode;\n      wgReg = 2;\n    }\n    if (length (mt - wgBx[3].xy) < wgBx[3].z) {\n      if (mPtrP.z <= 0.) juMode = 1 - juMode;\n      wgReg = 3;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (mPtr.z > 0. && mPtrP.z <= 0. && wgSel >= 0 && wgSel <= 2 && noInt > 0) {\n    reset = true;\n    rtMode = 0;\n    noInt = 0;\n  }\n  if (reset) {\n    cVec = vec2 (0.);\n    qtCur = vec4 (0., 0., 0., 1.);\n    el = 0.;\n    az = 0.;\n  }\n  if (mPtr.z > 0.) {\n    if (wgSel >= 0) {\n      if (wgSel <= 2) tCurM = tCur;\n    } else {\n      el = pi * mPtr.y;\n      az = 2. * pi * mPtr.x ;\n    }\n  } else {\n    if (tCur - tCurM > 3.) noInt = 1;\n    el *= 0.99;\n    az *= 0.99;\n  }\n  if (noInt > 0) {\n    cVec = Rot2D (vec2 (0.5, 0.), 0.1 * pi * tCur);\n    mVecP = vec3 (0., 0., 1.);\n    aSpd *= 0.25;\n  }\n  if (noInt > 0 || wgSel == 0) {\n    mVec = vec3 (aSpd * cVec, sqrt (max (0., 1. - aSpd * aSpd * dot (cVec, cVec))));\n    qtCur = normalize (QtMul (vec4 (cross (mVecP, mVec), dot (mVecP, mVec)), qtCur));\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = qtCur;\n  else if (pxId == 2) stDat = vec4 (cVec, float (rtMode), float (noInt));\n  else if (pxId == 3) stDat = vec4 (tCurM, float (juMode), el, az);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsBzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1416, 1416, 1440, 1477, 2546], [2548, 2548, 2573, 2610, 3155], [3157, 3157, 3186, 3221, 3467], [3469, 3469, 3491, 3491, 3915], [3917, 3917, 3950, 3950, 4133], [4135, 4135, 4156, 4156, 4412], [4414, 4414, 4451, 4451, 4706], [4708, 4708, 4725, 4725, 5339], [5341, 5341, 5376, 5376, 6144], [6146, 6146, 6192, 6192, 7811], [7813, 7813, 7869, 7869, 8906], [8908, 8908, 8955, 8955, 9002], [9004, 9004, 9037, 9037, 9064], [9066, 9066, 9088, 9088, 9115], [9117, 9117, 9139, 9139, 9177], [9179, 9179, 9236, 9236, 9319], [9321, 9321, 9345, 9345, 9661], [9663, 9663, 9693, 9693, 9806], [9808, 9808, 9839, 9839, 9903], [9905, 9905, 9941, 9941, 10147], [10149, 10149, 10173, 10173, 10295], [10388, 10388, 10413, 10413, 10536]], "test": "untested"}
{"id": "DtlBRX", "name": "Mellow rainbow blobby blob thing", "author": "bwestlin", "description": "Raymarching adaptation of https://www.shadertoy.com/view/ldGSWV", "tags": ["raymarching", "sound", "sines"], "likes": 2, "viewed": 171, "published": 3, "date": "1693263170", "time_retrieved": "2024-07-30T17:36:26.151288", "image_code": "#define t iTime\n#define ic0 iChannel0\n\n// Smooth minimum : https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat map(vec3 p) {\n    float d = sdPlane(p - vec3(0.0, -1.0, 0.0), vec4(0.0, 1.0, 0.0, 1.0));    \n    \n    for (float x = -5.0; x < 5.0; x += 1.0) {\n        d = smin(\n            d,\n            sdSphere(p - vec3(\n                    x + sin(x + iTime * 0.7),\n                    -1.4 + texture(ic0, vec2(x * 0.1 * sin(iTime), 0.1)).x + sin(x * iTime),\n                    -3.0 - 0.1 * cos(x + iTime)\n                ), 0.1 + 0.2 * texture(ic0, vec2(x + iTime, 0.)).x),\n            1.5);\n    }\n    \n    return d;\n}\n\nconst float EPS = 0.001;\nconst float MAX_ITER = 40.0;\nconst float MAX_T = 100.0;\n\nfloat intersect(vec3 origin, vec3 rayDir) {\n    float t = 0.0;\n    float dt = 0.1;\n    \n    for (float i = 0.0; i < MAX_ITER; i += 1.0) {\n        t += dt;\n        \n        dt = map(t * rayDir + origin);\n        if (abs(t) < EPS) {\n            break;\n        }\n        \n        if (t > MAX_T) {\n            t = 0.0;\n            break;\n        }\n    }\n\treturn t;\n}\n\nvec3 simple_camera(vec2 uv) {\n    vec3 forward = vec3(0.0, 0.0, -1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 side = vec3(1.0, 0.0, 0.0);\n    return normalize(forward + uv.x * side + uv.y * up);\n}\n\nvec3 plasma(vec2 uv) {\n    float s1 = .5 + .5 * min(texture(ic0, vec2(.1, 0.) ).x * 1.5, 1.);\n    float s2 = .5 + .5 * min(texture(ic0, vec2(.4, 0.) ).x * 1.5, 1.);\n    float s3 = .5 + .5 * min(texture(ic0, vec2(.6, 0.) ).x * 1.5, 1.);\n    float s4 = .5 + .5 * min(texture(ic0, vec2(.9, 0.) ).x * 1.5, 1.);\n    \n    vec2 p1 = vec2(0., 0.);\n    vec2 p2 = vec2(0., 1.);\n    vec2 p3 = vec2(1., 1.0);\n    vec2 p4 = vec2(1., 0.);\n       \n    float c1 = .5 + .5 * sin(distance(uv, p1) * 10. * s1 + t + s1 / 4.);\n    float c2 = .5 + .5 * sin(distance(uv, p2) * 10. * s2 + t + s2 / 4.);\n    float c3 = .5 + .5 * sin(distance(uv, p3) * 10. * s3 + t + s3 / 4.);\n    float c4 = .5 + .5 * sin(distance(uv, p4) * 25. * s4 + t * 3. + s4 / 4.);\n           \n\treturn vec3(c1 + c4 * .33, c2 + c4 * .33, c3 + c4 * .33);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraOrigin = vec3(0.0, 0.0 + sin(iTime), 0.0);\n    vec3 rayDir = simple_camera(uv);\n    rayDir.y -= 0.3;\n        \n    vec3 color = vec3(0.);\n    \n    float t = intersect(cameraOrigin, rayDir);\n    \n    if (t > 0.0) {\n        vec3 hit = cameraOrigin + t * rayDir;        \n        color = plasma(hit.xy / 7.);\n        color *= vec3(16.0 / (t*t));\n    }    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 96, 137, 137, 230], [232, 232, 265, 265, 289], [291, 291, 322, 322, 356], [358, 358, 377, 377, 872], [956, 956, 999, 999, 1318], [1320, 1320, 1349, 1349, 1521], [1523, 1523, 1545, 1545, 2325], [2327, 2327, 2382, 2382, 2891]], "test": "untested"}
{"id": "mtfBRf", "name": "eindacor_lines", "author": "Eindacor_DS", "description": "They're lines, you dolt!", "tags": ["lines"], "likes": 0, "viewed": 11, "published": 3, "date": "1693254081", "time_retrieved": "2024-07-30T17:36:27.133661", "image_code": "#define AA .002f\n#define TWOPI 6.28318530718f\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9897, 78.233))) * 43758.5453);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nfloat getLineVal(int rowIndex, int colIndex, vec2 uv, float gridSize, float lineweight) {\n    float colModifier = hash(vec2(float(colIndex)));\n    \n    float leftVal = hash(vec2(float(rowIndex) + colModifier, float(rowIndex - 1)));\n    float rightVal = hash(vec2(float(rowIndex + 1) + colModifier, float(rowIndex)));\n    \n    leftVal = (1. + sin(iTime + leftVal)) / 2.;\n    rightVal = (1. + sin(iTime + rightVal)) / 2.;\n    \n    float leftEdge = uv.x - mod(uv.x, gridSize);\n    float rightEdge = leftEdge + gridSize;\n    float bottomEdge = uv.y - mod(uv.y, gridSize);\n    float topEdge = bottomEdge + gridSize;\n    \n    vec2 leftPoint = vec2(leftEdge, bottomEdge + gridSize * leftVal);\n    vec2 rightPoint = vec2(rightEdge, bottomEdge + gridSize * rightVal);\n\n    return lineSegmentSmoothStep(leftPoint, rightPoint, uv, lineweight, AA, true);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float gridSize = .1;\n    int rowIndex = int(uv.x / gridSize);\n    int colIndex = int(uv.y / gridSize);\n    \n    float lineweight = gridSize * .08;\n\n    float lineVal = getLineVal(rowIndex, colIndex, uv, gridSize, lineweight);\n    lineVal = max(lineVal, getLineVal(colIndex, rowIndex, vec2(uv.y, uv.x), gridSize, lineweight));\n\n    // Output to screen\n    fragColor = vec4(lineVal);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 93, 113, 113, 179], [181, 181, 261, 261, 350], [352, 352, 465, 465, 1099], [1101, 1101, 1190, 1190, 1945], [1947, 1947, 2004, 2054, 2567]], "test": "untested"}
{"id": "mtXBRX", "name": "step breakdown 1", "author": "Abyddon", "description": "Manual application of the step function.", "tags": ["piano", "step"], "likes": 0, "viewed": 21, "published": 3, "date": "1693246493", "time_retrieved": "2024-07-30T17:36:27.922552", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    \n    // x >= a\n    \n    //for(int i = 0; i < 10; i++)\n    //{\n        \n    //}\n    float uvx = uv.x*10.;\n    uvx = fract(uvx);\n    \n    float y = float((uvx) >= 0.5);\n    //y = fract(y);\n    \n    col = vec3(y);\n    \n    col += vec3(float(uv.y <= .3));\n    \n    y = float((uvx >= 0. && uv.x < 0.1 || uvx >= 0. && uv.x > 0.3 && uv.x < 0.4 || uvx >= 0. && uv.x > 0.7 && uv.x < .8));\n    \n    col += vec3(y);\n    \n    y = float((uvx) <= 0.95);\n    \n    col *= vec3(y);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 736]], "test": "untested"}
{"id": "DtfBRf", "name": "eindacor_wavy_circle", "author": "Eindacor_DS", "description": "It's a wavy circle!", "tags": ["wavy"], "likes": 3, "viewed": 289, "published": 3, "date": "1693237751", "time_retrieved": "2024-07-30T17:36:28.735379", "image_code": "#define AA .002f\n#define TWOPI 6.28318530718f\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nfloat getRadialVal(vec2 center, vec2 p) {\n    float offsetAngle = getOffsetAngle(center, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x += ((.5 / aspectRatio) - .5);\n    uv.x *= aspectRatio;\n    \n    vec2 center  = vec2(.5);\n    \n    float distFromCenter = distance(uv, center);\n    \n    float circleRadius = .4f;\n    float waviness = circleRadius * .03;\n    \n    float radialVal = getRadialVal(center, uv);\n    \n    float waves = 24.;\n    \n    float localRadialVal = mod(radialVal, 1. / waves) * waves;\n    \n    float distCheck = circleRadius + waviness * sin(localRadialVal * TWOPI);\n    \n    float lineWidth = circleRadius * .05;\n    \n    float waveVal = 0.;\n    if (distFromCenter > distCheck) {\n        float outerEdge = distCheck + lineWidth * .5;\n        waveVal = smoothstep(outerEdge + AA, outerEdge - AA, distFromCenter);\n    } else {\n        float innerEdge = distCheck - lineWidth * .5;\n        waveVal = smoothstep(innerEdge - AA, innerEdge + AA, distFromCenter);\n    }\n    \n    fragColor = vec4(waveVal);\n    \n    return;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 94, 94, 353], [355, 355, 396, 396, 552], [554, 554, 611, 611, 1617]], "test": "untested"}
{"id": "DtffRX", "name": "3D random generator 2", "author": "FabriceNeyret2", "description": "mouse controls camera.       variant of https://shadertoy.com/view/DlfBRj\nmore conform to original: https://twitter.com/junkiyoshi/status/1695401421112492445", "tags": ["short", "golf", "reproduction"], "likes": 42, "viewed": 447, "published": 3, "date": "1693233466", "time_retrieved": "2024-07-30T17:36:29.633977", "image_code": "// variant of https://shadertoy.com/view/DlfBRX\n//            https://shadertoy.com/view/DlfBRj                      // ( code a bit clearer here ;-) ).\n\n#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                       // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float T = iTime, t=9.,r,a,z,H; int c;\n    vec3  R = iResolution,\n          D = normalize( vec3(U+U, -2.*R.y) - R ),                   // ray direction\n          p = vec3(0,0,10), q,P,                                     // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.                    // camera control\n                          : 3.* cos(.3*T + vec3(0,11,0));        // demo mode\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )                   // march scene\n        q = p, \n        q.yz *= rot(-C.y),                                           // rotations\n        q.xz *= rot(-C.x),\n        r = length(q.yz) - 4., a = atan(q.x,r),                                                       \n        P = vec3( 4.*atan(q.z,q.y) , a , 0 ) /.628,                  // surface parameterization \n        H = fract(sin(ceil(P.x)*71.3)),                              // random 1D\n        P.y = mod( P.y + 5.* sin( \n                                  (.3+3.*H) * max(0.,mod(2.*T,7.)-3.) ) // columns rotation\n                             //   ceil((.3+3.*H)/.15708)*.15708  * ( max(0.,mod(2.*T,7.)-3.)+4.*floor(2.*T/7.)) )\n                    , 10.),             \n        z = sin(fract(P.y)*.628-.314),                                                                                   \n        t = max( a = abs( length(vec2(q.x,r)) - sqrt(1.+z*z) ) -.02, // intersection polygonal torus surface    \n                 texture(iChannel0,                                  //        and   random digit SDF\n                  (  vec2( c = int(10.*H+ceil(P.y))%10, 12-c/16 )     \n                    +( vec2(.25,.15) + vec2(.5,.7) * fract(P.xy) )       \n                  ) /16. ).w - .5 ),                                 // draw torus-digits intersection \n        p += .5*t*D;                                                 // step forward = dist to obj  \n \n    O *= O*O*O*1.5;                                                  // color scheme\n    t!=a ? O += .5 : O *= .0;                                        // try t==a ;-) . I prefer, but less conform. \n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtffRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 272, 272, 2358]], "test": "untested"}
{"id": "Dtsfzj", "name": "betty first", "author": "jorge2017a2", "description": "betty first", "tags": ["bettyfirst"], "likes": 16, "viewed": 227, "published": 3, "date": "1693189057", "time_retrieved": "2024-07-30T17:36:30.645272", "image_code": "///por jorge2017a2\n///Homero basico\n//3-ago-2023-\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(0.8),b,d)\n#define PI 3.141516\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0)); return colOut; }\n\n\nvec3 cejas(vec2 uv, vec3 col)\n{\nvec2 pc1p1=vec2(.700,.740);\nvec2 pc1p2=vec2(.790,.820);\nvec2 pc1p3=vec2(.850,.880);\nvec2 pc2p1=vec2(.830,.870);\nvec2 pc2p2=vec2(.890,.930);\nvec2 pc2p3=vec2(.940,.860);\nvec2 pc3p1=vec2(1.270,.860);\nvec2 pc3p2=vec2(1.350,.910);\nvec2 pc3p3=vec2(1.390,.820);\nvec2 pc4p1=vec2(1.380,.820);\nvec2 pc4p2=vec2(1.480,.770);\nvec2 pc4p3=vec2(1.520,.730);\nfloat d1= sdBezier(uv,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(uv,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(uv,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(uv,pc4p1,pc4p2,pc4p3);\n\n\ncol=DrawFigBorde(vec3(0.0),col,d1);\ncol=DrawFigBorde(vec3(0.0),col,d2);\ncol=DrawFigBorde(vec3(0.0),col,d3);\ncol=DrawFigBorde(vec3(0.0),col,d4);\n\n//nariz\n pc1p1=vec2(1.060,.410);\n pc1p2=vec2(1.140,.400);\n pc1p3=vec2(1.070,.370);\n d1= sdBezier(uv,pc1p1,pc1p2,pc1p3);\ncol=DrawFigSolo(vec3(0.0),col,d1);\nreturn col;\n}\n\nvec3 boca(vec2 p, vec3 col)\n{ vec2 pos , med;\npos=vec2(1.06,0.23);\nmed=vec2(0.03,0.04);\nfloat d1=sdEllipse(p-pos,med);\ncol=DrawFigSolo(vec3(0.0),col,d1);\n\npos=vec2(1.11,0.23);\nmed=vec2(0.03,0.04);\nfloat d2=sdEllipse(p-pos,med);\n  col=DrawFigSolo(vec3(0.0),col,d2);\n  \n    return col;\n}\n\nvec3 pestana(vec2 uv, vec3 col)\n{\nvec2 pc1p1=vec2(1.220,.620);\nvec2 pc1p2=vec2(1.190,.670);\nvec2 pc1p3=vec2(1.180,.710);\n\nvec2 pc2p1=vec2(1.260,.690);\nvec2 pc2p2=vec2(1.250,.740);\nvec2 pc2p3=vec2(1.230,.760);\n\nvec2 pc3p1=vec2(1.330,.700);\nvec2 pc3p2=vec2(1.340,.740);\nvec2 pc3p3=vec2(1.320,.780);\n\nvec2 pc4p1=vec2(1.390,.680);\nvec2 pc4p2=vec2(1.400,.740);\nvec2 pc4p3=vec2(1.400,.780);\n\nvec2 pc5p1=vec2(1.420,.620);\nvec2 pc5p2=vec2(1.430,.660);\nvec2 pc5p3=vec2(1.450,.720);\n\nvec2 pc6p1=vec2(1.420,.520);\nvec2 pc6p2=vec2(1.440,.480);\nvec2 pc6p3=vec2(1.450,.460);\n\nvec2 pc7p1=vec2(1.350,.450);\nvec2 pc7p2=vec2(1.352,.430);\nvec2 pc7p3=vec2(1.340,.400);\n\nvec2 pc8p1=vec2(1.260,.470);\nvec2 pc8p2=vec2(1.250,.430);\nvec2 pc8p3=vec2(1.270,.400);\n\nvec2 pc9p1=vec2(.750,.650);\nvec2 pc9p2=vec2(.740,.680);\nvec2 pc9p3=vec2(.720,.700);\n\nvec2 pc10p1=vec2(.810,.690);\nvec2 pc10p2=vec2(.810,.750);\nvec2 pc10p3=vec2(.780,.790);\n\nvec2 pc11p1=vec2(.850,.690);\nvec2 pc11p2=vec2(.870,.730);\nvec2 pc11p3=vec2(.880,.790);\n\nvec2 pc12p1=vec2(.930,.700);\nvec2 pc12p2=vec2(.940,.730);\nvec2 pc12p3=vec2(.950,.750);\n\nvec2 pc13p1=vec2(.960,.640);\nvec2 pc13p2=vec2(.980,.670);\nvec2 pc13p3=vec2(1.010,.710);\n\nvec2 pc14p1=vec2(.930,.490);\nvec2 pc14p2=vec2(.950,.440);\nvec2 pc14p3=vec2(.950,.420);\n\nvec2 pc15p1=vec2(.860,.430);\nvec2 pc15p2=vec2(.860,.370);\nvec2 pc15p3=vec2(.860,.360);\n\nvec2 pc16p1=vec2(.800,.460);\nvec2 pc16p2=vec2(.790,.420);\nvec2 pc16p3=vec2(.780,.390);\n\nvec2 pc17p1=vec2(.740,.470);\nvec2 pc17p2=vec2(.730,.430);\nvec2 pc17p3=vec2(.710,.390);\n\n\nfloat d1= sdBezier(uv,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(uv,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(uv,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(uv,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(uv,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(uv,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(uv,pc7p1,pc7p2,pc7p3);\nfloat d8= sdBezier(uv,pc8p1,pc8p2,pc8p3);\nfloat d9= sdBezier(uv,pc9p1,pc9p2,pc9p3);\nfloat d10= sdBezier(uv,pc10p1,pc10p2,pc10p3);\nfloat d11= sdBezier(uv,pc11p1,pc11p2,pc11p3);\nfloat d12= sdBezier(uv,pc12p1,pc12p2,pc12p3);\nfloat d13= sdBezier(uv,pc13p1,pc13p2,pc13p3);\nfloat d14= sdBezier(uv,pc14p1,pc14p2,pc14p3);\nfloat d15= sdBezier(uv,pc15p1,pc15p2,pc15p3);\nfloat d16= sdBezier(uv,pc16p1,pc16p2,pc16p3);\nfloat d17= sdBezier(uv,pc17p1,pc17p2,pc17p3);\n\n\ncol=DrawFigSolo(vec3(0.0),col,d1);\ncol=DrawFigSolo(vec3(0.0),col,d2);\ncol=DrawFigSolo(vec3(0.0),col,d3);\ncol=DrawFigSolo(vec3(0.0),col,d4);\ncol=DrawFigSolo(vec3(0.0),col,d5);\ncol=DrawFigSolo(vec3(0.0),col,d6);\ncol=DrawFigSolo(vec3(0.0),col,d7);\ncol=DrawFigSolo(vec3(0.0),col,d8);\ncol=DrawFigSolo(vec3(0.0),col,d9);\ncol=DrawFigSolo(vec3(0.0),col,d10);\ncol=DrawFigSolo(vec3(0.0),col,d11);\ncol=DrawFigSolo(vec3(0.0),col,d12);\ncol=DrawFigSolo(vec3(0.0),col,d13);\ncol=DrawFigSolo(vec3(0.0),col,d14);\ncol=DrawFigSolo(vec3(0.0),col,d15);\ncol=DrawFigSolo(vec3(0.0),col,d16);\ncol=DrawFigSolo(vec3(0.0),col,d17);\n\nreturn col;\n}\n\n\n\nvec3 cabeza(vec2 p,vec3 col)\n{\nvec2 pos, med,pr;\nfloat ang;\n\n//cabeza\npos=vec2(1.06,0.84);\nmed=vec2(0.68,0.53);\nfloat d2=sdEllipse(p-pos,med);\ncol=DrawFigBorde(vec3(0.0),col,d2);\n\n//rostro-boca\npos=vec2(1.07,0.45);\nmed=vec2(0.53,0.25);\nfloat d3=sdEllipse(p-pos,med);\n\n//ojo 1\npos=vec2(0.89,0.62);\nmed=vec2(0.33,0.4);\nfloat d4=sdEllipse(p-pos,med);\n\n\n//ojo 2\npos=vec2(1.34,0.64);\nmed=vec2(0.28,0.37);\nfloat d5=sdEllipse(p-pos,med);\n\nd3=min(d3,d5);\nd3=min(d3,d4);\ncol=DrawFigBorde(vec3(1.0),col,d3);\n\n//linea cabeza\nvec2 A,B;\nA= vec2(1.12,0.46+0.5);\nB= vec2(1.12,0.76+0.5);\nfloat d6=sdSegment(p,A,B);\ncol=DrawFigSolo(vec3(1.0),col,d6);\n\n\n//ojo izq\npos=vec2(0.84,0.58);\nmed=vec2(0.12,0.1201);\nfloat d10=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(1.0),col,d10);\n\n\n//ojo der\n pos=vec2(1.32,0.55);\n med=vec2(0.11,0.12);\nfloat d11=sdEllipse(p-pos,med);\ncol = DrawFigBorde(vec3(1.0),col,d11);\n\n//arete izq\npos=vec2(0.5,0.38);\nmed=vec2(0.06,0.12);\n ang =30.0 * PI / 180.0;\n pr = Rotate(p-pos, med, ang);\nfloat d12  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d12);\n\n\n\npos=vec2(1.57,0.39);\nmed=vec2(0.06,0.12);\n//rotar\nang = -25.0 * PI / 180.0;\npr = Rotate(p-pos, med, ang);\nfloat d13  = sdEllipse(pr, med);\ncol = DrawFigBorde(vec3(1.0), col, d13);\n\n\n\n//inicia pelo circulos\nfloat r14=0.12;\npos=vec2(0.74,1.27);\nfloat d14= sdCircle(p-pos,r14);\nfloat r15=0.07;\npos=vec2(0.78,1.32);\nfloat d15= sdCircle(p-pos,r15);\nd14=differenceSDF(d14,d15);\ncol=DrawFigBorde(vec3(0.0),col,d14);\n\n//--\nfloat r16=0.05;\n pos=vec2(0.46,1.14);\nfloat d16= sdCircle(p-pos,r16);\nfloat r31=0.08;\npos=vec2(0.42,1.1);\nfloat d31= sdCircle(p-pos,r31);\nd31=differenceSDF(d31,d16);\ncol=DrawFigBorde(vec3(0.0),col,d31);\n\n//inferior\nfloat r17=0.05;\npos=vec2(0.5,0.59);\nfloat d17= sdCircle(p-pos,r17);\n\nfloat r18=0.065;\npos=vec2(0.36,0.8);\nfloat d18= sdCircle(p-pos,r18);\n\nfloat r32=0.08;\npos=vec2(0.39,0.75);\nfloat d32= sdCircle(p-pos,r32);\nd32=differenceSDF(d32,d18);\ncol=DrawFigBorde(vec3(0.0),col,d32);\n\n\nfloat r19=0.05;\npos=vec2(1.35,1.32);\nfloat d19= sdCircle(p-pos,r19);\n\n\nfloat r3=0.08;\n pos=vec2(1.38,1.29);\n d3= sdCircle(p-pos,r3);\n d3=differenceSDF(d3,d19);\ncol=DrawFigSolo(vec3(0.0),col,d3);\n\n\nfloat r20=0.05;\npos=vec2(1.65,1.16);\nfloat d20= sdCircle(p-pos,r20);\n\nfloat r4=0.06;\n pos=vec2(1.65,1.12);\n d4= sdCircle(p-pos,r4);\nd4=differenceSDF(d4,d20);\ncol=DrawFigSolo(vec3(0.0),col,d4);\n\nfloat r21=0.05;\npos=vec2(1.71,0.83);\nfloat d21= sdCircle(p-pos,r21);\ncol=DrawFigBorde(vec3(1.0),col,d21);\n\nfloat r22=0.05;\npos=vec2(1.61,0.59);\nfloat d22= sdCircle(p-pos,r22);\n\nfloat r23=0.06;\npos=vec2(1.57,0.62);\nfloat d23= sdCircle(p-pos,r23);\n\nfloat r34=0.08;\n pos=vec2(1.62,0.57);\nfloat d34= sdCircle(p-pos,r34);\nd34=differenceSDF(d34,d23);\ncol=DrawFigBorde(vec3(0.0),col,d34);\n\nfloat r24=0.05;\npos=vec2(1.62,0.77);\nfloat d24= sdCircle(p-pos,r24);\ncol=DrawFigBorde(vec3(1.0),col,d24);\n\nfloat r25=0.05;\npos=vec2(1.52,0.96);\nfloat d25= sdCircle(p-pos,r25);\ncol=DrawFigBorde(vec3(1.0),col,d25);\n\n\nfloat r26=0.05;\npos=vec2(1.29,1.01);\nfloat d26= sdCircle(p-pos,r26);\ncol=DrawFigBorde(vec3(1.0),col,d26);\n\n\nfloat r27=0.05;\npos=vec2(0.95,1.02);\nfloat d27= sdCircle(p-pos,r27);\ncol=DrawFigBorde(vec3(1.0),col,d27);\n\nfloat r28=0.05;\npos=vec2(0.7,0.98);\nfloat d28= sdCircle(p-pos,r28);\ncol=DrawFigBorde(vec3(1.0),col,d28);\n\nfloat r29=0.05;\npos=vec2(0.56,0.81);\nfloat d29= sdCircle(p-pos,r29);\ncol=DrawFigBorde(vec3(1.0),col,d29);\n\nfloat r30=0.05;\npos=vec2(0.58,0.59);\nfloat d30= sdCircle(p-pos,r30);\n\nfloat r33=0.08;\npos=vec2(0.53,0.52);\nfloat d33= sdCircle(p-pos,r33);\nd33=differenceSDF(d33,d30);\ncol=DrawFigBorde(vec3(0.0),col,d33);\n\nfloat r35=0.08;\npos=vec2(1.7,0.78);\nfloat d35= sdCircle(p-pos,r35);\n\ncol=boca(p,col);\ncol=cejas(p, col);\ncol= pestana(p,col);\n\n///pupila izq\nfloat r1=0.09;\nfloat px=-0.025+0.05*sin(iTime*2.0);\n pos=vec2(0.93+px,0.62);\nfloat d1= sdCircle(p-pos,r1);\nd1=intersectSDF(d1,d10);\ncol=DrawFigSolo(vec3(0.0),col,d1);\n\n///pupila izq\nfloat r2=0.09;\n pos=vec2(1.41+px,0.63);\n d2= sdCircle(p-pos,r2);\nd2=intersectSDF(d2,d11);\ncol=DrawFigSolo(vec3(0.0),col,d2);\n\nfloat r5=0.05;\n pos=vec2(1.72,0.82);\n d5= sdCircle(p-pos,r5);\ncol=DrawFigSolo(vec3(0.0),col,d5);\nreturn col;\n}\n\nvec3 bettyboop(vec2 p, vec3 col)\n{ col= cabeza(p,col); return col;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uv2=uv*5.0;\n    //uv.y-=uv.y;\n    uv-=vec2(-0.65,-0.62);\n    uv*=1.0;\n    //vec3 col=vec3(0.,0.58,0.99);\n    vec3 col=vec3(0.65);\n    \n    col= bettyboop(uv, col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n//Quadratic Bezier - exact   (https://www.shadertoy.com/view/MlKcDD)\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n", "sound_code": "//Referencia de sonido IQ y Gaz\n//Modificado por Jorge2017a2---jorgefp\n#define PI acos(-1.)\n#define PIH (PI*.5)\n#define TAU (PI*2.)\n#define DD(a,b) n=(s>=a)?ivec2(a,b):n;\n\nconst float pi = 3.1415927;\nconst float tau = 6.283185;\nconst float ttotal=30.0;\n\n//gaz\n#define osc_sin(x)sin((x)*TAU)\n#define osc_saw(x)(1.-fract(x)*2.)\n#define osc_sqr(x)sign(0.5-fract(x))\n#define osc_tri(x)(asin(sin((x)*PI))/PIH)\nfloat noize(float t,  float a, float b){\n    float g=fract(cos(t*exp2(a))*exp2(b))+6.0;\n    return exp(-0.08*g*g) *40.0-1.;\n}\n\nfloat noize01(float t,  float a, float b){\n    float g=fract(cos(t*exp2(a))*exp2(b))+6.0;\n    return exp(-0.08*g*g) *40.0-1.;\n}\n\nfloat kick(float t)\n{  return clamp(1.5*asin(cos(320.0*t-30.0*exp(-40.0*t))),-1.,1.)*exp(-4.*t);}\n\nfloat kick2(float t)\n{ return clamp(1.5*asin(cos(620.0*t-30.0*exp(-40.0*t))),-1.,1.)*exp(-4.*t); }\n\nfloat snare(float t)\n{   float n=noize(t,10.,10.)*exp(-t*10.);\n    float f=t*160.,a=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float b=.05*osc_sin(10.*f+a)*exp(-t*3.);\n    float c=osc_sin(f+b)*exp(-t*15.), z;\n    return n+c;\n}\n\nfloat snare2(float t)\n{   float n=noize(t,10.,10.)*exp(-t*10.);\n    float f=t*260.,a=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float b=.05*osc_sin(10.*f+a)*exp(-t*3.);\n    float c=osc_sin(f+b)*exp(-t*15.), z;\n    return n+c;\n}\n\nfloat hihat01(float t)\n{ return noize01(t,10.,18.)*exp(-t*15.);}\n\n// saw wave iq\nfloat sawRaw( in float p, in float dpdt )\n{   float x = mod(p,tau)/tau; return 2.0*x-1.0; }\n\n// square wave iq\nfloat squareRaw( in float p, in float dpdt )\n{   float t = fract(p/tau); return sign(0.5-t);}\n\nfloat combinar(float a, float b, float f1, float f2)\n{   float ra=mix(0.0,a,f1);float rb=mix(0.0,b,f2);return ra+rb;}\n\nfloat wave( float x, float dxdt, in vec2 v )\n{   //referencia Inigo Quilez 2019\n    float a, b;\n    a=0.46;\n    b=0.65;\n    float f2=squareRaw(x, dxdt);\n    float fx=f2;\n    return fx;\n}\n\nfloat SoundIq(float time)\n{ ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal);\n // tune\n  const float tempo = 4.2;\n  int s = int(floor(time*tempo));\n  ivec2 n = ivec2(0);\n  \n  \n   DD(0,36)  DD(0,39)  DD(0,41)  DD(2,38)  DD(2,40)  DD(2,43)  DD(3,36)  DD(3,39) \n   DD(3,41)  DD(4,38)  DD(4,40)  DD(4,43)  DD(5,36)  DD(5,39)  DD(5,41)  DD(6,38)\n   DD(6,40)  DD(6,43)  DD(6,62)  DD(6,64)  DD(6,67)  DD(7,39)  DD(7,41)  DD(8,38)\n   DD(8,40)  DD(8,43)  DD(8,62)  DD(8,64)  DD(8,66)  DD(8,67)  DD(10,66) DD(10,64)\n   DD(11,65)  DD(12,64)  DD(12,66)  DD(12,70)  DD(13,65)  DD(13,68)  DD(14,40)\n   DD(14,42)  DD(14,46)  DD(14,28)  DD(14,30)  DD(14,34)  DD(15,44)  DD(15,41) \n   DD(15,38)  DD(16,42)  DD(16,40)  DD(20,42)  DD(20,40)  DD(20,44)  DD(22,41) \n   DD(22,43)  DD(24,40)  DD(24,42)  DD(24,44)  DD(24,68)  DD(24,66)  DD(24,64)\n   DD(25,41)  DD(25,43)  DD(25,46)  DD(26,44)  DD(26,42)  DD(26,40)  DD(26,64) \n   DD(26,66)  DD(26,68)  DD(27,70)  DD(27,67)  DD(27,65)  DD(30,68)  DD(30,70) \n   DD(30,65)  DD(30,62)  DD(32,69)  DD(32,67)  DD(32,64)  DD(33,70)  DD(33,68) \n   DD(33,46)  DD(33,44)  DD(34,45)  DD(35,44)  DD(35,46)  DD(35,70)  DD(35,68) \n   DD(36,43)  DD(36,41)  DD(36,39)  DD(38,40)  DD(38,42)  DD(40,43)  DD(40,41) \n   DD(40,39)  DD(42,40)  DD(42,42)  DD(43,43)  DD(43,41)  DD(43,39)  DD(43,67) \n   DD(43,65)  DD(43,63)  DD(44,64)  DD(44,66)  DD(44,70)  DD(45,67)  DD(45,65) \n   DD(46,64)  DD(47,63)  DD(47,65)  DD(47,67)  DD(48,64)  DD(49,63)  DD(49,65)\n   DD(49,67)  DD(50,64)  DD(51,63)  DD(51,65)  DD(51,67)  DD(53,65)  DD(55,65)\n   DD(53,67)  DD(55,67)  DD(57,65)  DD(57,67)  DD(59,65)  DD(59,67)  DD(59,63) \n   DD(59,69)  DD(60,64)  DD(60,68)  DD(61,67)  DD(61,65)  DD(62,66)  DD(63,66) \n   DD(64,65)  DD(65,64)  DD(66,63)  DD(63,67)  DD(64,68)  DD(65,69)  DD(67,66) \n   DD(68,65)  DD(70,64)  DD(71,63)  DD(68,67)  DD(69,68)  DD(70,69)  DD(72,67) \n   DD(72,65)  DD(74,65)  DD(74,67)  DD(76,65)  DD(76,67)  DD(78,42)  DD(80,42) \n   DD(78,40)  DD(80,40)  DD(78,44)  DD(80,44)  DD(81,41)  DD(84,41)  DD(81,43)\n   DD(84,43)  DD(82,42)  DD(83,42)  DD(84,46)  DD(84,38)  DD(85,45)  DD(86,42) \n   DD(85,38)  DD(87,38)  DD(87,45)  DD(87,46)  DD(87,41)  DD(87,43)  DD(88,42) \n   DD(89,43)  DD(89,41)  DD(90,44)  DD(90,40)  DD(91,45)  DD(91,39)  DD(92,42)\n   DD(93,38)  DD(93,46)  DD(94,37)  DD(94,47)  DD(94,42)  DD(96,42) \n  \n  // lower one octave\n  n.y +=0;  //n.y -= 12; //orginal\n      \n  // compute note frequency and time  \n  float f = 440.0*pow( 2.0, float(n.y-69)/12.0 );\n  float t = time - float(n.x)/tempo;\n  if( n.x==0 ) return 0.0;\n\n  // prepare wave parameters\n  float w = tau*f;\n  float dwdt = w/iSampleRate; // derivative\n    \n  // mix between bandlimited and raw saw waves  \n  vec2 v = smoothstep(-0.2,0.2,sin(time*vec2(1.0,0.5)) );\n    \n  // build instrument    \n  float y  = 0.4*wave(1.00*w*t,1.00*dwdt,v)*exp(-5.0*t);\n        y += 0.3*wave(2.01*w*t,2.01*dwdt,v)*exp(-7.0*t);\n        y += 0.2*wave(4.01*w*t,4.01*dwdt,v)*exp(-9.0*t);\n        y += 0.1*wave(8.01*w*t,8.01*dwdt,v)*exp(-11.0*t);\nreturn y;\n}\n\n\nfloat sound03(float time)\n{   int m, ss,c,d;\n    #define NI(c) m=(ss>=c)?c:m;\n  time = mod( time+1.0,ttotal );\n\n  // tune\n  const float tempo = 4.2;\n  ss = int(floor(time*tempo));\n  m = 0;\n  \n  NI(21) NI(23) NI(25) NI(29) NI(31) NI(49) NI(53) NI(55)\n  NI(57) NI(59) NI(66) NI(68) NI(70) NI(73) NI(75) NI(77) \n  float t = time - float(m)/tempo;\n  if( m==0 ) return 0.0;\n   float y= snare(t)*0.75;\n  return y;\n}\n\nfloat sound04(float time)\n{ int m, ss,c,d;\n     #define NI(c) m=(ss>=c)?c:m;\n    ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal );\n  // tune\n  const float tempo = 4.2;\n  ss = int(floor(time*tempo));\n  m = 0;\n \n NI(4) NI(7) NI(10) NI(14) NI(17) NI(18) NI(21) \n NI(23) NI(25) NI(27) NI(29) NI(30) NI(31) NI(33) \n NI(35) NI(37) NI(39) NI(40) NI(41) NI(43) NI(44) \n NI(45) NI(47) NI(48) NI(49) NI(51) NI(53) NI(55) NI(57) \n  \nfloat t = time - float(m)/tempo;\n  if( m==0 ) return 0.0;\nfloat y= kick(t)*0.75;\n    return y;\n}\n\nfloat sound05(float time)\n{  int m, ss,c,d;\n     #define NI(c) m=(ss>=c)?c:m;\n   time = mod( time+1.0, ttotal);\n  const float tempo = 4.2;\n  ss = int(floor(time*tempo));\n  m = 0;\n  \n \n NI(3) NI(6) NI(9) NI(11) NI(12) NI(13)\n NI(15) NI(16) NI(19) NI(20) NI(26) NI(28) \n NI(32) NI(34) NI(36) NI(41) NI(45) NI(49) \n NI(52) NI(54) NI(56) NI(58) NI(61) NI(63)\n NI(65) NI(67) NI(69) NI(71) \n \n  float t = time - float(m)/tempo;\n  if( m==0 ) return 0.0;\n  float y=hihat01(t)*0.75;\n    return y;\n}\n\nvec2 mainSound( in int samp, float time )\n{ float t=mod(time, 24.0);\nfloat y= SoundIq(t);\ny+= sound03(t);\ny+= sound04(t);\ny+= sound05(t);\n  return 0.75*vec2(y);\n}   \n\n\n", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtsfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 282, 282, 309], [310, 310, 353, 353, 380], [381, 381, 429, 429, 457], [460, 476, 524, 524, 602], [604, 604, 639, 639, 662], [664, 664, 701, 701, 773], [775, 775, 827, 827, 934], [936, 936, 998, 998, 1124], [1126, 1126, 1188, 1188, 1254], [1257, 1257, 1288, 1288, 2114], [2116, 2116, 2145, 2145, 2401], [2403, 2403, 2436, 2436, 5297], [5301, 5301, 5331, 5331, 9462], [9464, 9464, 9498, 9498, 9531], [9533, 9533, 9590, 9590, 9895]], "test": "untested"}
{"id": "dtsfzS", "name": "Bent Normals for SDF", "author": "XT95", "description": "A way to compute bent normals.\nAs always, Distance Field have amazing properties to get a nice approximation!", "tags": ["normal", "ibl", "bent"], "likes": 55, "viewed": 1919, "published": 3, "date": "1693167728", "time_retrieved": "2024-07-30T17:36:31.587753", "image_code": "// --------------------------------------------\n// A way to compute bent normals for SDF\n// --------------------------------------------\n//\n// How it works ?\n//\n// - Start by computing the normal, tangent, and bitangent\n//   at the intersection point.\n//\n// - Send a few rays into the hemisphere\n//   (spherical Fibonacci is used here to obtain a good distribution).\n//\n//    - Raymarch a few steps into the SDF\n//      (we don't care to intersect the surface, and that is the whole point!)\n//\n// - Compute the bent normal by summing\n//   all the rays weighted by the distance they traveled.\n//\n// - The sum of the distances of each ray also gives a nice approximation\n//   of ambient occlusion.\n//\n//\n// Why it works ?\n//\n// Raymarching a SDF takes more iterations when some geometries \n// are around.\n// For a fixed iteration count, if a ray goes farther than \n// an other, it mean that this direction is globally less\n// occluded than the other one.\n// By this fact, we can easily approximate the best unoccluded\n// direction without tracing a lot of rays. \n// We don't even need to raymarch rays until they hit the surface.\n//\n//\n// Shaders used here :\n//\n// SH code taken from https://www.shadertoy.com/view/Mt23zW\n// Scene taken from https://www.shadertoy.com/view/ldScDh\n// Specular occlusion factor from https://twitter.com/FewesW/status/1162341793721126913\n// --------------------------------------------\n\n#define AO_FACTOR 40.\n\nvoid normalBentAO(vec3 p, out vec3 n, out vec3 bent, out float ao) {\n    // init data\n    bent = vec3(0.);\n    ao = 0.;\n    \n    // compute the normal\n    float d = map(p);\n    vec2 eps = vec2(0.005,0.);\n    n = normalize(vec3(d-map(p-eps.xyy),d-map(p-eps.yxy),d-map(p-eps.yyx)));\n    \n    // orthonormal basis\n    vec3 nt,nb;\n    basis(n,nt,nb);\n    p += n * eps.x;\n    \n    \n    const int RayCount = 16;\n    const int RaymarchCount = 16;\n    \n    // send few rays\n    for(int j=0; j<RayCount; j++) {\n        vec3 fib = sphericalFibonacci(float(j),float(RayCount*2));\n        vec3 dir = fib.z * n + fib.x * nt + fib.y * nb;\n        \n        // raymarch few steps\n        float t = 0.025;\n        for(int i=0; i<RaymarchCount; i++) {\n            float dd = map(p + dir * t);\n            t += dd;\n            if (abs(dd)<eps.x) break;\n        }\n        \n        bent += dir * t;\n    }\n    \n    // normalize\n    float mag = length(bent);\n    ao = 1.-exp(-mag/float(RayCount)/AO_FACTOR);\n    bent /= mag;\n}\n\n\n\nvec3 shade(vec3 ro, vec3 rd, float depth, vec2 uv) {\n    float t = mod(iTime,9.5);\n    \n    // background\n    if (depth<0.) return ACES(texture(iChannel0, rd).xyz) *(smoothstep(3.5,3., t)+smoothstep(9.,9.5, t));\n    \n    // get data at intersection point\n    vec3 p = ro + rd * depth;\n    vec3 n, bent;\n    float ao;\n    normalBentAO(p, n,bent,ao);\n\n    // compute diffuse & specular term\n    float fre = pow(1.-max(0.,dot(-rd,n)),5.);\n    vec3 refDir = reflect(rd,n);\n    float specOcc = mix(max(dot(refDir,bent),0.), 1., ao); // from https://twitter.com/FewesW/status/1162341793721126913\n    \n    vec3 diff = calcIrradiance(bent) * ao * (1.-fre);\n    vec3 spec = texture(iChannel1,refDir).rgb * specOcc * fre;\n    \n    // display bent / AO / render\n    vec3 col1 = vec3(bent*.5+.5); col1 *= col1;\n    vec3 col2 = vec3(ao);\n    vec3 col3 = ACES(diff + spec);\n    \n    vec3 col = col3 * (smoothstep(3.5,3., t)+smoothstep(9.,9.5, t));\n    col += col1 * smoothstep(3.,3.5, t) * smoothstep(6.5,6., t);\n    col += col2 * smoothstep(6.,6.5, t) * smoothstep(9.5,9., t);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 v = uv*2.-1.;\n    v.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.,-1.,-30.);\n    vec3 rd = normalize(vec3(v,1.5));\n    ro.xz = rot(iTime*.25) * ro.xz;\n    rd.xz = rot(iTime*.25) * rd.xz;\n    \n    float depth = trace(ro, rd, vec2(0.,50.));\n    vec3 col = shade(ro,rd, depth, uv);\n\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ---------------------------------------------\n// Maths toolbox\n// ---------------------------------------------\n#define PI 3.14159265\n#define saturate(x) clamp(x,0.,1.)\n\nvec3 sphericalFibonacci(float i, float n) {\n    const float PHI = sqrt(5.) * 0.5 + 0.5;\n#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))\n    float phi = 2.0 * PI * madfrac(i, PHI - 1.);\n    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);\n    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));\n\n    return vec3( cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\n#   undef madfrac\n}\n\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.z<0.){\n        float a = 1.0 / (1.0 - n.z);\n        float b = n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, -b, n.x);\n        b2 = vec3(b, n.y * n.y*a - 1.0, -n.y);\n    }\n    else{\n        float a = 1.0 / (1.0 + n.z);\n        float b = -n.x * n.y * a;\n        b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n        b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n    }\n}\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    \n    return mat2(a,-b,b,a);\n}\n\n\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\n\n// ---------------------------------------------\n// SH of the scene\n// from https://www.shadertoy.com/view/Mt23zW\n// ---------------------------------------------\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is St. Peter's Basilica.\nconst SHCoefficients stpeter = SHCoefficients(\n    vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    vec3(-0.0818750, -0.0321501,  0.0033399 )\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = stpeter;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\n\n\n// ---------------------------------------------\n// Raytracing\n// ---------------------------------------------\nfloat map(vec3 p);\nfloat trace(vec3 ro, vec3 rd, vec2 nearFar) {\n    float t = nearFar.x;\n    \n    for(int i=0; i<128; i++) {\n        float d = map(ro+rd*t);\n        t += d;\n        if (abs(d) < 0.001) break;\n    }\n    if (t > nearFar.y) return -1.;\n    return t;\n}\n\n\n// ---------------------------------------------\n// SDF Scene\n// https://www.shadertoy.com/view/ldScDh\n// ---------------------------------------------\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opRepLim( in float p, in float s, in float lima, float limb, out float id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-lima,limb);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim, out vec2 id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax, out vec2 id )\n{\n    id = round(p/s);\n    return p-s*clamp(id,-limmin,limmax);\n}\nfloat opExtrussion( in float sdf, float z, in float h )\n{\n    vec2 w = vec2( sdf, abs(z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat hash1( vec2 p ) { p = 50.0*fract( p*0.3183099 ); return fract( p.x*p.y*(p.x+p.y) ); }\nfloat map( in vec3 p )\n{\n    vec3 op = p;\n    p.y += 2.0;\n    float ma = 0.0;\n\n    // columns\n    vec2 id;\n    vec3 q = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,2.0), id );\n    float d = length(q.xz) - 0.9 + 0.05*p.y;\n    d = max(d,p.y-6.0);\n    d = max(d,-p.y-5.0);\n    d -= 0.05*pow(0.5+0.5*sin(atan(q.x,q.z)*16.0),2.0);\n    d -= 0.15*pow(0.5+0.5*sin(q.y*3.0+0.6),0.12) - 0.15;\n    ma = floor(50.0*hash1( id + 11.2*floor(0.25 + (q.y*3.0+0.6)/6.2831) ));\n    d *= 0.85;\n    vec3 w = vec3(q.x,abs(q.y-0.3)-5.5, q.z );\n    d = min( d,  sdBox(w,vec3(1.4,0.2,1.4)+sign(q.y-0.3)*vec3(0.1,0.05,0.1))-0.1 ); // base\n    d = max( d, -sdBox(p,vec3(14.0,10.0,6.0)) ); // clip in\n\n    // floor\n    p.y -= 0.1;\n    float bb1 = op.y+7.0;\n    if( bb1<d ) //  bounding plane\n    {\n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(4.0,3.0), vec2(4.0,3.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n\n            float ra = 1.0*0.05 * hash1(id+vec2(1.0,3.0));\n            float b = sdBox( q-vec3(0.0,-6.0-ra,0.0), vec3(2.0,0.5,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1(id)); }\n        }\n    }\n\n    float bb2 = op.y+8.0;\n    if( bb2<d ) //  bounding plane\n    {\n        p.xz -= 2.0;\n        \n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(5.0,4.0), vec2(4.0,3.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n            \n            float ra = 0.15 * hash1(id+vec2(1.0,3.0)+23.1);\n            float b = sdBox( q-vec3(0.0,-7.0-ra,0.0), vec3(2.0,0.6,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1( id + 13.5 )); }\n        }\n        p.xz += 2.0;\n    }    \n     \n    float bb3 = op.y+9.0;\n    if( bb3<d ) //  bounding plane\n    {\n        vec2 id0 = round(p.xz/4.0);\n        vec2 off = step(vec2(0.0), p.xz/4.0-id0);\n        for( int j=0; j<2; j++ )\n        for( int i=0; i<2; i++ )\n        {\n            vec2 id = id0 + vec2(i,j) - off;\n            id = clamp( id, -vec2(5.0,4.0), vec2(5.0,4.0) );\n            vec2 ce = id*4.0;\n            q = p-vec3(ce.x,0.0,ce.y);\n\n            float ra = 0.15 * hash1(id+vec2(1.0,3.0)+37.7);\n            float b = sdBox( q-vec3(0.0,-8.0-ra-1.0,0.0), vec3(2.0,0.6+1.0,2.0)-0.1-ra )-0.1;\n            if( b<d ) { d = b; ma = floor(20.0*hash1( id*7.0 + 31.1 )); }\n        }\n    }\n\n    // roof\n    float bb4 = -(op.y-4.0);\n    if( bb4<d ) //  bounding plane\n    {\n        {\n        float id1;\n        q = vec3(p.x,p.y,abs(p.z))-vec3(0.0,0.0,9.0);\n        q.x = opRepLim( q.x, 4.0, 4.0, 4.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,0.95)-0.1 )-0.1;\n        if( b<d ) { d = b; ma = floor(20.0*(id1+6.0)); }\n        }\n        {\n        float id1;\n        q = vec3(abs(p.x)+1.0,p.y,p.z-2.0)-vec3(17.0,0.0,0.0);\n        q.z = opRepLim( q.z, 4.0, 2.0, 1.0, id1 );\n        float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.1 )-0.1;\n        if( b<d ) { d = b; ma = floor(30.0*(id1+6.0)); }\n        }\n\n        q = p; q.xz = opRepLim( q.xz+0.5, 1.0, vec2(18,10),vec2(19,11), id );\n        float b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.2,0.47)-0.05 )-0.05;\n        if( b<d ) { d = b; ma = floor(20.0*hash1( id + 7.8 )); }\n\n        b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,10.8), 0.0 ) ;\n        b = opExtrussion( b, p.x, 19.0-0.1 )-0.1;\n        q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n        b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.05 );\n        b = max( b, -p.y+8.2 );\n        \n        float bma = 13.0;\n        float c = sdRhombus( p.yz-vec2(8.2,0.0), vec2(2.25,8.7), 0.05 );\n        c = opExtrussion( c, abs(p.x)-19.0, 2.0 );\n        if( -c>b ) { b=-c; bma = 12.0; }\n        \n        b = max( b,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,2.0,9.0)) );\n        if( b<d ) { d=b; ma=bma; }\n    }\n\n    return d;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1438, 1438, 1506, 1523, 2441], [2445, 2445, 2497, 2497, 3526], [3530, 3530, 3587, 3587, 3982]], "test": "untested"}
{"id": "dlXfRj", "name": "Hydrogen Atom Wave Function", "author": "David654", "description": "This is a 3D representation of a hydrogen atom wave function. Feel free to play with quantum numbers (n, l, m) to change the wave function and get interesting shapes.", "tags": ["3d", "raymarching", "physics", "quantum", "atom", "wavefunction", "hydrogen"], "likes": 3, "viewed": 176, "published": 3, "date": "1693166036", "time_retrieved": "2024-07-30T17:36:32.628968", "image_code": "/*\nAuthor: David Lapidus\n*/\n\n#define N 8                      // [1; ∞];\n#define L 4                      // [0; N - 1];\n#define M -1                     // [-L; L]\n#define AXIS_SECTION_TYPE 2      // 0 -> None; 1 -> X-Axis; 2 -> Y-Axis; 3 -> Z-Axis\n#define COLOR_SCHEME 2\n#define FOV 60.0\n#define MAX_DIST 128.0\n#define MAX_STEPS 256\n#define ANTIALIASING 0           // Does not work properly with axis section at the moment\n#define ZOOM 1.0\n#define MANUAL_CAMERA 0\n\nconst float PI = 3.1415926;\nconst float E = 2.7182818;\nconst float BOHR_RADIUS = 0.005291772; // Increasing/decreasing this parameter may change the level of detail\nconst float REDUCED_PLANCK_CONSTANT = 1.054571817e-34;\n\nconst float EPSILON = 0.001;\n\nvec3 rotateX(in vec3 v, in float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(1, 0, 0, 0, cos, -sin, 0, sin, cos);\n}\n\nvec3 rotateY(in vec3 v, in float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, 0, sin, 0, 1, 0, -sin, 0, cos);\n}\n\nvec3 rotateZ(in vec3 v, in float theta)\n{\n    float sin = sin(theta);\n    float cos = cos(theta);\n    return v *= mat3(cos, -sin, 0, sin, cos, 0, 0, 0, 1);\n}\n\nvec3 mouseControl(in vec3 p)\n{\n    vec2 m = iMouse.xy / iResolution.xy - 0.5;\n    p = rotateX(p, -m.y * PI * 0.5 - 1.5);\n    p = rotateZ(p, -m.x * 2.0 * PI + PI);\n\n    return p;\n}\n\nvec3 CMRmap(in float t) // https://www.shadertoy.com/view/Nd3fR2\n{\n    const vec3 c0 = vec3(-0.046981,0.001239,0.005501);\n    const vec3 c1 = vec3(4.080583,1.192717,3.049337);\n    const vec3 c2 = vec3(-38.877409,1.524425,20.200215);\n    const vec3 c3 = vec3(189.038452,-32.746447,-140.774611);\n    const vec3 c4 = vec3(-382.197327,95.587531,270.024592);\n    const vec3 c5 = vec3(339.891791,-100.379096,-212.471161);\n    const vec3 c6 = vec3(-110.928480,35.828481,60.985694);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nstruct ComplexNumber\n{\n    float Re;\n    float Im;\n};\n\nfloat absoluteValueOfComplexNumber(ComplexNumber c)\n{\n    return sqrt(pow(c.Re, 2.0) + pow(c.Im, 2.0));\n}\n\nComplexNumber multiplyByScalar(ComplexNumber c, float a)\n{\n    return ComplexNumber(c.Re * a, c.Im * a);\n}\n\nComplexNumber multiplyByComplexNumber(ComplexNumber c, ComplexNumber a)\n{\n    return ComplexNumber(c.Re * a.Re - c.Im * a.Im, c.Re * a.Im + c.Im * a.Re);\n}\n\nfloat factorial(int a)\n{\n    float result = 1.0;\n\n    for(int i = 1; i <= a; i++)\n    {\n        result *= float(i);\n    }\n\n    return result;\n}\n\nfloat calculateAssociatedLegendrePolynomial(int l, int m, float x)\n{\n    float cos = cos(x);\n    float powM = m % 2 == 0 ? 1.0 : -1.0;\n    float p1 = powM / (exp2(float(l)) * factorial(l)) * pow(1.0 - cos * cos, float(m) / 2.0);\n    \n    int order = l + m;\n    float derivative = 0.0;\n\n    for(int i = 0; i <= l; i++)\n    {\n        float powI = i % 2 == 0 ? 1.0 : -1.0;\n        float a = factorial(l) / (factorial(i) * factorial(l - i)) * powI;\n        float power = 2.0 * float(l - i);\n\n        for(int j = 0; j < order; j++)\n        {\n            a *= power;\n            power--;\n        }\n\n        float cosSign = sign(cos) * (int(power) % 2 == 0 ? 1.0 : -1.0);\n        derivative += a * pow(abs(cos), power) * cosSign;\n    }\n    \n    return p1 * derivative;\n    \n    // Precalculated Associated Legendre Polynomials\n    /*float sin = sin(x);\n    float cos = cos(x);\n\n    float p = 0.0;\n\n    // https://en.wikipedia.org/wiki/Associated_Legendre_polynomials\n    if(l == 0 && m == 0)\n    {\n        p = 1.0;\n    }\n    else if(l == 1 && m == 0)\n    {\n        p = cos;\n    }\n    else if(l == 1 && abs(m) == 1)\n    {\n        p = -sin * (m > 0 ? 1.0 : -0.5);\n    }\n    else if(l == 2 && abs(m) == 0)\n    {\n        p = 0.5 * (3.0 * cos * cos - 1.0);\n    }\n    else if(l == 2 && abs(m) == 1)\n    {\n        p = -3.0 * sin * cos * (m > 0 ? 1.0 : -1.0 / 6.0);\n    }\n    else if(l == 2 && abs(m) == 2)\n    {\n        p = 3.0 * sin * sin * (m > 0 ? 1.0 : 1.0 / 24.0);\n    }\n    else if(l == 3 && abs(m) == 0)\n    {\n        p = 0.5 * cos * (5.0 * cos * cos - 3.0);\n    }\n    else if(l == 3 && abs(m) == 1)\n    {\n        p = -1.5 * (5.0 * cos * cos - 1.0) * sin * (m > 0 ? 1.0 : -1.0 / 12.0);\n    }\n    else if(l == 3 && abs(m) == 2)\n    {\n        p = 15.0 * cos * sin * sin * (m > 0 ? 1.0 : 1.0 / 120.0);\n    }\n    else if(l == 3 && abs(m) == 3)\n    {\n        p = -15.0 * sin * sin * sin * (m > 0 ? 1.0 : -1.0 / 720.0);\n    }\n    else if(l == 4 && abs(m) == 0)\n    {\n        p = 1.0 / 8.0 * (35.0 * pow(cos, 4.0) - 30.0 * pow(cos, 2.0) + 3.0);\n    }\n    else if(l == 4 && abs(m) == 1)\n    {\n        p = -2.5 * (7.0 * pow(cos, 3.0) - 3.0 * cos) * sqrt(1.0 - pow(cos, 2.0)) * (m > 0 ? 1.0 : -1.0 / 20.0);\n    }\n    else if(l == 4 && abs(m) == 2)\n    {\n        p = 7.5 * (7.0 * pow(cos, 2.0) - 1.0) * (1.0 - pow(cos, 2.0)) * (m > 0 ? 1.0 : 1.0 / 360.0);\n    }\n    else if(l == 4 && abs(m) == 3)\n    {\n        p = -105.0 * cos * pow(1.0 - pow(cos, 2.0), 1.5) * (m > 0 ? 1.0 : -1.0 / 5040.0);\n    }\n    else if(l == 4 && abs(m) == 4)\n    {\n        p = 105.0 * pow(1.0 - pow(cos, 2.0), 2.0) * (m > 0 ? 1.0 : 1.0 / 40320.0);\n    }\n\n    return p;**/\n}\n\nComplexNumber calculateSphericalHarmonics(int l, int m, float theta, float phi)\n{\n    float a = sqrt((2.0 * float(l) + 1.0) * factorial(l - m) / (4.0 * PI * factorial(l + m)));\n    float P = calculateAssociatedLegendrePolynomial(l, m, theta);\n    ComplexNumber phaseFactor = ComplexNumber(cos(float(m) * phi), sin(float(m) * phi));\n    phaseFactor = multiplyByScalar(phaseFactor, a * P);\n    return phaseFactor;\n}\n\nfloat calculateAssociatedLaguerrePolynomial(int r, int s, float x)\n{\n    float sum = 0.0;\n\n    for(int q = 0; q <= s; q++)\n    {\n        float f = q % 2 == 0 ? 1.0 : -1.0;\n        sum += f * pow(factorial(s + r), 2.0) * pow(x, float(q)) / (factorial(s - q) * factorial(r + q) * factorial(q));\n    }\n\n    return sum;\n}\n\nfloat calculateRadialFunction(int n, int l, float r)\n{\n    float a = sqrt(pow(2.0 / float(n) / BOHR_RADIUS, 3.0) * factorial(n - l - 1) / (2.0 * float(n) * pow(factorial(n + l), 3.0)));\n    float b = pow(2.0 * r / float(n) / BOHR_RADIUS, float(l)) * exp(-r / float(n) / BOHR_RADIUS);\n    float c = calculateAssociatedLaguerrePolynomial(2 * l + 1, n - l - 1, 2.0 * r / float(n) / BOHR_RADIUS);\n\n    return a * b * c;\n}\n\nComplexNumber calculateWaveFunction(int n, int l, int m, float r, float theta, float phi)\n{\n    float radialFunction = calculateRadialFunction(n, l, r);\n    ComplexNumber sphericalHarmonics = calculateSphericalHarmonics(l, m, theta, phi);\n\n    float E = -13.606 / pow(float(n), 2.0);\n    float phaseFactor = E * iTime / REDUCED_PLANCK_CONSTANT;\n    ComplexNumber phase = ComplexNumber(cos(phaseFactor), -sin(phaseFactor));\n\n    //return multiplyByComplexNumber(multiplyByScalar(sphericalHarmonics, radialFunction), phase);\n    return multiplyByScalar(sphericalHarmonics, radialFunction);\n}\n\nvec3 createAtom(vec3 p)\n{\n    if(MANUAL_CAMERA == 0)\n    {\n        p = rotateX(p, PI / 2.0);\n        p = rotateZ(p, -iTime);\n    }\n    else if(MANUAL_CAMERA == 1)\n    {\n        p = mouseControl(p);\n    }\n\n    float r = length(p);\n    float theta = acos(p.z / r);\n    float phi = atan(p.y, p.x);\n\n    ComplexNumber waveFunction = calculateWaveFunction(N, L, M, r, theta, phi);\n    ComplexNumber sphericalHarmonics = calculateSphericalHarmonics(L, M, theta, phi);\n    float wF = absoluteValueOfComplexNumber(waveFunction);\n    float atomDist = length(p) - wF;\n    //atomDist = min(atomDist, 0.0);\n\n    // Cross-section Slice\n    if(AXIS_SECTION_TYPE == 1) atomDist = max(min(atomDist, MAX_DIST), p.x);\n    else if(AXIS_SECTION_TYPE == 2) atomDist = max(min(atomDist, MAX_DIST), p.y);\n    else if(AXIS_SECTION_TYPE == 3) atomDist = max(min(atomDist, MAX_DIST), p.z);\n\n    vec3 atom = vec3(atomDist, wF, sphericalHarmonics.Im); //absoluteValueOfComplexNumber(sphericalHarmonics)\n\n    return atom;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(createAtom(p).x) - vec3(createAtom(p - e.xyy).x, createAtom(p - e.yxy).x, createAtom(p - e.yyx).x);\n    return normalize(n);\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos)\n{\n    float res = 1.0;\n    float dist = EPSILON;\n    float lightSize = 0.03;\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 hit = createAtom(p + lightPos * dist);\n\n        res = min(res, hit.x / (dist * lightSize));\n        dist += hit.x;\n\n        if(hit.x < EPSILON || dist > 60.0)\n        {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat getAmbientOcclusion(vec3 p, vec3 normal)\n{\n    float occ = 0.0;\n    float weight = 1.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        float len = 0.01 + 0.02 * float(i * i);\n        float dist = createAtom(p + normal * len).x;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\nvec3 HSLToRGB(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 blackbody(float i) \n{\n    float T = 1400. + 1400.*i; // Temperature range (in Kelvin).\n    vec3 l = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    l = pow(l,vec3(5.0)) * (exp(1.43876719683e5/(T*l))-1.0);\n    return 1.0-exp(-5e8/l); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\nvec3 getLight(vec3 p, vec3 rd, float waveFunction, float sphericalHarmonics, vec3 lightPos)\n{\n    vec3 finalCol = vec3(0, 0, 0);\n    vec3 v = -rd;\n    vec3 n = getNormal(p);\n\n    float r = length(p);\n    float theta = acos(p.z / r);\n    float phi = atan(p.y, p.x);\n\n    vec3 col = vec3(0);\n\n    // Color Schemes\n    if(COLOR_SCHEME == 0)\n    {\n        // Single color\n        col = vec3(1, 0, 0);\n    }\n    else if(COLOR_SCHEME == 1)\n    {\n        // Wave Function 1\n        col = vec3(clamp(waveFunction, 0.0, 1.0), 0, 0);\n    }\n    else if(COLOR_SCHEME == 2)\n    {\n        // // Wave Function 2\n        col = CMRmap(clamp(waveFunction * 0.9, 0.0, 1.0));\n    }\n    else if(COLOR_SCHEME == 3)\n    {\n        // Spherical Harmonics\n        col = normalize(HSLToRGB(vec3(sphericalHarmonics, 1, theta)));\n    }\n    else if(COLOR_SCHEME == 4)\n    {\n        col = blackbody(waveFunction);\n    }\n\n    vec3 l = normalize(lightPos - p);\n    vec3 R = reflect(-l, n);\n    vec3 H = normalize(l + v);\n\n    vec3 ambient = col * 0.1;\n    vec3 diffuse = col * clamp(dot(l, n), 0.0, 1.0);\n    vec3 specColor = vec3(0.1);\n    vec3 specular = specColor * pow(clamp(dot(R, v), 0.0, 1.0), 128.0);\n\n    // Soft Shadows\n    //float shadow = getSoftShadow(p + n * 0.02, lightPos);\n\n    // Ambient occlusion\n    float occ = getAmbientOcclusion(p, n);\n\n    // Reflections\n    vec3 back = 0.05 * col * clamp(dot(n, -l), 0.0, 1.0);\n\n    finalCol = (ambient + back) * occ + (diffuse + specular * occ);\n\n    return finalCol;\n}\n\nvec4[2] rayMarch(vec3 ro, vec3 rd, vec3 lightPos)\n{\n    vec3 hit;\n    vec3 object;\n    vec3 oh = vec3(0);\n    vec4 tmp = vec4(0);\n    float waveFunction;\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        // Raymarching\n        vec3 p = ro + object.x * rd;\n        hit = createAtom(p);\n\n        float px = 2.0 / iResolution.y;\n        float th1 = px * object.x;\n        th1 *= 1.5;\n\n        object.x += hit.x * 0.085;\n        object.y = hit.y;\n        object.z = hit.z;\n        int index = int(object.y) - 1;\n\n        if(hit.x < 0.0 || object.x > float(MAX_DIST))\n        {\n            break;\n        }\n\n        // Antialiasing\n        if(ANTIALIASING == 1)\n        {\n            if(abs(hit.x) < th1)\n            {\n                break;\n            }\n\n            float th2 = px * object.x * 20.0;\n            \n            if((abs(hit.x) < th2 && hit.x > oh.x))\n            {\n                float lalp = 1.0 - (hit.x - th1) / (th2 - th1);\n                vec3 lcol = getLight(p, rd, object.y, object.z, lightPos);\n                tmp.xyz += (1.0 - tmp.w) * lalp * lcol;\n                tmp.w += (1.0 - tmp.w) * lalp;\n                \n                if(tmp.w > 0.99)\n                {\n                    break;\n                }\n            }\n            \n            oh = hit;\n        }\n    }\n\n    vec4[2] res = vec4[](vec4(object, 0), tmp);\n    return res;\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 position = vec3(0.0, 0.0, -3.0 + ZOOM);\n\n    vec3 ro = position;\n\n    float invTanFOV = 1.0 / (tan(FOV / 2.0 * PI / 180.0));\n    vec3 rd = normalize(vec3(uv, invTanFOV));\n\n    vec3 lightPos = vec3(0, 100, -100);\n\n    vec4 object[2] = rayMarch(ro, rd, lightPos);\n    vec3 col;\n\n    if(object[0].x < float(MAX_DIST))\n    {\n        vec3 p = ro + object[0].x * rd;\n\n        col = getLight(p, rd, object[0].y, object[0].z, lightPos);\n    }\n    else\n    {\n        col = vec3(0); // Background color\n    }\n\n    if(ANTIALIASING == 1)\n    {\n        vec4 tmp = object[1];\n        col = mix(col, tmp.xyz / (0.001 + tmp.w), tmp.w);\n    }\n\n    return col;\n}\n\nvec2 getUV(in vec2 offset, in vec2 fragCoord)\n{\n    return (2.0 * fragCoord.xy + offset - iResolution.xy) / iResolution.y;\n}\n\n// MSAAx1 (default)\nvec3 renderAAx1(in vec2 fragCoord)\n{\n    return render(getUV(vec2(0), fragCoord));\n}\n\n// MSAAx2 (slow)\nvec3 renderAAx2(in vec2 fragCoord)\n{\n    float bxy = float(int(fragCoord.x + fragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.33 * nbxy, 0.), fragCoord)) + render(getUV(vec2(0.33 * bxy, 0.66), fragCoord)));\n    return colAA / 2.0;\n}\n\n// MSAAx3 (slower)\nvec3 renderAAx3(in vec2 fragCoord)\n{\n    float bxy = float(int(fragCoord.x + fragCoord.y) & 1);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.66 * nbxy, 0.), fragCoord)) + render(getUV(vec2(0.66 * bxy, 0.66), fragCoord)) + render(getUV(vec2(0.33, 0.33), fragCoord)));\n    return colAA / 3.0;\n}\n\n// MSAAx4 (the slowest)\nvec3 renderAAx4(in vec2 fragCoord)\n{\n    vec4 e = vec4(0.125, -0.125, 0.375, -0.375);\n    vec3 colAA = render(getUV(e.xz, fragCoord)) + render(getUV(e.yw, fragCoord)) + render(getUV(e.wx, fragCoord)) + render(getUV(e.zy, fragCoord));\n    return colAA /= 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = renderAAx1(fragCoord);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[721, 721, 762, 762, 878], [880, 880, 921, 921, 1037], [1039, 1039, 1080, 1080, 1196], [1198, 1198, 1228, 1228, 1377], [1379, 1379, 1445, 1445, 1910], [1967, 1967, 2020, 2020, 2072], [2074, 2074, 2132, 2132, 2180], [2182, 2182, 2255, 2255, 2337], [2339, 2339, 2363, 2363, 2482], [5116, 5116, 5197, 5197, 5529], [5531, 5531, 5599, 5599, 5848], [5850, 5850, 5904, 5904, 6267], [6269, 6269, 6360, 6360, 6858], [6860, 6860, 6885, 6885, 7854], [7856, 7856, 7880, 7880, 8058], [8060, 8060, 8104, 8104, 8477], [8479, 8479, 8527, 8527, 8827], [8829, 8829, 8855, 8855, 8995], [8997, 8997, 9023, 9023, 9346], [9348, 9348, 9441, 9441, 10844], [12214, 12214, 12239, 12239, 12893], [12895, 12895, 12942, 12942, 13019], [13021, 13041, 13077, 13077, 13125], [13127, 13144, 13180, 13180, 13411], [13413, 13432, 13468, 13468, 13744], [13746, 13770, 13806, 13806, 14030], [14032, 14032, 14087, 14087, 14159]], "test": "untested"}
{"id": "DlfBRj", "name": "3D random generator", "author": "FabriceNeyret2", "description": "mouse controls camera\ninspiration: https://twitter.com/junkiyoshi/status/1695401421112492445", "tags": ["short", "reproduction"], "likes": 41, "viewed": 507, "published": 3, "date": "1693154495", "time_retrieved": "2024-07-30T17:36:33.505624", "image_code": "#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                  // rotation\n#define H(P)      fract(sin(ceil(P.x)*71.3))                    // random 1D\n//#define H(P)    fract(sin(ceil(P)*mat2(R,71)))                // random 2D\n\n#define T texture(iChannel0,             /* random digit SDF */  \\\n          (  vec2( c = int(10.*H(P)+ceil(P.y))%10, 12-c/16 )     \\\n            +( vec2(.25,.15) + vec2(.5,.7) * fract(P.xy) )       \\\n          ) /16. ) \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,r,a; int c;\n    vec3  R = iResolution,\n          D = normalize( vec3(U+U, -2.*R.y) - R ),              // ray direction\n          p = vec3(0,0,10), q,P,                                // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.               // camera control\n                          : 3.* cos(.3*iTime + vec3(0,11,0));   // demo mode\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )              // march scene\n        q = p, \n        q.yz *= rot(-C.y),                                      // rotations\n        q.xz *= rot(-C.x),\n        r = length(q.yz) - 4.,a = atan(q.x,r),\n        t =  abs( length(vec2(q.x,r)) - 1. ),                   // torus surface\n        P.xy = vec2( 4.*atan(q.z,q.y) , a ) /.628,              // surface parameterization\n        P.y = mod( P.y + 5.* sin( (.3+3.*H(P)) * iTime ), 10.), // columns rotation\n        t = max(   t,      T.w - .5 ),                          // draw torus-digits intersection\n     // t = max( a=t-.01,  T.w - .5 ),\n        p += .5*t*D;                                            // step forward = dist to obj  \n    \n    O *= O*O*O*1.5;                                             // color scheme\n // O *= texture(iChannel0,P.xy/10.).x;\n // O *= T.x;\n // if (t==a) O*=vec4(.3,0,0,0);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 489, 489, 1786]], "test": "untested"}
{"id": "clXBRj", "name": "Fork PS2 menu s hyphellux 505", "author": "hyphellux", "description": "Based on https://www.shadertoy.com/view/ldc3z4\n\nimproved trails by drawing straight line-segments instead of points\nforked to look more like https://www.youtube.com/watch?v=G6jni8AtHkQ&t=151s", "tags": ["ps2", "playstation"], "likes": 8, "viewed": 269, "published": 3, "date": "1693151959", "time_retrieved": "2024-07-30T17:36:34.431150", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = uv-.5; suv.x /= iResolution.y/iResolution.x;\n\tfragColor = texture(iChannel0,uv)+(texture(iChannel1,uv))+vec4((1.-((length(suv)-0.2)+0.2)*2.)*vec3(0.1,0.12,0.3),0.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nmat3 r(float a)\n{\n    float ax = xSpeed*a;\n    float ay = ySpeed*a;\n    float az = zSpeed*a;\n\n\tfloat cy = cos(ay);\n    float sy = sin(ay);\n\t//p.x = cy * q.x + sy * q.z;\n\t//p.z = -sy * q.x + cy * q.z;\n\n\tfloat cz = cos(az);\n    float sz = sin(az);\n\t//r.x = cz * p.x - sz * p.y;\n\t//r.y = sz * p.x + cz * p.y; =>\n\t//r.x = cz * (cy * q.x + sy * q.z) - sz * q.y;\n\t//r.y = sz * (cy * q.x + sy * q.z) + cz * q.y;\n    //r.z = -sy * q.x + cy * q.z;\n    \n    \n\tfloat cx = cos(ax);\n    float sx = sin(ax);\n\t//s.y = cx * r.y - sx * r.z;\n\t//s.z = sx * r.y + cx * r.z;=>\n\t//s.x = cz * (cy * q.x + sy * q.z) - sz * q.y;\n\t//s.y = cx * (sz * (cy * q.x + sy * q.z) + cz * q.y) - sx * (-sy * q.x + cy * q.z);\n\t//s.z = sx * (sz * (cy * q.x + sy * q.z) + cz * q.y) + cx * (-sy * q.x + cy * q.z);\n    \n\t//s.x = (cz*cy)*q.x          - sz*q.y    + (cz * sy) * q.z;\n\t//s.y = (cx*sz*cy+sx*sy)*q.x + cx*cz*q.y + (cx*sz*sy-sx*cy)*q.z;\n\t//s.z = (sx*sz*cy-cx*sy)*q.x + sx*cz*q.y + (sx*sz*sy-cx*cy)*q.z;\n    float sxsz = sx*sz;\n    float cxsz = cx*sz;\n    mat3 qtos = mat3(\n        cz*cy, (cxsz*cy+sx*sy), (sxsz*cy-cx*sy),\n        -sz,   cx*cz,            sx*cz,\n        cz*sy, (cxsz*sy-sx*cy), (sxsz*sy-cx*cy)\n    );\n    return qtos;\n\n}\n\nvec3 dirDist(float dir, float dist) {\n    return vec3(cos(dir)*dist,sin(dir)*dist,0.0);\n}\n// \"Converted\" from \"C++\" from here: https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\nfloat segment_distance_square(vec2 v, vec2 w, vec2 p) {\n  // Return minimum distance between line segment vw and point p\n    vec2 dvec = v-w;\n  float l2 = dot(dvec,dvec);  // i.e. |w-v|^2 -  avoid a sqrt\n  //if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  // We clamp t from [0,1] to handle points outside the segment vw.\n  float t = clamps(dot(p - v, w - v) / l2);\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  dvec = p- projection;\n  return dot(dvec,dvec);\n}\n\nfloat animation(vec2 uv, float time, float timeDelta) {\n    float circles_square = 1000.;\n    float prevtime = time - max(0., timeDelta-0.005 ); // 0.005 to reduce double drawing\n    mat3 rPrev = r(prevtime);\n    mat3 rCurr = r(time);\n    float DISTANCE = 0.2;\n    for (float k = 0.; k < DOTS; k++) {\n        float pointspeed = k*0.1;\n        float DIRECTION = time*pointspeed;\n        float PREVDIRECTION = prevtime*pointspeed;\n        vec3 POSITION = rCurr*dirDist(DIRECTION,DISTANCE);\n        vec3 PREVPOSITION = rPrev*dirDist(PREVDIRECTION,DISTANCE);\n        float segDist = segment_distance_square(PREVPOSITION.xy, POSITION.xy ,uv);\n        circles_square = min(circles_square, segDist );\n    }\n    float circles = clamps(1.0-sqrt(circles_square)*20.0);\n    return circles;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 suv = uv-.5; suv.x /= iResolution.y/iResolution.x;\n    float time = iTime;\n    float timeDelta = iTimeDelta;\n    vec3 drawing = vec3(0.0);\n    if(0.25<uv.x && 0.75>uv.x && 0.20<uv.y && 0.80>uv.y)\n    {\n        drawing = \n            vec3(animation(suv, time, timeDelta));\n    }\n    \n    drawing = vec3(pow(drawing,vec3(2.5,1.8,1.)));\n\tfragColor = vec4(drawing,1.);\n}", "buffer_a_inputs": [], "buffer_b_code": "\nvec2 circle(float a){return vec2(cos(a),sin(a));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 d = vec4(0);\n    vec2 p = circle((1.)*pi*1.);\n    p.x /= iResolution.x/iResolution.y;\n    d = max(d,texture(iChannel1,uv+(p*0.00001)));\n\n\tfragColor = pow(texture(iChannel0,uv),vec4(9.))+(clamps(d)*pow(0.00001,iTimeDelta));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define clamps(x) clamp(x,0.,1.)\n#define DOTS 7.\n\nfloat pi = 3.14159265358979323;\n\n\nconst float xSpeed = 0.52;\nconst float ySpeed = 1.1;\nconst float zSpeed = 2.15;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 282]], "test": "untested"}
{"id": "dllBzB", "name": "SmoothMinimum (LP / L∞ norm)", "author": "iY0Yi", "description": "a smooth minimum function but with LP / L∞ norm.", "tags": ["maptoy"], "likes": 12, "viewed": 232, "published": 3, "date": "1693147667", "time_retrieved": "2024-07-30T17:36:35.479348", "image_code": "// based on the cubic smin shown here,\n// https://iquilezles.org/articles/smin/\n// and inspired by @ephtracy's tweet.\n// https://twitter.com/ephtracy/status/1676832562168098818\n\nfloat bUniLP(float a, float b, float k, float p) {\n    float h = max(k - pow(abs(a-b), p-1.), 0.)/k;\n    return min(a,b) - h*h*h*k*(1./6.);\n}\n\nfloat bUniLInf(float a, float b, float k) {\n    float h = max(k - max(abs(a),abs(b)), 0.)/k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nfloat map(vec3 p){\n    float d1 = length(p+vec2(0,.5).yxx)-.5;\n    float d2 = length(p-vec2(0,.5).yxx)-.5;\n    RED(d1);\n    GREEN(d2);\n    float d = bUniLP(d1,d2, .5, floor((sin(iTime)*.5+.5)*6.));\n    if(iMouse.z>.5)d = bUniLP(d1,d2,(mouse.x+1.)*.5, (mouse.y+1.)*8.);\n    \n    // L∞ version\n    //d = bUniLInf(d1,d2, (mouse.x+1.)*.5+.001);\n    \n    YELLOW(d);\n    return d;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uniform vec3 iWheel;\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\nfloat opUniS(float a,float b,float r){\n\tfloat h = max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r){\n  p.y=abs(p.y);\n  p.y-=clamp(p.y,0.,h);\n  return length(p)-r;\n}\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 30.\n#define STEP_MAX 100\n\n// Markers: 8 colors\n#define cRED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n#define cGREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n#define cPURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n#define cYELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n#define cORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n#define cCOBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n#define cBLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n#define cBLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n\nfloat tRED = 1.;\nfloat tGREEN = 1.;\nfloat tPURPLE = 1.;\nfloat tYELLOW = 1.;\nfloat tORANGE = 1.;\nfloat tCOBALT = 1.;\nfloat tBLUE = 1.;\nfloat tBLACK = 1.;\n#define RED(v) tRED = step(DIST_MIN*10., v)\n#define GREEN(v) tGREEN = step(DIST_MIN*10., v)\n#define PURPLE(v) tPURPLE = step(DIST_MIN*10., v)\n#define YELLOW(v) tYELLOW = step(DIST_MIN*10., v)\n#define ORANGE(v) tORANGE = step(DIST_MIN*10., v)\n#define COBALT(v) tCOBALT = step(DIST_MIN*10., v)\n#define BLUE(v) tBLUE = step(DIST_MIN*10., v)\n#define BLACK(v) tBLACK = step(DIST_MIN*10., v)\n\n#define INIT_CAM_POS vec3(2,-1,2)*2.\n#define CAM_DIST 2.\n#define CAM_INIT_SCALE 1.25\n#define TURN_TABLE_SPEED .25\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(1,.95,.9)*.8)\n#define THM_GRID (vec3(.1,.2,.25)*1.7)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(1)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc char(U,64+CAPS+c);\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\n#define render() \\\nbool isTurntable = false;\\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nfloat char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;}\\\n    return 0.;\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=min(0,iFrame); i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=min(0,iFrame); i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED+PI*.25), 1, cos(iTime*TURN_TABLE_SPEED+PI*.25))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST+iWheel.y*.0005;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz)*1.5;\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz);\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(4.2)), g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col*= (tRED<.5)?cRED:vec3(1);\\\n    col*= (tGREEN<.5)?cGREEN:vec3(1);\\\n    col*= (tPURPLE<.5)?cPURPLE:vec3(1);\\\n    col*= (tYELLOW<.5)?cYELLOW:vec3(1);\\\n    col*= (tORANGE<.5)?cORANGE:vec3(1);\\\n    col*= (tCOBALT<.5)?cCOBALT:vec3(1);\\\n    col*= (tBLUE<.5)?cBLUE:vec3(1);\\\n    col*= (tBLACK<.5)?cBLACK:vec3(1);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(2.2)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x>.5;\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(1.-THM_GRID,vec3(2.2)),1);\\\n    drawDebug(fragColor);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n  \n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){\n        O = vec4(0);\n        if(ID(C_CAMERA)){O = vec4(1, true, 0, 0);return;}\n        return;\n    }\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 228, 228, 319], [321, 321, 364, 364, 455], [457, 457, 475, 475, 835]], "test": "untested"}
{"id": "dtlfRS", "name": "P-norms visualized", "author": "barth", "description": "What is a circle realy? It all depends on your definition of distance. P-norms are generalization of the euclidean distance and from them arise new types of circles", "tags": ["geometrypnorm"], "likes": 4, "viewed": 207, "published": 3, "date": "1693132480", "time_retrieved": "2024-07-30T17:36:36.265247", "image_code": "float pnorm(vec2 point, float p) {\n  return pow(pow(point.x, p) + pow(point.y, p), 1.0 / p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    float maxDimension = max(iResolution.x, iResolution.y);\n    float minDimension = min(iResolution.x, iResolution.y);\n    \n    vec2 uv = fragCoord / maxDimension;\n    \n    vec2 circleCenter = vec2(0.5, 0.5 * minDimension / maxDimension);\n    \n    vec2 uvToCenter = abs(uv - circleCenter);\n    \n    float circleRadius = 0.2;\n    float circleThickness = 0.01;\n    \n    float p = 0.5 + 5.0 * (cos(iTime) + 1.0) / 2.0;\n\n\n    vec3 col = vec3(0.0);\n\n    if(pnorm(uvToCenter, p) > circleRadius - circleThickness && pnorm(uvToCenter, p) < circleRadius + circleThickness) {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));   \n    }\n    \n    fragColor = vec4(col,1.0); \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 94], [96, 96, 153, 203, 879]], "test": "untested"}
{"id": "dtlBRS", "name": "A study of glass II", "author": "mrange", "description": "2018-10-07 I released on shadertoy 'a study of glass' which was the first shader of mine to make it as a 'Shader of the week'.\nFor my first 4KiB intro I thought it made sense to do 'a study of glass II'.\nThanks to Virgill for providing the music!!", "tags": ["raymarching", "4k", "glass"], "likes": 38, "viewed": 705, "published": 3, "date": "1693130549", "time_retrieved": "2024-07-30T17:36:37.285518", "image_code": "//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//      release name: A study of glass II       |\n//              type: Windows 4k intro          |\n//   release date: 26.08.2023                   |\n//   party/compo: Xenium 2023                   |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - 2018-10-07 I released on shadertoy  |\n// 'a study of glass' which was the first       |\n// shader of mine to make it as a               |\n// 'Shader of the week'.                        |\n//                                              |\n// Since then I have been very fortunate and    |\n// had other shaders make it as well but the    |\n// first one is always special to us.           |\n//                                              |\n// For my first 4KiB intro I thought it         |\n// made sense to do 'a study of glass II'.      |\n//                                              |\n// Thanks to Virgill for providing the very     |\n// nice and fitting music as well as assisting  |\n// me in squeezing it all into 4KiB.            |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\n// Uploaded here: https://www.pouet.net/prod.php?which=94949\n// Youtube: https://www.youtube.com/watch?v=wNh-X0Ny1UI\n\n// Greetings to (I probably forgotten a few. I add you next time!) =>\n// Big Wings     - Soaring with mind-bending shader magic!\n// Byt3 M3chanic - Engineering genius of breathtaking visuals!\n// Dave Hoskins  - Mad scientist, blowing minds one pixel at a time!\n// EvilRyu       - Unleashing wickedly awesome shaders that drop jaws!\n// Evvvil        - Conjuring atmospheric realms of awe and a hint of terror!\n// FabriceNeyrat2- Shader virtuoso, reigning with cryptic elegance in the realm of concise chaos!\n// Impulse       - Veterans of my crew, aging like fine wine, still rocking the tv sofa scene!\n// IQ            - Mind-boggling shaders that question reality itself!\n// Kali          - Enchantress weaving mesmerizing visual spells!\n// lug00ber      - Mixing the beats, creating musical magic in the demo scene!\n// msm01         - Shaping extraterrestrial realms with scenic shaders, a true interstellar artist!\n// Nimitz        - Navigating shader seas with finesse and artistic flair!\n// Shane         - Crafting symphonies of light and color that dance!\n// Totetmatt     - Master sculptor molding stunning digital art!\n// Virgill       - Overworked maestro of 4klang, turning symphonies into code!\n// XorDev        - Shader sorcerer and explainer of FXAA algorithm!\n\n\n// All my code is licensed under CC0\n//  Others code I have indicated where I found it\n//  and what license was available at the time of\n//  discovery\n\n// The FXAA post processing provided by XorDev\n//  Applies fullscreen antialiasing to the input in IChannel0\n//  The input to iChannel0 is connected to Buffer A (see tabs on top)\n\n#define RESOLUTION      iResolution\n\n// License: Unknown, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n      \n  fragColor = fxaa(iChannel0, q, sqrt(2.0)/RESOLUTION.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//      release name: A study of glass II       |\n//              type: Windows 4k intro          |\n//   release date: 26.08.2023                   |\n//   party/compo: Xenium 2023                   |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - 2018-10-07 I released on shadertoy  |\n// 'a study of glass' which was the first       |\n// shader of mine to make it as a               |\n// 'Shader of the week'.                        |\n//                                              |\n// Since then I have been very fortunate and    |\n// had other shaders make it as well but the    |\n// first one is always special to us.           |\n//                                              |\n// For my first 4KiB intro I thought it         |\n// made sense to do 'a study of glass II'.      |\n//                                              |\n// Thanks to Virgill for providing the very     |\n// nice and fitting music as well as assisting  |\n// me in squeezing it all into 4KiB.            |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\n// Uploaded here: https://www.pouet.net/prod.php?which=94949\n// Youtube: https://www.youtube.com/watch?v=wNh-X0Ny1UI\n\n// Greetings to (I probably forgotten a few. I add you next time!) =>\n// Big Wings     - Soaring with mind-bending shader magic!\n// Byt3 M3chanic - Engineering genius of breathtaking visuals!\n// Dave Hoskins  - Mad scientist, blowing minds one pixel at a time!\n// EvilRyu       - Unleashing wickedly awesome shaders that drop jaws!\n// Evvvil        - Conjuring atmospheric realms of awe and a hint of terror!\n// FabriceNeyrat2- Shader virtuoso, reigning with cryptic elegance in the realm of concise chaos!\n// Impulse       - Veterans of my crew, aging like fine wine, still rocking the tv sofa scene!\n// IQ            - Mind-boggling shaders that question reality itself!\n// Kali          - Enchantress weaving mesmerizing visual spells!\n// lug00ber      - Mixing the beats, creating musical magic in the demo scene!\n// msm01         - Shaping extraterrestrial realms with scenic shaders, a true interstellar artist!\n// Nimitz        - Navigating shader seas with finesse and artistic flair!\n// Shane         - Crafting symphonies of light and color that dance!\n// Totetmatt     - Master sculptor molding stunning digital art!\n// Virgill       - Overworked maestro of 4klang, turning symphonies into code!\n// XorDev        - Shader sorcerer and explainer of FXAA algorithm!\n\n// All my code is licensed under CC0\n//  Others code I have indicated where I found it\n//  and what license was available at the time of\n//  discovery\n\n#define RESOLUTION    iResolution\n#define TIME          iTime\n\n\nconst float PI              = acos(-1.)   ;\nconst float SPLIT           = 0.02        ;\nconst float INIT            = SPLIT-.001  ;\nconst float TOLERANCE       = 1.0E-4      ;\nconst float MAX_RAY_LENGTH  = 10.         ;\nconst float NORM_OFF        = 0.001       ;\nconst float MAX_RAY_MARCHES = 70.0        ;\nconst float Z               = log2(2.05)  ;\n// Virgill's song is 64 BPM meaning\n//  7.5 sec per switch lines up to 16 beats per switch\nconst float PERIOD          = 7.5         ;\n\nconst int   MAX_BOUNCES     = 5           ;\nconst int   SCRIPT_PARTS    = 17          ;\n\nconst vec4 Units = vec4(0,.5,1,2);\n\nconst vec3 lightPos  = vec3(0,9.,1)                   ;\nconst vec3 skyCol    = vec3(1,.53,.15)                ;\nconst vec3 beerCol0  = vec3(1.5,.56,.15)              ;\nconst vec3 beerCol1  = -vec3(2.,1.3,1)                ;\nconst vec3 sphereCol = vec3(.6,3.,1.85)               ;\nconst vec3 glassCol  = skyCol                         ;\nconst vec3 sphereMat = Units.xyz                      ;\nconst vec3 glassMat  = vec3(.75,.5,.87)               ;\nconst vec3 mirrorCol = glassCol                       ;\nconst vec3 mirrorMat = Units.xzz                      ;\nconst vec3 sunDir    = normalize(vec3(-.55, -.58, 1)) ;\nconst vec3 RO1       = vec3(0,-1,2.5)                 ;\nconst vec3 RO0       = 1.2*abs(RO1)                   ;\nconst vec3 luma      = vec3(.299, .587, .114)         ;\n\nstruct part {\n  float flash_control ;\n  float ray_origin    ;\n  int   variant       ;\n};\n\n// The demo script, controlling the flashing of light, the ray origin and what object to show\nconst part parts[SCRIPT_PARTS] = part[SCRIPT_PARTS](\n  //   flash    ray_origin variant\n  part(-1.0   , 0.0     , 0       ),// 0\n  part(-1.0   , 0.0     , 1       ),\n  part(-1.0   , 0.0     , 3       ),\n  part(-1.0   , 0.0     , 2       ),\n  part(+0.0   , 0.0     , 5       ),// 4\n  part(+0.0   , 0.0     , 3       ),\n  part(+0.0   , 0.0     , 2       ),\n  part(+0.0   , 2.0     , 1       ),\n  part(+1.0   , 0.0     , 6       ),// 8\n  part(+1.0   , 1.0     , 5       ),\n  part(+1.0   , 1.0     , 4       ),\n  part(+1.0   , 2.0     , 3       ),\n  part(+1.0   , 2.0     , 4       ),// 12\n  part(+1.0   , 2.0     , 6       ),\n  part(+1.0   , 2.0     , 7       ),\n  part(+1.0   , 0.0     , 2       ),\n  part(-1.0   , 0.0     , 0       ) // 16\n  );\n\n// Love us some global variables\nmat2 g_rot_x; \nmat2 g_rot_y;\nvec3 g_mat;\nvec3 g_diffCol;\nint g_variant;\n\nmat2 rot(float a) {\n  float c=cos(a);\n  float s=sin(a);\n  return mat2(c,s,-s,c);\n}\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) { \n  return fract(sin(co*12.9898) * 13758.5453); \n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a,float b,float k) {\n  float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);return mix(b, a, h)-k*h*(1.0-h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmax(float a,float b,float k) {\n  return -pmin(-a,-b,k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b){\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0))+min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p)-b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat sphere4(vec3 p, float r) {\n  p*=p;\n  return pow(dot(p, p),.25)-r;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  // The sky \"box\"\n  \n  // The glow in the horizon\n  vec3 col = vec3(.0025*skyCol)/abs(rd.y);\n  \n  float tp0 = rayPlane(ro, rd, vec4(Units.xzx,5.));\n  float tp1 = rayPlane(ro, rd, vec4(-Units.xzx,5.));\n\n  if (tp1 > 0.0) {\n    // Place a glowing box above the the scene\n    //  This makes the reflections \"pop\"\n    \n    float db = box((ro + tp1*rd).xz, vec2(6.0, 9.0))-1.0;\n    col += 3.0*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += 0.6*skyCol*exp(-0.5*max(db, 0.0));\n    col += -0.05*min(0.0, db);\n  }\n\n  if (tp0 > 0.0) {\n    // A glow from below helps illuminate bottom parts of box \n    col += 0.25*skyCol*exp(-0.5*(length((ro + tp0*rd).xz)));\n  }\n\n  // The sun is just an explosion\n  col += 6E-3*sqrt(skyCol).zyx/(1.01+dot(rd, sunDir));\n\n  return min(col,4.);\n}\n\n// The distance field function\nfloat df(vec3 p) {\n  vec3 pp = p;\n  // Some global rotation\n  p.yz *= g_rot_x;\n  p.xz *= g_rot_y;\n\n  // The inner sphere\n  float d0 = sphere(pp, 1.05);\n  float d1 = d0-.2;\n  \n  // Compute some ridges\n  vec3 p1 = pp*(PI*40.);\n  float h = .5+.5*sin(p1.y+p1.x-p1.z);\n  h*=h;h*=h;h*=h;\n  // Apply ridges to the sphere\n  d0 += 5E-4*h;\n  \n  // The outer box\n  float d2 = sphere4(p, 1.5);\n\n  // The glass \n  float dg;\n  // The modified outer box\n  float db;\n\n  float dtmp;\n  vec3 ptmp;\n\n  int variant = g_variant;\n  switch(variant) {\n  default:\n  case 0:\n    // Just the sphere\n    dg = MAX_RAY_LENGTH;\n    db = MAX_RAY_LENGTH;\n    break;\n  case 1:\n    // A transparent box\n    dg = d2;\n    db = MAX_RAY_LENGTH;\n    break;\n  case 2:\n    // A box with two glass stripes, my favorite in it's simplicity\n  \n    // The plane\n    dtmp = dot(normalize(vec3(1.0, 1.0, -1.0)), pp);\n  \n    // Onionize the plane to get two stripes\n    dtmp = abs(dtmp)-0.5;\n    dtmp = abs(dtmp)-0.25;\n  \n    // Glass is the box smooth intersected with the stripes\n    dg = pmax(d2, dtmp, 0.0125);\n  \n    // Box is the box smooth diffences with the stripes\n    // SPLIT need to not overstep when crossing materials\n    db = pmax(d2, -(dtmp-SPLIT), 0.0125);\n    break;\n  case 3:\n    // A box with circular windows\n  \n    // A cross\n    dtmp = min(min(length(p.xy), length(p.xz)), length(p.yz))-.75;\n  \n    // Glass is the box smooth intersected with the cross\n    dg = pmax(d2, dtmp, 0.05);\n  \n    // Box is the box smooth diffences with the cross\n    // SPLIT need to not overstep when crossing materials\n    db = pmax(d2, -(dtmp-SPLIT), 0.05);\n    break;\n  case 4:\n    // A box with \"bubbles\"\n  \n    //  A callback to the box with bubbles in the original 'a study of glass'\n    //  I don't think this is a good looking but it's more compact code which\n    //  is what is needed for 4KiB\n    \n    ptmp = pp;\n    // Apply some rotation to give the impression the bubbles are floating upwards\n    ptmp.yz *= g_rot_y;\n  \n    // Many bubbles please\n    ptmp -= round(ptmp);\n    \n    // The bubble\n    dtmp = sphere(ptmp, 0.43);\n    \n    // Glass is the box smooth intersected with the bubbles\n    dg = pmax(d2, dtmp, 0.05);\n  \n    // Box is the box smooth diffences with bubbles\n    // SPLIT need to not overstep when crossing materials\n    db = pmax(d2, -(dtmp-SPLIT), 0.05);\n    break;\n  case 5:\n    // A box with glass on top.\n    // Kind of like a filler box, looks ok but not the favorite\n    \n    dtmp = sphere4(pp-vec3(0.0, 1.5, 1.0), 1.25);\n  \n    // Glass is the box smooth intersected with the sphere4\n    // SPLIT need to not overstep when crossing materials\n    dg = pmax(d2, dtmp, 0.025)+SPLIT;\n  \n    // Box is the box smooth diffences with the sphere4\n    db = pmax(d2, -dtmp, 0.025);\n    break;\n  case 6:\n    // It's a magic box!\n  \n    ptmp = abs(p)-1.5;\n    float fp_6= exp2(length(ptmp)*Z);\n    float n_6 = floor(fp_6);\n    float x0_6 = log2(n_6)/Z;\n    float x1_6 = log2(n_6+1.0)/Z;\n    float m_6 = (x0_6+x1_6)*.5;\n    float w_6 = x1_6-x0_6;\n    dtmp = abs(length(ptmp)-m_6)-(w_6*0.5)+0.1;\n    dg = pmax(d2, dtmp, 0.0075)+SPLIT*0.5;\n    db = pmax(d2, -dtmp, 0.0075)+SPLIT*.5;\n  \n    break;\n  case 7:\n    // Glassy box distored by spheres\n    //  Wanted something I show just once that I hope give a little bit of wow effect\n    //  The music also has a nice buzz to it here\n    \n    // Shrink the spheres somewhat \n    const float z_7 = .75;\n    ptmp = pp/z_7;\n  \n    // Apply some rotation\n    ptmp.xy *= g_rot_y;\n  \n    // Many sphers please\n    ptmp -= round(ptmp);\n  \n    // The bubble\n    dtmp = sphere(ptmp.yzx, .4);\n  \n    dtmp *= z_7;\n  \n    // Glass is the box smooth intersected with the sphere4\n    // SPLIT need to not overstep when crossing materials\n    dg = pmax(d2, -(dtmp-SPLIT), .05);\n  \n    // No box\n    db = MAX_RAY_LENGTH;\n    break;\n  }\n\n\n  // Compute final distance\n  // Start with the box\n  float d = db; \n  // Then the glass\n  d = min(d, dg);\n  // Remove the sphere surrounding the inner sphere\n  d = max(d, -d1);\n  // Remove the inner sphere\n  d = min(d, d0);\n\n  // Material checking\n  \n  if (d == d0) {\n    // The inner sphere  \n    g_mat     = sphereMat;\n    g_diffCol = sphereCol;\n  } else if (d == db) {\n    // The box\n    g_mat     = mirrorMat;\n    g_diffCol = mirrorCol;\n  } else {\n    // The glass\n    g_mat     = glassMat;\n    g_diffCol = glassCol;\n  }\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  // This is the classic normal from distance field computation\n  // Essentially it is an approximate derivate of the distance field in each axis\n  //  then normalized\n  \n  vec2 eps = Units.zx*NORM_OFF;\n  return normalize(vec3(\n      df(pos+eps.xyy)-df(pos-eps.xyy)\n    , df(pos+eps.yxy)-df(pos-eps.yxy)\n    , df(pos+eps.yyx)-df(pos-eps.yyx))\n    );\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dm) {\n  // Classic raymarching with support being inside an object (being glass)\n\n  float t     = 0.0;\n  float tol   = dm*TOLERANCE;\n  vec2 nti = vec2(MAX_RAY_MARCHES,0);\n  float i;\n\n  for (i = 0.0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) break;\n    float d = dm*df(ro + rd*t);\n    if (d<nti.x) nti = vec2(d,t);\n    if (d < tol) break;\n    t += d;\n  }\n\n  // A trick learnt from a comment from IQ here: https://www.shadertoy.com/view/NdyyW3\n  //  It doesn't always improve things so thanks to tinkering around I found\n  //  I should only apply it when not inside the glass thus the extra dm>0.0\n  if(i==MAX_RAY_MARCHES && dm>0.0) t = nti.y;\n\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd, float fade) {\n  // Computes the color of the main object\n\n  // Aggregated color  \n  vec3 agg = vec3(0);\n  \n  // Aggregation reduction of color (to simulate glass absorbtion)\n  vec3 ragg= vec3(1);\n  \n  // Are we inside or outside when we begin?\n  bool isInside = df(ro) < 0.0;\n\n  // Outer loop for bounces inside glass or reflections\n  //  Can't both refract and reflect though :)\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n\n    // Check if we absorb so much light so that we can stop bouncing \n    float mragg = max(max(ragg.x, ragg.y), ragg.z);\n    if (mragg < .025) break;\n\n    // Find the intersection with object\n    float st = rayMarch(ro, rd, dfactor);\n\n    // Capture mat and diffuse color early as these global variables might be messed up later\n    vec3 mat = g_mat, diffCol = g_diffCol;\n    if (st >= MAX_RAY_LENGTH) {\n      // Missed the object, compute the skyColor and add it to the aggregated color adjusted for absorbtion \n      agg += ragg*skyColor(ro, rd);\n      break;\n    }\n\n    // Point of intersection\n    vec3 sp = ro+rd*st;\n    // Normal at intersection, adjust for if we are inside or outside\n    vec3 sn = dfactor*normal(sp);\n\n    // Fresnel effect, this decreases reflection if the ray direction aligns with normal\n    //  This can be observed when standing in water\n    //  Looking down water doesn't reflect much but when you lift your eyes the reflection\n    //  of water increases more and more as it stretches toward the horizon\n    //  My way to compute it is a HUGE fake, quite compact though\n    float fre = 1.0+dot(rd, sn);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    // Direction to the light source\n    vec3 ld   = normalize(lightPos - sp);\n\n    // Diffuse lighting factor\n    float dif = max(dot(ld, sn), 0.0);\n\n    // Reflect the incoming ray \n    vec3 ref  = reflect(rd, sn);\n\n    // And refract it\n    vec3 refr = refract(rd, sn, isInside ? 1.0/mat.z : mat.z);\n\n    // Compute the reflect sky\n    //  This is a huge approximation as the reflected might not even be visible\n    //  at this point or might be impact by refraction or reflections\n    //  Too hard to do all that and this looks ok\n    vec3 rsky = skyColor(sp, ref);\n\n    // The diffuse color + the reflected sky adjusted for the material and fresnel    \n    vec3 col  = diffCol*dif*dif*(1.0-mat.x)+rsky*mat.y*fre;\n\n    // The beer effect to simulate absorbtion of light in the glass\n    //  To emulate glow we use a negative beer \"absorbtion\" factor \n    if (isInside) ragg *= exp((st+INIT)*mix(beerCol1, beerCol0, fade));\n\n    // aggregate the color adjusted for the absorbtion\n    agg += ragg*col;\n\n    // Check if the refraction instead was a full reflection\n    if (refr == Units.xxx) {\n      // Yes it was, so next ray direction is the reflected ray\n      rd = ref;\n    } else {\n      // We are either entering or leaving the glass\n\n      // Adjusted absorbtion factor depending on the material \n      ragg *= mat.x;\n\n      // Turn it inside out, just like in galaxy quest\n      isInside = !isInside;\n\n      // Ray direction is the refracted ray\n      rd = refr;\n    }\n    \n    // new ray origin is current pos + a small step in the ray direction in order to not get stuck here\n    ro = sp+INIT*rd;\n  }\n  return agg;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  // Center should be 0,0\n  vec2 p = -1.0+2.0*q;\n  // Adjust for screen ratio\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  int period        = int(floor(TIME/PERIOD))%SCRIPT_PARTS;\n  part period_part  = parts[period];\n  g_variant         = period_part.variant;\n  float periodTime  = mod(TIME,PERIOD);\n  // Setup global rotation\n  g_rot_x = rot(-0.2);\n  g_rot_y = rot(-0.125*TIME);\n\n  vec3 ro = mix(RO0,RO1,period_part.ray_origin*0.5);\n\n  // I have seen people make the setup of rd shorter but I never understood how that works.\n  vec3 ww = normalize(-ro);\n  vec3 uu = normalize(cross(Units.xzx, ww));\n  vec3 vv = cross(ww,uu);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + 1.5*ww);\n\n  // Emulating light flickering on, this code I am pretty satisfied with :)\n  float fade0 = smoothstep(PERIOD/4.0, 0.5*PERIOD, periodTime)+period_part.flash_control > hash(floor(TIME*30.0)) ? 1.0 : 0.0;\n\n  // Symmetric fade in/fade out\n  float fade1 = smoothstep(0.5*PERIOD, 0.5*PERIOD-PERIOD/8.0, abs(periodTime-0.5*PERIOD));\n\n  // Do the raytrace and compute the color\n  vec3 col = render(ro, rd, fade0);\n\n  // Dirt simple trick to increase saturation and remove undesired glow\n  col -= 0.025*Units.zwx*length(p);\n\n  col = max(col, 0.0);\n  col *= fade1*fade1;\n\n  // Inaccurate sRGB conversion \n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 34546, "src": "https://soundcloud.com/virgill/4klang-studies-of-glass-ii", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlBRS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[3365, 3443, 3492, 3591, 5634], [5636, 5636, 5693, 5693, 5797]], "test": "untested"}
{"id": "DtsBRB", "name": "nuclear icon", "author": "ololeecn", "description": "nuclear", "tags": ["nuclear"], "likes": 3, "viewed": 145, "published": 3, "date": "1693120599", "time_retrieved": "2024-07-30T17:36:38.303796", "image_code": "#define ANG2RAD 3.14  / 180.0\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdPie(in vec2 p, in vec2 c, in float r ,float rotateTheta)\n{ \n    float roateteRad = rotateTheta * ANG2RAD;\n    mat2 rm = mat2(cos(roateteRad),sin(roateteRad),-sin(roateteRad),cos(roateteRad));\n    p = rm * p;\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n    float d0 = sdCircle(p,0.12);\n    float d1 = sdCircle(p,0.15);\n    float d2 = sdCircle(p,0.55);\n    float d3 = sdCircle(p,0.55);\n\n    \n    float t = 30.0  * ANG2RAD;\n    float rd = sdPie(p,vec2(sin(t),cos(t)), 0.5,0.0);\n    float rd2 = sdPie(p,vec2(sin(t),cos(t)), 0.5,-120.0);\n    float rd3 = sdPie(p,vec2(sin(t),cos(t)), 0.5, 120.0);\n    \n    vec3 blackColor = vec3(0.000,0.020,0.039) ;\n    vec3 yello = vec3(0.949,0.827,0.027);\n    \n    vec3 col = mix(blackColor,yello,smoothstep(0.0,0.01,rd));\n    col = mix(blackColor,col,smoothstep(0.0,0.01,rd2));\n    col = mix(blackColor,col,smoothstep(0.0,0.01,rd3));\n    \n    \n    col = mix(col, yello, 1.0-smoothstep(0.0,0.01,d1));\n    col = mix(col, blackColor, 1.0-smoothstep(0.0,0.01,d0));\n    \n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.03,abs(d3)));\n    col = mix( vec3(1.0), col, 1.0-smoothstep(0.0,0.01,d2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 72, 72, 98], [100, 100, 166, 166, 458], [460, 460, 517, 517, 1497]], "test": "untested"}
{"id": "dlsBDM", "name": "Inverse Square Fourier Transform", "author": "beans_please", "description": "0 = Input\n1 = 2D FFT\n2 = Inverse FFT\n\nSee use_sq at the top of Common.", "tags": ["fft", "square", "fourier", "transform", "dft"], "likes": 3, "viewed": 194, "published": 3, "date": "1693112135", "time_retrieved": "2024-07-30T17:36:39.388895", "image_code": "vec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = (2.0 * frag_coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // What to render at this time?\n    int mode = int(floor(3. * iTime / sec_per_shape)) % 3;\n    \n    // UV for text\n    vec2 uv2 = frag_coord / min(iResolution.x, iResolution.y);\n    uv2 -= .1;\n    uv2 /= 1.5;\n    const vec2 uv2max = vec2(64. / 1024.) - .001;\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (all(greaterThan(uv2, vec2(.001))) && all(lessThan(uv2, uv2max)))\n    {\n        // Text\n        col = vec3(texture(iChannel2, vec2(0., .75) + vec2(float(mode) * 64. / 1024., 0.) + uv2).x);\n    }\n    else if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        float v = 0.;\n        switch (mode)\n        {\n        case 0:\n            // Input\n            ft_input_init(iTime);\n            v = ft_input(vec2(uv * 0.5 + 0.5), iTime);\n            break;\n        case 1:\n            // FFT\n            v = length(texelFetch(iChannel0, ivec2(vec2(uv * 0.5 + 0.5) * vec2(ft_res)), 0).rg);\n            break;\n        case 2:\n            // Inverse FFT\n            v = length(texelFetch(iChannel1, ivec2(vec2(uv * 0.5 + 0.5) * vec2(ft_res)), 0).rg);\n            break;\n        }\n        col = vec3(v);\n    }\n    else\n    {\n        col = vec3(0);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Use square sin/cos?\nconst bool use_sq = true;\n\n// FT resolution\nconst ivec2 ft_res = ivec2(100);\n\n// FT multiplier. Do not modify\nconst float ft_mul = 1. / sqrt(float(ft_res.x * ft_res.y));\n\n// Seconds per shape\nconst float sec_per_shape = 6.;\n\n\n\n/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\n/*____________________ End ____________________*/\n\n\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return remap01(x - center, -half_width - fade_width, -half_width)\n        * remap01(x - center, half_width + fade_width, half_width);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n\n// FT input variables\nfloat ft_input_shape0_radius;\nfloat ft_input_shape1_slit1_half_width;\nfloat ft_input_shape1_slit2_center;\nfloat ft_input_shape1_slit2_fade;\nfloat ft_input_shape1_cutout_radius;\n\n// Initialize FT input variables\nvoid ft_input_init(float time)\n{\n    float t = TAU * time;\n    ft_input_shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    ft_input_shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    ft_input_shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    ft_input_shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    ft_input_shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n}\n\n// Evaluate FT input at uv and time\nfloat ft_input(vec2 uv, float time)\n{\n    int shape = int(floor(time / sec_per_shape)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return remap01(distance(uv, vec2(0.5, 0.5)), ft_input_shape0_radius, ft_input_shape0_radius - 0.02);\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, ft_input_shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, ft_input_shape1_slit2_center, 0.02, ft_input_shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= remap01(d, ft_input_shape1_cutout_radius, ft_input_shape1_cutout_radius - 0.01);\n        v *= remap01(d, 0.3, 0.01) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return remap01(sd_npoly(5.0, 0.15, time * 0.25, uv - 0.5), 0.01, 0.0);\n    }\n    return 0.;\n}\n\n// Square sin\nfloat sqsin(float x)\n{\n    if (use_sq)\n        return mod(x / TAU, 1.) < .5 ? 1. : -1.;\n    else\n        return sin(x);\n}\n\n// Square cos\nfloat sqcos(float x)\n{\n    if (use_sq)\n        return mod((x / TAU) + .25, 1.) < .5 ? 1. : -1.;\n    else\n        return cos(x);\n}\n\n// Multiply two complex numbers\nvec2 complex_mul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n", "buffer_a_code": "// FT is performed in this buffer.\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0);\n    for (int y = 0; y < ft_res.y; y++)\n    {\n        for (int x = 0; x < ft_res.x; x++)\n        {\n            vec2 uv = (vec2(x, y) + .5) / vec2(ft_res);\n            float a = dot(uv, f2);\n            v += ft_input(uv, iTime) * vec2(sqcos(a), sqsin(a));\n            // Same thing:\n            //v += complex_mul(vec2(ft_input(uv, iTime), 0.), vec2(sqcos(a), sqsin(a)));\n        }\n    }\n    return v * ft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < ft_res.x || int(floor(iResolution.y)) < ft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // If outside the region of interest\n    if (icoord.x >= ft_res.x || icoord.y >= ft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for ft_input\n    ft_input_init(iTime);\n    \n    // What 2D frequency to check\n    ivec2 freq = icoord - (ft_res / 2);\n    \n    // How much of the frequency is present\n    frag_col = vec4(freq_amount(freq), 0., 1.);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "// Inverse FT is performed in this buffer.\n\n// How much of this frequency is present in the input?\nvec2 freq_amount(ivec2 freq)\n{\n    vec2 f2 = vec2(freq) * -TAU;\n    vec2 v = vec2(0);\n    for (int y = 0; y < ft_res.y; y++)\n    {\n        for (int x = 0; x < ft_res.x; x++)\n        {\n            vec2 uv = (vec2(x, y) + .5) / vec2(ft_res);\n            float a = dot(uv, f2);\n            v += complex_mul(texelFetch(iChannel0, ivec2(x, y), 0).xy, vec2(sqcos(a), sqsin(a)));\n        }\n    }\n    return v * ft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < ft_res.x || int(floor(iResolution.y)) < ft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // If outside the region of interest\n    if (icoord.x >= ft_res.x || icoord.y >= ft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // What 2D frequency to check\n    ivec2 freq = icoord;\n    \n    // How much of the frequency is present\n    frag_col = vec4(freq_amount(freq), 0., 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 48, 88], [90, 90, 145, 155, 1484]], "test": "untested"}
{"id": "DlsfRS", "name": "Repeater", "author": "fad", "description": "Try dragging with your mouse\n\nInspired by the After Effects plugin of the same name https://www.plugineverything.com/repeater", "tags": ["interactive", "texture", "repetition", "tiling", "tile", "overlap", "repeat"], "likes": 12, "viewed": 247, "published": 3, "date": "1693108622", "time_retrieved": "2024-07-30T17:36:40.306441", "image_code": "// Try dragging with your mouse\n// \n// Inspired by the After Effects plugin of the same name\n// https://www.plugineverything.com/repeater\n//\n// Change texSize and tex(uv, instance) for different textures\n\n#define texSize (vec2(40.0, 32.0) * 5.0)\n\nvec4 tex(vec2 uv, vec2 instance) {\n    // Instance is an integer ID used for per-instance randomness\n    // random number for this instance\n    vec4 r = texelFetch(\n        iChannel1,\n        ivec2(mod(instance, vec2(textureSize(iChannel1, 0)))),\n        0\n    );\n\n    // Randomly mirror the texture\n    if (r.x < 0.2) {\n        uv.x = 1.0 - uv.x;\n        r.x = r.x / 0.2;\n    } else {\n        r.x = (r.x - 0.2) / 0.8;\n    }\n\n    if (r.x < 0.2) {\n        uv.y = 1.0 - uv.y;\n        r.x = r.x / 0.2;\n    } else {\n        r.x = (r.x - 0.2) / 0.8;\n    }\n\n    // Animate Nyan Cat\n    float frame = mod(floor(iTime * 8.0 + r.x * 10.0), 6.0);\n    ivec2 p = ivec2((uv.x + frame) * 40.0, uv.y * 32.0);\n    \n    // Tint Nyan Cat\n    vec4 tint = vec4(normalize(r.yzw) * 0.7 + 0.6, r.a * 0.5 + 0.5);\n    \n    return texelFetch(iChannel0, p, 0) * tint;\n}\n\nvec4 blendOver(vec4 front, vec4 back) {\n    float a = front.a + back.a * (1.0 - front.a);\n    return a > 0.0\n        ? vec4((front.rgb * front.a + back.rgb * back.a * (1.0 - front.a)) / a , a)\n        : vec4(0.0);\n}\n\nmat3 translate(vec2 p) {\n    mat3 m = mat3(1.0);\n    m[2].xy = p;\n    return m;\n}\n\nmat3 scale(float s) {\n    mat3 m = mat3(1.0);\n    m[0].x = s;\n    m[1].y = s;\n    return m;\n}\n\nmat3 rotate(float theta) {\n    mat3 m = mat3(1.0);\n    m[0].xy = vec2(cos(theta), sin(theta));\n    m[1].xy = vec2(-sin(theta), cos(theta));\n    return m;\n}\n\nconst float MAX_FLOAT = uintBitsToFloat(0x7f7fffffu);\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = mix(\n        vec4(0.6, 0.7, 0.9, 1.0),\n        vec4(0.9, 1.0, 1.0, 1.0),\n        (fragCoord.x + fragCoord.y) / (iResolution.x + iResolution.y)\n    );\n    \n    // Matrix to transform instance IDs to positions\n    // If the determinant is close to zero then it will lag because a\n    // lot of instances will overlap\n    mat3 m = mat3(1.0);\n    m[0].xy = vec2(mix(100.0, 200.0, sin(iTime) * 0.5 + 0.5), 50.0);\n    m[1].xy = vec2(30.0, mix(100.0, 150.0, cos(iTime) * 0.5 + 0.5));\n    m[2].xy = iResolution.xy * 0.5 + vec2(cos(iTime), sin(iTime)) * 100.0;\n    \n    if (iMouse.z > 0.0) {\n        vec2 p = abs(iMouse.zw);\n        vec2 q = iMouse.xy;\n        m = translate(p)\n          * scale(length(vec3(p - q, 40.0)))\n          * rotate(p == q ? 0.0 : atan(q.y - p.y, q.x - p.x));\n    }\n    \n    mat3 im = inverse(m);\n    vec4 s = vec4(texSize, -texSize) / 2.0;\n    vec2 p1 = (im * vec3(fragCoord + s.xy, 1.0)).xy;\n    vec2 p2 = (im * vec3(fragCoord + s.zy, 1.0)).xy;\n    vec2 p3 = (im * vec3(fragCoord + s.zw, 1.0)).xy;\n    vec2 p4 = (im * vec3(fragCoord + s.xw, 1.0)).xy;\n    float yMin = ceil(min(min(min(p1, p2), p3), p4)).y;\n    float yMax = floor(max(max(max(p1, p2), p3), p4)).y;\n    \n    for (float y = yMin; y <= yMax; ++y) {\n        float xMin = MAX_FLOAT;\n        float xMax = -MAX_FLOAT;\n        \n        #define intersect(p1, p2)                                               \\\n            if (p1.y != p2.y && min(p1.y, p2.y) <= y && y <= max(p1.y, p2.y)) { \\\n                float x = mix(p1, p2, (y - p1.y) / (p2.y - p1.y)).x;            \\\n                xMin = min(xMin, x); xMax = max(xMax, x);                       \\\n            }\n        \n        intersect(p1, p2);\n        intersect(p2, p3);\n        intersect(p3, p4);\n        intersect(p4, p1);\n        xMin = ceil(xMin);\n        xMax = floor(xMax);\n        \n        for (float x = xMin; x <= xMax; ++x) {\n            vec2 instance = vec2(x, y);\n            vec2 p = (m * vec3(instance, 1.0)).xy;\n            vec2 uv = (fragCoord - (p - s.xy)) / texSize;\n            fragColor = blendOver(tex(uv, instance), fragColor);\n        }\n    }\n   \n    fragColor.rgb *= fragColor.a;\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 281, 386, 1089], [1091, 1091, 1130, 1130, 1306], [1308, 1308, 1332, 1332, 1389], [1391, 1391, 1412, 1412, 1484], [1486, 1486, 1512, 1512, 1641], [1698, 1698, 1750, 1750, 3911]], "test": "untested"}
{"id": "DtsfRS", "name": "Arabesque knots 7 (music)", "author": "jarble", "description": "A variant of my \"Banded mosaic\" pattern with a more interesting color palette.", "tags": ["fractal", "music", "arabesque"], "likes": 6, "viewed": 162, "published": 3, "date": "1693108133", "time_retrieved": "2024-07-30T17:36:41.073391", "image_code": "\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 =\n        a+a2\n    ;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n\n\n\n\nvec3 fractal(vec2 uv,float s1,float s2){\n    vec3 col = vec3(0.);\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 12; k++){\n        \n        //uv.x += t1_(floor(uv),floor(uv));\n        \n        float offset =\n            0.\n        ;\n        uv =\n            (uv+t2)/scale\n            \n            //looks better with more iterations\n            //(uv+t2+fract(-t2/1.5))/scale\n        ;\n        //uv = (fract(vec2(uv+vec2(.5,1.5))*2.)-.5)/2.;\n        //if(uv.x<uv.y) {uv = uv.yx;}\n        t2 =\n            triangle_wave(uv+.5*s1+offset)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx+s2+offset)\n        ;\n        float c1 =\n            uv.y-uv.x\n            //uv.y+uv.x*sign(t2.x-t2.y)\n        ;\n        col = vec3(c1,col.yz);\n        if(t3 =\n            t2.x < t2.y\n            //t2.x < t2.y || uv.x<uv.y\n        ) col =\n            col.yzx\n        ;\n        {uv=-uv.yx;t2=-t2.yx;}\n\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    col = fractal(uv,1.,0.);\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat fmod2(float a, float b){\n    return b*mod(floor(a),b);\n}\n\nfloat fmod(float x,float y,float z){\n    //x += floor(floor(x)/floor(y+2.)/floor(z+2.));\n    x += floor(mod(x/4.,4.));\n    y += floor(mod(y/4.,4.));  \n    return\n        floor(max(mod(floor(x)*3.,y),mod(floor(-x)*4.,y)))\n        //floor(sqrt(floor(max(mod(floor(x)*3.*y,y*y),mod(floor(-x)*4.*y,y*y)))))\n    ;\n}\n\nfloat fmod1(float x,float y){\n    //x += mod(x,4.)-mod(x,3.);\n    return\n        floor(min(mod(floor((x))*3.,y),mod(floor(-x)*4.,y)))\n        //floor(min(mod(mod(floor((x))*3.,y),y*y),mod(mod(floor(-x)*4.,y),y*y)))\n    ;\n}\n\n#define fract2(a) (1.-fract(-a)*fract(-a))\n\nfloat fract1(float a){\n    return\n        abs(fract(a)+.25)/1.25\n    ;\n}\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 mainSound(int samp, float time){  \n  float\n  tempo = 1.;\n  float t1=\n      1.\n  ;\n  float\n  s1 =\n      pow(2.,1.+fmod(time/8.,3.,time))\n  ,\n  s2 = pow(2.,1.+fmod1(time/8.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1+1.,2.,time)),\n  t =\n      time\n  ;\n  float m4 = fmod1(t*s1/(1.+fmod(t/s1,2.,time)),s2),\n  m3 = fmod((t*t1+m4)*s1/m1,s2,time);\n  t *= s1/(1.+fmod(t/s1,2.,time));\n  float m2 =\n      1. + fmod(t,s1,time)\n  ,\n  a =\n      //pow(2.,2.-log(fract(t)))/2.\n      //pow(2.-log(fract(t)),2.)/2.\n      //pow(1.-log(fract2(t)/8.)/2.,2.)\n      pow(log(1./64.*2.+fract2(t)/8.),2.)\n      //pow(1.-log(fract(t)/2.),2.)\n  ,\n  a2 =\n      pow(log(1./64.*2.+fract2(t)/4.),2.)\n  ,\n  nb = time*tempo*pow(2.,(m3+m2)/5.+5.5);\n  return\n      //abs(.5-1.5*vec2(fract(nb*.998),fract(nb)))*a\n      \n      //sitar\n      sitar2(vec2(a),vec2(nb))-sitar2(vec2(a2),vec2(nb*2.))\n      //a/16./8.*log(1./4.+.5*abs(a/16.-abs(.5-vec2(fract2(nb*.998),fract2(nb)))*a))\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 142, 142, 231], [233, 233, 260, 260, 375], [381, 381, 421, 421, 1342], [1344, 1344, 1401, 1401, 1706]], "test": "untested"}
{"id": "mtfBRS", "name": "sin graph", "author": "codeway", "description": "just a master piece (absolutky not)", "tags": ["sin"], "likes": 0, "viewed": 165, "published": 3, "date": "1693082004", "time_retrieved": "2024-07-30T17:36:41.920128", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //ignore the comments and reasd my shitty code\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = uv.y*2.0-1.0;\n    vec3 c = vec3((sin(uv.x*3.0)*(uv.y)),0.0,(sin(uv.x*3.0)*(uv.y)*-1.0));\n    // Time varying pixel color\n    float multi = abs(sin(iTime*0.1))*35.0+3.0;\n    uv.x+=iTime*0.03;\n    float r =  1.0/iResolution.y*2.5*multi;\n    if(sin(uv.x*multi)-r<=uv.y && sin(uv.x*multi)+r>=uv.y) c =vec3(1.0,1.0,1.0);\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 158, 580]], "test": "untested"}
{"id": "DtsBWM", "name": "Packed Voronoi Tracking", "author": "fenix", "description": "Testing an implementation of tracking 8 voronoi particles per cell instead of the usual 4.\n\nLeft: 4 neighbors per cell\nRight: 8 neighbors per cell\n\n*mouse x: particle speed*\n*mouse y: horizontal split*\n*space: reset*\n*1-8: render the Nth closest*", "tags": ["voronoi", "particles", "tracking", "jfa"], "likes": 13, "viewed": 273, "published": 3, "date": "1693078207", "time_retrieved": "2024-07-30T17:36:43.150836", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another voronoi experiment, in the same genre as its predecessor. This shows a case\n//  where there is a benefit to maintaining eight voronoi neighbors per cell. The proof\n//  that it helps in this case is that the right side of the screen is brighter; we're\n//  missing fewer of the particles on that side.\n//\n//  Just as before, you can control the particle speed with mouse X. Mouse Y moves the\n//  horizontal bar up and down. Above the bar, the particles are rendered using the\n//  voronoi buffer. Below the bar, a debug view of the voronoi buffer is shown. Drag\n//  the bar up to get a good luck at the debug draw, and down to see the particles.\n//\n//  There is a completely new feature! Press the number keys 1-8 to change the debug\n//  draw to render the ids of the Nth closest particle to each pixel (default view is\n//  1, i.e. the closest particle).\n//\n//  In order to store eight neighbors per pixel, only 65534 particles are allowed,\n//  because the particle ids are stored in the upper and lower 16 bits of each component.\n//  That might or might not be enough particles depending on your needs.\n//\n//  The only reason this strategy makes a difference is that the particles are so crowded\n//  together, so that more than four can actually need to be rendered per pixel. If you\n//  click the mouse all the way to the left to slow the particles down, you can see even\n//  when the voronoi is allowed to completely converge, the right side is still brighter.\n//\n//  If you hold shift, only the four closest particles will be drawn on both sides. At\n//  slow speeds left and right look the same, as the voronoi can completely converge.\n//  But if you click on the right side to speed the particles up, you can see that\n//  the right side is brighter than the left again. This is because of the additional\n//  information transfer when you track eight neighbors. You might be able to see this\n//  additional information transfer in the form of increased \"clarity\" in the voronoi\n//  debug draw on the right, at the correct resolution and particle speed.\n//\n//  However, it's also clearly more expensive. If I run many random samples with the\n//  eight neighbor algorithm, it slows down the shader much faster than with a non-packed\n//  \"normal\" voronoi update. It's probably about four times as expensive per sample, since\n//  sorting eight things into eight is about four times as expensive as sorting four into\n//  four. So in cases when there is not a lot of particle overdraw, it might be better to\n//  use a non-packed voronoi buffer since you could run four times more samples for the\n//  same cost.\n// ---------------------------------------------------------------------------------------\n\n// render four particles from the voronoi buffer\nvoid renderParticles(vec2 p, uvec4 o, inout vec4 O)\n{\n    for (int i = 0; i < 4; ++i)\n    {\n        uint id = o[i];\n        if (id == -1U || id >= MAX_PARTICLES) break;\n        vec4 v = getParticle(id);\n        float d = fxLinePointDist(v.xy, v.zw, p);\n        O.xyz += pow(smoothstep(.05, .01, d), 1.) * vec3(1, .25, .1) * .5;\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 h = texelFetch(iChannel0, ivec2(R.x - 1., R.y - 1.), 0).yw, // state y: horiz split point; w: numeric selection\n         p = (u - .5 * R) / R.y;\n         \n    uvec4 oa, ob;\n    getClosest(u, oa, ob);\n    \n    if (p.y > h.x)\n    {\n        O = vec4(0);\n    \n        renderParticles(p, oa, O);\n        if (!keyDown(KEY_SHIFT)) renderParticles(p, ob, O);\n    }\n    else\n    {\n        // render voronoi below vertical split\n        uint id = h.y < 4. ? oa[int(h.y)] : ob[int(h.y) - 4];\n        O.rgb = pow(sin(vec3(id) * vec3(1, 2, 3)), vec3(7.));;\n    }\n    \n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(3. / R.y, 0., abs(p.y - h.x)));    // horizontal bar\n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(3. / R.y, 0., abs(p.x))); // vertical bars\n    O.a = 1.;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//\tParticle \"sim\" and state management\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec4 s = texelFetch(iChannel0, ivec2(R - .5), 0); // state stored in upper right corner\n\n    if (u == R - .5)\n    {\n        // persistent state tracking\n        // state pixel has:\n        // xy: mouse position\n        // z: time\n        // w: number selection\n        \n        // record user mouse position\n        if (iMouse.z > 0.) s.xy = (iMouse.xy - .5 * R) / R;\n        \n        // update particle time\n        s.z += (s.x + .5) * .003; // z holds particle time\n        \n        // handle number selection\n        for (int i = 0; i < 9; ++i)\n            if (keyClick(KEY_1 + i)) s.w = float(i);\n            \n        // init\n        if (iFrame == 0) s = vec4(0);\n        \n        O = s;\n        return;\n    }\n    \n    O.zw = texelFetch(iChannel0, ivec2(u), 0).xy; // zw holds previous position\n    \n    float idx = u.x + u.y * R.x; // which particle\n    if (uint(idx) >= MAX_PARTICLES) return;\n    \n    // this is not really a simulation at all, just a stateless animation to give our tracker something to do\n    idx = idx * .06 + s.z;\n    O.x = (.7 * sin(idx) + .3 * sin(idx * 40.4)) * .45 * R.x / R.y;\n    O.y = cos(idx * 10.) * .4;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n//\tPacked voronoi tracking buffer, tracking eight neighbors per pixel\n// ---------------------------------------------------------------------------------------\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    if (id == -1U || id >= MAX_PARTICLES) return 1e6;\n    \n    vec4 v = getParticle(id);\n    return min(length2(v.xy - u), length2(v.zw - u));\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\n// the furthest distance (whether from the vector or the input) will end up in i and d\nvoid insertionSort(inout uvec4 i, inout vec4 d, inout uint i_, inout float d_)\n{\t\n    uint ip = i_;\n    float dp = d_;\n    if (d_ < d[0])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(ip,i.xyz),    d = vec4(dp,d.xyz);\n    else if(d_ < d[1])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.x,ip,i.yz), d = vec4(d.x,dp,d.yz);\n    else if(d_ < d[2])            \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xy,ip,i.z), d = vec4(d.xy,dp,d.z);\n    else if(d_ < d[3])           \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xyz,ip),    d = vec4(d.xyz,dp);\n}\n\n// sort a single particle into two four-element vectors (8 total slots)\nvoid insertionSort2(inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, uint id, vec2 p)\n{\n    if (any(equal(uvec4(id),na)) || any(equal(uvec4(id),nb))) return; // don't insert the same id twice\n    \n    float d = distance2Particle(id, p);\n    insertionSort(na, da, id, d);\n    insertionSort(nb, db, id, d);\n}\n\n// consider a new set of four candidate particles to insert into our arrays\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db)\n{\n    for (int j = 0; j < 4; j++)\n        insertionSort2(na, nb, da, db, old[j], p);\n}\n\n// consider a new set of eignt candidate particles to insert into our arrays\nvoid sortNbs2(uvec4 a, uvec4 b, vec2 p, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db)\n{\n    sortNbs(a, p, na, nb, da, db);\n    sortNbs(b, p, na, nb, da, db);\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x )\n{\n    const uint k = 1103515245U;  // GLIB C\n    \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n\tvec2 p = (u - .5 * R) / R.y;\n    uvec4 na = uvec4(-1U), nb = uvec4(-1U); // the eight new closest particle ids\n    vec4 da = vec4(1e6), db = vec4(1e6);  // the distances of the eight closest particles\n\n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        // start with our previous frame's values, and look up the distances\n        uvec4 oa, ob;\n        getClosest(u, oa, ob);\n        sortNbs2(oa, ob, p, na, nb, da, db);\n        \n        // search a random nearby cell for possible improvements to our arrays\n        // note: this would typically be in a loop, taking multiple samples per frame, for faster convergence\n        vec3 h = hash3(uvec3(u, iFrame)) - .5;\n        uvec4 ta, tb;\n        getClosest(u + h.xy * 100., ta, tb);\n        sortNbs2(ta, tb, p, na, nb, da, db);\n\n        // search a random cell in the entire buffer to kick-start the process\n        // note: this would typically be in a loop, taking multiple samples per frame, for faster convergence\n        uint id = uint(h.z*float(MAX_PARTICLES));\n        insertionSort2(na, nb, da, db, id, p);\n    }\n    \n    // kill the second four neighbors on the left side of the screen, for demonstration purposes\n    if (p.x < 0.) nb = uvec4(-1);\n    \n    O = saveClosest(na, nb);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const uint MAX_PARTICLES = 3000U;\n#define R iResolution.xy\n\n// compute squared length of vector\nfloat length2(vec2 v) { return dot(v, v); }\n\n// compute distance to line segment\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n// pack two unsigned vectors into one, keeping only the bottom 16 bits\nuvec4 pack2(uvec4 a, uvec4 b)\n{\n    return (a & 0xffffU) | ((b & 0xffffU) << 16);\n}\n\n// unpack a packed unsigned vector packed by pack2\nvoid unpack2(uvec4 p, out uvec4 a, out uvec4 b)\n{\n    a = p & 0xffffU;\n    b = (p & 0xffff0000U) >> 16;\n}\n\n// get the eight closest particles to some screen pixel\n//    u - pixel position\n//    a - closest 4 particles\n//    b - next 4 closest particles\n#define getClosest(X, Y, Z) getClosestImpl(iChannel1, X, Y, Z)\nvoid getClosestImpl(sampler2D smp, vec2 u, out uvec4 a, out uvec4 b)\n{\n    vec4 o = texelFetch(smp, ivec2(u), 0);\n    uvec4 p = floatBitsToUint(o);\n    unpack2(p, a, b);\n}\n\n// export the eight closest ids to the shader output\nvec4 saveClosest(uvec4 a, uvec4 b)\n{\n    return uintBitsToFloat(pack2(a, b));\n}\n\n// get the info for one particle: position in xy, previous position in zw\n#define getParticle(X) getParticleImpl(iChannel0, uint(R.x), X)\nvec4 getParticleImpl(sampler2D smp, uint wd, uint id)\n{\n    return texelFetch(smp, ivec2(id % wd, id / wd), 0);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_1 49", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsBWM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2919, 2968, 3021, 3021, 3303], [3305, 3305, 3341, 3341, 4105]], "test": "untested"}
{"id": "clffRB", "name": "print numbers, code-only (cc0)", "author": "wareya", "description": "prints numbers to the screen without using textures or large lookup tables. intended for debugging.", "tags": ["tutorial", "text", "presentation", "gui"], "likes": 7, "viewed": 750, "published": 3, "date": "1693076833", "time_retrieved": "2024-07-30T17:36:44.080351", "image_code": "// GLSL code for rendering numbers without using any textures or global arrays, using a tiny bitmap font\n// for debugging!\n// public domain. use under the creative commons zero license (any version)\n// warning: the float-to-decimal conversion logic is \"incorrect\" and can only give around around four or five decimal places of floating point decision\n// warning: the integer part of the printed floats is limited to the size of a signed 32-bit integer\n\n\nconst int _print_number_max_float_digits = 5;\nconst int _print_number_scale = 2;\nconst int _print_number_stretch_x = 1;\nconst int _print_number_stretch_y = 1;\n\nfloat num_bit(int num, int x, int y)\n{\n    if (x < 0 || y < 0 || x >= 3 || y >= 5)\n        return 0.0;\n    \n    int bit = (1) << (x + 3*y);\n    \n    // godot users: change int[](...) to {...}\n    //int array[] = int[](0x01C0, 0x2000, 0x7B6F, 0x749A, 0x73E7, 0x79E7, 0x49ED, 0x79CF, 0x7BCF, 0x4927, 0x7BEF, 0x79EF);\n    // or: (has an offset '1' and '.' glyphs, so it's \"stretchable\")\n    int array[] = int[](0x01C0, 0x4000, 0x7B6F, 0x4924, 0x73E7, 0x79E7, 0x49ED, 0x79CF, 0x7BCF, 0x4927, 0x7BEF, 0x79EF);\n    \n    int mask = 0;\n    if (num >= -2 && num <= 9)\n        mask = array[num+2];\n    \n    if ((mask & bit) > 0)\n        return 1.0;\n    return 0.0;\n}\n\nivec2 char_size()\n{\n    return ivec2(4 + _print_number_stretch_x, 6 + _print_number_stretch_y*2) * _print_number_scale;\n}\n\nint number_width(float num)\n{\n    int int_digits = 1;\n    int num2 = int(num);\n    while(num2 >= 10)\n    {\n        int_digits += 1;\n        num2 /= 10;\n    }\n    \n    return (int_digits + _print_number_max_float_digits + 1)*(4 + _print_number_stretch_x);\n}\nvec4 get_number(ivec2 px, float num)\n{\n    if (px.y < 0 || px.x < 0)\n        return vec4(0.0);\n    \n    px /= _print_number_scale;\n    \n    int y_mid = 2+_print_number_stretch_y;\n    int y_end = 4+_print_number_stretch_y*2;\n    \n    if (px.y == 0)\n        px.y = 0;\n    else if (px.y > 0 && px.y < y_mid)\n        px.y = 1;\n    else if (px.y == y_mid)\n        px.y = 2;\n    else if (px.y > y_mid && px.y < y_end)\n        px.y = 3;\n    else if (px.y == y_end)\n        px.y = 4;\n    else\n        return vec4(0.0);\n    \n    int x_end = 2+_print_number_stretch_x;\n    \n    int _x = px.x % (4 + _print_number_stretch_x);\n    int which_digit = px.x / (4 + _print_number_stretch_x);\n    \n    if (_x == 0)\n        px.x = 0;\n    else if (_x > 0 && _x < x_end)\n        px.x = 1;\n    else if (_x == x_end)\n        px.x = 2;\n    else\n        return vec4(0.0);\n    \n    int int_digits = 1;\n    int num2 = abs(int(num));\n    while(num2 >= 10)\n    {\n        int_digits += 1;\n        num2 /= 10;\n    }\n    \n    if (which_digit - int_digits > _print_number_max_float_digits)\n        return vec4(0.0);\n    \n    int digit = -1;\n    \n    if (num < 0.0)\n    {\n        if (which_digit == 0)\n            digit = -2;\n        which_digit -= 1;\n    }\n    \n    if (which_digit >= 0 && which_digit < int_digits)\n    {\n        which_digit = int_digits - which_digit - 1;\n        digit = abs(int(num));\n        for(int i = 0; i < which_digit; i += 1)\n            digit /= 10;\n        digit = (digit % 10 + 10) % 10;\n    }\n    else if (which_digit > int_digits)\n    {\n        which_digit = which_digit - int_digits;\n        float factor = 1.0;\n        for(int i = 0; i < which_digit; i += 1)\n            factor *= 10.0;\n        \n        int num3 = int(mod(abs(fract(num)) * factor, 10.0));\n        \n        digit = int(num3) % 10;\n    }\n    \n    ivec2 digit_px = ivec2(((px.x % 4) + 4) % 4, (((px.y % 6) + 6) % 6));\n    \n    return vec4(num_bit(digit, digit_px.x, digit_px.y));\n}\n\nvec4 print_number(ivec2 px, float num, vec4 in_color, vec4 text_color)\n{\n    vec4 out_color = get_number(px, num) * text_color;\n    return mix(in_color, out_color, out_color.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0.0),1.0);\n    \n    ivec2 px = ivec2(fragCoord.x, iResolution.y - fragCoord.y);\n    \n    px.x -= 5;\n    px.y -= 5;\n    \n    fragColor = print_number(px, 3.14159, fragColor, vec4(1.0));\n    px.y -= char_size().y;\n    \n    fragColor = print_number(px, 135798624.0, fragColor, vec4(1.0));\n    px.y -= char_size().y;\n    \n    fragColor = print_number(px, iTime, fragColor, vec4(1.0));\n    px.y -= char_size().y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clffRB.jpg", "access": "api", "license": "public-domain", "functions": [[1272, 1272, 1291, 1291, 1393], [1395, 1395, 1424, 1424, 1651], [1652, 1652, 1690, 1690, 3599], [3601, 3601, 3673, 3673, 3780], [3782, 3782, 3839, 3839, 4275]], "test": "untested"}
{"id": "DsBcWW", "name": "Sonus", "author": "Antrague", "description": "Microphone reaction, for Colors of Ostrava 2023.", "tags": ["tunnel", "mic"], "likes": 5, "viewed": 282, "published": 3, "date": "1693075718", "time_retrieved": "2024-07-30T17:36:45.075690", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan - https://www.shadertoy.com/view/MdBczW\n* hacked by cale bradbury\n*/\n\n#define I_MAX\t200\n#define E\t\t0.0005\n\n//#define SEE_ALL\n//#define SPIRAL\n\nvoid\trotate(inout vec2 v, float angle);\nfloat\tsdTorus( vec3 p, vec2 t );\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tscene(vec3 p);\n\nfloat\tg; //coloring id\nfloat\tt; // time\nfloat\ta; // angle\nvec3\tss;// tmp var recording old ray position\nvec4 vv;\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    t = iTime*.3;\n    for( int i=0; i<4; i++ )\n\t{\n        vv[i] = texture(iChannel1, vec2(float(i)/6.0, .01)).r;\n\t}\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(0., 0., 0.);\n    rotate(dir.zx, cos(t)*.25);\n    vec2\tinter = (march(pos, dir));\n \to.xyz = vec3(inter.y*.2 - (inter.x)*.01);\n    o.xyz *= vec3(sin(1.04+(0.4*t)), sin(2.09+(0.4*t)), sin(3.14+(0.4*t)));\n    o.xyz += (1.)*blackbody((15.-(2.*inter.y-.1*inter.x) )*50.);\n  \n  //o.xyz += (texture(iChannel1, vec2( 2., 2.)).x)*blackbody((20.*inter.y-.1*inter.x)*80.);\n   // o.xyz += (1.-sin(t))*vec3(abs(sin(t+1.04+g)), abs(sin(t+2.09+g)), abs(sin(t+3.14+g)))*inter.x*.005;\n   // o.xyz *= (1.1-length(uv)*1.);\n}\n\nfloat\tscene(vec3 p)\n{\n\tfloat scale = 1.0;\n    float r2,k;\n    a = cos( .5*(p.z) +t);\n    rotate(p.yx, (a) );\n    p.xy+=vec2(cos(t), sin(t))*.25+1.;\n    p.z-=t;\n    //p.xy+=t;\n    \n    ss = p;\n    for( int i=0; i<4; i++ )\n\t{\n        p.xyz = 1.0 - 2.*fract(.5*p.xyz+0.5);\n        //p*=1.+pow(v, 3.);\n\t\tr2 = sdTorus(p, vec2(.21,.4*vv[i]+.21) );\n       /// if(r2 > 5./float(i) )\n        //    break;\n\t\tk = 1./(r2);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tss=p*(fract(ss)+.5);\n    return (0.25*(abs(p.x)+length(fract(ss.xz)-.5 )*.1)/scale);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec2\ts = vec2(0.0);\n\n    vec3\tdirr;\n    for (int i = 0; i < I_MAX; ++i)\n    {\n        dirr = dir;\n    \t//rotate(dirr.zx, .025*dist.y*sin(t*1.5));        \n        //rotate(dirr.yx, .5*dist.y*sin(t*.5));\n        \n    \tp = pos + dirr * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 6.)\n        {\n            p=ss;\n            g = p.y;\n\t        g += (step(sin(5.*p.x), .5) \n             + step(sin(20.*p.x), .5) );\n           break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//by cale bradbury\n//hacked from https://www.shadertoy.com/view/MdBczW by balkhan\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 o = vec2(0., 1.1/iResolution.y);\n    float m = mix(\n        texture(iChannel0, uv-o).x,\n        texture(iChannel1, vec2(uv.x, .3)).x,\n       \tmax(ceil(1.-fragCoord.y), 0.));\n    m*=(1.0-pow(1.0-uv.x, 5.))*.3+.8;\n    fragColor = vec4(m,m,m,1.);\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsBcWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[879, 879, 907, 907, 1232], [1281, 1281, 1321, 1321, 2051], [2053, 2053, 2074, 2074, 2582], [2584, 2584, 2616, 2616, 3217], [3233, 3233, 3266, 3266, 3333], [3335, 3335, 3357, 3357, 3564], [3566, 3566, 3606, 3606, 3681]], "test": "untested"}
{"id": "mtsBzH", "name": "Single spiral galaxy 2", "author": "Mermersk", "description": "Tried to make something similiar to this image of the milky way: https://solarsystem.nasa.gov/internal_resources/125/ . Based on previous shader I made, but now im using a logarithmic spiral + some other new stuff.", "tags": ["spiral", "space", "galaxy", "milkyway", "cineshader"], "likes": 16, "viewed": 1411, "published": 3, "date": "1693070828", "time_retrieved": "2024-07-30T17:36:46.022159", "image_code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\n#define PI 3.1415926\n#define PI2 6.283186\n#define e 2.71828\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat noise1d(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\t\n\treturn mix(hashwithoutsine11(i), hashwithoutsine11(i+1.0), smoothstep(0.0, 1.0, f));\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,711.7)),\n              dot(st,vec2(619.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*23758.545123);\n}\n\nvec2 hashwithoutsine22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    //vec2 u = smoothstep(0.0, 1.0, f);//f*f*(3.0-2.0*f);\n    // Quintic interpolation curve\n    vec2 u = f*f*f*(f*(f*6.-15.)+10.);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 rotZ(vec3 p, float angle) {\n\t\n\tmat3 m = mat3(cos(angle), -sin(angle), 0.0,\n\t\t\t\t  sin(angle), cos(angle), 0.0,\n\t\t\t\t  0.0, 0.0, 1.0);\n\t\t\t\t  \n\treturn m * p;\n}\n\n\n/*\nFractal brownian motion\nIs about adding noise together. From book of shaders:\nBy adding different iterations of noise (octaves), where we successively \nincrement the frequencies in regular steps (lacunarity) and decrease the amplitude (gain) \nof the noise we can obtain a finer granularity in the noise and get more fine detail. \nThis technique is called \"fractal Brownian Motion\" (fBM), or simply \"fractal noise\".\n\nFor each octave(iteration): Increase the frequency of the wave(by 2.0) -> Called the lacunarity value.\n\t\t\t\t\t\t\tDecrease the amplitude of the wave(by 0.5) -> Called the gain.\n*/\nfloat fbm(vec2 uv, float seed, int o, float l, float g, float a, float f, bool rot, bool absolute) {\n\tfloat fbm = 0.0;\n\t\n\t//Constant value, octaves is the number of iterations.\n\tint octaves = o;//16;\n\tfloat lacunarity = l;//8.0;\n\tfloat gain = g;//0.85;\n\t\n\t//Initial values, are changed on each ocatve/iteration.\n\tfloat amplitude = a;//0.5;\n\tfloat frequency = f;//10.0;\n    \n    uv += seed;\n\t\n\tfor (int i = 0; i < octaves; i++) {\n        float newVal = amplitude * noise(uv * frequency);\n        \n        if (absolute) newVal = abs(newVal);\n        \n\t\tfbm += newVal;\n\n        if (rot) uv = rotZ(vec3(uv.x, uv.y, 0.0), float(i)).xy;\n        \n\t\tfrequency *= lacunarity;\n\t\tamplitude *= gain;\n\t\n\t}\n\t\n\treturn fbm;\n}\n\n\nfloat logarithmicSpiral(vec2 polarUV, float a, float b) {\n    float len = polarUV.x;\n    float angle = polarUV.y;\n    \n    /*\n        logSpiralAngle is the angle it must be given the length of the vector. It is the logaritmhic spiral formula used above, but rearranged/isolated for the value of angle.\n        Output can go from 0 to infinity. So if we draw a line from origin, then until it crosses the spiral for the 1 time, the anglue value will be\n        somewhere between 0 and 2PI. As soon as the line crosses the spiral the first time, then the angle value must be between 2PI and 4PI.\n        Fromt his value we can know in what revolution it is currently in, 1 rev: 0 to 2PI, 2 rev: 2PI to 4PI.\n        Dividing by 2PI and flooring gives us a neat revolution counter -> 0.0: 1 rev, 1.0: 2 rev...\n    */\n    //float a = 0.59;\n    //float b = 0.25;\n    float logSpiralAngle = log(len/a)/b;\n    //Working solution for infinete revolutions - Without a for loop!\n    float intersectMain = a * pow(e, b * (angle + (PI2*floor(logSpiralAngle/PI2))));\n    //Intersect next revolution\n    float intersectNextRev = a * pow(e, b * (angle + (PI2*floor(logSpiralAngle/PI2+1.0))));\n    float intersectPreviousRev = a * pow(e, b * (angle + (PI2*floor(logSpiralAngle/PI2-1.0))));\n  \n    float fr = min(abs(len-intersectMain), abs(len-intersectNextRev));//min(len - r, len - r2);\n    fr = min(fr, abs(len - intersectPreviousRev));\n    \n    //float d = abs(fr - (maxxi*0.5));//mod(fr, r);\n    float d = fr;\n    \n    return d;\n}\n//Vesica sdf from IQ: https://iquilezles.org/articles/distfunctions2d/\nfloat sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w )\n{\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length( q-h.xy) - h.z;\n}\n\nvec3 galaxy(vec2 uv, vec2 polarUV, vec3 col) {\n    \n    float size = 5.0;\n    float len = polarUV.x*size;\n    float angle = polarUV.y;\n    \n    //SpiralAngle from 0 to infinty\n    //float spiralAngle = angle + (PI2 * floor(len/PI2));\n    float spiralAngle = angle + (PI2 * len/PI2);\n    \n    /* Create different spirals and cut them off at some length */\n    //1. spiral\n    float spiralD = logarithmicSpiral(vec2(len, angle), 0.59, 0.25);\n    spiralD += len * smoothstep(5.5, 8.3, len);\n    //2. spiral\n    float spiralD2 = logarithmicSpiral(vec2(len, angle), 0.41, 0.26);\n    float logSpiralD2Angle = log(len/0.41)/0.26;\n    //Cut of spiral arm at x length\n    spiralD2 += len * smoothstep(5.6, 8.1, len);\n    //3. spiral\n    float spiralD3 = logarithmicSpiral(vec2(len, atan(uv.y, uv.x)), 0.59, 0.25);\n    spiralD3 += len * smoothstep(5.5, 8.0, len);\n    //4. spiral\n    float spiralD4 = logarithmicSpiral(vec2(len, atan(uv.y, uv.x)), 0.41, 0.25);\n    spiralD4 += len * smoothstep(5.0, 7.5, len);\n    \n    //Combine all spirals to single SDF\n    spiralD = min(spiralD, min(spiralD2, min(spiralD3, spiralD4)));\n    \n    //Haze spiralD, make them radius bigger than the spiral with the stars\n    float hazeSpiralD = spiralD;\n    float hazeSpiralArmRadius = 1.4;\n    hazeSpiralD = 1.0-smoothstep(0.0, hazeSpiralArmRadius, hazeSpiralD); \n    \n    //Control distance between each spiral arm, need more blackess between\n    float spiralArmRadius = 0.65;\n    spiralD = 1.0-smoothstep(0.0, spiralArmRadius, spiralD);\n     \n    float starN = fbm(uv, 244.0, 8, 2.0, 0.5, 0.68, 2.7, true, true);\n    float starN2 = fbm(uv, 69.0, 8, 1.6, 0.85, 0.5, 13.0, true, true); \n    float innerBandN = fbm(uv, 539.0, 6, 1.4, 0.85, 0.55, 17.0, true, true);\n    \n    innerBandN = innerBandN * innerBandN * innerBandN;\n    starN = starN * starN * starN * starN;\n    starN2 = starN2 * starN2 * starN2;\n       \n    //galaxyColor is color of the stars in this area\n    float galaxyColorInput = len*0.1 + 499.2 + noise1d(angle*1.0+55.0);\n    vec3 galaxyCol =  hash31(ceil(galaxyColorInput));\n    vec3 nextGalaxyCol = hash31(ceil(galaxyColorInput + 1.0));\n    \n    galaxyCol = mix(galaxyCol, nextGalaxyCol, smoothstep(0.5, 1.0, fract(galaxyColorInput)));\n    \n    galaxyCol *= vec3(1.0, 0.4, 1.74);\n    \n    vec3 starCol = mix(vec3(0.0), galaxyCol, 1.0-exp(starN*50.0));\n    \n    vec3 starCol2 = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), 1.0-exp(starN2*10.0));\n    \n    vec3 combinedStarCol = max(starCol/starCol2, 0.0);\n    \n    //Add main starfield\n    vec3 finalCol = mix(vec3(0.0), combinedStarCol, spiralD);\n    \n    //Background haze color\n    vec3 bgHazeCol = vec3(59.0/255.0, 69.0/255.0, 101.0/255.0);\n    \n    //Add the hazy outline of spirals\n    finalCol += mix(vec3(0.0), bgHazeCol*vec3(1.1, 1.0, 2.0), smoothstep(1.7, 0.33, length(uv)))*0.1;\n    finalCol += mix(vec3(0.0), bgHazeCol*vec3(1.0, 1.2, 1.75), hazeSpiralD*hazeSpiralD*0.12);\n    \n    float vesicaD = sdOrientedVesica(uv, vec2(0.085, -0.085), vec2(-0.085, 0.085), 0.025);\n    \n    vec3 centerCol = vec3(387.0/255.0,252.0/255.0,197.0/255.0);\n    vec3 galaxyCenterCol = 1.0/max(vesicaD, 0.0)*0.005 * (mix(galaxyCol, centerCol, 0.3)*1.0);\n    \n    galaxyCenterCol *= smoothstep(2.0, 0.0, length(uv)); \n    //Add glowing vesica in the middle\n    finalCol += galaxyCenterCol;\n    \n    \n    vec3 backgroundCol = vec3(0.0, 0.0, 0.0);\n    vec3 redCol = vec3(1.5, 0.0, 0.0);\n    vec3 whiteCol = vec3(1.0, 1.0, 1.0)*2.0;\n    //Narrow band of stars located mostly at origin of spiral arms\n    vec3 narrowStarsCol = mix(backgroundCol, redCol, smoothstep(0.1, 0.2, innerBandN));\n    narrowStarsCol = mix(narrowStarsCol, whiteCol, smoothstep(0.2, 0.25, innerBandN));\n    //Add narrow band of stars\n    finalCol += narrowStarsCol * smoothstep(0.7, 0.9, spiralD);\n    \n    return finalCol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv * 2.0) - 1.0;\n    \n    vec3 col = vec3(0.0);\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x *= ar;\n    \n    uv = rotZ(vec3(uv.x, uv.y, 0.0), -iTime*0.018).xy;\n    \n    uv *= 1.3;\n    \n    vec2 polarUV = vec2(length(uv), atan(uv.y, uv.x)+PI);\n    \n    col = galaxy(uv, polarUV, col);\n    \n    //Saturation\n    float grayscale = dot(min(col, 1.0), vec3(0.299, 0.587, 0.114));\n    float saturation = 0.77;\n    col = clamp(mix(vec3(grayscale), col, saturation), 0.0, 1.0);\n    \n    //gamma correction\n    col = pow(col, vec3(.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 144, 144, 229], [231, 231, 253, 253, 386], [388, 388, 412, 412, 544], [546, 546, 568, 568, 706], [708, 708, 740, 740, 873], [876, 961, 983, 983, 1489], [1491, 1491, 1523, 1523, 1651], [1654, 2249, 2349, 2349, 2958], [2961, 2961, 3018, 3018, 4479], [4480, 4551, 4610, 4610, 4875], [4877, 4877, 4923, 4923, 8693], [8695, 8695, 8752, 8802, 9466]], "test": "untested"}
{"id": "DlfBRS", "name": "Gyroid bath With Refraction", "author": "Oman395", "description": "Modified version of my gyroid bath shader that implements (not physically accurate, only includes air-glass transition without glass-air transition, and normals are weird, but whenever I try making it more accurate it looks worse. Still, p happy with it!", "tags": ["raymarching", "refraction", "gyroid", "infill", "3dprinter"], "likes": 3, "viewed": 241, "published": 3, "date": "1693069797", "time_retrieved": "2024-07-30T17:36:47.005530", "image_code": "float getDist(vec3 pos) { return (sin(pos.x) * cos(pos.y) + sin(pos.y) * cos(pos.z) + sin(pos.z) * cos(pos.x)) * 0.5; }\n\nvec3 getNormal(vec3 p) {\n    const vec2 EPSILON = vec2(0.0001,0);\n    vec3 a = vec3(getDist(p + EPSILON.xyy), getDist(p + EPSILON.yxy), getDist(p + EPSILON.yyx));\n    vec3 b = vec3(getDist(p - EPSILON.xyy), getDist(p - EPSILON.yxy), getDist(p - EPSILON.yyx));\n    return normalize(a - b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = vec3((uv - 0.5) * 2.0 * 0.7, iTime * 0.5), dir = normalize(vec3(pos.xy,0.75));\n    pos.xy += (3.0 * 3.14159265 / 4.0) * vec2(sin(pos.z), cos(pos.z)) - vec2(3.14159265 / 2.0, 0);\n    int cnt = 0, passed = 0;\n    for(int i = 0; i < 256; i++) {\n        float d = abs(getDist(pos));\n        if(cnt != 0) cnt--;\n        if(d <= 0.0001 && passed < 2 && cnt == 0) {\n            cnt = 20, passed++;\n            dir = refract(dir, getNormal(pos), 1.0 / 1.4);\n            pos += dir * 0.1 * vec3(1, iResolution.y / iResolution.x, 1);\n        } else if(d <= 0.0001 && cnt == 0) break;\n        pos += dir * d * vec3(1, iResolution.y / iResolution.x, 1);\n    }\n    float c = 16.0 / (pos.z - iTime * 0.5 + 16.0);\n    fragColor = vec4(0.1, 0.7, 1, 1) * c + vec4(0,0.1,0.1,1) * (1.0 - c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 119], [121, 121, 145, 145, 411], [413, 413, 470, 470, 1300]], "test": "untested"}
{"id": "DtXfD7", "name": "Histogram Preserving Blend", "author": "gehtsiegarnixan", "description": "This is a comparison as well as a simple, commented demo on how to preserve contrast when interpolating colors.", "tags": ["test", "mix", "contrast", "lerp", "blend", "interpolation", "variance", "comparison"], "likes": 5, "viewed": 270, "published": 3, "date": "1693066952", "time_retrieved": "2024-07-30T17:36:47.806389", "image_code": "/*\nThis is a simple demo and guide designed to help you understand contrast-preserving \ninterpolation techniques.\n\nThe interpolation between two colors leads to a reduction in contrast, which can \nbecome quite noticeable. To mitigate the diminished contrast, we compare two \nmethods I found on Shadertoy.\n\nThe shader illustrates these two methods standalone functions, with comments and \nreformatting for improved readability. The columns, from top to bottom, showcase:\n1. The alpha parameter utilizing the Viridis Colormap\n2. A toggle between two textures at an alpha value of 0.5\n3. Standard interpolation between the two textures\n4. Histogram-Preserving Blending (by Fabrice Neyret, https://www.shadertoy.com/view/4dcSDr)\n5. Contrast-Aware Blending (by huwb, https://www.shadertoy.com/view/MtcGWs)\n6. Height blend based on lightness\n\nThe Histogram-Preserving Blending is basically the standart everywhere, but it\nproduces sometimes worse results for example when blending grayscale noise. \nI think my ligthness blend is superiour and it doesn't even requiere an additional\ntexture sample and works great in all cases I tried yet.\n*/\n\n// select the texture using an index. Acts like a crude texture array\nvec4 textureArray(int index, vec2 uv) {\n    vec4 color;\n    if (index == 0) {\n        color = texture(iChannel0, uv);\n    } else if (index == 1) {\n        color = texture(iChannel1, uv);\n    } else if (index == 2) {\n        color = texture(iChannel2, uv);\n    } else {\n        color = texture(iChannel3, uv);\n    }\n    return color;\n}\n\n// select the texture using an index. Acts like a crude texture array with mip level\nvec4 textureArray(int index, vec2 uv, float mip) {\n    vec4 color;    \n    if (index == 0) {\n        color = texture(iChannel0, uv, mip);\n    } else if (index == 1) {\n        color = texture(iChannel1, uv, mip);\n    } else if (index == 2) {\n        color = texture(iChannel2, uv, mip);\n    } else {\n        color = texture(iChannel3, uv, mip);\n    }\n    return color;\n}\n\n// hard Edge from switching directly between on or the other\nvec4 twoTextureSwitch(vec4 A, vec4 B, float alpha) {\n    // switch between uvs at halfway point of alpha\n    return (alpha < 0.5) ? A : B;;\n}\n\n// vanilla interpolation of two textures\nvec4 twoTextureLerp(vec4 A, vec4 B, float alpha) {\n     \n     // Interpolation between the textures\n     return mix(A, B, alpha);\n}\n\n// NB: trick published in https://hal.inria.fr/inria-00536064v2\n// deeper conservation: see histogram-preserving here: https://hal.inria.fr/hal-01824773\n// modified version of FabriceNeyret2 https://www.shadertoy.com/view/4dcSDr \nvec4 conrastCorrectBlend(vec4 A, vec4 B, float alpha, int texIndex, vec2 uvA) {\n    \n    // Interpolation between the textures\n    vec4 col = mix(A, B, alpha);\n    \n    // redudant for true alpha with sum 1\n    //float alphaSum = 1.; // alpha + (1.-alpha);\n    \n    // square alphas and add them up\n    // or do this instead dot(vec2(alpha, (1.-alpha), vec2(alpha, (1.-alpha))\n    float squaredAlphaSum = alpha * alpha + (1.-alpha) * (1.-alpha);\n    \n    // sampling mips lowest level to get the mean, could be a constant if known\n    vec4 mean = textureArray(texIndex, uvA, 1000.);\n    \n    // variance restoration with normalization\n    //return mean + (col - alphaSum * mean) / sqrt(squaredAlphaSum); // alphaSum == 1\n    return mean + (col - mean) / sqrt(squaredAlphaSum);\n}\n\n// from huwb https://www.shadertoy.com/view/MtcGWs\nvec4 contrastBlend(vec4 A, vec4 B, float alpha ) {\n     \n    // brightness\n    float Ab = A.x * B.y * A.z;\n    float Bb = B.x * B.y * B.z;\n    \n    // work out blend param based on relative brightness, smoothstep\n    // to increase contrast.\n    float contrastAlpha = smoothstep(0.,1.,2.*Ab/(Ab+Bb));\n    \n    // push our alpha towards the contrastAlpha, but still follow alpha to 0 and 1.\n    \n    // goes to 0 when alpha is near 0 or 1\n    float proximityTo01 = min(alpha,1.-alpha);\n        \n    // powering it up seems to give better results\n    proximityTo01 = pow( proximityTo01, 0.25);\n    \n    // mix between alpha and contrast-aware alpha\n    alpha = mix( alpha, contrastAlpha, proximityTo01);\n    \n    //return vec4(viridis(alpha), 0.);\n    \n    // Interpolation\n    return mix( A, B, alpha );\n}\n\n// Offset weight with height bias by contrast\n// See https://www.desmos.com/calculator/gxhnhzu1cs\nfloat straightHeightWeight (float weight, vec2 heights, float contrast) {\n\n    // apply contrast with offset\n    float heightWeight = weight + contrast * (weight * heights.y - (1.-weight) * heights.x);\n\n    // Ensure the final weight value is clamped to the range [0, 1]\n    return clamp(heightWeight, 0.0, 1.0);\n}\n\n// Applies height interpolation based on the luminosity\nvec4 straightHeightWeight(vec4 A, vec4 B, float alpha) {\n    \n    // Find the brightness of either sample\n    float lightnessA = RGBtoHSV(A.xyz).z;\n    float lightnessB = RGBtoHSV(B.xyz).z;\n    vec2 heights = vec2(lightnessA, lightnessB);   \n    //vec2 heights = vec2(length(A.xyz), length(B.xyz)); // faster and looks just as good\n    \n    // offset the weight with the brightness values\n    alpha = straightHeightWeight(alpha, heights, 1.);\n    \n    // Interpolate the two colors using offset alpha by height blend\n    return mix(A, B, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // square UVs\n    float scale = 9.;\n    vec2 uvA = fragCoord/iResolution.y * scale;\n    \n    // rotate UVs to have two sets of UVs\n    vec2 direction = normalize(vec2(1., -1.));\n    vec2 uvB = mat2x2(direction.y, direction.x, -direction.x, direction.y)*uvA; \n\n    // normalized UV, Alpha.y for spliting up and Alpha.x the interpolation\n    vec2 Alpha = fragCoord / iResolution.xy;\n    \n    // add some animation\n    float aniPeriod = 5.; // in seconds for a full cycle\n    float aniValue = pow(abs(fract(iTime/aniPeriod+.5)-.5)*2.,2.);\n    \n    // slightly increase contrast of alpha.x\n    float Contrast = mix(1., 8., aniValue);\n    Alpha.x = straightContrast(Alpha.x, 1.5); // so small region stays a or b\n    Alpha.x = smoothContrast(Alpha.x, Contrast);  // increases contrast of alpha\n    Alpha.x = clamp(Alpha.x, 0.0, 1.0); // prevents float errors\n    \n    // setup breakup of screen\n    float ComparisonCount = 6.; // how many sections we have\n    float zeroSectionSize = 0.5; // alpha display smaller\n    Alpha.y = 1.-Alpha.y; // invert coordinates\n    float zeroOffset = (zeroSectionSize-1.)/(ComparisonCount-1.);\n    Alpha.y = ((Alpha.y - zeroOffset)/(1.-zeroOffset));\n    float y = floor(Alpha.y*ComparisonCount);\n        \n    // switch textures around to see method on different textures\n    float switchPerid = aniPeriod * 4.0; // in seconds for a full cycle\n    int texIndex = int(4.0 * fract(iTime / switchPerid)); //0-4 values\n    \n    // sample a texture array for the demo, but can be replaced default texture\n    vec4 sampleA = textureArray(texIndex, uvA);\n    vec4 sampleB = textureArray(texIndex, uvB);\n    \n    // add the comparison methods\n    if (y == 0.) {\n        // show the alpha value, with pretty colormap\n        fragColor.xyz = viridis(Alpha.x);\n    } else if (y == 1.) {\n        // hard switch between two texture\n        fragColor = twoTextureSwitch(sampleA, sampleB, Alpha.x);\n    } else if (y == 2.) {\n        // default 2 texture lookup lerp\n        fragColor = twoTextureLerp(sampleA, sampleB, Alpha.x);\n    } else if (y == 3.) {\n        // default 2 texture lookup lerp\n        fragColor = conrastCorrectBlend(sampleA, sampleB, Alpha.x, texIndex, uvA);\n    } else if (y == 4.) {\n        // default 2 texture lookup lerp\n        fragColor = contrastBlend(sampleA, sampleB, Alpha.x);\n    } else if (y == 5.) {\n        // default 2 texture lookup lerp\n        fragColor = straightHeightWeight(sampleA, sampleB, Alpha.x);\n    }\n    \n    // black bars\n    float BorderThickness = 0.04;\n    float ZigzagPattern = abs(fract(Alpha.y*(ComparisonCount))-0.5);\n    fragColor *= vec4(step(ZigzagPattern, 0.5-BorderThickness*0.5)); \n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_____________________GENERIC FUNCTIONS______________________________\n\n// Increases the steepness of Alpha while forcing 0-1 range and 1 sum\n// See desmos graph example (https://www.desmos.com/calculator/dpxa6mytnv)\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInfAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInfAlpha);\n}\n\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Converts an RGB color to an HSV color\nvec3 RGBtoHSV(vec3 rgbColor) {\n    // Constants for the conversion process\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    \n    // Determine the minimum and maximum values between the colors\n    vec4 p = mix(vec4(rgbColor.bg, K.wz), vec4(rgbColor.gb, K.xy), step(rgbColor.b, rgbColor.g));\n    vec4 q = mix(vec4(p.xyw, rgbColor.r), vec4(rgbColor.r, p.yzx), step(p.x, rgbColor.r));\n    float d = q.x - min(q.w, q.y);\n    \n    // Small constant to avoid division by zero\n    float e = 1.0e-10;\n    \n    // Calculate the HSV values\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1137, 1207, 1246, 1246, 1541], [1543, 1628, 1678, 1678, 1997], [1999, 2060, 2112, 2164, 2201], [2203, 2244, 2294, 2343, 2375], [2377, 2607, 2686, 2733, 3385], [3387, 3438, 3488, 3512, 4242], [4244, 4342, 4415, 4450, 4656], [4658, 4714, 4770, 4819, 5261], [5263, 5263, 5320, 5341, 7988]], "test": "untested"}
{"id": "mtsfW7", "name": "Golfed Sphere [307 Chars]", "author": "SnoopethDuckDuck", "description": "Maybe more interesting as a golfing challenge than something to look at\n\nIf anyone knows shorter spheres pls share :)", "tags": ["3d", "sphere", "golf"], "likes": 7, "viewed": 208, "published": 3, "date": "1693059525", "time_retrieved": "2024-07-30T17:36:48.576330", "image_code": "#define Z normalize\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 N = iResolution,             // Normal         \n         P = vec3(U+U-N.xy, 0) / N.y, // Ray origin -> Light direction\n         R = Z(vec3(-P.xy, 1));       // Ray direction\n    \n    // Ray-Sphere intersection\n    // and Cook Torrance lighting (ripped apart)\n    float b = dot(P, R),          \n          r = dot(N = Z(P + R*(sqrt(b*b-dot(P,P) + .4)-b)),R), // dot(N,R)\n          k = pow(1. - r,  5.),               // Fresnel\n          l = max(dot(N, P = Z(1. - P)), 0.), // dot(N,L)\n          h = dot(N, Z(P+R)),                 // dot(N,H) \n          d = 1. - .96*h*h;\n    \n    O = sqrt(l \n             * (.5+.5*N.rgbr) \n             * (1.4 - k - k/d/d/(1.+9.*r)/(1.+9.*l)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 59, 59, 748]], "test": "untested"}
{"id": "DtlBW7", "name": "BINTANG HITAM", "author": "zhonkvision", "description": "Code by Flopine | Edited version by Zhonk Vision\n", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 3, "viewed": 195, "published": 3, "date": "1693031796", "time_retrieved": "2024-07-30T17:36:49.469941", "image_code": "// Code by Flopine | Edited version by Zhonk Vision\n// AN AUDIO REACTIVE SHADER, play the sound in iChannel0\n\n#define ITER 64.\n#define PI 3.141592\n#define megabass (texture(iChannel0, vec2(0.001,0.25)).x)\n\n// Parameters to control the bintang shape\nuniform float shipLength; // Length of the bintang\nuniform float shipWidth;  // Width of the bintang\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,14.1)))*1245.4);}\n// Modify a 2D vector by rotating its components around the origin\nvec2 moda(vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/4.;\n    return vec2(cos(a),sin(a))*l;\n}\n\n// Generate a 2x2 rotation matrix based on an angle\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// Define a sphere shape centered at the origin\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\n// Define a cylinder shape centered at the origin along the x-y plane\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\n// Create a complex structure resembling needles or spikes\nfloat needles(vec3 p)\n{\n    vec3 pp = p;\n    float l_needle = 0.8 - clamp(megabass,0.,0.75);\n    \n    p.xz = moda(p.xz, 2.*PI/7.);\n    float n1 = cyl(p.yz,0.1-p.x*l_needle);\n    \n    p = pp;\n    p.y = abs(p.y);\n    p.y -= 0.1;\n    p.xz = moda(p.xz, 2.*PI/7.);\n    p.xy *= rot(PI/4.5);\n\n    float n2 = cyl(p.yz,0.1-p.x*l_needle);\n    \n    p = pp;\n    float n3 = cyl(p.xz, 0.1-abs(p.y)*l_needle);\n    \n    // Adjust the bintang shape here\n    float alienShip = sphe(p, shipLength) - shipWidth;\n    \n    return min(n3, min(n2, min(n1, alienShip)));\n}\n// Create a combined shape with a spiky ball and needles\nfloat spikyball (vec3 p)\n{\n    p.y -= iTime;\n    p.xz *= rot(iTime);\n    p.yz *= rot(iTime*0.5);\n    float s = sphe(p,.1);\n    return smin(s, needles(p), 2.);\n}\n\n// Define a complex room-like environment using trigonometric functions\nfloat room(vec3 p)\n{\n    p += sin(p.yzx - cos(p.zxy));\n    p += sin(p.yzx/0.5 + cos(p.zxy)/200.)*.5;\n    return -length(p.xz) + 5.;\n}\n\n// Combine the spiky ball and room shapes using the minimum function\nfloat SDF (vec3 p)\n{ \n    return min(spikyball(p),room(p));\n}\n\n// Main rendering function to calculate pixel color and shading\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Generate a dither value based on pixel coordinates\n    float dither = hash21(uv);\n    \n    // Define the camera ray origin and direction\n    vec3 ro = vec3(0.001,0.001+iTime,-3.); \n    vec3 p = ro;\n    vec3 dir = normalize(vec3(uv, 1.));\n    \n    // Initialize shading intensity\n    float shad = 0.;\n    \n    // Raymarching loop\n    for (float i = 0.; i<ITER; i++)\n    {\n        // Calculate signed distance to the scene\n        float d = SDF(p);\n        // Break loop if very close to the surface\n        if(d<0.001)\n        {\n        \tshad = i/ITER;\n            break;\n        }\n        // Adjust distance with dither for randomness\n        d *= 0.9+dither*0.1;\n        // Move along the ray\n        p+=d*dir;\n    }    \n    \n    // Calculate shading color\n    vec3 c = vec3 (shad);\n    \n    // Apply gamma correction and assign color to pixel\n    fragColor = vec4(pow(c,vec3(1.5)),1.0);\n}", "image_inputs": [{"id": 34540, "src": "https://soundcloud.com/oslated/ben-kaczor-alternation-kcz?si=24faeb12faab4ea0accefefabfb21afb&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 374, 374, 424], [425, 492, 522, 522, 648], [650, 702, 722, 722, 765], [767, 767, 808, 808, 879], [881, 929, 959, 959, 979], [981, 1051, 1080, 1080, 1100], [1102, 1161, 1184, 1184, 1708], [1709, 1766, 1792, 1792, 1926], [1928, 2000, 2020, 2020, 2133], [2135, 2204, 2224, 2224, 2265], [2267, 2331, 2388, 2423, 3385]], "test": "untested"}
{"id": "clsBDN", "name": "Perly Dance", "author": "timestamp", "description": "* Gradient Noise\n* Fade-in \n", "tags": ["gradientnoise"], "likes": 8, "viewed": 250, "published": 3, "date": "1693030432", "time_retrieved": "2024-07-30T17:36:50.259829", "image_code": "//\n// Perly Dance\n//\n// (c) timestamp @ shadertoy.com\n//\n// POI\n//  * Gradient noise\n//  * Fade-in\n//\nvoid mainImage(out vec4 C, vec2 I) {\n    C = texelFetch(iChannel0, ivec2(I), 0);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Perly Dance\n//\n// (c) timestamp @ shadertoy.com\n//\n// POI\n//  * Gradient noise\n//  * Fade-in\n//\n\n#define Eps .00001\n#define NEps (2. * Eps)\n#define Pi 3.14159265\n\nfloat sqr(float x) { return x * x; }\nvec2 rot(vec2 p, float a) { return vec2(p.x * cos(a) - p.y * sin(a), p.y * cos(a) + p.x * sin(a)); }\nint idot(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nivec3 bv(int i) { return ivec3(i & 1, (i >> 1) & 1, (i >> 2) & 1); }\n\nvec3 rn(ivec3 v) {\n    const ivec3 p0 = ivec3(3532822529u, 3839940361u, 2165740037u);\n    const ivec3 p1 = ivec3(3847243819u, 2322422897u, 2464623787u);\n    const vec2  c1 = vec2(Pi, Pi * .5) / 2147483648.;\n    v = v ^ 102;\n    vec2 w = vec2(ivec2(idot(v, p0), idot(v, p1))) * c1;\n    w.y *= w.y;\n    return vec3(cos(w.x) * cos(w.y), sin(w.x) * cos(w.y), sin(w.y));\n}\n\nvec3[8] rr;\nivec3 _iv = ivec3(2147483647);\n\nfloat per(vec3 v) {\n    float[8] g;\n    ivec3 iv = ivec3(floor(v));\n    vec3 fv = fract(v);\n    if (iv != _iv) {\n        _iv = iv;\n        for (int i = 0; i < 8; i++) rr[i] = rn(iv + bv(i));\n    }\n    fv *= fv * fv * ((fv * 6. - 15.) * fv + 10.);\n    for (int i = 0; i < 8; i++) g[i] = dot(fv - vec3(bv(i)), rr[i]);\n    return mix(mix(mix(g[0], g[1], fv.x), mix(g[2], g[3], fv.x), fv.y),\n        mix(mix(g[4], g[5], fv.x), mix(g[6], g[7], fv.x), fv.y), fv.z);\n}\n\nfloat f;\nfloat H;\nfloat cut = 1.;\nfloat F = .6;\n\nvec2 map(vec3 p) {\n    float sd0 = (per(p) + H + p.z * .02) * F;\n    float sd = max(abs(sd0) - .005, p.z - cut);\n    vec2 q = abs(fract(p.xz * 8.) / 8. - 1. / 16.);\n    float a = (iTime == 0. ? 1. : clamp(iTime * .33 - 4., 0., 1.));\n    float sd2 = length(q) - (f * .01 + .01) * a;\n    return vec2(max(sd, -sd2), sd0);\n}\n\nvec3 mapN(vec3 p) {\n    const vec2 e = vec2(1, -1) / sqrt(3.) * NEps;\n    vec4 s = vec4(map(p + e.xyy).x, map(p + e.yyx).x, map(p + e.yxy).x, map(p + e.xxx).x);\n    return normalize((s.xzy + s.www) - (s.yxx + s.zyz));\n}\n\nvoid mainImage(out vec4 C, vec2 I) {\n    float f = max(texelFetch(iChannel0, ivec2(0, 0), 0).x * .97,\n                  texelFetch(iChannel1, ivec2(260, 0), 0).x);\n    if (I == vec2(.5)) { C = vec4(f); return; }\n    f = clamp(f * 4. - .8, 0., 1.);\n    H = .25 + (f - .5) * .04 * sqrt(500. / iResolution.y);\n    if (iTime > 0.) {\n        H *= min(1., iTime / 20.);\n        F *= min(1., iTime / 10.);\n    }\n\n    vec3 ro = vec3(-2.4, -5, cut + 1. + cos(iTime * .2));\n    ro.xy = rot(ro.xy, iTime * .1);\n    vec2 sc = (I + I - iResolution.xy) / iResolution.y;\n    vec3 rd = -normalize(ro);\n    vec3 right = normalize(cross(rd, vec3(0, 0, 1)));\n    vec3 up = cross(right, rd);\n    rd = normalize(rd * 6. + right * sc.x + up * sc.y);\n\n    vec2 sd;\n    vec3 p;\n    float i, t = max(0., (cut - ro.z) / rd.z);\n    for (; i < 250. && (sd = map(p = ro + t * rd)).x >= Eps; i++, t += sd.x);\n    vec3 n = mapN(p);\n\n    vec3 dif = vec3(1);\n    if (sd.y < 0.) dif = vec3(0.541, 0.000, 0.188);\n    if (fract(p.z * 4.) < clamp((iTime-7.) * .25 * .07, 0., .07)) dif = vec3(0.251, 0.016, 0.443);\n    if (p.z >= cut - Eps) dif =  vec3(0.251, 0.016, 0.443); //  vec3(0.784, 0.149, 0.910);\n    if (iTime > 0. && p.z < 2. - iTime * .3) dif = vec3(0.251, 0.016, 0.443);\n    vec3 farC = f > .95 ? vec3(1., 0., 0.149) : vec3(0);\n    dif = mix(dif, farC, min(1., sqr(t / 20.)));\n\n    vec3 ld = normalize(vec3(-ro.y, ro.x, 7));\n    float lum = sqr(cos(n.z) * .4 + 1.2);\n    lum *= max(.1, dot(ld, n));    \n    C.xyz = pow(lum * dif, vec3(1. / 2.2));\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 102, 138, 138, 188]], "test": "untested"}
{"id": "dtffDM", "name": "Simulation vs Prediction", "author": "wyatt", "description": "Prediction vs Simulation of field arising from arbitrary signal carrying wire.", "tags": ["maxwell", "wire", "em"], "likes": 16, "viewed": 330, "published": 3, "date": "1692997404", "time_retrieved": "2024-07-30T17:36:51.135487", "image_code": "Main {\n    float _ = .01;\n    if (true) {\n        vec2 r = U-vec2(.5,.55)*R;\n        vec2 u = normalize(r);\n        float l = length(r);\n            float x = ((float(iFrame-10)-sqrt(mu*eps)*2.*l)/60.);\n         float dj= eps*(f(x)+df(x));\n\n         Q += .2*vec4(\n             (dj)*u.y,\n            -(dj)*u.x,\n            mu*df(x),\n            1\n        )/(l);\n    }\n    if (true) {\n        vec2 r = U-vec2(.5,.45)*R;\n        vec2 u = normalize(r);\n        float l = length(r);\n            float x = ((float(iFrame-10)-sqrt(mu*eps)*2.*l)/60.);\n         float dj= eps*(f(x)+df(x));\n\n         Q += .2*vec4(\n             (dj)*u.y,\n            -(dj)*u.x,\n            mu*df(x),\n            1)/(l);\n    }\n      \n    if (true) {\n        vec2 r = U-vec2(.4,.3)*R;\n        vec2 u = normalize(r);\n        float l = length(r);\n        float x = ((float(iFrame-10)-sqrt(mu*eps)*2.*l)/60.);\n        vec2 m = g(x);\n        vec2 dm = dg(x)+ddg(x);\n        Q += .25*vec4(\n            vec2(u.y,-u.x)*dm.x*u.y+\n            vec2(-u.y,u.x)*dm.y*u.x+\n            35.*(+2.*m/l-4.*u*dot(u,m)/l)\n            ,\n            (u.y*dm.x-u.x*dm.y),\n            1.\n        )/(15.+l);\n    }\n    vec2 u = U;\n    u -= .5*R;\n    float a = -3.+1.*iTime;\n    u *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    if (sign(u.x)<0.)\n        Q = A(U);\n    //Q.z *= 0.;\n    Q = .5+Q;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define mu 1.\n#define eps 1.\n#define pi 3.141592659\n\nfloat f (float x) {\n    // Change the input signal here!\n    return 10.*smoothstep(0.,1.,x)*asin(.9*sin(5.*x+10.*sin(.3*x)));\n}\nfloat df (float x) {\n    float e = .1;\n    return (f(x+e)-f(x-e))/(2.*e);\n}\nfloat ddf (float x) {\n    float e = .1;\n    return (df(x+e)-df(x-e))/(2.*e);\n}\n\n\nvec2 g (float x) {\n    // Change the input signal here!\n    \n    return 4.*smoothstep(0.,1.,x)*vec2(sin(2.*x+3.*sin(.2*x)),cos(2.*x+3.*sin(.2*x)));\n}\nvec2 dg (float x) {\n    float e = .1;\n    return (g(x+e)-g(x-e))/(2.*e);\n}\nvec2 ddg (float x) {\n    float e = .1;\n    return (dg(x+e)-dg(x-e))/(2.*e);\n}", "buffer_a_code": "Main {\n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    if (iFrame%2==0) {\n        // dB/dt = -curl E\n        Q.x -= .5/mu*(n.z-s.z);\n        Q.y += .5/mu*(e.z-w.z);\n    } else {\n        // dE/dt = curl B - j\n        Q.z -= .5/eps*(n.x-s.x-e.y+w.y) - Q.w;\n    }\n    //Q.w -= Q.z;\n    Q.w = 0.;\n    if (length(U-vec2(.5,.55)*R)<2.) Q.w += f((float(iFrame)/60.))/10.;\n    else if (length(U-vec2(.5,.45)*R)<2.) Q.w += f((float(iFrame)/60.))/10.;\n    else Q.w = 0.;\n    \n    \n    if (length(U-vec2(.4,.3)*R)<2.) \n        Q.xy = g((float(iFrame)/60.));\n    \n    if (U.x<50.||U.y<50.||R.x-U.x<50.||R.y-U.y<50.)\n        Q *= .98;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtffDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cll3zf", "name": "Face dots", "author": "z0rg", "description": "Party publish, code is not clean, it's meant to be used with a specific camera setup\nTo see what it does with the proper setup https://www.instagram.com/p/CwY6HREoIuS/\n", "tags": ["zef"], "likes": 9, "viewed": 1858, "published": 3, "date": "1692996663", "time_retrieved": "2024-07-30T17:36:51.947317", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    \n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 80\n#define GLOW_DISTANCE 0.05\n#define GLOW_POW 1.1\n#define GLOW_OPACITY 5.76\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    vec2 rep = vec2(.07);\n    vec2 id = floor((p.xz+rep*.5)/rep)-rep*.5;\n    //id *= .5;\n    p.xz = mod(p.xz+rep*.5,rep)-rep*.5;\nfloat h = pow(texture(iChannel2, id*.004-.5).x,1.5)*6.5*(1.-sat(pow(abs(id.x*.05), 2.))*.96);\n    //h -= h*sin(iTime+(id.x+id.y)*.1)*.2-.02;\n    \n    float shape = _cube(p-vec3(0.,-h*2.,0.), vec3(mix(0.01,.005, 1.-sat(h*3.))));\n    \n    //acc = _min(acc, vec2(-p.y-h, 0.));\n    acc = _min(acc, vec2(shape, 0.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 10.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    uv.x *= -1.;\n    float t = iTime*.5;\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(sin(iTime*.5)*0.,-9.,-3.);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        //col = n*.5+.5;\n        col = mix(vec3(1.000,0.078,0.800)*(1.-sat(length(p.xz*.5-.25)-.5)), vec3(0.094,0.604,0.545), sat(-p.y));\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    //vec2 off = .75*(vec2(rand(), rand())-.5)*2.*1./iResolution.x;\n    vec3 col = rdr(uv);\n    \n    vec2 off = vec2(1., -1.)/(iResolution.x*1.5);\n\n    if (true)//diff > 0.3) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    col *= 1.9/(col+1.);\n    //col = pow(col, vec3(.4545));\n    col = sat(col);\n//    col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .3);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cll3zf.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1087]], "test": "untested"}
{"id": "dlfBWM", "name": "ambient clouds", "author": "niclasvoysys", "description": "Ambient clouds", "tags": ["noise", "clouds", "fbm"], "likes": 5, "viewed": 194, "published": 3, "date": "1692991505", "time_retrieved": "2024-07-30T17:36:52.784080", "image_code": "\nfloat random(in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Based on https://thebookofshaders.com/13/\n#define NUM_OCTAVES 5\nfloat fbm(in vec2 _st, float factor) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for(int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5 * 12.0 * 0.1 + (0.07 * sin(10.0 * factor + 0.32));\n    }\n    return v;\n}\n\n// Based on https://thebookofshaders.com/13/\n// #define NUM_OCTAVES 5\nfloat fbm2(in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for(int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat fbm_mod(vec2 st) {\n    vec2 q = vec2(0.);\n    q.x = fbm2(st + 0.00 * iTime);\n    q.y = fbm2(st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm2(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * iTime);\n    r.y = fbm2(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * iTime);\n\n    float f = fbm2(st + r);\n\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n\n    float x_sample = uv.x * 512.0;\n    int x = int(x_sample);\n\n    float dist = 1.0 - abs(1.0 - uv.x);\n    dist = smoothstep(0.0, 1.0, dist);\n\n    float scale = 0.1;\n    \n    const float noise_amount = 1.0;\n\n    float disturbance = abs(noise(uv.xy)) * noise_amount * 0.1;\n\n    float modifier = scale;\n    modifier = modifier * dist;\n    modifier = modifier * disturbance * 0.3;\n\n    col = mix(col, vec3(0.66667, 1.0, 1.0), modifier);\n\n    col = mix(col, vec3(0.98, 0.54, 0.09), 0.3 * modifier);\n\n    float f = fbm_mod(uv.xy);\n\n    col = mix(col, vec3(0.98, 0.54, 0.09), f * f);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 105], [107, 185, 211, 211, 570], [639, 639, 677, 677, 1044], [1046, 1116, 1141, 1141, 1458], [1460, 1460, 1484, 1484, 1769], [1771, 1771, 1828, 1828, 2510]], "test": "untested"}
{"id": "DtfBD7", "name": "Distorsi Harmoni", "author": "zhonkvision", "description": "The name \"Harmonic Distortions\" gets to the heart of the code, in which audio harmonics and fractal distortions work together to make a world that looks both harmonious and messed up.", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 4, "viewed": 201, "published": 3, "date": "1692988182", "time_retrieved": "2024-07-30T17:36:53.624832", "image_code": "// original code by shadertoyjiang\n// edited by Zhonk Vision\n// Simplex 2D noise function\nvec3 permute(vec3 x) {\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\n// Hash function\nfloat s(vec2 v) {\n    const vec4 C = vec4(0.511324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(8.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// Rotation function with audio interaction\nvec2 rotate(vec2 p, float a, float audioAmplitude) {\n    float c = cos(a + audioAmplitude * 0.1); // Adjust the multiplier as needed\n    float s = sin(a + audioAmplitude * 0.1); // Adjust the multiplier as needed\n    return p * mat2(c, s, -s, c);\n}\n\n\n// Fractal shape function\nfloat fractalShape(vec2 u, float t, float audioAmplitude, float rotationSpeed) {\n    float n = sin(u.x) * cos(u.y);\n    float b;\n    \n    u = abs(u * 2.0);\n    b = u.x;\n    \n    vec2 a = vec2(2.0 - u);\n    \n    float param1 = 0.25 + audioAmplitude * 0.9; // Adjust the multiplier as needed\n    float param2 = 0.62 + audioAmplitude * 0.9; // Adjust the multiplier as needed\n    \n    for (int i = 0; i < 15; i++) {\n        a += u + cos(length(u));\n        u.y += sin(a.x - b - 0.5 * t) * param1;\n        u.x += sin(a.y + t) * param2;\n        u -= (u.x + u.y) - n;\n        a.x += u.x;\n    }\n    \n    return length(u) * 0.1;\n}\n\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n    vec2 R = iResolution.xy;\n    vec2 u = (fragCoord * 2.0 - R) / R.y * 2.0 - vec2(0.0, 1.3);\n    u = u.yx;\n    \n    float t = 1.93 + iTime * 0.5;\n    \n    // Get the audio amplitude from the input texture\n    float audioAmplitude = texture(iChannel0, vec2(0.1)).r;\n    \n    // Calculate the fractal shape value\n    float fractalValue = fractalShape(u, t, audioAmplitude, 0.5);\n    \n    // Calculate the rotation angle based on the audio amplitude for medium frequency\n    float rotationAngle = audioAmplitude * 0.5; // Adjust the multiplier as needed\n    \n    // Apply rotation to the point\n    u = rotate(u, rotationAngle, audioAmplitude);\n    \n    // Define parameters to control color change with audio interaction\n    vec3 lowFrequencyColor = vec3(0.2, 0.0, 1.0); // Purple color for low frequency\n    vec3 highFrequencyColor = vec3(1.0, 0.2, 0.8); // Pink color for high frequency\n    \n    // Calculate the color gradient based on the audio amplitude\n    vec3 color = mix(lowFrequencyColor, highFrequencyColor, audioAmplitude);\n    \n    // Mix color gradient with black based on the fractal value\n    vec3 finalColor = mix(vec3(0.0), color, fractalValue);\n    \n    O = vec4(finalColor, 1.0);\n}\n\n\n\n\n\n\n", "image_inputs": [{"id": 34539, "src": "https://soundcloud.com/sentimony/psydewise-crystalized-mind?si=ed6c3028d9ec4d03a3a86315bc2cb162&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 90, 112, 112, 161], [163, 180, 197, 197, 1037], [1039, 1083, 1135, 1135, 1331], [1334, 1360, 1440, 1440, 1982], [1984, 1984, 2031, 2031, 3231]], "test": "untested"}
{"id": "DlByW1", "name": "Screensaver 2023", "author": "morimea", "description": "Evolution of my old shader, that on right top, but we in 2023 now.\n\n\n[b]P.S. Fabrice please dont waste your time on this my horrible code... [/b]", "tags": ["2d", "animation", "console"], "likes": 32, "viewed": 708, "published": 3, "date": "1692985306", "time_retrieved": "2024-07-30T17:36:54.508469", "image_code": "\n// Created by Danil (2023+) https://cohost.org/arugl\n\n// License - CC0 or use as you wish\n\n// self https://www.shadertoy.com/view/DlByW1\n\n\n#define iTime (iTime+78.)\n\n\n// using FabriceNeyret2 runes (simplified version) \n// https://www.shadertoy.com/view/4ltyDM\n\n//--------------------------------------\n\n// --- glyphs simplified from \"runes\" by otaviogood. \n// https://shadertoy.com/view/MsXSRn - original is CC0\n\nfloat line(vec2 p, vec2 a,vec2 b) {\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n\treturn length(p - b * h);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Rune(vec2 U, vec2 seed, float px)\n{\n\tfloat d = 1e5;\n    float h = hash12(seed.xy*33.);\n    int rn = int(h*h*h*6.);\n    for (int i = 0; i < 1+rn; i++)\n    {\n        vec4 pos = vec4(hash22(seed).xy,hash22(seed+1.).xy );\n        seed += 2.;\n        pos = fract(pos * 128.);\n        if (i == 0) pos.y = .0;\n        if (i == 1) pos.x = .999;\n        if (i == 2) pos.x = .0;\n        if (i == 3) pos.y = .999;\n        vec4 snaps = vec4(2, 3, 2, 3);\n        pos = ( floor(pos * snaps) + .5) / snaps;\t\n        d = min(d, line(U, pos.xy, pos.zw + .001) );\n    }\n\treturn 1.-smoothstep(40./360.-px,40./360.,d);\n}\n//--------------------------------------\n\n\n\n\n\n\n\n// right top\n\n//--------------------------------------\n// from my old shader https://www.shadertoy.com/view/4lKyDd\n// updated Fabrice version\n\nvoid mainImage_rt(out vec4 O,vec2 u){\n    O=vec4(0.);\n    vec2 T =  1./vec2(62.5,31.),\n         R = iResolution.xy,\n         U = (u -.5*R) / R.y,\n         p = mod( U-T/2., T) - T/2.,\n         r = R / R.y, c=r/T;\n    float t = iTime*4.+14.;\n    int x = int(c),\n        i = int( t*8. + 3.5*( cos(t/1.5) - cos(t) ) ) % ( x*int(c.y) );\n    r = vec2( i%x, i/x ) - ceil( (r/2. + vec2(U.x,-U.y) ) / T );\n    r.y>0. || r.y==0. && r.x>0.\n       ? O += 1. - ( .98 < fract(1e4*sin(dot(ceil(U/T-.5),vec2(591,154))))\n                        ? p = abs(p), max( max(p.x,p.y)-.0051, min(p.x,p.y) )\n                        : length(p+T*vec2(0.,.25)) - .001\n                   ) / .003\n       : O;\n}\n//--------------------------------------\n\n\n\n\n\n// left bot\n\n//--------------------------------------\n\nvoid mainImage_lb( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 res=iResolution.xy/iResolution.y;\n    vec2 uv=fragCoord/iResolution.y-0.5*res;\n    \n    float px = 1.5/iResolution.y;\n    vec4 c=vec4(0.);\n    \n    float sc = 25.;\n    vec2 tuv = (uv+res*0.5)*sc;\n    vec2 lid = floor(tuv);\n    vec2 alid = floor(res*sc);\n    vec2 olid = lid;\n    tuv = fract(tuv)-0.5;\n    \n    float t = iTime*0.1+22.51;\n    float x = step(tuv.y+0.35,0.)*step(0.,abs(tuv.x+0.5)-0.15);\n    x*=step(fract(t*9.85+(lid.x-lid.y+alid.y*2.)*0.33),(olid.y<0.5?0.65:0.25)-0.15*sin(lid.x*5.35));\n    float ttl = t + .4*(cos(t/1.5) - cos(t));\n    lid.y=-lid.y+2.*alid.y;\n    lid.y+=floor(ttl);\n    ttl = fract(ttl);\n    float s = 0.;\n    float r = smoothstep(0.,px*sc,length(tuv)-0.35);\n    float vid = mod(lid.y,12.);\n    if(vid>0.5){\n        vec2 lp = tuv;\n        s = 1.-max(smoothstep(0.,px*sc,min(abs(lp.y)*1.75, abs(-abs(lp.y)+abs(lp.x*1.5)))-0.065),r);\n        bool ra = cos(lid.x*0.15)>-0.75;\n        bool rb = !ra&&cos(lid.x*1.5)>-0.95&&floor(mod(lid.y,4.))!=0.;\n        bool rc = ra&&cos(lid.x*0.22)<-0.05&&cos(lid.x*4.80)>-0.0&&sin(lid.y*0.57+lid.x*0.33)<-0.05;\n        float h = hash12(lid.xy*33.);\n        ra=ra&&(vid>=mod(lid.x+1.,15.)*4.||mod(lid.x-15.,30.)>4.)&&floor(mod(lid.y,4.))==1.+floor(mod(lid.y,12.)/4.);\n        vec2 tid = lid;\n        if(rb){\n            tid.y = floor(mod(tid.y/1.65,3.))+10.*floor((tid.y/3.));\n            bool rb1 = cos(lid.x*1.5)>0.75;\n            if(rb1){\n                tid.y += 33.*(1.-abs(sign(floor(mod(lid.y,4.))-2.)));\n            }\n        }\n        bool rg = ra||rb||rc;\n        s = (lid.x>1.&&lid.x<13.)?s*step(lid.x-1.,vid):((lid.x>0.&&lid.x<14.)?\n            (1.-r)*step(abs(lp.x)-0.065,0.)+step(sign(lid.x-5.)*lp.x-0.065,0.)*step(abs(lp.x)-0.065*3.,0.)*step(abs(abs(lp.y)-0.5+0.065*2.)-0.065,0.):\n            (rg?Rune(lp+0.5, tid, 1./200.*sc):0.));\n        if(olid.y==1.&&lid.x>13.&&rg){float tdx=(alid.x+13.)*smoothstep(0.,.8,ttl);s=mix(x*(step(olid.x-3.,max(13.,tdx))),s,step(olid.x,tdx));}\n        else if(olid.y==0.){float tx=floor(14.*smoothstep(.4+0.15*sin(lid.y*2.33),.6,ttl*ttl));s=lid.x==tx?x:(lid.x<14.?s*step(lid.x,tx):0.);}\n    }else{\n        s = 1.-max(smoothstep(0.,px*sc,abs(abs(tuv.y)+tuv.x)-0.065),r);\n        if(olid.y<0.5)s*=step(0.55,ttl);\n        vec2 tid = lid;\n        tid.y=tid.y*step((sin(tid.x*0.15)+2.*cos(tid.x*0.75)),0.);\n        bool ra = step(tid.x,8.)>0.5;\n        bool rb = step(10.,tid.x)*step(tid.x,12.+mod(lid.y,7.))>0.5;\n        bool rg = ra||rb;\n        s=lid.x>0.5?(rg?Rune(tuv+0.5, tid, 1./200.*sc):0.):s;\n        if(olid.y<0.5){float ttl=rg||ttl<0.65?smoothstep(.3,.65,ttl*ttl):((alid.x-2.)/alid.x);float ts=step(olid.x,alid.x*ttl);s=(s*ts+step(0.01,ttl)*x*(1.-ts)*step(olid.x-1.,alid.x*ttl));}\n    }\n    s*=step(72.,lid.y);\n    c=vec4(clamp(s,0.,0.88));\n    \n    fragColor = vec4(c.rgb,1.0);\n}\n//--------------------------------------\n\n\n\n\n//left top\n\n//--------------------------------------\n// Rune reused from above\n\nvoid mainImage_lt( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 res=iResolution.xy/iResolution.y;\n    vec2 uv=fragCoord/iResolution.y-0.5*res;\n    \n    float px = 1.5/iResolution.y;\n    vec4 c=vec4(0.);\n    \n    float sc = 25.;\n    vec2 tuv = (uv+res*0.5)*sc;\n    vec2 lid = floor(tuv);\n    vec2 alid = floor(res*sc);\n    vec2 olid = lid;\n    tuv = fract(tuv)-0.5;\n    \n    float s = 0.;\n    float r = smoothstep(0.,px*sc,length(tuv)-0.35);\n    \n    float t = iTime*0.075+0.005;\n    float x = step(tuv.y+0.35,0.)*step(0.,abs(tuv.x+0.5)-0.15);\n    float l = step(abs(tuv.x)-0.075,0.)*(1.-r);\n    x*=step(fract(t*17.85+(lid.x-lid.y+alid.y*2.)*0.33),(olid.y<0.5?0.65:0.25)-0.15*sin(lid.x*5.35));\n    \n    float ttl = t + .4*(cos(t/1.5) - cos(t));\n    lid.y=-lid.y+2.*alid.y;\n    lid.y+=25.+26.*floor(ttl/5.);\n    ttl = fract(ttl/5.);\n    \n    vec2 lp = tuv;\n    float ra = step(lid.x,0.)*step(25.,mod(lid.y,26.));\n    s = ra*(1.-max(smoothstep(0.,px*sc,abs(abs(lp.y)+lp.x)-0.065),r));\n    float a = cos(lid.x*2.25+lid.y*11.33);\n    float b = sin((lid.x*.025+16.*sin(lid.y*.33)));\n    float rb = (1.-ra)*step(0.5,0.5+(0.5*a+0.5*b)+b*3.*sin(lid.y*.33));\n    b = sin(lid.x*.25+0.6);\n    ra=(1.-ra)*step(0.5,0.5+0.5*a+0.6*b)*step(lid.x,18.)*step(25.,mod(lid.y,26.));\n    \n    float rc=step(mod(lid.y,26.),4.)*(1.-step(4.,mod(lid.y,26.))*step(9./alid.x,abs(lid.x/alid.x-0.5)));\n    rb*=(1.-rc)*step(mod(lid.y,26.),17.);\n    \n    rc*=step(abs(lid.x/alid.x-0.5),7./alid.x);\n    \n    float rd = (1.-rc)*step(abs(lid.x/alid.x-0.5),8./alid.x)*step(mod(lid.y,26.),4.);\n    rc*=1.-step(abs(lid.x-alid.x*0.5)-2.*abs(mod(lid.y+6.,26.)-8.),0.);\n    \n    vec2 tid = lid;\n    \n    lp.x=mix(lp.x,-lp.x,step(tid.x-alid.x*0.5,0.));\n    tid=mix(tid,vec2(abs(tid.x-alid.x*0.5),floor(tid.y/6.)),rc);\n    s += mix(Rune(lp+0.5, tid, 1./200.*sc)*(rb+ra+rc),l,rd);\n    \n    \n    ra = step(lid.x,2.);\n    rb = (1.-ra)*step(lid.x,3.)+step(lid.x,25.)*step(25.,lid.x);\n    rc = step(26.,lid.x);\n    rd = (1.-step(mod(lid.y,26.),17.))*step(mod(lid.y,26.),24.);\n\n    float trb = rb;\n    float trd = rd;\n    float tra = ra;\n    float xs = step(abs(lp.x),0.45)*step(abs(lp.y),0.45)*(1.-(step(lid.x,3.)+step(25.,lid.x)));\n    \n    ra = step(0.03,ttl);\n    float tlp = 0.4*smoothstep(0.3,0.35,ttl)+0.3*smoothstep(0.05,0.056,ttl)+0.2*smoothstep(0.1,0.13,ttl)+0.1*smoothstep(0.2,0.27,ttl);\n    float tlx = smoothstep(0.37,0.995,ttl);\n    s*=step(mod(lid.y+1.,26.),floor(tlp*18.));\n    \n    rb = step(ttl,0.03);\n    rc = step(mod(lid.y,26.),23.);\n    s*=max(rc,step(lid.x,floor(smoothstep(0.,0.03,ttl)*16.)));\n    s+=(1.-rc)*rb*x*step(lid.x-1.,floor(smoothstep(0.,0.03,ttl)*16.))*step(floor(smoothstep(0.,0.03,ttl)*16.),lid.x-1.);\n    \n    rd = step(mod(lid.y+1.,26.),floor(tlp*18.)+floor(tlx*6.));\n    rc = step(mod(lid.y+2.,26.),floor(tlp*18.)+floor(tlx*6.));\n    \n    tid = lid;\n    tid.y = mix(tid.y,mix(min(4.,floor(fract(tlx*6.)*11.))/4.,1.,rc),tra);\n    float os = mix(Rune(lp+0.5, tid, 1./200.*sc)*(tra+step(27.,lid.x)*step(-0.5,sin(lid.x*1.25)))*trd,l*trd,trb);\n    s+=os*rd;\n    s+=xs*step(lid.x-3.,mix(fract(tlx*6.)*50.,50.,rc))*rd*step(19.,mod(lid.y+1.,26.));\n    s*=1.-step(mod(lid.y,26.),24.)*step(23.,mod(lid.y,26.));\n    s+=ra*x*step(lid.x,0.)*step(mod(lid.y,26.),floor(tlp*18.)+floor(tlx*6.))*step(floor(tlp*18.)+floor(tlx*6.),mod(lid.y,26.));\n    \n    c=vec4(clamp(s,0.,0.88));\n    \n    fragColor = vec4(c.rgb,1.0);\n}\n//--------------------------------------\n\n\n\n\n//right bot\n\n//--------------------------------------\n// Rune reused from above\n\n\nvoid mainImage_rb( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 res=iResolution.xy/iResolution.y;\n    vec2 uv=fragCoord/iResolution.y-0.5*res;\n    \n    float px = 1.5/iResolution.y;\n    vec4 c=vec4(0.);\n    \n    float sc = 25.;\n    vec2 tuv = (uv+res*0.5)*sc;\n    vec2 lid = floor(tuv);\n    vec2 alid = floor(res*sc);\n    vec2 olid = lid;\n    tuv = fract(tuv)-0.5;\n    \n    float s = 0.;\n    float r = smoothstep(0.,px*sc,length(tuv)-0.35);\n    \n    float t = iTime*0.24+22.51;\n    float x = step(tuv.y+0.35,0.)*step(0.,abs(tuv.x+0.5)-0.15);\n    x*=step(fract(t*4.85+(lid.x-lid.y+alid.y*2.)*0.33),(olid.y<0.5?0.65:0.25)-0.15*sin(lid.x*5.35));\n    float ttl = t + .4*(cos(t/1.5) - cos(t));\n    lid.y=-lid.y+2.*alid.y;\n    lid.y+=floor(ttl);\n    ttl = fract(ttl);\n    \n    float l = (1.-r)*step(abs(tuv.x)-0.065,0.)+step(sign(lid.x-1.)*tuv.x-0.065,0.)*step(abs(tuv.x)-0.065*3.,0.)*step(abs(abs(tuv.y)-0.5+0.065*2.)-0.065,0.);\n    \n    float ra = (step(lid.x,0.)+step(3.,lid.x)*step(lid.x,3.));\n    float rb = (step(1.,lid.x)*step(lid.x,3.));\n    float rc = step(1.,olid.y);\n    \n    s=l*ra;\n    \n    vec2 tid = lid;\n    tid.y = mix(tid.y,mod(tid.y*5.,20.),rb);\n    s+=Rune(tuv+0.5, tid, 1./200.*sc)*(1.-ra)*step((tid.x+30.*(0.5+0.5*sin(tid.y*2.33))),alid.x);\n    \n    s*=step(72.,lid.y)*rc*max(step(2.,olid.y),step(lid.x,3.+alid.x*step(0.015,ttl*ttl)));\n    s+=x*step(lid.x,0.)*(1.-rc);\n    \n    c=vec4(clamp(s,0.,0.88));\n    \n    fragColor = vec4(c.rgb,1.0);\n}\n\n\n//--------------------------------------\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    ivec2 tid = ivec2(uv*2.);\n    \n    float m = 2.;\n    if(iMouse.z>0.){\n        m=1.;\n        tid = ivec2(iMouse.xy/iResolution.xy*2.);\n    }\n    \n    if(tid==ivec2(0,0)){mainImage_lb(fragColor, fract(uv*m)*iResolution.xy);}\n    \n    else{if(tid==ivec2(0,1)){mainImage_lt(fragColor, fract(uv*m)*iResolution.xy);}\n    else{if(tid==ivec2(1,0)){mainImage_rb(fragColor, fract(uv*m)*iResolution.xy);}\n    else mainImage_rt(fragColor, fract(uv*m)*iResolution.xy);}\n    }\n    \n    fragColor.a = 1.;\n    \n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlByW1.jpg", "access": "api", "license": "cc0-1.0", "functions": [[414, 414, 449, 449, 547], [549, 549, 570, 570, 703], [705, 705, 727, 727, 844], [846, 846, 887, 887, 1452], [1644, 1644, 1681, 1681, 2325], [2427, 2427, 2487, 2487, 5298], [5424, 5424, 5484, 5484, 8823], [8951, 8951, 9011, 9011, 10417], [10464, 10464, 10521, 10521, 11062]], "test": "untested"}
{"id": "clffDM", "name": "Radar Sweeper", "author": "Falafel", "description": "A radar sweep. can be customized a bit.", "tags": ["radar", "circular", "sweep", "military", "battleship"], "likes": 1, "viewed": 175, "published": 3, "date": "1692983349", "time_retrieved": "2024-07-30T17:36:55.305338", "image_code": "\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 finalColor = vec3(0.0);\n    \n    // Speed of sweeps. The inner sweep will probably look shit if you don't adjust the values below\n    float innerSweepSpeed = 4.;\n    float outerSweepSpeed = .62;\n   \n    // Background sweep\n    finalColor.y = palette(uv.x * 0.1 - iTime * outerSweepSpeed + .25).y * 0.2;\n    \n    if (length(uv) <= 1.1) {\n       \n        // Outer circle\n        if (length(uv) >= 1.04) {\n            finalColor.y += palette(length(uv) * 15. + .53).y;\n        }\n        \n        if (length(uv) <= 1.06) {\n            // Vertical line\n            if (uv.x < .015 && uv.x > -.015) {\n            finalColor.y += palette(uv.x * 30. + .6).y * .8;\n            }\n            // Horizonal line\n            if (uv.y < .015 && uv.y > -.015) {\n                finalColor.y += palette(uv.y * 30. + .6).y * .8;\n            }\n            // Smaller inside circles\n            float temp = palette(length(uv) * 4.5 + .53).y;\n            finalColor.y += .2 + pow(temp, 100.) * .6;\n            \n            // Circular sweep. Don't recommend trying to change this, it's a pain.\n            vec2 d = vec2(sin(innerSweepSpeed * iTime), cos(innerSweepSpeed * iTime)) * length(uv);\n            vec2 d2 = vec2(sin(innerSweepSpeed * (iTime - 0.4)), cos(innerSweepSpeed * (iTime - 0.4))) * length(uv);\n            float val = length(d - uv) / length(uv);\n            float val2 = length(d2 - uv) / length(uv);\n            if (1./val > .45 && val2 > 1.8) {\n                finalColor.y += palette(log(val * 0.4 + 0.83)).y;\n            }\n        }\n    }\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clffDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 45, 70, 70, 254], [257, 257, 314, 314, 1972]], "test": "untested"}
{"id": "clsfD4", "name": "Day 1345", "author": "jeyko", "description": "poto", "tags": ["pathtracing", "monochrome", "mdtmjvm"], "likes": 16, "viewed": 369, "published": 3, "date": "1692982612", "time_retrieved": "2024-07-30T17:36:56.484188", "image_code": "// Fork of \"Day 1344\" by jeyko. https://shadertoy.com/view/clsfW8\n// 2023-08-25 08:31:43\n\n// Fork of \"Day 60smth WIP\" by jeyko. https://shadertoy.com/view/7tjXWd\n// 2023-08-24 08:52:32\n\n// box intersection from IQ\n// agx from https://www.shadertoy.com/view/cd3XWr\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C= max(texture(iChannel1,U/R),0.);\n    //C = min(C,0.95);\n    \n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)\n#define NO_INTERSECTION -1.123456\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n#define iTime (iTime + 18.)\n\nuint seed = 111425u;\n\nuint hash_u(uint _a) {\n   uint a = _a;\n   a ^= a >> 16;\n   a *= 0x7feb352du;\n   a ^= a >> 15;\n   a *= 0x846ca68bu;\n   a ^= a >> 16;\n   return a; \n}\n\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 4.;  // max display brightness\n    const float a = 2.5;  // contrast\n    const float m = 0.2; // linear section start\n    const float l = 0.;  // linear section length\n    const float c = 1.3; // black\n    const float b = 0.;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat r11(float g){return fract(sin(g*12.5)*4.5);}\n\nvec3 temp_norm;\nfloat boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out bool inters_inside) {\n    //boxSize -= 0.004;\n    // convert from ray to box space\n\tvec3 rdd = (vec4(rd,0.)).xyz;\n\tvec3 roo = (vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    \n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return NO_INTERSECTION;\n    \n    // use this instead if your rays origin can be inside the box\n    inters_inside = tN < 0.0;\n    vec4 res = !inters_inside ? vec4( tN, step(vec3(tN),t1)) :\n                          vec4( tF, step(t2,vec3(tF)));\n    //vec4 res = vec4(tN, step(tN,t1) );\n    \n    temp_norm = (vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n    //temp_norm = normalize(temp_norm);\n    //if(inters_inside && temp_norm.y<-0.9){\n    if(temp_norm.y>0.9){\n        return NO_INTERSECTION;\n    }\n    if(inters_inside){\n        temp_norm = temp_norm;\n    }\n    \n    return res.x;\n}\n\n\n#define pi acos(-1.0)\n#define tau (2.*pi) \n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\nfloat hash_21_s(ivec2 _s_){ \n  uvec2 s = uvec2(_s_ + 2000);\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \n  return hash_f_s(_s); \n}\nfloat valueNoise( in vec2 p ){\n    p += 100.;\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \n                     hash_21_s( i + ivec2(1,0) ), u.x),\n                mix( hash_21_s( i + ivec2(0,1) ), \n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\n}\n\nfloat Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    // Uchimura 2017, \"HDR theory and practice\"\n    // Math: https://www.desmos.com/calculator/gslcdxvipg\n    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\n/*\nvoid mainImagea( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C -= C;\n    vec2 uv = (U - 0.5*R)/R.y;\n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(\n        sin(muv.x*pi)*cos(muv.y*pi/1.),\n        cos(muv.y*pi/1.),\n        cos(muv.x*pi)*cos(muv.y*pi/1.)\n    )*0.4;\n    \n    vec3 rd = getRd(ro,vec3(0.0),uv);\n    const float bayer[] = float[64](\n         0./63., 32./63., 8./63., 40./63., 2./63., 34./63., 10./63., 42./63., \n        48./63., 16./63., 56./63., 24./63., 50./63., 18./63., 58./63., 26./63., \n        12./63., 44./63., 4./63., 36./63., 14./63., 46./63., 6./63., 38./63.,\n        60./63., 28./63., 52./63., 20./63., 62./63., 30./63., 54./63., 22./63., \n         3./63., 35./63., 11./63., 43./63., 1./63., 33./63., 9./63., 41./63., \n        51./63., 19./63., 59./63., 27./63., 49./63., 17./63., 57./63., 25./63.,\n        15./63., 47./63., 7./63., 39./63., 13./63., 45./63., 5./63., 37./63.,\n        63./63., 31./63., 55./63., 23./63., 61./63., 29./63., 53./63., 21./63.\n    );    \n\tvec2 buv = mod(floor(U.xy), 8.);\n\tfloat bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    //seed += uint(bay*64.);\n    \n    vec3 p = ro;\n    //rd = normalize(vec3(uv,0.5));\n    \n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    //rd.xy *= rot((t)*0.4);\n    vec3 thr = vec3(1);\n    \n    vec3 em = vec3(0);\n    \n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 box = intersect(p,rd);\n        p = p + rd *  (box.x > 0. ? box.x : box.y);\n        vec4 c = get(p);\n        \n        thr *= c.xyz;\n        if(c.w > 0.1){\n            em += c.xyz*c.w;\n        }\n        \n        \n        float bncSubCnt = 1240.;\n        \n        p += n*0.002;\n        \n        vec3 subs = vec3(0);\n        for(float bncSub = 0.; bncSub < bncSubCnt; bncSub++){\n            vec3 brd = randomCosineHemisphere(n*1.);\n            \n            vec2 scene = intersect(p,brd);\n            \n            vec3 pp = p + brd * (scene.x > 0. ? scene.x : scene.y);\n            vec4 c = get(pp);\n            if(c.w > 0.03){\n                subs += thr * c.xyz / bncSubCnt;\n                em += c.w * thr * c.xyz / bncSubCnt;\n            }\n            \n            //att *= c;\n        \n            //vec2 \n        }\n        thr *= subs;\n    }\n    C.xyz += em;\n    \n    \n    if(iFrame == 0){\n        C = vec4(0,0,0,1);\n    }\n}\n*/\n\n#define AGX_LOOK 2\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  // Golden\n  slope = vec3(1.0, 0.9, 0.5);\n  power = vec3(0.8);\n  sat = 0.8;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// <-\n\nvec4 do_agx( vec4 fragColor)\n{\n  vec3 col = fragColor.xyz;\n  \n  // AgX\n  // ->\n  col = agx(col);\n  col = agxLook(col);\n  col = agxEotf(col);\n  // <-\n  \n  fragColor = vec4(col, 1.0);\n  return fragColor;\n}\n", "buffer_b_code": "\n#define pi acos(-1.0)\n//#define tau 2.*pi\n\n#define intersects(a)  (abs(a - NO_INTERSECTION) > 0.02)\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\nvec3 gp;\nvec3 norm;\nfloat id;\nfloat inside = -1.;\nfloat first_inside = -1.;\n\nvec4 get(vec3 p){\n    vec4 c;\n    if(\n        p.y > 0.01 && norm.y < -0.04\n        //&& norm.y < -0.1\n    ){\n        c = vec4(\n            //0.2*abs(sin(p.y*25.1 + iTime*20.)),\n            //1.5 + sin(p.y*8. + iTime)*1.,\n            0. + ((sin(p.y*55. + iTime) > 0.8) ? 5. : 0.),\n            0.5 ,\n            1.0 + ((sin(p.y*125. + iTime) > 0.8) ? 2. : 0.),\n            1.0);\n        c.xyz = sin(c.xyz + iTime*sin(p.y*15.)) + 0.5;\n    } else {\n        c = vec4(vec3(0.5),0.);\n    }\n    c = abs(c);\n    //c = max(c,0.);\n    return c;\n    //return vec4(0.5,0.5,0.5,0.4);\n}\n\nvec2 dmin(vec2 a, float b, float id){\n    if(abs(id - inside) < 0.001){\n        return a;\n    }\n    vec2 inters = a;\n    \n    if(!intersects(b)){\n    } else if (\n        ( b < a.x) ||\n        !intersects(a.x)\n        ) {\n        inters = vec2(b, id);\n        norm = temp_norm;\n    }\n    return inters;\n}\nint bnc = 0;\nvec2 intersect(vec3 ro, vec3 rd){\n    vec3 oro = ro;\n    vec2 ba = vec2(NO_INTERSECTION);\n    bool inters_inside;\n    ba = dmin(ba,boxIntersection(ro - vec3(0,4.0,0),rd,vec3(20.2,4.0,11.4),inters_inside),1.);\n    ba = dmin(ba,boxIntersection(ro + vec3(0,0,2.),rd,vec3(12.4,2.,0.4),inters_inside),4.);\n    //ba = dmin(ba,boxIntersection(ro - vec3(0,0,2.),rd,vec3(12.4,2.,0.4),inters_inside),4.);\n    ba = dmin(ba,boxIntersection(ro - vec3(3.,0,0.),rd,vec3(0.4,2.,102.4),inters_inside),4.);\n    ba = dmin(ba,boxIntersection(ro - vec3(-3.,0,0.),rd,vec3(0.4,2.,102.4),inters_inside),4.);\n    vec2 bounds = vec2(3.,2);\n    id = ba.y;\n    \n    if(intersects(ba.x) || (inside > 0.)){\n        if(inside < 0.0){\n            ro = ro + rd * ba.x;\n        }\n        \n        int t = 1*iFrame/50*0 + 1;\n        bool hit = false;\n        for(int i = 0; i < 4; i++){\n            ivec2 tidb = ivec2(t + i);\n            float sb = hash_21_s(tidb);\n            \n            sb = mix(0.6,1.,sb);\n            vec2 md = vec2(sb,mix(0.1,2.,mod(sb*12.5,1.)));\n            ivec2 id = ivec2(ro.xz/md);\n            vec3 q = ro;\n            ro.z += iTime*sb + sin(float(id.x)+ iTime);\n            q.xz = mod(ro.xz,md) - 0.5*md;\n\n            ivec2 tid = ivec2(id + t + i*20);\n            float s = hash_21_s(tid);\n            if(mod(s*125.61,1.0) < 0.7 + sin(iTime)*0.15){\n                s = 0.;\n            }\n            vec3 sz = vec3(1,mix(0.01,.8,s*s*s),1)*(vec3(0,1.0,0) + s*vec3(1,0,1)*md.xyy*0.5);\n            float inters = boxIntersection(q,rd,sz,inters_inside);\n\n\n            float inters_d = (inters + (intersects(ba.x) ? ba.x : 0.0));\n            \n            vec3 pp = oro + rd * inters_d;\n            if( intersects(inters) && inters_inside && inters_d > ba.x\n                && abs(pp.x) < 2.45 && abs(pp.z) < 1.8\n            ){\n                if(bnc == 0)\n                    inside = ba.y;\n                ba.x = inters_d;\n                norm = temp_norm;\n                hit = true;\n                //break;\n            }        \n        }\n        //ro += 0.1*vec3(0,1,0);\n        \n\n        //if()\n        //if()\n    }\n    \n    //ba = dmin(ba,boxIntersection(ro - vec3(0.2),rd,vec3(5.,0.2,5.)),1.);\n    return ba;\n}\n\n\nvec3 rand_sphere_dfox(){\n    float z = hash_f() * 2.0f - 1.0f;\n    float a = hash_f() * tau;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 randomCosineHemisphere(vec3 n){\n    return normalize(rand_sphere_dfox() + n);\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C = vec4(0);\n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(0.1);\n    vec3 rd = normalize(vec3(uv,0.5));\n    \n    muv = vec2(0.3,-0.1);\n    \n    float zoom = 7.5;\n    \n    float id = floor(iTime/9.0);\n    float idb = 0.;\n    if(mod(iTime,9.) < 3.0){\n        if(mod(id,2.) == 1.){\n            muv = vec2(0.,-0.4);\n            zoom *= 1.5;\n            idb = 1.;\n        }\n        muv.x += sin(iTime*.4 + sin(iTime*0.6))*0.02;\n        muv.y += sin(iTime*.4 + sin(iTime*0.6))*0.02;\n    } else {\n        muv = vec2(0.,0);\n        muv.x += sin(iTime*.4 + sin(iTime*0.6))*0.1;\n        idb = 2.;\n    }\n    \n    //muv.y += sin(iTime*0.7 + sin(iTime*0.4))*0.05;\n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    vec3 lookat = vec3(0.0,-0.4,0);\n    \n    if(idb == 0.){\n        lookat.y -= 0.7;\n        lookat += sin(vec3(0.5,0.2,0.6)*iTime)*vec3(0.2,0.1,0.2)*2.;\n    }else{\n        if(idb == 1.){\n            lookat += sin(vec3(0.5,0.2,0.6)*iTime*0.2 + idb*4. + sin(iTime*0.2))*vec3(0.5,0.1,0.3)*2.;\n        } else{\n            lookat += sin(vec3(0.3,0.3,0.6)*iTime*1. + idb*4. + sin(iTime*0.4))*vec3(0.5,0.1,0.3)*2.;\n            uv*=rot(0. + sin(iTime + cos(iTime))*0.05);\n        \n        }\n    }\n    //rd.xy *= rot((muv.x)*1.4);\n    if(true){\n        ro = vec3(\n            sin(muv.x*pi)*cos(muv.y*pi/1.),\n            sin(muv.y*pi/1.),\n            cos(muv.x*pi)*cos(muv.y*pi/1.)\n        )*zoom + vec3(0,-2.5,0);\n        rd = getRd(ro,lookat,uv*(0.3 + sin(idb + id)*0.05));\n    }\n    vec2 buv = mod(floor(U.xy), 8.);\n    seed += uint(iFrame);\n    seed += uint(texelFetch(iChannel1,ivec2(buv),0)*64.0)/1u;\n\t//float bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    \n    vec3 p = ro;\n    vec3 thr = vec3(1);\n    \n    vec3 acc = vec3(0);\n    \n        vec2 res = intersect(p,rd);\n        if(intersects(res.x)){\n            vec3 N = norm;\n            p = p + rd*res.x;\n            vec4 c = get(p);\n            \n            thr *= c.xyz;\n            if(c.w > 0.02){\n                acc += c.xyz*c.w;\n            }\n\n\n            float bncSubCnt =241.;\n            first_inside = inside;\n            p += N*0.002;\n            //acc += p.y;///\n            //acc += sin(p.y*11145.)*0.1;\n            bnc++;\n            if(c.w < 1.){\n                for(float bncSub = 0.; bncSub < bncSubCnt + min(float(iFrame),0.); bncSub++){\n                    vec3 brd = randomCosineHemisphere(N);\n\n                    vec2 res = intersect(p,brd);\n\n                    vec3 pp = p + brd * res.x;\n                    vec4 c = get(pp);\n                    if(intersects(res.x)){\n                        acc += c.w * thr * c.xyz / bncSubCnt;\n                        //acc -= 0.2/bncSubCnt;\n                        //acc -= 0.001;\n                    } else if(!intersects(res.x)){\n                        // sky\n                        acc += 0.05 * thr * vec3(0.1) / bncSubCnt;\n                    }\n\n                    //att *= c;\n\n                    //vec2 \n                }\n            }\n        } else {\n            acc += 1.0;\n        }\n    C.xyz += acc;\n    \n    \n    //C.xyz = tonemap_uchimura2(C.xyz*2.5);\n    //C.xyz = Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b);\n    //C = C/(1.+C);\n    C*= 1.0;\n    C = do_agx( abs(C) );\n    C = max(C,0.);\n    C = pow(C,vec4(.4545));\n    //C = clamp(C,0.,1.);\n}", "buffer_b_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// idk where this is from, copied from noby shader\n\nfloat FXAAamt = 0.25;\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 304, 304, 397]], "test": "untested"}
{"id": "mtsBDN", "name": "SNDH Audio Spectrum", "author": "cbalestra", "description": "Shader for sndh.oxygenedemos.com", "tags": ["audioreactive"], "likes": 2, "viewed": 182, "published": 3, "date": "1692978499", "time_retrieved": "2024-07-30T17:36:57.359845", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.75 + 0.5*cos(iTime*0.5+vec3(-2.,1.,3.)*(uv.x + 1.0));\n    //col = 0.75 + 0.5*cos(vec3(12.,6.,3.)*(uv.x + iTime * 0.01));\n\n  \n    float acc = texture(iChannel1, vec2(uv.x, 0.0)).x;\n    float v = 0.;\n    for(float i = -8.; i <= 8.; i++)\n    {\n        v += texture(iChannel0, vec2(uv.x + i * 0.005, 0.0)).x;\n    }\n    v /= 8.0;\n    //col.x = smoothstep(0.005, 0.0, abs(v-h));\n    //col *= .9 - pow(abs(v-h), 0.25 * smoothstep(.9, 0.0, abs(uv.x - 0.5)));\n    float h = uv.y - 0.5;\n    col *= 1. - pow(abs(v-h), 0.25);// * (1.0 - pow(abs(acc), 1.));\n    \n    col *= smoothstep(.9, 0., abs(uv.x - 0.5)) * smoothstep(.9, 0., abs(uv.y - 0.5));\n \n    /*if(uv.y > 0.9)\n    {\n    \n        col.xyz = vec3(texture(iChannel1, vec2(uv.x, 0.0)).x + 0.5);\n    }\n    else if(uv.y > 0.8)\n    {\n    \n        col.xyz = vec3(texture(iChannel0, vec2(uv.x, 0.0)).x + 0.5);\n    }*/\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y > 1.) discard;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    float want_p = texture(iChannel0, vec2(uv.x + .01, 1.0)).x;\n    want_p -= texture(iChannel0, vec2(uv.x - .01, 1.0)).x;\n    float curr_p = texture(iChannel2, vec2(uv.x, 0.0)).x;\n    float v = texture(iChannel1, vec2(uv.x, 0.0)).x;\n    \n    float acc = want_p - curr_p;\n    col.x = v * 0.5 + 0.1 * acc;\n \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     if(fragCoord.y > 1.) discard;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    float v = texture(iChannel0, vec2(uv.x, 0.0)).x;\n    float p = texture(iChannel1, vec2(uv.x, 0.0)).x;\n    \n    col.x = p + v;\n \n    fragColor = vec4(col,1.0);\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1112]], "test": "untested"}
{"id": "mllfWN", "name": " quality of bluenoise texture: v", "author": "FabriceNeyret2", "description": "mouse.x ( or time ) selects one value in the bluenoise mask. Note that discrepancy is good for 0 and 255, but less for the other values.\nright: pairs of successive values.\n\nFunny: on left I have the illusion of translation .1+.1*(cos(t),sin(t))", "tags": ["illusion", "mask", "bluenoise", "perception"], "likes": 7, "viewed": 203, "published": 3, "date": "1692976819", "time_retrieved": "2024-07-30T17:36:58.124800", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy;\n    float t = iMouse.z > 0. ? iMouse.x/R.x                             // manual tuning\n                      : fract(iTime/30.);                          // demo mode\n    \n    int m = int(255.*texelFetch( iChannel0, ivec2(u)%1024, 0 )), // bluenoise mask\n        s = int(256.*t);                                         // selected value\n        \n    O = vec4(                    m == s                          // left: select one\n              || u.x/R.x > .5 && m == s+1                        // right: select two in a row\n            );\n    if ( int(u) == int(R)/2 ) O = vec4(1,0,0,1);                 // red separator\n    if ( u.y < 5. ) O = vec4(1, u.x/R.x > t, 0,1);               // progress bar = value\n\n // O.g += .5* sqrt(smoothstep( 1., 0., abs(length( u-100.)-64.) ) \n //               + smoothstep( 1., 0., length( u-100.+64.*cos(6.28*t*16.+vec2(0,11)))-3. )); \n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 948]], "test": "untested"}
{"id": "DtlfDN", "name": "JVC & Britney Flatscreen TV", "author": "misol101", "description": "Clearly, this is the future of Television! Wait 15s for JVC to show up\n\nCONTROLS: p=pause, 7-9=speed, c=color, a=contrast, v=view, space=mix/brit/jvc, w/s=zoom,  b=box. Rotate with mouse.\n", "tags": ["3d", "video", "interactive", "voxel", "britney", "jvc"], "likes": 7, "viewed": 232, "published": 3, "date": "1692970628", "time_retrieved": "2024-07-30T17:36:59.208902", "image_code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// More keys: p=pause, 7-9=speed, c=color, a=contrast, v=view, space=mix/brit/jvc, w/s=zoom, b=box\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nint row;\nbool top=false;\nbool hitbox=false;\nfloat fade=1.0;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v, bool isShadow) \n{\n    p+=5.; // 0 == -5\n\n    int NM=int(N)-1;\n    int NMZ=int(N)/ZDIV-1;\n    if (!isShadow && bbox == 1) {\n        int x=int(p.x),y=int(p.y),z=int(p.z);\n        //if (z==NM-2 || (x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n        if (int(p.x+p.y+p.z)%3==0 && ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NMZ) || (y==NM && z==NMZ)  || (y==0 && z==NMZ) || (x==0 && z==NMZ) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM)) ) {\n            v=-1.;\n            hitbox=true;\n            return true;\n        }\n    }\n\n    float cv = cellval(ivec3(p));\n\n//    v=cv*0.13+(N/float(ZDIV)-(N-p.z))*0.012; // col by state value blue\n    v=cv*0.13+(N/float(ZDIV)-(p.z))*0.012; // col by state value\n//    v=cv*0.13; // col by state value\n\n    bool hit = cv > 1.;\n    if (hit && int(p.z)>=row-0) \n        top=true;\n    //if (hit)\n    //    fade=(float(p.z)/N);\n    return hit;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v, false)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 4.; ++i) {\n        if (map(ep, v, true)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-98.+(max(0.,1.-iResolution.y/450.))*70.;\n    float xrot=-0.66;\n    if (view == 1) yp=-98., xrot=-0.66;\n    if (view == 2) yp=0., xrot=1.;\n    if (view == 3) yp=0., xrot=-1.;\n\n    float a = 0.5/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0., yp, -d+zmod);\n\n    float mxc, myc;\n\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.83))*0.9;\n        myc = -0.66+sin(sin(iTime*0.57))*0.16;\n        if (view > 0) myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./2.8));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int show2d = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    float hidetext = 1.-texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    row = min(int(texelFetch(iChannel1, ivec2(5,0), 0 ).x),int(N/float(ZDIV))-2);\n    colmethod = int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    bbox = 1-int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n\n    if (show2d == 1 && fragCoord.y < N && fragCoord.x > iResolution.x - N) {\n        fragColor=texelFetch(iChannel2, ivec2(iResolution.x - fragCoord.x, fragCoord.y),0)*100.;\n        return;\n    }\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N/float(ZDIV)) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec2 uv=fragCoord/iResolution.y;\n    vec3 color = texture(iChannel3, uv+(mod(iTime,5.)*8.)).xxx; //vec3(0.0, 0.0, 0.0);\n    color=color*color*0.04;\n    \n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n\n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n        if ((top && colmethod==0) || colmethod==2) {color *= 2.3 +2.4;color.x=color.y; color.z=color.y;}\n        if (hitbox) {color *= vec3(0.3,0.3,0.6);}\n        //color*=fade;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_A     = 65;\nconst int KEY_M     = 77;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); discard; }\n\n    if (ix == 0 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_SPACE, 1., 3.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 2.;\n        if( readKey(KEY_9)) speed = 10.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        float row = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_SPACE) )\n            row = 0.;\n        fragColor = vec4(row+1.001,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 3.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 4.);\n        return;\n    }\n\n    if (ix == 11 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_A, 1., 2.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// 3d cell buffer, pixel packed with 4 bits per state and max 8 digits per component for 6*4=24 cells per pixel \n\nint N;\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val;\n}\n\nint aut2dval( in ivec3 p) {\n    ivec2 p2 = ivec2(p.x,p.y);\n    \n    int val = int(texelFetch(iChannel2, p2, 0 ).x*10.+0.);\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./2.8));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N/ZDIV) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 0+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int row = int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    if (row < N/ZDIV-2+speed) speed=0;\n    row = min(row,N/ZDIV-2);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || int(xres) != int(iResolution.x) || row==1;\n\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/6;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) {\n            fst[fi] = fst[fi]<<4;\n            continue;\n        }\n\n        if (regen) {\n            fst[fi] = (fst[fi] << 4);\n            continue;\n        }\n\n        int st;\n        if (zi==row) {\n            st=aut2dval(pos3d);\n        }\n        else {\n            st = cellval(pos3d,0,0,1);\n        }\n\n        fst[fi] = (fst[fi] << 4) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 200.\n\nconst int CPP = 24; // Cells Per Pixel (only 6,12,18,24 will work)\n\n//#define HORIZON\n\nconst float LAST_PATT = 2.001;\n\nconst int ZDIV=10;\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_c_code": " // TV buffer\n\nint N;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./2.8));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    if (int(fragCoord.y) > N) discard;\n    if (int(fragCoord.x) > N) { fragColor = vec4(0.); return; }\n\n    int ix = int(texelFetch(iChannel3, ivec2(0,0), 0 ).x);\n    int contr = int(texelFetch(iChannel3, ivec2(11,0), 0 ).x);\n\n    float swap = fragCoord.x;\n    fragCoord.x=fragCoord.y;\n    fragCoord.y=swap;\n\n    fragCoord.x *= 640. / float(N);\n    fragCoord.y *= 386. / float(N);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float solid;\n    vec3 tex;\n    float t=mod(iTime, 139.);\n    if (ix==0) {\n        if((t>15. && t < 30.2) || (t>56.5 && t < 87.0) || (t>95. && t < 116.8) || (t>124. && t < 138.0))\n            { tex = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb; solid=1.4; }\n        else\n            { tex = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb; solid=4.4; }\n    } else if (ix==1) {\n        tex = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb; solid=4.4;\n    } else {\n        tex = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb; solid=1.4;\n    }\n    if (contr==1) solid*=0.3;\n    tex=pow(tex,vec3(solid));\n\n    float x = (tex.g - tex.r - tex.b)*2.5;\n    \n\tfloat pos = 0.65; float radius = 1.1;\n\tfloat intensity = smoothstep(pos-radius, pos, x) * (1.0-smoothstep(pos, pos+radius, x));\n    \n    intensity=max(0., 0.5-intensity);\n    \n\tfragColor = vec4(vec3(intensity),1.0);\n}\n", "buffer_c_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n", "buffer_d_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 370, 370, 615], [617, 672, 748, 748, 791], [793, 793, 822, 822, 1172], [1174, 1174, 1224, 1224, 2346], [2348, 2348, 2458, 2458, 2775], [2777, 2777, 2826, 2826, 2937], [2939, 2939, 3056, 3056, 3765], [3767, 3767, 3855, 3855, 4439], [4441, 4441, 4536, 4536, 4675], [4677, 4677, 4753, 4753, 5887], [5890, 5890, 5915, 5915, 6102], [6104, 6104, 6260, 6260, 7171], [7173, 7173, 7200, 7200, 7267], [7269, 7269, 7326, 7326, 9910]], "test": "untested"}
{"id": "clffWN", "name": "JCvD & Britney TV Box", "author": "misol101", "description": "Clearly, this is the future of Television! Wait 15s for JCvD to show up\n\nCONTROLS: p=pause, 7-9=speed, c=color, a=contrast, v=view, space=mix/brit/jvc, w/s=zoom,  b=box.  Rotate with mouse.\n", "tags": ["3d", "video", "interactive", "voxel", "britney", "jvc"], "likes": 19, "viewed": 340, "published": 3, "date": "1692970623", "time_retrieved": "2024-07-30T17:37:00.323920", "image_code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// More keys: p=pause, 7-9=speed, c=color, a=contrast, v=view, space=mix/brit/jvc, w/s=zoom, b=box\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nint row;\nbool top=false;\nbool hitbox=false;\nfloat fade=1.0;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v, bool isShadow) \n{\n    p+=5.; // 0 == -5\n\n    int NM=int(N)-1;\n    if (!isShadow && bbox == 1) {\n        int x=int(p.x),y=int(p.y),z=int(p.z);\n        //if (z==NM-2 || (x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n        if (int(p.x+p.y+p.z)%4>=0 && ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM)) ) {\n            v=-1.;\n            hitbox=true;\n            return true;\n        }\n    }\n\n    float cv = cellval(ivec3(p));\n\n    v=cv*0.13+(N-p.z)*0.007; // col by state value\n\n    bool hit = cv > 1.;\n    if (hit && int(p.z)>=row-1) \n        top=true;\n    //if (hit)\n    //    fade=(float(p.z)/N);\n    return hit;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v, false)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 5.; ++i) {\n        if (map(ep, v, true)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-1., xrot=-0.80;\n    if (view == 1) yp=0., xrot=-0.66;\n    if (view == 2) yp=0., xrot=1.;\n    if (view == 3) yp=0., xrot=-1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(sin(iTime*2.0)*10.*1., yp, -d+zmod);\n\n    float mxc, myc;\n\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.73))*0.8;\n        myc = -0.78+sin(sin(iTime*0.37))*0.22;\n        if (view > 0) myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int show2d = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    float hidetext = 1.-texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    row = min(int(texelFetch(iChannel1, ivec2(5,0), 0 ).x),int(N)-2);\n    colmethod = int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    bbox = 1-int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n\n    if (show2d == 1 && fragCoord.y < N && fragCoord.x > iResolution.x - N) {\n        fragColor=texelFetch(iChannel2, ivec2(iResolution.x - fragCoord.x, fragCoord.y),0)*100.;\n        return;\n    }\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec2 uv=fragCoord/iResolution.y;\n    vec3 color = texture(iChannel3, uv+(mod(iTime,5.)*8.)).xxx; //vec3(0.0, 0.0, 0.0);\n    color=color*color*0.04;\n\n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n\n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n        if ((top && colmethod==0) || colmethod==2) {color *= 2.3 +2.4;color.x=color.y; color.z=color.y;}\n        if (hitbox) {color *= vec3(0.3,0.3,0.6);}\n        //color*=fade;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_A     = 65;\nconst int KEY_M     = 77;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); discard; }\n\n    if (ix == 0 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_SPACE, 1., 3.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = 2.;\n        if( readKey(KEY_9)) speed = 10.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        float row = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_SPACE) )\n            row = 0.;\n        fragColor = vec4(row+1.001,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 3.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 4.);\n        return;\n    }\n\n    if (ix == 11 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_A, 1., 2.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// 3d cell buffer, pixel packed with 4 bits per state and max 8 digits per component for 6*4=24 cells per pixel \n\nint N;\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val;\n}\n\nint aut2dval( in ivec3 p) {\n    ivec2 p2 = ivec2(p.x,p.y);\n    \n    int val = int(texelFetch(iChannel2, p2, 0 ).x*10.+0.);\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 0+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int row = int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    if (row < N-2+speed) speed=0;\n    row = min(row,N-2);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || int(xres) != int(iResolution.x) || row==1;\n\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/6;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) {\n            fst[fi] = fst[fi]<<4;\n            continue;\n        }\n\n        if (regen) {\n            fst[fi] = (fst[fi] << 4);\n            continue;\n        }\n\n        int st;\n        if (zi==row) {\n            st=aut2dval(pos3d);\n        }\n        else {\n            st = cellval(pos3d,0,0,1);\n        }\n\n        fst[fi] = (fst[fi] << 4) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 90.\n\nconst int CPP = 24; // Cells Per Pixel (only 6,12,18,24 will work)\n\n//#define HORIZON\n\nconst float LAST_PATT = 2.001;\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_c_code": " // TV buffer\n\nint N;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    if (int(fragCoord.y) > N) discard;\n    if (int(fragCoord.x) > N) { fragColor = vec4(0.); return; }\n\n    int ix = int(texelFetch(iChannel3, ivec2(0,0), 0 ).x);\n    int contr = int(texelFetch(iChannel3, ivec2(11,0), 0 ).x);\n\n    float swap = fragCoord.x;\n    fragCoord.x=fragCoord.y;\n    fragCoord.y=swap;\n\n    fragCoord.x *= 640. / float(N);\n    fragCoord.y *= 386. / float(N);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float solid;\n    vec3 tex;\n    float t=mod(iTime, 139.);\n    if (ix==0) {\n        if((t>15. && t < 30.2) || (t>56.5 && t < 87.0) || (t>95. && t < 116.8) || (t>124. && t < 138.0))\n            { tex = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb; solid=1.4; }\n        else\n            { tex = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb; solid=4.4; }\n    } else if (ix==1) {\n        tex = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb; solid=4.4;\n    } else {\n        tex = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb; solid=1.4;\n    }\n    if (contr==1) solid*=0.3;\n    tex=pow(tex,vec3(solid));\n\n    float x = (tex.g - tex.r - tex.b)*2.5;\n    \n\tfloat pos = 0.65; float radius = 1.1;\n\tfloat intensity = smoothstep(pos-radius, pos, x) * (1.0-smoothstep(pos, pos+radius, x));\n    \n    intensity=max(0., 0.5-intensity);\n    \n\tfragColor = vec4(vec3(intensity),1.0);\n}\n", "buffer_c_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n", "buffer_d_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clffWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 370, 370, 615], [617, 672, 748, 748, 791], [793, 793, 822, 822, 1172], [1174, 1174, 1224, 1224, 2188], [2190, 2190, 2300, 2300, 2617], [2619, 2619, 2668, 2668, 2779], [2781, 2781, 2898, 2898, 3607], [3609, 3609, 3697, 3697, 4281], [4283, 4283, 4378, 4378, 4517], [4519, 4519, 4595, 4595, 5729], [5732, 5732, 5757, 5757, 5944], [5946, 5946, 6102, 6102, 6983], [6985, 6985, 7012, 7012, 7079], [7081, 7081, 7138, 7138, 9693]], "test": "untested"}
{"id": "DtlfD4", "name": "Soft Blooming", "author": "ming", "description": "A soft blooming filter that try to avoid washing out the original color.\nLeft: ordinary blooming\nRight: soft blooming", "tags": ["2d", "blur", "fast", "bloom", "trick"], "likes": 1, "viewed": 212, "published": 3, "date": "1692954965", "time_retrieved": "2024-07-30T17:37:01.243462", "image_code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Trick: take one single texture sample at the corner of a given texel, right where it \n// meets three of its neighbors, so that the bilinear filtering hardware averages those\n// four texels for you. This basically lets you downsample or box-blur the texture\n// without fetching and averaging the four texels by hand.\n//\n// This shader shows the technique by blurring an image repeatedly with only ONE texture\n// sample.\n//\n// A more advanced use of this for gaussian blurs here: https://www.shadertoy.com/view/Xd33Rf\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 img = CREATE_TEXTURE;\n    \n    \n    vec4 bloom = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    \n    if(fragCoord.x > iResolution.x / 2.0)\n    {\n        float bloom_lum = dot(vec4(0.2126, 0.7152, 0.0722, 0), bloom);\n        img = mix(img, bloom, bloom_lum);\n    }\n    else\n    {\n        img = img + bloom;\n    }\n    \n    // output and apply gamma correction\n    if(abs(fragCoord.x - iResolution.x / 2.0) < 2.0)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    else\n        fragColor = pow(img, vec4(1.0 / 2.2));\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Trick: take one single texture sample at the corner of a given texel, right where it \n// meets three of its neighbors, so that the bilinear filtering hardware averages those\n// four texels for you. This basically lets you downsample or box-blur the texture\n// without fetching and averaging the four texels by hand.\n//\n// This shader shows the technique by blurring an image repeatedly with only ONE texture\n// sample.\n//\n// A more advanced use of this for gaussian blurs here: https://www.shadertoy.com/view/Xd33Rf\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // blur    \n    vec2 s = vec2(float(iFrame&1))-0.5;             // generate -0.5 or +0.5 alternativelly\n    //vec2 s = vec2(iFrame&1,(iFrame>>1)&1)-0.5;      // touch four corners alternativelly\n    fragColor = textureLod( iChannel0, (fragCoord+s) / iResolution.xy, 0.0 );\n\n    // initial image, it seems that we need to wait for a few frames for image loading\n    if( iFrame<10 ) \n    {\n        vec4 img = CREATE_TEXTURE;\n        \n        // assume we are storing linear in BufferA\n        fragColor = img;\n    }\n}\n", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LOAD_IMAGE (textureLod(iChannel1, fragCoord.xy/(iResolution.xy*vec2(3.2, 1.0)), 0.0))\n\n#define CREATE_TEXTURE pow(LOAD_IMAGE, vec4(2.2))", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlfD4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[648, 648, 705, 705, 1232]], "test": "untested"}
{"id": "mlXfDN", "name": "PBR Training", "author": "AYAYA2", "description": "Support by UnrealEngine, https://www.pbr-book.org", "tags": ["sdf", "pbr", "physicallybasedrendering"], "likes": 0, "viewed": 169, "published": 3, "date": "1692933405", "time_retrieved": "2024-07-30T17:37:02.153030", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.\n#define SURF_DIST .01\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define rcp(x) 1.0 / (x)\n#define PI 3.14159265359\n\nfloat dot2( in vec2 v ) { return dot(v,v); }// 二维向量模长\nfloat dot2( in vec3 v ) { return dot(v,v); }// 三维向量模长\nfloat ndot( in vec2 a, in vec2 b ) { return a.x * b.x - a.y * b.y; }\nfloat Pow4( float x ) { float xx = x * x; return xx * xx; }\nfloat Pow5( float x ) { return Pow4(x) * x; }\n\nvec3 lerp( vec3 a, vec3 b, float c)\n{\n    float x = mix(a.x, b.x, c);\n    float y = mix(a.y, b.y, c);\n    float z = mix(a.z, b.z, c);\n    return vec3(x, y, z);\n}\n\n/////////////////////SDF/////////////////////\n\nfloat sdPlane(vec3 p) { return p.y; }\n\nfloat dSphere(vec3 p, vec3 o, float radius) { return length(p - o.xyz) - radius; }\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// 场景\nvec2 GetDist(vec3 p)\n{\n    float planeDist = sdPlane(p);// ground\n    \n    // 遍历形式所有物体 物体摆放\n    float sd = dSphere(p, vec3(0, 1, 3), 1.25);\n    vec2 hit = opUnion(vec2(planeDist, 0), vec2(sd, 1));\n    \n    return hit;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    float MaterialID = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        MaterialID = dS.y;\n        if (dO > MAX_DIST || dS.x < SURF_DIST) break;     \n    }\n    \n    return vec2(dO, MaterialID);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).x;\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy).x,\n        GetDist(p - e.yxy).x,\n        GetDist(p - e.yyx).x);\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lightPos)\n{\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p + n * SURF_DIST * 2.,l).x;\n    if(d < length(lightPos - p)) dif*=.1;\n    \n    return dif;\n}\n\nfloat GetShadow(vec3 P, vec3 LightPos)\n{\n    vec3 L = normalize(LightPos - P);\n    vec3 N = GetNormal(P);\n    \n    float Shadow = 1.0;\n    float Dist = RayMarch(P + N * SURF_DIST * 2., L).x;\n    if(Dist < length(LightPos - P)) Shadow = 0.0;\n    \n    return Shadow;\n}\n\n/////////////////////BSDF/////////////////////\n\n// GGX / Trowbridge-Reitz\n// [Walter et al. 2007, \"Microfacet models for refraction through rough surfaces\"]\nfloat D_GGX( float a2, float NoH )\n{\n\tfloat d = ( NoH * a2 - NoH ) * NoH + 1.0;\t// 2 mad\n    return a2 / ( PI * d * d );\t\t\t\t\t    // 4 mul, 1 rcp\n}\n\n// Appoximation of joint Smith term for GGX\n// [Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"]\nfloat Vis_SmithJointApprox( float a2, float NoV, float NoL )\n{\n\tfloat a = sqrt(a2);\n\tfloat Vis_SmithV = NoL * ( NoV * ( 1.0 - a ) + a );\n\tfloat Vis_SmithL = NoV * ( NoL * ( 1.0 - a ) + a );\n\treturn 0.5 * rcp( Vis_SmithV + Vis_SmithL );\n}\n\n// [Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"]\nvec3 F_Schlick( vec3 SpecularColor, float VoH )\n{\n\tfloat Fc = Pow5( 1.0 - VoH );\t\t\t\t// 1 sub, 3 mul\n\t//return Fc + (1 - Fc) * SpecularColor;\t\t  // 1 add, 3 mad\n\t\n\t// Anything less than 2% is physically impossible and is instead considered to be shadowing\n\treturn saturate( 50.0 * SpecularColor.y ) * Fc + (1.0 - Fc) * SpecularColor;\n}\n\nfloat DielectricSpecularToF0(float Specular)\n{\n\treturn 0.08f * Specular;\n}\n\nvec3 ComputeF0(float Specular, vec3 BaseColor, float Metallic)\n{\n\treturn lerp(vec3(DielectricSpecularToF0(Specular)), BaseColor, Metallic);\n}\n\n\n/////////////////////Tone mapping and transfer functions/////////////////////\n\nvec3 Tonemap_ACES(const vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n/////////////////////Main/////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // User Control\n    vec3 BaseColor = vec3(1.0, 1.0, 1.0);\n    float Specular = 0.9f;\n    float Roughness = 0.9f;\n    float Metalic = 0.9f;\n    \n    vec3 Ray0 = vec3(0, 3, 0);// CameraPos\n    vec3 LightPos = vec3(0, 3, 1);\n    //LightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    LightPos.x += sin(iTime) * 2.5;// Time varying pixel color\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 UV = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    // RayTracing\n    vec3 RayDir = normalize(vec3(UV.x, UV.y -.3, .35));// cameraDir\n    vec2 Dist = RayMarch(Ray0, RayDir);   \n    vec3 Pos = Ray0 + RayDir * Dist.x;\n       \n    // BSDF\n    vec3 N = GetNormal(Pos);\n    vec3 V = normalize(Ray0 - Pos);\n    vec3 L = normalize(LightPos - Pos);\n    vec3 H = normalize(L + V);\n    \n    float NoV = abs(dot(N, V)) + 1e-5;\n    float NoL = saturate(dot(N, L));\n    float NoH = saturate(dot(N, H));\n    float LoH = saturate(dot(L, H));\n    float VoH = saturate(dot(V, H));\n    \n    float a2 = Pow4(Roughness);\n    \n    float D = D_GGX(a2, NoH);\n    \n    float G = Vis_SmithJointApprox(a2, NoV, NoL);\n    \n    // Diffuse\n    vec3 DiffuseColor = BaseColor - BaseColor * Metalic;\n    vec3 LightingDiffuse = DiffuseColor * (1.0 / PI);// Diffuse_Lambert\n    \n    // Specular\n    vec3 SpecularColor = ComputeF0(Specular, BaseColor, Metalic);\n    vec3 F = F_Schlick(SpecularColor, VoH);\n    \n    vec3 LightingSpecular = vec3(G);//D * G * F;\n    \n    vec3 FinalColor = LightingSpecular;// + LightingDiffuse;\n    \n    float MaterialID = Dist.y;\n    if (MaterialID < 1.0)\n        FinalColor = vec3(0.3);\n    \n    // Shadow\n    float Shadow = GetShadow(Pos, LightPos);\n    FinalColor *= Shadow;\n    \n    // Tone mapping\n    FinalColor = Tonemap_ACES(FinalColor);\n\n    // Exponential distance fog\n    //color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    FinalColor = OECF_sRGBFast(FinalColor);\n\n    // Output to screen\n    fragColor = vec4(FinalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 183, 183, 202], [202, 224, 249, 249, 268], [268, 290, 326, 326, 358], [359, 359, 382, 382, 418], [419, 419, 442, 442, 464], [466, 466, 503, 503, 627], [676, 676, 699, 699, 713], [715, 715, 760, 760, 797], [799, 799, 831, 831, 867], [869, 879, 901, 901, 1122], [1124, 1124, 1157, 1157, 1462], [1464, 1464, 1488, 1488, 1688], [1690, 1690, 1729, 1729, 1955], [1957, 1957, 1997, 1997, 2223], [2273, 2382, 2418, 2418, 2528], [2530, 2664, 2726, 2726, 2901], [2903, 2981, 3030, 3030, 3315], [3317, 3317, 3363, 3363, 3391], [3393, 3393, 3457, 3457, 3534], [3616, 3616, 3649, 3705, 3891], [3893, 3893, 3932, 3932, 3975], [4025, 4025, 4082, 4102, 6111]], "test": "untested"}
{"id": "DlfBW4", "name": "polygon sdf", "author": "01000001", "description": "I wanted to try to create a polygon sdf myself. This is my attempt. The shader is forked from iq's polygon shader, and only the function body has been changed. Fun coding exercise!  See the fork source if you want to give it a try yourself.", "tags": ["2d", "sdf", "distance", "polygon"], "likes": 6, "viewed": 244, "published": 3, "date": "1692921356", "time_retrieved": "2024-07-30T17:37:02.949899", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Shader forked from Inigo Quilez, polygon function reconstructed from scratch\n\n\n// Distance to a polygon with n arbitrary points\n\n\n#define N 7\n\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    float pointMin = float(uint(-1));\n    float lineMin = pointMin;\n    int intersections = 0;\n    \n    for( int i=0; i<N; i++ ){\n    \n        pointMin = min(length(p-v[i]), pointMin);\n        // Kinda unrelated thing being calculated in the same loop.\n        // I thought it might cause problems but the tangency of points\n        // lines up with the previous line at the border so it's not a problem.\n        // Comment to see what it does\n\n\n        // Line distance! Perp is an interesting check, see what happens\n        // if you break; when it's true.\n        vec2 me = v[i];\n        vec2 next = v[i==N-1?0:i+1];\n        \n        float len = length(next-me); // Line length\n        vec2 dir = (next-me)/len; // Normalized line\n        \n        bool perp = dot(p-me, dir) > 0. && dot(p-me, dir) < len; \n        //if (perp) break; // Try this!\n        // Would the normal, intersecting the line, be able to intersect uv too?\n\n        dir *= mat2x2(0, 1, -1, 0);\n        // rotate dir by 90° to get normal\n        \n        lineMin = min(perp?abs(dot(p-me, dir)):pointMin, lineMin);\n        // distance to infinite line. If not perp then we use point dist.\n        \n        \n        // Unrelated calculation in the same loop cuz we can\n        // If even intersection count from uv to (inf, uv.y), \n        // then point is outside. If odd, point is inside\n        float f = (p.y - me.y) / (next.y - me.y);\n        if (f < 1. && f > 0.){\n            // point is not above or below line\n\n        \n            if (p.x < min(me.x, next.x)){ \n                // point is left of bounding box\n                \n                intersections++;\n            } else if (!(p.x > max(me.x, next.x))){ \n                // point is in bounding box\n                // so we check intersection\n                \n                if (mix(me.x, next.x, f) > p.x){\n                    intersections++;\n                }\n            }\n        }\n    }\n    \n    return lineMin * (intersections%2==1?-1.:1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    vec2[] polygon = vec2[N](\n        0.8*sin( 0.40*iTime + vec2(0.0,2.00) + 0.0 ),\n        0.8*cos( 0.45*iTime + vec2(0.0,1.50) + 1.0 ),\n        0.8*sin( 0.50*iTime + vec2(0.0,3.00) + 2.0 ),\n        0.8*cos( 0.55*iTime + vec2(0.0,2.00) + 4.0 ),\n        0.8*sin( 0.60*iTime + vec2(0.0,1.00) + 5.0 ),\n        0.8*cos( 0.65*iTime + vec2(0.0,1.00) + 5.5 ),\n        0.8*sin( 0.70*iTime + vec2(0.0,1.00) + 6.0 )\n    );\n    \n\tfloat d = sdPolygon(p, polygon);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 )\n    {\n    d = sdPolygon( m, polygon );\n    col = mix(col, vec3(sign(d),1.,1.-sign(d)), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(sign(d),1.,1.-sign(d)), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = col.xyzz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfBW4.jpg", "access": "api", "license": "mit", "functions": [], "test": "untested"}
{"id": "DtfBD4", "name": "Fork ShaderTober - Dark", "author": "cbalestra", "description": "A small doodle with inktober's theme \"Dark\". \nPlay the sound in iChannel0 and enjoy this awesome track from son lux :D All of their work are amazing > https://soundcloud.com/son-lux", "tags": ["raymarching", "audioreactive", "inktober", "sonlux"], "likes": 7, "viewed": 270, "published": 3, "date": "1692904434", "time_retrieved": "2024-07-30T17:37:04.420966", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// AN AUDIO REACTIVE SHADER, play the sound in iChannel0\n\n#define ITER 64.\n#define PI 3.141592\n#define megabass (texture(iChannel0, vec2(0.001,0.25)).x)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,14.1)))*1245.4);}\n\nvec2 moda(vec2 p, float per)\n{\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat needles(vec3 p)\n{\n    vec3 pp = p;\n    float l_needle = 0.8 - clamp(megabass,0.,0.75);\n    \n    p.xz = moda(p.xz, 2.*PI/7.);\n    float n1 = cyl(p.yz,0.1-p.x*l_needle);\n    \n    p = pp;\n    p.y = abs(p.y);\n    p.y -= 0.1;\n    p.xz = moda(p.xz, 2.*PI/7.);\n    p.xy *= rot(PI/4.5);\n\n    float n2 = cyl(p.yz,0.1-p.x*l_needle);\n    \n    p = pp;\n    float n3 = cyl(p.xz, 0.1-abs(p.y)*l_needle);\n    \n    return min(n3,min(n2,n1));\n}\n\nfloat spikyball (vec3 p)\n{\n    p.y -= iTime;\n    p.xz *= rot(iTime);\n    p.yz *= rot(iTime*0.5);\n    float s = sphe(p,.9);\n    return smin(s, needles(p), 5.);\n}\n\n// provided by Shane, thank you :3\nfloat room(vec3 p)\n{\n    p += sin(p.yzx - cos(p.zxy));\n    p += sin(p.yzx/1.5 + cos(p.zxy)/2.)*.5;\n    return -length(p.xz) + 5.;\n}\n\nfloat SDF (vec3 p)\n{ \n    return min(spikyball(p),room(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001+iTime,-3.); \n    vec3 p = ro;\n    vec3 dir = normalize(vec3(uv, 1.));\n    \n    float shad = 0.;\n    \n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if(d<0.001)\n        {\n        \tshad = i/ITER;\n            break;\n        }\n        d *= 0.9+dither*0.1;\n        p+=d*dir;\n    }    \n    \n    vec3 c = vec3 (shad);\n    \n    // Output to screen\n    fragColor = vec4(pow(c,vec3(1.5)),1.0);\n}", "image_inputs": [{"id": 20154, "src": "https://soundcloud.com/dark_vibe/son-lux-dream-state-dark-day", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 489, 489, 539], [541, 541, 571, 571, 697], [699, 699, 719, 719, 762], [764, 764, 805, 805, 876], [878, 878, 908, 908, 928], [930, 930, 959, 959, 979], [981, 981, 1004, 1004, 1413], [1415, 1415, 1441, 1441, 1575], [1577, 1612, 1632, 1632, 1743], [1745, 1745, 1765, 1765, 1806], [1808, 1808, 1865, 1865, 2411]], "test": "untested"}
{"id": "clXBW4", "name": "Fork polygon :D beans_plea 404", "author": "beans_please", "description": "challenge shader", "tags": ["2d", "sdf", "distance", "polygon"], "likes": 0, "viewed": 73, "published": 3, "date": "1692902788", "time_retrieved": "2024-07-30T17:37:05.299617", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular pentagon, without trigonometric functions. \n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\n\n\n\n\n\n// NO STEALING CODE FROM THE ORIGINAL!\n\n\n\n\n\n\n\n\n\nconst int N = 5;\n\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    // Minimum distance\n    float m = 1e9;\n    \n    // How many segments intersect a half line from p to (+inf, p.y)\n    int num_intersections = 0;\n    \n    // The segments\n    for (int i = 0; i < N; i++)\n    {\n        // Line segment vertices\n        vec2 a = v[i];\n        vec2 b = v[(i + 1) % N];\n        \n        // Slope and intercept\n        float temp = b.x - a.x;\n        if (temp == 0.) temp = 1e-9;\n        float slope = (b.y - a.y) / temp;\n        float intercept = a.y - slope * a.x;\n        \n        // Should we use the endpoints or the line?\n        if (min(dot(p - a, b - a), dot(p - b, a - b)) < 0.)\n        {\n            // Distance from the endpoints\n            m = min(m, min(distance(p, a), distance(p, b)));\n        }\n        else\n        {\n            // Distance from the line\n            m = min(m, abs(slope * p.x - p.y + intercept) / sqrt(slope * slope + 1.));\n        }\n        \n        // Intersect AB with half line from p to (+inf, p.y)\n        // (only if p.y is between a.y and b.y)\n        if (p.y > min(a.y, b.y) && p.y < max(a.y, b.y))\n        {\n            float x_where_y_equals_py = (p.y - intercept) / slope;\n            if (x_where_y_equals_py > p.x)\n            {\n                num_intersections++;\n            }\n        }\n    }\n    \n    // Is num_intersections odd?\n    if (num_intersections % 2 == 1) m = -m;\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n        \n    // add more points\n    vec2[] polygon = vec2[N](\n        0.8*cos( 0.40*iTime + vec2(0.0,2.00) + 0.0 ),\n        0.8*cos( 0.45*iTime + vec2(0.0,1.50) + 1.0 ),\n        0.8*cos( 0.50*iTime + vec2(0.0,3.00) + 2.0 ),\n        0.8*cos( 0.55*iTime + vec2(0.0,2.00) + 4.0 ),\n        0.8*cos( 0.60*iTime + vec2(0.0,1.00) + 5.0 )\n    );\n    \n\tfloat d = sdPolygon(p, polygon);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    if( iMouse.z>0.001 ){\n        d = sdPolygon( m, polygon );\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = col.xyzz;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXBW4.jpg", "access": "api", "license": "mit", "functions": [], "test": "untested"}
{"id": "ctXfW4", "name": "Approx sphere soft shadow", "author": "Blindman67", "description": "Very simple soft shadow approximation test. ", "tags": ["shadow", "sphere"], "likes": 3, "viewed": 154, "published": 3, "date": "1692902392", "time_retrieved": "2024-07-30T17:37:06.064572", "image_code": "#define PLANET_RADIUS 4.0\n#define ATMOSPHERE_DEPTH 0.25\n#define CAMERA_OFFSET 80.0\n#define CAMERA_LENGTH 0.2\n\n#define RAY_SRC_SPHERE 2u\n#define RAY_SRC_SPACE 3u\n#define RAY_SRC_AIR   4u\n\nconst vec4 COL_SUN          = vec4(1, 1, 1, 62.0);\nconst vec4 COL_AMBIENT      = vec4(0.005, 0.01, 0.02, 1.0) * 5.0;\n\nRay camera = Ray(vec3(0), vec3(0));\nRay ray = Ray(vec3(0), vec3(0));\nSphere world = Sphere(vec3(0), PLANET_RADIUS, PLANET_RADIUS * PLANET_RADIUS);\nSphere world1 = Sphere(vec3(6, 0, 0), PLANET_RADIUS * 0.5, pow(PLANET_RADIUS * 0.5,  2.0));\nSphere world2 = Sphere(vec3(9, 0, 0), PLANET_RADIUS * 0.25, pow(PLANET_RADIUS * 0.25,  2.0));\nconst Sphere sun = Sphere(vec3(1000,520, 10), PLANET_RADIUS, pow(PLANET_RADIUS, 2.0));\nuint type = RAY_SRC_SPACE;\nvec2 invRes;\nvec3 srcPos;\nvec3 srcPosN;\nbool shadow = true;\nfloat soft = 0.0;\nbool TraceShadow(Ray ray, Sphere w) {\n    vec3 d = DistAllSphere(ray, w); \n    if (d.x >= FAR || d.x < 0.0) { return false; }\n\n    soft -= clamp(w.radius -length(ray.origin + ray.dir * d.z - w.origin), 0.0, 0.5) * 2.0;\n\n    return true;\n}\nvec2 Trace(Ray camera) {\n    shadow = false;\n\tfloat wDist = DistToSphere(camera, world); \n    float wDist1 = DistToSphere(camera, world1); \n    float wDist2 = DistToSphere(camera, world2); \n    float mDist = min(wDist, min(wDist1, wDist2));\n    if (mDist >= FAR) {\n        type = RAY_SRC_SPACE;\n        return vec2(0);\n    \n    }\n    type = RAY_SRC_SPHERE;\n    srcPos = camera.origin + camera.dir * mDist;\n    soft = 1.0;\n    if (wDist < wDist1 && wDist < wDist2) {\n        srcPosN = normalize(srcPos - world.origin);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world1);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world2) || shadow;\n    } else if (wDist1 < wDist2) {   \n        srcPosN = normalize(srcPos - world1.origin);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world2) || shadow;\n    } else {\n        srcPosN = normalize(srcPos - world2.origin);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world);\n        shadow = TraceShadow(Ray(srcPos, normalize(sun.origin - srcPos)), world1) || shadow;\n    }\n\n    soft = UClamp(soft);\n    return vec2(atan(srcPosN.z, srcPosN.x) * INV_TAU, acos(-srcPosN.y) * INV_TAU);  \n}\n\nvec3 Light(vec3 col) {    \n    vec3 L = normalize(sun.origin - srcPos);\n    vec3 R = reflect(L, srcPosN);\n    float light = UClamp(dot(normalize(srcPosN), L)) * soft;\n    vec3 a = col * COL_AMBIENT.rgb;\n    float spec = pow((col.r + col.g + col.b) * (1.0 / 3.0), 0.5);\n    col *= light;            \n    col += spec * soft * pow(UClamp(dot(camera.dir, R)) * COL_SUN.rgb, vec3(COL_SUN.a)) ;\n    col += a;\n    return col + COL_AMBIENT.rgb;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 px ) {\n    world1.origin = vec3(sin(iTime*0.133) * 5.5, cos(iTime*0.133) * 5.5, 0);\n    world2.origin = vec3(sin(iTime) * 2.75 + world1.origin.x, + world1.origin.y, cos(iTime) * 2.75 + world1.origin.z);\n    invRes = InvRes(iResolution.xy);\n    vec2 look = iMouse.x < 1.0 && iMouse.y < 1.0 ? iResolution.xy * vec2(0.5, 0.45) : iMouse.xy;\n    mat3 vmat = lookMouse(look / iResolution.xy * vec2(4.0, 2.0));\n    vec2 uv = (px - iResolution.xy * 0.5) * invRes.y;\n    camera.origin =  - vmat[2] * CAMERA_OFFSET;\n    camera.dir = normalize(vmat * vec3(uv  * CAMERA_LENGTH, 1.0));\n    vec2 coord = Trace(camera);\n    uv = coord / iResolution.xy;\n    if (type == RAY_SRC_SPHERE) {\n        col = vec4(Light(texture(iChannel0, coord).xyz), 1);\n    } else {\n        col = vec4(0);\n    }\n\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define EPSILON 0.0001\n#define TINY 0.001\n#define FAR  10000.0\n\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float ANG_90 = PI * 0.5;\nconst float INV_PI = 1.0 / PI;\nconst float INV_ANG_90 = 1.0 / ANG_90;\nconst float INV_TAU = 1.0 / TAU;\nconst float INV_60 = 1.0 / 60.0;\nconst float INV_64 = 1.0 / 64.0;\nconst float INV_255 = 1.0 / 255.0;\n\n\nstruct Ray {vec3 origin; vec3 dir;};\nstruct Sphere {vec3 origin; float radius; float radiusSqr;};\nvec3 Uint2RGB(uint c) { return vec3(float((c >> 16u) & 255u) * INV_255, float((c >> 8u) & 255u) * INV_255, float(c & 255u) * INV_255); }\nfloat UClamp(in float v) { return clamp(v, 0.0, 1.0); } /* U for unit */\nvec2 Rotate(in vec2 uv, float a) {\n    float c = cos(a), s = sin(a);\n    return vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n}\n\nvec3 InvRes(in vec3 res) { return 1.0 / res; }\nvec2 InvRes(in vec2 res) { return 1.0 / res; }\nvec2 FixUV(in vec2 uv, in vec3 res) { return (2.0 * uv - res.xy); }\nfloat Time(in int f) { return float(f) * INV_60; }\nfloat Time(in int f, in float scale) { return float(f) * INV_60 * scale; }\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\nmat3 lookMouse(in vec2 unitMouse) {  return camMatrix((unitMouse.x * 1.0 + 0.0) * PI, (unitMouse.y * 0.5 + 0.5) * PI); }\n\n\n\nfloat DistOutSphere(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin - ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return FAR; }\n    return d + sqrt(sphere.radiusSqr - d2);\n}\nfloat DistToSphere(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin - ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return FAR; }\n    return d - sqrt(sphere.radiusSqr - d2);\n}\nvec2 DistToSphereInOut(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin -ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return vec2(FAR); }\n    float t = sqrt(sphere.radiusSqr - d2);\n    return vec2(d - t, d + t);\n}\nvec3 DistAllSphere(in Ray ray, in Sphere sphere) {  \n    vec3 s = sphere.origin -ray.origin;\n    float d = dot(s, ray.dir);\n    float d2 = dot(s, s) - d * d;\n    if (d2 >= sphere.radiusSqr) { return vec3(FAR); }\n    float t = sqrt(sphere.radiusSqr - d2);\n    return vec3(d - t, d + t, d);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[830, 830, 867, 867, 1068], [1069, 1069, 1093, 1093, 2387], [2389, 2389, 2411, 2411, 2827], [2830, 2830, 2874, 2874, 3645]], "test": "untested"}
{"id": "mtlfDH", "name": "Mondrian Truchet explored", "author": "misol101", "description": "Found this nice truchet pattern (see link), but just felt it could use some spin and movement to explore it. All credits to XT95!\n\nPress mouse button to zoom.\n\nUse fullscreen!", "tags": ["2d", "truchet", "pattern", "mondrian", "samuel", "monnier"], "likes": 24, "viewed": 473, "published": 3, "date": "1692898000", "time_retrieved": "2024-07-30T17:37:06.845485", "image_code": "// Movement and zoom added by misol101.\n\n// ---------------------------------------------------------------------------------------\n//\tCreated by anatole duprat - XT95/2017\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Truchet variation with Mondrian color style \n//  Idea by Samuel Monnier : http://algorithmic-worlds.net\n//\n//  Looks better in fullscreen !\n//\n// ---------------------------------------------------------------------------------------\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// we need 3 cells to do this effect\nconst vec2 dir[3] = vec2[]( vec2(0.,0.), vec2(1.,0.), vec2(0.,1.)); \n\n// color palette\nconst vec3 palette[7] = vec3[]( vec3(.8,0.,0.), vec3(0.,.4,1.), vec3(1.,1.,1.),\n        \t\t\t\t\t  vec3(1.,.8,0.), vec3(1.,.9,.9), vec3(.7,.8,1.),\n        \t\t\t\t\t  vec3(1.,.9,.8) );\n\n\nvoid Mondrian( vec2 uv, float res, inout vec4 col, inout int currentPalette )\n{\n    uv *= res;\n\tfloat lw = max(0.001*res,0.02); // line width\n    \n    \n    // cell tiling\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n\n\t// random number for each cell\n    vec2 v[3];\n    for(int i=0; i<3; i++)\n        v[i] = (texture(iChannel0, (iuv+dir[i])/256.).rg)*(1.-exp(-iTime));\n    \n    \n    // draw segments in the four directions\n    float l = 1.;\n    l = min(l, abs(fuv.y-v[0].y) + step( max(v[2].x,v[0].x)+lw, fuv.x ) );\n    l = min(l, abs(fuv.y-v[1].y) + step( fuv.x+lw, min(v[2].x,v[0].x) ) );\n    l = min(l, abs(fuv.x-v[0].x) + step( max(v[1].y, v[0].y), fuv.y ) );\n    l = min(l, abs(fuv.x-v[2].x) + step( fuv.y, min(v[1].y,v[0].y) ) );\n    \n    \n    // get random color if we are in the box of the four segments\n    if( step( fuv.x, max(v[2].x,v[0].x) ) * step( min(v[2].x,v[0].x), fuv.x ) *\n        step( fuv.y, max(v[1].y,v[0].y) ) * step( min(v[1].y,v[0].y), fuv.y )  > .1 )\n    {\n        \n        currentPalette = int( mod(v[0].y*42.+float(currentPalette), 7.) );\n        col.rgb = palette[currentPalette];\n    }\n    \n    // line are done in a separate channel to simplify the blending\n    col.a *= step(lw, l);\n}\n\n\n// classic hash function for jittering\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int nbSample = 3;\n    vec3 c = vec3(0.);\n    \n    \n    for(int s=0; s<nbSample; s++)\n    {\n    \tvec2 uv = (-iResolution.xy + 2.0*(fragCoord+(hash2( float(s) )-0.5)))/ iResolution.y;\n\n        uv*=rot(-iTime/4.);\n\n    \tint currentPalette = 2;\n    \tvec4 col = vec4(1.);\n        for(int i=0; i<4; i++)\n        {\n            vec2 p = (uv+vec2(iTime/87.,0.)) + vec2(3.,0.)*((iTime/8.));\n            if (iMouse.z > 0.) {\n                p = (uv+vec2(iTime/87.,0.)) + vec2((4.-float(i))*0.6,0.) + vec2(1.,0.)*((iTime/194.));\n                p *= sin(iTime/2.)*0.4 + 0.685; \n            }\n            float res = float(i*i)*2.+1.;\n       \t\tMondrian(p, res, col, currentPalette);\n        }\n\n\t\tc += col.rgb*col.a;\n    }\n    \n    c /= float(nbSample);\n\tfragColor = vec4(c, 1.0);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlfDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[859, 859, 938, 938, 2081], [2084, 2123, 2146, 2146, 2216], [2219, 2219, 2276, 2276, 3055]], "test": "untested"}
{"id": "clsfW8", "name": "Day 1344", "author": "jeyko", "description": "poto", "tags": ["pathtracing", "monochrome", "mdtmjvm"], "likes": 28, "viewed": 511, "published": 3, "date": "1692893524", "time_retrieved": "2024-07-30T17:37:07.831847", "image_code": "// Fork of \"Day 60smth WIP\" by jeyko. https://shadertoy.com/view/7tjXWd\n// 2023-08-24 08:52:32\n\n// box intersection from IQ\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C= max(texture(iChannel1,U/R),0.);\n    C = min(C,0.95);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)\n#define NO_INTERSECTION -1.123456\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n#define iTime (iTime + 25.)\n\nuint seed = 111425u;\n\nuint hash_u(uint _a) {\n   uint a = _a;\n   a ^= a >> 16;\n   a *= 0x7feb352du;\n   a ^= a >> 15;\n   a *= 0x846ca68bu;\n   a ^= a >> 16;\n   return a; \n}\n\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 4.;  // max display brightness\n    const float a = 2.5;  // contrast\n    const float m = 0.2; // linear section start\n    const float l = 0.;  // linear section length\n    const float c = 1.3; // black\n    const float b = 0.;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat r11(float g){return fract(sin(g*12.5)*4.5);}\n\nvec3 temp_norm;\nfloat boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out bool inters_inside) {\n    //boxSize -= 0.004;\n    // convert from ray to box space\n\tvec3 rdd = (vec4(rd,0.0)).xyz;\n\tvec3 roo = (vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    \n    vec3 n = m*roo;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n    // no intersection\n\tif( tN>tF || tF<0.0 ) return NO_INTERSECTION;\n    \n    // use this instead if your rays origin can be inside the box\n    inters_inside = tN < 0.0;\n    vec4 res = !inters_inside ? vec4( tN, step(vec3(tN),t1)) :\n                          vec4( tF, step(t2,vec3(tF)));\n    //vec4 res = vec4(tN, step(tN,t1) );\n    \n    temp_norm = (vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n\n    \n    return res.x;\n}\n\n\n#define pi acos(-1.0)\n#define tau (2.*pi) \n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\nfloat hash_21_s(ivec2 _s_){ \n  uvec2 s = uvec2(_s_ + 2000);\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \n  return hash_f_s(_s); \n}\nfloat valueNoise( in vec2 p ){\n    p += 100.;\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \n                     hash_21_s( i + ivec2(1,0) ), u.x),\n                mix( hash_21_s( i + ivec2(0,1) ), \n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\n}\n/*\nvoid mainImagea( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C -= C;\n    vec2 uv = (U - 0.5*R)/R.y;\n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(\n        sin(muv.x*pi)*cos(muv.y*pi/1.),\n        cos(muv.y*pi/1.),\n        cos(muv.x*pi)*cos(muv.y*pi/1.)\n    )*0.4;\n    \n    vec3 rd = getRd(ro,vec3(0.0),uv);\n    const float bayer[] = float[64](\n         0./63., 32./63., 8./63., 40./63., 2./63., 34./63., 10./63., 42./63., \n        48./63., 16./63., 56./63., 24./63., 50./63., 18./63., 58./63., 26./63., \n        12./63., 44./63., 4./63., 36./63., 14./63., 46./63., 6./63., 38./63.,\n        60./63., 28./63., 52./63., 20./63., 62./63., 30./63., 54./63., 22./63., \n         3./63., 35./63., 11./63., 43./63., 1./63., 33./63., 9./63., 41./63., \n        51./63., 19./63., 59./63., 27./63., 49./63., 17./63., 57./63., 25./63.,\n        15./63., 47./63., 7./63., 39./63., 13./63., 45./63., 5./63., 37./63.,\n        63./63., 31./63., 55./63., 23./63., 61./63., 29./63., 53./63., 21./63.\n    );    \n\tvec2 buv = mod(floor(U.xy), 8.);\n\tfloat bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    //seed += uint(bay*64.);\n    \n    vec3 p = ro;\n    //rd = normalize(vec3(uv,0.5));\n    \n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    //rd.xy *= rot((t)*0.4);\n    vec3 thr = vec3(1);\n    \n    vec3 em = vec3(0);\n    \n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 box = intersect(p,rd);\n        p = p + rd *  (box.x > 0. ? box.x : box.y);\n        vec4 c = get(p);\n        \n        thr *= c.xyz;\n        if(c.w > 0.1){\n            em += c.xyz*c.w;\n        }\n        \n        \n        float bncSubCnt = 1240.;\n        \n        p += n*0.002;\n        \n        vec3 subs = vec3(0);\n        for(float bncSub = 0.; bncSub < bncSubCnt; bncSub++){\n            vec3 brd = randomCosineHemisphere(n*1.);\n            \n            vec2 scene = intersect(p,brd);\n            \n            vec3 pp = p + brd * (scene.x > 0. ? scene.x : scene.y);\n            vec4 c = get(pp);\n            if(c.w > 0.03){\n                subs += thr * c.xyz / bncSubCnt;\n                em += c.w * thr * c.xyz / bncSubCnt;\n            }\n            \n            //att *= c;\n        \n            //vec2 \n        }\n        thr *= subs;\n    }\n    C.xyz += em;\n    \n    \n    if(iFrame == 0){\n        C = vec4(0,0,0,1);\n    }\n}\n*/", "buffer_a_code": "\n\nfloat sdBox(vec2 p, vec2 sz){\n    p = abs(p) - sz;\n    return max(p.x,p.y);\n}\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 uvn = (U - 0.5*R.xy)/min(R.x,R.y);\n    C = vec4(0);\n    int F = iFrame % 120;\n    seed += uint(iFrame/120)*1000u;\n    if(F == 0){ \n        C = Ta(uv);\n        C.w = 1.0;\n    } else{\n        if(F == 1){\n            uv += step(valueNoise( uv*rot(5.5+ hash_f()*20.)*vec2(0.01,5.) ),0.5)*0.4;\n            C = Tb(uv); \n            if(sdBox(mod(uvn*rot(0.) - hash_v2()*1. - 0.5,4.), vec2(0.7,5.)) < 0.){\n                C.w = 15.;\n                C += 11.5;\n            }  \n        } else if (F == 2){\n            uv -= smoothstep(valueNoise( uv*rot(5.5 + hash_f()*20.)*vec2(0.01,5.) ),0.1,0.104)*0.4;\n            C = Tb(uv)*vec4(0.5,1.5,1,1.) - Ta(uv*14.).yyyy; \n            \n            if(length(fwidth(uv)) > 0.5){\n                C = vec4(1);\n            }\n        } else if (F == 3){\n            uv -= smoothstep(valueNoise( uv*rot(5.5+ hash_f()*20. + 3.14/2.)*vec2(0.01,5.) + 5. * hash_f() ),0.1,0.104)*0.4;\n            C = Tb(uv)*vec4(1,1,1,1.); \n            C = Tb(uv + 0.1 * float(C.w > 0.9))*vec4(1,1,1,1.); \n            \n            if(length(fwidth(uv)) > 0.42){\n                C = vec4(1);\n            }\n        } else {\n            C = Tb(uv);\n            \n            if(hash_f() > 0.5 || true){\n                C = Ta(uv*1.);\n                uv -= vec2(dFdx(C.y),dFdy(C.x))*0.41 * mix(0.,2.5,hash_f());\n                vec2 muv = (iMouse.xy - 0.5*R.xy)/min(R.x,R.y);\n                //C.xy += -15.*vec2(dFdx(C.y),dFdy(C.x))*0.41 * mix(7.,.5,hash_f());\n                //uv -= vec2(1)*rot(hash_f()*20.)*step(valueNoise( uv*rot(5.5+ hash_f()*20.)*vec2(0.01,5.) ),0.5)*0.001;\n                \n                C = Tb(uv);\n            }\n        }\n    }\n    \n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 uvn = (U - 0.5*R.xy)/min(R.x,R.y);\n    C = vec4(0);\n\n  const float bayer[] = float[64](\n     0./63., 32./63., 8./63., 40./63., 2./63., 34./63., 10./63., 42./63., /* 8x8 Bayer ordered dithering */\n    48./63., 16./63., 56./63., 24./63., 50./63., 18./63., 58./63., 26./63., /* pattern. Each input pixel */\n    12./63., 44./63., 4./63., 36./63., 14./63., 46./63., 6./63., 38./63., /* is scaled to the 0..63 range */\n    60./63., 28./63., 52./63., 20./63., 62./63., 30./63., 54./63., 22./63., /* before looking in this table */\n     3./63., 35./63., 11./63., 43./63., 1./63., 33./63., 9./63., 41./63., /* to determine the action. */\n    51./63., 19./63., 59./63., 27./63., 49./63., 17./63., 57./63., 25./63.,\n    15./63., 47./63., 7./63., 39./63., 13./63., 45./63., 5./63., 37./63.,\n    63./63., 31./63., 55./63., 23./63., 61./63., 29./63., 53./63., 21./63.\n  );    \n    \n    C = Ta(uv);\n    C = C + texture(iChannel0,uv,2. + mod(iTime*float(sin(iTime*5.)>0.),2.))*0.1;\n    vec4 oC = C;\n\t//vec2 fuv = floor((uv + 5.)/ sc) * sc;\n\t//vec2 buv = mod(fuv/sc, 8.);\n    \n    float luma = dot(C.xyz,C.xyz);\n    \n    seed = uint(iFrame/60);\n\n    vec2 bay_mult = vec2(1.0,4.);\n    \n    if(luma  < 0.42){\n        bay_mult *= 2.;\n    } else if(luma > 0.02){\n        bay_mult.y *= 1. + 1114442. * fwidth(oC.w);\n        if(fwidth(oC.x) > 0.07){\n            bay_mult *= 4.;\n        }\n    }\n    \n    \n\tvec2 buv = mod(floor(U.xy/bay_mult), 8.);\n    \n\tfloat bay = bayer[int(buv.x) + int(buv.y)*8];\n    if(C.w > 0.8){\n        if(luma > bay){\n            C = vec4(1);\n        } else {\n            C = vec4(0);\n        }\n    } else {\n        if(luma > 0.02){\n            C = vec4(1);\n        } else {\n            C = vec4(0);\n        }\n    }\n    //C = 1.-C;\n    C.x += dFdx(oC.w)*1.;\n    vec4 atten = 1.-vec4(hash_f(),1.- hash_f(),hash_f(),1)*50.;\n    for(int i = 0; i < 4; i++){\n        seed = uint(iFrame/60 + i);\n        C[i] += fwidth(oC.x * valueNoise( uvn*1. + 4.))*(\n            atten[i]\n        );\n    }\n    //C = pow(abs(C),vec4(14.4545));\n    C = clamp(C,0.,1.);\n    C = 1.-C;\n    //C -= 0.5;\n    //C = pow(abs(C),vec4(2.2,1.9,0.9,0.9));\n    if(C.x < 0.1){\n        C += 0.1;\n    }\n    C -= 0.05 * valueNoise( uvn*400.) + 0.02;\n}\n", "buffer_d_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n#define pi acos(-1.0)\n//#define tau 2.*pi\n\n#define pmod(p,a) mod(p,a) - 0.5*a\nvec3 gp;\nvec3 norm;\nfloat id;\nfloat inside = -1.;\nvec4 get(vec3 p){\n    //return vec4(0.5,0.5,0.2,1.);\n    if(inside > 0.){\n        //return vec4(0.2,0.2,0.2,1.)*0.;\n    }\n    bool h = dot(norm,vec3(-1)) > 0.; \n    if(h){\n        p.xz = -p.xz/4.;\n    }\n    int im = (iFrame + int(id)*40) % 240;\n    vec4 c = vec4(texture(iChannel0,\n        im < 60 ? p.yy*0.2 : p.zx*.22\n        ,0.).xyz,1.0);\n    if(h){\n        c.w = 0.;\n        c.xyz = 1.-c.xyz;\n        c *= 0.3;\n        c = max(c,0.1);\n    }\n    //c = clamp(c,0.0,1.);\n    return c;\n}\n\nvec2 dmin(vec2 a, float b, float id){\n    if(abs(id - inside) < 0.002){\n        return a;\n    }\n    vec2 inters = a;\n    \n    if((b - NO_INTERSECTION) < 0.04){\n    } else if (\n        ( b < a.x) ||\n        a.x - NO_INTERSECTION < 0.02\n        ) {\n        inters = vec2(b, id);\n        norm = temp_norm;\n    }\n    return inters;\n}\nvec2 intersect(vec3 ro, vec3 rd){\n    vec2 ba = vec2(NO_INTERSECTION);\n    bool inters_inside;\n    ba = dmin(ba,boxIntersection(ro,rd,vec3(10.2,0.1,11.4),inters_inside),1.);\n    ba = dmin(ba,boxIntersection(ro +0.0*vec3(0,-1.5+ valueNoise(vec2(iTime*1.))*.5,0.),rd,vec3(0.4,.2,0.4),inters_inside),2.);\n    ba = dmin(ba,boxIntersection(ro - vec3(0,0,0),rd,vec3(0.1,0.3,0.1),inters_inside),0.1);\n    ba = dmin(ba,boxIntersection(ro + vec3(0,0,2.),rd,vec3(2.4,1.,0.4),inters_inside),4.);\n    //ba = dmin(ba,boxIntersection(ro + vec3(0,0,-1.),rd,vec3(10.4,0.1,0.4),inters_inside),5.);\n    \n    id = ba.y;\n    \n    \n    if(ba.x != NO_INTERSECTION && inside < 0.){\n        vec3 ro = ro + rd * ba.x + 1. + sin(floor(iTime));\n        vec2 md = vec2(1.5) + vec2(1,0)*mod(floor(iTime),2.)*0.6;\n        ivec2 id = ivec2(ro.xz/md);\n        ro.xz = mod(ro.xz,md) - 0.5*md;\n        \n        float s = hash_21_s(ivec2(id + iFrame/50));\n        float inters = boxIntersection(ro,rd,vec3(0.1,2.7,0.05)*s*md.xyx,inters_inside);\n        \n        if(inters != NO_INTERSECTION && inters_inside){\n            inside = ba.y;\n            ba.x = inters;\n            //ba = vec2(inters,2.);\n            norm = -temp_norm;\n            //norm = -norm;\n        }\n        //if()\n        //if()\n    \n    }\n    //ba = dmin(ba,boxIntersection(ro - vec3(0.2),rd,vec3(5.,0.2,5.)),1.);\n    return ba;\n}\n\n\n/*\nvec2 dmin(vec2 a, float id, vec4 b ){\n    if (a.x < b.x ||  b.x == NO_INTERSECTION){\n    \treturn a;\n    } else if (  m.w < 1. ){\n\t\tglow += shade(id,b.x,b.yzw);\n        return a;\n    } else {\n        N = b.yzw;\n        return vec2(b.x,id);\n    }\n    \n}\n*/\nvec3 rand_sphere_dfox(){\n    float z = hash_f() * 2.0f - 1.0f;\n    float a = hash_f() * tau;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 randomCosineHemisphere(vec3 n){\n    return normalize(rand_sphere_dfox() + n);\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C = vec4(0);\n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    vec2 muv = (iMouse.xy - 0.5*R)/min(R.y,R.x);\n    \n    vec3 ro = vec3(0.1);\n    vec3 rd = normalize(vec3(uv,0.5));\n    \n    muv = vec2(0.3,-0.1);\n    \n    muv.x += sin(iTime*0.4 + sin(iTime*0.6))*0.1;\n    muv.y += sin(iTime*0.7 + sin(iTime*0.4))*0.05;\n    float t = iTime + sin(iTime + 3.);\n    //rd.xz *= rot((t)*0.4);\n    vec3 lookat = vec3(0.0,-0.2,0);\n    \n    lookat += sin(vec3(0.5,0.2,0.6)*iTime)*0.1;\n    //rd.xy *= rot((muv.x)*1.4);\n    if(true){\n        ro = vec3(\n            sin(muv.x*pi)*cos(muv.y*pi/1.),\n            sin(muv.y*pi/1.),\n            cos(muv.x*pi)*cos(muv.y*pi/1.)\n        )*2.5 + vec3(0,-0.8,0);\n        rd = getRd(ro,lookat,uv*(0.35 + sin(iTime*0.2 + sin(iTime*0.3))*0.1));\n    }\n    vec2 buv = mod(floor(U.xy), 8.);\n    seed += uint(texelFetch(iChannel1,ivec2(buv),0)*64.0)*4u;\n\t//float bay = bayer[int(buv.x) + int(buv.y)*8];\n    \n    \n    vec3 p = ro;\n    vec3 thr = vec3(1);\n    \n    vec3 acc = vec3(0);\n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 res = intersect(p,rd);\n        if(abs(res.x - NO_INTERSECTION) > 0.02){\n            vec3 N = norm;\n            p = p + rd*res.x;\n            vec4 c = get(p);\n\n            thr *= c.xyz;\n            if(c.w > 0.2){\n                acc += c.xyz*c.w*0.5;\n            }\n\n\n            float bncSubCnt = 184.;\n\n            p += N*0.002;\n\n            vec3 subs = vec3(0);\n            for(float bncSub = 0.; bncSub < bncSubCnt + min(float(iFrame),0.); bncSub++){\n                vec3 brd = randomCosineHemisphere(N);\n\n                vec2 res = intersect(p,brd);\n                \n                vec3 pp = p + brd * res.x;\n                vec4 c = get(pp);\n                if(c.w > 0.02 && abs(res.x - NO_INTERSECTION) > 0.002){\n                    subs += thr * c.xyz / bncSubCnt;\n                    acc += c.w * thr * c.xyz / bncSubCnt;\n                } else {\n                    acc += .8*thr * vec3(0.2,0.2,0.2) * (0.4 + .6*float(0.4*mod(iTime,4.) < 1.)) / bncSubCnt;\n                \n                }\n\n                //att *= c;\n\n                //vec2 \n            }\n        } else {\n            acc += 1.0;\n        }\n    }\n    C.xyz += acc;\n    \n    \n    C.xyz = tonemap_uchimura2(C.xyz*4.5);\n    //C = C/(1.+C);\n    C*=1.1;\n    C = pow(C,vec4(.4545));\n    //C = clamp(C,0.,1.);\n}", "buffer_b_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\n// idk where this is from, copied from noby shader\n\nfloat FXAAamt = 0.5;\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 164, 164, 255]], "test": "untested"}
{"id": "mllfW8", "name": "hexagonal Void And Cluster", "author": "FabriceNeyret2", "description": "hexagonal Void And Cluster bluenoise + its power spectrum ( sigma = 2.5 )\n- in A, the energy rejection modulo is along equilateral triangle grid\n- tile is 64*(1,sqrt(3)/2), should repeat as brick wall → inst, we produce 64*(1,sqrt(3)) which tiles as usual", "tags": ["noise", "bluenoise"], "likes": 18, "viewed": 347, "published": 3, "date": "1692890218", "time_retrieved": "2024-07-30T17:37:08.627719", "image_code": "// Hexagonal variant of https://shadertoy.com/view/DlXfWn\n// inspired from krax shader + my simplifications: https://www.shadertoy.com/results?query=Void+And+Cluster+Bluenoise\n\n// ===  Fourier Transform of Void And Cluster bluenoise ( Buff A,B,C, from https://www.shadertoy.com/view/mt2cWR ) ===\n// fork from Fourier-based transform (e.g. kernel convolution) using https://www.shadertoy.com/view/4s3GDs\n// adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS#\n// see also https://www.shadertoy.com/view/4dGGz1 to play with spectrum.\n\n\n// #define paintDFT(F) log(length(F)) / log(SIZE.x*SIZE.y)     // log scale\n   #define paintDFT(F)     length(F) / sqrt(SIZE.x*SIZE.y)     // linear scale    \n\nvoid mainImage( out vec4 O,  vec2 u )\n{ \n    vec2 R = iResolution.xy,     \n         U = ( u - R/2.) / SIZE  + vec2(2,1)/2.,\n         I = floor(U);\n         U = fract(U) * SIZE / R ;\n\n // O =       texelFetch(iChannel0, ivec2(u) % (S*ivec2(1,2)), 0).xxxx ;return;              // uncomment for fullpage texture\n // O = vec4( texelFetch(iChannel0, ivec2(u) % (S*ivec2(1,2)), 0).x < iMouse.x/R.x) ;return; // dither(mouse.x)\n\n//O = texture(iChannel0,u/R*s/R      *vec2(1,2))/64.;                        return;  // (for debug)\n//O = texture(iChannel2,u/R*s/8./R   *vec2(1,2)).yzwx / vec4(.0001,64,64,0); return;\n//O = texture(iChannel3,u/R*s/8./8./R*vec2(1,2)).yzwx / vec4(.0001,64,64,0); return;\n    O *= 0.;\n    \n    O +=  I == vec2(0,0) ? texture(iChannel0, (u+vec2(1,.5)*SIZE-floor(R/2.))/R).x // left tile: Input image\n                        // texture(iChannel0, U).x                     // left tile: Input image\n        : I == vec2(2,0) ? paintDFT(texture(iChannel1, U*SIZE/s.x).xy) // right tile: DFT\n        : I.x < -1.      ? texture(iChannel0, u/R).x                   // left border: repeated tile\n        :                  .3;  \n    \n    if ( int(u) > int(R)-10 ) { O = vec4(1, u.y/R.y > float(iFrame)/(s.x*s.y),0,0); return; } // red separator + progress bar\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define SIZE (2.*floor(iResolution.xx/4.*.8)) // uncomment for large spectrum (not nice for repeated tiles )\n  #define SIZE (s*vec2(1,2))\n\nconst ivec2 S = ivec2(64,55);  // bluenoiseSize = S x S.sqrt(3)/2 , cycling tile (like brick wall. use S.y*2 for regular tiling).\nvec2  s = vec2(S);             // note that more buffers are needed if S > 64 : clone C , S/8^(i+1)\nfloat sigma = 2.5;             // NB: krax used 1.9 \n\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y) % S, 0)\n\nfloat H( uvec3 x ) {           // from iq https://www.shadertoy.com/view/XlXcW4\n    uint k = 1103515245U;      // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n // x = ((x>>8U)^x.yzx)*k;     // but this version only return 10⁻¹⁹ amplitude\n    return uintBitsToFloat( ((((x.x>>8U)^x.y)*k )  & 0x1fffffffU) );\n}\n\n#define M(S,c)                                                                                         \\\nvoid mainImage( out vec4 O, vec2 U ) {                                                                 \\\n    if( U.x > vec2((S+7)/8).x || U.y > vec2((S+7)/8).y ) return; /* we only simulate a small square */ \\\n    O = vec4( 0,1e35,0,0);                                                                             \\\n    ivec2   start = min( ivec2(U)*8, S - 1 ),                 /* to reduce a 8x8 above subtile to 1 */ \\\n              end = min( start + 8, S );                                                               \\\n    for( int y=start.y; y<end.y; ++y)                                                                  \\\n      for( int x=start.x; x<end.x; ++x) {                                                              \\\n        vec4 E = T(x,y);                                                                               \\\n        c;                                                    /* store result */                       \\\n}   } \n", "buffer_a_code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background energy.\n// output: .x = bluenoise, .y = energy.   \n// input:  D.yz = location or largest void.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0, ivec2(U) % (S*ivec2(1,2)), 0);  // uncomment to repeat copies\n    if( U.y>s.y && U.y<2.*s.y )  O = T(U.x+s.x/2.,U.y);       // to avoid managing brick wall tiling, copy the offseted odd line\n    if( U.x>s.x || U.y>s.y ) return; // we only simulate a small (cyclicling) tile\n\n    if(iFrame == 0)                  // init: noise = 0, energy = random\n    {   O.xy = vec2( 0, H(uvec3(U, 2111)) );\n        return;\n    }\n    \n    O = T(U.x,U.y);                  // previous state\n    if(iFrame > S.x*S.y-1) return;   // max iteration reached\n \n \n    // Get the result from downscaling and finding the smallest void center\n    U = abs( floor(U) - texelFetch(iChannel1, ivec2(0), 0).zw ) / s;  // delta to target\n\n    float v = 1. - float(iFrame-1) / (s.x*s.y-1.); // noise value = normalized iterations\n\n    // Wrap around logic : max energy around optimal void center modulo s : https://www.desmos.com/calculator/zuopknqihy\n//  vec2 d = ( abs( U - .5 ) - .5 )  * s / sigma;\n    U*=s; \n    float d = min( min( length(U), length(U-vec2(s.x,0)) ), length(U-vec2(s.x/2.,s.y)) ) / sigma;\n    // should I reject more modulos ?\n    d = min(d, min( length(U-vec2(-s.x/2.,s.y)),length(U-vec2(3.*s.x/2.,s.y)) ) / sigma );  // probably useless ?\n    \n    O.xy += vec2( U==vec2(0) ? v : 0.,            // we are at the optimum : store noise\n                  v * exp( -d*d )                 // energy += gaussian to optimum\n              //  v * max(0., 1.-d )              // variant\n                );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Void and cluster reduce init\n// input:  .xy = SxS state noise,energy.\n// output: .yzw = lowest energy value + position on SxS /8   ( and not already chosen )\n\nM( S , \n   if( E.x == 0. && E.y < O.y ) O = vec4( 0, E.y, x, y )\n )", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Void and cluster reduce iteration\n// input:  .xy = SxS /8 state energy,location\n// output: .yzw = lowest energy value + position on SxS /8²  ( and not already chosen )\n//                note that with S = 64 this is only 1 pixel.\n\nM( (S+7)/8 ,                                            \n   if( E.y < O.y ) O = E\n )", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fourier transform of the input\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\n#define tex(ch,I)  texelFetch(ch, I, 0)\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O-=O; \n    \n    if(uv.x > SIZE.x || uv.y > SIZE.y) return;\n        \n    for(float n = 0.; n < SIZE.x; n++)  {\n        vec2 xn = tex(iChannel0, ivec2(n+.5, uv.y) ).xy,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;       \n        O.zw += cmul(xn, a.x);\n    }\n    for(float n = 0.; n < SIZE.y; n++)  {\n        vec2 yn = tex(iChannel1, ivec2(uv.x, n+.5) ).zw,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;\n        O.xy += cmul(yn, a.y);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[704, 704, 743, 743, 1978]], "test": "untested"}
{"id": "dllfD8", "name": "Interactive Mandelbulb 3", "author": "dr2", "description": "Partially transparent nested Mandelbulbs", "tags": ["mandelbulb", "transparent"], "likes": 14, "viewed": 199, "published": 3, "date": "1692890106", "time_retrieved": "2024-07-30T17:37:09.396663", "image_code": "// \"Interactive Mandelbulb 3\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Sliders control zoom, transparency and iteration count; default mode\n  sweeps latter two parameters; mouseable.\n  (Based on \"Interactive Mandelbulb 2\")\n*/\n\n#define AA   1     // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec4 Loadv4 (int idVar);\n\nvec3 ltDir;\nfloat dstFar, tCur, sFac, trFac;\nint nFrame, nItMx;\nconst float pi = 3.1415927;\n\nfloat ObjDf (vec3 p)\n{\n  vec4 aa, sa, ca;\n  vec3 c, q, qd;\n  float qLen, qdLen, q2, q4, phi, theta, thetad, phid;\n  q = p.xzy / sFac;\n  c = q;\n  qLen = length (q);\n  phi = atan (q.y, q.x);\n  theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n  thetad = 0.;\n  phid = 0.;\n  qdLen = 1.;\n  for (int n = VAR_ZERO; n < nItMx; n ++) {\n    q2 = qLen * qLen;\n    q4 = q2 * q2;\n    aa = vec4 (8. * vec2 (theta, phi), 7. * vec2 (theta, phi) + vec2 (thetad, phid));\n    sa = sin (aa);\n    ca = cos (aa);\n    q = q4 * q4 * vec3 (sa.x * vec2 (ca.y, sa.y), ca.x) + c;\n    qd = 8. * q4 * q2 * qLen * qdLen * vec3 (sa.z * vec2 (ca.w, sa.w), ca.z) + 1.;\n    qLen = length (q);\n    phi = atan (q.y, q.x);\n    theta = (qLen > 0.) ? acos (q.z / qLen) : 0.;\n    qdLen = length (qd);\n    phid = atan (qd.y, qd.x);\n    thetad = (qdLen > 0.) ? asin (qd.z / qdLen) : 0.;\n    if (qLen > 3.1623) break;\n  }\n  return (qLen > 0.) ? sFac * 0.5 * qLen * log (qLen) / qdLen : 0.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d, dMin, eps;\n  eps = 2e-4;\n  dMin = dstFar;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 0.001 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec3 parmV)\n{\n  vec4 wgBx[3];\n  vec3 cc[3], cw;\n  vec2 ut, ust, c;\n  float asp;\n  c = vec2 (1., 0.5);\n  cc[0] = c.xyy;\n  cc[1] = c.yxy;\n  cc[2] = c.yyx;\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < 3; k ++)\n     wgBx[k] = vec4 ((0.36 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n  for (int k = 0; k < 3; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (Maxv2 (ust) < 0.) {\n      if (Minv2 (abs (ust)) * canvas.y < 2.) cw = 0.3 * cc[k];\n      else cw = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? 0.3 * cc[k] : 0.6 * cc[k];\n    }\n    ut.y -= (parmV[k] - 0.5) * 2. * wgBx[k].w;\n    cw = mix (cc[k], cw, smoothstep (0., 0.5, abs (length (ut * vec2 (1., 1.5)) - 0.015) *\n       canvas.y - 3.));\n  }\n  return mix (col, cw, length (cw));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, roo, rdo, colS[3], cc[3];\n  vec2 c;\n  float dHit, b, rLim, nDotL;\n  roo = ro;\n  rdo = rd;\n  rLim = 3.;\n  c = vec2 (1., 0.2);\n  cc[0] = c.xyy;\n  cc[1] = c.yxy;\n  cc[2] = c.yyx;\n  b = - dot (ro, rd);\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    sFac = 0.6 + 0.2 * float (k);\n    ro = roo;\n    rd = rdo;\n    dHit = b * b - dot (ro, ro) + sFac * rLim;\n    if (dHit > 0.) {\n      ro += (b - sqrt (dHit)) * rd;\n      dHit = ObjRay (ro, rd);\n    } else dHit = dstFar;\n    if (dHit < dstFar) {\n      ro += dHit * rd;\n      vn = ObjNf (ro);\n      nDotL = max (dot (vn, ltDir), 0.);\n      colS[k] = cc[k] * (0.7 + 0.3 * smoothstep (0.7, 1., length (ro) / sFac));\n      colS[k] *= 0.2 + 0.8 * nDotL * nDotL + pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    } else colS[k] = vec3 (0.1);\n  }\n  col = mix (colS[0], colS[1], trFac);\n  col = mix (col, colS[2], 2. * max (trFac - 0.5, 0.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col, parmV;\n  vec2 canvas, uv;\n  float az, el, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  stDat = Loadv4 (0);\n  el = stDat.x;\n  az = stDat.y;\n  stDat = Loadv4 (2);\n  parmV = stDat.yzw;\n  zmFac = 30. * parmV.x + 8.;\n  trFac = parmV.y;\n  nItMx = 1 + int (5. * parmV.z);\n  dstFar = 20.;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -14.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowWg (uv, canvas, ShowScene (ro, rd), parmV);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Interactive Mandelbulb 3\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nint nFrame;\nconst float txRow = 32.;\nconst float pi = 3.1415927;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[3], stDat, mPtr, mPtrP;\n  vec3 parmV;\n  vec2 iFrag, canvas, ust;\n  float tCur, tCurP, el, az, asp, autoMod, tMan;\n  int pxId, wgSel, wgReg, kSel;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3) discard;\n  wgSel = -1;\n  wgReg = -2;\n  if (nFrame <= 1) {\n    el = -0.2 * pi;\n    az = 0.;\n    parmV = vec3 (0.1, 0.3, 0.3);\n    mPtrP = mPtr;\n    autoMod = 1.;\n    tMan = tCur;\n    tCurP = tCur;\n  } else {\n    stDat = Loadv4 (0);\n    el = stDat.x;\n    az = stDat.y;\n    autoMod = stDat.z;\n    tMan = stDat.w;\n    stDat = Loadv4 (1);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (2);\n    tCurP = stDat.x;\n    parmV = stDat.yzw;\n  }\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 3; k ++)\n       wgBx[k] = vec4 ((0.36 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n    for (int k = 0; k < 3; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    autoMod = 0.;\n    tMan = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az += 0.1 * (1. - 0.85 * parmV.x) * mPtr.x;\n      el += 0.1 * (1. - 0.85 * parmV.x) * mPtr.y;\n    }\n  } else {\n    parmV[wgSel] = clamp (0.5 + 0.5 * (mPtr.y - wgBx[wgSel].y) / wgBx[wgSel].w, 0., 0.99);\n  }\n  if (autoMod == 1.) {\n    az = mod (az + 0.05 * (tCur - tCurP), 2. * pi);\n    el = mod (el + 0.02 * (tCur - tCurP), 2. * pi);\n    parmV.y = SmoothBump (0.25, 0.75, 0.25, fract (0.03 * tCur));\n    parmV.z = 0.7 * SmoothBump (0.25, 0.75, 0.25, fract (0.02 * tCur));\n  } else if (tCur - tMan > 3.) {\n    autoMod = 1.;\n    tMan = tCur;\n  }\n  if      (pxId == 0) stDat = vec4 (el, az, autoMod, tMan);\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 2) stDat = vec4 (tCur, parmV);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllfD8.jpg", "access": "api", "license": "cc-by-nc-sa-2.0", "functions": [[592, 592, 614, 614, 1535], [1537, 1537, 1570, 1570, 1824], [1826, 1826, 1847, 1847, 2104], [2106, 2106, 2164, 2164, 2996], [2998, 2998, 3033, 3033, 3962], [3964, 3964, 4020, 4020, 5039], [5041, 5041, 5063, 5063, 5090], [5092, 5092, 5114, 5114, 5141], [5143, 5143, 5173, 5173, 5286], [5288, 5288, 5324, 5324, 5530], [5623, 5623, 5648, 5648, 5771]], "test": "untested"}
{"id": "DtsBWH", "name": "Fork: Dancing Glow Lights", "author": "QuantumSuper", "description": "Auto-VJ forked from Glow Lights, a 2.5D arrangement of lights & particles circling an invisible sphere.\n\n- Use with music in iChannnel0 -", "tags": ["2d", "music"], "likes": 15, "viewed": 533, "published": 3, "date": "1692884005", "time_retrieved": "2024-07-30T17:37:10.190540", "image_code": "// Fork: Dancing Glow Lights 0.1.230824 by QuantumSuper\n// Forked from Glow Lights 0.5.230821 by QuantumSuper\n// auto-vj of a 2.5d arrangement of lights & particles circling an invisible sphere\n//\n// - use with music in iChannel0 -\n\n#define PI 3.14159265359\n#define aTime 2.5*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\nfloat hash21(vec2 p){p = fract(p*vec2(13.81,741.76)); p += dot(p, p+42.23); return fract(p.x*p.y);} //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nfloat particle(vec2 p){ //single particle shape\n    return smoothstep( .1, .0, length(p)) * smoothstep( .1, .06, length(p-vec2(0.,.02)));\n}\n\nfloat particleLayer(vec2 p){ //pseudo-random 2d particle plane\n    float id = hash21(floor(p));\n    return smoothstep(0.,1.,id) *\n        particle((fract(p)-vec2(.5+.4*cos(id*iTime),.5+.4*sin(.8*id*iTime))) * rotM((id-fft.x)*2.*PI)/vec2(cos(.5*id*iTime),1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){ \n\n    // General initializations\n    compressFft(); //initializes fft, ffts\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n\tvec3 col = vec3(0);\n    \n    // Center orbs \n    vec3 p, camPos = vec3(0,0,-1.3+(.3*sin(aTime/16.))); //vec3 camDir = vec3(0,0,1); \n    float v1, v2, a = 11.;\n    for (float n=1.;n<a;n++){            \n        v1 = aTime + n/a*PI*4. - fft.x*n/a*1.;\n        v2 = iTime + n/a*PI + fft.y*mod(1.-n*2./a,2.)*1.;\n        p = vec3( cos(v1)*cos(v2), sin(v1)*cos(v2), sin(v2)) * .5*max(ffts.w,fft.x); //parametric sphere\n        p.yz *= rotM(n); //vary orientation\n        col += 1./((p.z-camPos.z)*(p.z-camPos.z)+dot(p.xy,p.xy)) * //vary brightness with distance\n            .001*(.8+1.*fft.x*fft.x) / max( .001, length(uv-camPos.xy-p.xy/(p.z-camPos.z)) - .02/(p.z-camPos.z)) * //orb shape, vary size with distance\n            (.5 + clamp( .01/max( .001, length(uv-camPos.xy-p.xy/(p.z-camPos.z)+.005*normalize(p.xy))), .0, .9)) * //light spot\n            (vec3(mod(n+.5,2.),mod(n,2.),mod(n*PI,2.))*ffts.xyz*.5 + .5*vec3(ffts.x<=ffts.y,ffts.y<=ffts.z,ffts.z<=ffts.x)); //color\n    }    \n\n    // Particle layers    \n    uv *= rotM(iTime*.1-.5*length(uv)); //rotate inner faster\n    float aFrac, amp = 0.; \n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-.05*iTime+.25*n)-.02*fft.w*fft.w*fft.w;\n        amp += 1.4*(.2+.8*fft.z)*particleLayer( (uv*mix(1.,length(uv),ffts.w)+n*vec2(.1,.05))*25.*aFrac) * smoothstep(1.,.33,aFrac) * (.1+.9*smoothstep(.33,.66,aFrac));\n        \n    }\n\tcol *= (1. + amp*40.*(1.+.5*fft.x*fft.x*fft.x/abs(length(uv)-fract(aTime)*1.15))); //expanding particle flash rings\n    col += .05*step(.95, fft.x)*hash21(vec2(aTime,iFrame))*mod(float(iFrame),2.)/abs(length(uv)-fract(aTime+.1)*1.15); //expanding large flash rings\n    \n    // Finalizations\n    col *= .3*hash21(uv*iTime) + .7; //noise\n\tcol -= length(uv) * .005; //vignette\n\tcol = pow(col, vec3(.4545)); //gamma correction    \n    fragColor = vec4(col,1.);\n}\n\n\n\n", "image_inputs": [{"id": 34536, "src": "https://soundcloud.com/verknipt-events/sara-landry-verknipt-festival-2022", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 333, 352, 352, 405], [406, 427, 448, 448, 526], [598, 598, 617, 708, 1830], [1832, 1832, 1855, 1879, 1971], [1973, 1973, 2001, 2035, 2233], [2235, 2235, 2290, 2323, 4322]], "test": "untested"}
{"id": "DllfWH", "name": "大龙猫 - Lightshockwave", "author": "totetmatt", "description": "Quick one", "tags": ["quicky"], "likes": 6, "viewed": 167, "published": 3, "date": "1692882314", "time_retrieved": "2024-07-30T17:37:11.034284", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=4.*(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    float s=1.,t=iTime;fragColor=vec4(s);\n    for(int c=-1;c<3;fragColor[c-1]=smoothstep(.02,.01,length(uv-(s=1.+sin((t+=float(++c)*.025)-sqrt(length(uv))))*round(uv/s))-.01));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 299]], "test": "untested"}
{"id": "mtXBD8", "name": "Zellij pattern 17 (music)", "author": "jarble", "description": "A zellij tile pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "zellij", "gamelan"], "likes": 7, "viewed": 309, "published": 3, "date": "1692855883", "time_retrieved": "2024-07-30T17:37:12.297906", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract(.5+(a1)*(a2.x+a2.y))-.5)\n        //abs(abs(fract(.5+(a1)*(a2.x+a2.y))-.5)+sign(a.x-a.y))\n    ;\n}\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvec3 fractal(vec2 uv,vec2 t2){\n    vec3 col = vec3(0.);\n    bool b = uv.x>uv.y;\n    bool b1 = uv.x>uv.y;\n    vec2 uv2 = uv/1.5;\n    \n    //uv /= 4.;\n    \n    //rotate 45 degrees\n    mat2 r = rotate2D(0.785398);\n\n    \n    for(int k = 0; k < 6; k++){\n        //uv.x += 1.5;\n        b1 = uv.x>uv.y*float(!b1);\n        //uv.x -= t1_(uv,floor(uv));\n        //uv += binary_digit(k+1,1)/2.;\n        uv =\n            abs(.5+uv+t2)/1.5\n            //-sign(uv/1.5-t2)-abs(.5+uv/1.5+t2)\n\n            //abs(max(uv.yx,t2)+t2)\n            //abs(.5+abs(uv-t2)/1.5-t2) //looks better zoomed out\n            //abs(.5+uv+max(t2/1.5,uv))\n            //abs(.5+uv+t2)/1.5*sign(uv.x-uv.y)\n            //abs(.5+uv+t2+mod(floor(uv2.x/1.5),2.))/1.5\n            //abs(.5+uv+t2/1.5)\n            //abs(.5+uv/1.5+t2)\n        ;\n        \n        //A perfect tessellation!\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n\n        \n        //if(t2.y>t2.x)\n        b =\n            uv.y>uv.x\n            //uv.y>uv.x-1./1.5/2.;\n            //uv.y>uv.x&&(t2.y<t2.x||col.y>col.x)\n            //uv.y>uv.x&&(col.x<col.y||t2.x<t2.y)\n            //t2.y<t2.x||(col.x<col.y&&uv.x>uv.y)\n            //uv.y>uv.x&&(t2.y>t2.x)\n            //uv.y>uv.x||t2.y<t2.x\n            //uv.y*float(!b1)>uv.x\n        ;\n        if(\n            b\n        ) uv = uv.yx;\n        //else uv -= t1_(floor(uv),floor(uv))/1.5;\n        \n        t2 =\n            -triangle_wave(uv-.5).yx\n            //-triangle_wave(uv-.5).yx + floor(t2)\n        ;\n        uv =\n            (t2.yx-triangle_wave(uv.yx)).yx\n        ;\n        vec2 uv1 =\n            uv\n            //triangle_wave(uv)-triangle_wave(uv.yx-.5)\n        ;\n        //if(b||t2.y<t2.x)\n        //if(b||uv.y<uv.x)\n        //if(uv.x>-.25)\n        col =\n            vec3(col.zx,max(abs(uv1.x-uv1.y)*sign(t2.x-t2.y),0.))\n            //vec3(col.zx,max(uv.x-uv.y,0.))\n            //vec3(col.zx,max(col.y,max(uv.y-uv.x,0.)))\n            //vec3(col.zx,max(col.y,max(abs(uv1.x-uv1.y)*sign(t2.x-t2.y),0.)))\n        ;\n        uv2 += uv;\n        \n        //uv.y -= float(uv.x<uv.y);\n\n        }\n        uv2 += uv;\n        return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1/2.0;\n    vec2 t2 = vec2(0.);\n    vec3 col = fractal(uv,t2);\n    for(int i = 0; i < 1; i++){\n        col = abs(fractal(uv,t2));\n    }\n    \n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "int collatz(int initial, int steps){\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\nfloat binary_digit(int n, int i){\n    return float((n >> i) & 1);\n}\n\nfloat fract1(float a){\n    return\n        8.*abs(pow(fract(-a),2.)/4.)/8.\n        //abs(fract(a)*1.125-.125)\n    ;\n}\n\nfloat m1(float a, float b, float c){\n    return floor(floor(floor(a)/b)/c);\n}\n\nfloat mod1(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a/8.),8.); i++){\n        a += mod(floor(a/8.),b)*i;\n    }\n    */\n    return\n        mod(a,b)\n        //mod(a/2.-mod(a*2.,b),b)\n        //mod(a+floor(a/4.),b)\n        //mod(a+floor((((b/2.+a)+1.)/2.)),b)\n        //mod(a+floor(b*13./7.),b)\n        //floor(mod(floor(a+floor(a)/8.),b))\n        //mod(a-mod(a-mod(a,5.),3.),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\nfloat fmod(float a, float b){\n    //distort(a,b);\n    //a += collatz(a,b);\n    //a += collatz(mod(a,8.)+floor(a/8.),8.);\n    \n    //a += (mod(a/8.,3.)-mod(a/8.,2.));\n        \n    //a = (a/2. + floor(a))/4.;\n    \n    //a += floor(a/b)*8.;\n    //a += mod(floor(b/2.+floor(a/4.)),4.);\n    //a /= 1.+mod(floor(a+b),2.);\n    a +=\n        //floor(a/8./8.)\n        //floor((a+b)/8.)\n        m1(a/8.,b*b+5.,b+2.)\n        //m1(a,2.*b+b,3.+b)\n    ;\n    \n    //a += mod((floor(a)+b),3.);\n    //a += m1(a,3.,7.);\n    //a += abs(mod((a),3.)-mod((a),5.));\n    //a -= mod(b/2.,2.);\n    //a += mod(floor(a/4.),4.);\n    //a /= 2.;\n    //b += floor(b/2.);\n    \n    float\n        a1 = mod1(floor(a),b),\n        a2 =\n            mod1(floor((a)/b),b)\n            //mod1(floor((floor(a/2.)*b/4.+a)/b),b)\n    ;\n    \n    return\n        mod1(a1*a2,b)\n        //mod1(a1*a2+floor(a*sign(a1-a2)),b)\n        //mod(mod(floor(a+binary_digit(int(a),2)),b)*mod(floor((a)/b),b),b)\n        //floor(mod(mod(floor(a),b)*mod(a/b,b),b))\n        //mod(floor(a/b-mod(a/b,2.)+mod(a/b,3.)),b)\n        //floor(mod(mod(floor(a/b),b)*(2.-mod(floor(a/2.),2.)),b))\n        //floor(mod(floor(a)+mod(a/8.,8.),b))\n        //mod(floor(floor(a)*1.5)+floor(floor(a)*2.)+floor(floor(a)*3.),b)\n        //floor(mod(mod(floor(a)/4.,8.)*mod(floor(a)/4.,b),b))\n        //mod(mod(floor(a+b),b*b),b)\n        //mod(mod(floor(a),b+mod(floor(a/8.),b)),b)\n        //mod(floor(a),b)\n    ;\n}\n\n\nfloat prime_rhythm(float time){\n    \n    //time += fmod(time,4.)*4.;\n    \n    //time += mod(time/8.,2.) - mod(time/8.,3.);\n    \n    //time += floor(time*2.)/2.;\n    return\n        (1.+fmod(time/2.,2.))*(1.+fmod(time/3.,2.))/(1.+fmod(time/5.,2.))/(1.+fmod(time/7.,2.))\n        //(1.+fmod(time/2.,2.))/(1.+fmod(mod(time/2./3.,3.),2.))/(1.+fmod(mod(time/2./5.,5.),2.))\n    ;\n}\n\nfloat fmod1(float a, float b){\n    //a += collatz(a/8.,8.)*4.;\n    \n    //a += (mod(a/2.,3.)-mod(a/2.,2.));\n    \n    //change the notes without changing the rhythm\n    //a += mod(-b/2.,2.);\n    \n    //a /= prime_rhythm(a);\n    \n    return\n        fmod(a,b)\n        //fmod(a+floor(b*(2.+floor(a/2.)))/2.,b)\n        //max(fmod(a-mod(a-mod(a,5.),3.),b),fmod(a-mod(a-mod(a,3.),5.),b))\n        //fmod(a,b+fmod(floor(a)/4.,2.))\n        //max(fmod(a,b),fmod(a/2.,b*2.))\n        //fmod(a+fmod(a/8.,8.),b)\n    ;\n}\n\n\n//#define fract1(a) pow(fract(a),2.)\n//#define fract1(a) pow(fract(a),1.+fract(a))\n//#define fract1(a) (1.-fract(-a)*fract(-a))\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n//#define fract1(a) pow(fract(a),1.+pow(fract(a),2.))\n//#define fract1(a) pow(fract(a),3.)\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 mainSound1(int samp, float time,float scale,int instrument,float duration){\n  \n  \n  \n  float tempo1 =\n      prime_rhythm(time)\n      //prime_rhythm(time+collatz(time,time))\n  ;\n  //time += floor(time/16.*tempo1);\n  \n  //time = time + floor(time*4.)/2.;\n  \n  float s1 =\n      8.,\n\n  t =\n      s1*time/4./tempo1\n      //s1*(time + floor(time*2.))/4./tempo1\n  ,\n  \n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod1(t4,2.), //one half octave lower or higher\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod1(t6,s1/2.)/2.),\n      //floor(fmod(t6+floor(time/8./tempo1),s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.)\n      //1. + fmod(t/t3/2.+floor(t/8.),s1/2.)\n  ;\n  vec2 a= vec2(\n      //(2.-log(fract(t)))*(2.-log(fract(t/2.)))\n      //(1.-log(fract(t/2./prime_rhythm(time+14.))/2.))*(1.-log(fract(t/prime_rhythm(time+7.))/4.))\n      \n      //sitar / bell / hurdy-gurdy / gamelan / slap bass\n      //(1.-log(.125/4.+fract1(t/2./prime_rhythm(time+14.))/4.)),(1.-log(fract1(t/prime_rhythm(time+7.))/4.))\n      -(log(1./64./4.+fract1(t/2./prime_rhythm(time+14.))/8./duration)),-(log(1./64./4.+fract1(t/prime_rhythm(time+7.))/8./duration))\n\n      \n      //piano / marimba\n      //(1.-log(fract1(t/2./prime_rhythm(time+14.))*2.)),(1.-log(fract1(t/prime_rhythm(time+7.))*2.))\n      \n      //pow(2.-log(fract(t5)),2.)\n      //pow(2.-log(fract(t6)),2.)\n      //32.*sqrt(fract(-t/2.)/2.)/2.\n      //32.*log(fract(-t/4.)/2.)/2.\n      //4.*(1.-log(pow(fract(t),2.)))\n      //2.*log((1.+(fract(-(t)/2.)*fract(-t/2.)/8.)))\n  ),\n  nb = vec2(\n      t*vec2(pow(2.,(m3+m2-t1*4.)/7.+scale))*tempo1\n  ),\n  gamelan =\n      a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))\n      ,\n  hurdy_gurdy =\n      .125/2.*(abs(log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.))-log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))))\n  ,\n  sitar =\n      a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.))) \n      //log(.125+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.))\n  ,oud = a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n  ,steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,banjo = a/16./8.*abs(log(1./2.+a*abs(1./8.-.5*abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  -log(1./2.+a*abs(abs(1./2.-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))\n  ,guitar = a/16./8.*abs(log(1./4.+a*abs(1./8.-.5*abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))))\n      -log(1./4.+.5*a*abs(abs(1./2.-vec2(fract1(nb.x*.998),fract1(nb.y))))))\n  ,synth_drum = a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n  ,harp = \n      a/16./4.*abs(\n      synth(1./4.,a,1./8.,1.,nb*4.,2.)\n      + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n  ;\n;\n  //nb *= (1.-fract(floor(-t)/2.));\n  \n  switch(instrument){\n  case 1: return gamelan;\n  case 2: return steel_drum;\n  case 3: return oud;\n  case 4: return hurdy_gurdy;\n  case 5: return banjo;\n  case 6: return guitar;\n  case 7: return synth_drum;\n  default:\n  return\n      //log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a)\n      \n      //sitar\n      gamelan\n      //steel_drum\n      //oud\n\n      //hurdy-gurdy\n      //hurdy_gurdy\n      \n      //saxophone\n      //(abs(log(a/32.+.125*a*abs(1./32.-abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.))-log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))))\n\n      \n      //bell\n      //abs(log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*4.)))/2.))\n      //+log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*4.)))/2.)))/2.\n      \n      //slap bass\n      //abs(log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*8.*.998),fract1(nb.y*8.)))/2.))\n      //+log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n      \n      //marimba\n      //(abs(log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))-log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))))\n      \n      //koto\n      //abs(log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))\n      //+log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.)))/2.\n      \n      //log(abs(a/8.-abs(.5-vec2(fract(nb.x*.998),fract(nb*2.)))*a))\n      //log(abs(abs(a/4.)-abs(a/8.-abs(.5-vec2(fract(nb.x/2.+.5),fract(nb.y)))*a)))\n      \n      //abs(log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a/2.))/2.\n      //log(1.+abs(a/16.-abs(.5-vec2(fract(-nb*.998),fract(-nb)))*a))\n      //abs(log(a)-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n  }\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument){\n    return mainSound1(samp, time,scale,instrument,1.);\n}\n\nvec2 mainSound(int a,float b){\n    \n    //sitar\n    //return (mainSound1(a,b,6.5,1,1./2.)-mainSound1(a,b,5.5,1,1./4.));\n    return (mainSound1(a,b,6.,1,1./2.)*2.-mainSound1(a,b,5.,1,1./4.));\n    \n    //return abs(mainSound1(a,b,6.5,1,1./2.)-mainSound1(a,b,6.5,1)/2.);\n    \n    //sitar remix\n    //return mainSound1(a,b,5.25,7);\n    \n    //bagpipe remix\n    //return mainSound1(a,b/4.,7.,4)/2.+mainSound1(a,b/2.,8.,4)/2.;\n    \n    //return (mainSound1(a,b,7.,6)+mainSound1(a,b/2.,7.,6)*2.)/2.;\n\n    //return (mainSound1(a,b/2.,6.5,1)+mainSound1(a,b,6.5,2)/2.)/2.;\n    //return (mainSound1(a,b,6.5,1)+mainSound1(a,b/2.,7.5,1)+mainSound1(a,b/4.,8.5,1))/3.;\n    //return mainSound1(a,b,6.5,1)+mainSound1(a,b/2.,6.5,1)/2.+mainSound1(a,b/4.,7.5,1)/4.+mainSound1(a,b/8.,8.5,1)/8.;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 209], [210, 210, 243, 243, 277], [279, 279, 303, 303, 355], [472, 472, 498, 498, 587], [589, 589, 619, 619, 2708], [2710, 2710, 2765, 2765, 3179]], "test": "untested"}
{"id": "dlXBW8", "name": "Fork Audio Eclipse", "author": "cbalestra", "description": "Super basic audio-reactive HSL light ring. My first shader here :)", "tags": ["basic", "reactive", "audio"], "likes": 2, "viewed": 365, "published": 3, "date": "1692850960", "time_retrieved": "2024-07-30T17:37:13.181543", "image_code": "\nconst float dots = 40.; //number of lights\nconst float radius = .25; //radius of light ring\nconst float brightness = 0.02;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\t\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 c=vec3(0,0,0.1); //background color\n\t\t\n    for(float i=0.;i<dots; i++){\n\t\n\t\t//read frequency for this dot from audio input channel \n\t\t//based on its index in the circle\n\t\tfloat vol =  texture(iChannel0, vec2(i/dots, 0.0)).x;\n\t\tfloat b = vol * brightness;\n\t\t\n\t\t//get location of dot\n        float x = radius*cos(2.*3.14*float(i)/dots);\n        float y = radius*sin(2.*3.14*float(i)/dots);\n        vec2 o = vec2(x,y);\n\t    \n\t\t//get color of dot based on its index in the \n\t\t//circle + time to rotate colors\n\t\tvec3 dotCol = hsv2rgb(vec3((i + iTime*10.)/dots,1.,1.0));\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tc += b/(length(p-o))*dotCol;\n    }\n\t\n    //black circle overlay\t   \n\tfloat dist = distance(p , vec2(0));  \n\tc = c * smoothstep(0.26, 0.28, dist);\n\t \n\tfragColor = vec4(c,1);\n}\n", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 146, 167, 167, 336], [340, 340, 397, 397, 1295]], "test": "untested"}
{"id": "clffWH", "name": "Fork Shimmy", "author": "cbalestra", "description": "Music by Tony Leys https://soundcloud.com/tonileys", "tags": ["raymarching", "audioreactive"], "likes": 8, "viewed": 317, "published": 3, "date": "1692846086", "time_retrieved": "2024-07-30T17:37:14.056204", "image_code": "//#define iTime iChannelTime[0]\nfloat det=.005, maxdist=50., pi=3.1416, gl=0.;\nvec2 id;\n\n\nfloat hash12(vec2 p)\n{\n    p*=1000.;\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 pc=abs(p)-c;\n    return length(max(vec3(0.),pc))-min(0.,max(pc.z,max(pc.x,pc.y)));\n}\n\nvec2 amod(vec2 p, float n, float off, out float i)\n{\n    float l=length(p)-off;\n    float at=atan(p.x,p.y)/pi*n*.5;\n    i=abs(floor(at));\n    float a=fract(at)-.5;\n    return vec2(a,l);\n}\n\nfloat ring(vec3 p,inout vec2 id)\n{\n    p.xy=amod(p.xy*rot(iTime*0.), 20., 2., id.x);\n    float h=max(0.,texture(iChannel0,vec2(.15+fract(id.x*.2+id.y*.1),0.)*.5).r*3.-.5);\n    h+=sin(iTime*10.+id.x)*.2;\n    float d=box(p+vec3(0.,-h*1.5,0.),vec3(.1,h,.1));\n    return d*.5;\n}\n\nfloat de(vec3 p)\n{\n    float d=100.,ii=0.;\n    p.xz*=rot(iTime);\n    p.yz*=rot(sin(iTime));\n    float r=4.;\n    vec2 ids;\n    for (float i=0.; i<r; i++)\n    {\n        p.xz*=rot(pi/r);\n        ids.y=i;\n        float r=ring(p,ids);\n        if (r<d)\n        {\n            d=r;\n            id=ids;\n        }\n    }\n    d=min(d,length(p)-1.5);\n    return d*.7;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(0.,det);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float d, td=0.;\n    vec3 p, col=vec3(0.);\n    for (int i=0; i<100; i++)\n    {\n        p=from+td*dir;\n        d=de(p);\n        if (d<det || td>maxdist) break;\n        td+=d;\n        gl+=.1/(10.+d*d*10.)*step(.7,hash12(id+floor(iTime*5.)));\n    }\n    if (d<det)\n    {\n        //id+=floor(iTime*5.);\n        vec3 colid=vec3(hash12(id),hash12(id+123.123),1.);\n        p-=dir*det;\n        vec3 n=normal(p);\n        vec2 e=vec2(0.,.05);\n        col=.1+max(0.,dot(-dir,n))*colid;\n        col*=.5+step(.7,hash12(id+floor(iTime*5.)));\n    } \n    else\n    {\n        dir.xz*=rot(iTime*.5);\n        dir.yz*=rot(iTime*.25);\n        vec2 p2=abs(.5-fract(dir.yz));\n        float d2=100.,is=0.;\n        for(int i=0; i<10; i++)\n        {\n            p2=abs(p2*1.3)*rot(radians(45.))-.5;\n            float sh=length(max(vec2(0.),abs(p2)-.05));\n            if (sh<d2)\n            {\n                d2=sh;\n                is=float(i);\n            }\n        }\n        col+=smoothstep(.05,.0,d2)*fract(is*.1+iTime)*normalize(p+50.);\n    }\n    return col*mod(gl_FragCoord.y,4.)*.5+gl;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 from = vec3(0.,0.,-8.);\n    vec3 dir = normalize(vec3(uv,.7));\n    vec3 col = march(from, dir);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26471, "src": "https://soundcloud.com/tonileys/through-a-cardboard-world", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clffWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 112, 112, 246], [249, 249, 268, 268, 327], [329, 329, 356, 356, 450], [452, 452, 504, 504, 639], [641, 641, 675, 675, 915], [917, 917, 935, 935, 1273], [1275, 1275, 1296, 1296, 1394], [1397, 1397, 1430, 1430, 2498], [2502, 2502, 2559, 2559, 2756]], "test": "untested"}
{"id": "mlsBDn", "name": "Gyroid Bath", "author": "Oman395", "description": "Messing around with gyroid. Inspired by 3d printing, the \"\"\"transparency\"\"\" is literally just making the gyroid distance function absolute value and never actually return 0, meaning that all the walls do is reduce the eventual distance traveled.", "tags": ["raymarching", "gyroid", "infill", "3dprinter"], "likes": 11, "viewed": 228, "published": 3, "date": "1692826739", "time_retrieved": "2024-07-30T17:37:14.906930", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = vec3((uv - 0.5) * 2.0 * 0.7, iTime * 2.0);\n    vec3 dir = normalize(vec3(pos.xy,3));\n    pos.xy += (3.0 * 3.14159265 / 4.0) * vec2(sin(pos.z * 0.2), cos(pos.z * 0.2)) - vec2(3.14159265 / 2.0, 0);\n    for(int i = 0; i < 164; i++) {\n        float d = max(abs(sin(pos.x) * cos(pos.y) + sin(pos.y) * cos(pos.z * 0.2) + sin(pos.z * 0.2) * cos(pos.x)) + 0.0001, 0.0);\n        pos += dir * d * 2.0;\n    }\n    float c = 16.0 / (pos.z - iTime * 2.0 + 16.0);\n    fragColor = vec4(0.1, 0.7, 1, 1) * c + vec4(0,0.1,0.1,1) * (1.0 - c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 637]], "test": "untested"}
{"id": "dllfz7", "name": "NixOS 10", "author": "El_Sargo", "description": "Windows 10 inspired wallpaper for Nixos", "tags": ["3d", "raymarching"], "likes": 11, "viewed": 491, "published": 3, "date": "1692814897", "time_retrieved": "2024-07-30T17:37:15.671885", "image_code": "const mat2 r = mat2(cos(-0.7),-sin(-0.7),sin(-0.7),cos(-0.7));\nconst vec2 ta = vec2(0.,-20.)*r;\nconst vec3 tar = vec3(ta.x,0.,ta.y);\nconst vec3 ro = vec3(-1.7, 0., 4.5);\nconst vec2 rop = ro.xz * r;\nconst vec3 ror = vec3(rop.x,ro.y,rop.y);\n\n\nfloat sdNix(vec3 p){\n    p.xy += vec2(0.25,0.47);\n    vec2[] verts = vec2[](\n        vec2(11.,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(7.0,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(5.0,1.0 * 0.75*4.472135956) * 0.053,\n        vec2(3.0,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(1.0,0.0 * 0.75*4.472135956) * 0.053,\n        vec2(0.0,0.5 * 0.75*4.472135956) * 0.053,\n        vec2(3.0,2.0 * 0.75*4.472135956) * 0.053,\n        vec2(1.0,3.0 * 0.75*4.472135956) * 0.053,\n        vec2(3.0,4.0 * 0.75*4.472135956) * 0.053\n    );\n\n    ivec3[] tris = ivec3[](\n        ivec3( 0, 1, 6),\n        ivec3( 0, 6, 8),\n        ivec3( 6, 7, 8),\n        ivec3( 2, 6, 3),\n        ivec3( 3, 4, 5),\n        ivec3( 3, 5, 6)\n    );\n    \n    float d = sdTriangle(p.xy, \n        verts[tris[0].x],\n        verts[tris[0].y],    \n        verts[tris[0].z]    \n    );\n    if (d > 0.8) {\n        return d;\n    }\n    for (int i=1;i<tris.length();i++) {\n        d = min(d,sdTriangle(p.xy, \n            verts[tris[i].x],\n            verts[tris[i].y],    \n            verts[tris[i].z]    \n        ));\n        \n    }\n\n    d = opExtrusion(p,d,.1);\n    return d-0.04;\n}\n\n\nfloat sdFlake(vec3 p){\n    float d = 10e10;\n\n    for (float r = 0.0;r<2.0;r += 1.0 / 3.0){\n        vec2 z = p.xy * rot(-pi*r) - vec2(-0.3,-0.4);\n        d = min(d,sdNix(vec3(z.x,z.y,p.z)));\n    }\n    return d;\n}\n\nfloat map(vec3 p){\n    \n    p.xz *= r;\n    vec3 rt = normalize(tar-p);\n    vec3 ps = p + p.z * rt * 0.15;\n      \n    float d = 10e10;\n    if (p.z > -0.) {\n        d = sdFlake(vec3(ps.xy,0.));    \n    }\n    float b = 0.;\n   \n    if (d < 0.) {\n        float m = p.z;\n        b = exp(-0.7-m*0.1)*0.1;\n    }\n\n    return b*(0.7+fbmd(p*5.).x-p.y*0.5);\n}\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = (uv-0.5)*vec2(1.,iResolution.y/iResolution.x);\n    vec3 rd = normalize(vec3(nuv, -0.7));    \n\n    vec3 col = vec3(0.);\n    float g = 0.0;\n    float dt = 0.03;\n    uvec2 xh = uvec2(uint(fragCoord.x),uint(fragCoord.y));\n    for (float T = hash12(xh)*dt; T < 6.; T += dt ){\n        vec3 p = ro+rd*T;\n        float d = map(p);\n        col += dt*100.0*d*vec3(0.01,0.5,1.0)*exp(-g*0.1);\n        if (d > 0.) {\n            g += dt;\n        }\n    }\n    col = mix(col,vec3(0.016,0.184,0.290)*(0.9+0.1*fbmd(vec3(nuv*20.,0.)).x),exp(-g*0.1));\n    vec2 rc = rd.xy * r;\n    vec3 rdr = vec3(rc.x,rd.y,rc.y);\n    vec3 s = ro + rd * (ror.z);\n    float d = sdFlake(vec3(s.x+0.0,s.y,0.)*1.3);\n    col +=  vec3(.2,1.,3.4)*smoothstep(0.01,0.0,abs(d));\n    col +=  vec3(.02,0.5,1.4)*(-1.02+nuv.x*6.0)*smoothstep(0.01,0.0,d);\n\n    col *= smoothstep(.9,0.,length(uv-0.5));\n    fragColor =  vec4(aces_tonemap(col),1.0);\n}\n", "image_inputs": [], "common_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12(uvec2 q) {\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nconst float pi = 3.14159265359;\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat opExtrusion( in vec3 p, in float sdf, in float h ) {\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat hash(vec2 p){\n\treturn fract(3.12312*dot(p,p*01.123));\n}\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n\n\nfloat smix(float a,float b,float t){\n\treturn mix( a, b, smoothstep(0.,1.,t) ) ;\n}\n\nfloat n(vec2 p){\n\tvec2 f = floor(p);\n\tvec2 t = fract(p);\n\tvec2 tr = f + vec2(1.,1.);\n\tvec2 tl = f + vec2(0.,1.);\n\tvec2 br = f + vec2(1.,0.);\n\tvec2 bl = f;\n\tfloat htr = hash(tr);\n\tfloat htl = hash(tl);\n\tfloat hbr = hash(br);\n\tfloat hbl = hash(bl);\n\tfloat mt = smix(htl,htr,t.x);\n\tfloat mb = smix(hbl,hbr,t.x);\n\treturn smix(mb,mt,t.y);\n\t\n}\n\nvec4 nd( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p+vec3(0,0,0) );\n    float b = hash( p+vec3(1,0,0) );\n    float c = hash( p+vec3(0,1,0) );\n    float d = hash( p+vec3(1,1,0) );\n    float e = hash( p+vec3(0,0,1) );\n    float f = hash( p+vec3(1,0,1) );\n    float g = hash( p+vec3(0,1,1) );\n    float h = hash( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                 2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                 k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                 k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n\nvec4 fbmd( in vec3 x )\n{\n\n    float f = 1.78;  // could be 2.0\n    float s = 0.54;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0);\n    for( int i=0; i < 9; i++ )\n    {\n\t    \n        vec4 n = nd(x);\n        a += b*n.x;          // accumulate values\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m*x;\n\tx.xy *= rot(1.23123);\n\tx.zy *= rot(-2.23123);\n        //m = f*m*mat3(1.,-1.,1.,-1,1.,-1.,1.,-1.,1.);\n    }\n    return vec4( a, d );\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1384, 1384, 1406, 1406, 1595], [1597, 1597, 1615, 1615, 1944], [1946, 1946, 2003, 2003, 2955]], "test": "untested"}
{"id": "mtsBDn", "name": "SHEYTAN", "author": "zhonkvision", "description": "Music by Sheytan ", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 5, "viewed": 119, "published": 3, "date": "1692812719", "time_retrieved": "2024-07-30T17:37:16.558514", "image_code": "// MUSIC | SHEYTAN Live @Arcan May 2023\n// VISUAL | ZHONK VISION˚\n\nuniform sampler2D; // Audio input texture\n\nvec3 palette(float d) {\n    return mix(vec3(1.4, 0.7, 0.9), vec3(1.0, 0.0, 1.0), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.05;\n    for (int i = 0; i < 8; ++i) {\n        float t = angle;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.89);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    \n    float SHEYTAN = length(p.xy) - 0.2; // Create a circular Sheytan shape\n    \n    return SHEYTAN;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 100.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    \n    // Use the red channel of the audio input texture to modulate the color\n    vec3 audioColorMod = texture(iChannel0, vec2(iTime * 0.01, 0.8)).rgb;\n    col *= audioColorMod;\n    \n    return vec4(col, 1.0 / (d * 80.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -120.0);\n    \n    // Remove rotation modulation\n    ro.xz = rotate(ro.xz, iTime * 0.5); // Keep a constant rotation speed\n    \n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    \n    fragColor = col;\n}\n", "image_inputs": [{"id": 34757, "src": "https://soundcloud.com/sheytan_kl/live-arcan-may-2023?si=631a6ff426ac4d39bff20084588e7eda&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 134, 134, 197], [199, 199, 229, 229, 309], [311, 311, 330, 330, 652], [654, 654, 681, 681, 1248], [1250, 1250, 1305, 1305, 1815]], "test": "untested"}
{"id": "mlsfWn", "name": "macro tricks ( compat & more)", "author": "FabriceNeyret2", "description": "- Add this Common content to the one of buggy shader to test if it fixes compatibility issues.\n- testing the size of a vector / float / void ( B&W tiles:see Image ).\n\nAFTER SHADER LOAD, SET Common:26 #if TO 1 AND RECOMPILE. Compiler complains but it works", "tags": ["compatibility", "tricks", "macros"], "likes": 14, "viewed": 293, "published": 3, "date": "1692812507", "time_retrieved": "2024-07-30T17:37:17.359373", "image_code": "// see tricks in Common\n// all compatibility issues: https://shadertoyunofficial.wordpress.com/2016/07/22/compatibility-issues-in-shadertoy-webglsl/\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 R = iResolution;\n    vec2 I = floor(4.*U/R.xy);\n    float a;                   // column = dimension 1...4\n    O = vec4(   I==vec2(0,3) ?  dim(R)==1 : I==vec2(1,3) ?  dim(R)==2 : I==vec2(2,3) ?  dim(R)==3  // top line:    dim of vec3\n              : I==vec2(0,2) ?  dim(U)==1 : I==vec2(1,2) ?  dim(U)==2 : I==vec2(2,2) ?  dim(U)==3  //              dim of vec2\n              : I==vec2(0,1) ?  dim(a)==1 : I==vec2(1,1) ?  dim(a)==2 : I==vec2(2,1) ?  dim(a)==3  //              dim of float\n              : I==vec2(0,0) ?  dim( )==1 : I==vec2(1,0) ?  dim( )==2 : I==vec2(2,0) ?  dim( )==3  // bottom line: dim of void\n              : false );\n              \n    ivec2 G = ivec2(U) % ivec2(R/4.);          // red separators\n    if ( G.x*G.y==0 ) O = vec4(1,0,0,0);\n  \n}", "image_inputs": [], "common_code": "//=== to be copied in Common in the shader to debug ===========================\n\n// --- find the dimension of vectors / float / empty argument ( dim(empty) = 1 )\n\n#define dim(v) int(dot( v+1.-(v+0.) ,v+1.-(v+0.) ))\n\n\n// --- to test if a compatibility issue is causing a bug\n\n#define pow(a,b)       pow(abs(a),b)             // Windows wrongly adds abs() to avoid NaN\n#define sqrt(a)        sqrt(abs(a))\n#define inversesqrt(a) inversesqrt(abs(a)) \n#define log(a)         log(abs(a))\n#define log2(a)        log2(abs(a))\n#define clamp(x,m,M)   min(max(x, m), M)         // wrong clamp implem on Windows\n#define sin(a)         sin(mod(a,6.28318530718)) // precision issues on Windows\n#define cos(a)         cos(mod(a,6.28318530718))\n#define atan(y,x)      atan(y+1e-15,x+1e-15)     // Windows hack degenerate cases to avoid NaN\n#define mod(a,b)     ( dot(b,b)==0. ? (a)*0. : mod(a,b) )\n#define normalize(v)   normalize( v+1e-15 )\n//#define length(v)    length( v+1e-15 )         // this one won't work if array.length() is used\n#define dot(a,b)     ( dot(a,b) + 1e-15 )\n\n\n// --- force all out to be inout, with turnover for MainImage.\n\n#if 0 // <<<  AFTER SHADER LOAD, SET TO 1 AND RECOMPILE <<< ( Compiler complains, but it works :-) )\n\nvoid mainImage_( inout vec4 O, vec2 U );\nvoid mainImage ( out vec4 O, vec2 U ){ mainImage_(O,U); }\n#define mainImage mainImage_\n#define out inout                                // wrong out implem on Windows\n\n#endif\n\n\n// --- to prevent loop unrolling, making compilation a lot faster\n// replace value 0 or 0. in loops with iZ of fZ :\n\n// #define iZ min(0, iFrame)\n// #define dZ min(0., iTime)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 188, 188, 964]], "test": "untested"}
{"id": "dllBWn", "name": "Brokowi", "author": "zhonkvision", "description": "Inspired by \"Brokoli\" and \"Daun Sawi\"\n\nMusic by Nazreth - The Warehouse Hanoi - The Warehouse #45 ", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 16, "viewed": 336, "published": 3, "date": "1692809231", "time_retrieved": "2024-07-30T17:37:18.210098", "image_code": "uniform float musicAmplitude; // Audio analysis data representing amplitude\n\nvec3 palette(float d, float audioAmplitude) {\n    vec3 yellow = vec3(0.6, 0.1, 0.0); // Yellow\n    vec3 green = vec3(0.2, 1.7, 0.5); // Green\n    \n    d *= audioAmplitude * 0.1 + 0.5;\n    vec3 color = mix(yellow, green, d);\n    return color;\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p, float audioAmplitude) {\n    float angle = iTime * 0.05 * (0.2 + musicAmplitude * 0.8) + sin(iTime * 0.2) * 0.0;\n    for (int i = 0; i < 12; ++i) {\n        float t = angle;\n        p.xz = rotate(p.xz, t * 10.666);\n        p.xy = rotate(p.xy, t * 40.666);\n        p.xz = rotate(p.xz, t * 10.666);\n        p.xy = rotate(p.xy, t * 50.666);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    \n    float sphere = length(p) - (0.5 + audioAmplitude * 0.1); // Adjust size based on audio amplitude\n    \n    return sphere;\n}\n\nvec4 rm(vec3 ro, vec3 rd, float audioAmplitude) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p, audioAmplitude) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 200.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1, audioAmplitude) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 300.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    float spiralTime = iTime * 0.05 * (0.2 + musicAmplitude * 0.8);\n    vec3 ro = vec3(0.0, 0.0, -28.0);\n    ro.xz = rotate(ro.xz, spiralTime);\n    \n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 4.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    float audioData = texture(iChannel0, vec2(iTime * 0.2, 0.0)).r; // Sample audio data from iChannel0\n    float uuvScale = 0.7 + audioData * 0.2; // Scale adjusted with audio amplitude\n    \n    vec3 uuv = ro + cf * uuvScale + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd, musicAmplitude);\n    \n    fragColor = col;\n}\n", "image_inputs": [{"id": 34528, "src": "https://soundcloud.com/user-951273249/nazreth-mastered?si=c3dcdd6678784cdab01546036fc8eb6a&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 122, 122, 320], [322, 322, 352, 352, 432], [434, 434, 475, 475, 972], [974, 974, 1023, 1023, 1437], [1439, 1439, 1494, 1494, 2210]], "test": "untested"}
{"id": "DlsBDr", "name": "Ogor - ogor", "author": "zhonkvision", "description": "Inspired by \"Agar - agar and Obor obor\"", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 5, "viewed": 169, "published": 3, "date": "1692806722", "time_retrieved": "2024-07-30T17:37:18.984029", "image_code": "vec3 palette(float d) {\n    vec3 purple = vec3(0.6, 0.2, 0.8); // Purple\n    vec3 turquoise = vec3(0.0, 0.7, 0.7); // Turquoise\n    vec3 blue = vec3(0.0, 0.2, 0.6); // Blue\n    \n    // Interpolate between the colors based on the distance 'd'\n    vec3 color = mix(purple, turquoise, d);\n    color = mix(color, blue, d);\n    return color;\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.05; // Slower rotation speed\n    for (int i = 0; i < 14; ++i) { // Increased iterations\n        float t = angle;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.89);\n        p.xz = abs(p.xz);\n        p.xz -= 0.3;\n    }\n    \n    float sphere = length(p) - 0.3; // Adjust the radius to make it smaller\n    \n    return sphere;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.1;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.3; i < 66.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 140.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 100.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    float spiralTime = iTime * 0.5; // Adjust the speed of the spiral motion\n    vec3 ro = vec3(0.0, 0.0, -28.0); // Move even closer to the origin\n    \n    // Apply a spiral rotation to ro.xz coordinates\n    ro.xz = rotate(ro.xz, spiralTime);\n    \n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 4.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 0.7 + uv.x * cs + uv.y * cu; // Scale down the shape\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 338], [340, 340, 370, 370, 450], [452, 452, 471, 471, 843], [845, 845, 872, 872, 1254], [1256, 1256, 1311, 1311, 1938]], "test": "untested"}
{"id": "DlXfWn", "name": "Fourier spectr Void And Cluster", "author": "FabriceNeyret2", "description": "Show the Fourier Transform of Void And Cluster bluenoise ( sigma = 2.5 )", "tags": ["noise", "bluenoise"], "likes": 10, "viewed": 378, "published": 3, "date": "1692775542", "time_retrieved": "2024-07-30T17:37:19.759954", "image_code": "// ===  Fourier Transform of Void And Cluster bluenoise ( Buff A,B,C, from https://www.shadertoy.com/view/mt2cWR ) ===\n// inspired from krax shader + my simplifications: https://www.shadertoy.com/results?query=Void+And+Cluster+Bluenoise\n\n// fork from Fourier-based transform (e.g. kernel convolution) using https://www.shadertoy.com/view/4s3GDs\n// adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS#\n// see also https://www.shadertoy.com/view/4dGGz1 to play with spectrum.\n\n\n// #define paintDFT(F) log(length(F)) / log(SIZE*SIZE)   // log scale\n   #define paintDFT(F)     length(F) / SIZE              // linear scale    \n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,     \n         U = ( u - R/2.) / SIZE  + vec2(2,1)/2.,\n         I = floor(U);\n         U = fract(U) * SIZE / R ;\n\n // O =       texelFetch(iChannel0, ivec2(u) % S, 0).xxxx ;return;              // uncomment for fullpage texture\n // O = vec4( texelFetch(iChannel0, ivec2(u) % S, 0).x < iMouse.x/R.x) ;return; // dither(mouse.x)\n\n    O *= 0.;\n    \n    O +=  I == vec2(-1,0) ? texture(iChannel0, (u+vec2(2,.5)*SIZE-floor(R/2.))/R).x // left: Input image\n                         // texture(iChannel0, U).x            // left: Input image\n        : I == vec2( 1,0) ? paintDFT(texture(iChannel1, U).xy) // right: DFT\n        :                   .3;  \n    \n    if ( int(u) > int(R)-10 ) { O = vec4(1, u.y/R.y > float(iFrame)/(s*s),0,0); return; } // red separator + progress bar\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define SIZE (2.*floor(iResolution.x/4.*.8)) // uncomment for large spectrum\n  #define SIZE s\n\nconst int S = 64;           // bluenoiseSize = SxS , cycling tile\nfloat s = float(S),         // note that more buffers are needed if S > 64 : clone C , S/8^(i+1)\n      sigma = 2.5;          // NB: krax used 1.9 \n\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y) % S, 0)\n\nfloat H( uvec3 x ) {        // from iq https://www.shadertoy.com/view/XlXcW4\n    uint k = 1103515245U;   // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n // x = ((x>>8U)^x.yzx)*k;  // but this version only return 10⁻¹⁹ amplitude\n    return uintBitsToFloat( ((((x.x>>8U)^x.y)*k )  & 0x1fffffffU) );\n}\n\n#define M(S,c)                                                                                  \\\nvoid mainImage( out vec4 O, vec2 U ) {                                                          \\\n    if( U.x > float(S/8) || U.y > float(S/8) ) return; /* we only simulate a small square    */ \\\n    O = vec4( 0,1e35,0,0);                                                                      \\\n    ivec2   start = min( ivec2(U)*8, S - 1 ),          /* to reduce a 8x8 above subtile to 1 */ \\\n              end = min( start + 8, S );                                                        \\\n    for( int y=start.y; y<end.y; ++y)                                                           \\\n      for( int x=start.x; x<end.x; ++x) {                                                       \\\n        vec4 E = T(x,y);                                                                        \\\n        c;                                             /* store result */                       \\\n}   } \n", "buffer_a_code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background energy.\n// output: .x = bluenoise, .y = energy.   \n// input:  D.yz = location or largest void.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n // O = T(U.x,U.y);              // uncomment to repeat copies\n    if( U.x>s || U.y>s ) return; // we only simulate a small (cyclicling) square\n\n    if(iFrame == 0)              // init: noise = 0, energy = random\n    {   O.xy = vec2( 0, H(uvec3(U, 2111)) );\n        return;\n    }\n    \n    O = T(U.x,U.y);              // previous state\n    if(iFrame > S*S-1) return;   // max iteration reached\n \n \n    // Get the result from downscaling and finding the smallest void center\n    U = abs( floor(U) - texelFetch(iChannel1, ivec2(0), 0).zw ) / s;  // delta to target\n\n    float v = 1. - float(iFrame-1) / (s*s-1.); // noise value = normalized iterations\n\n    // Wrap around logic : max energy around optimal void center modulo s : https://www.desmos.com/calculator/zuopknqihy\n    vec2 d = ( abs( U - .5 ) - .5 )  * s / sigma;\n    O.xy += vec2( U==vec2(0) ? v : 0.,            // we are at the optimum : store noise\n                  v * exp( -dot(d,d) )            // energy += gaussian to optimum\n              //  v * max(0., 1.-length(d) )      // variant\n                );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Void and cluster reduce init\n// input:  .xy = SxS state noise,energy.\n// output: .xyz = lowest energy value + position on SxS /8   ( and not already chosen )\n\nM( S , \n   if( E.x == 0. && E.y < O.y ) O = vec4( 0, E.y, x, y )\n )", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Void and cluster reduce iteration\n// input:  .xy = SxS /8 state energy,location\n// output: .xyz = lowest energy value + position on SxS /8²  ( and not already chosen )\n//                note that with S = 64 this is only 1 pixel.\n\nM( S/8 ,                                            \n   if( E.y < O.y ) O = E\n )", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fourier transform of the input\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\n#define tex(ch,I)  texelFetch(ch, I, 0)\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O-=O; \n    \n    if(uv.x > SIZE || uv.y > SIZE) return;\n        \n    for(float n = 0.; n < SIZE; n++)  {\n        vec2 xn = tex(iChannel0, ivec2(n+.5, uv.y) ).xy,\n             yn = tex(iChannel1, ivec2(uv.x, n+.5) ).zw,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;\n        \n        O.zw += cmul(xn, a.x);\n        O.xy += cmul(yn, a.y);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[634, 634, 673, 673, 1476]], "test": "untested"}
{"id": "mtlfR7", "name": "Fork Jeweled Vo DJBETOTJ 469", "author": "djbetotj", "description": "Fancy number spiral.\nMagical segmentation code derived from: https://www.shadertoy.com/view/lsdBzX\nUpdated Jan 2023", "tags": ["2d", "math", "spiral", "fractions"], "likes": 4, "viewed": 185, "published": 3, "date": "1692762971", "time_retrieved": "2024-07-30T17:37:20.628632", "image_code": "#define M iMouse\n#define R iResolution.xy\n#define PI 3.14159265358979\n#define TAU 6.283185307179586\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec3 c = vec3(0);\n    vec2 m = (M.xy-.5*R)/R.y*2.; // mouse coords\n    float t = (M.z > 0.) ? atan(m.x, -m.y): -.54+(iTime*TAU)/3600., // arc from time or mouse\n          n = (cos(t) > 0.) ? sin(t): 1./sin(t), // t to sin/csc\n          e = n*2.,                              // exponent\n          z = clamp(pow(500., n), 1e-16, 1e+18); // zoom\n    vec2 uv = (XY-.5*R)/R.y*2., // screen coords\n          u = uv*z;             // coords with zoom\n    float ro = -PI/2.,               // rotation\n          cr = iTime*TAU/5.,         // counter rotation\n          a = atan(u.y, u.x)-ro,     // screen arc\n          i = a/TAU,                 // arc to range between +/-0.5\n          r = exp(log(length(u))/e), // radius | slightly faster than pow(length(u), 1./e)\n          sc = ceil(r-i),            // spiral contour\n          s = pow(sc+i, 2.),         // spiral gradient\n          vd = cos((sc*TAU+a)/n),    // visual denominator\n          ts = cr+s/n*TAU;           // segment with time\n    c += sin(ts/2.); // spiral 1\n    c *= cos(ts);    // spiral 2\n    c *= pow(abs(sin((r-i)*PI)), abs(n*2.)+5.); // smooth edges & thin near inf\n    c *= .2+abs(vd);                            // dark folds\n    c = min(c, pow(length(u)/z, -1./n));        // dark gradient\n    vec3 rgb = vec3(vd+1., abs(sin(t)), 1.-vd); // color\n    c += (c*2.)-(rgb*.5);                       // add color\n    if (M.z > 0.) c = max(c, digit(iChannel0, uv-m, n, .2, 4., 4.)); // digits\n    RGBA = vec4(c, 1.);\n}\n\n/* golf 489 char with help from Fabrice\nvoid mainImage( out vec4 c, vec2 U )\n{\n    vec2 R = iResolution.xy, u,\n         m = (2.*iMouse.xy-R)/R.y;\n    float T = 6.283,\n          t = (iMouse.z > 0.) ? \n              atan(m.x, -m.y): \n              -.54+iTime*T/3600.,\n          n = (cos(t) > 0.) ? sin(t): 1./sin(t),\n          z = clamp(pow(5e2, n), 1e-16, 1e+18);\n    u = (2.*U-R)/R.y*z;\n    float a = T/4.+atan(u.y, u.x),\n          i = a/T,\n          l = length(u),\n          r = exp(log(l)/n/2.),\n          h = ceil(r-i),\n          v = cos((h*T+a)/n),\n          k = iTime*T/5.+pow(h+i, 2.)/n*T;\n    c *= 0.;\n    c += sin(k/2.)*cos(k) *\n             pow(abs(sin((r-i)*T/2.)), abs(n*2.)+5.) *\n             (.2+abs(v));\n    c = min(c, pow(l/z, -1./n));\n    c += c+c-.5*vec4(v+1., abs(sin(t)), 1.-v, 0);\n}\n*/", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// font code from https://www.shadertoy.com/view/7tV3zK\nvec4 char(sampler2D ic, vec2 p, int c)\n{\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad(ic, p/16. + fract( vec2(c, 15-c/16)/16.), dFdx, dFdy );\n}\nvec4 pInt(sampler2D ic, vec2 p, float n, float d)\n{\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(ic, p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = d; i>0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(ic, p - .5*vec2(i-1.,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// texture, screen coords, value, size, num left digits, num right digits\nvec3 digit(sampler2D ic, vec2 uv, float v, float s, float l, float r)\n{\n    float numleft = min(log2(abs(v))/log2(10.), l-1.);\n    l = max(floor(numleft), 0.)+1.;\n    uv /= s; // size\n    if (isinf(abs(v))) return vec3(char(ic, uv*.7+vec2(.5, .3), 153).x); // infinity symbol\n    uv += vec2((l+1.)/2., .28); // center on decimal\n    vec3 d = vec3(0);\n    d += pInt(ic, uv, v, l).x; // left of decimal\n    uv.x -= l/2.;\n    d += char(ic, uv, 46).x; // decimal point\n    uv.x -= .5;\n    d += pInt(ic, uv, floor(abs(v)*pow(10., r)), r).x; // right of decimal\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 145, 145, 1634]], "test": "untested"}
{"id": "dlsBR7", "name": "Fire Spaghetti", "author": "adacohen", "description": "Blurry spirals add together and evolve to create a slow, smoldering effect", "tags": ["fire", "abstract", "spirals"], "likes": 3, "viewed": 156, "published": 3, "date": "1692761015", "time_retrieved": "2024-07-30T17:37:21.584077", "image_code": "#define MAIN_PALETTE vec3(1.00,0.44,0.00),vec3(0.46,0.52,0.32),vec3(0.25,0.62,0.96),vec3(0.04,0.40,0.69)\nvec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nfloat random(vec2 seed) {\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt = dot(seed.xy, vec2(a, b));\n  highp float sn = mod(dt, 3.14);\n  return fract(sin(sn) * c);\n}\n\nvec2 spiralizeUv(vec2 uv, float twistAmount) {\n  float dist = length(uv);\n  float angle = atan(uv.y, uv.x);\n  float spiralAngle = angle + twistAmount * dist;\n  return dist * vec2(cos(spiralAngle), sin(spiralAngle));\n}\n\nfloat spiral(vec2 uv, float thickness, float twistAmount) {\n  float blur = 20.0;\n  vec2 spiralUv = spiralizeUv(uv, twistAmount);\n  float spiralScale = 1.0 + length(uv) * abs(twistAmount) / 10.0;\n  thickness *= pow(spiralScale, 3.0);\n  return 1.0 - smoothstep(thickness, thickness * blur, abs(spiralUv.x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  // Spherical lens distortion\n  uv = uv * (1.0 + 0.5 * length(uv));\n  vec3 col = vec3(0.0);\n\n  // Make a bunch of spirals at different offsets and twist amounts\n  bool rotateDirection = true;\n  for(float i = 0.; i < 30.; i++) {\n    vec2 curUv = uv;\n    float rotationSpeed = random(vec2(i, 30.0)) * 0.1 + 0.1;\n    if(rotateDirection) {\n      rotationSpeed *= -1.0;\n    }\n    rotateDirection = !rotateDirection;\n    float rotation = iTime * rotationSpeed;\n    float colorShiftSpeed = random(vec2(i, 31.0)) * 0.1 + 0.1;\n    float thickness = random(vec2(i, 11.0)) * 0.002 + 0.004;\n    float twistSpeed = random(vec2(i, 3.0)) * 0.02 + 0.02;\n    float driftSpeed = random(vec2(i, 14.0)) * 0.1 + 0.1;\n    vec2 driftAmplitude = vec2(random(vec2(i, 4.0)), random(vec2(i, 5.0))) * 0.4;\n    // Twist and untwist with time in a sinusoidal pattern\n    const float maxTwist = 10.0;\n    float twistAmount = maxTwist * sin(iTime * twistSpeed + random(vec2(i, 6.0)) * 6.28318);\n    vec2 offset = vec2(random(vec2(i, 0.0)), random(vec2(i, 1.0))) - 0.5;\n    offset += vec2(driftAmplitude.x * cos(iTime * driftSpeed + random(vec2(i, 2.0)) * 6.28318), driftAmplitude.y * sin(iTime * driftSpeed + random(vec2(i, 7.0)) * 6.28318)) * 0.5;\n    curUv = curUv + offset;\n        // Rotate the spiral around the center\n    curUv = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation)) * curUv;\n    float val = spiral(curUv, thickness, twistAmount);\n    float spiralColorT = random(vec2(i, 10.0)) + iTime * colorShiftSpeed;\n    // Tiny hint of blue tint\n    vec3 spiralColor = cosPalette(spiralColorT, MAIN_PALETTE) + vec3(0., 0., 0.15);\n    col += val * spiralColor * 0.35;\n  }\n\n  const float overExposureThreshold = 3.0;\n  // If we're above the overexposure threshold, mix with white to wash out the image\n  col = mix(col, vec3(1.0), smoothstep(overExposureThreshold, overExposureThreshold + 1.0, length(col)));\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n  // fragColor = vec4(spiralUv, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 163, 163, 210], [212, 212, 237, 237, 430], [432, 432, 478, 478, 649], [651, 651, 710, 710, 958], [960, 960, 1015, 1015, 3076]], "test": "untested"}
{"id": "cllfRM", "name": "the power of sdfs", "author": "01000001", "description": "I saw Mr. Quilez's recent shader https://www.shadertoy.com/view/dljyDc and wanted to try it out myself but with buffers for performance. This shader seems to work best with objects that do not have many pointy parts. ", "tags": ["thing"], "likes": 2, "viewed": 108, "published": 3, "date": "1692741188", "time_retrieved": "2024-07-30T17:37:22.582408", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    O = sqrt(texture(iChannel0, U/iResolution.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int samples = 4;\nfloat boxDF( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p)-b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdf(vec2 p){\n    return \n    /*\n    length(p)-1.;\n    /*/boxDF(p, vec2(1));\n    //*/\n}\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x ){\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 point(uvec3 x){\n    return hash(x).xy*2.-1.;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r  = iResolution.xy;\n    O       = iFrame < 20?vec4(0):texture(iChannel0, U/r);\n    O      *= 0.99;\n    vec2 uv = (2.*U-r)/r.y;\n    \n    for (int i = 0; i < samples; i++){\n        vec2 p  = point(uvec3(iFrame + i, -iFrame + i, i<<iFrame));\n        p.x *= r.x/r.y;\n        float s = 1.7;    \n        float d = length(p - uv)*s-abs(sdf(p*s));\n        O      += smoothstep(2.*s/r.y, 0., abs(d))*.2;\n    }\n    O       = vec4(max(0., O.x));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 91]], "test": "untested"}
{"id": "clScWG", "name": "Carrinho", "author": "bjks", "description": "carrinho", "tags": ["carrinho"], "likes": 0, "viewed": 119, "published": 3, "date": "1692738424", "time_retrieved": "2024-07-30T17:37:23.471032", "image_code": "void drawSquare(in vec2 uv, in vec3 color, in vec2 position,in vec2 size, \nout vec4 outColor)\n{\n    vec2 posn=-position/iResolution.xy;\n    if(uv.x+posn.x>0.0 && uv.x+posn.x<size.x \n    && uv.y+posn.y>0.0 && uv.y+posn.y<size.y)\n    {\n        outColor=vec4(color,1);\n    }\n}\n\nvoid drawCircle(in vec2 uv, in vec3 color, in vec2 position,in float radius, \nout vec4 outColor)\n{\n    vec2 posn=position/iResolution.xy;\n    float distanceToCenter=distance(uv,posn);\n    if(radius>distanceToCenter)\n    {\n        outColor=vec4(color,1);\n    }\n}\n\nvoid carrinho(in vec2 pos,in vec2 uv, out vec4 fragColor)\n{\n    drawSquare(uv,vec3(.5,.6,.5),pos+vec2(1,0),vec2(0.2, 0.1),fragColor);\n    drawSquare(uv,vec3(.5,.6,.5),pos+vec2(15,0),vec2(0.1, 0.2),fragColor);\n    drawCircle(uv,vec3(.5,.6,.5),pos+vec2(25,-7),0.03,fragColor);\n    drawCircle(uv,vec3(.5,.6,.5),pos+vec2(110,-7),0.03,fragColor);\n}\n\n\n\n\n\nvoid montanhas(in vec2 uv, in vec3 color, in vec2 position,in vec2 size, \nout vec4 outColor)\n{\n    \n}\n\nvoid DrawAPole( in vec2 pos, in vec2 uv, out vec4 PoleColor)\n{\n    \n    drawSquare(uv,vec3(0,0,0.0),vec2(-705,35), vec2(11,.05), PoleColor);  \n    for(int i = 0; i<20; i++)\n    {\n      drawSquare(uv,vec3(0,.0,.0),vec2(pos.x - 2.0 + float(i)*0.3, pos.y), vec2(.01,.2), PoleColor);  \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float yOffset = abs( 5.0 * fract(iTime) - 1.0) * 1.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor=vec4(.3,.2,.5,.5);\n    \n    //drawCircle(uv, vec3(1.5,.5,1.5), iMouse.xy, 0.05,fragColor);\n    \n    //drawSquare(uv,vec3(1.5,.5,1.5),iMouse.xy, vec2(0.1, 0.2), fragColor);\n    DrawAPole(vec2(15,0),vec2(uv.x +2.0 *fract(iTime)-1.0, uv.y), fragColor);\n    carrinho(vec2(50,25.0+yOffset),uv,fragColor);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clScWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 95, 95, 273], [275, 275, 373, 373, 536], [538, 538, 597, 597, 881], [887, 887, 981, 981, 988], [990, 990, 1052, 1052, 1279], [1281, 1281, 1338, 1338, 1807]], "test": "untested"}
{"id": "mlfBR4", "name": "Boids + Packed Voronoi Tracking", "author": "beans_please", "description": "Finally learned Voronoi Tracking, read the explanations in Buffer A.", "tags": ["voronoi", "simulation", "particles", "boids"], "likes": 1, "viewed": 121, "published": 3, "date": "1692737129", "time_retrieved": "2024-07-30T17:37:24.673817", "image_code": "// Read the explanations in Buffer A.\n\n#define BUFF_A iChannel0\n#define BUFF_B iChannel1\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Debug\n    if (false)\n    {\n        uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, ivec2(frag_coord), 0));\n        for (uint i = 0u; i < 4u; i++)\n        {\n            frag_col[i] = float(load_u16(stored_ids, i)) / float(max_particle_id(uvec2(iResolution.xy)));\n        }\n        return;\n    }\n    \n    // UV\n    px2uv_init(iResolution.xy);\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Colliders\n    vec3 col = mix(\n        vec3(.2, .6, 1.),\n        vec3(.2, .8, .1),\n        remap01(sd_colliders(uv, iTime, iMouse), px2uv, 0.)\n    );\n    \n    // Particles distance (using the Voronoi buffer)\n    uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, ivec2(frag_coord), 0));\n    float dist_sqr = 1e9;\n    for (uint i = 0u; i < n_ids_in_voronoi; i++)\n    {\n        // ID\n        uint curr_id = load_u16(stored_ids, i);\n        \n        // Check if ID is invalid\n        if (curr_id > max_particle_id(uvec2(iResolution.xy)))\n            continue;\n        \n        // Matching pixel coordinates in the data buffer (this)\n        ivec2 icoord = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n        \n        // Get the distance\n        vec2 pos = texelFetch(BUFF_B, icoord, 0).xy;\n        pos -= uv;\n        dist_sqr = min(dist_sqr, dot(pos, pos));\n    }\n    \n    // Particles\n    col = mix(\n        col,\n        vec3(.05),\n        remap01(sqrt(dist_sqr), particle_radius + px2uv * .5, particle_radius - px2uv * .5)\n    );\n    \n    // Point of attraction\n    vec2 poa = get_point_of_attraction(iTime, iMouse);\n    col = mix(\n        col,\n        vec3(.8, 0.05, 0.04),\n        remap01(distance(uv, poa), .03, .03 - px2uv)\n    );\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Desired number of particles (actual count might be less)\nconst uint n_particles = 400u;\n\n// Number of particle IDs stored in each pixel in the Voronoi buffer\nconst uint n_ids_in_voronoi = 8u;\n\n// Particle position bounds\nconst vec2 min_pos = vec2(-.9);\nconst vec2 max_pos = vec2(.9);\n\n// Boid movement speed\nconst float move_speed = .6;\n\n// Particle radius for rendering\nconst float particle_radius = .006;\n\n// Particle attention radius\nconst float attention_radius = .2;\n\n// Epsilon\nconst float eps = .001;\n\n// Pixel to UV conversion factor\nfloat px2uv;\n\n// iResolution\nvec2 gres;\n\n// Initialize px2uv and gres\nvoid px2uv_init(vec2 res)\n{\n    px2uv = 2. / min(res.x, res.y);\n    gres = res;\n}\n\n// Screen to UV\nvec2 screen_to_uv(vec2 coord)\n{\n    return px2uv * (coord - .5 * gres);\n}\n\n// UV to screen\nvec2 uv_to_screen(vec2 uv)\n{\n    return (uv / px2uv) + (.5 * gres);\n}\n\n// Signed distance from the colliders\n// Make sure you have called px2uv_init() before\nfloat sd_colliders(vec2 p, float time, vec4 mouse)\n{\n    float d = 1e9;\n    \n    // Walls (bounds)\n    d = min(d, p.x - min_pos.x);\n    d = min(d, p.y - min_pos.y);\n    d = min(d, max_pos.x - p.x);\n    d = min(d, max_pos.y - p.y);\n    \n    // Circle\n    vec2 center;\n    if (false && mouse.z > .1)\n    {\n        center = screen_to_uv(mouse.xy);\n    }\n    else\n    {\n        center = vec2(sin(time) * .4, 0.);\n    }\n    d = min(d, length(p - center) - .15);\n    \n    return d;\n}\n\n// Get the point of attraction\nvec2 get_point_of_attraction(float time, vec4 mouse)\n{\n    if (true && mouse.z > .1)\n    {\n        return screen_to_uv(mouse.xy);\n    }\n    else\n    {\n        float a = .8 * time;\n        return .7 * vec2(cos(a), sin(a));\n    }\n}\n\nuint umin(uint a, uint b)\n{\n    return (a < b) ? a : b;\n}\n\nuint max_particle_id(uvec2 res)\n{\n    return umin(umin(n_particles - 1u, res.x * res.y - 1u), 65535u);\n}\n\n\n\n/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return int(result % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random();\n    float temp = sqrt(-2. * log(u1));\n    return vec2(temp * cos(TAU * u2), temp * sin(TAU * u2));\n}\n\n// Initialize\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n/*____________________ End ____________________*/\n\n\n\n// 1D index --> 2D integer coordinates\nivec2 idx_to_icoord2(int idx, ivec2 res)\n{\n    return ivec2(idx % res.x, idx / res.x);\n}\n\n// 1D index --> 3D integer coordinates\nivec3 idx_to_icoord3(int idx, ivec3 res)\n{\n    return ivec3(\n        idx % res.x,\n        (idx % (res.x * res.y)) / res.x,\n        idx / (res.x * res.y)\n    );\n}\n\n// 2D integer coordinates --> 1D index\nint icoord2_to_idx(ivec2 icoord, ivec2 res)\n{\n    return icoord.x + icoord.y * res.x;\n}\n\n// 3D integer coordinates --> 1D index\nint icoord3_to_idx(ivec3 icoord, ivec3 res)\n{\n    return\n        icoord.x\n        + icoord.y * res.x\n        + icoord.z * res.x * res.y;\n}\n\n// 2D integer coordinates --> 3D integer coordinates\nivec3 icoord2_to_3(ivec2 icoord2, ivec2 res2d, ivec3 res3d)\n{\n    return idx_to_icoord3(icoord2_to_idx(icoord2, res2d), res3d);\n}\n\n// 3D integer coordinates --> 2D integer coordinates\nivec2 icoord3_to_2(ivec3 icoord3, ivec3 res3d, ivec2 res2d)\n{\n    return idx_to_icoord2(icoord3_to_idx(icoord3, res3d), res2d);\n}\n\n// Check if 2D integer coordinates 'icoord' fit in a 2D screen of size 'res'\nbool icoord_in_bounds(ivec2 icoord, ivec2 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y);\n}\n\n// Check if 3D integer coordinates 'icoord' fit in a 3D screen of size 'res'\nbool icoord_in_bounds(ivec3 icoord, ivec3 res)\n{\n    return\n        (icoord.x >= 0) && (icoord.x < res.x)\n        && (icoord.y >= 0) && (icoord.y < res.y)\n        && (icoord.z >= 0) && (icoord.z < res.z);\n}\n\n// Load a 16-bit unsigned integer from a uvec4. Max index is 7.\nuint load_u16(in uvec4 container, uint idx)\n{\n    if ((idx % 2u) == 0u)\n    {\n        return container[idx / 2u] & 65535u;\n    }\n    else\n    {\n        return (container[idx / 2u] & (65535u << 16)) >> 16;\n    }\n}\n\n// Store a 16-bit unsigned integer in a uvec4. Max index is 7.\nvoid store_u16(inout uvec4 container, uint idx, uint value)\n{\n    if (value > 65535u) value = 65535u;\n    container[idx / 2u] |= value << (16u * (idx % 2u));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr <= 1. && lensqr != 0.) break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr <= 1. && lensqr != 0.) break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\nmat2 rotate2D(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n", "buffer_a_code": "// Voronoi buffer\n\n// Each pixel stores 8 IDs that are supposed to be the IDs of the eight closest\n// particles to the current pixel's matching UV coordinates. We store 8 IDs by\n// embedding them in the output as 16-bit integers. This is done by the help\n// of functions load_u16() and store_u16() implemented in Common, and built-in\n// functions uintBitsToFloat() and floatBitsToUint().\n\n// Each frame, we calculate the distances of the particles associated with the\n// IDs stored in a few randomly selected neighboring pixels (using a gaussian\n// distribution around the current pixel) from the current pixel's UV\n// coordinates, and we also do some checks against a few random particles in\n// the data buffer. After we have gathered all of the distances and their\n// corresponding particle IDs (the dist and id arrays), we sort them and\n// output the first 8 unique IDs to frag_col, storing them as 16-bit integers.\n\n// We have a mechanism for converting integer pixel coordinates to 1D indices\n// and vice versa. This lets us treat the data buffer (B) as a 1D array\n// instead of a 2D texture. This is how we calculate the integer pixel\n// coordinates from the particle ID. This also means we need to reset every\n// time the resolution changes. We do this by storing the resolution data in\n// the last pixel in the buffer. The last pixel in the Voronoi buffer also\n// contains the iteration number (number of frames since the last reset).\n\n// The data buffer (B) stores and updates the particle data. Each pixel stores\n// the position and the velocity of one particle in xy and zw. Every frame, we\n// use the Voronoi buffer (this) to get information about the 8 closest\n// particles.\n\n// You can find related constants in the Common tab.\n\n#define BUFF_A iChannel0\n#define BUFF_B iChannel1\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Info about the last pixel where we store useful data\n    ivec2 res_coord = ivec2(iResolution.xy) - 1;\n    vec4 res_data = texelFetch(BUFF_A, res_coord, 0);\n\n    // Should we reset?\n    bool should_reset =\n        iFrame < 1 ||\n        iTime < .02 ||\n        res_data.xy != iResolution.xy;\n    \n    // Store the current resolution in the last pixel, also store the number of\n    // frames passed since the last reset/initialization (Voronoi iteration).\n    if (ivec2(frag_coord) == res_coord)\n    {\n        frag_col = vec4(iResolution.xy, should_reset ? 0. : res_data.z + 1., 0);\n        return;\n    }\n    \n    // UV\n    px2uv_init(iResolution.xy);\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Are we outside the bounds?\n    if (any(lessThan(uv, min_pos - .05)) || any(greaterThan(uv, max_pos + .05)))\n    {\n        frag_col = vec4(0);\n        return;\n    }\n\n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Initialize with randomized IDs\n    if (should_reset)\n    {\n        uvec4 ids = uvec4(0);\n        for (uint i = 0u; i < n_ids_in_voronoi; i++)\n        {\n            store_u16(ids, i, randomui() % (max_particle_id(uvec2(iResolution.xy)) + 1u));\n        }\n        frag_col = uintBitsToFloat(ids);\n        return;\n    }\n    \n    // Gather the distances of the particles associated with the IDs stored in\n    // some neighboring pixels, and a few randomly selected particles.\n    const uint neighbors = 3u;\n    const uint random_checks = 2u;\n    \n    // A pixel in the Voronoi buffer (this) stores 8 IDs but a random check\n    // only checks a single particle.\n    const uint total_checks = n_ids_in_voronoi * neighbors + random_checks;\n    \n    // Array for storing the distances (squared for performance) and their\n    // associated IDs.\n    float dist_sqr[total_checks];\n    uint id[total_checks];\n    uint head = 0u;\n    \n    // Neighboring pixels\n    for (uint i = 0u; i < neighbors; i++)\n    {\n        // Coordinates of the pixel to check in the Voronoi buffer (this)\n        // Using gaussian distribution to focus around the center\n        vec2 offs = 3. * random_gauss();\n        ivec2 icoord = ivec2(floor(frag_coord + offs));\n        \n        // Check the IDs\n        uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, icoord, 0));\n        for (uint j = 0u; j < n_ids_in_voronoi; j++)\n        {\n            // ID\n            uint curr_id = load_u16(stored_ids, j);\n            id[head] = curr_id;\n            \n            // Get pixel coordinates in the data buffer (B)\n            ivec2 icoord2 = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n            \n            // Get the position from the data buffer (B)\n            vec2 curr_pos = texelFetch(BUFF_B, icoord2, 0).xy;\n            \n            // Distance squared\n            curr_pos -= uv;\n            dist_sqr[head] = dot(curr_pos, curr_pos);\n            \n            head++;\n        }\n    }\n    \n    // Also check against a few random particles in the data buffer (B)\n    for (uint i = 0u; i < random_checks; i++)\n    {\n        // ID\n        uint curr_id = randomui() % (max_particle_id(uvec2(iResolution.xy)) + 1u);\n        id[head] = curr_id;\n        \n        // Get pixel coordinates in the data buffer (B)\n        ivec2 icoord = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n        \n        // Get the position from the data buffer (B)\n        vec2 curr_pos = texelFetch(BUFF_B, icoord, 0).xy;\n        \n        // Distance squared\n        curr_pos -= uv;\n        dist_sqr[head] = dot(curr_pos, curr_pos);\n        \n        head++;\n    }\n    \n    // Sort id and dist based on dist in increasing order (Insertion Sort)\n    // https://betterprogramming.pub/5-basic-sorting-algorithms-you-must-know-9ef5b1f3949c\n    {\n        int i, j;\n        float keyf;\n        uint keyi;\n        for (i = 1; i < int(total_checks); i++)\n        {\n            keyf = dist_sqr[i];\n            keyi = id[i];\n            j = i - 1;\n            \n            /* Move elements of arr[0..i-1], that are greater than key, to one position ahead \n            of their current position */\n            while (j >= 0 && dist_sqr[j] > keyf)\n            {\n                dist_sqr[j + 1] = dist_sqr[j];\n                id[j + 1] = id[j];\n                j--;\n            }\n            dist_sqr[j + 1] = keyf;\n            id[j + 1] = keyi;\n        }\n    }\n    \n    // Pick the first 8 unique IDs and store as 16-bit ints\n    uvec4 closest_ids = uvec4(0);\n    head = 0u;\n    for (uint i = 0u; i < total_checks; i++)\n    {\n        // Check if this ID is unique\n        bool unique = true;\n        for (uint j = 0u; j < i; j++)\n        {\n            if (id[i] == id[j])\n            {\n                unique = false;\n                break;\n            }\n        }\n        \n        if (unique)\n        {\n            // Store new unique ID in closest_ids\n            uint curr_id = id[i];\n            store_u16(closest_ids, head++, curr_id);\n            if (head >= n_ids_in_voronoi)\n                break;\n        }\n    }\n    \n    // Output closest_ids\n    frag_col = uintBitsToFloat(closest_ids);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Data buffer\n// Read the explanations in Buffer A.\n\n#define BUFF_A iChannel0\n#define BUFF_B iChannel1\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Store the current resolution in the last pixel\n    ivec2 res_coord = ivec2(iResolution.xy) - 1;\n    if (ivec2(frag_coord) == res_coord)\n    {\n        frag_col = vec4(iResolution.xy, 0, 0);\n        return;\n    }\n    \n    // Are we outside the region of interest?\n    uint idx = uint(icoord2_to_idx(ivec2(frag_coord), ivec2(iResolution.xy)));\n    if (idx > max_particle_id(uvec2(iResolution.xy)))\n    {\n        return;\n    }\n    \n    // Initialize PRNG\n    prng_init(vec3(5. + frag_coord / iResolution.y, iTime + 5.));\n    \n    // Should we reset?\n    bool should_reset =\n        iFrame < 1 ||\n        iTime < .02 ||\n        texelFetch(BUFF_B, res_coord, 0).xy != iResolution.xy;\n    \n    // Initialize with random position and velocity\n    if (should_reset)\n    {\n        vec2 pos = vec2(remap(random(), 0., 1., min_pos.x, max_pos.x), remap(random(), 0., 1., min_pos.y, max_pos.y));\n        float angle = random() * TAU;\n        vec2 vel = move_speed * vec2(cos(angle), sin(angle));\n        frag_col = vec4(pos, vel);\n        return;\n    }\n    \n    // UV\n    px2uv_init(iResolution.xy);\n    \n    // Get last frame's value\n    vec4 data = texelFetch(BUFF_B, ivec2(frag_coord), 0);\n    vec2 pos = data.xy;\n    vec2 vel = data.zw;\n    \n    // Wait until the Voronoi buffer is relatively stable.\n    float voronoi_iter = texelFetch(BUFF_A, res_coord, 0).z;\n    if (voronoi_iter < 25.)\n    {\n        frag_col = vec4(pos, vel);\n        return;\n    }\n    \n    // Where does pos fall on the screen?\n    ivec2 icoord_pos = ivec2(floor(uv_to_screen(pos)));\n    \n    // Information about the 8 closest particles (using the Voronoi buffer)\n    uvec4 stored_ids = floatBitsToUint(texelFetch(BUFF_A, icoord_pos, 0));\n    vec2 nearby_pos[8];\n    vec2 nearby_vel[8];\n    float nearby_dist[8];\n    for (uint i = 0u; i < n_ids_in_voronoi; i++)\n    {\n        // ID\n        uint curr_id = load_u16(stored_ids, i);\n        \n        // Check if ID is invalid\n        if (curr_id > max_particle_id(uvec2(iResolution.xy)))\n        {\n            nearby_pos[i] = vec2(-100000.);\n            nearby_vel[i] = vec2(0);\n            nearby_dist[i] = 100000.;\n        }\n        else\n        {\n            // Matching pixel coordinates in the data buffer (this)\n            ivec2 icoord = idx_to_icoord2(int(curr_id), ivec2(iResolution.xy));\n            \n            // Get information\n            vec4 data2 = texelFetch(BUFF_B, icoord, 0);\n            nearby_pos[i] = data2.xy;\n            nearby_vel[i] = data2.zw;\n            nearby_dist[i] = distance(pos, nearby_pos[i]);\n        }\n    }\n    \n    // Delta time\n    float dt = min(iTimeDelta, 0.02);\n    \n    // Steer away from nearby boids\n    for (uint i = 0u; i < n_ids_in_voronoi; i++)\n    {\n        // Is the other boid in my view cone?\n        if (dot(normalize(vel), normalize(nearby_vel[i])) > cos(1.1))\n        {\n            // Vector between us\n            vec2 this_to_other = nearby_pos[i] - pos;\n            \n            // How much do I steer away?\n            float fac = 1. - clamp(nearby_dist[i] / attention_radius, 0., 1.);\n            \n            // Steer\n            float deg_per_sec = 20. * fac;\n            vel *= rotate2D(radians(deg_per_sec * dt));\n            \n            // Move away\n            vel -= 5. * fac * dt * this_to_other;\n        }\n    }\n    \n    // Try to go in the same direction as the neighbors\n    if (true)\n    {\n        // Weighted average of the neighbor velocities\n        vec2 avg_vel = vec2(0);\n        for (uint i = 0u; i < n_ids_in_voronoi; i++)\n        {\n            float weight = 1. - clamp(nearby_dist[i] / attention_radius, 0., 1.);\n            avg_vel += weight * nearby_vel[i];\n        }\n        \n        // Check if the lengths (squared) are zero\n        float lensqr_avg_vel = dot(avg_vel, avg_vel);\n        float lensqr_vel = dot(vel, vel);\n        if (lensqr_avg_vel > 0. && lensqr_vel > 0.)\n        {\n            // Tend toward the average direction\n            vel = mix(vel, avg_vel, min(.3 * dt, 1.));\n        }\n    }\n    \n    // Try to follow the point of attraction\n    if (true)\n    {\n        vec2 poa = get_point_of_attraction(iTime, iMouse);\n        vel = mix(vel, (poa - pos), min(1. * dt, 1.));\n    }\n    \n    // Constant speed\n    vel = move_speed * normalize(vel);\n\n    // Update position\n    pos += vel * dt;\n    \n    // Get away from the colliders\n    if (true)\n    {\n        // Signed distance\n        float sd = sd_colliders(pos, iTime, iMouse);\n        \n        // Normal\n        vec2 normal = normalize(vec2(\n            sd_colliders(pos + vec2(eps, 0.0), iTime, iMouse) - sd,\n            sd_colliders(pos + vec2(0.0, eps), iTime, iMouse) - sd\n        ));\n        \n        // If inside\n        if (sd < 0.)\n        {\n            // Snap to outside\n            pos += (.001 - sd) * normal;\n            \n            // Bounce\n            vel = reflect(vel, normal);\n        }\n        \n        // Steer away\n        float temp = max(0., sd);\n        float deg_per_sec = -50. * exp(-15. * temp);\n        float angle = radians(deg_per_sec * dt);\n        vel *= rotate2D(angle);\n        \n        // Move away\n        temp *= temp;\n        float force = 1. / (100. * temp + .1);\n        vel += force * dt * normal;\n    }\n    \n    // Output\n    frag_col = vec4(pos, vel);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 145, 158, 1883]], "test": "untested"}
{"id": "Dlffz7", "name": "Greenosys", "author": "Jayzeen", "description": "Just a simple fractal design", "tags": ["fractal", "fantasy"], "likes": 1, "viewed": 175, "published": 3, "date": "1692728931", "time_retrieved": "2024-07-30T17:37:25.533517", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.341,0.867,1.000);\n    vec3 b = vec3(0.255,0.439,0.984);\n    vec3 c = vec3(1.000,0.757,0.659);\n    vec3 d = vec3(0.333,0.925,0.969);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i=0.0; i<4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n    \n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0)  + i*.4 + iTime*.2);\n\n        d = sin(d * 10. + iTime)/4.;\n        d = abs(d);\n\n        d = 0.01 / d ;\n\n        finalColor += col * d;\n    \n    }\n    \n     // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlffz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 225], [227, 227, 284, 334, 840]], "test": "untested"}
{"id": "mtXBRM", "name": "A Noisy Life", "author": "tetrismegistus", "description": "a combination of Perlin Noise and Conway's Game of Life, http://thelastindex.com/noisyshader/", "tags": ["cellularautomata"], "likes": 3, "viewed": 257, "published": 3, "date": "1692725659", "time_retrieved": "2024-07-30T17:37:26.299469", "image_code": "precision highp float;\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Sample texture from iChannel0 (assuming currentStateTexture is here)\n    vec4 cellData = texture(iChannel0, uv);\n    float cellState = cellData.r;\n    float cellAge = cellData.g;\n\n    vec4 color1 = vec4(0.6, 0.5608, 0.7804, 1.0);\n    vec4 color2 = vec4(0.0784, 0.1412, 0.5412, 1.0);  // #14248A\n    vec4 deadColor = vec4(0.1569, 0.1490, 0.1725, 1.0);\n\n    vec4 finalColor;\n    if(cellState == 1.0) { // If the cell is alive\n        // Interpolate between color1 and color2 based on age\n        finalColor = mix(color1, color2, cellAge);\n    } else {\n        finalColor = deadColor;\n    }\n\n    fragColor = finalColor;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "precision highp float;\n\nconst float perlinThreshold = 0.5;\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n\nfloat cnoise(vec4 P){\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / 7.0;\n  vec4 gy00 = floor(gx00) / 7.0;\n  vec4 gz00 = floor(gy00) / 6.0;\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 / 7.0;\n  vec4 gy01 = floor(gx01) / 7.0;\n  vec4 gz01 = floor(gy01) / 6.0;\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 / 7.0;\n  vec4 gy10 = floor(gx10) / 7.0;\n  vec4 gz10 = floor(gy10) / 6.0;\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 / 7.0;\n  vec4 gy11 = floor(gx11) / 7.0;\n  vec4 gz11 = floor(gy11) / 6.0;\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 texelSize = 1.0 / iChannelResolution[0].xy; // Use the resolution of the first channel\n    vec2 uv = fragCoord * texelSize;\n\n    float aliveCount = 0.0;\n    float noiseVal = cnoise(vec4(uv.x * 6.25, uv.y * 6.25, iTime * 0.1, 0.0));\n    float age = texture(iChannel0, uv).g;\n\n    // Iterate over the neighbors\n    for(int dx=-1; dx<=1; dx++) {\n        for(int dy=-1; dy<=1; dy++) {\n            if(dx != 0 || dy != 0) {\n                vec2 neighborUV = uv + vec2(dx, dy) * texelSize;\n                float neighborState = texture(iChannel0, neighborUV).r;\n                aliveCount += neighborState;\n            }\n        }\n    }\n\n    vec4 currentData = texture(iChannel0, uv);\n    float currentState = currentData.r;\n    float currentAge = currentData.g;\n    float newState;\n    float newAge = currentAge;\n\n    if(currentState == 1.0) {\n        if(aliveCount < 2.0 || (aliveCount > 3.0 && noiseVal < perlinThreshold))\n            newState = 0.0;\n        else {\n            newState = 1.0;\n            newAge += 0.005;\n            newAge = min(newAge, 1.0);\n        }\n    } else {\n        if (aliveCount == 3.0 || noiseVal > perlinThreshold) {\n            newState = 1.0;\n            newAge = 0.0;\n        } else {\n            newState = 0.0;\n        }\n    }\n    \n    fragColor = vec4(newState, newAge, 0.0, 1.0);\n    \n    if(iFrame == 0) {\n        vec4 seedColor = texture(iChannel1, uv); \n        if(seedColor.r > 0.5) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0); // Alive\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Dead\n        }\n    }\n}\n    \n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 81, 125, 794]], "test": "untested"}
{"id": "clffR7", "name": "Mipmap visualizer", "author": "sotrh", "description": "A simple way to visualize the mipmaps of a texture.", "tags": ["debug"], "likes": 3, "viewed": 158, "published": 3, "date": "1692724490", "time_retrieved": "2024-07-30T17:37:27.119278", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 size = vec2(4.0, 3.0);\n    vec2 p = uv * size;\n    \n    vec2 st = fract(p);\n    vec2 id = floor(vec2(p.x, size.y - p.y));\n    float lod = id.x + size.x * id.y;\n\n    vec3 col = textureLod(iChannel0, st, lod).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clffR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 352]], "test": "untested"}
{"id": "clXBR7", "name": "dithering with points (not mask)", "author": "FabriceNeyret2", "description": "applying fast white noise  https://shadertoy.com/view/DtfBRM  ( ie. using true points rather than thresholfing with a noise mask ).\nMouse.x controls the density.\n", "tags": ["noise", "poisson", "blue"], "likes": 13, "viewed": 236, "published": 3, "date": "1692723884", "time_retrieved": "2024-07-30T17:37:27.967011", "image_code": "// applying fast white noise  https://shadertoy.com/view/DtfBRM\n// some limitations: - I don't manage cells border ( should visit neighbors )\n//                   - no seed coherence when the density varies in time\n\nvec3 uhash3( uvec3 x ) {         // iq version https://shadertoy.com/view/XlXcW4\n    const uint k = 1103515245U;  // GLIB C version\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)/float(0xffffffffU);\n}\n#define iH3(f)  uhash3( floatBitsToUint(f) ) // FabriceN version https://www.shadertoy.com/view/NtjyWw\n#define iH32(f) iH3(f).xy\n\n\nvoid mainImage( out vec4 O, vec2 u ) // ----------------------------------------------------------------------\n{\n    float d = 9., r,t, n;                                   // n x n cells\n    vec2  R = iResolution.xy;\n    r = R.x/R.y;                                            // aspect ratio\n    t =   iMouse.z > 0. ? exp2(iMouse.x/R.x) - 1.           // target point density\n                        : .5+.5*sin(iTime);                 // mouse vs demo mode.\n                     // : float(iFrame);\n    O = texture(iChannel0,u/R);        \n    t *= ( exp2(length(O.rgb))-1.) * 16.*16.*100. * R.x/800.;\n    \n    n = max(1., floor(sqrt(t/5.)) );                        // 5 = target point per cell. Choose n accordingly.\n    t = round(t/(n*n))*n*n;                                 // if we want same number of points everywhere.\n    \n    vec2  U = n * u / R.y, D,\n          I = floor(U),                                     // cell id\n          F = U-I;                                          // coords in cells   \n   \n    O *= 0.;                                    \n    for (float i=0.; i < t/(n*n); i++ )                     // ---  white noise in n x n cells\n        D = F - iH32(vec3(I,i-t)),                          // distance vector to point\n        d = min(d, dot(D,D) );                              // keep smallest d²\n     // O += smoothstep(1.5*n/R.y, 0., length(D) );         // draw point\n\n    O += smoothstep(1.5*n/R.y, 0., sqrt(d) );               // draw closest point\n    \n  \n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 240, 296, 473], [605, 605, 717, 717, 2106]], "test": "untested"}
{"id": "DlXBR7", "name": "Primitive Drawing :)", "author": "nakanzaki", "description": "A drawing using primitive shapes", "tags": ["primitives"], "likes": 0, "viewed": 120, "published": 3, "date": "1692723694", "time_retrieved": "2024-07-30T17:37:28.784824", "image_code": "bool circle(vec2 uvCenter, float diameter, vec2 uvCoord) {\n    return distance(uvCenter * iResolution.xy, uvCoord * iResolution.xy) \n           < diameter * iResolution.y / 2.0;\n}\n\nbool rectangle(vec2 uvCenter, vec2 shape, vec2 uvCoord) {\n    return abs((uvCenter.x * iResolution.x) - (uvCoord.x * iResolution.x)) \n           < (shape.x * iResolution.y / 2.0)\n           &&\n           abs((uvCenter.y * iResolution.y) - (uvCoord.y * iResolution.y))\n           < (shape.y * iResolution.y / 2.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    vec2 uvCoord = fragCoord/iResolution.xy;\n    \n    // Testing\n    \n    // Circle\n    //if(circle(vec2(0.5, 0.5), 0.5, uvCoord)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    // Square\n    //if(rectangle(vec2(0.5, 0.5), vec2(0.5, 0.5), uvCoord)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    // Animation\n    \n    // Bounce horizontaly\n    vec2 drawingOffset = vec2(sin(iTime * 4.0) / 10.0, 0.0);\n    \n    // Drawing\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if(circle(vec2(0.35, 0.7) + drawingOffset, 0.25, uvCoord)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    if(circle(vec2(0.65, 0.7) + drawingOffset, 0.25, uvCoord)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    if(rectangle(vec2(0.5, 0.2) + drawingOffset, vec2(0.75, 0.1), uvCoord)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    if(rectangle(vec2(0.3, 0.25) + drawingOffset, vec2(0.1, 0.2), uvCoord)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    if(rectangle(vec2(0.7, 0.25) + drawingOffset, vec2(0.1, 0.2), uvCoord)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXBR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 179], [181, 181, 238, 238, 496], [498, 498, 553, 589, 1603]], "test": "untested"}
{"id": "DtfBRM", "name": "fast white/Poisson point distri2", "author": "FabriceNeyret2", "description": "Adaptive variant of https://shadertoy.com/view/dtlfzN\nRight: naive white/Poisson distrib. Cost = number of dots.\nLeft: taking ~5 random point per cell, with cell size adapted to reach the target density. Still, note that low freq variations are missing.", "tags": ["noise", "poisson", "blue"], "likes": 5, "viewed": 181, "published": 3, "date": "1692718344", "time_retrieved": "2024-07-30T17:37:29.829032", "image_code": "// === left white noise / Poisson point distribution always cost ~5 while right naive point distrib cost ~ number or points.\n// ( adaptive variant of https://shadertoy.com/view/dtlfzN )\n\n// --- hash utilities  ( float version get visibly bias for high densities ).\n\n// #define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n// #define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *3758.5453123)\n// #define H23(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n// #define H32(p) fract(sin((p)*mat2x3(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n\nvec3 uhash3( uvec3 x ) {         // iq version https://shadertoy.com/view/XlXcW4\n    const uint k = 1103515245U;  // GLIB C version\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)/float(0xffffffffU);\n}\n#define iH3(f)  uhash3( floatBitsToUint(f) ) // FabriceN version https://www.shadertoy.com/view/NtjyWw\n#define iH32(f) iH3(f).xy\n\n\nvoid mainImage( out vec4 O, vec2 u ) // ----------------------------------------------------------------------\n{\n    float d = 9., r,t, n;                                   // n x n cells\n    vec2  R = iResolution.xy;\n    r = R.x/R.y;                                            // aspect ratio\n    t = floor( 16.*16. * ( \n               iMouse.z > 0. ? exp2(9.*iMouse.x/R.x) - 1.   // target point density\n                             : 10.* ( .5+.5*sin(iTime) ) )  // mouse vs demo mode.\n                          // : float(iFrame)\n             );\n    n = max(1., floor(sqrt(t/5.)) );                        // 5 = target point per cell. Choose n accordingly.\n    t = round(t/(n*n))*n*n;                                 // if we want same number of points everywhere.\n    \n    vec2  U = n * u / R.y, D,\n          I = floor(U),                                     // cell id\n          F = U-I;                                          // coords in cells  \n    O *= 0.;   \n   \n    if ( u.x < R.x/2. )                                     // --- left: white noise in n x n cells\n      for (float i=0.; i < t/(n*n); i++ )\n          D = F - iH32(vec3(I,i)),                          // distance vector to point\n          d = min(d, dot(D,D) );                            // keep smallest d²\n       // O += smoothstep(1.5*n/R.y, 0., length(D) );       // draw point\n          \n    else                                                    // --- right: white noise in whole screen.\n      for (float i=0.; i < t*r/2.; i++ )                    // unstructured: we need to test all points\n          D = U - n*( vec2(r/2.,0) + vec2(r/2.,1)* iH32(i*vec3(1,17,71)) ),\n          d = min(d, dot(D,D) );\n    \n    O += smoothstep(1.5*n/R.y, 0., sqrt(d) );               // draw closest point\n    \n    if ( int(u)==int(R)/2 ) O = vec4(1,0,0,0);              // red separator\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[609, 609, 633, 689, 866], [998, 998, 1110, 1110, 2858]], "test": "untested"}
{"id": "dtlfzN", "name": "fast white/Poisson point distrib", "author": "FabriceNeyret2", "description": "sometime we want blue distrib, but sometime we just want fast white/Poisson distrib.\nleft: white noise in 16x16 cells        right: white noise in whole screen.\nMouse.x controls density.\nsince ~ 5 points per cell, blueness bias is no longer visible.\n\n", "tags": ["noise", "poisson", "blue"], "likes": 4, "viewed": 165, "published": 3, "date": "1692715963", "time_retrieved": "2024-07-30T17:37:30.867257", "image_code": "// === left white noise / Poisson point distribution is 228 times cheaper than right naive point distrib. \n//     Same quality as soon as density t >= 5.  \n//    ( for less, we could just use larger cells : see  https://shadertoy.com/view/dtlfzN ).\n\n// --- hash utilities  ( float version get visibly biased for high densities ).\n\n// #define H(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n// #define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *3758.5453123)\n// #define H23(p) fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n// #define H32(p) fract(sin((p)*mat2x3(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123)\n\nvec3 uhash3( uvec3 x ) {         // iq version https://shadertoy.com/view/XlXcW4\n    const uint k = 1103515245U;  // GLIB C version\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x)/float(0xffffffffU);\n}\n#define iH3(f)  uhash3( floatBitsToUint(f) ) // FabriceN version https://www.shadertoy.com/view/NtjyWw \n#define iH32(f) iH3(f).xy\n\n\nvoid mainImage( out vec4 O, vec2 u ) // ----------------------------------------------------------------------\n{\n    float d = 9., r,t, n = 16.;                             // n x n cells\n    vec2  R = iResolution.xy,\n          U = n * u / R.y, D,\n          I = floor(U),                                     // cell id\n          F = U-I;                                          // coords in cells\n\n    r = R.x/R.y;                                            // aspect ratio\n    t = floor( iMouse.z > 0. ? exp2(9.*iMouse.x/R.x)        // target point density\n                             : 10.* ( .5+.5*sin(iTime) ) ); // mouse vs demo mode.\n                          // : float(iFrame);\n    O *= 0.;   \n   \n    if ( u.x < R.x/2. )                                     // --- left: white noise in 16x16 cells\n      for (float i=0.; i < t; i++ ) \n          D = F - iH32(vec3(I,i)),                          // distance vector to point\n          d = min(d, dot(D,D) );                            // keep smallest d²\n          \n    else                                                    // --- right: white noise in whole screen.\n      for (float i=0.; i < t*n*n*r/2.; i++ )                // unstructured: we need to test a *lot* more points\n          D = U - n*( vec2(r/2.,0) + vec2(r/2.,1)* iH32(i*vec3(1,17,71)) ),\n          d = min(d, dot(D,D) );\n    \n    O += smoothstep(1.5*n/R.y, 0., sqrt(d) );               // draw closest point\n    \n    if ( int(u)==int(R)/2 ) O = vec4(1,0,0,0);              // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[674, 674, 698, 754, 931], [1064, 1064, 1176, 1176, 2584]], "test": "untested"}
{"id": "dtlBzN", "name": "Ruang", "author": "zhonkvision", "description": "Inspired by \"Space = Ruang\"", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 2, "viewed": 155, "published": 3, "date": "1692712898", "time_retrieved": "2024-07-30T17:37:31.622238", "image_code": "vec3 palette(float d) {\n    vec3 purple = vec3(0.6, 0.4, 0.8); // Purple\n    vec3 pink = vec3(0.9, 0.4, 0.6);   // Pink\n    return mix(purple, pink, d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.1; // Adjust modulation speed\n    for (int i = 0; i < 5; ++i) { // Increase iterations\n        float t = angle;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 0.2); // Adjust rotation\n        p.xz = abs(p.xz);\n        p.xz -= 0.2;\n    }\n    \n    float ruang = length(p.xy) - abs(sin(p.z * 1.0 + iTime * 0.75)) * 0.15; // ruang\n    \n    return ruang;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.2;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 200.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 200.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -50.0);\n    ro.xz = rotate(ro.xz, iTime * 0.5); // Adjust rotation speed\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlBzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 154], [156, 156, 186, 186, 266], [268, 268, 287, 287, 684], [686, 686, 713, 713, 1095], [1097, 1097, 1152, 1152, 1608]], "test": "untested"}
{"id": "clsfRN", "name": "volumetric trap #3: dens vs occl", "author": "FabriceNeyret2", "description": "Water and air are continuous volumetric material, but many are made of opaque particles ( pigments, foliage... ).\nTrap: If occluders distribution is space-correlated, the opacity is angle-dependent, and can be both under or over estimated.\n", "tags": ["volumetric", "tuto", "short"], "likes": 7, "viewed": 227, "published": 3, "date": "1692707050", "time_retrieved": "2024-07-30T17:37:32.368243", "image_code": "// === volumetric trap: occlusion ≠ density, \n//     since the 1st can be direction-dependent if the occluder distribution is space-correlated.\n//     In particular, opacity is generally surestimated on silhouettes of voxelized solid objects.\n//     Density makes sense only for truly homogeneous material or totally uncorrelated distributions.\n\n// see also  volumetric trap #1: \"density\": https://shadertoy.com/view/mllBR8\n//           volumetric trap #2: \"Ti*𝛙*To\"\" https://shadertoy.com/view/mtsfR8\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float n = 7., i = 16., a, k; \n    vec2  R = iResolution.xy, A = R/R.y,\n          U = n* u / R.y,\n          K = floor(U/A),                                           // set id\n          N = U - K*A +(1.-A)/2.,                                   // coord in set\n          B =  abs(N-.5),                                           // centered symmetric version ( for boxes )\n          I = floor(N*i);                                           // subpixels\n          k = K.x/(n-1.);                                           // set coefficient in [0,1]\n\n    O *= 0.;\n    if (clamp(N,0.,1.) != N ) return;\n    \n    K.y==6. ? O.r = smoothstep( 3.*i/R.y, 0., abs(max(B.x,B.y)-.5) ),                         // red boxes            \n              O += vec4( round( mix( i*fract(1e4*sin(I.y*171.7-K.x*93.2)), I.y, k) ) == I.x ) // particles configuration\n            : O ; \n \n    K.x==3. ? O.r += max(0., 1.-R.y/n* abs(  K.y==2. ? N.y - N.x    // red: directionality\n                                           : K.y==0. ? N.y + N.x -1. \n                                           : K.y==4. ? min( abs(B.x-B.y), min(B.x,B.y)) \n                                           : 1.)) : 0.;\n    a = 1. - pow(1.-1./i,i);\n    if ( K.x<1. || K.x > n-2. )\n        O += floor(U.y-.2)==4. ?     a          : 0.,               // opacity, assuming no correlation\n        O += floor(U.y-.4)==2. ? mix(a, 1./i,k) : 0.,               // opacity along /\n        O += floor(U.y-.6)==0. ? mix(a, 1.  ,k) : 0.;               // opacity along \\\n    \n    O = sqrt(O);                                                    // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 547, 547, 2148]], "test": "untested"}
{"id": "ctsBzN", "name": "Day 1342", "author": "jeyko", "description": "bayer tato", "tags": ["mdtmjvm"], "likes": 22, "viewed": 396, "published": 3, "date": "1692706783", "time_retrieved": "2024-07-30T17:37:33.221961", "image_code": "void mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 uvn = (U - 0.5*R.xy)/min(R.x,R.y);\n    C = vec4(0);\n    \n    C = Ta(uv);\n    //C += Ta(uv - 0.2*sin(iTime)*clamp(fwidth(C.x),0.,0.01)*0.4).y*0.8;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nfloat sdBox(vec2 p, vec2 sz){\n    p = abs(p) - sz;\n    return max(p.x,p.y);\n}\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 uvn = (U - 0.5*R.xy)/min(R.x,R.y);\n    C = vec4(0);\n    int F = iFrame % 120;\n    seed += uint(iFrame/120)*1000u;\n    if(F == 0){\n        C = Ta(uv);\n        C.w = 1.0;\n    } else{\n        if(F == 1){\n            uv += step(valueNoise( uv*rot(5.5+ hash_f()*20.)*vec2(0.01,5.) ),0.5)*0.4;\n            C = Tb(uv); \n            if(sdBox(mod(uvn*rot(0.) - hash_v2()*1. - 0.5,4.), vec2(0.7,5.)) < 0.){\n                C.w = 15.;\n                C += 11.5;\n            }  \n        } else if (F == 2){\n            uv -= smoothstep(valueNoise( uv*rot(5.5 + hash_f()*20.)*vec2(0.01,5.) ),0.1,0.104)*0.4;\n            C = Tb(uv)*vec4(0.5,1.5,1,1.) - Ta(uv*14.).yyyy; \n            \n            if(length(fwidth(uv)) > 0.5){\n                C = vec4(1);\n            }\n        } else if (F == 3){\n            uv -= smoothstep(valueNoise( uv*rot(5.5+ hash_f()*20. + 3.14/2.)*vec2(0.01,5.) + 5. * hash_f() ),0.1,0.104)*0.4;\n            C = Tb(uv)*vec4(1,1,1,1.); \n            C = Tb(uv + 0.1 * float(C.w > 0.9))*vec4(1,1,1,1.); \n            \n            if(length(fwidth(uv)) > 0.42){\n                C = vec4(1);\n            }\n        } else {\n            C = Tb(uv);\n            \n            if(hash_f() > 0.5 || true){\n                C = Ta(uv*1.);\n                uv -= vec2(dFdx(C.y),dFdy(C.x))*0.41 * mix(0.,2.5,hash_f());\n                vec2 muv = (iMouse.xy - 0.5*R.xy)/min(R.x,R.y);\n                if (iMouse.z > 0.)\n                    uv += 0.1*normalize(muv - uvn) * smoothstep(0.1,0.,length(muv-uvn));\n                //C.xy += -15.*vec2(dFdx(C.y),dFdy(C.x))*0.41 * mix(7.,.5,hash_f());\n                //uv -= vec2(1)*rot(hash_f()*20.)*step(valueNoise( uv*rot(5.5+ hash_f()*20.)*vec2(0.01,5.) ),0.5)*0.001;\n                \n                C = Tb(uv);\n            }\n        }\n    }\n    \n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nuint seed = 11425u;\n\nuint hash_u(uint _a) {\n   uint a = _a;\n   a ^= a >> 16;\n   a *= 0x7feb352du;\n   a ^= a >> 15;\n   a *= 0x846ca68bu;\n   a ^= a >> 16;\n   return a; \n }\nfloat hash_f(){ uint s = hash_u(seed); seed = s;return ( float( s ) / float( 0xffffffffu ) ); }\nvec2 hash_v2(){ return vec2(hash_f(), hash_f()); }\nvec3 hash_v3(){ return vec3(hash_f(), hash_f(), hash_f()); }\nvec4 hash_v4(){ return vec4(hash_f(), hash_f(), hash_f(), hash_f()); }\n\nfloat hash_f_s(uint s){ s = hash_u(s); return ( float( s ) / float( 0xffffffffu ) ); }\n// vec2 hash_22_s(uvec2 s){ uint _s = hash_u(s.x) + hash_u(s.y); return vec2(hash_f_s(_s.x), hash_f_s(_s.y)); }\nfloat hash_21_s(ivec2 _s_){ \n  uvec2 s = uvec2(_s_);\n  uint _s = hash_u(s.x + hash_u(s.y)) + hash_u(s.y + hash_u(s.x)); \n  return hash_f_s(_s); \n}\n// vec3 hash_23_s(){ return vec3(hash_f_s(), hash_f_s(), hash_f_s()); }\n// vec4 hash_24_s(){ return vec4(hash_f_s(), hash_f_s(), hash_f_s(), hash_f_s()); }\n\n\nfloat valueNoise( in vec2 p ){\n    p += 100.;\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash_21_s( i + ivec2(0,0) ), \n                     hash_21_s( i + ivec2(1,0) ), u.x),\n                mix( hash_21_s( i + ivec2(0,1) ), \n                     hash_21_s( i + ivec2(1,1) ), u.x), u.y);\n}", "buffer_b_code": "void mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 uvn = (U - 0.5*R.xy)/min(R.x,R.y);\n    C = vec4(0);\n\n  const float bayer[] = float[64](\n     0./63., 32./63., 8./63., 40./63., 2./63., 34./63., 10./63., 42./63., /* 8x8 Bayer ordered dithering */\n    48./63., 16./63., 56./63., 24./63., 50./63., 18./63., 58./63., 26./63., /* pattern. Each input pixel */\n    12./63., 44./63., 4./63., 36./63., 14./63., 46./63., 6./63., 38./63., /* is scaled to the 0..63 range */\n    60./63., 28./63., 52./63., 20./63., 62./63., 30./63., 54./63., 22./63., /* before looking in this table */\n     3./63., 35./63., 11./63., 43./63., 1./63., 33./63., 9./63., 41./63., /* to determine the action. */\n    51./63., 19./63., 59./63., 27./63., 49./63., 17./63., 57./63., 25./63.,\n    15./63., 47./63., 7./63., 39./63., 13./63., 45./63., 5./63., 37./63.,\n    63./63., 31./63., 55./63., 23./63., 61./63., 29./63., 53./63., 21./63.\n  );    \n    \n    C = Ta(uv);\n    C = C + texture(iChannel0,uv,2. + mod(iTime*float(sin(iTime*5.)>0.),2.))*0.1;\n    vec4 oC = C;\n\t//vec2 fuv = floor((uv + 5.)/ sc) * sc;\n\t//vec2 buv = mod(fuv/sc, 8.);\n    \n    float luma = dot(C.xyz,C.xyz);\n    \n    seed = uint(iFrame/60);\n\n    vec2 bay_mult = vec2(1.0);\n    if(luma  < 0.02){\n        bay_mult *= 2.;\n    } else if(luma > 0.02){\n        bay_mult.y *= 1. + 1114442. * fwidth(oC.w);\n        if(fwidth(oC.x) > 0.07){\n            bay_mult *= 4.;\n        }\n    }\n    \n    \n\tvec2 buv = mod(floor(U.xy/bay_mult), 8.);\n    \n\tfloat bay = bayer[int(buv.x) + int(buv.y)*8];\n    if(C.w > 0.8){\n        if(luma > bay){\n            C = vec4(1);\n        } else {\n            C = vec4(0);\n        }\n    } else {\n        if(luma > 0.02){\n            C = vec4(1);\n        } else {\n            C = vec4(0);\n        }\n    }\n    C = 1.-C;\n    C.x += dFdx(oC.w)*1.;\n    for(int i = 0; i < 4; i++){\n        seed = uint(iFrame/60 + i);\n        if(hash_f() > 0.5)\n            C[i] += fwidth(oC.x * valueNoise( uvn*1. + 4.))*(14.)*hash_f();\n    }\n    \n    C = clamp(C,0.,1.);\n    \n    if(C.x < 0.1){\n        C += 0.1;\n    }\n    C -= 0.05 * valueNoise( uvn*400.) + 0.02;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsBzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 219]], "test": "untested"}
{"id": "mtlfR4", "name": "Shiny Diamond", "author": "alphardex", "description": "A shiny diamond, use mouse for orbit controls.\nMainly based on this tutorial: https://www.youtube.com/watch?v=0RWaR7zApEo&ab_channel=TheArtofCode", "tags": ["raymarching"], "likes": 3, "viewed": 160, "published": 3, "date": "1692696832", "time_retrieved": "2024-07-30T17:37:34.094627", "image_code": "#define IS_IN_SHADERTOY 1\n#if IS_IN_SHADERTOY==1\n#define iChannel0Cube iChannel0\n#endif\n\nconst float PI=3.14159265359;\n\nconst float TWO_PI=6.28318530718;\n\nmat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nmat4 rotation3d(vec3 axis,float angle){\n    axis=normalize(axis);\n    float s=sin(angle);\n    float c=cos(angle);\n    float oc=1.-c;\n    \n    return mat4(\n        oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.,\n        oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,0.,\n        oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,0.,\n        0.,0.,0.,1.\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nvec3 rotate(vec3 v,vec3 axis,float angle){\n    return(rotation3d(axis,angle)*vec4(v,1.)).xyz;\n}\n\n// Credit: https://www.shadertoy.com/view/ltfXDM\nfloat sdDiamond(in vec3 p){\n    vec3 normalTopA=normalize(vec3(0.,1.,1.4));\n    vec3 normalTopB=normalize(vec3(0.,1.,1.));\n    vec3 normalTopC=normalize(vec3(0.,1.,.5));\n    vec3 normalBottomA=normalize(vec3(0.,-1.,1.));\n    vec3 normalBottomB=normalize(vec3(0.,-1.,1.6));\n    float topCut=p.y-1.;\n    // float angleStep=PI/(iMouse.z<.5?8.:2.+floor(18.*iMouse.x/iResolution.x));\n    float angleStep=PI/20.;\n    float angle=angleStep*(.5+floor(atan(p.x,p.z)/angleStep));\n    vec3 q=rotate(p,vec3(0.,1.,0),angle);\n    float topA=dot(q,normalTopA)-2.;\n    float topC=dot(q,normalTopC)-1.5;\n    float bottomA=dot(q,normalBottomA)-1.7;\n    q=rotate(p,vec3(0.,1.,0),-angleStep*.5);\n    angle=angleStep*floor(atan(q.x,q.z)/angleStep);\n    q=rotate(p,vec3(0.,1.,0),angle);\n    float topB=dot(q,normalTopB)-1.85;\n    float bottomB=dot(q,normalBottomB)-1.9;\n    \n    return max(topCut,max(topA,max(topB,max(topC,max(bottomA,bottomB)))));\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nfloat opIntersection(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\nfloat opSubtraction(float d1,float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opSmoothUnion(float d1,float d2,float k){\n    float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)-k*h*(1.-h);\n}\n\nfloat opSmoothSubtraction(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2+d1)/k,0.,1.);\n    return mix(d2,-d1,h)+k*h*(1.-h);\n}\n\nfloat opSmoothIntersection(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2-d1)/k,0.,1.);\n    return mix(d2,d1,h)+k*h*(1.-h);\n}\n\nconst float gamma=2.2;\n\nfloat toGamma(float v){\n    return pow(v,1./gamma);\n}\n\nvec2 toGamma(vec2 v){\n    return pow(v,vec2(1./gamma));\n}\n\nvec3 toGamma(vec3 v){\n    return pow(v,vec3(1./gamma));\n}\n\nvec4 toGamma(vec4 v){\n    return vec4(toGamma(v.rgb),v.a);\n}\n\nmat3 setCamera(in vec3 ro,in vec3 ta,float cr)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr),cos(cr),0.);\n    vec3 cu=normalize(cross(cw,cp));\n    vec3 cv=(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nvec3 getRayDirection(vec2 p,vec3 ro,vec3 ta,float fl){\n    mat3 ca=setCamera(ro,ta,0.);\n    vec3 rd=ca*normalize(vec3(p,fl));\n    return rd;\n}\n\nvec2 map(vec3 p){\n    vec2 d=vec2(1e10,0.);\n    \n    float d1=sdDiamond(p);\n    d=opUnion(d,vec2(d1,3.));\n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h=.0001;\n    const vec2 k=vec2(1,-1);\n    return normalize(k.xyy*map(p+k.xyy*h).x+\n    k.yyx*map(p+k.yyx*h).x+\n    k.yxy*map(p+k.yxy*h).x+\n    k.xxx*map(p+k.xxx*h).x);\n}\n\nfloat softshadow(in vec3 ro,in vec3 rd,float mint,float maxt,float k)\n{\n    float res=1.;\n    float t=mint;\n    for(int i=0;i<256&&t<maxt;i++)\n    {\n        float h=map(ro+rd*t).x;\n        if(h<.001)\n        return 0.;\n        res=min(res,k*h/t);\n        t+=h;\n    }\n    return res;\n}\n\nvec2 raycast(vec3 ro,vec3 rd,float side){\n    vec2 result=vec2(-1.,-1.);\n    float depth=0.;\n    for(int i=0;i<128;i++){\n        vec3 p=ro+rd*depth;\n        // float d=map(p);\n        vec2 res=map(p)*side;\n        float d=res.x;\n        float m=res.y;\n        \n        depth+=d;\n        if(d<.01){\n            result=vec2(depth,m);\n            break;\n        }\n    }\n    return result;\n}\n\nvec3 getRdOut(vec3 rdIn,vec3 norExit,float ior){\n    vec3 rdOut=refract(rdIn,norExit,ior);\n    if(dot(rdOut,rdOut)==0.){\n        rdOut=reflect(rdIn,norExit);\n    }\n    return rdOut;\n}\n\nvec3 RGBShift(samplerCube tex,vec3 rUv,vec3 gUv,vec3 bUv){\n    float r=texture(tex,rUv).r;\n    float g=texture(tex,gUv).g;\n    float b=texture(tex,bUv).b;\n    return vec3(r,g,b);\n}\n\nfloat fresnel(float bias,float scale,float power,vec3 I,vec3 N)\n{\n    return bias+scale*pow(1.-dot(I,N),power);\n}\n\nvec3 lighting(in vec3 col,in vec3 pos,in vec3 rd,in vec3 nor,in float t){\n    vec3 lin=col;\n    \n    // refraction\n    {\n        float ior=1.49;\n        float ca=.01;\n        vec3 reflTex=vec3(0.);\n        \n        // do refraction\n        vec3 rdIn=refract(rd,nor,1./ior);// ray direction when entering\n        vec3 pEnter=pos-nor*.001*t*3.;\n        float dIn=raycast(pEnter,rdIn,-1.).x;// inside the object\n        \n        vec3 pExit=pEnter+rdIn*dIn;// 3d position of exit\n        vec3 norExit=-calcNormal(pExit);\n        \n        // vec3 rdOut=getRdOut(rdIn,norExit,ior);\n        // reflTex=texture(iChannel0Cube,rdOut).xyz;\n        \n        // chromatic aberration\n        vec3 rUv=getRdOut(rdIn,norExit,ior-ca);\n        vec3 gUv=getRdOut(rdIn,norExit,ior);\n        vec3 bUv=getRdOut(rdIn,norExit,ior+ca);\n        vec3 rgbTex=RGBShift(iChannel0Cube,rUv,gUv,bUv);\n        reflTex=rgbTex;\n        \n        // color\n        // vec3 gemColor=vec3(1.,.05,.2);\n        // reflTex*=gemColor;\n        \n        // optical Density\n        float dens=.1;\n        float optDist=exp(-dIn*dens);\n        reflTex*=optDist;\n        \n        // fresnel\n        float fre=fresnel(0.,1.,5.,-rd,nor);\n        // reflTex=vec3(fre);\n        vec3 reflOutside=texture(iChannel0Cube,reflect(rd,nor)).xyz;\n        reflTex=mix(reflTex,reflOutside,fre);\n        \n        lin=reflTex;\n    }\n    \n    return lin;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=(uv-.5)*2.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(0.,4.,8.);\n    vec3 ta=vec3(0.,0.,0.);\n    const float fl=3.;\n    \n    vec2 mouse=iMouse.xy/iResolution.xy;\n    ro.yz=rotate(ro.yz,-mouse.y*PI+1.);\n    ro.xz=rotate(ro.xz,-mouse.x*TWO_PI);\n    \n    vec3 rd=getRayDirection(uv,ro,ta,fl);\n    \n    vec3 col=vec3(0.);\n    \n    vec2 res=raycast(ro,rd,1.);\n    float d=res.x;\n    float m=res.y;\n    if(m>-.5){\n        vec3 p=ro+rd*d;\n        \n        // col=vec3(1.);\n        col=vec3(0.);\n        vec3 normal=(m<1.5)?vec3(0.,1.,0.):calcNormal(p);\n        \n        // vec3 objectColor=vec3(1.);\n        // vec3 lightColor=vec3(.875,.286,.333);\n        \n        // // ambient\n        // float ambIntensity=.2;\n        // vec3 ambient=lightColor*ambIntensity;\n        // col+=ambient*objectColor;\n        \n        // // diffuse\n        // vec3 lightPos=vec3(10.,10.,10.);\n        // vec3 lightDir=normalize(lightPos-p);\n        // float diff=dot(normal,lightDir);\n        // diff=max(diff,0.);\n        // vec3 diffuse=lightColor*diff;\n        // float shadow=softshadow(p,lightDir,.01,10.,16.);\n        // col+=diffuse*objectColor*shadow;\n        \n        // // specular\n        // vec3 reflectDir=reflect(-lightDir,normal);\n        // vec3 viewDir=normalize(ro-p);\n        // vec3 halfVec=normalize(lightDir+viewDir);\n        // float spec=dot(normal,halfVec);\n        // spec=max(spec,0.);\n        // float shininess=32.;\n        // spec=pow(spec,shininess);\n        // vec3 specular=lightColor*spec;\n        // col+=specular*objectColor;\n        \n        col=lighting(col,p,rd,normal,d);\n    }\n    \n    col=toGamma(col);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=2.;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 184, 184, 289], [291, 291, 330, 330, 723], [725, 725, 757, 757, 791], [793, 793, 835, 835, 888], [890, 939, 966, 966, 1868], [1870, 1870, 1904, 1904, 1929], [1931, 1931, 1962, 1962, 1993], [1995, 1995, 2036, 2036, 2061], [2063, 2063, 2103, 2103, 2129], [2131, 2131, 2178, 2178, 2258], [2260, 2260, 2313, 2313, 2394], [2396, 2396, 2450, 2450, 2530], [2556, 2556, 2579, 2579, 2609], [2611, 2611, 2632, 2632, 2668], [2670, 2670, 2691, 2691, 2727], [2729, 2729, 2750, 2750, 2789], [2791, 2791, 2839, 2839, 3001], [3003, 3003, 3057, 3057, 3145], [3147, 3147, 3164, 3164, 3273], [3275, 3275, 3303, 3303, 3489], [3491, 3491, 3562, 3562, 3775], [3777, 3777, 3818, 3818, 4164], [4166, 4166, 4214, 4214, 4349], [4351, 4351, 4409, 4409, 4531], [4533, 4533, 4598, 4598, 4646], [4648, 4648, 4721, 4721, 6037], [6039, 6039, 6074, 6074, 7781], [7783, 7783, 7836, 7836, 8161]], "test": "untested"}
{"id": "mlBcz3", "name": "Fluid sim mk3", "author": "thepinkpanzer", "description": "An improved version of my fluid simulation, this time featuring linear interpolants.", "tags": ["simulation", "fluid", "physics"], "likes": 6, "viewed": 212, "published": 3, "date": "1692679855", "time_retrieved": "2024-07-30T17:37:35.175737", "image_code": "#define T(p) texture(iChannel0,(p))\n#define B(p) texture(iChannel1,(p))\n\nvec4 jet(float x) // from 0 to 1\n{\n    return pow(vec4(x*x*(1.-x)/0.148, pow(x*(1.-x)*4.,2.), x*(1.-x)*(1.-x)/0.148, 0), vec4(1.6));\n}\nvec4 twilight(float x) // from -1 to 1\n{\n    float s  = sign(x);\n    x *= s;\n    \n    float r  = mix(1., (s > 0. ? x*x : x*x*x*x*x), 0.8);\n    float b  = mix(1., (s < 0. ? x*x : x*x*x*x*x), 0.8);\n    float g  = mix(1., x*x*x*x, 0.95);\n    return vec4(r, g, b, 0);\n}\n\nvec4 recolor(float x)\n{\n    x = tanh(x);\n    return jet(x);\n}\n\n#define ZOOM   1.0\n#define CENTER vec2(0.5,0.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fract((fragCoord/iResolution.xy - 0.5)/ZOOM+CENTER);\n    vec4 Q   = T(uv);\n    vec4 q   = Q/Q.r;\n    \n    float ek = 0.5*(q.g*q.g+q.b*q.b);\n    float t  = q.a-ek;\n    float s  = (GAMMA-1.)*t*pow(Q.r, -GAMMA);\n    \n    // ek  is kinetic energy per unit mass\n    // t   is thermal energy per unit mass\n    // s   is related to the entropy\n    // Q.r is density\n    \n    // Colour scheme: vec4(tanh(ek/t*10.));//\n    //if (fragCoord.y/iResolution.y > 0.5)\n    //{\n        fragColor = tanh(normalize(recolor(pow(t/7., 0.6)))*pow(Q.r*2., 0.4));//tanh(vec4(Q.r));//recolor(q.b*2.);\n    //}\n    //else\n    //{\n    //    fragColor = recolor(t*Q.r*1.);\n    //}\n    //fragColor = twilight(tanh(q.b*20.));\n    // Draw obstacles in black\n    fragColor*= (1.-B(uv).r);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// here i will store the fundamental laws of the universe\n// DT:    Timestep\n// GAMMA: Adiabatic constant for the gas (1.67=monatomic, 1.4=diatomic, 1.33=polyatomic)\n#define DT      0.03\n#define GAMMA   1.67\n\n// Boundary conditions\n// 0: Loop\n#define X_BOUNDARY 0\n#define Y_BOUNDARY 0\n\n// Limiter type\n#define LIMITER    2\n\n/*\nThis simulation is based on Van Leer's Monotonic Upstream-centered \nScheme for Conservation Laws (MUSCL). Unlike Godunov's earlier scheme,\nwhich takes each cell to have a constant mass, momentum, and energy\ndensity (see https://www.shadertoy.com/view/NtGBDR), MUSCL uses a linear\napproximation within cells, which makes it second-order in space. This\nallows it to better capture fine detail, and results in much less blurring.\n\nUnfortunately, the naive approaches are very unstable (Godunov's Theorem\nproves that every scheme which attempts to be second-order everywhere is\nunstable - schemes must reduce to first-order to be stable around discont-\ninuities. The solution is to ensure monotonicity, hence the M of MUSCL.\nWhenever a gradient estimate would produce a new maximum or minimum, it is\ncorrected (\"limited\") to reachieve monotonicity. At true maxima and minima,\nthe gradient is set to zero. While it results in extra blurring \n(\"dissipation\"), it also makes the scheme second-order where possible and\nfirst-order at shocks, as required by Godunov's theorem.\n\nThe solver I am using is unfortunately not always stable, and so I have a \ncheck to remove NaN and extreme values. This should hopefully not happen \noften, so won't do much to the results.\n\nThe initial conditions here have a dense but very low-pressure cloud, \nimmersed in a high-pressure, low-density gas. This makes it susceptible\nto Rayleigh-Taylor instability, which results in the mushroom-like swirls.\n*/", "buffer_a_code": "#define T(p) texture(iChannel0, (mod(p, iResolution.xy)/iResolution.xy))\nvec4 LimitedDeriv(vec4 a, vec4 b, vec4 c, float v)\n{\n    vec4 dm = 2.*(b - a);\n    vec4 dc =    (c - a)/2.;\n    vec4 dp = 2.*(c - b);\n    \n    #if LIMITER == 0\n        vec4 maxgrad = mix(sign(dp)*min(abs(dp), abs(dm)), vec4(0.), 1.-step(vec4(0.), dp*dm));\n        vec4 limited = sign(maxgrad)*min(abs(dc), abs(maxgrad))*1.;\n    #elif LIMITER == 1\n        vec4 limited = 0.5*sign(dc)*(min(abs(dm), abs(dp)))*step(-dm*dp,vec4(0.));\n    #elif LIMITER == 2\n        vec4 limited = sign(dc)/(1./abs(dm) + 1./abs(dp))*step(-dm*dp,vec4(0.));\n    #endif\n    \n    return limited;\n}\nvec4 Prim(vec4 Q)\n{\n    float ek = (dot(Q.gb, Q.gb))/(2.*Q.r);\n    float T  = Q.a-ek;\n    float P  = T*(GAMMA-1.);\n    return vec4(Q.r, Q.gb/Q.r, P);\n}\nvec4 Cons(vec4 P)\n{\n    float ek = dot(P.gb, P.gb)*0.5*P.r;\n    float T  = P.a/(GAMMA-1.);\n    float U  = T + ek;\n    return vec4(P.r, P.gb*P.r, U);\n}\nvec4 ConsG(vec4 P, vec4 Pxy)\n{\n    float dek = dot(P.gb, Pxy.gb*P.r + 0.5*P.gb*Pxy.r);\n    float dT  = Pxy.a/(GAMMA-1.);\n    float dU  = dT + dek;\n    return vec4(Pxy.r, (Pxy.gb*P.r)+(P.gb*Pxy.r), dU);\n}\nvec4 Evolve(vec4 P, vec4 Px, vec4 Py, float u, float v)\n{\n    /* Euler equations:\n    Time derivative=          A d v e c t i o n           +           p h y s i c s \n        (density )   (d/dx(density )*u + d/dy(density )*v +     density   *(d/dx(u) + d/dy(v)))\n    d/dt(   u    ) = (d/dx(   u    )*u + d/dy(   u    )*v +   (1/density) *   d/dx(pressure)  )\n        (   v    )   (d/dx(   v    )*u + d/dy(   v    )*v +   (1/density) *   d/dy(pressure)  )\n        (pressure)   (d/dx(pressure)*u + d/dy(pressure)*v + GAMMA*pressure*(d/dx(u) + d/dy(v)))\n    */\n    float density  = P.r;\n    float pressure = P.a;\n    \n    vec4 dP = vec4(\n    Px.r*u + Py.r*v +    density    *(Px.g + Py.b),\n    Px.g*u + Py.g*v +  (1./density) *    Px.a,\n    Px.b*u + Py.b*v +  (1./density) *    Py.a,\n    Px.a*u + Py.a*v + GAMMA*pressure*(Px.g + Py.b));\n    \n    P -= 0.5*min(DT, 0.5*min(abs(P.r/dP.r), abs(P.a/dP.a)))*dP;\n    \n    return P;\n}\nfloat P(vec4 Q)\n{\n    float ek = (dot(Q.gb, Q.gb))/(2.*Q.r);\n    float T  = Q.a-ek;\n    float P  = T*(GAMMA-1.);\n    return P;\n}\nvec4 Flux(vec4 Q)\n{\n    float P = P(Q);\n    return vec4(Q.g, (Q.g*Q.g/Q.r + P), Q.g*Q.b/Q.r, Q.g/Q.r*(Q.a + P));\n}\n//*\nvec4 Flux(vec4 Pn0, vec4 Pnp)\n{\n    // Momenta inside here are rotated so the outwards-facing normal is along +x\n    // Have to rotate to and from outside of here.\n    \n    // Q0/|_Qp\n    \n    // Enthalpy on sides:\n    float H0 = GAMMA*Pn0.a/Pn0.r/(GAMMA-1.) + 0.5*(Pn0.g*Pn0.g + Pn0.b*Pn0.b);\n    float Hp = GAMMA*Pnp.a/Pnp.r/(GAMMA-1.) + 0.5*(Pnp.g*Pnp.g + Pnp.b*Pnp.b);\n    // Sqrt densities:\n    float s0 = sqrt(Pn0.r);\n    float sp = sqrt(Pnp.r);\n    // Roe averages:\n    float H  = (s0* H0   + sp* Hp  )/(s0 + sp);\n    float u  = (s0*Pn0.g + sp*Pnp.g)/(s0 + sp);\n    float v  = (s0*Pn0.b + sp*Pnp.b)/(s0 + sp);\n    \n    float ek = 0.5*(u*u+v*v);\n    float a  = sqrt((GAMMA-1.)*(H - ek));\n    \n    // Small CFL number approximation (no gradients)\n    mat4 L   = mat4(vec4(((GAMMA-1.)*ek+a*u)/(2.*a*a), ((1.-GAMMA)*ek+a*a)/(a*a), ((GAMMA-1.)*ek-a*u)/(2.*a*a),  v),\n                    vec4(((1.-GAMMA)*u -a  )/(2.*a*a), ((GAMMA-1.)*u     )/(a*a), ((1.-GAMMA)*u +a  )/(2.*a*a),  0),\n                    vec4(((1.-GAMMA)*v     )/(2.*a*a), ((GAMMA-1.)*v     )/(a*a), ((1.-GAMMA)*v     )/(2.*a*a), -1),\n                    vec4(((GAMMA-1.)       )/(2.*a*a), ((1.-GAMMA)       )/(a*a), ((GAMMA-1.)       )/(2.*a*a),  0.));\n    vec4 eigenvalues = vec4( u-a,  u ,  u+a ,  u);\n    mat4 R   = mat4(vec4(1., u-a, v, H-a*u),\n                    vec4(1., u  , v, ek   ),\n                    vec4(1., u+a, v, H+a*u),\n                    vec4(0., 0., -1., 0.));\n    \n    vec4 w0 = L*Cons(Pn0);\n    vec4 wp = L*Cons(Pnp);\n    \n    vec4 flux = -0.5*R*(eigenvalues*(wp+w0) + abs(eigenvalues)*(wp-w0));\n    return flux;\n}\n//*/\n/*\nvec4 Flux(vec4 Pn0, vec4 Pnp)\n{\n    vec4 Qn0  = Cons(Pn0);\n    vec4 Qnp  = Cons(Pnp);\n    // Momenta inside here are rotated so the outwards-facing normal is along +x\n    // Have to rotate to and from outside of here.\n    float z   = (GAMMA-1.)/(2.*GAMMA);\n    \n    float ek0 = (dot(Qn0.gb, Qn0.gb))/(2.*Qn0.r);\n    float T0  = Qn0.a-ek0;\n    float P0  = T0*(GAMMA-1.);\n    float a0  = sqrt(GAMMA*P0/Qn0.r);\n    float u0  = Qn0.g/Qn0.r;\n    \n    float ekp = (dot(Qnp.gb, Qnp.gb))/(2.*Qnp.r);\n    float Tp  = Qnp.a-ekp;\n    float Pp  = Tp*(GAMMA-1.);\n    float ap  = sqrt(GAMMA*Pp/Qnp.r);\n    float up  = Qnp.g/Qnp.r;\n    \n    float Pstar = pow((a0 + ap - (GAMMA-1.)*0.5*(up-u0))/(a0/pow(P0, z)+ap/pow(Pp, z)), 1./z);\n    float q0    = Pstar > P0 ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Pstar/P0-1.)) : 1.;\n    float qp    = Pstar > Pp ? sqrt(1. + (GAMMA+1.)/(2.*GAMMA)*(Pstar/Pp-1.)) : 1.;\n    \n    // Wave speeds\n    float S0    = u0 - q0*a0;\n    float Sp    = up + qp*ap;\n    float Sstar = (Pp - P0 + Qn0.r*u0*(S0-u0) - Qnp.r*up*(Sp-up))\n                 /(Qn0.r*(S0-u0) - Qnp.r*(Sp-up));\n    \n    float k0    = Qn0.r*(S0-u0)/(S0-Sstar);\n    vec4  Qn1   = k0*vec4(1, Sstar, Qn0.b/Qn0.r, Qn0.a/Qn0.r + (Sstar-u0)*(Sstar + P0/(Qn0.r*(S0-u0))));\n    \n    float kp    = Qnp.r*(Sp-up)/(Sp-Sstar);\n    vec4  Qn2   = kp*vec4(1, Sstar, Qnp.b/Qnp.r, Qnp.a/Qnp.r + (Sstar-up)*(Sstar + Pp/(Qnp.r*(Sp-up))));\n    \n    vec4  QL    = Cons(Pn0);\n    vec4  QR    = Cons(Pnp);\n    \n    // Fluxes\n    vec4 flux;\n    if (Sstar > 0.)\n    {\n        flux = Flux(QL);\n        if (S0 < 0.)\n        {\n            flux += S0*(Qn1 - QL);\n        }\n    }\n    else\n    {\n        flux = Flux(QR);\n        if (Sp > 0.)\n        {\n            flux += Sp*(Qn2 - QR);\n        }\n    }\n    return flux;\n    \n}//*/\n\nvoid mainImage( out vec4 Q1, in vec2 c )\n{\n    /* \n    Need a 13-cell stencil:\n    Cells:\n    p/m = plus one/minus one. d/s = plus two/minus two (double and subtract)\n    Edges:\n    L/R = plus 0.5/minus 0.5, starting from the given cell\n\n    We need to:\n    1) estimate gradients for current cell and neighbours\n    2) limit said gradients\n    3) calculate edge states\n    4) boost edge states by half timestep\n    5) get fluxes\n    easy.\n    */\n    \n    // Stencil!\n    // These are our cell and its neighbours\n    vec4 Q00 = T(c            );\n    vec4 Qp0 = T(c+vec2( 1, 0));\n    vec4 Qm0 = T(c+vec2(-1, 0));\n    vec4 Q0p = T(c+vec2( 0, 1));\n    vec4 Q0m = T(c+vec2( 0,-1));\n    // These are only needed for gradients and limiting\n    vec4 Qd0 = T(c+vec2( 2, 0));\n    vec4 Qs0 = T(c+vec2(-2, 0));\n    vec4 Q0d = T(c+vec2( 0, 2));\n    vec4 Q0s = T(c+vec2( 0,-2));\n    vec4 Qpp = T(c+vec2( 1, 1));\n    vec4 Qmp = T(c+vec2(-1, 1));\n    vec4 Qpm = T(c+vec2( 1,-1));\n    vec4 Qmm = T(c+vec2(-1,-1));\n    \n    // Primitive variables!\n    vec4 P00 = Prim(Q00);\n    vec4 Pp0 = Prim(Qp0);\n    vec4 Pm0 = Prim(Qm0);\n    vec4 P0p = Prim(Q0p);\n    vec4 P0m = Prim(Q0m);\n    vec4 Pd0 = Prim(Qd0);\n    vec4 Ps0 = Prim(Qs0);\n    vec4 P0d = Prim(Q0d);\n    vec4 P0s = Prim(Q0s);\n    vec4 Ppp = Prim(Qpp);\n    vec4 Pmp = Prim(Qmp);\n    vec4 Ppm = Prim(Qpm);\n    vec4 Pmm = Prim(Qmm);\n    \n    // Gradients! (Only five in each direc)\n    // x direc\n    vec4 Px00 = LimitedDeriv(Pm0, P00, Pp0, P00.g);\n    vec4 Pxp0 = LimitedDeriv(P00, Pp0, Pd0, Pp0.g);\n    vec4 Pxm0 = LimitedDeriv(Ps0, Pm0, P00, Pm0.g);\n    vec4 Px0p = LimitedDeriv(Pmp, P0p, Ppp, P0p.g);\n    vec4 Px0m = LimitedDeriv(Pmm, P0m, Ppm, P0m.g);\n    // y direc\n    vec4 Py00 = LimitedDeriv(P0m, P00, P0p, P00.b);\n    vec4 Pyp0 = LimitedDeriv(Ppm, Pp0, Ppp, Pp0.b);\n    vec4 Pym0 = LimitedDeriv(Pmm, Pm0, Pmp, Pm0.b);\n    vec4 Py0p = LimitedDeriv(P00, P0p, P0d, P0p.b);\n    vec4 Py0m = LimitedDeriv(P0s, P0m, P00, P0m.b);\n    // We need some extra gradients beyond the ones needed for \n    // the edge states to get second order accuracy in time\n        \n    // Edge states! (We need eight)\n    // in x:\n    vec4 PL000 = (P00 - 0.5*Px00);\n    vec4 PR000 = (P00 + 0.5*Px00);\n    vec4 PL0p0 = (Pp0 - 0.5*Pxp0);\n    //vec4 PR0p0 = (Pp0 + 0.5*Pxp0);\n    //vec4 PL0m0 = (Pm0 - 0.5*Pxm0);\n    vec4 PR0m0 = (Pm0 + 0.5*Pxm0);\n    //vec4 PL00p = (P0p - 0.5*Px0p);\n    //vec4 PR00p = (P0p + 0.5*Px0p);\n    //vec4 PL00m = (P0m - 0.5*Px0m);\n    //vec4 PR00m = (P0m + 0.5*Px0m);\n    // in y:\n    vec4 P0L00 = (P00 - 0.5*Py00);\n    vec4 P0R00 = (P00 + 0.5*Py00);\n    vec4 P0L0p = (P0p - 0.5*Py0p);\n    //vec4 P0R0p = (P0p + 0.5*Py0p);\n    //vec4 P0L0m = (P0m - 0.5*Py0m);\n    vec4 P0R0m = (P0m + 0.5*Py0m);\n    //vec4 P0Lp0 = (Pp0 - 0.5*Pyp0);\n    //vec4 P0Rp0 = (Pp0 + 0.5*Pyp0);\n    //vec4 P0Lm0 = (Pm0 - 0.5*Pym0);\n    //vec4 P0Rm0 = (Pm0 + 0.5*Pym0);\n    \n    // Recalculate gradients with new limited edge states\n    // x direc\n    //Px00 = (PR000 - PL000);\n    //Pxp0 = (PR0p0 - PL0p0);\n    //Pxm0 = (PR0m0 - PL0m0);\n    //Px0p = (PR00p - PL00p);\n    //Px0m = (PR00m - PL00m);\n    // y direc\n    //Py00 = (P0R00 - P0L00);\n    //Pyp0 = (P0Rp0 - P0Lp0);\n    //Pym0 = (P0Rm0 - P0Lm0);\n    //Py0p = (P0R0p - P0L0p);\n    //Py0m = (P0R0m - P0L0m);\n    \n    \n    // Estimate speeds at useful edges (only four)\n    float uL0 = (sqrt(PL000.r)*PL000.g + sqrt(PR0m0.r)*PR0m0.g)/(sqrt(PL000.r) + sqrt(PR0m0.r));\n    float uR0 = (sqrt(PR000.r)*PR000.g + sqrt(PL0p0.r)*PL0p0.g)/(sqrt(PR000.r) + sqrt(PL0p0.r));\n    float v0L = (sqrt(P0L00.r)*P0L00.b + sqrt(P0R0m.r)*P0R0m.b)/(sqrt(P0L00.r) + sqrt(P0R0m.r));\n    float v0R = (sqrt(P0R00.r)*P0R00.b + sqrt(P0L0p.r)*P0L0p.b)/(sqrt(P0R00.r) + sqrt(P0L0p.r));\n    \n    // Evolve edge states by a half-timestep (only eight)\n    PL000 = Evolve(PL000, Px00, Py00, uL0, PL000.b);\n    PR000 = Evolve(PR000, Px00, Py00, uR0, PR000.b);\n    PL0p0 = Evolve(PL0p0, Pxp0, Pyp0, uR0, PL0p0.b);\n    PR0m0 = Evolve(PR0m0, Pxm0, Pym0, uL0, PR0m0.b);\n    \n    P0L00 = Evolve(P0L00, Px00, Py00, P0L00.g, v0L);\n    P0R00 = Evolve(P0R00, Px00, Py00, P0R00.g, v0R);\n    P0L0p = Evolve(P0L0p, Px0p, Py0p, P0L0p.g, v0R);\n    P0R0m = Evolve(P0R0m, Px0m, Py0m, P0R0m.g, v0L);\n    \n    /*\n    // Convert back to conserved quantities at edges (eight again)\n    vec4 QL000 = Cons(PL000);\n    vec4 QR000 = Cons(PR000);\n    vec4 QL0p0 = Cons(PL0p0);\n    vec4 QR0m0 = Cons(PR0m0);\n    \n    vec4 Q0L00 = Cons(P0L00);\n    vec4 Q0R00 = Cons(P0R00);\n    vec4 Q0L0p = Cons(P0L0p);\n    vec4 Q0R0m = Cons(P0R0m);\n    \n    vec4 QxL   = ConsG(PL000, Px00);\n    vec4 QxR   = ConsG(PR000, Px00);\n    vec4 QyL   = ConsG(P0L00, Py00);\n    vec4 QyR   = ConsG(P0R00, Py00);\n    \n    vec4 QxpL  = ConsG(PL0p0, Pxp0);\n    vec4 QxmR  = ConsG(PR0m0, Pxm0);\n    vec4 QypL  = ConsG(P0L0p, Py0p);\n    vec4 QymR  = ConsG(P0R0m, Py0m);\n    */\n\n    // Writing the new state of the system\n    Q1  =  Q00;\n    \n    // Calculate fluxes (at long last!) (only four!)\n    Q1 -= DT*(Flux(PR000, PL0p0) + Flux(P0R00.xzyw, P0L0p.xzyw).xzyw\n            - Flux(PR0m0, PL000) - Flux(P0R0m.xzyw, P0L00.xzyw).xzyw);\n    \n    if (Q1 != Q1 || Q1.r < 0.01 || Q1.a < (dot(Q1.gb, Q1.gb)/(2.*Q1.r)) || Q1.r > 100. || Q1.a > 100.)\n    {\n        Q1 = vec4(1,0,0,10);\n        //Q1.ra = max(Q1.ra, vec2(0.01,0.05*Q1.r+dot(Q1.gb,Q1.gb)/(2.*Q1.r)));\n    }\n    //Q1 = Cons(P00);\n    // Initial conditions\n    if (iFrame == 0)\n    {\n        \n        if (length((c-iResolution.xy/2. + 2.*sin(c.yx+sin(c+20.*cos(c.yx))))*vec2(0.6,1./0.6)) > iResolution.y/3.)\n        {\n            Q1 = vec4(1,0,0,10);\n        }\n        else\n        {\n            Q1 = vec4(10,0,0,0.1);\n        }\n        /*\n        if (cos(6.*3.14159265*(c.y+5.*sin(3.14159*c.x/iResolution.x*10.))/iResolution.y) > 0.)\n        {\n            Q1 = vec4(1, 3.0,0,10);\n        }\n        else\n        {\n            Q1 = vec4(1,-3.0,0,10);\n        }*/\n    }\n    //Q1 = vec4(Px00.a)*100.;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 107, 107, 207], [208, 208, 248, 248, 473], [475, 475, 498, 498, 536], [586, 586, 643, 643, 1416]], "test": "untested"}
{"id": "DlffzN", "name": "Disintegrating block", "author": "misol101", "description": "2d automata history with variations.\n\nCONTROLS: up/down=prev/next CA, 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  t=text\n", "tags": ["3d", "interactive", "voxel", "automata"], "likes": 9, "viewed": 203, "published": 3, "date": "1692658979", "time_retrieved": "2024-07-30T17:37:36.165093", "image_code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// Press UP/DOWN for variants.\n\n// More keys: 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  t=text\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nint row;\nbool invert;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v) \n{\n    p+=5.; // 0 == -5\n\n    int NM=int(N)-1;\n    float cv = cellval(ivec3(p));\n\n    if(colmethod == 1) {\n        v=(3.-cv)*0.17; // col by state value\n    } else\n        v=length(p-N/2.)*0.020+1.5; // col by distance\n\n    return !invert ? cv > 1. : int(cv) == 1;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 32.; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-120.+(max(0.,1.-iResolution.y/450.))*70., xrot=-0.55;\n    if (view == 1) { yp=-105.+(max(0.,1.-iResolution.y/450.))*70., xrot=-0.0; zmod+=180.; }\n    if (view == 2) yp=0., xrot=-1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, yp, -d+zmod);\n\n    float mxc, myc;\n\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.33))*1.17;\n        myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./2.8));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    colmethod = 1-int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n    bbox = int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n    row = min(int(texelFetch(iChannel1, ivec2(5,0), 0 ).x),int(N)-2);\n    int show2d = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n\n    invert=false;\n\n    if (show2d == 1 && fragCoord.y < N && fragCoord.x > iResolution.x - N) {\n        fragColor=texelFetch(iChannel2, ivec2(iResolution.x - fragCoord.x, fragCoord.y),0)*100.;\n        return;\n    }\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N/12.) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*0.7, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n\n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    //fragColor *= vec4(1.,1.,0.46,1.);\n    \n    fragColor += text_pixel;    \n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_M     = 77;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); discard; }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=1.001;\n                    if (kx > LAST_PATT+0.5) kx=0.5;\n                } else {\n                    kx-=1.001;\n                    if (kx < 0.) kx=LAST_PATT+0.5;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = -1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        float row = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_SPACE) )\n            row = 0.;\n        fragColor = vec4(row+1.001,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 3.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Automata buffer, pixel packed with 4 bits per state and max 8 digits per component for 6*4=24 cells per pixel \n\nint N;\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\nconst int KEY_D  = 68;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellwrap( in ivec3 p, int xp,int yp, int zp) {\n    int x=p.x+xp, y=p.y+yp, z=p.z+zp;\n    if (x==0) x=N-2;  if (x==N-1) x=1;\n    if (y==0) y=N-2;  if (y==N-1) y=1;\n    if (z==0) z=N-2;  if (z==N-1) z=1;\n    int n=x+y*N+z*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val;\n}\n\n\nint aut2dval( in ivec3 p) {\n    ivec2 p2 = ivec2(p.x,p.y);\n    \n    int val = int(texelFetch(iChannel2, p2, 0 ).x*10.+0.);\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./2.8));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N/12) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 1+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int row = int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    if (row < (N/12)-2+speed) speed=0;\n    row = min(row,N/12-2);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || int(xres) != int(iResolution.x) || row==1;\n\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/6;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) {\n            fst[fi] = fst[fi]<<4;\n            continue;\n        }\n\n        if (regen) {\n            fst[fi] = (fst[fi] << 4);\n            continue;\n        }\n\n        int st;\n        if (zi==row) {\n            st=aut2dval(pos3d);\n        }\n        else {\n            st = cellval(pos3d,0,0,1);\n        }\n\n        fst[fi] = (fst[fi] << 4) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 240.\n\nconst int CPP = 24; // Cells Per Pixel (only 6,12,18,24 will work)\n\n//#define HORIZON\n\nconst float LAST_PATT = 32.01;\nfloat density=50.;\nfloat liveval = 0.1;\nint stayset, bornset;\nfloat plot=0.;\nint clearmethod;\n\nvoid setRules(int index) {\n    int v1, v2;\n    plot=0.;\n    clearmethod=-1;\n\n    if (index == 0) {v1 = 203, v2=162; density=98.; plot=8.;}   // \"Diamonds\"\n    if (index == 1) {v1 = 116, v2=48; density=90.; clearmethod=3;}   // Going spiky black\n    if (index == 2) {v1 = 138, v2=225; density=90.;}  // Chaos,dark\n    if (index == 3) {v1 = 134, v2=98; density=90.; plot=8.;}   // Rectangles II\n    if (index == 4) {v1 = 64, v2=88; density=98.; clearmethod=3;}    // Flashy diamonds\n    if (index == 5) {v1 = 140, v2=225; density=100.;}  // Critters and diagonal lines \n    if (index == 6) {v1 = 136, v2=225; density=100.;}  // Weed \n    if (index == 7) {v1 = 149, v2=196; density=100.;}  // Critters\n    if (index == 8) {v1 = 128, v2=60; density=90.; clearmethod=3;}    // Mosquito \n    if (index == 9) {v1 = 208, v2=33; density=80.;}    // \"Worms\"\n    if (index == 10) {v1 = 130, v2=52; density=90.;}    // Slowly building \"dotted lines\"\n    if (index == 11) {v1 = 147, v2=225; density=94.; clearmethod=3;}  // Growing \"pipes\"\n    if (index == 12) {v1 = 80, v2=97; density=100.;}    // Black and white flashy\n    if (index == 13) {v1 = 200, v2=97; density=100.;}  // \"Worms + cross\"\n    if (index == 14) {v1 = 167, v2=73; density=100.; clearmethod=3;}  // Mini moving dots\n    if (index == 15) {v1 = 141, v2=72; density=98.; plot=8.; clearmethod=3;}   // Rectangles go fuzzy\n    if (index == 16) {v1 = 206, v2=161; density=90.; clearmethod=3;}  // Crosses and noise\n    if (index == 17) {v1 = 203, v2=196; density=70.;clearmethod=3;}  // Dying critters\n    if (index == 18) {v1 = 170, v2=145; density=100.;} // Dots and \"bursts\"\n    if (index == 19) {v1 = 128, v2=98; density=90.; plot=8.;}    // Rectangles\n    if (index == 20) {v1 = 164, v2=225; density=100.;} // Straight,weird \"lines\"\n    if (index == 21) {v1 = 229, v2=33; density=70.;}   // White vs black\n    if (index == 22) {v1 = 128, v2=57; density=90.;}   // Mosquito II\n    if (index == 23) {v1 = 140, v2=225; density=90.;}  // Chaos, less dark\n    if (index == 24) {v1 = 145, v2=225; density=90.;}  // Rounded short lines\n    if (index == 25) {v1 = 153, v2=225; density=100.;} // Slow, straight lines\n    if (index == 26) {v1 = 153, v2=225; density=90.;}  // Squiggly, dense lines\n    if (index == 27) {v1 = 172, v2=97; density=90.;}   // Plant war\n    if (index == 28) {v1 = 85, v2=176; density=90.; clearmethod=3;}   // Going spiky black II + flashy\n    if (index == 29) {v1 = 122, v2=8; density=96.; clearmethod=3;}    // Stable bg\n    if (index == 30) {v1 = 146, v2=72; density=100.; clearmethod=3;}  // Diagonal dying lines\n    if (index == 31) {v1 = 206, v2=160; density=97.; clearmethod=3;}  // Stable cracks\n    if (index == 32) {v1 = 207, v2=129; density=100.;clearmethod=3;} // Stable cracks II\n\n    stayset=v1, bornset=v2;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_c_code": " // Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nint N;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    if (p.y < 0) p.y = N-1;\n    if (p.x < 0) p.x = N-1;\n    if (p.y >= N) p.y = 0;\n    if (p.x >= N) p.x = 0;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 3)\n        return randpix(fragCoord);\n\n    vec2 mid = vec2(N,N) / 2.; \n    float w=25., h=25., radius=25.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 0) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./2.8));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    if (int(fragCoord.y) > N) discard;\n    if (int(fragCoord.x) > N) { fragColor = vec4(0.); return; }\n\n    float ix = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int method = int(texelFetch(iChannel3, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel3, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel3, ivec2(9,0), 0 ).x);\n    \n    setRules(int(ix));\n    if(clearmethod>=0) method=clearmethod;\n    \n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_RIGHT) || readKey(KEY_LEFT) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)\n     || readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor =  vec4(restart(fragCoord, method), 0.,0.,0.);\n        return;\n    }\n\n    ivec2 px = ivec2( fragCoord );\n\n    if (iFrame % (speed+1) > 0 || pause==1) {\n        fragColor = vec4( cellval(px), 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int ev = int(cellval(px)*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if ((stayset & (1<<(k-1))) > 0 ) f=k;\n    }\n    else {\n        f = (bornset & (1<<(k-1))) > 0 ? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    for (float i=0.; i<plot; i++) {\n        int sz = int(2.5 + hash1(iTime + i) * 1.5);\n        if (f==k && abs(int(hash1(iTime+i*0.1)*iResolution.x) - int(fragCoord.x)) < sz && abs(int(hash1(iTime + i*0.1 + 0.287)*iResolution.y) - int(fragCoord.y)) < sz)\n            ff = 0.;\n    }\n\n\tfragColor = vec4( ff, 0.0, 0.0, 0.0 );\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlffzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 365, 365, 610], [613, 668, 744, 744, 787], [789, 789, 818, 818, 1168], [1170, 1170, 1205, 1205, 1469], [1471, 1471, 1581, 1581, 1898], [1900, 1900, 1949, 1949, 2060], [2062, 2062, 2179, 2179, 2881], [2883, 2883, 2971, 2971, 3550], [3552, 3552, 3647, 3647, 3786], [3788, 3788, 3864, 3864, 4998], [5001, 5001, 5026, 5026, 5213], [5215, 5215, 5371, 5371, 6231], [6233, 6233, 6260, 6260, 6327], [6329, 6329, 6386, 6386, 8713]], "test": "untested"}
{"id": "ctffzN", "name": "3D Particle Sim", "author": "SnoopethDuckDuck", "description": "messy code", "tags": ["particles", "fun", "buffer"], "likes": 37, "viewed": 390, "published": 3, "date": "1692652686", "time_retrieved": "2024-07-30T17:37:36.982905", "image_code": "void mainImage( out vec4 O, in vec2 px )\n{\n    O = texelFetch(iChannel0, ivec2(px), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define res iResolution.xy\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define ballRadius .03\n\n\n// Hash from BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(vec2 a) {\n    int x = FK(a.x), y = FK(a.y);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\n// Capsule SDF from iq\nfloat seg( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat map0(vec3 p, float t) {\n    p.xy *= rot(.2*t);\n    float d1 = length(p.xz) - 1.3 + .3 * thc(4., .5*t);\n    float d = length(vec2(d1, p.y)) - .15 + .05 * thc(4., .25*t);\n    \n    return d;\n}", "buffer_a_code": "vec3 norm(vec3 p) {\n\tfloat d = map0(p, iTime);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map0(p-e.xyy, iTime),\n        map0(p-e.yxy, iTime),\n        map0(p-e.yyx, iTime));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    if (iFrame < 1) {\n        // Position\n        if (px.y == .5)     \n            O.xyz = 3. * vec3(hash(px), hash(px+.1), hash(px+.2));\n            \n        // Velocity\n        else if (px.y == 1.5)\n            O.xyz = vec3(0);\n    }\n    else {        \n        vec3 p = texelFetch(iChannel0, ivec2(px.x, .5), 0).xyz;\n        vec3 v = texelFetch(iChannel0, ivec2(px.x, 1.5), 0).xyz;\n        vec3 n = norm(p);\n        \n        if (px.y == .5) {\n            // Move ball\n            p += v;\n            \n            // Clamp to sphere\n            float l = length(p);\n            if (l > 5.)\n                p *= 5. / l;\n            \n            O.xyz = p;\n        } \n        else if (px.y == 1.5) {\n            // Push away from surface if touching\n            if (map0(p, iTime) - ballRadius < 0.)\n                v = .06 * n;      \n            else {\n                v -= .04 * n;\n                v.xy += .002 * vec2(-n.y, n.x);\n                v.yz += .002 * vec2(-n.z, n.y);\n                v *= .99;\n            }\n            O.xyz = v;\n        }\n        else if(px.y == 2.5) { \n            // Store previous position\n            O.xyz = p;\n        }\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define EPS .001\n\nvec3 ro;\nvec3 rd;\n\n#define numPoints 16\nvec3 points[numPoints];\nvec3 pointsPrev[numPoints];\n\nvoid setOri() {\n    vec2 m = iMouse.xy / res;\n    ro = vec3(0, 2.5, -4);\n   // ro.yz *= rot(-m.y*pi+1.);\n   // ro.xz *= rot(-m.x*2.*pi);\n}\n\nvoid setDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = f*z,\n         i = c + uv.x*r + uv.y*u;\n    rd = normalize(i);\n}\n\nvec2 map(vec3 p) {\n    float mat;\n    float d = map0(p, iTime);\n    \n    float d2 = 1e5;\n    for (int i = 0; i < numPoints; i++) \n        d2 = min(d2, seg(p, points[i], pointsPrev[i], ballRadius));\n    \n    d2 < d ? d = d2, mat = 1.\n           : d;\n           \n    return vec2(d, mat);\n}\n\nvec3 march(vec3 ro, vec3 rd, float z) {\t\n    float d = 0.;\n    float s = sign(z);\n    int steps = 0;\n    float mat = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * d;\n        vec2 m = map(p);\n        m.x *= .9 + .2 * hash(vec2(p.y, hash(p.xz)));\n        if (s != sign(m.x)) { z *= 0.5; s = sign(m.x); }\n        if (abs(m.x) < EPS || d > MAX_DIST) {\n            steps = i + 1;\n            mat = m.y;\n            break;\n        }\n        d += m.x * z; \n    }   \n    return vec3(min(d, MAX_DIST), steps, mat);\n}\n\nvec3 norm(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 O, in vec2 px )\n{\n    vec2 uv = (px - 0.5 * res) / res.y;\n\t\n    setOri();\n    setDir(uv, ro, vec3(0), 1.);\n    \n    vec3 col = vec3(0);\n\n    for (int i = 0; i < numPoints; i++) {\n        points[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n        pointsPrev[i] = texelFetch(iChannel0, ivec2(i, 2), 0).xyz;\n    }  \n    \n    vec3 m = march(ro, rd, 1.);  \n    float d = m.x;    \n    vec3 p = ro + rd * d;\n\n    if (d<MAX_DIST) {        \n        vec3 n = norm(p);\n        vec3 r = reflect(rd, n);        \n        float fres = pow(1. + dot(rd, n),  2.);     \n        col = vec3(m.z);\n    }\n    \n    col = max(col, vec3(1.-1./cosh(.05*m.y)));\n    col = sqrt(col);\n    \n    O = .94 * texelFetch(iChannel1, ivec2(px), 0);\n    O = max(O, vec4(col,1));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctffzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 89]], "test": "untested"}
{"id": "DlfBzN", "name": "Square Fourier Transform?", "author": "beans_please", "description": "What if we used square waves instead of (co)sine waves in Fourier transforms?\nSee sqsin() and sqcos() at the end of Common.\n\n- Enable fft_preview_input in the Common tab to see the input shapes.\n\n- You can also change the resolution in the Common tab.", "tags": ["2d", "fft", "experiment", "square", "fourier"], "likes": 5, "viewed": 152, "published": 3, "date": "1692651978", "time_retrieved": "2024-07-30T17:37:37.923391", "image_code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: None\n  iChannel0: Buffer A\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.5));\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Render\n    vec3 col = vec3(0.0);\n    if (max(abs(uv.x), abs(uv.y)) < 1.0)\n    {\n        col = texture(iChannel0, vec2(uv * 0.5 + 0.5) * vec2(fft_res) / iResolution.xy).rgb;\n        \n        vec3 tint = rgb_sweep(iTime * 0.14) + 0.03;\n        tint /= dot(tint, vec3(0.3, 0.59, 0.12));\n        col *= tint;\n    }\n    else\n    {\n        col = vec3(0);\n        //col = vec3(0.005, 0.01, 0.02);\n    }\n    \n    // Output\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\nconst ivec2 fft_res = ivec2(150);\nconst bool fft_preview_input = bool(0);\nconst float fft_mul = 50.0 / float(fft_res.x * fft_res.y);\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n/* Pseudo-Random Number Generator */\n#define PRNG 0\n\n/* Color Utils (requires MATH_UTILS) */\n#define COLOR_UTILS 1\n\n/* Keyboard Utils */\n#define KEYBOARD_UTILS 0\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\n#if PRNG\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Color Utils (requires MATH_UTILS)\n// -----------------------------------------------\n\n#if COLOR_UTILS\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), map_range_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), map_range_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), map_range_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), map_range_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), map_range_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), map_range_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#if KEYBOARD_UTILS\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// Just linear mapping\nfloat not_so_smoothstep(float e0, float e1, float x)\n{\n    return clamp((x - e0) / (e1 - e0), 0.0, 1.0);\n}\n\n// 1D slit function\nfloat slit(float x, float center, float half_width, float fade_width)\n{\n    return not_so_smoothstep(-half_width - fade_width, -half_width, x - center)\n        * not_so_smoothstep(half_width + fade_width, half_width, x - center);\n}\n\n// Regular polygon\n// Source: https://www.shadertoy.com/view/tdsXz8\nfloat sd_npoly(float n, float radius, float rotation, vec2 p)\n{\n    n *= .5;\n    float o = PI_OVER_2 / n;\n    float a = atan(p.y / p.x);\n    if(p.x < 0.)\n        a += PI;\n    float s = round((a + rotation) / PI * n) / n * PI - rotation;\n    float d = round((a + o + rotation) / PI * n) / n * PI - o - rotation;\n    vec2 c = vec2(cos(d), sin(d)) * radius;\n    vec2 f = vec2(cos(s), sin(s));\n    float b = length(p - c);\n    float l = dot(p, f);\n    l -= cos(o) * radius;\n    float m = b;\n    if(abs(dot(vec2(p.x, -p.y), f.yx)) <= sin(o) * radius)\n        m = l;\n    return m;\n}\n\nfloat sqsin(float x)\n{\n    return mod(x / TAU, 1.) < .5 ? 1. : -1.;\n}\n\nfloat sqcos(float x)\n{\n    return mod((x / TAU) + .25, 1.) < .5 ? 1. : -1.;\n}\n", "buffer_a_code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: FFT is performed in this buffer.\n  iChannel0: None\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nfloat shape0_radius;\nfloat shape1_slit1_half_width;\nfloat shape1_slit2_center;\nfloat shape1_slit2_fade;\nfloat shape1_cutout_radius;\n\nfloat fft_input(vec2 uv)\n{\n    int shape = int(floor(0.34 * iTime)) % 3;\n    if (shape == 0)\n    {\n        // Circle\n        return not_so_smoothstep(shape0_radius, shape0_radius - 0.02, distance(uv, vec2(0.5, 0.5)));\n    }\n    else if (shape == 1)\n    {\n        // Double slit\n        float v = slit(uv.x, 0.44, shape1_slit1_half_width, 0.004);\n        v += slit(uv.x, shape1_slit2_center, 0.02, shape1_slit2_fade);\n        v *= slit(uv.y, 0.5, 0.25, 0.004);\n        float d = distance(uv, vec2(0.5, 0.5));\n        v *= not_so_smoothstep(shape1_cutout_radius, shape1_cutout_radius - 0.01, d);\n        v *= not_so_smoothstep(0.3, 0.01, d) * 0.5 + 0.5;\n        return v;\n    }\n    else if (shape == 2)\n    {\n        // Pentagon\n        return not_so_smoothstep(0.01, 0.0, sd_npoly(5.0, 0.15, iTime * 0.25, uv - 0.5));\n    }\n    return 0.0;\n}\n\n// How much of this frequency is present in fft_input?\nvec2 freq_amount(ivec2 freq)\n{\n    const vec2 uv00 = 0.5 / vec2(fft_res);\n    const vec2 uv_step = 1.0 / vec2(fft_res);\n    vec2 f2 = vec2(freq) * TAU;\n    vec2 v = vec2(0.0);\n    float a = 0.0;\n    for (float y = uv00.y; y < 1.0; y += uv_step.y)\n    {\n        for (float x = uv00.x; x < 1.0; x += uv_step.x)\n        {\n            a = dot(vec2(x, y), f2);\n            v += fft_input(vec2(x, y)) * vec2(sqcos(a), sqsin(a));\n        }\n    }\n    return v * fft_mul;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // If iResolution is not large enough\n    if (int(floor(iResolution.x)) < fft_res.x || int(floor(iResolution.y)) < fft_res.y)\n    {\n        frag_col = vec4(1, 0, 1, 1);\n        return;\n    }\n    \n    // Integer coordinates & UV\n    ivec2 icoord = ivec2(floor(frag_coord));\n    vec2 uv = (vec2(icoord) + 0.5) / vec2(fft_res);\n    \n    // If outside the region of interest\n    if (icoord.x >= fft_res.x || icoord.y >= fft_res.y)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Init variables for fft_input\n    float t = TAU * iTime;\n    shape0_radius = 0.16 + 0.07 * cos(t * 0.2);\n    shape1_slit1_half_width = 0.02 + 0.007 * cos(t * 0.2286);\n    shape1_slit2_center = 0.56 + 0.01 * cos(t * 0.4);\n    shape1_slit2_fade = 0.005 + 0.004 * cos(t * 0.3772);\n    shape1_cutout_radius = 0.254 + 0.02 * cos(t * 0.1689);\n    \n    float v = 0.0;\n    if (fft_preview_input)\n    {\n        // Preview FFT input\n        v = fft_input(uv);\n    }\n    else\n    {\n        // What 2D frequency to check\n        ivec2 freq = icoord - (fft_res / 2);\n        \n        // How much of the frequency is present\n        v = length(freq_amount(freq));\n    }\n    \n    // Output\n    frag_col = vec4(v, v, v, 1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfBzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 254, 254, 335], [337, 337, 368, 385, 425], [427, 427, 482, 492, 1023]], "test": "untested"}
{"id": "DtXfz4", "name": "Simple Clouds - Jan", "author": "Jan300100", "description": "clouds", "tags": ["clouds"], "likes": 1, "viewed": 173, "published": 3, "date": "1692645291", "time_retrieved": "2024-07-30T17:37:38.684356", "image_code": "vec3 hash( uvec3 x )\n{  \n    //https://www.shadertoy.com/view/4lXyWN\n    \n    //multiply large prime value first.\n    uint k = 1103515245U;\n    x*= k;\n    //mix x, y, z values.\n    //Without shift operator, x, y and z value become same value.\n    x = ((x>>2u)^(x.yzx>>1u)^x.zxy)*k;\n \n    return (vec3(x)*(1.0/float(0xffffffffU)));\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvec3 noise(vec3 p)\n{\n    uvec3 fl = uvec3(floor(p));\n    vec3 fr = fract(p);\n    fr = smoothstep(0.0,1.0,fr);\n    vec3 tr = hash(fl + uvec3(0,0,0));\n    vec3 tl = hash(fl + uvec3(1,0,0));\n    vec3 br = hash(fl + uvec3(0,1,0));\n    vec3 bl = hash(fl + uvec3(1,1,0));\n    vec3 tr2 = hash(fl + uvec3(0,0,1));\n    vec3 tl2 = hash(fl + uvec3(1,0,1));\n    vec3 br2 = hash(fl + uvec3(0,1,1));\n    vec3 bl2 = hash(fl + uvec3(1,1,1));\n        \n    \n    vec3 res = mix(mix(mix(tr, tl, fr.x), mix(br, bl, fr.x), fr.y)\n            ,mix(mix(tr2,tl2,fr.x), mix(br2,bl2, fr.x), fr.y),fr.z);\n    \n    vec3 result = (1.0 + res)*0.5; //map to [0,1]\n\n    return res;\n}\n\nvec3 fbm(vec3 p)\n{\n    vec3 r;\n    float amp;\n    r  = 0.500 * noise(p); p = p*2.01;\n    r += 0.250 * noise(p); p = p*2.05;\n    r += 0.125 * noise(p); p = p*2.01;\n    r += 0.0625 * noise(p); p = p*2.01;\n    r += 0.03125 * noise(p); p = p*2.01;\n    r += 0.015625 * noise(p); p = p*2.01;\n    return r;\n}\n\nfloat getNoise(vec2 fragCoord)\n{\n    float t = iTime * 1.0f;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += vec2(5000,1000) + vec2(t, t/2.0f) * 0.02f;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 variationCoords = vec3((uv + vec2(1000)) * 10.0f, t * 0.1f);\n    vec3 noise = fbm(vec3(uv * 5.0,t * 0.1 + fbm(variationCoords).xxx)).xxx;\n    return noise.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // color\n    \n    float noise = getNoise(fragCoord);\n    vec3 sky = vec3(59, 156, 212) / 255.0f;\n    vec3 sun = vec3(255, 228, 212) / 255.0f;\n    \n    float cloudRemover = 0.5f;\n    float elevatedNoise = clamp((noise * 2.0f) - cloudRemover,0.0,1.0);\n    \n    vec3 col = sky * (vec3(1) - elevatedNoise) + elevatedNoise * sun;\n\n    // Output to screen\n    fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 113, 332], [460, 460, 480, 480, 1109], [1111, 1111, 1129, 1129, 1412], [1414, 1414, 1446, 1446, 1779], [1781, 1781, 1838, 1851, 2223]], "test": "untested"}
{"id": "mtjcRK", "name": "Persian Rug Box", "author": "misol101", "description": "2d automata history with variations. Not all of them look like rugs :)\n\nCONTROLS: left/right=prev/next CA, up/down=prev/next CA clear, 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  b=box, t=text\n", "tags": ["3d", "interactive", "voxel", "automata"], "likes": 8, "viewed": 180, "published": 3, "date": "1692644960", "time_retrieved": "2024-07-30T17:37:39.776436", "image_code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// Press LEFT/RIGHT for variants.\n\n// More keys: up/down=prev/next CA clear, 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  b=box, t=text\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nint row;\nbool invert;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v) \n{\n    p+=5.; // 0 == -5\n\n    int NM=int(N)-1;\n    if (bbox == 1) {\n        int x=int(p.x),y=int(p.y),z=int(p.z);\n        //if (z==NM-2 || (x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n        if ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n            v=-1.;\n            return true;\n        }\n    }\n\n    float cv = cellval(ivec3(p));\n\n    if(colmethod == 1) {\n        v=(3.-cv)*0.17; // col by state value\n    } else\n        v=length(p-N/2.)*0.1+1.5; // col by distance\n\n    return !invert ? cv > 1. : int(cv) == 1;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 32.; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-3., xrot=-0.69;\n    if (view == 1) yp=0., xrot=0.0;\n    if (view == 2) yp=0., xrot=1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, yp, -d+zmod);\n\n    float mxc, myc;\n\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.33))*1.17;\n        myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    colmethod = 1-int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n    bbox = int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n    row = min(int(texelFetch(iChannel1, ivec2(5,0), 0 ).x),int(N)-2);\n    int show2d = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n\n    invert=false;\n\n    if (show2d == 1 && fragCoord.y < N && fragCoord.x > iResolution.x - N) {\n        fragColor=texelFetch(iChannel2, ivec2(iResolution.x - fragCoord.x, fragCoord.y),0)*100.;\n        return;\n    }\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n\n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_M     = 77;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); discard; }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=1.001;\n                    if (kx > LAST_PATT+0.5) kx=0.5;\n                } else {\n                    kx-=1.001;\n                    if (kx < 0.) kx=LAST_PATT+0.5;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = -1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        float row = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_SPACE) )\n            row = 0.;\n        fragColor = vec4(row+1.001,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 3.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Automata buffer, pixel packed with 4 bits per state and max 8 digits per component for 6*4=24 cells per pixel \n\nint N;\n\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\nconst int KEY_D  = 68;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellwrap( in ivec3 p, int xp,int yp, int zp) {\n    int x=p.x+xp, y=p.y+yp, z=p.z+zp;\n    if (x==0) x=N-2;  if (x==N-1) x=1;\n    if (y==0) y=N-2;  if (y==N-1) y=1;\n    if (z==0) z=N-2;  if (z==N-1) z=1;\n    int n=x+y*N+z*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val == int(liveval) ? 1 : 0;\n}\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (6-1) - (n % 6);\n    int pi=(n%CPP)/6;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= 4*pos;\n    val = val & 0xf;\n    return val;\n}\n\n\nint aut2dval( in ivec3 p) {\n    ivec2 p2 = ivec2(p.x,p.y);\n    \n    int val = int(texelFetch(iChannel2, p2, 0 ).x*10.+0.);\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 1+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int row = int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    if (row < N-2+speed) speed=0;\n    row = min(row,N-2);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || int(xres) != int(iResolution.x) || row==1;\n\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/6;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) {\n            fst[fi] = fst[fi]<<4;\n            continue;\n        }\n\n        if (regen) {\n            fst[fi] = (fst[fi] << 4);\n            continue;\n        }\n\n        int st;\n        if (zi==row) {\n            st=aut2dval(pos3d);\n        }\n        else {\n            st = cellval(pos3d,0,0,1);\n        }\n\n        fst[fi] = (fst[fi] << 4) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 120.\n\nconst int CPP = 24; // Cells Per Pixel (only 6,12,18,24 will work)\n\n//#define HORIZON\n\nconst float LAST_PATT = 32.01;\nfloat density=50.;\nfloat liveval = 0.1;\nint stayset, bornset;\nfloat plot=0.;\n\nvoid setRules(int index) {\n    int v1, v2;\n    plot=0.;\n\n    if (index == 0) {v1 = 140, v2=225; density=100.;}  // Critters and diagonal lines \n    if (index == 1) {v1 = 134, v2=98; density=90.; plot=8.;}   // Rectangles II\n    if (index == 2) {v1 = 138, v2=225; density=90.;}  // Chaos,dark\n    if (index == 3) {v1 = 203, v2=162; density=98.; plot=8.;}   // \"Diamonds\"\n    if (index == 4) {v1 = 136, v2=225; density=100.;}  // Weed \n    if (index == 5) {v1 = 149, v2=196; density=100.;}  // Critters\n    if (index == 6) {v1 = 128, v2=60; density=90.;}    // Mosquito \n    if (index == 7) {v1 = 208, v2=33; density=80.;}    // \"Worms\"\n    if (index == 8) {v1 = 130, v2=52; density=90.;}    // Slowly building \"dotted lines\"\n    if (index == 9) {v1 = 147, v2=225; density=94.;}  // Growing \"pipes\"\n    if (index == 10) {v1 = 80, v2=97; density=100.;}    // Black and white flashy\n    if (index == 11) {v1 = 200, v2=97; density=100.;}  // \"Worms + cross\"\n    if (index == 12) {v1 = 167, v2=73; density=100.;}  // Mini moving dots\n    if (index == 13) {v1 = 141, v2=72; density=98.; plot=8.;}   // Rectangles go fuzzy\n    if (index == 14) {v1 = 206, v2=161; density=90.;}  // Crosses and noise\n    if (index == 15) {v1 = 203, v2=196; density=70.;}  // Dying critters\n    if (index == 16) {v1 = 170, v2=145; density=100.;} // Dots and \"bursts\"\n    if (index == 17) {v1 = 116, v2=48; density=90.;}   // Going spiky black\n    if (index == 18) {v1 = 128, v2=98; density=90.; plot=8.;}    // Rectangles\n    if (index == 19) {v1 = 164, v2=225; density=100.;} // Straight,weird \"lines\"\n    if (index == 20) {v1 = 229, v2=33; density=70.;}   // White vs black\n    if (index == 21) {v1 = 128, v2=57; density=90.;}   // Mosquito II\n    if (index == 22) {v1 = 140, v2=225; density=90.;}  // Chaos, less dark\n    if (index == 23) {v1 = 145, v2=225; density=90.;}  // Rounded short lines\n    if (index == 24) {v1 = 153, v2=225; density=100.;} // Slow, straight lines\n    if (index == 25) {v1 = 153, v2=225; density=90.;}  // Squiggly, dense lines\n    if (index == 26) {v1 = 172, v2=97; density=90.;}   // Plant war\n    if (index == 27) {v1 = 85, v2=176; density=90.;}   // Going spiky black II + flashy\n    if (index == 28) {v1 = 64, v2=88; density=98.;}    // Flashy diamonds\n    if (index == 29) {v1 = 122, v2=8; density=96.;}    // Stable bg\n    if (index == 30) {v1 = 146, v2=72; density=100.;}  // Diagonal dying lines\n    if (index == 31) {v1 = 206, v2=160; density=97.;}  // Stable cracks\n    if (index == 32) {v1 = 207, v2=129; density=100.;} // Stable cracks II\n\n    stayset=v1, bornset=v2;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_c_code": " // Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nint N;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    if (p.y < 0) p.y = N-1;\n    if (p.x < 0) p.x = N-1;\n    if (p.y >= N) p.y = 0;\n    if (p.x >= N) p.x = 0;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 3)\n        return randpix(fragCoord);\n\n    vec2 mid = vec2(N,N) / 2.; \n    float w=25., h=25., radius=25.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 0) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    if (int(fragCoord.y) > N) discard;\n    if (int(fragCoord.x) > N) { fragColor = vec4(0.); return; }\n\n    float ix = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int method = int(texelFetch(iChannel3, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel3, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel3, ivec2(9,0), 0 ).x);\n    \n    setRules(int(ix));\n    \n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_RIGHT) || readKey(KEY_LEFT) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)\n     || readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor =  vec4(restart(fragCoord, method), 0.,0.,0.);\n        return;\n    }\n\n    ivec2 px = ivec2( fragCoord );\n\n    if (iFrame % (speed+1) > 0 || pause==1) {\n        fragColor = vec4( cellval(px), 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int ev = int(cellval(px)*10.+0.5);\n    int f = 0;\n    if (e==1) {\n        f = ev - 1;\n        if ((stayset & (1<<(k-1))) > 0 ) f=k;\n    }\n    else {\n        f = (bornset & (1<<(k-1))) > 0 ? k : 0;\n    }\n\n    float ff = float(f)/10.;\n\n    for (float i=0.; i<plot; i++) {\n        int sz = int(2.5 + hash1(iTime + i) * 1.5);\n        if (f==k && abs(int(hash1(iTime+i*0.1)*iResolution.x) - int(fragCoord.x)) < sz && abs(int(hash1(iTime + i*0.1 + 0.287)*iResolution.y) - int(fragCoord.y)) < sz)\n            ff = 0.;\n    }\n\n\tfragColor = vec4( ff, 0.0, 0.0, 0.0 );\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 403, 403, 648], [651, 706, 782, 782, 825], [827, 827, 856, 856, 1206], [1208, 1208, 1243, 1243, 2134], [2136, 2136, 2246, 2246, 2563], [2565, 2565, 2614, 2614, 2725], [2727, 2727, 2844, 2844, 3546], [3548, 3548, 3636, 3636, 4215], [4217, 4217, 4312, 4312, 4451], [4453, 4453, 4529, 4529, 5663], [5666, 5666, 5691, 5691, 5878], [5880, 5880, 6036, 6036, 6801], [6803, 6803, 6830, 6830, 6897], [6899, 6899, 6956, 6956, 9239]], "test": "untested"}
{"id": "dljyRt", "name": "Desert Dream Buzz Saw", "author": "misol101", "description": "Attempt at remaking this classic: https://www.youtube.com/watch?v=jziQBWQxvok&t=425s\n\nSeems hard to time sound with picture (delay varies), so it might be out of sync at times...\n\nFullscreen gives bigger impact :)", "tags": ["amiga", "kefrens", "reproduction", "buzzsaw", "buzzsaw", "desertdream"], "likes": 6, "viewed": 199, "published": 3, "date": "1692643273", "time_retrieved": "2024-07-30T17:37:40.644117", "image_code": "// Original rasterizer from https://www.shadertoy.com/view/MdS3Rz by HLorenzi\n\nconst float PI=3.14159265359;\n\nvec4 inTriangle(vec2 p0, vec2 p1, vec2 p2, vec2 p)\n{\n\tfloat a = 0.5*(-p1.y*p2.x + p0.y*(-p1.x + p2.x) + p0.x*(p1.y - p2.y) + p1.x*p2.y);\n\tfloat s = 1.0/(2.0*a)*(p0.y*p2.x - p0.x*p2.y + (p2.y - p0.y)*p.x + (p0.x - p2.x)*p.y);\n\tfloat t = 1.0/(2.0*a)*(p0.x*p1.y - p0.y*p1.x + (p0.y - p1.y)*p.x + (p1.x - p0.x)*p.y);\n\t\n\tif (s > 0.0 && t > 0.0 && 1.0 - s - t > 0.0) {\n\t\treturn vec4(1.0,s,t,1.0-s-t);\n\t} else {\n\t\treturn vec4(0.0,s,t,1.0-s-t);\n\t}\n}\n\nfloat rx=0., ry=PI*0.501, rz=0., dist=2.0;\nfloat xg=0., yg=0.;\n\nvoid triangle(inout vec4 c, vec2 p, int type, sampler2D tex, vec3 p0, vec3 p1, vec3 p2, vec2 t0, vec2 t1, vec2 t2)\n{\n\tfloat cx = cos(rx); float sx = sin(rx);\n\tfloat cy = cos(ry); float sy = sin(ry);\n\tfloat cz = cos(rz); float sz = sin(rz);\n    \n\tmat4 transform1 =\n\t\tmat4(1, 0, 0, 0,\n      \t\t 0, 1, 0, 0,\n      \t\t 0, 0, 1, 0,\n\t\t\t 0, 0, -2.5, 1);\n\t\n\tmat4 transform2 =\n\t\tmat4(cz*cy, -sz*cy, sy, 0,\n\t\t\t sz*cx + cz*sy*sx, cz*cx - sz*sy*sx, -cy*sx, 0,\n\t\t\t sz*sx - cz*sy*cx,cz*sx + sz*sy*cx, cy*cx, 0,\n\t\t\t 0, 0, 0, 1);\n\t\n\tfloat n = dist;\n\tfloat f = 30.0;\n\tfloat r = 1.0 * iResolution.x / iResolution.y;\n\tfloat t = 1.0;\n\tmat4 projection =\n\t\tmat4(n/r, 0, 0, 0,\n      \t\t 0, n/t, 0, 0,\n      \t\t 0, 0, -(f+n)/(f-n), -1,\n\t\t\t 0, 0, -(2.0*f*n)/(f-n), 0);\n\t\n\tvec4 pt0 = vec4(0,0,0,0);\n\tvec4 pt1 = vec4(0,0,0,0);\n\tvec4 pt2 = vec4(0,0,0,0);\n\t\n\tpt0 = projection * transform1 * transform2 * vec4(p0,1);\n\tpt1 = projection * transform1 * transform2 * vec4(p1,1);\n\tpt2 = projection * transform1 * transform2 * vec4(p2,1);\n\t\n    pt0.x += xg; pt0.y += yg;\n    pt1.x += xg; pt1.y += yg;\n    pt2.x += xg; pt2.y += yg;\n\t\n\tvec4 test = inTriangle(pt0.xy / pt0.w, pt1.xy / pt1.w, pt2.xy / pt2.w, p);\n\t\n\tif (test.x != 0.0) {\n\t\tfloat z = ((pt1.z * test.y) / pt1.w +\n\t\t\t\t   (pt2.z * test.z) / pt2.w +\n\t\t\t\t   (pt0.z * test.w) / pt0.w) /\n\t\t\t\t\t(test.y / pt1.w +\n\t\t\t\t\t test.z / pt2.w +\n\t\t\t\t\t test.w / pt0.w);\n\t\tif (z < c.w) {\n\t\t\tfloat tx = ((t1.x * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.x * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.x * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\t\t\t\n\t\t\tfloat ty = ((t1.y * test.y) / pt1.w +\n\t\t\t\t\t\t(t2.y * test.z) / pt2.w +\n\t\t\t\t\t\t(t0.y * test.w) / pt0.w) /\n\t\t\t\t\t   (test.y / pt1.w +\n\t\t\t\t\t\ttest.z / pt2.w +\n\t\t\t\t\t\ttest.w / pt0.w);\n\t\t\t\t\n\t\t\tc = vec4(texture(tex, vec2(tx,ty)).xyz, z);\n\t\t}\n\t}\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nvec4 pixel(vec2 p)\n{\t\n    float time = getTime(iTime);\n\n    float sz = 1.0, pz=0.01;\n    vec4 color = vec4(0,0,0,1000);\n\n    // Zooming and spinning\n    dist = 1.5 + cos(min(5.,max(time-5.3,0.))*1.2) * (0.5+min(5.0,max(0.,(time-9.2)*0.33)*2.)+min(3.0,max(0.,(time-9.7)*0.43)*8.));\n    \n    ry = sin(min(4.2,max(0.,time-5.5))*0.4 - PI*0.5) * (PI*0.501);\n    rz = sin(max(0.,time-5.5)*0.4 + PI*0.5) * (PI*0.501);\n    rz += sin(max(0.,time-11.0)*0.14) * (PI);\n\n    // Final move to the right\n    xg = max(time-15.0,0.) * 4.;\n\n    // Draw plane\n\ttriangle(color, p, 1, iChannel3, vec3(pz,-sz,-sz),  vec3(pz,-sz,sz), vec3(pz,sz,-sz),\n\t\t\t\t\t              vec2(0,0),\t   vec2(1,0),\t  vec2(0,1));\n\t\n\ttriangle(color, p, 1, iChannel3, vec3(pz,-sz,sz),   vec3(pz,sz,sz),  vec3(pz,sz,-sz),\n\t\t\t\t\t              vec2(1,0),\t   vec2(1,1),\t  vec2(0,1));\n\n    // Cutting!\n    if (time > 10.5 && time < 14.3 ) {\n        vec2 pf=p+0.3;\n        if (pf.y > sin(time*5.6) && pf.y < sin(time*12.))\n            color = color*0.7 + 1.65 * (texture(iChannel2, mod(p,0.05+sin(hash1(iTime*43.3)))+sin(hash1(iTime*43.3))));\n    }\n    if (time > 10.5 && time < 15.3 ) {\n        if (iFrame % 33 < 16) color=vec4(1.0)-color;\n        color = (color+0.15) * 0.65 * (texture(iChannel2, p+sin(hash1(iTime*43.3)))) + texture(iChannel1, (p+1.)*(1.3+sin(hash1(iTime*100.3))));\n        if (iFrame % 20 < 6) color*=(vec4(0.,0.8,0.43,1.));\n        if ((iFrame+23) % 96 < 7) color*=(vec4(0.3,0.0,0.05,1.));\n        if ((iFrame+60) % 200 > 130) color=1.-(color);\n        if ((iFrame+123) % 560 > 370 && time < 14.9) color*=(vec4(0.3,0.2,1.45,1.));\n    }\n    // End fade\n    else if (time >= 15.3) { color += vec4(vec3(max(0.,1.0-(time-15.3)*0.5)),1000); }\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - vec2(1.0,1.0);\n\tfragColor = pixel(uv);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Original star drawing function from https://www.shadertoy.com/view/dlSczt by kushnadas\n\n// Function to draw a buzz saw\nfloat saw(vec2 st, float time) {\n    st = st*1.2 - 0.6;\n    \n    // Convert to polar coordinates\n    float r = length(st);\n    float a = atan(st.y, st.x);\n\n    // Adjust angle for rotation over time\n    a += max(0.,(time-2.0)) * 3.0 * min(1.0,(max((time-2.0)*0.7,0.))*0.16);\n\n    // Create shape using modulo and scaling\n    float l = 3.14159/2.5/5.0;\n    float m = min(max(time-0.8,0.)*4.5,6.);\n    float sector = (l-mod(a, l)) * m / 3.14159;\n    r = smoothstep(0.9, 0.41, r * (2.0 - sector));\n\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float time = getTime(iTime);\n\n    fragColor = vec4(vec3(min(time*1.5,1.)) * ceil(saw(uv, time)), 1.0);\n}\n", "buffer_a_inputs": [], "sound_code": "// Don't know at all what I'm doing... Basically using https://www.shadertoy.com/view/XsBXWt by Kali\n\n// Help to make a saw sound closer to the original would be appreciated!\n\nvec2 mainSound( in int samp,float time) {\n    time = getTime(time + 0.5);\n\n\tvec2 ut = vec2( fract(sin(3.2831*940.0*time*2.)*100.));\n    if (time < 9.3) ut*=0.0;\n    else if (time < 10.9) ut*=(time-9.3)/(10.9-9.3)*0.3;\n    else if (time > 15.6) ut*=max(0.,16.6-time);\n    return ut;\n}", "sound_inputs": [], "common_code": "const bool BOUNCE_TIME = false;\n\nfloat getTime(float time) {\n    if (!BOUNCE_TIME)\n        time = mod(time, 18.);\n    else {\n        time = mod(time, 36.);\n        if (time >= 18.0) time = 36. - time;\n    }\n    return time;\n}\n", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 162, 162, 551], [617, 617, 733, 733, 2425], [2427, 2427, 2451, 2451, 2491], [2493, 2493, 2513, 2513, 4217], [4219, 4219, 4276, 4276, 4376]], "test": "untested"}
{"id": "dtlBRn", "name": "Closest Point to SDF", "author": "tristanantonsen", "description": "This shows a simple scene that demonstrates how to find the closest point to the surface of an SDF. The blue spheres are the \"search\" points and the red spheres are the closest points.\n\nNote the little dents in the SDF are just for visualization. :)\n\n", "tags": ["raymarching", "sdf"], "likes": 12, "viewed": 288, "published": 3, "date": "1692638484", "time_retrieved": "2024-07-30T17:37:41.735199", "image_code": "// Ray marching constants\n#define MAX_STEPS 250\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n// iquilezles.org/articles/distfunctions\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r) {\n    p = abs(p)-(s-r);\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU - PI);\n    //p = rotX(p, -m.y*PI - PI / 2.0);\n    return p;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 sdf(vec3 po) {\n\n    // rotation\n    vec3 p = rotX(po, 0.5*iTime);\n    p = rotY(p, 0.5*iTime);\n\n    // main\n    float s1 = sdEllipsoid(p, vec3(0., -0., 0.),vec3(0.9, 0.85, 0.9));\n    float b1 = sdRoundedBox(p, vec3(0.5), 0.05);\n\n    float d = mix(s1, b1, 0.5*sin(iTime)+0.5);\n    vec2 res = vec2(d, 1.0); // id to track color\n    return res;\n}\n\nvec3 gradientSDF(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = sdf(p + dx).x - sdf(p - dx).x;\n    float ddy = sdf(p + dy).x - sdf(p - dy).x;\n    float ddz = sdf(p + dz).x - sdf(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec2 map(vec3 po) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = orbitControls(po);\n    vec3 pSym = vec3(abs(p.x), p.y, p.z);\n    vec2 res;\n    res.y = 1.;\n\n    // main sdf (light blue)\n    // this is what the \"closest points\" are in reference to\n    res = sdf(p);\n    \n    // Creating some points orbiting semi-randomly around the sdf\n    float offset = 1.5; // search point distance from origin\n    \n    // Point 1\n    float x1 = offset * cos(2.*iTime);\n    float z1 = offset * sin(2.*iTime);\n    vec3 sP1 = vec3(x1, 1.*sin(iTime), z1);\n    // translation vector v = -d * n; d = sdf value @ point, n = gradient @ point\n    vec3 cP1 = -sdf(sP1).x * gradientSDF(sP1) + sP1; // this is the line that finds the closest points\n    float s1 = sdSphere(p, sP1, 0.075);\n    float c1 = sdSphere(p, cP1, 0.05);\n\n    // Point 2\n    float x2 = offset * sin(2.*iTime);\n    float z2 = offset * cos(2.*iTime);\n    vec3 sP2 = vec3(x2, 1.*cos(iTime), z2);\n    vec3 cP2 = -sdf(sP2).x * gradientSDF(sP2) + sP2;\n    float s2 = sdSphere(p, sP2, 0.075);\n    float c2 = sdSphere(p, cP2, 0.05);\n    \n    // Point 3\n    float x3 = offset * sin(2.*iTime+PI/2.);\n    float z3 = offset * sin(2.*iTime-PI/2.);\n    vec3 sP3 = vec3(x3, 1.*cos(iTime), z3);\n    vec3 cP3 = -sdf(sP3).x * gradientSDF(sP3) + sP3;\n    float s3 = sdSphere(p, sP3, 0.075);\n    float c3 = sdSphere(p, cP3, 0.05);\n    \n    // Connectors (red)\n    float rc = 0.005; // connector radius\n    float l1 = sdCapsule(p, sP1, cP1, rc);\n    float l2 = sdCapsule(p, sP2, cP2, rc);\n    float l3 = sdCapsule(p, sP3, cP3, rc);\n    \n    // final visualization/adding to the SDF\n    res.x = opSmoothSubtraction(res.x, c1, 0.05);\n    res.x = opSmoothSubtraction(res.x, c2, 0.05);\n    res.x = opSmoothSubtraction(res.x, c3, 0.05);\n\n    // creating a body consisting of the \"search point\" spheres\n    float searchPoints = s1;\n    searchPoints = opUnion(searchPoints, s2);\n    searchPoints = opUnion(searchPoints, s3);\n    \n    // creating a body consisting of the \"closest point\" spheres\n    float closestPoints = c1;\n    closestPoints = opUnion(closestPoints, c2);\n    closestPoints = opUnion(closestPoints, c3);\n    \n    float connectors = l1;\n    connectors = opSmoothUnion(connectors, l2, 0.01);\n    connectors = opSmoothUnion(connectors, l3, 0.01);\n    \n    // adding to the sdf & assigning colors\n    \n    if (searchPoints < res.x) res.y = 2.0;\n    res.x = opUnion(res.x, searchPoints);\n    if (closestPoints < res.x) res.y = 3.0;    \n    res.x = opUnion(res.x, closestPoints);\n    if (connectors < res.x) res.y = 4.0;    \n    res.x = opUnion(res.x, connectors);\n    \n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec2(d, mat);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., -0.05, -1.);\n    vec3 ro = vec3(0., -0.05, -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec2 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n        vec3 c1 = vec3(0.2,0.8,1.);\n        vec3 c2 = vec3(0.8,0.2,1.);\n        \n        vec3 color = c1;\n        \n        if (d.y == 1.) color.xyz = c1;        \n        if (d.y == 2.) color.xyz = vec3(0.2, 0.2, 0.9);        \n        if (d.y == 3.) color.xyz = vec3(1., 0., 0.);        \n        if (d.y == 4.) color.xyz = vec3(1., 0., 0.);        \n        \n        \n        \n        color *= illumination; \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n                \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45 + specular * 0.08;\n        \n        \n        fragColor = vec4(color, 1.0);\n        \n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 351, 393, 393, 429], [431, 431, 474, 474, 504], [506, 506, 552, 552, 661], [663, 663, 715, 715, 836], [838, 838, 883, 883, 972], [1123, 1123, 1159, 1159, 1180], [1182, 1182, 1223, 1283, 1310], [1311, 1311, 1353, 1353, 1379], [1381, 1381, 1431, 1431, 1530], [1531, 1531, 1587, 1587, 1687], [1688, 1688, 1744, 1744, 1843], [1989, 1989, 2017, 2017, 2167], [2169, 2169, 2197, 2197, 2347], [2349, 2349, 2378, 2378, 2547], [2707, 2707, 2726, 2743, 3054], [3056, 3056, 3082, 3082, 3416], [3418, 3418, 3437, 3450, 6077], [6079, 6079, 6112, 6112, 6425], [6427, 6427, 6450, 6450, 6784], [6786, 6786, 6831, 6858, 7459], [7462, 7462, 7519, 7569, 9126]], "test": "untested"}
{"id": "mtsfRH", "name": "Fork Neon Lines grid love", "author": "marvpaul", "description": "change from https://www.shadertoy.com/view/ls3Sz4\nPlaying around with this nice shader and got some inspiration from the last Paul Kalkbrenner concert", "tags": ["neon"], "likes": 4, "viewed": 185, "published": 3, "date": "1692632782", "time_retrieved": "2024-07-30T17:37:42.590911", "image_code": "//https://www.shadertoy.com/view/ls3Sz4\n//--------------------------------------------------------------------------------------------\nfloat hash(int x) { return fract(sin(float(x))*7.847); } \n\nfloat dSegment(vec2 a, vec2 b, vec2 c)\n{\n    vec2 ab = b-a;\n    vec2 ac = c-a;\n\n    float h = clamp(dot(ab, ac)/dot(ab, ab), 0., 1.);\n    vec2 point = a+ab*h;\n    return length(c-point);\n}\n\nvec3 drawLine(vec3 color, vec2 uv, float wave, int i){\n\tvec2 a = vec2(hash(i)*2.-1., hash(i+1)*2.-1.);\n \tvec2 b = vec2(hash(10*i+1)*2.-1., hash(11*i+2)*2.-1.);\n \tvec3 lineColor = vec3(hash(10+i), hash(18+i*3), hash(5+i*10));\n \tfloat speed = b.y*0.15;\n \tfloat size = wave + 4.0+(0.005 + 0.3*hash(5+i*i*2)) + (0.5+0.5*sin(a.y*5.+0.0*speed))*0.1;\n        \n    float offset = float(i)*0.5-2.-0.05*wave; \n    float dist = dSegment(vec2(offset, sin(iTime)-sin(wave)), vec2(offset, cos(iTime)+sin(wave)), uv);\n    offset = float(i)*0.3-0.9; \n    dist = i%2==0? (dSegment(vec2(sin(iTime)-sin(wave), offset), vec2(cos(iTime)+sin(wave), offset), uv)):dist;\n \tfloat soundWave = 1.5*wave;\n \tcolor += mix(lineColor, vec3(0.), smoothstep(0., 1.0, pow(dist/size, soundWave*(0.5+0.5)*0.20) ));\n\treturn color;\n}\n    \n#define N 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord.xy*2.-iResolution.xy) / iResolution.yy;\n    \n    vec3 color = vec3(0.);\n    \n    for(int i=0; i < N; ++i)    {\n        color = drawLine(color, uv, texture(iChannel0, vec2(float(i)/float(N), 0.0)).x, i);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 154, 154, 191], [194, 194, 234, 234, 382], [384, 384, 438, 438, 1178], [1196, 1196, 1252, 1252, 1520]], "test": "untested"}
{"id": "mtsfR8", "name": "volumetric trap #2: \"Ti*𝛙*To\"", "author": "FabriceNeyret2", "description": "Water and air are continuous volumetric material, but many are made of opaque particles ( pigments, foliage... ).\nTrap: transparency in and out are correlated for in-out angles less than the angular size of occluders.\nFor real, T_tot = conditional proba", "tags": ["volumetric", "tuto", "short", "hotspot"], "likes": 12, "viewed": 266, "published": 3, "date": "1692626339", "time_retrieved": "2024-07-30T17:37:43.396756", "image_code": "// === volumetric trap: incoming and outcoming transparencies = not-independant probabilities\n//     → hot spot effect. see https://www.google.com/search?q=hot+spot+BRDF&tbm=isch\n//       Or more precisely, opposition effect https://en.wikipedia.org/wiki/Opposition_surge\n//       E.g., visible on aerial views at antisolar locations, \n//             or in photos of forest/grass/sand/gravel at dusk/dawn in the antisolar direction.\n//       Not to be confused with Heiligenschein hotspot effect (droplet backscatter) https://en.wikipedia.org/wiki/Heiligenschein\n\n// see also    volumetric trap #1: \"density\":   https://shadertoy.com/view/mllBR8\n//             volumetric trap #3: dens vs occl https://www.shadertoy.com/view/clsfRN\n\n\n#define S(v,r)  smoothstep( 2./R.y, -2./R.y, length(v) - r )    // draw AA line\n#define C(r)    smoothstep( 6./R.y, 0., abs( length(C) - r ) )  // draw AA curve\n\nvec2 L(vec2 p, float a ) {                                      // distance vector to line (0,0) - (2cos(a),2sin(a))\n    vec2   b = 2.*sin( a +vec2(0,33));\n    return p - b * clamp(dot(p, b) / dot(b, b), 0., 1.); \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, A = R/R.y, F,I,\n          U = ( u+u - R ) / R.y,\n          C = U + vec2(.5*A.x, 1),                    // center of left referential\n          D = C; D.x = mod(U.x, A.x) - .5*A.x;        // center of left&right referentials ( for in/out rays )\n\n    float  i = 4., \n           r = .2/i,                                  // occluder radius\n           t = .8,                                    // medium transparency per unit length\n          ai = .6*sin(iTime),                         // incoming angle\n          ao = -.3;                                   // outgoing angle\n    \n    O = vec4( S( L( D, ao ) , .01 ) ,                 // red: outgoing ray\n              S( L( D, ai ) , .01 ) ,                 // green: incoming ray\n             0,0);\n    O += U.x < 0. && length(C) < 1.5                  // --- left: show configuration\n                ?  F = fract(U*i), I = floor(U*i),    // draw particles\n                   S( ( F -.8 + .6*fract(1e4*sin(I*mat2(R,71.-R)+i)) ) /i, .2/i )  \n                :  0. ; \n                \n    C.x -= R.x/R.y;                                   // --- right: show total transmittance\n    O.gb += C( pow(t,2.) );                           // cyan: assuming no correlation, Ttot = Tin*Tout = t²\n    i = abs( atan(C.x,C.y) - ao ) / r,                // in-out occluding correlation\n    O.rg += C( pow(t, 2. - exp(-.5 *i*i ) ));         // yellow: Ttot = P( light in ) * P ( light out | could in ).\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[898, 898, 924, 1014, 1113], [1115, 1115, 1153, 1153, 2625]], "test": "untested"}
{"id": "mllBR8", "name": "volumetric trap #1: \"density\"", "author": "FabriceNeyret2", "description": "Water and air are continuous volumetric material, but many are made of opaque particles ( pigments, foliage... ).\nTrap: the volume density or the mass density tell nothing about transparency: same volume split in smaller particles is more opaque.\n", "tags": ["volumetric", "2tweets", "tuto", "short"], "likes": 12, "viewed": 288, "published": 3, "date": "1692623389", "time_retrieved": "2024-07-30T17:37:44.155727", "image_code": "// === volumetric trap: even at constant amount, size matters. \n//     consider number density rather than volume density.\n\n// see also:   volumetric trap #2: \"Ti*𝛙*To\"    https://www.shadertoy.com/view/mtsfR8\n//             volumetric trap #3: dens vs occl https://www.shadertoy.com/view/clsfRN\n\n\n#define S(v,r) smoothstep( 2./R.y, -2./R.y, length(v) - r )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, F,I,\n          U = ( u+u - R ) / R.y;\n\n    float i = pow( 1.3, ceil((U.y+1.06)/.1) ); // partic radius = .1/i , total occluders volume = cst \n                                               // → number density ρ ~ i³ , partic cross section σ = πr² ~ 1/i²\n                                               // → T = exp( -σρL ) ~ exp( - i L )   \n                                               // ( proof: dI = -I*σρ → dI/I = -σρ → log(I)=-σρx → I = exp(-σρL)  )\n    O = vec4(sqrt(                                   // to sRGB\n              U.x < 0.                       \n                ?  F = fract(U*i), I = floor(U*i),   // --- left: draw particles ( 2D slice in 3D volume )\n                   S( ( F -.9 + .8*fract(1e4*sin(I*mat2(R,71.-R)+i)) ) /i, .1/i )  \n                : 1. - exp( -i/40. )                 // --- right: corresponding opacity\n            ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 400, 400, 1320]], "test": "untested"}
{"id": "DtlfzH", "name": "Combined SDF", "author": "lennon27", "description": "Combined the SDF of a square and a circle", "tags": ["shapes", "outline"], "likes": 3, "viewed": 145, "published": 3, "date": "1692620204", "time_retrieved": "2024-07-30T17:37:45.417354", "image_code": "float circleSDF(vec2 uv, float size) \n{\n    return length(uv) - size;\n}\n\nfloat squareSDF(vec2 uv, float size)\n{\n    return max(abs(uv.x), abs(uv.y)) - size;\n}\n\nmat2 rotationMatrix(float rotation)\n{\n    return mat2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Constants\n    float shapeSize = 0.5;\n    float circleSize = 0.5;\n    float rotationSpeed = 0.3;\n    float scalingSpeed = 2.0;\n    float scalingSize = 0.1;\n    float lineWidth = 4.0;\n    vec3 lineColor = vec3(1, 1, 0);\n    vec3 backgroundColor = vec3(0, 0, 0);\n\n    // UV (from center)\n    vec2 uv = vec2(2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec2 rotatedUV = uv * rotationMatrix(iTime * rotationSpeed);\n    float scaleModifier = sin(iTime * scalingSpeed) * scalingSize;\n    float circleSDF = circleSDF(rotatedUV, shapeSize - scaleModifier);\n    float squareSDF = squareSDF(rotatedUV, shapeSize + scaleModifier);\n    float combinedSDF = min(squareSDF, circleSDF);\n    float hollowSDF = smoothstep(lineWidth / iResolution.y, 0.0, abs(combinedSDF));\n    vec3 AAColor = mix(backgroundColor, lineColor, hollowSDF);\n    \n    fragColor = vec4(AAColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtlfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 71], [73, 73, 111, 111, 158], [160, 160, 197, 197, 299], [301, 301, 356, 373, 1238]], "test": "untested"}
{"id": "ctsBRH", "name": "Glow Lights", "author": "QuantumSuper", "description": "A 2.5D arrangement of lights & particles circling an invisible sphere.", "tags": ["sphere", "25d", "pseudorandom"], "likes": 4, "viewed": 252, "published": 3, "date": "1692612904", "time_retrieved": "2024-07-30T17:37:46.588223", "image_code": "// Glow Lights 0.4.230821 by QuantumSuper\n// 2.5d arrangement of lights & particles circling an invisible sphere\n\n#define PI 3.14159265359\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\nfloat hash21(vec2 p){p = fract(p*vec2(13.81,741.76)); p += dot(p, p+42.23); return fract(p.x*p.y);} //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n\nfloat particle(vec2 p){ //single particle shape\n    return smoothstep( .1, .0, length(p)) * smoothstep( .1, .06, length(p-vec2(0.,.02)));\n}\n\nfloat particleLayer(vec2 p){ //pseudo-random 2d particle plane\n    float id = hash21(floor(p));\n    return smoothstep(0.,1.,id) *\n        particle((fract(p)-vec2(.5+.4*cos(id*iTime),.5+.4*sin(.8*id*iTime))) * rotM(id*2.*PI)/vec2(cos(.5*id*iTime),1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){    \n    // General initializations\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n\tvec3 col = vec3(0);\n    \n    // Center orbs \n    vec3 p, camPos = vec3(0,0,-1.5); //vec3 camDir = vec3(0,0,1); \n    float v1, v2, a = 11.;\n    for (float n=1.;n<a;n++){            \n        v1 = iTime*2.3 + n/a*PI*4.;\n        v2 = iTime + n/a*PI;\n        p = vec3( cos(v1)*cos(v2), sin(v1)*cos(v2), sin(v2)) * .5; //parametric sphere\n        p.yz *= rotM(n); //vary orientation\n        col += 1./((p.z-camPos.z)*(p.z-camPos.z)+dot(p.xy,p.xy)) * //vary brightness with distance\n            .001 / max( .001, length(uv-camPos.xy-p.xy/(p.z-camPos.z)) - .02/(p.z-camPos.z)) * //orb shape, vary size with distance\n            (.5 + clamp( .01/max( .001, length(uv-camPos.xy-p.xy/(p.z-camPos.z)+.005*normalize(p.xy))), .0, .9)) * //light spot\n            vec3(mod(n+.3,2.),mod(n*n*.3,2.),mod(n*PI,2.)); //color\n    }    \n\n    // Particle layers    \n    uv *= rotM(iTime*.1-.5*length(uv)); //rotate inner faster\n    float aFrac, amp = 0.; \n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-.05*iTime+.25*n)-.02*1.;\n        amp += 1.4*(.2+.8*1.)*particleLayer( (uv*length(uv)+n*vec2(.1,.05))*25.*aFrac) * smoothstep(1.,.33,aFrac) * (.1+.9*smoothstep(.33,.66,aFrac));\n        \n    }\n    col *= (1.+amp*40.) * 1.5;\n    \n    // Finalizations\n    col *= .3*hash21(uv*iTime) + .7; //noise\n\tcol -= length(uv) * .005; //vignette\n\tcol = pow(col, vec3(.4545)); //gamma correction    \n    fragColor = vec4(col,1.);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 159, 159, 212], [213, 234, 255, 255, 333], [405, 405, 428, 452, 544], [546, 546, 574, 608, 798], [800, 800, 855, 890, 2415]], "test": "untested"}
{"id": "ctlBRH", "name": "U-Boids", "author": "dr2", "description": "Aquatic version of \"Boidies 2\"", "tags": ["dynamics", "fish", "swarm", "boid", "collective"], "likes": 21, "viewed": 283, "published": 3, "date": "1692611962", "time_retrieved": "2024-07-30T17:37:47.561621", "image_code": "// \"U-Boids\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Pseudofish behaving like boids. The red uboid is the leader; those of the other\n  two colors try to follow the leader and also prefer to group with those of the\n  same color. The leader flies a fixed path which sometimes takes it through the\n  square hoop. Uboids are confined to a cubic box.\n\n  The two sliders control zoom and the various interaction parameters (all lumped\n  together for simplicity, red is strongest, and parameter change is initially\n  automatic). Click on the left ring to select the view (tracking, fixed, or attached -\n  behind / ahead of / looking back on - the red leader); the right ring selects\n  number of uboids; mouseable.\n\n  Explore...\n*/\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nmat3 QtToRMat (vec4 q);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, qnHit, ltDir;\nfloat dstFar, tCur, regSz, bdRad, bdLen, wnRad, wnThk, hoopSz, hoopThk, hoopHt, vuMode;\nint nFrame, idObj, nBoid, idBoid;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec4 VCylHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s;\n  float dMin, d, a, b, w, srdx;\n  dMin = dstFar;\n  a = dot (rd.yz, rd.yz);\n  b = dot (rd.yz, ro.yz);\n  w = b * b - a * (dot (ro.yz, ro.yz) - rad * rad);\n  if (w > 0.) {\n    srdx = sign (rd.x);\n    s.x = len;\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      }\n    }\n    if (abs (s.x) < len) {\n      dMin = d;\n      qnHit = vec3 (0., s.yz);\n    } else if (srdx * ro.x < - len) {\n      d = - (srdx * ro.x + len) / abs (rd.x);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.yz) < rad) {\n          dMin = d;\n          qnHit = vec3 (0., 0., - srdx);\n        }\n      }\n    }\n  }\n  return vec4 (s, dMin);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, sMin;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      sMin = s;\n      qnHit = vec3 (s.xy, 0.);\n    } else {\n      drz = - len * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          s = ro + d * rd;\n          dMin = d;\n          sMin = s;\n          sMin.z -= drz;\n          qnHit = s;\n        }\n      }\n    }\n  }\n  return vec4 (sMin, dMin);\n}\n\nfloat BoidHit (vec3 ro, vec3 rd)\n{\n  mat3 bMat;\n  vec4 ds;\n  vec3 rom, rdm, qHitM, qnHitM;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBoid; n ++) {\n    bMat = QtToRMat (Loadv4 (3 * n + 4 + 2));\n    rom = bMat * (ro - Loadv4 (3 * n + 4).xyz);\n    rdm = bMat * rd;\n    ds = CapsHit (rom, rdm, bdRad, bdLen);\n    if (ds.w < dMin) {\n      dMin = ds.w;\n      idBoid = n;\n      qHitM = ds.xyz;\n      qnHitM = qnHit;\n    }\n    rom.z += 2. * bdLen;\n    ds = VCylHit (rom, rdm, wnRad, wnThk);\n    if (ds.w < dMin) {\n      dMin = ds.w;\n      idBoid = n;\n      qHitM = ds.xyz;\n      qHitM.z -= 2. * bdLen;\n      qnHitM = qnHit;\n    }\n  }\n  qHit = qHitM;\n  qnHit = normalize (qnHitM) * QtToRMat (Loadv4 (3 * idBoid + 4 + 2));\n  return dMin;\n}\n\nvec4 BoidCol ()\n{\n  vec3 col;\n  float s;\n  if (idBoid == 0) col = vec3 (1., 0.2, 0.2);\n  else col = ((Loadv4 (3 * idBoid + 4).w == 0.) ? vec3 (1., 1., 0.2) : vec3 (0.2, 1., 1.));\n  col *= 0.9 + 0.1 * smoothstep (- bdLen, bdLen, qHit.z);\n  s = length (qHit.yz - vec2 (0.5 * bdLen, bdLen + 0.35 * bdRad));\n  if (s < 0.2 * bdRad) col = (s < 0.1 * bdRad) ? vec3 (1.) : vec3 (0.2, 0.8, 0.2);\n  if (length (qHit - vec3 (0., -0.2 * bdRad, bdRad + bdLen)) < 0.6 * bdRad)\n     col = vec3 (1.) * (1. - 0.9 * step (abs (qHit.y + 0.2 * bdRad), 0.05 * bdRad) *\n        SmoothBump (0.2, 0.8, 0.05, mod (8. * abs (qHit.x / bdRad), 1.)));\n  if (length (qHit.yz + vec2 (0., 2. * bdLen)) > 0.7 * wnRad) {\n    s = 0.25 + atan (qHit.z + 2. * bdLen, - qHit.y) / (2. * pi);\n    if (abs (s) < 0.15) col = mix (vec3 (0., 1., 0.), col, SmoothBump (0.15, 0.85, 0.05, mod (32. * s, 1.)));\n  }\n  return vec4 (col, 0.2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, rc;\n  dMin = dstFar;\n  rc = 0.2;\n  q = p;\n  q.y -= hoopHt;\n  d = min (PrRoundBoxDf (vec3 (abs (q.x) - hoopSz, q.yz), hoopThk + vec3 (0., hoopSz, 0.) - rc, rc),\n           PrRoundBoxDf(vec3 (q.xz, abs (q.y) - hoopSz).xzy, hoopThk + vec3 (hoopSz, 0., 0.) - rc, rc));\n  DMIN (1);\n  q = p;\n  sLen = vec4 (vec3 (regSz), 0.);\n  q = abs (q);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + rc, rc),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + rc, rc)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + rc, rc));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec4 b;\n  vec2 q, qq;\n  float c, tt;\n  q = 2. * pi * mod (vec2 (dot (p.yzx, n), dot (p.zxy, n)), 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (int j = 1; j <= 7; j ++) {\n    tt = t * (1. + 1. / float (j));\n    b = sin (tt + vec4 (- qq + vec2 (0.5 * pi, 0.), qq + vec2 (0., 0.5 * pi)));\n    qq = q + tt + b.xy + b.wz;\n    c += 1. / length (q / sin (qq + vec2 (0., 0.5 * pi)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  if (rd.y == 0.) rd.y = 0.0001;;\n  p = 20. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (2. * p.x + 0.77 * t + sin (0.73 * p.y - t)) + sin (0.81 * p.y - 0.89 * t +\n     sin (0.33 * p.x + 0.34 * t)) + 0.5 * (sin (1.43 * p.x - t) + sin (0.63 * p.y + t));\n  h *= 0.04 * smoothstep (0.5, 1., rd.y);\n  return h;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.8), vec3 (0.25, 0.4, 1.), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + gd * 0.05);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstBoid, dstObj;\n  dstBoid = BoidHit (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstBoid) < dstFar) {\n    if (dstBoid < dstObj) {\n      ro += dstBoid * rd;\n      col4 = BoidCol ();\n      vn = qnHit;\n    } else {\n      ro += dstObj * rd;\n      if (idObj == 1) {\n        col4 = vec4 (0.4, 0.7, 0.5, 0.);\n      } else if (idObj == 2) {\n        col4 = vec4 (0.5, 0.5, 0.6, 0.);\n      }\n      vn = ObjNf (ro);\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    if (idObj == 1) col += 0.1 * TurbLt (0.5 * ro, abs (vn), 0.5 * tCur) *\n       smoothstep (-0.3, -0.1, vn.y);\n  } else col = BgCol (rd) + WatShd (rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, vec4 parmV)\n{\n  vec4 wgBx[4];\n  vec3 cg;\n  vec2 ut, c;\n  float asp, w;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.43 * asp, -0.2, 0.02, 0.);\n  wgBx[1] = vec4 (0.48 * asp, -0.2, 0.02, 0.);\n  wgBx[2] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n  wgBx[3] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n  c = vec2 (1., 0.);\n  for (int k = 0; k <= 1; k ++) {\n    col = mix (((parmV[k] == 0.) ? c.yxy : (parmV[k] == 1.) ? c.xxy : c.xyy), col,\n       smoothstep (1.2, 2.2, abs (length (0.5 * uv - wgBx[k].xy) - wgBx[k].z) * canvas.y));\n  }\n  for (int k = 2; k <= 3; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    w = Maxv2 (abs (ut) - wgBx[k].zw);\n    if (abs (w) * canvas.y < 1. || w < 0. && mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n       canvas.y < 6.) col = vec3 (0.7);\n    cg = (k == 2) ? c.xyx : ((parmV[k] > 0.7) ? c.xyy : ((parmV[k] > 0.3) ? c.xxy : c.yxy));\n    col = mix (cg, col, smoothstep (1.5, 3.5, abs (length (ut - vec2 (0., (parmV[k] - 0.5) *\n       2. * wgBx[k].w)) - 0.7 * wgBx[k].z) * canvas.y));\n  }\n  return col;\n}\n\n#define N_WIN  4\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, flMat;\n  vec4 stDat, mPtr;\n  vec3 rd, ro, vd, rLd, vLd, col, rOff;\n  vec2 canvas, uv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float tCur, el, az, asp, zmFac, zmVar, flVar, szMode, vuId, vuIdO, regId;\n  int wgSel;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. / mSize.y - 1.) * mSize;\n  mMid[1] = mMid[0] * vec2 (1., -1.);\n  mMid[2] = mMid[0] * vec2 (-1., -1.);\n  mMid[3] = mMid[0] * vec2 (-1., 1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  stDat = Loadv4 (0);\n  vuMode = stDat.y;\n  nBoid = int (stDat.z);\n  regSz = stDat.w;\n  stDat = Loadv4 (1);\n  hoopSz = stDat.x;\n  hoopThk = stDat.y;\n  hoopHt = stDat.z;\n  stDat = Loadv4 (2);\n  flVar = stDat.x;\n  zmVar = stDat.y;\n  szMode = stDat.z;\n  stDat = Loadv4 (3);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  rLd = Loadv4 (0 + 4).xyz;\n  bdRad = 0.15;\n  bdLen = 0.1;\n  wnRad = 0.25;\n  wnThk = 0.005;\n  az = 0.;\n  el = 0.;\n  regId = -1.;\n  if (wgSel < 0 && mPtr.z > 0.) {\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  vuId = 0.;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  vuIdO = vuId;\n  if (regId > 0. && (vuId == 0. || vuId == regId)) vuId = regId - vuId;\n  if (wgSel < 0) {\n    if (mPtr.z > 0. && (vuId == 0. || vuId == regId)) {\n      az += 2. * pi * msw.x;\n      el += pi * msw.y;\n    }\n  }\n  vuMode = mod (vuMode + vuId, 5.);\n  if (vuMode == 0.) {\n    ro = vec3 (0., 0., - 4. * regSz);\n    vd = normalize (rLd - ro);\n    zmFac = 3. + 15. * zmVar;\n    az = clamp (0.25 * az, -0.2 * pi, 0.2 * pi);\n    el = clamp (0.25 * el, -0.2 * pi, 0.2 * pi);\n    az += 0.5 * pi + atan (- vd.z, vd.x);\n    el += asin (vd.y);\n  } else if (vuMode == 1.) {\n    ro = vec3 (0., 0., - 4. * regSz);\n    zmFac = 2.5 + 6. * zmVar;\n    el = clamp (el, -0.25 * pi, 0.25 * pi);\n  } else if (vuMode >= 2.) {\n    az = clamp (az, - pi, pi);\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n    zmFac = 0.5 + 4.5 * zmVar;\n  }\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  if (vuMode == 1.) {\n    ro = vuMat * ro;\n  } else if (vuMode >= 2.) {\n    flMat = QtToRMat (Loadv4 (2 + 4));\n    rOff = (vuMode == 3.) ? vec3 (0., 2.5 * bdRad, 0.) : ((vuMode == 2.) ?\n       vec3 (0., 2. * bdRad, -15. * bdLen) : vec3 (0., 2. * bdRad, 15. * bdLen));\n    ro = rLd + rOff * flMat;\n    if (vuMode == 4.) rd.z *= -1.;\n    rd = rd * flMat;\n  }\n  dstFar = 8. * regSz;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  col = ShowScene (ro, rd);\n  if (vuIdO == 0.) col = ShowWg (uv, canvas, col, vec4 (vuMode, szMode, zmVar, flVar));\n  if (mPtr.z > 0. && wgSel < 0 && vuIdO == 0. && Maxv2 (abs (uv)) < 0.03 &&\n     Minv2 (abs (uv)) < 0.003) col = vec3 (0.8, 0.8, 0.1);\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 2.)\n       col = vec3 (0.8, 0.8, 0.2);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"U-Boids\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 RMatToQt (mat3 m);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBoidMx = 1024;\nvec3 rLd, vLd, aLd;\nfloat vFly, regSz, fSep, rFlok, fFlok, fAln, fLead, rAttr, fDamp, nStep, dt,\n   hoopSz, hoopThk, hoopHt;\nint nFrame, nBoid;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid Step (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  vec4 p;\n  vec3 dr, rSum, vSum;\n  float nNeb, rLen, vMag, rMarg;\n  p = Loadv4 (3 * mId + 4);\n  r = p.xyz;\n  grp = p.w;\n  v = Loadv4 (3 * mId + 4 + 1).xyz;\n  a = vec3 (0.);\n  if (nStep > 0.) {\n    vSum = vec3 (0.);\n    rSum = vec3 (0.);\n    nNeb = 0.;\n    for (int n = VAR_ZERO; n < nBoid; n ++) {\n      if (n != mId) {\n        p = Loadv4 (3 * n + 4);\n        dr = r - p.xyz;\n        rLen = length (dr);\n        if (rLen < 1.) a += fSep * (1. / rLen - 1.) * dr;\n        if (rLen < rFlok && grp == p.w) {\n          rSum += p.xyz;\n          vSum += Loadv4 (3 * n + 4 + 1).xyz;\n          ++ nNeb;\n        }\n      }\n    }\n    if (nNeb > 0.) a -= fFlok * (r - rSum / nNeb) + fAln * (v - vSum / nNeb);\n    dr = r - rLd;\n    rLen = length (dr);\n    if (rLen < rAttr) {\n      a += ((1. - 2. * smoothstep (2., 3., rLen)) * fLead / max (rLen * rLen, 0.001)) * dr;\n    }\n    rMarg = 1.;\n    dr = r;\n    dr.xy -= vec2 ((hoopSz - hoopThk) * sign (r.x), hoopHt);\n    dr = max (abs (dr) - vec3 (hoopThk, hoopSz, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    dr = r;\n    dr.y -= hoopHt + (hoopSz - hoopThk) * sign (r.y);\n    dr = max (abs (dr) - vec3 (hoopSz, hoopThk, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    a += 0.05 * (vFly - length (v)) * normalize (v);\n    dr = (regSz - 0.3) * sign (r) - r;\n    a -= step (abs (dr), vec3 (1.)) * 10. * fSep * (1. / abs (dr) - 1.) * dr;\n    a -= fDamp * v;\n    v += dt * a;\n    r += dt * v;\n  }\n}\n\nvec3 TrackPos (float t)\n{\n  vec3 r;\n  float tt = mod (t, 1.);\n  r.xz = 0.35 * regSz * ((mod (t, 2.) < 1.) ? vec2 (- cos (2. * pi * tt) + 1., sin (2. * pi * tt)) :\n     vec2 (cos (2. * pi * tt) - 1., sin (2. * pi * tt)));\n  r.y = hoopHt + (hoopSz + 7. * hoopThk) * ((mod (floor (t / 2. - 0.25), 4.) > 1.) ?\n     SmoothBump (0.3, 0.7, 0.15, tt) : 1.);\n  return r;\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  float mIdf, w;\n  mIdf = float (mId) + 0.1;\n  w = floor (pow (float (nBoid), 1./3.) + 0.999);\n  r = 2.5 * vec3 (mod (mIdf, w), mod (floor (mIdf / w), w), floor (mIdf / (w * w))) -\n     vec3 (1.25 * w, 1.25 * w, regSz - 1.25 * w);\n  v = vFly * (2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3),\n     Hashff (mIdf + 0.6)) - 0.5) + 1.);\n  a = vec3 (0.);\n  grp = floor (2. * Hashff (mIdf));\n}\n\nvoid SetLead (out vec3 r, out vec3 v, out vec3 a)\n{\n  vec3 rf, rb;\n  float s, ds;\n  s = 5.5 * vFly * max (nStep, 0.) * dt / (2. * pi * regSz);\n  ds = 0.1;\n  r = TrackPos (s);\n  rf = TrackPos (s + ds);\n  rb = TrackPos (s - ds);\n  v = (rf - rb) / (2. * ds);\n  a = (rf - 2. * r + rb) / (ds * ds);\n}\n\nvec4 EvalOri (int mId, vec3 v, vec3 a)\n{\n  vec3 va, ort, ca, sa;\n  float el, az, rl;\n  v = normalize (v);\n  va = cross (a, v);\n  el = -0.7 * asin (v.y);\n  az = atan (v.z, v.x) - 0.5 * pi;\n  rl = 0.001 * length (va) * sign (va.y);\n  ort = vec3 (el, az, rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  return RMatToQt (mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[4], stDat, p;\n  vec3 r, v, a;\n  vec2 iFrag, canvas, ust;\n  float tCur, grp, vuMode, szMode, asp, zmVar, flVar, autoVar;\n  int mId, pxId, wgSel, wgReg, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBoidMx + 4) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mId = (pxId >= 4) ? (pxId - 4) / 3 : -1;\n  vFly = 1.2;\n  hoopSz = 4.;\n  hoopThk = 1.;\n  hoopHt = -2.;\n  fSep = 10.;\n  rFlok = 6.;\n  fDamp = 1e-4;\n  dt = 0.05;\n  wgReg = -2;\n  if (nFrame <= 1) {\n    mPtrP = mPtr;\n    wgSel = -1;\n    szMode = 1.;\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    vuMode = stDat.y;\n    nBoid = int (stDat.z);\n    regSz = stDat.w;\n    stDat = Loadv4 (1);\n    autoVar = stDat.w;\n    stDat = Loadv4 (2);\n    flVar = stDat.x;\n    zmVar = stDat.y;\n    szMode = stDat.z;\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.43 * asp, -0.2, 0.02, 0.);\n    wgBx[1] = vec4 (0.48 * asp, -0.2, 0.02, 0.);\n    wgBx[2] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n    wgBx[3] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n    ust = mPtr.xy * vec2 (asp, 1.);\n    if (length (ust - wgBx[0].xy) < wgBx[0].z) wgReg = 0;\n    if (length (ust - wgBx[1].xy) < wgBx[1].z) wgReg = 1;\n    if (Maxv2 (abs (ust - wgBx[2].xy) - wgBx[2].zw) < 0.) wgReg = 2;\n    if (Maxv2 (abs (ust - wgBx[3].xy) - wgBx[3].zw) < 0.) wgReg = 3;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel <= 1) {\n    if (mPtrP.z <= 0.) {\n      if (wgSel == 0) {\n        vuMode = mod (++ vuMode, 5.);\n        zmVar = 0.2;\n      } else if (wgSel == 1) {\n        szMode = mod (++ szMode, 3.);\n        doInit = true;\n        zmVar = 0.2;\n      }\n    }\n  } else if (wgSel == 2) {\n    zmVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[2].y) / wgBx[2].w, 0., 1.);\n  } else if (wgSel == 3) {\n    flVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[3].y) / wgBx[3].w, 0., 1.);\n    autoVar = 0.;\n  }\n  if (doInit) {\n    nBoid = (szMode == 0.) ?  nBoidMx / 4 : ((szMode == 1.) ? nBoidMx / 2 : nBoidMx);\n    regSz = 40. * pow (float (nBoid) / float (nBoidMx), 1./3.);\n    nStep = -50.;\n    vuMode = 0.;\n    zmVar = 0.2;\n    flVar = 0.2;\n    autoVar = 1.;\n  } else {\n    ++ nStep;\n    if (autoVar > 0.) flVar = 0.2 + 0.8 * SmoothBump (0.1, 0.9, 0.1,\n       fract (0.1 * vFly * max (nStep, 0.) * dt / (2. * regSz)));\n  }\n  fLead = mix (1., 10., flVar);\n  rAttr = mix (3., 12., flVar);\n  fAln = mix (0., 0.04, flVar);\n  fFlok = mix (0., 0.04, flVar);\n  if (mId < nBoid) {\n    if (mId >= 0) SetLead (rLd, vLd, aLd);\n    if (mId > 0) {\n      if (doInit) Init (mId, r, v, a, grp);\n      else Step (mId, r, v, a, grp);\n    }\n  }\n  if (mId == 0) {\n    r = rLd;\n    v = vLd;\n    a = aLd;\n    grp = 2.;\n  }\n  if (mId < 0) {\n    if      (pxId == 0) stDat = vec4 (nStep, vuMode, float (nBoid), regSz);\n    else if (pxId == 1) stDat = vec4 (hoopSz, hoopThk, hoopHt, autoVar);\n    else if (pxId == 2) stDat = vec4 (flVar, zmVar, szMode, 0.);\n    else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  } else if (mId < nBoid) {\n    kp = 4 + 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (r, grp);\n    else if (pxId == kp + 1) stDat = vec4 (v, 0.);\n    else if (pxId == kp + 2) stDat = EvalOri (mId, v, a);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"U-Boids\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 RMatToQt (mat3 m);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBoidMx = 1024;\nvec3 rLd, vLd, aLd;\nfloat vFly, regSz, fSep, rFlok, fFlok, fAln, fLead, rAttr, fDamp, nStep, dt,\n   hoopSz, hoopThk, hoopHt;\nint nFrame, nBoid;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid Step (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  vec4 p;\n  vec3 dr, rSum, vSum;\n  float nNeb, rLen, vMag, rMarg;\n  p = Loadv4 (3 * mId + 4);\n  r = p.xyz;\n  grp = p.w;\n  v = Loadv4 (3 * mId + 4 + 1).xyz;\n  a = vec3 (0.);\n  if (nStep > 0.) {\n    vSum = vec3 (0.);\n    rSum = vec3 (0.);\n    nNeb = 0.;\n    for (int n = VAR_ZERO; n < nBoid; n ++) {\n      if (n != mId) {\n        p = Loadv4 (3 * n + 4);\n        dr = r - p.xyz;\n        rLen = length (dr);\n        if (rLen < 1.) a += fSep * (1. / rLen - 1.) * dr;\n        if (rLen < rFlok && grp == p.w) {\n          rSum += p.xyz;\n          vSum += Loadv4 (3 * n + 4 + 1).xyz;\n          ++ nNeb;\n        }\n      }\n    }\n    if (nNeb > 0.) a -= fFlok * (r - rSum / nNeb) + fAln * (v - vSum / nNeb);\n    dr = r - rLd;\n    rLen = length (dr);\n    if (rLen < rAttr) {\n      a += ((1. - 2. * smoothstep (2., 3., rLen)) * fLead / max (rLen * rLen, 0.001)) * dr;\n    }\n    rMarg = 1.;\n    dr = r;\n    dr.xy -= vec2 ((hoopSz - hoopThk) * sign (r.x), hoopHt);\n    dr = max (abs (dr) - vec3 (hoopThk, hoopSz, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    dr = r;\n    dr.y -= hoopHt + (hoopSz - hoopThk) * sign (r.y);\n    dr = max (abs (dr) - vec3 (hoopSz, hoopThk, hoopThk), 0.) * sign (dr);\n    rLen = length (dr);\n    if (rLen < hoopThk + rMarg) a += fSep * ((hoopThk + rMarg) / rLen - 1.) * dr;\n    a += 0.05 * (vFly - length (v)) * normalize (v);\n    dr = (regSz - 0.3) * sign (r) - r;\n    a -= step (abs (dr), vec3 (1.)) * 10. * fSep * (1. / abs (dr) - 1.) * dr;\n    a -= fDamp * v;\n    v += dt * a;\n    r += dt * v;\n  }\n}\n\nvec3 TrackPos (float t)\n{\n  vec3 r;\n  float tt = mod (t, 1.);\n  r.xz = 0.35 * regSz * ((mod (t, 2.) < 1.) ? vec2 (- cos (2. * pi * tt) + 1., sin (2. * pi * tt)) :\n     vec2 (cos (2. * pi * tt) - 1., sin (2. * pi * tt)));\n  r.y = hoopHt + (hoopSz + 7. * hoopThk) * ((mod (floor (t / 2. - 0.25), 4.) > 1.) ?\n     SmoothBump (0.3, 0.7, 0.15, tt) : 1.);\n  return r;\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v, out vec3 a, out float grp)\n{\n  float mIdf, w;\n  mIdf = float (mId) + 0.1;\n  w = floor (pow (float (nBoid), 1./3.) + 0.999);\n  r = 2.5 * vec3 (mod (mIdf, w), mod (floor (mIdf / w), w), floor (mIdf / (w * w))) -\n     vec3 (1.25 * w, 1.25 * w, regSz - 1.25 * w);\n  v = vFly * (2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3),\n     Hashff (mIdf + 0.6)) - 0.5) + 1.);\n  a = vec3 (0.);\n  grp = floor (2. * Hashff (mIdf));\n}\n\nvoid SetLead (out vec3 r, out vec3 v, out vec3 a)\n{\n  vec3 rf, rb;\n  float s, ds;\n  s = 5.5 * vFly * max (nStep, 0.) * dt / (2. * pi * regSz);\n  ds = 0.1;\n  r = TrackPos (s);\n  rf = TrackPos (s + ds);\n  rb = TrackPos (s - ds);\n  v = (rf - rb) / (2. * ds);\n  a = (rf - 2. * r + rb) / (ds * ds);\n}\n\nvec4 EvalOri (int mId, vec3 v, vec3 a)\n{\n  vec3 va, ort, ca, sa;\n  float el, az, rl;\n  v = normalize (v);\n  va = cross (a, v);\n  el = -0.7 * asin (v.y);\n  az = atan (v.z, v.x) - 0.5 * pi;\n  rl = 0.001 * length (va) * sign (va.y);\n  ort = vec3 (el, az, rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  return RMatToQt (mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[4], stDat, p;\n  vec3 r, v, a;\n  vec2 iFrag, canvas, ust;\n  float tCur, grp, vuMode, szMode, asp, zmVar, flVar, autoVar;\n  int mId, pxId, wgSel, wgReg, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBoidMx + 4) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mId = (pxId >= 4) ? (pxId - 4) / 3 : -1;\n  vFly = 1.2;\n  hoopSz = 4.;\n  hoopThk = 1.;\n  hoopHt = -2.;\n  fSep = 10.;\n  rFlok = 6.;\n  fDamp = 1e-4;\n  dt = 0.05;\n  wgReg = -2;\n  if (nFrame <= 1) {\n    mPtrP = mPtr;\n    wgSel = -1;\n    szMode = 1.;\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    vuMode = stDat.y;\n    nBoid = int (stDat.z);\n    regSz = stDat.w;\n    stDat = Loadv4 (1);\n    autoVar = stDat.w;\n    stDat = Loadv4 (2);\n    flVar = stDat.x;\n    zmVar = stDat.y;\n    szMode = stDat.z;\n    stDat = Loadv4 (3);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.43 * asp, -0.2, 0.02, 0.);\n    wgBx[1] = vec4 (0.48 * asp, -0.2, 0.02, 0.);\n    wgBx[2] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n    wgBx[3] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n    ust = mPtr.xy * vec2 (asp, 1.);\n    if (length (ust - wgBx[0].xy) < wgBx[0].z) wgReg = 0;\n    if (length (ust - wgBx[1].xy) < wgBx[1].z) wgReg = 1;\n    if (Maxv2 (abs (ust - wgBx[2].xy) - wgBx[2].zw) < 0.) wgReg = 2;\n    if (Maxv2 (abs (ust - wgBx[3].xy) - wgBx[3].zw) < 0.) wgReg = 3;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel <= 1) {\n    if (mPtrP.z <= 0.) {\n      if (wgSel == 0) {\n        vuMode = mod (++ vuMode, 5.);\n        zmVar = 0.2;\n      } else if (wgSel == 1) {\n        szMode = mod (++ szMode, 3.);\n        doInit = true;\n        zmVar = 0.2;\n      }\n    }\n  } else if (wgSel == 2) {\n    zmVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[2].y) / wgBx[2].w, 0., 1.);\n  } else if (wgSel == 3) {\n    flVar = clamp (0.5 + 0.5 * (mPtr.y - wgBx[3].y) / wgBx[3].w, 0., 1.);\n    autoVar = 0.;\n  }\n  if (doInit) {\n    nBoid = (szMode == 0.) ?  nBoidMx / 4 : ((szMode == 1.) ? nBoidMx / 2 : nBoidMx);\n    regSz = 40. * pow (float (nBoid) / float (nBoidMx), 1./3.);\n    nStep = -50.;\n    vuMode = 0.;\n    zmVar = 0.2;\n    flVar = 0.2;\n    autoVar = 1.;\n  } else {\n    ++ nStep;\n    if (autoVar > 0.) flVar = 0.2 + 0.8 * SmoothBump (0.1, 0.9, 0.1,\n       fract (0.1 * vFly * max (nStep, 0.) * dt / (2. * regSz)));\n  }\n  fLead = mix (1., 10., flVar);\n  rAttr = mix (3., 12., flVar);\n  fAln = mix (0., 0.04, flVar);\n  fFlok = mix (0., 0.04, flVar);\n  if (mId < nBoid) {\n    if (mId >= 0) SetLead (rLd, vLd, aLd);\n    if (mId > 0) {\n      if (doInit) Init (mId, r, v, a, grp);\n      else Step (mId, r, v, a, grp);\n    }\n  }\n  if (mId == 0) {\n    r = rLd;\n    v = vLd;\n    a = aLd;\n    grp = 2.;\n  }\n  if (mId < 0) {\n    if      (pxId == 0) stDat = vec4 (nStep, vuMode, float (nBoid), regSz);\n    else if (pxId == 1) stDat = vec4 (hoopSz, hoopThk, hoopHt, autoVar);\n    else if (pxId == 2) stDat = vec4 (flVar, zmVar, szMode, 0.);\n    else if (pxId == 3) stDat = vec4 (mPtr.xyz, float (wgSel));\n  } else if (mId < nBoid) {\n    kp = 4 + 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (r, grp);\n    else if (pxId == kp + 1) stDat = vec4 (v, 0.);\n    else if (pxId == kp + 2) stDat = EvalOri (mId, v, a);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlBRH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1307, 1307, 1362, 1362, 2053], [2055, 2055, 2110, 2110, 2836], [2838, 2838, 2872, 2872, 3586], [3588, 3588, 3605, 3605, 4481], [4483, 4483, 4505, 4505, 5087], [5089, 5089, 5122, 5122, 5304], [5306, 5306, 5327, 5327, 5584], [5586, 5586, 5626, 5626, 6086], [6088, 6088, 6112, 6112, 6444], [6446, 6446, 6468, 6468, 6888], [6890, 6890, 6925, 6925, 7739], [7741, 7741, 7799, 7799, 8841], [8861, 8861, 8917, 8917, 12235], [12237, 12237, 12259, 12259, 12286], [12288, 12288, 12310, 12310, 12337], [12339, 12339, 12385, 12385, 12432], [12434, 12434, 12491, 12491, 12574], [12576, 12576, 12612, 12612, 12818], [12820, 12820, 12850, 12850, 12963], [12965, 12965, 12989, 12989, 13305], [13399, 13399, 13424, 13424, 13547]], "test": "untested"}
{"id": "dlXfzH", "name": "Fractal thingi", "author": "Lunasoldev", "description": "idk just testing things out", "tags": ["fractal"], "likes": 0, "viewed": 107, "published": 3, "date": "1692599161", "time_retrieved": "2024-07-30T17:37:48.630762", "image_code": "#define NUM_LAYERS 128.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = .01;\n    \n    float time = pow(abs(sin(iTime)),4.);\n    \n    theta *= iTime;\n    \n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    \n    for(float i = 0.; i<1.; i+=1./NUM_LAYERS) {\n        uv = (abs(uv)-.5)*1.03;\n        uv *= mat2(\n        cos(theta),-sin(theta),\n        sin(theta), cos(theta)\n        );\n    }\n    \n    \n    // Output to screen\n    vec3 col = vec3(length(uv+vec2(.2,-.3)), length(uv+vec2(-.4,-.1)), length(uv+vec2(-.2,.3)));\n    \n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 580]], "test": "untested"}
{"id": "dtXfzH", "name": "Bent Ray March Black Hole", "author": "Blindman67", "description": "Ray march warped (by gravity) as it passes the singularity. Drag mouse to change view.", "tags": ["raymarch"], "likes": 11, "viewed": 370, "published": 3, "date": "1692598879", "time_retrieved": "2024-07-30T17:37:49.457552", "image_code": "#define CAMERA_DIST 20.0\n#define SINGULARITY_RADIUS 1.0\n#define MASS 0.1  \n#define DISK_RADIUS 10.0 \n#define MAX_STEPS 105\n#define MAX_DIST ((DISK_RADIUS + CAMERA_DIST) * 1.4)\n#define MIN_DIST 0.01\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\n#define RAY_SRC_DISK 1u\n#define RAY_SRC_HORIZON 2u\n#define RAY_SRC_SPACE 3u\nuint raySrc = 0u;\n\nfloat rayDistance = 0.0;\n\nRay camera = Ray(vec3(0), vec3(0));\nRay plane = Ray(vec3(0, 0, 0), vec3(0,-1,0));\nvec3 srcPos;\nfloat Plane(vec3 origin, vec3 dir, Ray plane){\n    float d = dot(plane.dir, dir);\n    return abs(d) > 0.0001 ? dot(plane.origin - origin, plane.dir) / d : MAX_DIST;\n}\nfloat GetDist(vec3 origin, vec3 dir) {\n    float pDist = Plane(origin, dir, plane);\n    rayDistance = length(origin);\n    float hDist = rayDistance - SINGULARITY_RADIUS;\n    if (pDist < hDist) {\n        float dDist = length(origin + dir * pDist);\n        if (dDist < DISK_RADIUS) {\n            raySrc = RAY_SRC_DISK;\n            return pDist;\n        }\n    } \n    raySrc = RAY_SRC_HORIZON;\n    return hDist;\n}\nfloat Temp(float dist) { return pow(e, -pow(((PI * (dist - 0.5)) / (dist - 0.1)), 2.0)); }\nvec4 GetSpace() { return vec4(0.0, 0.01, 0.02, 1); }\nvec4 GetDisk(vec3 pos) {\n   float dir = atan(pos.x, pos.z) + PI + TAU; \n   float dist = (length(pos) - SINGULARITY_RADIUS) / (DISK_RADIUS - SINGULARITY_RADIUS);\n   if (dist > 1.0) { return GetSpace(); }\n   vec3 n = Noise2D(vec2(sin(dir + iTime * (1.0 - dist)), dist*10.0));\n   float temp = (Temp(dist + 0.35)- 0.01) * (1.0 - (n.x + n.y));\n   float idx = temp * 38.0;\n   uint i1 = uint(idx);\n   uint i2 = i1 + 1u;\n   vec3 c1 = Uint2RGB(BLACK_BODY[i1]);\n   vec3 c2 = Uint2RGB(BLACK_BODY[i2]);\n   float f = fract(idx);\n   vec3 c = ((c2 - c1) * f + c1) * (1.0 + temp* 2.0);\n   return vec4(c, temp);\n}\nvec4 March(Ray camera) {\n\tfloat dist = 0.0; \n    float stepDist;\n    vec3 pos = camera.origin;\n    int i;\n    for(i = 0; i < MAX_STEPS; i++){\n        stepDist = GetDist(pos, camera.dir);\n        camera.dir = normalize(camera.dir - normalize(pos) * (MASS / (rayDistance * rayDistance)));\n        pos += camera.dir * stepDist;\n        dist += stepDist;\n        if (dist > MAX_DIST || dist < MIN_DIST) { break; }\n    }\n    if (dist > MAX_DIST) { raySrc = RAY_SRC_SPACE; }\n    srcPos = pos;\n    if (raySrc == RAY_SRC_DISK) { return GetDisk(srcPos); }\n    if (raySrc == RAY_SRC_HORIZON) { return vec4(0); } \n    return GetSpace();    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 look = iMouse.x <= 1.0 && iMouse.y <= 1.0 ? iResolution.xy * vec2(0.5, 0.45) : iMouse.xy;\n    mat3 vmat = lookMouse(look / iResolution.xy);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    camera.origin =  - vmat[2] * 20.0;\n    camera.dir = normalize(vmat * vec3(uv, 2.0));\n    \n    fragColor = vec4(pow(March(camera).xyz, vec3(1)),1.0);\n}", "image_inputs": [], "common_code": "const float PI = 3.14159;\nconst float e = 2.71828182846;\n\nconst float TAU = PI * 2.0;\nconst float INV_255 = 1.0 / 255.0;\nconst uint BLACK_BODY[38] = uint[](0u,  // high 8 bits are alph, then red, green, and blue\n    0x44270800u, 0x884e1001u, 0xAA751802u, 0xCC9c2103u, 0xEEc42903u, 0xFFeb3104u, 0xFFff3605u, 0xFFff6200u, \n    0xFFff7c00u, 0xFFff8f1du, 0xFFffa042u, 0xFFffb05eu, 0xFFffbc76u, 0xFFffc78bu, 0xFFffd09fu, 0xFFffd8b1u, \n    0xFFffe0c0u, 0xFFffe7d0u, 0xFFffeddeu, 0xFFfff1eau, 0xFFfff6f5u, 0xFFfff9feu, 0xFFf7f5ffu, 0xFFeff0ffu, \n    0xFFe8ecffu, 0xFFe2e9ffu, 0xFFdce5ffu, 0xFFd7e2ffu, 0xFFd3dfffu, 0xFFcfddffu, 0xFFcbdbffu, 0xFFc8d9ffu, \n    0xFFc5d7ffu, 0xFFc3d5ffu, 0xFFc0d4ffu, 0xFFbed2ffu, 0xFFbbd1ffu\n);\nvec3 Uint2RGB(uint col) {\n    return vec3(\n        float((col >> 16u) & 0xFFu) * INV_255,\n        float((col >> 8u) & 0xFFu) * INV_255,\n        float(col & 0xFFu) * INV_255\n    );\n}\nvec4 Uint2RGBA(uint col) {\n    return vec4(\n        float((col >> 16u) & 0xFFu) * INV_255,\n        float((col >> 8u) & 0xFFu) * INV_255,\n        float(col & 0xFFu) * INV_255,\n        float(col >> 24u) * INV_255\n    );\n}\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\n\nmat3 lookMouse(in vec2 unitMouse) {\n    return camMatrix((unitMouse.x * 1.2 - 0.1) * PI, (unitMouse.y + 0.5) * PI);\n}\n\nfloat Hash(vec2 pos) {\n    pos = fract(pos * 13.654678) * 65.247743;\n    float f = fract((pos.x + pos.y) * pos.x * pos.y);\n    return f * f;\n}\nvec3 Noise2D(vec2 pos) {  /* returns vec3 where 2D noise is return.xy  */\n    vec2 fPos = floor(pos);\n    float a = Hash(fPos);\n    float b = Hash(fPos + vec2(1, 0));\n    float c = Hash(fPos + vec2(0, 1));\n    float d = Hash(fPos + vec2(1, 1));\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f), u1 = 1.0 - u;\n    float ca = c - a;\n    float ba = b - a;\n    return vec3(\n        6.0 * u * u1 * (vec2(ba, ca) + u.yx * (a - b - c + d)),\n        a + ba * u.x * u1.y + ca * u1.x * u.y + (d - a) * u.x * u.y        \n    );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 508, 508, 628], [629, 629, 667, 667, 1038], [1039, 1039, 1063, 1063, 1129], [1130, 1130, 1147, 1147, 1182], [1183, 1183, 1207, 1207, 1779], [1780, 1780, 1804, 1804, 2411], [2413, 2413, 2470, 2470, 2840]], "test": "untested"}
{"id": "dlffRH", "name": "cube ray planting", "author": "chenxianming", "description": "without wireframe, but looks well.", "tags": ["cineshader", "nextstop"], "likes": 10, "viewed": 900, "published": 3, "date": "1692591533", "time_retrieved": "2024-07-30T17:37:50.408010", "image_code": "#define PI 3.1415926\n#define I iResolution\n#define T( s ) fract( iTime * s ) * PI * 4.\n#define T2( s ,b ) fract(iTime * s) * b\n#define rot( a ) mat2( cos( a ), sin( a ), -sin( a ), cos( a ) )\n\n// texture\n\nfloat h(in vec2 a) { return dot(a, a); }\nfloat i(in vec2 c, in vec2 a, in vec2 d) {\n  vec2 e = c - a, b = d - a;\n  return h(e - b * clamp(dot(e, b) / dot(b, b), 0., 1.));\n}\n\nfloat j(vec2 d) {\n  float c = .1;\n  for (float a = 0.; a < 24.; a++) {\n    float b = a + 1.;\n    if (a > 23.)\n      break;\n    float e = cos(a / 24. * 6. * 6.28) * .1 * (a / 5.),\n          k = sin(a / 24. * 6. * 6.28) * .1 * (a / 5.),\n          l = cos(b / 24. * 6. * 6.28) * .1 * (b / 5.),\n          m = sin(b / 24. * 6. * 6.28) * .1 * (b / 5.);\n    c = min(c, i(d, vec2(e, k), vec2(l, m)));\n  }\n  return c;\n}\nvec2 g(inout vec2 b, vec2 a) {\n  vec2 c = a * .5, d = floor((b + c) / a);\n  b = mod(b + c, a) - c;\n  return d;\n}\nfloat n(vec2 a) {\n  float b = .1;\n  a.y += T2( .25, .96 );\n  vec2 c = g(a, vec2(.49, .48));\n  a.xy *= mod(c.x, 2.) == 0. ? rot(0.) : rot(3.141593), b = min(b, j(a * 2.));\n  return b;\n}\n\n// textureEND\n\n// geo\nfloat j(vec3 a, int b) {\n  float c = b == 0 ? 1. : abs(abs(a.y) - .5);\n  return max(max(abs(a.x) - .5 * c, abs(a.z) - .5 * c), abs(a.y) - .5);\n}\n// sdf\nfloat df(vec3 a) {\n  a.z -= 2., a.xz *= -rot(T(.0125)), a.yz *= rot(T(.0125));\n  float c = .8;\n  for (float b = 0.; b < 20.; b++)\n    a.xz *= rot(b), c += b / 20., a.xz = abs(a.xz) - .01 * b,\n                                a.y += c * .01 * -1., a.zy *= -rot(b);\n  return j(a, 1);\n}\n// trace2\nfloat s(vec3 a) {\n  a.xz *= rot(T(.05)), a.yz *= -rot(T(.05));\n  return j(a, 0);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 nrm( vec3 a) {\n    vec2 e = vec2(1.0, -1.0);\n\n    const float eps = .01;\n    return normalize(e.xyx * s(a + e.xyy * eps) +\n        e.yyx * s(a + e.yyx * eps) +\n        e.yxy * s(a + e.yxy * eps) +\n        e.xxx * s(a + e.xxx * eps));\n}\n\nvoid mainImage(out vec4 U, in vec2 V) {\n  \n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 u = ( V + V - I.xy ) / min( I.x, I.y );\n  \n  float bg = .1;\n  u *= rot(.785398), bg = n(u), bg = smoothstep(0., bg, 1e-5);\n  \n  vec3 g = vec3( bg * .2 ), a, m = vec3(0, 0, -6), h = vec3(u * .15, 1);\n  float b, c, n = 0., o = sqrt(1e-4) * .8, i = 0.;\n  \n  // Time varying pixel color\n  \n  //trace\n  for (; i < 32.; i++)\n    a = m + h * b, c = s(a), b += c;\n\n  // gradient\n  if( c < 1e-3 )\n    g += max( nrm( a ).x, .0 ) * .5,\n    g += max( -nrm( a ).y, .0 ) * .3,\n    g += max( nrm( a ).z, .0 ) * .4;\n\n  a = vec3(0);\n  \n  for (int q = 0; q < 12; q++) {\n    a = m + h * b, \n    // a = mod( a, 1. ) - .5, // what if this code?\n    a *= .8, a = normalize(reflect(a, h)), c = df(a),\n    i = 1. - abs(c) / o,\n    i > 0.\n        ? (g -= .8 * (reflect(a, h) * .2 + .5 * i / b), g += sign(g) * .1, n++)\n        : 0.;\n    if (n > 10.)\n      break;\n    b -= max(abs(c), o * .3);\n  }\n  \n  U = vec4(g, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlffRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 225, 225, 245], [246, 246, 288, 288, 377], [379, 379, 396, 396, 789], [790, 790, 820, 820, 902], [903, 903, 920, 920, 1087], [1104, 1111, 1135, 1135, 1255], [1256, 1263, 1281, 1281, 1545], [1546, 1556, 1573, 1573, 1638], [1640, 1686, 1705, 1705, 1926], [1928, 1928, 1967, 2018, 2920]], "test": "untested"}
{"id": "DlByzd", "name": "First Shroom Shader", "author": "kushnadas", "description": "This is three spinning mushrooms (supposed to be mushrooms)", "tags": ["spinning"], "likes": 0, "viewed": 116, "published": 3, "date": "1692577276", "time_retrieved": "2024-07-30T17:37:51.158005", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    st = st * 2.0 - 1.0;  // Normalize to [-1, 1]\n    st.x *= iResolution.x / iResolution.y;  // Adjust for aspect ratio\n\n    vec3 color = vec3(0.0); // initialize to black\n\n    for(int i=0; i<3; i++) {  // 3 mandalas for this example\n        vec2 s = st;\n\n        // Convert to polar coordinates\n        float r = length(s);\n        float theta = atan(s.y, s.x);\n\n        // Opposing rotations for moiré effect\n        if(i % 2 == 0) {\n            theta += iTime * (0.5 + float(i)*0.5);  // Adjust speed for variety\n        } else {\n            theta -= iTime * (0.5 + float(i)*0.5); \n        }\n        \n        float repetitions = 6.0 + float(i);  // More petals for variety\n        theta *= repetitions;\n\n        // Convert back to Cartesian coordinates\n        s.x = r * cos(theta);\n        s.y = r * sin(theta);\n\n        // Adjust mushroom size\n        float scaleFactor = 0.5 + float(i) * 0.2; \n        s /= scaleFactor;\n\n        // Mushroom shape\n        float capDist = length(s - vec2(0.0, 0.4));\n        float cap = (capDist < 0.5) ? 1.0 : 0.0;\n        float stem = 1.0;\n        if(abs(s.x) > 0.1 || s.y < -0.5 || s.y > 0.2) stem = 0.0;\n\n        float mushroom = max(stem, cap);\n        if(mushroom > 0.5) {\n            vec3 currentColor;\n            if(i == 0) {\n                currentColor = vec3(0.000,0.518,1.000);  // Red\n            } else if(i == 1) {\n                currentColor = vec3(0.882,1.000,0.000);  // Green\n            } else {\n                currentColor = vec3(0.408,0.643,0.055);  // Blue\n            }\n            color += currentColor;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlByzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1722]], "test": "untested"}
{"id": "mtXBR8", "name": "SpinnerPurp", "author": "kushnadas", "description": "a spinning purple thing", "tags": ["purpspinner"], "likes": 0, "viewed": 97, "published": 3, "date": "1692575945", "time_retrieved": "2024-07-30T17:37:52.025686", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 daygloColor(float value) {\n    float hue = mod(iTime * 0.01 + value * 3.0, 1.0); // Slowed down the pulsing\n    return mix(vec3(0.000,1.000,0.251), \n               vec3(0.6, 0.0, 1.0),\n               hue);\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    return mat2(cos(angle), -sin(angle), \n                sin(angle), cos(angle)) * uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Slow rotation\n    uv = rotate(uv, iTime * 0.05); // Adjust the 0.1 value for faster/slower rotation\n\n    // Basic radial pattern\n    float pattern = sin(18.0 * atan(uv.y, uv.x));\n    \n    // Some Picasso-esque abstract patterns\n    pattern += step(0.5, mod(uv.x + uv.y * 2.5, 1.0)); // Slowed down the pulsing\n    pattern += step(0.5, mod(uv.y * 5.0, 1.0));\n    \n    // Play with these values to adjust the patterns\n    float mask = smoothstep(0.3, 0.41, length(uv));\n    pattern *= mask;\n    \n    vec3 color = daygloColor(pattern);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtXBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 77, 77, 258], [260, 260, 295, 295, 385], [387, 387, 442, 442, 1117]], "test": "untested"}
{"id": "dtXBR8", "name": "moka-Shader", "author": "mokasiri", "description": "sin cos flow", "tags": ["cossin"], "likes": 3, "viewed": 127, "published": 3, "date": "1692575681", "time_retrieved": "2024-07-30T17:37:52.900347", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/ iResolution.xy;\n    \n    vec2 wavedUv = vec2(\n        uv+ sin(uv.yx * 80.0 + iTime * 10.0) * .1\n    );\n    \n    float strength = smoothstep(0.02, 0.0, abs(distance(wavedUv, vec2(0.5)) - 0.25)); // anti aliasing\n    \n    fragColor = vec4(strength);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 332]], "test": "untested"}
{"id": "clXfzH", "name": "Star-Rotate", "author": "mokasiri", "description": "star", "tags": ["star"], "likes": 2, "viewed": 145, "published": 3, "date": "1692573472", "time_retrieved": "2024-07-30T17:37:53.831856", "image_code": "#define PI 3.1415926538979\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float vTime = fract(iTime);\n\n    vec2 uv = fragCoord/ iResolution.xy; \n    //uv.x *= iResolution.x/iResolution.y;\n    uv -= 0.5;\n    \n    vec2 uv2 = fragCoord/ iResolution.xy; \n    //uv2.x *= iResolution.x/iResolution.y;\n    uv2 -= .5;\n    \n    uv.x = uv.x * cos(PI/ 5.0) - uv.y * sin(PI/5.0);\n    uv.y = uv.x * sin(PI/5.0) + uv.y * cos(PI/5.0);\n    \n    uv2.x = uv2.x * cos(-PI/ 5.0) - uv2.y * sin(-PI/5.0);\n    uv2.y = uv2.x * sin(-PI/5.0) + uv2.y * cos(-PI/5.0);\n    \n    uv.y  *= 0.3;\n    uv2.y *= 0.3;\n    \n\n    float strength = 0.015 / length(uv) - 0.1;\n    strength += 0.015 / length(uv2) - 0.1;\n    \n    \n    // Output to screen\n    fragColor = vec4(strength, strength, strength + 0.4 ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 790]], "test": "untested"}
{"id": "DtfBzH", "name": "FRACTAL BLACK HOLE :::.", "author": "ENDESGA", "description": "///////", "tags": ["fractal", "hole", "black"], "likes": 3, "viewed": 240, "published": 3, "date": "1692571826", "time_retrieved": "2024-07-30T17:37:54.767355", "image_code": "// golfed by @Xor [493 chars]\nvoid mainImage(out vec4 o, vec2 i)\n{\n    o = vec4( .7, 7, 70, 700)/9.;\n    float l, T = iTime*o.z;\n    \n\tvec2 R = iResolution.xy,\n        u = (i+i - R) / R.y * vec2(2, 4),\n        r = mat2( cos( T * o.y + vec4(0,11,33,0)) ) * u,\n        z = r * o.x * vec2( 1, o.y ),\n        c = cos( T * o.x + sin( 1. / ( o.y + sin( T * o.x ) * (l=length( u )) ) ) ) / length( z )  * o.zz  * ( 1. - 1. /l ),\n        Z = z;\n\t\n\n\tfor(l=0.; l < o.w && dot( z, z ) < 7e3 / 9. ; l += o.y )\n\t\tz = (z * z * z - 3. * z * (z * z).yx -c.y * Z.yx) * vec2(1,-1)+c.x * Z;\n    u = min(u+vec2(u.x,0),u+u);\n\n\to = ( 1. - exp( -pow( (l-o) / o.w, o ).y * vec4( 1, 0, o ) * pow( max(0.,1. -  1. / length( u )) , o.y ) ) ) \n    *  pow( 1. - exp( - .25 /  dot( u *= o.x, u) ), o.z ) * o.z;\n}\n\n/* original\n#define H vec4( .7 / 9., 7. / 9., 70. / 9., 700. / 9. )\n#define T (iTime*H.z)\nvoid mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 u = ( 2.0 * i - iResolution.xy ) / iResolution.y * vec2( 2., 4. ),\n        r = mat2( cos( -T * H.y ), -sin( -T * H.y ), sin( -T * H.y ), cos( -T * H.y ) ) * u,\n        z = r * H.x * vec2( 1., H.y ),\n        c = vec2( ( cos( T * H.x + sin( 1.0 / ( H.y + sin( T * H.x ) * length( u ) ) ) ) / length( z ) ) * H.z ) * ( 1.0 - 1.0 / length( u ) ),\n        Z = z;\n\tfloat l;\n\n\tfor( l = 0.0; l < H.w; l += H.y )\n\t{\n\t\tz = vec2( z.x * z.x * z.x - 3.0 * z.x * z.y * z.y + c.x * Z.x - c.y * Z.y,\n            3.0 * z.x * z.x * z.y - z.y * z.y * z.y + c.x * Z.y + c.y * Z.x );\n\t\tif( dot( z, z ) > 7000. / 9. ) break;\n\t}\n\n\tu *= vec2( 2., 1. );\n\tvec3 col = vec3( pow( l / H.w, H.y ) * vec3( 1., 0., H.x ) );\n\tif( u.y < 0. ) u.y *= 2.;\n\tcol *= pow( 1.0 - ( 1.0 / length( u ) ), H.y );\n\n\to = ( 1.0 - exp( -vec4( col, 1.0 ) ) ) *\n        pow( 1. - exp( -pow( 1.0 / ( length( u * H.x ) * 2. ), 2.0 ) ), H.z ) * H.z;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 66, 66, 782]], "test": "untested"}
{"id": "dllBRr", "name": "Jean Claud von dots", "author": "Andre", "description": "Draw video in 8 color oversaturate dots, and added circle coordinates just for fun.", "tags": ["dither", "dots"], "likes": 3, "viewed": 180, "published": 3, "date": "1692557772", "time_retrieved": "2024-07-30T17:37:55.741749", "image_code": "// #define circular 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert to circular coordinates\n#ifdef circular\n    uv -= 0.5;\n    float cd = length(uv);\n    uv.x = mod(1.0+iTime*-0.1+atan(uv.x,uv.y)/3.14*2.5,1.0);\n    uv.y = max(cd-0.06,0.0)*2.3;\n#endif\n    vec2 res = iChannelResolution[0].xy / 7.0;\n    vec2 pt = mod(uv, 1.0/res);\n    uv -= pt;\n    pt *= res;\n    \n    // Remove green\n    vec4 tex = texture(iChannel0,uv);\n    tex.g *= 0.93;\n    float newG = min(tex.g,max(tex.r,tex.b));\n    tex.g = newG;\n    \n    // distance from dot center\n    float x = (0.7071-length(pt -0.5))/0.7071;\n    // inverted black and white pixel (unweighted for rgb but i'm colorblind anyway :) )\n    float y = 1.0-pow(max(0.0,length(tex.rgb)-0.2) / 1.732, 1.0/2.2);\n    \n    // max out saturation\n    vec3 clr = tex.rgb / max(max(tex.r,tex.g),tex.b);\n    // Quantize to 8 colors\n    clr = round(clr*2.0)/2.0;\n    \n        \n\tfragColor = vec4(clr * vec3(smoothstep(y,y+0.2,x)),1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 1039]], "test": "untested"}
{"id": "3s3Bzf", "name": "Psychedelic Visuals Overlay", "author": "emymin", "description": "trying to recreate some typical psychedelic visuals\nusing the domain distortion found in this shader https://www.shadertoy.com/view/Mss3Wf\nand IQ's palette function https://www.shadertoy.com/view/ll2GD3", "tags": ["psychedelic"], "likes": 1, "viewed": 191, "published": 3, "date": "1692557625", "time_retrieved": "2024-07-30T17:37:56.545600", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nvec2 fractalize(vec2 uv,int maxIterations){\n\n\tfloat s=0.3;\n\tfor(int i=0;i<maxIterations;i++){\n\t\tuv=abs(uv)-s;\n\t\tuv=rot(uv,iTime);\n\t\ts=s/2.1;\n\t}\n    return uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 inuv = fragCoord.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    uv *= 2.;\n    uv=fract(uv)-.5;\n    \n    uv = fractalize(uv,5);\n    \n    col = pal( (uv.x+uv.y)*20., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n\n    col.rgb = texture(iChannel0,inuv).rgb + col*0.1;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Bzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 111], [112, 112, 138, 138, 203], [205, 205, 248, 248, 365], [368, 368, 425, 425, 828]], "test": "untested"}
{"id": "3d3fzf", "name": "concentric tests", "author": "emymin", "description": "idk just testing out some stuff", "tags": ["distortion"], "likes": 0, "viewed": 119, "published": 3, "date": "1692557607", "time_retrieved": "2024-07-30T17:37:57.353441", "image_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 EulToPol(vec2 uv){return vec2(length(uv),atan(uv.y,uv.x)); }\nvec2 PolToEul(vec2 pol){return vec2(pol.x*cos(pol.y),pol.x*sin(pol.y));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 inuv = uv;\n    \n    uv=EulToPol(uv-.5);\n    uv.x=fract((uv.x-iTime/10.)*10.);\n    uv=PolToEul(uv);\n\n    \n    vec3 col;\n    col.rgb = texture(iChannel0, (uv/2.+.5)  ).rgb;\n\t//col.rgb = texture(iChannel0,inuv).rgb+col.rgb*0.1;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 117], [119, 119, 142, 142, 184], [185, 185, 209, 209, 257], [259, 259, 316, 366, 697]], "test": "untested"}
{"id": "clXBR8", "name": "Berbuih", "author": "zhonkvision", "description": "Inspired by \"Buehbossa\"", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 6, "viewed": 176, "published": 3, "date": "1692557373", "time_retrieved": "2024-07-30T17:37:58.103435", "image_code": "precision highp float;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = cos(abs(fract(pi * 5.0)));\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) - pi * r;\n    float n = pi2 / r * r;\n    a = cos(fract(floor(a * n) * n));\n    return p * rot(-a);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x - 5.0, 10.0) - 5.0;\n    p1.y = mod(p1.y - 5.0, 10.0) - 5.0;\n    p1.z = mod(p1.z, 32.0) - 2.0;\n    p1.xy = pmod(p1.xy, 5.0);\n    return sphere(p1, 2.0); // Adjust the sphere radius to create the globe shape\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(1.3 * sin(iTime * 1.8), 1.4 * cos(iTime * 0.3), -6.0 * -iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist * 3.0);\n        if (mod(length(pos) + 10.0 * iTime, 20.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.001, acc * 0.0041 + acc2 * 0.005, acc * 0.012 + acc2 * 0.005);\n    fragColor = vec4(col, 3.0 - t * 0.03);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 109], [186, 186, 214, 214, 344], [346, 346, 377, 377, 405], [407, 407, 437, 437, 682], [684, 684, 739, 739, 1642]], "test": "untested"}
{"id": "Ws3fDH", "name": "Torques", "author": "emymin", "description": "Infinite Space of Torques and some bubbles crawling along them idk\n\nUsing https://www.shadertoy.com/view/WtGXDD raymarching template", "tags": ["raymarching"], "likes": 10, "viewed": 150, "published": 3, "date": "1692557123", "time_retrieved": "2024-07-30T17:37:58.874374", "image_code": "\n#define MAX_STEPS 1000\n#define MAX_DIST 100000.\n#define SURF_DIST .001\n#define PI 3.14159\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat repeat(float x, float margin){\n    return (mod(x+0.5*margin,margin)-0.5*margin);\n}\n\nvec2 repeat_id(float x, float margin){\n    float p = mod(x+0.5*margin,margin)-0.5*margin;\n    float id = floor((x+0.5*margin)/margin);\n    return vec2(p,id);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat archimedes(vec3 p){\n    p.y = repeat(p.y,2.);\n    p.xz = p.xz*Rot(p.y*PI*0.5);   \n    float d = sdBox(p, vec3(1));\n    return d-.5;\n}\n\nvec2 GetDist_id(vec3 p) {\n    vec2 ax = repeat_id(p.x,20.);\n    vec2 az = repeat_id(p.z,20.);\n    vec3 repeatedspace = vec3(ax.x,p.y,az.x);\n    vec3 randomoffsetspace = repeatedspace+vec3(0.,1.,0.)*Hash21(vec2(ax.y,az.y))*20.+vec3(0.,1.,0.)*(80.*Hash21(vec2(az.y,ax.y)) + iTime*-10.  );\n    randomoffsetspace.y = (repeat(randomoffsetspace.y,100.))/1.5;\n    float sphered = length(randomoffsetspace)-Hash21(vec2(ax.y,az.y))*8.;\n    float d=archimedes(repeatedspace);\n    float id=0.;\n    d=opSmoothUnion(d,sphered,2.5);\n    return vec2(d*.5,sphered/d);\n}\nfloat GetDist(vec3 p){\n\treturn vec2(GetDist_id(p)).x;   \n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float id=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dist = GetDist_id(p);\n        id = dist.y;\n        float dS = dist.x;\n        dO += dS*1.;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,id);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col;\n    vec3 ro = vec3(5.+sin(iTime/10.)*100., 0,5.+cos(iTime/10.)*100.);\n    //vec3 ro = vec3(10.,0,0);\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, ro+vec3(2.*PI,0,10), 1.);\n\n    vec2 result = RayMarch(ro, rd);\n    float d = result.x;\n    float id = result.y;\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n        col = clamp(mix(vec3(1,0,0),vec3(0,0,0),id/1000.),vec3(0,0,0),vec3(1,0,0));\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col += dif;\n        col *= 1.-(d/200.);\n            //col*=id/float(MAX_STEPS)*10.;\n            //col=vec3(id);\n    }\n    if(d<0.){col=vec3(0.5,0.5,0.5);}\n    col = pow(col, vec3(.4545));\t// gamma correction\n    //col=vec3(id);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 149, 149, 211], [213, 213, 235, 235, 329], [332, 332, 384, 384, 483], [485, 485, 521, 521, 573], [575, 575, 613, 613, 734], [736, 736, 765, 765, 846], [847, 847, 872, 872, 986], [988, 988, 1013, 1013, 1541], [1542, 1542, 1564, 1564, 1600], [1602, 1602, 1635, 1635, 1927], [1929, 1929, 1953, 1953, 2143], [2145, 2145, 2195, 2195, 2386], [2390, 2390, 2447, 2447, 3374]], "test": "untested"}
{"id": "dtsfRr", "name": "Easy Interactive Ripples", "author": "emymin", "description": "Simple implementation of 2D interactive ripples", "tags": ["2d", "water", "ripple"], "likes": 9, "viewed": 295, "published": 3, "date": "1692555080", "time_retrieved": "2024-07-30T17:37:59.756017", "image_code": "vec3 checkerboard(vec2 uv){\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 id = floor(uv*10.);\n    return mix(vec3(0.156,0.156,0.156),vec3(0.921,0.858,0.698),mod(id.x+id.y,2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 wave = texture(iChannel0,uv).xy; //ripple simulation is in Buffer A\n    \n    vec2 d = vec2(dFdx(wave.x),dFdy(wave.y));\n    float highlight = smoothstep(0.,.2,5.*dot(d,vec2(1.,-1.))); //tiny bit of lighting\n\n    fragColor = vec4(vec3(checkerboard(uv+wave)+highlight),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//simple GLSL implementation of interactive 2D water ripple effect based on this algorithm\n//https://web.archive.org/web/20160607052007/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n#define STRENGTH 1.0\n#define DAMPENING 0.99\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = vec2(dFdx(uv.x),dFdy(uv.y)); //size of pixels in UV space\n\n    float new = 0.;\n    float prev = texture(iChannel0, uv).r; //previous step, stored in r\n    float prev_prev = texture(iChannel0,uv).g; //previous previous step, stored in g\n    \n    //set mouse for interactivity\n    vec4 m = iMouse;\n    m.xy = m.xy/iResolution.xy;\n    if(m.z>0.0){\n        new = smoothstep(.01, 0., length(m.xy-uv)) * STRENGTH;\n    }\n        \n    //spread\n    new += texture(iChannel0,vec2(uv.x-offset.x,uv.y)).r + \\\n           texture(iChannel0,vec2(uv.x+offset.x,uv.y)).r + \\\n           texture(iChannel0,vec2(uv.x,uv.y-offset.y)).r + \\\n           texture(iChannel0,vec2(uv.x,uv.y+offset.y)).r - 2.;\n    //velocity\n    new = new - (prev_prev-.5)*2.;\n    //dampening;\n    new*=DAMPENING;\n    //clean at startup\n    new*=smoothstep(0.,1.,float(iFrame>=60));\n    //normalize\n    new = new * 0.5 + 0.5;\n    \n    fragColor = vec4(new,prev,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsfRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 181], [183, 183, 240, 240, 563]], "test": "untested"}
{"id": "dlsBRr", "name": "Handling Clicks", "author": "LeifMessinger", "description": "Green if inside the box, red if outside", "tags": ["mouse"], "likes": 1, "viewed": 112, "published": 3, "date": "1692554532", "time_retrieved": "2024-07-30T17:38:00.510001", "image_code": "//Macros from here https://www.shadertoy.com/view/llySRh\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. )                    // mouse down even: mouse button is down\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n\nconst bool PERSISTENT_MOUSE = false; //If you click in the rectangle, it'll stay green even if you drag it out.\n\nbool insideBox(vec2 bottomCorner, vec2 boxSize, vec2 position){\n    vec2 relativeDistanceFromCorner = position - bottomCorner;\n\n    return ((relativeDistanceFromCorner.x >= 0.0f) && (relativeDistanceFromCorner.x <= boxSize.x)) && ((relativeDistanceFromCorner.y >= 0.0f) && (relativeDistanceFromCorner.y <= boxSize.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 boxSize = vec2(50.0f, 100.0f);\n    vec2 boxPosition = vec2(100.0f, 50.0f);\n\n    float brightness = insideBox(boxPosition, boxSize, fragCoord)? 1.0f : 0.0f;\n\n    vec3 col;\n\n    if(mouseDown){\n        vec2 mouse = PERSISTENT_MOUSE? iMouse.zw : iMouse.xy;\n        if(insideBox(boxPosition, boxSize, abs(mouse))){\n            col = vec3(0.0f, brightness, 0.0f);\n        }else{\n            col = vec3(brightness, 0.0f, 0.0f);\n        }\n    }else{\n        col = vec3(brightness, brightness, brightness);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlsBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[503, 503, 566, 566, 823], [825, 825, 882, 882, 1453]], "test": "untested"}
{"id": "dtsBzn", "name": "Durian 24", "author": "zhonkvision", "description": "Inspired by \"Buah Durian\"", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 7, "viewed": 196, "published": 3, "date": "1692552816", "time_retrieved": "2024-07-30T17:38:01.664913", "image_code": "vec3 palette(float d) {\n    vec3 neonGreen = vec3(0.2, 1.0, 0.4); // Neon Green\n    vec3 darkerGreen = vec3(0.1, 0.3, 0.1); // Darker Green\n    return mix(neonGreen, darkerGreen, d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.2;\n    for (int i = 0; i < 8; ++i) {\n        float t = angle;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.89);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    \n    float durian = length(p.xy) - 0.2; // Create a circular durian shape\n    \n    return durian;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 100.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 100.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -100.0);\n    ro.xz = rotate(ro.xz, iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 184], [186, 186, 216, 216, 296], [298, 298, 317, 317, 635], [637, 637, 664, 664, 1046], [1048, 1048, 1103, 1103, 1529]], "test": "untested"}
{"id": "mtlBzn", "name": "Manggis", "author": "zhonkvision", "description": "Inspired by \"Buah Manggis\"", "tags": ["glsl", "zhonk", "zhonkvision", "vjloop"], "likes": 1, "viewed": 134, "published": 3, "date": "1692552792", "time_retrieved": "2024-07-30T17:38:03.763302", "image_code": "vec3 palette(float d) {\n    return mix(vec3(2.2, 0.7, 0.9), vec3(0.0, 0.0, 1.0), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    float angle = iTime * 0.05;\n    for (int i = 0; i < 8; ++i) {\n        float t = angle;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.89);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    \n    float manggis = length(p.xy) - 1.4; // Create a circular manggis shape\n    \n    return manggis;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 0.0; i < 64.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.5;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 100.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (400.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 70.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -180.0);\n    ro.xz = rotate(ro.xz, iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd);\n    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 86], [88, 88, 118, 118, 198], [200, 200, 219, 219, 541], [543, 543, 570, 570, 951], [953, 953, 1008, 1008, 1434]], "test": "untested"}
{"id": "mtsfRn", "name": "diamboy's simple perlin noise", "author": "Diamboy", "description": "simple perlin noise", "tags": ["perlinnoise"], "likes": 0, "viewed": 107, "published": 3, "date": "1692551208", "time_retrieved": "2024-07-30T17:38:04.703788", "image_code": "int rand(ivec2 c, int seed)\n{\n    int v = c.x * 2600676571 + c.y * 1340679673 + seed;\n    v = (v ^ (v >> 16)) * 0x45d9f3b;\n    v = (v ^ (v >> 16)) * 0x45d9f3b;\n    v = (v ^ (v >> 16));\n    return v;\n}\n\nfloat rand1(ivec2 c, int seed)\n{\n    return fract(float(rand(c, seed)) / 16777216.0);\n}\n\nvec2 rand2(ivec2 c, int seed)\n{\n    int r = rand(c, seed);\n    int t = rand(c + r, seed);\n    vec2 s = fract(vec2(r, t) / 16777216.0);\n    s.y *= 6.2831853;\n    return vec2(cos(s.y), sin(s.y)) * s.x;\n}\n\nfloat smoothermix(float a, float b, float x)\n{\n    return mix(a, b, x*x*x * (10.0 - 15.0*x + 6.0*x*x));\n}\n\nfloat perlin(vec2 c, int seed)\n{\n    const int ITERS = 5;\n    const float SCALE = 1.0 / (2.0 - pow(0.5, float(ITERS - 1)));\n    float total = 0.0;\n    \n    for (int i = 1; i < 1 << ITERS; i <<= 1)\n    {\n        vec2 s = c * float(i);\n        ivec2 ic = ivec2(floor(s));\n        vec2 fc = s - floor(s);\n    \n        vec2 g1 = rand2(ic + ivec2(0, 0), seed + i);\n        vec2 g2 = rand2(ic + ivec2(1, 0), seed + i);\n        vec2 g3 = rand2(ic + ivec2(0, 1), seed + i);\n        vec2 g4 = rand2(ic + ivec2(1, 1), seed + i);\n\n        float d1 = dot(g1, vec2(0, 0) - fc);\n        float d2 = dot(g2, vec2(1, 0) - fc);\n        float d3 = dot(g3, vec2(0, 1) - fc);\n        float d4 = dot(g4, vec2(1, 1) - fc);\n\n        float r = smoothermix(\n            smoothermix(d1, d2, fc.x),\n            smoothermix(d3, d4, fc.x),\n            fc.y\n        );\n        total += r / float(i);\n    }\n    return (total / SCALE) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 muv = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float r = perlin((uv - muv) * 8.0, int(iTime * 0.25));\n    fragColor = vec4(r,r,r,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtsfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 200], [202, 202, 234, 234, 289], [291, 291, 322, 322, 492], [494, 494, 540, 540, 599], [601, 601, 633, 633, 1517], [1519, 1519, 1576, 1576, 1803]], "test": "untested"}
{"id": "clsBzr", "name": "an AA test", "author": "rebelonion", "description": "an AA test", "tags": ["aa"], "likes": 0, "viewed": 78, "published": 3, "date": "1692546883", "time_retrieved": "2024-07-30T17:38:05.882636", "image_code": "\n// for slightly sharper aa, change line 11 to\n// pix = floor(pix) + smoothstep(0.0, 1.0, fract(pix) / fwidth(pix)) - 0.5;\n\nvoid mainImage(out vec4 col, in vec2 pix)\n{\n   // scale pixels 4-8x\n   pix /= sin(iTime * 0.4) * 2.0 + 6.0;\n\n   // apply aa algorithm\n   pix = floor(pix) + min(fract(pix) / fwidth(pix), 1.0) - 0.5;\n\n   // sample and return\n   col = texture(iChannel0, pix / iChannelResolution[0].xy);\n}\n", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 167, 191, 409]], "test": "untested"}
{"id": "dtfBzr", "name": "Weird Fractal", "author": "Lunasoldev", "description": "its a fractal i got by manipulating time and space", "tags": ["fractal", "weird"], "likes": 0, "viewed": 83, "published": 3, "date": "1692526342", "time_retrieved": "2024-07-30T17:38:06.834093", "image_code": "float Circle(vec2 uv, vec2 pos, float r, float blur) {\n    return smoothstep(r,r-blur-0.0001,length(uv-pos));\n}\n\nfloat Rectangle(vec2 uv, vec2 pos) {return 1.;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float d = length(uv);\n    uv*=sin(uv.x)*13.;\n    uv*=uv.y;\n    uv.x = fract(uv.x);\n    uv.y = fract(uv.y);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    col += vec3(uv.x,uv.y,uv.x*uv.y)*smoothstep(8., 0., Circle(uv,vec2(sin(iTime*5.*uv.x),cos(iTime*5.*uv.y)),1.,0.05)/(abs(x)+abs(y)));\n    col -= abs(x*y);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 111], [113, 113, 149, 149, 160], [162, 162, 219, 270, 809]], "test": "untested"}
{"id": "mlXBzr", "name": "Noise Curl Zoom", "author": "leon", "description": "zoomy", "tags": ["zoom"], "likes": 29, "viewed": 363, "published": 3, "date": "1692525920", "time_retrieved": "2024-07-30T17:38:07.979031", "image_code": "\n// Noise Curl Zoom\n// by Leon Denise\n// 2023/08/20\n\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec2 pos)\n{\n    vec3 p = vec3(pos, 0.);\n    float result = 0., a = .5;\n    for (int i = 0; i < 5; ++i, a /= 2.) {\n        p.z += result*.5;\n        result += gyroid(p/a)*a;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-R/2.)/R.y;\n    \n    // polar coordinates with scrolling log radius\n    p = vec2(atan(p.y, p.x), log(length(p))-iTime*.3);\n    \n    // curl noise\n    vec2 e = vec2(.001,0);\n    float x = (fbm(p+e.yx)-fbm(p-e.yx))/(2.*e.x);\n    float y = (fbm(p+e.xy)-fbm(p-e.xy))/(2.*e.x);\n    vec2 curl = vec2(x,-y);\n    \n    // shape from curl noise magnitude\n    float d = length(curl);\n    float px = fwidth(d); // AA by Fabrice Neyret\n    fragColor = vec4(ss(-px,px,d-2.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 140, 140, 179], [180, 180, 202, 202, 390], [392, 392, 449, 449, 937]], "test": "untested"}
{"id": "mlXBRr", "name": "2D curve plotter", "author": "lisyarus", "description": "A simple 2D curve plotter based on a curve equation. Uses pixel derivatives to make a curve of uniform width.", "tags": ["curve", "function", "plot"], "likes": 12, "viewed": 467, "published": 3, "date": "1692522794", "time_retrieved": "2024-07-30T17:38:09.114993", "image_code": "float f(float x, float y)\n{\n    // Circle\n    // return x * x + y * y - 1.0;\n    \n    // Hyperbola\n    // return x * x - y * y - 1.0;\n    \n    // Cut parabola\n    // return (x < sqrt(1.5)) ? y - x * x : y - 1.5;\n    \n    // Cubic\n    // return x * x * x - 2.0 * x - y;\n    \n    // Witch of Agnesi\n    // return (x * x + 1.0) * y - 1.0;\n    \n    // Three-leaved clover\n    return x * x * x * x + 2.0 * x * x * y * y + y * y * y * y - x * x * x + 3.0 * x * y * y;\n    \n    // Butterfly curve\n    // return pow(abs(x), 6.0) + pow(abs(y), 6.0) - x * x;\n    \n    // Sine\n    // return sin(x) - y;\n}\n\nfloat max2(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // const float scale = 100.0;\n    float scale = max2(abs(iMouse.xy - iResolution.xy * 0.5)) * 0.5;\n    vec2 p = (fragCoord - iResolution.xy * 0.5) / scale;\n    \n    float value = f(p.x, p.y);\n    \n    vec2 grad = vec2(dFdx(value), dFdy(value));\n    \n    float plot_alpha = smoothstep(1.5 * length(grad), 0.0, abs(value));\n    \n    vec2 pm = mod(p, vec2(1.0));\n    float grid_alpha = smoothstep(1.0 / scale, 0.0, min(min(pm.x, 1.0 - pm.x), min(pm.y, 1.0 - pm.y)));\n    \n    float x_axis_alpha = smoothstep(1.0 / scale, 0.0, abs(p.y));\n    float y_axis_alpha = smoothstep(1.0 / scale, 0.0, abs(p.x));\n        \n    vec3 color = vec3(1.0);\n   \n    color = mix(color, vec3(0.8), grid_alpha);\n    color = mix(color, vec3(1.0, 0.0, 0.0), x_axis_alpha);\n    color = mix(color, vec3(0.0, 0.0, 1.0), y_axis_alpha);\n    color = mix(color, vec3(0.0), plot_alpha);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 367, 593], [595, 595, 615, 615, 643], [645, 645, 702, 736, 1595]], "test": "untested"}
{"id": "dlffzn", "name": "loopless N-sided Prism intersect", "author": "me_123", "description": "Loopless A generalized ray-prism intersector for N number of sides.\nReturns the near distance and the normal.\n\nClick and drag for interaction.\nMouse X position controls the rotation.\nMouse Y position controls the number of sides.", "tags": ["3d", "raytracing", "intersection", "prism", "loopless", "intersector"], "likes": 8, "viewed": 170, "published": 3, "date": "1692521723", "time_retrieved": "2024-07-30T17:38:10.094375", "image_code": "\n// N-Sided Prism - Intersection\n// https://www.shadertoy.com/view/ssBcDD\n\n/**\n * A generalized ray-prism intersector for N number of sides.\n * Returns the near distance and the normal.\n *\n * Click and drag for interaction.\n * Mouse X position controls the rotation.\n * Mouse Y position controls the number of sides.\n * \n *   This shader computes the intersection by looping through each plane face\n * and checking whether it is a front or a back side, and assigning it to the\n * near or far intersection respectively.\n *   Then the hit mask is computed by comparing the near and far distances.\n * Is there a name for this property?)\n * \n *   For prisms with an even number of sides, it would be much more efficient\n * to use slab intersections instead, where the front and the backside is already known.\n * (i.e. Hexprism - intersection by iq: https://www.shadertoy.com/view/tljBWy)\n * \n *   I've been wondering if this can be applied to subdivisions of polyhedrons,\n * maybe with octahedrons or icosahedrons.\n *   Something like Geodesic tiling by tdhooper: https://www.shadertoy.com/view/llVXRd\n * but only with just planar faces.\n * \n *   Edit: I've just found out about this amazing shader.\n * Somebody has already done this 3 years ago T_T\n * Wish I'd seen it before writing all of these lol.\n * Looks like it's the same method but theirs is much more elegant. TT_TT\n * \n * Truncated Icosahedron by marian42: https://www.shadertoy.com/view/ltsfzN\n * \n**/\n\n#define MAX_SIDES 12\n\n#define AA 2\n\n#define MAX_DIST 1e3\n#define PI 3.14159265359\n\n#define rot2D(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec4 iPrism( vec3 o, vec3 d, float r, float he, int si )\n{\n    float s = float(si);\n    float is = 1./s;\n    float r2 = r*r;\n    if (abs(o.y) > he) {\n        float pl = -(o.y+he*sign(d.y))/d.y;\n        vec2 plp = o.xz+d.xz*pl;\n        float z;\n        if ((z=length(plp)) < r) {\n            float a = atan(plp.x, plp.y)+(PI*is)*mod(s+1.0, 2.0);\n            if (cos(PI*is)/cos(a-2.*PI*is*floor((s*a+PI)/(2.*PI)))>z/r) return vec4(pl, 0, -sign(d.y), 0);\n        }\n    }\n    float a = 2.0*(d.x*d.x+d.z*d.z);\n    float b = 2.*(o.x*d.x+o.z*d.z);\n    float disc = b*b - 2.*a*(o.x*o.x + o.z*o.z - r2);\n    if (disc < 0.0) return vec4(MAX_DIST);\n    disc = sqrt(disc);\n    a = 1./a;\n    float z = dot(o.xz, o.xz)>r2?(-b - disc)*a:0.0;\n    if (z < 0.0) return vec4(MAX_DIST);\n    vec2 p = o.xz+d.xz*z;\n    float an = (PI+atan(p.x, p.y));\n    float m = (PI*2.0)*is;\n    float x = (floor(an/m)+0.5)*m;\n    float fan = cos(x);\n    vec2 n = vec2(sqrt(1.-fan*fan)*sign(x-PI), -fan);\n    float nz =  -(dot(o.xz, n)-sqrt(2.+2.*cos(2.*PI*is))*0.5*r)/dot(d.xz, n);\n    if (abs(o.y+d.y*nz) > he) return vec4(MAX_DIST);\n    if (nz < z) return vec4(MAX_DIST);\n    if (nz > (-b + disc)*a) return vec4(MAX_DIST);\n    return vec4(nz, vec3(n.x, 0, n.y));\n}\n\nmat3 getCamMat(vec3 ro, vec3 lo)\n{\n    vec3 w = normalize(lo - ro);\n    vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float t = iTime * 0.4;\n    vec3 ro = vec3(0, 1.2, 1.8);\n    vec3 lo = vec3(0, 0, 0);\n    \n    //ro.yz *= rot2D(iMouse.z > 0. ? m.y * PI+PI*2./3. : 0.);\n    ro.yz *= rot2D(sin(t)*.15);\n    ro.xz *= rot2D(iMouse.z > 0. ? m.x * 2.*PI : t);\n    \n    float fn = iMouse.z > 0. ? m.y : (cos(iTime*PI/2.5)*0.5+0.5);\n    int n = int(fn * float(MAX_SIDES - 3)*.9999 + 3.);\n    \n    mat3 cm = getCamMat(ro, lo);\n\n    vec3 tot = vec3(0);\n    \n    #if AA > 1\n    for( int p=0; p<AA; p++ )\n    for( int v=0; v<AA; v++ )\n    {\n        vec2 o = vec2(float(p),float(v)) / float(AA) - 0.5;\n        vec2 pv = (2.0 * (fragCoord+o) - iResolution.xy) / iResolution.y;\n    #else\n        vec2 pv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    #endif\n        \n        vec3 col = vec3(0);\n\n        vec3 rd = normalize(cm * vec3(pv, 1.5));\n\n        vec4 d = iPrism(ro, rd,0.8, 0.8, n);\n\n        if (d.x < MAX_DIST)\n        {   \n            vec3 p = ro + rd*d.x;\n            vec3 n = d.yzw;\n            vec3 l = normalize(vec3(1., .6, .5));\n            \n            vec2 uv = abs(n.y) > .5 ? p.xz : vec2(atan(p.z, p.x)/PI*2., p.y*1.2);\n            \n            vec3 env = textureLod(iChannel0, reflect(rd, n), 3.).rgb*.6+.4;\n            float ch = mod(dot(floor(uv*2.5), vec2(1)), 2.)*.4+.6;\n            float dif = max(dot(n, l), .1);\n            col = vec3(.1, .2, .3)*.6 + vec3(.9, .8, .6)*dif*env*ch;\n        } else\n        {\n            col = vec3(0.12)*(1.-0.45*length(pv));\n        }\n\n        tot += col;\n    #if AA > 1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    tot = max(tot, vec3(0));\n    tot = tot / (1. + tot);\n    tot = pow(tot, vec3(1./2.2));\n    \n    tot += fract(sin(fragCoord.x*vec3(32,11,2)+fragCoord.y*vec3(3,31,21))*232.323)/255.;\n    \n    fragColor = vec4(tot, 1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlffzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1601, 1601, 1659, 1659, 2832], [2834, 2834, 2868, 2868, 3020]], "test": "untested"}
{"id": "msSyDc", "name": "Year of Truchets #052", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nsimple truchet - mouseable polar warp", "tags": ["2d", "mouse", "truchet"], "likes": 24, "viewed": 284, "published": 3, "date": "1692491684", "time_retrieved": "2024-07-30T17:38:10.994967", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #052\n    08/19/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.141592653\n#define PI2         6.283185307\n#define hue(a) .55 + .45 * sin(PI * (a+T*.5)  * vec3(1.,.75,.25) + vec3(0.051,0.663,0.973));\n\nfloat tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nfloat db = 2.;\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a) {return fract(sin(dot(a,vec2(27.609,57.583)))*43758.5453);}\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\nfloat box(vec2 p, vec2 b){ vec2 d = abs(p)-b;return length(max(d,0.))+min(max(d.x,d.y),0.);}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    mat2 r45 = rot(.785398);\n    mat2 r4z = rot(-.785398);\n    tspeed = T*.5;\n    tmod = mod(tspeed,12.);\n    \n    float t1 = lsp(00.,02.,tmod);\n    float t2 = lsp(03.,05.,tmod);\n    float t3 = lsp(06.,08.,tmod);\n    float t4 = lsp(09.,11.,tmod);\n    \n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    t3 = eoc(t3); t3 = t3*t3*t3;\n    t4 = eoc(t4); t4 = t4*t4*t4;\n    \n    ga1 = (t1*db)-(t3*db);\n    ga2 = (t2*db)-(t4*db);\n    ga3 = (t2*db)-(t3*db);\n    ga4 = (t3*db)-(t4*db);\n    \n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    vec2 vv = uv;\n\n    if(vv.x<.0) { uv*=5.; } else { uv.x-=.5; }\n\n    // mouse //\n    float x = M.xy==vec2(0) ? ga1 : ga1-(M.y/R.y*.5-.25);\n    float y = M.xy==vec2(0) ? ga2 : ga2-(M.x/R.x*.5-.25);\n\n    uv *= rot(T*.1+y+(M.y/R.y)*PI2);\n    \n    if(vv.x>.0) uv = vec2(log(length(uv)), atan(uv.y, uv.x))*.955;\n\n    //other good values//2.546;//1.273;//.955;//.636;//.3175;\n    \n    uv.x+=x+(M.x/R.x)*PI2;\n\n    float px = fwidth(uv.x); \n\n    // background patterns\n    float sc = vv.x>0. ? 5. : 15.;\n    vec2 f = fract((uv+vec2(T*.1,0))*sc)-.5;\n\n    float bp= length(f.x)-.25;\n    vec3  C = mix(vec3(.005),vec3(0.05),smoothstep(px,-px,bp));\n\n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float hs = hash21(id.xy);\n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    \n    if(hs>.5) q = vec2(-q.y,q); \n\n    float wd = .015, mv = .15+.1*sin(ga3+ga4);\n    vec2 q2 = q;\n\n    vec2 pq = length(q.xy-vec2(-.5,.5))<length(q.xy+vec2(-.5,.5))? q.xy-vec2(-.5,.5) : q.yx+vec2(-.5,.5);\n  \n    pq *= r45;\n    q2 *= r45;\n \n    // main pattern\n    float d = length(pq.x);\n    d=abs(d)-mv;\n\n    // posts\n    float b = length(abs(q)-.5)-(mv*1.5);\n    d = min(b,d);\n    d = max(d,-(b+.075));\n    float md = d;\n    \n    d=abs(d)-wd;\n    \n    // grid lines\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.01;\n    d2 = max(d2,-(b+.05));\n    vec3 clr = vec3(.4);\n    vec2 dq =q*r4z;\n    dq.x+=T*.1;\n    dq=fract(dq*5.)-.5;\n\n    vec3 clh = hue(uv.x*.3);\n    vec3 clx = (dq.x*dq.y>0.) ? clh : vec3(.0025);\n    \n    // color mixdown\n    C = mix(C,vec3(.15),smoothstep(px,-px,d2));\n\n    C = mix(C,C*.35,smoothstep(.075+px,-px,d-.015));\n    C = mix(C,clr,smoothstep(px,-px,d));\n    C = mix(C,vec3(.0025),smoothstep(px,-px,md));\n    C = mix(C,clx,smoothstep(px,-px,md+.075));\n    if(vv.x >-.004 && vv.x<.004) C=vec3(.2);\n    // gamma and output\n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msSyDc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[586, 586, 605, 605, 648], [649, 649, 671, 671, 729], [730, 730, 767, 767, 801], [802, 802, 821, 821, 848], [849, 849, 875, 875, 941], [943, 943, 984, 984, 3381]], "test": "untested"}
{"id": "ctXfzn", "name": "Voronoi doodle", "author": "lisyarus", "description": "A simple doodle rendering a Voronoi diagram", "tags": ["voronoi"], "likes": 10, "viewed": 397, "published": 3, "date": "1692479506", "time_retrieved": "2024-07-30T17:38:12.098018", "image_code": "vec2 randomInCell(ivec2 cell)\n{\n    // All random constants are produced by randomly pressing 4 keys on the numpad\n\n    vec2 result = vec2(\n        fract(sin(1275.0 * float(cell.x) + 7564.0 * float(cell.y))),\n        fract(sin(2134.0 * float(cell.y) + 8974.0 * float(cell.x)))\n    );\n    \n    // Wiggle the resulting point with time, but make sure it doesn't escape the cell\n    result.x += sin(3548.0 * float(cell.x) + 4789.0 * float(cell.y) + iTime) * min(result.x, 1.0 - result.x) * 0.8;\n    result.y += sin(3875.0 * float(cell.x) + 4554.0 * float(cell.y) + iTime) * min(result.y, 1.0 - result.y) * 0.8;\n    \n    return result;\n}\n\nvec3 cellColor(ivec2 cell)\n{\n    return vec3(\n        fract(sin(127.0 * float(cell.x) + 756.0 * float(cell.y))),\n        fract(sin(213.0 * float(cell.x) + 897.0 * float(cell.y))),\n        fract(sin(345.0 * float(cell.x) + 456.0 * float(cell.y)))\n    );\n}\n\nvec3 voronoiColor(vec2 fragCoord)\n{\n    const float cellSize = 128.0;\n    ivec2 cellId = ivec2(fragCoord / cellSize);\n    vec2 cellStart = vec2(cellId) * cellSize;\n    \n    float closest = 1e8;\n    float secondClosest = 1e8;\n    \n    vec3 color = vec3(0.0);\n    \n    for (int x = -1; x <= 1; ++x)\n    {\n        for (int y = -1; y <= 1; ++y)\n        {\n            vec2 cellPoint = cellStart + cellSize * randomInCell(cellId + ivec2(x, y)) + vec2(ivec2(x, y)) * cellSize;\n            float dist = distance(cellPoint, fragCoord);\n            if (dist < closest)\n            {\n                secondClosest = closest;\n                closest = dist;\n                color = cellColor(cellId + ivec2(x, y));\n            }\n            else if (dist < secondClosest)\n            {\n                secondClosest = dist;\n            }\n        }\n    }\n    \n    vec3 centerColor;\n    float oops = dot(color, vec3(1.0));\n    \n    if (oops < 1.0)\n        centerColor = vec3(0.1, 0.2, 0.3);\n    else if (oops < 2.0)\n        centerColor = vec3(0.2, 0.1, 0.2);\n    else\n        centerColor = vec3(0.1, 0.1, 0.2);\n    \n    //color = mix(vec3(0.1, 0.1, 0.2), vec3(1.0, 0.8, 0.5), 0.02 * closest);\n    color = mix(centerColor, vec3(1.0, 0.8, 0.5), pow(closest/100.0, 2.0));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    //float p = 1.0 + 2.0 * smoothstep(100.0, 110.0, distance(iMouse.xy, fragCoord));\n    float p = 1.5;\n    \n    for (int o = 0; o < 2; ++o)\n    {\n        float s = pow(2.0, float(o));\n        float w = pow(2.0, - p * float(o));\n        color += voronoiColor(fragCoord * s) * w;\n        weights += w;\n    }\n\n    fragColor = vec4(color / weights, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 114, 632], [634, 634, 662, 662, 888], [890, 890, 925, 925, 2169], [2171, 2171, 2226, 2226, 2639]], "test": "untested"}
{"id": "clXfRn", "name": "Pretty test", "author": "essexshade", "description": "Kishimisu tutorial: https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["fractal", "sdf", "tutorial", "intro", "repetition", "code", "youtube", "tuto", "creative"], "likes": 0, "viewed": 150, "published": 3, "date": "1692474354", "time_retrieved": "2024-07-30T17:38:12.964700", "image_code": "// cosine based palette, 4 vec3 params\nvec3 palette( float t){\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i < 4.0; i++)\n              \n    {uv = fract(uv * 1.5) -0.5;\n    \n    float d = length(uv) * exp(-length(uv0));\n    \n    vec3 col = palette(length(uv0) + (i * 0.4) + iTime * 0.4);\n    \n    d = sin(d*8. + iTime)/8.;\n    \n    d = abs(d);    \n    \n    d = pow(0.01 / d, 1.2);\n    \n    finalColor += col * d;}\n    \n    fragColor = vec4(finalColor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 62, 62, 232], [234, 234, 291, 291, 798]], "test": "untested"}
{"id": "DtXfRn", "name": "Three colored rings", "author": "lennon27", "description": "Three colored rings", "tags": ["colors"], "likes": 0, "viewed": 119, "published": 3, "date": "1692474231", "time_retrieved": "2024-07-30T17:38:13.765559", "image_code": "vec3 getCirclePixel(vec3 circleColor, float circleSize, float circleWidth, vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float distance = length(uv);\n    float circleDistance = abs(distance - circleSize);\n    \n    vec3 bgColor = vec3(1.0, 1.0, 1.0);\n    vec3 color = circleColor + bgColor * circleDistance;\n    color.x = step(circleWidth, color.x);\n    color.y = step(circleWidth, color.y);\n    color.z = step(circleWidth, color.z);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 blueCircle = getCirclePixel(vec3(0.0, 0.0, 1.0), 0.5, 0.075, fragCoord + vec2(130, 30));\n    vec3 redCircle = getCirclePixel(vec3(1.0, 0.0, 0.0), 0.5, 0.075, fragCoord + vec2(0, -20));\n    vec3 greenCircle = getCirclePixel(vec3(0.0, 1.0, 0.0), 0.5, 0.075, fragCoord + vec2(-130, 30));\n    \n    vec3 color = vec3(1.0, 1.0, 1.0);\n    if (color == vec3(1.0, 1.0, 1.0)) color *= blueCircle;\n    if (color == vec3(1.0, 1.0, 1.0)) color *= redCircle;\n    if (color == vec3(1.0, 1.0, 1.0)) color *= greenCircle;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 92, 92, 499], [501, 501, 556, 556, 1111]], "test": "untested"}
{"id": "DtfBRn", "name": "Deprecated: My 2nd Def. Shader", "author": "beans_please", "description": "My starting point for new shaders (not anymore)\nnew one coming soon", "tags": ["default", "shader", "utils", "common"], "likes": 1, "viewed": 126, "published": 3, "date": "1692473050", "time_retrieved": "2024-07-30T17:38:14.528519", "image_code": "vec2 screen_to_uv(vec2 coord)\n{\n    return (2. * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    vec3 col = vec3(uv, 0);\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nmat2 rotate_2d(float angle)\n{\n    return mat2(cos(angle), sin(angle), cos(angle + PI_OVER_2), sin(angle + PI_OVER_2));\n}\n\n/*____________________ End ____________________*/\n\n\n\n/*_______ Pseudo-Random Number Generator ______*/\n// Source: https://www.shadertoy.com/view/WdSSRt\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\n// Random uint from 0 to 2^32-1\nuint randomui()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return result;\n}\n\n// Random int from 0 to 2^31-1\nint randomi()\n{\n    return int(randomui() % 0x7FFFFFFFu);\n}\n\n// Random float from 0 to 1\nfloat random()\n{\n    return float(randomui()) / float(0xffffffffu);\n}\n\n// Generate two normally distributed random numbers using the\n// Box-Muller Transform.\n// https://www.baeldung.com/cs/uniform-to-normal-distribution\nvec2 random_gauss()\n{\n    float u1 = random();\n    float u2 = random() * TAU;\n    float temp = sqrt(-2. * log(u1));\n    return temp * vec2(cos(u2), sin(u2));\n    \n    // Unoptimized version\n    //float u1 = random();\n    //float u2 = random();\n    //return vec2(cos(TAU * u2), sin(TAU * u2)) * sqrt(-2. * log(u1));\n}\n\nvec2 random_unit_vec2()\n{\n    vec2 v = vec2(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_unit_vec3()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr == 0.)\n            i--;\n        else if (lensqr <= 1.)\n            break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.)\n            return v;\n    }\n    return v;\n}\n\n// Initialize with uvec2\nvoid prng_init(uvec2 seed)\n{\n    seed += uvec2(1317, 944573125);\n    seed *= 464973573u;\n    prng_state[0] = seed.x;\n    prng_state[1] = seed.y;\n    randomi();\n}\n\n// Initialize with uint\nvoid prng_init(uint seed)\n{\n    prng_init(uvec2(seed, 1));\n}\n\n// Initialize with vec3\nvoid prng_init(vec3 seed)\n{\n    seed += 3.49276101561702;\n    seed.xy *= (seed.z + 10.258);\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    randomui();\n}\n\n// Initialize with vec2\nvoid prng_init(vec2 seed)\n{\n    prng_init(vec3(seed, 1));\n}\n\n// Initialize with float\nvoid prng_init(float seed)\n{\n    prng_init(vec3(seed, 1, 1));\n}\n\n/*____________________ End ____________________*/\n\n\n\n// ...\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 111], [113, 113, 168, 168, 328]], "test": "untested"}
{"id": "mtjcDd", "name": "Artic Radar", "author": "hicster_rs", "description": "My implementation of the recommended shader practice of the book of shaders ch.08. \"Oblivion Radar\".", "tags": ["rotation", "learn"], "likes": 6, "viewed": 137, "published": 3, "date": "1692471192", "time_retrieved": "2024-07-30T17:38:15.289485", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535\n#define HALF_PI PI/2.\n#define DOUBLE_PI PI*2.\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n\n\nmat2 get_2d_rotation_matrix(float radian){\n    return mat2(cos(radian),-sin(radian),\n        sin(radian),cos(radian));\n}\nvec3 normalize_rgb(vec3 rgb) {\n    return rgb/255.;\n}\nvec3 normalize_rgb(int r, int g, int b) {\n    return vec3(float(r)/255., float(g)/255., float(b)/255.);\n}\n\n#define BACKGROUND_COLOR normalize_rgb(0x2e, 0x34, 0x40)\n#define BLUE normalize_rgb(0x81, 0xa1, 0xc1) // #81a1c1 or #50aadd\n#define WHITE normalize_rgb(0xec, 0xef, 0xf4) // #eceff4\n#define RED normalize_rgb(0xbf, 0x61, 0x6a) // #bf616a\n\nfloat noise(float x) {\n    return sin(x)*(sin(x*.3+2.)*1.5)*cos(x*2.+3.)*sin(x/2.+PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 rotating_uv = get_2d_rotation_matrix(iTime) * uv;\n    vec3 final_buffer = vec3(0.);\n\n    float d = length(uv);\n    float circles_df = smoothstep(0.06,.01,abs(sin(d*PI*4.))) + smoothstep(.0,.5,.03/abs(sin(d*PI*4.)));\n    float mask = smoothstep(1.12,1.08,d/PI*3.45); // mask to limit some elementds to render constrained, clip space\n    circles_df *= mask;\n    final_buffer = vec3(circles_df)*BLUE;\n    \n    float cross_mask = 1.-step(.005,abs(uv.y-uv.x));\n    uv = get_2d_rotation_matrix(-PI/2.) * uv;\n    cross_mask += 1.-step(.005,abs(uv.y-uv.x));\n    uv = get_2d_rotation_matrix(PI/2.) * uv;\n    cross_mask *= mask;\n    final_buffer += max(vec3(cross_mask)*WHITE-circles_df*.1,0.);\n\n    float sonar_mask = smoothstep(0.,1.,atan(rotating_uv.y,rotating_uv.x)-HALF_PI);\n    sonar_mask *= mask;\n    final_buffer += clamp(sonar_mask,0.,1.)*BLUE;\n\n    d = length(vec2(uv.x, uv.y+.54));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x+.08, uv.y+.6));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI+.08,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x+.06, uv.y+.75));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI-.06,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x-.18, uv.y+.92));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time-HALF_PI-.18,DOUBLE_PI)/2.),3.5)*RED;\n    d = length(vec2(uv.x+.38, uv.y-.26));\n    final_buffer += step(d,0.04)*pow(max(0.,1.-mod(u_time+.60,DOUBLE_PI)/2.),3.5)*RED;\n\n    d = length(vec2(uv.x+noise(u_time/2.)*.3-.45, uv.y+noise(u_time/2.+DOUBLE_PI)*.5-.2));\n    final_buffer += smoothstep(.01,0.005,abs(d-.05))*BLUE;\n    final_buffer += max(0.,step(abs(d/(fract(u_time*1.5))),0.35)-smoothstep(.35,.2,d/fract(u_time*1.5)))*BLUE;\n    final_buffer += step(d,0.03)*pow(max(0.,1.-abs(mod(u_time,.4)-.5)),pow(2.,2.5))*BLUE*mask;\n\n    d = length(vec2(uv.x-noise(u_time/2.+654.)*.8, uv.y-noise(u_time+897.)*.6-.02));\n    final_buffer += smoothstep(.01,0.005,abs(d-.05))*BLUE;\n    final_buffer += max(0.,step(abs(d/(fract((u_time+1.5)*1.5))),0.35)-smoothstep(.35,.2,d/fract((u_time+1.5)*1.5)))*BLUE;\n    final_buffer += step(d,0.03)*pow(max(0.,1.-abs(mod(u_time,.4)-.5)),pow(2.,2.5))*BLUE*mask;\n\n    d = length(uv);\n    rotating_uv = get_2d_rotation_matrix(sin(u_time*.325)/DOUBLE_PI) * uv;\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI-1.2))*(step(abs(d-1.2),.005)+smoothstep(0.02,0.,abs(d-1.2)))*WHITE;\n    rotating_uv = get_2d_rotation_matrix(sin(-u_time*.75)/DOUBLE_PI) * (get_2d_rotation_matrix(.5)*uv);\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI-1.3))*(step(abs(d-1.1),.005)+smoothstep(0.02,0.,abs(d-1.1)))*WHITE;\n    rotating_uv = get_2d_rotation_matrix(u_time*.075) * uv;\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI+.5356))*(step(abs(d-1.3),.005)+smoothstep(0.02,0.,abs(d-1.3)))*WHITE;\n    rotating_uv = get_2d_rotation_matrix(sin(-u_time*.5)/DOUBLE_PI) * (get_2d_rotation_matrix(PI)*uv);\n    final_buffer += vec3(step(0.,abs(atan(rotating_uv.y,rotating_uv.x))-HALF_PI-.8))*(step(abs(d-1.15),.005)+smoothstep(0.02,0.,abs(d-1.15)))*WHITE;\n\n    float colors_mask = (final_buffer.r + final_buffer.g + final_buffer.b) / 3.; \n    final_buffer += BACKGROUND_COLOR*(1.-colors_mask); \n    \n    fragColor = vec4(vec3(final_buffer),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 211, 211, 289], [290, 290, 320, 320, 343], [344, 344, 385, 385, 449], [688, 688, 710, 710, 776], [778, 778, 835, 835, 4339]], "test": "untested"}
{"id": "DljyDG", "name": "Breathing Fractal", "author": "beans_please", "description": "Drag to explore the complex universe!\n", "tags": ["fractal"], "likes": 6, "viewed": 185, "published": 3, "date": "1692469704", "time_retrieved": "2024-07-30T17:38:16.097325", "image_code": "vec2 screen_to_uv(vec2 coord)\n{\n    return 2.4 * (coord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\n// Returns a value in [0, 1] which will be fed to the color map\nfloat fractal(vec2 coord)\n{\n    vec2 uv = screen_to_uv(coord);\n    \n    // Number of iterations\n    const int max_iters = 120;\n    int iters;\n    \n    // Starting complex number\n    vec2 a = uv;\n    \n    // Constant to add in each iteration\n    vec2 c;\n    if (iMouse.z > .5)\n    {\n        vec2 m = .5 * screen_to_uv(iMouse.xy);\n        m /= sqrt(length(m));\n        c = m;\n    }\n    else\n    {\n        c = vec2(-0.756924804733 + .008 * cos(1.2 * iTime), 0.210445461405);\n    }\n    \n    while (iters++ < max_iters)\n    {\n        // a = a^2\n        a = vec2(a.x * a.x - a.y * a.y, 2. * a.x * a.y);\n        \n        // Add constant\n        a += c;\n        \n        // Break if a is too large\n        if (dot(a, a) > pow(1.25 + .25 * cos(iTime * 1.2), 2.))\n            break;\n    }\n    \n    // Return a value based on the number of iterations \n    // done before becoming too large.\n    return remap(\n        exp(-float(iters) / float(max_iters)),\n        1., exp(-1.),\n        0., 1.15\n    );\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Super sampling\n    float v = 0.;\n    {\n        const ivec2 ssaa_res = ivec2(4);\n        for (int y = 1; y <= ssaa_res.x; y++)\n        {\n            for (int x = 1; x <= ssaa_res.y; x++)\n            {\n                vec2 offs = vec2(float(x) / float(ssaa_res.x + 1), float(y) / float(ssaa_res.y + 1)) - .5;\n                v += fractal(frag_coord + offs);\n            }\n        }\n        v /= float(ssaa_res.x * ssaa_res.y);\n    }\n    \n    // Colormap\n    vec3 col = colormap(v);\n    col = mix(vec3(dot(col, vec3(1. / 3.))), col, 1.1);\n\n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "float remap(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat remap_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    return out_start + t * (out_end - out_start);\n}\n\nvec3 colormap(float x)\n{\n    vec3 c = vec3(1.0);\n    c = mix(c, 1.2 * vec3(0.3, 0.5, 0.8), remap_clamp(x, -1.0, -0.6, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.1, 0.02, 0.4), remap_clamp(x, -0.6, -0.25, 0.0, 1.0));\n    c = mix(c, vec3(0.0), remap_clamp(x, -0.25, 0.0, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.4, 0.1, 0.02), remap_clamp(x, 0.0, 0.25, 0.0, 1.0));\n    c = mix(c, 1.2 * vec3(0.8, 0.5, 0.3), remap_clamp(x, 0.25, 0.6, 0.0, 1.0));\n    c = mix(c, vec3(1.0), remap_clamp(x, 0.6, 1.0, 0.0, 1.0));\n    \n    c = pow(c, vec3(1.8));\n    c += vec3(0.03, 0.0, 0.02);\n    \n    return c;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 117], [119, 183, 210, 210, 1175], [1177, 1177, 1232, 1254, 1858]], "test": "untested"}
{"id": "mtjcWt", "name": "But Can It Run Crysis?", "author": "dean_the_coder", "description": "My small tribute to Crysis from Crytek.\n(Apologies - This might be a bit GPU-heavy...?)", "tags": ["3d", "raymarching", "reflections"], "likes": 54, "viewed": 1334, "published": 3, "date": "1692460037", "time_retrieved": "2024-07-30T17:38:17.309086", "image_code": "// 'But Can It Run Crysis?' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/mtjcWt (YouTube: https://youtu.be/rsIRB3Gxtwc)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// My small tribute to Crysis from Crytek.\n//\n// Buffer A - All the Good Stuff.\n//   Check out usages of 'g' (line 30) to see how the glow effect was added.\n//   The sdf() function is where most of the modelling is done. (Lots of domain mirroring/etc)\n//   I use a float for each material ID, where the floating point component\n//   represents how reflective the material is - Very handy for tweaking the\n//   material properties.\n// Buffer B - Small amount of fish eye lens distortion.\n// This buffer - Film grain and lens dust.\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - SDF fine details only modelled when ray is near a surface.\n//   - Using bump maps over SDF displacement where possible.\n//     (Displacing an SDF is much more expensive at the code is\n//     ever time the ray moves, whereas a bump is only applied once\n//     when the ray has hit a surface.)\n//   - Lots of domain repetition (missiles, the '80' segments, etc)\n//   - Shadows don't appear much in this scene (it's mostly ambient occlusion)\n//     so the shadow marching code returns early for large areas of the scene.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define CHROMATIC 0.003\n\n// Thnx Dave_Hoskins\nvec2 h22(vec2 p)\n{\n\tvec3 v = fract(p.xyx * vec3(.1031, .1030, .0973));\n    v += dot(v, v.yzx + 333.33);\n    return fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h21(vec2 p) {\n    p += 353.627;\n    vec3 p3  = fract(p.xyx * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat film(vec2 uv) {\n    // Film grain.\n    float c = (h21(uv * iResolution.xy) - 0.5) / 128.;\n\n    // Lens dust.\n    uv *= 4.;\n    float sm = 0.1;\n    for (int i = 0; i < 3; i++, uv++) {\n        vec2 p = fract(uv) - 0.5, id = floor(uv);\n        float s = h21(id) * sm;\n        p += h22(id) * (1.0 - sm) * 0.5;\n        float f = smoothstep(s, s * 0.5, length(p)) * 0.025;\n        f = max(0.0, f - smoothstep(s, s * 0.5, length(p - vec2(-0.01, 0.02))) * 0.015);\n        c = max(c, f * clamp(iTime, 0., 1.));\n        sm *= 0.5;\n        uv *= 2.282;\n    }\n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Chromatic aberration.\n    vec2 ca = (uv - 0.5) * CHROMATIC;\n\n    fragColor = vec4(\n                    texture(iChannel0, uv + ca).r,\n                    texture(iChannel0, uv).g,\n                    texture(iChannel0, uv - ca).ba);\n                    \n    fragColor += film(uv * vec2(1, iResolution.y / iResolution.x));\n        \n    // Color correction.\n    fragColor = pow(fragColor, vec4(0.4545));\n        \n    // Vignette.\n    uv -= 0.5;\n    fragColor *= 1.0 - 0.4 * dot(uv, uv);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34514, "src": "https://soundcloud.com/giammarco-simonelli/crysis-2-epilogue-main-theme?si=4f570f1d38a64e14bd0988020691545a&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// 'But Can It Run Crysis?' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/mtjcWt (YouTube: https://youtu.be/rsIRB3Gxtwc)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// My small tribute to Crysis from Crytek.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t2e-4\n#define START_DIST\t1.\n#define MAX_DIST\t140.\n#define MAX_STEPS\t120.\n#define MAX_RDIST\t80.\n#define MAX_RSTEPS\t52.\n#define SHADOW_STEPS\t25.\n#define AO_STRENGTH\t.5\n#define LIGHT_RGB\tvec3(2, 1.6, 1.4)\n#define YELLOW_LIGHT_RGB\tvec3(10, 5, 2)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(int(iTime), 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S\tsmoothstep\n#define S01(a)\tS(0., 1., a)\n\nfloat t,\n      fade = 1.;\nvec2 g;\nvec3 lp;\nstruct Hit {\n\tfloat d, id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, float id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nvoid Uh(inout Hit h, Hit h2) { U(h, h2.d, h2.id, h2.p); }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat sum3(vec3 v) { return dot(v, vec3(1)); }\n\nfloat mul3(vec3 v) { return v.x * v.y * v.z; }\n\n///////////////////////////////////////////////////////////////////////////////\n// Hash/noise functions (Thnx Dave_Hoskins, Shane, iq)\nfloat h11(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 3.3456;\n\treturn fract(p * (p + p));\n}\n\nfloat h31(vec3 p) {\n\tp = fract(p * .3183099 + .1);\n\tp *= 17.;\n\treturn fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat h21(vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .11369, .13787));\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat n21(vec2 p) {\n\tvec2 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(h21(i), h21(i + vec2(1, 0)), f.x), mix(h21(i + vec2(0, 1)), h21(i + 1.), f.x), f.y);\n}\n\nfloat n31(vec3 p) {\n\tvec3 i = floor(p),\n\t     f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(mix(mix(h31(i), h31(i + vec3(1, 0, 0)), f.x), mix(h31(i + vec3(0, 1, 0)), h31(i + vec3(1, 1, 0)), f.x), f.y), mix(mix(h31(i + vec3(0, 0, 1)), h31(i + vec3(1, 0, 1)), f.x), mix(h31(i + vec3(0, 1, 1)), h31(i + 1.), f.x), f.y), f.z);\n}\n\nfloat fbm2(vec2 p) {\n\tint octaves = 4;\n\tfloat roughness = .5,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n21(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nfloat fbm(vec3 p) {\n\tint octaves = 4;\n\tfloat roughness = .5,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      tot = 0.;\n\troughness = sat(roughness);\n\twhile (octaves-- > 0) {\n\t\tsum += amp * n31(p);\n\t\ttot += amp;\n\t\tamp *= roughness;\n\t\tp *= 2.;\n\t}\n\treturn sum / tot;\n}\n\nfloat musgraveFbm(vec3 p) {\n\tfloat octaves = 5.,\n\t      sum = 0.,\n\t      amp = 1.,\n\t      pwMul = pow(3., 0.);\n\twhile (octaves-- > 0.) {\n\t\tfloat n = n31(p) * 2. - 1.;\n\t\tsum += n * amp;\n\t\tamp *= pwMul;\n\t\tp *= 3.;\n\t}\n\treturn sum;\n}\n\nvec3 rxz(vec3 p) {\n\tp.xz *= mat2(8e-4, 1, -1, 8e-4);\n\treturn p;\n}\n\nvec3 dx(vec3 p) {\n\tp.x += -5.;\n\treturn p;\n}\n\nvec3 dy(vec3 p, float e) {\n\tp.y += e;\n\treturn p;\n}\n\nvec3 dz(vec3 p, float e) {\n\tp.z += e;\n\treturn p;\n}\n\nvec3 ax(vec3 p, float d) { return vec3(abs(p.x) - d, p.yz); }\n\nvec3 ay(vec3 p) { return vec3(p.x, abs(p.y) - 5.3, p.z); }\n\nvec3 az(vec3 p, float d) { return vec3(p.xy, abs(p.z) - d); }\n\nfloat rep(float p) { return p - 4. * floor(p / 4. + .5); }\n\nvec2 opModPolar(vec2 p, float n) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.x, p.y) + angle, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat box2d(vec2 p, vec2 b) {\n\tvec2 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max2(q), 0.);\n}\n\nfloat boxFrame(vec3 p, vec3 b, float e) {\n\tp = abs(p) - b;\n\tvec3 q = abs(p + e) - e,\n\t     v1 = vec3(q.xz, p.y),\n\t     v2 = vec3(q.xy, p.z),\n\t     v3 = vec3(q.yz, p.x);\n\treturn min(min(length(max(v3, 0.)) + min(max3(v3), 0.), length(max(v1, 0.)) + min(max3(v1), 0.)), length(max(v2, 0.)) + min(max3(v2), 0.));\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat tor(vec3 p) {\n\tconst vec2 r = vec2(12.2, .15);\n\treturn length(vec2(length(p.xz) - r.x, p.y)) - r.y;\n}\n\nfloat pyramid(vec3 p) { return (sum3(abs(p)) - 16.) * .57735027; }\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(-9, 0, 100) - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 skyCol(float y) {\n\tvec3 c = pow(vec3(max(1. - y * .5, 0.)), vec3(6, 3, 1.5)) * vec3(.95, 1, 1) * (1. - pow(vec3(2), -vec3(35, 14, 7)));\n\tc *= mix(vec3(1), vec3(1, .5, .4), sin(t * .2) * .5 + .5);\n\treturn c * .03;\n}\n\nvec3 sky(vec3 rd) {\n\tvec3 p,\n\t     col = skyCol(rd.y);\n\tfloat den,\n\t      d = 10. / rd.y;\n\tif (d < 0.) return col;\n\tp = rd * d + vec3(1, .2, 1) * t * .2;\n\tp.xz *= .2;\n\tden = 1.;\n\tfor (int i = 0; i < 3; i++)\n\t\tden *= exp(-.06 * fbm(p));\n\n\treturn mix(col, LIGHT_RGB * .05, S(.9, 1., den) * (1. - sat(d / MAX_DIST)));\n}\n\nfloat fakeEnv(vec3 n) {\n\t// Thanks Blackle.\n\treturn length(sin(n * 2.5) * .5 + .5) / 1.73205;\n}\n\n// Shameless self-promotion. :)\nvoid dtc(vec2 p, inout vec3 c) {\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) {\n\t\tc += vec3(.7, .6, .5);\n\t\treturn;\n\t}\n\n\tfloat f,\n\t      dc = step(.5, -p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\tif (dc > 0.) c += vec3(.5, .3, .05);\n}\n\nfloat texAluminium(vec3 p) { return S(-1., 1., fbm(p * 7. * musgraveFbm(p * 4.6))); }\n\n// ID.Reflectivity\n#define SKY_ID\t0.\n#define WALL_ID\t2.\n#define GROUND_ID\t3.1\n#define CONCRETE_ID\t4.\n#define GLASS_ID\t5.1\n#define RED_DOOR_ID\t6.\n#define GUN_METAL_ID\t7.\n#define ALI_ID\t8.\n#define WLIGHT_ID\t9.\n#define YLIGHT_ID\t10.\n#define MISSILE_ID\t11.\n\nHit window(vec3 p) {\n\t// Platform.\n\tHit h = Hit(box(dy(p, 9.5), vec3(14, 1, 16)), CONCRETE_ID, p);\n\tif (h.d > 12.) return h;\n\n\t// Safety rail (Safety Is Important)\n\tU(h, boxFrame(ax(dx(p), 0.) + vec3(-4, 7, 15), vec3(4.1, 2, 0), .2), ALI_ID, p);\n\n\t// Window frames.\n\tfloat f = S(.6, .4, abs(p.x)) + S(.8, 1., abs(p.y + 3.) - 1.5);\n\tp.xz *= mat2(.70739, .70683, -.70683, .70739);\n\tf += S(.4, .2, min(abs(p.x), abs(p.z)));\n\n\t// Windows.\n\tU(h, max(pyramid(p), p.y - 1.) - sat(f) * .1, bool(f) ? WALL_ID : GLASS_ID, p);\n\th.d *= .9;\n\treturn h;\n}\n\nfloat door(vec3 p) {\n\tfloat d = box(p, vec3(1.6, 3.2, .1)) - .4;\n\td -= .1 * S(.3, .2, abs(abs(abs(p.x) - .5) - .5)) * S(.6, .5, abs(abs(abs(p.y) - 1.7) - .7));\n\treturn d;\n}\n\nHit missiles(vec3 p) {\n\tp.y += 6.75;\n\tHit h = Hit(boxFrame(az(dz(p, -1.), 1.2), vec3(2.4, 1.7, 1.3), .1), ALI_ID, p);\n\tfloat d,\n\t      f = max(0., -p.z - 2.);\n\tf = 1. - pow(f, 2. + f);\n\tf *= S(5., 1., -p.z);\n\tf += .05 * (S(4.45, 4.5, p.z) - S(.05, 0., abs(p.z - 4.65)));\n\tp.xy = abs(p.xy) - .75;\n\tp.x = abs(p.x) - .75;\n\td = cyl(p, vec2(.7 * f, 5));\n\td = max(d, -3. - p.z);\n\tU(h, d * .7, MISSILE_ID, p);\n\treturn h;\n}\n\nHit eighty(vec3 p) {\n\tfloat d,\n\t      ox = p.x - 6.6;\n\tp.x = abs(p.x - 6.6) - 6.6;\n\tp.y -= .5;\n\tvec3 q = p;\n\tif (ox < 0.) {\n\t\tq.y = abs(q.y) - 3.35;\n\t\tq.y = p.y < 0. ? abs(q.y - 1.) - 1.2 : abs(q.y - .6) - .4;\n\t}\n\telse {\n\t\tq.y = abs(q.y + .6) - 1.2;\n\t\tq.y = abs(q.y) - 2.36;\n\t\tq.y = abs(q.y) - 1.18;\n\t}\n\n\tq.x = abs(q.x) - .8;\n\tq.xy = opModPolar(q.xy, 8.);\n\tq.x -= 3.3;\n\tHit h = Hit(box(q, vec3(.55, 2, .4)), CONCRETE_ID, p);\n\td = box(q, vec3(.3, .8, .6)) - .1;\n\tU(h, d, WLIGHT_ID, p);\n\tg.x += .01 / (.2 + d * d);\n\treturn h;\n}\n\nHit sdf(vec3 p) {\n\t// Building wall.\n\tvec3 tp,\n\t     q = p - vec3(-14.5, 5, 70);\n\tfloat f,\n\t      d = box(dz(q, -10.), vec3(48.6, 13.5, 9.5));\n\td = abs(d) - .5;\n\n\t// Left doorway.\n\ttp = p + vec3(51, 4.6, -70);\n\tf = box2d(tp.xy, vec2(1.5, 2.8));\n\td = max(d, .5 - f);\n\td = min(d, max(abs(f - .5) - .1, abs(tp.z) - .5));\n\tHit h = Hit(d, WALL_ID, q);\n\n\t// Left door.\n\ttp.z -= 1.1;\n\ttp.xz *= mat2(.95534, .29552, -.29552, .95534);\n\ttp.x += 5.;\n\tf = fract((tp.y - .8) * .6);\n\tf = min(f, fract((tp.x - .9) * .6));\n\td = box2d(tp.xy - vec2(.1, 0), vec2(1.3, 3.1));\n\tf = max(f, d - .2);\n\tf = min(f, abs(d - .2));\n\td = box(tp, vec3(1.5, 3.2, .1)) - .4;\n\td = min(d, max(f - .05, abs(tp.z) - .7));\n\tU(h, d, RED_DOOR_ID, p);\n\ttp.x -= 2.2;\n\ttp = az(tp.xzy, 2.);\n\td = cyl(tp, vec2(.5, .1));\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Right doors.\n\ttp = p + vec3(18, 4.6, -70);\n\td = door(ax(tp, 7.));\n\ttp = az(tp.xzy, 2.);\n\ttp.x = abs(tp.x + 2.) - 7.;\n\td = min(d, cyl(tp, vec2(.5, .1)));\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Top doors.\n\tU(h, door(ax(p - vec3(22, 22.5, 77), 3.)), CONCRETE_ID, p);\n\n\t// Wall speaker.\n\ttp = p + vec3(16.6, -5, -70);\n\tf = max(length(tp.xz - vec2(.4 + .02 * sin(tp.y), -.05)) - .05, tp.y);\n\ttp.x = abs(tp.x + 20.) - 20.;\n\td = abs(length(tp.xy) - .4 + tp.z * .5) - .05;\n\td = max(d, -1. - tp.z);\n\td = min(d, length(dz(tp, .3)) - .3);\n\td = min(d, box(tp, vec3(.85, .85, .3)));\n\td = min(d, f);\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Random wires.\n\ttp = p + vec3(54.5, -5, -70);\n\tf = sign(tp.x);\n\ttp.x = abs(tp.x) - .2;\n\td = max(max(length(tp.xz) - .03, tp.y - 5.), f - 3. - tp.y);\n\tU(h, d, ALI_ID, p);\n\n\t// Wall bracket things.\n\ttp = p + vec3(16.6, -2, -70);\n\ttp.x = abs(tp.x) - 16.5;\n\ttp.x = abs(tp.x) - 11.;\n\ttp.x = abs(tp.x) - 1.7;\n\td = box(tp, vec3(1, .1, .5));\n\ttp.y -= .3;\n\td = min(d, box(tp, vec3(1, .3, .2)));\n\td = max(d, p.x - 11.);\n\tU(h, d, GUN_METAL_ID, p);\n\n\t// Spot lights.\n\ttp = ax(p + vec3(31, -9, -69.5), 20.);\n\ttp.y -= sign(p.x + 20.) * 4.;\n\ttp.yz *= mat2(.95534, .29552, -.29552, .95534);\n\tU(h, box(tp, vec3(1. - sat(tp.y + .6) * .9)), GUN_METAL_ID, p);\n\tf = S(.2, 4., -tp.y - max(.4, abs(tp.x * .6)));\n\ttp.y++;\n\td = box(tp, vec3(.8, .05, .8));\n\tU(h, d, YLIGHT_ID, p);\n\tg.y += S(71., 70., p.z) * .04 / (.05 + d * d) * f;\n\n\t// Top walls.\n\td = min(box(q - vec3(0, 0, 8), vec3(48.6, 24, 1)), box(q - vec3(-10, 0, 8), vec3(40, 40, 1)));\n\tU(h, d, WALL_ID, p);\n\n\t// Top-right tower thing.\n\td = box2d(q.xz - vec2(39, 4), vec2(3.5 - p.y * .05)) - 1.;\n\td = max(d, 30. - p.y);\n\tU(h, d, CONCRETE_ID, p);\n\n\t// Right walkway.\n\ttp = q - vec3(52.5, 3.6, 13);\n\tU(h, box(tp, vec3(4, .5, 15)), CONCRETE_ID, p);\n\ttp.y -= 2.;\n\ttp.z += 6.6;\n\tU(h, boxFrame(tp, vec3(3.6, 2, 8), .1), ALI_ID, p);\n\n\t// 80\n\tUh(h, eighty(q - vec3(17, 0, 0)));\n\n\t// Balconies.\n\ttp = q - vec3(7.8, 19.8, 6);\n\ttp = ay(tp);\n\tf = 7.01 + 8. * S(12., -40.8, tp.x);\n\td = box(tp, vec3(41.5, 2, f));\n\tif (q.y > 19.8) d = max(d, tp.x - 34.8);\n\tU(h, d * .95, CONCRETE_ID, q);\n\n\t// Balcony under-struts.\n\ttp = q;\n\ttp.x = rep(tp.x);\n\ttp.y = abs(tp.y - 17.8) - 5.25;\n\tU(h, max(d - 1., max(7. - tp.z - f, box(tp, vec3(.2, .2, 200)))), CONCRETE_ID, q);\n\n\t// Balcony spots.\n\ttp = p - vec3(-18, 32, 65.5);\n\tU(h, box(tp, vec3(3.5, 1, 1)), ALI_ID, p);\n\ttp = ax(ax(tp, 1.2), 1.2);\n\ttp.z += 1.3;\n\td = cyl(tp, vec2(.6, .05));\n\tU(h, d, WLIGHT_ID, p);\n\tg.x += .1 / (.3 + d * d * d) * S(.4, -.4, tp.z);\n\n\t// Ground.\n\tq.y += 13.5;\n\tU(h, max(q.y, q.z - 20.), GROUND_ID, p);\n\n\t// Ground wall.\n\tq.z -= 8.;\n\tU(h, box(q, vec3(200, 3.6, 1)), CONCRETE_ID, p);\n\n\t// Missiles.\n\tif (p.z > 40. && p.y < 0.) {\n\t\tUh(h, missiles(ax(ax(p - vec3(12, 0, 64), 2.8), 2.8)));\n\t\tUh(h, missiles(az(ax(rxz(p - vec3(1.5, 0, 52)), 3.), 25.)));\n\t\tUh(h, missiles(rxz(p - vec3(-23.5, 3.5, 55))));\n\t\tUh(h, missiles(ax(p - vec3(-10, 0, 52), 2.6)));\n\t}\n\n\t// Windows.\n\tq = p - vec3(-62, 28, 78);\n\tUh(h, window(q));\n\tq.y -= 10.6;\n\tUh(h, window(q));\n\n\t// Watch tower.\n\tq.y += 25.;\n\tq.yz = q.zy;\n\td = cyl(q, vec2(10, 5));\n\th.d = max(h.d, -d);\n\td = abs(d) - .15;\n\td = max(d, -box(dy(q, 18.5), vec3(10, 10, 1.6)));\n\tU(h, d, WALL_ID, p);\n\tq.z += 5.;\n\td = min(d, cyl(q, vec2(13, .35)));\n\tU(h, d, CONCRETE_ID, p);\n\tq.yx = opModPolar(q.yx, 22.);\n\td = max(cyl(dy(q, -12.2), vec2(.12, 3)), -q.z);\n\td = min(d, tor(dy(q.xzy, -3.)));\n\tU(h, d, ALI_ID, p);\n\n\t// Boaty McBoatface.\n\tq = p - vec3(65, -8, 93);\n\td = box(q, vec3(15, 5, 3));\n\td = max(d, -11. - q.x - q.y);\n\tf = length(q.xy - vec2(0, 63.5));\n\td = max(d, 60. - f);\n\td += S(60.5, 67., f);\n\td += S(60.5, 61., f) * .1;\n\tU(h, d, ALI_ID, p);\n\tq.x -= 5.;\n\td = box(q, vec3(5, 8, 1));\n\td = min(d, max(box(q, vec3(10, 7, 2)), -10. - q.x + q.y * .5)) + .05 * S(.1, 0., abs(q.y - 5.));\n\tU(h, d, CONCRETE_ID, p);\n\tq.x = abs(q.x + 1.) - 3.;\n\tq.x = abs(q.x) - 2.;\n\tq += vec3(1, -6, 2);\n\td = length(q);\n\tg.y += 1e-4 / (.001 + d * d);\n\n\t// Nothing is perfectly sharp.\n\th.d -= .01;\n\treturn h;\n}\n\nvec3 N(vec3 p, float d) {\n\tfloat h = d * .05;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdf(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tif (p.y > 20. || p.z < 40.) return 1.;\n    \n\tfloat s = 1.,\n\t      l = .01,\n\t      mxL = length(p - lp);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\tfloat d = sdf(l * ld + p).d;\n\t\ts = min(s, 7. * d / l);\n\t\tl += max(.05, d);\n\t\tif (mxL - l < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n) {\n\tconst vec3 h = vec3(2, 3, 5);\n\tvec3 ao;\n\tfor (int i = I0; i < 3; i++)\n\t\tao[i] = sdf(h[i] * n + p).d;\n\n\treturn sat(mul3((1. - AO_STRENGTH) + AO_STRENGTH * ao / h));\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, inout vec3 n, inout Hit h) {\n\tif (h.id == SKY_ID) return sky(rd);\n\tfloat _ao, sha,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, l, skyTop, col,\n\t     ld = normalize(lp - p);\n\n\t// Calculate ambient occlusion and shadows.\n\t_ao = ao(p, n);\n\tsha = shadow(p, ld, n);\n\tif (h.id == CONCRETE_ID || h.id == WALL_ID) {\n\t\tc = vec3(.55, .55, .65);\n\t\tfloat f = 0.;\n\t\tif (h.id == WALL_ID) {\n\t\t\t// Concrete slabs.\n\t\t\tf = fract(p.x * .08) - .5;\n\t\t\tc *= .6 + .2 * S(0., .012, abs(f));\n\t\t\tf = floor((p.x - 6.25) * .08);\n\t\t\tc *= 1. + .4 * (h11(f) - .5);\n\t\t\tf = floor(p.x - 6.25);\n\n\t\t\t// Me!\n\t\t\tdtc((p.xy + vec2(11, -.3)) * .6, c);\n\n\t\t\t// Damp.\n\t\t\tc *= .65 + .35 * S(0., 2., 13. + p.y - fbm2(vec2(p.x * .12, 1)) * 10.);\n\t\t}\n\n\t\tc *= texAluminium((p + f) * .015);\n\n\t\t// Dark footer.\n\t\tc *= .2 + .8 * S(0., .2, p.y + 7.8);\n\t}\n\telse if (h.id == GROUND_ID) {\n\t\tc = vec3(.05);\n\n\t\t// White/yellow stripe.\n\t\tfloat b, r,\n\t\t      f = S(1., .7, abs(p.z - 30. - p.x * .05));\n\t\tc += mix(vec3(.5, .25, 0), vec3(.5), S(0., .2, sin(p.x * .4))) * f;\n\n\t\t// Bump map a water effect.\n\t\tb = S(.6, .3, .75 * n21(p.xz * .1) + .25 * n21(p.xz * .3));\n\t\tf = mix(n31(p * 5.) * .4, n31(p * vec3(.7, 1, 3)), b);\n\t\tn.z += .15 * (f - .5);\n\n\t\t// Patchy puddles.\n\t\th.id = floor(h.id) + .01 + .08 * b + S(45., 80., p.z) * .3;\n\t\tc *= .4 + .6 * f;\n\n\t\t// Rain drops.\n\t\tr = h21(floor(p.xz * .3));\n\t\tf = length(fract(p.xz * .3) - .5);\n\t\tf = S(.95, 1., sin(f * 25. - (t + 10.) * r * 6.)) * S(.4, 0., f);\n\t\tf *= step(.6, r);\n\t\tf *= .2 + .8 * b;\n\t\tc *= 1. + f * f * 15.;\n\t\tn = normalize(n);\n\t}\n\telse if (h.id == RED_DOOR_ID) c = vec3(.6, .11, .1);\n\telse if (h.id == WLIGHT_ID) c = vec3(5);\n\telse if (h.id == YLIGHT_ID) c = YELLOW_LIGHT_RGB;\n\telse if (h.id == GUN_METAL_ID) c = vec3(.12, .12, .15);\n\telse if (h.id == ALI_ID) c = vec3(.3);\n\telse if (h.id == MISSILE_ID) {\n\t\tc = vec3(.05, .1, .05);\n\t\tc += S(4.45, 4.5, h.p.z) * .1;\n\t\tc.rg += .15 * S01(sin(h.p.z * 10.)) * step(h.p.z, -.8);\n\t}\n\telse {\n\t\tc = vec3(.1, .1, .05);\n\t\tshine = 7.;\n\t\tspe = 80.;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n\tdot(-ld.xz, n.xz),  // Reverse light.\n\tn.y // Sky light.\n\t));\n\tl.x *= fakeEnv(ld * 4.); // Light mask.\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl *= _ao; // Ambient occlusion.\n\tl *= vec3(1, .5, .2); // Light contributions (key, reverse, sky).\n\tl.x *= .1 + .9 * sha;\n\tskyTop = skyCol(1.);\n\tc += skyTop * (1. - sha) * .5;\n\tshine *= sha;\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine;\n\n\t// Light falloff.\n\tl.x *= dot(lp, lp) / (1. + dot(lp - p, lp - p));\n\n\t// Combine the lights (key, reverse, sky).\n\tcol = mix((sum2(l.xy) * LIGHT_RGB + l.z * skyTop) * c, skyTop, S(.6, 1., 1. + dot(rd, n)) * .25);\n\n\t// Distance Fog.\n\treturn mix(skyCol(0.), col, 1. - sat(S(65., 105., length(p.yz))));\n}\n\nfloat addFade() { return min(1., abs(t)); }\n\nvec3 march(vec3 ro, vec3 rd) {\n\tfade = addFade();\n\tlp = vec3(0, .001, -15);\n\tlp.yz *= mat2(.69671, -.71736, .71736, .69671);\n\tlp.xz *= mat2(.2675, -.96356, .96356, .2675);\n\n\t// March the scene.\n\tvec3 n,\n\t     p = ro,\n\t     col = vec3(0);\n\tfloat i,\n\t      d = START_DIST;\n\tHit h;\n\tg = vec2(0);\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\tif (d > MAX_DIST) {\n\t\t\th.id = SKY_ID;\n\t\t\tbreak;\n\t\t}\n\n\t\th = sdf(p);\n\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tcol += g.x * LIGHT_RGB;\n\tcol += g.y * YELLOW_LIGHT_RGB;\n\tn = N(p, d);\n\tcol += lights(p, ro, rd, n, h);\n    \n\tif (fract(h.id) > 0.) {\n\t\t// We hit a reflective surface, so march reflections.\n\t\tfloat refl = fract(h.id);\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tro = p;\n\t\td = .01;\n\t\tg = vec2(0);\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\tif (d > MAX_RDIST) {\n\t\t\t\th.id = SKY_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\th = sdf(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tcol += refl * g.x * LIGHT_RGB;\n\t\tcol += refl * g.y * YELLOW_LIGHT_RGB;\n\t\tn = N(p, d);\n\t\tcol += refl * (1. - col) * lights(p, ro, rd, n, h);\n\t}\n\n\treturn max(vec3(0), col);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tg = vec2(0);\n\tt = mod(iTime, 30.);\n\n\t// Camera.\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\tvec3 col,\n\t     ro = vec3(-10, 0, t * .7 - 10.);\n\n\t// View bob.\n\tro += sin(t * vec3(.9, .7, .3));\n\tcol = march(ro, rayDir(ro, uv));\n\tcol *= 1. + S(.97, 1., n21((uv + vec2(.1, 8) * t) * vec2(100, 2) * mat2(-.41615, .9093, -.9093, -.41615)));\n\tfragColor = vec4(col * fade, 0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define LENS 0.005\n\nvec2 fisheye(vec2 uv) {\n    uv -= 0.5;\n    uv *= pow(dot(uv, uv), LENS);\n    return uv + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Lens distortion.\n    uv = fisheye(uv);\n\n    fragColor = texture(iChannel0, uv);    \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjcWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1748, 1769, 1787, 1787, 1914], [1916, 1916, 1935, 1935, 2087], [2089, 2089, 2110, 2129, 2659], [2661, 2661, 2713, 2713, 3254]], "test": "untested"}
{"id": "DlBcWV", "name": "plasma_noise", "author": "DoomHunter", "description": "plasma", "tags": ["noise"], "likes": 9, "viewed": 213, "published": 3, "date": "1692457345", "time_retrieved": "2024-07-30T17:38:18.176765", "image_code": "const float PI2 = 6.283185;\nconst int MIN_DEPTH = 3;\nconst int MAX_DEPTH = 8;\n\n\nvec2 rotate_vec2 (in vec2 v, in float r, in vec2 pivod)\n{\n    float rad = r * PI2;\n    float s = sin(rad);\n    float c = cos(rad);\n    \n    return vec2((v-pivod) * mat2(c, s, -s, c)) + pivod;\n    \n    //return vec2(dot(v-pivod, vec2(c, s)),\n    //            dot(v-pivod, vec2(-s, c))) + pivod;\n}\n\n\n\n\nvec4 g2c(in vec2 p) \n{\n    float d = dot(p, vec2(123.34547, 321.5643));\n    vec4 f = vec4(4823.9471,5643.2356, 1045.3865, 8326.3953) / (d + 0.513254);\n    vec4 s = fract(sin(f * 4572.8462));\n    return s;\n}\n\n\n\n\n\nfloat noise(in vec2 uv, in float scale, in float disorder)\n{\n    vec2 g = uv * scale;\n    vec2 g_id = floor(g); \n    vec2 g_uv = g - g_id;\n    vec2 g_uv_inv = 1.0 - g_uv;\n    \n    \n    \n    vec3 cubx = vec3(g_uv.x, g_uv.x, g_uv_inv.x) * vec3(g_uv.x, g_uv_inv.x, g_uv_inv.x) * vec3(0.5, 1.0, 0.5) + vec3(0.0, 0.5, 0.0);\n    vec3 cuby = vec3(g_uv.y, g_uv.y, g_uv_inv.y) * vec3(g_uv.y, g_uv_inv.y, g_uv_inv.y) * vec3(0.5, 1.0, 0.5) + vec3(0.0, 0.5, 0.0);\n    \n    mat3 cubm = mat3(cubx.x*cuby.x, cubx.x*cuby.y, cubx.x*cuby.z,\n                    cubx.y*cuby.x, cubx.y*cuby.y, cubx.y*cuby.z, \n                    cubx.z*cuby.x, cubx.z*cuby.y, cubx.z*cuby.z);\n    \n    \n    \n    \n    vec4 n4 = g2c(g_id-vec2(0.0, 0.0))* cubm[0][0] + g2c(g_id-vec2(1.0, 0.0))* cubm[1][0] + g2c(g_id-vec2(2.0, 0.0))* cubm[2][0] +\n              g2c(g_id-vec2(0.0, 1.0))* cubm[0][1] + g2c(g_id-vec2(1.0, 1.0))* cubm[1][1] + g2c(g_id-vec2(2.0, 1.0))* cubm[2][1] +\n              g2c(g_id-vec2(0.0, 2.0))* cubm[0][2] + g2c(g_id-vec2(1.0, 2.0))* cubm[1][2] + g2c(g_id-vec2(2.0, 2.0))* cubm[2][2];\n   \n    return 1.0 - sqrt(length(rotate_vec2(n4.xy, disorder, vec2(0.5, 0.5)) - n4.zw));\n}\n\n\n\nfloat fract_noise(vec2 uv, float disorder, int minDepth, int maxDepth){\n\n    float fract_noise = 0.0;\n    \n    for( int i = minDepth; i < maxDepth; i++){\n    \n        float currentDepth2pow = pow(2.0, float(i - minDepth + 1));\n        float fi = float(i);\n        \n        fract_noise += noise(uv, pow(2.0, fi), disorder * currentDepth2pow) * (1.0 / currentDepth2pow);\n    }\n    return fract_noise;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / min(iResolution.x, iResolution.y);\n    float t = iTime / 2.0;\n    \n    float fbm = fract_noise(uv, t, MIN_DEPTH, MAX_DEPTH);\n    fbm = pow(fbm, 3.0);\n    \n    //float fbm = pow( 0.50000 * noise(uv, 8.000, t * 1.0) +\n    //                 0.25000 * noise(uv, 16.00, t * 2.0) +\n    //                 0.12500 * noise(uv, 32.00, t * 4.0) +\n    //                 0.06250 * noise(uv, 64.00, t * 8.0), 3.0);\n        \n    fragColor = vec4(vec3(fbm), 1.0) * vec4(3.0, 1.0, 0.5, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 137, 137, 376], [381, 381, 403, 403, 587], [593, 593, 653, 653, 1750], [1754, 1754, 1825, 1825, 2154], [2160, 2160, 2217, 2217, 2723]], "test": "untested"}
{"id": "cl2yDd", "name": "Collapsing neon flower", "author": "lennon27", "description": "My first shader", "tags": ["neon"], "likes": 5, "viewed": 161, "published": 3, "date": "1692454602", "time_retrieved": "2024-07-30T17:38:18.967650", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv); \n    float angle = atan(uv.y, uv.x) + sin(iTime) * d;\n    float squiggle = sin(angle * 5.0) * 0.08;\n    float subsquiggle = sin(angle * 10.0) * 0.03;\n    d += squiggle + subsquiggle;\n    \n    d = sin(d * 8.0 + iTime - sqrt(d) * 8.0) / 8.0;\n    d = 0.02 / abs(d);\n    \n    vec3 col = vec3(0.5, 0.8, 1.0);\n    col *= d;\n    col.z = col.z + 0.5 * squiggle + 0.05;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2yDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 550]], "test": "untested"}
{"id": "Dt2yWt", "name": "Circles_gyp", "author": "TinajXD", "description": "circles", "tags": ["circles", "colors", "first", "violet"], "likes": 2, "viewed": 141, "published": 3, "date": "1692443716", "time_retrieved": "2024-07-30T17:38:19.853283", "image_code": "vec3 palette(float t) {\n//http://dev.thi.ng/gradients/\n//\n    vec3 a = vec3(0.500, 0.500, 0.500);\n    vec3 b = vec3(0.500, 0.500, 0.500);\n    vec3 c = vec3(1.000, 1.000, 1.000);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n    \n    return a + b*cos(6.28*(c * t * d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    \n    \n    vec3 col = palette(d + iTime);\n    \n    \n    d = sin(d * 8.0 + iTime) / 8.0;\n    d = abs(d);\n    \n    d = 0.01 / d;\n    \n    \n    col *= d;\n    \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2yWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 57, 264], [267, 267, 324, 324, 616]], "test": "untested"}
{"id": "mtBcDd", "name": "Noise Splash Zoom", "author": "leon", "description": "zoo-min", "tags": ["zoom"], "likes": 21, "viewed": 297, "published": 3, "date": "1692441238", "time_retrieved": "2024-07-30T17:38:21.009192", "image_code": "\n// Noise Splash Zoom\n// by Leon Denise\n// 2023/08/19\n\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\n\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 5; ++i, a /= 2.) {\n        seed.z += result*.5;\n        result += abs(gyroid(seed/a)*a);\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-R/2.)/R.y;\n    float d = length(p);\n    p = normalize(p) * log(length(p)*.5);\n    p = vec2(atan(p.y, p.x), length(p)*.5+iTime*.5);\n    float shades = 6.;\n    float shape = ss(.9, .5, fbm(vec3(p*.5, 0.)));\n    float shade = ceil(shape*shades)/shades;\n    vec3 color = vec3(shade)*ss(2., .0, d);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtBcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 142, 142, 181], [183, 183, 206, 206, 377], [379, 379, 436, 436, 789]], "test": "untested"}
{"id": "dtByDd", "name": "instant histogram equalization", "author": "FabriceNeyret2", "description": "does realtime histogram equalization ( top right ).\nclick for quantization.\nBuffA: realtime histogram, adapted \"instant histogramming\" https://shadertoy.com/view/fsV3Dy\nBuffB: antiderivative of the histogram.", "tags": ["histogram", "gpmipmap"], "likes": 10, "viewed": 326, "published": 3, "date": "1692436714", "time_retrieved": "2024-07-30T17:38:21.888840", "image_code": "// input video in CubeA:buffA  + #define T()\n// adapted from \"instant histogramming\" https://shadertoy.com/view/fsV3Dy\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= R;\n    O *= 0.;\n    int i = int(U.x*256.);\n    O.r = step( U.y/64. , H(iChannel0, i ) ) ;          // histogram\n    O.b = step( U.y/64. , H(iChannel1, i ) ) ;          // anti-derivative\n    \n    if (U.x<.5 && U.y>.5)  O += texture(iChannel0,2.*U-1.).y;  // top left : draw source\n    if (U.x>.5 && U.y>.5) {                                    // top right: equalize histogram\n        i = int(255.9 * texture(iChannel0,2.*U-1.).y );\n        O +=   H(iChannel1, i ) \n             / H(iChannel1, 255) ;                      // sum of histogram\n    }\n    if (iMouse.z > 0.) O = floor(O*4.)/3.;              // compared quantizations\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// === histogram computation ===============================\n// from \"instant histogramming\" https://shadertoy.com/view/fsV3Dy :\n// isolate tiles following one given signal values in 8x8 tiles, 4 channels, 4 faces of a CubeMap.\n// use MIPmap to count the bits in this.\n// ( Coding-decoding locations in CubeMaps is always a nightmare )\n\n   #define T(U)  texture(iChannel0, (U)/128.).r   // Britney\n// #define T(U)  length(texture(iChannel0, (U)/128.).rgb)/1.7   // Britney\n// #define T(U)  texture(iChannel1, (U+iMouse.xy/R)/256.).r // white noise with interpolation offset\n// #define T(U)  texture(iChannel2, (U)/1024.).r  // Blue noise\n\nvoid mainCubemap( out vec4 O, vec2 U,  vec3 C, vec3 D )\n{\n    ivec2 I = ivec2(U)/128;                                      // tile bi-Id\n    vec3 A = abs(D);\n    int  f = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2,  // faceId\n         s = I.x + 8*I.y,                                        // tile Id\n         i = int(1023.* T( mod(U,128.) ) );                      // discretize signal\n    if ( D[f] < 0. ) f += 3;                                     // full face Id.\n    O = f<4 ? vec4( equal( ivec4(i), s + 64*ivec4(0,1,2,3) + 256*f )) // isolate one value within 256                                \n            : vec4(T(U/R*128.),0,0,0);                           //  2 useless : free to show the image ! \n // O = .5*vec4(  ( s + 64*ivec4(0,1,2,3) + 256*f) );    // cubeMap calibration\n}", "cube_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define H(ch,i) texelFetch(ch, ivec2((i)%16,(i)/16) ,0 ).x   // histogram(i)", "buffer_a_code": "// === ready-to-use histogram =======================\n// read histogram(i) with texelFetch(iChannel, ivec2(i%16,i/16) ,0 ).x  or H(ch,i)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = 1.-u/R;  O.y = texture(iChannel0,vec3(2.*U-1.,-1)).x; // source video\n    \n    if ( u.x > 16. || u.y > 16. ) return;        // we use only the 16x16 tile \n    \n    u -= .5;\n    int  v = int( 1024.*(u.x+16.*u.y)/256. ),    // histogram value 16x16 stored in:\n         f = (v/256 + 5 ) %6,                    //    face \n         c = (v%256)/64,                         //    color field\n         t =  v%64,                              //    tile id\n         x = t%8, y = t/8;                       //    tile coords\n    if (f>2) x = 7-x;\n    vec3 V = vec3( 2.* (vec2(x,7-y)+.5)/8. - 1., // location in cubeMap\n                   f > 2 ? -1 : 1 \n                );\n    if (f==0) V.y = -V.y;\n    if (f==3) V.x = -V.x;\n    f = f%3; if (f==2) V.z=-V.z;\n    V = f==0 ? V.xzy : f==2 ? V.zyx : V; \n    O.x = textureLod(iChannel0, V ,7.)[c];       // histogram\n    \n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === ready-to-use antiderivative of the histogram ==================\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if ( u.x > 16. || u.y > 16. ) return;        // we use only the 16x16 tile \n    \n    u -= .5;\n    int p = int(u.x) + 16*int(u.y);\n    float s = 0.;\n    for (int i = 0; i <= p; i++ )\n        s += H( iChannel0, i );\n\n     O.x = s / 64.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtByDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 158, 158, 799]], "test": "untested"}
{"id": "dlScDt", "name": "Water Toon Torrent", "author": "leon", "description": "be water my friend", "tags": ["water", "npr"], "likes": 80, "viewed": 1558, "published": 3, "date": "1692427495", "time_retrieved": "2024-07-30T17:38:23.105587", "image_code": "// Water Toon Torrent\n// by Leon Denise\n// 2023/08/19\n\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\n\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 6; ++i, a /= 2.) {\n        seed.x += iTime*.01/a;\n        seed.z += result*.5;\n        result += gyroid(seed/a)*a;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-R)/R.y;\n    float count = 2.;\n    float shades = 3.;\n    float shape = abs(fbm(vec3(p*.5, 0.)))-iTime*.1-p.x*.1;\n    float gradient = fract(shape*count+p.x);\n    vec3 blue = vec3(.459,.765,1.);\n    vec3 tint = mix(blue*mix(.6,.8,gradient), vec3(1), round(pow(gradient, 4.)*shades)/shades);\n    vec3 color = mix(tint, blue*.2, mod(floor(shape*count), 2.));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlScDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 142, 142, 181], [183, 183, 206, 206, 403], [405, 405, 462, 462, 880]], "test": "untested"}
{"id": "ctSyDd", "name": "GLSL Function Profiler", "author": "01000001", "description": "A tool to help compare the performance of various functions! See common tab for instructions on how to use this shader. \n\nScore means the number of function calls possible per pixel, maintaining 50 fps. Bonus: Fully functional in thumbnail!", "tags": ["utility", "debug", "tool"], "likes": 6, "viewed": 131, "published": 3, "date": "1692405217", "time_retrieved": "2024-07-30T17:38:24.087960", "image_code": "\n\n\n\n\n        // See Common for instructions on how to use.\n\n\n\n\n// Thanks to https://www.shadertoy.com/view/4sBfRd\n#define C(c) O+= char(U,c).x; U.x-=.45;\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    O = texture(iChannel0, U/iResolution.xy);\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    float x;\n    \n    \n    \n    \n    //// OVERLAYS ////\n    \n    // You can change these values as you please to move \n    // the white markers. They are useful to compare results\n    // The higher the blue bar, the better the performance\n    // of the function you're testing.\n    \n    x = .42;    \n\n    O += smoothstep(8./r.y, 0., abs(x-uv.y)) * (uv.x > .8?1.:0.);\n\n    x = .32;    \n\n    O += smoothstep(8./r.y, 0., abs(x-uv.y)) * (uv.x > .8?1.:0.);\n\n    x = .8;    \n\n    O += smoothstep(8./r.y, 0., abs(x-uv.y)) * (uv.x > .8?1.:0.);\n    \n    \n    \n    // This displays the number of function calls\n    \n    U = U/iResolution.y * 8.;\n    float s = texture(iChannel0, r-r).x;\n    for (float i = 7.; i >= 0.; i--){\n        C(48 + int(s / pow(10., i))%10);\n    }\n    \n    U.x += 3.4;\n    U.y -= .8;\n    U *= 2.;\n    C(64+19);C(96+3);C(96+15);C(96+18);C(96+5);C(58);\n    \n    if (texture(iChannel0, r-r).z > averagingTime) O = O.xzyw;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U-r)/r.y;\n    int samples = 1;\n    \n    vec4 data = texture(iChannel0, r-r);\n        \n    O = vec4(0); // Initialize stuff for safety\n    if (iFrame < 20){\n        return;\n    } else { \n        samples = int(data.x); // Only read if we're fairly sure it's initialized\n    }\n    \n    if (U == vec2(.5)){\n    \n        O.x = max(100., data.x) * (iFrameRate > 50.?1.01:0.99);\n        O.z = max(1., data.z);\n        \n        if (iFrameRate < 50. || O.z > 50.){ // Start tracking average samples once you hit the limit\n\n            if (O.z > averagingTime){\n                O.xy = data.yy;\n                // Once we've been past the limit for a while, stop adjustments.\n            } else {\n                O.y = mix(data.y, O.x, 1e-3 + 1./O.z);\n                O.z ++;\n            }\n            \n        }\n\n        return;\n    }\n    \n    if (data.z > averagingTime){\n        // And decrease this shader's contribution to the heat death of the universe\n        O = texture(iChannel0, U/r);\n        return;\n    }\n        \n    for (int i = 0; i < samples; i++){\n        uvec3 h = uvec3(iFrame + i, int(U.x) - i, int(U.y) + i);\n        // Required for hash input\n        \n        \n        ////// Here you may do whatever visualization you wish. \n        // It is not necessary, but it can be nice to see that\n        // it's actually working! If you rewrite this make sure\n        // that you call a() and that a() is not empty otherwise\n        // chaos ~~may~~ will ensue.\n        \n        vec2 b = vec2(.5);\n        vec2 result = a(h, b);\n        \n        \n\n        O.x += smoothstep(4./r.y, 0., length(result-uv));\n        \n        \n        \n    }\n    \n    \n\n    O.z = smoothstep(0., 1./r.y, data.y*c-U.y/r.y);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This shader allows you to compare the performance of functions\n// easily, I hope :D.  The shader will automatically adjust the\n// number of function calls per pixel, attempting to stabilize the\n// framerate around 50 fps. Once it is relatively stable, it will\n// stop tweaking the performance, and you can log the result. \n\n// The number of calls per pixel is displayed in the corner.\n// The blue line is purely visual, and can be removed if you want.\n// The blue line will turn green once the shader has reached its decision.\n// The time taken to find the equilibrium can be adjusted below, in\n// float averagingTime. Larger is more accurate, but takes longer.\n\n// Please note, the purpose of this shader is only to compare the \n// performance of functions. There is no absolute measurement, \n// only relative.\n\n\n\n\n\n/////////////////////////////////////////\n///////////// CONTROL PANEL /////////////\n/////////////////////////////////////////\n\n\n// the function a() at the bottom is where you place your functions to test.\n// Any visualizations may be placed inside the block at line 60 in Buffer A.\n\n// A hash function is provided to make it easy to test with random values\n// A circle sample function is also provided. Samples a circle of radius 1\n// A square sample function is also provided. Samples a square of width  1\n\n\n// You may need to adjust the coefficient below to suit the performance\n// of your function. If the entire screen goes blue, decrease. If the line\n// is very close to the bottom of the screen, adjust as needed.\nfloat c = 2e-3;\n\n\n// The amount of time the shader spends trying to find the perfect value\n// after it begins oscillating around the eqilibrium.\nfloat averagingTime = 500.;\n\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(v=hash(x+uint(v*1e9)).xy*2.-1.;\n        dot(v,v)<1.;)\n    return v;\n}\nvec2 squareSample(uvec3 x){\n    return hash(x).xy*2.-1.;\n}\n\n\n\n\n\n\n\n\nvec2 cloBox( in vec2 p, in vec2 b )\n{\n    vec2   s = sign(p);\n    vec2   w = abs(p) - b;\n    float  g = max(w.x,w.y);\n    float  m = min(0.0,g);\n    return p - vec2(w.x>=m?w.x:0.0,w.y>=m?w.y:0.0)*s;\n}\n\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    float g = max(w.x,w.y);\n    return (g>0.0)?length(max(w,0.0)):g;\n}\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgBox( in vec2 p, in vec2 b, float ra )\n{\n    vec2 w = abs(p)-(b-ra);\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l-ra: g-ra,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\n\n\n\n\nvec2 a(uvec3 x, vec2 b){\n    vec2 p = circleSample(x).xy * 5.;\n    \n    // Below is a comment trick I often use. \n    // Remove one slash from the line below to toggle between the blocks\n    //*\n    return cloBox(p, b);\n    /*/\n    return p - sdgBox(p, b, 0.).yz * sdBox(p, b);\n    //*/\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 180, 180, 350], [352, 352, 392, 392, 1426]], "test": "untested"}
{"id": "DlSyWd", "name": "Kishimisu Visualizer", "author": "Ebanflo", "description": "made kishimisu's fractal structure musical\nhttps://youtu.be/f4s1h2YETNY\nhttps://www.shadertoy.com/view/mtyGWy", "tags": ["2d", "fractal", "music"], "likes": 1, "viewed": 150, "published": 3, "date": "1692402901", "time_retrieved": "2024-07-30T17:38:24.914750", "image_code": "\nvec3 palette(float t) {\n    vec3 a = vec3(0.8, 0.2, 0.6);\n    vec3 b = vec3(0.0, 0.2, 0.9);\n    vec3 c = vec3(0.6, 0.2, 0.5);\n    vec3 d = vec3(0.4, 0.2, 0.7);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for  (int i = 0; i < 6; i++){\n    \n        float octave_energy = texture(iChannel0, vec2(float(i)/6.0, 0.25)).r;\n    \n        uv = fract(uv * 1.5) - 0.5;\n    \n        float d = length(uv) * exp(-length(uv0));\n    \n        vec3 col = palette(length(uv0) + float(i)*.4 + 2.*float(1 + i)*octave_energy);\n    \n        d = sin(d*16. + (16. - float(i))*octave_energy)/8.;\n        d = abs(d);\n        \n        d = pow(0.01 /d, 1.2);\n   \n       finalColor+= 0.3*col *d;\n    }\n    \n   \n   fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// low pass filter of the power in each frequency seems to stabilize note identification\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 5) {\n        fragColor = vec4(0, 0, 0, 1);\n    } else {\n        fragColor = 0.95*pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(2))\n                  + 0.05*pow(texture(iChannel1, fragCoord/iResolution.xy), vec4(2));\n    }\n}", "buffer_a_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// sampling of the texture thanks to Gibj\n// https://www.shadertoy.com/view/4dc3zH\n\nconst float A = 0.0370;\nconst float semitone  = pow(2.0, 1.0/12.0);\n\nfloat note_to_freq(int n){\n    return pow(semitone, float(n - 49))*440.;\n}\n\nfloat freq_to_text(float freq){\n    return freq*A/440.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //int y_ix = int(uv.y > 0.5);\n    //int x_ix = int(step(0.333, uv.x) + step(0.666, uv.x));\n    int octave = int(floor(6.0*uv.x));\n\n    int start_note = 12*octave + 6;\n    float[12] texture_indices;\n    for(int i = 0; i < 12; i++) {\n        texture_indices[i] = freq_to_text(note_to_freq(start_note + i));\n    }\n    \n    for(int i = 0; i < 12; i++) {\n        fragColor.r += texture(iChannel1, vec2(texture_indices[i], 0.25)).r;\n    }\n    \n    //ivec3 current_notes = current_notes(texture_indices);\n    //ivec2 ratios = get_ratios(current_notes);\n    \n    //fragColor.rg = 0.5*texture(iChannel0, uv).rg + 0.5*vec2(1 + current_notes.yz);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 204], [207, 207, 264, 264, 908]], "test": "untested"}
{"id": "7sKcRy", "name": "Year of Truchets #051", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nSimple animated truchet tiles (mouseable). ", "tags": ["reflection", "refraction", "truchet", "raymaching"], "likes": 28, "viewed": 223, "published": 3, "date": "1692402075", "time_retrieved": "2024-07-30T17:38:25.855235", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #051\n    08/18/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\nmat2 rot (float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n//@iq\nfloat box(vec3 p, vec3 b){vec3 q=abs(p)-b;return length(max(q,0.));}\nfloat cap(vec3 p, float h, float r){p.y-=clamp(p.y,0.,h);return length(p)-r;}\n\n// globals for stuff\nvec3 hit,hitPoint;\nvec2 gid,sid;\nfloat time=0.,ftime=0.,glow=0.,mse=0.,gcurve=0.,scurve=0.;\n\nconst vec2 sc = vec2(.225), hsc = .5/sc; \nconst float amt = 4.;\nconst float dbl = amt*2.;\n\nvec2 map(vec3 p, float sg) {\n\n    vec3 op = p;\n    vec2 res = vec2(1e5,0.);\n\n    // breakdown domain\n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 q = p.xz - id/sc;\n    \n    vec3 pd = vec3(q.x,op.y,q.y);\n    \n    // flip random cells\n    float rnd = hash21(id);\n    if(rnd<.5) q.y = -q.y;\n\n    // create truchet curves\n    vec2 d2 = vec2(length(q-hsc), length(q+hsc)); \n    float crv = abs(min(d2.x,d2.y)-hsc.x);\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n\n    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);\n    pp *= rot((time+mse)*dir);\n\n    // create vectors for track\n    float a = atan(pp.y, pp.x);\n    float ai = floor(dir*a/PI*amt);\n    a = (floor(a/PI2*dbl) + .5)/dbl;\n    float ws = mod(ai,amt);\n\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hsc.x;\n\n    // vectors for things\n    vec3 npos = vec3(qr.x, op.y, qr.y);\n    vec3 nnos = vec3(qr.x, op.y-.2, qr.y);\n\n    // apply rotations\n    vec3 ngos = nnos-vec3(0,.05,0);\n  \n    vec3 qd = pd;\n    qd.xz=abs(qd.xz)-hsc;\n\n    float blk = length(qd)-.95;\n    blk=max(abs(blk)-.15,blk);\n \n    if(blk<res.x) {\n        res = vec2(blk,4.);\n        hit= qd;\n        gid = vec2(15);\n    }\n    \n    //holder\n    float blox = box(npos,vec3(.15,.05,.05))-.005;\n    nnos.xz=abs(nnos.xz)-.0125;\n    float cl = cap(nnos+vec3(0,.1,0),.25,.005);\n    cl = min(cap(ngos,.05,.0275),cl);\n    cl = min(length(npos-vec3(0,.05,0))-.045,cl);\n    \n    vec3 fpos = ngos-vec3(0,.08,0);\n\n    // put all the things together\n    blox = min(blox,cl);\n    \n    if(blox<res.x) {\n        res = vec2(blox,24.);\n        hit= nnos;\n    }\n\n    // tube\n    float tube = cap(fpos+vec3(0,0,0),.1,.045);\n    tube = min(length(fpos-vec3(0,.2,0))-.15,tube);\n\n    if(tube<res.x) {\n        res = vec2(tube,ws==1.?2.:ws==3.?4.:5.);\n        hit= fpos;\n        gid = vec2(ws,ai);\n    }\n    \n    if(sg==1. && ws==1.) glow += .0025/(.0025+tube*tube);\n    \n    //truchet track\n    vec3 tp =vec3(abs(abs(crv)-.145)-.075,op.y,crv);\n    float bx = box(tp, vec3(.0325, .015,1.))-.0015;\n    if(bx<res.x) {\n        res = vec2(bx, 3.);\n        hit=tp;\n    }\n    \n    // ground floor\n    float ground = p.y+.05;\n    if(ground<res.x) {\n        res = vec2(ground,1.);\n        hit=p;\n        gcurve=crv;\n    }   \n    return res;\n}\n\n\nvec3 normal(vec3 p, float t) {\n    float d = map(p,0.).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n    );\n    return normalize(n);\n}\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    t+=T*.1;\n    return .42+.32*cos( PI2*t*vec3(.95,.97,.88)*vec3(.11,.95,.78)); \n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout vec3 ref) \n{ \n    n = normal(p,d);\n    vec3 lpos =  vec3(3,10,-8);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),.0,.85);\n    \n    float shdw = 1.0;\n    for( float t=.01; t < 9.; ) {\n        float h = map(p + l*t,0.).x;\n        if( h<.0001 ) { shdw = 0.; break; }\n        shdw = min(shdw, 12.*h/t);\n        t += h;\n        if( shdw<.0001 || t>24. ) break;\n    }\n    diff = mix(diff,diff*shdw,.5);\n        \n    vec3 h = vec3(.5);\n\n    if(m==1.){\n        h = vec3(.075);\n        vec3 hp = hitPoint;\n        \n        float px = 8./R.x;\n        vec2 id =floor(hp.xz*3.);\n        vec2 f = fract(hp.xz*3.)-.5;\n        float hs = hash21(id);\n        if(hs>.5) f.x *= -1.;\n        \n        vec2 d2 = vec2(length(f-.5), length(f+.5)); \n        vec2 pp = d2.x<d2.y? vec2(f - .5) : vec2(f + .5);\n\n        float pt = length(pp)-.5;\n        pt=smoothstep(px,-px,abs(abs(abs(abs(pt)-.2)-.1)-.05)-.025);\n        h=mix(h,vec3(.1),pt);\n        \n        px = 3./R.x;\n        float edge = smoothstep(px,-px,abs(abs(scurve)-.5)-.05);\n        float curve= smoothstep(px,-px,abs(scurve)-.5);\n        \n        vec3 clr = hue(13.+clamp(hp.z*.1,0.,.5));\n        h=mix(h,clr,curve);\n        h=mix(h,vec3(.6),edge);\n        ref=vec3(.65);\n    }\n\n    if(m==4.) {\n        h =vec3(0.376,0.376,0.463);\n        ref=vec3(.5);\n    }\n\n    if(m==12.){\n        float hs = hash21(sid);\n        h =hue(hs);\n    }\n\n    vec3 rtn = (m==5.||m==3.||m==1.)?diff*h:diff*vec3(.005);\n    return rtn;\n}\n\nvoid mainImage(out vec4 O, in vec2 F) { \n    // precal\n    time = T*.265;\n    mse = (M.x/R.y);\n    \n    vec3 C = vec3(.0015);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(10,0,3.75);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // camera //\n    float y = T*1.*PI2/180.;\n    \n    mat2 rx = rot(.5+.1*sin(y));\n    mat2 ry = rot(y);\n\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 p = ro + rd;\n    vec3 atten = vec3(1.);\n    vec3 ref = vec3(0);\n    \n    float k = 1.,d = 0.,iv = 1.,fA = 0.;\n    float bnc = 6.;\n    \n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p,1.);\n        vec3 n = vec3(0);\n        float m = ray.y;\n\n        d = i<32?ray.x*.8:ray.x;\n        p += rd * d * k;\n        \n        if(bnc>5.) fA += d;\n        \n        if (d*d < 1e-8) {\n            hitPoint = hit;\n            sid=gid;\n            scurve=gcurve;\n            bnc--;\n                \n            C+=render(p,rd,ro,d,ray.y,n,ref)*atten;\n            if(m!=1.&&m!=5.&&m!=4.||bnc<1.)break;\n            \n            atten *= ref;\n            p += rd*.01;\n            k = sign(map(p,0.).x);\n\n            if(m== 4.) {\n                vec3 rf=refract(rd,n,iv > 0. ? .98 : 1.1);\n                iv *= -1.;\n                if(length(rf) == 0.) rf = reflect(rd,n);\n                rd=rf;\n                p+=-n*.1;\n            } else {\n                rd=reflect(-rd,n);\n                p+=n*.1;\n            }\n        } \n\n        if(distance(p,rd)>50.) { break; }\n    }\n\n    C = mix( C, vec3(.85,.55,.27)*(glow*.6)+C,clamp(glow,.0,1.)); \n    if(fA>0.) C=mix(C,vec3(.16), 1.-exp(-.00065*fA*fA*fA));\n    \n    C = mix(C,C*.8,hash21(uv)>.5?0.:1.);\n    \n    C = clamp(C,vec3(0),vec3(1));\n    C = pow(C,vec3(0.4545));\n    O = vec4(C,1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKcRy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[310, 310, 330, 330, 373], [374, 374, 398, 398, 453], [454, 460, 486, 486, 528], [529, 529, 565, 565, 606], [813, 813, 841, 841, 3045], [3048, 3048, 3078, 3078, 3266], [3268, 3315, 3333, 3333, 3418], [3420, 3420, 3508, 3508, 4967], [4969, 4969, 5008, 5023, 6718]], "test": "untested"}
{"id": "clBcDt", "name": "Oil Projector v2", "author": "sh1boot", "description": "Trying to use mipmaps to calculate ~~median~~ (actually average) value by quantising to a threshold and taking whole-frame average as a count of values above/below that threshold.  We use this threshold to try to keep the area of the oil blobs constant.", "tags": ["lava", "blobby", "constantvolume"], "likes": 1, "viewed": 152, "published": 3, "date": "1692397168", "time_retrieved": "2024-07-30T17:38:26.708953", "image_code": "vec4 pal(in vec4 i, in vec2 uv) {\n    // Convert saturated (ie., approximately binary) xyzw values\n    // into a 16-colour palette.  In this case, an approximation\n    // of the C64 colour palette.  Why the C64?  I do not know.\n    // I just wanted to do away with that RGB-filter look that\n    // comes out otherwise.\n    vec4 j = vec4(1.) - i;\n#if 0\n    return (j.x * j.y * j.z * j.w) * vec4(0., 0., 0., 0.)\n         + (j.x * j.y * j.z * i.w) * vec4(1., 1., 1., 0.)\n         + (j.x * j.y * i.z * j.w) * vec4(0., 1., 0., 0.)\n         + (j.x * j.y * i.z * i.w) * vec4(.5, 0., 0., 0.)\n         + (j.x * i.y * j.z * j.w) * vec4(.6, 1., .9, 0.)\n         + (j.x * i.y * j.z * i.w) * vec4(.7, .3, .7, 0.)\n         + (j.x * i.y * i.z * j.w) * vec4(0., .7, .4, 0.)\n         + (j.x * i.y * i.z * i.w) * vec4(0., 0., .6, 0.)\n         + (i.x * j.y * j.z * j.w) * vec4(.9, .9, .5, 0.)\n         + (i.x * j.y * j.z * i.w) * vec4(.8, .5, .3, 0.)\n         + (i.x * j.y * i.z * j.w) * vec4(1., .5, .5, 0.)\n         + (i.x * j.y * i.z * i.w) * vec4(.2, .2, .2, 0.)\n         + (i.x * i.y * j.z * j.w) * vec4(.5, .5, .5, 0.)\n         + (i.x * i.y * j.z * i.w) * vec4(.6, 1., .7, 0.)\n         + (i.x * i.y * i.z * j.w) * vec4(0., .5, 1., 0.)\n         + (i.x * i.y * i.z * i.w) * vec4(.8, .8, .8, 0.);\n#else\n    return (j.x * j.y * j.z * j.w) * vec4(0., 0., 0., 0.)\n         + (j.x * j.y * j.z * i.w) * vec4(1., 1., 1., 0.)\n         + (j.x * j.y * i.z * j.w) * vec4(0., 1., 0., 0.)\n         + (j.x * j.y * i.z * i.w) * vec4(.5, 0., 0., 0.)\n         + (j.x * i.y * j.z * j.w) * vec4(.6, 1., .9, 0.)\n         + (j.x * i.y * j.z * i.w) * vec4(.7, .3, .7, 0.)\n         + (j.x * i.y * i.z * j.w) * vec4(0., .7, .4, 0.)\n         + (j.x * i.y * i.z * i.w) * texture(iChannel3, uv + vec2(0.01, 0.03) * iTime)\n         + (i.x * j.y * j.z * j.w) * vec4(.9, .9, .5, 0.)\n         + (i.x * j.y * j.z * i.w) * vec4(.8, .5, .3, 0.)\n         + (i.x * j.y * i.z * j.w) * vec4(1., .5, .5, 0.)\n         + (i.x * j.y * i.z * i.w) * vec4(.2, .2, .2, 0.)\n         + (i.x * i.y * j.z * j.w) * vec4(.5, .5, .5, 0.)\n         + (i.x * i.y * j.z * i.w) * vec4(.6, 1., .7, 0.)\n         + (i.x * i.y * i.z * j.w) * vec4(0., .5, 1., 0.)\n         + (i.x * i.y * i.z * i.w) * texture(iChannel2, uv + vec2(0.02, -0.007) * iTime);\n#endif\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec4 b = texture(iChannel0, uv);\n    vec4 c = texture(iChannel1, uv);\n    if (uv.x > 0.95) b = texture(iChannel1, uv, 100.5);\n    b = m.y > uv.y ? b : c;\n    b = pal(b, uv);\n    fragColor = b;\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Mostly a generic framebuffer feedback thing, with some\n// scribbling over the top.\n// To help edge towards rounded shapes, the smoothed and\n// sharpened buffer is fed back into this as well, so that\n// it gradually sharpens itself as it mixes and the shapes\n// should become progressively rounder from frame to frame\n// (if not for the stirring).\n\n\nvec4 funborder(sampler2D s, vec2 uv) {\n    if (any(notEqual(uv, fract(uv)))) {\n        uv -= 0.5;\n        float th = atan(uv.y, uv.x) + iTime;\n        return max(vec4(0), sin(vec4(0.4, -0.7, -0.9, 0.1) * th) - 0.7);\n    }\n    return texture(s, uv);\n}\n\n// Just some random perturbation of the coordinates to make things swirl.\nvec2 f(in vec2 uv) {\n    const vec2 centre = vec2(0.35, 0.35);\n    const float th = 0.003;\n    const float r = 0.9995;\n    float c = cos(th), s = sin(th);\n    uv = (uv - centre) * mat2(c, s, -s, c) * r + centre;\n    vec2 wiggle = vec2(sin(iTime + uv.y * 15.1), cos(uv.x * 14.1));\n    uv += wiggle * 0.002;\n\n    uv = (uv - 0.5) * 1.001 + 0.5;\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec2 vu = uv.yx;\n    uv = f(uv);\n    vu = f(vu).yx;\n    vec4 q = 0.5 * vec4(funborder(iChannel1, uv).xz,\n                        funborder(iChannel1, vu).yw).xzyw;\n    vec4 col = vec4(funborder(iChannel0, uv).xz,\n                    funborder(iChannel0, vu).yw).xzyw;\n\n    // Magic number here seems like viscosity:\n    col = mix(col, q, 0.078);\n    \n    // Try to enlarge colour fringes a bit.\n    col *= vec4(1.005, 0.995, 0.995, 1.005);\n\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int blur_taps = 15;\nconst float blur_radius = 8.0;\n\nfloat aastep(float threshold, float f) {\n    float margin = clamp(fwidth(f) * 0.7, 0.0, 0.1);\n    return smoothstep(threshold - margin, threshold + margin, f);\n}\n\nvec4 aastep(float threshold, vec4 f) {\n    vec4 margin = clamp(fwidth(f) * 0.7, 0.0, 0.1);\n    return smoothstep(threshold - margin, threshold + margin, f);\n}\n\n\nfloat pdf(float x) {\n#if 0\n    // pdf for s=0.1667: `sum(uniform(-.5,.5, 3)/3)`\n    return 2.39365*exp(-18. * x * x);\n#else\n    // pdf for s=0.144: `sum(uniform(-.5,.5, 4)/4)`\n    return 2.77043 * exp(-24.1126 * x * x);\n#endif\n}\n\n\nvec4 gsample(sampler2D tex, vec2 uv, vec2 v, float radius) {\n#if 1\n    vec4 sum = vec4(0);\n    float den = 0.0;\n\n    for (int i=-blur_taps; i <= blur_taps; i++) {\n        float f = float(i) / float(blur_taps);\n        float w = pdf(f / radius);\n        vec2 ofs = v * f;\n        sum += textureLod(tex, uv + ofs, 2.5) * w;\n        den += w;\n    }\n    return sum / den;\n#else\n    return texture(tex, uv);\n#endif\n}\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = gsample(iChannel0, uv, vec2(0.05, 0.0), blur_radius);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = gsample(iChannel0, uv, vec2(0.0, 0.05), blur_radius);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Read a blurred Buffer A (blurring aims to represent surface tension),\n// and quantise it according to the average of the previous frame.\n// The idea is that the average of the result should seek the median\n// weight of Buffer A so that half the buffer is lit.\n// This is fed back into buffer A to encourage it to gradually gain\n// more defined edges and the expected weight, while still being able\n// to move and blur.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample the main framebuffer with a whole lot of smoothing.\n    vec4 colour = 0.50 * texture(iChannel0, uv);\n\n#if 0\n    // Take the average of the whole of the previous output;\n    // if this is low then too few pixels were 'set', and\n    // if it is high then too many pixels were 'set'.\n    vec4 threshold = textureLod(iChannel1, vec2(0.5), 99.9);\n#else\n    // Take the average of the whole of the current input;\n    // This divides the output into above and below average,\n    // which is not the same as the median, but I think it will\n    // seek the median more stably than above.\n    vec4 threshold = textureLod(iChannel0, vec2(0.5), 99.9);\n#endif\n    \n    // I didn't really think this through.  We need to make an informed\n    // guess at where the correct threshold should be, but it's fiddly\n    // trying to be stateful about previous guesses, so I just mashed\n    // the keyboard until the flashing and blinking didn't happened so\n    // much.\n    threshold = mix(threshold, vec4(0.55), 0.1);\n    colour = aastep(0.0, colour - threshold);\n\n    fragColor = colour;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = vec4(0.0);\n    vec2 clip = vec2(rayDir.z * 0.25);\n    vec2 clipuv = abs(rayDir.xy);\n    if (all(lessThanEqual(clipuv, rayDir.zz))\n        && all(lessThanEqual(clipuv, clip))) {\n        vec2 uv = rayDir.xy / clip;\n        fragColor = texture(iChannel0, uv);\n    }\n}", "cube_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 318, 2285], [2287, 2287, 2344, 2344, 2626]], "test": "untested"}
{"id": "dljyDc", "name": "Just touching the heart", "author": "iq", "description": "Circles tangent to a heart shape", "tags": ["2d", "circles", "sdf", "heart"], "likes": 89, "viewed": 1960, "published": 3, "date": "1692397070", "time_retrieved": "2024-07-30T17:38:28.099235", "image_code": "// Copyright Inigo Quilez, 2023 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// heart shape: https://www.shadertoy.com/view/3tyBzV\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdHeart( in vec2 p )\n{\n    p.y += 0.6;\n    p.x = abs(p.x);\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75)))-sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))); //*sign(p.x-p.y); // don't need sign really for this shader\n}\n\n// oldschool rand() from Visual Studio\nint seed=666; float frand(void) {seed=seed*0x343fd+0x269ec3;return float((seed>>16)&32767)/32767.0;}\n\n// for each pixel, do math\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2  p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // add circles over time (loop every 15 seconds)\n    float time = mod( iTime, 15.0 );\n    const int kMaxNum = 1536;\n    float fnum = 16.0*(time/10.0) + (float(kMaxNum)-16.0)*pow(time/10.0,3.0);\n    int   inum = min(1+int(floor(fnum)),kMaxNum);\n\n    // gradually make brush softer\n    float brush = 0.3 + 0.3*pow(max(0.0,1.0-float(inum)/float(kMaxNum)),4.0);\n\n    // draw circles\n    float col = 1.0;\n    for( int i=0; i<inum-1; i++ )\n    {\n        // pick random positions\n        vec2  q = vec2(1.3,0.9)*(-1.0+2.0*vec2(frand(),frand()));\n\n        // compute the distance to the art\n        float r = sdHeart(q/1.15)*1.15;\n\n        // and make a circle of size equal to that distance\n        float d = abs(length(p-q)-abs(r))-0.001;\n\n        // put black inc for this circle\n        col *= 1.0 - brush*smoothstep(2.0*px, -2.0*px, d);\n    }\n\n    // only last cicle needs angular animation\n    {\n        vec2  q  = vec2(1.3,0.9)*(-1.0+2.0*vec2(frand(),frand()));\n        vec2  w  = p - q;\n        float ra = atan(w.y,w.x)/6.283185; if(ra<0.0) ra += 1.0;\n        float da = fnum-float(inum-1);\n        float al = smoothstep( 0.0, 0.1, 1.1*da - ra );\n        float r  = sdHeart(q/1.15)*1.15;\n        float d  = abs(length(w)-abs(r))-0.001;\n        col *= 1.0 - al*brush*smoothstep(2.0*px, -2.0*px, d);\n    }\n    \n    // gradually introduce vignetting\n    col *= 1.0 - 0.1*length(p) * (float(inum)/float(kMaxNum));\n\n    // fade to white\n    col = mix( col, 1.0, smoothstep(12.0,15.0f,time) );\n    \n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljyDc.jpg", "access": "api", "license": "proprietary-license", "functions": [[766, 820, 845, 845, 864], [865, 865, 893, 893, 1170], [1172, 1225, 1244, 1244, 1311]], "test": "untested"}
{"id": "dtSyDc", "name": "Open World. Mouse look keys move", "author": "Blindman67", "description": "Use mouse to look (left click drag). Use keys to move (up,down,left,right or WASD). How big is the world? I have not set any limits, the world is as big as floating point precision will let you move. It is very large.", "tags": ["terrain", "raymarch", "keyboard", "explore", "openworld"], "likes": 16, "viewed": 270, "published": 3, "date": "1692393149", "time_retrieved": "2024-07-30T17:38:29.135465", "image_code": "\n\n\nfloat glare;\nvec3 CalcNorm(vec3 pos, float dist, uint stopAt) {\n    vec2 e = vec2(0.001 * dist, 0);\n    return normalize(vec3(\n        TerrainSDF((pos.xz - e.xy) * MAP_SCALE, stopAt) - TerrainSDF((pos.xz + e.xy) * MAP_SCALE, stopAt), \n        2.0 * e.x, \n        TerrainSDF((pos.xz - e.yx) * MAP_SCALE, stopAt) - TerrainSDF((pos.xz + e.yx) * MAP_SCALE, stopAt)\n    ));\n}\nNorms CalcNorms(vec3 pos, float dist) {\n    vec2 e = vec2(0.001 * dist * MAP_SCALE , 0);\n    vec2 p = pos.xz * MAP_SCALE;\n    vec3 A = TerrainSDF(p - e.xy);\n    vec3 B = TerrainSDF(p + e.xy);\n    vec3 C = TerrainSDF(p - e.yx);\n    vec3 D = TerrainSDF(p + e.yx);\n    float e2 = 0.002 * dist;\n    return Norms(\n        normalize(vec3(A.x - B.x, e2, C.x - D.x)),\n        normalize(vec3(A.y - B.y, e2, C.y - D.y)),\n        normalize(vec3(A.z - B.z, e2, C.z - D.z))\n    );\n}\nvoid SunGlow(in vec3 rDir, in vec3 sDir, inout vec3 atmosphere) {\n    float sdot = UClamp(dot(rDir, sDir)) * glare;\n    atmosphere += COl_SunA.rgb * pow(sdot, COl_SunA.a);\n    atmosphere += COl_SunB.rgb * pow(sdot, COl_SunB.a);\n    atmosphere += COl_SunC.rgb * pow(sdot, COl_SunC.a);\n    atmosphere += COl_SunD.rgb * pow(sdot, COl_SunD.a);\n}\nfloat RayMarch(Ray ray, float dist) {\n    vec3 p = ray.origin + dist * ray.dir;\n    for(uint i = 0u; i < MAX_ITER && dist < MAX_DIST; i++) {\n        float h = p.y - TerrainSDF(p.xz * MAP_SCALE, 8u);\n        if (abs(h) < EPSILON * dist) { return dist; }\n        h *= 0.6;\n        p += h * ray.dir;\n        dist += h;\n    }\n    return dist;\n}\n\n\nvec3 DrawPixel(Ray ray) {\n    float dist = RayMarch(ray, MIN_DIST);    \n    vec3 col = vec3(0);\n    vec3 atmosphere = vec3(0.3, 0.5, 0.85) - ray.dir.y * ray.dir.y * 0.5;\n    atmosphere = mix(atmosphere, 0.85 * vec3(0.7, 0.75, 0.85), pow(1.0 - max(ray.dir.y, 0.0), 4.0));\n    SunGlow(ray.dir, sun.dir, atmosphere);\n\n    if (dist <= MAX_DIST) {\n        vec3 p = ray.origin + dist * ray.dir;\n        Norms norms = CalcNorms(p, dist);\n        vec3 up = vec3(0,1,0);\n        float dotH = dot(norms.nH, up);\n        float dotL = dot(norms.nL, up);\n        \n        float altitude = p.y + dotH * 40.0;\n        float snow = altitude > 95.0 ? dotH : 0.0;\n        float snowCover = UClamp((150.0 - p.y) / 150.0) + 0.3;\n        float green = altitude < 90.0 ? dotH : 0.0;\n        float greenCover = UClamp(p.y / 150.0) + 0.5;\n        \n        vec3 rockC = mix(COl_A, COl_B, smoothstep(0.8, 0.802, dotH));\n        float mixSnow = step(UClamp(snowCover), snow);\n        if (mixSnow > 0.5) {\n            twist = twist1;\n            norms.nL = CalcNorm(p, dist, 4u);\n            twist = twist2;\n        }\n        float mixGrass = step(UClamp(greenCover), green);\n        rockC = mix(rockC, COl_C, mixSnow);\n        rockC = mix(rockC, mix(COl_D, COl_D1, norms.nH.z * norms.nH.y), mixGrass);\n        \n        vec3 n = mix(norms.nH, norms.nL, max(mixSnow, mixGrass * 0.5));\n        float difuse = UClamp(dot(sun.dir, n)) + 0.3;        \n        float sh = RayShadow(p + n * 0.5, sun.dir);        \n        float ambient = UClamp(n.y * 0.5 + 0.5);\n        float back = UClamp(dot(vec3(-sun.dir.x, -sun.dir.y * 4.0, -sun.dir.z), n)) ;\n        vec3 lin = vec3(0.4, 0.6, 1.0) * ambient * 6.0;\n        lin += vec3(6.0, 4.0, 3.0) * difuse * difuse * difuse * 2.0 * sh; \n        lin += vec3(4.4, 7.15, 10.6) * pow(back, 5.0);\n\n        col = mix(atmosphere, rockC * lin , exp(-pow(0.002 * dist, 1.5)));\n    } else {\n        col = atmosphere;\n    }\n    return col;\n}\n\nvec3 GetPixel(in vec2 fragCoord) {\n    twist = twist2;\n    float time = Time(iFrame, ORBIT_SPEED);\n    vec3 invRes = InvRes(iResolution);\n    vec4 posGlare = GetState(STATE_CH, STATE_CAM_HEIGHT);\n    glare = posGlare.w;\n    Ray ray = Ray(posGlare.xyz, vec3(0));\n    vec2 yawPitch = GetState(STATE_CH, STATE_CAM_DIR).xy;        \n    vec2 px = 1.0 / iResolution.xy;   \n    vec2 uv = FixUV(fragCoord, iResolution) * invRes.y;\n    mat3 vmat = lookMouse(2.0 * yawPitch);\n\n    #ifndef ANTI_ALIAS\n        ray.dir = normalize(vmat * vec3(uv, 2.0));\n        return  DrawPixel(ray);   \n    #else\n        vec3 col = vec3(0);\n        vec2 subPx = vec2(0);  \n        for (subPx.y = 0.0; subPx.y < 1.0; subPx.y += AA_STEP) {\n            for (subPx.x = 0.0; subPx.x < 1.0; subPx.x += AA_STEP) {\n                ray.dir = normalize(vmat * vec3(uv + px * subPx, 2.0));\n                vec3 c = DrawPixel(ray);   \n                col += c * c;\n            }\n        }\n        return pow(col * AA_SAMPLES, vec3(0.5));\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(1.0 - exp(-GetPixel(fragCoord) * 2.0), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define ANTI_ALIAS 3.0\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define MAX_SHADOW_DIST 100.0\n#define SHADOW_SCALE 0.01\n#define WORLD_VERT_SIZE 127.0  /* This value is at its max. Larger values will create artifacts. vert for vertical */\n#define WORLD_VERT_POW 1.5 \n#define FOG_SCALE 100.0\n#define FAR vec4(1e5)\n#define EPSILON 0.0001\n#define MAX_ITER 128u\n#define MAX_SHADOW_ITER 64u\n#define MAP_SCALE 0.0025\n#define ORBIT_RADIUS 4012.0\n#define ORBIT_SPEED 0.00055\n#define CAMERA_OFFSET 10.0\n\n\n#define STATE_DATA_STRIDE 32 /* Must be less than resolution */\n#define STATE_CH iChannel0\n#define STATE_MAX_IDX 3      /* To help reduce GPU load */\n\n\n#define KEYS iChannel1\n#define KEY_UP 38\n#define KEY_DOWN 40\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n#define KEY_A 65 \n#define KEY_B 66 \n#define KEY_C 67 \n#define KEY_D 68 \n#define KEY_E 69\n#define KEY_F 70 \n#define KEY_G 71 \n#define KEY_H 72 \n#define KEY_I 73 \n#define KEY_J 74\n#define KEY_K 75 \n#define KEY_L 76 \n#define KEY_M 77 \n#define KEY_N 78 \n#define KEY_O 79\n#define KEY_P 80 \n#define KEY_Q 81 \n#define KEY_R 82 \n#define KEY_S 83 \n#define KEY_T 84\n#define KEY_U 85 \n#define KEY_V 86 \n#define KEY_W 87 \n#define KEY_X 88 \n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_0 48 \n#define KEY_1 49 \n#define KEY_2 50 \n#define KEY_3 51 \n#define KEY_4 52\n#define KEY_5 53 \n#define KEY_6 54 \n#define KEY_7 55 \n#define KEY_8 56 \n#define KEY_9 57\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\n#ifdef ANTI_ALIAS\n    const float AA_STEP = 1.0 / ANTI_ALIAS;\n    const float AA_SAMPLES = 1.0 / (ANTI_ALIAS * ANTI_ALIAS);\n#endif\nconst float inv_60 = 1.0 / 60.0;\n\n\n\n\nstruct Ray{ vec3 origin; vec3 dir; };\n\nvec4 GetState(in sampler2D sampler, in int idx) {    \n    return texelFetch(sampler, ivec2(idx % STATE_DATA_STRIDE, idx / STATE_DATA_STRIDE), 0);    \n}\nint GetStateIdx(vec2 coord) {\n    int x = int(coord.x);\n    return x < STATE_DATA_STRIDE ? x + int(coord.y) * STATE_DATA_STRIDE : STATE_MAX_IDX;\n}\n\nbool Key(in sampler2D sampler, int charIdx) {\n  return texelFetch(sampler, ivec2(charIdx, 0), 0).x > 0.0;\n}\nbool Key(in sampler2D sampler, int char1Idx, int char2Idx) {\n  if (texelFetch(sampler, ivec2(char1Idx, 0), 0).x > 0.0) { return true; }\n  return texelFetch(sampler, ivec2(char2Idx, 0), 0).x > 0.0;\n}\n\n\nfloat UClamp(in float v) { return clamp(v, 0.0, 1.0); } /* U for unit */\nfloat Hash(vec2 pos) {\n    pos = fract(pos * 13.654678) * 65.247743;\n    float f = fract((pos.x + pos.y) * pos.x * pos.y);\n    return f * f;\n}\nvec3 Noise2D(vec2 pos) {  /* returns vec3 where 2D noise is return.xy  */\n    vec2 fPos = floor(pos);\n    float a = Hash(fPos);\n    float b = Hash(fPos + vec2(1, 0));\n    float c = Hash(fPos + vec2(0, 1));\n    float d = Hash(fPos + vec2(1, 1));\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f), u1 = 1.0 - u;\n    float ca = c - a;\n    float ba = b - a;\n    return vec3(\n        6.0 * u * u1 * (vec2(ba, ca) + u.yx * (a - b - c + d)),\n        a + ba * u.x * u1.y + ca * u1.x * u.y + (d - a) * u.x * u.y        \n    );\n}\n\n\nvec3 InvRes(in vec3 res) { return 1.0 / res; }\nvec2 FixUV(in vec2 uv, in vec3 res) { return (2.0 * uv - res.xy); }\nfloat Time(in int f) { return float(f) * inv_60; }\nfloat Time(in int f, in float scale) { return float(f) * inv_60 * scale; }\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\nmat3 lookMouse(in vec2 unitMouse) {\n    return camMatrix((unitMouse.x * 1.2 - 0.1) * PI, (unitMouse.y * 0.5 + 0.5) * PI);\n}\n\n\n\n\n#define STATE_CAM_POS 0\n#define STATE_CAM_DIR 1\n#define STATE_CAM_HEIGHT 2\n\n\nconst vec3  COl_A = vec3(0.03, 0.032, 0.034) * 1.5;   // Rock steep\nconst vec3  COl_B = vec3(0.054, 0.053, 0.05);   // Rock\nconst vec3  COl_C = vec3(0.257, 0.257, 0.25);   // Snow\nconst vec3  COl_D = vec3(0.044, 0.052, 0.04);   // Grass\nconst vec3  COl_D1 = vec3(0.052, 0.055, 0.045);  // Grass 2\n\n/* Alpha used as power */\nconst vec4  COl_SunA = vec4(1.0, 0.7, 0.0, 5.0);\nconst vec4  COl_SunB = vec4(1.5, 1.2, 0.6, 64.0);\nconst vec4  COl_SunC = vec4(2.0, 2.0, 1.1, 512.0);\nconst vec4  COl_SunD = vec4(1.0, 0.7, 0.3, 8.0);\n\nRay sun = Ray(vec3(0), normalize(vec3(0.8, 0.1, -0.2)));\nstruct Norms {\n    vec3 nL;\n    vec3 n;\n    vec3 nH;\n};\nmat2 twist;\nconst mat2 twist1 = mat2(sin(0.5), -cos(0.5) * 1.8, cos(0.5) * 1.7, sin(0.5));\nconst mat2 twist2 = mat2(0.6, -0.8, 0.8, 0.632);\nfloat TerrainSDF(vec2 coord, uint stopAt) {\n    vec2 p = coord;\n    vec3 n; \n    float a = 0.0, b = 1.0;\n    vec2 d = vec2(0);\n    uint i = 0u;\n    while (i < stopAt) {\n        n = Noise2D(p);\n        d += n.xy;\n        a += b * n.z / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    return WORLD_VERT_SIZE * pow(a, WORLD_VERT_POW);\n}\nvec3 TerrainSDF(vec2 coord) {\n    vec2 p = coord;\n    float a = 0.0, b = 1.0;\n    vec2 d = vec2(0);\n    uint i = 0u;\n    vec3 n, res;\n    while (i < 3u) {\n        n = Noise2D(p);\n        d += n.xy;\n        a += b * n.z / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.x = WORLD_VERT_SIZE * pow(a, WORLD_VERT_POW);\n    while (i < 8u) {\n        n = Noise2D(p);\n        d += n.xy;\n        a += b * n.z / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.y = WORLD_VERT_SIZE * pow(a, WORLD_VERT_POW);\n    while (i < 16u) {\n        n = Noise2D(p);\n        d += n.xy;\n        a += b * n.z / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.z = WORLD_VERT_SIZE * pow(a, WORLD_VERT_POW);\n    return res;\n}\n\nfloat RayShadow(vec3 origin, vec3 dir) {\n    float dist = MIN_DIST;\n    vec3 p = origin + MIN_DIST * dir;\n    for(uint i = 0u; i < MAX_SHADOW_ITER && dist < MAX_SHADOW_DIST; i++) {\n        float h = p.y - TerrainSDF(p.xz * MAP_SCALE, 10u);\n        if (abs(h) < EPSILON * dist) { break; }\n        p += h * dir;\n        dist += h;\n    }\n    return dist < MAX_SHADOW_DIST && dist > EPSILON ? UClamp(pow(dist * 0.2 * SHADOW_SCALE, 0.2)) : 1.0; \n}\nfloat InShadow(vec3 origin, vec3 dir) {\n    float dist = MIN_DIST;\n    vec3 p = origin + MIN_DIST * dir;\n    for(uint i = 0u; i < MAX_ITER && dist < MAX_DIST; i++) {\n        float h = p.y - TerrainSDF(p.xz * MAP_SCALE, 3u);\n        if (abs(h) < EPSILON * dist) { break; }\n        p += h * dir;\n        dist += h;\n    }\n    return dist < MAX_DIST ? 0.0 : 1.0; \n}\n", "buffer_a_code": "#define MAX_SPEED 0.5\n#define SPEED_ACCEL 0.1\nint stateIdx = -1;\nvec4 stateData[STATE_MAX_IDX];\nvec4 LoadState(int idx) {    \n    return stateData[idx] = texelFetch(STATE_CH, ivec2(idx % STATE_DATA_STRIDE, idx / STATE_DATA_STRIDE), 0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    stateIdx = GetStateIdx(fragCoord);\n    if (stateIdx < STATE_MAX_IDX) {\n        vec4 pos = LoadState(STATE_CAM_POS);\n\n        vec4 yPS = LoadState(STATE_CAM_DIR);\n        vec4 camPos = LoadState(STATE_CAM_HEIGHT);\n        if (pos.a <= EPSILON) {\n            pos = vec4(10,1,1,1);\n            yPS = vec4( 0.5, 0.5, 0, 0);\n        } else {\n            vec2 m = (iMouse.x < 1.0 && iMouse.y < 1.0) ? iResolution.xy * 0.5 : iMouse.xy;\n            yPS.xy += ((m / iResolution.xy) - yPS.xy) * 0.1;\n        }\n        mat3 vmat = lookMouse(2.0 * yPS.xy);\n        float speed = 0.0f;\n        float slide = 0.0f;\n        float speedBoost = 1.0f;\n        if (Key(KEYS, KEY_Q)) { speedBoost = 15.0f; }\n        if (Key(KEYS, KEY_UP, KEY_W)) { speed = MAX_SPEED * speedBoost; }\n        else if (Key(KEYS, KEY_DOWN, KEY_S)) { speed = -MAX_SPEED * speedBoost; }\n        \n        if (Key(KEYS, KEY_RIGHT, KEY_D)) { slide = MAX_SPEED; }\n        else if (Key(KEYS, KEY_LEFT, KEY_A)) { slide = -MAX_SPEED; }\n\n        yPS.z += (speed - yPS.z) * SPEED_ACCEL;\n        yPS.w += (slide - yPS.w) * SPEED_ACCEL;\n        pos.xyz += vmat[2] * yPS.z;\n        pos.xyz += vmat[0] * yPS.w;\n        stateData[STATE_CAM_DIR] = yPS;        \n        stateData[STATE_CAM_POS] = pos;\n        \n        twist = twist2;\n        camPos.xyz = vec3(pos.x, TerrainSDF(pos.xz * MAP_SCALE, 8u) + CAMERA_OFFSET, pos.z);\n        \n        float glare = pow(UClamp(dot(vmat[2], sun.dir)), 2.0) * InShadow(camPos.xyz, sun.dir); \n        camPos.w += (glare - camPos.w) * 0.05;\n        stateData[STATE_CAM_HEIGHT] = camPos;\n        fragColor = stateData[stateIdx];\n    } else {\n        discard;\n    }\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 66, 66, 373], [374, 374, 413, 413, 843], [844, 844, 909, 909, 1185], [1186, 1186, 1223, 1223, 1526], [1529, 1529, 1554, 1554, 3466], [3468, 3468, 3502, 3502, 4479], [4481, 4481, 4536, 4536, 4604]], "test": "untested"}
{"id": "Dl2yDc", "name": "invmin/invmax for free - cubemap", "author": "FabriceNeyret2", "description": "find the location of the min or max in the image for free, using GeneralPurpose MIPmaps.\nCubeMap variant of https://shadertoy.com/view/dlSyDc : robust MIPmap calculation, but half precision only.\nMouse.y: control LOD, i.e. the number tracking area.", "tags": ["minmax", "gpmipmap"], "likes": 8, "viewed": 273, "published": 3, "date": "1692385530", "time_retrieved": "2024-07-30T17:38:29.904409", "image_code": "// CubeMap variant of https://shadertoy.com/view/dlSyDc\n// inspired from https://shadertoy.com/view/3sKGWy\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float LOD = 9.;                                    // less for local extremas\n    if (iMouse.z>0.) LOD = floor(10.*iMouse.y/R.y);\n\n    O = texture(iChannel0, U/R).xxxw;                   // source image + resol\n    float l = min(10., floor(LOD+log2(1024./O.w)) ),    // select lod\n          L = exp2(l);\n    vec2 V = ( floor(U/R*1024./L)*L+L/2.+.5)/1024.;     // emulates texelFetch(LOD)\n // vec2 V =   floor(U/R*1024./L)*L         /1024.;                \n    vec4 M = C(V,0,l);                                  // fetch partial sum  \n // vec4 M = C(vec2(.5),0,10);                          // fetch partial sum\n // O += M.xyww/1024.; return;                          // ( for debug )\n // O.g += M.w; return;                                 // ( for debug )\n    M /= M.z;                                           // normalize position with weight : should show ~invmin\n    M.xy *= R;                                          // → window coordinates.\n\n    O = mix(O, vec4(1,0,0,0), smoothstep( 2.5, 1., length(M.xy-U)-LOD )); // plot the position\n\n    O = pow( O, vec4(1./2.2) );                         // back to sRGB\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === source image ================================\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.x = pow( length( texture(iChannel0, U/R).rb ) , 4. ); \n // O.x = pow( length( texture(iChannel0, U/R).rb ) / 1.3, 2.2. );// luminance\n    O.w = iChannelResolution[0].y;                                // source resolution\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define POW 9.  // the larger the better min/max, but more bigfloats precision issues\n\n#define R  iResolution.xy\n\n// CubeMap utils from  https://www.shadertoy.com/view/3tGBDz\nvec3 E;\n#define C(U,n,l) ( E =   vec3( 2.*fract(U) -1., 1 )                                             \\\n                       * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),                     \\\n                   E = (n)%3 != 2 ? E.yzx : E.xzy,                                              \\\n                   textureLod( iChannel1, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) , float(l) ) \\\n                 )", "cube_a_code": "// === prepare (inv)min/max calculation ========================\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n    \n    O *= 0.;\n    if (n>0) return;                                     // we only use Face 0                                  \n\n    U /= 1024.;                                          // normalized coordinate\n    \n // float w = pow( texture(iChannel0, U).x, -POW ) ;     // this approximates MIN. then apply pow(LODmax, -1/POW)\n    float w = pow( texture(iChannel0, U).x,  POW ) ;     // this approximates MAX. then apply pow(LODmax,  1/POW)\n \n    O.xy = U*w;                                          // weighted location\n    O.z  = w;                                            // weight\n // O.w =  texture(iChannel0, U).x;                      // ( for debug )\n}\n\n", "cube_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2yDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 146, 146, 1274]], "test": "untested"}
{"id": "ml2cWc", "name": "(fork) Cylinder - With Comments", "author": "MattOstgard", "description": "Same code as Inigo Quilez's cylinder, but added comments. Original comment:\nIntersection of a ray and a generic (oriented in any direction) capped cylinder. See capsule here: [url]https://www.shadertoy.com/view/Xt3SzX[/url]", "tags": ["3d", "raycasting"], "likes": 2, "viewed": 139, "published": 3, "date": "1692382183", "time_retrieved": "2024-07-30T17:38:30.796025", "image_code": "// The MIT License\n// Copyright © 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction\n//\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n//\n// and https://iquilezles.org/articles/intersectors\n//\n// Other cylinder functions:\n//   Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n//   Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n//   Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction.\n//\n// Arguments:\n//     - ro: The origin of the ray being cast.\n//     - rd: The direction of the ray being cast.\n//     - pa: One endpoint of the cylinder's axis.\n//     - pb: The other endpoint of the cylinder's axis.\n//     - ra: Cylinder's radius.\n//\n// Returns vec4:\n//     - x: -1 if no hit, otherwise the distance from the ray to the hit point.\n//     - yzw: Hit surface's normal.\nvec4 iCylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra ) \n{\n    // Vector from point A to point B, defining the cylinder's main axis\n    vec3  ba = pb - pa;\n    // Vector from ray origin (ro) to point A on the cylinder\n    vec3  oc = ro - pa;\n    \n    // Dot product of ba with itself, representing the squared length of the cylinder's axis\n    float baba = dot(ba,ba);\n    // Dot product of ba with ray direction (rd), representing alignment of ray with cylinder's axis\n    float bard = dot(ba,rd);\n    // Dot product of ba with oc, representing alignment of the cylinder's axis with the vector to the ray origin\n    float baoc = dot(ba,oc);\n    \n    // Quadratic coefficients for solving ray-cylinder intersection\n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    /*\n    // In case you really need to handle parallel raycasts.\n    if( k2==0.0 )\n    {\n        // Handle the case where the ray is parallel to the cylinder's axis.\n\n        // If this special case is detected (i.e., k2 == 0.0), calculate intersections with the two endpoints of the\n        // cylinder and verify that the intersection is within the cylinder's radius. If so, it returns the intersection\n        // point and surface normal information. If not, it returns -1.0, indicating no intersection.\n        \n        // Parameters for intersection with the two endpoints of the cylinder.\n        float ta = -dot(ro-pa,ba)/bard;\n        float tb = ta + baba/bard;\n        \n        // Determining the intersection point based on ray direction.\n        vec4 pt = (bard>0.0) ? vec4(pa,-ta) : vec4(pb,tb);\n        \n        // Calculating the offset from the intersection point to determine if the intersection is within the cylinder's radius.\n        vec3 q = ro + rd*abs(pt.w) - pt.xyz;\n        if( dot(q,q)>ra*ra ) return vec4(-1.0);\n        \n        // Returning the intersection point and surface normal information.\n        return vec4( abs(pt.w), sign(pt.w)*ba/sqrt(baba) );\n    }\n    */\n    \n    // Discriminant of the quadratic equation; determines whether there is an intersection.\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); // No intersection.\n    h = sqrt(h);\n    float t = (-k1-h)/k2; // The \"t\" value where the intersection occurs.\n    \n    // Checking intersection with the body of the cylinder.\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return vec4( t, (oc+t*rd - ba*y/baba)/ra );\n    \n    // Checking intersection with the end caps of the cylinder.\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h ) return vec4( t, ba*sign(y)/sqrt(baba) );\n    \n    return vec4(-1.0); // No intersection.\n}\n\n\n// Get the normal of a cylinder's body from a point on the surface.\n//\n// Arguments:\n//     - p: Point on the cylinder body.\n//     - 'a' and 'b': Points along the axis of the cylinder, defining its direction.\n//     - 'ra': The radius of the cylinder.\n//\n// Returns the cylinder body's normal.\n//\nvec3 nCylinder( in vec3 p, in vec3 a, in vec3 b, in float ra )\n{\n    // 'pa' is the vector from point 'a' to the point 'p' where we want to find the normal.\n    vec3  pa = p - a;\n\n    // 'ba' is the vector from point 'a' to point 'b', defining the direction of the cylinder's axis.\n    vec3  ba = b - a;\n\n    // 'baba' is the squared length of vector 'ba', used to normalize 'ba'.\n    float baba = dot(ba,ba);\n\n    // 'paba' is the projection of 'pa' onto 'ba', giving us the portion of 'pa' that is parallel to the cylinder's axis.\n    float paba = dot(pa,ba);\n\n    // Subtracting the projected vector (ba * paba / baba) from 'pa' gives us the vector perpendicular to the axis, \n    // pointing towards the surface of the cylinder from 'p'. Dividing by 'ra' scales it to the normal direction.\n    return (pa - ba*paba/baba)/ra;\n}\n\n\n// Same as above, but specialized to the Y axis.\n//\n// Arguments:\n//     - ro: The origin of the ray being cast.\n//     - rd: The direction of the ray being cast.\n//     - he: Cylinder's height.\n//     - ra: Cylinder's radius.\n//\n// Returns vec4:\n//     - x: -1 if no hit, otherwise the distance from the ray to the hit point.\n//     - yzw: Hit surface's normal.\n//\nvec4 iCylinderVertical( in vec3 ro, in vec3 rd, float he, float ra )\n{\n    // Quadratic coefficients for ray-cylinder intersection with a vertical axis.\n    float k2 = 1.0        - rd.y*rd.y;\n    float k1 = dot(ro,rd) - ro.y*rd.y;\n    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;\n\n    // Discriminant of the quadratic equation; determines whether there is an intersection.\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0); // No intersection.\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // Checking intersection with the body of the cylinder.\n    float y = ro.y + t*rd.y;\n    if( y>-he && y<he ) return vec4( t, (ro + t*rd - vec3(0.0,y,0.0))/ra );\n\n    // Checking intersection with the end caps of the cylinder.\n    t = ( ((y<0.0)?-he:he) - ro.y)/rd.y;\n    if( abs(k1+k2*t)<h ) return vec4( t, vec3(0.0,sign(y),0.0) );\n\n    return vec4(-1.0); // No intersection\n}\n\n// Generate a pattern (grid-like) based on the given UV coordinates.\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define camera rotation and position.\n    float an = 0.5*iTime;\n    vec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    // Create camera's orthonormal basis (u,v,w).\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n\n    // Anti-aliasing loop (if AA > 1).\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // Subpixel sampling.\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // Create view ray.\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // Define cylinder.\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n\n        // Initialize background color.\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        // Cylinder-ray intersection.\n        vec4 tnor = iCylinder( ro, rd, capA, capB, capR );\n        if( tnor.x>0.0 )\n        {\n            // Compute shading, texture, and lighting if intersection occurred.\n\n            // SHADING\n            // Calculating the position and normal at the intersection.\n            float t = tnor.x;\n            vec3  pos = ro + t*rd;\n            vec3  nor = tnor.yzw;\n\n            // LIGHTING\n            // Define the light direction and halfway vector.\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n\n            // Calculate the diffuse and ambient components using dot products.\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 ); // Diffuse lighting\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 ); // Ambient lighting\n            float occ = 0.5 + 0.5*nor.y; // Occlusion factor, contributes to ambient shading\n\n            // TEXTURING\n            // Coordinate transformation for texture mapping on the cylinder.\n            vec3 w = normalize(capB-capA);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-capA)*mat3(u,v,w);\n            col = pattern( vec2(12.0,64.0)*vec2(atan(q.y,q.x),q.z) ); // Apply texture pattern.\n\n            // Combine shading, texturing, and lighting\n            col *= vec3(0.2,0.3,0.4)*amb*occ + vec3(1.0,0.9,0.7)*dif; // Apply ambient and diffuse components.\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif; // Apply specular reflection.\n        }\n        col = sqrt( col );\n\n        // Accumulate color.\n        tot += col;\n    #if AA>1\n    }\n    // Average color for anti-aliasing.\n    tot /= float(AA*AA);\n    #endif\n\n    // Add dithering to remove banding in the background.\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n    // Output final color.\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2cWc.jpg", "access": "api", "license": "mit", "functions": [[1532, 2003, 2080, 2153, 4752], [4755, 5053, 5117, 5209, 5883], [5886, 6252, 6322, 6404, 7132], [7134, 7203, 7231, 7231, 7421]], "test": "ok"}
{"id": "ml2cD3", "name": "Liquid VHS", "author": "leon", "description": "another noise designed arranged lighted grayscale", "tags": ["weird", "gyroid"], "likes": 14, "viewed": 325, "published": 3, "date": "1692381692", "time_retrieved": "2024-07-30T17:38:31.559982", "image_code": "\n// Liquid VHS\n// by Leon Denise\n// 2023/08/18\n\n// another noise designed arranged lighted grayscale\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// mercury\n// https://mercury.sexy/hg_sdf/\nvec2 moda (vec2 p, float count)\n{\n    float an = 6.283/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a,an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n#define R iResolution.xy\n#define ss(a,b,t) smoothstep(a,b,t)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\n\nfloat fbm (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 4; ++i, a /= 2.) {\n        seed.z += result*2.5;\n        result += gyroid(seed/a)*a;\n    }\n    return result;\n}\n\nfloat fbm2 (vec3 seed)\n{\n    float result = 0., a = .5;\n    for (int i = 0; i < 4; ++i, a /= 2.) {\n        seed.z += result*.5;\n        result += (gyroid(seed/a)*a);\n    }\n    return result;\n}\n\n// heightmap\nfloat height (vec3 pos, float d)\n{\n    // noise\n    float f = fbm(pos)*.5+.5;\n    \n    // offset distance\n    d = max(0., d-.2); \n    \n    // layers thickness\n    float thin1 = .5+sin(d*12.-iTime)*.1;\n    float thin2 = d*.1;\n    f = abs(abs(abs(f)-thin1)-thin2)-.1;\n    \n    // border thickness\n    return ss(.01,-.1,f-d*.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R;\n    vec2 p = (2.*fragCoord-R)/R.y;\n    float a = atan(p.y,p.x)+iTime*.1;\n    float d = length(p);\n    \n    // noise coordinates\n    vec3 pos = vec3(p, d*.5);\n    pos.z -= iTime*.01;\n    \n    // heightmap\n    float h = height(pos, d);\n    \n    // normal from heightmap\n    #define H(e) height(pos+vec3(e,0), d)\n    vec3 e = vec3(1./R, 0);\n    vec3 n = normalize(vec3(H(-e.xz)-H(e.xz),H(-e.zy)-H(e.zy), 0.2/max(.001,d-.2)));\n    \n    // color\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*2.+a);\n    vec3 color = vec3(.05);\n    tint = mix(vec3(1), tint, ss(.0,.5,d));\n    \n    // liquid\n    float l = max(0., dot(n, -normalize(vec3(p,-1))));\n    l *= ss(-.5,.2,d);\n    color = vec3(pow(l, 1.9)*pow(1.-h, 4.))*tint;\n    color += tint*pow(l, 20.);\n    color *= ss(0.,.1,h);\n    \n    // background shape and lighting\n    e = vec3(.01,0,0);\n    pos = vec3(p, 0.);\n    pos += h*.02;\n    pos.x = abs(pos.x)-iTime*.1+0.05/max(.0,abs(p.x)+.1);\n    float x = (fbm2(pos+e.yxy)-fbm2(pos-e.yxy))/(2.*e.x);\n    float y = (fbm2(pos+e.xyy)-fbm2(pos-e.xyy))/(2.*e.x);\n    vec2 curl = vec2(-x,y);\n    p += curl*.1*ss(.9,.0,abs(p.x)-.7);\n    float shape = abs(p.y)-.2;\n    float strips = mix(.8+.2*sin(uv.y*1000.+iTime*10.+h*5.+uv.x*200.), 1., d);\n    color += strips*tint*min(1., (0.00+h*.1)/max(0.,shape));\n    color *= mix(1.,.2,h*d);\n    color = mix(color, vec3(0), ss(mix(0.01, .1,h),.0,abs(p.y)-mix(0.1, .01,h)));\n    color = mix(color, vec3(1), ss(mix(0.01, .1,h),.0,abs(p.y-.05)-mix(0.05, .01,h)));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2cD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 159, 182, 182, 285], [286, 286, 308, 308, 432], [434, 477, 510, 510, 642], [705, 705, 724, 724, 769], [770, 770, 796, 796, 835], [837, 837, 860, 860, 1027], [1029, 1029, 1053, 1053, 1221], [1223, 1236, 1270, 1283, 1564], [1566, 1566, 1623, 1642, 3184]], "test": "untested"}
{"id": "dtjcWc", "name": "Fork Fork AI no supernlogn 943", "author": "supernlogn", "description": "Using discrete sharpness filter over previous work of beating heart\n", "tags": ["2d", "heart", "ecg", "sharpnessfilter"], "likes": 1, "viewed": 118, "published": 3, "date": "1692381046", "time_retrieved": "2024-07-30T17:38:32.541358", "image_code": "// CC0: AI not included\n// Tinkering around with old shaders.\n// No AI and very little human intelligence used ;)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.58;\nconst vec3 dbcol = HSV2RGB(vec3(hoff+0.96, 0.8, 0.75));\nconst vec3 sbcol = HSV2RGB(vec3(hoff+0.95, 0.4, 1.0));\nconst vec3 gbcol = HSV2RGB(vec3(hoff+0.98, 0.9, 0.001));\nconst vec3 fbcol = HSV2RGB(vec3(hoff+0.95, 0.7, 2.0));\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n\nfloat computeBeat() {\n    float timeSlow = TIME; // this works for 60 fps as we use coefficients till 60 Hz\n    float val = (0.37785045725124383) * cos(0.3141592653589793 * timeSlow)+(2.3364232140542085) * cos(1.5707963267948966 * timeSlow)+(18.717028467910303) * cos(1.6336281798666925 * timeSlow)+(3.696330823238726) * cos(1.7592918860102842 * timeSlow)+(9.578403455815018) * cos(1.8221237390820801 * timeSlow)+(1.3625736929657797) * cos(1.8849555921538756 * timeSlow)+(2.7942202996192163) * cos(1.9477874452256716 * timeSlow)+(1.7711610615255986) * cos(2.0106192982974678 * timeSlow)+(0.9713881229829386) * cos(2.0734511513692637 * timeSlow)+(1.721581029181113) * cos(2.1362830044410597 * timeSlow)+(1.0957706783455479) * cos(2.199114857512855 * timeSlow)+(1.0743272383031455) * cos(2.261946710584651 * timeSlow)+(1.9237696070026973) * cos(2.324778563656447 * timeSlow)+(3.0501469540827926) * cos(2.4504422698000385 * timeSlow)+(3.57347625097854) * cos(2.57610597594363 * timeSlow)+(4.164819657445082) * cos(2.701769682087222 * timeSlow)+(0.9780693241331418) * cos(2.764601535159018 * timeSlow)+(13.732993114269574) * cos(2.827433388230814 * timeSlow)+(8.990633102958629) * cos(2.9530970943744057 * timeSlow)+(6.260044998909341) * cos(3.141592653589793 * timeSlow)+(2.422189622275397) * cos(3.267256359733385 * timeSlow)+(15.933357175405717) * cos(3.4557519189487724 * timeSlow)+(0.3716019058694118) * cos(3.581415625092364 * timeSlow)+(4.2045240500285095) * cos(3.6442474781641603 * timeSlow)+(0.43314671398601945) * sin(0.3141592653589793 * timeSlow)+(10.259948928086486) * sin(1.5707963267948966 * timeSlow)+(12.083461743869616) * sin(1.6336281798666925 * timeSlow)+(8.091002375361459) * sin(1.7592918860102842 * timeSlow)+(-4.947019252504502) * sin(1.8221237390820801 * timeSlow)+(0.0600410407611961) * sin(1.8849555921538756 * timeSlow)+(5.842610601241493) * sin(1.9477874452256716 * timeSlow)+(1.3074994797075126) * sin(2.0106192982974678 * timeSlow)+(2.0786788597400236) * sin(2.0734511513692637 * timeSlow)+(1.876456336333239) * sin(2.1362830044410597 * timeSlow)+(2.2983684279760968) * sin(2.199114857512855 * timeSlow)+(1.5756881298204577) * sin(2.261946710584651 * timeSlow)+(0.7598722612130775) * sin(2.324778563656447 * timeSlow)+(3.092277842258946) * sin(2.4504422698000385 * timeSlow)+(1.1479047878773916) * sin(2.57610597594363 * timeSlow)+(2.2552228380551265) * sin(2.701769682087222 * timeSlow)+(-1.1038233102198718) * sin(2.764601535159018 * timeSlow)+(4.851386456130351) * sin(2.827433388230814 * timeSlow)+(13.47166890824398) * sin(2.9530970943744057 * timeSlow)+(-29.19821342041527) * sin(3.141592653589793 * timeSlow)+(-1.5531119423375312) * sin(3.267256359733385 * timeSlow)+(-2.646483440926437) * sin(3.4557519189487724 * timeSlow)+(6.665382994344453) * sin(3.581415625092364 * timeSlow)+(-4.85667950496648) * sin(3.6442474781641603 * timeSlow);\n    return -val/100.0;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  float beatFraction = computeBeat();\n  p.x = pabs(p.x, 0.05) * (0.90 + 0.10 * beatFraction);\n  p.y = p.y * (0.93 + 0.07 * beatFraction);\n  if( p.y+p.x>1.0 )\n      return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n  return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                  dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat df(vec2 p) {\n  vec2 hp = p;\n  const float hz = 1.0;\n  hp /= hz;\n  hp.y -= -0.6;\n  float d = heart(hp)*hz;\n  return d;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float h = (-20.0*d);\n  h = tanh_approx(h);\n  h -= 3.0*length(p);\n  h = pmin(h, 0.0, 1.);\n  h *= 0.25;\n  return h;\n}\n\nvec3 nf(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = hf(p + e.yx) - hf(p - e.yx);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  float f = (aggr * 0.5) + 0.5;\n  \n  return f;\n}\n\nfloat divf(float offset, float f) {\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  float r = abs(goff + offset - f);\n  r = max(r, gfloor);\n  return r;\n}\n\n// This way of computing \"lightning\" I found at shadertoy. Unfortunately I don't remember where.\nvec3 lightning(vec2 pos, vec2 pp, float offset) {\n  vec3 sub = 0.03*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n\n  float time = TIME+123.4;\n  float stime = time/200.0;\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*cos(vec2(sqrt(0.5), 1.0)*stime)+vec2(0.0, -11.0)*stime;\n  const float glow = 0.0125;\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  for (float i = 0.0; i < 3.0; ++i) {\n    vec3 gcol0 = (1.0+cos(0.50*vec3(0.0, 1.0, 2.0) +time+3.0*pos.x-0.33*i));\n    vec3 gcol1 = (1.0+cos(1.25*vec3(0.0, 1.0, 2.0) +2.*time+pos.y+0.25*i));\n    float btime = stime*85.0 + (i);\n    float rtime = stime*75.0 + (i);\n    float div1 = divf(offset, fbm((pos + f) * 3.0, rtime));\n    float div2 = divf(offset, fbm((pos + f) * 2.0, btime));\n    float d1 = offset * glow / div1;\n    float d2 = offset * glow / div2;\n    col += (d1 * gcol0)-sub;\n    col += (d2 * gcol1)-sub;\n  }\n    \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 4.0/RESOLUTION.y;\n  float d = df(p);\n  float h = hf(p);\n  vec3 n = nf(p);\n  const vec3 lp = vec3(-4.0, -5.0, 3.0);\n  const vec3 ro = vec3(10.0, 00.0, 0.0);\n  vec3 p3 = vec3(p, h); \n  vec3 rd = normalize(p3-ro);\n  vec3 ld = normalize(lp-p3);\n  vec3 r = reflect(rd, n);\n  float diff = max(dot(ld, n), 0.0);\n  vec3 dcol = dbcol*mix(vec3(0.15), vec3(1.0), diff);\n  float spe = pow(max(dot(ld, r), 0.0), 3.0);\n  vec3 scol = spe*sbcol;\n  float gd = d+0.0;\n  vec2 gp = p;\n  vec3 gcol = lightning(gp, pp, gd);\n  vec3 hcol = dcol;\n  hcol += scol;\n  vec3 col = vec3(1.0);\n  col += gbcol/max(0.01*(dot2(p)-0.15), 0.0001);\n  col += gcol;\n  col = mix(col, hcol, smoothstep(0.0, -aa, d));\n  col = mix(col, fbcol, smoothstep(0.0, -aa, abs(d+0.01)-0.01));\n  col *= smoothstep(1.75, 0.5, length(pp));\n\n  col = aces_approx(col); \n  col = sqrt(col); \n  return col;\n}\n\nfloat laplacian[9] = float[9](0.0, -1.0, 0.0, \n                            -1.0, 4.0, -1.0,\n                             0.0, -1.0, 0.0);\nconst float sharpness = 0.0;\n\nvec4 sharpness_filter(float[36] color_table) {\n    float color[4] = float[4](0.0,0.0,0.0,0.0);\n    for (int j = 0; j < 4; ++j) {\n        for (int i = 0; i < 9; ++i) {\n            color[j] += sharpness * laplacian[i] * color_table[i*4];\n        }\n     }\n    \n    return vec4(color[0] + color_table[18], color[1] + color_table[19], color[2] + color_table[20], 1.0);\n}\n\nvec4 getColorAtq(vec2 q) {\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  return vec4(col.yxz, 1.0);\n}\n\nfloat[36] get_color_table(vec2 fragCoord) {\n    float A[36];\n    vec2 q;\n    vec4 c;\n    for (int i = -1; i<2;++i) {\n        for (int j = -1; j < 2; ++j) {\n            q = (fragCoord + vec2(i,j) )/RESOLUTION.xy;\n            c = getColorAtq(q);\n            A[18 + i*3*4 +j*4] = c.x; \n            A[18 + i*3*4 +j*4 + 1] = c.y; \n            A[18 + i*3*4 +j*4 + 2] = c.z; \n            A[18 + i*3*4 +j*4 + 3] = c.w; \n        }\n    }\n    return A;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  float A[36] = get_color_table(fragCoord);\n  fragColor = sharpness_filter(A);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjcWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 425, 425, 571], [1115, 1243, 1271, 1337, 1413], [1415, 1522, 1548, 1548, 1733], [1735, 1835, 1874, 1874, 1959], [1961, 2049, 2079, 2079, 2107], [2109, 2109, 2129, 2129, 2151], [2154, 2154, 2175, 2175, 5052], [5054, 5172, 5193, 5193, 5522], [5524, 5524, 5542, 5542, 5649], [5651, 5651, 5669, 5669, 5806], [5808, 5808, 5825, 5825, 6015], [6017, 6017, 6036, 6036, 6159], [6161, 6161, 6182, 6182, 6609], [6611, 6611, 6642, 6642, 7003], [7005, 7005, 7040, 7040, 7168], [7170, 7267, 7316, 7316, 8147], [8149, 8149, 8179, 8179, 9040], [9577, 9577, 9603, 9603, 9738], [10186, 10186, 10241, 10241, 10358]], "test": "untested"}
{"id": "ml2yWc", "name": "HSV Blend", "author": "VEShaderStuff", "description": "..", "tags": ["hsv"], "likes": 0, "viewed": 104, "published": 3, "date": "1692380714", "time_retrieved": "2024-07-30T17:38:33.440953", "image_code": "// RGB Variables\n\nconst float r = 255.5;\nconst float g = 127.0;\nconst float b = 0.0;\n\n// Required RGB stuff\n\nfloat hueToRgb(float p, float q, float t)\n{\n    if (t < 0.0) t += 1.0;\n    if (t > 1.0) t -= 1.0;\n    if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;\n    if (t < 1.0 / 2.0) return q;\n    if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;\n    return p;\n}\nvec3 hslToRgb(vec3 hsl)\n{\n    vec3 rgb;\n    \n    if (hsl.y == 0.0)\n    {\n        rgb = vec3(hsl.z); // Grayscale\n    }\n    else\n    {\n        float q = (hsl.z < 0.5) ? (hsl.z * (1.0 + hsl.y)) : (hsl.z + hsl.y - hsl.y * hsl.z);\n        float p = 2.0 * hsl.z - q;\n        \n        rgb.r = hueToRgb(p, q, hsl.x + 1.0 / 3.0);\n        rgb.g = hueToRgb(p, q, hsl.x);\n        rgb.b = hueToRgb(p, q, hsl.x - 1.0 / 3.0);\n    }\n    \n    return rgb;\n}\nvec3 rgbToHsl(vec3 color)\n{\n    vec3 hsl;\n    float maxVal = max(max(color.r, color.g), color.b);\n    float minVal = min(min(color.r, color.g), color.b);\n    \n    hsl.z = (maxVal + minVal) / 2.0;\n    \n    if (maxVal == minVal)\n    {\n        hsl.x = 0.0;\n        hsl.y = 0.0;\n    }\n    else\n    {\n        float d = maxVal - minVal;\n        \n        hsl.y = (hsl.z < 0.5) ? (d / (maxVal + minVal)) : (d / (2.0 - maxVal - minVal));\n        \n        if (maxVal == color.r)\n            hsl.x = (color.g - color.b) / d + (color.g < color.b ? 6.0 : 0.0);\n        else if (maxVal == color.g)\n            hsl.x = (color.b - color.r) / d + 2.0;\n        else\n            hsl.x = (color.r - color.g) / d + 4.0;\n        \n        hsl.x /= 6.0;\n    }\n    \n    return hsl;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Define the resolution of the screen\n    vec2 resolution = iResolution.xy;\n    \n    // Normalize the coordinates\n    vec2 uv = fragCoord.xy / resolution;\n    \n    // Sample the texture\n    vec4 texColor = texture(iChannel0, uv);\n    \n    // Define hue shifts for red, green, and blue channels\n    float redHueShift = r / 255.0;   // Hue shift for red channel\n    float greenHueShift = g / 255.0; // Hue shift for green channel\n    float blueHueShift = b / 255.0;  // Hue shift for blue channel\n    \n    // Convert the RGB color to HSL\n    vec3 hsl = rgbToHsl(texColor.rgb);\n    \n    // Apply hue shifts to the red, green, and blue channels\n    hsl.x = fract(hsl.x + redHueShift);   // Apply hue shift to red channel\n    hsl.y = fract(hsl.y + greenHueShift); // Apply hue shift to green channel\n    hsl.z = fract(hsl.z + blueHueShift);  // Apply hue shift to blue channel\n    \n    // Convert the modified HSL color back to RGB\n    vec3 modifiedColor = hslToRgb(hsl);\n    \n    // Output the modified color\n    fragColor = vec4(modifiedColor, texColor.a);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2yWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 152, 152, 375], [376, 376, 401, 401, 816], [817, 817, 844, 844, 1575], [1577, 1577, 1632, 1675, 2693]], "test": "untested"}
{"id": "dt2cD3", "name": "Strange Lab Goop", "author": "N8Shader", "description": "ey", "tags": ["clay"], "likes": 7, "viewed": 158, "published": 3, "date": "1692378940", "time_retrieved": "2024-07-30T17:38:34.429311", "image_code": "float w0(float a)\n{\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nfloat w1(float a)\n{\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nfloat w2(float a)\n{\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nfloat w3(float a)\n{\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 and g1 are the two amplitude functions\nfloat g0(float a)\n{\n    return w0(a) + w1(a);\n}\n\nfloat g1(float a)\n{\n    return w2(a) + w3(a);\n}\n\n// h0 and h1 are the two offset functions\nfloat h0(float a)\n{\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nfloat h1(float a)\n{\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 texture_bicubic(sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod)\n{\n\tuv = uv*texelSize.zw + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\n    float g0x = g0(fuv.x);\n    float g1x = g1(fuv.x);\n    float h0x = h0(fuv.x);\n    float h1x = h1(fuv.x);\n    float h0y = h0(fuv.y);\n    float h1y = h1(fuv.y);\n\n\tvec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\tvec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\t\n    vec2 lodFudge = pow(1.95, lod) / fullSize;\n    return g0(fuv.y) * (g0x * \n        textureLod(tex, p0, lod)  +\n                        \n        g1x * textureLod(tex, p1, lod)\n                    ) +\n           g1(fuv.y) * (\n            g0x * textureLod(tex, p2, lod)  +\n                        g1x * textureLod(tex, p3, lod));\n}\n\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n vec2 fullSize = vec2(textureSize(s, 0));\n vec4 floorSample = texture_bicubic( s, uv, vec4(1.0 / lodSizeFloor.x, 1.0 / lodSizeFloor.y, lodSizeFloor.x, lodSizeFloor.y), fullSize, floor(lod));\n vec4 ceilSample = texture_bicubic( s, uv, vec4(1.0 / lodSizeCeil.x, 1.0 / lodSizeCeil.y, lodSizeCeil.x, lodSizeCeil.y), fullSize, ceil(lod));\n return mix(floorSample, ceilSample, fract(lod));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float height = texture(iChannel0, fragCoord.xy / iResolution.xy, 0.0).r;\n    //float mippedHeight = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 4.0).r;\n    //float occlusion = 10.0 * max(mippedHeight - height, 0.0);\n    float occlusion = 0.0;\n    for(float i = 2.0; i <= 5.0; i++) {\n        float mippedHeight = textureBicubic(iChannel0, fragCoord.xy / iResolution.xy, i).r;\n        occlusion += 4.0 * max(mippedHeight - height, 0.0) * (1.0 / i);\n    }\n    vec3 col = mix(vec3(0.8, 0.6, 0.4), vec3(1.0), height) * (1.0 - occlusion);\n    vec3 pos = vec3(fragCoord.xy, height);\n    vec3 totalNormal = vec3(0.0);\n    for(float i = 3.0; i <= 5.0; i++) {\n    float mipLevel = i;\n    float texelStep =pow(2.0, mipLevel);\n    vec3 normal = normalize(vec3(\n        5.0 * (textureBicubic(iChannel0, (fragCoord.xy + vec2(texelStep, 0.0)) / iResolution.xy, mipLevel).r -  textureBicubic(iChannel0, (fragCoord.xy - vec2(texelStep, 0.0)) / iResolution.xy, mipLevel).r),\n        5.0 * (textureBicubic(iChannel0, (fragCoord.xy + vec2(0.0, texelStep)) / iResolution.xy, mipLevel).r -  textureBicubic(iChannel0, (fragCoord.xy - vec2(0.0, texelStep)) / iResolution.xy, mipLevel).r),\n        1.0\n    ));\n    totalNormal += normal;\n    }\n    vec3 normal = normalize(totalNormal);\n    float lambert = max(dot(normal, vec3(0.0, 0.0, 1.0)), 0.0);\n    vec3 rayDir = normalize(vec3((fragCoord.xy - iResolution.xy / 2.0) / iResolution.y, 1.0));\n    vec3 envSampleDir = reflect(rayDir, normal);\n    vec3 envSample = textureLod(iChannel1, envSampleDir, 3.0).rgb;\n    vec3 applied = 0.6 * col + 0.4 * col * envSample;\n    fragColor = vec4(applied,1.0);\n\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define NUM_OCTAVES 3\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    // Time varying pixel color\n    float fbmRes = fbm(vec3(fragCoord * 0.001, fbm(vec3(fragCoord * 0.001, fbm(vec3(0.001 * fragCoord, 0.1 * iTime + fbm(vec3(fragCoord * 0.0001, 0.1 * iTime))))))));\n    float ramp = 0.5 + 0.5 * fbmRes;\n    ramp = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, ramp));\n    ramp = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, ramp));\n    float fRamp = ramp;\n    // Output to scree\n    fragColor = vec4(ramp, 0.0, 0.0, 0.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2cD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 74], [76, 76, 95, 95, 145], [147, 147, 166, 166, 225], [227, 227, 246, 246, 278], [280, 325, 344, 344, 372], [374, 374, 393, 393, 421], [423, 465, 484, 484, 529], [531, 531, 550, 550, 594], [596, 596, 684, 684, 1525], [1528, 1528, 1582, 1582, 2079], [2080, 2080, 2137, 2137, 3777]], "test": "untested"}
{"id": "DdKGDV", "name": "Sleep Paralysis [SOUND ON]", "author": "crocidb", "description": "you're awake but you can't move\nweird things start to happen", "tags": ["sound", "music", "horror", "sleep"], "likes": 25, "viewed": 417, "published": 3, "date": "1692369354", "time_retrieved": "2024-07-30T17:38:35.382761", "image_code": "// \n// Sleep Paralysis [SOUND ON]\n// \n// you're awake but you can't move\n// weird things start to happen\n// \n// by Bruno Croci\n// https://crocidb.com/\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // uv distortion\n    uv += vec2(\n        texture(iChannel1, 0.3 * (uv + vec2(iTime * .11, iTime * .1))).r,\n        texture(iChannel1, 0.34 * (uv + vec2(iTime * .14, (iTime + 123.0) * .12))).r) * .02;\n    \n    // chromatic aberration\n    float spread = length(uv) * .009 * pow(sin(iTime * 0.75), 9.0) + .002;\n    vec4 color = vec4(\n        texture(iChannel0, uv - (vec2(spread, 0.0))).r,\n        texture(iChannel0, uv).g,\n        texture(iChannel0, uv + (vec2(spread, 0.0))).b,\n        1.0);\n\n    // grain\n    vec2 guv = uv + noise(vec2(iTime)) + noise(vec2(uv));\n    float h = hash12(guv)*0.3+0.7;\n    color = color * mix(1.0, h, clamp(color.y, 0.7, 1.0));\n    \n    // gamma\n    color.xyz = pow( color.xyz, vec3(0.655) );\n    \n    fragColor = color;\n}\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define TWO_PI 6.2831\n\nvec2 pan(float p)\n{\n    vec2 np = vec2(1.0 - p, 1.0 + p);\n    return normalize(np);\n}\n\nfloat FM(float fc, float fm, float iom, float time)\n{\n    return sin(TWO_PI * fc * time + iom * sin(TWO_PI * fm * time));\n}\n\nfloat click(float t)\n{\n    float a = fract( sin( 253.9898 * mod(t * 2.3, 0.5) ) * 19375.5453 );\n    float b = FM(10.0, 20.0, 6.4, t);\n    return (a * b) * exp(-12.0 * t) * .1;\n}\n\nvec2 bell(float t)\n{\n    vec2 b = FM(55.0, 220.0, 3.4, t) * pan(-1.) + FM(60.0, 240.0, 3.4, t) * pan(1.);\n    return b * exp(-1.0 * t) * .5;\n}\n\nvec2 fm_tone(float freq, float time)\n{\n    float fc = freq;\n    float fm = freq * 1.;\n    float iom = 1.0;\n\n    float env = exp(-3.0 * time) * .2;\n\n    vec2 s = vec2(0.0);\n\n    s += FM(fc + 1., fm + 1., iom, time) * env * pan(-0.5f);\n    s += FM(fc - 1., fm - 1., iom, time) * env * pan(0.5f);\n    s += FM(fc * .5, fm * 1.5, .4, time) * exp(-1.0 * time) * .05 * pan(0.0f);\n\n    s += FM(fc * .25, fm, 1.0 + 5.0 * sin(time * 6.0), time) * env * pan(0.0f) * .1;\n\n    s += FM(fc * 1.0, fm * 1.0, 5. + + 5.0 * sin(time * 20.0), time) * exp(-1.5 * time) * pan(0.0f) * .01;\n    s += FM(fc * 1.0, fm, 25., time) * exp(-20.0 * time) * pan(0.0f) * 0.02;\n\n    return s;\n}\n\nfloat interval(float semitones)\n{\n    return pow(2., semitones/12.0);\n}\n\nconst float notes[] = float[30](\n    0.0, 1.0,\n    0.0, 1.0,\n    7.0, 1.0,\n    7.0, 1.0,\n    9.0, 1.0,\n    9.0, 1.0,\n    7.0, 1.0,\n    0.0, 0.0,\n    5.0, 1.0,\n    5.0, 1.0,\n    4.0, 1.0,\n    4.0, 1.0,\n    2.0, 1.0,\n    2.0, 1.0,\n    0.0, 1.0  \n);    \n\nvec2 melody(float time)\n{\n    vec2 signal = vec2(0.0);\n\n    for (int i = 0; i < 15; i++)\n    {\n        float note = notes[i * 2];\n        float fq = 880.0 * interval(note);\n        float t = mod(time - (float(i) * .25), 4.75);\n        signal += fm_tone(fq, t) * normalize(pan(-1.0 + mod(float(i), 3.0)) * .4f) * notes[i * 2 + 1];\n        signal += fm_tone(fq, 4.75 - t) * notes[i * 2 + 1] * .1;\n    }\n\n    return signal;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 s = vec2(0.0);\n\n    // click\n    float t = mod(time, 4.0);\n    float t2 = mod(time - 1.0, 4.0);\n    s += (click(t) + click(t2)) * pan(.5);\n\n    // bell\n    s += bell(mod(time + 4.0, 16.));\n\n    time = mod(time, 180.0);\n\n    // tv static\n    s += vec2(fract( sin( 22353.9898 * mod(time * .1, 0.5) ) * 19375.5453 )) * pan(-.6) * .05;\n\n    // melody\n    time *= .5f;\n    time = time + sin(time * 0.4) * .14f;\n    s += melody(time);\n\n    return s;\n}\n", "sound_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Rotation\nmat3 rotateX(float phi)\n{\n    float c = cos(phi);\n    float s = sin(phi);\n\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, c, -s),\n        vec3(0.0, s, c));\n}\n\nmat3 rotateY(float theta)\n{\n\tfloat c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(c, 0.0, s),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-s, 0.0, c));\n}\n\nmat3 rotateZ(float psi)\n{\n    float c = cos(psi);\n    float s = sin(psi);\n\n    return mat3(\n        vec3(c, -s, 0.0),\n        vec3(s, c, 0.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\n// SDF\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// SDF Operators\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// Noise\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st)\n{\n    vec2 f = fract(st);\n    vec2 i = floor(st);\n    \n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    \n    float r = mix( mix( dot( random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    return r * .5 + .5;\n}\n\nfloat fbm(vec2 st)\n{\n    float value = 0.;\n    float amplitude = .5;\n    float frequency = 0.;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    \n    return value;\n}\n\n// Noise and FBM (as seen on iq tutorials)\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "buffer_a_code": "#define AA 1\n\n#define ZERO (min(iFrame,0))\n#define MAX_STEPS\t\t\t150\n#define MAX_DIST\t\t\t18.0\n#define SURFACE_DIST\t\t0.006\n\nvec3 ro = vec3(0.2, 3.2, -0.2);\n\nbool light_on = true;\nbool eyes_on = false;\n\nfloat oTime;\n\nvec2 closest(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 gp;\n    float gf;\n\n    // wall\n    vec3 wp = vec3(5.0, 0.0, 0.0);\n    vec3 ws = vec3(.2, 5.0, 5.0);\n    float w = sdBox(abs(p) - wp, ws);\n    w = min(w, sdBox(abs(p) - wp.zyx, ws.zyx));\n\n    vec2 wall = vec2(w, 1.0);\n    \n    // drawer\n    gp = vec3(0.0, .83, 4.3);\n    gf = sdBox(p - gp, vec3(1.0, 0.8, 0.4)) - .05;\n    gf = min(gf, sdBox(p - gp - vec3(0.0, 0.5, 0.0), vec3(0.9, 0.15, 0.45)) - .05);\n    gf = min(gf, sdSphere(p - gp - vec3(0.0, 0.5, -0.55), .07));\n\n    gf = min(gf, sdBox(p - gp + vec3(0.0, -0.05, 0.0), vec3(0.9, 0.15, 0.45)) - .05);\n    gf = min(gf, sdSphere(p - gp + vec3(0.0, -0.05, 0.55), .07));\n\n    gf = min(gf, sdBox(p - gp + vec3(0.0, 0.45, 0.0), vec3(0.9, 0.18, 0.45)) - .05);\n    gf = min(gf, sdSphere(p - gp + vec3(0.0, 0.45, 0.55), .07));\n\n    vec2 drawer = vec2(gf, 3.0);\n\n    // tv\n    gp = vec3(0.0, 2.21, 4.3);\n    vec3 rp = (p - gp) * rotateY(-0.7) + gp;\n    gf = sdBox(rp - gp, vec3(0.5, 0.5, 0.23)) - .05;\n    gf = opSmoothUnion(gf, sdBox(rp - gp - vec3(0.0, -0.05, 0.5), vec3(.35, .38 * (1.0 - clamp(rp.z - 4.5, 0., 1.)), .25)) - .07, 0.20);\n    gf = opSmoothSubtraction(sdBox(rp - vec3(0.0, 2.26, 3.29), vec3(0.29, 0.21, 0.95)) - .13, gf, 0.19);\n    vec2 tv = vec2(gf, 4.0);\n\n    // tv screen\n    gp = gp + vec3(-0.04, 0.05, -0.);\n    gf = sdBox(rp - gp, vec3(0.4, 0.29, 0.1)) - .1 + 000.0;\n    vec2 screen = vec2(gf, 5.0);\n\n    // floor\n    float f = dot(p, vec3(0.0, 1.0, 0.0));\n    vec2 flo = vec2(f, 2.0);\n\n    // eyes\n    if (!light_on && eyes_on)\n    {\n        gp = vec3(-1.6, 0.8, 0.6);\n        rp = (p - gp) * rotateY(-0.3) + gp;\n        gf = sdSphere(rp - gp, .027);\n        gf = min(sdSphere(rp - gp + vec3(0.0, 0.0, .12), .027), gf);\n        flo = closest(flo, vec2(gf, 6.0));\n    }\n    \n    return closest(closest(wall, closest(closest(screen, tv), drawer)), flo);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e).x;\n    }\n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec3 p;\n    vec2 obj;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        p = ro + t * rd;\n        obj = map(p);\n        if (obj.x < SURFACE_DIST || t > MAX_DIST) break;\n        t += obj.x;\n    }\n    \n    obj.x = t;\n    return obj;\n}\n\n// Lighting\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.002f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec2 obj = map(p + n * t);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat getVisibility(vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < MAX_DIST)\n\t{\n\t\tvec2 o = map(p0 + rd * t);\n\n\t\tif(o.x < SURFACE_DIST)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\n\t\tt += o.x;\n\t}\n\n\treturn f;\n}\n\n// Texturing\nvec2 triplanar(vec3 p, vec3 normal)\n{\n    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) > .8)\n    {\n        return p.xz;\n    }\n    else if (abs(dot(normal, vec3(1.0, 0.0, 0.0))) > .8)\n    {\n        return p.yz;\n    }\n    else\n    {\n        return p.xy;\n    }\n}\n\nvec3 textureWood(vec2 uv)\n{\n    uv.x *= .6;\n    \n    float no = noise(vec2(1.2, 2.4) + uv * 6.);\n\n    float n0 = .6 + .4 * smoothstep(\n        .24,\n        0.55,\n        fbm(vec2(uv.x * 10., uv.y * 30.) + vec2(15.0, 10.0)));\n    uv += no;\n    float n1 = fbm(vec2(uv.x * 5., uv.y * 20.) + vec2(2.0, 2.0));\n    float n2 = smoothstep(\n        1.0,\n        0.3,\n        fbm(vec2(uv.x * 1., uv.y * 10.)));\n    \n    vec3 col = n0 * n1 * n2 * vec3(0.92, 0.5, 0.2);\n    return pow(col, vec3(1.0));\n}\n\nvec3 textureWall(vec2 uv)\n{\n    vec2 iuv = floor(uv * 10.0);\n    vec3 col = clamp(smoothstep(0.14, 0.65, noise(uv * 10.4) * fbm(uv * 18.0)) + .9, 0.0, 1.0) * vec3(0.85, 0.8, 0.7);\n    return col;\n}\n\nvec3 textureFloor(vec2 uv)\n{\n    uv *= .5;\n    vec2 tiling = vec2(6.0, 80.0);\n    vec2 uv2 = vec2(0.0);\n    uv2.y = floor(uv.y * tiling.y) / tiling.y;\n    uv2.x = (mod(uv2.y * tiling.y, 2.0) == 0.0) ? floor((uv.x * tiling.x)) / tiling.x : floor(((uv.x + .09) * tiling.x)) / tiling.x;\n    uv += uv2 * 2.0;\n    uv *= 10.;\n    \n    float n0 = .6 + .4 * smoothstep(\n        .24,\n        0.52,\n        fbm(vec2(uv.x * 10., uv.y * 60.) + vec2(14.0, 10.0)));\n    \n    vec3 col = n0 * vec3(0.88, 0.64, 0.3) * (noise(uv2*44.0) * .7 + .3);\n    return pow(col, vec3(1.0));\n}\n\nvec3 tvscreen(vec2 uv)\n{\n    vec2 iuv = floor(uv * 10.0);\n    vec3 col = hash1((iTime + 10.) * uv * 1.0) * vec3(4.3, 4.3, 8.0) * 12.0;\n    col *= pow(0.7 - distance(uv, vec2(.5, .5)), 0.8);\n\n    return col;\n}\n\n// Renderer\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv)\n{\n    vec3 col;\n    \n    vec3 normal = calcNormal(p);\n    float fog;\n    \n    if (obj.x >= MAX_DIST)\n    {\n        col = vec3(1.0, 0.6, 0.4) * (uv.y + .6);\n    }\n    else\n    {\n        fog = pow((obj.x / MAX_DIST), 8.3);\n        float aa = pow(ambientOcclusion(p, normal), 2.0);\n\n        float diff_mask = 1.0;\n        float spec_power = 15.0;\n        float spec_mask = 1.0;\n\n        vec3 albedo = vec3(0.);\n        \n        if (obj.y >= 6.0) // eyes\n        {\n            albedo = vec3(1.0, .1, .1) * 440.;\n            spec_power = 40.0;\n            spec_mask = 1.3;\n        }\n        else if (obj.y >= 5.0) // tv screen\n        {\n            vec2 uv = mod((triplanar(p * rotateY(-.7), normal) + vec2(-.4, 0.42)) * vec2(1.1, 1.3), vec2(1.0, 1.0));\n            albedo = tvscreen(uv);\n            spec_power = 40.0;\n            spec_mask = 1.3;\n        }\n        else if (obj.y >= 4.0) // tv\n        {\n            vec2 uv = triplanar(p, normal) * 0.8;\n            albedo = vec3(.2, .2, .2);\n            spec_power = 10.0;\n            spec_mask = 1.0;\n        }\n        else if (obj.y >= 3.0) // drawer\n        {\n            vec2 uv = triplanar(p, normal) * 0.8;\n            albedo = textureWood(uv) * 1.1;\n        }\n        else if (obj.y >= 2.0) // floor\n        {\n            vec2 uv = triplanar(p, normal) * 0.168 + 1.1;\n            albedo = textureFloor(uv);\n            spec_power = 25.0;\n            spec_mask = 1.0;\n        }\n        else if (obj.y >= 1.0) // walls\n        {\n            vec2 uv = triplanar(p, normal) * 3.0;\n            \n            uv = mod(uv * 0.02 + 0.5, 1.0);\n            albedo = textureWall(uv) * vec3(0.905, 0.854, 0.684);\n            spec_power = 2.0;\n            spec_mask = .5;\n        }\n\n        #if 1\n        col += albedo * aa * .08;\n        #endif\n\n        // top Light\n        if (light_on)\n        {\n            vec3 light_pos = vec3(-2.0, 5.0, 0.4);\n            vec3 light_col = vec3(0.9, 0.6, 0.3) * .7;\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = dot(light_dir, normal);\n            float visibility = getVisibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            if (obj.y < 5.0) col += diff_mask * diffuse * albedo * visibility * light_col * .36 * aa;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n\n        // TV Light\n        #if 1\n        if (obj.y < 5.0)\n        {\n            vec3 light_pos = vec3(-0.3, 2.93, 3.9);\n            vec3 light_col = vec3(0.15, 0.22, 0.7) * ((.5 + .5 * sin(iTime * 85.)) * .07 + .3);\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = abs(dot(light_dir, normal));\n            float visibility = getVisibility(p, light_pos, 5.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            if (p.z < 4.75) visibility = visibility + smoothstep(visibility, (p.z + 4.0) * .3, 1.0);\n\n            float intensity = 0.8;\n            if (!light_on) intensity = 3.0;\n            \n            col += diff_mask * diffuse * albedo * visibility * light_col * intensity * aa;\n            col += spec * (light_col * albedo) * visibility * spec_mask * 3.0;\n        }\n        #endif\n\n        // eye light\n        #if 1\n        if (!light_on && eyes_on)\n        {\n            vec3 light_pos = vec3(-1.6, 0.8, 0.6);\n            vec3 light_col = vec3(1.0, 0.1, 0.1) * .2;\n\t\t\tvec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n            \n            float diffuse = abs(dot(light_dir, normal));\n            float visibility = getVisibility(p, light_pos, 5.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            if (p.z < 4.75) visibility = visibility + smoothstep(visibility, (p.z + 4.0) * .3, 1.0);\n\n            float intensity = 0.8;\n            if (!light_on) intensity = 3.0;\n            \n            col += diff_mask * diffuse * albedo * visibility * light_col * intensity * aa;\n            col += spec * (light_col * albedo) * visibility * spec_mask * 3.0;\n        }\n        #endif\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    oTime = iTime;\n#if 1\n    float d = 0.8;\n    float v = -0.4 + sin(iTime * .4) * .1;\n    float vvv = -0.5;\n    vec3 ta = ro + vec3(sin(v) * d, vvv, cos(v) * d);\n#else \n    float d = 0.8;\n    float v = ((iMouse.x / iResolution.x) - .5) * -5.;\n    vec3 ta = ro + vec3(sin(v) * d, clamp((iMouse.y / iResolution.y) - .5, -0.5, 30.5), cos(v) * d);\n#endif\n\n    light_on = !(mod(iTime, 4.0) < 1.);\n    eyes_on = !(mod(iTime + 4.0, 16.) > 1.0);\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for(int m=ZERO; m<AA; m++)\n    for(int n=ZERO; n<AA; n++)\n    {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else    \n    \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif       \n        // Ray direction\n        vec3 ww = normalize(ta - ro);\n        vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, -0.4)));\n        vec3 vv = normalize(cross(uu, ww));\n        \n        vec3 rd = normalize(uv.x * uu + uv.y * vv + (2.) * ww);\n        \n        // render\t\n        vec2 obj = rayMarch(ro, rd);\n        vec3 p = ro + obj.x * rd;\n    \n   \t\tvec3 col = render(obj, p, rd, uv);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n        \n    if (!light_on)\n    {\n        float mask = clamp(1.0 - length((uv + vec2(1.0, -0.5)) * .25), 0.0, 1.0);\n        tot *= pow(mask, 2.0);\n    }\n    \n    fragColor = vec4(tot, 1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 213, 213, 1010]], "test": "untested"}
{"id": "mtjcDV", "name": "Mountain RAY MARCH", "author": "Blindman67", "description": "A study of ray marching, and using noise.  There are many artifacts (most close to camera) that need to be fixed", "tags": ["terrain", "raymarch"], "likes": 11, "viewed": 189, "published": 3, "date": "1692328814", "time_retrieved": "2024-07-30T17:38:36.289337", "image_code": "\nconst Ray sun = Ray(vec3(0), normalize(vec3(0.8, 0.4, -0.2)));\nstruct Norms {\n    vec3 nL;\n    vec3 n;\n    vec3 nH;\n};\n/* Used by Noise2D */\nmat2 twist;\nconst mat2 twist1 = mat2(sin(0.3), -cos(0.3), cos(0.3), sin(0.3));\nconst mat2 twist2 = mat2(0.6, -0.8, 0.8, 0.632);\n\nfloat TerrainSDF(vec2 coord, uint stopAt) {\n    vec2 p = coord;\n    float a = 0.0, b = 1.0;\n    vec2 d = vec2(0);\n    uint i = 0u;\n    while (i < stopAt) {\n        vec3 n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    return 120.0 * a;\n}\nvec3 TerrainSDF(vec2 coord) {\n    vec2 p = coord;\n    float a = 0.0, b = 1.0;\n    vec2 d = vec2(0);\n    uint i = 0u;\n    vec3 n, res;\n    while (i < 3u) {\n        n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.x = 120.0 * a;\n    while (i < 8u) {\n        n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.y = 120.0 * a;\n    while (i < 16u) {\n        n = Noise2D(p);\n        d += n.yz;\n        a += b * n.x / (1.0 + dot(d, d));\n        p = twist * p * 2.0;\n        b *= 0.5;\n        i++;\n    }\n    res.z = 120.0 * a;\n    return res;\n}\nfloat RayMarch(Ray ray, float dist, float maxDist) {\n    vec3 p = ray.origin + dist * ray.dir;\n    for(uint i = 0u; i < MAX_ITER && dist < maxDist; i++) {\n        float h = p.y - TerrainSDF(p.xz * MAP_SCALE, 8u);\n        if (abs(h) < EPSILON * dist) { return dist; }\n        h *= 0.6;\n        p += h * ray.dir;\n        dist += h;\n    }\n    return dist;\n}\nfloat RayShadow(Ray ray, float dis) {\n    float minStep = clamp(0.01 * dis, 0.5, 50.0);\n    float res = 1.0;\n    float dist = 0.001;\n    for(int i = 0; i < 80; i++) {\n        vec3 p = ray.origin + dist * ray.dir;\n        float h = p.y - TerrainSDF(p.xz * MAP_SCALE, 8u);\n        res = min(res, 8.0 * h / dist);\n        dist += max(minStep, h);\n        if(res < 0.001 || p.y > 200.0) {  break; }\n    }\n    return UClamp(res);\n}\nvec3 CalcNorm(vec3 pos, float dist, uint stopAt) {\n    vec2 e = vec2(0.001 * dist, 0);\n    return normalize(vec3(\n        TerrainSDF((pos.xz - e.xy) * MAP_SCALE, stopAt) - TerrainSDF((pos.xz + e.xy) * MAP_SCALE, stopAt), \n        2.0 * e.x, \n        TerrainSDF((pos.xz - e.yx) * MAP_SCALE, stopAt) - TerrainSDF((pos.xz + e.yx) * MAP_SCALE, stopAt)\n    ));\n}\nNorms CalcNorms(vec3 pos, float dist) {\n    vec2 e = vec2(0.001 * dist * MAP_SCALE , 0);\n    vec2 p = pos.xz * MAP_SCALE;\n    vec3 A = TerrainSDF(p - e.xy);\n    vec3 B = TerrainSDF(p + e.xy);\n    vec3 C = TerrainSDF(p - e.yx);\n    vec3 D = TerrainSDF(p + e.yx);\n    float e2 = 0.002 * dist;\n    return Norms(\n        normalize(vec3(A.x - B.x, e2, C.x - D.x)),\n        normalize(vec3(A.y - B.y, e2, C.y - D.y)),\n        normalize(vec3(A.z - B.z, e2, C.z - D.z))\n    );\n}\nvec3 DrawPixel(Ray ray) {\n    float dist = RayMarch(ray, MIN_DIST, MAX_DIST);\n    vec3 col = vec3(0);\n    vec3 atmosphere = vec3(0.3, 0.5, 0.85) - ray.dir.y * ray.dir.y * 0.5;\n    atmosphere = mix(atmosphere, 0.85 * vec3(0.7, 0.75, 0.85), pow(1.0 - max(ray.dir.y, 0.0), 4.0));\n\n    float sdot = UClamp(dot(ray.dir, sun.dir));\n    atmosphere += vec3(1.0, 0.7, 0.0) * pow(sdot, 5.0);\n    atmosphere += vec3(1.5, 1.2, 0.6) * pow(sdot, 64.0);\n    atmosphere += vec3(2.0, 2.0, 1.1) * pow(sdot, 512.0);\n    atmosphere += vec3(1.0, 0.7, 0.3) * pow(sdot, 8.0);\n    \n    if (dist <= MAX_DIST) {\n        vec3 p = ray.origin + dist * ray.dir;\n        Norms norms = CalcNorms(p, dist);\n        float t = dot(norms.nH, vec3(0,1,0));\n        float snow = p.y + t * 10.0 > 75.0 ? dot(norms.n, vec3(0,1,0)) : 0.0;\n        float snowCover = UClamp((150.0 - p.y) / 150.0) + 0.3;\n        float green = p.y + t * 10.0 < 70.0 ? dot(norms.nH, vec3(0,1,0)) : 0.0;\n        float greenCover = UClamp(p.y / 150.0) + 0.5;\n        \n        vec3 rockC = mix(COl_A, COl_B, t);\n        float mixSnow = step(UClamp(snowCover), snow);\n        if (mixSnow > 0.5) {\n            twist = twist1;\n            norms.nL = CalcNorm(p, dist, 3u);\n            twist = twist2;\n        }\n        float mixGrass = step(UClamp(greenCover), green);\n        rockC = mix(rockC, COl_C, mixSnow);\n        rockC = mix(rockC, mix(COl_D, COl_D1, norms.nH.z * norms.nH.y), mixGrass);\n        col = t * rockC;\n        vec3(0);\n        vec3 n = mix(norms.nH, norms.nL, max(mixSnow, mixGrass));\n        float difuse = UClamp(dot(sun.dir, n));\n        float sh = RayShadow(sun, dist), shh = sh * sh;\n        float ambient = UClamp(n.y * 0.5 + 0.5);\n        float bac = UClamp(dot(vec3(-sun.dir.x, 0.0, sun.dir.z), n) * 0.8 + 0.2);\n        vec3 lin = vec3(8.0, 5.0, 3.0) * difuse * 1.5 * vec3(sh, shh * 0.5 + 0.5 * sh, shh * 0.8 + 0.2 * sh);\n        lin += vec3(0.4, 0.6, 1.0) * ambient * 6.0;\n        lin += vec3(0.4, 1.15, 1.6) * bac;\n        col = mix(col * lin, atmosphere, 1.0 - exp(-pow(0.002 * dist, 1.5)));\n    } else {\n        col = atmosphere;\n    }\n    return col;\n}\n\nvec3 GetPixel(in vec2 fragCoord) {\n    twist = twist2;\n    float time = Time(iFrame, ORBIT_SPEED);\n    vec3 invRes = InvRes(iResolution);\n    Ray ray = Ray(vec3(0), vec3(0));\n    ray.origin = vec3( cos(time) * ORBIT_RADIUS, cos(time) * 0.3 + 0.4, sin(time) * ORBIT_RADIUS);\n    ray.origin.y = TerrainSDF(ray.origin.xz * MAP_SCALE, 8u) + CAMERA_OFFSET;\n    vec2 px = 1.0 / iResolution.xy;   \n    vec2 uv = FixUV(fragCoord, iResolution) * invRes.y;\n    mat3 vmat;\n    if (time < 0.1) {\n        vmat = lookMouse(2.0 * (iMouse.xy + iResolution.xy * (invRes.xy * 0.55)) * invRes.xy);    \n    } else {\n        vmat = lookMouse(2.0 * iMouse.xy * invRes.xy);\n    }\n    #ifndef ANTI_ALIAS\n        ray.dir = normalize(vmat * vec3(uv, 2.0));\n        return  DrawPixel(ray);   \n    #else\n        vec3 col = vec3(0);\n        vec2 subPx = vec2(0);  \n        for (subPx.y = 0.0; subPx.y < 1.0; subPx.y += AA_STEP) {\n            for (subPx.x = 0.0; subPx.x < 1.0; subPx.x += AA_STEP) {\n                ray.dir = normalize(vmat * vec3(uv + px * subPx, 2.0));\n                vec3 c = DrawPixel(ray);   \n                col += c * c;\n\n            }\n        }\n        return pow(col * AA_SAMPLES, vec3(0.5));\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(1.0 - exp(-GetPixel(fragCoord) * 2.0), 1.0);\n}", "image_inputs": [], "common_code": "//#define ANTI_ALIAS 3.0\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define FOG_SCALE 100.0\n#define FAR vec4(1e5)\n#define EPSILON 0.0001\n#define MAX_ITER 128u\n#define MAP_SCALE 0.003\n#define ORBIT_RADIUS 4012.0\n#define ORBIT_SPEED 0.0055\n#define CAMERA_OFFSET 10.0\n\nconst float INV_255 = 1.0 / 255.0;\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\n#ifdef ANTI_ALIAS\n    const float AA_STEP = 1.0 / ANTI_ALIAS;\n    const float AA_SAMPLES = 1.0 / (ANTI_ALIAS * ANTI_ALIAS);\n#endif\nconst float inv_60 = 1.0 / 60.0;\n\nconst vec3  BG_Color = vec3 (0.45, 0.76, 1.0);\nconst vec3  COl_A = vec3(0.05, 0.043, 0.025);\nconst vec3  COl_B = vec3(0.057, 0.057, 0.05);\nconst vec3  COl_C = vec3(0.257, 0.257, 0.25);\nconst vec3  COl_D = vec3(0.028, 0.032, 0.02);\nconst vec3  COl_D1 = vec3(0.034, 0.035, 0.03);\nconst vec3  COLs[4] = vec3[](COl_A, COl_B, COl_C, COl_D);\nconst vec3  COl_Ambient = vec3(0.2, 0.3, 0.4);\nconst vec3  COl_Dark = vec3(0.2, 0.4, 0.3);\nconst vec3  COl_Light = vec3(1);\n\n\nconst vec3 lightPos1 = normalize(vec3(1, 1, -1));\nconst vec3 lightPos2 = normalize(vec3(-1, 0, 1));\n\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\nvec3 RGB2Color(float R, float G, float B) { return vec3(R * INV_255, G * INV_255, B * INV_255); }\nvec3 RGB2Color(uint R, uint G, uint B) { return vec3(float(R) * INV_255, float(G) * INV_255, float(B) * INV_255); }\n\nfloat UClamp(in float v) { return clamp(v, 0.0, 1.0); } /* U for unit */\n\n\nfloat Hash(vec2 pos) {\n    pos = fract(pos * 13.654678) * 65.247743;\n    return pow(fract((pos.x + pos.y) * pos.x * pos.y), 2.0);\n}\nvec3 Noise2D(vec2 pos) {\n    vec2 p = floor(pos);\n    float a = Hash(p);\n    float b = Hash(p + vec2(1, 0));\n    float c = Hash(p + vec2(0, 1));\n    float d = Hash(p + vec2(1, 1));\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6.0 * u * (1.0 - u);\n    return vec3(\n        a + (b - a) * u.x * (1.0 - u.y) + (c - a) * (1.0 - u.x) * u.y + (d - a) * u.x * u.y, \n        du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx)\n    );\n}\n\nvec3 InvRes(in vec3 res) { return 1.0 / res; }\nvec2 FixUV(in vec2 uv, in vec3 res) { return (2.0 * uv - res.xy); }\nfloat Time(in int f) { return float(f) * inv_60; }\nfloat Time(in int f, in float scale) { return float(f) * inv_60 * scale; }\nfloat plane(Ray ray, Ray plane){\n    float d = dot(plane.dir, ray.dir);\n    return d > MIN_DIST ? dot(plane.origin - ray.origin, plane.dir) / d : MAX_DIST;\n}\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\nmat3 lookMouse(in vec2 unitMouse) {\n    return camMatrix((unitMouse.x * 1.0 + 0.0) * PI, (unitMouse.y * 0.5 + 0.5) * PI);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 314, 314, 606], [607, 607, 636, 636, 1344], [1345, 1345, 1397, 1397, 1699], [1700, 1700, 1737, 1737, 2126], [2127, 2127, 2177, 2177, 2484], [2485, 2485, 2524, 2524, 2954], [2955, 2955, 2980, 2980, 5071], [5073, 5073, 5107, 5107, 6275], [6277, 6277, 6332, 6332, 6400]], "test": "untested"}
{"id": "dt2yDK", "name": "Segment - closest 2D", "author": "iq", "description": "Closest point on a segment or capsule.", "tags": ["2d", "sdf", "segment", "capsule", "closest"], "likes": 21, "viewed": 562, "published": 3, "date": "1692321050", "time_retrieved": "2024-07-30T17:38:37.061273", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\n\n// Closest point on segment\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  c = a + h*ba;\n    return c + th*normalize(p-c);\n}                    \n\n/*\nvec2 cloSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q); // distance\n    vec2  g = q/d;       // gradient\n    return p-(d-th)*g; // closest point\n} \n*/\n\n// distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    return length(q) - th;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.1,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    vec2 v1 = 0.7*cos( 0.5*iTime*vec2(1.3,1.0) + vec2(2,4) );\n    vec2 v2 = 0.7*cos( 0.5*iTime*vec2(0.9,1.2) + vec2(1,5) );\n    float th = 0.2*(0.7+0.3*sin(iTime*1.2+2.0));\n\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdSegment(p,v1,v2,th);\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdSegment(m,v1,v2,th); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloSegment(m,v1,v2,th); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2yDK.jpg", "access": "api", "license": "mit", "functions": [[1156, 1184, 1249, 1249, 1403], [1732, 1755, 1820, 1820, 1966], [1968, 1968, 2025, 2061, 3243]], "test": "ok"}
{"id": "ct2cDV", "name": "Truly Signed Distance Field JFA", "author": "fenix", "description": "Computing a 2D signed distance field per-pixel via jump flood algorithm. Higher paint calls work well for faster update. Interactive-only: use mouse to draw a shape.\n\n* mouse to draw *\n* space to reset *", "tags": ["2d", "mouse", "interactive", "sdf", "flood", "jump", "codegolf", "multipass", "jfa"], "likes": 27, "viewed": 434, "published": 3, "date": "1692319657", "time_retrieved": "2024-07-30T17:38:37.854153", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  This shader was inspired by MysteryPancake's comment on this shader's fork parent,\n//  asking to support interior distances (in other words, an actually *signed* distance\n//  field). Fair enough, but it does present an extra challenge. It made the shader\n//  sufficiently more complicated that it seemed like posting a new one was warranted.\n//\n//  The difficulty with interior distances is the same as the problem with supporting\n//  erasing: the way jump flood works, each pixel stores the location of its nearest\n//  zero-distance cell. When any pixel on the screen disappears, any of the other pixels\n//  in the buffer might point to it. This can be solved by having each pixel reset itself\n//  if it finds it is pointing to a pixel being drawn on. You can see this happening in\n//  the blue interior area as you draw, a chunk of the buffer gets much worse momentarily\n//  before fixing itself.\n//\n//  An extra trick is that not only might our own cell be pointing to an invalidated\n//  cell, we might also find an invalidated cell while performing the jump flood. So\n//  the jump flood also had to be modified slightly to prevent cells that \"refused to\n//  be erased\".\n//\n//  The way I did this, there are essentially two different jump floods happening, one\n//  on the exterior and one on the interior. It seems like it might be possible to\n//  still do just a single jump flood, which keeps track of the closest zero-distance\n//  cell both interior and exterior, and record whether we're inside or out in another\n//  channel. I tried this briefly, but it was tricky writing the cells when drawing\n//  with the mouse, because it's easy to add zero distance cells that you didn't expect.\n//\n//   * Set the brush size via BRUSH_SIZE in Buffer A\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O.x = D(T(u).xy, u) - D(T(u).zw, u);\n\n    O = mix( vec4(1), (O.x > 0. ? vec4(0.9,0.6,0.3, 1) : vec4(0.65,0.85,1.0, 1)) // iq's standard SDF distance visualization\n\t                     * (1. - exp(-6.*abs(O.x * .002)))\n\t                     * (.8 + .2*cos(O.x * .3)), smoothstep(0., 3.,abs(O.x)) );\n                         \n    vec2 c = (vec2(sin(iTime * .3), cos(iTime)) * .45 + .5) * iResolution.xy; // circle center\n    O = mix(O, vec4(1, 1, 0, 1), smoothstep(3., 0., abs(D(c, u) - D(T(c).xy, c) - D(T(c).zw, c)))); // render circle\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//   XY coordinates hold the location for exterior cells of nearest zero-distance (drawn-on) pixel\n//   ZW coordinates hold the location for interior cells of nearest zero-distance (drawn-on) pixel\n// ---------------------------------------------------------------------------------------\n\n#define BRUSH_SIZE .05 * R.y\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution, m = iMouse.xyz;\n    \n    if (max(u.x, u.y) < 1.)\n        O = vec4(0, 0, 0, R.x * R.y); // resolution stored in lower left corner\n    else if (iFrame == 0 || // bootstrap\n        texelFetch(iChannel0,ivec2(0,0),0).w != R.x * R.y || // detect resolution changes\n        texelFetch(iChannel3,ivec2(32,0),0).x > 0.) // support keyboard \"space\" reset)\n    {\n        O.xy = vec2(1e6);\n        O.zw = u;\n    }\n    else\n    {        \n        O = T(u);\n        if (m.z > 0. && D(m.xy, O.zw) < BRUSH_SIZE) // clear any cells that point to a cell under active mouse\n            O.zw = vec2(1e6);\n        else\n        {\n            // search nearby cells for new shorter path\n            for (int x = -1; x <= 1; ++x)\n            for (int y = -1; y <= 1; ++y)\n            {\n                vec4 a = T(u + exp2(float(iFrame % 8)) * vec2(x, y));\n                O.xy = D(u, a.xy) < D(O.xy, u) ? a.xy : O.xy; // when we find a shorter path, update our root\n                if (m.z <= 0. || D(a.zw, m.xy) >= BRUSH_SIZE) // don't let the jump flood grab pixels being drawn on, right as they're resetting themselves\n                    O.zw = D(u, a.zw) < D(O.zw, u) ? a.zw : O.zw; // update interior shortest path\n            }\n        }\n        \n        // support drawing with mouse\n        O = m.z > 0. && D(m.xy, u) < BRUSH_SIZE ? vec4(u.xy, vec2(1e7)) : O;\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) Timpl(u, iChannel0, iResolution.xy)\nvec4 Timpl(vec2 u, sampler2D smp, vec2 R)\n{\n   if (u.x < 0. || u.y < 0. || u.x >= R.x || u.y >= R.y) return vec4(1e6);\n   if (max(u.x, u.y) < 1.) return vec4(1e6);\n   return texelFetch(smp, ivec2(u), 0);\n}\n#define D distance", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2cDV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2054, 2054, 2092, 2092, 2635]], "test": "untested"}
{"id": "dl2cWK", "name": "CosmicEclipse", "author": "ChatGPT", "description": "Step into the mystical allure of 'CosmicEclipse.' This shader crafts a cosmic tale on your screen, where vibrant hues blend and dance like celestial bodies during an eclipse. ", "tags": ["circles", "colors", "lines", "eclipse", "blend", "cosmic", "awe", "mystic", "celestial", "technological"], "likes": 1, "viewed": 107, "published": 3, "date": "1692318778", "time_retrieved": "2024-07-30T17:38:38.664985", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // Create a gradient background\n    vec3 bgColor = vec3(0.15, 0.1, 0.2);\n    vec3 color = mix(bgColor, vec3(0.5, 0.2, 0.7), abs(p.y));\n\n    // Add dynamic circle pattern\n    vec2 center = vec2(0.5, 0.5);\n    float circle = smoothstep(0.1, 0.15, length(p - center));\n    color += vec3(0.8, 0.5, 0.2) * circle;\n\n    // Add rotating lines\n    float angle = atan(p.y - center.y, p.x - center.x) + iTime;\n    float lines = smoothstep(0.01, 0.015, abs(fract(angle * 6.0) - 0.5));\n    color += vec3(0.3, 0.7, 0.4) * lines;\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2cWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 698]], "test": "untested"}
{"id": "mt2cWK", "name": "TranquilSeabed", "author": "ChatGPT", "description": "Dive into the serenity of the underwater world with 'TranquilSeabed.' This captivating shader recreates the depths of the ocean, where shimmering light rays pierce through the water's surface, painting the sandy seabed with a golden glow.", "tags": ["waves", "interactive", "ocean", "underwater", "lightrays", "calm", "sand", "serene", "shimmering", "tranquil"], "likes": 0, "viewed": 188, "published": 3, "date": "1692318496", "time_retrieved": "2024-07-30T17:38:39.434927", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 uv = p * 2.0;\n\n    float time = iTime * 0.5;\n\n    // Create underwater scene\n    vec3 waterColor = vec3(0.106, 0.561, 0.835);\n    vec3 sandColor = vec3(0.953, 0.882, 0.737);\n    vec3 color = mix(sandColor, waterColor, smoothstep(-0.2, 0.2, uv.y));\n\n    // Add shimmering light rays\n    vec2 lightPos = vec2(-0.3, 0.5);\n    vec2 toLight = normalize(lightPos - uv);\n    float lightIntensity = max(0.0, dot(vec2(0.0, 1.0), toLight));\n    float rays = pow(lightIntensity, 10.0) * 0.1;\n    color += vec3(1.0, 0.9, 0.5) * rays;\n\n    // Add gentle waves\n    float waves = sin(uv.x * 10.0 + time) * 0.02 + sin(uv.y * 25.0 + time) * 0.02;\n    color += vec3(0.05, 0.1, 0.2) * waves;\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2cWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 859]], "test": "untested"}
{"id": "dt2cWK", "name": "CelestialTunnel", "author": "ChatGPT", "description": "Embark on a journey through the boundless cosmos with 'CelestialTunnel.' This mesmerizing shader whisks you away to a swirling vortex of color and light, where a hypnotic tunnel beckons you into its depths. As you navigate the infinite expanse, dynamic pa", "tags": ["tunnel", "interactive", "colorful", "abstract", "cosmos", "vortex", "exploration", "mesmerizing", "celestial", "dynamicpatterns"], "likes": 1, "viewed": 119, "published": 3, "date": "1692318204", "time_retrieved": "2024-07-30T17:38:40.285652", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 uv = p * 2.0;\n\n    float time = iTime * 0.5;\n\n    // Create tunnel effect\n    float tunnelDepth = 5.0;\n    vec3 color = vec3(0.1);\n    vec2 tunnelCenter = vec2(sin(time), cos(time)) * 0.5;\n    float distanceToCenter = length(uv - tunnelCenter) * 2.0;\n    float tunnel = mod(distanceToCenter - time * 3.0, tunnelDepth);\n    color += vec3(0.5 + 0.5 * cos(tunnel * 3.14159));\n\n    // Add dynamic patterns\n    float pattern = cos(uv.x * 10.0 + time) * sin(uv.y * 20.0 + time);\n    color += vec3(0.2 * pattern);\n\n    // Apply color palette\n    vec3 palette[5] = vec3[5](\n        vec3(0.988, 0.325, 0.369),\n        vec3(0.992, 0.671, 0.267),\n        vec3(0.976, 0.831, 0.329),\n        vec3(0.263, 0.792, 0.698),\n        vec3(0.239, 0.345, 0.686)\n    );\n    int paletteIndex = int(mod(time * 2.0, 5.0));\n    color *= palette[paletteIndex];\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2cWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1019]], "test": "untested"}
{"id": "mljcWK", "name": "EnchantedEtherea", "author": "ChatGPT", "description": "Enter a realm of enchantment and ethereal beauty with 'EnchantedEtherea.' This mesmerizing shader combines vibrant, shifting patterns with a luminous orb at its core, radiating a sense of magical wonder. As if woven by the threads of a digital sorcerer's ", "tags": ["chatgpt"], "likes": 0, "viewed": 123, "published": 3, "date": "1692318080", "time_retrieved": "2024-07-30T17:38:41.050607", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    // Create a time-based variable for animation\n    float time = iTime * 0.5;\n    \n    // Generate a magical pattern\n    vec3 color = 0.5 + 0.5 * cos(time + uv.xyx + vec3(0, 2, 4));\n    \n    // Add a glowing orb of light in the center\n    vec2 center = vec2(0.0, 0.0);\n    float orbSize = 0.1;\n    float orb = smoothstep(orbSize, orbSize + 0.05, length(uv - center) + 0.1 * sin(time));\n    color += vec3(1.0, 0.8, 0.2) * orb;\n    \n    // Add swirling trails of light\n    float swirl = sin(time + length(uv - center) * 10.0);\n    color *= vec3(0.5 + 0.5 * abs(swirl));\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 122, 822]], "test": "untested"}
{"id": "cljcDV", "name": "Color Gradient Fade", "author": "rdwz", "description": "Just the default shader", "tags": ["default"], "likes": 0, "viewed": 132, "published": 3, "date": "1692311788", "time_retrieved": "2024-07-30T17:38:41.899338", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "DljcDG", "name": "Rounded Box - closest 2D", "author": "iq", "description": "Closest point on a round rectangle.", "tags": ["2d", "sdf", "rounded", "roundedrectangle", "closest"], "likes": 23, "viewed": 526, "published": 3, "date": "1692311012", "time_retrieved": "2024-07-30T17:38:42.741087", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\n\n// closest point on rounded box\nvec2 cloRoundBox( in vec2 p, in vec2 b, float r )\n{\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    vec2 w = abs(p) - b;\n    if( max(w.x,w.y)>0.0 )\n    {\n        vec2  q = max(w,0.0);\n        float l = length(q);\n        p -= s*(l-r)*q/l;\n    }\n    else\n    {\n        if( w.x>w.y ) p.x = s.x*(b.x+r);\n        else          p.y = s.y*(b.y+r);\n    }\n    return p;\n}\n\n// distance to rounded box\nfloat sdRoundBox( in vec2 p, in vec2 b, float r )\n{\n    vec2  w = abs(p)-b;\n    float g = max(w.x,w.y);\n    return ((g>0.0)?length(max(w,0.0)):g) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.2,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    const vec2  bs = vec2(0.7,0.3);\n    const float ra = 0.2;\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdRoundBox(p,bs,ra); \n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdRoundBox(m,bs,ra); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloRoundBox(m,bs,ra); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljcDG.jpg", "access": "api", "license": "mit", "functions": [[1157, 1189, 1240, 1240, 1554], [1556, 1583, 1634, 1634, 1735], [1737, 1737, 1794, 1830, 2895]], "test": "ok"}
{"id": "cldSzf", "name": "Box - closest 2D", "author": "iq", "description": "Closest point on a rectangle.", "tags": ["2d", "sdf", "rectangle", "closest"], "likes": 18, "viewed": 542, "published": 3, "date": "1692311000", "time_retrieved": "2024-07-30T17:38:43.544938", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Closest point on box\n//\n//   For points inside the box where 3 or 4 closest points exist (p.y=0 or p.x=0) or \n//   where 2 solutions exit (the diagonals |p.x-p.y|=|b.x-b.y|, you need to take\n//   extra precautions, for example:\n//\n//   if( g<0.0 )\n//   {\n//     if( w.x==w.y ) return vec2(1e20);                                          // 2 solutions\n//     if( (b.x>b.y) && abs(p.x)<=(b.x-b.y) && abs(p.y)==0.0 ) return vec2(1e20); // 3 solutions\n//     if( (b.x<b.y) && abs(p.y)<=(b.y-b.x) && abs(p.x)==0.0 ) return vec2(1e20); // 3 solutions\n//   }\n//\n// Other closest point distances: https://www.shadertoy.com/playlist/ff2BRD\n\nvec2 cloBox( in vec2 p, in vec2 b )\n{\n    vec2   s = sign(p);\n    vec2   w = abs(p) - b;\n    float  g = max(w.x,w.y);\n    float  m = min(0.0,g);\n    return p - vec2(w.x>=m?w.x:0.0,w.y>=m?w.y:0.0)*s;\n}\n\n\n// distance to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    float g = max(w.x,w.y);\n    return (g>0.0)?length(max(w,0.0)):g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    if( iMouse.z<0.01 ) m = vec2(1.2,0.8)*cos(iTime*vec2(1.1,1.3)+vec2(0,2));\n    \n    vec2 b1 = vec2(0.7,0.5);\n\n    vec3 col;\n    \n    // background color\n    {\n    float d = sdBox(p,b1); \n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n    }\n    \n    {\n    // distance from pointer\n    float d = sdBox(m,b1); \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    // closest point\n    {\n    vec2 cl = cloBox(m,b1); \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-cl)-0.025));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldSzf.jpg", "access": "api", "license": "mit", "functions": [[1714, 1714, 1751, 1751, 1914], [1917, 1936, 1973, 1973, 2067], [2069, 2069, 2126, 2162, 3174]], "test": "ok"}
{"id": "cl2cDK", "name": "drum 3 Basico-sound", "author": "jorge2017a2", "description": "drum 3 Basico-sound", "tags": ["sound", "bass", "drum"], "likes": 10, "viewed": 181, "published": 3, "date": "1692307204", "time_retrieved": "2024-07-30T17:38:44.835488", "image_code": "//por jorge2017a2\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n#define PI 3.141516\n\n\n//casa izq 1\nfloat sdPoly5a POLY(5)\nvec2  pt5a[5]=vec2[](\nvec2(2.21,-0.5),vec2(4.29,0.97),vec2(4.38,4.49),vec2(2.22,5.2),vec2(2.21,-0.5)  );\n\n//casa izq 2\nfloat sdPoly5b POLY(5)\nvec2  pt5b[5]=vec2[](\nvec2(4.32,2.32),vec2(5.82,3),vec2(5.82,4.01),vec2(4.39,4.49),vec2(4.32,2.32)  );\n\n\nfloat sdPoly5c POLY(5)\nvec2  pt5c[5]=vec2[](\nvec2(5.84,2.79),vec2(6.79,3.31),vec2(6.79,3.71),vec2(5.83,4.04),vec2(5.84,2.79)  );\n\n//banqueta\nfloat sdPoly5d POLY(5)\nvec2  pt5d[5]=vec2[](\nvec2(1.905,5.2),vec2(6.8,3.71),vec2(6.86,3.75),vec2(3.32,5.34),vec2(1.905,5.2)  );\n\n\nfloat sdPoly5e POLY(5)\nvec2  pt5[5]=vec2[](\nvec2(3.33,5.32),vec2(6.84,3.73),vec2(6.87,3.73),vec2(3.65,5.32),vec2(3.33,5.32)  );\n\n\nfloat sdPoly6f POLY(6)\nvec2  pt6f[6]=vec2[](\nvec2(7.62,3.7),vec2(7.66,3.69),vec2(11.57,5.2),vec2(11.57,5.21),vec2(10.6,5.28),\nvec2(7.62,3.7)  );\n\n\nfloat sdPoly5g POLY(5)\nvec2  pt5g[5]=vec2[](\nvec2(10.74,5.32),vec2(7.61,3.69),vec2(7.58,3.7),vec2(10.32,5.31),vec2(10.74,5.32)  );\n\n\nfloat sdPoly5h POLY(5)\nvec2  pt5h[5]=vec2[](\nvec2(10.95,4.95),vec2(9.27,4.28),vec2(9.27,2.64),vec2(11,1.79),vec2(10.95,4.95)  );\n\n\nfloat sdPoly6i POLY(6)\nvec2  pt6i[6]=vec2[](\nvec2(8.24,3.28),vec2(9.28,2.91),vec2(9.26,4.27),vec2(9.26,4.28),vec2(8.21,3.86),\nvec2(8.24,3.28)  );\n\n\nfloat sdPoly5j POLY(5)\nvec2  pt5j[5]=vec2[](\nvec2(7.65,3.35),vec2(8.2,3.1),vec2(8.21,3.89),vec2(7.68,3.67),vec2(7.65,3.35)  );\n\n\nfloat sdPoly5k POLY(5)\nvec2  pt5k[5]=vec2[](\nvec2(3.17,0.35),vec2(4.09,1),vec2(4.1,1.61),vec2(3.18,1.21),vec2(3.17,0.35)  );\n\n\nfloat sdPoly5l POLY(5)\nvec2  pt5l[5]=vec2[](\nvec2(5.54,2.96),vec2(5.75,3.05),vec2(5.73,3.25),vec2(5.56,3.21),vec2(5.54,2.96)  );\n\nfloat sdPoly5m POLY(5)\nvec2  pt5m[5]=vec2[](\nvec2(6.62,3.28),vec2(6.75,3.33),vec2(6.75,3.41),vec2(6.63,3.38),vec2(6.62,3.28)  );\n\n\nfloat sdPoly22n POLY(22)\nvec2  pt22n[22]=vec2[](\nvec2(8.8,4.27),vec2(8.81,2.31),vec2(8.51,2.29),vec2(8.51,2.19),vec2(8.78,2.21),\nvec2(8.79,2.11),vec2(8.65,2.12),vec2(8.64,2.06),vec2(8.79,2.03),vec2(8.78,1.88),\nvec2(8.78,1.88),vec2(8.97,1.88),vec2(8.96,2.02),vec2(9.12,2.03),vec2(9.13,2.13),\nvec2(8.98,2.14),vec2(8.98,2.21),vec2(9.28,2.21),vec2(9.3,2.29),vec2(8.97,2.33),\nvec2(8.97,4.26),vec2(8.8,4.27)  );\n\n\n//triangulo 1\nfloat sdPoly4o POLY(4)\nvec2  pt4o[4]=vec2[](\nvec2(5.3,2.74),vec2(5.83,2.75),vec2(5.83,2.98),vec2(5.30,2.74)  );\n\n\nfloat sdPoly4p POLY(4)\nvec2  pt4p[4]=vec2[](\nvec2(8.22,3.27),vec2(8.19,3.1),vec2(8.79,3.07),vec2(8.22,3.27)  );\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\nvec3 DrawFigBordeCoL(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 DrawFigDelgado(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj-0.001,0.0)); return colOut; }\n\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nvec3 fig00(vec2 p,vec3 col)\n{\n    float sd5a = sdPoly5a(p, pt5a);\n    //col=mix(col,colNegro ,S( sd5 ,0.0));\n    col=DrawFigBorde(vec3(0.57,0.57,0.57),col,sd5a );\n    \n    \n    float sd5b = sdPoly5b(p, pt5b);\n    col=DrawFigBorde(vec3(0.36),col,sd5b );\n\n    \n    float sd5c = sdPoly5c(p, pt5c);\n    col=DrawFigBorde(vec3(0.45),col,sd5c);\n    \n    //banqueta\n    float sd5d = sdPoly5d(p, pt5d);\n    col=DrawFigBorde(vec3(0.85),col,sd5d);\n    \n    float sd5e = sdPoly5e(p, pt5);\n    col=DrawFigBorde(vec3(0.25),col,sd5e);\n\n    float sd6f = sdPoly6f(p, pt6f);\n    col=DrawFigBorde(vec3(0.85),col,sd6f);\n\n    float sd5g = sdPoly5g(p, pt5g);\n    col=DrawFigBorde(vec3(0.25),col,sd5g);\n\n\n    float sd5h = sdPoly5h(p, pt5h);//casa izq 3\n    col=DrawFigBorde(vec3(0.45),col,sd5h );\n    \n    \n    float sd6i = sdPoly6i(p, pt6i); //casa izq 2\n    col=DrawFigBorde(vec3(0.65),col,sd6i);\n    \n    \n    float sd5j = sdPoly5j(p, pt5j); //casa izq\n    col=DrawFigBorde(vec3(0.485),col,sd5j);\n\n    \n    //ventana\n    float sd5k = sdPoly5k(p, pt5k);\n    col=DrawFigBorde(vec3(0.4),col,sd5k);\n\n    \n    float sd5l = sdPoly5l(p, pt5l);\n    col=DrawFigBorde(vec3(0.4),col,sd5l);\n\n    float sd5m = sdPoly5m(p, pt5m);\n    col=DrawFigBorde(vec3(0.4),col,sd5m);\n\n\n    float sd22n = sdPoly22n(p, pt22n); //poste\n    col=DrawFigBorde(vec3(0.4),col,sd22n);\n    \n    float sd4o = sdPoly4o(p, pt4o);\n    col=DrawFigBorde(vec3(0.4),col,sd4o );\n    \n    float sd4p = sdPoly4p(p, pt4p);\n    col=DrawFigBorde(vec3(0.4),col,sd4p );\n    \nreturn col;\n}\n\nfloat N21(vec2 p)\n{ return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n     uv-=vec2(-2.7,1.0);\n    uv*=2.5;\n    vec2 uv2=floor(uv*5.0+iTime);\n    uv.y=-uv.y;\n    vec3 col=vec3(0.67,0.67,0.68);\n    \n    if (uv.y<3.5)\n     col*=vec3(0.0,0.0,2.0)*N21(uv2);\n     \n    col=fig00(uv,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "//Referencia de sonido IQ y Gaz \n//PolyBLEP by iq\n//Modificado por Jorge2017a2---jorgefp\n#define PI acos(-1.)\n#define PIH (PI*.5)\n#define TAU (PI*2.)\n\n\n#define DD(a,b) n=(s>=a)?ivec2(a,b):n;\n\nconst float pi = 3.1415927;\nconst float tau = 6.283185;\nconst float  ttotal=30.0;\n\n//gaz\n#define osc_sin(x) sin((x)*TAU)\n#define osc_saw(x) (1.-fract(x)*2.)\n#define osc_sqr(x) sign(0.5-fract(x))\n#define osc_tri(x) (asin(sin((x)*PI))/PIH)\n \nfloat noize(float t,  float a, float b){\n    float g=fract(cos(t*exp2(a))*exp2(b))+6.0;\n    return exp(-0.08*g*g) *40.0-1.;\n}\n\nfloat kick(float t)\n{ return clamp(1.5*asin(cos(300.1*t-30.0*exp(-40.0*t))),-1.,1.)*exp(-4.*t);}\n\nfloat kick2(float t)\n{ return clamp(1.5*asin(cos(650.1*t-30.0*exp(-40.0*t))),-1.,1.)*exp(-4.*t);}\n\nfloat kick3(float t)\n{ return clamp(1.5*asin(cos(500.1*t-40.1*exp(-10.0*t))),-1.,1.)*exp(-3.*t);}\n\nfloat kick4(float t)\n{ return clamp(1.5*asin(cos(250.1*t-25.1*exp(-40.0*t))),-1.,1.)*exp(-4.*t);}\n\n\nfloat snare(float t)\n{ float n=noize(t,10.,5.)*exp(-t*10.);\n    float f=t*160.,a=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float b=.05*osc_sin(10.*f+a)*exp(-t*3.);\n    float c=osc_sin(f+b)*exp(-t*15.), z;\n    return n+c;\n}\n\nfloat snare2(float t)\n{   float n=noize(t,10.,12.1)*exp(-t*10.);\n    float f=t*260.,a=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float b=.05*osc_sin(10.*f+a)*exp(-t*3.);\n    float c=osc_sin(f+b)*exp(-t*15.), z;\n    return n+c;\n}\n\n// saw wave iq\nfloat sawRaw( in float p, in float dpdt )\n{   float x = mod(p,tau)/tau;\n    return 2.0*x-1.0;\n}\n\n// square wave iq\nfloat squareRaw( in float p, in float dpdt )\n{   float t = fract(p/tau);\n    return sign(0.5-t);\n}\n\n\nfloat combinar(float a, float b, float f1, float f2)\n{   float ra=mix(0.0,a,f1);\n    float rb=mix(0.0,b,f2);\n    return ra+rb;\n}\n\nfloat wave( float x, float dxdt, in vec2 v )\n{ //referencia Inigo Quilez 2019\n    float f3=osc_saw(x*dxdt);\n    return f3;\n}\n\nfloat SoundIq(float time)\n{\n///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal );\n\n  // tune\n  const float tempo = 4.2;\n  int s = int(floor(time*tempo));\n  ivec2 n = ivec2(0);\n  DD( 8,70) DD( 9,62) DD(10,67) DD(11,70) DD(12,72) DD(13,65) DD(14,69) DD(15,70)\n  DD(17,67) DD(18,70) DD(19,74) DD(20,75) DD(21,67) DD(22,74) DD(23,72) DD(24,70)\n  DD(25,62) DD(26,67) DD(27,70) DD(28,72) DD(29,65) DD(30,69) DD(31,70) DD(33,67)\n  DD(34,70) DD(35,74) DD(36,75) DD(37,67) DD(38,74) DD(39,72) DD(40,70) DD(41,62)\n  DD(42,67) DD(43,70) DD(44,72) DD(45,65) DD(46,69) DD(47,70) DD(49,67) DD(50,70)\n  DD(51,74) DD(52,75) DD(53,67) DD(54,74) DD(55,72) DD(56,70) DD(57,62) DD(58,67)\n  DD(59,70) DD(60,69) DD(61,60) DD(62,65) DD(63,67) DD(65,58) DD(66,65) DD(67,67)\n  DD(69,65) DD(70,67) DD(71,69) DD(72,70) DD(73,62) DD(74,67) DD(75,70) DD(76,72)\n  DD(77,65) DD(78,69) DD(79,70) DD(81,67) DD(82,70) DD(83,74) DD(84,75) DD(85,67)\n  DD(86,74) DD(87,72) DD(88,70) DD(89,62) DD(90,67) DD(91,70) DD(92,72) DD(93,65)\n DD(94,69) DD(95,70) DD(97,67) DD(98,70) DD(99,74) DD(100,75) DD(101,67) DD(102,74)\n  DD(103,72) DD(104,70) DD(105,62) DD(106,67) DD(107,70) DD(108,72) DD(109,65) DD(110,69)\n  DD(111,70) DD(113,67) DD(114,70) DD(115,74) DD(116,75) DD(117,67) DD(118,74) DD(119,72)\n  DD(120,70) DD(121,62) DD(122,67) DD(123,70) DD(124,69) DD(125,60) DD(126,65) DD(127,67)\n  DD(208,70) DD(209,62) DD(210,67) DD(211,70) DD(212,72) DD(213,65) DD(214,69) DD(215,70)\n  DD(217,67) DD(218,70) DD(219,74) DD(220,75) DD(221,67) DD(222,74) DD(223,72) DD(224,70)\n  DD(225,62) DD(226,67) DD(227,70) DD(228,72) DD(229,65) DD(230,69) DD(231,70) DD(233,67)\n  DD(234,70) DD(235,74) DD(236,75) DD(237,67) DD(238,74) DD(239,72) DD(240,70) DD(241,62)\n  DD(242,67) DD(243,70) DD(244,72) DD(245,65) DD(246,69) DD(247,70) DD(249,67) DD(250,70)\n  DD(251,74) DD(252,75) DD(253,67) DD(254,74) DD(255,72) DD(256,70) DD(257,62) DD(258,67)\n  \n  DD(259,70) DD(260,69) DD(261,60) DD(262,65) DD(263,67) DD(416,62) DD(416,65) DD(416,69)\n  DD(430,62) DD(430,70) DD(430,67) DD(432,62) DD(432,69) DD(432,65) DD(446,62) DD(446,70)\n  DD(446,67) DD(448,62) DD(448,69) DD(448,65) DD(462,62) DD(462,70) DD(462,67) DD(464,62)\n  DD(464,69) DD(464,65) DD(480,70) DD(481,62) DD(482,67) DD(483,70) DD(484,72) DD(485,65)\n  DD(486,69) DD(487,70) DD(489,67) DD(490,70) DD(491,74) DD(492,75) DD(493,67) DD(494,74)\n \n  // lower one octave\n  n.y -= 12;\n      \n  // compute note frequency and time  \n  float f = 440.0*pow( 2.0, float(n.y-69)/12.0 );\n  float t = time - float(n.x)/tempo;\n  if( n.x==0 ) return 0.0;\n\n  // prepare wave parameters\n  float w = tau*f;\n  float dwdt = w/iSampleRate; // derivative\n    \n  // mix between bandlimited and raw saw waves  \n  vec2 v = smoothstep(-0.2,0.2,sin(time*vec2(1.0,0.5)) );\n    \n  // build instrument\n  \n  float y  = 0.4*wave(1.00*w*t,1.00*dwdt,v)*exp(-5.0*t);\n        y += 0.3*wave(2.01*w*t,2.01*dwdt,v)*exp(-7.0*t);\n        y += 0.2*wave(4.01*w*t,4.01*dwdt,v)*exp(-9.0*t);\n        //y += 0.1*wave(8.01*w*t,8.01*dwdt,v)*exp(-11.0*t);\nreturn y;\n}\n\n\nfloat sound02(float time)\n{int m,ss,c, d;\n    #define NI(c) m=(ss>=c)?c:m;\n    ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal );\n// tune\n  const float tempo = 4.2;\n  ss = int(floor(time*tempo));\n  m = 0;\n  \n NI( 8) NI(9) NI(10) NI(11) NI(12) NI(13) NI(14) NI(15)\n NI(17) NI(18) NI(19) NI(20) NI(21) NI(22) NI(23) NI(24)\n  \n  NI(69) NI(71) NI(72)  NI(75) NI(76)\n  NI(77)  NI(79) NI(81)  NI(84) NI(85)\n  NI(86)  NI(88) NI(89)  NI(92) NI(93)\n  NI(94)  NI(97) NI(98)  NI(101) NI(102)\n  float t = time - float(m)/tempo;\n  if( m==0 ) return 0.0;\nfloat y= kick3(t)*0.75;\n    return y;\n}\n\n\n\nfloat sound03(float time)\n{int m,ss,c, d;   \n    #define NI(c) m=(ss>=c)?c:m;\n    ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal );\n // tune\n  const float tempo = 4.2;\n  ss = int(floor(time*tempo));\n  m = 0;\n  NI( 8) NI( 9) NI(10) NI(11) NI(12) NI(13) NI(14) NI(15)\n  NI(17) NI(18) NI(19) NI(20) NI(21) NI(22) NI(23) NI(24)\n  \n  NI(25)  NI(27)  NI(29) NI(31) NI(33)\n  NI(34)  NI(36)  NI(38) NI(40) NI(41)\n  \n  NI(42)  NI(45) NI(49) NI(50)\n  NI(51)  NI(54) NI(57) NI(58)\n  NI(59)  NI(62) NI(66) NI(67)\n  NI(69)  NI(72) NI(75) NI(76)\n  float t = time - float(m)/tempo;\n  if( m==0 ) return 0.0;\n   float y= snare(t)*0.75;\n    return y;\n}\n\nfloat sound04(float time)\n{  int m,ss,c, d;\n     #define NI(c) m=(ss>=c)?c:m;\n    ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal );\n\n  // tune\n  const float tempo = 4.2;\n  ss = int(floor(time*tempo));\n  m = 0;\n  \n NI(111)  NI(114) NI(115) NI(116) \n NI(120)  NI(122) NI(123) NI(124) \n NI(208)  NI(210)  NI(212)  NI(214)\n  \n  float t = time - float(m)/tempo;\n  if( m==0 ) return 0.0;\nfloat y= kick(t)*0.75;\n    return y;\n}\n\n\n\nfloat sound05(float time)\n{ int m,ss,c,d;\n     #define NI(c) m=(ss>=c)?c:m;\n    ///referencia de notas musicales... iq \n  time = mod( time+1.0, ttotal );\n// tune\n  const float tempo = 4.2;\n  ss = int(floor(time*tempo));\n  m = 0;\n//NI( 8) NI(9) NI(10) NI(11) NI(12) NI(13) NI(14) NI(15)\n//NI(17) NI(18) NI(19) NI(20) NI(21) NI(22) NI(23) NI(24)\n   \n NI(111)  NI(114) NI(115) NI(116) \n NI(120)  NI(122) NI(123) NI(124) \n NI(208)  NI(210)  NI(212)  NI(214)\n  \n  float t = time - float(m)/tempo;\n  if( m==0 ) return 0.0;\nfloat y=snare2(t)*0.75;\n    return y;\n}\n\nvec2 mainSound( in int samp, float time )\n{  float y= SoundIq( time);\n    y+= sound02(time);\n    y+= sound03(time);\n    y+= sound04(time);\n    y+= sound05(time);\n  return vec2(y);\n}   \n\n\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2cDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2951, 2951, 3013, 3013, 3139], [3140, 3140, 3221, 3221, 3349], [3351, 3351, 3415, 3415, 3486], [3490, 3490, 3537, 3537, 3564], [3565, 3565, 3608, 3608, 3635], [3636, 3636, 3684, 3684, 3712], [3715, 3731, 3779, 3779, 3857], [3859, 3859, 3894, 3894, 3917], [3919, 3919, 3956, 3956, 4028], [4030, 4030, 4082, 4082, 4189], [4191, 4191, 4216, 4216, 4235], [4236, 4236, 4261, 4261, 4280], [4281, 4281, 4317, 4317, 4345], [4348, 4348, 4413, 4413, 4723], [4726, 4726, 4755, 4755, 6242], [6244, 6244, 6263, 6263, 6317], [6319, 6319, 6376, 6376, 6685]], "test": "untested"}
{"id": "Dl2cWK", "name": "honeyX", "author": "Del", "description": "grid", "tags": ["grid"], "likes": 14, "viewed": 258, "published": 3, "date": "1692301994", "time_retrieved": "2024-07-30T17:38:45.876703", "image_code": "\nvec4 HexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547,0.0,-0.5773503,1.0);\n    vec2 f = fract(uv);\n    float triid = 1.0;\n\tif((f.x+f.y) > 1.0)\n    {\n        f = 1.0 - f;\n     \ttriid = -1.0;\n    }\n    vec2 co = step(f.yx,f) * step(1.0-f.x-f.y,max(f.x,f.y));\n    id = floor(uv) + (triid < 0.0 ? 1.0 - co : co);\n    co = (f - co) * triid * mat2(0.866026,0.0,0.5,1.0);    \n    uv = abs(co);\n    id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(0.5-max(uv.y,abs(dot(vec2(0.866026,0.5),uv))),length(co),co);\n}\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 gridnoise(vec2 uv)\n{\n\n    float t = iTime*1.5;\n    vec2 n = vec2(0);\n    vec2 q = vec2(0);\n    vec2 p = uv;\n    float d = dot(p,p);\n    float S = 7.;\n    float a = 0.0;\n    mat2 m = rotate2D(5.0);\n    for (float j = 0.; j < 6.; j++)\n    {\n        p *= m;\n        n *= m;\n        q = p * S + t * 0.55 + sin(t * 0.65 - d * 4.0) * 4.0 + j + a - n; \n        a += dot(cos(q)/S, vec2(0.4));\n        n -= sin(q+q*0.05);\n        S *= 1.4;\n\t    m=m*1.01;\n    }\n\n    vec3 col = vec3(1.9, 2.8, 1.6) * ((a*3.0)+0.3 ) + a + a - d;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = gridnoise(uv);\n\t\n\tuv *= rotate2D(iTime*0.075);\n    \n    \n\tvec3 finalcol = vec3(0.3);\n\tvec3 bordercol = col;\n\tvec2 id;\n \tvec4 h = HexGrid(uv*7.0, id);\t\n    \tfloat vv = smoothstep(0.01, 0.085, h.x);\n        vv=vv*vv;\n\t\n\tfloat xx = 1.0-vv;\n\t\n   \t  finalcol = xx*mix(bordercol,finalcol,vv); // white edge\t\n\tfinalcol += vec3(0.3)-xx;\n\n    // Output to screen\n    fragColor = vec4(finalcol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2cWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 545], [546, 546, 570, 570, 622], [624, 624, 649, 649, 1164], [1167, 1167, 1224, 1224, 1697]], "test": "untested"}
{"id": "DljyWK", "name": "Analog Clock", "author": "snurf08", "description": "Just a clock", "tags": ["time", "clock"], "likes": 0, "viewed": 101, "published": 3, "date": "1692296148", "time_retrieved": "2024-07-30T17:38:46.836138", "image_code": "#define PI 3.14159\n\n// SMOOTH OR FLAT\nconst bool SMOOTH = true;\nfloat smf(in float v,in float fac) {\n    if(SMOOTH) return v;\n    return floor(v*fac)/fac;\n}\n\nfloat norm(in float v) {\n    if(v<0.f) {\n        v = floor(abs(v))-abs(v);\n    }\n    return mod(v,1.f);\n}\nbool dlt(in float a,in float b,in float dist) {\n    return abs((100.f+a) - (100.f+b))<dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 cp = iResolution.xy/2.f;\n    \n    float angle = norm((atan(fragCoord.y-cp.y,fragCoord.x-cp.x)/PI+1.f)/2.f+.25f);\n    \n    float dist = sqrt(pow(fragCoord.x-cp.x,2.f)+pow(fragCoord.y-cp.y,2.f));\n    \n    float timeInSec = iDate.w;\n    \n    float sec = mod(timeInSec,60.f);\n    float mnt = mod(timeInSec/60.f,60.f);\n    float hor = mod(timeInSec/3600.f,12.f);\n    \n  \n    if(dist < 100.f) {\n        // HOUR DASHES\n        if(mod(angle*12.f,1.f) < 0.1f && dist > 90.f) {\n            fragColor = vec4(0.f);\n            return;\n        }\n        // MINUTE DASHES\n        if(mod(angle*60.f,1.f) < 0.075f && dist > 95.f) {\n            fragColor = vec4(0.f);\n            return;\n        }\n        bool secHandleVisible =  dlt(angle,smf(1.f-sec/60.f,60.f),.5f/dist) && dist < 95.f;\n        bool mntHandleVisible =  dlt(angle,smf(1.f-mnt/60.f,60.f),.5f/dist) && dist < 75.f;\n        bool horHandleVisible =  dlt(angle,smf(1.f-hor/12.f,12.f),.5f/dist) && dist < 60.f;\n        \n    \n        // Output to screen\n        fragColor = vec4(\n            (secHandleVisible?0.f:1.f) *\n            (mntHandleVisible?0.f:1.f) *\n            (horHandleVisible?0.f:1.f)\n        );\n    }else if(dist < 105.f) {\n        fragColor = vec4(0.f);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 100, 100, 156], [158, 158, 182, 182, 263], [264, 264, 311, 311, 357], [359, 359, 416, 416, 1656]], "test": "untested"}
{"id": "dtBcDV", "name": "julia set͏", "author": "01000001", "description": "Yeah so a friend of mine told me he did this by accident, adding a constant, the same constant, to each point instead of c. So I tried it. It works! yay. Why is every resource so useless that I understood this by accident before I understood any of them??", "tags": ["fractal", "julia", "complex", "imaginary"], "likes": 2, "viewed": 112, "published": 3, "date": "1692294255", "time_retrieved": "2024-07-30T17:38:47.599098", "image_code": "// FULLSCREEN! Trust me, it's worth it. Don't worry, the shader is very performant.\n\n\n\n\n\n// Thanks to https://www.shadertoy.com/view/4sBfRd\n#define C(c) O+= char(U,c).x; U.x-=.5;\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n    O = texture(iChannel0, U/iResolution.xy);\n    \n    \n    if (iMouse.x < 1. && iMouse.y < 1.){  // No mouse input yet\n        U = 8.*U/iResolution.y;\n        C(64+13);C(96+15);C(96+21);C(96+19);C(96+5);C(32);\n        C(64+9);C(96+14);C(96+16);C(96+21);C(96+20);C(33);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int iters = 512;\nint ssaa = 1;\nvec2 uvtc(vec2 u){ return (2.*u - iResolution.xy)/iResolution.y; }\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(v=hash(x+uint(v*1e9)).xy-.5;\n        dot(v,v)<.5;)\n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 mo = uvtc(iMouse.xy);\n    if (iMouse.x < 1. && iMouse.y < 1. || iFrame < 10){  // No mouse input yet\n        mo = .01*cos(iTime + vec2(11, 0)) - vec2(.7, .28);\n        iters = 512;\n        ssaa = 8;\n    } else {\n        mo = uvtc(iMouse.xy)*.5;\n    }\n        \n    float t = 0.;\n    \n    vec4 tex = iFrame==0?vec4(0):texture(iChannel0, U/r);\n    vec4 acc = iFrame==0?vec4(1):texture(iChannel0, r-r);\n    bool accum = acc.xy == mo;\n\n    if (U == vec2(.5)){\n        O.w = 1. + (accum?acc.w:0.);\n        O.xy = mo;\n        O.z = 0.; // Don't wanna leave it uninitialized\n        return;\n    }\n    \n    \n    for(int s = 0; s < ssaa; s++){\n    \n        vec2 uv = uvtc(U + \n            circleSample(uvec3(iFrame + s, int(U.x) + s, int(U.y) + s))\n        );\n        \n        float x = 0.;\n        vec2 z = uv;\n        int i = 0;\n        for(; i < iters; i++)\n        {\n\n            z = vec2(\n                z.x * z.x - z.y*z.y,\n                2. * z.x * z.y\n            ) + mo;\n\n            if (length(z) > 2.) break;\n        }\n\n        x = float(i-iters)/float(iters);\n        t += x;\n    }\n\n    t = t/float(ssaa);\n    t = (exp(t)-exp(-1.))/(1.-exp(-1.));\n    \n\n    O = mix(tex, vec4(t), 1./acc.w);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 205, 205, 375], [377, 377, 417, 417, 695]], "test": "untested"}
{"id": "dtByRw", "name": "test J/M set", "author": "Elyades", "description": "Quick draft of the sets. Trying to get more precision", "tags": ["mandelbrotset"], "likes": 3, "viewed": 136, "published": 3, "date": "1692288308", "time_retrieved": "2024-07-30T17:38:48.551553", "image_code": "// Fork of \"cos(1/sin(z)) J/M set\" by Elyades. https://shadertoy.com/view/Dd2BR3\n// 2023-08-09 10:44:20\n\n// Fork of \"J/M Set\" by Elyades. https://shadertoy.com/view/DdjfDh\n// 2023-07-21 15:02:44\n\nfloat PI = 3.1415926535897932;\nfloat PIONTWO = 1.57079632679;\nfloat TWOPI = 6.28318530718;\n\nfloat atan2(float y, float x)\n{\n    float result = atan(y,x);\n    if(result < 0.0){result += TWOPI;}\n    return result;\n}\n\nfloat add(float a, float b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return((a+b)/scalingFactor);\n}\n\nvec2 add2(float a, float b)\n{\n    float s = a + b;\n    float e = s - a;\n    float t = b - e;\n    float high = s;\n    float low = a - (s - t);\n    return vec2(high,low);\n}\n\nfloat lengthsquared(vec2 uv)\n{\n    return(uv.x*uv.x + uv.y*uv.y);\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = lengthsquared(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nfloat mult(float a, float b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return( a*b/(scalingFactor*scalingFactor));\n}\n\nvec2 add2d(vec2 a, vec2 b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return((a+b)/scalingFactor);\n}\n\nvec2 mult2d(vec2 a, vec2 b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return( vec2(add(a.x*b.x,-a.y*b.y,scalingFactor) , add(a.x*b.y,a.y*b.x,scalingFactor))/(scalingFactor*scalingFactor));\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\nvec2 rotate(vec2 uv,float angle)\n{\n    float co = cos(angle);float si = sin(angle);\n    uv *= mat2(co,-si,si,co);\n    return(uv);\n}\n\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    vec2 result = (exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5;\n    return vec2(-itimes(result));\n}\n\nvec2 tan2d(vec2 uv)\n{\n    return(sin2d(uv)/cos2d(uv));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float r = length(uv);\n    float angle = (n*(atan2(uv.y,uv.x)));\n    return( pow(r,n)*vec2(cos(angle),sin(angle)) );\n}\n\n\nvec2 iteration(vec2 uv, vec2 c)\n{    \n    vec2 result = cos2d(oneoverz(sin2d(uv))) + c;\n    return(result);\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.33,0.67,0.0);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec2 mousePoint = iMouse.xy/iResolution.xy/4.0;\n    \n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.5,1.0,0.0 + 4.0*mousePoint.x);\n    vec3 d = vec3(0.0,0.33, 0.67);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 thirdDegreeProcessing(vec3 color)\n{\n    float a = 8.92587;\n    float b = -13.75;\n    float c = 5.82143;\n    return vec3(a*color*color*color - b*color*color + c*color );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Scale\n    float scale = 8.0;\n    uv += -0.5;\n    uv *= scale;\n    uv.x *= iResolution.x / iResolution.y;\n\n    //Choosing the Zoom\n    float zoomAmount = pow(10.0,-iTime/8.0);\n    //zoomAmount = exp(-max(iTime-6.0,0.0));\n    //vec2 zoomPoint = vec2(0.354,0.0);\n    vec2 mousePoint = (iMouse.xy - iResolution.xy/2.0)*8.0/ iResolution.xy;\n    vec2 zoomPoint = vec2(-0.5,0.0);\n    \n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    //uv += mousePoint;\n    //uv += vec2(-0.61021,-0.0001);\n    //uv += zoomPoint*zoomAmount;\n    \n    //Determining the interior of the set\n    \n    //Change this line to go from Mandelbrot to Julia\n    //vec2 c = 30.0*(iMouse.xy/iResolution.xy - 0.5);\n    vec2 c = uv;\n    \n    float tol = pow(10.0,-8.0);\n    float currentModulus = lengthsquared(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    vec2 dummyuv = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = dummyuv;\n        dummyuv = iteration(dummyuv,c);\n        currentModulus = lengthsquared(dummyuv);\n        \n        if(currentModulus > pow(10.0,8.0))\n        {\n            break;\n        } \n    }\n\n    //Coloring the interior of the set\n    \n    if (currentModulus < pow(10.0,8.0))\n    {\n        \n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //Coloring the exterior of the set\n    \n    else\n    {\n        \n        /*if(iterationAmount <= 2)\n        {\n            float intensity = 1.0 - float(iterationAmount/10);\n            fragColor = vec4(intensity*0.7,intensity*0.0,intensity*1.0,1.0);\n        }*/\n        \n        //else\n        {\n            iterationAmount /= 200;\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette2(indexFast);\n            \n            int periodMedium = 30;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette2(indexMedium);\n            \n            int periodSlow = 100;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette2(indexSlow);\n\n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n     }\n        \n        \n    }\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtByRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 288, 319, 319, 409], [411, 411, 461, 461, 540], [542, 542, 571, 571, 712], [714, 714, 744, 744, 781], [783, 783, 805, 805, 839], [841, 841, 865, 865, 973], [975, 975, 1026, 1026, 1120], [1122, 1122, 1171, 1171, 1250], [1252, 1252, 1302, 1302, 1471], [1473, 1473, 1494, 1494, 1546], [1548, 1548, 1569, 1569, 1622], [1624, 1624, 1658, 1658, 1755], [1758, 1758, 1779, 1779, 1846], [1848, 1848, 1869, 1869, 1969], [1971, 1971, 1992, 1992, 2027], [2029, 2029, 2059, 2059, 2181], [2184, 2184, 2217, 2217, 2293], [2295, 2295, 2321, 2343, 2531], [2533, 2533, 2559, 2581, 2846], [2848, 2848, 2888, 2888, 3023], [3026, 3026, 3083, 3133, 5786]], "test": "untested"}
{"id": "clScDV", "name": "Epic Fractal Odyssey", "author": "KarmaDeezy", "description": "ChatGPT made this, I have no idea how to code (yet)", "tags": ["weird", "chatgpt"], "likes": 2, "viewed": 131, "published": 3, "date": "1692279088", "time_retrieved": "2024-07-30T17:38:49.343435", "image_code": "// Shadertoy 2023. \"Epic Fractal Odyssey\" by ChatGPT\n\n// Author: OpenAI\n\nuniform vec2 Mouse; // Mouse position in pixels (x, y)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    p *= 3.5;\n\n    vec2 c = vec2(cos(iTime), sin(iTime)) * 0.3;\n    c *= 1.0 + 0.5 * sin(iTime * 0.5);\n\n    // Convert mouse position to fractal coordinates\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    mousePos = mix(vec2(-1.0, -1.0), vec2(1.0, 1.0), mousePos);\n    c += 0.6 * mousePos;\n\n    float zoom = 1.5 + 1.0 * sin(iTime * 0.3);\n    p /= zoom;\n\n    vec2 z = p;\n    float intensity = 0.0;\n\n    for (int i = 0; i < 400; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        intensity += length(z);\n\n        if (length(z) > 100.0)\n            break;\n    }\n\n    intensity = pow(intensity / 400.0, 0.6);\n\n    // Color variation based on distance from the center\n    vec3 baseColor = vec3(intensity * 0.7, 0.3 + intensity * 0.2, 0.4 + intensity * 0.6);\n    vec3 colorVariation = 0.5 + 0.5 * vec3(sin(iTime), cos(iTime * 0.7), sin(iTime * 1.3));\n    vec3 color = baseColor * colorVariation;\n\n    // Add subtle animated waves\n    float waves = 0.03 * sin(p.y * 10.0 + iTime);\n    color += vec3(waves);\n\n    // Apply vignette effect based on distance from the center\n    float vignette = 1.0 - 0.7 * length(p);\n    color *= vignette;\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clScDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 184, 184, 1471]], "test": "untested"}
{"id": "Wl2yDy", "name": "Rope with alternating twist", "author": "fizzgig", "description": "need to figure out actual braid", "tags": ["rope"], "likes": 25, "viewed": 231, "published": 3, "date": "1692275940", "time_retrieved": "2024-07-30T17:38:50.113376", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    float strongth;\n    vec3 color;\n};\n\n#define PI 3.1415926\n    \nmat4 euler(float x, float y, float z) {\n    mat4 xmat = mat4(vec4(1.0,  0.0,    0.0,    0.0),\n                     vec4(0.0,  cos(x), sin(x), 0.0),\n                     vec4(0.0, -sin(x), cos(x), 0.0),\n                     vec4(0.0,  0.0,    0.0,    1.0));\n    mat4 ymat = mat4(vec4( cos(y), 0.0, sin(y), 0.0),\n                     vec4( 0.0,    1.0, 0.0,    0.0),\n                     vec4(-sin(y), 0.0, cos(y), 0.0),\n                     vec4( 0.0,    0.0, 0.0,    1.0));\n    mat4 zmat = mat4(vec4( cos(z),  sin(z), 0.0, 0.0),\n                     vec4(-sin(z),  cos(z), 0.0, 0.0),\n                     vec4( 0.0,     0.0,    1.0, 0.0),\n                     vec4( 0.0,     0.0,    0.0, 1.0));\n    \n    return xmat*ymat*zmat;\n}\n\nmat4 transform(float x, float y, float z) {\n    return mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(x,   y,   z,   1.0));\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(point - center) - radius;\n}\n\nfloat planeSDF(vec3 origin, vec3 normal, vec3 point) {\n    return dot(point - origin, normal);\n}\n\nfloat ropeSDF(float coiledness, uint n, vec3 point) {\n    for (uint i = 0u; i < n; ++i) {\n        float r = length(point.xz);\n    \tfloat t = atan(-point.x, -point.z) + PI;\n        \n        t -= 2.0*PI*coiledness*float(2u*i+1u);\n        t = mod(t, 2.0*PI/3.0) + 2.0*PI/3.0;\n        \n        point.x = r*sin(t);\n        point.z = r*cos(t);\n        \n        point.z += 1.0;\n        point.xz *= 1.0 + 1.0/sin(PI/3.0);\n        point.z *= -1.0;\n    }\n    \n    point.xz /= 1.0 + sin(PI/3.0);\n    \n    float lpxz = length(point.xz);\n    \n    vec2 d = vec2(lpxz, abs(point.y + 0.5)) - vec2(1.0,0.5);\n    \n    for (uint i = 0u; i < n; ++i) d.x /= 1.0 + 1.0/sin(PI/3.0);\n    \n    d.x *= 1.0 + sin(PI/3.0);\n    \n    return min(max(d.x,d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sceneSDF(vec3 point) {\n    point.y /= 20.0;\n    return ropeSDF(1.0-(0.5*cos(iTime*0.2+PI)+0.5)*(point.y+1.0), 5u, point);\n   /*return min(\n       min(\n           min(\n               sphereSDF(vec3(-0.7, 0.7, 0.0), 0.5, point),\n               sphereSDF(vec3(0.7, 0.7, 0.0), 0.5, point)\n           ),\n           sphereSDF(vec3(0.0), 1.0, point)\n       ),\n       planeSDF(vec3(0.0), vec3(0.0, 1.0, 0.0), point)\n     );\n   */\n}\n\nvec3 sceneSDFGradient(vec3 point, float epsilon) {\n    vec3 xe = vec3(epsilon, 0.0, 0.0)/2.0;\n    vec3 ye = vec3(0.0, epsilon, 0.0)/2.0;\n    vec3 ze = vec3(0.0, 0.0, epsilon)/2.0;\n    \n    return vec3(\n        (sceneSDF(point + xe) - sceneSDF(point - xe)) / epsilon,\n        (sceneSDF(point + ye) - sceneSDF(point - ye)) / epsilon,\n        (sceneSDF(point + ze) - sceneSDF(point - ze)) / epsilon\n      );\n}\n\nvec3 sceneSDFNormal(vec3 point) {\n    return normalize(sceneSDFGradient(point, 0.01));\n}\n\nvec3 rayPoint(Ray ray, float dist) {\n    return ray.origin + dist * ray.direction;\n}\n\nvec3 screen(vec3 a, vec3 b) {\n    return vec3(1.0) - (vec3(1.0) - a)*(vec3(1.0) - b);\n}\n\nvec3 lightPoint(Light light, vec3 point, vec3 normal, vec3 camera, vec3 diffuse, vec3 bounce, vec3 current) {\n    vec3 lightchord = light.position - point;\n    \n    vec3 lightcolor = light.color * 1.0 / pow(length(lightchord/3.0)/light.strongth+1.0, 2.0);\n    \n    vec3 colour = diffuse * lightcolor * max(dot(normal, normalize(lightchord)), 0.0);\n    colour = screen(colour, bounce * lightcolor * max(vec3(1.0) - 5.0*(vec3(1.0) - dot(normalize(lightchord), reflect(normalize(point - camera), normal))), 0.0));\n    \n    return screen(current, colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lightradius = 3.0;\n    \n    float lightangle = iTime;\n    \n    Light light1 = Light(vec3(lightradius*cos(lightangle), 2.0, lightradius*sin(lightangle)), 10.0, vec3(0.5, 0.5, 0.5));\n    \n    lightangle += PI*2./3.;\n    \n    Light light2 = Light(vec3(lightradius*cos(lightangle), 2.0, lightradius*sin(lightangle)), 10.0, vec3(0.5, 0.6, 0.5));\n    \n    lightangle += PI*2./3.;\n    \n    Light light3 = Light(vec3(lightradius*cos(lightangle), 2.0, lightradius*sin(lightangle)), 10.0, vec3(0.4, 0.4, 1.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light4 = Light(vec3(lightradius*cos(lightangle), -22.0, lightradius*sin(lightangle)), 10.0, vec3(0.5, 0.6, 0.5));\n    \n    lightangle += PI*2./3.;\n    \n    Light light5 = Light(vec3(lightradius*cos(lightangle), -22.0, lightradius*sin(lightangle)), 10.0, vec3(0.4, 0.4, 1.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light6 = Light(vec3(lightradius*cos(lightangle), -22.0, lightradius*sin(lightangle)), 10.0, vec3(0.5, 0.5, 0.5));\n    \n    float disttoscreen = 1.0;\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 camorigin = vec3(-6.0, 6.0, 0.0);\n    \n    mat4 camtoscene = transform(camorigin.x, camorigin.y, camorigin.z)*euler(PI*0.5, -PI*0.18, 0.0);\n    \n    Ray ray = Ray((camtoscene*vec4(vec3(0.0),1.0)).xyz,\n                  normalize(camtoscene*vec4(uv.x, uv.y, disttoscreen, 0.0)).xyz);\n    \n    vec3 point = camorigin;\n    \n    float scenedist = sceneSDF(point);\n    float raydist = 0.0;\n    \n    float epsilon = 0.0001;\n    float end = 100.0;\n    \n    while (scenedist > epsilon) {\n        if (raydist > end) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        \n        point = rayPoint(ray, raydist);\n        \n        scenedist = sceneSDF(point);\n        \n        raydist += scenedist*0.6;\n    }\n    \n    vec3 normal = sceneSDFNormal(point);\n    vec3 diffuse = vec3(1.0);\n    vec3 bounce = vec3(1.0);\n        \n    vec3 colour = lightPoint(light1, point, normal, camorigin, diffuse, bounce, vec3(0.0));\n    colour = lightPoint(light2, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light3, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light4, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light5, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light6, point, normal, camorigin, diffuse, bounce, colour);\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2yDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 193, 193, 882], [884, 884, 927, 927, 1098], [1100, 1100, 1156, 1156, 1202], [1204, 1204, 1258, 1258, 1300], [1302, 1302, 1355, 1355, 2060], [2062, 2062, 2090, 2090, 2491], [2493, 2493, 2543, 2543, 2899], [2901, 2901, 2934, 2934, 2989], [2991, 2991, 3027, 3027, 3075], [3077, 3077, 3106, 3106, 3164], [3166, 3166, 3275, 3275, 3719], [3721, 3721, 3778, 3778, 6342]], "test": "untested"}
{"id": "mlSyRt", "name": "Colorful-tunnel1", "author": "mokasiri", "description": "Colorful-tunnel1", "tags": ["colorfultunnel1"], "likes": 1, "viewed": 157, "published": 3, "date": "1692275048", "time_retrieved": "2024-07-30T17:38:50.976069", "image_code": "vec3 palette(float t) {\n    vec3 a = vec3(0.500, 0.500, 0.500);\n    vec3 b = vec3(0.468, 0.500, 0.500);\n    vec3 c = vec3(0.838, 1.000, 1.000);\n    vec3 d = vec3(-0.422, 0.638, -0.252);\n    return a + b * cos(6.28318*(c*t+d));\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/ iResolution.xy-0.5; \n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec2 uv0 = uv;\n    \n    uv *= 4.0;\n    \n    \n    float d = length(uv); \n    \n    vec3 col = palette(length(uv0) + iTime/2.0);\n    d = 5.0/d;\n    d = sin(d*8.0+ iTime)/8.0;\n    d = abs(d);\n    d = 0.1/d;\n    \n    \n    col *= d;\n    fragColor = vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 228], [235, 235, 292, 292, 659]], "test": "untested"}
{"id": "ctjyWy", "name": "Rectangle Repetition", "author": "iq", "description": "Domain repetition in the shape of a rectangle. The basic shape SDF (square) is evaluated only ONCE. Better than doing a limited repetition ([url]https://www.shadertoy.com/view/3syGzz[/url]) and then carving out its interior with a max() subtraction.", "tags": ["2d", "repetition"], "likes": 34, "viewed": 862, "published": 3, "date": "1692261268", "time_retrieved": "2024-07-30T17:38:52.016288", "image_code": "// Domain repetition in the shape of an empty rectangle.\n// The basic shape SDF (rounded square in this case) is\n// evaluated only ONCE.\n//\n// IT ONLY WORKS ON SYMMETRIC SHAPES.\n//\n// Note that this is better than doing a limited repetition\n// (see https://www.shadertoy.com/view/3syGzz) and then\n// carving out its interior with a max() subtraction.\n//\n// More info: https://iquilezles.org/articles/sdfrepetition/\n\n\nfloat sdShape(in vec2 p);\n\n// Created by user \"timestamp\", see comments\nvec2 opRepRectangle( in vec2 p, in ivec2 size, in float spacing )\n{            \n    p = abs(p/spacing) - (vec2(size)*0.5-0.5);\n    p = (p.x<p.y) ? p.yx : p.xy;\n    p.y -= min(0.0, round(p.y));\n    return p*spacing;\n}\n\n// My original version, not nearly as elegant and timestamp's\nvec2 _old_opRepRectangle( in vec2 p, in ivec2 size, in float spacing )\n{\n    vec2 b = vec2(size>>1);\n    p = abs(p/spacing);\n    p += 0.5*vec2(1-(size&1));\n    vec2 w = p - b;\n    p -= round(min(p,b));\n    return spacing*( (w.x<w.y )? vec2(p.x,w.y) : vec2(w.x,p.y) );\n}\n\n\n\nfloat sdShape(in vec2 p)\n{\n    // an sdBox()\n    vec2  w = abs(p)-0.07;\n    float g = max(w.x,w.y);\n    return ((g>0.0)?length(max(w,0.0)):g)-0.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    ivec2 size = ivec2(round(vec2(6,4) + vec2(2,1)*sin(floor(iTime/2.0)*vec2(9.7,11.1)+vec2(0,2))));\n    float rep = 0.4;\n\n    float d = sdShape( opRepRectangle(p,size,rep) );\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n  //if( d<0.0 ) { vec2 id = round(p/rep+0.5*(1.0-vec2(size&1)) ); col += sin(id.x*0.31+0.73*id.y+vec3(0,1,2)); } \n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdShape( opRepRectangle(m,size,rep) );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 489, 556, 556, 705], [707, 769, 841, 841, 1038], [1042, 1042, 1068, 1086, 1191], [1193, 1193, 1250, 1250, 2213]], "test": "untested"}
{"id": "dlScDy", "name": "Fork NEON LOVE awahab 863", "author": "awahab", "description": "Quadratic Bezier curve SDF with glow. Using distance function from [url]https://www.shadertoy.com/view/MlKcDD[/url]\n\nAt sharp turns, the SDF has creases in the far field. Smooth minimum functions seem to distort low values. Is there a fix for this?", "tags": ["2d", "sdf", "bezier", "heart", "glow", "curve", "neon"], "likes": 4, "viewed": 212, "published": 3, "date": "1692223153", "time_retrieved": "2024-07-30T17:38:52.874992", "image_code": "// gelami has created a nice fix for the creases: https://www.shadertoy.com/view/7l3GDS\n\n#define POINT_COUNT 2\n\nvec2 points[POINT_COUNT];\nconst float speed = -0.5;\nconst float len = 0.25;\nconst float scale = 0.012;\nfloat intensity = 1.3;\nfloat radius = 0.015;\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n\n//http://mathworld.wolfram.com/HeartCurve.html\nvec2 getHeartPosition(float t){\n    return vec2(16.0 * sin(t) * sin(t) * sin(t),\n                -(13.0 * cos(t) - 5.0 * cos(2.0*t)\n                - 2.0 * cos(3.0*t) - cos(4.0*t)));\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n    return pow(radius/dist, intensity);\n}\n\nfloat getSegment(float t, vec2 pos, float offset){\n\tfor(int i = 0; i < POINT_COUNT; i++){\n        points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);\n    }\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n\tfloat dist = 1000.0;\n    \n    for(int i = 0; i < POINT_COUNT-1; i++){\n        //https://tinyurl.com/y2htbwkm\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));\n    }\n    return max(0.0, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 pos = centre - uv;\n    pos.y /= widthHeightRatio;\n    //Shift upwards to centre heart\n    pos.y += 0.03;\n\t\n    float t = iTime;\n    \n    //Get first segment\n    float dist = getSegment(t, pos, 0.0);\n    float glow = getGlow(dist, radius, intensity);\n    \n    vec3 col = vec3(0.0);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Pink glow\n    col += glow * vec3(10.0,0.05,0.3);\n    \n    //Get second segment\n    dist = getSegment(t, pos, 0.4);\n    glow = getGlow(dist, radius, intensity);\n    \n    //White core\n    col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Blue glow\n    col += glow * vec3(0.1,0.4,1.0);\n        \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    \n    for (float i = 0.0; i < 10.; i+= 1.) {\n    \n       dist = getSegment(t, pos * sin(iTime), (pow(iMouse.x, sin(iTime * .001)))* i * 10.1);\n        glow = getGlow(dist, radius, intensity);\n        col += 10.0*vec3(smoothstep(0.006, 0.003, dist));\n    //Blue glow\n        col += glow * vec3(0.0,1.0,0.0);\n    }\n \n    \n    //White core\n\n        \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    //Gamma\n    col = pow(col, vec3(0.4545));\n\n    //Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "/*\n    Copyright (c) 2019 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlScDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 341, 390, 390, 1666], [1669, 1716, 1747, 1747, 1900], [1902, 1942, 1999, 1999, 2041], [2043, 2043, 2093, 2093, 2588], [2590, 2590, 2646, 2646, 3993]], "test": "untested"}
{"id": "mtByDy", "name": "Colorful Backup Spirals", "author": "Aurcereal", "description": "really bright", "tags": ["raymarching", "domainrepetition", "glow"], "likes": 11, "viewed": 201, "published": 3, "date": "1692221840", "time_retrieved": "2024-07-30T17:38:53.810491", "image_code": "// Fork of \"graphic 3dtest5w\" by Aurcereal. https://shadertoy.com/view/DlScDy\n// 2023-08-16 21:02:27\n\n// Fork of \"graphic 3dtest\" by Aurcereal. https://shadertoy.com/view/dlBcD1\n// 2023-08-16 17:38:30\n\n// Fork of \"graphic ctest\" by Aurcereal. https://shadertoy.com/view/dtByD1\n// 2023-08-10 23:33:27\n\n#define MAXDIST 100.\n#define MAXSTEPS 300\n#define SDEPS 0.0001\n#define NORMEPS 0.0001\n\nvec2 getDomainDim()\n{\n    float tt = t*.5;\n    float rep = 120.*.5*.67;\n    tt = mod(tt, rep);\n    tt = tt + step(rep*.5, tt) * (rep*.5 - (tt - rep*.5) - tt);\n\n    return vec2(4.+tt*.4, 4.);\n}\n\nvec3 currCol;\n\nvec3 getCol(vec3 p)\n{\n\n    vec2 domxy = getDomainDim().x * vec2(1., 1.);\n    p.xy = p.xy - (mod(p.xy, domxy) - domxy*.5);\n    p.xy /= domxy;\n    \n    float domz = getDomainDim().y;\n    p.z = p.z - (mod(p.z+domz*.5, domz) - domz*.5);\n    \n    float h = hash31flr(p*10.+100.);\n    \n    return hsv2rgb(vec3(h, .9, 1.)); //.8 .8\n    \n}\n\nfloat smin(float a, float b, float k)\n{\n    float d = abs(a - b);\n    float h = pow(1. - max(0., d/k), 2.);\n    return min(a, b) - .25 * k * h;\n}\n\nfloat getFog(float dist)\n{\n    return saturate(exp(-dist*.1+2.));\n}\n\nfloat sdrails(vec3 p)\n{\n\n    vec3 wp = p;\n    \n    float spiralRep = getDomainDim().x;\n    vec2 xyID = p.xy - (mod(p.xy, spiralRep) - spiralRep*.5); //xyID *= 0.;\n    p.xy = p.xy - xyID;\n\n    p.z += (8.+2.) * t;\n    \n    \n\n    float rotAmount = hash21(xyID/spiralRep+50.)*100.+t+.1*max(0., p.z - 10.);\n    p = rot(p, V.yyx, rotAmount);\n    //p = rot(p - .1*vec3(1., 1., 0.), V.yyx, .1*rotAmount);\n    currCol = getCol(p+vec3(xyID.x, xyID.y, 0.));\n    \n\n    vec2 domainDim = vec2(2.7, getDomainDim().y);\n    vec2 highlightDim = vec2(.2, 2.);\n    \n    float thickness = 0.005*100. * (1. + .5 * smoothstep(2., 7., length(xyID)));\n    \n    //\n    p.z = mod(p.z+domainDim.y*.5, domainDim.y) - domainDim.y*.5;\n    p.x = abs(p.x) - domainDim.x*.5;\n    \n    p = abs(p);\n    \n    return sdBox(p, vec3(highlightDim.x, thickness, highlightDim.y));\n    \n    \n}\n\nfloat sdf(vec3 p)\n{\n    return sdrails(p); //be careful chaining too far\n}\n\nfloat sdGlowObject(vec3 p)\n{\n    return sdf(p);\n}\n\nvec3 sampleGlow(vec3 p, float squeeze, float size, float offset)\n{\n    return 4.*currCol * getFog(p.z) * .3*(1.-exp(-size/pow(sdGlowObject(p)+offset, squeeze))); //*1.4\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(NORMEPS, 0.);\n    \n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n        ));\n}\n\nfloat march(vec3 ro, vec3 rd, out int steps, out vec3 glow)\n{\n    \n    steps = 0; glow = vec3(0.);\n    float sd, d = 0.;\n    \n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        sd = min(.5+100.*0., sdf(ro + rd*d));\n        d += sd;\n        steps++;\n        glow += sd * sampleGlow(ro + rd * d, 10., 0.3, .9);\n        if(abs(sd) < SDEPS || d >= MAXDIST) return d;\n    }\n    \n    return d;\n    \n}\n\nfloat aspect;\n\nvec3 skybox(vec3 rd, vec3 lrd, vec2 wp)\n{\n\n    return hsv2rgb(vec3(acos(rd.y) * IPI+t*.05, .8, .8)) * .3 + V.xxx * pow(hash21(100.*vec2(acos(lrd.y), atan(lrd.z, lrd.x))), .5*10.*356.);\n}\n\nvec3 shade(vec3 camPos, vec3 rd, vec3 p, vec3 norm, int steps, out float fog)\n{\n\n    //\n    vec3 lightDir = -V.yxy;//-V.xyx/sqrt(2.);//genUnconstrainedDir(hash11(1.44), hash11(2.44), vec2(0.0004));//\n    \n    //\n    float diffuse = saturate(-.1+dot(norm, lightDir));\n    diffuse = pow(diffuse, 0.5);\n    \n    //\n    float specular = pow(max(0., dot(reflect(rd, norm), lightDir)), 8.);\n    \n    //\n    fog = getFog(dot(p - camPos, rd));\n    float AO = max(0., 1. - float(steps) / 20.);\n    \n    //\n    return mix(mix((diffuse * .9 + specular * .9 + AO * .8) * 2.4*currCol, currCol, 0.9), (1.+2.*.7)*texture(iChannel0, reflect(rd, norm)).rgb, .2);\n}\n\nvec3 postProcess(vec3 col, vec2 p)\n{\n    vec2 lp = abs(p);\n    lp = vec2(aspect, 1.) - lp;\n    float d = min(lp.x, lp.y);\n    float vignette = smoothstep(0.4, 0., d);\n    \n    float bg = sample2DBackground(p);\n    return (1.- bg) * mix(col, V.yyy, vignette*0.3) + bg * V.xxx;\n}\n\nvec3 render(vec2 fragCoord)\n{\n    //\n    t = iTime*2.;\n\n    //\n    float fAng = -.4*.3*sin(.3*t); //-.1\n    float twist = .4 * .2 * cos(.2*t+10.);\n    vec3 fo = -rot(vec3(0., sin(fAng), cos(fAng)), V.yxy, twist);\n    vec3 ro = vec3(0., 2., -5.);\n\n    vec3 lrd = normalize(vec3((fragCoord/iResolution.xy)*2.-1., 1.) * vec3(1., .577, 1.));\n    \n    float o = 0.;//t*.7;\n    vec3 up = vec3(-sin(o), cos(o), 0.);\n    vec3 ri = normalize(cross(up, fo)); up = cross(fo, ri);\n    \n    vec3 rd = mat3(ri, up, fo) * lrd;\n    \n    //\n    int steps; vec3 glow;\n    float dist = march(ro, rd, steps, glow);\n    \n    vec2 wp = (fragCoord/iResolution.xy*2.-1.)*vec2(aspect, 1.);\n    vec3 skySample = glow + skybox(rd, lrd, wp);\n    float fog; vec3 solidSample = (glow + shade(ro, rd, ro+rd*dist, normal(ro+rd*dist), steps, fog));\n    \n    if(dist >= MAXDIST) return postProcess(skySample, wp);\n    return postProcess(mix(solidSample, skySample, 1.-fog), wp);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   aspect = iResolution.x/iResolution.y;\n   \n   vec2 d = vec2(.5,0.); //1.\n   vec3 col = render(fragCoord+d.yy);// + render(fragCoord+d.xy) + render(fragCoord+d.yx) + render(fragCoord+d.xx); col *= .25;\n   fragColor = vec4(pow(col, vec3(.5)), 1.);\n   \n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define IPI 0.318309\n#define TAU 6.28318\n#define V vec2(1., 0.)\n\n//Hash functions from https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31flr(vec3 p3)\n{\n    p3 = p3 - mod(p3, .1);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, 0., 1.);\n}\n\nvec3 saturate(vec3 c)\n{\n    return vec3(saturate(c.x), saturate(c.y), saturate(c.z));\n}\n\nvec2 fold(vec2 v, vec2 n)\n{\n    return v - 2. *  n * min(0., dot(v, n));\n}\n\nvec3 fold(vec3 v, vec3 n)\n{\n    return v - 2. *  n * min(0., dot(v, n));\n}\n\nfloat unlerp(float a, float b, float t)\n{\n    return saturate((t-a)/(b-a));\n}\n\nvec3 rot(vec3 v, vec3 a, float o)\n{\n    float along = dot(v, a);\n    \n    vec3 up = normalize(cross(v, a));\n    vec3 ri = cross(up, a);\n    \n    float r = length(cross(v, a));\n    \n    return a * along + ri * r * cos(o) + up * r * sin(o);\n}\n\nfloat t;\n\nfloat randLinear(float t, vec2 range, float rand)\n{\n    float rangeRand = abs(rand-.5)*2.;\n    float sig = step(rand, 0.5)*2.-1.;\n    return t * (range.x + (range.y-range.x)*rangeRand) * sig;\n}\n\nvec3 genDir(float rand, float phiBound) // ~ [0, 1]\n{\n    float theta = randLinear(1.+t, vec2(1., 2.), rand);\n    float phi = phiBound * sin(randLinear(1.+t, vec2(0.7, 1.4), rand));\n    \n    return vec3(cos(phi) * cos(theta), sin(phi), cos(phi) * sin(theta));\n}\n\nvec3 genUnconstrainedDir(float rand1, float rand2, vec2 speedRange)\n{\n    float theta = randLinear(1.+t, speedRange, rand1);\n    float phi = randLinear(1.+t, speedRange, rand2);\n    \n    return vec3(cos(phi) * cos(theta), sin(phi), cos(phi) * sin(theta));\n}\n\nvec3 genUnconstrainedDir(float rand1, float rand2)\n{\n    return genUnconstrainedDir(rand1, rand2, .4*vec2(1., 2.));\n}\n\n//2D\n\nvec2 rot(vec2 p, float o)\n{\n    return mat2(cos(o), sin(o), -sin(o), cos(o)) * p;\n}\nvec2 perp(vec2 p)\n{\n    return rot(p, PI*.5);\n}\nvec2 toCart(vec2 polar)\n{\n    return polar.x * vec2(cos(polar.y), sin(polar.y));\n}\nfloat sdRect(vec2 p, vec2 fo, vec2 dim)\n{\n    p = abs(vec2(dot(p, fo), dot(p, perp(fo)))) - dim*.5;\n    float s = sqrt(max(0., p.x*p.x*sign(p.x)) + max(0., p.y*p.y*sign(p.y)));\n    return s + step(s, 0.) * max(p.x, p.y);\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n//\n\n// Official HSV to RGB conversion taken from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//fullscreen\n\nfloat bellCurve(float x)\n{\n    return exp(-x*x);\n}\n\nfloat sample2DBackground(vec2 p)\n{\n    float exists = 0.;\n\n    //\n    p = abs(p) * sign(p.x) * sign(p.y); //it'd be nice to have the rings have a bit of a delayed bounce\n    \n    // it'd also be cool to have a rectangle highlight that connects the circles instead of the highlights going offscreen\n    float r = 0.6;\n    float thetaRepLen = 0.2;\n    vec2 highlightDim = vec2(0.1, 0.05);\n    \n    float it = unlerp(4., 4.4, t);\n    float scale = 1.-pow(1.-it, 2.); scale += .3*bellCurve((it-.4)*2.); //.6, 10\n    scale *= 1.-step(it, 0.);\n    \n    p = p - vec2(1.67, 1.);\n    p /= scale;\n    exists += step(sdCircle(p, r), 0.);\n    \n    vec2 polar = vec2(length(p), .4*t+atan(p.y, p.x));\n    polar.y = mod(polar.y, thetaRepLen) - thetaRepLen*.5;\n    polar.x = polar.x - r*1.1;\n    polar = abs(polar);\n    exists += step(polar.x, highlightDim.y*.5) * step(polar.y, highlightDim.x*.5);\n    \n    return exists;\n}\n\n\n//3D\n\nfloat sdBox(vec3 p, vec3 dim)\n{\n    p = abs(p) - dim*.5;\n    float s = sqrt(max(p.x*p.x*sign(p.x), 0.) + max(p.y*p.y*sign(p.y), 0.) + max(p.z*p.z*sign(p.z), 0.));\n    return s + step(s, 0.) * max(max(p.x, p.y), p.z);\n}\n\nfloat sdEdgedBox(vec3 p, vec3 dim, float thickness, vec3 fo)\n{\n    //\n    vec3 ri = normalize(cross(fo, vec3(0., 1., 0.)));\n    vec3 up = cross(ri, fo);\n    p = vec3(dot(p, ri), dot(p, up), dot(p, fo));\n    \n    //\n    p = abs(p);\n    p = p - dim*.5;\n    \n    p = fold(p, 1./sqrt(2.) * vec3(-1., 0., 1.));\n    p = fold(p, 1./sqrt(2.) * vec3(1., -1., 0.));\n    \n    return sdBox(p - vec3(0., thickness*.5-(dim.y+thickness)*.25, 0.), vec3(thickness, 5.*(dim.y+thickness)*.5, thickness));\n}\n\nfloat sdCone(vec3 p, vec2 dim, vec3 up) //sparse on ring slightly smaler than ud think maybe\n{\n    vec2 lp = vec2(length(cross(p, up)), dot(p, up));\n    lp /= dim;\n    return max(dot(vec2(1., 1.)/sqrt(2.), lp - vec2(0., 1.)), -lp.y);\n}\n\nfloat sdRing(vec3 p, vec3 dim, vec3 fo)\n{\n    vec2 lp = vec2(dot(p, fo), length(cross(p, fo)));\n    return sdRect(lp - vec2(0., dim.z), vec2(1., 0.), dim.xy);\n}\n\nfloat sdRingConed(vec3 p, vec3 dim, vec3 fo, vec3 up, float coneOffset, vec2 coneDim, float coneCount, float t)\n{\n    vec3 lp = vec3(dot(p, fo), dot(p, up), dot(p, cross(fo, up)));\n    \n    vec2 plp = vec2(lp.x, length(lp.yz));\n    float sdRing = sdRect(plp - vec2(0., dim.z), vec2(1., 0.), dim.xy);\n    \n    vec2 polar = vec2(length(lp.yz), t + atan(lp.z, lp.y));\n    polar.y = mod(polar.y, TAU/coneCount) - .5 * TAU/coneCount;\n    lp = vec3(lp.x, polar.x * sin(polar.y), polar.x * cos(polar.y));\n    float sdC = sdCone(lp - vec3(0., 0., dim.z + dim.y * .5 + coneOffset), coneDim, vec3(0., 0., 1.));\n    \n    return min(sdC, sdRing);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtByDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[388, 388, 409, 409, 580], [597, 597, 618, 618, 928], [930, 930, 969, 969, 1075], [1077, 1077, 1103, 1103, 1144], [1146, 1146, 1169, 1169, 1994], [1996, 1996, 2015, 2015, 2070], [2072, 2072, 2100, 2100, 2121], [2123, 2123, 2189, 2189, 2293], [2295, 2295, 2316, 2316, 2516], [2518, 2518, 2579, 2579, 2909], [2926, 2926, 2967, 2967, 3112], [3114, 3114, 3193, 3201, 3761], [3763, 3763, 3799, 3799, 4040], [4042, 4042, 4071, 4078, 4993], [4995, 4995, 5052, 5052, 5307]], "test": "untested"}
{"id": "dtSyWG", "name": "Be one with the eye", "author": "santiagolucero", "description": "Testing", "tags": ["testing"], "likes": 3, "viewed": 125, "published": 3, "date": "1692209075", "time_retrieved": "2024-07-30T17:38:54.680166", "image_code": "vec3 palette (float t) {\n    vec3 a= vec3(3.138, 0.758, 1);\n    vec3 b= vec3(3.138, 0.048, 0.500);\n    vec3 c= vec3(0.358, 4, 0.718);\n    vec3 d= vec3(0.498, 0.333, 0.008);\n    \n    return a + b*cos(23.*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord*2.0-iResolution.xy))/iResolution.y*1.5;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i=0.0; i<3.;i++){\n\n        uv = fract(uv*1.)- 0.5;\n\n        float d = length (uv)*exp(length(uv0));\n        vec3 col = palette(length(uv0)+iTime*0.1+ i*0.4);\n\n        d = (sin(d*3. + iTime))/8.;\n        d = abs(d);\n        d = pow(0.007 /d ,2.2);\n\n        finalColor += col * d;\n        \n        }\n    // Output to screen\n    \n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 214], [217, 217, 274, 274, 779]], "test": "untested"}
{"id": "DlByDy", "name": "Springy Subdivision [324 Chars]", "author": "SnoopethDuckDuck", "description": "color could be better but the motion is cool, golifng always welcome!", "tags": ["spring", "subdivision", "onetweet", "golf"], "likes": 32, "viewed": 441, "published": 3, "date": "1692206713", "time_retrieved": "2024-07-30T17:38:55.543856", "image_code": "// -10 thanks to Xor 🦙\n// -26  thanks to Fabrice 🦙\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = 1.4 * u / iResolution.xy - .7; \n    \n    float i, // index\n          t, // time\n          f, // fract(time)\n          j; // id\n    \n    for (O *= i; i++ < 8.; O += .6 / exp( (2.+i) * dot(u,u) ) ) \n    {\n        // Springy time\n        f = fract( t = .05*i + .35*iTime - .4 );\n        t -= f + cos(23.*f) / exp(7.*f) - i/.8; \n        \n        // New horiz&vert splits      \n        vec2 H = .4* cos( t + vec2(0,11) ), \n        \n        // New bounds   \n        s = .5*sign(H-u);  \n        \n        j += s.x+s.y+1., \n        \n        // Map uv to new bounds and rotate\n        u = mat2(H,-H.y,H) * ( (u+u -H+s) / (s+H) *s ) /.4;       \n    }\n    \n    // Color (O * palette -> gamma)\n    O = .7 * sqrt(O + O*cos(.4*j +cos(vec4(1,2,3,0)*t)));         \n}\n\n\n// Mid version [352 Chars]\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = 1.4 * u / iResolution.xy - .7;\n         \n    float i, // index\n          t, // time\n          h, // horizontal split\n          v, // vertical split\n          j; // id\n          \n    for (O *= i; i++ < 8.; O += .6 / exp((2.+i) * dot(u,u))) {  \n        vec2 z,\n        B = .5 + z, // top-right bounds\n        A = -B;     // bot-left  bounds\n\n        v = fract(t = .05 * i + .35 * iTime - .4),\n\n        // New splits and springy time\n        // (S=cos(t+vec2(0,11)) needs too many S.x's)\n        h = .4 * cos(t -= v + cos(23.*v)/exp(7.*v) - i/.8),\n        v = .4 * sin(t),\n       \n        // New bounds and id\n        u.x < h ? B.x = h, j+=.4 \n                : A.x = h,\n        u.y < v ? B.y = v, j+=.4\n                : A.y = v,\n\n        // Map uv to new bounds and rotate\n        u = (u+u-A-B) / (B-A) * mat2(h, -v, v, h)/.8;\n    }        \n    // Color (O * palette -> gamma)\n    O = .71 * sqrt(O + O*cos(j+cos(vec4(1,2,3,0)*t)));\n}\n//*/\n\n\n// Original [379 Chars]\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = 1.4 * (u / iResolution.xy - .5);\n         \n    float i,    // index\n          t,    // time\n          h,    // horizontal split\n          v,    // vertical split\n          j, k, // x, y id values\n          a, b, // x1, x2 horizontal bounds\n          c, d; // y1, y2 vertical bounds\n        \n    for (O = O-O; i++ < 8.;) \n        // Reset bounds\n        a = c = -.5,\n        b = d = .5,\n\n        // Springy time (-.04*i is cool too)\n        t = .05 * i + .35 * iTime - .4,\n        v = fract(t),\n        t -= v + exp(-7.*v)*cos(23.*v) - 1.25*i,               \n        //t = -.5 * iTime,\n        \n        // New splits\n        h = .4 * cos(t),\n        v = .4 * sin(t),\n\n        // New bounds and id\n        u.x < h ? b = h, j+=.4\n                : a = h,    \n        u.y < v ? d = v, k+=.4\n                : c = v,\n\n        // Remap uv to new bounds\n        u = (u-vec2(a, c)) / vec2(b-a, d-c) - .5,\n              \n        // Rotate\n        u *= mat2(h, -v, v, h)/.4,\n        \n        O += .6 / exp((2.+i) * dot(u,u));\n            \n    // Color (O * palette -> gamma)\n    O = .71 * sqrt(O + O*cos(j+k+cos(vec4(1,2,3,0)*t)));\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlByDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 95, 95, 853]], "test": "untested"}
{"id": "clByDG", "name": "Neutron star", "author": "santiagolucero", "description": "the power of the logarithms", "tags": ["logsss"], "likes": 0, "viewed": 138, "published": 3, "date": "1692206456", "time_retrieved": "2024-07-30T17:38:56.306816", "image_code": "\nvec3 palette (float t) {\n    vec3 a= vec3(0.468, 0.388, 1.538);\n    vec3 b= vec3(-0.242, 0.118, 0.028);\n    vec3 c= vec3(1.408, 1.268, 2.518);\n    vec3 d= vec3(0.000, -3.132, 0.667);\n    \n    return a + b*cos(23.*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y*0.9;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i=0.0; i<2.;i++){\n\n        uv = fract(uv*2.4)- 0.5;\n\n        float d = length (uv)*log(length(uv0)*sin(iTime)+0.1);\n        vec3 col = palette(length(uv0)+iTime*0.1+ i*0.4);\n\n        d = (sin(d*8. + iTime))/8.;\n        d = abs(d);\n        d = pow(0.005 /d ,1.2);\n\n        finalColor += col * d;\n        \n        }\n    // Output to screen\n    \n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clByDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 225], [228, 228, 285, 285, 804]], "test": "untested"}
{"id": "DtByWy", "name": "inout SquaresCircles", "author": "janpitokiala", "description": "inout", "tags": ["circles", "squares"], "likes": 0, "viewed": 44, "published": 3, "date": "1692203308", "time_retrieved": "2024-07-30T17:38:57.172502", "image_code": "void DrawSquare(in vec2 uv,in vec3 color,in vec2 pos,in vec2 size,inout vec4 outcolor){\n    vec2 posn = -pos/iResolution.xy;\n    if(uv.x+posn.x>0.0 && uv.x+posn.x<size.x &&\n    uv.y+posn.y>0.0 && uv.y+posn.y<size.y)\n    {\n         outcolor=vec4(color,1);\n    } \n}\n\nvoid DrawCircle( in vec2 uv,in vec3 color, in vec2 pos, in float radius,inout vec4 outcolor){\n    vec2 posn = pos/iResolution.xy;  \n    float distanceToCenter = distance(uv, posn);\n    if(radius>distanceToCenter){\n       outcolor=vec4(color,1);\n    }\n}\n\nvoid car(in vec2 pos,in vec2 uv,out vec4 fragColor){\n DrawSquare(uv,vec3(0.5,1,0.5),pos+vec2(1,0),vec2(0.1,0.1),fragColor);\n DrawSquare(uv,vec3(0.5,1,0.5),pos+vec2(1,0),vec2(0.2,0.07),fragColor);\n DrawCircle(uv,vec3(1,1,1),pos,0.05,fragColor);\n DrawCircle(uv,vec3(1,1,1),pos+vec2(100,0),0.05,fragColor);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor=vec4(0,0,0,0);\n     //DrawSquare(uv,vec3(0.5,1,0.5),iMouse.xy,vec2(0.05,0.07),fragColor);\n     //DrawCircle(uv,vec3(1,1,1),iMouse.xy,0.05,fragColor);\n     car(iMouse.xy,uv,fragColor);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtByWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 87, 87, 263], [265, 265, 358, 358, 517], [519, 519, 571, 571, 825], [827, 827, 884, 884, 1124]], "test": "untested"}
{"id": "ctSyDG", "name": "Paz", "author": "santiagolucero", "description": "neon palette waves", "tags": ["waves"], "likes": 1, "viewed": 102, "published": 3, "date": "1692200723", "time_retrieved": "2024-07-30T17:38:57.992310", "image_code": "vec3 palette (float t) {\n    vec3 a= vec3(1.050, 0.938, 1.050);\n    vec3 b= vec3(0.808, 0.318, 0.408);\n    vec3 c= vec3(2.000, 2.000, 2.000);\n    vec3 d= vec3(-0.343, -0.523, 0.323);\n    \n    return a + b*cos(6.28318*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord *20.0 /iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for(float i = 0.0; i<4.0; i++){\n    \n        uv = fract(uv *1.5)- 10.00;\n        \n        float d = length(uv)*exp(-length(uv0));\n    \n        vec3 col = palette (length(uv0) + i*.4 + iTime+.4);\n        \n    \n        d = sin(d*8. + iTime)/10.;\n        d = abs(d);\n        d = (0.0002/d);\n \n        finalColor += col*d;\n     }\n     \n     \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 228], [231, 231, 288, 288, 816]], "test": "untested"}
{"id": "mt2cRd", "name": "Cave Train", "author": "dr2", "description": "Ride through a colossal cave (mouseable)", "tags": ["truchet", "cave", "train"], "likes": 24, "viewed": 264, "published": 3, "date": "1692198230", "time_retrieved": "2024-07-30T17:38:59.023553", "image_code": "// \"Cave Train\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat HexVertDist (vec2 p);\nfloat Ssign (float x);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN  17\n#define N_CAR 3\n\nvec4 cPath[PLEN], carPos[N_CAR];\nvec3 qHit, ltDir, ltPos, ltAx;\nvec2 cIdB, cMidB, wlBase;\nfloat dstFar, tCur, hgSizeB, tEnd[PLEN + 1], tLen, trVel, cDir, cType, trSzFac;\nint nFrame, idObj;\nconst int idCave = 1, idBase = 2, idRail = 3, idTie = 4, idSig = 5, idEng = 8, idCar = 9,\n   idRf = 10, idWhl = 11, idAxle = 12, idCrod = 13, idFun = 14, idCpl = 15, idLamp = 16;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat EngDf (vec3 p, float dMin)\n{  // (from \"Truchet's Train\")\n  vec3 q;\n  float wRad, d, aw, sx, tw;\n  tw = wlBase.x;\n  wRad = 0.8;\n  q = p;\n  d = max (max (PrBoxDf (vec3 (q.xy, q.z + 1.75), vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (vec3 (q.xy, q.z + 1.95), vec3 (0.95, 1.3, 0.65))),\n     - PrBox2Df (q.yz - vec2 (0.7, -1.75), vec2 (0.5, 0.4)));\n  d = min (d, max (PrCapsDf (q - vec3 (0., -0.2, 0.5), 1., 2.), - (q.z + 1.2)));\n  d = min (min (min (min (d, PrBoxDf (q - vec3 (0., -0.5, -3.15), vec3 (1., 0.7, 0.3))),\n     PrBoxDf (q - vec3 (0., -1.3, -0.25), vec3 (1., 0.1, 3.2))),\n     PrBoxDf (q - vec3 (0., -1.4, 3.), vec3 (1.1, 0.2, 0.07))),\n     PrCylDf (vec3 (abs (q.x) - 0.6, q.y + 1.4, q.z - 3.1), 0.2, 0.1));\n  DMINQ (idEng);\n  d = max (PrCylDf (q - vec3 (0., -2.35, -1.77), 4., 0.7), max (1.4 - q.y, abs (q.x) - 1.35));\n  DMINQ (idRf);\n  d = PrCylDf ((q - vec3 (0., -1.4, -3.5)).xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  d = min (PrCylDf ((q - vec3 (0., 1.1, 2.)).xzy, 0.3, 0.5),\n     PrCylDf ((q - vec3 (0., 1.5, 2.)).xzy, 0.4, 0.15));\n  d = min (d, PrCapsDf ((q - vec3 (0., 0.8, 0.5)).xzy, 0.3, 0.2));\n  DMINQ (idFun);\n  q = p;\n  q.yz -= vec2 (-0.2, 3.5);\n  d = PrCylDf (q, 0.25, 0.2);\n  DMINQ (idLamp);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (tw - 0.12, -1.4, wlBase.y);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1), PrCylDf (q.zyx - vec3 (0.,0., -0.07),\n     wRad + 0.05, 0.03)), - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (tw - 0.17, -1.4, sign (q.z * wlBase.y));\n  aw = - trVel * tCur / (wRad * trSzFac);\n  q.yz = Rot2D (q.yz, aw);\n  q.yz = Rot2D (q.yz, 2. * pi * floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.);\n  q.z -= -0.5 * wRad;\n  d = min (d, PrCylDf (q, 0.05, 0.5 * wRad));\n  DMINQ (idWhl);\n  q = p;\n  sx = sign (q.x);\n  q.x = abs (q.x);\n  q.xy -= vec2 (tw + 0.08, -1.4);\n  aw -= 0.5 * pi * sx;\n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);\n  q.xz -= vec2 (-0.1, wlBase.y);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  DMINQ (idCrod);\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0., -1.4, wlBase.y);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, tw;\n  wRad = 0.35;\n  tw = wlBase.x;\n  q = p;\n  d = PrBoxDf (q, vec3 (1.3, 1.4, 2.8));\n  DMINQ (idCar);\n  d = max (PrCylDf (vec3 (q.x, q.y + 2.35, q.z), 4., 2.85), max (1.4 - q.y, abs (q.x) - 1.35));\n  DMINQ (idRf);\n  q = p;\n  q.z = abs (q.z);\n  q.yz -= vec2 (-1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (tw - 0.1, -1.85, wlBase.y);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1), PrCylDf (q.zyx - vec3 (0.,0., -0.07),\n     wRad + 0.05, 0.03)), PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - PrCylDf (q.zyx, 0.2, 0.05));\n  DMINQ (idWhl);\n  q = p;\n  q.z = abs (q.z);\n  q.yz -= vec2 (-1.85, wlBase.y);\n  d = PrCylDf (q.zyx, 0.05, tw);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar / trSzFac;\n  q = (p - carPos[0].xyz) / trSzFac;\n  q.xz = Rot2D (q.xz, carPos[0].w);\n  dMin = EngDf (q, dMin);\n  for (int k = VAR_ZERO + 1; k < N_CAR; k ++) {\n    q = (p - carPos[k].xyz) / trSzFac;\n    q.xz = Rot2D (q.xz, carPos[k].w);\n    dMin = CarDf (q, dMin);\n  }\n  return dMin * trSzFac;\n}\n\nvec4 TrnCol ()\n{\n  vec4 col4, carCol, carCol2;\n  carCol = vec4 (0.8, 0.2, 0.2, 0.2);\n  carCol2 = vec4 (0.2, 1., 0.2, 0.2);\n  if (idObj == idEng || idObj == idCar) {\n    col4 = mix (carCol2, carCol, smoothstep (0., 0.05, abs (abs (qHit.y + 0.25) - 0.1) - 0.02)) *\n       (0.5 + 0.5 * step (-1.15, qHit.y));\n  }\n  if (idObj == idEng) {\n    if (min (max (abs (abs (qHit.x) - 0.5) - 0.4, abs (qHit.y - 1.1) - 0.2),\n       max (abs (abs (qHit.z - 1.) - 1.5) - 0.1,  - qHit.y - 1.1)) < 0.)\n       col4 = vec4 (0.2, 0.2, 0.4, -1.);\n    if (qHit.z > 3.1 && qHit.y < -1.) col4 = carCol;\n    if (qHit.z < -2.8 && qHit.y > 0.1) col4 = vec4 (vec3 (0.01), 0.);\n  } else if (idObj == idCar) {\n    if (min (max (abs (abs (qHit.z) - 1.25) - 1., abs (qHit.y - 0.6) - 0.5),\n       length (vec2 (qHit.xy - vec2 (0., 0.6))) - 0.4) < 0.) col4 = vec4 (0.2, 0.2, 0.4, -1.);\n  } else if (idObj == idRf) {\n    col4 = carCol2;\n    if (length (qHit.xy - vec2 (0., -2.35)) > 3.97)\n       col4 *= (0.8 + 0.2 * smoothstep (0., 0.05, abs (fract (4. * qHit.x + 0.5) - 0.5)));\n  } else if (idObj == idFun) {\n    col4 = ((qHit.y > 1.35) ? carCol : carCol2) * (0.5 + 0.5 * step (0.25,\n       length (vec2 (qHit.xz - vec2 (0., 2.)))));\n  } else if (idObj == idAxle) {\n    col4 = vec4 (0.3, 0.3, 0.35, 0.);\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.6, 0.6, 0.7, 0.1);\n  } else if (idObj == idCpl) {\n    col4 = vec4 (0.3, 0.3, 0.3, 0.);\n  } else if (idObj == idCrod) {\n    col4 = vec4 (0.7, 0.7, 0.1, 0.1);\n  } else if (idObj == idLamp) {\n    col4 = (length (qHit.xy) < 0.18) ? vec4 (0.8, 0.8, 0.8, -1.) : carCol;\n  }\n  return col4;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{ // (from \"Forest Train Ride\")\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * Ssign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * Ssign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * Ssign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = Ssign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. ||\n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= Ssign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - Ssign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nfloat Ddot (vec3 p)\n{\n  return dot (p, p);\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, a;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (4.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        a.z = Ddot (vec3 (gx, gy, gz) + 0.9 * Hashv3v3 (ip + vec3 (gx, gy, gz)) - fp);\n        if (a.z < a.x) a.xy = a.zx;\n        else a.y = min (a.z, a.y);\n      }\n    }\n  }\n  return sqrt (a.y - a.x);\n}\n\nfloat BObjDf (vec3 p)\n{ // (cave from \"Rainbow Cavern\")\n  vec3 q, cm3;\n  vec2 w, ws;\n  float dMin, d, dt, dh, rc, ac, th;\n  bool onTrk;\n  dMin = dstFar;\n  q = p;\n  w = (q.xz - cMidB) / hgSizeB;\n  dh = hgSizeB * HexEdgeDist (w);\n  cm3 = TruchSDist (w);\n  dt = hgSizeB * abs (cm3.x);\n  rc = abs (cm3.y);\n  ac = 18. * cm3.z;\n  onTrk = (cType <= 2. && rc != 0. && OnTrk (w));\n  q += 0.1 * (1. - cos (2. * pi * (q + 0.2 * (1. - cos (2. * pi * q.zxy)))));\n  q.y -= 0.35;\n  d = length (cos (0.6 * q - 0.5 * sin (1.4 * q.zxy + 0.4 * cos (2.7 * q.yzx)))) - 1.2;\n  th = SmoothMin (length (vec2 (dt, max (q.y, 0.2))) - 0.5, length (vec2 (dh, max (q.y, 0.2))) - 0.4, 0.1);\n  d = SmoothMin (SmoothMax (d, - th, 0.1), p.y, 0.1);\n  if (d < 0.1) d -= ((p.y < 0.05) ? 0.04 : mix (0.015, 0.05, smoothstep (0., 0.05, th))) * VPoly (4. * p);\n  d *= 0.6;\n  DMIN (idCave);\n  if (onTrk) {\n    q = p;\n    q.y -= 0.05;\n    ws = vec2 (0.005, 0.01);\n    d = max (abs (dt) - wlBase.x * trSzFac - 0.04, q.y);\n    DMIN (idBase);\n    d = PrRoundBox2Df (vec2 (dt - wlBase.x * trSzFac + ws.x, q.y - ws.y), ws, 0.003);\n    DMIN (idRail);\n    d = PrRoundBoxDf (vec3 (dt - wlBase.x * trSzFac + ws.x, q.y,\n         (fract (18. * rc * ac + 0.5) - 0.5) / 3.), vec3 (0.015, 0.005, 0.002), 0.001);\n    DMIN (idTie);\n    if (cm3.y < 0.) {\n      q = vec3 (dt -  wlBase.x * trSzFac - 0.03, q.y, dh);\n      d = PrCapsDf (q.xzy, 0.012, 0.04);\n      DMINQ (idSig);\n    }\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeB;\n  dHit = 0.;\n  cIdB = PixToHex (ro.xz / hgSizeB);\n  pM = HexToPix (cIdB);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      BConf ();\n      cNu = false;\n    }\n    d = BObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdB = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeB);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{ // (based on \"Trapped Light\")\n  vec3 q;\n  float d;\n  q = p - carPos[0].xyz;\n  q.xz = Rot2D (q.xz, carPos[0].w);\n  q.yz -= vec2 (-0.2, 3.5) * trSzFac;\n  q.z += 0.1;\n  d = PrConCylDf (q, sin (-0.08 * pi + vec2 (0.5 * pi, 0.)), 0.01, dstFar);\n  return d;\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnn, ltVec, ltDirL, ltAxL, roo, cm3, glit;\n  vec2 vf;\n  float dstObj, dstObjB, dstTrObj, s, att, nDotL, sh;\n  int idObjB;\n  vf = vec2 (0.);\n  roo = ro;\n  dstObjB = BObjRay (ro, rd);\n  idObjB = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObjB < dstObj) {\n    dstObj = dstObjB;\n    idObj = idObjB;\n  }\n  col = vec3 (0.01);\n  vf = vec2 (0.);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (dstObj == dstObjB) {\n      vn = BObjNf (ro);\n    } else {\n      vn = ObjNf (ro);\n    }\n    if (idObj >= idEng && idObj <= idLamp) {\n      col4 = TrnCol ();\n    } else {\n      cm3 = TruchSDist ((ro.xz - cMidB) / hgSizeB);\n      if (idObj == idCave) {\n        col4 = vec4 (0.5, 0.5, 0.6, 0.) * (0.6 + 0.4 * Fbm2 (4. * ro.xz));\n        vf = vec2 (32., 4.);\n      } else if (idObj == idBase) {\n        if (step (0.45, abs (fract (324. * abs (cm3.y) * abs (cm3.z)) - 0.5)) > 0.) {\n          col4 = vec4 (0.5, 0.5, 0.6, 0.);\n        } else {\n          col4 = vec4 (0.3, 0.2, 0.1, 0.) * (0.6 + 0.4 * Fbm2 (4. * ro.xz));\n          vf = vec2 (128., 0.5);\n        }\n      } else if (idObj == idRail) {\n        col4 = vec4 (0.7, 0.7, 0.8, 0.05);\n      } else if (idObj == idTie) {\n        col4 = vec4 (0.6, 0.6, 0.6, 0.);\n      } else if (idObj == idSig) {\n        col4 = (qHit.y > 0.02) ? vec4 (0., 0.8, 0., -1.) : vec4 (0.4, 0.4, 0.5, 0.);\n      }\n    }\n    vnn = vn;\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (idObj == idCave) {\n        ltVec = roo + ltPos - ro;\n        s = length (ltVec);\n        ltDirL = ltVec / s;\n        att = smoothstep (0.75, 0.9, dot (ltAx, - ltDirL)) / (1. + 0.015 * s * s);\n        glit = vec3 (1., 1., 0.) * pow (max (dot (reflect (rd, vn), ltDirL), 0.), 256.);\n      } else {\n        ltDirL = ltDir;\n        s = dstObj / hgSizeB;\n        att = 1. / (1. + 0.1 * s * s);\n        glit = vec3 (0.);\n      }\n      nDotL = max (dot (vn, ltDirL), 0.);\n      if (idObj >= idEng && idObj <= idRf) nDotL *= nDotL;\n      sh = (idObj != idCave) ? ObjSShadow (ro + 0.01 * vn, ltDirL) : 1.;\n      col = att * (col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         step (0.95, sh) * (col4.a * pow (max (dot (reflect (rd, vn), ltDirL), 0.), 32.) + glit));\n      if (! (idObj >= idEng && idObj <= idLamp)) {\n        ltAxL = vec3 (0., 0., 1.);\n        ltAxL.xz = Rot2D (ltAxL.xz, - carPos[0].w);\n        ltVec = carPos[0].xyz - ro;\n        ltVec.yz -= vec2 (-0.2, 3.5) * trSzFac;\n        s = length (ltVec);\n        ltDirL = ltVec / s;\n        col = mix (col, 0.8 * vec3 (1., 1., 0.95) * sh * (0.6 + 0.4 * nDotL),\n           0.3 * smoothstep (0.85, 0.95, - dot (ltAxL, ltDirL)) *\n           step (0., dot (vnn, ltDirL)) / (1. + 0.1 * s * s));\n      }\n    } else {\n      col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    }\n  }\n  ro = roo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    s = length (ro - carPos[0].xyz);\n    att = 1. / (1. + 0.2 * s * s);\n    col = mix (col, vec3 (1., 1., 0.95), max (- dot (vn, rd), 0.) *\n       att * (1. - smoothstep (-0.15, -0.05, dstTrObj - dstObj)));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, pc[3];\n  float el, az, zmFac, asp, sr, t, cGap;\n  int vuId, regId;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 3600.) + 30. * floor (dateCur.w / 3600.) + 20.;\n  asp = canvas.x / canvas.y;\n  mSize = (1./5.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  hgSizeB = 8.;\n  SetPath ();\n  trVel = 0.5;\n  trSzFac = 0.1;\n  cGap = 2.3 * trSzFac;\n  wlBase = vec2 (1.3, 1.1);\n  az = 0.;\n  el = -0.02 * pi;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  for (int k = VAR_ZERO; k < N_CAR; k ++) {\n    t = tCur * trVel + 2. - (float (k) + ((k > 0) ? 0.05 : 0.)) * cGap;\n    for (int j = VAR_ZERO; j < 3; j ++)\n       pc[j] = EvalPPos (t + ((j > 0) ? sign (float (j) - 1.5) * wlBase.y * trSzFac : 0.));\n    carPos[k].xz = pc[0];\n    carPos[k].y = 0.06 + 2.4 * trSzFac;\n    vd.xy = pc[2] - pc[1];\n    carPos[k].w = 0.5 * pi - atan (vd.y, vd.x);\n  }\n  t = tCur * trVel;\n  if (vuId <= 1 && length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01,\n     fract (tCur / 60.))) vuId = 1 - vuId;\n  if (vuId <= 1) {\n    ro.xz = EvalPPos (t + ((vuId == 0 ? 0.5 : float (N_CAR) - 0.2)));\n    ro.x += 0.01;\n    ro.y = 0.45;\n    vd = normalize (vec3 (carPos[((vuId == 0) ? N_CAR - 1 : 0)].xz, ro.y).xzy - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += asin (vd.y) + 0.03 * pi;\n    el = clamp (el, -0.5 * pi, 0.5 * pi);\n    zmFac = 2.8;\n    dstFar = 8. * hgSizeB;\n  }\n  vuMat = StdVuMat (el, az);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  ltPos = vuMat * vec3 (0., 0.5, -0.5);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCylDf (vec3 p, vec2 cs, float r, float h)\n{\n  return max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat HexVertDist (vec2 p)\n{\n  p = abs (p);\n  return min (length (vec2 (p.x - (sqrt3/2.), p.y - 0.5)), length (vec2 (p.x, p.y - 1.)));\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2cRd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1730, 1730, 1764, 1793, 3945], [3947, 3947, 3981, 3981, 4745], [4747, 4747, 4769, 4769, 5103], [5105, 5105, 5121, 5121, 6709], [6711, 6711, 6744, 6744, 6927], [6929, 6929, 6950, 6950, 7205], [7207, 7207, 7244, 7244, 7487], [7489, 7489, 7510, 7510, 7533], [7535, 7535, 7561, 7591, 8579], [8581, 8581, 8602, 8602, 9248], [9250, 9250, 9267, 9267, 10112], [10114, 10114, 10139, 10139, 10793], [10795, 10795, 10810, 10810, 11519], [11521, 11521, 11542, 11542, 11565], [11567, 11567, 11589, 11589, 11997], [11999, 11999, 12022, 12054, 13443], [13445, 13445, 13479, 13479, 14648], [14650, 14650, 14672, 14672, 14930], [14932, 14932, 14956, 14986, 15210], [15212, 15212, 15247, 15247, 15431], [15433, 15433, 15456, 15456, 15713], [15715, 15715, 15750, 15750, 18929], [22149, 22149, 22181, 22181, 22281], [22283, 22283, 22329, 22329, 22376], [22378, 22378, 22411, 22411, 22500], [22502, 22502, 22549, 22549, 22596], [22598, 22598, 22640, 22640, 22691], [22693, 22693, 22736, 22736, 22800], [22802, 22802, 22856, 22856, 22929], [22931, 22931, 22955, 22955, 23185], [23187, 23187, 23211, 23211, 23271], [23273, 23273, 23301, 23301, 23381], [23383, 23383, 23411, 23411, 23519], [23521, 23521, 23544, 23544, 23582], [23584, 23584, 23606, 23606, 23633], [23635, 23635, 23657, 23657, 23684], [23686, 23686, 23708, 23708, 23746], [23748, 23748, 23770, 23770, 23808], [23810, 23810, 23855, 23855, 23947], [23949, 23949, 23994, 23994, 24032], [24034, 24034, 24091, 24091, 24174], [24176, 24176, 24212, 24212, 24418], [24420, 24420, 24450, 24450, 24563], [24565, 24565, 24596, 24596, 24660], [24694, 24694, 24718, 24718, 24778], [24780, 24780, 24804, 24804, 24916], [24918, 24918, 24942, 24942, 25060], [25062, 25062, 25087, 25087, 25271], [25273, 25273, 25294, 25294, 25449], [25451, 25451, 25480, 25480, 25692], [25694, 25694, 25733, 25733, 25985]], "test": "untested"}
{"id": "mljczt", "name": "the radiant gradient", "author": "coreythuro", "description": "/", "tags": ["warp"], "likes": 1, "viewed": 105, "published": 3, "date": "1692195814", "time_retrieved": "2024-07-30T17:38:59.918161", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*sin( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord / exp2(-1.) - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 3.40; i++) {\n        uv = fract(uv / sin(iTime)) * tan(iTime);\n\n        float d = length(uv) * exp(length(uv0));\n\n        vec3 col = palette(length(uv0) + i/4.4 + iTime/0.4);\n\n        d = sin(d*8. + iTime)/8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    vec2 offsetUV2 = uv0 - vec2(sin(119.), sin(-110.1)); // Adjust the offset amount for the second layer\n    vec3 secondLayerColor = vec3(0.0);\n\n    for (float i = 0.0; i < 3.40; i++) {\n        offsetUV2 = fract(uv * cos((iTime))) / sin((-iTime));\n\n        float d = length(offsetUV2) * exp(length(uv0));\n\n        vec3 col = palette(length(uv0) + i/4.4 + iTime/0.4 / 0.2); // Adjust the time offset for the second layer\n\n        d = sin(d*8. + iTime)/8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        secondLayerColor += col * d;\n    }\n\n    vec2 offsetUV3 = uv0 + vec2(110.1, 110.1); // Adjust the offset amount for the third layer\n    vec3 thirdLayerColor = vec3(0.0);\n\n    for (float i = 0.0; i < 3.40; i++) {\n        offsetUV3 = fract(offsetUV2 / cos(iTime)) / cos(iTime);\n\n        float d = length(offsetUV3) * exp(length(uv0));\n\n        vec3 col = palette(length(uv0) + i/4.4 / iTime/0.4 + 0.3); // Adjust the time offset for the third layer\n\n        d = sin(d*8. + iTime)/8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        thirdLayerColor += col * d;\n    }\n\n    vec2 offsetUV4 = uv0 + vec2(-110.05, -110.0); // Adjust the offset amount for the fourth layer\n    vec3 fourthLayerColor = vec3(0.0);\n\n    for (float i = 0.0; i < 3.40; i++) {\n        offsetUV4 = fract(offsetUV4 / sin(iTime)) * tan(iTime);\n\n        float d = length(offsetUV4) * exp(length(uv0));\n\n        vec3 col = palette(length(uv0) + i*4.4 + iTime*0.4 + 0.4); // Adjust the time offset for the fourth layer\n\n        d = sin(d*8. + iTime)/8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        fourthLayerColor += col * d;\n    }\n\n    // Combine the four layers with appropriate blending\n    vec3 blendedColor = (finalColor + secondLayerColor + thirdLayerColor + fourthLayerColor) / 4.0;\n    fragColor = vec4(blendedColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 209], [211, 211, 268, 268, 2572]], "test": "untested"}
{"id": "cljczd", "name": "Mod of 01000001's FXAA Shader", "author": "beans_please", "description": "Original shader: https://www.shadertoy.com/view/mljyzc", "tags": ["fxaa"], "likes": 1, "viewed": 92, "published": 3, "date": "1692189706", "time_retrieved": "2024-07-30T17:39:00.713036", "image_code": "float get_luminance(vec3 col)\n{\n    return dot(col, vec3(.3, .58, .12));\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 r = iResolution.xy;\n    \n    // Find the normal\n    vec2 normal = vec2(0);\n    {\n        float next_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(1, 0), 0).xyz);\n        float prev_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(-1, 0), 0).xyz);\n        normal.x = (prev_lum - next_lum) / 2.;\n    }\n    {\n        float next_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(0, 1), 0).xyz);\n        float prev_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(0, -1), 0).xyz);\n        normal.y = (prev_lum - next_lum) / 2.;\n    }\n    \n    // Tangent\n    vec2 tangent = normal * mat2(0, 1, -1, 0);\n    \n    // Directional blur along the tangent\n    const int num_samples = 20;\n    const float len = 10.;\n    vec3 col = vec3(0);\n    float sum_weights = 0.;\n    for (int i = 0; i < num_samples; i++)\n    {\n        // 0 to 1\n        float t = float(i) / float(num_samples - 1);\n        \n        // -len/2 to len/2\n        float offs_along_tanget = len * (t - .5);\n        \n        // Target pixel's coordinates\n        vec2 target_coord = U + tangent * offs_along_tanget;\n        \n        // Weight of this sample\n        //float weight = 1. - abs(2. * t - 1.); // Tent\n        float weight = cos(3.14159265359 * (t - .5)); // Cosine\n        //float weight = 1.;\n        \n        // Update the sum of all weights\n        sum_weights += weight;\n        \n        col += weight * texture(iChannel0, target_coord / r).xyz;\n    }\n    col /= sum_weights;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    O = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 O, in vec2 U)\n{\n    vec2 uv = U / iResolution.y * (sin(iTime*.1) * .5 + .6);\n    \n    vec3 col = vec3(0.15, 1., 0.05);\n    \n    float a = length(mod(uv*10., vec2(2))-1.)>.8?0.:1.;\n    col *= a;\n    \n    O = vec4(col, 1.);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 74], [76, 76, 115, 115, 1690]], "test": "untested"}
{"id": "DtjcRd", "name": "Demodulation2023 round 2", "author": "z0rg", "description": "Second round of the shader battle for Demodulation2023 won the 2nd place\nConverted using https://github.com/TheNuSan/BonzomaticToShadertoy", "tags": ["shadershowdown", "demodulation"], "likes": 10, "viewed": 165, "published": 3, "date": "1692188122", "time_retrieved": "2024-07-30T17:39:01.640556", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Converted using NuSan's converter\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord.xy/iResolution.xy).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Converted using NuSan's converter\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\nfloat _seed = 0.0;\n\nfloat hash11(float seed)\n{\n    return fract(sin(seed * 123.456) * 123.456);\n}\n\nfloat rand()\n{\n    float _52 = _seed;\n    _seed = _52 + 1.0;\n    float param = _52;\n    return hash11(param);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize((rd + (r * uv.x)) + (u * uv.y));\n}\n\nmat2 r2d(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(vec2(c, -s), vec2(s, c));\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p) - s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat map(inout vec3 p)\n{\n    vec3 rep = vec3(7.0);\n    vec3 id = floor((p + (rep * 0.5)) / rep);\n    p = mod(p + (rep * 0.5), rep) - (rep * 0.5);\n    float param = iTime * sin(id.x);\n    vec3 _149 = p;\n    vec2 _151 = _149.xy * r2d(param);\n    p.x = _151.x;\n    p.y = _151.y;\n    float param_1 = (iTime * 1.73) * sin(id.y * 0.78);\n    vec3 _167 = p;\n    vec2 _169 = _167.yz * r2d(param_1);\n    p.y = _169.x;\n    p.z = _169.y;\n    vec3 param_2 = p;\n    vec3 param_3 = vec3(1.5);\n    float shape = _cube(param_2, param_3);\n    shape = max(shape, -(length(p.xy) - 1.0));\n    shape = max(shape, -(length(p.xz) - 1.0));\n    shape = max(shape, -(length(p.yz) - 1.0));\n    return shape;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    float _208 = rand();\n    float _209 = rand();\n    vec2 off = ((vec2(_208, _209) - vec2(0.5)) * 0.1) * 0.0;\n    vec3 ro = vec3(sin(iTime * 0.33) * 5.0, 5.0, -5.0);\n    vec3 _227 = ro;\n    vec2 _229 = _227.xy + (off * 1.5);\n    ro.x = _229.x;\n    ro.y = _229.y;\n    float param = floor(iTime);\n    float param_1 = floor(-iTime);\n    vec3 ta = vec3(5.0 * (hash11(param) - 0.5), 5.0 * (hash11(param_1) - 0.5), 0.0);\n    vec3 rd = normalize(ta - ro);\n    vec3 _257 = rd;\n    vec2 _259 = _257.xy - (off * 0.05);\n    rd.x = _259.x;\n    rd.y = _259.y;\n    vec3 param_2 = rd;\n    vec2 param_3 = uv;\n    rd = getCam(param_2, param_3);\n    vec3 p = ro;\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 param_4 = p;\n        float _287 = map(param_4);\n        float res = _287;\n        if (res < 0.01)\n        {\n            col = vec3(0.1);\n            vec3 rgb = vec3((sin(iTime + abs(uv.x * 5.0)) * 0.5) + 0.5, 0.5, (cos(iTime * 0.3) * 0.3) + 0.7);\n            col = (rgb * clamp(sin((length(p) * 100.0) + (iTime * 30.0)), 0.0, 1.0)) * 3.0;\n        }\n        p += (rd * res);\n    }\n    float d = distance(p, ro);\n    col = mix(col, vec3(0.5, 0.2, 0.9) * (1.0 - (abs(uv.y) * 3.0)), vec3(1.0 - exp((-d) * 0.05)));\n    return col;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = vec2(fragCoord.x / iResolution.xy.x, fragCoord.y / iResolution.xy.y);\n    uv -= vec2(0.5);\n    uv /= vec2(iResolution.xy.y / iResolution.xy.x, 1.0);\n    float pix = mix(0.001, 0.02, length(uv));\n    _seed = texture(iChannel2, uv).x + iTime;\n    vec2 m = vec2(0.0);\n    m.x = atan(uv.x / uv.y) / 3.14;\n    m.y = (1.0 / length(uv)) * 0.2;\n    float d = m.y;\n    float f = texture(iChannel0, vec2(abs(uv.x) - abs(uv.y), 0.)).x * 5.0;\n    vec3 col = (vec3((sin(iTime + abs(uv.x * 5.0)) * 0.5) + 0.5, 0.5, (cos(iTime * 0.3) * 0.3) + 0.7) * f) * clamp(length(uv) - 0.35, 0.0, 1.0);\n    vec2 param = uv;\n    vec3 _468 = rdr(param);\n    col += _468;\n    float _472 = rand();\n    float _473 = rand();\n    vec2 param_1 = uv + ((vec2(_472, _473) - vec2(0.5)) * 0.05);\n    vec3 _480 = rdr(param_1);\n    col += (pow(_480, vec3(4.0)) * 0.1);\n    // Commented the logo bit :p\n    //vec3 col2 = texture(texLogo, (vec2(1.0, -1.0) * uv) - vec2(0.5)).xyz;\n    //col2 += (col.yzx * 0.5);\n    //float ring = sin(length(uv) - (iTime * 2.0));\n    //col = mix(col, col2, vec3(clamp(ring * 100.0, 0.0, 1.0)));\n    col = mix(col, texture(iChannel1, ouv).xyz, vec3(0.5));\n    out_color = vec4(col, 1.0);\n}\n\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjcRd.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[488, 488, 545, 545, 646]], "test": "untested"}
{"id": "ctjyzd", "name": "Demodulation2023 round 1", "author": "z0rg", "description": "Second round of the shader battle for Demodulation2023 won the 3rd place and qualified me for the final here https://www.shadertoy.com/view/DtjcRd\nConverted using https://github.com/TheNuSan/BonzomaticToShadertoy", "tags": ["shadershowdown", "demodulation"], "likes": 6, "viewed": 157, "published": 3, "date": "1692188104", "time_retrieved": "2024-07-30T17:39:02.505244", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Converted using NuSan's converter\n// https://github.com/TheNuSan/BonzomaticToShadertoy\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x) + abs(v.y);\n}\n\nfloat hash11(float seed)\n{\n    return fract(sin(seed * 123.456) * 123.456);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize((rd + (r * uv.x)) + (u * uv.y));\n}\n\nmat2 r2d(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(vec2(c, -s), vec2(s, c));\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p) - s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat map(inout vec3 p)\n{\n    float pix = 0.05;\n    p = floor(p / vec3(pix)) * pix;\n    vec3 op = p;\n    float rep = 2.0;\n    float param = (p.z * 0.1) * sin(iTime);\n    vec3 _140 = p;\n    vec2 _142 = _140.xy * r2d(param);\n    p.x = _142.x;\n    p.y = _142.y;\n    p.z += (iTime+texture(iChannel0, vec2(0.0,0.)).x * 1.0);\n    p.z = mod(p.z + (rep * 0.5), rep) - (rep * 0.5);\n    float _174 = p.z;\n    vec3 _180 = p;\n    vec2 _182 = _180.xy * mix(0.5, 1.0, (sin(_174 * 2.0) * 0.5) + 0.5);\n    p.x = _182.x;\n    p.y = _182.y;\n    vec3 param_1 = p;\n    vec3 param_2 = vec3(1.0, 1.0, 0.1);\n    float shape = _cube(param_1, param_2);\n    vec3 param_3 = p;\n    vec3 param_4 = vec3(0.99, 0.99, 1.0);\n    shape = max(shape, -_cube(param_3, param_4));\n    float ground = ((-op.y) + 5.0) - (texture(iChannel3, (op.xz * 0.01) + vec2(0.0, iTime * 0.03)).x * 10.0);\n    shape = min(shape, ground);\n    return shape;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    float param = floor(iTime);\n    float param_1 = floor(-iTime);\n    vec3 ro = vec3((hash11(param) - 0.5) * 5.0, (hash11(param_1) - 0.5) * 3.0, -5.0);\n    vec3 ta = vec3(0.0);\n    vec3 rd = normalize(ta - ro);\n    vec3 param_2 = rd;\n    vec2 param_3 = uv;\n    rd = getCam(param_2, param_3);\n    vec2 param_4 = uv;\n    col = vec3(1.0, 0.0, 0.2) * (1.0 - clamp(lenny(param_4), 0.0, 1.0));\n    vec3 p = ro;\n    vec3 accCol = vec3(0.0);\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 param_5 = p;\n        float _297 = map(param_5);\n        float res = _297;\n        if (res < 0.01)\n        {\n            col = vec3(0.1);\n            if (p.y > 1.0)\n            {\n                vec3 rgb = mix(vec3(1.0, 0.0, 0.2), vec3(0.0), vec3(sin((p.y * 5.0) + iTime)));\n                col = (rgb * clamp(sin(p.y * 50.0) - 0.5, 0.0, 1.0)) * 2.0;\n            }\n        }\n        if (p.y < 1.0)\n        {\n            accCol += ((vec3((sin(p.z) * 0.2) + 0.8, 0.5, 1.0) * (1.0 - clamp(res / 0.5, 0.0, 1.0))) * 0.1);\n        }\n        p += (rd * res);\n    }\n    col += accCol;\n    col = pow(col, vec3(2.2));\n    return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n    vec2 off = (vec2(0.01, 0.0) * texture(iChannel0, vec2(0.2,0.)).x) * 1.0;\n    vec3 col = vec3(0.0);\n    vec2 param = uv + off;\n    col.x = rdr(param).x;\n    vec2 param_1 = uv;\n    col.y = rdr(param_1).y;\n    vec2 param_2 = uv - off;\n    col.z = rdr(param_2).z;\n    return col;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.xy.x, fragCoord.y / iResolution.xy.y);\n    uv -= vec2(0.5);\n    uv /= vec2(iResolution.xy.y / iResolution.xy.x, 1.0);\n    uv *= (2.0 - (length(uv) * 2.0));\n    vec2 m = vec2(0.0);\n    m.x = atan(uv.x / uv.y) / 3.14;\n    vec2 param = uv;\n    m.y = (1.0 / mix(lenny(param), length(uv), -1.0)) * 0.2;\n    float d = m.y;\n    float f = (texture(iChannel0, vec2(d, 0.)).x * 1.0) * 0.1;\n    vec3 col = vec3(1.0) * f;\n    vec2 param_1 = uv;\n    col += rdr2(param_1);\n    out_color = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctjyzd.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[488, 488, 509, 509, 543], [545, 545, 571, 571, 622], [624, 624, 655, 655, 805], [807, 807, 826, 826, 914], [916, 916, 945, 945, 1008], [1010, 1010, 1035, 1035, 1912], [1914, 1914, 1933, 1933, 3072], [3074, 3074, 3094, 3094, 3376], [3378, 3378, 3435, 3435, 3973]], "test": "untested"}
{"id": "mtByzd", "name": "Texture FeedBack", "author": "Blindman67", "description": "Total unreadable code mess. Just playing getting a feel of shadertoy.", "tags": ["feedback"], "likes": 1, "viewed": 121, "published": 3, "date": "1692172042", "time_retrieved": "2024-07-30T17:39:03.390876", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n  fragColor = vec4(col *col); \n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texture(iChannel0, uv)  * 2.0;\n    if (iFrame < WAIT_TO_START) {\n        col = texture(iChannel1, uv);\n    } else {\n        col -= texture(iChannel1, uv) * 5.4;\n    }\n    fragColor = col; \n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n      vec2 uv = fragCoord / iResolution.xy;\n      vec4 col1 = texture(iChannel0,uv);\n      float t = Time(iFrame);\n      float ang = (col1.x + col1.y + col1.z) * TAU * 0.3 + t * 0.3;\n      float len = (col1.x * col1.z * 10.0) / iResolution.x;\n      vec2 off1 = vec2(cos(ang), sin(ang)) * len;\n      vec4 col0 = texture(iChannel1,uv);\n      ang = (col0.x * col0.y * col0.z) * TAU * 30.3 + t * 0.13;\n      len = (col0.x * col0.z * 130.0) / iResolution.x;\n      vec2 off0 = vec2(cos(ang), sin(ang)) * len;\n      if (iFrame < WAIT_TO_START) {\n          fragColor  = texture(iChannel0, uv);// * (1.0 - iTime);\n      } else {\n          vec4 c1 = texture(iChannel1, uv + off1);\n          vec4 c2 = texture(iChannel2, uv + off0);\n          fragColor = pow((c1 * c1 + c2 * c2) * 0.5, vec4(0.5));\n      }      \n      \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n#define TAU (PI * 2.0)\n#define WAIT_TO_START 60\n\nconst float invTAU = 1.0 / TAU;\n\n\nvec2 points[4] = vec2[](\n    vec2(-100, 100),\n    vec2(100, 100),\n    vec2(100, -100),\n    vec2(-100, -100)\n);\nconst float inv_60 = 1.0 / 60.0;\nfloat Time(int f) { return float(f) * inv_60; }", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col1 = texture(iChannel0,uv);\n    float t = TAU * Time(iFrame) * (2.0 + uv.x + uv.y * 2.0);\n    vec2 px = vec2(cos(col1.x * t), sin(col1.y * t)) * 1.5 /  iResolution.xy;\n\n    vec4 col3 = texture(iChannel1,uv + px);\n    \n  if (iFrame < WAIT_TO_START) {\n      fragColor = col1;\n      } else {\n        vec3 dif2 = (vec3((col1.x - col3.x), (col1.y - col3.y), (col1.z - col3.z)));\n    fragColor = ( col1  - vec4(dif2 , 1.0) ) ;\n      \n      }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtByzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 151]], "test": "untested"}
{"id": "mlSyzd", "name": "Got It...", "author": "ordii", "description": "Yippiiiiii.........", "tags": ["firstraymarch"], "likes": 0, "viewed": 84, "published": 3, "date": "1692171642", "time_retrieved": "2024-07-30T17:39:04.231628", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\n\n\n\nfloat get_dist(vec3 pt){\n    float d_plane = pt.y;\n    vec4 sphere = vec4(0.,1.,6.,1.);\n    float d_sphere = length(sphere.xyz - pt) - sphere.w;\n    return min(d_sphere, d_plane);\n}\n\n\nfloat ray_march(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 pt = ro + dO*rd;\n        float dS = get_dist(pt);\n        dO += dS;\n        if (dS <= SURF_DIST || dO >= MAX_DIST) break;\n    }\n    return dO;\n\n}\nvec3 get_normal(vec3 pt){\n    vec2 e = vec2(0.01, 0.);\n    vec3 n = get_dist(pt) - vec3(get_dist(pt - e.xyy), get_dist(pt - e.yxy), get_dist(pt - e.yyx));\n    return normalize(n);\n\n\n}\nfloat get_light(vec3 pt){\n    vec3 lightPos = vec3(1.,6.,6.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lt_vec = normalize(lightPos - pt);\n    vec3 pt_nml = get_normal(pt);\n    float diff = clamp(dot(lt_vec, pt_nml), 0., 1.);\n    float sh = ray_march(pt+pt_nml*SURF_DIST*2., lt_vec);\n    if (sh < length(lightPos-(pt+pt_nml*SURF_DIST*2.))) diff *= 0.01;\n    return diff;\n }\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.x;\n    vec3 cam = vec3(0.,1.,0.);\n    vec3 camRay = normalize(vec3(uv, 1.));\n    float d = ray_march(cam, camRay);\n    vec3 pt = cam + d*camRay;\n    float diff = get_light(pt);\n    \n    \n    \n    \n    \n    \n    \n    \n\n    // Output to screen\n    //fragColor = vec4(vec3(diff),1.0);\n    fragColor = vec4(vec3(diff),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 95, 95, 252], [255, 255, 289, 289, 508], [509, 509, 534, 534, 692], [693, 693, 718, 718, 1085], [1090, 1090, 1147, 1197, 1577]], "test": "untested"}
{"id": "dtBczt", "name": "Inside the mandelbulb II KUSH", "author": "kushnadas", "description": "CC0: Inside the mandelbulb II x Kush,\n this has some changes \nvia XorDev and mrange", "tags": ["3d", "mandelbulb"], "likes": 9, "viewed": 245, "published": 3, "date": "1692159049", "time_retrieved": "2024-07-30T17:39:05.048445", "image_code": "// Fork of \"Inside the mandelbulb II\" by mrange. https://shadertoy.com/view/mtScRc\n// 2023-08-16 04:10:26\n\n// CC0: Inside the mandelbulb II\n//  Received some \"complaints\" about the old mandelbulb suffering from \n//  alias effects. So thought I make a quick try to apply the FXAA\n//  thing I learnt from XorDev. It did improve it but not perfect still.\n\n// When experimenting with this shader I realized this entire shader is \n// basically just a lucky bug (apart from the aliasing)\n\n#define RESOLUTION      iResolution\n\n// License: Unknowon, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.3))\n    + texture(tex, uv + dir * (0.3))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  \n  fragColor = fxaa(iChannel0, q, sqrt(2.0)/RESOLUTION.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// --\n#define LOOPS   5    // 4+ and higher to show off you expensive GPU\n#define POWER   8.0\n#define ANIMATE\n// --\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PHI             (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  5.0\n#define MAX_RAY_MARCHES 10\n#define NORM_OFF        0.005\n#define MAX_BOUNCES     5\n\nmat3 g_rot  = mat3(1.0); \nvec3 g_mat  = vec3(0.0);\nvec3 g_beer = vec3(0.0);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.0;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.6, 0.50, 1.0));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.065, 0.8, 6.0));\nconst vec3 diffuseCol = HSV2RGB(vec3(hoff+0.6, 0.85, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\n\nconst float initt       = 0.1; \n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: Unknown, author: EvilRyu, found: https://www.shadertoy.com/view/MdXSWn\nfloat mandelBulb(vec3 p) {\n\n  const float power = POWER;\n  vec3 z  = p;\n  vec3 dz = vec3(0.0);\n  float r, theta, phi;\n  float dr = 1.0;\n  \n  for(int i = 0; i < LOOPS; ++i) {\n    r = length(z);\n    if(r > 2.0) continue;\n    theta = atan(z.y, z.x);\n#ifdef ANIMATE\n    phi = asin(z.z / r) + TIME*0.2;\n#else\n    phi = asin(z.z / r);\n#endif\n    \n    dr = pow(r, power - 1.0) * dr * power + 1.0;\n  \n    r = pow(r, power);\n    theta = theta * power;\n    phi = phi * power;\n    \n    z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n  }\n  return 0.5 * log(r) * r / dr;\n}\n\n\n\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  vec3 p1 = p;\n  const float z1 = 2.0;\n  float d1 = mandelBulb(p1/z1)*z1;\n\n  vec3 mat = vec3(0.8, 0.5, (1.+0.05));\n  const vec3 gcol = HSV2RGB(vec3(0.05, 0.95, 2.0)); \n  vec3 beer = -gcol;\n\n  float d = d1;\n  \n  \n  g_mat = mat;\n  g_beer = beer;\n  return d;\n}\n\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = min(min(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    vec3 mat = g_mat;\n    vec3 beer = g_beer;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n//    fre = clamp(abs(fre), 0.0, 1.0);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    float re    = mat.z;\n    float ire   = 1.0/re;\n    vec3 refr   = refract(rd, sn, !isInside ? re : ire);\n    vec3 rsky   = skyColor(sp, ref);\n    vec3 col = vec3(0.0);    \n    col += diffuseCol*dif*dif*(1.0-mat.x);\n    float edge = smoothstep(1.0, 0.9, fre);\n    col += rsky*mat.y*fre*vec3(1.0)*edge;\n    if (isInside) {\n      ragg *= exp(-st*beer);\n    }\n    agg += ragg*col;\n\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      ragg *= mat.x;\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    // TODO: if beer is active should also computer it based on initt    \n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = rot_x(0.2*TIME)*rot_y(0.3*TIME);\n  vec3 ro = 0.6*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtBczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 599, 648, 747, 2790], [2792, 2792, 2849, 2849, 2949]], "test": "untested"}
{"id": "mlSczt", "name": "Aces Back To Back", "author": "kushnadas", "description": "Rose", "tags": ["rambleonrose"], "likes": 0, "viewed": 92, "published": 3, "date": "1692158986", "time_retrieved": "2024-07-30T17:39:06.085671", "image_code": "// CC0: Inside the mandelbulb II\n//  Received some \"complaints\" about the old mandelbulb suffering from \n//  alias effects. So thought I make a quick try to apply the FXAA\n//  thing I learnt from XorDev. It did improve it but not perfect still.\n\n// When experimenting with this shader I realized this entire shader is \n// basically just a lucky bug (apart from the aliasing)\n\n#define RESOLUTION      iResolution\n\n// License: Unknowon, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  \n  fragColor = fxaa(iChannel0, q, sqrt(2.0)/RESOLUTION.xy);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 492, 541, 640, 2683], [2685, 2685, 2742, 2742, 2842]], "test": "untested"}
{"id": "dlSczt", "name": "StarRotater", "author": "kushnadas", "description": "a star", "tags": ["stars"], "likes": 0, "viewed": 91, "published": 3, "date": "1692158622", "time_retrieved": "2024-07-30T17:39:06.942381", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 uResolution;\nuniform float uTime;\n\n// Function to draw a five-pointed star\nfloat star(vec2 st) {\n    st = st * 2.0 - 1.0;\n\n    // Convert to polar coordinates\n    float r = length(st);\n    float a = atan(st.y, st.x);\n\n    // Adjust angle for rotation over time\n    a -= iTime;\n\n    // Create star shape using modulo and scaling\n    float sector = mod(a, 3.14159/2.5) * 2.0 / 3.14159;\n    r = smoothstep(0.9, 0.41, r * (2.0 - sector));\n\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Create rotating color effect\n    vec3 color = 0.5 + 0.5 * cos(iTime + vec3(0.000,1.000,0.118));\n\n    // Use star function to mask the color\n    fragColor = vec4(color * star(uv), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 134, 155, 155, 510], [512, 512, 567, 567, 807]], "test": "untested"}
{"id": "dlScRt", "name": "AntiAlias checkerboard", "author": "Blindman67", "description": "Experimenting with shaders and shader toy. Very basic ray traced plane with checkerboard. Multi sample anti-aliasing and distance blending to reduce aliasing artifacts.", "tags": ["antialias"], "likes": 2, "viewed": 130, "published": 3, "date": "1692151616", "time_retrieved": "2024-07-30T17:39:07.842972", "image_code": "\nbool overBG = false;\n\n\nvec3 rayTrace(in Ray ray){\n    Ray pl = Ray(vec3(0,0,0), vec3(0,-1,0));\n    float dist = abs(plane(ray, pl));\n    if (dist < MAX_DIST) {\n        overBG = false;\n        vec3 p = floor((pl.origin + ray.dir * dist) * CHECKER_SIZE);        \n        vec3 col = vec3(0.2 + 0.4 * mod(p.x + p.z, 2.0));\n        if (dist > MAX_DIST - BLEND_DIST) {\n            float m = pow((dist - (MAX_DIST - BLEND_DIST)) / BLEND_DIST, BLEND_CURVE);\n            return mix(col, vec3((0.2 + 0.4) * 0.5), m);\n        }\n        return col;\n    }\n    overBG = true;\n    return BG_Color - max(0.95 * ray.dir.y, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 origin = vec3(1.0, -10.0, -10.0);\n    Ray ray = Ray(origin, vec3(0));\n    uint count = 0u;\n    vec3 col = vec3(0);\n    vec2 subPx = vec2(0);    \n    vec2 px = 1.0 / iResolution.xy;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;    \n    mat3 vmat = lookMouse(2.0 * iMouse.xy  / iResolution.xy);\n\n    for (subPx.y = 0.0; subPx.y < 1.0; subPx.y += AA_STEP) {\n        for (subPx.x = 0.0; subPx.x < 1.0; subPx.x += AA_STEP) {\n            ray.dir = normalize(vmat * vec3(uv + px * subPx, 2.0));\n            col += rayTrace(ray);   \n            if (count == 0u && overBG) {\n                fragColor = vec4(col, 1.0);\n                return;\n            }\n            count ++;\n        }\n    }\n  \n    fragColor = vec4(col * AA_SAMPLES, 1.0);\n}\n\n", "image_inputs": [], "common_code": "#define MAX_DIST 330.0\n#define MIN_DIST 0.01\n#define RAY_STEP_LEN 200.0\n#define MAX_STEPS 100\n#define ANTI_ALIAS 3.0\n#define BLEND_DIST 200.0\n#define CHECKER_SIZE 0.2\n#define BLEND_CURVE 0.75\n\nconst float INV_255 = 1.0 / 255.0;\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float AA_STEP = 1.0 / ANTI_ALIAS;\nconst float AA_SAMPLES = 1.0 / (ANTI_ALIAS * ANTI_ALIAS);\nconst vec3 BG_Color = vec3 (0.45, 0.76, 1.0);\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\nvec3 RGB2Color(float R, float G, float B) { return vec3(R * INV_255, G * INV_255, B * INV_255); }\nfloat plane(Ray ray, Ray plane){\n    float d = dot(plane.dir, ray.dir);\n    return d > MIN_DIST ? dot(plane.origin - ray.origin, plane.dir) / d : MAX_DIST;\n}\nmat3 camMatrix(in float yaw, in float pitch) {\n    vec3 forward = normalize(vec3(sin(yaw), sin(pitch), cos(yaw)) * cos(pitch));\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));   \n    return mat3(right, cross(forward, right), forward);\n}\nmat3 lookMouse(in vec2 unitMouse) {\n    return camMatrix((unitMouse.x * 1.0 + 0.0) * PI, (unitMouse.y * 0.5 + 0.5) * PI);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlScRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 50, 50, 614], [618, 618, 675, 675, 1440]], "test": "untested"}
{"id": "mtByRt", "name": "qr͏", "author": "01000001", "description": "Pixels are encoded in the bits of the integers. Each int in p stores one row of pixels. \n\nLinks to my portfolio website, best viewed on desktop (https://01000001-01101011.github.io/portfolio)", "tags": ["scan", "qr", "code"], "likes": 1, "viewed": 113, "published": 3, "date": "1692148129", "time_retrieved": "2024-07-30T17:39:08.808391", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 r = iResolution.xy;\n    float e = 10.5,s = e/r.y * 2.3;\n\n    U=(U-r*.5)*s;\n    //U *= mat2(cos(iTime/e + vec4(0,11,33,0))); // Spin :P\n\n    O = texelFetch(iChannel0, ivec2(U+e), 0);\n    r = abs(U);\n    if (max(r.x, r.y) > e) O-=O;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int p[] = int[](\n  2088831\n, 1067585\n, 1525341\n, 1527389\n, 1530973\n, 1071169\n, 2086271\n, 3840\n, 1070683\n, 12174\n, 1979752\n, 832033\n, 1680103\n, 854272\n, 201855\n, 280641\n, 597853\n, 419165\n, 1676381\n, 2058561\n, 18815\n);\n\nvoid mainImage( out vec4 O, vec2 U ){\n    O=iFrame<9?\n        vec4(p[int(U.y)]>>int(U.x)&1):\n        texture(iChannel0, U/iResolution.xy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtByRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 280]], "test": "untested"}
{"id": "clBczd", "name": "PaintPourOne", "author": "kushnadas", "description": "light clouds", "tags": ["paint"], "likes": 3, "viewed": 120, "published": 3, "date": "1692145832", "time_retrieved": "2024-07-30T17:39:09.610247", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// A simple hash function to create randomness, used to make a basic noise function\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\n// Basic noise function using random hashing\nfloat noise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(hash(n), hash(n + 1.0), f.x),\n               mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\nvec3 liquidLight(vec2 st) {\n    vec2 distortedCoords = st + 0.5 * vec2(noise(st + iTime), noise(st - iTime));\n    float timeFactor = iTime * 0.1;\n    \n    vec3 color = vec3(0.0);\n    \n    // Layer 1: Base flow\n    float baseNoise = noise(distortedCoords + timeFactor);\n    color += mix(vec3(0.216,1.000,0.000), vec3(0.565,0.000,0.639), baseNoise);\n    \n    // Layer 2: Fine details\n    float fineNoise = noise(distortedCoords * 3.69 + timeFactor);\n    color += mix(vec3(0.114,0.000,0.961), vec3(1.000,0.451,0.000), fineNoise) * 0.5;\n\n    // Layer 3: Medium disturbances\n    float medNoise = noise(distortedCoords * 2.69 + timeFactor);\n    color += mix(vec3(0.016,0.000,1.000), vec3(1.000,0.000,0.000), medNoise) * 0.75;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st * 2.0 - 1.0;  // Normalize to [-1, 1]\n    st.x *= iResolution.x / iResolution.y;  // Adjust for aspect ratio\n    \n    vec3 color = liquidLight(st);\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clBczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 130, 151, 151, 192], [194, 239, 260, 260, 485], [487, 487, 514, 514, 1231], [1233, 1233, 1290, 1290, 1534]], "test": "untested"}
{"id": "dlfcD8", "name": "Path Tracing name already in use", "author": "beans_please", "description": "Good old naive path tracing", "tags": ["3d", "raytracing", "lighting", "sphere", "pathtracing"], "likes": 7, "viewed": 244, "published": 3, "date": "1692139870", "time_retrieved": "2024-07-30T17:39:10.659442", "image_code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: Output\n  iChannel0: Buffer A\n  iChannel1: Buffer B\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Skip the bottom row of pixels (data row)\n    if (int(frag_coord.y) < 1)\n    {\n        frag_col = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    // Read the data from Buffer A\n    vec3 col = texelFetch(iChannel0, ivec2(frag_coord), 0).xyz;\n    \n    // flim\n    col = flim_transform(col, 4., iChannel1);\n    \n    // Output\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Pseudo-Random Number Generator\n// Source: https://www.shadertoy.com/view/WdSSRt\n// -----------------------------------------------\n\n/* Usage Example:\n    void mainImage(out vec4 frag_col, in vec2 frag_coord)\n    {\n        // Initialize PRNG\n        prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n        // Using the function\n        float a = random();\n        vec3 b = vec3(random(), random(), random());\n        \n        ...\n    }\n*/\n\nuint prng_state[2];\n\nuint prng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = prng_state[0];\n    uint s1 = prng_state[1];\n    uint result = prng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    prng_state[0] = prng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    prng_state[1] = prng_rot(s1, 13);\n    return float(result) / float(0xffffffffu);\n}\n\nvoid prng_init(vec3 seed)\n{\n    seed.xy *= (seed.z + 10.258);\n    seed += 3.49276101561702;\n    prng_state[0] = floatBitsToUint(seed.x);\n    prng_state[1] = floatBitsToUint(seed.y);\n    random();\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Additional Color Utils (most functions are in flim)\n// -----------------------------------------------\n\nconst vec3 lum_linear_bt709 = vec3(0.2126, 0.7152, 0.0722);\n\nfloat rgb_variance(vec3 a, vec3 b)\n{\n    a = max(a, 0.0);\n    b = max(b, 0.0);\n    \n    a += 0.001;\n    b += 0.001;\n    \n    float v = dot(abs(log2(a / b)), vec3(0.3, 0.59, 0.11));\n    return v*v;\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Keyboard Utils\n// -----------------------------------------------\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESC 27\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PRINT_SCREEN 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LWIN 91\n#define KEY_RWIN 92\n#define KEY_POPUP 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_ASTERISK 106 \n#define KEY_NUMPAD_PLUS 107\n#define KEY_NUMPAD_MINUS 109\n#define KEY_NUMPAD_PERIOD 110\n#define KEY_NUMPAD_SLASH 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_LSHIFT 160\n#define KEY_RSHIFT 161\n#define KEY_LCTRL 162\n#define KEY_RCTRL 163\n\nbool key_is_down(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool key_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool key_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return texelFetch(keyboard_channel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat fkey_is_down(int key, sampler2D keyboard_channel)\n{\n    return key_is_down(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_got_pressed(int key, sampler2D keyboard_channel)\n{\n    return key_got_pressed(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\nfloat fkey_toggle_state(int key, sampler2D keyboard_channel)\n{\n    return key_toggle_state(key, keyboard_channel) ? 1.0 : 0.0;\n}\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// Parameters\n\nconst float flim_pre_exposure = 4.3;\nconst vec3 flim_pre_formation_filter = vec3(1.0);\nconst float flim_pre_formation_filter_strength = 0.0;\n\nconst float flim_extended_gamut_red_scale = 1.05;\nconst float flim_extended_gamut_green_scale = 1.12;\nconst float flim_extended_gamut_blue_scale = 1.045;\nconst float flim_extended_gamut_red_rot = 0.5;\nconst float flim_extended_gamut_green_rot = 2.0;\nconst float flim_extended_gamut_blue_rot = 0.1;\nconst float flim_extended_gamut_red_mul = 1.0;\nconst float flim_extended_gamut_green_mul = 1.0;\nconst float flim_extended_gamut_blue_mul = 1.0;\n\nconst float flim_sigmoid_log2_min = -10.0;\nconst float flim_sigmoid_log2_max = 22.0;\nconst float flim_sigmoid_toe_x = 0.44;\nconst float flim_sigmoid_toe_y = 0.28;\nconst float flim_sigmoid_shoulder_x = 0.591;\nconst float flim_sigmoid_shoulder_y = 0.779;\n\nconst float flim_negative_film_exposure = 6.0;\nconst float flim_negative_film_density = 5.0;\n\nconst vec3 flim_print_backlight = vec3(1.0);\nconst float flim_print_film_exposure = 6.0;\nconst float flim_print_film_density = 27.5;\n\nconst float flim_black_point = -1.0; // -1 = auto\nconst vec3 flim_post_formation_filter = vec3(1.0);\nconst float flim_post_formation_filter_strength = 0.0;\nconst float flim_midtone_saturation = 1.02;\n\n// -------------------------------\n\nvec3 blender_rgb_to_hsv(vec3 rgb)\n{\n    float cmax, cmin, h, s, v, cdelta;\n    vec3 c;\n\n    cmax = max(rgb[0], max(rgb[1], rgb[2]));\n    cmin = min(rgb[0], min(rgb[1], rgb[2]));\n    cdelta = cmax - cmin;\n\n    v = cmax;\n    if (cmax != 0.0)\n    {\n        s = cdelta / cmax;\n    }\n    else\n    {\n        s = 0.0;\n        h = 0.0;\n    }\n\n    if (s == 0.0)\n    {\n        h = 0.0;\n    }\n    else\n    {\n        c = (vec3(cmax) - rgb.xyz) / cdelta;\n\n        if (rgb.x == cmax)\n        {\n            h = c[2] - c[1];\n        }\n        else if (rgb.y == cmax)\n        {\n            h = 2.0 + c[0] - c[2];\n        }\n        else\n        {\n            h = 4.0 + c[1] - c[0];\n        }\n\n        h /= 6.0;\n\n        if (h < 0.0)\n        {\n            h += 1.0;\n        }\n    }\n\n    return vec3(h, s, v);\n}\n\nvec3 blender_hsv_to_rgb(vec3 hsv)\n{\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n\n    if (s == 0.0)\n    {\n        rgb = vec3(v, v, v);\n    }\n    else\n    {\n        if (h == 1.0)\n        {\n            h = 0.0;\n        }\n\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.0 - s);\n        q = v * (1.0 - (s * f));\n        t = v * (1.0 - (s * (1.0 - f)));\n\n        if (i == 0.0)\n        {\n            rgb = vec3(v, t, p);\n        }\n        else if (i == 1.0)\n        {\n            rgb = vec3(q, v, p);\n        }\n        else if (i == 2.0)\n        {\n            rgb = vec3(p, v, t);\n        }\n        else if (i == 3.0)\n        {\n            rgb = vec3(p, q, v);\n        }\n        else if (i == 4.0)\n        {\n            rgb = vec3(t, p, v);\n        }\n        else\n        {\n            rgb = vec3(v, p, q);\n        }\n    }\n\n    return rgb;\n}\n\nvec3 blender_hue_sat(vec3 col, float hue, float sat, float value)\n{\n    vec3 hsv = blender_rgb_to_hsv(col);\n\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0.0, 1.0);\n    hsv[2] = hsv[2] * value;\n\n    return blender_hsv_to_rgb(hsv);\n}\n\nfloat rgb_avg(vec3 inp)\n{\n    return (inp.x + inp.y + inp.z) / 3.0;\n}\n\nfloat rgb_sum(vec3 inp)\n{\n    return inp.x + inp.y + inp.z;\n}\n\nfloat rgb_max(vec3 inp)\n{\n    return max(max(inp.x, inp.y), inp.z);\n}\n\nfloat rgb_min(vec3 inp)\n{\n    return min(min(inp.x, inp.y), inp.z);\n}\n\nvec3 rgb_uniform_offset(vec3 inp, float black_point, float white_point)\n{\n    float mono = rgb_avg(inp);\n    float mono2 = remap_clamp(mono, black_point / 1000.0, 1.0 - (white_point / 1000.0), 0.0, 1.0);\n    return inp * (mono2 / mono);\n}\n\nvec3 rgb_sweep(float hue)\n{\n    hue = wrap(hue * 360.0, 0.0, 360.0);\n\n    vec3 col = vec3(1, 0, 0);\n    col = mix(col, vec3(1, 1, 0), remap_clamp(hue, 0.0, 60.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 0), remap_clamp(hue, 60.0, 120.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 1, 1), remap_clamp(hue, 120.0, 180.0, 0.0, 1.0));\n    col = mix(col, vec3(0, 0, 1), remap_clamp(hue, 180.0, 240.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 1), remap_clamp(hue, 240.0, 300.0, 0.0, 1.0));\n    col = mix(col, vec3(1, 0, 0), remap_clamp(hue, 300.0, 360.0, 0.0, 1.0));\n    \n    return col;\n}\n\n// -------------------------------\n\nvec3 flim_rgb_sweep(vec2 uv0to1)\n{\n    float hue = 1.0 - uv0to1.y;\n    float exposure = remap(uv0to1.x, 0.0, 1.0, -5.0, 10.0);\n    return rgb_sweep(hue) * pow(2.0, exposure);\n}\n\n// https://www.desmos.com/calculator/khkztixyeu\nfloat flim_super_sigmoid(float inp, float toe_x, float toe_y, float shoulder_x, float shoulder_y)\n{\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n    toe_x = clamp(toe_x, 0.0, 1.0);\n    toe_y = clamp(toe_y, 0.0, 1.0);\n    shoulder_x = clamp(shoulder_x, 0.0, 1.0);\n    shoulder_y = clamp(shoulder_y, 0.0, 1.0);\n\n    // Calculate straight line slope\n    float slope = (shoulder_y - toe_y) / (shoulder_x - toe_x);\n\n    // Toe\n    if (inp < toe_x)\n    {\n        float toe_pow = slope * toe_x / toe_y;\n        return toe_y * pow(inp / toe_x, toe_pow);\n    }\n\n    // Straight line\n    if (inp < shoulder_x)\n    {\n        float intercept = toe_y - (slope * toe_x);\n        return slope * inp + intercept;\n    }\n\n    // Shoulder\n    float shoulder_pow = -slope / (((shoulder_x - 1.0) / pow(1.0 - shoulder_x, 2.0)) * (1.0 - shoulder_y));\n    return (1.0 - pow(1.0 - (inp - shoulder_x) / (1.0 - shoulder_x), shoulder_pow)) * (1.0 - shoulder_y) + shoulder_y;\n}\n\nfloat flim_dye_mix_factor(float mono, float max_density)\n{\n    // log2 and map range\n    float offset = pow(2.0, flim_sigmoid_log2_min);\n    float fac = remap_clamp(log2(mono + offset), flim_sigmoid_log2_min, flim_sigmoid_log2_max, 0.0, 1.0);\n\n    // Calculate amount of exposure from 0 to 1\n    fac = flim_super_sigmoid(fac, flim_sigmoid_toe_x, flim_sigmoid_toe_y, flim_sigmoid_shoulder_x, flim_sigmoid_shoulder_y);\n\n    // Calculate dye density\n    fac *= max_density;\n\n    // Mix factor\n    fac = pow(2.0, -fac);\n\n    // Clip and return\n    return clamp(fac, 0.0, 1.0);\n}\n\nvec3 flim_rgb_color_layer(vec3 inp, vec3 sensitivity_tone, vec3 dye_tone, float max_density)\n{\n    // Normalize\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n\n    // Dye mix factor\n    float mono = dot(inp, sensitivity_tone_norm);\n    float mixFac = flim_dye_mix_factor(mono, max_density);\n\n    // Dye mixing\n    return lerp(dye_tone_norm, vec3(1.0), mixFac);\n}\n\nvec3 flim_rgb_develop(vec3 inp, float exposure, float max_density)\n{\n    // Exposure\n    inp *= pow(2.0, exposure);\n\n    // Blue-sensitive layer\n    vec3 result = flim_rgb_color_layer(inp, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n\n    // Green-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n\n    // Red-sensitive layer\n    result *= flim_rgb_color_layer(inp, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n\n    return result;\n}\n\nvec3 flim_gamut_extension_mat_row(float primary_hue, float scale, float rotate, float mul)\n{\n    vec3 result = blender_hsv_to_rgb(vec3(wrap(primary_hue + (rotate / 360.0), 0.0, 1.0), 1.0 / scale, 1.0));\n    result /= rgb_sum(result);\n    result *= mul;\n    return result;\n}\n\nmat3 flim_gamut_extension_mat(\n    float red_scale,\n    float green_scale,\n    float blue_scale,\n    float red_rot,\n    float green_rot,\n    float blue_rot,\n    float red_mul,\n    float green_mul,\n    float blue_mul\n)\n{\n    mat3 m;\n    m[0] = flim_gamut_extension_mat_row(0.0, red_scale, red_rot, red_mul);\n    m[1] = flim_gamut_extension_mat_row(1.0 / 3.0, green_scale, green_rot, green_mul);\n    m[2] = flim_gamut_extension_mat_row(2.0 / 3.0, blue_scale, blue_rot, blue_mul);\n    return m;\n}\n\nvec3 negative_and_print(vec3 inp, vec3 backlight_ext)\n{\n    // Develop Negative\n    inp = flim_rgb_develop(inp, flim_negative_film_exposure, flim_negative_film_density);\n\n    // Backlight\n    inp *= backlight_ext;\n\n    // Develop Print\n    inp = flim_rgb_develop(inp, flim_print_film_exposure, flim_print_film_density);\n\n    return inp;\n}\n\nbool flim_load_matrices(sampler2D matrix_ch, out mat3 extend_mat, out mat3 extend_mat_inv)\n{\n    // W == valid_w means the matrices have been calculated\n    // in the source buffer.\n    const float valid_w = 2.0;\n\n    vec4 row;\n\n    // extend_mat\n    {\n        row = texelFetch(matrix_ch, ivec2(0, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(1, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(2, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat[2] = row.xyz;\n    }\n\n    // extend_mat_inv\n    {\n        row = texelFetch(matrix_ch, ivec2(3, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[0] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(4, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[1] = row.xyz;\n\n        row = texelFetch(matrix_ch, ivec2(5, 0), 0);\n        if (row.w != valid_w)\n            return false;\n        extend_mat_inv[2] = row.xyz;\n    }\n\n    return true;\n}\n\n// -------------------------------\n\n// matrix_ch: Which channel provides the buffer\n// containing gamut extension matrices?\nvec3 flim_transform(vec3 inp, float exposure, sampler2D matrix_ch)\n{\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, flim_pre_exposure + exposure);\n\n    // Clip very large values for float precision reasons\n    inp = min(inp, 5000.0);\n\n    // Gamut Extension Matrix (Linear BT.709)\n    mat3 extend_mat, extend_mat_inv;\n    if (!flim_load_matrices(matrix_ch, extend_mat, extend_mat_inv))\n    {\n        return vec3(1, 0, 1);\n    }\n\n    // Backlight (extended gamut)\n    vec3 backlight_ext = flim_print_backlight * extend_mat;\n\n    // Upper limit in the print (highlight cap)\n    const float big = 10000000.0;\n    vec3 white_cap = negative_and_print(vec3(big, big, big), backlight_ext);\n\n    // Pre-Formation Filter\n    inp = lerp(inp, inp * flim_pre_formation_filter, flim_pre_formation_filter_strength);\n\n    // Convert to extended gamut\n    inp *= extend_mat;\n\n    // Negative & Print\n    inp = negative_and_print(inp, backlight_ext);\n\n    // Convert from extended gamut\n    inp *= extend_mat_inv;\n\n    // Eliminate negative values\n    inp = max(inp, 0.0);\n\n    // White cap\n    inp /= white_cap;\n\n    // Black cap\n    if (flim_black_point == -1.0) // -1 = auto\n    {\n        vec3 black_cap = negative_and_print(vec3(0.0), backlight_ext);\n        black_cap /= white_cap;\n        inp = rgb_uniform_offset(inp, rgb_avg(black_cap) * 1000.0, 0.0);\n    }\n    else\n    {\n        inp = rgb_uniform_offset(inp, flim_black_point, 0.0);\n    }\n\n    // Post-Formation Filter\n    inp = lerp(inp, inp * flim_post_formation_filter, flim_post_formation_filter_strength);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // Midtone Saturation\n    float mono = rgb_avg(inp);\n    float mixFac = (mono < 0.5) ? remap_clamp(mono, 0.05, 0.5, 0.0, 1.0) : remap_clamp(mono, 0.5, 0.95, 1.0, 0.0);\n    inp = lerp(inp, blender_hue_sat(inp, 0.5, flim_midtone_saturation, 1.0), mixFac);\n\n    // Clip\n    inp = clamp(inp, 0.0, 1.0);\n\n    // OETF (Gamma 2.2)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n\n\n\nvec3 random_unit_vector()\n{\n    vec3 v = vec3(1);\n    float lensqr;\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        lensqr = dot(v, v);\n        if (lensqr <= 1.) break;\n    }\n    return v / sqrt(lensqr);\n}\n\nvec3 random_in_sphere()\n{\n    vec3 v = vec3(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec3(2. * random() - 1., 2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\nvec2 random_in_circle()\n{\n    vec2 v = vec2(1);\n    for (int i = 0; i < 20; i++)\n    {\n        v = vec2(2. * random() - 1., 2. * random() - 1.);\n        if (dot(v, v) <= 1.) return v;\n    }\n    return v;\n}\n\n// Basic perspective camera\nstruct cam_t\n{\n    vec3 pos;\n    float fov;\n    float internal_zoom;\n    vec3 internal_forward;\n    vec3 internal_right;\n    vec3 internal_up;\n};\n\n// Ray\nstruct ray_t\n{\n    vec3 orig;\n    vec3 dir;\n};\n\n// Hit info\nstruct hit_t\n{\n    bool hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat_id;\n};\n\n// Material info\nstruct mat_t\n{\n    vec3 diffuse;\n    float roughness;\n    vec3 emission;\n    bool no_bounce;\n};\n\n// Ray offset\nconst float ray_offset = .001;\n\n// cam_t: Update internal zoom factor\nvoid cam_update_zoom(inout cam_t cam)\n{\n    cam.internal_zoom = 90. / cam.fov;\n}\n\n// cam_t: Look at a point\nvoid cam_look_at(inout cam_t cam, vec3 look_at)\n{\n    cam.internal_forward = normalize(vec3(0., 0., 1.) - cam.pos);\n    cam.internal_right = normalize(cross(cam.internal_forward, vec3(0, 0, 1)));\n    cam.internal_up = cross(cam.internal_right, cam.internal_forward);\n}\n\n// cam_t: Generate a camera ray for a given set of UV coords\nray_t cam_gen_ray(in cam_t cam, vec2 uv)\n{\n    ray_t r;\n    r.orig = cam.pos;\n    r.dir = normalize(\n        cam.internal_forward\n        + cam.internal_right * (uv.x / cam.internal_zoom)\n        + cam.internal_up * (uv.y / cam.internal_zoom)\n    );\n    return r;\n}\n\n// cam_t: Generate a camera ray for a given set of UV coords (includes DOF)\nray_t cam_gen_ray_dof(in cam_t cam, vec2 uv, float focus_dist, float jitter)\n{\n    // Generate normal ray without normalizing the direction\n    ray_t r;\n    r.orig = cam.pos;\n    r.dir =\n        cam.internal_forward\n        + cam.internal_right * (uv.x / cam.internal_zoom)\n        + cam.internal_up * (uv.y / cam.internal_zoom);\n    \n    // Focal point\n    vec3 fp = r.orig + focus_dist * r.dir;\n    \n    // Randomly offset the ray origin\n    vec2 offs = jitter * random_in_circle();\n    r.orig += cam.internal_right * offs.x + cam.internal_up * offs.y;\n    \n    // Look at the focal point again\n    r.dir = normalize(fp - r.orig);\n    \n    return r;\n}\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(int mat_id, const vec3 box_min, const vec3 box_max, in ray_t r, out hit_t h) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    if (t1 > max(t0, 0.0))\n    {\n        h.hit = true;\n        h.t = t0;\n        h.pos = r.orig + r.dir * t0;\n        h.normal = vec3(0.0, 0.0, 1.0); // what's the proper way? please comment\n        \n        // Material ID\n        h.mat_id = mat_id;\n    }\n}\n\nvoid ray_sphere(int mat_id, const vec3 center, const float radius, in ray_t r, out hit_t h)\n{\n    vec3 ro = r.orig - center;\n    \n    // Quadratic equation\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(ro, r.dir);\n    float c = dot(ro, ro) - radius*radius;\n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        // No hits\n        h.hit = false;\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float t = (-b - sqrt_d) / (2.0 * a);\n    \n    if (t < 0.0)\n    {\n        h.hit = false;\n        return;\n    }\n    \n    h.hit = true;\n    h.t = t;\n    h.pos = r.orig + (t * r.dir);\n    \n    // Normal\n    h.normal = (h.pos - center) / radius;\n    \n    // Material ID\n    h.mat_id = mat_id;\n}\n", "buffer_a_code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: Rendering\n  iChannel0: Cubemap\n  iChannel1: Buffer A (self-feeding)\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\n// Sample the environment\nvec3 get_env(vec3 dir)\n{\n    return .02 * pow(texture(iChannel0, dir.xzy).xyz, vec3(2.2));\n}\n\n// Materials\nvoid get_mat(int id, out mat_t m)\n{\n    // Default values\n    m.diffuse = vec3(1);\n    m.roughness = 1.;\n    m.emission = vec3(0);\n    m.no_bounce = false;\n\n    // Ground\n    if (id == 0)\n    {\n        m.diffuse = vec3(.6);\n        m.roughness = .9;\n        return;\n    }\n    \n    // Sphere 1\n    if (id == 1)\n    {\n        m.diffuse = vec3(.1, .25, .9);\n        m.roughness = .9;\n        return;\n    }\n    \n    // Sphere 2\n    if (id == 2)\n    {\n        m.diffuse = vec3(.9, .05, .01);\n        m.roughness = .12;\n        return;\n    }\n    \n    // LEDs\n    if (id >= 3 && id <= 7)\n    {\n        float hue = .1 * iTime +  247.34 * float(id - 3) / 4.;\n        m.emission = 10. * rgb_sweep(hue);\n        m.no_bounce = true;\n        return;\n    }\n}\n\nray_t gen_ray(vec2 uv)\n{\n    const vec3 cam_target = vec3(0, 0, 1);\n    \n    // Camera params\n    cam_t cam;\n    cam.pos = vec3(-.3, -3., 1.5);\n    cam.fov = 60.0;\n    cam_update_zoom(cam);\n    cam_look_at(cam, cam_target);\n    \n    // Ray\n    return cam_gen_ray_dof(cam, uv, iTime * .5, .2);\n}\n\n// Cast a ray to the scene and return information about it\nvoid cast_ray(ray_t r, out hit_t h_final)\n{\n    // Reset\n    h_final.hit = false;\n    h_final.t = 1e9;\n    h_final.mat_id = -1;\n    \n    // Ground\n    {\n        hit_t h;\n        ray_aabb(0, vec3(-8., -8., -.1), vec3(8., 8., 0.), r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // Sphere 1\n    {\n        hit_t h;\n        const vec3 sphere_pos = vec3(-.55, 0., 0.5);\n        const float sphere_radius = 0.5;\n        ray_sphere(1, sphere_pos, sphere_radius, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // Sphere 2\n    {\n        hit_t h;\n        const vec3 sphere_pos = vec3(.55, 0., 0.5);\n        const float sphere_radius = 0.5;\n        ray_sphere(2, sphere_pos, sphere_radius, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n    \n    // LEDs\n    for (int i = 0; i < 5; i++)\n    {\n        hit_t h;\n        float t = iTime * .4;\n        vec3 sphere_pos = vec3(\n            1.8 * cos(TAU * .48 * t + float(i)),\n            -.1 + .2 * cos(TAU * t + float(i)),\n            2. + .2 * cos(TAU * 1.35 * t + 3.72 * float(i)));\n        ray_sphere(i + 3, sphere_pos, .1, r, h);\n        if (h.hit && h.t < h_final.t) h_final = h;\n    }\n}\n\n// Update a given set of absorption and emission spectra based on given ray hit info\nvoid shade_ray(inout ray_t r, inout hit_t h, inout vec3 absorbed, inout vec3 emitted, out bool no_bounce)\n{\n    if (h.hit)\n    {\n        // Get material info\n        mat_t mat;\n        get_mat(h.mat_id, mat);\n        \n        // Emission\n        emitted += mat.emission;\n        \n        // Absorption (Diffuse)\n        absorbed *= mat.diffuse;\n        \n        // Should we stop bouncing?\n        if (mat.no_bounce)\n        {\n            no_bounce = true;\n            return;\n        }\n        \n        // Bounce ray\n        r.orig = h.pos + ray_offset * h.normal;\n        vec3 dir_refl = reflect(r.dir, h.normal);\n        vec3 dir_rand = normalize(h.normal + random_in_sphere());\n        r.dir = normalize(mix(dir_refl, dir_rand, mat.roughness));\n    }\n    else\n    {\n        // Environment\n        emitted += get_env(r.dir);\n        no_bounce = true;\n    }\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Generate camera ray\n    ray_t r = gen_ray(uv);\n    \n    // Ray info\n    hit_t h;\n    vec3 absorbed = vec3(1);\n    vec3 emitted = vec3(0);\n    \n    // Bounce ray and shade\n    bool no_bounce = false;\n    for (int i = 0; i <= 4; i++)\n    {\n        cast_ray(r, h);\n        shade_ray(r, h, absorbed, emitted, no_bounce);\n        if (no_bounce) break;\n    }\n    \n    // Final color\n    return absorbed * emitted;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Read data from the previous frame, stored at the bottom row of pixels.\n    \n    // Data: Resolution\n    vec4 prev_res;\n    {\n        const ivec2 data_coord = ivec2(0, 0);\n        if (ivec2(frag_coord) == data_coord)\n        {\n            frag_col = vec4(iResolution.xy, 0., 0.);\n            return;\n        }\n        prev_res = texelFetch(iChannel1, data_coord, 0);\n    }\n    \n    // Read the previous value of the current pixel\n    vec4 data = texelFetch(iChannel1, ivec2(frag_coord), 0);\n    \n    // Initialize PRNG\n    prng_init(vec3(frag_coord / iResolution.y, iTime));\n    \n    // Render with jitter sampling\n    const int num_samples = 50;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < num_samples; i++)\n    {\n        vec2 offs = vec2(random(), random()) - 0.5;\n        col += render(frag_coord + offs);\n    }\n    col /= float(num_samples);\n    \n    // Frame blending\n    frag_col = vec4(mix(data.xyz, col, .3), 1.);\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // W == valid_w means the matrices have already been calculated.\n    const float valid_w = 2.0;\n\n    // We only care about the first 6 pixels\n    if (ivec2(fragCoord).x > 5 || ivec2(fragCoord).y > 0)\n        return;\n\n    // Previous frame's value\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev;\n\n    // Do we need to recalculate the matrices?\n    bool needToCalc = (prev.w != valid_w) || (iTime == 0.0) || (iFrame < 1);\n    if (!needToCalc)\n        return;\n\n    // (Re)calculate the matrices\n    mat3 extend_mat = flim_gamut_extension_mat(flim_extended_gamut_red_scale, flim_extended_gamut_green_scale, flim_extended_gamut_blue_scale, flim_extended_gamut_red_rot, flim_extended_gamut_green_rot, flim_extended_gamut_blue_rot, flim_extended_gamut_red_mul, flim_extended_gamut_green_mul, flim_extended_gamut_blue_mul);\n    mat3 extend_mat_inv = inverse(extend_mat);\n\n    // extend_mat\n    {\n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = vec4(extend_mat[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(1, 0))\n        {\n            fragColor = vec4(extend_mat[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(2, 0))\n        {\n            fragColor = vec4(extend_mat[2], valid_w);\n        }\n    }\n\n    // extend_mat_inv\n    {\n        if (ivec2(fragCoord) == ivec2(3, 0))\n        {\n            fragColor = vec4(extend_mat_inv[0], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(4, 0))\n        {\n            fragColor = vec4(extend_mat_inv[1], valid_w);\n        }\n        if (ivec2(fragCoord) == ivec2(5, 0))\n        {\n            fragColor = vec4(extend_mat_inv[2], valid_w);\n        }\n    }\n}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfcD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 284, 332, 646]], "test": "untested"}
{"id": "DlByzt", "name": "textFlow", "author": "Athenus", "description": "textFlow", "tags": ["textflow"], "likes": 1, "viewed": 143, "published": 3, "date": "1692133144", "time_retrieved": "2024-07-30T17:39:11.532109", "image_code": "#define X(T)+ t) * (1. - i * .01 * (sin(T) * .5 + .5))\n\nvoid mainImage(out vec4 O, vec2 F)\n{\n    vec2 R = iResolution.xy,\n         u = (F + F - R) / R.y * 1.4;\n    \n    // Apply scaling factor\n    float scaleFactor = 0.8; // Adjust this factor to control the scale\n    u *= scaleFactor;\n    \n    //Declares and initializes some variables: i (used in the loop), t (current time), and l (length of vector u).\n    float i, t = iTime, l = length(u);\n\n    for (O *= i; i < 100.0; i += .5)\n    {\n        O += pow(0.0015 / \n        abs(length(u + vec2(cos(.98 * i X(t+1.0), sin(i X(t)))\n        - l*0.015 - .002) \n        * smoothstep(-2.0, 2.0, l) \n        * (1.0 * cos(i + i + l + l + t * .5 + 5. + vec4(0, 1, 2, 0))), O - O + 1.1);\n        }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlByzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mljyzc", "name": "FXAA͏", "author": "01000001", "description": "Experimenting with how to create FXAA using an 3x3 edge detection convolution and what I think works? no idea if this is correct", "tags": ["experiment", "antialiasing"], "likes": 1, "viewed": 136, "published": 3, "date": "1692125591", "time_retrieved": "2024-07-30T17:39:12.418738", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n\n    mat3x3 h = mat3x3(\n        .75, 0, -.75,\n         1 , 0,  -1,\n        .75, 0, -.75\n    )*.5;\n\n    vec2 normal = vec2(0);\n\n    float div = 0.;\n    for (int x = 0; x < 3; x++){\n        for (int y = 0; y < 3; y++){\n            normal.x += texture(iChannel0, (U-.5 + vec2(x, y))/r).a * h[y][x];\n        }\n    }\n\n    div = 0.;\n    for (int x = 0; x < 3; x++){\n        for (int y = 0; y < 3; y++){\n            normal.y += texture(iChannel0, (U-.5 + vec2(x, y))/r).a * h[x][y];\n        }\n    }\n\n\n    vec2 tangent = normal * mat2(0, 1, -1, 0);\n\n\n    \n    O = vec4(0);\n    div = 0.;\n    float samples = 3.;\n    float size = 1.;\n    for (float x = -size; x <= size;){\n        float c = -x*x + 1.;\n        x += size/samples;\n        div += c;\n        O += c * texture(iChannel0, (U + tangent*x)/r);\n    }\n\n    O /= div;\n\n    //O*=0.; O.xy = normal;\n\n\n    if (fract(iTime*.2) < .3){\n        O = (O-texture(iChannel0, U/r))*3.;\n    } else if (fract(iTime*.2) < .5) {\n        O = texture(iChannel0, U/r);\n    }\n    \n    O = pow(O, vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U/iResolution.y * (sin(iTime*.1) * .5 + .6);\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float a = length(mod(uv*10., vec2(2))-1.)>.8?0.:1.;\n    col *= a;\n    \n    O = vec4(col,a);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 1128]], "test": "untested"}
{"id": "ctByzK", "name": "SMPTE Test Pattern", "author": "martymarty", "description": "Recreating the SMPTE TV pattern using some math. Started this before seeing https://www.shadertoy.com/view/XlGXRz which uses a different approach. Now with golfing!", "tags": ["simple", "colors", "testpattern", "colorbars"], "likes": 4, "viewed": 215, "published": 3, "date": "1692120398", "time_retrieved": "2024-07-30T17:39:13.249517", "image_code": "//258 chars even shorter from Fabrice and Greg Rostami \nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= iResolution.xy;\n    float r = u.x*7.;\n    vec4 z, v = .075+z,\n         c = vec4(0,.22,.35,.5);\n   \n    O = mod( ceil(r/vec4( 2, 4, 1, 0)) , 2. );\n    \n    O = u.y > .33 ? O * .75\n      : u.y > .25 ? vec4(1.-O.xy, O.zz) * .75*O.z\n      : r < 1.25  ? c\n      : r < 2.5   ? v/v\n      : r < 3.75  ? c.yxwx\n      : r < 5.    ? v\n      : r < 5.33  ? z \n      : r < 6. && r > 5.67 ? z+.15 \n      : v;\n}\n\n//271 chars\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= iResolution.xy;\n    float r = u.x*84.;\n    vec4 z, v = .075 +z,\n         c = vec4(0,.22,.35,.5);\n   \n    O = mod( floor(vec4( r/24., r/48., r/12. , 0)) -1. , 2. );\n    \n    O = u.y > .33   ? O * .75\n      : u.y > .25   ? vec4(1.-O.xy, O.zz ) * .75* O.z\n      : r < 15. ? c\n      : r < 30. ? v/v\n      : r < 45. ? c.yxwx\n      : r < 60. ? v\n      : r < 64. ? z \n      : r > 68. && r < 72. ? z+.15 \n      : v;\n}\n*/\n\n/* \n//296 chars from Fabrice and Greg Rostami \nvoid mainImage( out vec4 O, vec2 u )\n{\n    u /= iResolution.xy;\n    float t = u.x*7.-5., r = ceil(t+4.);\n    vec4 z, v = .075 +z,\n         c = vec4(0,.22,.35,.5);\n    \n    O = mod( floor( vec4( r/2., r/4., r+2. , 0) ) -1. , 2. );\n    \n    O = u.y > .33   ? O * .75\n      : u.y > .25   ? vec4(1.-O.xy, O.zz ) * .75* O.z\n      : r < 5.      ? r = ceil(u.x*28.),\n                      r < 6.  ? c\n                    : r < 11. ? v/v\n                    : r < 16. ? c.yxwx\n                    :           v\n      :               t < .33 ? z \n                    : t > .66 && t < 1. ? z+.15 \n                    :           v;\n}\n*/\n\n/*\n// Original implementation \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float rect = floor(uv.x*7.0);\n    vec3 col = vec3(0.0);\n    if(uv.y>(1.0/3.0)){\n        col = 0.75*vec3(floor(mod((rect-2.0)/2.0,2.0)),\n                        floor(mod((rect-4.0)/4.0,2.0)),\n                        floor(mod(rect+1.0,2.0)));\n    }\n    else if(uv.y > 0.25){\n        col = vec3(1.0-floor(mod((rect-2.0)/2.0,2.0)),\n                        1.0-floor(mod((rect-4.0)/4.0,2.0)),\n                        floor(mod(rect+1.0,2.0)));\n        col *= col.b;\n        col *= 0.75;\n    }\n    else if(rect < 5.0){\n        rect = floor(uv.x*28.0);\n        if(rect <= 4.0){\n            col = vec3(0.0,0.22,0.35);\n        }\n        else if(rect <= 9.0){\n            col = vec3(1.0);\n        }\n        else if(rect <= 14.0){\n            col = vec3(0.22,0.0,0.5);\n        }\n        else {\n            col = vec3(0.075);\n        }\n    }\n    else {\n        col = vec3(0.075);\n        float three = uv.x*7.0-5.0;\n        if(three < 0.33333333){\n            col = vec3(0.0);\n        }\n        else if (three > 0.6666666667 && three < 1.0){\n            col = vec3(0.15);\n        }\n    }\n    fragColor = vec4(col,1.0);\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctByzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 94, 94, 499]], "test": "untested"}
{"id": "dt2cR3", "name": "carton flower4", "author": "chenxianming", "description": "wasted too many chars for according materials.", "tags": ["sdf", "flower", "cineshader", "carton"], "likes": 9, "viewed": 768, "published": 3, "date": "1692119920", "time_retrieved": "2024-07-30T17:39:14.137143", "image_code": "#define I iResolution\n#define PI 3.1415926\n#define op min\n#define gd(p, no) clamp(dot(no, vec3(p, -.5)), 0.0, 1.0)\n#define T(a) fract(iTime * a) * PI * 4.\n#define fk .125 * cos( T( .125 ) )\n\n// smax\nfloat s(float a, float b, float c) {\n  float d = clamp(.5 + .5 * (-b + a) / c, 0., 1.);\n  return -(mix(-b, -a, d) - c * d * (1. - d));\n}\n\nmat2 rot(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, s, -s, c);\n}\n// repetition\nfloat rp(inout vec2 b, float e) {\n  float a = 6.28 / e, f = (atan(b.y, b.x) + a * .5) / a, c = floor(f),\n        h = a * c;\n  b *= rot(h);\n  return c;\n}\n// calcRoot\nfloat cr(vec3 p) {\n  float d = .1;\n\n  // p.xy *= rot(PI * .15);\n  p -= vec3(.1, -.6, .4);\n\n  d = max(\n      length(p.xz + vec2(.25 * pow(p.y, 2.) + .125 * -p.x - fk * ( p.y / 2. + .5 ), 0.)) -\n          .1,\n      ( p.y / 2. + .5) - 1. );\n      // ( p.y / 2. + .5) - .08 * T( .25 ) ); // grow up\n\n  return d;\n}\n// petalUnit\nfloat pt(vec3 p) {\n  p.xy *= rot(PI * -.5), p.yz *= rot(PI * -.1);\n\n  vec3 op = p;\n\n  p.y -= .25;\n\n  float t = s(s(abs(p.x) - .1, abs(p.z) - .1, .02), abs(p.y) - .1, .02);\n\n  p = op;\n\n  float py = p.y;\n  py = py > 0. ? py * 5. : py, py = py < 0. ? py * 2. : py,\n  py = clamp(py, -1., 1.), py = abs(abs(pow(py, 2.)) - 1.);\n\n  return s(max(s(abs(p.x) - .18 * py, abs(p.z) - .1 * py, .1), abs(p.y) - .5),\n           -t, .1);\n}\n// calcPetals\nfloat cp(vec3 p) {\n  p.x = p.x - fk;\n\n  p.y -= .3;\n  p.yz *= rot(PI * .15);\n  p.xz *= rot(PI * -.05);\n\n  float d = .1;\n\n  float r = rp(p.xy, 7.);\n\n  d = min(d, pt(p + vec3(-0.55, 0., 0.)));\n\n  return d;\n}\n// calcPistil\nfloat cs(vec3 p) { return length(p - vec3( fk, .25, .05)) - .2; }\n// leafsPos\nfloat g(vec2 p, float s) { return length(p + vec2(s, 0.)) - .3; }\n// calcLeafs\nfloat cl(vec3 p) {\n  \n  p.x -=  .125 * .6 * cos( T( .125 ) );\n  p += vec3(-.042, .6, 0.);\n  \n\n  float r = rp(p.xy, 2.);\n  p += vec3(-.25, .1, 0.);\n\n  p.xy *= rot(PI * -.5);\n  p.xz *= rot(PI * .4);\n\n\n  return max(max(max(g(p.xy, .06), g(p.xy, -.06)), abs(p.z) - .01),\n             -(p.y + .2));\n}\n// sdf\nfloat df(vec3 p) {\n  float d = .1;\n  d = op(d, cp(p));\n\n  d = op(d, cs(p));\n\n  d = op(d, cr(p));\n\n  d = op(d, cl(p));\n\n  return d;\n}\n// calcNormal (IQ)\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nvoid mainImage(out vec4 U, in vec2 V) {\n  vec2 u = ( V + V - I.xy ) / I.y;\n\n  vec3 c, p, n, o = vec3(0., 0., -5.), r = vec3(u * .28, 1.);\n  float t, d, i, d1, d2;\n\n  for (; i < 64.; i++) // raymarching\n    p = o + r * t, d = df(p), t += d;\n\n  if (d < 1e-3)\n    n = l(p), d1 = gd(vec2(-.4, 1), n), d2 = gd(vec2(-.2, .2), n), c = vec3(1.),\n    // map or shaded each item\n    c = df(p) == cp(p)                       ? vec3(.98, .56, .59) * d1\n        : df(p) == cs(p)                     ? vec3(3. * d2)\n        : (df(p) == cl(p) || df(p) == cr(p)) ? vec3(.45, .67, .18) * d1\n                                             : p;\n\n  U = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2cR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 199, 235, 235, 335], [337, 337, 356, 356, 418], [419, 433, 466, 466, 585], [586, 598, 616, 616, 907], [908, 921, 939, 939, 1344], [1345, 1359, 1377, 1377, 1563], [1564, 1578, 1596, 1596, 1643], [1644, 1656, 1682, 1682, 1721], [1722, 1735, 1753, 1753, 2030], [2031, 2038, 2056, 2056, 2170], [2171, 2190, 2209, 2209, 2405], [2407, 2407, 2446, 2446, 3053]], "test": "untested"}
{"id": "mlBczc", "name": "tribute to \"Les maîtres du temps", "author": "FabriceNeyret2", "description": "ref: \"Les Maîtres Du Temps\" Laloux, Moebius, etc. (1982)\nhttps://archive.org/details/les-maitres-du-temps_202111\nfinal sequence, time code 1h14'26 - 1h15'28   ", "tags": ["short", "reproduction"], "likes": 16, "viewed": 201, "published": 3, "date": "1692103423", "time_retrieved": "2024-07-30T17:39:15.044717", "image_code": "#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                  // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,l,i,g, d,b;\n    vec3  R = iResolution, a,\n          D = normalize(vec3(U+U, -3.*R.y) - R),                // ray direction\n          p = vec3(0,0,6.+4.*cos(.3*iTime)), Q,q,               // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.               // camera control\n                            : vec3(.5*iTime,-.1,0);             // demo mode\n                          //  : vec3(3,.2,0)* cos(.3*iTime + vec3(0,11,0));\n    for ( ; i++ < 1e2 && t > .01;  )                            // march scene\n        q = p, \n        q.yz *= rot(-C.y),                                      // rotations\n        q.xz *= rot(-C.x),\n        t = min(t, max(length(Q=q)-1., .1 - abs(q.y) ) ),       // 2 hemispheres\n        t = min(t, d = max( length(q.xz)-.97, b = abs(abs(q.y)-.12)-.07 )), // docks\n        \n        q.yz *= rot(1.),                                        // tilt\n        a = abs(q) -1.2,\n        l = min(a.x, min(a.y,a.z)),\n        l = length( l==a.x ? a.yz: l==a.y ? a.xz : a.xy),       // cube\n        t =  min(t, l +.1 ),\n        g += exp(-18.*l),                                       // glow\n        \n        p += .5*t*D;                                            // step forward = dist to obj  \n    \n    O = 1.-i/1e2 + g*vec4(.4,.7,1,0);                           // color scheme \n#define T(q)  texture(iChannel0, 10.* (d==b ? q.xz : vec2(atan(q.z,q.x),2.*q.y)) ).r\n    if (t==d) O *= .9 + 1.5* (T(Q) - T((3e-3+Q)) );             // texture docks\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 113, 113, 1618]], "test": "untested"}
{"id": "mtScRc", "name": "Inside the mandelbulb II", "author": "mrange", "description": "CC0: Inside the mandelbulb II\nReceived some \"complaints\" about the old mandelbulb suffering from \nalias effects. So thought I make a quick try to apply the FXAA\nthing I learnt from XorDev. It did improve it but not perfect still.\n", "tags": ["3d", "mandelbulb"], "likes": 309, "viewed": 15272, "published": 3, "date": "1692095316", "time_retrieved": "2024-07-30T17:39:15.996173", "image_code": "// CC0: Inside the mandelbulb II\n//  Received some \"complaints\" about the old mandelbulb suffering from \n//  alias effects. So thought I make a quick try to apply the FXAA\n//  thing I learnt from XorDev. It did improve it but not perfect still.\n\n// When experimenting with this shader I realized this entire shader is \n// basically just a lucky bug (apart from the aliasing)\n\n#define RESOLUTION      iResolution\n\n// License: Unknowon, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  \n  fragColor = fxaa(iChannel0, q, sqrt(2.0)/RESOLUTION.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// CC0: Inside the mandelbulb II\n//  Received some \"complaints\" about the old mandelbulb suffering from \n//  alias effects. So thought I make a quick try to apply the FXAA\n//  thing I learnt from XorDev. It did improve it but not perfect still.\n\n// When experimenting with this shader I realized this entire shader is \n// basically just a lucky bug (apart from the aliasing)\n\n// --\n#define LOOPS   2    // 4+ and higher to show off you expensive GPU\n#define POWER   8.0\n#define ANIMATE\n// --\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PHI             (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.005\n#define MAX_BOUNCES     5\n\n\nmat3 g_rot  = mat3(1.0); \n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.0;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.6, 0.86, 1.0));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.065, 0.8, 6.0));\nconst vec3 diffuseCol = HSV2RGB(vec3(hoff+0.6, 0.85, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\nconst vec3 mat        = vec3(0.8, 0.5, (1.+0.05));\nconst vec3 beer       = -HSV2RGB(vec3(0.05, 0.95, 2.0)); \nconst float initt     = 0.1; \n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: Unknown, author: EvilRyu, found: https://www.shadertoy.com/view/MdXSWn\nfloat mandelBulb(vec3 p) {\n\n  const float power = POWER;\n  vec3 z  = p;\n  vec3 dz = vec3(0.0);\n  float r, theta, phi;\n  float dr = 1.0;\n  \n  for(int i = 0; i < LOOPS; ++i) {\n    r = length(z);\n    if(r > 2.0) continue;\n    theta = atan(z.y, z.x);\n#ifdef ANIMATE\n    phi = asin(z.z / r) + TIME*0.2;\n#else\n    phi = asin(z.z / r);\n#endif\n    \n    dr = pow(r, power - 1.0) * dr * power + 1.0;\n  \n    r = pow(r, power);\n    theta = theta * power;\n    phi = phi * power;\n    \n    z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n  }\n  return 0.5 * log(r) * r / dr;\n}\n\n\n\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  const float z1 = 2.0;\n  return mandelBulb(p/z1)*z1;\n}\n\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = max(max(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    float re    = mat.z;\n    float ire   = 1.0/re;\n    vec3 refr   = refract(rd, sn, !isInside ? re : ire);\n    vec3 rsky   = skyColor(sp, ref);\n    vec3 col = vec3(0.0);    \n    col += diffuseCol*dif*dif*(1.0-mat.x);\n    float edge = smoothstep(1.0, 0.9, fre);\n    col += rsky*mat.y*fre*vec3(1.0)*edge;\n    if (isInside) {\n      ragg *= exp(-(st+initt)*beer);\n    }\n    agg += ragg*col;\n\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      ragg *= mat.x;\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = rot_x(0.2*TIME)*rot_y(0.3*TIME);\n  vec3 ro = 0.6*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtScRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 492, 541, 640, 2683], [2685, 2685, 2742, 2742, 2842]], "test": "untested"}
{"id": "DljyWW", "name": "First Shader(Random Luck)", "author": "ordii", "description": "I reallly don't know how I got it. It is my first time.", "tags": ["cosmic"], "likes": 0, "viewed": 82, "published": 3, "date": "1692088568", "time_retrieved": "2024-07-30T17:39:16.768109", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.;\n    uv.y *= iResolution.y/iResolution.x;\n    float d = length(uv);\n    d *= cos(d*iTime + 0.2);\n    d = smoothstep(cos(iTime)*0.5, cos(iTime)*0.5, d);\n    // Output to screen\n    fragColor = vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 379]], "test": "untested"}
{"id": "DtBczc", "name": "Bitmapped text render.", "author": "Blindman67", "description": "Often debugging can be helped if numbers can be seen. This is a little boilerplate that can display a numbers (or text if bitmaps are given). Numbers are 10, 3 by 5 pixel black & white bitmaps . Click drag mouse button to see mouse coordinates displayed.", "tags": ["bitmappedtext"], "likes": 9, "viewed": 136, "published": 3, "date": "1692074783", "time_retrieved": "2024-07-30T17:39:17.615843", "image_code": "#define DIGIT_PX_SIZE 2.0 /* Bitmapped pixel render size */\n#define DIGIT_HEIGHT 5u   /* Bitmapped digit height */\n#define DIGIT_WIDTH 4u\n#define DIGIT_PX_WIDTH 3u /* Bitmapped digit width */\n#define DIGIT_COUNT 10u   /* Number of bitmapped digits */\n\n/* Bitmapped digits, low bit 0b1 is bottom left pixel, high bit 0b100_000_000_000_000 is top right pixel */\nuint digits[DIGIT_COUNT] = uint[](\n    0x7u + (0x5u << 3) + (0x5u << 6) + (0x5u << 9) + (0x7u << 12),  // digit 0\n    0x7u + (0x2u << 3) + (0x2u << 6) + (0x2u << 9) + (0x3u << 12),  // digit 1\n    0x7u + (0x1u << 3) + (0x2u << 6) + (0x4u << 9) + (0x7u << 12),  // digit 2\n    0x7u + (0x4u << 3) + (0x2u << 6) + (0x4u << 9) + (0x7u << 12),  // digit 3\n    0x4u + (0x7u << 3) + (0x5u << 6) + (0x1u << 9) + (0x1u << 12),  // digit 4\n    0x3u + (0x4u << 3) + (0x3u << 6) + (0x1u << 9) + (0x7u << 12),  // digit 5\n    0x2u + (0x5u << 3) + (0x3u << 6) + (0x1u << 9) + (0x6u << 12),  // digit 6\n    0x2u + (0x2u << 3) + (0x2u << 6) + (0x4u << 9) + (0x7u << 12),  // digit 7\n    0x7u + (0x5u << 3) + (0x2u << 6) + (0x5u << 9) + (0x7u << 12),  // digit 8\n    0x3u + (0x4u << 3) + (0x6u << 6) + (0x5u << 9) + (0x7u << 12)   // digit 9   \n);\nconst float invH = 1.0 / float(DIGIT_HEIGHT);\n\n/* Digit of number to display. eg 5 digits thus max number is 99999 */\n#define NUMBER_DIGITS 5u\nuint number[NUMBER_DIGITS];\n\n/* Bounding box size to contain NUMBER_DIGITS */\nconst vec2 size = vec2(\n    float(NUMBER_DIGITS) * DIGIT_PX_SIZE * float(DIGIT_WIDTH), \n    DIGIT_PX_SIZE * float(DIGIT_HEIGHT)\n);\n\n/* Used to avoid overhead of second number. */\nbool coordOnNum = false;\n\nvoid setNumber(uint num) {\n    uint i = NUMBER_DIGITS;\n    while (i-- > 0u) {\n        if (num > 0u) {\n            number[i] = num % 10u;\n            num /= 10u;\n        } else { number[i] = DIGIT_COUNT; }\n    }\n}    \nfloat drawNumber(vec2 px, vec4 boxed) {\n    if (px.x >= boxed.x && px.x < boxed.z && px.y >= boxed.y && px.y < boxed.w) {\n        coordOnNum = true;\n        uvec2 pos = uvec2((px - boxed.xy) / ((boxed.w - boxed.y) * invH));\n        uint idx = number[(pos.x >> 2) % DIGIT_COUNT];\n        if (idx < DIGIT_COUNT) {        \n            uint xBit = pos.x % DIGIT_WIDTH;\n            if (xBit < DIGIT_PX_WIDTH) {\n                uint yBit = (pos.y % (DIGIT_HEIGHT)) * DIGIT_PX_WIDTH;\n                bool bit = bool((digits[idx] >> (xBit + yBit)) & 1u);\n                return bit ? 1.0 : 0.0;\n            }\n        }\n    }    \n    return 0.0;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float p = 0.0;\n    setNumber(uint(iFrame) % 100000u);\n    p = drawNumber(fragCoord, vec4((iResolution.xy - size * 4.0) * 0.5,  (iResolution.xy + size * 4.0) * 0.5));\n    if (!coordOnNum) { /* if not on frame number */\n        setNumber(uint(iMouse.x));\n        vec2 mousePos = iMouse.xy;\n        p += drawNumber(fragCoord, vec4(mousePos, mousePos + size));\n        if (!coordOnNum) { /* if not on x coord number */\n            setNumber(uint(iMouse.y));        \n            mousePos += vec2(0, size.y + 2.0);\n            p += drawNumber(fragCoord, vec4(mousePos,  mousePos + size));\n        }\n    }\n    \n    fragColor = vec4(vec3(p), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1617, 1617, 1643, 1643, 1829], [1834, 1834, 1873, 1873, 2472], [2478, 2478, 2535, 2535, 3181]], "test": "untested"}
{"id": "clByz3", "name": "Background Integer Pixel Grid", "author": "Blindman67", "description": "Simple 3 level background grid with fixed width origin lines.", "tags": ["grid"], "likes": 1, "viewed": 118, "published": 3, "date": "1692055665", "time_retrieved": "2024-07-30T17:39:18.400744", "image_code": "#define GRID_PIXELS 10.0\n#define GRID_AREAS_A 5.0\n#define GRID_AREAS_B 10.0\n\n#define ZOOM_RATE 0.1\n#define MIN_ZOOM 0.5\n#define ZOOM_RANGE 4.0\n\n#define COL_1 vec3(0.5)\n#define COL_2 vec3(0.34)\n#define COL_3 vec3(0.25)\n#define COL_4 vec3(0.125)\n#define LINE_COL vec3(0.69)\n\nconst float invPxScale    = 1.0 / GRID_PIXELS;\nconst float invAreaScaleA = 1.0 / GRID_AREAS_A;\nconst float invAreaScaleB = 1.0 / GRID_AREAS_B;\n\nvec3 color;\n\nfloat unitSin(float a) { return sin(a) * 0.5 + 0.5; }\nbool gridId(vec2 coord) { return bool((uint(coord.x) + uint(coord.y)) % 2u); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = abs(fragCoord - iResolution.xy * 0.5);\n    if (coord.x <= 0.5 || coord.y <= 0.5) {    \n        color = LINE_COL;\n    } else {\n        float zoom = unitSin(iTime * ZOOM_RATE) * ZOOM_RANGE + MIN_ZOOM;\n        vec2 coordModA = coord * zoom * invPxScale;\n        vec2 coordModB = coordModA * invAreaScaleA;\n        vec2 coordModC = coordModB * invAreaScaleB;\n        bool pA = gridId(coordModA);\n        bool pB = gridId(coordModB);\n        bool pC = gridId(coordModC);\n        color = (pB ? (pA ? COL_1 : COL_2) : (pA ? COL_3 : COL_4)) * (pC ? 1.0 : 0.75);  \n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clByz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[430, 430, 454, 454, 483], [484, 484, 509, 509, 562], [564, 564, 621, 621, 1236]], "test": "untested"}
{"id": "clXyDS", "name": "Automata History Box", "author": "misol101", "description": "2d automata history with variations. Only seen this with Game of Life before.\n\nCONTROLS: left/right=prev/next CA, up/down=prev/next CA clear, 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  b=box, t=text\n", "tags": ["3d", "interactive", "voxel", "automata"], "likes": 28, "viewed": 408, "published": 3, "date": "1692039132", "time_retrieved": "2024-07-30T17:39:19.434979", "image_code": "\n// Increase SIZE in Common if your GPU can handle it!\n\n// Press UP/DOWN(clear) or LEFT/RIGHT for variants.\n\n// More keys: up/down=prev/next CA clear, 7-9=speed, c=color, v=view, p=pause, space=regen, 1-5=clear method, w/s=zoom,  b=box, t=text\n\n// Voxel cube from https://www.shadertoy.com/view/4lfSW4 by glk7\n\n#define EPS 0.001\n\nfloat N;\nint colmethod;\nint bbox;\nint row;\n\nfloat text(vec2 uv, float index)\n{\n    float col = 0.0;\n    vec2 center = text_res/2.0;\n    \n    text_pos(2, 2.0 + STRHEIGHT(0.0));\n    col += print_integer(index,0,uv) + _lsl() + print_integer(LAST_PATT,0,uv);// + _spc() + print_integer(iFrameRate,0,uv); \n    \n    return col;\n}\n\n\n// Taken from https://iquilezles.org/articles/palettes\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cellval( in ivec3 p )\n{\n    int iN=int(N);\n    int n=p.x+p.y*iN+p.z*iN*iN;\n    int pos = (SPC-1) - (n % SPC);\n    int pi=(n%CPP)/SPC;\n    n /= CPP;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    ivec2 p2 = ivec2(n%r.x,n/r.x);\n\n    vec4 outv = texelFetch(iChannel0, p2, 0 );\n\n    int val = int(outv[pi]);\n    val >>= BPS*pos;\n    val = val & AND_VAL;\n    \n    return float(val);\n}\n\nbool map(in vec3 p, out float v) \n{\n    p+=5.; // 0 == -5\n\n    int NM=int(N)-1;\n    if (bbox == 1) {\n        int x=int(p.x),y=int(p.y),z=int(p.z);\n        //if (z==NM-2 || (x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n        if ((x==0 && y==0) || (x==0 && z==0) || (y==0 && z==0) || (x==NM && y==NM) || (x==NM && z==NM) || (y==NM && z==NM)  || (y==0 && z==NM) || (x==0 && z==NM) || (x==0 && y==NM)  || (y==0 && x==NM) || (z==0 && y==NM)  || (z==0 && x==NM) ) {\n            v=-1.;\n            return true;\n        }\n    }\n\n    float cv = cellval(ivec3(p));\n\n    if (int(p.z)==row) \n        v=-1.;\n    else if(colmethod == 1) {\n        v=cv*0.12; // col by state value\n    } else\n        v=length(p-N/2.)*0.1+1.5; // col by distance\n\n    return cv > 0.5;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    return normalize(smoothstep(0.1, 0.0, bmax - p) - \n                     smoothstep(0.1, 0.0, p - bmin));\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (dot(re - ro, rd) < EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < int(N*3.); ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (dot(re - ro, rd) < EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro, -rd, -invrd, bmin, bmax, re, pa);\n    if (dot(re - ro, rd) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 32.; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (dot(re - ro, rd) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0/v0;\n    const vec3 invv1 = 1.0/v1;\n    const vec3 invv2 = 1.0/v2;\n    const vec3 invv3 = 1.0/v3;\n    const vec3 invv4 = 1.0/v4;\n    const vec3 invv5 = 1.0/v5; \n    const vec3 invv6 = 1.0/v6;\n    const vec3 invv7 = 1.0/v7;\n    vec3 invn = 1.0/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, float zmod, int view,\n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float yp=-3., xrot=-0.66;\n    if (view == 1) yp=0., xrot=0.0;\n    if (view == 2) yp=0., xrot=1.;\n    if (view == 3) yp=0., xrot=-1.;\n\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, yp, -d+zmod);\n\n    float mxc, myc;\n\n    if (iMouse.z > 0.) {\n        mxc = clamp(-((iMouse.x / iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n        myc = clamp((iMouse.y / iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    } else {\n        mxc=sin(sin(iTime*0.33))*1.17;\n        myc = xrot;\n    }\n\n    float mxs = sqrt(1.0-(mxc*mxc));\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=SIZE;\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < int(N)) N=float(maxsize-(1-maxsize%2));\n\n    float index = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int show2d = int(texelFetch(iChannel1, ivec2(3,0), 0 ).x);\n    float hidetext = texelFetch(iChannel1, ivec2(4,0), 0 ).x;\n    row = min(int(texelFetch(iChannel1, ivec2(5,0), 0 ).x),int(N)-2);\n    colmethod = int(texelFetch(iChannel1, ivec2(6,0), 0 ).x);\n    float zmod = texelFetch(iChannel1, ivec2(7,0), 0 ).x;\n    bbox = int(texelFetch(iChannel1, ivec2(8,0), 0 ).x);\n    int view = int(texelFetch(iChannel1, ivec2(10,0), 0 ).x);\n\n    if (show2d == 1 && fragCoord.y < N && fragCoord.x > iResolution.x - N) {\n        fragColor=texelFetch(iChannel2, ivec2(iResolution.x - fragCoord.x, fragCoord.y),0)*100.;\n        return;\n    }\n\n    text_res = iResolution.xy / DOWN_SCALE;\n    float text_pixel = 0.;\n    if (hidetext < 1.) text_pixel = text(fragCoord, index);    \n\n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(N, N, N) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(N*0.5), N*1.37, zmod, view, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 / rd;\n    vec3 invl = 1.0 / l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    #ifdef HORIZON\n    float yp=(iResolution.y - fragCoord.y);\n    float hp=0.10; if(view==1) hp=0.4; if(view==2) hp=1.;\n    float yf1=iResolution.y*hp, yf2=iResolution.y*(hp+0.2);\n    if (yp >= yf1 && yp < yf2) color = mix(vec3(0.4, 0.45, 0.85),vec3(0.03, 0.03, 0.03), 1.-(yf2-yp)/(yf2-yf1));\n    else if (yp < yf1) color = vec3(0.4, 0.45, 0.85);\n    #endif\n\n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n    \n    fragColor += text_pixel;    \n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Persistive Keyboard Input buffer\n\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_M     = 77;\nconst int KEY_P     = 80;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey( int key ) {\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec4 keyStep(int ix, int iy, int key, float delta, float maxval) {\n    vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n    float kx=keystate.x;\n    float ky=keystate.y;\n    if( readKey(key) ) {\n        if (ky == 0.) {\n            kx+=1.;\n            if (kx >= maxval) kx=0.;\n            if (kx < 0.) kx=maxval-delta;\n        }\n        ky+=0.01;\n        if (ky >= 1.0) ky=0.;\n    }\n    else {\n        ky = 0.;\n    }\n    return vec4(kx,ky,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int ix = int(fragCoord.x), iy = int(fragCoord.y);\n\n    if (iy > 1) { fragColor = vec4(0.,0.,0.,1.0); discard; }\n\n    if (ix == 0 && iy == 0) {\n        vec3 keystate = texelFetch(iChannel0, ivec2(ix,iy), 0 ).xyz;\n        float kx=keystate.x;\n        float ky=keystate.y;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_LEFT)||readKey(KEY_RIGHT) ) {\n            if (ky == 0.) {\n                if (readKey(KEY_DOWN) || readKey(KEY_RIGHT)) {\n                    kx+=1.001;\n                    if (kx > LAST_PATT+0.5) kx=0.5;\n                } else {\n                    kx-=1.001;\n                    if (kx < 0.) kx=LAST_PATT+0.5;\n                }\n            }\n            ky+=0.01;\n            if (ky >= 1.0) ky=0.;\n        }\n        else {\n            ky = 0.;\n        }\n        fragColor = vec4(kx,ky,0.,0.);\n        return;\n    }\n\n    if (ix == 1 && iy == 0) {\n        float method = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_1)) method = 0.5;\n        if( readKey(KEY_2)) method = 1.5;\n        if( readKey(KEY_3)) method = 2.5;\n        if( readKey(KEY_4)) method = 3.5;\n        if( readKey(KEY_5)) method = 4.5;\n        fragColor = vec4(method,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 2 && iy == 0) {\n        float speed = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_7)) speed = 0.;\n        if( readKey(KEY_8)) speed = -1.;\n        if( readKey(KEY_9)) speed = 5.;\n        fragColor = vec4(speed,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 3 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_M, 1., 2.);\n        return;\n    }\n\n    if (ix == 4 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_T, 1., 2.);\n        return;\n    }\n\n    if (ix == 5 && iy == 0) {\n        float row = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_UP)||readKey(KEY_DOWN)||readKey(KEY_SPACE) )\n            row = 0.;\n        fragColor = vec4(row+1.001,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 6 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_C, 1., 2.);\n        return;\n    }\n\n    if (ix == 7 && iy == 0) {\n        float zmod = texelFetch(iChannel0, ivec2(ix,iy), 0 ).x;\n        if( readKey(KEY_W)) zmod += 1.;\n        if( readKey(KEY_S)) zmod -= 1.;\n        zmod = clamp(zmod, -20., 40.);\n        fragColor = vec4(zmod,0.,0.,0.);\n        return;\n    }\n\n    if (ix == 8 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_B, 1., 2.);\n        return;\n    }\n\n    if (ix == 9 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_P, 1., 2.);\n        if (readKey(KEY_DOWN) || readKey(KEY_UP))\n            fragColor = vec4(0.);\n        return;\n    }\n\n    if (ix == 10 && iy == 0) {\n        fragColor = keyStep(ix, iy, KEY_V, 1., 4.);\n        return;\n    }\n\n\n    fragColor = vec4(0.,0.,0.,1.0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// 3d cell buffer, pixel packed with 1 bit per state and using 15 bits per component for 15*4=60 cells per pixel \n// Max size: for 800*450, pow(800*450*60,1/3) = 278!\n// Could use up to 24 bits per component for desktop, but won't work on mobile\n\nint N;\n\nint cellval( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    int pos = (SPC-1) - (n % SPC);\n    int pi=(n%CPP)/SPC;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    int val = int(texelFetch(iChannel0, p2, 0 )[pi]);\n    val >>= BPS*pos;\n    val = val & AND_VAL;\n    return val;\n}\n\nint aut2dval( in ivec3 p) {\n    ivec2 p2 = ivec2(p.x,p.y);\n    \n    int val = int(texelFetch(iChannel2, p2, 0 ).x*10.+0.);\n    return val;\n}\n\nvec4 cv4( in ivec3 p, int xp,int yp, int zp) {\n    int n=(p.x+xp)+(p.y+yp)*N+(p.z+zp)*N*N;\n    n/=CPP;\n\n    int resx = int(iResolution.x);\n    ivec2 p2 = ivec2(n%resx, n/resx);\n    \n    return texelFetch(iChannel0, p2, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    int pos1d=int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x);\n    pos1d *= CPP;\n    if (pos1d > N*N*N) { fragColor = vec4(0.); return; }\n    fragCoord.x = float(pos1d % int(iResolution.x));\n    fragCoord.y = float(pos1d / int(iResolution.x));\n\n    float xres = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    int speed = 1+int(texelFetch(iChannel1, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel1, ivec2(9,0), 0 ).x);\n\n    int row = int(texelFetch(iChannel1, ivec2(5,0), 0 ).x);\n    if (row < N-2+speed) speed=0;\n    row = min(row,N-2);\n\n    int z=pos1d/(N*N);\n    pos1d-=z*N*N;\n    int y=pos1d/N;\n    int x=pos1d-y*N;\n\n    ivec4 fst=ivec4(0);\n\n    bool regen = iFrame < 1 || int(xres) != int(iResolution.x) || row==1;\n\n    if (!regen && (iFrame % (speed+1) > 0 || pause == 1)) {\n        fragColor = cv4(ivec3(x,y,z),0,0,0);\n        return;\n    }\n\n    for (int i=0; i<CPP; i++) {\n        int fi=i/SPC;\n        int xi=x+i,yi=y,zi=z;\n        if (xi >= N) {xi-=N; yi++; if (yi >= N) {yi=0; zi++;}}\n        ivec3 pos3d=ivec3(xi,yi,zi);\n\n        int NM=N-1;\n        if (xi==0 || yi==0 || zi==0 || xi==NM || yi==NM || zi==NM) {\n            fst[fi] = fst[fi]<<BPS;\n            continue;\n        }\n\n        if (regen) {\n            fst[fi] = (fst[fi] << BPS);\n            continue;\n        }\n\n        int st;\n        if (zi==row) {\n            st=aut2dval(pos3d);\n        }\n        else {\n            st = cellval(pos3d,0,0,1);\n        }\n\n        fst[fi] = (fst[fi] << BPS) | st;\n\n        fragCoord.x+=1.;\n        if(fragCoord.x >= iResolution.y) { fragCoord.y+=1.; fragCoord.x=0.; }\n    }\n\n    fragColor = vec4(fst);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE 90.\n\nconst int BPS = 1; // Bits per state\nconst int SPC = 15; // States per component (BPS*SPC must be <=24, and to work for mobile <=15)\nconst int CPP = SPC*4; // Cells Per Pixel (*1,2,3,4 will work)\nconst int AND_VAL = (1 << BPS) - 1;\n\n//#define HORIZON\n\nconst float LAST_PATT = 28.001;\nfloat density=50.;\nfloat liveval = 0.1;\nint stayset, bornset;\nint clearmethod;\n\nvoid setRules(int index) {\n    int v1, v2;\n    clearmethod=-1;\n\n    if (index == 0) {v1 = 230, v2=196; density=10.; clearmethod=1; }   // Chaotic life, forced symmetry \n    if (index == 1) {v1 = 240, v2=40; density=73.;}    // Ink blobs \n    if (index == 2) {v1 = 70, v2=4; density=20.;}      // \"Self-activating\" GOL\n    if (index == 3) {v1 = 122, v2=225; density=60.;}   // Worms in static\n    if (index == 4) {v1 = 120, v2=4; density=85.;}     // Black vs white landscape \n    if (index == 5) {v1 = 175, v2=8; density=20.;}     // Stable bg\n    if (index == 6) {v1 = 241, v2=92; density=11.;}    // Oddly growing rects\n    if (index == 7) {v1 = 122, v2=240; density=60.;}   // Stable worms\n    if (index == 8) {v1 = 122, v2=65; density=60.;}    // Chaos + stable\n    if (index == 9) {v1 = 122, v2=65; density=70.;}    // Chaos + stable II\n    if (index == 10) {v1 = 96, v2=57; density=100.;}   // Grow to stable flashing\n    if (index == 11) {v1 = 249, v2=228; density=14.;}  // Growing blobs\n    if (index == 12) {v1 = 243, v2=24; density=55.;}   // Stable BW\n    if (index == 13) {v1 = 243, v2=88; density=45.;}   // Stable BW II\n    if (index == 14) {v1 = 249, v2=216; density=31.;}  // Stable \"stones\"\n    if (index == 15) {v1 = 121, v2=16; density=54.;}   // Squiggly no chaos\n    if (index == 16) {v1 = 185, v2=9; density=50.;}    // Ant war\n    if (index == 17) {v1 = 113, v2=89; density=50.;}   // Ant war with spots\n    if (index == 18) {v1 = 227, v2=255; density=18.;}  // Hornet's nest\n    if (index == 19) {v1 = 242, v2=18; density=63.;}   // Slow growing blobs in chaos\n    if (index == 20) {v1 = 5, v2=12; density=70.;}     // Chaotic life III\n    if (index == 21) {v1 = 219, v2=216; density=50.;}  // Black eating ant war\n    if (index == 22) {v1 = 248, v2=65; density=10.;}   // Random to stable takeover\n    if (index == 23) {v1 = 248, v2=66; density=10.;}   // Growing jigsaw\n    if (index == 24) {v1 = 0, v2=61; density=90.;}     // Triangles\n    if (index == 25) {v1 = 222, v2=32; density=100.;}  // Stone\n    if (index == 26) {v1 = 51, v2=4; density=10.;}     // Non-growing chaos\n    if (index == 27) {v1 = 120, v2=68; density=97.;}   // Slow growing \"maps\"\n    if (index == 28) {v1 = 38, v2=20;  density=9.;}    // Chaotic life II\n\n    stayset=v1, bornset=v2;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\n\n// FONT\n// From https://www.shadertoy.com/view/Mt2GWD by Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 text_res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\n\nfloat text_mode(int mode) {\n    TEXT_MODE = mode;\n    return 0.;\n}\n\n#define text_pos(a,b) print_pos = vec2(a, b)\n\n#define _spc() char(ch_spc,uv)\n#define _exc() char(ch_exc,uv)\n#define _quo() char(ch_quo,uv\n#define _hsh() char(ch_hsh,uv)\n#define _dol() char(ch_dol,uv)\n#define _pct() char(ch_pct,uv)\n#define _amp() char(ch_amp,uv)\n#define _apo() char(ch_apo,uv)\n#define _lbr() char(ch_lbr,uv)\n#define _rbr() char(ch_rbr,uv)\n#define _ast() char(ch_ast,uv)\n#define _crs() char(ch_crs,uv)\n#define _com() char(ch_com,uv)\n#define _dsh() char(ch_dsh,uv)\n#define _per() char(ch_per,uv)\n#define _lsl() char(ch_lsl,uv)\n#define _0() char(ch_0,uv)\n#define _1() char(ch_1,uv)\n#define _2() char(ch_2,uv)\n#define _3() char(ch_3,uv)\n#define _4() char(ch_4,uv)\n#define _5() char(ch_5,uv)\n#define _6() char(ch_6,uv)\n#define _7() char(ch_7,uv)\n#define _8() char(ch_8,uv)\n#define _9() char(ch_9,uv)\n#define _col() char(ch_col,uv)\n#define _scl() char(ch_scl,uv)\n#define _les() char(ch_les,uv)\n#define _equ() char(ch_equ,uv)\n#define _grt() char(ch_grt,uv)\n#define _que() char(ch_que,uv)\n#define _ats() char(ch_ats,uv)\n#define _A() char(ch_A,uv)\n#define _B() char(ch_B,uv)\n#define _C() char(ch_C,uv)\n#define _D() char(ch_D,uv)\n#define _E() char(ch_E,uv)\n#define _F() char(ch_F,uv)\n#define _G() char(ch_G,uv)\n#define _H() char(ch_H,uv)\n#define _I() char(ch_I,uv)\n#define _J() char(ch_J,uv)\n#define _K() char(ch_K,uv)\n#define _L() char(ch_L,uv)\n#define _M() char(ch_M,uv)\n#define _N() char(ch_N,uv)\n#define _O() char(ch_O,uv)\n#define _P() char(ch_P,uv)\n#define _Q() char(ch_Q,uv)\n#define _R() char(ch_R,uv)\n#define _S() char(ch_S,uv)\n#define _T() char(ch_T,uv)\n#define _U() char(ch_U,uv)\n#define _V() char(ch_V,uv)\n#define _W() char(ch_W,uv)\n#define _X() char(ch_X,uv)\n#define _Y() char(ch_Y,uv)\n#define _Z() char(ch_Z,uv)\n#define _lsb() char(ch_lsb,uv)\n#define _rsl() char(ch_rsl,uv)\n#define _rsb() char(ch_rsb,uv)\n#define _pow() char(ch_pow,uv)\n#define _usc() char(ch_usc,uv)\n#define _a() char(ch_a,uv)\n#define _b() char(ch_b,uv)\n#define _c() char(ch_c,uv)\n#define _d() char(ch_d,uv)\n#define _e() char(ch_e,uv)\n#define _f() char(ch_f,uv)\n#define _g() char(ch_g,uv)\n#define _h() char(ch_h,uv)\n#define _i() char(ch_i,uv)\n#define _j() char(ch_j,uv)\n#define _k() char(ch_k,uv)\n#define _l() char(ch_l,uv)\n#define _m() char(ch_m,uv)\n#define _n() char(ch_n,uv)\n#define _o() char(ch_o,uv)\n#define _p() char(ch_p,uv)\n#define _q() char(ch_q,uv)\n#define _r() char(ch_r,uv)\n#define _s() char(ch_s,uv)\n#define _t() char(ch_t,uv)\n#define _u() char(ch_u,uv)\n#define _v() char(ch_v,uv)\n#define _w() char(ch_w,uv)\n#define _x() char(ch_x,uv)\n#define _y() char(ch_y,uv)\n#define _z() char(ch_z,uv)\n#define _lpa() char(ch_lpa,uv)\n#define _bar() char(ch_bar,uv)\n#define _rpa() char(ch_rpa,uv)\n#define _tid() char(ch_tid,uv)\n#define _lar() char(ch_lar,uv)\n", "buffer_c_code": " // Cellular automata buffer\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\n\nint N;\n\nbool readKey( int key )\n{\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, .25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nint cell( in ivec2 p )\n{\n    if (p.y < 0) p.y = N-1;\n    if (p.x < 0) p.x = N-1;\n    if (p.y >= N) p.y = 0;\n    if (p.x >= N) p.x = 0;\n\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return ( val > 0.) ? 1 : 0;\n}\nfloat cellval( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    float val = texelFetch(iChannel0, p, 0 ).x;\n    return val;\n}\n\nfloat randpix(vec2 fragCoord) {\n    float rn = hash1(iTime+fragCoord.x*13.0+hash1(fragCoord.y*71.1));\n    return clamp(step(1.01-density/100., rn), 0., liveval);\n}\n\nfloat restart(vec2 fragCoord, int method) {\n    if (method == 0)\n        return randpix(fragCoord);\n\n    vec2 mid = vec2(N,N) / 2.; \n    float w=25., h=25., radius=25.;\n    float thick=2., wl=w-thick, hl=h-thick;\n\n    if (method == 1) {\n        if (length(fragCoord-mid)< radius && length(fragCoord-mid) > (radius-thick))\n            return liveval;\n        return 0.;\n    }\n    if (method == 2) {\n        if (((fragCoord.x > mid.x - w && fragCoord.x < mid.x - wl) || (fragCoord.x > mid.x + wl && fragCoord.x < mid.x + w))\n            && fragCoord.y > mid.y - h && fragCoord.y < mid.y + h)\n            return liveval;\n        if (((fragCoord.y > mid.y - h && fragCoord.y < mid.y - hl) || (fragCoord.y > mid.y + hl && fragCoord.y < mid.y + h))\n            && fragCoord.x > mid.x - w && fragCoord.x < mid.x + w)\n            return liveval;\n        return 0.;\n    }\n    if (method == 3) {\n        if (length(fragCoord-mid)< radius)\n            return liveval;\n        return 0.;\n    }\n    if (method == 4) {\n        if (fragCoord.x > mid.x - radius && fragCoord.x < mid.x + radius && fragCoord.y > mid.y - radius && fragCoord.y < mid.y + radius)\n            return liveval;\n        return 0.;\n    }\n\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    N=int(SIZE);\n    int maxsize = int(pow(iResolution.x*iResolution.y*float(CPP), 1./3.));\n    if (maxsize < N) { N=maxsize-(1-maxsize%2); }\n\n    if (int(fragCoord.y) > N) discard;\n    if (int(fragCoord.x) > N) { fragColor = vec4(0.); return; }\n\n    float ix = texelFetch(iChannel3, ivec2(0,0), 0 ).x;\n    float xres = texelFetch(iChannel1, ivec2(0,0), 0 ).x;\n    int method = int(texelFetch(iChannel3, ivec2(1,0), 0 ).x);\n    int speed = int(texelFetch(iChannel3, ivec2(2,0), 0 ).x);\n    int pause = int(texelFetch(iChannel3, ivec2(9,0), 0 ).x);\n    \n    setRules(int(ix));\n    if(clearmethod>=0) method=clearmethod;\n    \n    if( iFrame==0 || readKey(KEY_SPACE) || readKey(KEY_RIGHT) || readKey(KEY_LEFT) || readKey(KEY_UP) || readKey(KEY_DOWN) || int(xres) != int(iResolution.x)\n     || readKey(KEY_1) || readKey(KEY_2) || readKey(KEY_3) || readKey(KEY_4) || readKey(KEY_5) ) {\n        fragColor =  vec4(restart(fragCoord, method), 0.,0.,0.);\n        return;\n    }\n\n    ivec2 px = ivec2( fragCoord );\n\n    if (iFrame % (speed+1) > 0 || pause == 1) {\n        fragColor = vec4( cellval(px), 0.0, 0.0, 0.0 );\n        return;\n    }\n    \n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    int f = 0;\n    if (e==1) {\n        f = 0;\n        if ((stayset & (1<<(k-1))) > 0 ) f=1;\n    }\n    else {\n        f = (bornset & (1<<(k-1))) > 0 ? 1 : 0;\n    }\n\n    float ff = float(f)/10.;\n\n\tfragColor = vec4( ff, 0.0, 0.0, 0.0 );\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// resolution change\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { fragColor = vec4(iResolution.x); }\n", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 374, 408, 408, 653], [656, 711, 787, 787, 830], [832, 832, 861, 861, 1223], [1225, 1225, 1260, 1260, 2166], [2168, 2168, 2278, 2278, 2595], [2597, 2597, 2646, 2646, 2757], [2759, 2759, 2876, 2876, 3578], [3580, 3580, 3668, 3668, 4247], [4249, 4249, 4344, 4344, 4483], [4485, 4485, 4561, 4561, 5695], [5698, 5698, 5723, 5723, 5910], [5912, 5912, 6068, 6068, 6869], [6871, 6871, 6898, 6898, 6965], [6967, 6967, 7024, 7024, 9286]], "test": "untested"}
{"id": "DtjczV", "name": "hash with sigmoid", "author": "iY0Yi", "description": "red is raw hash.\ngreen is sigmoided.", "tags": ["hash", "sigmoid"], "likes": 4, "viewed": 182, "published": 3, "date": "1692030504", "time_retrieved": "2024-07-30T17:39:20.304654", "image_code": "// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sigmoidHash12(vec2 seed, float scale) {\n    float r = hash12(seed);\n    return 1./(1.+exp((r-.5)*scale*2.));\n}\n\nbool inRange(float v, float min, float max) {\n    return v > min && v < max;\n}\n\n#define loop(i,itr) for(int i=0;i<itr;i++)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = vec3(0);\n    float pix = 1./iResolution.x;\n    \n    loop(i,50)\n    loop(j,50){\n    \n        vec2 off = vec2(i,j)+iTime;\n        \n        if( inRange( hash12 (fragCoord.xx+off), uv.x-pix*.5, uv.x+pix*.5))\n            c.r++;\n            \n        if( inRange( sigmoidHash12 (fragCoord.xx+off, 5.+(sin(iTime*5.)*.5+.5)*50.), uv.x-pix*.5, uv.x+pix*.5))\n            c.g++;\n    }\n\n    fragColor = .25+vec4(c.r*10.>fragCoord.y,\n                     c.g*10.>fragCoord.y,\n                     0,1)*.75;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjczV.jpg", "access": "api", "license": "mit", "functions": [[0, 115, 136, 136, 253], [255, 255, 300, 300, 371], [373, 373, 418, 418, 451]], "test": "untested"}
{"id": "Dt2czV", "name": "Transfigured Grid", "author": "coreythuro", "description": "//", "tags": ["multistable"], "likes": 4, "viewed": 190, "published": 3, "date": "1692030315", "time_retrieved": "2024-07-30T17:39:21.141418", "image_code": "\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*sin( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord / -2.5 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.40; i++) {\n        uv = fract(uv * .5) - 105.15;\n\n        float d = length(uv) * exp(length(uv0));\n\n        vec3 col = palette(length(uv0) + i*4.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2czV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 210], [212, 212, 269, 269, 759]], "test": "untested"}
{"id": "DljcRV", "name": "Distortion of space", "author": "01000001", "description": "opposite", "tags": ["raymarching", "blackhole", "physics", "gravity", "singularity"], "likes": 14, "viewed": 338, "published": 3, "date": "1692029805", "time_retrieved": "2024-07-30T17:39:21.907368", "image_code": "#define SuperSamplingSampleCount 1\n\n\n\nconst float pi = 3.1415926;\nconst float maxDist = 80.;\nconst float horizon = 1.;\nconst float disk = 3.;\nconst float diskT = 0.05;\nvec3 col = vec3(0);\nfloat stepSize;\nconst int maxSteps = 1024;\nconst float focalLength = 9.1;\n\nfloat frame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat df(vec3 p)\n{    \n    if (max(abs(p.x), max(abs(p.y), abs(p.z))) < 6.02){\n        p += 2.;\n        p = mod(p, vec3(4)) - vec3(2);\n        float df = frame(p, vec3(2), 0.05);\n        return df;\n    } else {\n        return box(p, vec3(6));\n    }\n}\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 ps(uvec3 x){\n    return hash(x).xy * 2. - 1.;\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\n    vec2 ri = iResolution.xy;\n    int i = 0;\n    vec2 muv = iMouse.z > 0.?(2.*iMouse.xy - ri.xy)/ri.xy * vec2(3, 7):vec2(.5, 2.);\n    vec3 dirV;\n    vec3 odir;\n    float sDist = 500.;\n\n    int ssaa = SuperSamplingSampleCount;\n\n    for (int m = 0; m < ssaa; m++){\n\n        vec2 offset = ps(uvec3(iFrame + m, int(U.y) - m, int(U.x)+m))*.5;\n        // SSAA\n        float c = 1./(sqrt(length(offset))+0.3);\n        //Varied contribution of ssaa sample based on distance from centre\n        vec2 uv = (2.*U - ri.xy\n            +offset\n        )/ri.y;\n\n        vec3 camDir = normalize(vec3(sin(muv.xx + vec2(0,11)), -muv.y*0.085));\n        vec3 r = cross(camDir, vec3(0, 0, 1));\n        vec3 u = cross(r, camDir);\n        dirV = normalize(camDir * focalLength + r * uv.x + u * uv.y);\n        odir = dirV;\n\n        float depth = 0.;\n        vec3 camPos = vec3(sin(-muv.xx - vec2(0,11)) * 65., muv.y*5.);\n\n        vec3 shift = vec3(sin(iTime)*4., cos(iTime)*4., sin(iTime * pi) * 0.);\n\n        float g = 0.;\n        vec3 p = camPos + shift;\n\n        for (i = 0; i<maxSteps; i++){\n\n            stepSize = min(df(p - shift), .5); \n            // this .5 is the biggest performance drop. \n            // If you decrease this you get better quality but slower rendering\n            p += stepSize * dirV;\n\n            depth += stepSize;\n            \n            sDist = min(sDist, length(p)*length(p));\n            g = (stepSize / pow(length(p), 2.));\n            dirV = normalize(dirV + p * 0.1*g);\n\n            if (stepSize < 0.01){\n                col +=  c * vec3(2./(depth-56.));\n                i = maxSteps;\n            }\n            \n            if (depth > maxDist)\n            {\n                i = maxSteps;\n            }\n        }\n    }\n    \n    col = col /= float(ssaa);\n    \n    O = vec4(pow(col.x, 1./2.2));//*/\n/*\n\n    O.x *= 8./distort;\n    O.y *= 25./distort - O.x*2.5;\n    O.z *= 1.-1./distort;/*/\n    \n    O *= 0.5 + 0.5 * sin(10./(sDist+(10./pi*.5)) + vec4(0, 33, 11, 0) - 2.);\n    //*/\n}\n\n\n\n//I would add TAA but I'm tired and annoyed at this shader\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 303, 303, 590], [592, 592, 621, 621, 708], [710, 710, 728, 728, 960], [990, 990, 1012, 1012, 1145], [1146, 1197, 1214, 1214, 1249], [1253, 1253, 1294, 1294, 3292]], "test": "untested"}
{"id": "Dt2yRV", "name": "getDigits/inRange", "author": "iY0Yi", "description": "tiny helper function to extract some small integer from a float value.", "tags": ["digits", "index", "id"], "likes": 6, "viewed": 173, "published": 3, "date": "1692023541", "time_retrieved": "2024-07-30T17:39:22.842867", "image_code": "// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nint getDigits(float f, int digc, int index) {\n    // Note: For 32-bit floats, the precision is typically up to about 7 decimal places.\n    // Exceeding this may lead to accuracy issues.\n    // 1. Multiply the float by a power of 10 to shift the desired digits to the integer part.\n    //    This depends on both the desired number of digits (dig) and the offset (id).\n    f = f * pow(10., float(digc + index));\n    // 2. Convert the float to an integer to discard any fractional part.\n    // 3. Return the last 'dig' digits of the integer.\n    return int(f) % int(pow(10., float(digc)));\n}\n\nbool inRange(float v, float min, float max) {\n    return v > min && v < max;\n}\n\nbool inRange(int v, int min, int max) {\n    return v > min && v < max;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord=floor(fragCoord/8.+(iTime*8.));\n    \n    float f = hash12(fragCoord);\n    \n    const int ans0 = 123;\n    const int ans1 = 456;\n    const int ans2 = 789;\n    \n    int digt = getDigits(f, 3, 1);\n    \n    if(ans0==digt)\n        fragColor = vec4(1,0,0,1);\n    else\n    if(ans1==digt)\n        fragColor = vec4(0,1,0,1);\n    else\n    if(ans2==digt)\n        fragColor = vec4(0,0,1,1);\n    else\n    if(inRange(digt, ans2-5, ans2+5))\n        fragColor = vec4(1,1,0,1);\n    else\n    fragColor = vec4(f*.0125);\n    \n    fragColor = pow(fragColor,vec4(.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2yRV.jpg", "access": "api", "license": "mit", "functions": [[0, 115, 136, 136, 253], [255, 255, 300, 622, 844], [846, 846, 891, 891, 924], [926, 926, 965, 965, 998], [1000, 1000, 1056, 1056, 1621]], "test": "ok"}
{"id": "ctSyRV", "name": "Fork Pixel Flame", "author": "Blindman67", "description": "Fork of \"Simple flame shader\" with some tweeks to center flame and enhance darker parts of flame.  Also removed most bad coding habits from code (0.0 for floats not 0. or .0 and delimit all code blocks with {}, when practical multiply rather than divide)", "tags": ["voronoi", "flame", "perlin", "pixelart"], "likes": 8, "viewed": 202, "published": 3, "date": "1691974509", "time_retrieved": "2024-07-30T17:39:23.709550", "image_code": "#define TIME_RATE 1.25\n#define PIXEL_SIZE 8.0\n#define PIXEL_RES iResolution.y / PIXEL_SIZE\n/* CHAOS float must be > 0.0. Larger values have more chaotic flame, smaller creates more regular flame */\n#define CHAOS 0.8\n/* From dark to light */\n#define FLAME_COL_1 vec3(0.769, 0.153, 0.153)\n#define FLAME_COL_2 vec3(0.886, 0.345, 0.133)\n#define FLAME_COL_3 vec3(0.914, 0.475, 0.102)\n#define FLAME_COL_4 vec3(0.945, 0.604, 0.067)\n#define FLAME_COL_5 vec3(0.973, 0.729, 0.035)\n#define FLAME_COL_6 vec3(1.0,   0.85,   0.4)  \n/* Flame noise thresholds */\n#define FLAME_THRES_1 0.000001 \n#define FLAME_THRES_2 0.01\n#define FLAME_THRES_3 0.3\n#define FLAME_THRES_4 0.6\n#define FLAME_THRES_5 0.8\n#define FLAME_THRES_6 0.95\n\n\nfloat Step(float a, float threshold) { return (a < threshold) ? 0.0 : 1.0; }\nvec4 MixAlpha(vec4 a, vec4 b) { return mix(a, b, b.a); }\nfloat Noise21(vec2 uv) {\n    const int w = 64;\n    const int s = 32;\n    int a = int(uv.x);\n    int b = int(uv.y);\n    a *= 3284157443; \n    b ^= a << s | a >> w - s;\n    b *= 1911520717; \n    a ^= b << s | b >> w - s;\n    a *= 2048419325;\n    float rand = float(a) * (3.14159265 / float(~(~0u >> 1)));\n    return cos(rand) * 0.5 + 0.5;\n}\nvec2 Noise22(vec2 uv) {\n    vec3 a = fract(uv.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\nfloat SmoothNoise(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    float tl = Noise21(id + vec2(0, 1)); \n    float bl = Noise21(id);              \n    float tr = Noise21(id + vec2(1, 1)); \n    float br = Noise21(id + vec2(1, 0)); \n    float t = mix(tl, tr, lv.x); \n    float b = mix(bl, br, lv.x); \n    return mix(b, t, lv.y);\n}\nfloat LayerNoise(vec2 uv) {\n    float result = 0.0;\n    float delta = 0.0;\n    float freq = 10.0; \n    float amp = 1.0;  \n    for (float i = 0.0; i < 4.0; i++) {\n        result += SmoothNoise(uv * freq) * amp;\n        delta += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return result / delta;\n}\nfloat VoronoiNoise(vec2 uv, float t) {\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv) - 0.5;\n    float minDist = 100.0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            vec2 offs = vec2(x, y);\n            vec2 n = Noise22(id + offs);\n            vec2 p = offs + sin(n * t) * 0.5;\n            float d = length(lv - p);\n            minDist = min(minDist, d);\n        }\n    }\n    return smoothstep(0.0, 1.0, minDist);\n}\nvec4 FlameLayer(vec2 uv, vec3 col, float threshold) {\n    float t = iTime * TIME_RATE;\n    float fromCenter = abs(uv.x);\n    uv.y = 1.0 - pow(1.0 - uv.y, 1.1 + sin(iTime * (pow(fromCenter, 4.0) * 0.00325)));\n    float layerNoise = LayerNoise(uv + vec2(0.25, -0.5) * t);\n    float voronoiNoise = VoronoiNoise(uv * 3.0 + vec2(0.0, -0.25) * t, t);\n    float res = layerNoise;\n    res *= mix(res, voronoiNoise, 0.7);\n    res = pow(res, 0.8);\n    res *= pow(1.0 - fromCenter, 5.0);\n    res = smoothstep(res, 0.0, uv.y);\n    res = Step(res, threshold);\n    return vec4(col, res);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv.y += 0.5; \n    uv -= mod(uv, 1.0 / vec2(PIXEL_RES));    \n    vec4 col;\n    col =       MixAlpha(vec4(0), FlameLayer(uv, FLAME_COL_1, FLAME_THRES_1));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_2, FLAME_THRES_2));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_3, FLAME_THRES_3));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_4, FLAME_THRES_4));\n    col =       MixAlpha(col,     FlameLayer(uv, FLAME_COL_5, FLAME_THRES_5));\n    fragColor = MixAlpha(col,     FlameLayer(uv, FLAME_COL_6, FLAME_THRES_6));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[713, 713, 751, 751, 789], [790, 790, 821, 821, 846], [847, 847, 871, 871, 1185], [1186, 1186, 1209, 1209, 1344], [1345, 1345, 1373, 1373, 1726], [1727, 1727, 1754, 1754, 2034], [2035, 2035, 2073, 2073, 2504], [2505, 2505, 2558, 2558, 3080], [3081, 3081, 3137, 3137, 3757]], "test": "untested"}
{"id": "DlBczK", "name": "Image Transition Mosaic", "author": "alphardex", "description": "Use mouse to drag the transition.", "tags": ["transition"], "likes": 2, "viewed": 235, "published": 3, "date": "1691973707", "time_retrieved": "2024-07-30T17:39:24.485475", "image_code": "vec4 getFromColor(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec4 getToColor(vec2 uv){\n    return texture(iChannel1,uv);\n}\n\nfloat random(vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec4 transition(vec2 uv){\n    float progress=iMouse.x/iResolution.x;\n    \n    float ratio=iResolution.x/iResolution.y;\n    \n    vec2 p=uv;\n    p.x*=ratio;\n    \n    float d=random(floor(p*vec2(20.,20.)));\n    \n    float s=.5;\n    \n    return mix(\n        getFromColor(uv),\n        getToColor(uv),\n        smoothstep(0.,-s,d-progress*(1.+s))\n    );\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    vec4 col=transition(uv);\n    \n    fragColor=col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 63], [65, 65, 90, 90, 126], [128, 128, 151, 151, 217], [219, 219, 244, 244, 567], [569, 569, 623, 623, 721]], "test": "untested"}
{"id": "DlBcRK", "name": "Slanted Line Illusion [127]", "author": "SnoopethDuckDuck", "description": "replacing U.y with log(length(U)), length(U), U.x etc. also interesting", "tags": ["opticalillusion", "golf"], "likes": 12, "viewed": 160, "published": 3, "date": "1691966093", "time_retrieved": "2024-07-30T17:39:25.339193", "image_code": "// (seperately)\n// -4 thanks to Fabrice 🦕\n// -6 thanks to coyote  🦕\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U += U - (O.xy=iResolution.xy);\n    O = fract(iTime - dot(acos(U/=O.y), 1e-3/U) + U.yyyy) - .5;\n    O = exp(-8.*O*O);\n}\n\n// Original [133]\n/*\nvoid mainImage( out vec4 O, vec2 U )\n{\n    //U = (U+U-(U=iResolution.xy))/U.y;\n    vec2 R = iResolution.xy;\n    U = (U+U-R)/R.y;\n    O = 0.*O + fract(U.y - dot(1e-3/U, acos(U)) + iTime) - .5;        \n    O = exp(-8.*O*O);\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 74, 112, 112, 236]], "test": "untested"}
{"id": "mtjyDw", "name": "1D Continuous Function Graphing", "author": "beans_please", "description": "Basically sample points on the function and connect them with line segments", "tags": ["2d", "graph", "plot", "plotting", "graphs"], "likes": 6, "viewed": 131, "published": 3, "date": "1691962447", "time_retrieved": "2024-07-30T17:39:26.129081", "image_code": "/************************/\n/*                      */\n/*  YOUR FUNCTION HERE  */\n/*                      */\n/************************/\nfloat f(float x)\n{\n    return .6 * sin(4. * x + iTime * 3.) * exp(-x * .25);\n}\n\n\n\nconst float zoom = 2.8;  // Zoom-out\nfloat px2uv;             // Pixel to UV conversion factor (defined in main)\nfloat max_thickness;     // Line thickness (defined in main)\n\nfloat dist_f(vec2 p)\n{\n    // We have a line between every something pixels.\n    // The line vertices lie on f(x).\n    int n = int(.5 * iResolution.x);\n    \n    // Total horizontal length of the lines (screen length in UV)\n    float total_len = iResolution.x * px2uv;\n    \n    // Distance between the line vertices (in UV)\n    float step_size = total_len / float(n);\n    \n    // Index range of the lines which we want to check\n    int idx0 = int(floor((p.x - max(max_thickness, step_size)) / step_size));\n    int idx1 = int(floor((p.x + max(max_thickness, step_size)) / step_size));\n    \n    // Initial distance\n    float dist = 1e9;\n    \n    // Find the minimum distance from the lines we chose\n    for (int i = idx0; i <= idx1; i++)\n    {\n        // Point A of the line segment\n        float ax = float(i) * step_size;\n        float ay = f(ax);\n        \n        // Point B of the line segment\n        float bx = float(i + 1) * step_size;\n        float by = f(bx);\n        \n        // Distance\n        dist = min(dist, sd_segment(p, vec2(ax, ay), vec2(bx, by)));\n    }\n    \n    return dist;\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = px2uv * (frag_coord - iResolution.xy * .5);\n    if (iMouse.z > .2)\n    {\n        uv += px2uv * (abs(iMouse.zw) - iMouse.xy);\n    }\n    \n    // Cartoon paper effect\n    uv += (texture(iChannel0, .4 * uv + vec2(13.4823 * SNAP(iTime, .125), 0.)).xy - .5) * .02;\n    \n    // Render grid\n    vec3 col = vec3(1., .9, 0.72);\n    vec3 col_grid = vec3(0.3, 0.1, 0.065);\n    #if 0\n    {\n        // Snap grid lines to pixels\n        // For this to work you need to disable the paper effect above\n        \n        #define SNAP_PX(X) SNAP(X, px2uv)\n        \n        float d = min(abs(uv.x - SNAP_PX(round(uv.x))), abs(uv.y - SNAP_PX(round(uv.y))));\n        if (d < .5 * px2uv) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - SNAP_PX(round(t.x))), abs(t.y - SNAP_PX(round(t.y))));\n        if (d < .5 * px2uv * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < 1. * px2uv) col = col_grid;\n    }\n    #else\n    {\n        // Don't snap to pixels\n        \n        float d = min(abs(uv.x - round(uv.x)), abs(uv.y - round(uv.y)));\n        if (d < .006) col = mix(col, col_grid, .5);\n        \n        vec2 t = uv * 4.;\n        d = min(abs(t.x - round(t.x)), abs(t.y - round(t.y)));\n        if (d < .006 * 4.) col = mix(col, col_grid, .2);\n        \n        d = min(abs(uv.x), abs(uv.y));\n        if (d < .012) col = col_grid;\n    }\n    #endif\n    \n    // Distance from f(x)\n    float d = dist_f(uv);\n    \n    // Render lines\n    float thick = max_thickness;\n    col = mix(col, vec3(.03, .04, 0.6), smoothstep(thick, thick - px2uv, d));\n    \n    return col;\n}\n\nvoid main_image(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Pixel to UV conversion factor\n    px2uv = 2. * zoom / min(iResolution.x, iResolution.y);\n    \n    // Line thickness\n    max_thickness = .03;\n    \n    // Super-sampling\n    vec3 col = vec3(0);\n    {\n        col += render(frag_coord + vec2(-.25, -.25));\n        col += render(frag_coord + vec2(-.25, +.25));\n        col += render(frag_coord + vec2(+.25, +.25));\n        col += render(frag_coord + vec2(+.25, -.25));\n    }\n    col /= 4.;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define main_image mainImage /* force snake_case */\n\n#define SNAP(X, STEP) ((floor(X / STEP) + .5) * STEP)\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 153, 153, 213], [392, 392, 414, 506, 1485], [1487, 1487, 1517, 1527, 3168], [3170, 3170, 3226, 3263, 3755]], "test": "untested"}
{"id": "dtjczG", "name": "Color Motion Illusion (241 chs)", "author": "fenix", "description": "Reproduction of this illusion. The blocks are all moving at the same constant vertical speed!\n\nhttps://www.reddit.com/r/OpticalIllusionGifs/comments/3a2pk7/squares_moving_at_constant_speeds/", "tags": ["optical", "illusion", "codegolf", "reproduction"], "likes": 12, "viewed": 212, "published": 3, "date": "1691953056", "time_retrieved": "2024-07-30T17:39:27.102478", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Reproduction of this illusion. The blocks are all moving at the same constant speed!\n//  I'm sure I've seen this before and I don't know who invented it, but it seemed like a\n//  fun thing to code golf. Submissions welcome as always!\n//\n//    https://www.reddit.com/r/OpticalIllusionGifs/comments/3a2pk7/squares_moving_at_constant_speeds/\n// ---------------------------------------------------------------------------------------\n\n// From SnoopethDuckDuck: 241 chars! (was 233 before FabriceNeyret2 reported a problem with previous entry)\n//*\n#define R iResolution\nvoid mainImage(out vec4 O, vec2 U)\n{\n    U = (U+U - R.xy) / R.y;\n    O = vec4(fract(U.y * 4.) < .5);\n    \n    float t = abs(mod(iTime, 4.) - 2.);\n    \n    #define B(S) abs(abs(U.x S.4)-.8) < .4 - t * .1\n    \n    O = abs(U.y - t * .75 + .75) < .25 ?\n            B(+) ? vec4(1, .9, .3, 1) :\n            B(-) ? vec4(0, .1, .5, 1) :\n                O : O;\n}\n/**/\n\n// Original: 258 chars\n/*\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec2 R = iResolution.xy, u = (2.* U - R) / R.y;\n    O = vec4(fract(u.y * 4.) < .5);\n    float t = 2. - abs(fract(iTime * .25) * 4. - 2.);\n    \n    #define B(X) abs(u.x - X) < .2 + t * .1\n    O = abs(u.y + t * .75 - .75) < .25 ?\n            B(-1.2) || B( .4) ? vec4(1, .9, .3, 1) :\n            B( -.4) || B(1.2) ? vec4(0, .1, .5, 1) :\n                O : O;\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtjczG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "cl2czy", "name": "simple pointt", "author": "ordii", "description": "p", "tags": ["point"], "likes": 0, "viewed": 106, "published": 3, "date": "1691944581", "time_retrieved": "2024-07-30T17:39:27.983123", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    uv = 2.*uv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 scr = vec3(uv, 0.);\n    vec3 cam = vec3(0.,0.,-2.);\n    vec3 rd = scr - cam;\n    rd = normalize(rd);\n    float bldp = 2.;\n    vec3 pt = vec3(sin(0.2*iTime),cos(0.2*iTime),bldp);\n    \n    float mapp = dot(pt, rd);\n    mapp = smoothstep(bldp - 0.01, bldp, mapp);\n    // Output to screen\n    fragColor = vec4(vec3(mapp),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2czy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 549]], "test": "untested"}
{"id": "DljyRy", "name": "3D Ising Model", "author": "thepinkpanzer", "description": "The Ising Model is a simple model of magnetic materials in which each cell (corresponding to an atom or molecule) has a value of either plus or minus 1, for the direction in which its magnetic field points.", "tags": ["raymarching", "simulation", "volumetric", "cubemap", "physics", "cubemapa"], "likes": 28, "viewed": 383, "published": 3, "date": "1691940408", "time_retrieved": "2024-07-30T17:39:28.949540", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec4 bloom = texture(iChannel1, uv);\n    vec4 raw   = texture(iChannel0, uv);\n    fragColor  = tanh(0.9*bloom + 0.9*raw);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int  dataPage;\n    vec3 worldPos = WorldPosFromCube(fragCoord, rayDir, dataPage);\n    if (dataPage == 1)\n    {\n        float currentSpin  = texture(iChannel0, rayDir).r;\n        float neighbourSum = texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 1, 0, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3(-1, 0, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 1, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0,-1, 0)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 0, 1)), dataPage)).r\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 0,-1)), dataPage)).r;\n        float energy       = J*neighbourSum*currentSpin + H*currentSpin;\n        float energy_flip  = 2.*energy;\n        float energy_rand  = Random(length(worldPos/54.12345 + vec3(1.65546, 0.654323, 0.73243)) + fract(iTime/13.));\n        float flip_rand    = Random(energy_rand);\n        if      (iFrame <= 5)\n        {\n            currentSpin  = sign(flip_rand*2.-1.);\n            if (Random(abs(flip_rand*2.-1.)) < IMPURITYDENSITY)\n            {\n                currentSpin = 0.;\n            }\n        }\n        else if ((exp(-max(0.,energy_flip/T)) > energy_rand) && (flip_rand < DT))\n        {\n            currentSpin *= -1.;\n        }\n        fragColor = vec4(vec3(currentSpin), neighbourSum*currentSpin);\n    }\n    else\n    {\n        fragColor = vec4(1,0,1,0);\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// MARCHING\n#define STEPDIST    1./128.\n#define NUMSTEPS    100\n// BLOOM\n#define BLOOMRADIUS 30.\n#define BLOOMLOD 2.\n// COLORS AND LIGHTING\n#define ABSORPTIVITY 24.\n#define HAZE         0.02\n#define RED   vec4(0.1, 0.5, 1., 0.)\n#define BLUE  vec4( 1., 0.5,0.1, 0.)\n#define WHITE vec4( 1.,  1., 1., 0.)*160.\n// SIMULATION PARAMETERS\n// External field\n#define H  0.\n// Temperature (periodic flashing)\n#define T  (fract(iTime/20.) < 0.05 ? 10. : 2.)\n// Inter-atom alignment strength\n#define J  1.\n// Timestep per frame\n#define DT 0.2\n// Number of cells set to 0 (instead of ±1)\n#define IMPURITYDENSITY 0.\n\nvec3 WorldPosFromCube(vec2 fragCoord, vec3 rayDir, out int dataPage)\n{\n    /*\n    Function to be used (primarily) in Cube A. Converts the fragCoord and ray direction\n    into world position, while storing the Data Page on the side.\n    \n    Note that while the cubemap has 6 faces, there are only 3 data pages as two faces\n    are required to fill out the 128x128x128 cube.\n    */\n    vec3 ard = abs(rayDir);\n    float m  = max(ard.x, max(ard.y, ard.z));\n    int bigCoord = int(fragCoord.x) + 1024*int(fragCoord.y);\n    if      (m ==  rayDir.x)\n    {\n        dataPage = 1;\n    }\n    else if (m ==  rayDir.y)\n    {\n        dataPage = 2;\n    }\n    else if (m ==  rayDir.z)\n    {\n        dataPage = 3;\n    }\n    else if (m == -rayDir.x)\n    {\n        dataPage = 1;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.y)\n    {\n        dataPage = 2;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.z)\n    {\n        dataPage = 3;\n        bigCoord+= 1024*1024;\n    }\n    int x = (bigCoord        )%128;\n    int y = (bigCoord/128    )%128;\n    int z = (bigCoord/128/128)%128; // % is unnecessary but why not\n    return (vec3(x,y,z));\n}\nvec3 RoundWorldPos(vec3 worldPos)\n{\n    worldPos += 0.5;\n    worldPos *= 128.;\n    worldPos  = floor(worldPos);\n    return worldPos;\n}\nvec3 CubeFromWorldPos(vec3 worldPos, int dataPage)\n{\n    /*\n    The inverse of WorldPosFromCube (well, kind of). Converts world position into the\n    ray direction needed to read that voxel (on that Data Page). Not exactly the inverse \n    of WorldPosFromCube in that WPFC uses the frag coords as primary input, while CFWP\n    spits out the ray direction.\n    \n    Note: worldPos is the **ROUNDED** world position.\n    */\n    worldPos = mod(worldPos, 128.);\n    worldPos = floor(worldPos);\n    if (worldPos.x > 127. || worldPos.y > 127. || worldPos.z > 127.\n     || worldPos.x < 0.   || worldPos.y < 0.   || worldPos.z < 0.  )\n    {\n        return vec3(0);\n    }\n    else\n    {\n        int bigCoord = ((int(worldPos.z)*128+int(worldPos.y))*128+int(worldPos.x));\n        bigCoord -= int(worldPos.z+1.) > 64 ?   1024*1024 : 0;\n        dataPage += int(worldPos.z+1.) > 64 ?           3 : 0;\n        dataPage -= 1;\n        vec3 rgVex[6] = vec3[6](vec3( 0, 0,-1),vec3( 1, 0, 0),vec3( 1, 0, 0),vec3( 0, 0, 1),vec3( 1, 0, 0),vec3(-1, 0, 0));\n        vec3 upVex[6] = vec3[6](vec3( 0,-1, 0),vec3( 0, 0, 1),vec3( 0,-1, 0),vec3( 0,-1, 0),vec3( 0, 0,-1),vec3( 0,-1, 0));\n        vec3 fwVex[6] = vec3[6](vec3( 1, 0, 0),vec3( 0, 1, 0),vec3( 0, 0, 1),vec3(-1, 0, 0),vec3( 0,-1, 0),vec3( 0, 0,-1));\n        vec2 uvs      = (vec2(bigCoord % 1024, (bigCoord/1024)%1024) + 0.5)/1024.;\n        uvs           = 2.*uvs - 1.;\n        vec3 rayDir   = (rgVex[dataPage]*uvs.x + upVex[dataPage]*uvs.y);\n        rayDir       += (fwVex[dataPage]);\n        return normalize(rayDir);\n    }\n}\nfloat Random(float seed)\n{\n    seed = fract(seed*(104.643 - seed) + 6.2341);\n    seed = fract(seed*( 42.123 - seed) + 2.8583);\n    seed = fract(seed*( 36.131 - seed) + 1.6235);\n    return seed;\n}", "buffer_a_code": "#define PI      3.1415926\n#define ROTFREQ 0.06\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse  = (iMouse.xy == vec2(0) ? vec4(iResolution.x*(iTime*ROTFREQ), iResolution.y*0.3, 1., 0) : iMouse);\n    float theta = (mouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (mouse.y - iResolution.y / 2.) / iResolution.y * PI*0.55;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition      = -2.*iCameraFwd;\n    \n    float m = 1.2;\n    \n    // Anti-aliasing by randomly jittering the pixel\n    fragCoord += vec2(Random(fract(iTime) + dot(fragCoord, vec2(0.123, 0.215))), Random(fract(iTime) + dot(fragCoord, vec2(.053, 0.253))));\n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    // SORTING FACES\n    float distXP =  (0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYP =  (0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZP =  (0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    float distXM = (-0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYM = (-0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZM = (-0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    vec3 faceList[6] = vec3[6]( vec3( 1,0,0), vec3(0, 1,0), vec3(0,0, 1),\n                                vec3(-1,0,0), vec3(0,-1,0), vec3(0,0,-1));\n\n    float distList[6] = float[6]( distXP, distYP, distZP,\n                                  distXM, distYM, distZM);\n    \n    for (int n = 0; n < 5; n++)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            if (distList[i] > distList[i+1])\n            {\n                vec3 c        = faceList[i];\n                faceList[i]   = faceList[i+1];\n                faceList[i+1] = c;\n                \n                float r       = distList[i];\n                distList[i]   = distList[i+1];\n                distList[i+1] = r;\n            }\n        }\n    }\n    \n    // MARCH!\n    fragColor   = vec4(0);\n    vec4 absorb = vec4(1);\n    if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n    {\n        vec3 pos = iCameraPosition + distList[2]*iViewDirection;\n        vec3 dir = refract(iViewDirection, faceList[2], 0.7);\n        for (int n = 0; n < NUMSTEPS; n++)\n        {\n            vec3 samplePos = pos + dir*STEPDIST*Random(pos.x + fract(iTime/13.));\n            vec4 sampleVal = texture(iChannel0, CubeFromWorldPos(RoundWorldPos(samplePos), 1));\n            vec4 color     = sampleVal.r > 0. ? RED : BLUE;\n            vec4 glow      = ((J > 0. ? (0.5 - sampleVal.a/12.) : (sampleVal.a/12. + 0.5))*WHITE + HAZE*ABSORPTIVITY)*STEPDIST;\n            absorb        *= exp(-color*ABSORPTIVITY*STEPDIST);\n            fragColor     += glow*absorb;\n            pos           += dir*STEPDIST;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS; x < BLOOMRADIUS+1.; x++)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*textureLod(iChannel0, (fragCoord + vec2(1,0)*(x*BLOOMLOD))/iResolution.xy, (BLOOMLOD));\n    }\n    fragColor /= BLOOMRADIUS;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS; x < BLOOMRADIUS+1.; x++)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*textureLod(iChannel0, (fragCoord + vec2(0,1)*(x*BLOOMLOD))/iResolution.xy, (BLOOMLOD));\n    }\n    fragColor /= BLOOMRADIUS;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DljyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 300]], "test": "untested"}
{"id": "DlScRG", "name": "dft͏ (Warning: Flashing lights)", "author": "01000001", "description": "Learning how to do discrete fourier transform, compared with builtin. Mine is on the bottom.\n\nShadertoy's scaliing of the FFT and colour space is weird but I tried to match it with a weird transformation... it works.", "tags": ["fourier", "discrete", "transform", "dft"], "likes": 8, "viewed": 181, "published": 3, "date": "1691937528", "time_retrieved": "2024-07-30T17:39:29.721475", "image_code": "// Convert brightness values from buffer B to nice colours\n\nvec4 green(float x){\n    return vec4(0.1 * (x-1.), 0.3*x*x, x*.05, 0);\n}\n\nvec4 blue(float x){\n    return vec4(0, x*x*.2, x, 0);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec4 tex = texture(iChannel0, U/r);\n    O = green(tex.x) + blue(tex.y);\n    O = pow(O, vec4(1./2.4));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float pi = 3.14159256;\nconst float temporalBlend = 0.75;\n\n// A few things you can try.\n\n// https://soundcloud.com/ehrling/ehrling-sthlm-sunset\n// https://soundcloud.com/3kliksphilip/under-the-pizza\n// https://soundcloud.com/nyanara/for-a-moment-i-was-there-1?in=spacelady87/sets/various-ambient-chill-lt-dub\n// https://soundcloud.com/symphonicsamples/cornfield-chase-hans-zimmer-midi-mockup\n// https://soundcloud.com/dainumo/prokofiev-space-transmission-download-in-description \n// ^ This one is pretty cool at the start\n// Default shadertoy tracks\n\n\n// Note: You may need to adjust the coefficient at line 55\n//       to make different tracks line up.\n\n\nfloat dft(float x)\n{\n    float c=0.,s=c;\n    vec2 r = iResolution.xy;\n\n    for(float i = 0.; i < 1.; i += 1./r.x){\n    \n        s += (sin(i * x * 2. * pi)\n            * ((texture(iChannel0, vec2(i, 1)).x)*2.-1.)) / sqrt(r.x);\n        c += (cos(i * x * 2. * pi) \n            * ((texture(iChannel0, vec2(i, 1)).x)*2.-1.)) / sqrt(r.x);\n    }\n    //return smoothstep(r.x / 30., r.x / 5., x)*20.;\n    return max(0., length(vec2(s, c))\n    *mix(log(x), sqrt(x)*pi/2., smoothstep(r.x / 30., r.x / 5., x))\n    // This multiplication is SO weird, but it works to create a similar result to the builtin\n    // And no, I cannot explain why it works.\n    -0.025);//This subtraction is a nasty hack but it clears up the visualizer a ton\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (U.y > 3.) return;\n    \n    float wave = texture(iChannel0, vec2(uv.x, 1)).x * 2. - 1.;\n    float fft = texture(iChannel0, vec2(uv.x, 0)).x;\n    \n    if (U.y == 0.5){\n        O.x = wave;\n        // Waveform output bottom pixel row\n    } else if (U.y == 1.5) {\n        O.x = texture(iChannel0, vec2(uv.x, 0)).x;\n        // Shadertoy FFT output\n    } else if (U.y == 2.5) {\n        O.x = mix(dft(uv.x*128.), texture(iChannel1, uv).x, temporalBlend);\n        // My DFT output\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34501, "src": "https://soundcloud.com/anicator/the-march-of-the-mountains", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// Visualize data\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float wave = texture(iChannel0, vec2(uv.x, 0)).x;\n    float fft = texture(iChannel0, vec2(uv.x, 1.5/r.y)).x;\n    float dft = texture(iChannel0, vec2(uv.x, 2.5/r.y)).x;\n\n    O.x = mix(fft, \n        //*\n        dft,\n        /*/\n        pow(abs((pow(dft, 0.25)-.25)-.1), 0.8), // this is if not using *x on return in dft function\n        //*/\n        smoothstep(.55,.45, uv.y - wave/3.)\n    );\n\n    O.y = abs(0.03/((wave - (uv.y-.5)*3.)));\n\n\n    //if (U.y == 0.5) O = vec4(wave);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlScRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 80, 80, 132], [134, 134, 153, 153, 189], [191, 191, 232, 232, 369]], "test": "untested"}
{"id": "mlBczy", "name": "Wind Waves 3D", "author": "gehtsiegarnixan", "description": "This is a 3D material using Directional Flow with a novel Tiling method that allows me to half the performance cost. It is also great at visualizing vector fields as a wind wave", "tags": ["3d", "waves", "cheap", "tiling", "flowmap", "wind", "vectorfield", "rhombicdodecahedron"], "likes": 8, "viewed": 279, "published": 3, "date": "1691932972", "time_retrieved": "2024-07-30T17:39:30.565220", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis 3D material leverages Directional Flow with an innovative tiling technique, \neffectively reducing performance costs by half. The shader employs 4 Rhombic \nDodecahedron grid tiles for optimized sampling of 4 points in space, achieving \nTrilinear interpolation quality with only 4 samples. Importantly, as a 3D \nmaterial rather than a projected 2D material, it remains distortion-free across \nany surface.\n\nThis implementation also serves as a valuable tool for visualizing 3D vector \nfields on a surface, evoking the appearance of wind waves where vector direction \naligns perpendicular to the displayed wave. The current vector field originates \nfrom sampling a noise texture.\n\nFor a standalone quadripel Rhombic Dodecahedron Tiling technique, please visit:\nhttps://www.shadertoy.com/view/fddfRn\n\nFor a 2D variant of wind waves employing 3 samples see:\nhttps://www.shadertoy.com/view/7ddBWl\n*/\n\n// highlight the blend regions. Comment to hide\n//#define SHOWBLEND // it also helps reducing the gridscale a bit\n#define LINETHICKNESS 0.01\n\n#define GRIDSCALE 6.0\n// 1 for no contrast between samples, higher values for increased contrast\n#define CONTRAST 1.0\n\n#define twoPi           6.2831853072\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\nvec2 rohmSinWave(vec3 uvw, vec3 offset, float gridRes, float time) {\n    // generate grid\n    tilingVal3D cell = rohmCell(uvw, offset, gridRes);\n\n    // Sample vector field/flow map\n    vec3 noise = texture(iChannel0, cell.id * 0.07).xyz;\n    vec3 flowMap = noise * 2.0 - 1.0; // Scale to -1 to 1\n    float vectorScale = 1.0;\n    flowMap *= vectorScale;\n    \n    // kind of arbitrarily chosen for what looks nice\n    float speed = length(flowMap); // Wind Speed \n    //speed = sqrt(speed); // make distribution nicer\n    vec3 dir = normalize(flowMap); // Wind Direction\n    float k = twoPi / speed; //Wave Number\n    time *= speed;\n    float amplitude = speed;   \n    \n    // scale grid to make sure largest waves are still smaller than grid\n    cell.grid *= 8.0;\n    \n    float dD = dot(cell.grid,dir); //Directional/Straight Wave\n    float wave = sin(k * (dD - time))*.5+.5; // make sin wave\n    wave *= amplitude; // apply amplitude\n\n    return vec2(wave, cell.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast, float time) {\n    vec2 a = rohmSinWave(uvw, vec3( .0, .0, .0), gridRes, time);\n    vec2 b = rohmSinWave(uvw, vec3( .5, .0, qurt_sqrt2), gridRes, time);\n    vec2 c = rohmSinWave(uvw, vec3( .0, .5, qurt_sqrt2), gridRes, time);\n    vec2 d = rohmSinWave(uvw, vec3( .0, .0, half_sqrt2), gridRes, time);\n           \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.y, b.y, c.y, d.y), contrast);\n        \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = vec3(a.x * alpha.x + b.x * alpha.y + c.x * alpha.z + d.x * alpha.w);\n\n#ifdef SHOWBLEND\n    // the edges of the alpha mask blending\n    vec4 blend = step(abs(alpha - 0.1), vec4(LINETHICKNESS));\n    col = max(max(blend.xyz,vec3(blend.w)), col);\n#else\n    // cell shading\n    float levels = 3.;\n    //col =  round(col*levels)/levels;\n    \n    col = PuBu_r(col.x); // apply colormap for blueish colors\n#endif\n    return col;\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx = mm2(iTime*.1+um.x*5.);\n    mat2 my = mm2(iTime*0.05+um.y*5.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec2 t = iSphere(ro,rd);\n    \n    vec3 colorA;\n    if (t.x > 0.) {\n    \tvec3 pos = ro+rd*t.x;\n        // Sphere mapping\n    \tcolorA = quadGrid(pos, GRIDSCALE, CONTRAST, iTime *1.0);\n        colorA *= 1.1;\n    }\n    \n    // Background mapping\n    vec3 colorB = quadGrid(rd, GRIDSCALE, CONTRAST, iTime *1.0)*0.6;\n    \n    // Smooth blending of ball with background\n    vec3 color = mix(colorA, colorB, smoothstep(0.02, 0.0, t.y));\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_____________________GENERIC FUNCTIONS______________________________\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n// makes PuBu_r colormap with polynimal 6\nvec3 PuBu_r(float t) {\n    const vec3 c0 = vec3(-0.006363,0.212872,0.336555);\n    const vec3 c1 = vec3(1.081919,1.510170,1.985891);\n    const vec3 c2 = vec3(-14.783872,-6.062404,-2.068039);\n    const vec3 c3 = vec3(71.020484,24.455925,-4.350981);\n    const vec3 c4 = vec3(-127.620020,-46.977973,14.599012);\n    const vec3 c5 = vec3(101.930678,41.789097,-14.293631);\n    const vec3 c6 = vec3(-30.634205,-13.967854,4.778537);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlBczy.jpg", "access": "api", "license": "mit", "functions": [[2417, 2466, 2490, 2490, 2737], [2739, 2769, 2801, 2801, 3209], [3211, 3261, 3321, 3321, 3525], [3527, 3527, 3595, 3616, 4500], [4502, 4581, 4649, 4649, 5556], [5703, 5703, 5724, 5724, 5776], [5778, 5778, 5816, 5816, 5986], [5988, 5988, 6045, 6045, 6910]], "test": "untested"}
{"id": "mlByzG", "name": " [2023 Demodulation] \t大龙猫 - Блоб", "author": "totetmatt", "description": "My entry to Demodulation Shader Showbattle ", "tags": ["shadershowdown"], "likes": 21, "viewed": 329, "published": 3, "date": "1691911990", "time_retrieved": "2024-07-30T17:39:31.491742", "image_code": "#define fGlobalTime iTime\nvec3 pal(float t){return .5+.5*cos(6.28*(t+vec3(0,.3,.7)));}\nfloat diam2(vec2 p,float s){p=abs(p);return (p.x+p.y-s)*inversesqrt(3.);}\nfloat timer ;\nfloat bpm ;\nvec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\nfloat tru(vec3 p){\n  \n     vec3 id = floor(p)+.5;\n     vec3 gv = p-id;\n      gv.x  *= fract(452.6*sin(dot(id,vec3(452.5,985.5,487.56)))) > .5 ? -1.:1. ;\n    gv.xz-=.5 * (gv.x >-gv.z ? 1. :-1.);\n      return max(abs(gv.y)-.05,abs(diam2(gv.xz,.5)*4.)-.05);\n  }\n vec3 path(float t){\n   \n     vec3 o=vec3(0);\n     o.x+=asin(sin(t*.45))*.5;\n    o.x+=asin(cos(t*.75))*.45;\n    o.y+=asin(cos(t*.95))*.33;\n    o.y+=asin(sin(t*.35))*.44;\n   return o;\n   }\nvec2 sdf(vec3 p){\n   vec2 h;\n   vec3 hp=p;\n  hp.z -=timer;\n   hp+=path(floor((hp.z*.025+.5))+timer);\n   h.x = length(hp)-1.-.2*mix(0.,dot(sin(hp+fGlobalTime),cos(hp.zxy*5.)),tanh(sin(bpm+fGlobalTime)*10.)*.5+.5);;\n  h.y =1.;\n  \n    vec2 t;\n    vec3 tp=p;\n    tp+=path(tp.z);\n     tp/=4.;\n    t.x = min(tru(tp.zxy),min(tru(tp),tru(tp.yzx)));\n    t.y= 2.;\n    h=t.x < h.x ? t:h;\n  return h;\n  }\n  #define q(s) s*sdf(p+s).x\n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float rnd = float(((floatBitsToInt(uv.x)*floatBitsToInt(fragCoord.y)) ^ (floatBitsToInt(uv.y)*floatBitsToInt(fragCoord.x))))/2.19e9;\n   \n \n  bpm = floor(fGlobalTime*115./60.)+ fract(fGlobalTime*115./60.);\n   bpm +=rnd*.1;\n  bpm = floor(bpm)+smoothstep(.0,1.,pow(fract(bpm),.4));  timer +=fGlobalTime+bpm;\nvec3 col = vec3(0.);\n   vec2 puv = uv* fragCoord.x / iResolution.x;\n    puv +=.5;\n     \n    // float q = texelFetch(iChannel0,ivec2(puv.x*50.),0).r;\n    // Shadertoy version as Bonzomatic FFT is quite different\n    // Also no smoothing of FFT so quite flikering bars)\n    float q = texture(iChannel0,fract(floor(puv.xx*10.)/10.)).r*.0225;\n  float st ;\n  col+=sqrt((st=step(-(abs(uv.y)-.5),sqrt(q)))*sqrt(q));\n    if(st>.00) uv*=(1.+sqrt(q)*5.);\n    vec3 ro=vec3(0,0,-5),rt=vec3(0);\n  ro = erot(ro,vec3(0.,1.,0),bpm*.1);\n  ro.z +=timer-tanh(cos(bpm)*5.);\n   \n  ro+=path(ro.z)*2.;\n  rt.z+=timer;\n   rt+=path(ro.z);\n    vec3 z=normalize(rt-ro),x=normalize(cross(z,vec3(0.,-1.,0))),y=cross(z,x);\n    vec3 rd=mat3(x,y,z)*normalize(vec3(uv,1.+.5*tanh(sin(bpm)*5.)));\n    vec3 rp=ro;\n    vec3 light = vec3(1.,2.,-3.+timer);\n  vec3 acc=vec3(0.);\n    for(float i=0.;i++<128.;){\n      \n         vec2 d = sdf(rp);\n         if(d.y==2.){\n              acc+=vec3(.03,.04,.05)*exp(10.*-abs(d.x))/(20.-19.*exp(-3.*fract(fGlobalTime+rp.z)));\n              d.x = max(.001,abs(d.x));\n              \n           }\n         rp+=rd*d.x;\n         if(d.x <  .001){\n           \n             vec3 n = norm(rp,.001);\n             vec3 nl=  normalize(light-rp);\n              float dif = max(0.,dot(nl,n));\n              float spc = pow(max(0.,dot(rd,reflect(nl,n))),16.); \n             col = vec3(.75)*dif + spc;\n           \n           if(d.y==1.){\n               col=col*(col);\n               rd= reflect(rd,n);\n               rp+=rd*.1;\n              continue;\n             }\n             break;\n           }\n      }\n  \n  \n    // Output to screen\n    fragColor  = vec4(sqrt(col+acc),1.);\n}", "image_inputs": [{"id": 34415, "src": "https://soundcloud.com/pornouzi/porno-uzi-endogenous-mushrooms", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlByzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 86], [87, 87, 115, 115, 160], [187, 187, 221, 221, 275], [276, 276, 294, 294, 534], [536, 536, 555, 555, 722], [723, 723, 740, 740, 1115], [1146, 1146, 1173, 1173, 1248], [1249, 1249, 1306, 1356, 3389]], "test": "untested"}
{"id": "dlScRG", "name": "Julia fractal animated", "author": "tovaris", "description": "Animated (julia constant) julia fractal", "tags": ["fractal", "julia", "animated", "juliafractal"], "likes": 1, "viewed": 152, "published": 3, "date": "1691911139", "time_retrieved": "2024-07-30T17:39:32.354436", "image_code": "#define MAX_ITER 2000\n#define ESCAPE_RADIUS 999999.0\n#define PI 3.14159265359\n\n#define xmin -2.5\n#define xmax 2.5\n#define ymin -1.5\n#define ymax 1.5\n\nvec2 c_mul(in vec2 a, in vec2 b) {\n   return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n\nfloat escape(in vec2 coord, in vec2 c) {\n    \n    vec2 z = vec2(coord);\n    for (int i = 0; i < MAX_ITER; ++i) {\n        z = c_mul(z, z) + c;\n        \n        if (length(z) > ESCAPE_RADIUS) {\n        \n            float v = float(i) / float(MAX_ITER);\n            v = 2.0 / (1.0 + exp(-300.0 * v)) - 1.0;\n            return v;\n        }\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 maxs = vec2(xmax, ymax);\n    vec2 mins = vec2(xmin, ymin);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Map to user defined range\n    uv = uv * (maxs - mins) + mins;\n\n    float cReal = noise(vec2(-0.5251993, -0.5251993) * iTime * 0.3);\n    float cImag = noise(vec2(-0.4, 0.6) * iTime * 0.3);\n    vec2 c = vec2(cReal, cImag) * 2.0 - 1.0;\n    float blue = escape(uv, c);\n    \n    vec3 color = vec3(1.0, 0.0, 0.0);\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(0.0, 0.0, blue), 1.0);\n}", "image_inputs": [], "common_code": "// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlScRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 184, 184, 248], [251, 251, 291, 291, 610], [612, 612, 669, 669, 1229]], "test": "untested"}
{"id": "ml2yzW", "name": "Projected Spherical Cap sampling", "author": "KylBlz", "description": "This isn't the most efficient or complete implementation, but it was fun!\nhere's a desmos link https://www.desmos.com/calculator/cf3yvyqum1", "tags": ["sampling", "spherical", "projected", "cap", "psc"], "likes": 7, "viewed": 227, "published": 3, "date": "1691899452", "time_retrieved": "2024-07-30T17:39:33.225108", "image_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    float ving = 1.1 - sqrt(dot(ndc, ndc) * 0.4);\n    fragColor = texture(iChannel0, uv);\n    fragColor.rgb = linear_srgb(ACESFitted(ving * fragColor.rgb / fragColor.a));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // rng\n    ivec2 fc = ivec2(fragCoord);\n    int seed = (fc.x + fc.y*2 + iFrame*53685) + (fc.x*43977 ^ fc.y*36025);\n    // camera stuff\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    float asp = iResolution.x / iResolution.y;\n    ndc.x *= asp;\n    vec3 ro = vec3(0.0, 0.5, -5.0);\n    vec3 rd = normalize(vec3(ndc, 2.0));\n\n    // update scene\n    vec2 rnd = weyl2(seed) - 0.5;\n    float time = (iTime + (rnd.x + rnd.y) * iTimeDelta) * 0.5;\n    light.x = -2.0 * sin(time);\n    light.z = -2.0 * cos(time);\n    \n    // render psc sample\n    mat4 precomp = psc_precomp(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), light);\n    smp = psc(precomp, int(floor(iTime*5.0)));\n    \n    vec4 h = raymarch(ro, rd);\n    vec4 nc = norcurv(h.xyz, eps);\n \n    fragColor = texture(iChannel0, uv) * 0.5;\n    \n    vec3 lc = light.xyz - ro;\n    float lcd = sqrt(dot(lc, lc));\n    lc /= lcd;\n    \n    vec3 lh = light.xyz - h.xyz;\n    float lhd = dot(lh, lh);\n    lh /= sqrt(lhd);\n    \n    // flair\n    fragColor.rgb += lightCol.rgb * pow(max(eps, dot(lc, rd)), 5.0*(lcd*lcd)/(light.w*light.w));\n\n    // hit nothing\n    if (h.w > 100.0) {\n        fragColor += vec4(skyCol * max(eps, rd.y), 1.0);\n        return;\n    }\n    // hit light\n    if (abs(lhd - light.w*light.w) < 0.01) {\n        fragColor += vec4(lightCol, 1.0);\n        //return;\n    }\n    \n    vec3 rfl = reflect(rd, nc.xyz);\n    float sch = Schlick(nc.xyz, rfl, 1.0, 2.0);\n    float oms = 1.0 - sch;\n\n    skyCol *= max(eps, rfl.y);\n\n    // skybox reflection\n    fragColor.rgb += sch*skyCol;\n\n    vec3 ro2 = h.xyz + nc.xyz * 0.001;\n    vec3 final = vec3(0.0);\n    precomp = psc_precomp(ro2, nc.xyz, light);\n    // sample the precomputed spherical cap a few times\n    for (int i = 0; i < PSC_SAMPLES; ++i) {\n        smp = psc(precomp, i + seed);\n        // specular\n        vec3 hv = normalize(smp.xyz - rd);\n        float spec = pow(max(eps, dot(nc.xyz, hv)), 128.0);\n        // trace light\n        vec4 h2 = raymarch(ro2, smp.xyz);\n        float hitlit = float(distance(h2.xyz, light.xyz) - light.w < 0.01);\n        // psc lambert, blinn phong specular\n        final += (sch*spec + oms*smp.w*materialCol) * hitlit*lightCol.rgb;\n    }\n    fragColor.rgb += final / float(PSC_SAMPLES);\n    fragColor.a += 1.0;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int PSC_SAMPLES = 4;\n\nfloat zfar = 1000.0;\nfloat eps = 0.001;\nfloat ieps = 0.999;\nfloat PI = 3.1415926;\n\nvec3 skyCol = vec3(0.2, 0.3, 0.4);\n// xyz rad\nvec4 light = vec4(0.0, 2.0, 0.0, 0.5);\nvec3 lightCol = vec3(4.0, 3.0, 2.0);\nvec3 materialCol = vec3(0.8);\n// xyz pdf\nvec4 smp = vec4(0.0, 1.0, 0.0, 0.0);\n\n// r2 sequence using 16 bit integers\nvec2 weyl2(in int v) {\n    return fract(vec2(v*ivec2(49471, 37345)) / float(0xffffU));\n}\n\n// https://pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations\nvec2 concentric(in vec2 v) {\n    vec2 w = v * 2.0 - 1.0;\n    float thta, rad;\n    if (abs(w.x) > abs(w.y)) {\n        rad = w.x;\n        thta = PI/4.0 * (w.y/w.x);\n    } else {\n        rad = w.y;\n        thta = PI/2.0 - PI/4.0 * (w.x/w.y);\n    }\n    return rad * vec2(cos(thta), sin(thta));\n}\n\nmat4 psc_precomp(in vec3 l, in vec3 n, in vec4 s) {\n    mat4 ret = mat4(0.0);\n    \n    vec3 sl = s.xyz - l.xyz;\n    // +y is normal vec\n    float Y = dot(sl, n);\n    vec3 Ybasis = n;\n    // +x is plane tangent vec towards light\n    vec3 Xbasis = sl - Y * Ybasis;\n    float X = max(eps, sqrt(dot(Xbasis, Xbasis)));\n    Xbasis /= X;\n    // by definition Z is zero\n    vec3 Zbasis = cross(Xbasis, Ybasis);\n    // distance to light\n    float d = 1.0 / sqrt(X*X + Y*Y);\n    // light direction and size on unit circle\n    vec3 sln = sl * d;\n    float swn = s.w * d;\n    float pdf = PI * swn * swn;\n    // angle to light +/- half angle\n    float va = asin(clamp(swn, eps, ieps));\n    float vi = atan(Y / X);\n    // x range on unit disk\n    float x1 = cos(clamp(vi - va, eps, PI));\n    float x2 = cos(clamp(vi + va, eps, PI));\n    float xr = x1 - x2;\n    // one dimension simplifies away\n    vi = PI * 0.5;\n    // z range on unit disk\n    float y1 = cos(clamp(vi - va, eps, PI));\n    float y2 = cos(clamp(vi + va, eps, PI));\n    float yr = y1 - y2;\n\n    ret[0] = vec4(Xbasis, X);\n    ret[1] = vec4(Ybasis, Y);\n    ret[2] = vec4(Zbasis, pdf * (xr/yr));\n    ret[3] = vec4(xr, yr, x2, y2);\n    return ret;\n}\n\nvec4 psc(mat4 precomp, in int i) {\n    // disk in range [0, 1]\n    vec2 cw2 = concentric(weyl2(i)) * 0.5 + 0.5;\n    // in range [xz1 to xz2]\n    cw2 = cw2 * precomp[3].xy + precomp[3].zw;\n    // project up onto unit circle\n    vec3 pc3 = vec3(cw2.x, sqrt(max(eps, 1.0 - cw2.x*cw2.x - cw2.y*cw2.y)), cw2.y);\n    return vec4(\n        // back to world space using basis vecs\n        mat3(precomp) * pc3,\n        // pdf from earlier\n        precomp[2].w\n    );\n}\n\nfloat Schlick(in vec3 hn, in vec3 rfl, in float r1, in float r2) {\n \tfloat r0 = (r1 - r2) / (r1 + r2);\n    return mix(r0*r0, 1.0, pow(1.0 - max(eps, dot(rfl, hn)), 5.0));\n}\n\nfloat sdf(in vec3 l) {\n    float d = zfar;\n    d = min(d, (l.y));\n    d = min(d, (distance(l, vec3(0.0, 0.0, 0.0)) - 1.0));\n    d = min(d, (distance(l, light.xyz) - light.w));\n    d = min(d, (distance(l, length(l) * normalize(smp.xyz)) - 0.01));\n    return d;\n}\n\nvec4 norcurv(in vec3 p, in float ep) {\n    vec2 e = vec2(-1., 1.)*ep;\n    float t1 = sdf(p + e.yxx), t2 = sdf(p + e.xxy);\n    float t3 = sdf(p + e.xyx), t4 = sdf(p + e.yyy);\n    return vec4(normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4), (t1+t2+t3+t4 - 4.0*sdf(p))/(ep*ep));\n}\n\nvec4 raymarch(in vec3 ro, in vec3 rd) {\n    vec4 l = vec4(ro, 0.0);\n    for (int i = 0; i < 255; i++) {\n        float d = sdf(l.xyz);\n        if (d < eps)\n            return l;\n        l.w += d;\n        l.xyz += rd * d;\n    }\n    return vec4(zfar);\n}\n\n// Thanks Paniq\nvec3 linear_srgb(vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x, vec3(0.0031308)));\n}\n\nvec3 srgb_linear(vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x, vec3(0.04045)));\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(vec3 color) {\n\t// ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color = color * mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color = a / b;\n\t// Back to color space\n    color = color * mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2yzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 56, 56, 305]], "test": "untested"}
{"id": "DtBcRy", "name": "eindacor_ai_psychadelic", "author": "Eindacor_DS", "description": "it was written by ChatGPT-3.5 with some coaching, you dolt!", "tags": ["psychadelic"], "likes": 1, "viewed": 117, "published": 3, "date": "1691893701", "time_retrieved": "2024-07-30T17:39:34.076831", "image_code": "float hash(float n) { return fract(sin(n) * 43758.5453); }\n\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n               mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\nvec3 blendColors(float t, vec3 c1, vec3 c2, vec3 c3) {\n    return mix(mix(c1, c2, t), c3, t);\n}\n\n// Function to generate ocean wave refraction pattern\nfloat waterRefraction(vec2 uv) {\n    float wave1 = 0.5 + 0.5 * sin(uv.x * 10.0 + iTime * 1.5);\n    float wave2 = 0.5 + 0.5 * sin(uv.x * 6.0 + uv.y * 6.0 + iTime * 1.5);\n    float wave3 = 0.5 + 0.5 * sin(uv.y * 12.0 + iTime * 1.0);\n    return (wave1 + wave2 + wave3) / 3.0; // Normalize to the range of 0.5 to 1.0\n}\n\n// Function to generate a wireframe 3D grid\nfloat geometricPattern(vec2 uv, float thickness) {\n    float scale = 10.0;\n    vec2 p = uv * scale;\n    float lines = step(thickness, mod(p.x, 1.0)) + step(thickness, mod(p.y, 1.0));\n    return lines;\n}\n\n// Function to add colorful glittery effect\nvec3 glitteryEffect(vec2 uv, float glitterIntensity) {\n    vec3 glitterColor = vec3(1.0, 1.0, 1.0);\n    float glitter = noise(uv * 50.0 + iTime * 5.0) * glitterIntensity;\n    return glitterColor * glitter;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized coordinates\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // Create a brighter and more pastel color palette with blues and greens\n    vec3 col = 0.5 + 0.5 * cos(iTime + 3.0 + vec3(0, 2, 4)) * vec3(0.3, 0.6, 0.8);\n\n    // Create a dynamic pattern using sine waves and Perlin noise\n    float r = length(p);\n    float stripes = 0.5 * (sin(r * 20.0 - iTime) + 1.0) + 0.5;\n    float waves = 0.5 * (sin(10.0 * r + iTime) + 1.0) + 0.5;\n\n    // Add Perlin noise to the pattern\n    float perlinNoise = 0.5 * noise(p * 5.0 + iTime) + 0.5;\n\n    // Mix colors for the final pattern, and adjust output to the range of 0.5 to 1.0\n    vec3 invertedPattern = mix(col, vec3(1.0), stripes) * waves * perlinNoise * 0.5 + 0.5;\n\n    // Shifting blend of blues, greens, and cyans\n    vec3 blue = vec3(0.2, 0.4, 1.0);\n    vec3 green = vec3(0.4, 1.0, 0.5);\n    vec3 cyan = vec3(0.5, 1.0, 1.0);\n    float blendT = 0.5 + 0.5 * sin(iTime);\n    vec3 otherColor = 0.25 * blendColors(blendT, blue, green, cyan); // Scale down otherColor\n\n    // Mix otherColor with vec3(1.0) using invertedPattern\n    vec3 finalColor = mix(otherColor, vec3(1.0), invertedPattern);\n\n    // Overlay old film burning effect (slowed down and clamped)\n    vec3 burnColor = vec3(1.0, 0.3, 0.1);\n    float burnEffect = mix(0.0, 1.0, sin(iTime * 0.5) * 0.2); // Slow down burn effect\n    finalColor = clamp(finalColor + burnEffect * burnColor, 0.0, 1.0);\n\n    // Generate ocean wave refraction pattern and modify green channel of finalColor\n    float wavePattern = waterRefraction(p);\n    finalColor.g *= wavePattern;\n\n    // Generate wireframe 3D grid with specified thickness and modify blue channel of finalColor\n    float gridPattern = geometricPattern(p, 0.2); // Adjust thickness here\n    finalColor.b *= gridPattern;\n\n    // Add colorful glittery effect\n    vec3 glitter = glitteryEffect(p, 0.2); // Adjust glitter intensity here\n    finalColor += glitter;\n\n    // Output the final color\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBcRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 58], [60, 60, 84, 84, 315], [317, 317, 371, 371, 412], [414, 468, 500, 500, 782], [784, 828, 878, 878, 1030], [1032, 1076, 1130, 1130, 1283], [1285, 1285, 1340, 1370, 3384]], "test": "untested"}
{"id": "ctBcRG", "name": "Cool Fractal [287 Chars]", "author": "SnoopethDuckDuck", "description": "was playing with jarble's shader and got this", "tags": ["fractal", "knot", "arabesque"], "likes": 12, "viewed": 229, "published": 3, "date": "1691879452", "time_retrieved": "2024-07-30T17:39:35.272634", "image_code": "#define T(a) abs(fract(1.5 * (a + 1./vec2(3,2)))-.5)\n\nvoid mainImage( out vec4 O, vec2 U )\n{      \n    vec2 u = (U/iResolution.y + (12.+iTime) * vec2(.1, .04)) / 6e2,\n         v;\n         \n    O = vec4(2,3,3,0);\n    \n    for(float i; i++ < 7.;)\n        u = abs(u + v + .5),      \n        u = u.y > u.x ? u.yx + vec2(0, 1.25)\n                      : u + .15 * u * i,           \n        v = -T(u+.5),\n        u = -abs(v-T(u.yx)),\n        O = .1 + 4. * exp(O * (u.x+u.y));\n    \n    O /= 3.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 92, 92, 489]], "test": "untested"}
{"id": "clScRW", "name": "Advanced Smoke Shader", "author": "Oman395", "description": "Test", "tags": ["test"], "likes": 5, "viewed": 257, "published": 3, "date": "1691878358", "time_retrieved": "2024-07-30T17:39:36.335791", "image_code": "/* Advanced Smoke Shader\nMade by Oran RH\nOman395 on shadertoy and github\n\nThis is based around how I think the CS2 smoke grenade effects work. Inspired by Acerola's work on replicating CS2 smoke grenades (video below but link is long). Relatively\nsimple, essentially the gist is that it figures out each cube that a pixel's ray passes through (and the depth that the ray travels), then adjusts the depth based\non some noise, as well as circularifying it. The bullet effect is achieved by simply adding another depth modifier to the entrance and exit, then adjusting incoming\nlight based on an approximation of the depth into the tube.\n\nTODOS:\nBetter rayBox function\nSupport for more shapes\nBetter lighting\n- Actually implementing mie scattering (or a better approximation)\n- Phong illumination\n - Normal function\n*/\n\n\n// #define SHOW_RAW\n\n// Rotate 3d vector by pitch and yaw. Not ideal but works for the camera\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\n// Rotates camera position about (0,0)\nvec3 camPos(float iTimse, vec2 iMouse) {\n    return rotate(CAM, iMouse * vec2(PI, -PI));\n}\n\n// Get camera pitch and yaw based on mouse position\nvec2 camDir(float iTime, vec2 iMouse) {\n    return iMouse * vec2(PI, -PI);\n}\n\n// Checks if a distance results in a point that is within the bounds of the target square\nbool validateDistance(float dist, vec2 r0, vec2 rd, vec2 boundMin, vec2 boundMax) {\n    vec2 np = dist * rd + r0;\n    vec2 s = step(boundMin, np) - step(boundMax, np);\n    return dist >= 0.0 && s.x * s.y > 0.0;\n}\n\n// horrible rayBox function but oh well lmao\n// Literally just checks for intersection with the 6 sides of a box\nvec2 rayBox(vec3 r0, vec3 rd, vec3 boundMin, vec3 boundMax) {\n    vec3 dMin = boundMin - r0;\n    vec3 dMax = boundMax - r0;\n    float distTop = dMax.y / rd.y;\n    float distBottom = dMin.y / rd.y;\n    float distRight = dMax.x / rd.x;\n    float distLeft = dMin.x / rd.x;\n    float distBack = dMax.z / rd.z;\n    float distFront = dMin.z / rd.z;\n    float minimum = 10000.0;\n    float maximum = 0.0;\n    if(validateDistance(distTop, r0.xz, rd.xz, boundMin.xz, boundMax.xz)) minimum = min(minimum, distTop), maximum = max(maximum, distTop);\n    if(validateDistance(distBottom, r0.xz, rd.xz, boundMin.xz, boundMax.xz)) minimum = min(minimum, distBottom), maximum = max(maximum, distBottom);\n    if(validateDistance(distRight, r0.yz, rd.yz, boundMin.yz, boundMax.yz)) minimum = min(minimum, distRight), maximum = max(maximum, distRight);\n    if(validateDistance(distLeft, r0.yz, rd.yz, boundMin.yz, boundMax.yz)) minimum = min(minimum, distLeft), maximum = max(maximum, distLeft);\n    if(validateDistance(distBack, r0.xy, rd.xy, boundMin.xy, boundMax.xy)) minimum = min(minimum, distBack), maximum = max(maximum, distBack);\n    if(validateDistance(distFront, r0.xy, rd.xy, boundMin.xy, boundMax.xy)) minimum = min(minimum, distFront), maximum = max(maximum, distFront);\n    return vec2(minimum, maximum);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Used for the bullet hole\nfloat sdTube(vec3 p) {\n    return distance(p.xy, vec2(0, -0.5)) - TUBE_RAD - cnoise(p * 10.0) * 0.03;\n}\n\n// How much the depth at the entrance, OR the exit, of a cube should be adjusted by\nfloat depthOffsetSingle(vec3 p) {\n    #ifndef SHOW_RAW\n    float off = -cnoise(p) * CUTOUT_WEIGHT * 0.7; // Smoke noise layer 1\n    off -= pow(cnoise(3.0 * (p + 4.0)), 2.0) * CUTOUT_WEIGHT * 0.2;\n    off -= pow(cnoise(3.0 * (p + 8.0)), 4.0) * CUTOUT_WEIGHT * 0.1;\n    off +=  (1.0 - distance(p, CENTER)); // Makes everything more \"sphere-like\"\n    // Note: This could be used to allow for more complex shapes; I just don't really feel like worrying about that right now\n    return off;\n    #else\n    return 0.0;\n    #endif\n}\n\n// How much the depth at the entrance, AND the exit should be adjusted by\nfloat depthOffset(vec3 pos, vec2 iD, vec3 rayDir) {\n    return depthOffsetSingle(pos + iD.x * rayDir) + depthOffsetSingle(pos + iD.y * rayDir);\n}\n\n// Used to scale up the cubes bc I was too lazy to actually change the values of the cubes xd\nvec3 scaleBoundMin(vec3 bound) {\n    bound -= 0.6;\n    return bound;\n}\n\nvec3 scaleBoundMax(vec3 bound) {\n    bound += 0.6;\n    return bound;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Set up camera\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvN = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uvN.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    pos.y -= 0.4;\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS));\n    rayDir = rotate(rayDir, dir);\n    \n    vec4 col = vec4(0.7);\n    vec2 iD = vec2(100000, -1); // Intercept data\n    int closestBox = -1;\n    \n    for(int i = 0; i < boxes.length(); i += 2) {\n        vec3 boundMin = scaleBoundMin(boxes[i]);\n        vec3 boundMax = scaleBoundMax(boxes[i + 1]);\n        vec2 sID = rayBox(pos, rayDir, boundMin, boundMax); // Single intercept data\n        if(sID.x > sID.y || sID.x < 0.0 || sID.y < 0.0 || depthOffset(pos, sID, rayDir) > abs(sID.y - sID.x)) continue;\n        if(iD.x > sID.x) {\n            iD.x = sID.x;\n            closestBox = i;\n        }\n        iD.y = max(sID.y, iD.y);\n        iD.y = max(sID.x, iD.y);\n    }\n    \n    // Normalize the entrance and exit points to a sphere (cut off by the floor)\n    vec3 enterPos = normalize(iD.x * rayDir + pos) * RAD;\n    vec3 exitPos = normalize(iD.y * rayDir + pos) * RAD;\n    iD.x = distance(enterPos, pos);\n    iD.y = distance(exitPos, pos);\n    \n    // Depth is reduced, then depthOffset adds to it. I found that this gave better results than just subtracting from the depth :P\n    float depth = max((iD.y - iD.x) - 0.35 + depthOffset(pos, iD, rayDir), 0.0);\n    \n    float distTubeEn = sdTube(enterPos);\n    float distTubeEx = sdTube(exitPos);\n    float enteredExternalLight = 0.0;\n    \n    if(distTubeEn < 0.0 && distTubeEx < 0.0) {\n        depth = 0.0;\n    } else if(distTubeEn < 0.0 && depth > 0.0) {\n        // Emulates how it would look to partially see through the tube\n        depth -= distTubeEn / length(rayDir.xy);\n        enteredExternalLight = 1.0 / (abs(distTubeEn * 10.0) + 1.0);\n        if(abs(distTubeEx) <= TUBE_RAD / 2.0) {\n            // A little bit of fade at the exit, I find it looks better :P\n            depth *= min(max(abs(distTubeEx / (TUBE_RAD / 2.0)), 0.0), 1.0);\n        }\n    } else {\n        enteredExternalLight = 1.0;\n    }\n    float depthMult = min(max(depth / MAX_DIST, 0.0), 1.0);\n    float heightAcc = 0.0;\n    float averageHeight = iD.x * rayDir.y * 0.5 + iD.y * rayDir.y * 0.5 + pos.y;\n    // Assumption is that more light will scatter in when height is lower (assuming the light is always on top)\n    float light = 0.0;\n    // This is NOT accurate _at all_. TODO: Figure out how mie scattering works\n    float inScatterLight = min(max((averageHeight + LIGHT_DIST * 0.5 - depth / LIGHT_DIST) / (LIGHT_DIST), 0.0), 1.0);\n    light += inScatterLight;\n    light += enteredExternalLight * 0.1; // Ambient light\n    // TODO: Normal function, actual phong illumination\n    vec4 smokeCol = SMOKE_COL_LIT * min(max(light, 0.0), 1.0) + SMOKE_COL_BASE * (1.0 - min(max(light, 0.0), 1.0));\n    smokeCol *= depthMult;\n    fragColor = vec4(0.7) * (1.0 - depthMult) + smokeCol;\n}", "image_inputs": [], "common_code": "const vec3 CAM = vec3(0,0,-5);\nconst float PI = 3.14159265;\nconst float FOCUS = 3.0;\nconst vec2 EPSILON = vec2(0.000001, 0);\n// Colors from https://www.schemecolor.com/volcano-smoke-color-scheme.php\nconst vec4 SMOKE_COL_BASE = vec4(88, 84, 83, 255) / 255.0;\nconst vec4 SMOKE_COL_LIT = vec4(172, 166, 150, 255) / 255.0;\nconst float MAX_DIST = 0.1;\nconst float LIGHT_DIST = 2.0;\nconst vec3 LIGHT = vec3(0, 1, 0);\nconst float CUTOUT_WEIGHT = 0.3;\nconst vec3 CENTER = vec3(0, -1.25, 0);\nconst float TUBE_RAD = 0.1;\nconst float RAD = 1.75;\n\n\nconst vec3 boxes[] = vec3[](\n    vec3(-0.25),\n    vec3(0.25),\n    vec3(-0.25, 0.25, -0.25),\n    vec3(0.25,0.75,0.25),\n    vec3(-0.25, -0.75, -0.25),\n    vec3(0.25,-0.25,0.25),\n    vec3(-0.75, -0.25, -0.25),\n    vec3(-0.25, 0.25, 0.25),\n    vec3(0.25, -0.25, -0.25),\n    vec3(0.75, 0.25, 0.25),\n    vec3(0.25, 0.25, -0.25),\n    vec3(0.75, 0.75, 0.25),\n    vec3(-0.75, 0.25, -0.25),\n    vec3(-0.25, 0.75, 0.25),\n    vec3(0.25, -0.75, -0.25),\n    vec3(0.75, -0.25, 0.25),\n    vec3(-0.75, -0.75, -0.25),\n    vec3(-0.25, -0.25, 0.25),\n    \n    vec3(-0.25, -0.25, 0.25),\n    vec3(0.25, 0.25, 0.75),\n    vec3(-0.25, 0.25, 0.25),\n    vec3(0.25,0.75,0.75),\n    vec3(-0.25, -0.75, 0.25),\n    vec3(0.25,-0.25,0.75),\n    vec3(-0.75, -0.25, 0.25),\n    vec3(-0.25, 0.25, 0.75),\n    vec3(0.25, -0.25, 0.25),\n    vec3(0.75, 0.25, 0.75),\n    vec3(0.25, -0.75, 0.25),\n    vec3(0.75, -0.25, 0.75),\n    vec3(-0.75, -0.75, 0.25),\n    vec3(-0.25, -0.25, 0.75),\n    \n    vec3(-0.25, -0.25, -0.75),\n    vec3(0.25, 0.25, -0.25),\n    vec3(-0.25, 0.25, -0.75),\n    vec3(0.25,0.75,-0.25),\n    vec3(-0.25, -0.75, -0.75),\n    vec3(0.25,-0.25,-0.25),\n    vec3(-0.75, -0.25, -0.75),\n    vec3(-0.25, 0.25, -0.25),\n    vec3(0.25, -0.25, -0.75),\n    vec3(0.75, 0.25, -0.25),\n    vec3(0.25, -0.75, -0.75),\n    vec3(0.75, -0.25, -0.25),\n    vec3(-0.75, -0.75, -0.75),\n    vec3(-0.25, -0.25, -0.25),\n    \n    vec3(-1.25, -0.75, -0.25),\n    vec3(-0.75, -0.25, 0.25),\n    \n    vec3(0.75, -0.75, -0.25),\n    vec3(1.25, -0.25, 0.25),\n    \n    vec3(-0.25, -0.75, -1.25),\n    vec3(0.25, -0.25, -0.75),\n    \n    vec3(-0.25, -0.75, 0.75),\n    vec3(0.25, -0.25, 1.25),\n    \n    vec3(-0.75, -0.75, -1.25),\n    vec3(-0.25, -0.25, -0.75),\n    \n    vec3(0.25, -0.75, -1.25),\n    vec3(0.75, -0.25, -0.75),\n    \n    vec3(-0.75, -0.75, 0.75),\n    vec3(-0.25, -0.25, 1.25),\n    \n    vec3(0.25, -0.75, 0.75),\n    vec3(0.75, -0.25, 1.25),\n    \n    vec3(-1.25, -0.75, -0.75),\n    vec3(-0.75, -0.25, -0.25),\n    \n    vec3(0.75, -0.75, -0.75),\n    vec3(1.25, -0.25, -0.25),\n    \n    \n    vec3(-1.25, -0.75, 0.25),\n    vec3(-0.75, -0.25, 0.75),\n    \n    vec3(0.75, -0.75, 0.25),\n    vec3(1.25, -0.25, 0.75),\n    \n    vec3(-1.25, -0.25, -0.25),\n    vec3(-0.75, 0.25, 0.25),\n    \n    vec3(0.75, -0.25, -0.25),\n    vec3(1.25, 0.25, 0.25),\n    \n    vec3(-0.25, -0.25, -1.25),\n    vec3(0.25, 0.25, -0.75),\n    \n    vec3(-0.25, -0.25, 0.75),\n    vec3(0.25, 0.25, 1.25)\n);\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//  https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clScRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[839, 912, 948, 948, 1285], [1287, 1326, 1366, 1366, 1416], [1418, 1470, 1509, 1509, 1546], [1548, 1638, 1721, 1721, 1850], [1852, 1965, 2026, 2026, 3265], [3267, 3317, 3348, 3348, 3435], [3437, 3465, 3487, 3487, 3568], [3570, 3654, 3687, 3687, 4178], [4180, 4254, 4305, 4305, 4399], [4401, 4495, 4527, 4527, 4565], [4567, 4567, 4599, 4599, 4637], [4639, 4639, 4696, 4717, 7845]], "test": "untested"}
{"id": "ctScRG", "name": "drum Basico-sound", "author": "jorge2017a2", "description": "drum Basico-sound", "tags": ["2d", "sound", "bass", "drum"], "likes": 9, "viewed": 187, "published": 3, "date": "1691878150", "time_retrieved": "2024-07-30T17:39:37.317167", "image_code": "//por jorge2017a2\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(1.0),b,d)\n//#define PI 3.141516\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2(0.0,distObj));\ncolOut = mix(colOut,vec3(0.0) ,S2(0.0,abs( distObj)-0.001));\nreturn colOut;\n}\n\n\nfloat N21(vec2 p)\n{ return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);}\n\nvec3 banquetaIzq(vec2 p, vec3 col)\n{\nvec2 A,B;\n\nA= vec2(3.24,4.77);\nB= vec2(7.48,4.86);\nfloat d1=sdSegment(p,A,B);\n\nA= vec2(3.24,3.2);\nB= vec2(5.88,3.25);\nfloat d2=sdSegment(p,A,B);\n\nA= vec2(3.23,2.33);\nB= vec2(4.91,2.32);\nfloat d3=sdSegment(p,A,B);\n\nA= vec2(3.25,1.73);\nB= vec2(4.32,1.77);\nfloat d4=sdSegment(p,A,B);\n\nA= vec2(3.25,1.32);\nB= vec2(3.9,1.34);\nfloat d5=sdSegment(p,A,B);\n\nA= vec2(3.25,1.03);\nB= vec2(3.55,1.04);\nfloat d6=sdSegment(p,A,B);\n\nA= vec2(3.25,0.82);\nB= vec2(3.32,0.81);\nfloat d7=sdSegment(p,A,B);\n\nA= vec2(3.26,0.66);\nB= vec2(8.02,5.32);\nfloat d8=sdSegment(p,A,B);\n\nvec3 colc=vec3(0.64,0.64,0.64);\n col= DrawFigBorde(vec3(0.0), col, d1);\n col= DrawFigBorde(vec3(0.0), col, d2);\n col= DrawFigBorde(vec3(0.0), col, d3);\n col= DrawFigBorde(vec3(0.0), col, d4);\n col= DrawFigBorde(vec3(0.0), col, d5);\n col= DrawFigBorde(vec3(0.0), col, d6);\n col= DrawFigBorde(vec3(0.0), col, d7);\n col= DrawFigBorde(vec3(0.0), col, d8);\n    return col;\n}\n\n\nvec3 banquetaDer(vec2 p, vec3 col)\n{\nvec2 A,B;\n//linea inclinada\nA= vec2(4.03,0.22);\nB= vec2(9.79,2.37);\nfloat d9=sdSegment(p,A,B);\n\n\nA= vec2(3.78,0.25);\nB= vec2(9.62,2.5);\nfloat d10=sdSegment(p,A,B);\n\nA= vec2(4.84,0.21);\nB= vec2(10.29,1.69);\nfloat d11=sdSegment(p,A,B);\n\n\nA= vec2(6.72,0.72);\nB= vec2(6.7,0.25);\nfloat d12=sdSegment(p,A,B);\n\nA= vec2(7.16,0.85);\nB= vec2(7.18,0.21);\nfloat d13=sdSegment(p,A,B);\n\nA= vec2(7.51,0.88);\nB= vec2(7.5,0.23);\nfloat d14=sdSegment(p,A,B);\n\nA= vec2(8.58,0.23);\nB= vec2(8.57,1.19);\nfloat d15=sdSegment(p,A,B);\n\nA= vec2(9.31,0.23);\nB= vec2(9.31,1.39);\nfloat d16=sdSegment(p,A,B);\n\nA= vec2(9.96,0.25);\nB= vec2(10.02,1.58);\nfloat d17=sdSegment(p,A,B);\n\nA= vec2(7.13,0.85);\nB= vec2(5.78,0.84);\nfloat d18=sdSegment(p,A,B);\n\nA= vec2(6.47,1.11);\nB= vec2(8.33,1.12);\nfloat d19=sdSegment(p,A,B);\n\nA= vec2(7.4,1.44);\nB= vec2(9.5,1.45);\nfloat d20=sdSegment(p,A,B);\n\nA= vec2(3.77,0.24);\nB= vec2(10.28,2.77);\nfloat d21=sdSegment(p,A,B);\n\nA= vec2(4.03,0.22);\nB= vec2(10.27,2.54);\nfloat d22=sdSegment(p,A,B);\ncol= DrawFigBorde(vec3(0.0),col, d9);\ncol= DrawFigBorde(vec3(0.0),col, d10);\ncol= DrawFigBorde(vec3(0.0),col, d11);\ncol= DrawFigBorde(vec3(0.0),col, d12);\ncol= DrawFigBorde(vec3(0.0),col, d13);\ncol= DrawFigBorde(vec3(0.0),col, d14);\ncol= DrawFigBorde(vec3(0.0),col, d15);\n\ncol= DrawFigBorde(vec3(0.0),col, d16);\ncol= DrawFigBorde(vec3(0.0),col, d17);\ncol= DrawFigBorde(vec3(0.0),col, d18);\ncol= DrawFigBorde(vec3(0.0),col, d19);\ncol= DrawFigBorde(vec3(0.0),col, d20);\n\ncol= DrawFigBorde(vec3(0.0),col, d21);\ncol= DrawFigBorde(vec3(0.0),col, d22);\n    return col;\n}\n\nvec3 calle(vec2 p, vec3 col)\n{  col=banquetaIzq(p,col);\n   col=banquetaDer(p,col);\n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    //uv-=vec2(-2.0,1.0);\n    uv-=vec2(-3.3,1.0);\n    uv*=3.0;\n    //uv*=1.5* 3.* 2./iResolution.y;\n    uv.x*=0.48;\n    uv.x*=1.45;\n    \n    uv.y=-uv.y+0.2*sin(iTime);\n    uv.x+=0.2*sin(iTime+uv.y);\n    vec3 col=vec3(0.5);\n    col=calle(uv,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "//Referencia de sonido IQ y Gaz\n//Modificado por Jorge2017a2---jorgefp\n\n//,modificado por jorge2017a2\n//https://www.shadertoy.com/view/NdSyDy\n\n#define PI 3.1415926536\n#define PIH (PI*.5)\n#define TAU (PI*2.)\n\n\n#define DD(a,b) n=(s>=a)?ivec2(a,b):n;\n\nconst float pi = 3.1415927;\nconst float tau = 6.283185;\n\n//gaz\n#define osc_sin(x)sin((x)*TAU)\n#define osc_saw(x)(1.-fract(x)*2.)\n#define osc_sqr(x)sign(0.5-fract(x))\n#define osc_tri(x)(asin(sin((x)*PI))/PIH)\n \nfloat noize(float t,  float a, float b){\n    float g=fract(cos(t*exp2(a))*exp2(b))+6.0;\n    return exp(-0.08*g*g) *40.0-1.;\n}\n\nfloat kick(float t)\n{ return clamp(1.5*asin(cos(320.0*t-30.0*exp(-40.0*t))),-1.,1.)*exp(-4.*t);}\n\nfloat kick1(float t)\n{ return clamp(1.5*asin(cos(620.0*t-30.0*exp(-40.0*t))),-1.,1.)*exp(-4.*t);}\n\n\nfloat snare(float t)\n{  float n=noize(t,10.,10.)*exp(-t*10.);\n    float f=t*160.,a=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float b=.05*osc_sin(10.*f+a)*exp(-t*3.);\n    float c=osc_sin(f+b)*exp(-t*15.), z;\n    return n+c;\n}\n\nfloat snare2(float t)\n{ float n=noize(t,10.,10.)*exp(-t*10.);\n    float f=t*260.;\n    float a=0.0;\n    float b=.05*osc_sin(10.*f+a)*exp(-t*3.);\n    float c=osc_sin(f+b)*exp(-t*15.), z;\n    return n+c;\n}\n\nfloat SinMod(float x, float b, float c, float d)\n{  float p = (2. * PI) / b; return sin(p * (x + c)) + d; }\n\nfloat Amp(float a)\n{ return a * 0.1;}\n\nfloat SinWave(float f, float a, float t)\n{ return Amp(a) * sin(2. * PI * f * t); }\n\nfloat sec1(float t)\n{   float f1,cf1,p1,s1;\n    float t0=t;    \n     f1 = 40.;\n     cf1 = 1. / f1;\n     float t1=mod(t,12.0);\n     p1 = SinMod(t1, cf1, 0., 1.);\n     s1 = SinWave(p1, 0.3, t1);\n     return s1;\n}     \n\nfloat sound1(float  t, float freq, float tr)\n{   float x=6.2831*freq*t;\n    float d1=mod(x+sin(x*1.0),tr);\n    d1=abs(d1)-0.1;\n    return  d1*exp(-3.0*t);\n}\n\nvec2 mainSound(in int samp, float time)\n{   \n    float s1,s2,ss1;\n    float k1;\n    float dtr2=mod(time,12.0);\n    dtr2=12.0-time;\n    s1=sec1(dtr2)*1.5;\n float  trt=mod(time,15.0);\n  \n  const float tempo = 7.2;\n  int s = int(floor(trt*tempo));\n  float sa = (trt*tempo);\n  \n  ivec2 n = ivec2(0);\n  float na = 0.0;\n  \n  DD( 1,1) DD( 2,1) DD(3,1) \n  DD( 4,1) DD( 5,1) DD(5,2) \n  \n  DD(17,2) DD(18,2) DD(19,2)\n  DD(20,1) DD(21,1) DD(22,1)\n  DD(23,3) DD(24,3)\n  DD(25,1) DD(26,1) DD(27,1) DD(28,1) \n  DD(29,2) DD(30,1) DD(31,1) DD(33,2)\n  DD(34,3) DD(35,3) DD(36,1) DD(37,1)\n  DD(38,4) DD(39,4) DD(40,4) DD(41,1)\n  \n  DD(42,1) DD(43,2) DD(44,1) DD(45,2) \n  DD(46,1) DD(47,2) DD(49,2) DD(50,1)\n  DD(51,3) DD(52,3) DD(53,1) DD(54,1)\n  DD(55,3) DD(56,4) DD(57,4) DD(58,4)\n  DD(59,2) DD(60,3) DD(61,4) DD(62,4) \n  DD(63,1) DD(65,2) DD(66,1) DD(67,2)\n  DD(69,1) DD(70,3) DD(71,1) DD(72,1)\n  DD(73,3) DD(74,3) DD(75,2) DD(76,1)\n  DD(77,3) DD(78,3) DD(79,2) DD(81,1)\n  DD(82,3) DD(83,4) DD(84,3) DD(85,2)\n  DD(86,4) DD(87,4) DD(88,3) DD(89,2) \n  DD(90,4) DD(91,4) DD(92,4) DD(93,1)\n   // lower one octave\n  n.y -= 12;\n      \n  // compute note frequency and time  \n  float f = 440.0*pow( 2.0, float(n.y-69)/12.0 );\n  float t = trt - float(n.x)/tempo;\n    n.y += 12;\n\n  // prepare wave parameters\n  float w = tau*f;\n  float dwdt = w/iSampleRate; // derivative\n    \n    if(n.y==1)\n    k1= kick1(t);\n    \n    if(n.y==2)\n    k1= kick(t);\n    \n    if(n.y==3)\n    ss1= snare(t);\n    \n    if(n.y==4)\n    ss1= snare2(t);\n        return vec2(s1+k1+ss1);     \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctScRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 252, 252, 279], [280, 280, 323, 323, 350], [351, 351, 399, 399, 427], [430, 446, 494, 494, 572], [574, 574, 609, 609, 632], [634, 634, 671, 671, 743], [745, 745, 797, 797, 904], [906, 906, 968, 968, 1093], [1096, 1096, 1115, 1115, 1169], [1171, 1171, 1207, 1207, 2130], [2133, 2133, 2169, 2169, 3727], [3729, 3729, 3759, 3759, 3829], [3832, 3832, 3889, 3889, 4236]], "test": "untested"}
{"id": "DtjyWh", "name": "Voronoi Tracking Options", "author": "fenix", "description": "Demonstrating three different voronoi particle tracking search strategies.\n\nLeft: traditional\nCenter: randomized\nRight: jump flood\n\n*mouse x controls particle speed*\n*mouse y controls horizontal split*\n*space to reset*", "tags": ["voronoi", "particles", "tracking", "jfa"], "likes": 21, "viewed": 276, "published": 3, "date": "1691869700", "time_retrieved": "2024-07-30T17:39:38.264634", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I've done a lot of shaders using voronoi-tracked particles, but I've never slowed\n//  down to do a proper study of the effect of different voronoi search strategies.\n//  Of course, the particular algorithm you might want for a particular shader depends\n//  on a lot of factors that are not demonstrated here, but hopefully this might still\n//  give you some ideas of some general principles.\n//\n//  What you see are three different methods of tracking particles via voronoi buffer.\n//\n//  Left: traditional\n//  Center: randomized\n//  Right: jump flood\n//\n//  The voronoi tracking is intentionally weakened by only letting it run once every\n//  8 frames. This simulates the effects of faster moving particles while letting us\n//  study the patterns. Set SKIP to 1 in Buffer B to see \"full power\" tracking. You\n//  would also probably want more than one \"kick start\" whole-screen random search\n//  iteration.\n//\n//  To control the shader, use the mouse. Mouse x sets the particle speed, and mouse y\n//  sets the horizontal split bar. Above the bar, particles are rendered using the \n//  tracking buffer. Below the bar, the ids of the closest particles are visualized.\n//\n//  There are interesting things to see both above and below the bar. Above the bar,\n//  observe where the particles fail to render. Below the bar, it's easier to see how\n//  the different algorithms percolate the information across space.\n//\n//  The \"traditional\" search on the left side is what you usually get in voronoi\n//  tracking example shaders, like these:\n//\n//      Gegell's [Gegell] Boids                   https://shadertoy.com/view/ms2SW3\n//      FabriceNeyret2's Crowdy Waves 2           https://shadertoy.com/view/3ty3Dy  \n//      michael0884's Voronoi edge tracking II    https://shadertoy.com/view/WsXcWH\n//\n//  This works fine for some shaders, but if you have a need for speed (you want \n//  faster moving particles) you may want to go further. Above the bar, you can see how\n//  the particles are flickering quite badly, and below the bar, you can see how slowly\n//  the information moves through the buffer.\n//\n//  The middle area shows what you get if instead of only looking at the four nearest\n//  neighbors, we look at four random cells in some larger area. We could easily search\n//  more than four for even more power, I just wanted a fair comparison against the\n//  traditional search so I only do four here. It's both a strength and weakness of\n//  this method that you can, and need to tune the number of searches and the distance\n//  they roam.\n//\n//  I had higher hopes for the jump flood method on the right. I guess the idea was\n//  the inspiration for this shader, since I recently implemented JFA for this:\n//\n//      SDF Writer w/ JFA                         https://shadertoy.com/view/DllcDs\n//\n//  But, looking at the results here, the random search seems to usually do better.\n//  I think JFA converges a little faster when the particles are moving very slowly;\n//  click the mouse over on the left and press space to see this. But, in the busy\n//  middle section where the particles pass each other, they flicker much worse, and\n//  at slower speeds. When the particles move faster, the multi-frame beat of the JFA\n//  becomes quite visible below the bar. I guess both problems could be solved with\n//  a pipelined JFA like the greatest of all JFA shaders:\n//\n//      Flyguy's Van Damme - Distance             https://shadertoy.com/view/Wl3fWX\n//\n//  But that's a lot more complicated than most voronoi particle shaders, using the\n//  cubemap buffer to somehow compute the whole JFA each frame. Magic!\n//\n//  Are there any other search strategies I haven't tried?\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float h = texelFetch(iChannel0, ivec2(iResolution.x - 1., iResolution.y - 1.), 0).y; // mouse y determines horizontal split point\n    vec2 p = (u - .5 * iResolution.xy) / iResolution.y;\n    ivec4 old = T(u);\n    float e = 3. / iResolution.y;\n    \n    if (p.y > h)\n    {\n        O = vec4(0);\n    \n        // render particles\n        for (int i = 0; i < 4; ++i)\n        {\n            int id = old[i];\n            if (id < 0) break;\n            vec4 v = getParticle(id);\n            float d = fxLinePointDist(v.xy, v.zw, p);\n            O.xyz += smoothstep(e + e, e, d) * vec3(1, 0, 0);\n            O.xyz += smoothstep(e, 0., abs(d - e - e));\n        }\n    }\n    else\n    {\n        // render voronoi below vertical split\n        O.rgb = sin(vec3(old.x) + vec3(0, 11, 33));\n    }\n    \n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(e, 0., abs(p.y - h)));    // horizontal bar\n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(e, 0., abs(p.x - VBAR))); // vertical bars\n    O = mix(O, vec4(1, 0, 0, 0), smoothstep(e, 0., abs(p.x + VBAR)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//\tParticle \"sim\" and state management\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec3 s = texelFetch(iChannel0, ivec2(iResolution.x - 1., iResolution.y - 1.), 0).xyz; // state stored in last pixel\n    float t = s.z;\n    if (u == vec2(iResolution.x - .5, iResolution.y - .5))\n    {\n        // persistent state tracking\n        O.xyz = s;\n        if (iMouse.z > 0.)\n            O.xy = (iMouse.xy - .5 * iResolution.xy) / iResolution.xy; // xy holds mouse position\n        O.z = t + iTimeDelta * (s.x + .5) * .1; // z holds particle time\n        if (iFrame == 0) O.xyz = vec3(0); // init\n        return;\n    }\n    \n    O.zw = texelFetch(iChannel0, ivec2(u), 0).xy; // zw holds previous position\n    u = floor(u);\n    \n    float idx = u.x + u.y * iResolution.x; // which particle\n    if (int(idx) >= MAX_PARTICLES) return;\n    \n    // this is not really a simulation at all, just a stateless animation to give our tracker something to do\n    idx = idx * .06 + t;\n    O.x = (.7 * sin(idx) + .3 * sin(idx * 40.)) * .4 * iResolution.x / iResolution.y;\n    O.y = cos(idx * 10.) * .4;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer, implemented three ways\n// ---------------------------------------------------------------------------------------\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(int id, vec2 u)\n{\n    if (id < 0 || id >= MAX_PARTICLES) return 1e6;\n    vec4 v = getParticle(id);\n    \n    return min(length2(v.xy - u), length2(v.zw - u));\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(ivec4 old, vec2 p, inout ivec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        float dis2 = distance2Particle(id, p);\n        insertionSort( new, dis, id, dis2 );\n    }\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint SKIP = 8; // how often to perform voronoi updates (set to 1 for \"full power\")\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n\tvec2 p = (u - .5 * iResolution.xy) / iResolution.y;\n    float v = VBAR; // location of vertical split screen\n\n    ivec4 new = ivec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n\n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        ivec4 old = T(u);\n        O = vec4(old);\n        \n        if (iFrame % SKIP != 0) return; // weaken the voronoi for demonstration purposes\n        \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        if (p.x > v)\n        {\n            // On the right hand side, we have a jump flood. Over the course of JUMP_STEPS steps,\n            // first we look for neighbors 2^(JUMP_STEPS - 1) away, then 2^(JUMP_STEPS - 2) away,\n            // down to 1 away on the last step. \n            \n            const int JUMP_STEPS = 4;\n            \n            for (int x = -1; x <= 1; ++x)\n            for (int y = -1; y <= 1; ++y)\n                sortNbs(T(u + exp2(float((iFrame / SKIP) % JUMP_STEPS)) * vec2(x, y)), p, new, dis);\n        }\n        else if (p.x > -v)\n        {\n            // In the middle we have a randomized search. I'm sure I'm not the first person to do\n            // this, but I don't know where I saw it, or I might have rediscovered it. Just search\n            // a few times at random nearby spots. The quality of the hash function is important.\n            \n            const int SEARCH_STEPS = 4;\n            const float SEARCH_RANGE = 50.;\n            \n            for(int i = 0; i < SEARCH_STEPS; ++i)\n            {\n                vec2 h = hash3(uvec3(u, iFrame * 4 + i)).xy - .5;\n\n                sortNbs(T(u + vec2(h * SEARCH_RANGE)), p, new, dis);\n            }\n        }\n        else\n        {\n            // On the left is \"traditional\" voronoi tracking, as many shadertoy examples seem to\n            // use. Just search the four nearest neighbors to see if they have any better options.\n            \n            sortNbs(T(u + vec2(0, 1)), p, new, dis);\n            sortNbs(T(u + vec2(0, -1)), p, new, dis);\n            sortNbs(T(u + vec2(1, 0)), p, new, dis);\n            sortNbs(T(u + vec2(-1, 0)), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        float h = hash3(uvec3(u, iFrame)).x;\n        int id = int(h*float(MAX_PARTICLES));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    O = vec4(new);\n\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_PARTICLES = 300;\n\n// get the info for one particle: position in xy, previous position in zw\n#define getParticle(X) getParticleImpl(iChannel0, int(iResolution.x), X)\nvec4 getParticleImpl(sampler2D smp, int wd, int id)\n{\n    return texelFetch(smp, ivec2(id % wd, id / wd), 0);\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\n\nfloat fxLinePointDist(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return sqrt(length2(p - b * h)); // squared dist to segment\n}\n\n#define T(X) ivec4(texelFetch(iChannel1, ivec2(X), 0))\n#define VBAR iResolution.x / iResolution.y / 6.\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n\n#define KEY_SPACE 32", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjyWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3980, 3980, 4016, 4016, 5048]], "test": "untested"}
{"id": "ml2yDw", "name": "Demodulation 2023 qualifier", "author": "kostik1337", "description": "Demodulation shader showdown qualifier", "tags": ["showdown", "demodulation"], "likes": 9, "viewed": 157, "published": 3, "date": "1691867824", "time_retrieved": "2024-07-30T17:39:39.033578", "image_code": "#define time iTime\n#define INF (1./0.)\n#define rep(p,s) (mod(p,(s))-(s)/2.)\n#define mr(t) (mat2(cos(t),-sin(t),sin(t),cos(t)))\n#define PI 3.1415926535\n\n#define BPM 130.\n#define beat (time/60.*BPM)\n\nfloat ffti(float t) {\n  return iTime * exp(t*2.);\n}\n\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y, p.z));\n}\n\n\nfloat hash(float t) {return fract(sin(t)*45325.32165);}\nfloat hash(vec2 t) {return hash(dot(t,vec2(1.44,2.46423)));}\n\nfloat mybox(vec3 p, vec3 s, float h) {\n  float m1 = box(p,s);\n  float m = INF;\n  for(float i=0.;i<3.;++i) {\n    p += s*vec3(\n      hash(h+i),\n      hash(h+1.22+i)+time,\n      hash(h+1.77+i)\n    );\n    s *= .69;\n    p=rep(p, 2.*s);\n    m=min(m, box(p, s/1.7));\n  }\n  return max(-m, m1);\n}\n\n\nvec3 glow = vec3(0.);\n\nfloat map(vec3 p) {\n  p.x += time*.3;\n  vec3 op=p;\n  float m=INF;\n  \n  for(float i=0.; i<2.;++i) {\n    p = op;\n    float sx = .5;\n    if(i==1.) p.x += .5*sx;\n    vec2 cell = vec2(0.);\n    cell.x = floor(p.x / sx);\n    p.x = rep(p.x, sx);\n    \n    float sy = mix(.2, 1.5, hash(cell.x));\n    p.y += ffti(hash(cell.x+1.32))*.15 * (i==1. ? -1. : 1.);\n    cell.y = floor(p.y/sy);\n    p.y = rep(p.y, sy);\n    \n    vec3 bs = vec3(sx/7., sy/2.2, mix(.02, .08, hash(cell)));\n    //float m1=box(p, bs);\n    float m1=mybox(p, bs, hash(cell+2.11));\n    if(hash(cell+1.12 + floor(beat))<.3) {\n      glow += vec3(1.,1.2,1.5)*.002/(m1+.01) * exp(-3.*fract(beat));\n    }\n    m = min(m, m1);\n  }\n  \n  return min(m, -op.z+.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float blur=smoothstep(0., 1.5, dot(uv,uv));\n\n  vec3 c=vec3(0.);\n  vec3 O=vec3(0.,0.,-6.), D=vec3(uv, 6.);\n  D += .2*(hash(uv+time)-.5) * blur;\n  D = normalize(D);\n  O.yz *= mr(-PI/4.);\n  D.yz *= mr(-PI/4.);\n  if(fract(beat/32.)<.5) {\n    O.xy *= mr(PI/4.);\n    D.xy *= mr(PI/4.);\n  }\n  \n  float d=0.,i;\n  for(i=0.;i<64.;++i) {\n    vec3 p=O+D*d;\n    float m=map(p);\n    d += m;\n    if(m<.001*d) {\n      break;\n    }\n  }\n  c += exp(-d*.07) * pow(max(0., 1.-i/32.), 3.);\n  c += glow;\n  c = sqrt(c);\n  c *= mix(1., .3, blur);\n\t\n\tfragColor = vec4(c, 0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ml2yDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 219, 219, 249], [252, 252, 279, 279, 329], [332, 332, 353, 353, 387], [388, 388, 408, 408, 448], [450, 450, 488, 488, 737], [763, 763, 782, 782, 1473], [1475, 1475, 1532, 1532, 2185]], "test": "untested"}
{"id": "dt2cWw", "name": "Paint Thingy", "author": "Max_H", "description": "Test", "tags": ["test"], "likes": 1, "viewed": 49, "published": 3, "date": "1691865166", "time_retrieved": "2024-07-30T17:39:39.921204", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//https://www.shadertoy.com/view/3tdSDj\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(iFrame == 0) return;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 mouseOld = texture(iChannel1, uv);\n    vec4 mouseNew = iMouse;\n    \n    \n    bool isDrawing = mouseNew.z > 0.0;\n    bool isNewLine = mouseNew.w > 0.0;\n    \n    \n    if(!isDrawing)\n    {\n        fragColor = texture(iChannel0, uv);  \n        return;\n    }\n    \n    \n    vec2 samplePoint = fragCoord / iResolution.x;\n    \n    vec2 lineStart = (isNewLine? abs(mouseNew.zw) : mouseOld.xy) / iResolution.x;\n    vec2 lineEnd = mouseNew.xy / iResolution.x;\n    \n    \n    float distanceToLine = udSegment(samplePoint, lineStart, lineEnd);\n    \n    \n    if(distanceToLine <= 0.025)\n    {\n        fragColor = vec4(sin(iTime), cos(iTime), 1.0, 1.0); \n        return;\n    }\n    \n    fragColor = texture(iChannel0, uv);  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iMouse;\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2cWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 169]], "test": "untested"}
{"id": "dljcWw", "name": "Matrix background for Lively", "author": "stopsecret", "description": "Based off https://www.shadertoy.com/view/4t3BWl", "tags": ["matrix", "purple"], "likes": 17, "viewed": 385, "published": 3, "date": "1691864405", "time_retrieved": "2024-07-30T17:39:40.918538", "image_code": "/*\n  All credit goes to this shader: https://www.shadertoy.com/view/4t3BWl\n  I just made this version for a computer background\n*/\n\nconst int ITERATIONS = 30;   //use less value if you need more performance\nconst float SPEED = .1;\n\nconst float STRIP_CHARS_MIN =  7.;\nconst float STRIP_CHARS_MAX = 40.;\nconst float STRIP_CHAR_HEIGHT = 0.15;\nconst float STRIP_CHAR_WIDTH = 0.10;\nconst float ZCELL_SIZE = 1. * (STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX);  //the multiplier can't be less than 1.\nconst float XYCELL_SIZE = 12. * STRIP_CHAR_WIDTH;  //the multiplier can't be less than 1.\n\nconst int BLOCK_SIZE = 10;  //in cells\nconst int BLOCK_GAP = 2;    //in cells\n\nconst float WALK_SPEED = 1. * XYCELL_SIZE;\nconst float BLOCKS_BEFORE_TURN = 3.;\n\n\nconst float PI = 3.14159265359;\n\n\n//        ----  random  ----\n\nfloat hash(float v) {\n    return fract(sin(v)*43758.5453123);\n}\n\nfloat hash(vec2 v) {\n    return hash(dot(v, vec2(5.3983, 5.4427)));\n}\n\nvec2 hash2(vec2 v)\n{\n    v = vec2(v * mat2(127.1, 311.7,  269.5, 183.3));\n\treturn fract(sin(v)*43758.5453123);\n}\n\nvec4 hash4(vec2 v)\n{\n    vec4 p = vec4(v * mat4x2( 127.1, 311.7,\n                              269.5, 183.3,\n                              113.5, 271.9,\n                              246.1, 124.6 ));\n    return fract(sin(p)*43758.5453123);\n}\n\nvec4 hash4(vec3 v)\n{\n    vec4 p = vec4(v * mat4x3( 127.1, 311.7, 74.7,\n                              269.5, 183.3, 246.1,\n                              113.5, 271.9, 124.6,\n                              271.9, 269.5, 311.7 ) );\n    return fract(sin(p)*43758.5453123);\n}\n\n\n//        ----  symbols  ----\n//  Slightly modified version of \"runes\" by FabriceNeyret2 -  https://www.shadertoy.com/view/4ltyDM\n//  Which is based on \"runes\" by otaviogood -  https://shadertoy.com/view/MsXSRn\n\nfloat rune_line(vec2 p, vec2 a, vec2 b) {   // from https://www.shadertoy.com/view/4dcfW8\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\nfloat rune(vec2 U, vec2 seed, float highlight)\n{\n\tfloat d = 1e5;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec4 pos = hash4(seed);\n\t\tseed += 1.;\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) pos.y = .0;\n\t\tif (i == 1) pos.x = .999;\n\t\tif (i == 2) pos.x = .0;\n\t\tif (i == 3) pos.y = .999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec4 snaps = vec4(2, 3, 2, 3);\n\t\tpos = ( floor(pos * snaps) + .5) / snaps;\n\n\t\tif (pos.xy != pos.zw)  //filter out single points (when start and end are the same)\n\t\t    d = min(d, rune_line(U, pos.xy, pos.zw + .001) ); // closest line\n\t}\n\treturn smoothstep(0.1, 0., d) + highlight*smoothstep(0.4, 0., d);\n}\n\nfloat random_char(vec2 outer, vec2 inner, float highlight) {\n    vec2 seed = vec2(dot(outer, vec2(269.5, 183.3)), dot(outer, vec2(113.5, 271.9)));\n    return rune(inner, seed, highlight);\n}\n\n\n//        ----  digital rain  ----\n\n// xy - horizontal, z - vertical\nvec3 rain(vec3 ro3, vec3 rd3, float time) {\n    vec4 result = vec4(0.);\n\n    // normalized 2d projection\n    vec2 ro2 = vec2(ro3);\n    vec2 rd2 = normalize(vec2(rd3));\n\n    // we use formulas `ro3 + rd3 * t3` and `ro2 + rd2 * t2`, `t3_to_t2` is a multiplier to convert t3 to t2\n    bool prefer_dx = abs(rd2.x) > abs(rd2.y);\n    float t3_to_t2 = prefer_dx ? rd3.x / rd2.x : rd3.y / rd2.y;\n\n    // at first, horizontal space (xy) is divided into cells (which are columns in 3D)\n    // then each xy-cell is divided into vertical cells (along z) - each of these cells contains one raindrop\n\n    ivec3 cell_side = ivec3(step(0., rd3));      //for positive rd.x use cell side with higher x (1) as the next side, for negative - with lower x (0), the same for y and z\n    ivec3 cell_shift = ivec3(sign(rd3));         //shift to move to the next cell\n\n    //  move through xy-cells in the ray direction\n    float t2 = 0.;  // the ray formula is: ro2 + rd2 * t2, where t2 is positive as the ray has a direction.\n    ivec2 next_cell = ivec2(floor(ro2/XYCELL_SIZE));  //first cell index where ray origin is located\n    for (int i=0; i<ITERATIONS; i++) {\n        ivec2 cell = next_cell;  //save cell value before changing\n        float t2s = t2;          //and t\n\n        //  find the intersection with the nearest side of the current xy-cell (since we know the direction, we only need to check one vertical side and one horizontal side)\n        vec2 side = vec2(next_cell + cell_side.xy) * XYCELL_SIZE;  //side.x is x coord of the y-axis side, side.y - y of the x-axis side\n        vec2 t2_side = (side - ro2) / rd2;  // t2_side.x and t2_side.y are two candidates for the next value of t2, we need the nearest\n        if (t2_side.x < t2_side.y) {\n            t2 = t2_side.x;\n            next_cell.x += cell_shift.x;  //cross through the y-axis side\n        } else {\n            t2 = t2_side.y;\n            next_cell.y += cell_shift.y;  //cross through the x-axis side\n        }\n        //now t2 is the value of the end point in the current cell (and the same point is the start value in the next cell)\n\n        //  gap cells\n        vec2 cell_in_block = fract(vec2(cell) / float(BLOCK_SIZE));\n        float gap = float(BLOCK_GAP) / float(BLOCK_SIZE);\n        if (cell_in_block.x < gap || cell_in_block.y < gap || (cell_in_block.x < (gap+0.1) && cell_in_block.y < (gap+0.1))) {\n            continue;\n        }\n\n        //  return to 3d - we have start and end points of the ray segment inside the column (t3s and t3e)\n        float t3s = t2s / t3_to_t2;\n\n        //  move through z-cells of the current column in the ray direction (don't need much to check, two nearest cells are enough)\n        float pos_z = ro3.z + rd3.z * t3s;\n        float xycell_hash = hash(vec2(cell));\n        float z_shift = xycell_hash*11. - time * (0.5 + xycell_hash * 1.0 + xycell_hash * xycell_hash * 1.0 + pow(xycell_hash, 16.) * 3.0);  //a different z shift for each xy column\n        float char_z_shift = floor(z_shift / STRIP_CHAR_HEIGHT);\n        z_shift = char_z_shift * STRIP_CHAR_HEIGHT;\n        int zcell = int(floor((pos_z - z_shift)/ZCELL_SIZE));  //z-cell index\n        for (int j=0; j<2; j++) {  //2 iterations is enough if camera doesn't look much up or down\n            //  calcaulate coordinates of the target (raindrop)\n            vec4 cell_hash = hash4(vec3(ivec3(cell, zcell)));\n            vec4 cell_hash2 = fract(cell_hash * vec4(127.1, 311.7, 271.9, 124.6));\n\n            float chars_count = cell_hash.w * (STRIP_CHARS_MAX - STRIP_CHARS_MIN) + STRIP_CHARS_MIN;\n            float target_length = chars_count * STRIP_CHAR_HEIGHT;\n            float target_rad = STRIP_CHAR_WIDTH / 2.;\n            float target_z = (float(zcell)*ZCELL_SIZE + z_shift) + cell_hash.z * (ZCELL_SIZE - target_length);\n            vec2 target = vec2(cell) * XYCELL_SIZE + target_rad + cell_hash.xy * (XYCELL_SIZE - target_rad*2.);\n\n            //  We have a line segment (t0,t). Now calculate the distance between line segment and cell target (it's easier in 2d)\n            vec2 s = target - ro2;\n            float tmin = dot(s, rd2);  //tmin - point with minimal distance to target\n            if (tmin >= t2s && tmin <= t2) {\n                float u = s.x * rd2.y - s.y * rd2.x;  //horizontal coord in the matrix strip\n                if (abs(u) < target_rad) {\n                    u = (u/target_rad + 1.) / 2.;\n                    float z = ro3.z + rd3.z * tmin/t3_to_t2;\n                    float v = (z - target_z) / target_length;  //vertical coord in the matrix strip\n                    if (v >= 0.0 && v < 1.0) {\n                        float c = floor(v * chars_count);  //symbol index relative to the start of the strip, with addition of char_z_shift it becomes an index relative to the whole cell\n                        float q = fract(v * chars_count);\n                        vec2 char_hash = hash2(vec2(c+char_z_shift, cell_hash2.x));\n                        if (char_hash.x >= 0.1 || c == 0.) {  //10% of missed symbols\n                            float time_factor = floor(c == 0. ? time*5.0 :  //first symbol is changed fast\n                                    time*(1.0*cell_hash2.z +   //strips are changed sometime with different speed\n                                            cell_hash2.w*cell_hash2.w*4.*pow(char_hash.y, 4.)));  //some symbols in some strips are changed relatively often\n                            float a = random_char(vec2(char_hash.x, time_factor), vec2(u,q), max(1., 3. - c/2.)*0.2);  //alpha\n                            a *= clamp((chars_count - 0.5 - c) / 2., 0., 1.);  //tail fade\n                            if (a > 0.) {\n                                float attenuation = 1. + pow(0.06*tmin/t3_to_t2, 2.);\n                                vec3 col = (c == 0. ? vec3(0.67, 0.6, 1.) : vec3(0.3, 0.1, 0.50)) / attenuation;\n                                float a1 = result.a;\n                                result.a = a1 + (1. - a1) * a;\n                                result.xyz = (result.xyz * a1 + col * (1. - a1) * a) / result.a;\n                                if (result.a > 0.98)  return result.xyz;\n                            }\n                        }\n                    }\n                }\n            }\n            // not found in this cell - go to next vertical cell\n            zcell += cell_shift.z;\n        }\n        // go to next horizontal cell\n    }\n\n    return result.xyz * result.a;\n}\n\n\n//        ----  main, camera  ----\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n\tfloat c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvec3 rotateX(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(1.,0.,0.,0.,c,-s,0.,s,c) * v;\n}\n\nvec3 rotateY(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,0.,-s,0.,1.,0.,s,0.,c) * v;\n}\n\nvec3 rotateZ(vec3 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(c,-s,0.,s,c,0.,0.,0.,1.) * v;\n}\n\nfloat smoothstep1(float x) {\n    return smoothstep(0., 1., x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (STRIP_CHAR_WIDTH > XYCELL_SIZE || STRIP_CHAR_HEIGHT * STRIP_CHARS_MAX > ZCELL_SIZE) {\n        // error\n        fragColor = vec4(1., 0., 0., 1.);\n        return;\n    }\n\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\n    float time = iTime * SPEED;\n\n    const float turn_rad = 0.25 / BLOCKS_BEFORE_TURN;   //0 .. 0.5\n    const float turn_abs_time = (PI/2.*turn_rad) * 1.5;  //multiplier different than 1 means a slow down on turns\n    const float turn_time = turn_abs_time / (1. - 2.*turn_rad + turn_abs_time);  //0..1, but should be <= 0.5\n\n    float level1_size = float(BLOCK_SIZE) * BLOCKS_BEFORE_TURN * XYCELL_SIZE;\n    float level2_size = 4. * level1_size;\n    float gap_size = float(BLOCK_GAP) * XYCELL_SIZE;\n\n    vec3 ro = vec3(gap_size/2., gap_size/2., 0.);\n    vec3 rd = vec3(uv.x, 2.0, uv.y);\n\n    float tq = fract(time / (level2_size*4.) * WALK_SPEED);  //the whole cycle time counter\n    float t8 = fract(tq*4.);  //time counter while walking on one of the four big sides\n    float t1 = fract(t8*8.);  //time counter while walking on one of the eight sides of the big side\n\n    vec2 prev;\n    vec2 dir;\n    if (tq < 0.25) {\n        prev = vec2(0.,0.);\n        dir = vec2(0.,1.);\n    } else if (tq < 0.5) {\n        prev = vec2(0.,1.);\n        dir = vec2(1.,0.);\n    } else if (tq < 0.75) {\n        prev = vec2(1.,1.);\n        dir = vec2(0.,-1.);\n    } else {\n        prev = vec2(1.,0.);\n        dir = vec2(-1.,0.);\n    }\n    float angle = floor(tq * 4.);  //0..4 wich means 0..2*PI\n\n    prev *= 4.;\n\n    const float first_turn_look_angle = 0.4;\n    const float second_turn_drift_angle = 0.5;\n    const float fifth_turn_drift_angle = 0.25;\n\n    vec2 turn;\n    float turn_sign = 0.;\n    vec2 dirL = rotate(dir, -PI/2.);\n    vec2 dirR = -dirL;\n    float up_down = 0.;\n    float rotate_on_turns = 1.;\n    float roll_on_turns = 1.;\n    float add_angel = 0.;\n    if (t8 < 0.125) {\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        angle -= first_turn_look_angle * (max(0., t1 - (1. - turn_time*2.)) / turn_time - max(0., t1 - (1. - turn_time)) / turn_time * 2.5);\n        roll_on_turns = 0.;\n    } else if (t8 < 0.250) {\n        prev += dir;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel += first_turn_look_angle*0.5 + (-first_turn_look_angle*0.5+1.0+second_turn_drift_angle)*t1;\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.375) {\n        prev += dir + dirL;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        add_angel += second_turn_drift_angle*sqrt(1.-t1);\n        //roll_on_turns = 0.;\n    } else if (t8 < 0.5) {\n        prev += dir + dir + dirL;\n        turn = dirR;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = 0.;\n        up_down = sin(t1*PI) * 0.37;\n    } else if (t8 < 0.625) {\n        prev += dir + dir;\n        turn = dir;\n        dir = dirR;\n        angle += 1.;\n        turn_sign = -1.;\n        up_down = sin(-min(1., t1/(1.-turn_time))*PI) * 0.37;\n    } else if (t8 < 0.750) {\n        prev += dir + dir + dirR;\n        turn = dirL;\n        //dir = dir;\n        turn_sign = -1.;\n        add_angel -= (fifth_turn_drift_angle + 1.) * smoothstep1(t1);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else if (t8 < 0.875) {\n        prev += dir + dir + dir + dirR;\n        turn = dir;\n        dir = dirL;\n        angle -= 1.;\n        turn_sign = 1.;\n        add_angel -= fifth_turn_drift_angle - smoothstep1(t1) * (fifth_turn_drift_angle * 2. + 1.);\n        rotate_on_turns = 0.;\n        roll_on_turns = 0.;\n    } else {\n        prev += dir + dir + dir;\n        turn = dirR;\n        //dir = dir;\n        turn_sign = 1.;\n        angle += fifth_turn_drift_angle * (1.5*min(1., (1.-t1)/turn_time) - 0.5*smoothstep1(1. - min(1.,t1/(1.-turn_time))));\n    }\n\n    if (iMouse.x > 10. || iMouse.y > 10.) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n        up_down = -0.7 * mouse.y;\n        angle += mouse.x;\n        rotate_on_turns = 1.;\n        roll_on_turns = 0.;\n    } else {\n        angle += add_angel;\n    }\n\n    rd = rotateX(rd, up_down);\n\n    vec2 p;\n    if (turn_sign == 0.) {\n        //  move forward\n        p = prev + dir * (turn_rad + 1. * t1);\n    }\n    else if (t1 > (1. - turn_time)) {\n        //  turn\n        float tr = (t1 - (1. - turn_time)) / turn_time;\n        vec2 c = prev + dir * (1. - turn_rad) + turn * turn_rad;\n        p = c + turn_rad * rotate(dir, (tr - 1.) * turn_sign * PI/2.);\n        angle += tr * turn_sign * rotate_on_turns;\n        rd = rotateY(rd, sin(tr*turn_sign*PI) * 0.2 * roll_on_turns);  //roll\n    }  else  {\n        //  move forward\n        t1 /= (1. - turn_time);\n        p = prev + dir * (turn_rad + (1. - turn_rad*2.) * t1);\n    }\n\n    rd = rotateZ(rd, angle * PI/2.);\n\n    ro.xy += level1_size * p;\n\n    ro += rd * 0.2;\n    rd = normalize(rd);\n\n    vec3 col = rain(ro, rd, time);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[802, 802, 823, 823, 865], [867, 867, 887, 887, 936], [938, 938, 958, 958, 1050], [1052, 1052, 1072, 1072, 1293], [1295, 1295, 1315, 1315, 1564], [1779, 1779, 1820, 1868, 2033], [2035, 2035, 2083, 2083, 2723], [2725, 2725, 2785, 2785, 2914], [9450, 9450, 9480, 9480, 9573], [9575, 9575, 9606, 9606, 9698], [9700, 9700, 9731, 9731, 9823], [9825, 9825, 9856, 9856, 9948], [9950, 9950, 9978, 9978, 10014], [10016, 10016, 10073, 10073, 15056]], "test": "untested"}
{"id": "mt2yWw", "name": "sphere tracing experiment", "author": "silica163", "description": "my another raymarch playground", "tags": ["raymarch", "spheretrace"], "likes": 2, "viewed": 165, "published": 3, "date": "1691861751", "time_retrieved": "2024-07-30T17:39:42.977034", "image_code": "#define PI 3.14159265\n#define MAX 100.\n#define MIN .001\n#define STEP 128\n\nvec3 l = vec3(5,10,0);\n\n#define rotX(a) mat3(      1,      0,      0,      0, cos(a),-sin(a),      0, sin(a), cos(a))\n#define rotY(a) mat3( cos(a),      0, sin(a),      0,      1,      0,-sin(a),      0, cos(a))\n#define rotZ(a) mat3( cos(a),-sin(a),       0,sin(a), cos(a),      0,      0,      0,      1)\n#define rot2D(a) mat2(cos(a), sin(a), -sin(a),cos(a))\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat xzPlane( vec3 p)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(1,.01);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat3 yToNormal(vec3 N){\n    const int S = 3;\n    vec3 s[S];\n    \n    s[0] = N;\n    s[1] = normalize(cross(normalize(s[0]+vec3(.1,0,0)),s[0]));\n    s[2] = normalize(cross(s[0],s[1]));\n    \n    return mat3(s[1],s[0],s[2]);\n}\n\n\n// transform matrix that rotate normal vector to Y \nmat3 normalToY(vec3 N){\n    return inverse(yToNormal(N));\n}\n\nfloat dist(vec3 p){\n    float d = MAX;\n    //d = min(d,length(p - vec3(0,1,0))-1.);\n    //d = min(d,length(p - vec3(.5,0,1))-1.);\n    \n    //d = min(abs(p.y)-.001,d);\n\n\n    d = min(length(p - vec3(1,0,0))-.05,d);\n    d = min(length(p - vec3(0,1,0))-.05,d);\n    d = min(length(p - vec3(0,0,1))-.05,d);\n    \n    d = min(sdCapsule(p,vec3(-1,0,0),vec3(1,0,0),.02),d);\n    d = min(sdCapsule(p,vec3(0,-1.5,0),vec3(0,1.5,0),.02),d);\n    d = min(sdCapsule(p,vec3(0,0,-2),vec3(0,0,2),.02),d);\n    \n    const int S = 3;\n    vec3 s[S];\n    \n    s[0] = normalize(vec3(1));\n    s[1] = normalize(cross(normalize(s[0]+vec3(.1,0,0)),s[0]));\n    s[2] = normalize(cross(s[0],s[1]));\n    \n    /*d = min(length(p - s[0])-.1,d);\n    d = min(length(p - s[1])-.1,d);\n    d = min(length(p - s[2])-.1,d);\n    d = min(sdCapsule(p,vec3(0),s[0],.02),d);*/\n    \n    p = inverse(mat3(s[1],s[0],s[2]))*p;\n    \n    d = min(d,xzPlane(p));\n    //d = min(length(p - vec3(1,0,0))-.05,d);\n    d = min(length(p - vec3(0,1,0))-.05,d);\n    //d = min(length(p - vec3(0,0,1))-.05,d);\n    \n    return d;\n}\n\nvec3 sNormal(vec3 p){\n\tvec2 t = vec2(MIN,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat SSAO(vec3 p, vec3 N){\n    float sum = 0.;\n    mat3 toY = normalToY(N);\n    mat3 fromY = yToNormal(N);\n    \n    //if(dist(p+N*toY) < 0.)sum --;\n    \n    sum += max(dist(p+N*.01),0.);\n    \n    for(float i = 0.;i<2.;i++){\n        for(float j = 0.;j<8.;j++){\n        \n            mat3 sampleRot = rotY((PI/4.)*j)*rotX((PI/4.)*i);\n            vec3 dp = sampleRot*(vec3(0,1,0)*.01);\n            float d = max(dist(p+dp*toY),0.);\n            \n            sum+=d;\n            /*if(d < 0.){\n                sum--;\n            }*/\n        }\n    }\n    \n    return clamp(sum+.7,0.,1.);\n}\n\nvec4 march(vec3 ro,vec3 rp,vec3 rd){\n    float rl = 0.;\n    for(int s = 0;s < STEP;s ++){\n        rp = ro + rd * rl;\n        float d = dist(rp);\n        if(d >= MAX){\n            rl = MAX;\n            break;\n        }\n        if(d <= MIN)break;\n        rl += d;\n    }\n    return vec4(rp,rl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.5;\n    vec3 c = vec3(0);\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    //m.x = iTime*.1;\n    vec3 ca = vec3(PI/2.+m.y*PI/2.,PI/2.+m.x*PI/1.,0);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n    \n    vec3 ro = rotY*rotX*vec3(0,0,4);\n    vec3 rd = normalize(rotY*rotX*vec3(uv*.5,0)-ro);\n    float rl = 0.;\n    vec3 rp = ro + rl * rd;\n    vec4 hit = march(ro,rp,rd);\n    rp = hit.rgb;\n    \n    vec3 V = -rd;\n    vec3 N = sNormal(rp);\n    vec3 L = normalize(l-rp);\n    vec3 R = reflect(rd,N);\n    float AO = SSAO(rp,N);\n    \n    c = vec3(clamp(dot(L,N),0.,1.))+.1;\n    if(hit.w >= MAX)c = vec3(0.);\n    //c *= vec3(AO);\n    //c *= exp(-rl)+.1;\n    \n    //c = N*.5+.5;\n    //c = fract(rd*2.);\n    //c = rp;\n    \n    //c = vec3(dist(rp+rotX(PI/2.)*N*.1));\n    \n    fragColor = vec4(c,1.0);\n    //fragColor = vec4(sin(rp+cos(rp.zxy)*.5+sin(rp.yzx)*2.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2yWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 487, 487, 608], [610, 610, 634, 634, 743], [745, 745, 768, 768, 967], [970, 1022, 1045, 1045, 1081], [1083, 1083, 1102, 1102, 2145], [2147, 2147, 2168, 2168, 2298], [2300, 2300, 2327, 2327, 2881], [2883, 2883, 2919, 2919, 3176], [3178, 3178, 3235, 3235, 4371]], "test": "untested"}
{"id": "Dt2yDm", "name": "IYI Sigmoid function", "author": "iY0Yi", "description": "sigmoid is my new friend.", "tags": ["1d", "sigmoid"], "likes": 5, "viewed": 164, "published": 3, "date": "1691859873", "time_retrieved": "2024-07-30T17:39:43.915525", "image_code": "float sigmoid(float x, float s) {\n    return 1./(1.+exp(-x*s));\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    SCALE = 2.;\n    Paper(fragCoord, iResolution, iMouse);\n    \n    float v = sin(P.x*2.);\n    float scale = sin(iTime)*20.;\n    col *= graph(v, ORANGE);\n    col *= graph(sigmoid(v, scale)*2.-1., COBALT);\n\t    \n    fragColor=vec4(pow(col, vec3(.454545)), 1.);\n}", "image_inputs": [], "common_code": "// Constants\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define SQRT2 1.41421356237\n#define TAU (2.*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(v) ((v)*.5+.5)\n#define u2s(v) ((v-.5)*2.)\n\n\n#define RED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n#define GREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n#define PURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n#define YELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n#define ORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n#define COBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n#define BLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n#define BLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n\n#define TICKNESS .005\nfloat SCALE = 0.; vec2 P; vec3 col, Res;\n\nvec3 graph(float v, vec3 color){\n    float res =abs(P.y-v);\n    \n    //https://iquilezles.org/articles/distance\n    //https://www.shadertoy.com/view/MdfGWn\n    float e = 2./Res.y;\n    float g = length(vec2(dFdx(res),dFdy(res)))/e;\n    res /= g;\n    \n    res = sms(SCALE*e+TICKNESS, SCALE*e+TICKNESS*1.5, res);\n    return saturate(res+color);\n}\n\nvoid Paper(vec2 C, vec3 R, vec4 M){\n    vec2 uv=C.xy/R.xy;\n    P=(uv-0.5)*2.0;\n    if(M.z>0.) P-=(M.xy/R.xy)*2.-1.;\n    P*=SCALE*2.;\n    Res=R;\n    #define PAPER vec3(1,.95,.9)*.8\n    #define GUIDE vec3(.1,.2,.25)*1.7\n    float ZERO = .003*SCALE;\n    float ONE = .01*SCALE;\n    float TEN = .1*SCALE;\n    col=PAPER;\n    col*=1.-(sms(1.-ONE,1.,abs(u2s(mod(P.x,1.0))))+sms(1.-ONE,1.,abs(u2s(mod(P.y*R.y/R.x,1.0)))))*0.75*GUIDE;\n    col*=1.-(sms(1.-TEN,1.,u2s(mod(P.x*10.0,1.0)))+sms(1.-TEN,1.,abs(u2s(mod(P.y*10.0*R.y/R.x,1.0)))))*0.5*GUIDE;\n    col*=1.-(P.x<ZERO&&P.x>=-ZERO?1.0:0.0)*GUIDE;\n    col*=1.-(P.y*R.y/R.x<0.003*SCALE&&P.y>=-0.003*SCALE?1.0:0.0)*GUIDE;\n    P.y*=R.y/R.x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2yDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 65], [68, 68, 124, 124, 391]], "test": "untested"}
{"id": "cljcDw", "name": "Truchet coding on the bus", "author": "mrange", "description": "CC0: Truchet coding on the bus\nAnother quick shader created while travelling by bus\n", "tags": ["2d"], "likes": 16, "viewed": 235, "published": 3, "date": "1691855262", "time_retrieved": "2024-07-30T17:39:44.785199", "image_code": "// CC0: Truchet coding on the bus\n// Another quick shader created while travelling by bus\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float lw = 0.033;\n\nconst mat2[4] rots =mat2[4](ROT(0.0*TAU/4.0),ROT(1.0*TAU/4.0),ROT(2.0*TAU/4.0),ROT(3.0*TAU/4.0));\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat df0(vec2 p) {\n  return 1E3;\n}\n\nfloat df1(vec2 p, int v) {\n  p *= rots[v];\n  float d0 = abs(p.y);\n  float d1 = length(p);\n  float d2 = p.x > 0.0 ? d0 : d1;\n  return d2;\n}\n\nfloat df2_s(vec2 p, int v) {\n  float d0 = abs(p.y);\n  float d1 = abs(p.x);\n  return v == 0 ? d0 : d1;\n}\n\nfloat df2_c(vec2 p, int v) {\n  p *= rots[v];\n  float d = abs(circle(p-0.5, 0.5));\n  return d;\n}\n\nfloat df3(vec2 p, int v) {\n  p *= rots[v];\n  float d0 = abs(p.x);\n  float d1 = length(p);\n  float d2 = p.y > 0.0 ? d0 : d1;\n  float d3 = abs(p.y);\n  float d = d2;\n  d = min(d, d3); \n  return d;\n}\n\nfloat df4(vec2 p, float h) {\n  p = h > 0.5 ? p : vec2(p.y, -p.x);\n  float d1 = abs(circle(p-0.5, 0.5));\n  float d2 = abs(circle(p+0.5, 0.5));\n  float d = d1;\n  d = min(d, d2); \n  return d;\n}\n\nfloat df(vec2 p, int n, float h) {\n  float d0 = circle(p, lw);\n  float d;\n  switch(n) {\n  default:\n  case 0:   d = df0(p);       break;\n  case 1:   d = df1(p, 0);    break;\n  case 2:   d = df1(p, 1);    break;\n  case 3:   d = df2_c(p, 0);  break;\n  case 4:   d = df1(p, 2);    break;\n  case 5:   d = df2_s(p, 0);  break;\n  case 6:   d = df2_c(p, 1);  break;\n  case 7:   d = df3(p, 0);    break;\n  case 8:   d = df1(p, 3);    break;\n  case 9:   d = df2_c(p, 3);  break;\n  case 10:  d = df2_s(p, 1);  break;\n  case 11:  d = df3(p, 3);    break;\n  case 12:  d = df2_c(p, 2);  break;\n  case 13:  d = df3(p, 2);    break;\n  case 14:  d = df3(p, 1);    break;\n  case 15:  d = df4(p, h);    break;\n  }\n  d = min(d, d0);\n  return d-lw;\n}\n\nint select(vec2 np) {\n  vec2 p0 = 0.05*np;\n  vec2 p1 = 0.025*np;\n  float off = 0.5+0.5*sin(-p1.x+p1.y+0.25*TIME);\n  off *= off;\n  return int(15.0*clamp(1.5*texture(iChannel0, p0).x+0.25*off, 0.0, 1.0));\n}\nvec3 effect(vec2 p) {\n  const float z = .15;\n  float aa = 4.0/RESOLUTION.y;\n\n  vec2 zp = p;\n  float amp = 10.0;\n  zp += amp*sin(0.25*vec2(1.0, sqrt(0.5))*TIME/amp);\n  zp /=z; \n  vec2 np = round(zp);\n  vec2 cp = zp - np;\n  float h = hash(np);\n  int sel0 = select(np);\n  int sel1 = \n      ((1&select(np - vec2(+1.0, +0.0)))==0?0:4)\n    + ((2&select(np - vec2(+0.0, +1.0)))==0?0:8)\n    + ((4&select(np - vec2(-1.0, +0.0)))==0?0:1)\n    + ((8&select(np - vec2(+0.0, -1.0)))==0?0:2)\n    ;\n  bool choice = mod(np.x+np.y, 2.0) == 0.0;\n  int sel = choice ? sel0 : sel1;\n\n  float d = df(cp, sel, h)*z;\n  vec3 col = vec3(0.0);\n  col += choice ? 0.125 : 0.0;\n  col = mix(col, vec3(1.0), smoothstep(0.0, -aa, d));\n  \n  col = sqrt(col);\n\n  return col;\n  \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 453, 474, 474, 544], [546, 546, 577, 577, 601], [603, 603, 622, 622, 638], [640, 640, 666, 666, 778], [780, 780, 808, 808, 883], [885, 885, 913, 913, 980], [982, 982, 1008, 1008, 1177], [1179, 1179, 1207, 1207, 1369], [1371, 1371, 1405, 1405, 2100], [2102, 2102, 2123, 2123, 2306], [2307, 2307, 2328, 2328, 3050], [3052, 3052, 3109, 3109, 3265]], "test": "untested"}
{"id": "mtScWm", "name": "Blue Noise Dithering vs OETF 2.2", "author": "beans_please", "description": "Try commenting out the OETF to see how the dithered version and the clean version don't match in brightness anymore", "tags": ["dither", "gamma", "dithering", "bluenoise", "srgb", "oetf"], "likes": 9, "viewed": 282, "published": 3, "date": "1691841683", "time_retrieved": "2024-07-30T17:39:45.905205", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV\n    vec2 uv = 3. * (fragCoord - .5*iResolution.xy) / iResolution.y;\n    \n    // Wavy pattern\n    float f = cos(6.28 * (uv.x*uv.x*uv.x+uv.y*uv.y*uv.y))*.5+.5;\n    \n    // Dither\n    if (mod(iTime, 3.) < 1.5)\n        f = (f > texture(iChannel0, fragCoord / vec2(textureSize(iChannel0, 0))).x) ? 1. : 0.;\n    \n    // OETF 2.2 (Gamma)\n    f = pow(f, 1. / 2.2);\n    \n    fragColor = vec4(f, f, f, 1.0);\n}\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtScWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 67, 467]], "test": "untested"}
{"id": "dlSyWm", "name": "WIP - Loopless Sphere gear", "author": "me_123", "description": "A gear made of spheres rendered with no for loop.", "tags": ["3d", "wip", "realtime", "analytic", "gear", "loopless"], "likes": 15, "viewed": 262, "published": 3, "date": "1691839591", "time_retrieved": "2024-07-30T17:39:46.835717", "image_code": "const float PI = 3.141592653;\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir*2.0 + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nconst float inf = 10000.;\nvec2 sphere( in vec3 ro, in vec3 rd, float ra )\n{\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(inf); \n    h = sqrt( h );\n    if (c < 0.0) return vec2(0, -b+h);\n    return vec2(-b-h, -b+h);\n}\nbool inCone(in vec3 o, in float k) {\n    return o.x*o.x+o.y*o.y+o.z*o.z*k < 0.0 && o.z < 0.0;\n}\nfloat cone(in vec3 o, in vec3 d, in float k) {\n    o.z *= k;\n    d.z *= k;\n    float a = (d.x*d.x + d.y*d.y + k*d.z*d.z)*2.0;\n    float b = 2.0*(o.x*d.x + o.y*d.y + k*o.z*d.z);\n    float c = o.x*o.x + o.y*o.y + k*o.z*o.z;\n    if (c < 0.0&&o.z>0.0) return 0.0;\n    float disc = b*b - 2.*a*c;\n    \n    if (disc < 0.0) return inf;\n    float dist = (-b - sqrt(disc))/a;\n    if (dist < 0.0 || o.z+d.z*dist < 0.0) return inf;\n    return dist;\n}\nfloat hit(in vec3 o, in vec3 d, in float kk, in float z, in float count, float an) {\n    float g = 0.5*(count/PI);\n    float f = 0.55;\n    float dist = cone(o, d, -kk);\n    if (dist >= inf) return inf;\n    vec3 p = o+d*dist;\n    if (p.z > 0.0) return inf;\n    float angle = atan(p.x, p.y)+an;\n    float fangle = floor(angle*g)/g;\n    float tangle = abs(g*(angle-fangle)-0.5)*2.0;\n    vec3 col;\n    vec3 oo = o;\n    o += d*dist;\n    if (tangle < f) {\n        fangle -= an;\n        float k = (PI/count);\n        float h = k*(1.-f);\n        vec2 dir = vec2(cos(-fangle-k*2.0+h), sin(-fangle-k*2.0+h));\n        float pz = -(dot(o.xy, dir))/dot(d.xy, dir);\n        if (pz < 0.0) pz = inf;\n        \n        dir = vec2(cos(-fangle-h), sin(-fangle-h));\n        float pzz = -(dot(o.xy, dir))/dot(d.xy, dir);\n        if (pzz < 0.0) pzz = inf;\n        float dd = (min(pz, pzz));\n        vec3 cp = o+d*(dd);\n        if (inCone(cp, -kk*kk*kk)) dist += dd;//return inf;\n        else dist = inf;\n        //dist += dd;\n    }\n    dist = min(dist, cone(oo, d, -kk*z));\n    vec3 pos = oo+d*dist;\n    return dist;\n}\n#define gear(ro, rd, size, teeth, time) d=min(d,hit(ro, rd, size, 0.8, teeth, time))\nconst float s2 = sqrt(2.);\nconst float s2i = 1./s2;\nfloat hitShape(in vec3 ro, in vec3 rd) {\nconst float teeth = 12.;\n    float m = 0.6;\n    vec3 xo = vec3(ro.x,ro.y*s2i+ro.z*s2i,ro.z*s2i-ro.y*s2i);\n    vec3 xd = vec3(rd.x,rd.y*s2i+rd.z*s2i,rd.z*s2i-rd.y*s2i);\n    vec3 yo = vec3(ro.x*s2i+ro.z*s2i,ro.y,ro.z*s2i-ro.x*s2i);\n    vec3 yd = vec3(rd.x*s2i+rd.z*s2i,rd.y,rd.z*s2i-rd.x*s2i);\n    vec3 zo = vec3(ro.x*s2i+ro.y*s2i,ro.y*s2i-ro.x*s2i,ro.z);\n    vec3 zd = vec3(rd.x*s2i+rd.y*s2i,rd.y*s2i-rd.x*s2i,rd.z);\n    \n    float d = inf;\n    float g = (PI*2.0)/teeth*0.5;\n    float time = iTime*0.5;\n    \n    gear(ro, rd, 0.6, teeth, time);\n    gear(-ro, -rd, 0.6, teeth, -time);\n    gear(-ro.yzx, -rd.yzx, 0.6, teeth, -time);\n    gear(ro.yzx, rd.yzx, 0.6, teeth, time);\n    gear(ro.zxy, rd.zxy, 0.6, teeth, time);\n    gear(-ro.zxy, -rd.zxy, 0.6, teeth, -time);\n    time += g;\n    gear(-xo, -xd, 0.6, teeth, time);\n    gear(xo, xd, 0.6, teeth, -time);\n    gear(-xo.zxy, -xd.zxy, 0.6, teeth, time);\n    gear(xo.zxy, xd.zxy, 0.6, teeth, -time);\n    \n    gear(-yo, -yd, 0.6, teeth, time);\n    gear(yo, yd, 0.6, teeth, -time);\n    gear(-yo.yzx, -yd.yzx, 0.6, teeth, time);\n    gear(yo.yzx, yd.yzx, 0.6, teeth, -time);\n    \n    gear(-zo.yzx, -zd.yzx, 0.6, teeth, time);\n    gear(zo.yzx, zd.yzx, 0.6, teeth, -time);\n    gear(-zo.zxy, -zd.zxy, 0.6, teeth, time);\n    gear(zo.zxy, zd.zxy, 0.6, teeth, -time);\n    return d;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec2 bound = sphere(ro, rd, 1.0);\n    vec2 innerBound = sphere(ro, rd, 0.8);\n    if (bound.x >= inf) return vec3(0);\n    float d = hitShape(ro+rd*bound.x, rd)+bound.x;\n    \n    float dis = d;\n    if (dis >= bound.y) return vec3(0);\n    if (dis >= innerBound.x) {\n        d = hitShape(ro+rd*innerBound.y, rd)+innerBound.y;\n        if (d > bound.y) return vec3(0);\n    };\n    vec3 p = ro+rd*d;\n    return vec3(mix(vec3(0.6), vec3(1), 1.-1./(0.5+10.*(length(p)-0.8)))*exp(-d)*20.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = vec2(iTime*0.5, 0.75*sin(iTime*0.5)+PI*0.5);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*4.25;\n    vec3 rd = getRay(-normalize(ro), uv);\n    vec3 color = getColor(ro, rd);\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 74, 101, 315], [342, 342, 391, 391, 604], [605, 605, 641, 641, 700], [701, 701, 747, 747, 1139], [1140, 1140, 1224, 1224, 2235], [2373, 2373, 2413, 2413, 3732], [3733, 3733, 3772, 3772, 4257], [4258, 4258, 4315, 4315, 4719]], "test": "untested"}
{"id": "dlSyDw", "name": "Flow Plot (vec3 visualization)", "author": "gehtsiegarnixan", "description": "This shader uses a flow map to depict 3D vectors on a 2D surface, enhancing vector visualization over color-based approaches.", "tags": ["3d", "sphere", "flow", "plot", "vector", "material", "vectorfield"], "likes": 2, "viewed": 210, "published": 3, "date": "1691838065", "time_retrieved": "2024-07-30T17:39:47.673477", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis shader visualizes 3D vectors on a 2D surface using a flow map technique.\nThe lines represent vector directions, with colors denoting the X, Y, and Z \naxes.\n\nThe flow map displaces a 3D texture in the direction of the vector, aligning\nlines perpendicular to the vectors, similar to wind waves. Lines fade as\nthey move from the undisturbed grid.\n\nThe shader aims to improve vector visualization compared to color-based\nrepresentations and 3D quiver plots on 2D surfaces.\n\nThe shown vector field is a volume noise texture.\n\nFor related concepts, explore temporal flow maps:\n(https://catlikecoding.com/unity/tutorials/flow/texture-distortion/).\n\nFeel free to use it.\n*/\n\n// 3D cube grid with lines in RGB for XYZ axes\nvec3 cubeGrid(vec3 uvw, float lineThickness) {\n    // Side distance of the cube\n    vec3 sideDistBig = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Smaller scaled side distance of the cube\n    float detailScale = 4.0;\n    uvw *= detailScale;\n    vec3 sideDistDetail = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Merge grids\n    vec3 joined = min(sideDistBig, sideDistDetail);\n    \n    // Create hard outlines of sides\n    return step(joined, vec3(lineThickness)); \n}\n\n// Split cubemap, with poles and equator separate\nvec3 flowPlot(vec3 uvw) {\n    // should probably be input paramters\n    float gridScale = 1.3;\n    float lineThickness = 0.02;\n    float time = iTime * 0.25;\n    float vectorScale = 0.5;\n    \n    // Sample vector field/flow map\n    vec3 noise = texture(iChannel0, uvw * 0.05).xyz;\n    vec3 direction = noise * 2.0 - 1.0; // Scale to -1 to 1\n    direction *= vectorScale;\n    \n    uvw *= gridScale;\n    \n    // Static grid (looks calmer)\n    vec3 grid = cubeGrid(uvw, lineThickness);\n    \n    // Animated grid\n    int count = 7;\n    for (int index = 1; index < count; index += 1) {\n        // Unique percentage of each individual grid \n        float percent = fract(float(index) / float(count - 1) + time);        \n        // Fading brightness\n        float brightness = 1.0 - percent;\n        \n        // Scale offset\n        vec3 offset = percent * direction;\n        \n        // Sample grid\n        vec3 aniGrid = cubeGrid(uvw - offset, lineThickness);\n        \n        // Apply brightness which fades with distance\n        aniGrid *= brightness;\n\n        // Add to the existing grid color output\n        grid = max(grid, aniGrid);\n    }\n    \n    return grid;\n}\n\n// ________________________Ray Marching section________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n    } else {\n        mx = mm2(iTime*.1+um.x*5.);\n        my = mm2(iTime*0.05+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float t = iSphere(ro,rd);\n    vec3 col = vec3(0);\n    // Background mapping\n    col = flowPlot(rd)*0.5;\n    \n    if (t > 0.)\n    {\n    \tvec3 pos = ro+rd*t;\n        // Sphere mapping\n    \tcol = flowPlot(pos);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSyDw.jpg", "access": "api", "license": "mit", "functions": [[1755, 1802, 1848, 1881, 2261], [2263, 2313, 2338, 2380, 3476], [3623, 3623, 3644, 3644, 3696], [3698, 3698, 3737, 3737, 3890], [3892, 3892, 3949, 3949, 4722]], "test": "untested"}
{"id": "DlScWw", "name": "Arabesque knots 6 (music)", "author": "jarble", "description": "An arabesque knot pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "knot", "arabesque"], "likes": 8, "viewed": 197, "published": 3, "date": "1691814994", "time_retrieved": "2024-07-30T17:39:48.502261", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 7; k++){\n        uv =\n            abs(.5+uv+t2)\n        ;\n        \n        //if(uv.y>uv.x) uv = uv.yx-vec2(.5,1.5); else if((k)%3 == 1) uv -= vec2(.5,1.5); else uv *= 1.5;\n        if(uv.y>uv.x) uv = uv.yx-vec2(.5,1.5); else uv *= 1.5; if((k)%3 == 0) uv -= vec2(.5,1.5); \n        //if(uv.y>uv.x) uv = (uv.yx-vec2(.5,1.5))*1.5;\n        t2 =\n            -triangle_wave(uv-.5)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        col =\n            vec3(col.zx,max(uv.x-uv.y,0.))\n            //vec3(col.zx,max(uv.x-uv.y,col.y))\n        ;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\nfloat fmod(float a, float b){\n    return\n        //mod(floor(8./b+a*b/8./2.),b)\n        mod(floor(16./b+a*b/8.),b)\n        //mod(floor(8./b-a*b/8.),b)\n        //mod(floor(a*b/8.),b)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  time /= 2.;\n  float s1 =\n      8.,\n  s2 = 8.,\n  t = time/4.,\n  m1 = fmod(t*8.,s1/2.),\n  p1 = pow(2.,m1)\n  ;\n  t = \n      s1*pow(2.,fmod(t*16.+m1,2.))*t/(1.+fmod(floor(t*4.),2.))\n  ;\n  float\n  m3 =\n      floor(fmod(time*8.*p1,s1/2.)/2.)\n  ;\n  float m2 =\n      1. + fmod(t*8.,s1/2.);\n  ;\n  float a=\n      128.*pow((1.-sqrt(fract(t)/2.))/2.,2.)\n  ;\n  float nb =\n      pow(2.,(m3/2.+m2-m1)/2.5+8.)\n      //pow(2.,(m3+m2-m1)/7.+8.)\n  ;\n  return\n      abs(.5-1.*vec2(fract(time*nb*.998),fract(time*nb)))*a\n      //log(1.+abs(a/16.-abs(.5-1.*vec2(fract(time*nb*.998),fract(time*nb)))*a))\n  ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlScWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 193], [195, 195, 252, 252, 1163]], "test": "untested"}
{"id": "clScWw", "name": "Mandlebrot w/ Zoom", "author": "RnkSngh", "description": "Simple mandlebrot with zoom! ", "tags": ["mandlebrot"], "likes": 0, "viewed": 132, "published": 3, "date": "1691812977", "time_retrieved": "2024-07-30T17:39:49.363957", "image_code": "highp float; \n\n// (a+ bi)^2 = a^2 - b^2 + 2abi\nvec2 squareComplexNumber( vec2 c){\n    return vec2( pow(c.x,  2.) - pow(c.y, 2.) , 2.*c.x*c.y);\n}\n\nhighp float countIterations(vec2 c){\n    int maxIter = 100;\n    highp float threshold = 200.;\n    int currentIterations = 0; \n    vec2 z = vec2(0);\n    \n    while( currentIterations < maxIter && length(z) < threshold ){\n    \n        z  = squareComplexNumber(z) + c;\n        currentIterations++;\n    }\n    \n    highp float normalized = float(currentIterations)/float(maxIter);\n    \n    return normalized;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Transform uv to be centered on 0,0 and normalize to be length 1\n    vec2 uv = fragCoord/iResolution.xy ;\n    uv = uv + vec2(- 0.5);\n    \n    // Zoom based on frame\n    highp float timeFactor;\n    highp float iframeFloat = float(iFrame);\n    timeFactor= pow(1.01 , - iframeFloat );\n    uv= uv*timeFactor;\n    \n    // Transform to an interesting point \n    uv = uv - vec2(1.5, 0);\n\n    // Output to screen\n    highp float iterations = countIterations(uv);\n    fragColor = vec4(vec3(iterations, iterations*sin(iTime), iterations*cos(iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clScWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 47, 81, 81, 144], [554, 554, 611, 682, 1164]], "test": "untested"}
{"id": "dlScD1", "name": "ElectronOrbitals", "author": "NoddyDirksen", "description": "Electron orbitals\nChange the paramters; N, L and M to see different orbitals. \nRemember that N should be between 1 and 7, L should be between 0 and N - 1 and M should be between -L and L.\nHowever, for N=7 only L=1 is a possible orbit.", "tags": ["electrons", "physics", "orbitals", "atoms", "quantomphysics"], "likes": 10, "viewed": 180, "published": 3, "date": "1691780940", "time_retrieved": "2024-07-30T17:39:50.242608", "image_code": "// CHANGE THESE PARAMETERS:\nint N = 6; int L = 3; int M = 1;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat a_0 = 0.01;\nint Z = 1;\n\n//table generated in processing (For normalization)\nfloat weights[140] = float[140](343202.12, 186275.58, 155640.55, 298882.8, 155640.55, 44121.52, 41445.11, 141595.47, 41445.11, 47218.89, 64757.6, 207019.28, 64757.65, 47218.9, 14995.13, 13113.93, 51138.72, 13113.93, 14940.22, 20488.86, 87305.66, 20488.85, 14940.22, 18380.66, 18301.49, 28210.77, 123963.88, 28210.81, 18301.51, 16776.45, 6308.71, 5371.58, 21486.21, 5371.58, 6119.35, 8392.0, 36287.42, 8392.02, 6119.35, 18145.31, 7496.24, 11554.66, 51002.49, 11554.69, 7496.23, 6871.55, 170316.92, 62744.87, 9221.62, 14756.83, 65682.28, 14756.81, 9221.03, 7454.48, 7571.13, 3084.05, 2590.6, 10362.29, 2590.6, 2951.02, 4047.15, 17499.04, 4047.15, 2951.02, 23026.0, 3615.0, 5572.12, 24595.08, 5572.12, 3615.0, 3313.8, 207514.52, 76178.31, 4448.44, 7116.36, 31675.59, 7116.37, 4446.68, 3594.87, 3651.09, 500000.0, 491490.47, 132158.58, 5541.46, 8668.55, 38745.6, 8668.2, 5324.26, 4122.79, 3681.53, 3963.87, 1680.02, 1398.46, 5593.84, 1398.46, 1592.83, 2184.42, 9445.42, 2184.42, 1592.83, 26426.35, 1951.25, 3007.64, 13275.7, 3007.64, 1951.25, 1788.67, 239601.66, 89075.74, 2403.16, 3841.15, 17095.78, 3841.14, 2400.15, 1940.4, 1970.76, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 500000.0, 500000.0, 500000.0, 500000.0, 290962.38, 369260.75, 500000.0, 369250.9, 228901.84, 173593.95, 148123.94, 140033.84, 156570.36);\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec2 complexDivision(vec2 a, vec2 b){\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / float(b.x * b.x + b.y * b.y);\n}\n\nint factorial(int n){\n    int product = 1;\n    for(int i = 2; i <= n; i++){\n        product *= i;\n    }\n    return product;\n}\n\nfloat laguerre(int n, int alpha, float x){\n    if(n == 0)\n        return 1.0;\n    \n    float lsub = 1.0;\n    float l = float(alpha) - x + 1.0;\n    float ladd = 0.0;\n    for(int k = 1; k < n; k++){\n        ladd = ((2.0 * float(k) + 1.0 + float(alpha) - x) * l \n            - (float(k) + float(alpha)) * lsub) / (float(k) + 1.0);\n        lsub = l;\n        l = ladd;\n    }\n    \n    return l;\n}\n\nint pochhammer(int x, int n){\n    int product = 1;\n    \n    for(int i = 0; i < n; i++){\n        product *= (x + i);\n    }\n    \n    return product;\n}\n\nvec2 associatedLegendrePolynomial(int l, int m, float x){\n    float sum = 0.0;\n    for(int k = 0; k <= l; k++){\n        if(k - m < 0)\n            continue;\n        sum += float(pochhammer(-l, k) * pochhammer(l + 1, k)) / \n            float(factorial(k - m) * factorial(k)) * pow((1.0 - x) / 2.0, float(k));\n    }\n    float imTop = 0.0, reTop = 0.0, imBottom = 0.0, reBottom = 0.0;\n    \n    if(1.0 + x < 0.0){\n        imTop = pow(abs(1.0+x), float(m) / 2.0);\n    }\n    else{\n        reTop = pow(1.0+x, float(m) / 2.0);\n    }\n    if(1.0 - x < 0.0){\n        imBottom = pow(abs(1.0-x), float(m) / 2.0);\n    }\n    else{\n        reBottom = pow(1.0-x, float(m) / 2.0);\n    }\n        \n    vec2 fraction = complexDivision(vec2(reTop, imTop), vec2(reBottom, imBottom));\n    float frac = pow(abs(1.0+x), float(m) / 2.0) / pow(abs(1.0-x), float(m) / 2.0);\n    \n    return fraction * sum;\n}\n\nvec2 sphericalHarmonics(int l, int m, float theta){\n    float c = sqrt(float(2 * l + 1) * float(factorial(l - m)) \n        / (4.0 * 3.14 * float(factorial(l + m))));\n    vec2 polynomial = associatedLegendrePolynomial(l, m, cos(theta));\n    return c * polynomial;\n}\n\nfloat waveFunction(int n, int l, int m, float r, float theta, float phi){\n    float underSqrt = sqrt(pow(2.0 / (float(n) * a_0), 3.0) \n        * float(factorial(n - l - 1)) / float(2 * n * factorial(n + l)));\n    float rho = float(Z) * r / a_0;\n    float exponents = exp(-rho / 2.0) * pow(rho, float(l));\n    float laguerre = laguerre(n - l - 1, 2 * l + 1, rho);\n    float harmonics = length(sphericalHarmonics(l, m, theta));\n        \n    return underSqrt * laguerre * exponents * harmonics;\n}\n\nint location(int n, int l, int m){\n    return n * (n-1) * (2 * n - 1) / 6 + l * (l+1) + m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / (iResolution.y + 0.0);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = vec3(uv.y + 0.5) * vec3(84, 22, 235) / 255.0;\n    \n    // Output to screen\n    \n    vec3 sphereCenter = vec3(0, 0, 8);\n    float radius = 1.5;\n    \n    vec3 ray = vec3(vec2(uv.x * aspectRatio, uv.y) - vec2(0.5 * aspectRatio, 0.5), 2);\n    float rz = ray.z;\n    float rx = ray.x;\n    /*ray.x = rx * cos(iTime) - rz * sin(iTime);\n    ray.z = rz * cos(iTime) + rx * sin(iTime);*/\n    ray /= length(ray);\n    vec3 rayOrigin = vec3(0, sin(0.0), 0);\n    \n    float t = dot(sphereCenter - rayOrigin, ray);\n    vec3 p = rayOrigin + ray * t;\n    \n    float y = length(sphereCenter - p);\n    float x = sqrt(radius * radius - y * y);\n    float absorption = 0.0;\n    vec3 colorGained = vec3(0); \n    if(y < radius){\n        float t1 = t-x;\n        float t2 = t+x;\n        float distanceTravelled = abs(t1 - t2);\n        absorption = 1.0 - exp(-distanceTravelled * 1.0);\n        float stepSize = 0.01;\n        \n        float dist = 0.0;\n        float prevWaveFunction = 0.0;\n        for(int i = 1; float(i) < distanceTravelled / stepSize; i++){\n            vec3 pos = rayOrigin + ray * t1 + ray * stepSize * float(i);\n            vec3 prevPos = rayOrigin + ray * t1 + ray * stepSize * float(i - 1);\n            vec3 toCenter = normalize(pos - sphereCenter);\n            float theta = acos(dot(vec3(0, 1, 0), toCenter));\n            float phi = atan(toCenter.x, toCenter.z);\n            float multiplier = 1.0;\n            float totalWeight = weights[location(N, L, M)];\n            if(totalWeight > 0.001)\n                multiplier = 1.0 / totalWeight;\n            \n            float signedWaveFunction = waveFunction(N, L, M, length(pos - sphereCenter) \n                / 5.0, theta, 0.0);\n            float waveFunction = pow(signedWaveFunction, 2.0) * multiplier * 7500.0;\n                \n            float avr = (waveFunction + prevWaveFunction) / 2.0;\n            dist += avr * stepSize;\n            prevWaveFunction = waveFunction;\n            \n            float hue = (cos(float(M) * (phi + iTime)) + 1.0) / 2.0;\n            \n            vec2 harmonics = sphericalHarmonics(L, M, theta);\n            float colorMultiplier = 1.0;\n            if(harmonics.x < 0.0)\n                colorMultiplier *= -1.0;\n            if(signedWaveFunction < 0.0)\n                colorMultiplier *= -1.0;\n            //colorGained += HSVtoRGB(vec3(hue, 1.0, avr * stepSize));\n            colorGained += vec3(max(0.0, colorMultiplier), 0, max(0.0, -colorMultiplier)) * 0.005;\n        }\n        absorption = 1.0 - exp(-dist / 10.0);\n        \n    } else {\n        \n    }\n    col = mix(col * 0.5, colorGained, absorption);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlScD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1485, 1485, 1514, 1595, 1709], [1710, 1710, 1738, 1787, 1867], [1869, 1869, 1906, 1906, 2002], [2004, 2004, 2025, 2025, 2129], [2523, 2523, 2552, 2552, 2671], [2673, 2673, 2730, 2730, 3550], [3552, 3552, 3603, 3603, 3816], [4313, 4313, 4347, 4347, 4405], [4407, 4407, 4463, 4513, 7349]], "test": "untested"}
{"id": "clSyDD", "name": "quadtree distance of edge", "author": "lanx06", "description": "quadtree", "tags": ["tree", "quad", "quadtree"], "likes": 11, "viewed": 207, "published": 3, "date": "1691776586", "time_retrieved": "2024-07-30T17:39:51.005569", "image_code": "#define T iTime*0.5\n//#define pix 1.8/iResolution.y\nfloat shape(vec2 uv,int i){\n    vec2 l = uv-0.5;\n    float thin=0.15;\n    float radius=0.5;\n    float pix=1.3*float(1<<i)/iResolution.y;\n\n    float a= smoothstep(radius+pix,radius-pix,length(l));\n    //float a= smoothstep(pix,-pix,abs(length(l)-radius)-thin);\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n=500.0;\n    float pix= 1.3/iResolution.y;\n    float scale=iResolution.y*0.7;\n\n    vec2 st = (fragCoord/scale);\n    vec2 uv=fract(st);\n    float r=0.35;\n    vec2 p=vec2(cos(T),sin(T*0.333))*0.5+vec2(iResolution.x/scale*0.5,0.5);\n    if((iMouse.z > 1.0))\n        p=iMouse.xy/scale;\n    vec2 origin=0.5+floor(st);\n    float l;\n    vec3 col ;\n    int i=0;\n    for(i=0;i<6;i++){\n        float size=pow(0.5,float(i+1));\n        float r2=size;\n        l=distance(p,origin);\n        //not interset\n        if(l>=r2+r)\n            break;\n        //interset\n        else if(l> max(r2,r)-2.0*min(r2,r))\n            ;\n        //contain\n        else if(r2<=r)\n            break;\n        origin+=(step(vec2(0.5),uv)-0.5)*size;\n        uv=fract((uv-0.5)*2.0);   \n    }\n    col.rgb=vec3(shape(uv,i));\n    //col.rg=vec2(origin);\n    float v=smoothstep(pix,-pix,length(st-p)-r);\n    col.rgb=mix(1.0-col.rgb,col.rgb,v);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 52, 79, 79, 327], [329, 329, 386, 386, 1331]], "test": "untested"}
{"id": "DlByWD", "name": "spectrum of pseudo-bluenoise", "author": "FabriceNeyret2", "description": "show the power spectrum of pseudo-bluenoise ( set in BuffA )  \n- LF 3x3 filtering ( LOD0 - LOD1 )\n- LF 11x11 Lanczos filtering ( = 49 coefs )\n- LF 12x12 Bessel-Lanczos\n- ref bluenoise\nSee also on Poisson disc https://www.shadertoy.com/view/MssfDf", "tags": ["fft", "sampling", "fourier", "bluenoise", "dft"], "likes": 15, "viewed": 427, "published": 3, "date": "1691763989", "time_retrieved": "2024-07-30T17:39:51.776507", "image_code": "// === testing various pseudo-bluenoise spectrums ( def in BuffA ) ====================\n// fork from Fourier-based transform (e.g. kernel convolution) using https://www.shadertoy.com/view/4s3GDs\n\n// adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS#\n// see also https://www.shadertoy.com/view/4dGGz1 to play with spectrum.\n\n\n\nvec4 paintDFT(vec2 F) {\n     // return vec4( log(length(F)) / log(SIZE*SIZE) );   // log scale\n        return vec4( length(F) / SIZE );                  // linear scale    \n}\n\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,     \n     pixel = ( u - R/2.) / SIZE  + vec2(2,1)/2.,\n      tile = floor(pixel),\n         U = fract(pixel) * SIZE / R ;\n\n    O *= 0.;\n    \n    if(tile == vec2(0,0))  // Input (Left)\n        O += texture(iChannel0, U).x;        \n\n    if(tile == vec2(1,0))  // DFT (Right)\n        O += paintDFT(texture(iChannel1, U).xy);  \n\n\n  //if(tile.y>0.) O += texture(iChannel0, U/iResolution.xy).x; // displayed values in top margin   \n    if (tile != mod(tile,vec2(2,1))) O+=.3;  \n    \n  if ( pixel.x<0. && int(4.*u.y/R.y)==int(iTime)%4 )   // show demo id\n     O.r += smoothstep( 1.5,0.,length(u-vec2(R.x/4.-SIZE/2.,R.y*mod(floor(iTime)+.5,4.)/4.)) -R.y/30. );\n   \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === testing various pseudo-bluenoise spectrums ====================\n// Lanczos pseudoblue from https://www.shadertoy.com/view/dtlyzs\n// but L(x)L(y) is not isotropic and has altered spectrum.\n// My Bessel-Lanczos fixels that. see: https://www.desmos.com/calculator/wqjt4vsodz\n// See also on Poisson disc spectrum: https://www.shadertoy.com/view/MssfDf\n// Void And Cluster ( no spectrum ): https://www.shadertoy.com/view/mt2cWR\n\nconst float a = 3., n = a-.5, N = 2., PI = 3.1415927;\n\n  #define L(i)    ( i==0. ? 1. : i > a ? 0. : a* sin(PI*i)*sin(PI*i/a) / ( PI*PI*i*i ) ) // Lanczos\n//#define L(i) float[]( 1., .60793, 0., -.13509, 0., .024317 )[abs(int(i+i))]            // for a=3,N=2\n  #define B(i)    ( i==0. ? 1. : i > 3. ? 0. : J0(PI*i/1.09) * J0(PI*i/3.6/1.09) )       // Lanczos-like with Bessel\n\n\n#define blue() (                                          /* 3x3 low-pass filter */ \\\n          (  H(-1,-1) +     H(0,-1)  + H(1,-1)  \\\n           + H(-1, 0) - 8.* H(0, 0)  + H(1, 0)  \\\n           + H(-1, 1) +     H(0, 1)  + H(1, 1)  \\\n          ) *.5/9. *2.1 +.5 )         \n//#define H(i,j) texture( iChannel0, ( u + vec2(i,j) ) /256. )\n  #define H(i,j)  hash( u + vec2(i,j) )\n\n\nfloat J0(float x)                                         // BesselJ0 from https://www.shadertoy.com/view/Wt3czM\n{\n    float  xx = x * x,\n         lamb = .865,\n         q    = .7172491568,\n         p0   = .6312725339,\n         ps0  = .4308049446,\n         p1   = .3500347951,\n         ps1  = .4678202347,\n         p2   =-.06207747907,\n         ps2  = .04253832927,\n        lamb4 = (lamb * lamb) * (lamb * lamb),\n           t0 = sqrt(1. + lamb4 * xx),\n           t1 = sqrt(t0);\n    \n    return xx == 0. ? 1. :   ( (p0 + p1*xx + p2*t0) * cos(x) + ( (ps0 + ps1*xx) * t0 + ps2*xx ) * sin(x)/x )\n                           / ( t1 * (1. + q * xx) )  ;\n}\n\n//#define W(i,j)  ( 2.* texture( iChannel0, ( u +N*vec2(i,j) ) / 256. ) - 1. )   // white noise to be filtered\n  #define W(i,j)  ( 2.* hash( u + N*vec2(i,j)+1234.567 ) - 1. )\nfloat hash( vec2 f )                                      // quality integer hash from https://www.shadertoy.com/view/fsKBzw\n{   uvec2 x = floatBitsToUint(f),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n        O *= 0.; \n        \n        int i = int(iTime)%4;\n        \n        if ( i== 0 )\n            O = vec4( blue() );\n        else if (i == 1 ) {                               // --- Lanczos filter\n            for( float y=-n; y<=n; y+= 1./N )\n                for( float x=-n; x<=n; x+= 1./N )\n                   O += L(x)*L(y) * W(x,y);\n                // O += L(sqrt(x*x+y*y)) * W(x,y);\n\n            O = .5 + .65*( W(0.,0.) - O/(N*N) );          // white noise minus its low freqs\n        }\n        else if (i == 2 ) {                               // --- Bessel-Lanczos filter\n            float N = 1., n = 6.;                         // try commenting for just the ring\n            for( float y=-n; y<=n; y+= 1./N )\n                for( float x=-n; x<=n; x+= 1./N )\n                   O += B(sqrt(x*x+y*y)/1.2) * W(x,y);    // 1.2 to adjust the ring to frequency domain border.\n\n            O = .5 + .4*  O/(N*N);                \n        }\n        else O = texelFetch(iChannel1, ivec2(u)%1024, 0); // reference bluenoise texture\n        \n        O=O.rrrr;\n        \n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fourier transform of the input\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\n#define tex(ch,x,y)  texelFetch(ch, ivec2(x,y), 0)\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O-=O; \n    \n    if(uv.x > SIZE || uv.y > SIZE) return;\n        \n    for(float n = 0.; n < SIZE; n++)  {\n        vec2 xn = tex(iChannel0, n+.5, uv.y).xy,\n             yn = tex(iChannel1, uv.x, n+.5).zw,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;\n        \n        O.zw += cmul(xn, a.x);\n        O.xy += cmul(yn, a.y);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SIZE (2.*floor(iResolution.x/4.*.8)) // 256. \n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlByWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 337, 360, 431, 511], [514, 514, 553, 553, 1239]], "test": "untested"}
{"id": "DtBcWW", "name": "Bayer Matrix Generator ( 163 ch)", "author": "FabriceNeyret2", "description": "golfing 466 chars \"Bayer Matrix Generator\" by MartyMcFly. https://shadertoy.com/view/XtV3RG", "tags": ["dither", "algorithm", "short", "bayer", "onetweet", "golf"], "likes": 13, "viewed": 318, "published": 3, "date": "1691753602", "time_retrieved": "2024-07-30T17:39:52.543456", "image_code": "// golfing 466 chars \"Bayer Matrix Generator\" by MartyMcFly. https://shadertoy.com/view/XtV3RG\n\n\n#define N 6\nfloat n = float(1<<N);  // size n x n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    int s,i;   \n    for( ivec2 I = ivec2( n * U/iResolution.y ) ; i++ < N ; I/=2 )\n        s =  s*4 +  ( 4 - I.x%2 - I.y%2 *2 ) % 4 ;   // Bayer 2x2\n    O = vec4(s) / n/n;\n    \n    \n/* // 175 chars\n    ivec2 I = ivec2( n * U/iResolution.y) , J;\n    int s,i;   \n    for( ; i<N ; i++ )\n        J = I >> N-1-i &1,\n        s += ( 4 - J.x - 2*J.y ) % 4 << 2*i;   // Bayer 2x2\n    O = vec4(s) / n/n;\n/**/\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 187, 187, 589]], "test": "untested"}
{"id": "dlByzD", "name": "Watercolor Webcam Filter", "author": "ascomycody", "description": "A filter using Difference of Gaussians with a 7x7 kernel. Very messy code and lots of artifacts :)", "tags": ["matrix", "gaussian", "7x7"], "likes": 0, "viewed": 160, "published": 3, "date": "1691711808", "time_retrieved": "2024-07-30T17:39:53.312401", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 d = vec2(dx, dy);\n    \n    \n    vec3 gk0 = Apply7x7Filter(uv, d, ic0, gk7x7, gk7x7_d);\n    vec3 gk1 = vec3(1.) - texture(ic1, uv).gbb;\n    vec3 gk2 = texture(ic2, uv).rgb;\n    vec3 gk3 = texture(ic3, uv).rgb;\n    \n    //vec3 col = mix(gk1, gk0, .5) - (gk3 * .75) - (gk2) - (vec3(1.) - smoothstep(0., 0.01, gk0)); \n    \n    vec3 col = vec3(pow(mix(gk1, gk0, 0.25).r, BRIGHT), pow(mix(gk1, gk0, 0.1).g, BRIGHT), pow(mix(gk1, gk0, 0.1).b, BRIGHT));\n    \n    fragColor = vec4( (col * 3.), 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//----------Constants---------------------------------\n\n#define TAU .1\n#define RHO 2.5\n#define BRIGHT 1.5\n\n#define COLOR_STEPS 2.\n#define COLOR_STEPS_R 1. / COLOR_STEPS\n\n#define CONTRAST_THRESHOLD .25\n#define CONTRAST_RANGE .1\n\n\n#define ic0 iChannel0\n#define ic1 iChannel1\n#define ic2 iChannel2\n#define ic3 iChannel3\n\n#define sampleDist 1.\n\n#define dx sampleDist / iResolution.x\n#define dy sampleDist / iResolution.y\n\n#define gk3x3_d 1./16.\n\n#define gk5x5_d 1./273.\n\n#define gk7x7_d 1./1003.\n\n//-------Structs-------------------------------------\n\nstruct mtx7 { mat4 bl; mat3 tl; mat3 br; mat4 tr;};\n\n//--------Kernels-------------------------------------\n\n#define IDENTITY mat3(0.,0.,0.,0.,1.,0.,0.,0.,0.)\n\n#define EDGE mat3(-1.,-1.,-1.,-1.,8.,-1.,-1.,-1.,-1.);\n\n#define XSOBEL mat3(1.,0.,-1.,2.,0.,-2.,-1.,0.,1.)\n#define YSOBEL mat3(1.,2.,1.,0.,0.,0.,-1.,-2.,-1.)\n\n#define SHARPEN mat3(0.,-1.,0.,-1.,5.,-1.,0.,-1.,0.)\n\n#define G3X3  mat3(1., 2., 1., 2., 4., 2., 1., 2., 1.)\n\nmtx7 gk3x3 = mtx7(mat4(0., 0., 0., 0.,\n                       0., 0., 0., 0.,\n                       0., 0., 1., 2.,\n                       0., 0., 2., 4.),\n                  mat3(0., 0., 0.,\n                       0., 0., 0.,\n                       1., 0., 0.),\n                  mat3(0., 0., 1.,\n                       0., 0., 0.,\n                       0., 0., 0.),\n                  mat4(4., 2., 0., 0.,\n                       2., 1., 0., 0.,\n                       0., 0., 0., 0.,\n                       0., 0., 0., 0.));\n\nmtx7 gk5x5 = mtx7(mat4(0., 0.,  0.,  0.,\n                       0., 1.,  4.,  7.,\n                       0., 4., 16., 26.,\n                       0., 7., 26., 41.),\n                  mat3( 0., 0., 0.,\n                        4., 1., 0.,\n                       16., 4., 0.),\n                  mat3(0., 4., 16.,\n                       0., 1.,  4.,\n                       0., 0.,  0.),\n                  mat4(41., 26., 7., 0.,\n                       26., 16., 4., 0.,\n                        7.,  4., 1., 0.,\n                        0.,  0., 0., 0.));\n\nmtx7 gk7x7 = mtx7(mat4(0.,  0.,  1.,   2.,\n                       0.,  3., 13.,  22.,\n                       1., 13., 59.,  97.,\n                       2., 22., 97., 159.),\n                  mat3( 1.,  0., 0.,\n                       13.,  3., 0.,\n                       59., 13., 1.),\n                  mat3(1., 13., 59.,\n                       0.,  3., 13.,\n                       0.,  0.,  1.),\n                  mat4(159., 97., 22., 2.,\n                        97., 59., 13., 1.,\n                        22., 13.,  3., 0.,\n                         2.,  1.,  0., 0.));\n                         \n//-------Matrix Functions---------------------------------------------------------\n                       \nfloat gkVal(in mtx7 w, in float u, in int x, in int y)\n{\n    float z = (x<=3) ? (y<=3) ? w.bl[x][y] : (x<=2) ? w.tl[x][int(mod(float(y),4.))] : w.tr[int(mod(float(x),3.))][int(mod(float(y+1),4.))] : (y<=2) ? w.br[int(mod(float(x),4.))][y] : w.tr[x-3][y-3];\n    \n    return ( z * u );\n}\n\n//---------Kernel Functions-------------------------------------------------------\n\nvec3 Apply3x3Kernel(in mat3 r, in mat3 b, in mat3 g, in mat3 m, in float n)\n{   \n    vec3 x;\n    \n    for( int j = 0; j < 3; j++){\n    for( int i = 0; i < 3; i++){\n    \n        float a = m[i][j];\n        \n        x.r += r[i][j] * a;\n        x.g += b[i][j] * a;\n        x.b += g[i][j] * a;\n    }   \n    }\n    \n    return vec3(x.r, x.g, x.b) * n;\n}\n\nvec3 Apply7x7Kernel(in mat3 r, in mat3 b, in mat3 g, in mtx7 m, in float n)\n{   \n    vec3 x;\n    \n    for( int j = 0; j < 7; j++){\n    for( int i = 0; i < 7; i++){\n    \n        float a = gkVal(m, n, i, j);\n        \n        x.r += r[i][j] * a;\n        x.g += b[i][j] * a;\n        x.b += g[i][j] * a;\n    }   \n    }\n    \n    return vec3(x.r, x.g, x.b);\n}\n\n//---Filter Functions---------------------------------------------------------------------------\n\nvec3 Apply3x3Filter(in vec2 p, in vec2 d, in sampler2D x, in mat3 m, in float n)\n{    \n\n    mat3 r;\n    mat3 g;\n    mat3 b;\n    \n    for( int j = -1; j <= 1; j++ ){\n    for( int i = -1; i <= 1; i++ ){\n    \n            ivec2 o = ivec2(i, j);\n            vec2 pos = p + (vec2(o) * d * .5);\n        \n            r[i + 1][j + 1] = texture(x, pos).r;\n            g[i + 1][j + 1] = texture(x, pos).g;\n            b[i + 1][j + 1] = texture(x, pos).b;\n    }\n    }\n    \n    return Apply3x3Kernel(r, g, b, m, n);\n}\n\nvec3 Apply7x7Filter(in vec2 p, in vec2 d, in sampler2D x, in mtx7 m, in float n)\n{    \n\n    mat3 r;\n    mat3 g;\n    mat3 b;\n    \n    for( int j = -3; j <= 3; j++ ){\n    for( int i = -3; i <= 3; i++ ){\n    \n            ivec2 o = ivec2(i, j);\n            vec2 pos = p + (vec2(o) * d * .5);\n        \n            r[i + 3][j + 3] = texture(x, pos).r;\n            g[i + 3][j + 3] = texture(x, pos).g;\n            b[i + 3][j + 3] = texture(x, pos).b;\n    }\n    }\n    \n    return Apply7x7Kernel(r, g, b, m, n);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 d = vec2(dx, dy);\n    \n    //vec3 gk0 = texture(iChannel0, uv).rgb;\n    vec3 gk1 = Apply7x7Filter(uv, d, ic0, gk7x7, gk7x7_d);\n    //vec3 gk2 = Apply7x7Filter(uv, d, ic0, gk5x5, gk5x5_d);\n    //vec3 gk3 = Apply7x7Filter(uv, d, ic0, gk3x3, gk3x3_d);\n    vec3 gk2 = Apply3x3Filter(uv, d, ic0, G3X3, gk3x3_d);\n    \n    \n    vec3 col = smoothstep(CONTRAST_THRESHOLD, CONTRAST_THRESHOLD + CONTRAST_RANGE, (((1. + TAU) * gk2) - (TAU * gk1)));\n    \n    vec3 col1 = vec3(round(col.r * COLOR_STEPS) * COLOR_STEPS_R, round(col.g * COLOR_STEPS) * COLOR_STEPS_R, round(col.b * COLOR_STEPS) * COLOR_STEPS_R);\n    \n    //fragColor = vec4(col.bbb + col1.rgg, 1.0 );\n    fragColor = vec4(col1.ggg, 1.0 );\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 d = vec2(dx, dy);\n    \n    vec3 gk0 = Apply3x3Filter(uv, d, ic0, G3X3, gk3x3_d);\n    vec3 gk1 = Apply3x3Filter(uv, d, ic0, G3X3, gk3x3_d);\n    \n    vec3 col = vec3(1.) - RHO * (gk1.rrr - vec3(1., gk0.gb));\n    \n    fragColor = vec4( col, 1.0 );\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 d = vec2(dx, dy);\n    \n\n    vec3 gx = Apply3x3Filter(uv, d, ic0, XSOBEL, 1.);\n    vec3 gy = Apply3x3Filter(uv, d, ic0, YSOBEL, 1.);\n    \n    vec3 ge = gx * gx;\n    vec3 gf = gx * gy;\n    vec3 gg = gy * gy;\n    \n    vec3 evp = ((ge + gg) + sqrt((ge-gg)*(ge-gg) + 4. * (gf*gf))) * .5;\n    vec3 evn = ((ge + gg) - sqrt((ge-gg)*(ge-gg) + 4. * (gf*gf))) * .5;\n    \n    vec3 tx = evp - ge;\n    vec3 ty = -gf;\n    \n    vec3 col = vec3(pow((gx.r * 1.) + (gy.r * 1.), 2.)); \n    \n    fragColor = vec4( vec3(smoothstep(0.05, 0.1, col.r)), 1.0 );\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 d = vec2(dx, dy);\n    \n    \n    //vec3 gk0 = texture(ic0, uv).rgb;\n    vec3 gk1 = Apply7x7Filter(uv, d, ic0, gk7x7, gk7x7_d);\n    \n    vec3 col = vec3(pow(gk1.r, .9)); \n    \n    fragColor = vec4( col, 1.0 );\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlByzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 602]], "test": "untested"}
{"id": "mtByW1", "name": "Breathing Donut", "author": "jildert", "description": "its a breathing Donut", "tags": ["breathingdonut"], "likes": 2, "viewed": 106, "published": 3, "date": "1691704256", "time_retrieved": "2024-07-30T17:39:54.073366", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.x / iResolution.y;\n    uv.x*=AR;\n    uv.x-= .5;\n    uv.y-= .08;\n    uv *= 1.2;\n\n    float dis = distance(uv, vec2(.5,.5));\n    \n    float min = 0.2;\n    float max = 0.5;\n    \n    min += sin(iTime) * .1;\n    max += sin(iTime) * .1;\n    dis = clamp(dis, min, max);\n\n    // Output to screen\n    fragColor = vec4(dis * dis, dis, cos(iTime) * dis, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtByW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 525]], "test": "untested"}
{"id": "DlByD1", "name": "Bilinear terrain marching +music", "author": "me_123", "description": "raytraced terrain and good music.", "tags": ["terrain", "music", "heightmap", "normal", "bilinear"], "likes": 14, "viewed": 464, "published": 3, "date": "1691696836", "time_retrieved": "2024-07-30T17:39:55.075686", "image_code": "vec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir*0.5 + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nconst float inf = 10000.;\nvec2 box( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(inf); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2(tN, tF);\n}\nvec4 join(in vec4 a, in vec4 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\nfloat blin(in vec2 p, in vec4 h) {\n    \n    float k = h.x+p.x*h.y-p.x*h.x+p.y*h.z+p.y*p.x*h.w-p.y*p.x*h.z-p.y*h.x-p.y*p.x*h.y+p.y*p.x*h.x;\n    return k;\n}\nfloat blin(in vec3 o, in vec3 d, in vec3 rdi, in vec4 h) {\n    float m = max(max(h.x, h.y), max(h.z, h.w));\n    //if (-(o.z-m)*rdi.z < 0.0) return inf;\n    float a = 0.005+d.y*d.x*(h.w-h.z+h.x-h.y);\n    if (a == 0.0) {\n        return (a = (-o.z+h.x)*rdi.z) >= 0.0?a:inf;\n    }\n    float b = d.y*(o.x*h.w+h.z+h.x*o.x-h.x-h.y*o.x-o.x*h.z)-d.z+h.x*o.y*d.x-d.x*h.x-h.y*o.y*d.x+d.x*h.y+o.y*d.x*h.w-o.y*d.x*h.z;\n    float disc = b*b-4.*a*(o.x*(o.y*(h.x-h.y)+h.y-h.x+o.y*(h.w-h.z))+o.y*(h.z-h.x)+h.x-o.z);\n    if (disc < 0.0) return inf;\n    vec2 roots = (-b+vec2(1, -1)*sqrt(disc))/a;\n    if (roots.x < 0.0) roots.x = inf;\n    if (roots.y < 0.0) roots.y = inf;\n    return min(roots.x, roots.y)*0.5;\n}\nvec3 normall(in vec3 p, in vec4 h) {\n    vec4 l = vec4(h.x,-h.y,-h.z,h.w);\n    return normalize(vec3(h.y-h.x+dot(p.yyyy,l),h.z-h.x+dot(p.xxxx,l),1));\n}\nfloat blinBox(in vec3 ro, in vec3 rd, in vec3 rdi, in vec2 b, in vec4 dat) {\n    vec3 n;\n    float d = blin(ro+rd*b.x, rd, rdi, dat);\n    if (d > b.y-b.x) return inf;\n    d = min(d, b.y-b.x);\n    return d+b.x;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec3 rdi3 = 1./rd;\n    float maxHeight = 36.25;\n    bool inside = ro.z < maxHeight;\n    if (!inside) {\n        float boundPlain = -(ro.z-maxHeight)*rdi3.z;\n        if (boundPlain < 0.0) return vec3(0);\n        ro += rd*boundPlain;\n    }\n    vec2 i = floor(ro.xy);\n    float dist;\n    int ii;\n    vec2 normal;\n    vec2 srd = sign(rd.xy);\n    vec2 rdi = 1./(2.*rd.xy);\n    float old = 0.0;\n    vec2 oldI = i;\n    vec4 s = vec4(1, 1, 0, 1);\n    float c = inf;\n    vec4 u;\n    for (ii = 0; ii < 300; ii += 1) {\n        u = texelFetch(iChannel0, ivec2(oldI+iResolution.xy*0.5), 0);\n            float distt = blinBox(ro-vec3(oldI, 0), rd, rdi3, vec2(old, dist), \n                u\n            );\n            c = min(c, distt);\n\n            if (distt < inf || inside && (ro.z+rd.z*dist > maxHeight)) break;\n        old = dist;\n        oldI = i;\n        vec2 plain = ((1.+srd-2.*(ro.xy-i))*rdi);\n        dist = min(plain.x, plain.y);\n        normal = vec2(equal(vec2(dist), plain))*srd;\n        i += normal;\n    }\n    //return vec3(ii)*0.01;\n    vec3 n;\n    //c = blinBox(ro-vec3(oldI, 0), rd, vec2(old, dist));\n    if (c == inf) return vec3(0);\n    float ground = -(ro.z-0.2)/rd.z;\n    if (ground < 0.0) ground = inf;\n    vec3 p = ro+rd*c;\n    vec3 no = normalize(vec3(\n        u.y-u.x,\n        u.z-u.x,\n        1\n    ));\n    no = normall(vec3(fract(p.xy), p.z), u);\n    return (no*0.5+0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = vec2(iTime*0.8, 1.5);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*10.0;//*max(pow(2., 5.-iTime*2.0), 5.0);\n    vec3 rd = getRay(-normalize(ro), uv);\n    //ro += 1.0;\n    ro.z += 1.0;\n    vec3 color = getColor(ro, rd);\n\n    //super sample\n    fragColor = vec4(color, 1);\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0)*0.1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//music!\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\nfloat f[16] = float[16](\n400.,\n500.,\n450.,\n400.,\n500.,\n450.,\n400.,\n500.,\n500.,\n450.,\n400.,\n300.,\n400.,\n300.,\n400.,\n300.\n);\nfloat noise(in float x) {\n    return mix(hash(uint(floor(x))),hash(uint(floor(x+1.0))),fract(x));//mix(hash(uint(x), x+1, fract(x));//mix(hash(uint(floor(x))), hash(uint(floor(x))), fract(x));\n}\nfloat k(in float x, in float n) {\n    return (sign(-(fract(x)-n))*0.5+0.5)*sin((2.*3.14159*fract(x))/n);\n}\nfloat sound(in float time) {\n    float tm = time;//mod(time, 2.0);\n    float t = tm*3.1415*2.0;\n    float n = f[int(floor(time*3.0))%15];//sin(t*)*400.;\n    float nn = n*0.0001;//hash11(s)*0.4+0.1;\n    float v = sin(t*n);\n    v = sin(t*nn*n+v*n*0.01);\n    v = sin(v*n*0.003+t*n*0.03);\n   // v = sin(t*100.+v*2.0);\n   float vv = v;\n    v *= exp(-fract(time*2.0)*2.0);\n    v = mix(v, noise(time*1000.+vv*0.5), 0.7+sin(time*2.0)*0.1);\n    v += noise(time*(1000.+500.*mod(floor(time*7.0), 3.0)))*exp(-mod(time, 2.0));\n    v += 0.5*exp(-mod(time, 9.)*0.75)*sin(sin(t*(200.+mod(floor(time*5.0), 3.0)*20.))*10.0*exp(-mod(time*5.0, 1.0)*2.)+t);\n    v += 0.5*exp(-mod(time+4.0, 9.))*sin(sin((0.5+t)*(200.+mod(floor(time*10.0+0.3), 3.0)*20.))*10.0*exp(-mod(time*2.0+0.1, 1.0)*2.)+t);\n    float c = 250.*hash(uint(floor(time*0.2))+10u);\n    float a = 500.;\n    v += 0.5*exp(-mod(time, 5.0))*k(time*a+sin(time*c), 0.1*sin(fract(time*100.)*3.1415*2.0)+0.5);\n    return v*0.5;\n}\nfloat fbm(in float x) {\n    float v = 0.0;\n    for (int i = 0; i < 9; i += 1) {\n        v += noise(x*float(1<<i))*pow(2., -float(i));\n    }\n    return v*0.5;\n}\nvec2 mainSound( int samp, float time )\n{\n    uint s = uint(samp);\n    float v = sound(time);\n    float range = mix(noise(time*2.0)*0.1, 0.0, min(time*0.1, 1.0));\n    //if (time > 20.) range = clamp((time-20.)*0.1, 0.0, 1.0);\n    float d = 0.0;\n    for (float i = -1.0; i <= 1.0; i += 0.2) {\n        float w = i*i;\n        v += sound(time+i*range)*w;\n        d += w;\n    }\n    v /= d;\n    //v += sound(time)*0.5;\n    //v = sin(time*500.*noise(time));\n    v = mix(v, fbm(time*400.), 1.-min(time*0.1, 1.0));\n    return vec2(v);//return vec2(sound(time), sound(time+noise(time)*0.1));//vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}", "sound_inputs": [], "common_code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float v = fract((p3.x + p3.y) * p3.z);\n    return v;//texture(iChannel0, p*0.01+0.5).x*20.0-v*0.001;\n}\nfloat noise(in vec2 p) {\n    vec2 k = fract(p);\n    vec2 f = floor(p);\n    k = k*k*(3.0-2.0*k);\n    return mix(mix(hash12(f), hash12(f+vec2(1, 0)), k.x),\n               mix(hash12(f+vec2(0, 1)), hash12(f+vec2(1, 1)), k.x), k.y);\n}\nfloat fbm(in vec2 p) {\n    float v = 0.0;\n    for (float i = 0.; i < 10.; i += 1.) {\n        v += pow(noise(p*pow(2., i)+i*100.), 1.5)*pow(2., -i);\n    }\n    return v*0.5;\n}\nfloat get(in vec2 p) {\n    float v = pow(fbm(p*0.03), 1.0)*50.-12.0;\n    return (v);//max(v, 5.0);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (fragCoord.xy-iResolution.xy*0.5);\n    fragColor = vec4(get(p), get(p+vec2(1, 0)), get(p+vec2(0, 1)), get(p+vec2(1, 1)));//vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlByD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 71, 285], [312, 312, 383, 383, 858], [859, 859, 892, 892, 937], [938, 938, 972, 972, 1092], [1093, 1093, 1151, 1151, 1787], [1788, 1788, 1824, 1824, 1939], [1940, 1940, 2016, 2016, 2151], [2152, 2152, 2191, 2191, 3582], [3583, 3583, 3640, 3640, 4178]], "test": "untested"}
{"id": "DlSyDh", "name": "Chicken or the egg?", "author": "01000001", "description": "What do you see? Include screenshot in comments. Black screen on my device. I've heard intel macs do funny things with uninitialized data.", "tags": ["loop", "chaos", "data", "uninitialized"], "likes": 1, "viewed": 134, "published": 3, "date": "1691690862", "time_retrieved": "2024-07-30T17:39:56.245558", "image_code": "a", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "a", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "a", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define a void mainImage( out vec4 O, in vec2 U ){O += texture(iChannel0, U/iResolution.xy); discard;}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cljyWz", "name": "Matryoshka Dolls", "author": "struminsky", "description": "An infinite number of matryoshka dolls. Combining SDFs in a recursive manner leads to compute overload. In this shader, I combined SDFs by shifting and scaling a single doll.", "tags": ["3d", "raymarching", "fractal", "geometricseries", "matryoshka"], "likes": 4, "viewed": 212, "published": 3, "date": "1691683416", "time_retrieved": "2024-07-30T17:39:57.035446", "image_code": "#define M_PI 3.1415926535897932384626433832795\n#define SCALE 0.9\n#define RADIUS 6.0\n\n// textures\nvec3 skirtColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(128. / 255., 0. / 255., 0. / 255.);\n    case 1:\n        return vec3(25. / 255., 25. / 255., 112. / 255.);\n    case 2:\n        return vec3(85. / 255., 107. / 255., 47. / 255.);\n    case 3:\n        return vec3(47. / 255., 79. / 255., 79. / 255.);\n    default:\n        return vec3(139. / 255., 69. / 255., 19. / 255.);\n    }        \n}\n\nvec3 apronColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(255. / 255., 215. / 255. , 0. / 255.);\n    case 1:\n        return vec3(199. / 255., 21. / 255., 133. / 255.);\n    case 2:\n        return vec3(255. / 255., 228. / 255., 225. / 255.);\n    case 3:\n        return vec3(65. / 255., 105. / 255., 225. / 255.);\n    default:\n        return vec3(60. / 255., 179. / 255., 113. / 255.);\n    }\n}\n\nvec3 hairColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(188. / 255., 143. / 255., 143. / 255.);\n    case 1:\n        return vec3(160. / 255., 82. / 255., 45. / 255.);\n    case 2:\n        return vec3(184. / 255., 134. / 255., 11. / 255.);\n    case 3:\n        return vec3(255. / 255., 69. / 255., 0. / 255.);\n    default:\n        return vec3(105. / 255., 105. / 255., 105. / 255.);\n    }\n}\n\nvec3 hairScarfColor(in int color_index){\n    switch (color_index){\n    case 0:\n        return vec3(220. / 255., 20. / 255., 60. / 255.);\n    case 1:\n        return vec3(34. / 255., 139. / 255., 34. / 255.);\n    case 2:\n        return vec3(100. / 255., 149. / 255., 237. / 255.);\n    case 3:\n        return vec3(148. / 255., 0. / 255., 211. / 255.);\n    default:\n        return vec3(199. / 255., 21. / 255., 133. / 255.);\n    }\n}\n\nbool inCone(in vec3 pos, in vec3 w, in float r){\n    vec3 u = cross(w, vec3(0.0, 0.0, 1.0));\n    vec3 v = cross(w, u);\n    float x = dot(pos, u);\n    float y = dot(pos, v);\n    float z = dot(pos, w);\n    return (x * x + y * y) < (r * z * z);\n}\n\n// sdf primitives\nfloat sdSphere(in vec3 position,\n               in vec3 center,\n               in float radius){\n    return length(position - center) - radius;\n}\n\nfloat smin(in float a, in float b, in float k){\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h / (4. * k);\n}\n\n// single matryoshka\nvec4 matryoshka(in vec3 pos, in int color_index){\n    // compute sdf\n    vec3 head_center = vec3(0.0, 0.0, 1.5);\n    float head_radius = 0.7;\n    vec3 body_center = vec3(0.0, 0.0, 0.5);\n    float body_radius = 0.9;\n    float matryoshka_sdf = smin(\n        sdSphere(pos, head_center, head_radius),\n        sdSphere(pos, body_center, body_radius),\n        0.3);\n    \n    // get color\n    bool headscarf = pos.z > 1.2;\n    bool face = inCone(\n        vec3(pos.xy, pos.z - 1.65),\n        vec3(0., 1., 0.1),\n        0.45) && pos.y > 0.;\n    bool hair = inCone(\n        vec3(abs(pos.x), pos.y, pos.z - 1.65),\n        vec3(1.2, 0.2, 1.5),\n        1.8);\n    \n    vec3 color;\n    // headscarf\n    if (headscarf && !face){\n        color = hairScarfColor((11 * color_index) % 5);\n        return vec4(matryoshka_sdf, color);\n    }\n    // face \n    if (face && !hair){\n        color = vec3(0.9, 0.7, 0.6);\n        return vec4(matryoshka_sdf, color);\n    }\n    // hair\n    if (face && hair){\n        color = hairColor((13 * color_index) % 5);\n        return vec4(matryoshka_sdf, color);\n    }\n    // skirt\n    bool skirt = !inCone(pos, vec3(0., .6, 0.8), 0.09);\n    if (skirt){\n        color = skirtColor((17 * color_index) % 5);\n        return vec4(matryoshka_sdf, color);\n    }\n    // apron\n    color = apronColor((19 * color_index) % 5);\n    return vec4(matryoshka_sdf, color);\n}\n\nvec4 circleClone(in vec3 pos){\n    float phi = acos(pos.x / length(pos.xy));\n    phi = pos.y < 0. ? 2. * M_PI - phi : phi;\n    phi /= (2. * M_PI * (1. - SCALE));\n    \n    float copy_id = float(floor(log(1. - (1. - SCALE) * phi)\n                          / log(SCALE)));\n    //if (copy_id >= 64.) \n    //    return vec4(\n    //        pos.x,\n    //        pos.y,\n    //        pos.z + RADIUS,\n    //        1.0);\n    \n    // get center angle\n    float phi_center = (\n        0.5 * pow(SCALE, copy_id)\n        + (1. - pow(SCALE, copy_id)) / (1. - SCALE)\n    ) * (1. - SCALE) * 2. * M_PI;\n    \n    // rotate\n    float x = pos.x * cos(phi_center) + pos.y * sin(phi_center);\n    float y = -pos.x * sin(phi_center) + pos.y * cos(phi_center);\n    float z = pos.z;\n    // scale and shift\n    float current_scale = pow(SCALE, -copy_id);\n    x = (x - RADIUS) * current_scale;\n    y *= current_scale;\n    z *= current_scale;\n    \n    return vec4(copy_id,\n                x * cos(phi_center) - y * sin(phi_center),\n                x * sin(phi_center) + y * cos(phi_center),\n                z);\n}\n\nvec4 map(in vec3 pos){\n    vec4 id_and_pos = circleClone(pos);\n    float current_scale = pow(SCALE, -id_and_pos.x);\n    \n    float background_sdf = smin(\n        pos.z,\n        25. - length(pos.xy),\n        10.);\n    vec4 matryoshka_output = matryoshka(\n        id_and_pos.yzw,\n        int(id_and_pos.x)) / current_scale;\n    float matryoshka_sdf = matryoshka_output.x;\n    vec3 matryoshka_color = matryoshka_output.yzw;\n    \n    if (background_sdf < matryoshka_sdf)\n        return vec4(background_sdf, 1.0, 1.0, 1.0);\n    else\n        return matryoshka_output;\n}\n\nfloat castRay(in vec3 ro, in vec3 rd){\n    float t = 0.0;\n    for(int i=0; i<200; i++){\n        vec3 pos = ro + t*rd;\n        float h = map(pos).x;\n        if (h < 0.0001) break;\n        t += h;\n    }\n    return t;\n}\n\nfloat castSoftShadow(in vec3 ro, in vec3 rd){\n    float t = 1e-1;\n    float min_dist = 1.0;\n    for(int i=0; i<200 && t < RADIUS; i++){\n        float h = map(ro + t*rd).x;\n        if (h < 1e-3) return 0.;\n        t += h;\n        min_dist = min(min_dist, 8. * h / t );\n    }\n    return clamp(min_dist, 0., 1.);\n}\n\nvec3 calcNormal(in vec3 pos){\n    vec2 e = vec2(1e-3, 0.);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // map pixel coordinate to ray\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    \n    //float frame = 2.0 * iTime;\n    \n    vec3 ro;\n    vec3 camera_target;\n    if (iMouse.z > 0.0) {\n        ro = vec3(1.4 * RADIUS * cos(iMouse.x / 100.),\n                  1.4 * RADIUS * sin(iMouse.x / 100.),\n                  0.3 + iMouse.y / 100.);\n        camera_target = vec3(0.0, 0.0, iMouse.y / 1000.);\n    } else {\n        ro = vec3(1.4 * RADIUS * cos(iTime / 4.),\n                  1.4 * RADIUS * sin(iTime / 4.),\n                  1.3);\n        camera_target = vec3(0.0, 0.0, 0.3);\n    }\n    vec3 ww = normalize(camera_target - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 0.0, 1.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n    float t = castRay(ro, rd);\n    \n    vec3 pos = ro + t * rd;\n    vec3 normal = calcNormal(pos);\n    vec3 albedo = map(pos).yzw;\n    \n    \n    vec3 sun_dir = normalize(\n        vec3(0.5, 0.5, 0.7)\n    );\n    // sun shadow\n    float sun_shadow = castSoftShadow(pos, sun_dir);\n    // diffuse shadow\n    //vec3 diff_shadow = albedo;\n    vec3 diff_shadow = albedo * clamp(dot(sun_dir, normal), 0.0, 1.0);\n    // specular reflection\n    vec3 h = -normalize(-sun_dir + rd);\n    float alpha = 128.0;\n    vec3 specular_ref = vec3(0.7, 0.7, 0.8) * pow(clamp(dot(h, normal), 0.0, 1.0), alpha);\n    \n    vec3 col = vec3(0.05, 0.01, 0.01);\n    col += diff_shadow * sun_shadow; \n    col += specular_ref * sun_shadow; \n    fragColor = vec4(pow(col, vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 97, 133, 133, 523], [525, 525, 561, 561, 952], [954, 954, 989, 989, 1378], [1380, 1380, 1420, 1420, 1808], [1810, 1810, 1858, 1858, 2053], [2055, 2073, 2169, 2169, 2218], [2220, 2220, 2267, 2267, 2350], [2352, 2373, 2422, 2441, 3741], [3743, 3743, 3773, 3773, 4826], [4828, 4828, 4850, 4850, 5391], [5393, 5393, 5431, 5431, 5609], [5611, 5611, 5656, 5656, 5922], [5924, 5924, 5953, 5953, 6187], [6190, 6190, 6247, 6282, 7814]], "test": "untested"}
{"id": "mt2cWR", "name": "Void And Cluster Bluenoise -spl3", "author": "FabriceNeyret2", "description": "further simplifying  and optimizing Void And Cluster Bluenoise\" by krax  [url]https://www.shadertoy.com/view/cdfSD8[/url]\n( compute a lot less pixels, buff D useless ).\nLeft: krax algo with sigma = 2.5\nRight: shadertoy bluenoise.", "tags": ["noise", "bluenoise"], "likes": 13, "viewed": 362, "published": 3, "date": "1691680664", "time_retrieved": "2024-07-30T17:39:57.807383", "image_code": "// more optimization of https://shadertoy.com/view/Dtjczm and https://shadertoy.com/view/DdXSD4\n// simplifying \"Void And Cluster Bluenoise\" by krax. https://shadertoy.com/view/cdfSD8\n// from ref: https://alister-chowdhury.github.io/posts/20221230-bluenoise-generator/\n// ( TODO: try GPmipmap invmin. but half-float spoils it: https://www.shadertoy.com/view/DtffWM )\n// (       Hexagonal version: here https://www.shadertoy.com/view/mllfW8 )\n\n// more reading: https://momentsingraphics.de/BlueNoise.html#The_void_and_cluster_method\n// about variance in A: larger → more LF but more isotropic.  very low → Bayer. Best compromise ~1.9, but shadertoy one ~ 2.5\n// Fourier spectrum: https://www.shadertoy.com/view/DlXfWn\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n  // O = vec4(texelFetch(iChannel2, ivec2(u), 0).x!=0.); return; // for debug\n \n    vec2 R = iResolution.xy, U = u/R;\n    if ( int(u) == int(R)/2 ) { O = vec4(1, U.y > float(iFrame)/(s*s),0,0); return; } // red separator + progress bar\n    if ( U.x>.5 ) { O = texelFetch(iChannel1, ivec2(u)%1024, 0 ).xxxx; return; }      // reference shadertoy bluenoise \n\n#if 1\n    u = s*fract(u/s);\n#else \n    u *= s/R;\n#endif \n\n    O = T(u.x,u.y).xxxx;\n//  O = vec4(O.x < .001 );   // select first values \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int S = 64;           // bluenoiseSize = SxS , cycling tile\nfloat s = float(S),         // note that more buffers are needed if S > 64 : clone C , S/8^(i+1)\n      sigma = 2.5;          // NB: krax used 1.9 \n\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y) % S, 0)\n\nfloat H( uvec3 x ) {        // from iq https://www.shadertoy.com/view/XlXcW4\n    uint k = 1103515245U;   // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n // x = ((x>>8U)^x.yzx)*k;  // but this version only return 10⁻¹⁹ amplitude\n    return uintBitsToFloat( ((((x.x>>8U)^x.y)*k )  & 0x1fffffffU) ); // why ?\n // return 1e-19* float(((x.x>>8U)^x.y)*k   )  /float(0xffffffffU);  // Uniform\n}\n\n#define M(S,c)                                                                                  \\\nvoid mainImage( out vec4 O, vec2 U ) {                                                          \\\n    if( U.x > float(S/8) || U.y > float(S/8) ) return; /* we only simulate a small square    */ \\\n    O = vec4( 0,1e35,0,0);                                                                      \\\n    ivec2   start = min( ivec2(U)*8, S - 1 ),          /* to reduce a 8x8 above subtile to 1 */ \\\n              end = min( start + 8, S );                                                        \\\n    for( int y=start.y; y<end.y; ++y)                                                           \\\n      for( int x=start.x; x<end.x; ++x) {                                                       \\\n        vec4 E = T(x,y);                                                                        \\\n        c;                                             /* store result */                       \\\n}   } \n", "buffer_a_code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background energy.\n// output: .x = bluenoise, .y = energy.   \n// input:  D.yz = location or largest void.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if( U.x>s || U.y>s ) return; // we only simulate a small (cyclicling) square\n\n    if(iFrame == 0)              // init: noise = 0, energy = random\n    {   O.xy = vec2( 0, H(uvec3(U, 2111)) );\n        return;\n    }\n    \n    O = T(U.x,U.y);              // previous state\n    if(iFrame > S*S-1) return;   // max iteration reached\n \n \n    // Get the result from downscaling and finding the smallest void center\n    U = abs( floor(U) - texelFetch(iChannel1, ivec2(0), 0).zw ) / s;  // delta to target\n\n    float v = 1. - float(iFrame-1) / (s*s-1.); // noise value = normalized iterations\n\n    // Wrap around logic : max energy around optimal void center modulo s : https://www.desmos.com/calculator/zuopknqihy\n    vec2 d = ( abs( U - .5 ) - .5 )  * s / sigma;\n    O.xy += vec2( U==vec2(0) ? v : 0.,            // we are at the optimum : store noise\n                  v * exp( -dot(d,d) ) );         // energy += gaussian to optimum\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Void and cluster reduce init\n// input:  .xy = SxS state noise,energy.\n// output: .xyz = lowest energy value + position on SxS /8   ( and not already chosen )\n\nM( S , \n   if( E.x == 0. && E.y < O.y ) O = vec4( 0, E.y, x, y )\n )", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Void and cluster reduce iteration\n// input:  .xy = SxS /8 state energy,location\n// output: .xyz = lowest energy value + position on SxS /8²  ( and not already chosen )\n//                note that with S = 64 this is only 1 pixel.\n\nM( S/8 ,                                            \n   if( E.y < O.y ) O = E\n )", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2cWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[721, 721, 759, 838, 1255]], "test": "untested"}
{"id": "dl2yDR", "name": " iyfdbbbbbghg", "author": "nilok", "description": "asd", "tags": ["te"], "likes": 2, "viewed": 146, "published": 3, "date": "1691678617", "time_retrieved": "2024-07-30T17:39:58.631180", "image_code": "/* \"Audio Visualizer #5 - Wipeout\" by @kishimisu (2023) - https://www.shadertoy.com/view/ddXfzf\n\n   Playing with both linear and radial repetition around the z-axis in\n   a raymarched 3D scene\n   \n  \n*/\n\n#define rot(a) mat2(cos(a + vec4(0,33,11,0)))\n#define rep(p, r) mod(p+r, r+r) - r\n\nfloat b(vec3 q, vec3 b) { // box sdf\n    return length(max(q = abs(q) - b,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat h(vec2 p) { // 2->1 noise\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/* Audio-related functions */\n#define level(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\n#define pitch(f) logisticAmp(level(pow(2., f) * .02175))\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\nfloat logisticAmp(float amp){\n   float c = 1.-smoothstep(6.,0.,iTime)*.3, a = 15.;  \n   return (logX(amp, a, c) - logX(0., a, c)) / (logX(1., a, c) - logX(0., a, c));\n}\nfloat getVol(float samples) {\n    float avg = 0.;\n    for (float i = 0.; i < samples; i++) avg += level(i/samples);\n    return avg / samples;\n}\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2  R = iResolution.xy,\n          u = (F+F-R)/R.y * rot(-iTime*.15);\n    vec3  p, q, id;\n    float i = 0., t = 0., d, f, v = getVol(8.);\n    \n    for (O *= i; max(i,t) < 60.; i++) {\n    \n        q = p = t * normalize(vec3(u*rot(t*sin(iTime*.15)*.04),1));\n        p.z += iTime*3. + v;\n        \n        id.z = floor(p.z+.5);\n        p.z  = rep(p.z, .5);\n        \n        p.yx *= rot(round(atan(p.y, p.x) / .393) * .393);\n        \n        id.x = floor((p.x+.2)/.2);\n        p.x  = rep(p.x+.1, .1);\n                \n        t += d = max(b(p, vec3(.02 + length(q.xy)*.02)), 1.-length(q.xy));\n        \n        f = pitch(h(vec2(id.x + id.z*.05))*2.-1.);\n        O += pow(f,1.5) * abs(v-id.x*.004) * .04 / (.8 + abs(d)) \n             * (1. + cos(f*1. + t*.25 + iTime + vec4(0,1,2,0)));\n    }     \n}\n", "image_inputs": [{"id": 34406, "src": "https://soundcloud.com/ejorrr/shpongle-divine-moments-of-truth?in=gangsterd-2/sets/sphongle-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2yDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 312, 323, 400], [402, 402, 419, 433, 550], [752, 752, 781, 781, 920], [921, 921, 950, 950, 1064], [1066, 1066, 1102, 1102, 1899]], "test": "untested"}
{"id": "dt2yDR", "name": "Hexcopter", "author": "dr2", "description": "The quadcopter's big sister", "tags": ["flight", "rotor"], "likes": 22, "viewed": 208, "published": 3, "date": "1691678487", "time_retrieved": "2024-07-30T17:39:59.477916", "image_code": "// \"Hexcopter\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat Maxv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltPos[3], ltCol[3], flyerPos, qHit;\nvec2 aRotCs[3];\nfloat tCur, dstFar;\nint nFrame, idObj;\nconst int idCab = 11, idBod = 12, idArm = 13, idGard = 14, idMot = 15, idSup = 16, idAnt = 17,\n   idSkd = 18, idCam = 19, idProp = 20;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a, s, r;\n  q = p;\n  q.y -= 0.6;\n  d = max ((abs (q.y) + abs (q.z)) / sqrt(2.) - 0.5, max (q.y - 0.35, abs (q.x) - 0.7));\n  DMINQ (idCab);\n  d = PrRoundCylDf (vec3 (q.x, q.y - 0.17, abs (q.z) - 0.53).yzx, 0.03, 0.07, 0.5);\n  DMINQ (idCab);\n  d = min (min (PrSphDf (vec3 (abs (q.x) - 0.7, q.y, q.z), 0.2),\n     PrSphDf (vec3 (q.x - 0.7, q.y, abs (q.z) - 0.4), 0.1)),\n     PrSphDf (vec3 (q.x, q.y - 0.35, q.z), 0.15));\n  DMINQ (idCam);\n  d = PrRoundCylDf (vec3 (abs (q.xz) - vec2 (0.5, 0.2), q.y - 0.6), 0.01, 0.01, 0.3);\n  DMINQ (idAnt);\n  q = p;\n  d = PrSphDf (vec3 (abs (q.x) - 0.6, q.y + 0.35, q.z), 0.15);\n  DMINQ (idCam);\n  q.y -= -0.6;\n  d = min (PrRoundBoxDf (vec3 (q.x, q.y, abs (q.z) - 0.55), vec3 (0.7, 0.01, 0.06), 0.02),\n     PrCylDf (vec3 (abs (q.xz) - vec2 (0.55, 0.55), q.y - 0.2), 0.04, 0.2));\n  DMINQ (idSkd);\n  q = p;\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  s = sign (fract (3. * a) - 0.5);\n  q.xz = Rot2Cs (q.xz, CosSin (2. * pi * (floor (6. * a) + 0.5) / 6.));\n  d = min (max ((abs (q.y) - q.x) / sqrt(2.) - 0.85, max (-1. - q.x, abs (q.y) - 0.35)),\n     max ((abs (q.y) + abs (q.z)) / sqrt(2.) - 0.14, abs (q.x + 1.) - 0.1));\n  DMINQ (idBod);\n  d = max ((abs (abs (q.y) - 0.1) + abs (q.z)) / sqrt(2.) - 0.04, abs (q.x + 2.5) - 1.5);\n  DMINQ (idArm);\n  d = (abs (length (q.xz) - 3.06) + abs (abs (q.y) - 0.22)) / sqrt(2.) - 0.04;\n  q.x += 2.8;\n  r = length (q.xz) - 1.2;\n  d = max (d, - r);\n  DMINQ (idSup);\n  d = PrRoundCylDf (q.xzy, 0.15, 0.05, 0.25);\n  DMINQ (idMot);\n  q.y = abs (q.y) - 0.22;\n  d = max (Maxv2 (abs (abs (Rot2Cs (q.xz, CosSin (pi/4.))) - 0.85)) - 0.04, q.y);\n  DMINQ (idSup);\n  d = (abs (r) + abs (q.y)) / sqrt(2.) - 0.04;\n  DMINQ (idGard);\n  q.xz = Rot2Cs (q.xz, CosSin (10.1 * s * pi * tCur));\n  d = PrRoundBoxDf (q, vec3 (1.1, 0.01, 0.07), 0.01);\n  DMINQ (idProp);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float flyerSz;\n  flyerSz = 1.;\n  p -= flyerPos;\n  p.xy = Rot2Cs (p.xy, aRotCs[0]);\n  p.zy = Rot2Cs (p.zy, aRotCs[1]);\n  p.xz = Rot2Cs (p.xz, aRotCs[2]);\n  return flyerSz * FlyerDf (p / flyerSz, dstFar / flyerSz);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, fCol4, gCol4;\n  float a;\n  a = atan (qHit.z, - qHit.x) / (2. * pi) + 0.5;\n  fCol4 = vec4 (0.8, 0.8, 0.9, 0.2);\n  gCol4 = vec4 (0.9, 0.9, 0.4, 0.2);\n  if (idObj == idCab) {\n    col4 = mix (gCol4, fCol4 * ((qHit.y < 0.) ? 1.2 : 1.), step (0.02, abs (qHit.y)));\n    if (qHit.y > 0.) col4 = mix (gCol4, col4, step (0.05, abs (abs (qHit.x - 0.4 +\n       0.6 * abs (qHit.z) - 0.05) - 0.1)));\n    col4 = mix (vec4 (1., 1., 0., -1.), col4, step (0.21, length (qHit.yz)));\n    if (qHit.x < 0.) col4 = mix (vec4 (mix (vec3 (1., 0., 0.), vec3 (0., 0., 1.),\n       step (0.5, fract (2. * tCur + 0.25 * sign (qHit.z)))), -1.), col4, step (0.05,\n       length (vec2 (qHit.y, abs (qHit.z) - 0.4))));\n  } else if (idObj == idBod) {\n    col4 = mix (gCol4, fCol4 * ((qHit.y < 0.) ? 1.2 : 1.), step (0.02, abs (qHit.y)));\n    if (qHit.y < 0.) col4 = mix (vec4 (0., 1., 0., -1.), col4, step (0.02, abs (qHit.x + 0.3)));\n  } else if (idObj == idMot) {\n    col4 = gCol4;\n    if (abs (qHit.y) < 0.18) col4 *= 0.5 + 0.5 * step (0.5, fract (16. * a));\n    else col4 = mix (vec4 (0., 1., 0., -1.), col4, step (0.03, length (qHit.xz)));\n  } else if (idObj == idArm) {\n    col4 = mix (fCol4, gCol4, step (0.7, fract (8. * qHit.x)));\n  } else if (idObj == idSup) {\n    col4 = mix (fCol4, gCol4, step (0.7, fract (16. * qHit.y)));\n  } else if (idObj == idGard) {\n    col4 = mix (fCol4, gCol4, step (0.7, fract (64. * a)));\n  } else if (idObj == idAnt) {\n    col4 = vec4 (0.8, 0.8, 0.8, 0.2);\n  } else if (idObj == idSkd) {\n    col4 = vec4 (0.4, 0.4, 0.4, 0.05);\n  } else if (idObj == idCam) {\n    col4 = vec4 (0.2, 0.2, 0.2, -1.);\n  } else if (idObj == idProp)  {\n    col4 = vec4 (0.9, 0.9, 1., 0.3) * (0.5 + 0.5 * step (0.5, fract (2. * abs (qHit.x))));\n  }\n  return col4;\n}\n\nvoid SetConf ()\n{\n  float a[3], f, t;\n  t = 0.4 * tCur;\n  f = SmoothBump (0.15, 0.85, 0.05, mod (0.05 * tCur, 1.));\n  flyerPos.xz = vec2 (0.);\n  flyerPos.y = 0.8 + f * (2.5 + 1.2 * sin (1.2 * pi * t));\n  a[0] = f * 0.1 * pi * sin (1.1 * pi * t);\n  a[1] = f * 0.05 * pi * sin (1.4 * pi * t);\n  a[2] = (0.1 + 0.9 * f) * pi * sin (0.2 * pi * t);\n  aRotCs[0] = sin (a[0] + vec2 (0.5 * pi, 0.));\n  aRotCs[1] = sin (a[1] + vec2 (0.5 * pi, 0.));\n  aRotCs[2] = sin (a[2] + vec2 (0.5 * pi, 0.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir, ltAx, c;\n  vec2 u;\n  float dstObj, sh, att, ltDst, nDotL;\n  bool isMet;\n  SetConf ();\n  col = vec3 (0.);\n  dstObj = ObjRay (ro, rd);\n  isMet = false;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = FlyerCol ();\n    isMet = true;\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    col4 = vec4 (0.5, 0.5, 0.7, 0.1);\n    u = abs (fract (ro.xz + 0.5) - 0.5);\n    col4.rgb *= (1. - 0.15 * smoothstep (0.05, 0.08, (abs (dot (u, vec2 (1.))) - 0.2) - 0.2)) *\n       (1. - 0.15 * smoothstep (0.05, 0.08, length (max (u - 0.42, 0.))));\n    vn = vec3 (0., 1., 0.);\n  }\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      for (int k = VAR_ZERO; k < 3; k ++) {\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k] - vec3 (0., 2., 0.));\n        att = smoothstep (0., 0.02, dot (ltDir, ltAx) - 0.97);\n        sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDst) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (isMet) nDotL *= nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.1 + 0.9 * sh * nDotL) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n        col += c * c;\n      }\n      col = sqrt (col);\n    } else col = col4.rgb * (0.4 + 0.6 * max (- dot (vn, rd), 0.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.02 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1.5, -30.);\n  zmFac = 5.2;\n  dstFar = 60.;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 30., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur -\n       pi * float (k) / 3.)));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, -0.1 * pi * tCur + 2. * pi * float (k) / 3.);\n  }\n  ltCol[0] = vec3 (1., 0.2, 0.2);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dt2yDR.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[914, 914, 950, 950, 2821], [2823, 2823, 2845, 2845, 3062], [3064, 3064, 3097, 3097, 3345], [3347, 3347, 3368, 3368, 3623], [3625, 3625, 3674, 3674, 3916], [3918, 3918, 3936, 3936, 5695], [5697, 5697, 5714, 5714, 6185], [6187, 6187, 6222, 6222, 7654], [7656, 7656, 7712, 7712, 9134], [9136, 9136, 9182, 9182, 9229], [9231, 9231, 9264, 9264, 9291], [9293, 9293, 9335, 9335, 9386], [9388, 9388, 9445, 9445, 9521], [9523, 9523, 9545, 9545, 9572], [9574, 9574, 9631, 9631, 9714], [9716, 9716, 9752, 9752, 9958], [9960, 9960, 9990, 9990, 10103], [10105, 10105, 10136, 10136, 10200]], "test": "untested"}
{"id": "mljcWR", "name": "B/W logarithmic circles II", "author": "mrange", "description": "// CC0: B/W logarithmic circles II\n// Tweaking on an old shader on the bus.\n", "tags": ["2d"], "likes": 24, "viewed": 335, "published": 3, "date": "1691677289", "time_retrieved": "2024-07-30T17:40:00.244865", "image_code": "// CC0: B/W logarithmic circles II\n// Tweaking on an old shader on the bus.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// Carefully fine tuned. No thinking involved.\nconst float ExpBy   = log2(4.1);\nconst float Radius  = 0.3175;\n  \nfloat forward(float l) {\n  return exp2(ExpBy*l);\n}\n\nfloat reverse(float l) {\n  return log2(l)/ExpBy;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec3 effect(vec2 p) {\n  float aa = 4.0/RESOLUTION.y;\n  vec3 col = vec3(0.2*smoothstep(-sqrt(0.5), sqrt(0.5), sin(0.5*TAU*p.y/aa)));\n  \n  float tm = 0.5*TIME;\n  mat2 rot0 = ROT(-0.5*tm); \n  for (float i = 0.0; i < 2.0; ++i) {\n    float ltm = tm+0.5*i;\n    mat2 rot1 = ROT(i*0.5*TAU/8.0);\n    float mtm = fract(ltm);\n    float ntm = floor(ltm);\n    float zz = forward(mtm);\n  \n    vec2 p0 = p;\n    p0 *= rot0;\n    p0 *= rot1;\n    p0 /= zz;\n  \n    float l0 = length(p0);\n    \n    float n0 = ceil(reverse(l0));\n    float r0 = forward(n0);\n    float r1 = forward(n0-1.0);\n    float r = (r0+r1)/2.0;\n    float w = r0-r1;\n    float nn = n0;\n    n0 -= ntm;\n    vec2 p1 = p0;\n    float n1 = modPolar(p1, 8.0);\n    p1.x -= r;\n  \n    float a = 0.5*ltm+n1/8.0;\n    a = fract(a);\n    float d1 = length(p1)-Radius*w;\n    float d2 = length(p1)-Radius*w*smoothstep(0.0, 0.45, mod(a, 0.5));\n    d1 *= zz;\n    d2 *= zz;\n    vec3 ccol = vec3(1.0)*smoothstep(0.0, -aa, d2);\n    if (a >= 0.5) ccol = 1.0-ccol;\n    col = mix(col, ccol, smoothstep(0.0, -aa, d1));\n  }\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mljcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[368, 368, 392, 392, 418], [420, 420, 444, 444, 470], [472, 472, 521, 521, 920], [922, 922, 943, 943, 2001], [2003, 2003, 2060, 2060, 2217]], "test": "untested"}
{"id": "Dl2yWz", "name": "Walking Through Liminal Space", "author": "propagant", "description": "Simple raymarched scene, featuring infinite and atmospheric liminal spaces with vhs effect. Made just for fun!", "tags": ["raymarching", "backrooms", "liminalspace"], "likes": 9, "viewed": 255, "published": 3, "date": "1691674812", "time_retrieved": "2024-07-30T17:40:01.405761", "image_code": "// Walk through liminal atmospheric spaces written by Matej Vanco, August 2023.\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      GUI                                   //\n//                                                            //\n////////////////////////////////////////////////////////////////\n\nfloat rect(in vec2 st, in vec2 size)\n{\n    vec2 uv = step(0.25 - size, st * (1.0-st));\n\treturn uv.x * uv.y;\n}\n\nvec3 renderGUI(vec2 uv, in vec2 uvVHS)\n{\n#if GUI == 0\n    return ZERO;\n#endif\n\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 recIcon = vec3(1.,0.2,0.4) * step(length(vec2(uv.x-0.15,uv.y-0.9) + uvVHS * 0.01),0.015);\n    vec3 recIconSmh = vec3(1.,0.2,0.2) * \n    (1.-smoothstep(1.0e-4,0.05, length(vec2(uv.x-0.15,uv.y-0.9) + uvVHS * 0.01)));\n    float blinking = step(fract(iTime*0.5),.5);\n    recIcon *= blinking;\n    recIconSmh *= blinking;\n    \n    vec3 panel = ONE * 0.1 * rect(uv-vec2(.5,0.4)+uvVHS * 0.01,vec2(.4,1.e-5));\n    vec3 panel2 = ONE * 0.1 * rect(uv-vec2(.4,-0.4)+uvVHS * 0.01,vec2(.6,1.e-5));\n    \n    return recIcon + recIconSmh + panel + panel2;\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      MAIN + Post Processing                //\n//                                                            //\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n#if VHS == 1\n    float tf = fract(iTime);\n    float uvy = uv.y * 0.001;\n    vec2 vhs = fract(vec2(HASH1(uvy-tf), uv.y-tf * HASH1(uvy) * 0.1) * 20.) * VHSIntens;\n    vec2 chVhs = vhs * 0.0075;\n    vec4 color = vec4(texture(iChannel2, uv + chVhs).r, \n                texture(iChannel2, uv + CHROMATIC_ABERRATION + chVhs).g,\n                texture(iChannel2, uv - CHROMATIC_ABERRATION + chVhs).b, 1.);\n#else\n    vec2 vhs = vec2(0.);\n    vec4 color = texture(iChannel2, uv);\n#endif\n\n    vec4 guiColor = vec4(renderGUI(uv, vhs), 0.);\n    color.rgb += color.rgb;\n    \n    // Gamma\n    fragColor = color + vec4(0.14,0.118 + sin(iTime * 64.) * 0.005,0.099,0.) + guiColor;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34405, "src": "https://soundcloud.com/leylandkirby/01-all-you-are-going-to-want?in=leylandkirby/sets/the-caretaker-an-empty-bliss&si=c941021b310043dcbae70cea878d6a1e&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Renderer essentials\n\n#define MAX_DIST 64.0\n#define ITERS 32\n\n// 0 = default, 1 = depth, 2 = normals\n#define RENDER_MODE 0\n// 0 = disabled, 1 = enabled\n#define VHS 1\n#define VHSIntens 1.5\n#define CHROMATIC_ABERRATION 0.008\n#define GUI 1\n\nstruct Ray\n{\n    vec3 o,d;\n};\n\n#define EPSILON 1.0e-4\n\n// Hashes\n\n#define HASH1(v) fract(sin(v * 1024.32) * 768.4096)\n\n// Transform\n\n#define UP vec3(0.,1.,0.)\n#define FWD vec3(0.,0.,1.)\n#define ONE vec3(1.)\n#define ZERO vec3(0.)\n\nmat3 rotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Operations (iq's solutions)\n\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p + s * 0.5, s) - s * 0.5;\n}\n\nfloat ops(float a, float b, float s)\n{\n    float k = s;\n    float h = clamp( 0.5 - 0.5*(b+a)/k, 0.0, 1.0 );\n    return mix( a, -b, h ) + k*h*(1.0-h);\n}\n\nfloat opu(float a, float b, float s)\n{\n    float k = s;\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}", "buffer_a_code": "// Scene render\n\nfloat sdfBox(in vec3 c, in vec3 s, in float r)\n{\n\treturn length(max(abs(c),s)-s)-r;\n}\n\nfloat sdfPlane(in vec3 c, in vec3 n, in float h)\n{\n    return dot(c+UP*h,normalize(n));\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      CORE                                  //\n//            SDFs, Raymarching, lighting etc...              //\n////////////////////////////////////////////////////////////////\n\n\nfloat SDF(in vec3 p)\n{\n    vec3 rp = p;\n    rp.xz = opRep(p.xz, 2.5);\n        \n    float box = sdfBox(rp, vec3(.3,1.5,.3), 0.01);\n    float pool = sdfBox(rotateY(rp.x+rp.z) * (rp), vec3(0.8,.5,.6), 0.1);\n    \n    float ground = sdfPlane(p, UP, 0.5);\n    float roof = sdfPlane(p, -UP, -1.5);\n    \n    return opu(box, ops(min(roof,ground), pool, 0.1),0.3);\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 of = vec2(1.e-3,0.);\n    float sdf = SDF(p);\n    return normalize(sdf - vec3(SDF(p - of.xyy), SDF(p - of.yxy), SDF(p - of.yyx)));\n}\n\nfloat rayMarch(in Ray r)\n{\n    float t = 0.;\n    for(int i = 0; i < ITERS; i++)\n    {\n        vec3 cp = r.o + t * r.d;\n        float sdf = SDF(cp);\n        t+=sdf;\n        if(t > MAX_DIST)\n            break;\n    }\n    return t;\n}\n\nfloat lighting(vec3 p)\n{\n    p.xz = opRep(p.xz, 10.);\n    \n    vec3 lp = vec3(1.0,.5,1.);\n    \n    vec3 ld = lp - p;\n    vec3 ldn = normalize(ld);\n    vec3 n = normal(p);\n    \n    float atten = dot(n, ldn) * (.1/length(ld))*30.;\n    \n    return clamp(atten - abs(sin(iTime*50.)*0.2),0.,3.);\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      SCENE                                 //\n//                                                            //\n////////////////////////////////////////////////////////////////\n\nvec3 Texture(in vec3 uv)\n{\n    vec2 pp = fract((uv.xz+uv.xy)*15.);\n    return ONE * step(pp.y,0.25);\n}\n\nvec3 renderScene(in vec2 uv)\n{\n    Ray r;\n    r.o = vec3(1.25, sin(iTime * 15.) * 0.008, iTime * 0.5);\n    r.d = rotateY(cos(r.o.z / 2.)) * vec3(uv, 1.);\n    \n    float march = rayMarch(r);\n    float depth = 1. / march;\n    vec3 cp = r.o + r.d * march;\n    if(cp.y < -0.55)\n        cp.xz += texture(iChannel1, cp.xz*2.).r*0.5;\n    \n    vec3 color = vec3(0.);\n\n// Depth only\n#if RENDER_MODE == 1\n    color = vec3(depth);\n// Normals only\n#elif RENDER_MODE == 2\n    color = normal(cp);\n// Full render (albedo+lambert+fog)\n#else\n    float light = lighting(cp);\n    vec3 fog = mix(ZERO, vec3(.8,1.,0.1)/5., clamp(pow(depth,1.5),0.,1.));\n    vec3 tex = Texture(cp);\n    \n    color = (tex * 0.5 + light) * fog;\n#endif\n\n    return color;\n}\n\n////////////////////////////////////////////////////////////////\n//                                                            //\n//                      MAIN                                  //\n//                                                            //\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (.5 * iResolution.xy)) / iResolution.y;\n    fragColor = vec4(renderScene(uv), 1.);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2yWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 445, 445, 516], [518, 518, 558, 558, 1193], [1521, 1521, 1578, 1578, 2295]], "test": "untested"}
{"id": "dl2cRm", "name": "Pretty awesome Sunset", "author": "bartkamski", "description": "sunset", "tags": ["sun"], "likes": 2, "viewed": 162, "published": 3, "date": "1691662320", "time_retrieved": "2024-07-30T17:40:02.414065", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float BandMultiplier = 129.0;\n   float BandPower = 0.5;\n   float BandOffset = 0.512;\n   float BandWidth = 0.95;\n   float BandWidth1 = 0.05;\n   float Time = (sin(1.0*t)*0.1)+2.0;\n   \n   bool Switch = true;\n    \n   vec2 uv = fragCoord/iResolution.xy;\n   vec2 uv2 = (fragCoord * 2.0 -iResolution.xy) / iResolution.y;\n   \n\n/*\n    if (Switch == true)\n    {\n    BandWidth = 0.1;\n    };\n    */\n    \n  // bands\n  \n   //creating \"k\" variable and setting it with vertical coordinate from uv coordinates\n   float k = uv.y;\n   float l = uv.y;\n   \n   \n   k = k-1.0;\n   \n   k = (abs(k)-BandOffset);\n   \n   k = BandMultiplier*k*Time;\n   \n   k = pow(k,BandPower);\n   \n   k = fract(k);\n   \n   k = smoothstep(BandWidth,0.4,k);\n   \n   k = abs(k-1.0);\n   \n   k = (step(BandOffset,abs(uv.y-1.0)))*k;\n   \n   \n   l = l-1.0;\n   \n   l = (abs(l)-BandOffset);\n   \n   l = BandMultiplier*l*Time;\n   \n   l = pow(l,BandPower);\n   \n   l = fract(l);\n   \n   l = smoothstep(BandWidth1,0.4,l);\n   \n   l = abs(l-1.0);\n   \n   l = (step(BandOffset,abs(uv.y-1.0)))*l;\n\n   \n   \n   // circle\n   \n    float d = length(uv2);\n    \n    d = smoothstep(0.1, 0.15, d - 0.5);\n   \n    d = 1.0 - d;\n    \n    d = d * uv.y;\n    d = pow(d,0.4);\n    \n    float e = d*(smoothstep(0.49,0.5,uv.y));\n    \n   \n  \n   \n   //float a = k+l;\n   float a = ((l+k)*d)+e;\n   //float a = e;\n     \n   fragColor = vec4(a-0.1, a-0.45, 0, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dl2cRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 1447]], "test": "untested"}
{"id": "mtScDz", "name": "A Pac Man", "author": "ololeecn", "description": "A cute pac man.inspired by iq's https://www.shadertoy.com/view/3l23RK", "tags": ["2d", "sdf", "pacman"], "likes": 1, "viewed": 166, "published": 3, "date": "1691656079", "time_retrieved": "2024-07-30T17:40:03.531079", "image_code": "#define MIN_RAD 300.0\n#define MAX_RAD 360.0\n#define ANG2RAD 3.14  / 180.0\n#define EYE_R 0.06\n#define PAC_MAN_R 0.5\n\n//cover from iq\nfloat sdCircle(vec2 p, float r){\n    return length(p) - r;\n}  \n\nfloat tri(float freq,float x){\n    return mod(x,1.0/freq)*freq;\n}\n\n//\nfloat sdPie(in vec2 p, in vec2 c, in float r ,float theta )\n{ \n    float thetaRad = theta * ANG2RAD;\n    mat2 rm = mat2(cos(thetaRad),sin(thetaRad),-sin(thetaRad),cos(thetaRad));\n    p = rm * p;\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n   p.x = p.x + 1.0;\n   float t1 = 3.14*(0.5+0.5*cos(iTime*0.52));\n   float t3 = MIN_RAD + 60.0*smoothstep(0.0,0.7,sin(10.0*iTime));\n   float t2 = iTime*100.0;\n   float t = 0.5 * t3 * ANG2RAD;\n   float d = sdPie(p,vec2(sin(t),cos(t)), PAC_MAN_R,-90.0);\n   vec3 pacManColor =  vec3(0.949,0.827,0.027);\n   vec3 bgColor = vec3(0.000,0.020,0.039);\n   vec3 col = mix(pacManColor,bgColor,smoothstep(0.0,0.01,d));\n   \n   \n   float eye_rad = -14.0*ANG2RAD;\n   vec2 eyeP = p + 0.6 * PAC_MAN_R * vec2(sin(eye_rad),-cos(eye_rad));\n   for(float i = 0.0; i <= 1.1;i += 0.1){\n       vec2 beanP = p + vec2( 3.0*tri(0.9,iTime + i) - 3.0 ,0.0);\n       col = mix(pacManColor,col,smoothstep(0.0,0.01,sdCircle(beanP,EYE_R)));\n   }\n   col = mix(vec3(0.0),col,smoothstep(0.0,0.01,sdCircle(eyeP,EYE_R)));\n   col = mix( col, col, 1.0-smoothstep(0.0,0.5,abs(d)));\n   \n   fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtScDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 132, 164, 164, 192], [196, 196, 226, 226, 261], [263, 266, 327, 327, 603], [605, 605, 662, 662, 1595]], "test": "untested"}
{"id": "DtBGDy", "name": "Local Light Source Pachinko", "author": "fenix", "description": "20000 particle-balls falling down, deferred-rendered via voronoi tracking with 4000 local light sources + shadows.\n\n*mouse to control camera* \n*shift to disable shadows*\n*space to pause/resume sim*\n*left/right to change palette*", "tags": ["3d", "simulation", "shadow", "particles", "shadows", "dynamics", "lights", "physics", "deferred"], "likes": 54, "viewed": 794, "published": 3, "date": "1691647024", "time_retrieved": "2024-07-30T17:40:04.557335", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  This is a continuation of my experiments in screen-space shadows I started with\n//\n//      Local Light Source Ball Pit      https://shadertoy.com/view/mt23R3\n//\n//  I guess thematically it's related to my 2D shader\n//\n//      Gummy Worm Pachinko              https://shadertoy.com/view/cdlXDH\n//\n//  This shader isn't a totally new idea from its predecessor, but I had to fix several\n//  problems with this technique for this shader to work. I started on this months ago\n//  and got frustrated so I gave up, but as you can see I eventually figured those out.\n//\n//  So as a recap, the basic idea is an extension of SSAO, reconstructing scene geometry\n//  from a depth buffer generated in a previous render pass (Buffer C). I render a G \n//  buffer with material, depth, and normal information first. Then in the final pass\n//  I \"render the lights\", performing DDA over the depth buffer to decide when they're\n//  occluded. The lights use a dedicated voronoi buffer (D) so that lights can carry\n//  further without (usually) being missed.\n//\n//  I think it produces fairly believable shadows, at least for the chosen subject. I\n//  tried making the pegs tall and skinny, but that doesn't work well with the shadows.\n//  Since the G buffer doesn't know about the empty space behind the tall skinny object,\n//  that space still occludes light.\n//\n//  The difficulties I had were probably mainly due to not being careful enough to use z\n//  depths in all cases, in place of distance to camera. When I tried interpolating\n//  distances to camera, the floor was not \"flat\" and so would occlude too much light.\n//\n//  Other than math fixes, one specific improvement is that I am now searching from\n//  the light source towards each rendered pixel, rather than the reverse as I had it\n//  before. This makes sure I don't miss occluders close to the light source given\n//  a limited number of search iteration. The texel traversal is the most expensive part\n//  of the shader (disable with shift to see the difference), especially when zoomed in\n//  since this necessitates farther searching to avoid artifacts.\n//\n//  * mouse to control camera * \n//  * shift to disable shadows *\n//  * space to pause/resume sim *\n//  * left/right to change palette *\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Buffer D computes nearest lights to each screen pixel\n//  Image performs lighting and occlusion\n//\n// ---------------------------------------------------------------------------------------\n\n// decode color from G buffer material\nvec3 materialColor(float c)\n{\n    if (c <= 1.) return vec3(c); // ground    \n    if (int(c) < g_MaxParticles / LIGHT_EMIT_RATIO) return vec3(1); // lit balls\n    switch(int(c) % 2) // unlit balls\n    {\n        case 0: return vec3(.2);\n        case 1: return vec3(1);\n    }\n}\n\n// decode emissivity from G buffer material\nvec3 materialEmis(float c, fxState s)\n{\n    if (c <= 2. || int(c) > g_MaxParticles / LIGHT_EMIT_RATIO) return vec3(0); // floor and unlight balls\n    switch(int(s.palette) % 6)\n    {\n        case 0:\n        switch(int(c) % 5) // lit balls\n        {\n            case 0: return vec3(  0, .88,   0);\n            case 1: return vec3( .6,  .1,  .9);\n            case 2: return vec3(.05, .14, .96);\n            case 3: return vec3(.85, .11, .05);\n            case 4: return vec3(  1, .58, .03);\n        }\n        case 1:\n        return .5 + .45*cos(6.2831589*c/float(g_MaxParticles) + vec3(0, 1.2, 2) + .35);\n        case 2:\n        return vec3(.5);\n        case 3:\n        return .5 + .45*cos(6.2831589*c/float(g_MaxParticles) * vec3(1, 11, 33) + .35);\n        case 4:\n        switch(int(c) % 5) // lit balls\n        {\n            case 0: return vec3(1, .1, .1);\n            default: return vec3(.7, .5, 1);\n        }\n        case 5:\n        switch(int(c) % 3) // lit balls\n        {\n            case 0: return vec3(0.8,0.86,0.86);\n            case 1: return vec3(.9,.7,0.17);\n            case 2: return vec3(.05, .1, 1);\n        }\n    }\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvec2 intersectXY(ivec2 xy, vec2 from, vec2 dir) { return (vec2(xy) - from) / dir; }\nfloat sum(vec2 x) { return x.x + x.y; }\n\n// texel traversal from rendered pixel to each light position, accumulating occlusion\nfloat occluded(fxParticle light, int id, fxState s, vec2 u, float z, mat4 w2c)\n{\n    vec3 lc = (w2c * vec4(light.pos,1.0)).xyz; // light center\n    lc.xy = ((lc.xy / lc.z) * iResolution.y + iResolution.xy) * .5;\n    \n    float sc = iResolution.y / s.camDist; // effect scale\n    \n    // compute the gradient of z, to establish the \"straight line\" between light source and rendered pixel\n    float dz = (z - lc.z) / length(u - lc.xy);\n    \n    // don't bother searching past some distance, light will be very dim anyway\n    if (distance(lc.xy, u) > sc) return 0.;\n\n    // setup traversal\n    vec2 rd = u - lc.xy;\n    vec2 cur = lc.xy;\n\tivec2 mp = ivec2(lc.xy);\n\tivec2 fp = ivec2(u);\n\tvec2 dd = abs(length(rd) / rd);\n    ivec2 rs = ivec2(sign(rd));\n    vec2 fix = sign(rd) * 0.5 + 0.5;\n\tvec2 sd = (sign(rd) * (vec2(mp) - lc.xy) + fix) * dd; \n\t\n    float occ = 0.;\n\n    int ms = int(sc * .7);\n\tfor (int i = 0; i < ms; i++)\n    {\n\t\tif (mp == fp) break; // we're done!\n        \n        // compute next pixel\n        bvec2 mask = lessThanEqual(sd.xy, sd.yx);\n        vec2 ts = intersectXY(mp + ivec2(fix), lc.xy, rd);\n        vec2 nxt = lc.xy + rd * sum(vec2(mask) * ts);\n        \n        if (i > int(sc * .1) && // skip the first few pixel since they'll be the light source particle anyway\n            mp.x >= 0 && mp.y >= 0 && mp.x < int(iResolution.x) && mp.y < int(iResolution.y)) // off-screen pixels contribute no shadow\n        {\n            fxGBufferPixel pix = fxUnpackGBuffer(texelFetch(iChannel2, mp, 0)); // get potentially-occluding pixel from G buffer\n\n            if (pix.m != float(id + 2)) // ignore the emitter's pixels\n                occ += max(0., lc.z - pix.z + length(lc.xy - nxt) * dz); // add up occlusion\n        }\n        \n        // go to the next pixel\n        cur = nxt;\n\t\tsd += vec2(mask) * dd;\n\t\tmp += ivec2(vec2(mask)) * rs;\n\t}\n\n    return 1. - clamp(occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    \n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel2, u/iResolution.xy));\n    fxState s = fxGetState();\n    \n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, int(iResolution.x), ro, fwd, lft, up);\n    \n    vec3 rd = fxCalcRay(u, iResolution, fwd, lft, up);\n\n    // sample neighbor pixels\n    mat4 c2w = fxCalcCameraMat(ro, fwd, lft, up);\n    mat4 w2c = inverse(c2w);\n\n    float t = pix.z / dot(rd, fwd); // reconstruct t from z\n    vec3 pos = ro + rd * t;\n    vec3 mc = materialColor(pix.m);\n    vec3 col = materialEmis(pix.m, s) * 2. + max(0., dot(pix.n, vec3(-1, 1, 1))) * mc * .05;\n\n    // lighting\n    ivec4 old = fxGetClosestLight(ivec2(u));\n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n\n        // for each nearest light source\n        fxParticle lgt = fxGetParticle(id);\n\n        // compute occlusion\n        float occ = s.shadow ? occluded(lgt, id, s, u, pix.z, w2c) : 1.;\n\n        // compute light\n        vec3 ld = lgt.pos - pos;\n        float l2 = dot(ld, ld);\n        vec3 lc = materialEmis(float(id + 2), s) / l2;\n\n        // apply lighting\n        float ndl = max(0., dot(pix.n, ld / sqrt(l2)));\n        float dif = occ * ndl * .3;\n        col += lc * dif * mc;\n    }\n\n    O.xyz = col;\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = u.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.; // multiply with sth for intensity\n    vig = pow(vig, .8); // change pow for modifying the extend of the  vignette\n    O *= vig;\n\n    O.rgb = pow(ACESFilm(O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .1;\nconst int LIGHT_EMIT_RATIO = 5; // 1 out of N balls will be lit, decrease for MOAR LIGHTS\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X) // channel 1 is Buffer B\n#define fxGetClosestLight(X) fxGetClosestImpl(iChannel3, X) // channel 3 is buffer D\nivec4 fxGetClosestImpl(sampler2D smp, ivec2 v)\n{\n    return ivec4(texelFetch(smp, v, 0));\n}\n\n// enum for the data types making up the structure of each particle\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define VEL 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int wd, int id, int typ)\n{\n    int idx = id * NUM_PARTICLE_DATA_TYPES + typ;\n    return ivec2(idx % wd, idx / wd);\n}\n\nstruct fxParticle\n{\n    ivec4 nbs[4];\n    vec3 pos;\n    vec3 vel;\n};\n\n// get the particle corresponding to the id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\nfxParticle fxGetParticleImpl(sampler2D smp, int wd, int id)\n{\n    vec4 data0 = texelFetch(smp, fxLocFromID(wd, id, UL_NEIGHBORS), 0);\n    vec4 data1 = texelFetch(smp, fxLocFromID(wd, id, UR_NEIGHBORS), 0);\n    vec4 data2 = texelFetch(smp, fxLocFromID(wd, id, LL_NEIGHBORS), 0);\n    vec4 data3 = texelFetch(smp, fxLocFromID(wd, id, LR_NEIGHBORS), 0);\n    vec4 data4 = texelFetch(smp, fxLocFromID(wd, id, POS), 0);\n    vec4 data5 = texelFetch(smp, fxLocFromID(wd, id, VEL), 0);\n\n    fxParticle p;\n    p.nbs[0] = ivec4(data0);\n    p.nbs[1] = ivec4(data1);\n    p.nbs[2] = ivec4(data2);\n    p.nbs[3] = ivec4(data3);\n    p.pos = data4.xyz;\n    p.vel = data5.xyz;\n    \n    return p;\n}\n\n// write the correct channel of the particle\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D smp, int wd, int id, int typ)\n{\n    return texelFetch(smp, fxLocFromID(wd, id, typ), 0);\n}\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 20000;\nint g_MaxParticles = 0; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\n// must be called in each buffer before g_MaxParticles is valid\n#define computeMaxParticles() computeMaxParticlesImpl(iResolution)\nvoid computeMaxParticlesImpl(vec3 R)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, int(R.x * R.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec3 lookAt;\n    float camDist;\n    float camAngle;\n    float res;\n    float palette;\n    bool shadow;\n    bool sim;\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1) // channel 1 is Buffer B\nfxState fxGetStateImpl(sampler2D smp)\n{\n    vec4 data0 = texelFetch(smp, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(smp, ivec2(1, 0), 0);\n    \n    fxState s;\n    s.lookAt = data0.xyz;\n    s.camDist = data0.w;\n    s.camAngle = data1.x;\n    s.res = data1.y;\n    s.shadow = mod(data1.z, 2.) != 0.;\n    s.sim = data1.z >= 2.;\n    s.palette = data1.w;\n        \n    return s;\n}\n\nvec4 fxPutState(fxState s, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(s.lookAt, s.camDist);\n    else\n        return vec4(s.camAngle, s.res, (s.shadow ? 1. : 0.) + (s.sim ? 2. : 0.), s.palette);\n}\n\n// CAMERA\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nvoid fxCalcCamera(fxState s, int resolutionWidth, out vec3 ro, out vec3 fwd, out vec3 lft, out vec3 up)\n{\n    vec3 ta = s.lookAt;\n    \n    ro = vec3(0, 1, 1) * s.camDist;\n    ro.yz *= rotate(s.camAngle);\n    ro += ta;\n    \n    fwd = normalize(ta - ro);\n    lft = -normalize(cross(fwd, vec3(0.0,1.0,0.0)));\n    up = normalize(cross(lft, fwd));\n}\n\nmat4 fxCalcCameraMat(vec3 ro, vec3 fwd, vec3 lft, vec3 up)\n{\n    return mat4(vec4(-.5 * lft, 0),\n                vec4(-.5 * up , 0),\n                vec4(fwd      , 0),\n                vec4(ro       , 1));\n}\n\nvec3 fxCalcRay(vec2 u, vec3 R, vec3 fwd, vec3 lft, vec3 up)\n{\n\tvec2 s = (u - .5 * R.xy) / R.y;\n\treturn normalize(fwd - s.x * lft - s.y * up);\n}\n\n// PHYSICS BOUNDARY SCENE\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// returns (distance, material) for the entire scene (not including particles)\nvec2 scene(vec3 p)\n{\n    p.yz *= rotate(-.5);\n\n    vec3 f;\n    f.xz = fract(p.xz) - .5;\n    f.y = p.y;\n    float d = p.y; // dist to floor\n    float m = 0.;\n    float c1 = sdCappedCylinder(f - vec3(-.25, 0,  .25), .1, .05) - .05;\n    if (c1 < d)\n    {\n        d = c1;\n        m = 1.;\n    }\n    float c2 = sdCappedCylinder(f - vec3( .25, 0, -.25), .1, .05) - .05;\n    if (c2 < d)\n    {\n        d = c2;\n        m = 1.;\n    }\n    return vec2(d, m);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(vec3 p)\n{\n    const vec2 e = vec2(1,-1)*.00005773;\n    return normalize( e.xyy * scene(p + e.xyy).x + \n\t\t\t\t\t  e.yyx * scene(p + e.yyx).x + \n\t\t\t\t\t  e.yxy * scene(p + e.yxy).x + \n\t\t\t\t\t  e.xxx * scene(p + e.xxx).x );\n}\n\n// G BUFFER\n\n// note there are five dwords here...material m is stored where the normal z would usually be, and the normal z is reconstructed\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float z; // z depth\n    float m; // material\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n.xy, pix.m * sign(pix.n.z), pix.z);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n.xy = fragColor.xy;\n    \n    // reconstruct the z component of the normal\n    pix.n.z = sqrt(max(0., 1. - (pix.n.x * pix.n.x + pix.n.y * pix.n.y))) * sign(fragColor.z);\n    pix.m = abs(fragColor.z);\n    pix.z = fragColor.w;\n    \n    return pix;\n}\n\n// MISC\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_LEFT  37\n#define KEY_RIGHT 39\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1./float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// VORONOI\n\nfloat distance2Particle(sampler2D par, int wd, int id, vec2 u, mat4 w2c)\n{\n    // compute screen space position\n    vec3 wp = fxGetParticleDataImpl(par, wd, id, POS).xyz;\n    vec3 sp = (w2c * vec4(wp,1.0)).xyz;\n    sp.xy /= sp.z;\n    \n    return length2(sp.xy - u);\n}\n\n#define voronoi(A, B, C, D, E) voronoiImpl(A, B, C, iResolution, iFrame, D, E)\nvec4 voronoiImpl(sampler2D par, sampler2D clo, fxState s, vec3 R, int iFrame, vec2 u, int maxParticles)\n{\n    ivec2 ifc = ivec2(u);\n    int wd = int(R.x);\n\tvec2 p = (2. * u - R.xy) / R.y;\n\n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, wd, ro, fwd, lft, up);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(ro, fwd, lft, up);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosestImpl(clo, ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            if (id >= maxParticles) continue;\n            float dis2 = distance2Particle(par, wd, id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleDataImpl(par, wd, id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0 && nid < maxParticles)\n            {\n                float dis2 = distance2Particle(par, wd, nid, p, w2c);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint rng = 64u;\n        uint cnt = 4u;\n\n        for(uint i = 0u; i < cnt; ++i)\n        {\n            uvec4 h0 = hash(uvec4(ifc, iFrame, i) * i);\n            ivec4 old = fxGetClosestImpl(clo, ifc + ivec2( h0.xy % rng - rng / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                if (id >= maxParticles) continue;\n                float dis2 = distance2Particle(par, wd, id, p, w2c);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % maxParticles;\n            insertion_sort(new, dis, id, distance2Particle(par, wd, id, p, w2c));\n        }\n    }\n    \n    return vec4(new);\n}\n\n\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nvec3 GRAVITY = vec3(0,-.0005,0);\n\nvoid particleStep(inout fxParticle p, fxState s, int id, vec2 u);\nvec4 neighborUpdate(fxParticle p, fxState s, int typ, ivec2 ifc, int id);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n    int idx = ifc.x + ifc.y * int(iResolution.x);\n    int id = idx / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int typ = idx - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles();\n    if(id >= g_MaxParticles) return;\n\n    fxState s = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (typ < POS)\n    {        \n        O = neighborUpdate(p, s, typ, ifc, id);\n    }\n    else\n    {\n        if (s.sim) particleStep(p, s, id, u);\n        \n        O = fxSaveParticle(p, typ);\n    }\n}\n\n// PARTICLE UPDATE\n\nvoid particleStep(inout fxParticle p, fxState s, int id, vec2 u)\n{\n    if (iFrame == 0 || s.res < 0.)\n    {\n        // init\n        vec3 h = hash3( uvec3(u, iFrame) ) - .5;\n        p.pos = h * vec3(60, 0, 60);\n        p.pos.yz *= rotate(.5);\n        p.pos += vec3(0, 8, -16);\n        \n        if (id == 0) p.pos = vec3(0); // particle zero starts at the center so we can track it with the camera\n        \n        p.vel = vec3(0);\n        \n        return;\n    }\n\n    p.vel += GRAVITY;\n\n    // collide with neighbors\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            int nid = p.nbs[i][j];\n            if (nid < 0) break;\n            fxParticle nb = fxGetParticle(nid);\n\n            if (distance(nb.pos, p.pos) < PARTICLE_SIZE * 2.)\n            {\n                vec3 dir = normalize(p.pos - nb.pos);\n\n                // position correction\n                p.pos += mix(vec3(0), nb.pos + dir * PARTICLE_SIZE * 2. - p.pos, .05);\n\n                vec3 relVel = p.vel - nb.vel;\n                p.vel -= min(0., dot(relVel, dir)) * dir;\n            }\n        }\n    }\n\n    // collide with boundary\n    float b = scene(p.pos).x;\n    if (b < PARTICLE_SIZE)\n    {\n        vec3 n = sceneNormal(p.pos);\n\n        // position correction\n        p.pos += n * (PARTICLE_SIZE - b) * .5;\n\n        // clip velocity\n        p.vel -= min(0., dot(p.vel, n)) * n;\n    }\n    \n    // particle update\n    p.vel *= .995; // damping\n    const float MAX_SPEED = .025; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n\n    p.pos += p.vel; // integrate\n}\n\n// NEIGHBOR UPDATE\n\nbool iscoincidence(in ivec4 ids, int cid, int sid)\n{\n    return sid == cid || any(equal(ids,ivec4(sid)));\n}\n\nvoid sortParticle(inout ivec4 ids, inout vec4 ds, int typ, int pid, int sid, in fxParticle p)\n{\n    if(iscoincidence(ids, pid, sid)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(sid, POS).xyz; \n\n    vec3 dx = nbX - p.pos;\n    \n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n    if(dir != typ) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(ids, ds, sid, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState s, int typ, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 ids = ivec4(-1);\n    vec4 ds = vec4(1e6);\n\n    if (iFrame > 0 && s.res > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sortParticle(ids, ds, typ, id, nid, p);\n\n                // consider neighbors' closest neighbor\n                for (int x = 0; x < 4; ++x)\n                {\n                    ivec4 nbsNbs = ivec4(fxGetParticleData(nid, x));\n                    for (int y = 0; y < 2; ++y)\n                    {\n                        int nbNid = nbsNbs[y];\n                        if (nbNid < 0) break;\n                        sortParticle(ids, ds, typ, id, nbNid, p);\n                    }\n                }\n            }\n        }\n\n        // random search\n        int iter = iFrame < 10 ? 16 : 8;\n        for(int k = 0; k < iter; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % g_MaxParticles;\n            sortParticle(ids, ds, typ, id, hi, p);\n        }\n    }\n    \n    return vec4(ids);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer plus persistent state handling\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    fxState s = fxGetState();\n    \n    ivec2 ifc = ivec2(u);\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        if (iFrame == 0 || // bootstrap\n            abs(s.res) != iResolution.x * iResolution.y || // detect resolution change\n            s.lookAt.y < -70.) // reset after a while to prevent precision issues\n        {\n            s.res = -iResolution.x * iResolution.y;\n            s.camDist = 6.;\n            s.camAngle = .3;\n            if (iFrame == 0)\n                s.palette = 0.;\n            s.lookAt = vec3(0);\n            s.shadow = true;\n            s.sim = true;\n        }\n        else\n        {\n            // update persistent state\n            s.res = abs(s.res); // positive res means, don't reset\n            s.lookAt = mix(s.lookAt, fxGetParticleDataImpl(iChannel0, int(iResolution.x), 0, POS).xyz, .01); // track ball zero\n\n            if (iMouse.z > 0.)\n            {\n                s.camDist = 15. * (iMouse.x / iResolution.x);\n                s.camAngle = -iMouse.y / iResolution.y + .7;\n            }\n            \n            if (keyClick(KEY_SHIFT)) s.shadow = !s.shadow;\n            if (keyClick(KEY_SPACE)) s.sim = !s.sim;\n            if (keyClick(KEY_LEFT)) s.palette--;\n            if (keyClick(KEY_RIGHT)) s.palette++;\n        }\n\n        O = fxPutState(s, ifc);\n    }\n    else\n        O = voronoi(iChannel0, iChannel1, s, u, g_MaxParticles);\n}\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(int id, fxParticle p, vec3 fwd, vec3 ro, vec3 rd, inout fxGBufferPixel pix);\nfxGBufferPixel renderScene(vec3 ro, vec3 fwd, vec3 rd, vec3 ddx_rd, vec3 ddy_rd);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    \n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(fxGetState(), int(iResolution.x), ro, fwd, lft, up);\n\n    vec3 rd = fxCalcRay(u, iResolution, fwd, lft, up);\n    vec3 ddx_rd = fxCalcRay(u + vec2(1, 0), iResolution, fwd, lft, up);\n    vec3 ddy_rd = fxCalcRay(u + vec2(0, 1), iResolution, fwd, lft, up);\n    \n    fxGBufferPixel pix = renderScene(ro, fwd, rd, ddx_rd, ddy_rd);\n\n    // render particles\n    ivec4 old = fxGetClosest(ivec2(u));      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        renderParticle(id, data, fwd, ro, rd, pix);\n    }\n    \n    O = fxPackGBuffer(pix);\n}\n\n// PARTICLE RENDER\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.) return -1.;\n\treturn -b - sqrt( h );\n}\n\n// draw one particle\nvoid renderParticle(int id, fxParticle p, vec3 fwd, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    float t = sphIntersect(ro, rd, vec4(p.pos, PARTICLE_SIZE));\n    vec3 hit = ro + rd * t;\n    float z = t * dot(fwd, rd); // construct z from t\n    if (z > 0. && z < pix.z)\n    {\n        pix.n = normalize(hit - p.pos);\n        pix.m = float(id + 2); // materials 0...1 are for box\n        pix.z = z;\n    }\n}\n\n// SCENE RENDER\n\n// From iq's filtered checker (box, 2D)\n// https://.shadertoy.com/view/XlcSz2\n\n// --- analytically box-filtered checkerboard ---\n\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.6 - 0.4*i.x*i.y;                  \n}\n\nvec2 texCoords( in vec3 pos )\n{\n    pos.yz *= rotate(-.5);\n\n\treturn pos.xz;\n}\n\n// simple marching loop, returning (hit position, material)\nvec4 march(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n    float t = 0.;\n    float m = 0.;\n    for (int i = 0; i < 64; ++i)\n    {\n        vec2 r = scene(p);\n        m = r.y;\n        if (r.x < .001) break;\n        r.x *= .5;\n        p += r.x * rd;\n        t += r.x;\n    }\n\n    return vec4(p, m);\n}\n\n// render table and posts\nfxGBufferPixel renderScene(vec3 ro, vec3 fwd, vec3 rd, vec3 ddx_rd, vec3 ddy_rd)\n{\n    vec4 hit = march(ro, rd);\n    \n    fxGBufferPixel pix;\n    pix.n = sceneNormal(hit.xyz);\n    pix.z = dot(fwd, hit.xyz - ro); // construct z from hit point\n    pix.m = hit.w;\n\n    if (pix.m == 0.) // generate checker pattern if we hit the ground\n    {\n        vec3 ddx_pos = ro - ddx_rd*dot(ro-hit.xyz,pix.n)/dot(ddx_rd,pix.n);\n        vec3 ddy_pos = ro - ddy_rd*dot(ro-hit.xyz,pix.n)/dot(ddy_rd,pix.n);\n\n        // calc texture sampling footprint\t\t\n        vec2     uv = texCoords(hit.xyz);\n        vec2 ddx_uv = texCoords(ddx_pos) - uv;\n        vec2 ddy_uv = texCoords(ddy_pos) - uv;\n\n        pix.m = checkersTextureGradBox( uv, ddx_uv, ddy_uv );\n    }\n\n    return pix;\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking, only tracking light-emitting particles\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    \n    O = voronoi(iChannel0, iChannel2, fxGetState(), u, g_MaxParticles / LIGHT_EMIT_RATIO);\n}\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBGDy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2815, 2854, 2883, 2883, 3128], [3130, 3174, 3213, 3213, 4308], [4310, 4394, 4417, 4417, 4577], [4579, 4579, 4628, 4628, 4662], [4663, 4663, 4682, 4682, 4702], [4704, 4790, 4870, 4870, 6683], [6685, 6685, 6721, 6721, 8437]], "test": "untested"}
{"id": "dlByDR", "name": "Arabesque knots 5 (music)", "author": "jarble", "description": "An arabesque knot pattern.\nClick and drag to move around.", "tags": ["fractal", "music", "knot", "arabesque"], "likes": 5, "viewed": 183, "published": 3, "date": "1691645837", "time_retrieved": "2024-07-30T17:40:05.461916", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //min(abs(f1((a1)*(a2.x+a2.y))-.5),abs(f1((1.-a1/2.)*(a2.x+a2.y))-.5))\n    ;\n}\n\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        //uv.x += 1./4.;\n        \n        uv =\n            abs(.5+uv+t2)\n            //abs(.5+uv+t2)*sign(uv.y/1.5-uv.x)\n        ;\n        //uv = -(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        \n        if(k%3 == 0) uv += .5; else uv /= 1.5;\n        bool b = uv.y>uv.x;\n        if(\n            b\n            //b||t2.y<t2.x&&!b\n            //b&&t2.y>t2.x\n            //b&&t2.y<t2.x\n        ) uv = uv.yx;\n        //else col = col.yzx;\n        //else k -= 1;\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5)-floor(t2)\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n        ;\n        //if(b||t2.y<t2.x)\n        col =\n            vec3(col.zx,max(uv.x-uv.y,0.))\n            //vec3(col.xy,max(uv.x-uv.y,col.z)).yzx\n            //abs(vec3(col.zx,max(uv.x-uv.y,-col.y)))\n        ;\n        //uv += triwave1_((uv+iTime));\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float m1(float a, float b, float c){\n    return floor(floor(floor(a)/b)/c);\n}\n\nfloat mod1(float a,float b){\n    return \n        mod(a,b)\n        //mod(a+mod(a,3.)-mod(a,5.),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a += mod1(floor(a/2.),b);\n    }\n}\n\nfloat fmod(float a, float b){\n    //distort(a,b);\n    \n    //a *= (1.+mod(floor(a/8.),2.));\n    //a += m1(a/8.,5.+b,3.+b);\n    //a += mod(b/2.,2.);\n    return\n        mod1(mod1(8.+floor(a/8.),b*2.+floor(b*a)-floor(a/8.)),b)\n        //mod(mod(8.+floor(a/2.),8.+floor(a)),b)\n        //mod(floor(a/b-mod(a/8.,2.)+mod(a/8.,3.)),b)\n        //mod(floor(a/2.),b)*mod(floor(a/b)*floor(a/b),b/2.)\n        //mod(floor(8./b+a*b/8./2.),b)\n        //mod(mod(floor(8./b+a*b/8./2.),b+floor(a/8./2.)),b)\n        //mod(mod(8.+floor(a/8.+b/8.),b*2.+floor(b*a+8./b)-floor(a/8.+8./b)),b)\n    ;\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 mainSound1(int samp, float time,float scale){\n  time /= 2.;\n  float s1 =\n      8.,\n  s2 = 8.,\n  t = time/4.,\n  m1 = fmod(t*8.,s1/2.),\n  p1 = pow(2.,m1)\n  ;\n  t = \n      s1*pow(2.,fmod(t*16.+m1,2.))*t/(1.+fmod(floor(t*4.),2.))\n      //s1*pow(2.,fmod(t*8.+m1,3.))*t;\n  ;\n\n  float\n  m3 =\n      floor(fmod(time*8.*p1,s1/2.)/2.)\n  ;\n  float m2 =\n      1. + fmod(t*8.,s1/2.)\n      //1. + fmod((t+floor(t/8.))*8.,s1/2.)\n  ;\n  float a=\n      //128.*pow((1.-sqrt(fract(t)/2.))/2.,2.)\n      //pow(log(fract(t)/8.),2.)\n      \n      //gamelan\n      pow(log(.125+fract(t)/4.),2.)\n\n      \n  ;\n  float nb = time*pow(2.,(m3+m2-m1)/7.+scale);\n  return\n      //abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      \n      //gamelan\n      a/16./2.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb*4.*.998),fract1(nb*4.)))/2.))\n      +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb*2.*.998),fract1(nb*2.)))/2.)))   \n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      //log(1./8.+a*abs(1./8.-abs(.5-vec2(fract(nb*.998),fract(nb/2.)))))\n      \n      //log(1.+abs(a/32.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      //abs(.5-abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n  ;\n}\n\nvec2 mainSound(int a,float b){\n    return\n    //mainSound1(a,b,8.);\n    \n    //abs(mainSound1(a,b,8.)-mainSound1(a,b,8.5)/4.)\n\n    (mainSound1(a,b,8.)+mainSound1(a*2,b/2.,8.)+mainSound1(a*4,b/4.,8.))/3.\n    //(mainSound1(a,b*2.,6.)+mainSound1(a,b*4.,4.))/2.;\n    //mainSound1(a,b,8.)+mainSound1(a,b*2.,8.)/2.+mainSound1(a,b*4.,8.)/4.+mainSound1(a,b/8.,8.)/8.;\n    ;\n}", "sound_inputs": [], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlByDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 52], [54, 54, 81, 81, 272], [390, 390, 416, 416, 505], [508, 508, 565, 565, 1846]], "test": "untested"}
{"id": "Dtjczm", "name": "Void And Cluster Bluenoise -spl2", "author": "FabriceNeyret2", "description": "further simplifying  of https://shadertoy.com/view/DdXSD4  \nthat was simplifying \"Void And Cluster Bluenoise\" by krax  [url]https://www.shadertoy.com/view/cdfSD8[/url]\nLeft: krax algo with sigma = 2.5\nRight: shadertoy bluenoise.", "tags": ["noise", "bluenoise"], "likes": 13, "viewed": 229, "published": 3, "date": "1691602121", "time_retrieved": "2024-07-30T17:40:06.230860", "image_code": "// further simplifying  https://shadertoy.com/view/DdXSD4\n// simplifying \"Void And Cluster Bluenoise\" by krax. https://shadertoy.com/view/cdfSD8\n// from ref: https://alister-chowdhury.github.io/posts/20221230-bluenoise-generator/\n// Deeper simplif and optim here: https://www.shadertoy.com/view/mt2cWR\n\n// more reading: https://momentsingraphics.de/BlueNoise.html#The_void_and_cluster_method\n// about variance: larger → more LF but more isotropic.  very low → Bayer. Best compromise ~1.9, but shadertoy one ~ 2.5\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n // O = vec4(texelFetch(iChannel2, ivec2(u), 0).x!=0.); return; // for debug\n \n    vec2 R = iResolution.xy, U = u/R;\n    if ( int(u) == int(R)/2 ) { O = vec4(1, U.y > float(iFrame)/(s*s),0,0); return; } // reference shadertoy bluenoise\n    if ( U.x>.5 ) { O = texelFetch(iChannel1, ivec2(u)%1024, 0 ).xxxx; return; } // red separator\n\n#if 1\n    u = s*fract(u/s);\n#else \n    u *= s/R;\n#endif \n\n    O = T(u.x,u.y).xxxx;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int S = 64;           // bluenoiseSize = SxS , cycling tile\nfloat  s = float(S);\n\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y), 0)\n\nint H(uvec3 Seed)                                   // hash function\n{\n    uint  hx = 0xb543c3a6u ^ Seed.x,\n          hy = 0x526f94e2u ^ Seed.y,\n         hz0 = 0x53c5ca59u ^ (hx*hy >> 5u),\n         hz1 = 0x74743c1bu ^ Seed.z;\n    return int( hz0 * hz1 );\n}\n\n\n# if 1 \n\n#define INIT(S,SEED)   /* SEED ignored in my version */                 \\\n    if( U.x>float(S) || U.y>float(S) ) return; /* we only simulate a small square */ \\\n    O = vec4( 1e35, 0,0,0);                                             \\\n    ivec2   start = min( ivec2(U)*8, S - 1 ), /* to reduce a 8x8 above subtile to 1 */ \\\n              end = min( start + 8, S );                                \\\n    int x,y;\n        \n#define M(S,s,c)                                                        \\\nvoid mainImage( out vec4 O, vec2 U ) {                                  \\\n    INIT( S,  s );                                                      \\\n    for( y=start.y; y<end.y; ++y)                                       \\\n    for( x=start.x; x<end.x; ++x)                                       \\\n     {                                                                  \\\n        vec4 E = T(x,y);                                                \\\n        c;                           /* store result */                 \\\n}   } \n\n\n#else // original version. But the order scrambling seems useless to me, since energy can't be symmetrical due to initial hash\n\n#define INIT(S,SEED)                                                    \\\n    O = vec4( 1e35, 0,0,0);                                             \\\n    ivec2   start = min( ivec2(U) << 3, S - 1 ),                        \\\n              end = min( start + 8, S );                                \\\n    /* Reduce 8x8 at a time, but mix up the order of comparison */      \\\n    /* to prevent biasing in any one location */                        \\\n    int yh = H(uvec3(start + 1, SEED)) >> 20,                           \\\n        xh = H(uvec3(start + ivec2(13, 11), yh)) >> 19, x,y,i,j;\n        \n#define M(S,s,c)                                                        \\\nvoid mainImage( out vec4 O, vec2 U ) {                                  \\\n    INIT( S,  s );                                                      \\\n    for( j=0; j < 8; ++j ) {                                            \\\n        y = start.y + ((yh ^ j) & 7);                                   \\\n        if(y < end.y)                                                   \\\n            for( i=0; i < 8; ++i ) {                                    \\\n                x = start.x + ((xh ^ i) & 7);                           \\\n                if(x < end.x) {                                         \\\n                    vec4 E = T(x,y);                                    \\\n                    c;                           /* store result */     \\\n}   }       }   }\n\n#endif\n", "buffer_a_code": "// This stage deals with updating the blue noise energy.\n// On the first iteration, we simply seed it with background\n// energy.\n// output: .x = bluenoise, .y = energy.   \n// input:  D.yz = location or largest void.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if( U.x>s || U.y>s ) return; // we only simulate a small (cyclicling) square\n\n    if(iFrame == 0)              // init: noise = 0, energy = random\n    {   O.xy = vec2( 0, intBitsToFloat(H(uvec3(U, 2111)) & 0x1fffffff) );\n        return;\n    }\n    \n    O = T(U.x,U.y);              // previous state\n    if(iFrame > S*S-1) return;   // max iteration reached\n \n \n \n    // Get the result from downscaling and finding the smallest void center\n    U = abs( floor(U) - texelFetch(iChannel1, ivec2(0), 0).yz ) / s;  // delta to target\n\n    float v = 1. - float(iFrame-1) / (s*s-1.); // noise value = normalized iterations\n\n    // Wrap around logic : max energy around optimal void center modulo s : https://www.desmos.com/calculator/zuopknqihy\n    vec2 d = ( abs( U - .5 ) - .5 )  * s / 2.5 ;  // sigma = 2.5\n                                                  // $FaN: krax used 1.9 and fract(U)\n    O.xy += vec2( U==vec2(0) ? v : 0.,            // we are at the optimum : store noise\n                  v * exp( -dot(d,d) ) );         // energy += gaussian to optimum\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Void and cluster reduce init\n// input: SxS state noise,energy.\n// output: .xyz = lowest energy value + position on SxS  ( and not already chosen ). could have been/8 with modulo fetch\n\nM( S , \n   floatBitsToInt(iTime) ^ int(iFrame) ,                   // seed: useless in my version\n   if( E.x == 0. && E.y < O.x ) O = vec4( E.y, x, y, 0)\n )", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Void and cluster reduce iteration\n// input: SxS state energy,location\n// output: .xyz = lowest energy value + position on SxS /8 ( and not already chosen ). could have been/8 with modulo fetch\n\nM( (S+7)/8,                                            // or just S/8 if S = power of 2\n   H(floatBitsToUint(iDate.yzw * iTime)) ^ iFrame,     // seed. useless in my version\n   if( E.x < O.x ) O = E\n )", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Final reduction, no 8x8 tiling, since we have no more buffers.\n// input: SxS /8 state energy,location\n// output: .xyz = lowest energy value + position on SxS /8²    ( and not already chosen )\n\nM( (S+63) /64, 0,                // or just S/64 if S = power of 2\n   if ( E.x < O.x ) O = E;       // seed. useless in my version\n )\n\n/* original: \n\nvoid mainImage( out vec4 O, vec2 U )\n{\nINIT( (S+63) /64, 0 );\n    \n    for( y=start.y; y<end.y; ++y)\n    for( x=start.x; x<end.x; ++x)\n    {\n        vec4 E = T(x,y);\n        if ( E.x < O.x ) O = E; \n    }\n}\n*/    \n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtjczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[518, 518, 556, 634, 977]], "test": "untested"}
{"id": "Dt2yzm", "name": "banderia", "author": "bjks", "description": "b anderia", "tags": ["banderia"], "likes": 0, "viewed": 127, "published": 3, "date": "1691596147", "time_retrieved": "2024-07-30T17:40:07.000802", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float r1 = (sin(iTime-uv.y*3.0)+3.2)/10.0;\n    float r2 = (sin(iTime-uv.y*3.0)+6.5)/10.0;\n    float s1 = (sin(iTime-uv.y*3.0))/3.0;\n    float s2 = (sin(iTime-(uv.y-0.32)*10.0))/3.0;\n    \n    if(r1 > uv.x){\n                fragColor = vec4(1.0,0,.2,1)*(s1+0.45)/0.65;\n        } else if(r2 > uv.x){\n                fragColor = vec4(0,1,0.5,1)*(s1+0.45)/0.65;\n        } else if(r2 < uv.x){\n                fragColor = vec4(0,.0,1,1)*(s1+0.45)/0.65;\n        }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2yzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 610]], "test": "untested"}
{"id": "ct2yzm", "name": "Bandeira Monaco mexendo", "author": "CraquePedro", "description": "a", "tags": ["a"], "likes": 0, "viewed": 125, "published": 3, "date": "1691596126", "time_retrieved": "2024-07-30T17:40:07.767751", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float mv = (sin(iTime - uv.x * 3.0) + 15.0) / 30.0;\n    float mv2 = (sin(iTime - uv.x * 3.0) + 15.0) / 15.0;\n    float wv = sin(iTime - uv.x + 100.0)*50.0/ 100.0; \n     float wv2 = sin(iTime - uv.x + 100.0)*50.0/ 100.0; \n\n    if (mv > uv.y)\n    {\n        fragColor = vec4( 2,2, 2,2)*(wv+ 1.0)/2.0;\n    }\n\n    else\n    {\n        fragColor = vec4(2, 0, 0, 0)*(wv2 + 1.0)/2.0; \n    }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2yzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 485]], "test": "untested"}
{"id": "Dt2cRm", "name": "Tileable Water Fork", "author": "LeifMessinger", "description": "Holy cow it actually is tileable.\n\nRealized on the original (https://www.shadertoy.com/embed/dlSyzW) I could have just done #define SHOW_TILING. It also flashes a nice yellow. Might add that to some other stuff later.", "tags": ["water", "caustic"], "likes": 2, "viewed": 128, "published": 3, "date": "1691596068", "time_retrieved": "2024-07-30T17:40:08.539687", "image_code": "// Found this on shadertoy. He said it was tileable, so I tiled it using my function from here https://www.shadertoy.com/embed/dlSyzW\n// :)\n// by David Hoskins. https://www.shadertoy.com/view/MdlXz8\n// Original water turbulence effect by joltz0r\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5+23.0;\n    // uv should be the 0-1 uv of texture...\n    \n    bool mouseInactive = iMouse.xy == vec2(0.0, 0.0);\n    //Tile size in pixels\n    vec2 tileSize = mouseInactive? (iResolution.xy/8.0): iMouse.xy;\n    \n    //This gets the coords, which is the fragCoord from [0.0, 0.0] to [1.0, 1.0] inside the tile\n    ivec2 tileIndex;\n    vec2 uv = tile(fragCoord, tileSize, tileIndex);\n    \n#ifdef SHOW_TILING\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\n#else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n#endif\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\tfragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "//Tiles coordinates\n//loopDistance is the xy size of a tile\n//the output is the coordinate from [0,1] with respect to its own tile\nvec2 tile(in vec2 coord, in vec2 loopDistance, out ivec2 tileIndex){\n    vec2 xy = coord/loopDistance; //This is the xy of one tile\n    vec2 coords = fract(xy); //Same as mod(x,1.0);\n    tileIndex = ivec2(trunc(xy));\n    return coords;\n}\n\nvec2 tile(in vec2 coord, in vec2 loopDistance){\n    ivec2 tileIndex; //We throw this away\n    return tile(coord, loopDistance, tileIndex);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt2cRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 351, 351, 1349]], "test": "untested"}
{"id": "cl2yRm", "name": "Japan Flag Moving", "author": "nakanzaki", "description": "aaa", "tags": ["japan"], "likes": 0, "viewed": 90, "published": 3, "date": "1691595445", "time_retrieved": "2024-07-30T17:40:09.301650", "image_code": "bool circle(vec2 pos, vec2 center, float radius) {\n    return distance(pos, center) < radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Back and Forth\n    \n    //float time = mod(iTime, 1.0);\n    //if(sin(iTime * radians(180.0)) > 0.0) time = 1.0 - time;\n    \n    //if(time > uv.x) fragColor = vec4(1.0);\n    //else fragColor = vec4(0.0);\n    \n    // Ondulation\n    \n    float time = sin(radians(180.0) * 2.0 *(iTime + uv.y))*0.5;\n    //fragColor = vec4((time * 0.25) + uv.x);\n    fragCoord = fragCoord + vec2(time * 10.0, 0.0);\n    \n    // Flag Setup\n    \n    vec2 center = vec2(iResolution.x / 2.0, iResolution.y / 2.0);\n    if(circle(center, fragCoord, iResolution.y / 4.0)) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    else fragColor = vec4(1.0);\n    \n    \n    //fragColor = vec4(sin(mod((sin(radians(180.0) * uv.y) + 0.25) * 2.0, 1.0)));\n    //if(time + 0.5 > uv.x) fragColor = vec4(1.0) - fragColor;\n    \n    //if(time + 0.333 > uv.x) fragColor = vec4(1.0);\n    //else if(time + 0.667 > uv.x) fragColor = vec4(0.5);\n    //else fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2yRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 95], [97, 97, 154, 204, 1175]], "test": "untested"}
{"id": "Dtjyzw", "name": "circle distribution test", "author": "01000001", "description": "A small shader to experiment with circle area distribution functions to visually check for uniformity. Doubles as a way to test performance of functions.", "tags": ["utility", "tool"], "likes": 5, "viewed": 163, "published": 3, "date": "1691594023", "time_retrieved": "2024-07-30T17:40:10.082562", "image_code": "void mainImage( out vec4 O, vec2 U){\n    vec2 u = U/iResolution.xy;\n    O = texture(iChannel0, u);   \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//#define DoGoofyStuff\n\n\n\nconst float pi = 3.14159;\nconst float tau = pi*2.;\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\n\n//https://www.youtube.com/watch?v=p8u_k2LIZyo\nfloat fisqrt(float x)\n{\n    uint i;\n    float x2, y;\n    \n    x2 = x*.5;\n    y = x;\n    i = floatBitsToUint(x);              // evil floating point bit hack\n    i = uint(0x5f3759df) - ( i >> 1);    // wut\n    y = uintBitsToFloat(i);\n    \n\n    y = y*(1.5 - (x2 * y * y));           //newton iteration\n//  y = y*(1.5 - (x2 * y * y));           //newton iteration (optional)\n    \n\n    return y;\n}\n\n\nvec2 uvtc(vec2 u){ return (2.*u - iResolution.xy)/iResolution.y; }\n\n/*\n// Good : Rejection sampling\n#ifdef DoGoofyStuff\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy;\n    return sin(v.x*0.5+iTime*5. + vec2(0,11))*sqrt(sqrt(v.y));\n}\n#else\nvec2 circleSample(uvec3 x){\n    if (x.x == 0u && x.y == 0u && x.z == 0u) x=uvec3(iTimeDelta*1000.); // Optional safety check... which doesn't work.\n    // Use safer version below pls\n    // not necessary if you make sure the input is never all zero otherwise the function can hang forever and WILL crash\n    vec2 v,z;\n    for(;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., length(z) > 1.;);\n    return z;\n}\n#endif\n//*/\n\n//* // Safer version with limited loop\n\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && dot(z,z) > 1.;);\n    return z;\n}\n\n//*/\n\n\n/*\n//Bad non uniform - Demo to show how easily you can evaluate the quality of hash functions\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy;\n    return vec2(sin(v.x*tau),cos(v.x*tau))*v.y;\n}\n\n//*/\n\n\n/*\n// Also good, uniform analytical but not as fast as rejection sampling\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy;\n    return vec2(sin(v.x*tau),cos(v.x*tau))*sqrt(v.y);\n    // (1./fisqrt(v.y)) is slower. I tried.\n}\n//*/\n\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = uvtc(U);\n    fragColor = texture(iChannel0, uv)*0.995;\n    for(int s = 2<<7;s-->0;)\n    {\n        vec2 p = circleSample(uvec3(iFrame+s, -iFrame+s, iFrame-s));\n        fragColor += smoothstep(2./r.y, 0., length(cuv-p))*(.4 + .6*exp(-iTime*.5));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Want to quickly copy a circle distribution function into your project? Just grab these two\n/*\n\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n} //hash by IQ https://www.shadertoy.com/view/XlXcW4\n\n\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && dot(z,z) > 1.;);\n    return z;\n}\n\n\n\n\n\n\n\n\nOld version which seems to be just a convoluted if statement with an uninitialized return 😭\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(v=hash(x+uint(v*1e9)).xy*2.-1.;\n        dot(v,v)<1.;)\n    return v;\n}\n\nlemme try rewriting that...\n\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy*2.-1.;\n    return dot(v,v)<1.?v:normalize(v);\n}\n\n\nThis is incredibly bad but at least not as bad as the other one, which just hides its\nhorrible issues by hiding them all in a single point at the centre...\n\nHistory: \n\n// Golf contest with beans_please\n\nOriginal:\nvec2 circleSample(uvec3 x){\n    vec2 v=vec2(1);\n    for (int i;dot(v,v)>1.;i++)\n        v = hash(x + uint(i)).xy*2.-1.;\n    return v;\n}\n\nbeans_please\nvec2 circleSample(uvec3 x){\n    uint i=1u;\n    while(i++>0u){\n        vec2 v=hash(x+i).xy*2.-1.;\n        if(dot(v,v)<1.)return v;\n    }\n}\n\n\nmine attempt 2\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(\n        v=hash(x+uint(v.x*1e9)).xy*2.-1.;\n        dot(v,v)<1.;\n    )\n    return v;\n}\n\n\nmine attempt 3: This one saves one character from\nthe 1e9 version. This limits the number of possible unique\niterations to just 9 instead of 1e9. This means there is a \nprobability of 0.0000009654 that a given input x will cause\nall 9 possible samples to fall outside the circle, which \nwould lead to the function running forever and crashing the\nprogram. That's why I chose not to use it.\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(\n        v=hash(x+uint(v.x*9.)).xy*2.-1.;\n        dot(v,v)<1.;\n    )\n    return v;\n}\n\n\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtjyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 103]], "test": "untested"}
{"id": "clscWX", "name": "nanotube", "author": "remaindeer", "description": "Calculations @ GeoGebra: https://www.geogebra.org/3d/auzcy3pz\nReference:\nSmalley, R. E. (2001). Carbon Nanotubes: Synthesis, Structure, Properties and Applications (M. S. Dresselhaus, G. Dresselhaus, & P. Avouris, Eds.; 2001st edition). Springer.\n", "tags": ["raymarch", "sdf", "cylinder", "nanotube", "wythoffconstruction", "fundamentaltriangle", "euclideanplanetiling", "cylindricalcoordinatesystem"], "likes": 9, "viewed": 168, "published": 3, "date": "1691588502", "time_retrieved": "2024-07-30T17:40:11.040999", "image_code": "float scene(vec3 p) {\n    // parameters\n    float n = 1.0 + floor(mod(float(4000 + iFrame) / 240.0, 10.0));\n    float m = 0.0 + floor(mod(float(5000 + iFrame) / 360.0, 10.0));\n    vec4 vecs = nanotube_vectors(n, m, SQRT3);\n    vec3 Ch = vec3(vecs.xy, 0), T = vec3(vecs.zw, 0);\n    float r = length(T) / TAU;\n    float s = max(length(Ch), length(T)) / 1.5; \n    \n    // scale part 1/2\n    p *= s;\n\n    // nanotube\n    vec4 tile = TILES[int(mod(float(iFrame) / 120.0, 14.0))];\n    float d = sdfNanotube(p, n, m, SQRT3, 0.05, tile);\n    \n    // ball\n    p.z += length(Ch) / 2.0 * sin(float(iFrame) / 45.0);\n    d = min(d, sdSphere(p, r / 2.0));\n      \n    // scale part 2/2\n    return d / s;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    float d;\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + depth * rd;\n        d = scene(p);\n        depth += d;\n        if (d < PRECISION || depth > MAX_DIST) {\n            break;\n        }\n    }\n\n    d = depth;\n\n    return d;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n        e.xyy * scene(p + e.xyy) +\n        e.yyx * scene(p + e.yyx) +\n        e.yxy * scene(p + e.yxy) +\n        e.xxx * scene(p + e.xxx)\n    );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (m == vec2(0.0)) m = vec2(0.5);\n\n    vec3 col = vec3(0);\n    vec3 lp = vec3(0);\n    vec3 ro = vec3(0, 0, 1.5);\n\n    float camRadius = 1.0;\n    ro.yz = ro.yz * camRadius * rotmat2(mix(-PI / 2.0, PI / 2.0, m.y));\n    ro.xz = ro.xz * rotmat2(mix(-PI, PI, m.x)) + vec2(lp.x, lp.z);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(p, -1));\n\n    float d = march(ro, rd);\n\n    if (d > MAX_DIST) {\n        col = COLOR_BACKGROUND;\n    } else {\n        vec3 p = ro + rd * d;\n        vec3 norm = normal(p);\n\n        vec3 lightPos = vec3(0, 1, 1);\n        vec3 lightDir = normalize(lightPos - p) * 0.65;\n\n        float diff = clamp(dot(norm, lightDir), 0.0, 1.0) * 0.5 + 0.5;\n\n        vec3 rnd = 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n        col = vec3(diff) + rnd;    \n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "// MIT License\n// \n// Copyright (c) 2023, Daniel Antonio Negrón (@remaindeer)\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n//// ray marching\n#define MAX_ITER 10000\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.00001\n#define EPSILON 0.00005\n#define COLOR_BACKGROUND vec3(0, 0, 0)\n#define COLOR_AMBIENT vec3(0.42, 0.20, 0.1);\n\n//// constants\n#define PI 3.1415926535897932384626433\n#define TAU (2.0 * PI)\n#define PHI (1.0 + sqrt(5.0)) / 2.0\n#define INF 999.0\n#define COS30 cos(radians(30.0))\n#define SQRT3 sqrt(3.0)\n\n//// fundamental triangle\n#define ft vec4(0, COS30, 0.5, COS30)\n\n//// generator points\n#define gq vec2(0.25, COS30)\n#define gc (ft.xy + COS30 * ft.zw) / (0.5 + COS30 + 1.0)\n#define gx vec2((3.0 - SQRT3) / 4.0, tan(radians(60.0)) * ((3.0 - SQRT3) / 4.0))\n\n//// Wythoff construction ===========================================================\nconst vec4[14] TILES = vec4[14] (\n    ////// Platonic and Archimedean tilings -----------------------------------------\n    vec4(ft.zw, 1.0, 0.0), // Hexagonal tiling (hextille)\n    vec4(ft.xy, 2.0, 0.0), // Trihexagonal tiling (hexadeltille)\n    vec4(gq   , 3.0, 0.0), // Truncated hexagonal tiling (truncated hextille)\n    vec4(ft.xx, 4.0, 0.0), // Triangular tiling (deltille) \n    vec4(gx   , 5.0, 0.0), // Rhombitrihexagonal tiling (rhombihexadeltille)\n    vec4(gc   , 7.0, 0.0), // Truncated trihexagonal tiling (truncated hexadeltille)\n    vec4(ft.xx, 8.0, 0.0), // Snub trihexagonal tiling (snub hextille)\n    ////// Dual Laves tilings -------------------------------------------------------\n    vec4(ft.xx, 4.0, 0.0), // Triangular tiling (deltille) \n    vec4(ft.xx, 0.0, 2.0), // Rhombille tiling (rhombille)\n    vec4(ft.xx, 0.0, 3.0), // Triakis triangular tiling (kisdeltille)\n    vec4(ft.zw, 1.0, 0.0), // Hexagonal tiling (hextille)\n    vec4(ft.xx, 0.0, 5.0), // Deltoidal trihexagonal tiling (tetrille)\n    vec4(ft.xx, 0.0, 7.0), // Kisrhombille tiling (kisrhombille)\n    vec4(ft.xx, 9.0, 0.0)  // Floret pentagonal tiling (6-fold pentille)\n); // ===============================================================================\n\n//// number theory\n\nint gcd(float x, float y) {\n    int a = int(x);\n    for (int b = int(y), t; b != 0; )\n    {\n     \tt = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\n//// rotations\n\nmat2 rotmat2(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotmat3(vec3 angle) {\n    float sintht = sin(angle.x), sinpsi = sin(angle.y), sinphi = sin(angle.z);\n    float costht = cos(angle.x), cospsi = cos(angle.y), cosphi = cos(angle.z);\n    return mat3(\n        costht * cospsi, sintht * cospsi, -sinpsi, \n        costht * sinpsi * sinphi - sintht * cosphi, sintht * sinpsi * sinphi + costht * cosphi, cospsi * sinphi,\n        costht * sinpsi * cosphi + sintht * sinphi, sintht * sinpsi * cosphi - costht * sinphi, cospsi * cosphi\n    );\n}\n\n//// intersection\n\nvec2 intersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    // http://paulbourke.net/geometry/pointlineplane/\n    float d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;\n    // float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;\n    return p1 + ua * (p2 - p1);\n}\n\n//// signed distance functions\n//// ------------------------------------------------\n//// https://iquilezles.org/articles/distfunctions/\n//// https://iquilezles.org/articles/distfunctions2d/\n//// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\nfloat opIntersection( float d1, float d2 ) { \n    return max(d1, d2); \n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2); \n}\n\nfloat opOnion(in float sdf, in float thickness) {\n    return abs(sdf) - thickness;\n}\n\nvec3 opRep(in vec3 p, in vec3 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n//// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//// https://iquilezles.org/articles/distfunctions/\n//// https://iquilezles.org/articles/distfunctions2d/\n//// ------------------------------------------------\n\nfloat sdTube(vec3 p, float h, float r) {\n    float d = length(p.xy) - r;\n    d = opOnion(d, 0.05);\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n//// Wythoff Construction\n\nvec2 snub632() {\n    // fermat point\n    vec2 pf = intersection(vec2(-0.75, COS30 / 2.0), ft.zw, vec2(1, 0), ft.xy);\n    // reflect over side (y-axis)\n    vec2 q1 = vec2(-1.0 * pf.x, pf.y);\n    // vec2 q2 = vec2(pf.x, pf.y + 2.0 * (COS30 - pf.y));\n    // project to hypotenuse then double to obtain reflection\n    vec2 q3 = dot(pf, ft.zw) / dot(ft.zw, ft.zw) * ft.zw;\n    q3 = pf + 2.0 * (q3 - pf);\n    // snub point is at half the hypotenuse of the new right triangle (Thales's theorem)\n    return q1 + ((q3 - q1) / 2.0);\n}\n\nfloat sdSchwartz632Snub(vec3 p, float t) {\n    // p the uv\n    // t the thickness\n    // take advantage of symmetry\n    float a = atan(p.y, p.x);\n    float M = floor(mod(degrees(a) - 30.0, 360.0) / 60.0) * 60.0;\n    p.xy = rotmat2(radians(M)) * p.xy;\n    // snub point\n    vec3 g = vec3(snub632(), 0);\n    // rotate\n    vec3 G = vec3(rotmat2(radians(180.0)) * (g.xy - ft.xy) + ft.xy, 0);\n    // distance\n    float d = sdCapsule(p, g, G, t);\n    // fix by https://www.shadertoy.com/user/mla\n    d = opUnion(d, sdCapsule(vec3(rotmat2(radians(-60.0)) * p.xy, p.z), g, G, t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(-60.0)) * (G - g).xy + g.xy, 0), t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(+60.0)) * (G - g).xy + g.xy, 0), t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(+120.0)) * (G - g).xy + g.xy, 0), t));\n    d = opUnion(d, sdCapsule(p, g, vec3(rotmat2(radians(+180.0)) * (G - g).xy + g.xy, 0), t));\n    return d;\n}\n\nfloat sdSchwartz632DualSnub(vec3 p, float t) {\n    // p the uv\n    // t the thickness\n    // snub point\n    vec3 g = vec3(snub632(), 0);\n    // take advantage of symmetry\n    float a = atan(p.y, p.x) - (atan(g.y, g.x) - radians(60.0));\n    float M = floor(mod(degrees(a), 360.0) / 60.0) * 60.0;\n    p.xy = rotmat2(radians(M)) * p.xy;\n    float R3 = SQRT3 / 2.0 * length(g);\n    float r3 = SQRT3 / 6.0 * length(g); \n    vec2 n0 = normalize(rotmat2(radians(+30.0)) * g.xy);\n    vec3 n1 = vec3((R3 + r3) * n0, 0);\n    vec3 n2 = vec3(n1.xy + rotmat2(radians(-60.0)) * (2.0 * r3 * n0), 0);\n    vec3 n3 = vec3(n1.xy + rotmat2(radians(+60.0)) * (2.0 * r3 * n0), 0);\n    // distance\n    float d = sdCapsule(p, vec3(ft.xx, 0), n1, t);\n    d = opUnion(d, sdCapsule(p, n1, n2, t));\n    d = opUnion(d, sdCapsule(p, n1, n3, t));\n    d = opUnion(d, sdCapsule(p, n2, n1 + n2 + -n3, t));\n    d = opUnion(d, sdCapsule(p, n3, n1 + n3 + -n2, t));\n    return d;\n}\n\nfloat sdSchwartz632(vec3 p, vec2 g, float m, float w, float t, bool o) {\n    // snub case\n    if (m == 8.0) {\n        return sdSchwartz632Snub(p, t);\n    }\n    // dual snub case\n    else if (m == 9.0) {\n        return sdSchwartz632DualSnub(p, t);\n    }\n    p = abs(p);\n    if (p.y < 2.0 * COS30 * p.x) {\n        p.xy = rotmat2(radians(-60.0)) * p.xy;\n        p = abs(p);\n    }\n    // distance\n    float d = o ? sdSphere(p, t) : INF;\n    vec3 g3 = vec3(g, 0);\n    d = bool(mod(m, 2.0)) ? opUnion(d, sdCapsule(p, g3, vec3(0, g3.y, 0), t)) : d;\n    vec3 v = vec3(ft.zw, 0);\n    d = bool(mod(floor(m / 2.0), 2.0)) ? opUnion(d, sdCapsule(p, g3, dot(g3, v) / dot(v, v) * v, t)) : d;\n    d = bool(mod(floor(m / 4.0), 2.0)) ? opUnion(d, sdCapsule(p, g3, vec3(g3.x, ft.y, 0), t)) : d;\n    d = bool(mod(w, 2.0)) ? opUnion(d, sdCapsule(p, vec3(ft.xx, 0), vec3(ft.xy, 0), t)) : d;\n    d = bool(mod(floor(w / 2.0), 2.0)) ? opUnion(d, sdCapsule(p, vec3(ft.xx, 0), vec3(ft.zw, 0), t)) : d;\n    d = bool(mod(floor(w / 4.0), 2.0)) ? opUnion(d, sdCapsule(p, vec3(ft.xy, 0), vec3(ft.zw, 0), t)) : d;\n    return d;\n}\n\nfloat sdSchwartz632Plane(vec3 p, vec2 g, float m, float w, float t, bool o) {\n    vec3 v = vec3(3.0, 2.0 * COS30, 0.0);\n    vec3 p1 = opRep(p, v);\n    vec3 p2 = opRep(p + v / 2.0, v);\n    return opUnion(\n        sdSchwartz632(p1, g, m, w, t, o),\n        sdSchwartz632(p2, g, m, w, t, o)\n    );\n}\n\n//// nanotube\n\nvec4 nanotube_vectors(float n, float m, float cc) {\n    mat2 a = cc * mat2(SQRT3 / 2.0, 0.5, SQRT3 / 2.0, -0.5);\n    vec2 Ch = n * a[0] + m * a[1];\n    float dR = float(gcd(2.0 * n + m, 2.0 * m + n));\n    float t1 = (2.0 * m + n) / dR;\n    float t2 = -((2.0 * n + m) / dR);\n    vec2 T = t1 * a[0] + t2 * a[1];\n    return vec4(Ch, T);\n}\n\nfloat sdfNanotube(vec3 p, float n, float m, float cc, float t, vec4 tile) {\n    // p -> the uv\n    // n, m -> the nanotube lattice vector parameters\n    // cc -> the carbon-carbon bond length\n    // t -> the segment thickness\n    // tile -> the wythoff tile parameters\n    vec4 vecs = nanotube_vectors(n, m, cc);\n    // chiral vector (Ch)\n    vec3 C = vec3(vecs.xy, 0);\n    // lattice vector\n    vec3 T = vec3(vecs.zw, 0);\n    // radius\n    float r = length(T) / TAU;\n    // tube\n    float d = sdTube(p, length(C) / 2.0, r);\n    // cylinder -> unrolled cylinder on plane\n    p = vec3(p.z, (mod(atan(p.y, p.x) + TAU, TAU) / TAU) * length(T), 0.0);\n    // shift b/c lattice sheet starts @ (0, 0)\n    p.x += length(C) / 2.0;\n    // align lattice sheet w/ x-axis\n    float dir = sign(determinant(mat2(C.x, 1, C.y, 0)));\n    float alpha = (dir == 0.0 ? 1.0 : dir) * acos(dot(C.xy, vec2(1, 0)) / length(C.xy));\n    p = rotmat3(vec3(-alpha, 0, 0)) * p - vec3(0.5, SQRT3 / 2.0, 0);\n    // intersect tube and lattice\n    d = max(d, sdSchwartz632Plane(p, tile.rg, tile.b, tile.w, t, true));\n    return d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clscWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 39, 690], [692, 692, 723, 723, 999], [1001, 1001, 1025, 1025, 1230], [1232, 1232, 1279, 1279, 1441], [1443, 1443, 1498, 1498, 2424]], "test": "untested"}
{"id": "DtBcRm", "name": "ray tunnel intersection", "author": "me_123", "description": "A analytic ray intersection with a extruded checker tunnel.", "tags": ["tunnel", "light", "disco", "analytic", "loopless"], "likes": 4, "viewed": 161, "published": 3, "date": "1691574149", "time_retrieved": "2024-07-30T17:40:11.817922", "image_code": "\n#define PI 3.14159525\n#define eps 0.0001\n\nfloat time = 0.0;\nconst int samples = 1; //AA samples\nconst float motionBlur = 0.0;\nvec3 tex(in vec3 p, in vec3 color0, in vec3 color1) {\n    ivec3 z = ivec3(floor(p));\n    return (z.x+z.y+z.z)%2==0?color0:color1;\n}\nstruct hit {\n    float dist;\n    vec3 normal;\n    int id;\n    vec2 extra;\n};\nhit tunnel(vec3 o, vec3 d, float count, float r1) {\n    float freq = count/PI;\n    float cellSize = 1./freq;\n    float a = 2.0*dot(d.yz, d.yz);\n    float ai = 1./a;\n    float b = 2.0*dot(o.yz, d.yz);\n    float c = dot(o.yz, o.yz)-1.0;\n    float k = (-b - sqrt(b*b-2.0*a*c))*ai;\n    float d1 = k;\n    o += d*k;\n    vec2 t = vec2(atan(o.y, o.z), o.x);\n    vec2 fc = vec2(floor(t*freq)/freq);\n    \n    if (int(freq*(fc.x+fc.y))%2 != 0) return hit(-k, vec3(0, o.yz), 0, fc);\n    \n    float plainX = -(o.x-fc.y-cellSize*0.5+cellSize*sign(d.x)*0.5)/d.x;\n    \n    float m = (count-1.0)*PI/(count*2.0);\n    vec2 dir = vec2(sin(fc.x-m), cos(fc.x-m));\n    float j = 0.5*length(vec2(sin(PI/count)-sin(2.0*PI/count), cos(PI/count)-cos(2.0*PI/count)));\n    float dp = dot(d.yz, dir);\n    float plainY = -(dot(o.yz, dir)+j*sign(dp))/dp;\n    float k1 = max(plainY, plainX)+k;\n    o -= d*k;\n    vec3 kp = o+d*k1;\n    if (length(kp.yz) < 1.0+r1) return hit(-k1, k1==(plainX+k)?vec3(sign(d.x), 0, 0):vec3(0, dir*sign(-dp)), 2, fc);\n    c += 1.0;\n    c -= (r1+1.0)*(r1+1.0);\n    float dd = (-b - sqrt(b*b-2.0*a*c))*ai;\n    k1 = max(k1, dd);\n    return hit(-k1, vec3(0, (o.yz+d.yz*dd)/(1.+r1)), 1, fc);//hit(-k1, vec3(k1==dd?vec3(0, (o.yz+d.yz*dd)/(1.0+r1)):(k1==(plainX+k)?vec3(sign(d.x), 0, 0):vec3(0, dir*sign(-dp)))), k1==dd?1:2);//sin(50.*(o+d*k1));\n}\nvec3 getColor(in vec3 o, in vec3 d) {\n    float k = 0.09;//0.5*(sin(iTime)+1.01);\n    const float mm = 10.0;\n    hit t = tunnel(o, d, mm, k);\n    float m = 1.0+k;\n    vec3 r = hash(uvec3(t.extra.xyx*100.+10000.));\n    vec3 p = o-d*t.dist;\n    float len = length(p.yz);\n    float l = 0.3/((m-len)/k+eps)-0.3;\n    return mix(mix(vec3(mix(r, r*0.8+0.2, l))*l, vec3(0.0, 0.1, 0.5), 1.-exp(-t.dist*0.1)), t.normal, 0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 mr = 1./iResolution.xy;\n    vec2 mouse;\n    mouse = vec2(-PI*0.5+cos(iTime*0.1), sin(iTime*0.5)*0.1);\n    if (iMouse.z > 0.0) mouse = (iMouse.xy*mr - 0.5 - vec2(1.75, 1.0))*vec2(PI*2.0, -PI);\n    vec3 at = vec3(\n        sin(mouse.x)*cos(mouse.y),\n        cos(mouse.x)*cos(mouse.y),\n        sin(mouse.y)\n    );\n    time = iTime;\n    vec2 uv = ((fragCoord)-iResolution.xy*0.5)*max(mr.x, mr.y);\n    vec3 ro = vec3(time, sin(time)*0.5, cos(time*0.5)*0.9);\n\n    vec3 xPlain = vec3(normalize(vec2(at.y, -at.x)), 0);\n    vec3 yPlain = cross(xPlain, at);\n    vec3 rd = vec3(at + xPlain*uv.x + yPlain*uv.y);\n    fragColor = vec4(clamp(getColor(ro, rd), 0.0, 1.0), 1.0);\n}", "image_inputs": [], "common_code": "vec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 180, 180, 258], [336, 336, 387, 387, 1672], [1673, 1673, 1710, 1710, 2090], [2091, 2091, 2148, 2148, 2820]], "test": "untested"}
{"id": "Dd2BR3", "name": "cos(1/sin(z)) J/M set", "author": "Elyades", "description": "Quick draft of the sets. Trying to get more precision", "tags": ["mandelbrotset"], "likes": 1, "viewed": 159, "published": 3, "date": "1691570431", "time_retrieved": "2024-07-30T17:40:12.581880", "image_code": "// Fork of \"J/M Set\" by Elyades. https://shadertoy.com/view/DdjfDh\n// 2023-07-21 15:02:44\n\nfloat PI = 3.1415926535897932;\nfloat PIONTWO = 1.57079632679;\n\nfloat add(float a, float b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return((a+b)/scalingFactor);\n}\n\nvec2 add2(float a, float b)\n{\n    float s = a + b;\n    float e = s - a;\n    float t = b - e;\n    float high = s;\n    float low = a - (s - t);\n    return vec2(high,low);\n}\n\nfloat lengthsquared(vec2 uv)\n{\n    return(uv.x*uv.x + uv.y*uv.y);\n}\n\nvec2 itimes(vec2 uv)\n{\n    return( vec2(-uv.y,uv.x) );\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = lengthsquared(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nfloat mult(float a, float b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return( a*b/(scalingFactor*scalingFactor));\n}\n\nvec2 add2d(vec2 a, vec2 b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return((a+b)/scalingFactor);\n}\n\nvec2 mult2d(vec2 a, vec2 b, float scalingFactor)\n{\n    a *= scalingFactor; b *= scalingFactor;\n    return( vec2(add(a.x*b.x,-a.y*b.y,scalingFactor) , add(a.x*b.y,a.y*b.x,scalingFactor))/(scalingFactor*scalingFactor));\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)));\n}\n\nvec2 log2d(vec2 uv)\n{\n    return(vec2(log(length(uv)),atan(uv.y,uv.x)));\n}\n\nvec2 rotate(vec2 uv,float angle)\n{\n    float co = cos(angle);float si = sin(angle);\n    uv *= mat2(co,-si,si,co);\n    return(uv);\n}\n\n\nvec2 cos2d(vec2 uv)\n{\n    return ( vec2 (exp2d(itimes(uv)) + exp2d(itimes(-uv)))*0.5);\n}\n\nvec2 sin2d(vec2 uv)\n{\n    vec2 result = (exp2d(itimes(uv)) - exp2d(itimes(-uv)))*0.5;\n    return vec2(-itimes(result));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float r = length(uv);\n    float angle = (n*(atan(uv.y,uv.x)));\n    return( pow(r,n)*vec2(cos(angle),sin(angle)) );\n}\n\n\nvec2 iteration(vec2 uv, vec2 c)\n{    \n    vec2 result = cos2d(oneoverz(sin2d(uv))) + c;\n    return(result);\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.33,0.67,1.0);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.3,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,0.0,1.0);\n    vec3 d = vec3(0.25,0.25,0.25);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 thirdDegreeProcessing(vec3 color)\n{\n    float a = 8.92587;\n    float b = -13.75;\n    float c = 5.82143;\n    return vec3(a*color*color*color - b*color*color + c*color );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Scale\n    float scale = 5.0;\n    uv += -0.5;\n    uv *= scale;\n    uv.x *= iResolution.x / iResolution.y;\n\n    \n\n    //Choosing the Zoom\n    float zoomAmount = pow(10.0,-iTime/5.0);\n    //zoomAmount = exp(-max(iTime-6.0,0.0));\n    //vec2 zoomPoint = vec2(0.354,0.0);\n    vec2 mousePoint = (iMouse.xy - iResolution.xy/2.0)*8.0/ iResolution.xy;\n    vec2 zoomPoint = vec2(-0.1,0.0);\n    \n    \n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    //uv += mousePoint;\n    //uv += vec2(-0.61021,-0.0001);\n    //uv += zoomPoint*zoomAmount;\n    \n    //Determining the interior of the set\n    \n    //Change this line to go from Mandelbrot to Julia\n    vec2 c = 0.5*(iMouse.xy/iResolution.xy - 0.5);\n    //vec2 c = uv;\n    \n    float tol = pow(10.0,-8.0);\n    float DistanceToPrevious = 1.0;\n    float currentModulus = lengthsquared(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 80;\n    \n    vec2 dummyuv = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = dummyuv;\n        dummyuv = iteration(dummyuv,c);\n        currentModulus = lengthsquared(dummyuv);\n        DistanceToPrevious = lengthsquared(dummyuv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > pow(10.0,10.0))\n        {\n            break;\n        } \n    }\n\n    //Coloring the interior of the set\n    \n    if (currentModulus < pow(10.0,10.0))\n    {\n        \n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //Coloring the exterior of the set\n    \n    else\n    {\n        \n        /*if(iterationAmount <= 2)\n        {\n            float intensity = 1.0 - float(iterationAmount/10);\n            fragColor = vec4(intensity*0.7,intensity*0.0,intensity*1.0,1.0);\n        }*/\n        \n        //else\n        {\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette2(indexFast);\n            \n            int periodMedium = 15;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette2(indexMedium);\n            \n            int periodSlow = 50;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette2(indexSlow);\n\n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n     }\n        \n        \n    }\n\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd2BR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 204, 204, 283], [285, 285, 314, 314, 455], [457, 457, 487, 487, 524], [526, 526, 548, 548, 582], [584, 584, 608, 608, 716], [718, 718, 769, 769, 863], [865, 865, 914, 914, 993], [995, 995, 1045, 1045, 1214], [1216, 1216, 1237, 1237, 1289], [1291, 1291, 1312, 1312, 1365], [1367, 1367, 1401, 1401, 1498], [1501, 1501, 1522, 1522, 1589], [1591, 1591, 1612, 1612, 1712], [1714, 1714, 1744, 1744, 1865], [1868, 1868, 1901, 1901, 1977], [1979, 1979, 2005, 2027, 2215], [2217, 2217, 2243, 2265, 2454], [2456, 2456, 2496, 2496, 2631], [2634, 2634, 2691, 2741, 5521]], "test": "untested"}
{"id": "dtlcWf", "name": "Mandelbrot Arbitrary Precision", "author": "wyattlukelowery", "description": "you can zoom in as far as you want but frames will suffer", "tags": ["fractal"], "likes": 1, "viewed": 170, "published": 3, "date": "1691562182", "time_retrieved": "2024-07-30T17:40:13.378749", "image_code": "#define hsl(h) .5-.5*k.www*clamp(k.xxx-abs(fract(h+k.xyz)*4.-2.),-1.,1.)\nconst vec4 k=vec4(3.,2.,1.,9.)/3.;\n\n#ifdef GL_ES\nprecision highp int;\n#endif\n\n/* integers per arbitrary-precision number */\nconst int vals = 5; //Chunks of ints\n\n//Size of int per 'int-chunk'\nconst int limit = 10000;\nconst float limitFlt = float(limit);\n\nint result[vals];\n\n#define zero(x, len) for(int i=0;i<len;i++){x[i]=0;}\n#define assign(x, y) for(int i=0;i<vals;i++){x[i]=y[i];}\n#define negate(x) for(int i = 0; i < vals; i++) { x[i] = -x[i]; }\n\nbool signp(int[vals] a) {\n\treturn (a[vals-1] >= 0);\n}\nint keepVal, carry;\nvoid roundOff(int x) {\n\tcarry = x / limit;\n\tkeepVal = x - carry * limit;\n}\nvoid add(int[vals] a, int[vals] b) {\n\tbool s1 = signp(a), s2 = signp(b);\n\n\tcarry = 0;\n\n\tfor(int i = 0; i < vals-1; i++) {\n\t\troundOff(a[i] + b[i] + carry);\n\n\t\tif(keepVal < 0) {\n\t\t\tkeepVal += limit;\n\t\t\tcarry--;\n\t\t}\n\n\t\tresult[i] = keepVal;\n\t}\n\troundOff(a[vals-1] + b[vals-1] + carry);\n\tresult[vals-1] = keepVal;\n\t\n\tif(s1 != s2 && !signp(result)) {\n\t\tnegate(result);\n\n\t\tcarry = 0;\n\n\t\tfor(int i = 0; i < vals; i++) {\n\t\t\troundOff(result[i] + carry);\n\n\t\t\tif(keepVal < 0) {\n\t\t\t\tkeepVal += limit;\n\t\t\t\tcarry--;\n\t\t\t}\n\n\t\t\tresult[i] = keepVal;\n\t\t}\n\n\t\tnegate(result);\n\t}\n}\nvoid mul(int[vals] a, int[vals] b) {\n\tbool toNegate = false;\n\n\tif(!signp(a)) {\n\t\tnegate(a);\n\t\ttoNegate = !toNegate;\n\t}\n\tif(!signp(b)) {\n\t\tnegate(b);\n\t\ttoNegate = !toNegate;\n\t}\n\n\tconst int lenProd = (vals-1)*2+1;\n\tint prod[lenProd];\n\tzero(prod, lenProd);\n\n\tfor(int i = 0; i < vals; i++) {\n\t\tfor(int j = 0; j < vals; j++) {\n\t\t\tprod[i+j] += a[i] * b[j];\n\t\t}\n\t}\n\n\tcarry = 0;\n\tconst int clip = lenProd - vals;\n\tfor(int i = 0; i < clip; i++) {\n\t\troundOff(prod[i] + carry);\n\t\tprod[i] = keepVal;\n\t}\n\n\tif(prod[clip-1] >= limit/2) {\n\t\tcarry++;\n\t}\n\n\tfor(int i = clip; i < lenProd; i++) {\n\t\troundOff(prod[i] + carry);\n\t\tprod[i] = keepVal;\n\t}\n\n\tfor(int i = 0; i < lenProd - clip; i++) {\n\t\tresult[i] = prod[i+clip];\n\t}\n\n\tif(toNegate) {\n\t\tnegate(result);\n\t}\n}\nvoid loadFloat(float f) {\n\tfor(int i = vals - 1; i >= 0; i--) {\n\t\tint fCurr = int(f);\n\t\tresult[i] = fCurr;\n\t\tf -= float(fCurr);\n\t\tf *= limitFlt;\n\t}\n}\n\nvoid mainImage( out vec4 O, in vec2 F ){\n    \n    //float zoom =exp(iTime*.6); & inverse\n    int zoom[vals];\n    loadFloat(exp(iTime*.6));\n    assign(zoom, result);\n    \n    int invZoom[vals]; //LIMITER ---- FIND WAY TO DO 'BIG' division\n    loadFloat(1./exp(iTime*.6));\n    assign(invZoom, result);\n    \n    //Center & unit coords\n    vec3 r = iResolution;\n    vec2 uv = (F*2.-r.xy)/r.y;\n    \n    //Seperate uv coords\n\tint uvX[vals];\n    loadFloat(uv.x);\n    assign(uvX, result);\n    \n    int uvY[vals];\n    loadFloat(uv.y);\n    assign(uvY, result);\n    \n    //Focal\n    int focalX[vals];\n    loadFloat(-.9002005);\n    focalX[vals-2]=-9003;\n    focalX[vals-3]=9800;\n    focalX[vals-4]=3889;\n    \n    int focalY[vals];\n    focalY[vals-2]=2325;\n    focalY[vals-3]=0030;\n    focalY[vals-4]=7299;\n    \n    \n    //ZOOM----------\n  \n    \n    //  uv/=zoom\n    mul(uvX, invZoom);\n    assign(uvX, result);\n    \n    mul(uvY, invZoom);\n    assign(uvY, result);\n    \n    // uv += focal\n    add(uvX, focalX);\n    assign(uvX, result);\n    \n    add(uvY, focalY);\n    assign(uvY, result);\n    \n    //--------\n    \n    \n    //vec2 z\n    int zX[vals];\n    int zY[vals];\n    \n    //Itermitent calcs\n    int z1[vals]; // x^2\n    int z2[vals]; //y^2\n    int z3[vals]; // x*y\n    int len[vals]; //length()\n    \n    //Iterate - num iterations here\n    for(float i,n=199.;i<n;i++){\n    \n        //CPU Saver & get rid of dots\n        if(abs(zX[vals-1])>2 || abs(zY[vals-1])>2)\n            return;\n    \n        //mult(z,z)\n        //vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n\n        mul(zX, zX); // x^2\n        assign(z1, result);\n\n        mul(zY, zY); //y^2\n        assign(z2, result);\n\n        mul(zX, zY); // x*y\n        assign(z3, result);\n\n        add(z3, z3); //zY = 2*x*y\n        assign(zY, result);\n\n        negate(z2); //zX = x^2-y^2\n        add(z1,z2);\n        assign(zX,result);\n\n        //z=mult(z,z)+uv\n        add(zX,uvX);\n        assign(zX,result);\n\n        add(zY,uvY);\n        assign(zY,result);\n        \n        //Length(z)\n        mul(zX,zX); //x^2\n        assign(len,result);\n        mul(zY,zY); //y^2\n        add(len,result);//x^2 + y^2\n        assign(len, result);\n\n        //SQRT - Linear Approximation around x=4 -----> y=x/4 + 1\n        loadFloat(0.25);\n        mul(len, result);\n        assign(len,result);//I forgot this line lmfao\n        len[vals-1] += 1;\n\n        //There is some issue with large numbers that repeat but it just adds spots so who cares\n        //Convergence Check\n        if(len[vals-1]<2)\n            O=(hsl(i/n)).xyzz;\n        \n\n    }\n       \n}\n\n\n    \n    \n    \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[598, 598, 620, 620, 672], [1977, 1977, 2002, 2002, 2126], [2128, 2128, 2168, 2216, 4694]], "test": "untested"}
{"id": "clSyRw", "name": "Infinite Hearts 2 (165 char)", "author": "JuliaPoo", "description": "Modified version of Inigo's awesome golf: https://www.shadertoy.com/view/DlBcz1\n", "tags": ["hearts"], "likes": 7, "viewed": 160, "published": 3, "date": "1691561561", "time_retrieved": "2024-07-30T17:40:14.152680", "image_code": "// Original: https://www.shadertoy.com/view/DlBcz1\n\nvoid mainImage(out vec4 p,vec2 f){\n    for(\n        p=vec4(f/iResolution.y,1,0)-.6; // First setup camera\n        f.x-->0.; // Then while not done\n        p*=.99+7e-3*(cos(p.y+acos(cos(2.*p))/3.)*sin(p)+3.+sin(3.*p.z+iTime)).x // march forward\n    );\n    p=(p+p.z)*.1; // Finally, do color\n}\n\n// FabriceNeyret2:\n// -2: (cos(p.y+acos(cos(2.*p))/3.)*sin(p)+2.5+sin(3.*(p.z+iTime))).x\n// Make slower\n// -2: (cos(p.y+acos(cos(2.*p))/3.)*sin(p)+2.5+sin(3.*p.z+iTime)).x\n// Slight refactor:\n// -1: (cos(p.y+acos(cos(2.*p))/3.)*sin(p)+3.+sin(3.*p.z+iTime)).x", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clSyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 86, 86, 343]], "test": "untested"}
{"id": "ct2czD", "name": "audioAI", "author": "lucianoferrarezi", "description": "ai audio", "tags": ["audio", "ai"], "likes": 0, "viewed": 162, "published": 3, "date": "1691535202", "time_retrieved": "2024-07-30T17:40:14.920627", "image_code": "// Retorna a intensidade dos agudos e médios\nfloat getIntensity() {\n    float intensity = 0.0;\n    for(int i = 80; i < 200; i++) { \n        intensity += texture(iChannel0, vec2(float(i)/200.0, 0.5)).r;\n    }\n    return intensity / 120.0;\n}\n\nvec3 generateStars(vec2 coord, float intensity) {\n    coord *= 1.0 + 0.5 * intensity; \n    float starValue = fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453);\n    float threshold = 0.998 - intensity * 0.002;\n    return vec3(step(threshold, starValue));\n}\n\nvec3 generateTexture(vec2 coord) {\n    float bassIntensity = 0.0;\n    for(int i = 0; i < 100; i++) {\n        bassIntensity += texture(iChannel0, vec2(float(i)/100.0, 0.5)).r;\n    }\n    bassIntensity /= 100.0;\n\n    float col = bassIntensity * (0.5 + 0.5*sin(iTime + coord.y*10.0) + 0.5*cos(iTime + coord.x*10.0));\n    return vec3(col);\n}\n\nvec3 getSphereNormal(vec2 coord) {\n    float lon = mix(-3.14159265, 3.14159265, coord.x);\n    float lat = mix(-1.57079633, 1.57079633, coord.y);\n    vec3 normal;\n    normal.x = cos(lat) * sin(lon);\n    normal.y = sin(lat);\n    normal.z = cos(lat) * cos(lon);\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    vec3 normal = getSphereNormal(p);\n\n    float angleX = (iMouse.x / iResolution.x) * 3.14159265;\n    float angleY = (iMouse.y / iResolution.y) * 3.14159265;\n\n    mat2 rotationX = mat2(\n        cos(angleX), -sin(angleX),\n        sin(angleX), cos(angleX)\n    );\n\n    mat2 rotationY = mat2(\n        cos(angleY), -sin(angleY),\n        sin(angleY), cos(angleY)\n    );\n\n    normal.xz = rotationX * normal.xz;\n    normal.yz = rotationY * normal.yz;\n\n    vec2 sphereCoord = vec2(\n        0.5 + atan(normal.z, normal.x) / (2.0 * 3.14159265),\n        0.5 - asin(normal.y) / 3.14159265\n    );\n\n    vec3 col = generateTexture(sphereCoord);\n\n    // Calcula a intensidade\n    float intensity = getIntensity();\n    \n    // Calcula as estrelas baseadas na intensidade\n    vec3 stars = generateStars(fragCoord, intensity);\n\n    col += stars;\n\n    col = clamp(col, 0.0, 1.0);\n\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2czD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 68, 68, 240], [242, 242, 291, 291, 506], [508, 508, 542, 542, 844], [846, 846, 880, 880, 1125], [1127, 1127, 1181, 1181, 2116]], "test": "untested"}
{"id": "DtjczD", "name": "Foggy Spiral", "author": "Max_H", "description": "Test", "tags": ["test"], "likes": 3, "viewed": 108, "published": 3, "date": "1691534947", "time_retrieved": "2024-07-30T17:40:15.682589", "image_code": "//https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float FOV = 60.0;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float halfFOV = FOV * 0.5;\n    \n    float minPosition = tan(radians(-halfFOV));\n    float maxPosition = tan(radians(halfFOV));\n    \n    float percentage = iResolution.y / iResolution.x;\n    float difference = 1.0 - percentage;\n    \n    float x = mix(minPosition, maxPosition, uv.x);\n    float y = mix(minPosition, maxPosition, (uv.y * percentage) + (difference * 0.5));\n    \n    vec3 rayOrigin = vec3(0, 0, -1);\n    vec3 rayDirection = normalize(vec3(x, y, 1));\n    \n    int sphereCount = 32;\n    float space = 1.61803398875;\n    float minDistance = -1.0;\n    vec3 color = vec3(0);\n    for(int i = 0; i < sphereCount; i++)\n    {\n        float time = iTime + float(i) * space;\n        vec4 sphere = vec4(sin(time * 1.75), cos(time * 1.75), 5.0 + tan(time), 0.075);\n        float sphereDistance = sphIntersect(rayOrigin, rayDirection, sphere);\n        \n        if(sphereDistance >= 0.0 && (minDistance < 0.0 || sphereDistance < minDistance))\n        {\n           color = sphere.xyz * exp(-sphereDistance * 0.4);\n           minDistance = sphereDistance;\n        }\n    }\n    \n    if(minDistance < 0.0) color.rgb = vec3(0);\n    \n    fragColor.rgb = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtjczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 101, 101, 293], [295, 295, 352, 352, 1585]], "test": "untested"}
{"id": "cl2yzD", "name": "AIstars2", "author": "lucianoferrarezi", "description": "audio reactive", "tags": ["audioreactive"], "likes": 0, "viewed": 143, "published": 3, "date": "1691533985", "time_retrieved": "2024-07-30T17:40:16.455523", "image_code": "// Retorna a intensidade dos agudos\nfloat getTrebleIntensity() {\n    float trebleIntensity = 0.0;\n    for(int i = 100; i < 200; i++) {\n        trebleIntensity += texture(iChannel0, vec2(float(i)/200.0, 0.5)).r;\n    }\n    return trebleIntensity / 100.0;\n}\n\nvec3 generateStars(vec2 coord, float trebleIntensity) {\n    float starValue = fract(sin(dot(coord, vec2(12.9898, 78.233))) * 43758.5453);\n    return vec3(step(0.995 - trebleIntensity, starValue));\n}\n\nvec3 generateTexture(vec2 coord) {\n    float bassIntensity = 0.0;\n    for(int i = 0; i < 100; i++) {\n        bassIntensity += texture(iChannel0, vec2(float(i)/100.0, 0.5)).r;\n    }\n    bassIntensity /= 100.0;\n\n    float col = bassIntensity * (0.5 + 0.5*sin(iTime + coord.y*10.0) + 0.5*cos(iTime + coord.x*10.0));\n    return vec3(col);\n}\n\nvec3 getSphereNormal(vec2 coord) {\n    float lon = mix(-3.14159265, 3.14159265, coord.x);\n    float lat = mix(-1.57079633, 1.57079633, coord.y);\n    vec3 normal;\n    normal.x = cos(lat) * sin(lon);\n    normal.y = sin(lat);\n    normal.z = cos(lat) * cos(lon);\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    vec3 normal = getSphereNormal(p);\n\n    float angleX = (iMouse.x / iResolution.x) * 3.14159265;\n    float angleY = (iMouse.y / iResolution.y) * 3.14159265;\n\n    mat2 rotationX = mat2(\n        cos(angleX), -sin(angleX),\n        sin(angleX), cos(angleX)\n    );\n\n    mat2 rotationY = mat2(\n        cos(angleY), -sin(angleY),\n        sin(angleY), cos(angleY)\n    );\n\n    normal.xz = rotationX * normal.xz;\n    normal.yz = rotationY * normal.yz;\n\n    vec2 sphereCoord = vec2(\n        0.5 + atan(normal.z, normal.x) / (2.0 * 3.14159265),\n        0.5 - asin(normal.y) / 3.14159265\n    );\n\n    vec3 col = generateTexture(sphereCoord);\n\n    // Calcula a intensidade dos agudos\n    float trebleIntensity = getTrebleIntensity();\n    \n    // Calcula as estrelas baseadas nos agudos\n    vec3 stars = generateStars(fragCoord, trebleIntensity);\n\n    col += stars;\n\n    // Garante que a cor está dentro do intervalo [0,1]\n    col = clamp(col, 0.0, 1.0);\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2yzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 64, 64, 254], [256, 256, 311, 311, 454], [456, 456, 490, 490, 792], [794, 794, 828, 828, 1073], [1075, 1075, 1129, 1129, 2146]], "test": "untested"}
{"id": "ct2cRD", "name": "bokeh͏", "author": "01000001", "description": "Learning how the math behind bokeh works. \n\nXor's shader https://www.shadertoy.com/view/fldfWH helped a ton. Thanks!", "tags": ["blur", "bokeh"], "likes": 7, "viewed": 170, "published": 3, "date": "1691531489", "time_retrieved": "2024-07-30T17:40:17.217485", "image_code": "const float power = 3.;\nconst float phi = 1.61803398875;\nconst float pi = 3.1415926;\nconst float tau = pi*2.;\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\n\n/*\nvec2 circleSample(uvec3 x){\n    vec2 v = hash(x).xy;\n    return sin(v.x * tau + vec2(0,11))*sqrt(mod(v.x*1e2,1.));\n}\n/*/\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && length(z) > 1.;);\n    return z;\n}\n\n//*/\n\n\n//*\nvec2 bokehSample(int i, int s)\n{\n    float t = float(i)*2.*pi/(phi*phi);\n    float r = sqrt(float(i)/float(s));    \n    return sin(t + vec2(0,11)) * r;\n}/*/\n\nvec2 bokehSample(int i, int s){\n    float v = float(i)*pi / float(s);\n    return sin(v*tau + vec2(0,11))*sqrt(fract(v*pi*10.));\n    // (1./fisqrt(v.y)) is slower. I tried.\n}\n\n\n//*/\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;    \n    O=O-O;\n    \n    float b = .1*pow(abs(uv.y - .5 - sin(iTime)*.3),2.);\n    int s = int(ceil(float(2<<8)*sqrt(b))),i=s;\n    \n    for(;i-->0;){\n        //*\n        vec2 p = circleSample(uvec3(iFrame+i, int(U.x)+i, int(U.y)*i));/*/\n        vec2 p = bokehSample(i,s);//*/\n        p.y *= r.x/r.y;\n        vec4 c = texture(iChannel0, uv+p*b);\n        c *= c*2.;\n\t\tO += pow(c,power+O-O);\n\t}\n\tO /= float(s);\n    O = pow(O, 1./power+O-O);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, in vec2 U )\n{\n    int s = int(mod(iTime*0.4, 4.));\n    vec2 uv = U/iResolution.xy;\n    \n    float d = 0.5;\n    uv.x = uv.x * (mix(1., uv.y, d)) + (1.-uv.y)*d*.5;\n    \n    O = \n     s < 1?texture(iChannel0,uv.yx)\n    :s < 2?texture(iChannel1,uv.yx)\n    :s < 3?texture(iChannel2,uv)\n    :      texture(iChannel3,uv);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2cRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 160, 160, 293], [346, 470, 497, 497, 609], [618, 622, 654, 654, 775], [962, 962, 1003, 1003, 1489]], "test": "untested"}
{"id": "cl2cRD", "name": "Fixed FPS Experiment", "author": "beans_please", "description": "Adjusting the amount of computation in order to keep the FPS constant.\nMight take up to 20 seconds to reach the target FPS.\nDoesn't work well on my phone, probably because of 16 bit precision.", "tags": ["fps", "constant"], "likes": 1, "viewed": 67, "published": 3, "date": "1691530674", "time_retrieved": "2024-07-30T17:40:17.988424", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(0), 0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Target FPS and delta time\n    const float targetFPS = 42.;\n    const float targetDT = 1. / targetFPS;\n    \n    // prevN = Number of computations in the previous frame\n    float prevN = texelFetch(iChannel0, ivec2(0), 0).x;\n    if (prevN < 2.) prevN = 2.;\n    \n    // Calculate new N\n    float n;\n    if (iTimeDelta < targetDT)\n    {\n        float targetN = prevN * 1.01;\n        n = max(targetN, prevN + .5);\n    }\n    else\n    {\n        float targetN = prevN * 0.99;\n        n = min(targetN, prevN - .5);\n    }\n    \n    // Heavy ish computations\n    float a = 2. + fragCoord.x;\n    int n_int = max(int(floor(n)), 1);\n    for (int i = 0; i < n_int; i++)\n    {\n        a *= (a + 0.5);\n        a /= 0.01 + 0.02*a;\n        a /= (a + 9.);\n        a = sqrt(a);\n        //a /= pow(a, 2.5 * log2(a));\n    }\n    \n    // Output\n    fragColor = vec4(n, 0.0, a, 1.0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2cRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 109]], "test": "untested"}
{"id": "dtByRD", "name": "Universal Spin", "author": "arcadiancomp", "description": "Zooming in and out of a rotating universe", "tags": ["rotationspeeduniverse"], "likes": 1, "viewed": 112, "published": 3, "date": "1691515535", "time_retrieved": "2024-07-30T17:40:18.759363", "image_code": "// Define rotation, zoom, brightness\n\nconst float cpuSpeed = 0.5;  // Speed of the spinning Universe\nconst float zoomDuration = 20.0;  // Zoom duration in seconds\nconst float maxZoom = 0.2;  // Maximum zoom factor\nconst float maxBrightness = 2.5;  // Maximum brightness multiplier\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Calculate the rotation angle based on time\n    float angle = mod(iTime * cpuSpeed, 2.0 * 3.14159);\n\n    // Calculate the zoom factor based on time\n    float zoomFactor = 1.0 + 0.5 * (1.0 - cos(iTime * 3.14159 / zoomDuration));\n    zoomFactor = mix(1.0, maxZoom, zoomFactor);\n\n    // Apply the zoom and rotation to the coordinates\n    vec2 center = vec2(0.5, 0.5);\n    vec2 scaledUV = (uv - center) / zoomFactor + center;\n    vec2 rotatedUV = vec2(\n        cos(angle) * (scaledUV.x - center.x) - sin(angle) * (scaledUV.y - center.y) + center.x,\n        sin(angle) * (scaledUV.x - center.x) + cos(angle) * (scaledUV.y - center.y) + center.y\n    );\n\n    // Sample the CPU icon texture using the rotated coordinates\n    vec3 col = texture(iChannel0, rotatedUV).rgb;\n\n    // Calculate the brightness multiplier based on rotation angle\n    float brightnessMultiplier = mix(1.0, maxBrightness, abs(sin(angle)));\n\n    // Apply the brightness multiplier to the color\n    col *= brightnessMultiplier;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtByRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 337, 387, 1487]], "test": "untested"}
{"id": "dlSyzW", "name": "Tiled Circles", "author": "LeifMessinger", "description": "Tiling demo and circle drawing demo.\n\nUse the mouse to change the tile size.", "tags": ["circles", "tiling"], "likes": 1, "viewed": 148, "published": 3, "date": "1691512777", "time_retrieved": "2024-07-30T17:40:19.525315", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n//Boolean circles don't have AA. Switch to 1 to make circles boolean.\n#define CIRCLE_BOOL 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    bool mouseInactive = iMouse.xy == vec2(0.0, 0.0);\n    //Tile size in pixels\n    vec2 tileSize = mouseInactive? (iResolution.xy/8.0): iMouse.xy;\n    \n    //This gets the coords, which is the fragCoord from [0.0, 0.0] to [1.0, 1.0] inside the tile\n    ivec2 tileIndex;\n    vec2 coords = tile(fragCoord, tileSize, tileIndex);\n    \n    //Checking if it's an even or an odd tile\n    bool white = ((tileIndex.x ^ tileIndex.y) % 2) == 0;\n    \n    const float pulseSpeed = .5;\n    float diameter = abs(sin(M_PI * iTime * pulseSpeed));\n\n    #if CIRCLE_BOOL\n        bool inCircle = isInCircle(coords, vec2(1.0, 1.0), diameter);\n\n        float brightness = float(true ^^ inCircle ^^ white);\n\n        vec3 color = vec3(brightness);\n        // Output to screen\n        fragColor = vec4(color,1.0);\n    #else\n        const float AA_STRENGTH = 2.0;\n        float featherSize = diameter - ((1.0 / min(tileSize.x, tileSize.y)) * AA_STRENGTH);\n        float inCircle = circle(coords, vec2(1.0, 1.0), diameter, featherSize);\n\n        float brightness = (white)? inCircle : (1.0 - inCircle);\n\n        vec3 color = vec3(brightness);\n        // Output to screen\n        fragColor = vec4(color,1.0);\n    #endif\n}", "image_inputs": [], "common_code": "//Tiles coordinates\n//loopDistance is the xy size of a tile\n//the output is the coordinate from [0,1] with respect to its own tile\nvec2 tile(in vec2 coord, in vec2 loopDistance, out ivec2 tileIndex){\n    vec2 xy = coord/loopDistance; //This is the xy of one tile\n    vec2 coords = fract(xy); //Same as mod(x,1.0);\n    tileIndex = ivec2(trunc(xy));\n    return coords;\n}\n\nvec2 tile(in vec2 coord, in vec2 loopDistance){\n    ivec2 tileIndex; //We throw this away\n    return tile(coord, loopDistance, tileIndex);\n}\n\n\n//Centers a coordinate\n//Imagine a square that goes from [0, 0] to [x, y]. If we center it, we make it [-x/2, -y/2] to [x/2, y/2]\nvec2 center(in vec2 coord, in vec2 boundingBoxSize){\n    return coord - (.5 * boundingBoxSize);\n}\n\n//Maybe better looking, because of curves, but probably not worth the performance hit. Probably keep off.\n#define CIRCLE_SMOOTHSTEP 0\n//This one lets you make feather greater than radius and it'll fall back to the boolean circle converted to a float.\n#define CIRCLE_SAFETY 1\n//Makes the circles gray when the safety is triggered\n#define CIRCLE_SAFETY_DEBUG 0\n\n//Returns true if coord is in the circle\n//If the coord is in the circle, then the magnitude of the coordinate is less than the radius\n//The circle's origin is at 0,0\nbool isInCircle(in vec2 coord, in float radius){\n    return length(coord) < radius;\n}\n\n//The diameter is the size from 0.0 to 1.0 (or larger) of the circle within the bounding box\nbool isInCircle(in vec2 coord, in vec2 boundingBox, in float diameter){\n    //Center the coorinates\n    coord = center(coord, boundingBox);\n    \n    //Gets coordinates from [0, 0] to [1, 1] inside the box\n    vec2 xy = coord / boundingBox;\n    \n    return isInCircle(coord, diameter/2.0);\n}\n\nbool isInCircle(in vec2 coord, in vec2 boundingBox){\n    return isInCircle(coord, boundingBox, 1.0);\n}\n\n//Returns 1.0 if coord is in the circle\n//If the coord is in the circle, then the magnitude of the coordinate is less than the radius\n//The circle's origin is at 0,0\nfloat circle(in vec2 coord, in float radius){\n    return float(isInCircle(coord, radius));\n}\n\n//Feather is what point of the circle is good enough to be 1.0. Feather should be < radius\nfloat circle(in vec2 coord, in float radius, in float feather){\n    #if CIRCLE_SAFETY\n        #if CIRCLE_SAFETY_DEBUG\n            if(feather >= radius) return  .5 * circle(coord, radius);\n        #else\n            if(feather >= radius) return circle(coord, radius);\n        #endif\n    #endif\n    \n    #if CIRCLE_SMOOTHSTEP\n        //Typically, smoothstep is (min, max, x), which gives you 0.0 to 1.0 as x grows\n        //Turns out, you can flip it to (max, min, x) and it'll give you 1.0 to 0.0\n        return smoothstep(radius, feather, length(coord));\n    #else\n        return 1.0 - ((length(coord)-feather) / (radius-feather));\n    #endif\n}\n\n\n//The diameter is the size from 0.0 to 1.0 (or larger) of the circle within the bounding box\nfloat circle(in vec2 coord, in vec2 boundingBox, in float diameter, in float feather){\n    //Center the coorinates\n    coord = center(coord, boundingBox);\n    \n    //Gets coordinates from [0, 0] to [1, 1] inside the box\n    vec2 xy = coord / boundingBox;\n    \n    return circle(coord, diameter/2.0, feather/2.0);\n}\n\n//If you don't specify a feather, just call the boolean function instead. Can't really do anything if you don't specify feather.\nfloat circle(in vec2 coord, in vec2 boundingBox, in float diameter){\n    return float(isInCircle(coord, boundingBox, diameter));\n}\n\nfloat circle(in vec2 coord, in vec2 boundingBox){\n    return circle(coord, boundingBox, 1.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlSyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DtBcRD", "name": "Black & White smoke", "author": "motus_art", "description": "Modified water turbulence effect shader originally by joltz0r.\nAlso see David Hoskins's implementation https://www.shadertoy.com/view/MdlXz8", "tags": ["smoke"], "likes": 9, "viewed": 359, "published": 3, "date": "1691508128", "time_retrieved": "2024-07-30T17:40:20.295257", "image_code": "// Modified water turbulence effect shader originally by joltz0r\n// Also see David Hoskins's implementation https://www.shadertoy.com/view/MdlXz8\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * .125 + 23.0;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = mod(uv*TAU, TAU) - 213.0;\n    vec2 i = vec2(p);\n    float c = 1.0;\n    float inten = .005;\n\n    for (int n = 0; n < MAX_ITER; n++) {\n        float t = time * (1.0 - (3.5 / float(n + 1)));\n        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        c += 1.0 / length(vec2(p.x / (sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));\n    }\n    c /= float(MAX_ITER);\n    c = 1.17 - pow(c, 1.4);\n    vec3 colour = vec3(pow(abs(c), 10.0));\n    colour *= 0.75;\n    colour = clamp(colour + vec3(0.095), 0.0, 1.0);\n\n    fragColor = vec4(colour, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtBcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 249, 249, 915]], "test": "untested"}
{"id": "DlSyRD", "name": "Fast Inverse Square Root", "author": "01000001", "description": "cuz why not? Replicated from https://www.youtube.com/watch?v=p8u_k2LIZyo", "tags": ["math", "fast", "utility", "optimization", "sqrt", "tool"], "likes": 6, "viewed": 182, "published": 3, "date": "1691507230", "time_retrieved": "2024-07-30T17:40:21.068191", "image_code": "float fisqrt(float x)\n{\n    uint i;\n    float x2, y;\n    \n    x2 = x*.5;\n    y = x;\n    i = floatBitsToUint(x);       // evil floating point bit hack\n    i = 0x5f3759dfu - ( i >> 1);  // wut\n    y = uintBitsToFloat(i);\n    y = y*(1.5 - (x2 * y * y));   // 1st iteration\n//  y = y*(1.5 - (x2 * y * y));   // 2nd iteration, can be removed\n    \n    return y;\n}\n\n// https://youtu.be/p8u_k2LIZyo\n// Highly recommend watching this video explaining how it works in detail\n\nconst float pi = 3.14159;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * vec2(5, 2);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,pi*2./3.,pi*4./3.));\n    \n    float a = 1./fisqrt(uv.x);   \n    //Proper usage is to use this for normalizing vectors by multiplying\n    // for example, where vec3 a = something, instead of a = a / √(a.x * a.x + a.y * a.y + a.z * a.z)\n    // fast inverse square root lets you do a = a * fisqrt(a.x * a.x + a.y * a.y + a.z * a.z) allowing \n    // the entire operation to be completed without a single square root or division call. \n    // I tested this function in a real application and I found that it was exactly the same performance as normalize().\n    // It seems the compiler uses this trick internally!\n    float b = sqrt(uv.x);\n\n\n    float d = smoothstep(uv.y, uv.y + 8./iResolution.y, a*.7 +.3)*.5+.5;\n    d *= smoothstep(uv.y, uv.y + 8./iResolution.y, b*.7 +.3)*.5+.5;\n    \n    if (uv.y < .3) col = vec3(log((a-b)*200.+1.));\n    // Error between sqrt() and 1./fisqrt()\n    // Now... which one is closer to ground truth? I'll implement that later\n    // Interesting to note, sqrt() is always smaller, making abs(a-b) unnecessary.\n\n    // Output to screen\n    fragColor = vec4(col*d,1.0);\n}\n\n\n\n\n\n/* //Minified\n\nfloat fisqrt(float x)\n{\n    uint i;\n    float a = x,y;\n    a*=.5;\n    i=floatBitsToUint(x);\n    i=uint(0x5f3759df) - ( i >> 1);\n    y=uintBitsToFloat(i);\n    y=y*(1.5-(a*y*y));\n    return y;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlSyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 357], [492, 492, 549, 549, 1751]], "test": "untested"}
{"id": "DtSyRW", "name": "traffic: slow lane car illusion ", "author": "FabriceNeyret2", "description": "About the illusion that more people are passing us in the other lane during traffic jam.\nSPACE: switch referential\nmouse.x: % duration in jam \nmouse.y: % speed in jam", "tags": ["illusion", "inverse", "perception", "loopless", "smoothfloor", "file", "trafficjam"], "likes": 16, "viewed": 275, "published": 3, "date": "1691505590", "time_retrieved": "2024-07-30T17:40:21.832147", "image_code": "// drawing on https://shadertoy.com/view/DssfzS\n\nfloat d, h ; //  1.-d, h = width,height of spline part \n\n#define curve(x) ( f = clamp( ( fract(x) - d/2. ) / (1.-d), 0.,1.),  \\\n                   floor(x) + mix( fract(x), f*f*(3.-2.*f), h )  )\n\nfloat invcurve(float y) {\n                                    // --- inverse spline cf https://www.shadertoy.com/view/clXyWj ------\n   float a,b,c,k,l,A,R3=sqrt(3.),x; //                    with slope: https://www.shadertoy.com/view/DlByz1\n    y = fract(y);\n    if      ( y <    (1.-h)*d/2. ) x =     y/(1.-h);         // flat parts\n    else if ( y > 1.-(1.-h)*d/2. ) x = (y-h)/(1.-h);\n    else {                                                   // spline+slope part\n     // solve spline+kx: https://www.wolframalpha.com/input?i=solve%28y%3Dx*x*%283-2*x%29%2Bax%2C+x%29\n        y = ( y - (1.-h)/2.*d ) / (1.- (1.-h)*d );   \n        y /= h; \n        k = (1.-h) / h , \n        a = k+1.-2.*y, c = 2./3.*k+1., b = sqrt(c*c*c-a*a), A = atan(b,a)/3.,\n        x = sqrt(c)/2. * ( - cos(A) + R3*sin(A) )  + .5;\n        x = x*(1.-d) + d/2.;                                 // remaps for d\n    }\n    return x;\n}\n\n#define S(v) smoothstep( 1.5*s/R.y, 0., length(v) - 2.5*s/R.y )\n#define key(a)    ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 u ) // ============================================\n{\n    float n = 21.,                   // number of dots per cycle\n          s = .25;                   // figure scaling\n    bool  m = // length(iMouse.xy)>10., \n                 iMouse.z>0.,\n          v = key(32);\n    if (v) s = .5;\n    vec2  R = iResolution.xy,\n          U = s*( 2.*u - R ) / R.y, \n          M = iMouse.xy/R;\n    d = m ? M.x : .6,                // 1.-d = width of spline part \n    h = m ? 1.-M.y : .7,             // h = height of spline part \n    \n    O *= 0.;                    // --- direct slope-spline ( red dots as guide ) ------------\n    // base smooth floor (no slope ) : https://www.desmos.com/calculator/srnrjrphqu\n    float t = 2.*iTime, x,f,y,Y;\n    if (!v)  \n            O.g += S( (U-vec2(-.1,0))/3. ), // draw my car\n            U.y += curve(t/n);              // first person view\n    else    O.g += S( (U-vec2(-.1,curve(fract(t/n+.5)-.5)))/3. ); // draw my car\n    \n    if (abs(U.x)<.005) f = sin(62.*U.y), O += f / fwidth(f); // --- scenary around cars\n    if (abs(U.x)>.2) O   += texture(iChannel0,U);\n                else O.b += texture(iChannel1,U).x*1.3;\n\n    x = invcurve(U.y);  Y = floor(U.y);  // --- param x = inv-spline(y)         \n    x = round(x*n-t)/n +t/n,        // --- after inverse-map, draw geen dots from it\n    y = curve(x);    \n    O.g += S(U-vec2(-.1 ,y+Y));                             // drawgreen vertical dots\n // O.g += S(U-vec2(x+Y,y+Y));                              // debug: draw time curve\n\n    U.y -= .5;                           // red dots\n    x = invcurve(U.y);  Y = floor(U.y);           \n    x = round(x*n-t)/n +t/n,  \n    y = curve(x);\n    O.r += S(U-vec2(.1 ,y+Y));                              // draw red vertical dots\n}\n", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtSyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 270, 376, 1146], [1276, 1276, 1362, 1362, 3064]], "test": "untested"}
{"id": "DssfzS", "name": "inverse smoothfloor + slope", "author": "FabriceNeyret2", "description": "direct + inverse    smoothfloor + controlable flat parts and overall slope\nmouse.x: flat part length ( spline part = 1-d )\nmouse.y: spline height ( overall slope = 1-h )", "tags": ["inverse", "loopless", "smoothfloor"], "likes": 9, "viewed": 162, "published": 3, "date": "1691501209", "time_retrieved": "2024-07-30T17:40:22.604083", "image_code": "// basic smoothfloor:         floor(x) + spline(fract(x))   ( spline=smoothstep )\n// with tunable flat parts d: floor(x) + spline( ( fract(x) - d/2. ) / (1.-d) )\n// + tunable general slope h: floor(x) + mix( fract(x), spline( ( fract(x) - d/2. ) / (1.-d) ) )\n// Here we want to compute the inverse x=invcurve(y) ( compulsory for the green dots ).\n//   but just set h=1 and/or d=0 to get the simpler curves\n\n#define curve(x) ( f = clamp( ( fract(x) - d/2. ) / (1.-d), 0.,1.),  \\\n                   floor(x) + mix( fract(x), f*f*(3.-2.*f), h )  )\n\n#define S(v) smoothstep( 1.5*s/R.y, 0., length(v) - 2.5*s/R.y )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float n = 20.,  // number of dots per cycle\n          s = 1.5;  // figure scaling\n    vec2  R = iResolution.xy,\n          U = s*( 2.*u - R ) / R.y, \n          M = iMouse.xy/R;\n    bool  m = length(iMouse.xy)>10.; // iMouse.z>0.;\n    \n    O *= 0.;                    // --- direct slope-spline ( red dots as guide ) ------------\n    // base smooth floor (no slope ) : https://www.desmos.com/calculator/srnrjrphqu\n    float t = iTime, d = m ? M.x : .6, h = m ? M.y : .8,     //  1.-d, h = width,height of spline part \n          x = round(U.x*n-t)/n +t/n, \n          f, y = curve(x); \n\n    O.r += S(U-vec2(x,y));                                   // draw red dots   \n   \n                                    // --- inverse spline cf https://www.shadertoy.com/view/clXyWj ------\n   float a,b,c,k,l,A,Y,R3=sqrt(3.); //                    with slope: https://www.shadertoy.com/view/DlByz1\n    y = U.y, Y = floor(y), y = fract(y);\n    if      ( y <    (1.-h)*d/2. ) O.r, x =     y/(1.-h);    // flat parts\n    else if ( y > 1.-(1.-h)*d/2. ) O.r, x = (y-h)/(1.-h);\n    else {                                                   // spline+slope part\n#if 0                                                        // old version ( no slope )\n     // solve spline: https://www.wolframalpha.com/input?i=solve%28y%3Dx*x*%283-2*x%29%2C+x%29\n        a = 1. -2.*y, b = 2.*sqrt(y*(1.-y)), /*l = pow(a*a+b*b,1./6.),*/ A = atan(b,a)/3.,\n     // x = ( -(l+1./l)*cos(A) + 2.*R3*l*sin(A)  + 2. ) / 4.;          // inverse spline\n        x = ( -cos(A) + R3*sin(A)  + 1. ) / 2.;                        // inverse spline\n#else                                                        //  new version ( slope )\n     // solve spline+kx: https://www.wolframalpha.com/input?i=solve%28y%3Dx*x*%283-2*x%29%2Bax%2C+x%29\n        y = ( y - (1.-h)/2.*d ) / (1.- (1.-h)*d );   \n        y /= h; \n        k = (1.-h) / h , \n        a = k+1.-2.*y, c = 2./3.*k+1., b = sqrt(c*c*c-a*a), /*l = sqrt(c),*/ A = atan(b,a)/3.,\n        x = sqrt(c)/2. * ( - cos(A) + R3*sin(A) )  + .5;\n#endif        \n        x = x*(1.-d) + d/2.;                                 // remaps for d\n    }\n             \n    y = curve(x);                 // --- verification (should be thick vertical bar) : still not perfect for big d\n    O.g += S(U-vec2(-s*1.1 ,y+Y))*.5;\n                            \n    x = round(x*n-t)/n +t/n,      // --- after inverse-map, draw dots from it\n    y = curve(x);\n    \n    O.g += S(U-vec2(x+Y,y+Y));                               // to check, draw green dot over red dots → yellow if of\n    O.g += S(U-vec2(-s ,y+Y));                               // green vertical dots\n    O.b += S(U.y-y-Y)  * .5;                                 // horizontal blue lines   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DssfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[611, 611, 649, 649, 3374]], "test": "untested"}
{"id": "mt2yz1", "name": "Little Worm [319 Chars]", "author": "SnoopethDuckDuck", "description": "Golging welcome", "tags": ["worm", "onetweet", "chain", "golf"], "likes": 10, "viewed": 226, "published": 3, "date": "1691497734", "time_retrieved": "2024-07-30T17:40:23.373027", "image_code": "// https://www.desmos.com/calculator/sciymlhnlv\n\n// -2 thanks to Fabrice 🦣\n\n#define D d = min(d, length(u-\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 q = iResolution.xy,\n         u = (U-.5*q)/q.y + .4,\n         p = vec2(0, .2 - .2 * tanh(3.*cos(iTime)));\n            \n    for(float d = 9., l = .1, y, i;\n        i++<9.;\n        D (q = p))), \n        y = l / min(l, p.y = max(0., p.y + l * cos(-6.*iTime + i * .6))),       \n        p += l * cos(vec2(0,11) + max(atan(sqrt(y*y - 1.)) - 1.57, -.6)),\n        D .5*(p+q))))  \n     \n    O = 0.*O + //smooth\n                       step(D p)), .015);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mt2yz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtjyz1", "name": "CC0: Quick hack on the train", "author": "mrange", "description": "CC0: Quick hack on the train\nTravelling on the train I tried to recreate some twitter art\nUnoptimized, hackish and so on but good enough for the train\n\nThe tweet inspiring me: https://twitter.com/SnowEsamosc/status/1688731167451947008\n", "tags": ["2d", "train"], "likes": 33, "viewed": 434, "published": 3, "date": "1691496963", "time_retrieved": "2024-07-30T17:40:24.135987", "image_code": "// CC0: Quick hack on the train\n// Travelling on the train I tried to recreate some twitter art\n// Unoptimized, hackish and so on but good enough for the train\n\n// The tweet inspiring me: https://twitter.com/SnowEsamosc/status/1688731167451947008\n\nconst float zoom = log2(1.8);\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n#define REV(x)      exp2((x)*zoom)\n#define FWD(x)      (log2(x)/zoom)\n\nvec3 effect(vec2 op, vec2 opp) {\n  float aa = 4.0/RESOLUTION.y;\n  const float angle = TAU/10.0; \n  const mat2 rot = ROT(0.5*angle);\n  vec3 col = vec3(0.0);\n  \n  op *= ROT(0.125*TIME);\n  float od = 1E4;\n  \n  for (int j = 0; j < 2; ++j){\n    float tm = TIME+float(j)*0.5;\n    float ctm = floor(tm);\n    float ftm = fract(tm);\n    float z = REV(ftm);\n    vec2 p = op;\n    p /= z;\n  \n    float d = 1E4;\n    float n = floor(FWD(length(p)));\n    float r0 = REV(n);\n    float r1 = REV(n+1.0);\n    \n    for (int i = 0; i < 2; ++i) {\n      vec2 pp = toPolar(p);\n      mod1(pp.y, angle);\n      vec2 rp = toRect(pp);\n      \n      float d0 = circle(rp, r0);\n      float d1 = circle(rp, r1);\n      float d2 = segment(rp, rot*vec2(r0, 0.0), vec2(r1, 0.0));\n      float d3 = segment(rp, transpose(rot)*vec2(r0, 0.0), vec2(r1, 0.0));\n      d0 = abs(d0);\n      d1 = abs(d1);\n      d = min(d, d0);\n      d = min(d, d1);\n      d = min(d, d2);\n      d = min(d, d3);\n      float gd = d*z;\n      vec3 gcol = (1.0+cos(0.5*vec3(0.0, 1.0, 2.0)+op.x*op.y+op.x+TIME+1.6*float(i+j)));\n      col += gcol*0.02/(gd+0.0001);\n      p *= rot;\n    }\n    d *= z;\n    od = min(od, d);\n  }\n  od -= aa*0.66;\n  col = min(col, 1.0);\n  col = mix(col, vec3(0.5), smoothstep(0.0, -aa, od));\n  col = 1.0-col;\n  col *= smoothstep(0.025, 0.25, length(op));\n  col += ((1.0+cos(vec3(0.0, 1.0, 2.0)+TIME))*0.05/(dot(op, op)+0.075));\n  col *= smoothstep(1.5, 0.5, length(opp));\n  col = sqrt(col);\n  return col;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[458, 576, 615, 615, 734], [736, 822, 861, 861, 986], [988, 988, 1019, 1019, 1045], [1048, 1048, 1070, 1070, 1114], [1116, 1116, 1137, 1137, 1182], [1255, 1255, 1287, 1287, 2718], [2720, 2720, 2777, 2777, 2949]], "test": "untested"}
{"id": "ct2czh", "name": "大龙猫 - Shader ByteJam 2023-08-07 ", "author": "totetmatt", "description": "Aka Cucube took some weird M&M's on the disco floor.\nMediocre result, but the wave effect of color works not that bad which was the primary experiment for this jam.", "tags": ["cube"], "likes": 9, "viewed": 244, "published": 3, "date": "1691475531", "time_retrieved": "2024-07-30T17:40:24.908921", "image_code": "// HELLO !\n//  ###########################################################\n//  >> ASK  FOR MORE SHADER SHOWDOWN TO YOUR LOCAL DEMOPARTY <<\n// //  #######################################################\n\n// Music on BUFFER A\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// HELLO !\n//  ###########################################################\n//  >> ASK  FOR MORE SHADER SHOWDOWN TO YOUR LOCAL DEMOPARTY <<\n// //  #######################################################\n#define fGlobalTime iTime\nfloat bpm;\nfloat rnd;\nvec3 edges(vec3 p){\n      vec3 ap=abs(p);\n      if(ap.x>ap.z) return vec3(ap.x/p.x,0,0);\n     return vec3(0,0,ap.z/p.z);\n  }\n\nvec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\nfloat box(vec3 p,vec3 b){p=abs(p)-b; return length(max(vec3(0.),p))+min(0.,max(p.x,max(p.y,p.z)));}\nvec2 sdf(vec3 p){\n      vec2 h;\n      vec3 hp=p;\n       hp.z -=bpm;\n      float jump = -bpm;\n      hp.y -=sqrt(2.)*abs(sin(bpm*3.14));\n      hp = erot(hp,vec3(1,0,0),jump*3.14);\n      h.x = box(hp,vec3(1.));\n      h.y = 1.;\n  \n    vec2 t;\n    vec3 tp=p;\n    \n    tp.y+=1.5;\n    vec3 id = floor(tp)+.5;\n    id.y=0.;\n  \n    vec3 nid  = id + edges(hp-id);\n    nid .y= 0.;\n     float diff = sin(dot(cos(id*.4),sin(id.zyx*.3)))/2.;\n  diff= dot(cos(id*.4),sin(id.zyx*.3));\n     tp.y+=diff/2.;\n    t.x = box(tp-id,vec3(.49,max(0.1,diff/2.),.49));\n    t.x = min(t.x,box(tp-nid,vec3(.493,1.,.493)));\n    \n    // t.x = max(abs(tp.x)-5.,t.x);\n    t.y=3.+dot(sin(id*.4),cos(id.yzx*.23));\n  h= t.x < h.x ? t:h;\n      return h;\n}\n#define q(s) s*sdf(p+s).x\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(0,.1,.2)));}\nvec3 norm(vec3 p,float ee){vec2 e= vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n\n#define FBI(x,y) (floatBitsToInt(x)^floatBitsToInt(y))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   bpm = fGlobalTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  uv*=1.+abs(tanh(sin(-fGlobalTime+length(uv))*10.));\n    rnd =  fract(54.845*sin(dot(uv,vec2(353.35,676.35))));\n  bpm+=rnd*.1*length(uv);\n  bpm = floor(bpm) + smoothstep(0.,1.,pow(fract(bpm),.75));\n vec3 col =vec3(0.);\n  float zoomzoomzeum=sin(fGlobalTime);\n  vec3 ro=vec3(5.,2.,-5.),rt=vec3(0.);\n  ro = erot(ro,vec3(0.,1.,0.),bpm);\n  ro.x +=zoomzoomzeum;\n  ro.z +=bpm;\n  rt.z +=bpm;\n  vec3 z= normalize(rt-ro),x=normalize(cross(z,vec3(0.,-1.,0.))),y=cross(z,x);\n  vec3 rd=mat3(x,y,z)*normalize(vec3(uv,(1.-zoomzoomzeum*.5+.5)));\n  vec3 rp=ro;\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  for(float i=0.;i++<128.;){\n    \n       vec2 d =sdf(rp);\n       float effectSwitch = mod(fGlobalTime,20.)<5. ? d.y:0.;\n       float wave= exp(-7.*fract(effectSwitch+bpm*.5+rp.y*.1-.05*length(rp.xz-vec2(0,bpm))));\n       if(d.x<.1 &&d.y==1.)acc +=mix(vec3(.1),pal(d.y),tanh(wave))*exp(-abs(d.x))/(60.-wave*50.);\n       if(d.y==1.)d.x = max(.001,abs(d.x));\n       rp+=rd*d.x;\n       if(d.x<.001){\n            vec3 n = norm(rp,.001);\n           float dif = max(0.,dot(normalize(light),n));\n         \n           col =mix(vec3(.001),pal(d.y),tanh(wave))*dif;\n           \n           break;\n       }\n    }\n    ivec2 gl = ivec2(gl_FragCoord.xy);\n    ivec2 off= ivec2(5.);\n    float vr = texelFetch(iChannel0,gl+off,0).a;\n    float vg = texelFetch(iChannel0,gl-off,0).a;\n    float vb = texelFetch(iChannel0,gl-off,0).a;\n\tfragColor = vec4(mix(vec3(vr,vg,vb)*.1,sqrt(col+acc),sin(bpm)+1.5+2.*texture(iChannel1,vec2(.1)).r),length(col+acc));\n\n  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34382, "src": "https://soundcloud.com/ahi_jp/ahiep12-architect-sketches", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ct2czh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 224, 281, 281, 345]], "test": "untested"}
{"id": "cl2yzh", "name": "Raymarching Frosted Glass", "author": "alphardex", "description": "Drag to see the effect.", "tags": ["raymarching"], "likes": 5, "viewed": 754, "published": 3, "date": "1691473793", "time_retrieved": "2024-07-30T17:40:25.671881", "image_code": "mat2 rotation2d(float angle){\n    float s=sin(angle);\n    float c=cos(angle);\n    \n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nmat4 rotation3d(vec3 axis,float angle){\n    axis=normalize(axis);\n    float s=sin(angle);\n    float c=cos(angle);\n    float oc=1.-c;\n    \n    return mat4(\n        oc*axis.x*axis.x+c,oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.,\n        oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,oc*axis.y*axis.z-axis.x*s,0.,\n        oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,0.,\n        0.,0.,0.,1.\n    );\n}\n\nvec2 rotate(vec2 v,float angle){\n    return rotation2d(angle)*v;\n}\n\nvec3 rotate(vec3 v,vec3 axis,float angle){\n    return(rotation3d(axis,angle)*vec4(v,1.)).xyz;\n}\n\nfloat sdBox(in vec2 p,in vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\nvec2 opUnion(vec2 d1,vec2 d2)\n{\n    return(d1.x<d2.x)?d1:d2;\n}\n\nvec2 map(vec3 p){\n    vec2 d=vec2(1e10,0.);\n    \n    vec2 m=(iMouse.xy-iResolution.xy*.5)/iResolution.xy;\n    vec3 p1=p;\n    p1.z-=.2;\n    float tilt=.5;\n    p1=rotate(p1,vec3(0.,1.,0.),m.x*tilt);\n    p1=rotate(p1,vec3(1.,0.,0.),m.y*tilt);\n    float d1=sdBox(p1,vec3(.4,.4,.001));\n    d=opUnion(d,vec2(d1,1.));\n    vec3 p2=p;\n    float d2=sdBox(p2,vec3(1.,1.,.001));\n    d=opUnion(d,vec2(d2,2.));\n    return d;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    const float h=.0001;\n    const vec2 k=vec2(1,-1);\n    return normalize(k.xyy*map(p+k.xyy*h).x+\n    k.yyx*map(p+k.yyx*h).x+\n    k.yxy*map(p+k.yxy*h).x+\n    k.xxx*map(p+k.xxx*h).x);\n}\n\nfloat gaussian(vec2 d,float sigma){\n    return exp(-(d.x*d.x+d.y*d.y)/(2.*sigma*sigma));\n}\n\nvec4 gaussianBlur2D(in sampler2D tex,in vec2 st,in vec2 offset,const int kernelSize){\n    vec4 accumColor=vec4(0.);\n    \n    #define GAUSSIANBLUR2D_KERNELSIZE 20\n    float kernelSizef=float(kernelSize);\n    \n    float accumWeight=0.;\n    const float k=.15915494;// 1 / (2*PI)\n    vec2 xy=vec2(0.);\n    for(int j=0;j<GAUSSIANBLUR2D_KERNELSIZE;j++){\n        if(j>=kernelSize)\n        break;\n        xy.y=-.5*(kernelSizef-1.)+float(j);\n        for(int i=0;i<GAUSSIANBLUR2D_KERNELSIZE;i++){\n            if(i>=kernelSize)\n            break;\n            xy.x=-.5*(kernelSizef-1.)+float(i);\n            float weight=(k/kernelSizef)*gaussian(xy,kernelSizef);\n            accumColor+=weight*texture(tex,st+xy*offset);\n            accumWeight+=weight;\n        }\n    }\n    return accumColor/accumWeight;\n}\n\nvec3 render(vec2 uv){\n    vec3 col=vec3(0.);\n    \n    vec4 tex=texture(iChannel0,uv);\n    vec4 blurTex=gaussianBlur2D(iChannel0,uv,1./iResolution.xy,10);\n    \n    uv=(uv-.5)*2.;\n    \n    vec3 ro=vec3(0.,0.,1.);\n    vec3 rd=normalize(vec3(uv,0.)-ro);\n    \n    float depth=0.;\n    for(int i=0;i<64;i++){\n        vec3 p=ro+rd*depth;\n        vec2 t=map(p);\n        float d=t.x;\n        float m=t.y;\n        depth+=d;\n        \n        if(d<.01){\n            // col=vec3(1.);\n            vec3 normal=calcNormal(p);\n            \n            vec3 objectColor=vec3(1.);\n            if(m==1.){\n                objectColor=blurTex.xyz;\n            }else if(m==2.){\n                objectColor=tex.xyz;\n            }\n            vec3 lightColor=vec3(1.,1.,1.);\n            \n            if(m==1.){\n                float ambIntensity=.1;\n                vec3 ambient=lightColor*ambIntensity;\n                col+=ambient*objectColor;\n                \n                // diffuse\n                vec3 lightPos=vec3(20.);\n                vec3 lightDir=normalize(lightPos-p);\n                float diff=dot(normal,lightDir);\n                diff=max(diff,0.);\n                vec3 diffuse=lightColor*diff;\n                col+=diffuse*objectColor;\n                \n                // specular\n                vec3 reflectDir=reflect(-lightDir,normal);\n                vec3 viewDir=normalize(ro-p);\n                // float spec=dot(viewDir,reflectDir);\n                vec3 halfVec=normalize(lightDir+viewDir);\n                float spec=dot(normal,halfVec);\n                spec=max(spec,0.);\n                float shininess=32.;\n                spec=pow(spec,shininess);\n                vec3 specular=lightColor*spec;\n                col+=specular*objectColor;\n            }else if(m==2.){\n                // ambient\n                // float ambIntensity=.2;\n                float ambIntensity=1.;\n                vec3 ambient=lightColor*ambIntensity;\n                col+=ambient*objectColor;\n            }\n            \n            break;\n        }\n    }\n    \n    return col;\n}\n\nvec3 getSceneColor(vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 col=render(uv);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 tot=vec3(0.);\n    \n    float AA_size=2.;\n    float count=0.;\n    for(float aaY=0.;aaY<AA_size;aaY++)\n    {\n        for(float aaX=0.;aaX<AA_size;aaX++)\n        {\n            tot+=getSceneColor(fragCoord+vec2(aaX,aaY)/AA_size);\n            count+=1.;\n        }\n    }\n    tot/=count;\n    \n    fragColor=vec4(tot,1.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2yzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 134], [136, 136, 175, 175, 568], [570, 570, 602, 602, 636], [638, 638, 680, 680, 733], [735, 735, 769, 769, 843], [845, 845, 873, 873, 956], [958, 958, 992, 992, 1017], [1019, 1019, 1050, 1050, 1081], [1083, 1083, 1100, 1100, 1495], [1497, 1497, 1525, 1525, 1711], [1713, 1713, 1748, 1748, 1803], [1805, 1805, 1890, 1890, 2599], [2601, 2601, 2622, 2622, 4663], [4665, 4665, 4700, 4700, 4781], [4783, 4783, 4836, 4836, 5161]], "test": "untested"}
{"id": "mtByz1", "name": "Kiwi fruit mosaic", "author": "jarble", "description": "A mosaic pattern that looks like kiwi fruit.\nClick and drag to move around.", "tags": ["fractal", "mosaic", "fruit", "kiwi"], "likes": 4, "viewed": 141, "published": 3, "date": "1691465145", "time_retrieved": "2024-07-30T17:40:26.436836", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n    ;\n}\nvec2 uv3(vec2 uv){\n    if(uv.x>uv.y) return uv.yx;\n    else return\n        uv\n        //abs(uv-.5)\n    ;\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        //if(k % 2 == 0) uv *= 1.5;\n        uv =\n            uv3(abs(.5+uv+t2)/1.5)\n        ;\n        //uv = -abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        //if(uv.y<uv.x) uv = uv.yx-vec2(.5,1.5); else uv *= 1.5; if((k)%3 == 0) uv -= vec2(.5,1.5); \n\n        t2 =\n            -triangle_wave(-uv-.5).yx\n        ;\n        uv =\n            t2-triangle_wave(-uv.yx).yx\n        ;\n        //if(uv.x<-.25)\n        col =\n            vec3(col.zx,max(abs(uv.x-uv.y)*sign(t2.x-t2.y),0.))\n        ;\n        }\n        return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1/2.0;\n    vec3 col = fractal(uv);\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtByz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 142], [143, 143, 161, 161, 249], [251, 251, 273, 273, 878], [880, 880, 935, 935, 1243]], "test": "untested"}
{"id": "mtByzh", "name": "Wub Wub Wub", "author": "SentientCymatic", "description": "Illusion", "tags": ["psychedelic", "abstract", "illusion"], "likes": 1, "viewed": 88, "published": 3, "date": "1691457337", "time_retrieved": "2024-07-30T17:40:27.210766", "image_code": "void mainImage(out vec4 Z, in vec2 A)\n{\n    vec2 B = (A * 2.0 - iResolution.xy) / iResolution.y;\n    float C = sin(length(B) * 4.0 - iTime) * -0.05;\n    B += B * C;\n    float L = length(B);\n    float W = 50.*(1.+ C)/iResolution.y;\n    float H = 50.*(1.+ C)/iResolution.x;\n    float D = smoothstep(W * 2.5, H * 10., abs(fract(L * 20.) - 0.25) - 0.25);\n    vec2 uv = A/iResolution.xy;\n    vec3 E = vec3(D);\n    vec3 F = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 G = E * F;\n    Z = vec4(G, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtByzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 502]], "test": "untested"}
{"id": "DlBcz1", "name": "Microraymarcher (156 chars)", "author": "iq", "description": "Writing a raymarching shader using only the two input variables, no temporaries.", "tags": ["3d", "sdf", "raymarcher", "tweet", "micro", "golf", "size"], "likes": 114, "viewed": 4284, "published": 3, "date": "1691448861", "time_retrieved": "2024-07-30T17:40:27.976718", "image_code": "// The MIT License\n// Copyright © 2023 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// A raymarching shader using no more than the two input variables\n// Original was 161 chars long. -1 by SnoopethDuckDuck. -4 chars by Xor.\n\nvoid mainImage(out vec4 p,vec2 f){for(\np=vec4(f/iResolution.y,1,0)-.6;                                  // First set up camera\nf.x-->0.;                                                        // Then while not done\np*=.9+.1*length(cos(.7*p.x+vec3(p.z+iTime,p)))+.01*cos(4.*p.y)); // march forward\np=(p+p.z)*.1;}                                                   // Finally, do color\n\n\n\n// Basic idea:\n//\n// p += f(p)*rd              Start with a regular SDF raymarcher\n// p += f(p)*normalized(p)   and note ray direction is normalized position.\n// p += f(p)*p/p.z           But our Signed Field f(p) need NOT be an SDF,\n// p += f(p)*p*step          so we migh as well use a constant here.\n// p *= 1+f(p)*step          Then factor out ray position.\n// p *= (1-k*step)+step*g(p) Now, if f(p) has some level set constant k,\n//                           f(p)=g(p)-k, we can propagate it out of f(p).\n//\n// Notes:\n//\n// +4 chars, to fix clipping issue:       p=.1*vec4(f/iResolution.y,1,0)-.06;\n// +2 chars, to fix screen-left issue:    f.x-->-2e2;\n// +2 chars, to fix compatibility issues: vec3(p.z+iTime,p.xy)\n//\n// These fixes above applied makes 165 chars:\n//\n// void mainImage(out vec4 p,vec2 f){for(\n// p=.1*vec4(f/iResolution.y,1,0)-.06;\n// f.x-->-2e2;\n// p*=.9+.1*length(cos(.7*p.x+vec3(p.z+iTime,p.xy)))+.01*cos(4.*p.y));\n// p=(p+p.z)*.1;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlBcz1.jpg", "access": "api", "license": "mit", "functions": [[1288, 1288, 1322, 1322, 1599]], "test": "untested"}
{"id": "ctSyz1", "name": "circle music visualizer", "author": "janpitokiala", "description": "music visualizer", "tags": ["music", "visualizer"], "likes": 1, "viewed": 66, "published": 3, "date": "1691442792", "time_retrieved": "2024-07-30T17:40:28.745662", "image_code": "#define PI 3.14\n#define background vec3(0.0)\n#define color vec3(0.0,1.0,1.0)\n//#define low 2.0  //shows low frequencies more (also makes it asymmetric)\n\n#ifndef low\n#define low 1.0\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.y;\n    vec2 polar = vec2(0.5+atan(uv.x,uv.y)/(2.0*PI),length(uv));\n    float value = mix(\n                    texture(iChannel0, vec2(1.0-polar.x,0.0)).r,\n                    texture(iChannel0, vec2(polar.x,0.0)).r,\n                    min(polar.x*low,1.0)\n                  )*0.5;\n    float size = texture(iChannel0, vec2(0,0.0)).r*0.3;\n    vec3 col = background;\n    if(value+size>polar.y) {\n      col=color;\n      if(size>polar.y) {\n        col = texture(iChannel1, 0.5+uv/2.0/size).rgb;\n      }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 245, 245, 845]], "test": "untested"}
{"id": "ctBcR1", "name": "Trans pride", "author": "eimink", "description": "A simple trans flag shader first done at MondayNightBytes Shader Jam. This is the shadertoy version without FFT and a bit different blur.", "tags": ["pride", "transgender", "shaderjam"], "likes": 1, "viewed": 194, "published": 3, "date": "1691441691", "time_retrieved": "2024-07-30T17:40:29.510618", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float E = 0.001;\nconst int STEPS = 64;\nconst float FAR = 40.0;\n\nfloat fft = 0.0;\n\nstruct MarchResult\n{\n  float id;\n  float t;\n  vec3 p;\n  vec3 n;\n  float d;\n};\n\nfloat box(vec3 position, vec3 dimensions){\n  vec3 b = abs(position)-dimensions;\n  return length(max(b, 0.0)) + min(max(b.x, max(b.y, b.z)), 0.0); \n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 scene(vec3 p){\n  vec3 pp = abs(p);\n  vec2 res = vec2(1.,0.);\n  \n  for (float i = 0.; i < 35.0; ++i)\n  {\n    float a = box(p+vec3(0.,0.+sin(iTime-i),10.0-i),vec3(1.,1.,1.0));\n    float b = box(p+vec3(0.,2.+sin(iTime-i),10.0-i),vec3(1.,1.,1.0));\n    float c = box(p+vec3(0.,4.+sin(iTime-i),10.0-i),vec3(1.,1.,1.0));\n    float d = box(p+vec3(0.,6.+sin(iTime-i),10.0-i),vec3(1.,1.,1.0));\n    float e = box(p+vec3(0.,8.+sin(iTime-i),10.0-i),vec3(1.,1.,1.0));\n    res = opU(res,opU(opU(vec2(d,2.0),vec2(e,1.0)),opU(vec2(c,3.0),opU(vec2(a,1.0),vec2(b,2.0)))));\n  }    \n  \n  return res;\n  \n}\n\nvec3 calcNormal(vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(scene(pos+e.xyy).x-scene(pos-e.xyy).x,\n                           scene(pos+e.yxy).x-scene(pos-e.yxy).x,\n                           scene(pos+e.yyx).x-scene(pos-e.yyx).x ) );\n}\n\nMarchResult march(vec3 ro, vec3 rd)\n{\n  float t = E;\n  float id = 0.0;\n  vec3 position = ro;\n  for (int i = 0; i < STEPS;++i){\n    vec2 d = scene(position);\n    t +=d.x;\n    id = d.y;\n    position = ro+rd*t;\n    if (d.x < E || t > FAR) break;\n  }\n  MarchResult res;\n  res.t = t;\n  res.id = id;\n  res.p = position;\n  res.n = calcNormal(position);\n  return res;\n}\n\nvec3 colorize(MarchResult m, vec3 ld)\n{\n  float t = m.d;\n  vec3 p = m.p;\n  vec3 col = vec3(0.0);\n  if (m.id == 2.0)\n  {\n      col = vec3(1.0,.2,.9) + clamp(dot(m.n,ld),0.0,1.0);\n  }\n  else if (m.id == 3.0)\n  {\n    col = vec3(.8) + clamp(dot(m.n,ld),0.0,1.0);\n  }\n  else if (m.id == 1.0)\n  {\n    col = vec3(.2,.5,1.0) + clamp(dot(m.n,ld),0.0,1.0);\n  }\n  else col = vec3(0);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 uvv = -1.0 + 2.0*uv;\n  uvv.x *= iResolution.x / iResolution.y;\n    \n  vec3 rayOrigin = vec3(sin(iTime)*10.,sin(iTime)*2.-5.0,cos(iTime)*10.0-10.0);\n  vec3 lookAt = vec3(0.0, -5.0, 0.0);\n  \n  vec3 z = normalize(lookAt - rayOrigin);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  \n  vec3 rayDirection = normalize(mat3(x, y, z) * vec3(uvv, radians(60.00)));\n  \n  vec3 lightDirection = -rayDirection;\n  \n  vec3 col = vec3(0.0);\n  \n  MarchResult t = march(rayOrigin, rayDirection);\n  if ( t.t < FAR){\n    col = colorize(t,lightDirection);\n  }\n  fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufB = texelFetch(iChannel1,ivec2(fragCoord),0);\n    vec4 bufA = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec3 col;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n  fragColor = mix(bufB,bufA,0.05);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctBcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 117]], "test": "untested"}
{"id": "ctSyzh", "name": "Bouncy glowing circle", "author": "Unesty", "description": "A playful glowing sphere animated with physics-based bouncing, edge detected impacts, and timed glow bursts for visual flair.", "tags": ["glow", "distance"], "likes": 5, "viewed": 162, "published": 3, "date": "1691436886", "time_retrieved": "2024-07-30T17:40:30.275574", "image_code": "// Glowing Sphere Shader\n\n#define PI 3.14159265359\n\n//rotation matrix\nmat2 rot(float a) {    \n  return mat2(cos(a), sin(a), \n              -sin(a), cos(a));\n}\n\nfloat sawtooth(float x) {\n  return x - floor(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  float aspect = iResolution.x/iResolution.y;\n  vec2 uv = fragCoord/iResolution.xy*2.0 - 1.0;\n  \n  float time = iTime*0.5;\n  \n  //// Swirling distortion\n  //uv += vec2(sin(time), cos(time)) * 0.1;\n  //uv *= rot(sin(time*0.5)*0.3 + 0.7);\n  \n  //// Complex distortion\n  // Slow wave distortion\n  //vec2 wave1 = uv * vec2(0.2, 1.0) + vec2(sin(iTime), cos(iTime)) * 0.1;\n  \n  // Faster swirl  \n  //float swirl = iTime * 2.1;\n  //mat2 rotMat = mat2(cos(swirl), sin(swirl), \n  //                   -sin(swirl), cos(swirl));\n  //vec2 wave2 = rotMat * uv;\n\n  // Blend waves                \n  //uv = mix(uv, wave1, 0.5);\n  //uv = mix(uv, wave2, 0.75);\n  \n  \n  \n  //// Move up-down\n  // Gently float sphere vertically  \n  //float boy = sin(iTime) * 0.1;\n  //uv.y += boy;\n  \n  // Pulsing growth\n  //float pulse = (sin(iTime) + 1.0) * 0.5;\n  //float radius = mix(0.1, 0.5, pulse); // Unused lol\n\n  //// Ball\n  // Bouncing ball height \n \n  // Playful bounces\n  float bounces = sin(iTime * 2.0)*.5;//.9-.2; \n  bounces = abs(bounces);\n  \n  // Parabolic jump shape\n  float height = -32.0 * bounces * (1.0 - bounces);\n  uv.y += height * 0.1;\n  \n  // Triangle wave x position\n  #define roomsz 3.6\n  // Triangle wave x motion\n  float triWave = abs(2.0 * (mod(iTime/roomsz, 1.0)) - 1.0);\n  uv.x += (triWave-0.5) * (roomsz/2.0);\n  // Map to -1 to 1 range\n  //triWave = triWave*2.0 - 1.0;\n\n\n  // Solid sphere \n  float sphereDist = length(uv/vec2(1,aspect));\n  float sphere = smoothstep(0.1, 0.09, sphereDist);\n  \n  // Large glow\n  float glowDist = length(uv/vec2(1,aspect));\n  glowDist = sqrt(1.0 - glowDist*glowDist); \n  // Calculate distance from center\n  float dist = length(uv/vec2(1,aspect));\n    \n  // Map distance to glow\n  float glow = pow(1.0-dist, 4.0);\n  float largeGlow = glowDist*0.01 ;\n\n  \n  // Subtract sphere from glow\n  glow = max(glow - sphere, 0.0);\n  \n  // Sine blink\n  //largeGlow *= sin(time) * 5. + 0.5;\n  //glow *= sin(time) * 0.5 + 0.5;\n\n  // Use exponential pulses for glow\n  //float pulse = exp(abs(sin(time*3.0)));\n  //largeGlow *= pulse*2.;\n  //glow *= pulse*.5;\n\n  // Burst glow on impact\n  float floorImpact = smoothstep(0.075, 0.0, bounces)*.4;\n  // Side impacts\n  float sideImpact1 = smoothstep(0.075/roomsz, 0., triWave)*.4;\n  float sideImpact2 = smoothstep(1.-(0.075/roomsz), 1., triWave)*.4;\n\n  // Burst glow\n  glow *= 1.0 + floorImpact + sideImpact1 + sideImpact2;\n\n  // Combine\n  vec3 col = vec3(sphere) + glow + largeGlow;\n  \n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctSyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 70, 89, 89, 158], [160, 160, 185, 185, 210], [212, 212, 269, 269, 2744]], "test": "untested"}
{"id": "dljcRz", "name": "Dilate and Erode", "author": "servostar", "description": "Implementation of dilation and erosion filter with 3 different kernel shapes: box, diamond and circle.", "tags": ["filter", "convolution", "erosion", "dilation"], "likes": 4, "viewed": 345, "published": 3, "date": "1691428777", "time_retrieved": "2024-07-30T17:40:31.050501", "image_code": "\n//#define DIAMOND_KERNEL\n#define CIRCULAR_KERNEL\n\nfloat luminance(in vec3 rgb)\n{\n    return dot(rgb, vec3(0.21, 0.72, 0.07));\n}\n\n/**\n* Intensifies the brightest pixels of the applied kernel based on the luminance() function\n*/\nvec3 dilate(in sampler2D tex, in vec2 uv, in int size, in float sep, in float minb, in float maxb)\n{\n    vec3 cc = texture(tex, uv).rgb;\n    vec3 tc = cc;\n    float cl = luminance(cc);\n\n    vec2 texSize = sep/vec2(textureSize(tex, 0));\n\n    for (int x = -size; x <= size; ++x)\n    for (int y = -size; y <= size; ++y)\n    {\n        // default kernel is box shaped\n        \n        // diamond shaped kernel (45° rotated square)\n        #if defined(DIAMOND_KERNEL)\n        \n        if (abs(x) > size - abs(y))\n            continue;\n\n        #elif defined(CIRCULAR_KERNEL)\n        \n        if (distance(vec2(x, y), vec2(0, 0)) > float(size))\n            continue;\n            \n        #endif\n    \n        vec3 s = texture(tex, uv + vec2(x,y)*texSize).rgb;\n        float b = luminance(s);\n        \n        if (cl < b)\n        {\n            cl = b;\n            tc = s;\n        }\n    }\n    \n    return mix(cc, tc, smoothstep(minb, maxb, cl));\n}\n\n/**\n* Intensifies the darkest pixels of the applied kernel based on the luminance() function\n*/\nvec3 erode(in sampler2D tex, in vec2 uv, in int size, in float sep, in float minb, in float maxb)\n{\n    vec3 cc = texture(tex, uv).rgb;\n    vec3 tc = cc;\n    float cl = luminance(cc);\n\n    vec2 texSize = sep/vec2(textureSize(tex, 0));\n\n    for (int x = -size; x <= size; ++x)\n    for (int y = -size; y <= size; ++y)\n    {\n        // default kernel is box shaped\n        \n        // diamond shaped kernel (45° rotated square)\n        #if defined(DIAMOND_KERNEL)\n        \n        if (abs(x) > size - abs(y))\n            continue;\n\n        #elif defined(CIRCULAR_KERNEL)\n        \n        if (distance(vec2(x, y), vec2(0, 0)) > float(size))\n            continue;\n            \n        #endif\n    \n        vec3 s = texture(tex, uv + vec2(x,y)*texSize).rgb;\n        float b = luminance(s);\n        \n        if (cl > b)\n        {\n            cl = b;\n            tc = s;\n        }\n    }\n    \n    return mix(tc, cc, smoothstep(minb, maxb, cl));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float separation = (uv.x)*1.5;\n\n    vec3 dilation = dilate(iChannel0, uv, 16, separation, 0.0, 1.0);\n    vec3 erosion  = erode (iChannel0, uv, 16, separation, 0.0, 1.0);\n    \n    vec3 col = uv.x > 0.0 ? erosion : dilation;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dljcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 81, 81, 128], [130, 228, 328, 328, 1166], [1168, 1264, 1363, 1363, 2201], [2203, 2203, 2258, 2258, 2584]], "test": "untested"}
{"id": "dtSczz", "name": "Cliff Edge", "author": "dr2", "description": "Flight near a cliff (mouseable)", "tags": ["truchet", "flight", "helicopter"], "likes": 17, "viewed": 245, "published": 3, "date": "1691401379", "time_retrieved": "2024-07-30T17:40:32.077753", "image_code": "// \"Cliff Edge\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Notes on methodology: Grid-based raymarching is used in this shader. If the\n  world-space containing multiple distinct objects can be partitioned by a grid,\n  so that objects do not overlap cell boundaries, then distance computations need\n  only consider objects contained in the marched ray's current cell. When a ray\n  reaches a cell boundary, the contents of the next cell are determined, and\n  details of its boundaries computed. Partitioning may be 1d/2d/3d, with square or\n  hexagonal 2d cells, and optional partitioning in the remaining direction.\n  Multiple independent grids can be used. Significant performance improvements are\n  achievable and potential aliasing artifacts avoided. Adaptations for objects\n  that overlap cell boundaries, as well as other specialized partitioning, are\n  possible.\n\n  This shader uses two separate hexagonal grids for the raymarching: the Truchet\n  tiling, on which the coastline is based, uses a bigger grid; the trees use a\n  smaller grid, with random displacements partly obscuring the grid layout.\n  There is also a regular raymarching loop for the flyer (with bounding box).\n\n  Earlier shaders using various realizations of these techniques (all 132 of\n  them) are listed at the end. (Reminder: raymarching and raytracing are entirely\n  different methods.)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Ssign (float x);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define PLEN 17\n\nmat3 flyerMat;\nvec4 cPath[PLEN];\nvec3 qHit, flyerPos, sunDir, tOff;\nvec2 cIdB, cIdS, cMidB, cMidS, csRotor;\nfloat dstFar, tCur, hgSizeB, hgSizeS, tEnd[PLEN + 1], tLen, trVel, cDir, cType, baseWd,\n   baseHt, csOcc;\nint nFrame, idObj;\nbool withTrees, isSh;\nconst int idGrnd = 1, idTrnk = 2, idLvs = 3, idHeli = 13, idRotorM = 14, idRotorT = 15, idSkd = 16;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{ // (from \"Truchet's Train\")\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * Ssign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * Ssign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * Ssign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = Ssign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. ||\n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nbool SideTrk (vec2 w, float sd)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, side;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  if (cyo) side = (cxy == 0. && wp.x > 0. || cxy == 1. && (wp.y < 0. && sd > 0. || w.x < -0.5) ||\n     cxy == 2. && (wm.y > 0. && wp.y > 0. || w.x > 0.) || cxy == 3. || cxy == 4. && wm.x < 0. ||\n     cxy == 5. && (wp.x > 0. || wm.y < 0.));\n  else side = (cxy == 1. && (wp.x > 0. || wp.y > 0. || sd > 0.) ||\n     cxy == 2. && (wp.y < 0. || sd > 0.) || cxy == 3. && (wp.y > 0. && sd > 0. || w.x > 0.5) ||\n     cxy == 4. || cxy == 5.);\n  side = side || (cxy >= 6.);\n  return side;\n}\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= Ssign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - Ssign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nfloat FlyerDf (vec3 p)\n{  // (from \"Piz Gloria With Helicopter\")\n  vec3 q;\n  float dMin, d, r, s, flyerSz;\n  flyerSz = 0.12;\n  dMin = dstFar / flyerSz;\n  p = flyerMat * (p - flyerPos) / flyerSz;\n  if (! isSh) d = PrRoundBoxDf (p - vec3 (0., 0.5, -1.2), vec3 (4.5, 2., 5.5), 0.1);\n  if (isSh || d < 0.1) {\n    q = p;\n    r = 1.;\n    if (q.z < -0.1) {\n      s = (q.z + 0.1) * (q.z + 0.1);\n      r *= 1. - 0.1 * s;\n      q.y -= 0.05 * s;\n    } else if (q.z > 0.1) {\n      s = (q.z - 0.1) * (q.z - 0.1);\n      r *= 1. - 0.03 * s;\n    }\n    q.x *= 0.8;\n    d = PrCapsDf (q, max (r, 0.), 2.);\n    q = p;\n    q.yz = Rot2D (q.yz - vec2 (1.1, -4.2), -0.05 * pi);\n    r = 0.2 * (1. + 0.25 * q.z);\n    q.y *= 0.7;\n    d = min (d, PrCapsDf (q, r, 1.5));\n    q = p;\n    q.yz -= vec2 (1.7, -0.2);\n    d = min (d, PrCylDf (q.xzy, 0.4, 0.4));\n    q = p;\n    q.yz -= vec2 (0.4, -1.);\n    r = 1.1;\n    if (q.z < 0.) {\n      s = q.z * q.z;\n      r *= 1. - 0.2 * s;\n      q.y -= 0.1 * s;\n    }\n    q.y *= 0.8;\n    d = SmoothMin (d, PrCapsDf (q, max (r, 0.), 1.5), 0.03);\n    q = p;\n    q.yz -= vec2 (1.4, -6.15);\n    d = min (d, max (PrRoundCylDf (q.yzx, 0.5, 0.05, 0.02), 0.35 - length (q.yz)));\n    q = p;\n    DMINQ (idHeli);\n    q = p;\n    q.yz = Rot2Cs (q.yz - vec2 (1.4, -6.15), csRotor);\n    d = PrRoundBoxDf (q, vec3 (0.01, 0.32, 0.04), 0.02);\n    DMINQ (idRotorT);\n    q = p;\n    q.yz -= vec2 (2., -0.2);\n    d = PrCylDf (q.xzy, 0.12, 0.5);\n    q.y -= 0.4;\n    q.xz = Rot2Cs (q.xz, csRotor);\n    d = min (d, PrRoundBoxDf (q, vec3 (4.5, 0.02, 0.08), 0.03));\n    DMINQ (idRotorM);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.9, -1.4);\n    d = PrRoundBoxDf (q, vec3 (0.1, 0.01, 1.4), 0.04);\n    q.xy = Rot2D (q.xy, -0.1 * pi);\n    q.z = abs (q.z);\n    q.yz -= vec2 (0.4, 0.7);\n    d = min (d, PrCylDf (q.xzy, 0.06, 0.4));\n    DMINQ (idSkd);\n    dMin *= 0.7;\n  } else dMin = min (dMin, d);\n  return flyerSz * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4;\n  if (idObj == idHeli) {\n    col4 = mix (vec4 (1., 1., 0., 0.2), vec4 (1., 0., 0.1, 0.2), smoothstep (0., 0.02,\n       abs (qHit.y) - 0.05));\n    if (length (vec2 (qHit.x, qHit.y / 0.8)) > 1.24 && qHit.y > 0.55 && qHit.z > 0.4 &&\n       abs (abs (qHit.x) - 0.3) > 0.05) col4 = vec4 (0., 0.5, 0.5, -2.);\n    if (qHit.z > 0.) col4 = mix (vec4 (0., 1., 0., -1.), col4, step (0.15, length (qHit.xy)));\n    else col4 = mix (vec4 (0.5 + 0.5 * step (0.5, fract (2. * tCur +\n       0.25 * sign (qHit.x))), 0., 0., -1.), col4, step (0.2, length (vec2 (abs (qHit.x) - 0.3,\n       qHit.y))));\n  } else if (idObj == idRotorM) {\n    col4 = (length (qHit.xz) < 4.2) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n  } else if (idObj == idRotorT) {\n    col4 = (length (qHit.yz) > 0.06) ? vec4 (0.8, 0.8, 0.9, 0.1) : vec4 (1., 1., 0.2, 0.1);\n  } else if (idObj == idSkd) {\n    col4 = vec4 (0.7, 0.7, 0.75, 0.1);\n  }\n  return col4;\n}\n\nfloat FlyerSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = FlyerDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nfloat GrndHt (vec2 p)\n{\n  float f, a, aSum;\n  p *= 0.2;\n  f = 0.;\n  a = 1.;\n  aSum = 0.;\n  for (int j = 0; j < 3; j ++) {\n    f += a * Noisefv2 (p);\n    aSum += a;\n    a *= 0.4;\n    p *= 2.5;\n  }\n  return 2.5 * f / aSum;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 w;\n  float dMin, d, gHt;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    w = (q.xz - cMidB) / hgSizeB;\n    cm3 = TruchSDist (w);\n    if (cType <= 2. && cm3.y > 0. && OnTrk (w) || SideTrk (w, cm3.y)) gHt = baseHt;\n    else gHt = baseHt + GrndHt (p.xz);\n    d = q.y - gHt;\n    if (cType <= 2. && cm3.y < 0. && OnTrk (w)) {\n      d = SmoothMin (q.y - baseHt, SmoothMax (d, dot (vec2 (baseWd - hgSizeB * abs (cm3.x),\n         q.y - 0.4 * gHt), sin (0.17 * pi + vec2 (0.5 * pi, 0.))) - 0.2, 0.07), 0.25);\n    }\n    d *= 0.8;\n    DMIN (idGrnd);\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeB;\n  dHit = 0.;\n  cIdB = PixToHex (ro.xz / hgSizeB);\n  pM = HexToPix (cIdB);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 420; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      BConf ();\n      cNu = false;\n    }\n    d = BObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdB = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeB);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid SConf ()\n{\n  vec2 r;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  r = Hashv2v2 (73. * cIdS + 1.1);\n  tOff.xz = 0.4 * sqrt3 * hgSizeS * (0.5 + 0.5 * r.x) * sin (2. * pi * r.y + vec2 (0.5 * pi, 0.));\n  tOff.y = r.x + r.y;\n}\n\nvoid SBConf (vec2 cIdBT, vec2 u)\n{\n  vec3 cm3;\n  vec2 w;\n  cIdB = cIdBT;\n  BConf ();\n  w = (u - cMidB) / hgSizeB;\n  cm3 = TruchSDist (w);\n  if (cType <= 2. && cm3.y > 0. && OnTrk (w) || hgSizeB * abs (cm3.x) < baseWd + 0.4 ||\n     SideTrk (w, cm3.y)) csOcc = 0.;\n  else csOcc = 0.01 + 0.99 * Hashfv2 (17.11 * cIdS);\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  if (csOcc > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidS) / hgSizeS;\n    q.xz -= tOff.xz;\n    h = 0.1 + 0.07 * tOff.y;\n    q.y -= h + GrndHt (cMidS);\n    d = max (length (q.xz) - 0.03, q.y - h);\n    DMIN (idTrnk);\n    if (Maxv2 (tOff.xz) > 0.) {\n      q.y -= h + 0.25;\n      d = PrConCapsDf (q.xzy, sin (0.085 * pi + vec2 (0.5 * pi, 0.)), 0.1, 0.2);\n    } else {\n      q.y -= h + 0.17;\n      d = SmoothMin (PrSphDf (q, 0.15), PrSphDf (vec3 (q.x, abs (q.y) - 0.17, q.z), 0.1), 0.15);\n    }\n    DMIN (idLvs);\n  }\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM, u, cIdBT;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeS;\n  dHit = 0.;\n  cIdS = PixToHex (ro.xz / hgSizeS);\n  pM = HexToPix (cIdS);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SConf ();\n    }\n    u = cMidS + tOff.xz;\n    cIdBT = PixToHex (u / hgSizeB);\n    if (cNu || cIdB != cIdBT) SBConf (cIdBT, u);\n    cNu = false;\n    d = SObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdS = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeS);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP, u;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    u = cMidS + tOff.xz;\n    SBConf (PixToHex (u / hgSizeB), u);\n    if (csOcc > 0.) {\n      h = SObjDf (p);\n      sh = min (sh, smoothstep (0., 0.1 * d, h));\n      d += h;\n    } else d += 0.1 * hgSizeS;\n    if (sh < 0.05 || d > 2. * hgSizeS) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h, tWav;\n  h = 0.01 * (1. + sin (4. * dot (p, sin (- pi / 6. + vec2 (0., 0.5 * pi))) - tCur));\n  q = p;\n  wFreq = 2.;\n  wAmp = 0.002;\n  tWav = 0.1 * tCur;\n  tw = tWav * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= qRot;\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return h;\n}\n\nvec4 WaveNf (vec3 p, float d)\n{\n  vec3 h;\n  vec2 e, ee[3];\n  e = vec2 (max (0.1, 5e-3 * d * d), 0.);\n  ee[0] = e.yy;\n  ee[1] = e.xy;\n  ee[2] = e.yx;\n  for (int j = VAR_ZERO; j < 3; j ++) h[j] = WaveHt (p.xz + ee[j]);\n  return vec4 (normalize (vec3 (h.x - h.yz, e.x)).xzy, h.x);\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn, inout vec2 vf)\n{\n  vec4 col4, cc4, cg4;\n  vec3 cm3;\n  vec2 w;\n  float dt, h;\n  if (idObj == idGrnd) {\n    w = (ro.xz - cMidB) / hgSizeB;\n    cm3 = TruchSDist (w);\n    dt = hgSizeB * abs (cm3.x);\n    cg4 = vec4 (0.1, 0.6, 0.1, 0.) * (0.6 + 0.4 * Fbm2 (4. * ro.xz));\n    col4 = cg4;\n    if (cType <= 2. && cm3.y != 0. && OnTrk (w) && dt - baseWd < 0.3) {\n      cc4 = 0.9 * mix (vec4 (0.68, 0.68, 0.7, 0.), vec4 (0.7, 0.7, 0.75, 0.),\n         smoothstep (0.15, 0.25, abs (fract (8. * (ro.y / (0.5 + GrndHt (ro.xz)))) - 0.5)));\n      cc4 *= 1. - 0.1 * Fbm3 (16. * ro);\n      h = ro.y - baseHt;\n      if (h > 0.2) col4 = mix (cc4, col4, smoothstep (0.8, 0.9, vn.y));\n      else if (h > 0.) col4 = cc4;\n      col4 = mix (col4, cg4, smoothstep (0.25, 0.3, dt - baseWd));\n      col4 = mix (0.5 * cg4, col4, smoothstep (0.03, 0.1, h));\n      vf = vec2 (16., 0.5);\n    } else {\n      vf = vec2 (2., 2.);\n    }\n  }\n  return col4;\n}\n\nvec4 SObjCol (vec3 ro, out vec2 vf)\n{\n  vec4 col4;\n  if (idObj == idTrnk) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n    vf = vec2 (32., 1.);\n  } else if (idObj == idLvs) {\n    col4 = vec4 (0.4, 0.7 * min (1., (1.2 - 0.4 * csOcc)), 0.1, 0.);\n    col4 = mix (col4, vec4 (0.9, 0.9, 0., 0.1), step (0.7, Fbm3 (64. * ro.xzy)));\n    vf = vec2 (16., 2.);\n  }\n  return col4;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.4, 0.45, 0.9), vec3 (0.9, 0.9, 0.85),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnw, roo, rdo;\n  vec2 vf, u;\n  float dstObj, dstFlyer, dstObjB, dstObjS, dstWat, reflFac, sh;\n  int idObjB, idObjS, idObjF;\n  bool isLit;\n  csRotor = sin (17.1 * pi * tCur + vec2 (0.5 * pi, 0.));\n  vf = vec2 (0.);\n  isSh = false;\n  dstWat = (rd.y < 0.) ? - (ro.y - baseHt - 0.05) / rd.y : dstFar;\n  roo = ro;\n  rdo = rd;\n  reflFac = 1.;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = dstFar;\n    dstObjB = BObjRay (ro, rd);\n    idObjB = idObj;\n    dstObjS = withTrees ? SObjRay (ro, rd) : dstFar;\n    idObjS = idObj;\n    dstFlyer = FlyerRay (ro, rd);\n    idObjF = idObj;\n    if (min (min (dstObjB, dstObjS), dstFlyer) < dstFar) {\n      if (min (dstObjB, dstObjS) < dstFlyer) {\n        if (dstObjB < dstObjS) {\n          dstObj = dstObjB;\n          idObj = idObjB;\n        } else {\n          dstObj = dstObjS;\n          idObj = idObjS;\n        }\n      } else {\n        dstObj = dstFlyer;\n        idObj = idObjF;\n      }\n      if (k == 0 && dstWat < min (dstObj, dstFar)) {\n        ro += dstWat * rd;\n        vnw = WaveNf (ro, dstWat).xyz;\n        vnw = VaryNf (4. * ro, vnw, 0.05 * (1. - 0.9 * smoothstep (0.2, 0.3, dstWat / dstFar)));\n        rd = reflect (rd, vnw);\n        ro += 0.01 * rd;\n        reflFac = 0.7;\n      } else {\n        ro += dstObj * rd;\n        break;\n      }\n    }\n  }\n  isLit = false;\n  if (min (min (dstObjB, dstObjS), dstFlyer) < dstFar) {\n    if (idObj == idObjB) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      BConf ();\n      vn = BObjNf (ro);\n      col4 = GrndCol (ro, vn, vf);\n    } else if (idObj == idObjS) {\n      cIdS = PixToHex (ro.xz / hgSizeS);\n      SConf ();\n      u = cMidS + tOff.xz;\n      SBConf (PixToHex (u / hgSizeB), u);\n      vn = SObjNf (ro);\n      col4 = SObjCol (ro, vf);\n    } else {\n      vn = FlyerNf (ro);\n      col4 = FlyerCol ();\n    }\n    if (col4.a >= 0.) {\n      if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      isLit = true;\n    } else  if (col4.a == -1.) {\n      col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    } else if (col4.a == -2.) {\n      col = mix (col4.rgb, 0.8 * SkyCol (reflect (rd, vn)), 0.8);\n    }\n  } else {\n    col = SkyCol (rd);\n  }\n  if (isLit) {\n    isSh = true;\n    sh = FlyerSShadow (ro + 0.01 * vn, sunDir);\n    if (withTrees) sh = min (sh, SObjSShadow (ro + 0.01 * vn, sunDir));\n    col = col4.rgb * (0.3 + 0.1 * max (- dot (sunDir, vn), 0.) +\n       0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  }\n  if (reflFac < 1.) col = mix (mix (vec3 (0., 0.1, 0.), vec3 (0.08, 0.08, 0.1),\n     smoothstep (0.45, 0.55, Noisefv2 (128. * (roo + dstWat * rdo).xz))), reflFac * col,\n     1. - 0.95 * pow (max (dot (- rdo, vnw), 0.), 1.5));\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrkPos (float t)\n{\n  return vec3 (EvalPPos (t), 0.).xzy;\n}\n\nvoid FlyerPM (float t)\n{\n  vec3 vel, acc, va, flVd, fp, fpF, fpB;\n  vec2 cs;\n  float oRl, dt;\n  dt = 0.2;\n  fp = TrkPos (t);\n  flyerPos = fp;\n  flyerPos.y += 0.5 + 0.6 * (1. + sin (0.1 * pi * tCur));\n  fpF = TrkPos (t + dt);\n  fpB = TrkPos (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  acc = (fpF - 2. * fp + fpB) / (dt * dt);\n  va = cross (acc, vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = 0.07 * length (va) * Ssign (va.y);\n  oRl += 0.02 * pi * sin (1. * pi * t);\n  oRl = smoothstep (0.01, 0.03, abs (oRl)) * oRl;\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flyerMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\n#define N_WIN  2\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float el, az, zmFac, asp, sr, t;\n  int vuId, regId;\n  bool sWin;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 3600.) + 30. * floor (dateCur.w / 3600.) + 20.;\n  asp = canvas.x / canvas.y;\n  sWin = true;\n  if (sWin) {\n    mSize = (1./5.) * vec2 (asp, 1.);\n    mMid[0] = (1. - mSize.y) * vec2 (asp, -1.);\n    mMid[1] = (1. - mSize.y) * vec2 (asp, 1.);\n    for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  }\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    if (sWin) {\n      for (int k = 0; k < N_WIN; k ++) {\n        msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n        if (Maxv2 (abs (msw)) < mSize.y) {\n          regId = k + 1;\n          msw /= 2. * mSize.y;\n          break;\n        }\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0.) {\n        uv = (uv - mMid[k]) / mSize.y;\n        vuId = k + 1;\n        break;\n      }\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  withTrees = true;\n  hgSizeB = 16.;\n  hgSizeS = 1.;\n  baseHt = 0.;\n  baseWd = 1.8;\n  SetPath ();\n  trVel = 0.3;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += 0.5 * pi * msw.y;\n  }\n  t = tCur * trVel;\n  FlyerPM (t);\n  if (vuId <= 1 && length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.01,\n     fract (tCur / 60.))) vuId = 1 - vuId;\n  if (vuId == 0 || vuId == 1) {\n    ro.xz = EvalPPos (t + sign (float (vuId) - 0.5) * 4. * trVel);\n    ro.x += 0.01;\n    ro.y = (vuId == 0) ? 2. : 2.5;\n    vd = normalize (flyerPos - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi - 0.1 * pi * ((vuId == 0) ? 1. : -1.);\n    el += asin (vd.y);\n    el = clamp (el, -0.3 * pi, 0.15 * pi);\n    zmFac = 2.5;\n    dstFar = 300.;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 60., (-3. * sqrt3 + (2. / tLen) * t) * hgSizeB);\n    ro.xz = Rot2D (ro.xz, - pi / 3.);\n    ro.xz += 0.01;\n    ro.x += 1.6 * hgSizeB;\n    vd = normalize (flyerPos - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 3.;\n    if (mPtr.z > 0. && vuId == regId) zmFac = max (30. + 60. * msw.y, zmFac);\n    dstFar = 200.;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 0.7, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 3.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (sWin) {\n    for (int k = 0; k < N_WIN; k ++) {\n      if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n  Previous shaders using grid-based raymarching (chronological order, with\n  improving algorithms -- may have missed one or two):\n\n  \"Gotham City\"                     (XljXR3)     \"Panspermia Incoming\"             (tlcXD7)\n  \"Garage\"                          (Ms33Dj)     \"Live Assembly Instructions\"      (WlcSD2)\n  \"Pannini Flies Gotham\"            (4s3XzN)     \"Paper Rolls\"                     (WlKSRd)\n  \"Canal City\"                      (lsdXzM)     \"Love Is In The Air\"              (3dsyWB)\n  \"Thomas X3\"                       (ldtXD8)     \"Invasion Of The Covoids\"         (WdScD1)\n  \"Complex Tunnels\"                 (4dtXW4)     \"Library Lost and Found\"          (tdlBzH)\n  \"Express Train\"                   (MsdSDM)     \"Percolation\"                     (tlfcDn)\n  \"Visible Clock 2\"                 (ldtXRS)     \"Desert Reflections\"              (WtXyRB)\n  \"Dux\"                             (MlcSRn)     \"Cradles of Newton\"               (tlfcR2)\n  \"Fast Fish\"                       (Ml3XWH)     \"Bugs in the Shrubs\"              (wlScWy)\n  \"Urban Growth\"                    (XdXcRM)     \"Truchet Waves\"                   (3tScDc)\n  \"Deep Dive\"                       (4dXfD4)     \"Truchet Balls\"                   (tlXBW4)\n  \"Closely Watched Dolphins\"        (MdlfRl)     \"Edible Edifices\"                 (3ljBWt)\n  \"Hex Ducks\"                       (XsfBDj)     \"Underground Trains\"              (tsKyzw)\n  \"Island Flight\"                   (XdBBRR)     \"Truchet Passages\"                (WdKcWd)\n  \"Arctic Patrol\"                   (lsBfzy)     \"Desert Reflections 2\"            (wdtBDN)\n  \"Font3d\"                          (ltsyRr)     \"Desert Ducks\"                    (tdyBRD)\n  \"Lorem Ipsum\"                     (XlXyR8)     \"Mountain Lake with Tower\"        (3tdcWj)\n  \"Historical Text\"                 (4tXcRH)     \"Metallic Tubeworms\"              (3ltfzM)\n  \"Font Clock\"                      (MlscR8)     \"Truchetted Menger\"               (3lcBDl)\n  \"Alphaville\"                      (XtfczN)     \"Flying Bathtubs\"                 (Ndl3Ds)\n  \"Alphawall\"                       (MlXyWf)     \"Antarctic Flag\"                  (sdlSRl)\n  \"Active Flowers\"                  (4lXfWH)     \"Chateaux... v2\"                  (fsjXWG)\n  \"Buoyant Balls\"                   (MtsBW8)     \"Urban Smog\"                      (NsdGDN)\n  \"Endless Engines\"                 (ltffzB)     \"Vines at Night 2\"                (sdcGWB)\n  \"Franky and the Drakettes\"        (ltfBzf)     \"Balls Falling\"                   (NsKGR3)\n  \"Books and Stairs 2\"              (MtsfRl)     \"Spherical Metropolis\"            (ssG3W3)\n  \"Into the Woods\"                  (Mddczn)     \"Falling Random Numbers\"          (7stSWf)\n  \"Blob Zoo\"                        (4sdcWN)     \"Vessel Climbing\"                 (NdGXDD)\n  \"Hexpo\"                           (lsdcD7)     \"Wind Farm\"                       (Ntd3R2)\n  \"Alphapolis\"                      (4scyDj)     \"Helicopter Squadron\"             (flyGzD)\n  \"Iced Cake\"                       (4dGczw)     \"Greek Variants\"                  (ftVGDy)\n  \"Book of the Woods\"               (XsVyRw)     \"Forkscape\"                       (fttSR8)\n  \"Asteroid Field\"                  (4dGcDh)     \"Gold Edifices\"                   (NldSzM)\n  \"Big SETI\"                        (XsVcDW)     \"Mausolea\"                        (ftcSWS)\n  \"Falling Stars\"                   (lsVyz3)     \"Dynamic Block Grid\"              (sdsBDH)\n  \"Losing Focus\"                    (4d3fRM)     \"Drive the Mapper\"                (7dsBW2)\n  \"Ozymandias Redux\"                (lscBRB)     \"Losing Focus 2\"                  (sdSBzc)\n  \"Time Released\"                   (MdVBDK)     \"Random Slabs\"                    (7sKyWh)\n  \"Tux and Pals\"                    (XlyyRR)     \"Reading Room\"                    (fs3fzn)\n  \"Endless Penguins\"                (MlVyzR)     \"Ultimate Library 2\"              (flKyDt)\n  \"Penguins Can't Fly\"              (ltVyzh)     \"Martian Farming\"                 (ft3fWB)\n  \"Train Ride 2\"                    (XlVczW)     \"Hilbertian Saltation\"            (NtVfDh)\n  \"Fibonacci's Fugu\"                (Mltfzf)     \"Looping Hilbertian Saltation\"    (DdXGWn)\n  \"Fugu Watching\"                   (MtyfRW)     \"Generalized Truchet Path\"        (mdXGRf)\n  \"Knit\"                            (tsBSDz)     \"Twisted Passage\"                 (DdX3Rl)\n  \"Ride the Breeze\"                 (WdBXzG)     \"Truchet Nets\"                    (msj3RR)\n  \"Waterworld City\"                 (wlsGDn)     \"Truchet's Train\"                 (dd2GRy)\n  \"Palace on the Hill\"              (Wlj3DD)     \"Forest Train Ride\"               (csjGDd)\n  \"Stairs to Nowhere\"               (wtB3R3)     \"Monorail\"                        (cdfSzl)\n  \"Night of the Penguins\"           (ttlSRr)     \"Palladian Schneekugel\"           (mtf3zl)\n  \"Flying the Twisted Forest\"       (WtfXRS)     \"Dynamic Block Grid 2\"            (ctXSD2)\n  \"Chocolate Buttons\"               (3tlXWs)     \"Mriya Over Metropolis\"           (ct2SR1)\n  \"Cookies\"                         (tlBSzR)     \"Monorail 2\"                      (msc3zn)\n  \"Cupcakes\"                        (3lBSRm)     \"Falling Chips\"                   (DstGDr)\n  \"Vines at Night\"                  (WtBSD1)     \"Mini Metropolis\"                 (msc3W2)\n  \"Cookie Waves\"                    (wlSSWy)     \"Snapping Rockworms\"              (csGGWR)\n  \"Leaping Snakes 2\"                (3lBXWV)     \"Barque Fleet\"                    (mdKGzd)\n  \"Submerging Tower\"                (wdcGWr)     \"Desert Reflections 3\"            (msVXzz)\n  \"Moon Flight\"                     (tdVGWw)     \"Reflecting Dynamic Block Grid\"   (mtGGzh)\n  \"Engine Album\"                    (WsyGRK)     \"Falling Polyhedra\"               (DtKGDm)\n  \"Undersea Life\"                   (td3Szj)     \"Hexagonally Discretized Waves\"   (dlKGRV)\n  \"Dynamic Space Rocks\"             (WsGSzt)     \"Grid-Surfing Balls\"              (mlVGWy)\n  \"Trux in Space\"                   (tsVSW3)     \"Wind Walker Herd\"                (cl3SW7)\n  \"Planet Reboot 2\"                 (Wtc3Rf)     \"Truchet Path Journey\"            (mdXyRB)\n  \"Chateaux..\"                      (Wtd3Df)     \"Biplanes in the Badlands 2\"      (cdsBDX)\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtSczz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[2907, 2907, 2928, 2928, 2951], [2953, 2953, 2979, 3007, 3995], [3997, 3997, 4018, 4018, 4664], [4666, 4666, 4699, 4699, 5415], [5417, 5417, 5434, 5434, 6279], [6281, 6281, 6306, 6306, 6960], [6962, 6962, 6986, 7026, 8870], [8872, 8872, 8907, 8907, 9093], [9095, 9095, 9118, 9118, 9370], [9372, 9372, 9390, 9390, 10327], [10329, 10329, 10368, 10368, 10613], [10615, 10615, 10630, 10630, 11339], [11341, 11341, 11364, 11364, 11563], [11565, 11565, 11588, 11588, 12174], [12176, 12176, 12210, 12210, 13379], [13381, 13381, 13403, 13403, 13659], [13661, 13661, 13676, 13676, 13881], [13883, 13883, 13917, 13917, 14200], [14202, 14202, 14225, 14225, 14799], [14801, 14801, 14835, 14835, 16123], [16125, 16125, 16147, 16147, 16403], [16405, 16405, 16443, 16443, 16979], [16981, 16981, 17004, 17004, 17606], [17608, 17608, 17639, 17639, 17887], [17889, 17889, 17937, 17937, 18841], [18843, 18843, 18880, 18880, 19209], [19211, 19211, 19234, 19234, 19398], [19400, 19400, 19435, 19435, 22214], [22216, 22216, 22239, 22239, 22279], [22281, 22281, 22305, 22305, 22980], [23000, 23000, 23056, 23056, 26341], [26343, 26343, 26389, 26389, 26436], [26438, 26438, 26471, 26471, 26498], [26500, 26500, 26542, 26542, 26593], [26595, 26595, 26638, 26638, 26702], [26704, 26704, 26761, 26761, 26837], [26839, 26839, 26894, 26894, 27160], [27162, 27162, 27186, 27186, 27416], [27418, 27418, 27442, 27442, 27502], [27504, 27504, 27527, 27527, 27565], [27567, 27567, 27589, 27589, 27616], [27618, 27618, 27640, 27640, 27667], [27669, 27669, 27691, 27691, 27729], [27731, 27731, 27753, 27753, 27791], [27793, 27793, 27838, 27838, 27930], [27932, 27932, 27977, 27977, 28015], [28017, 28017, 28074, 28074, 28157], [28159, 28159, 28195, 28195, 28401], [28403, 28403, 28433, 28433, 28546], [28548, 28548, 28579, 28579, 28643], [28677, 28677, 28701, 28701, 28761], [28763, 28763, 28787, 28787, 28899], [28901, 28901, 28925, 28925, 28988], [28990, 28990, 29014, 29014, 29157], [29159, 29159, 29184, 29184, 29368], [29370, 29370, 29395, 29395, 29620], [29622, 29622, 29647, 29647, 29984], [29986, 29986, 30007, 30007, 30162], [30164, 30164, 30185, 30185, 30340], [30342, 30342, 30371, 30371, 30583], [30585, 30585, 30624, 30624, 30876]], "test": "untested"}
{"id": "mlSyRz", "name": "paradoxical shape", "author": "FabriceNeyret2", "description": "mouse controls camera\ninspiration: https://twitter.com/gunsnrosesgirl3/status/1688168567210987520\nA mirror facing us would also display the other shape: https://trendland.com/troika-squaring-the-circle/", "tags": ["short", "reproduction"], "likes": 27, "viewed": 264, "published": 3, "date": "1691397597", "time_retrieved": "2024-07-30T17:40:32.843705", "image_code": "#define rot(a)    mat2(cos(a+vec4(0,11,33,0)))                  // rotation\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,a,r,z;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -2.*R.y) - R),                // ray direction\n          p = vec3(0,0,10), P,q,                                // marching point along ray \n          C = iMouse.z > 0. ? 8.*iMouse.xyz/R -4.               // camera control\n                            : vec3(.5*iTime,0,0);               // demo mode\n                         // : 3.* cos(.3*iTime + vec3(0,11,0));\n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )              // march scene\n        q = p, \n        q.yz *= rot(-C.y),                                      // rotations\n        q.xz *= rot(-C.x),\n        r = length(q.xy),\n        a = max( abs(q).x, abs(q).y ),                          // z: z-profile such that proj1=square & proj2=circle :\n        z = 10. - 20. / ( 1. + r/a ),                           // → z.CS/max(|C|,|S|) = (20-z).CS , view2 = (0,0,20)-view1\n        t = length( vec2( a - .2*(10.-q.z) ,                    //          pyramid from viewpoint 1\n                       // r - .2*(10.+q.z) ,                    // equivalent: cone from viewpoint 2\n                          q.z - z                               // distance to z-profile \n                  )     ) -.1, \n        p += .5*t*D;                                            // step forward = dist to obj  \n    \n   O *= O*O*O*1.5;                                              // color scheme \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlSyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 113, 113, 1538]], "test": "untested"}
{"id": "dtlyWl", "name": "The Kiss", "author": "A_Toaster", "description": "Inspired by Rene Magritte's painting of the same title.", "tags": ["clouds", "fbm", "sky", "painting", "stars", "bird", "svg", "reproduction", "magritte"], "likes": 12, "viewed": 224, "published": 3, "date": "1691371534", "time_retrieved": "2024-07-30T17:40:33.790175", "image_code": "#define WAVE_ITER_MARCH 12\n#define WAVE_ITER_NORM 40\n\n\n\nconst float drag_mult = 0.8;\n\n\nconst float fog_density = 0.001;\nconst float fog_falloff = 0.3;\nconst float atmo_density = 0.0005;\nconst float atmo_falloff = 0.5;\n\nconst vec3 moon_dir = normalize(vec3(0., 1., -0.4));\nconst vec3 moon_col =  vec3(0.20, 0.2, 0.2);\nconst vec3 sun_col =  vec3(4., 7., 12.);\n\nconst vec3 water_col = vec3(0.01, 0.12, 0.2);\n\nvec2 hash_pos( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0;\n    float amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n\n// Calculates wave value and its derivative, \n// for the wave direction, position in space, wave frequency and time\nvec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\n      float x = dot(direction, position) * frequency + timeshift;\n      float wave = exp(sin(x) * 2. - 2.0);\n      float dx = wave * cos(x);\n      return vec2(wave, -dx);\n}\n\nfloat ocean(vec2 p, int iter) {\n    p += vec2(100.0, 100.0);\n    float dir = 0.;\n    float frequency = 0.1; // frequency of the wave, this will change every iteration\n    float timeMultiplier = 1.0; // time multiplier for the wave, this will change every iteration\n    float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n    float value = 0.0; // will store final sum of values\n    for(int i=0; i < iter; i++) {\n        // wave direction vec\n        vec2 d = vec2(sin(dir), cos(dir));\n        // calculate wave data\n        vec2 res = wavedx(p, d, frequency, iTime * timeMultiplier);\n\n        // shift position around according to wave drag and derivative of the wave\n        p += d * res.y * weight * drag_mult;\n\n        // add the results to sums\n        value += res.x * weight;\n\n        // modify next octave parameters\n        weight *= 0.88;\n        frequency *= 1.14;\n        timeMultiplier *= 1.07;\n\n        // \"randomize\" wave direction\n        dir = fract(dir + 0.33)  * 1. - 0.5;\n    }\n    return value * 0.75;\n}\n\nfloat march_waves(vec3 ro, vec3 rd){ \n   float d = 0.; // distance\n   \n   float h;\n   for(int i = 0; i < 64; ++i) {\n       vec3 p = ro + rd * d;\n       h = p.y - ocean(p.xz, WAVE_ITER_MARCH);\n       \n       d += h;\n       if(h < 1e-5) break;\n   }\n   //d += h / rd.y;\n   return d;\n}\n\nvec3 calc_normal(vec2 p) { \n    float c = ocean(p, WAVE_ITER_NORM);\n    float x = ocean(p + vec2(0.03, 0.), WAVE_ITER_NORM);\n    float y = ocean(p + vec2(0., 0.03), WAVE_ITER_NORM);\n    \n    vec3 cx = vec3(0.03, c - x, 0.);\n    vec3 cy = vec3(0., c - y, 0.03);\n    \n    return -normalize(cross(cx, cy));\n}\n\nvec3 night_sky( in vec3  rgb,      // original color of the pixel\n          in vec3  rayDir )\n{\n    float yi = 1./max(abs(rayDir.y), 0.0021);\n    \n    vec2 cloud_uv = rayDir.xz * yi;\n    \n    float cloud = max(0., noise(cloud_uv * vec2(0.5, 0.75)) + 0.4) * (noise(cloud_uv * vec2(1.25, 2.5)) + 1.) * 0.1;\n    \n    // atmosphere amount\n    float amount = (fog_density/fog_falloff + atmo_density/atmo_falloff) * yi + cloud * 0.2;\n    return mix(moon_col, rgb, exp(-amount));\n}\n\nvec3 day_sky(in vec3 rayDir) {\n    float yi = 1./max(abs(rayDir.y), 0.001);\n    \n    vec2 cloud_uv = rayDir.xz * yi;\n    \n    float cloud = max(0., noise(cloud_uv * vec2(0.5, 0.75)) + 0.4) * (noise(cloud_uv * vec2(1.25, 2.5)) + 1.) * 0.1;\n    \n    // atmosphere amount\n    float amount = (fog_density/fog_falloff + atmo_density/atmo_falloff) * yi + cloud * 0.02;\n    return mix(sun_col, vec3(0.), exp(-amount));\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float dist,     // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float fogAmount = (fog_density/fog_falloff) * exp(-rayOri.y*fog_falloff) * (1.0-exp( -dist*rayDir.y*fog_falloff ))/rayDir.y;\n    float atmosAmount = (atmo_density/atmo_falloff) * exp(-rayOri.y*atmo_falloff) * (1.0-exp( -dist*rayDir.y*atmo_falloff ))/rayDir.y;\n    float amount = fogAmount + atmosAmount;\n    return mix(moon_col, rgb, exp(-amount));\n}\n\nfloat dot2(vec2 p) {\n    return dot(p, p);\n}\n\nfloat sdStar(vec2 p) {\n    const float h = 0.5;\n    float k = 0.5*(h+1.0/h);\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :\n           sqrt(min(dot2(p-vec2(0,h)),\n                    dot2(p-vec2(1,0))));\n}\n\nvec3 star_layer(vec2 uv, float t) {\n    vec2 idx = floor(uv);\n    vec2 local_pos = fract(uv);\n    \n    vec2 star_pos = hash_pos(idx);\n    vec2 brightness_twinkle = hash_pos(idx + vec2(123., 456.));\n    float star_brightness = fract(brightness_twinkle.x);\n    \n    float twinkle_offset = brightness_twinkle.y;\n    \n    star_brightness *= 0.75 + (0.25 * sin(t + twinkle_offset) * sin((t + twinkle_offset) * 2.76));\n    \n    vec2 offset = star_pos - local_pos;\n    float d = sdStar(offset * 20.) * star_brightness;\n    float star = smoothstep(0., 0.2, -d);\n    \n    vec3 base_col = mix(vec3(1., 0.1, 0.), vec3(2., 1., 0.5), star_brightness);\n    \n    return vec3(base_col * star);\n}\n\n\nvec3 stars(vec2 uv, float t) {\n    return star_layer(uv * 10., t * 2.) \n        + 0.5 * star_layer(uv * 20. + vec2(24., 57.), t * 3.)\n        + 0.3 * star_layer(uv * 50. + vec2(74., 92.), t * 5.);\n\n}\n\nvec3 night_scene(vec2 uv, float max_y) {\n    vec3 col;\n    vec3 rd = normalize(vec3(uv.x, uv.y + max_y * 0.35, 2.));\n    vec3 ro = vec3(0., 5., 0.);\n    \n    // ray goes up, will never hit ocean.\n    if(rd.y > 0.){\n        col = stars(uv, iTime);\n        col = night_sky(col, rd);\n    } else {\n        float dist = march_waves(ro, rd);\n        vec3 hit_pt = ro + rd * dist;\n        float roughness = smoothstep(0., 20., ocean(hit_pt.xz, 40));\n        vec3 norm = calc_normal(hit_pt.xz);\n        float fresnel = pow(max(dot(norm, rd), roughness), 0.2);\n        \n        vec3 reflection_dir = reflect(rd, norm);\n        if(reflection_dir.y < 0.) {\n            fresnel *= 0.25;\n            reflection_dir.y *= -1.;\n        }\n        vec3 reflection = night_sky(vec3(0.), reflection_dir);\n        reflection += moon_col * pow(max(dot(reflection_dir, moon_dir), 0.), 3.);\n        \n        \n        float ndotl = clamp(dot(norm, moon_dir), 0., 1.);\n        vec3 scatter = ndotl * moon_col * mix(water_col, vec3(1.), roughness);\n        \n        col = mix(reflection, scatter, fresnel);\n        \n        col = applyFog(col, clamp(-1. / rd.y, 0.001, 1000.), ro, rd);\n    }    \n    return col;\n}\n\n\nconst float cloudscale = 8.;\nconst float speed = 0.03;\nconst float clouddark = 0.6;\nconst float cloudlight = 0.4;\nconst float cloudcover = -0.4;\nconst float cloudalpha = 5.0;\nconst float skytint = 0.1;\n\nvec3 clouds(vec2 uv, float time, vec3 skycolor) {\n    vec2 uv2 = uv;\n    \n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv2 *= cloudscale;\n    uv2 -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv2 ));\n        uv2 = m*uv2 + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv2 = uv;\n\tuv2 *= cloudscale;\n    uv2 -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv2 );\n        uv2 = m*uv2 + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    uv2 = uv;\n\tuv2 *= cloudscale*2.0;\n    uv2 -= q - time * 2.;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv2 );\n        uv2 = m*uv2 + time * 2.;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    uv2 = uv;\n\tuv2 *= cloudscale*3.0;\n    uv2 -= q - time * 3.;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv2 ));\n        uv2 = m*uv2 + time * 3.;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 cloudcolor = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    return mix(skycolor, clamp(skytint * skycolor + cloudcolor, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n}\n\nvec3 day_scene(vec2 uv, float max_y, float t) {\n    vec3 rd = normalize(vec3(uv.x, uv.y + max_y * 0.35, 2.));\n    vec3 sky = day_sky(rd);\n    \n    // scale the clouds so they move slower closer to the horizon\n    vec2 cloud_uv = uv * vec2(0.3, 1.);\n    cloud_uv.x *= (cloud_uv.y - 1.);\n    return clouds(cloud_uv, t * 0.01 + 50., day_sky(rd));\n}\n\n// non-constant zero\n#define ZERO min(0,iFrame)\n\n// SVG Shader generated with https://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14\n\nconst float border = 0.002;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\t\n\treturn 3;\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\t//horner's method\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\t\n\tif(all(lessThan(uv,max(max(p0,p1),p2)+border)) && all(greaterThan(uv,min(min(p0,p1),p2)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint quadratic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\n\tfloat qu = (p0.y - 2. * p1.y + p2.y);\n\tfloat li = (-2. * p0.y + 2. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec2 roots = vec2(1e38);\n\tint n_roots = solve_quadric(vec2(co/qu,li/qu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\tfloat x_pos = p0.x - 2. * p1.x + p2.x;\n\t\t\tx_pos = x_pos * roots[i] + -2. * p0.x + 2. * p1.x;\n\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\tif(x_pos > uv.x){\n\t\t\t\tn_ints++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\t\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    \telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat path0_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[162] p=vec2[](vec2(-0.35495,0.0459062),\n\t                   vec2(-0.35495,0.0459062),\n\t                   vec2(-0.347492,0.0525652),\n\t                   vec2(-0.326983,0.0570933),\n\t                   vec2(-0.306473,0.0616215),\n\t                   vec2(-0.269981,0.0522988),\n\t                   vec2(-0.258261,0.0525652),\n\t                   vec2(-0.246541,0.0528316),\n\t                   vec2(-0.175955,0.0570933),\n\t                   vec2(-0.129342,0.0256627),\n\t                   vec2(-0.0827289,-0.005768),\n\t                   vec2(-0.0787335,-0.0148243),\n\t                   vec2(-0.0787335,-0.0148243),\n\t                   vec2(-0.0787335,-0.0148243),\n\t                   vec2(-0.0819298,-0.0065671),\n\t                   vec2(-0.043041,0.0672151),\n\t                   vec2(-0.0041522,0.140997),\n\t                   vec2(0.0390683,0.164218),\n\t                   vec2(0.0742863,0.17408),\n\t                   vec2(0.109504,0.183941),\n\t                   vec2(0.14923,0.193238),\n\t                   vec2(0.173179,0.196619),\n\t                   vec2(0.197127,0.2),\n\t                   vec2(0.202762,0.196619),\n\t                   vec2(0.209242,0.196337),\n\t                   vec2(0.215722,0.196056),\n\t                   vec2(0.227837,0.199155),\n\t                   vec2(0.227837,0.199155),\n\t                   vec2(0.227837,0.199155),\n\t                   vec2(0.230654,0.191829),\n\t                   vec2(0.219948,0.186758),\n\t                   vec2(0.209242,0.181687),\n\t                   vec2(0.219103,0.179996),\n\t                   vec2(0.203325,0.172953),\n\t                   vec2(0.187548,0.165909),\n\t                   vec2(0.18952,0.161683),\n\t                   vec2(0.187266,0.155203),\n\t                   vec2(0.185012,0.148723),\n\t                   vec2(0.181619,0.149106),\n\t                   vec2(0.179323,0.141332),\n\t                   vec2(0.177027,0.133558),\n\t                   vec2(0.173978,0.129777),\n\t                   vec2(0.170033,0.119125),\n\t                   vec2(0.166088,0.108473),\n\t                   vec2(0.157956,0.100811),\n\t                   vec2(0.155845,0.0916192),\n\t                   vec2(0.153734,0.0824279),\n\t                   vec2(0.145564,0.0672452),\n\t                   vec2(0.145564,0.0672452),\n\t                   vec2(0.145564,0.0672452),\n\t                   vec2(0.149278,0.064726),\n\t                   vec2(0.148602,0.0489502),\n\t                   vec2(0.147926,0.0331745),\n\t                   vec2(0.139136,0.023709),\n\t                   vec2(0.139587,0.0203285),\n\t                   vec2(0.140038,0.016948),\n\t                   vec2(0.142742,0.00770787),\n\t                   vec2(0.140939,-0.000180023),\n\t                   vec2(0.139136,-0.00806791),\n\t                   vec2(0.13801,-0.0073918),\n\t                   vec2(0.138686,-0.0112231),\n\t                   vec2(0.139362,-0.0150543),\n\t                   vec2(0.139124,-0.0220527),\n\t                   vec2(0.139124,-0.0220527),\n\t                   vec2(0.139124,-0.0220527),\n\t                   vec2(0.141212,-0.0268884),\n\t                   vec2(0.140553,-0.0368895),\n\t                   vec2(0.139894,-0.0468906),\n\t                   vec2(0.138685,-0.0511768),\n\t                   vec2(0.138685,-0.0511768),\n\t                   vec2(0.138685,-0.0511768),\n\t                   vec2(0.18054,-0.062794),\n\t                   vec2(0.191242,-0.0662382),\n\t                   vec2(0.201944,-0.0696824),\n\t                   vec2(0.219518,-0.0751941),\n\t                   vec2(0.279288,-0.0722574),\n\t                   vec2(0.339058,-0.0693207),\n\t                   vec2(0.352014,-0.0789945),\n\t                   vec2(0.352014,-0.0789945),\n\t                   vec2(0.352014,-0.0789945),\n\t                   vec2(0.35495,-0.0834859),\n\t                   vec2(0.348732,-0.0886682),\n\t                   vec2(0.342513,-0.0938506),\n\t                   vec2(0.343031,-0.0917777),\n\t                   vec2(0.343031,-0.0917777),\n\t                   vec2(0.343031,-0.0917777),\n\t                   vec2(0.342858,-0.0964418),\n\t                   vec2(0.338021,-0.100588),\n\t                   vec2(0.333185,-0.104734),\n\t                   vec2(0.310181,-0.10979),\n\t                   vec2(0.308752,-0.117577),\n\t                   vec2(0.307324,-0.125364),\n\t                   vec2(0.313396,-0.127864),\n\t                   vec2(0.31804,-0.134722),\n\t                   vec2(0.322683,-0.14158),\n\t                   vec2(0.321897,-0.14158),\n\t                   vec2(0.320826,-0.142724),\n\t                   vec2(0.319754,-0.143867),\n\t                   vec2(0.318111,-0.143081),\n\t                   vec2(0.318111,-0.143081),\n\t                   vec2(0.318111,-0.143081),\n\t                   vec2(0.319468,-0.14601),\n\t                   vec2(0.317325,-0.147153),\n\t                   vec2(0.315182,-0.148296),\n\t                   vec2(0.282029,-0.138869),\n\t                   vec2(0.263837,-0.131618),\n\t                   vec2(0.245644,-0.124366),\n\t                   vec2(0.180289,-0.0992132),\n\t                   vec2(0.117571,-0.13448),\n\t                   vec2(0.0548538,-0.169747),\n\t                   vec2(0.023946,-0.192812),\n\t                   vec2(-0.0344535,-0.196406),\n\t                   vec2(-0.092853,-0.2),\n\t                   vec2(-0.121068,-0.182796),\n\t                   vec2(-0.128983,-0.178479),\n\t                   vec2(-0.136897,-0.174162),\n\t                   vec2(-0.135406,-0.174648),\n\t                   vec2(-0.144281,-0.172183),\n\t                   vec2(-0.153155,-0.169718),\n\t                   vec2(-0.167551,-0.164689),\n\t                   vec2(-0.17327,-0.16183),\n\t                   vec2(-0.178989,-0.15897),\n\t                   vec2(-0.179877,-0.159365),\n\t                   vec2(-0.188455,-0.161238),\n\t                   vec2(-0.197033,-0.163112),\n\t                   vec2(-0.200571,-0.16326),\n\t                   vec2(-0.200571,-0.16326),\n\t                   vec2(-0.200571,-0.16326),\n\t                   vec2(-0.201464,-0.161348),\n\t                   vec2(-0.199685,-0.158963),\n\t                   vec2(-0.197906,-0.156578),\n\t                   vec2(-0.198553,-0.157831),\n\t                   vec2(-0.197624,-0.15484),\n\t                   vec2(-0.196694,-0.151848),\n\t                   vec2(-0.193904,-0.150433),\n\t                   vec2(-0.193217,-0.149908),\n\t                   vec2(-0.19253,-0.149382),\n\t                   vec2(-0.191075,-0.148978),\n\t                   vec2(-0.190428,-0.14154),\n\t                   vec2(-0.189781,-0.134102),\n\t                   vec2(-0.189252,-0.128345),\n\t                   vec2(-0.180513,-0.119906),\n\t                   vec2(-0.171773,-0.111468),\n\t                   vec2(-0.170266,-0.110564),\n\t                   vec2(-0.161627,-0.108354),\n\t                   vec2(-0.152988,-0.106144),\n\t                   vec2(-0.152428,-0.106238),\n\t                   vec2(-0.152428,-0.106238),\n\t                   vec2(-0.152428,-0.106238),\n\t                   vec2(-0.166896,-0.0980232),\n\t                   vec2(-0.175565,-0.0851204),\n\t                   vec2(-0.184234,-0.0722176),\n\t                   vec2(-0.212573,-0.0272814),\n\t                   vec2(-0.237097,0.0026865),\n\t                   vec2(-0.241825,0.00846306),\n\t                   vec2(-0.265885,0.048008),\n\t                   vec2(-0.310458,0.0426059),\n\t                   vec2(-0.325515,0.0407811),\n\t                   vec2(-0.349031,0.0434361),\n\t                   vec2(-0.351641,0.0440886),\n\t                   vec2(-0.354251,0.0447412),\n\t                   vec2(-0.35495,0.0459062));\n\n\tivec4[54] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,48),\n\t                        ivec4(48,49,50,51),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,57),\n\t                        ivec4(57,58,59,60),\n\t                        ivec4(60,61,62,63),\n\t                        ivec4(63,64,65,66),\n\t                        ivec4(66,67,68,69),\n\t                        ivec4(69,70,71,72),\n\t                        ivec4(72,73,74,75),\n\t                        ivec4(75,76,77,78),\n\t                        ivec4(78,79,80,81),\n\t                        ivec4(81,82,83,84),\n\t                        ivec4(84,85,86,87),\n\t                        ivec4(87,88,89,90),\n\t                        ivec4(90,91,92,93),\n\t                        ivec4(93,94,95,96),\n\t                        ivec4(96,97,98,99),\n\t                        ivec4(99,100,101,102),\n\t                        ivec4(102,103,104,105),\n\t                        ivec4(105,106,107,108),\n\t                        ivec4(108,109,110,111),\n\t                        ivec4(111,112,113,114),\n\t                        ivec4(114,115,116,117),\n\t                        ivec4(117,118,119,120),\n\t                        ivec4(120,121,122,123),\n\t                        ivec4(123,124,125,126),\n\t                        ivec4(126,127,128,129),\n\t                        ivec4(129,130,131,132),\n\t                        ivec4(132,133,134,135),\n\t                        ivec4(135,136,137,138),\n\t                        ivec4(138,139,140,141),\n\t                        ivec4(141,142,143,144),\n\t                        ivec4(144,145,146,147),\n\t                        ivec4(147,148,149,150),\n\t                        ivec4(150,151,152,153),\n\t                        ivec4(153,154,155,156),\n\t                        ivec4(156,157,158,159),\n\t                        ivec4(159,160,161,0));\n\n\tif(all(lessThan(uv,vec2(0.35495,0.2)+border)) && all(greaterThan(uv,vec2(-0.35495,-0.2)-border))){\n\t\tfor(int i=ZERO;i<54;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\n\nfloat mask(vec2 mask_uv) {\n    // calculate squared distance to curve\n\tfloat dis_sq;\n    if(all(lessThan(mask_uv,vec2(0.35495,0.2)+border)) && all(greaterThan(mask_uv,vec2(-0.35495,-0.2)-border))){\n\t\tdis_sq=min(dis_sq,path0_dis_sq(mask_uv));\n\t}\n\n    // Calculate signed distance\n\tfloat dis=sign(dis_sq)*sqrt(abs(dis_sq));\n    \n    return smoothstep(-border, 0., dis);\n}\n\n\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // calculate centered UV coordinates\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    float max_y = iResolution.y/iResolution.x;\n    uv.y*=max_y;\n\n\n\n\n    vec2 mask_uv = uv - vec2(0., 0.05);\n\n    float mask = mask(mask_uv);\n    \n    vec3 out_col = vec3(0.);\n    \n    if(mask > 0.) {\n        out_col += night_scene(uv, max_y) * mask;\n    }\n    if(mask < 1.) {\n        out_col += day_scene(uv, max_y, iTime) * (1. - mask);\n    }\n    \n    fragColor = vec4(encodeSRGB(out_col), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 406, 431, 431, 533], [535, 535, 556, 556, 669], [671, 671, 697, 697, 1221], [1269, 1269, 1288, 1288, 1452], [1455, 1571, 1649, 1649, 1822], [1824, 1824, 1855, 1855, 2884], [2886, 2886, 2922, 2922, 3167], [3169, 3169, 3195, 3195, 3474], [3476, 3476, 3571, 3571, 3950], [3952, 3952, 3982, 3982, 4365], [4368, 4368, 4609, 4609, 4964], [4966, 4966, 4986, 4986, 5010], [5012, 5012, 5034, 5034, 5273], [5275, 5275, 5310, 5310, 5954], [5957, 5957, 5987, 5987, 6156], [6158, 6158, 6198, 6198, 7344], [7550, 7550, 7599, 7599, 8876], [8878, 8878, 8925, 8925, 9223], [9402, 9523, 9572, 9607, 9787], [9789, 9874, 9917, 9917, 10927], [10929, 10929, 11005, 11024, 11158], [11160, 11160, 11233, 11233, 11713], [11715, 11715, 11796, 11815, 11990], [11992, 11992, 12070, 12070, 12628], [12630, 12653, 12678, 12678, 12697], [12699, 12699, 12746, 12746, 12857], [12859, 12859, 12907, 12907, 13177], [13179, 13179, 13245, 13245, 13720], [13722, 13722, 13793, 13793, 14662], [25162, 25162, 25188, 25231, 25531], [25535, 25535, 25568, 25568, 25736], [25740, 25740, 25794, 25835, 26286]], "test": "untested"}
{"id": "DllcDs", "name": "SDF Writer w/ JFA", "author": "fenix", "description": "Computing a 2D signed distance field per-pixel via jump flood algorithm. Higher paint calls work well for faster update. Interactive-only: use mouse to draw a shape.\n\n* mouse to draw *\n* space to reset *", "tags": ["2d", "mouse", "interactive", "sdf", "flood", "jump", "codegolf", "multipass", "jfa"], "likes": 12, "viewed": 251, "published": 3, "date": "1691368639", "time_retrieved": "2024-07-30T17:40:34.554132", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Following up on my earlier shader that used a poorer algorithm, I wanted to at least\n//  implement the jump flood algorithm as recommended by MysteryPancake. I'm hoping to\n//  come up with a more compelling demonstration for JFA, since the experiece of this\n//  shader is captured with the very simple algorithm here in MysteryPancake's\n//\n//      Drawable SDF - Distance 2D     https://shadertoy.com/view/Dls3RS\n//\n//  There are some much cooler JFA shaders than this one already. I recommend:\n//\n//      Van Damme - Distance           https://shadertoy.com/view/Wl3fWX\n//      JFA Voronoi Video Filter       https://shadertoy.com/view/4sy3W3\n//\n//  Implementation-wise, there's not much to say. Each pixel in buffer A holds the\n//  address of the closest zero-distance pixel in xy.  I spent more time on the init\n//  calculation than the actual JFA step.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O.x = D(T(u).xy, u);\n    \n    O = mix( vec4(1), vec4(.9,.6,.3,0) // iq's standard SDF distance visualization\n\t                     * (1. - exp(-6.*abs(O.x * .002)))\n\t                     * (.8 + .2*cos(O.x * .3)), smoothstep(0., 3.,O.x) );\n                         \n    vec2 c = (vec2(sin(iTime * .3), cos(iTime)) * .45 + .5) * iResolution.xy; // circle center\n    O = mix(O, vec4(1, 1, 0, 1), smoothstep(3., 0., abs(D(c, u) - D(T(c).xy, c)))); // render circle\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//   XY coordinates hold the location of nearest zero-distance (drawn-on) pixel\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution, m = iMouse.xyz;\n    \n    if (max(u.x, u.y) < 1.)\n        O = vec4(0, 0, 0, R.x * R.y); // resolution stored in lower left corner\n    else if (iFrame == 0 || // bootstrap\n        T(vec2(0)).w != R.x * R.y || // detect resolution changes\n        texelFetch(iChannel3,ivec2(32,0),0).x > 0.) // support keyboard \"space\" reset)\n    {\n        vec2 c = (sign(u - .5 * R.xy) * .5 + .5) * R.xy, // closest corner\n             a = vec2(u.x, c.y), // closest top/bottom wall\n             b = vec2(c.x, u.y); // closest side wall\n             \n        O.xy = D(u, a) < D(u, b) ? a : b;\n    }\n    else\n    {\n        // support drawing with mouse\n        O = m.z > 0. && D(m.xy, u) < R.y * .005 ? u.xyyy : T(u);\n        \n        // search nearby cells for new shorter path\n        for (int x = -1; x <= 1; ++x)\n        for (int y = -1; y <= 1; ++y)\n        {\n            vec2 a = T(u + exp2(float(iFrame % 8)) * vec2(x, y)).xy;\n            O.xy = D(u, a) < D(O.xy, u) ? a : O.xy; // when we find a shorter path, update our root\n        }\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0)\n#define D distance", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllcDs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1162, 1162, 1200, 1200, 1668]], "test": "untested"}
{"id": "dllyDs", "name": "Striving Upward", "author": "scry", "description": "Best in fullscreen", "tags": ["2d"], "likes": 6, "viewed": 211, "published": 3, "date": "1691364698", "time_retrieved": "2024-07-30T17:40:35.337039", "image_code": "////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n#define pi acos(-1.)\n#define deg pi/180.\n#define time iTime*pi/10.\n#define R iResolution.xy\n#define ar R.x/R.y\nvec3 cs = vec3(1.,2.,3.);\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvec3 rgb2hsv(vec3 c){vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);float e = 1.0e-10;return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);}vec3 hsv2rgb(vec3 c){vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);}float bitm(vec2 uv,int c) {float h = 5.;float w = 3.;int p = int(pow(2.,w));float line1 = 9591.;uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);float c1 = 0.;float cc = uv.x + uv.y*w;c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);c1 *= step(0.,uv.x)*step(0.,uv.y);c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));return (c1);}vec3 slogo(vec2 uv, float ar_, float size) {size = 240./size;uv.x = 1.-uv.x;vec2 px = vec2(1./3.,1./5.);float ls = 4.1;uv *= 240./5.25/size;ls += 2.;float ul = length(uv);ul = length(vec2(uv.x*0.5,uv.y)-0.5);uv -= 0.4;uv.x *= ar*1.75;uv.y *= 1.04;int s = 29671;int c = 29263;int r = 31469;int y = 23186;uv.x= 5.-uv.x;float b = bitm(uv,s);uv.x -= 1./3.*4.;b += bitm(uv,c);uv.x -= 1./3.*4.;b += bitm(uv,r);uv.x -= 1./3.*4.;b += bitm(uv,y);float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));b = clamp(b,0.,1.);vec3 l = hsv2rgb(vec3(b+iTime/40.,0.1,rr-b*1.9))*rr;l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);return vec3(l);}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = uv;\n    vec3 col = vec3(0.);\n    uv -= 0.5;\n    uv.x *= ar;\n    vec2 ov = uv;\n    //uv = log(abs(uv))/sin(length(uv)/pi+time/8.)*0.4+time;\n    uv = vec2((length(uv)),atan(uv.x,uv.y));\n    vec2 cv = uv;\n    uv.x = log(uv.x);\n    //uv *= r2d(deg*45.);\n    //uv *= r2d(deg*45.)*2.;\n    //uv.x += sin(time*8.+uv.y*2.)/100;\n    //uv.x += sin(time*2.+uv.y*2.)/4.;\n    uv /= pi;\n    uv *= 8.;\n    uv.x += time*-1.;\n    //uv.y = abs(uv.y);\n    uv.x -= time/4.;\n    col += smoothstep(0.9,0.,length(ov))*(sin(atan(ov.x,ov.y)+cs+log(cv.x)*2.)*0.2+0.8);\n    col -= smoothstep(0.5,0.,length(ov))*1.2;\n    //uv *= 0.1;\n    //uv *= r2d(deg*45.)*2.;\n    //uv.x += sin(time)*8.;\n    vec2 uv1 = uv;\n    float s = 0.5+floor(sin(uv.x*4.*sin(uv.x*0.4*sin(uv.x*0.02+time*0.1)*0.002))*8.);\n    s = 10.;\n    vec2 f1 = floor(uv*s-0.5);\n    vec2 f2 = floor(uv*s);\n    uv = (fract(uv*s-0.5)-0.5)/10.;\n    uv1 = (fract(uv1*s)-0.5)/10.;\n    //uv += vec2(sin(time+f1.x),cos(time+f1.y))*0.01;\n    //uv1 += vec2(cos(time+f2.y),sin(time+f2.x))*0.01;\n    float bl = smoothstep(0.,0.7,cv.x+0.15);\n    float lv1 = (cos(f1.x/4.+f1.y*4.+time*2.)*0.5+0.5)*0.00;\n    float lv2 = (sin(f2.y/4.+f2.x*4.+time*2.)*0.5+0.5)*0.00;\n    float cv1 = sin(f1.y*9.)*sin(f1.x*8.)*2.;\n    float cv2 = cos(f2.y*9.)*cos(f2.x*9.)*2.;\n    col += smoothstep(0.01,0.,abs(length(uv)-0.02+cv1*0.01)-0.00)*(sin(time*8.+cv1+cs+atan(uv.x,uv.y)))*bl*0.98;\n    col += smoothstep(0.01,0.,abs(length(uv1)-0.02+cv2*0.01)-0.00)*(sin(time*8.+cv2+cs+atan(uv1.x,uv1.y)))*bl*0.98;\n    \n    float os = sin(cv.y*8.*sin(cv.y*1.*sin(cv.y*2.+3.+time*0.25)+time*0.5))+sin(sin(cv.y*90.)*sin(cv.y*88.)+cv.x*63.+time*5.)*0.4;\n    col += clamp(((sin(os+cv.y*2.-cv.x*10.)*0.7+0.5)*0.9+smoothstep(.4,0.,cv.x)*2.)*smoothstep(0.25,0.,cv.x)+smoothstep(0.1,0.,cv.x),0.,3.)*0.6;\n    col = clamp(col, 0., 1.);\n    col += slogo(tv,1.,300./0.5)*(sin(vec3(cs*0.6+tv.x*20.))*0.4+0.6)*0.35;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 302, 302, 351], [352, 352, 373, 373, 672], [672, 672, 693, 693, 846], [846, 846, 873, 873, 1174], [1174, 1174, 1218, 1218, 1836], [1840, 1840, 1895, 1895, 3879]], "test": "untested"}
{"id": "mtscWs", "name": "Noise Fractal Play", "author": "spenceryonce", "description": "Simple noise integration with some fractalness.", "tags": ["fractal", "noise", "math"], "likes": 2, "viewed": 132, "published": 3, "date": "1691363302", "time_retrieved": "2024-07-30T17:40:36.099999", "image_code": "float random (vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(20.830,50.860)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (iResolution.xy - fragCoord * 2.0) /iResolution.xy;\n    \n    float an = 12.0 + sin(iTime*0.1);\n\n    vec3 color = vec3(0.0);\n    color = vec3(length(uv));\n    \n    for(int i =0; i< 12; i++){\n        vec2 a = abs(uv);\n        uv*= mat2(sin(a.x+an), cos(a.x+an), -sin(a.x+an), cos(a.y+an));\n        uv*= mat2(sin(a.x+an), cos(a.x), -sin(a.x), cos(a.y));\n        uv*= mat2(sin(a.y), cos(a.y), -sin(a.y), cos(a.x));\n    }\n    \n    float i = floor(uv.x+sin(iTime));\n    float f = fract(uv.x-cos(iTime));\n    color += mix(random(vec2(i,i)), random(vec2(i+1.0,i+1.0)), smoothstep(0.0,1.0,f));\n    color.r *= 0.8;\n    color.g *= 0.4;\n    color.b *= 0.3+sin(iTime);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtscWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 130], [132, 132, 189, 239, 969]], "test": "untested"}
{"id": "DlscWs", "name": "2d Menger Sponge", "author": "Chick_Chicky", "description": "A small menger sponge shader that uses more iterations as time passes", "tags": ["mengerfractal"], "likes": 3, "viewed": 195, "published": 3, "date": "1691342720", "time_retrieved": "2024-07-30T17:40:36.913823", "image_code": "bool sponge(in vec2 coord, float size, int depth) {\n    for (float i = 0.f; i < float(depth); i++) {\n        if (!(int(coord.x/size*pow(3.f,i))%3!=1||int(coord.y/size*pow(3.f,i))%3!=1)) return false;\n    }\n    return true;\n}\n\nvoid mainImage( out vec4 fragcolor, in vec2 fragcoord ) {\n    vec2 coord = vec2(fragcoord.x,iResolution.y-fragcoord.y);\n    vec2 ncoord = coord/iResolution.xy;\n    float size = min(iResolution.x,iResolution.y);\n    if (coord.x<size&&coord.y<size) {\n        if (sponge(coord,size,min(MAX_ITER,int(iTime*TIME_SCALE))))   \n            fragcolor = COLOR_A;\n        else\n            fragcolor = COLOR_B;\n    } else\n        fragcolor = vec4(0.f,0.f,0.f,1.f);\n}", "image_inputs": [], "common_code": "#define COLOR_A vec4(1.f,1.f,1.f,1.f)\n#define COLOR_B vec4(0.f,0.f,0.f,1.f)\n#define TIME_SCALE 1.f\n#define MAX_ITER 60", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlscWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 283, 283, 680]], "test": "untested"}
{"id": "ddXXzn", "name": "circle blur from natron plugins", "author": "axiomgraph", "description": "natron plugins", "tags": ["blur"], "likes": 4, "viewed": 166, "published": 3, "date": "1691338404", "time_retrieved": "2024-07-30T17:40:37.681770", "image_code": "//                        MM.                          .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                     MM.  .MMMM        MMMMMMM    MMM.  .MM\n//                    MM.  .MMM           MMMMMM     MMM.  .MM\n//                   MM.  .MmM              MMMM      MMM.  .MM\n//                  MM.  .MMM                 MM       MMM.  .MM\n//                 MM.  .MMM                   M        MMM.  .MM\n//                MM.  .MMM                              MMM.  .MM\n//                 MM.  .MMM                            MMM.  .MM\n//                  MM.  .MMM       M                  MMM.  .MM\n//                   MM.  .MMM      MM                MMM.  .MM\n//                    MM.  .MMM     MMM              MMM.  .MM\n//                     MM.  .MMM    MMMM            MMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                        MM.                          .MM\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//\n//\n//\n//\n// Adaptation pour Natron par F. Fernandez\n// Code original : crok_lens_blur Matchbox pour Autodesk Flame\n\n// Adapted to Natron by F.Fernandez\n// Original code : crok_lens_blur Matchbox for Autodesk Flame\n\n\n// setting inputs names and filtering options\n// iChannel0: pass1_result , filter = linear , wrap = clamp\n// BBox: iChannel0\n\n\n// based on https://www.shadertoy.com/view/ldXBzB by luluco250\n\n\n\n\n//uniform vec2 direction;\n\nint SAMPLES = 10; // Samples : \n float amount =2.0; // Amount : ,min=0.0\n float aspect = 1.0; // Aspect : ,min=0.01, max=2.0\n\nint ANGLE_SAMPLES = 45; // samples divide\nint OFFSET_SAMPLES = 6 ; // offset samples\n\n\nfloat degs2rads(float degrees) {\n    return degrees * 0.01745329251994329576923690768489;\n}\n\nvec2 rot2D(float offset, float angle) {\n    angle = degs2rads(angle);\n    return vec2(cos(angle) * offset, sin(angle) * offset);\n}\n\nvec3 circle_blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec2 ps = (1.0 / iResolution.xy) * scale * amount;\n    vec3 col = vec3(0.0);\n    float accum = 0.0;\n\n    for (int a = 0; a < 360; a += 360 / ANGLE_SAMPLES) {\n        for (int o = 0; o < OFFSET_SAMPLES; ++o) {\n\t\t\tcol += texture(sp, uv + ps * rot2D(float(o), float(a))).rgb * float(o * o);\n            accum += float(o * o);\n        }\n    }\n\n    return col / accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  /*\n  if ( aspect > 1.0 )\n    direction.x = (direction.x - 1.0) * 10.0 + 1.0; */\n  vec2 dir = vec2(1.0);\n  dir = vec2(dir.x / aspect, dir.y * aspect);\n  vec2 uv = ( fragCoord.xy / iResolution.xy);\n  vec3 col = circle_blur(iChannel0, uv, dir);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddXXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1777, 1777, 1809, 1809, 1868], [1870, 1870, 1909, 1909, 2000], [2002, 2002, 2055, 2055, 2425], [2427, 2427, 2484, 2566, 2760]], "test": "untested"}
{"id": "DtsyWl", "name": "Colourful smoke", "author": "motus_art", "description": "Colourful waves of smoke based upon an example on GLSL sandbox water turbulence effect by joltz0r and David Hoskins's implementation https://www.shadertoy.com/view/MdlXz8", "tags": ["waves", "smoke", "colour"], "likes": 18, "viewed": 605, "published": 3, "date": "1691333799", "time_retrieved": "2024-07-30T17:40:38.456698", "image_code": "// Colourful waves of smoke based upon an example on \n// GLSL sandbox water turbulence effect by joltz0r and \n// David Hoskins's implementation https://www.shadertoy.com/view/MdlXz8\n#define TAU 6.28318530718\n#define MAX_ITER 8\n\n// cosine based palette, 4 vec3 params\n// By Inigo Quilez https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * .095 + 23.0;\n\t\n    vec2 uv = fragCoord/iResolution.xy;;\n\n    vec2 p = mod(uv*TAU, TAU) - 213.0;\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) {\n\t\tfloat t = time * (1.0 - (3.5 / float(n + 1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0 / length(vec2(p.x / (sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));\n\t}\n    \n\tc /= float(MAX_ITER);\n\tc = 1.17 - pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 10.0));\n    colour *= 1.1;\n    colour = clamp(colour + vec3(0.095), 0.0, 1.0);\n  \n    float palettePhase = abs(sin(uv.x * uv.y + iTime * 0.05)) + iTime * 0.1;\n    vec3 col = palette(palettePhase, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.50, 0.20, 0.25));\n    col *=  colour;\n \n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 328, 400, 400, 443], [446, 446, 503, 503, 1351]], "test": "untested"}
{"id": "mlfczB", "name": "golden glow", "author": "kig", "description": "Glass buoy", "tags": ["3d", "spheremarching"], "likes": 3, "viewed": 75, "published": 3, "date": "1691326580", "time_retrieved": "2024-07-30T17:40:39.221653", "image_code": "\n#define THRESHOLD 0.02\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 30\n\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat noise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n/*\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = ((p.xy+vec2(37.0,17.0)*p.z) + f.xy);\n\tvec2 rg = textureLod( iChannel0, (uv + 0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n*/\n\nfloat map(in vec3 p, in float t)\n{\n\tvec3 q = p + 0.1*vec3(0.2, -2.0, 2.2)*-t;\n\tfloat f;\n    f = 0.500*noise( q ); q = q*2.0;\n    f += 0.295*noise( q ); q = q*2.0;\n    f += 0.205*noise( q ); q = q*2.0;\n    //f += 0.0625*noise( q ); q = q*2.0;\n    //f += 0.03125*noise( q ); q = q*2.0;\n    //f += 0.015625*noise( q );\n\treturn 0.5+0.5*f;\n}\n\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nfloat scene(vec3 p)\n{\n    mat3 mp = rotationXY(vec2(-0.15, 0.25*3.14159)) * rotationXY(vec2(3.14159*0.25-0.8, 0.0));\n    float c = length(max(abs(mp*p*mat3(1.2, 0.1, -0.2, 0.1, 0.7, -0.2, 0.1, 0.1, -0.9) - (-0.4)*-1.*vec3(0.5, .05, 1.15)) - vec3(1.35), 0.0)) - 0.05;\n    float b = min(length(p-vec3(-2.5, -0.8+0.2*sin(3.0*iTime), 0.5))-(1.2+0.*cos(iTime)), (map(p*0.2, iTime*1.1)*-.35+.9+1.0*p.y));\n    return min(c, b);\n}\n\nvec3 normal(vec3 p, float d)\n{\n    mat3 mp = rotationXY(vec2(-0.15, 0.25*3.14159)) * rotationXY(vec2(3.14159*0.25-0.8, 0.0));\n    float c = length(max(abs(mp*p*mat3(1.2, 0.1, -0.2, 0.1, 0.5, -0.2, 0.1, 0.1, -0.9) - (-0.4)*-1.*vec3(0.5, .05, 1.15)) - vec3(1.35), 0.0)) - 0.05;\n\tfloat e = 0.05;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n    vec3 n = vec3(0.0);\n    if (c < 0.1) {\n        vec3 v = mp*p*mat3(1.2, 0.1, -0.2, 0.1, 0.5, -0.2, 0.1, 0.1, -0.9);\n        if ((int(fract(v.z*v.x*1.0) > 0.5) ^ int(fract(v.y*2.) > 0.5)) == 0) {\n           p *= 4.0;\n           n = 0.002*vec3(noise(p), noise(p + vec3(1.0, 0.0, 0.0)), noise(p + vec3(0.0, 1.0, 0.0)));\n        }\n    }\n\treturn normalize(vec3(dx, dy, dz) + n);\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord, int bounces)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n\t\t0.0, // cos(iTime*0.2/0.954929658551372)*4.0, \n\t\t0.0, // sin(iTime/1.1936620731892151)*3.0 - 4.0, \n\t\t-1.0 // sin(iTime*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 1.8, 0.85);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.6, 0.7, 0.70);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.37);\n\tbgCol += vec3(0.7, 0.5, 0.27)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 4.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 32.0) + pow( sp, abs(bgLight.y)*128.0));\n    bgCol += vec3(1.3,1.1,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 1.0); // * map(-nml) * map(-nml*nml.y));\n    float f = 0.0; //sin(iTime+atan(nml.y, nml.x) * 20.0)*sin(-iTime+atan(nml.z*nml.y, nml.x) * 20.0) > 0.0 ? 1.0 : 0.0;\n    if (bounces > 0) {\n      bgCol *= max(0.62, f+pow(0.95*sin(0.5*iTime+45.0*dot(nml, vec3(-0.3, 0.0, 1.0))*max(0.0, bgDiff)), 4.0));\n    } else {\n      bgCol *= 0.72;\n    }\n    bgCol *= (1.0+(nml.y))*0.6+0.5*map(4.0*nml.yzy*(bgDiff), iTime * 1.1)*(1.0-max(0.0, bgDiff));\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tif (iResolution.x < iResolution.y) {\n\t\taspect = vec2(1.0, iResolution.y / iResolution.x);\n\t}\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 d = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(uv*-2.0, -6.5) + d*3.6;\n    vec3 o = vec3(1.0);\n    int bounces = 0;\n    for (int i=0; i<RAY_STEPS; i++) {\n        float dist = scene(p);\n        if (dist < THRESHOLD) {\n            bounces++;\n            vec3 nml = normal(p, dist);\n            mat3 mp = rotationXY(vec2(-0.15, 0.25*3.14159)) * rotationXY(vec2(3.14159*0.25-0.8, 0.0));\n            float c = length(max(abs(mp*p*mat3(1.2, 0.1, -0.2, 0.1, 0.5, -0.2, 0.1, 0.1, -0.9) - (-0.4)*-1.*vec3(0.5, .05, 1.15)) - vec3(1.35), 0.0)) - 0.1;\n            if (c < 0.1) {\n                vec3 v = mp*p*mat3(1.2, 0.1, -0.2, 0.1, 0.5, -0.2, 0.1, 0.1, -0.9);\n                if ((int(fract(v.z*v.x*1.0) > 0.5) ^ int(fract(v.y*2.) > 0.5)) == 0) {\n                  o *= vec3(0.3);\n                }\n            }\n            d = reflect(d, nml);\n            p += (23.0*THRESHOLD) * d;\n        }\n        if (dist > MAX_DISTANCE) {\n            break; \n        }\n        p += dist * d;\n    }\n\tfragColor = vec4( 1.0 - exp(-1.0 * o * shadeBg(-d, fragCoord, bounces)), 1.0 );\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 94, 94, 143], [145, 145, 166, 166, 215], [217, 217, 239, 239, 280], [282, 282, 310, 310, 362], [364, 364, 387, 387, 2534], [2778, 2778, 2812, 2812, 3114], [3117, 3136, 3167, 3177, 3390], [3392, 3392, 3413, 3413, 3814], [4627, 4627, 4680, 4680, 6004]], "test": "untested"}
{"id": "DtXyDN", "name": "Ridged noise colors", "author": "tanczmy", "description": "Random function for perlin noise", "tags": ["perlin", "ridged"], "likes": 3, "viewed": 244, "published": 3, "date": "1691324911", "time_retrieved": "2024-07-30T17:40:39.984613", "image_code": "float random (vec2 st);\nfloat circle(vec2 center, float radius, vec2 uv);\nvec2 randomGradient(vec2 p);\n\nvec2 cubic(vec2 p);\nvec2 quintic(vec2 p);\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.498, 0.498, 0.558);\n    vec3 b = vec3(0.418, 0.500, 0.358);\n    vec3 c = vec3(1.168, 1.000, 1.778);\n    vec3 d = vec3(-0.192, 0.333, 1.478);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv = uv * iResolution.xy / iResolution.y;\n\n    // Normalized mouse position (from 0 to 1)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // Nice oscilation\n    // pow(tan(iTime), 4.0)\n\n    // Make the grid\n    float tiles = 4.8;\n    \n    // Vector rotation - from 0 to 1\n    vec2 gridId = floor(uv * tiles);\n    vec2 gridUv = fract(uv * tiles);\n    \n    vec2 color = gridUv;\n    \n    // Corners of each grid\n    vec2 bl = gridId + vec2(0.0, 0.0);\n    vec2 br = gridId + vec2(1.0, 0.0);\n    vec2 tl = gridId + vec2(0.0, 1.0);\n    vec2 tr = gridId + vec2(1.0, 1.0);\n    \n    // Random gradient for each corner\n    vec2 gradientBl = randomGradient(bl);\n    vec2 gradientBr = randomGradient(br);\n    vec2 gradientTl = randomGradient(tl);\n    vec2 gradientTr = randomGradient(tr);\n    \n    // Distance from current pixel to each corner\n    vec2 distanceBl = gridUv - vec2(0.0, 0.0);\n    vec2 distanceBr = gridUv - vec2(1.0, 0.0);\n    vec2 distanceTl = gridUv - vec2(0.0, 1.0);\n    vec2 distanceTr = gridUv - vec2(1.0, 1.0);\n    \n    // Dot product between distance and the random gradient\n    float dotBl = dot(gradientBl, distanceBl);\n    float dotBr = dot(gradientBr, distanceBr);\n    float dotTl = dot(gradientTl, distanceTl);\n    float dotTr = dot(gradientTr, distanceTr);\n    \n    // Smooth out the grid uvs\n    //gridUv = smoothstep(0.0, 1., gridUv);\n    //gridUv = cubic(gridUv);\n    gridUv = quintic(gridUv);\n    \n    \n    // Mix the colors\n    float b = mix(dotBl, dotBr, gridUv.x);\n    float t = mix(dotTl, dotTr, gridUv.x);\n    float perlin = mix(b, t, gridUv.y);\n  \n    float finalColor = pow(1.0 - abs(perlin), 10.);\n  \n    // Output to screen\n    fragColor = vec4(palette(finalColor + (sin(uv.x + iTime * .1) + sin(uv.y + iTime * .1))), 1.0);\n}\n\n// Random\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))\n        * 43758.5453123);\n}\n\nvec2 randomGradient(vec2 p) {\n  p = p + 0.02;\n  float x = dot(p, vec2(123.4, 234.5));\n  float y = dot(p, vec2(234.5, 345.6));\n  vec2 gradient = vec2(x, y);\n  gradient = sin(gradient);\n  gradient = gradient * 43758.5453;\n\n    \n\n  // part 4.5 - update noise function with time\n  gradient = 0.3 * sin(0.6 * gradient + 0.5 * iTime) + 0.2 * cos(0.4 * gradient + iTime * 0.3);\n  return gradient;\n\n  // gradient = sin(gradient);\n  // return gradient;\n}\n\n// Interpolation\n\nvec2 cubic(vec2 p) {\n  return p * p * (3.0 - p * 2.0);\n}\n\nvec2 quintic(vec2 p) {\n  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 170, 170, 374], [376, 376, 433, 483, 2291], [2304, 2304, 2328, 2328, 2411], [2413, 2413, 2442, 2442, 2858], [2878, 2878, 2898, 2898, 2934], [2936, 2936, 2958, 2958, 3013]], "test": "untested"}
{"id": "mlfyWs", "name": "weather icons", "author": "yasuo", "description": "weather icons", "tags": ["graphicdesign", "cineshader"], "likes": 31, "viewed": 1306, "published": 3, "date": "1691324485", "time_retrieved": "2024-07-30T17:40:40.948037", "image_code": "#define MAX_STEPS 128\n#define MAX_DIST 128.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define deg45 .707\n#define R45(p) (( p + vec2(p.y,-p.x) ) *deg45)\n#define Tri(p,s) max(R45(p).x,max(R45(p).y,B(p,s)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SPEED 200.\n#define ZERO (min(iFrame,0))\n#define WIRE_SIZE 0.01\n#define WIRE_COLOR 0\n#define OBJECT_COLOR 1\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.9;\n    p.y-=size*3.2;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.06;\n    mask = B(p,vec2(size,size+0.01));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segDot(vec2 p){\n    vec2 prevP = p;\n    p*=SkewX(-0.4);\n    float size = 0.03;\n    p.y = abs(p.y)-0.07;\n    float d = B(p,vec2(size));\n    return d;\n}\n\nfloat checkChar(int targetChar, int char){\n    return 1.-abs(sign(float(targetChar) - float(char)));\n}\n\nfloat drawFont(vec2 p, int char){\n    p*=SkewX(-0.4);\n    float d = seg0(p)*checkChar(seg_0,char);\n    d += seg1(p)*checkChar(seg_1,char);\n    d += seg2(p)*checkChar(seg_2,char);\n    d += seg3(p)*checkChar(seg_3,char);\n    d += seg4(p)*checkChar(seg_4,char);\n    d += seg5(p)*checkChar(seg_5,char);\n    d += seg6(p)*checkChar(seg_6,char);\n    d += seg7(p)*checkChar(seg_7,char);\n    d += seg8(p)*checkChar(seg_8,char);\n    d += seg9(p)*checkChar(seg_9,char);\n    \n    return d;\n}\n\nfloat digitNumbers(vec2 p, float n){\n    vec2 prevP = p;\n    p*=0.6;\n    p.y+=sin(iTime*3.+n)*0.02;\n    p*=Rot(radians(sin(iTime*2.+n)*5.));\n    float d = drawFont(p-vec2(-0.35,0.0),int(mod(iTime,9.)));\n    float d2 = drawFont(p-vec2(-0.15,0.0),int(mod(iTime*2.,9.)));\n    d = min(d,d2);\n    d2 = drawFont(p-vec2(0.15,0.0),int(mod(iTime*15.,9.)));\n    d = min(d,d2);\n    d2 = drawFont(p-vec2(0.35,0.0),int(mod(iTime*30.,9.)));\n    d = min(d,d2);\n    d2 = segDot(p);\n    d = min(d,d2);\n    return abs(d)-0.005;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sun(vec2 p){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.16)-0.01;\n    p*=Rot(radians(30.*iTime));\n    p = DF(p,2.0);\n    p-=vec2(0.2);\n    p*=Rot(radians(45.));\n    float d2 = B(p,vec2(0.02,0.06));\n    d = min(d,d2);\n    return d;\n}\n\nfloat cloud(vec2 p, float mask, float dir){\n    vec2 prevP = p;\n    p.x+=iTime*0.2*dir;\n    p.x+=0.6;\n    p.x = mod(p.x, 1.2)-0.6;\n    float d = length(p-vec2(0.04,0.1))-0.16;\n    p.x = abs(p.x)-0.22;\n    float d2 = length(p-vec2(0.0,-0.1))-0.16;\n    d = smin(d,d2,0.16);\n    p = prevP;\n    p.x+=iTime*0.2*dir;\n    p.x+=0.6;\n    p.x = mod(p.x, 1.2)-0.6;\n    d2 = B(p-vec2(0.0,-0.1),vec2(0.22,0.16));\n    d = mix(abs(min(d,d2))-0.01,min(d,d2),mask);\n\n    d = max((abs(prevP.x)-0.45),d);\n\n    return d;\n}\n\nfloat sunAndCloud(vec2 p){\n    vec2 prevP = p;\n    p.x+=0.15;\n    p.y-=0.1;\n    p*= 1.3;\n    float d = sun(p);\n    p = prevP;\n    p.y+=0.1;\n    float d2 = cloud(p,0.0,1.);\n    d = max(-cloud(p,1.,1.),d);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat wind(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(35.*iTime));\n    p.x*=-1.;\n    p = DF(p,2.);\n    p-=0.13;\n    p.y-=0.1;\n    p*=Rot(radians(-26.));\n    float d = Tri(p,vec2(0.1));\n    return abs(d)-0.01;\n}\n\nfloat umbrella(vec2 p, float outline){\n    p*=0.7;\n    p.y+=0.05;\n    vec2 prevP = p;\n    float d = length(p)-0.22;\n    d = max(-p.y,d);\n    p.x = abs(p.x)-0.145;\n    p.y+=0.03;\n    float size = ((0.22/3.)+0.01);\n    float d2 = length(p)-size;\n    d = max(-d2,d);\n    p = prevP;\n    p.y+=0.03;\n    d2 = length(p)-size;\n    d = mix(max(-d2,d),abs(max(-d2,d))-0.005,outline);\n    p = prevP;\n    d2 = B(p-vec2(0,0.05),vec2(0.005,0.2));\n    p.y-=0.135;\n    d2 = max(-(abs(p.y)-0.08),d2);\n    d = min(d,d2);\n    p = prevP;\n    d2 = abs(length(p-vec2(0.04,-0.15))-0.04)-0.01;\n    d2 = max(p.y+0.15,d2);\n    d = min(d,d2);\n    d2 = B(p-vec2(0,-0.13),vec2(0.01,0.02));\n    d = min(d,d2);\n    return d;\n}\n\nfloat rain(vec2 p){\n    vec2 prevP = p;\n    float d = umbrella(p,1.);\n    \n    p*=Rot(radians(20.));\n    p.y+=iTime*0.3;\n    p.x = mod(p.x,0.1)-0.05;\n    p.y=mod(p.y,0.14)-0.07;\n    float d2 = B(p, vec2(0.005,0.04));\n    d2 = max(-prevP.y+0.05,d2);\n    d2 = max(-umbrella(prevP,0.),d2);\n    d = min(d,d2);\n    \n    d = max((abs(prevP.x)-0.45),d);\n    d = max((abs(prevP.y)-0.45),d);\n    \n    return d;\n}\n\nfloat snowman(vec2 p, float outline){\n    vec2 prevP = p;\n    float d = length(p-vec2(0.0,-0.14))-0.24;\n    float d2 = length(p-vec2(0.0,0.14))-0.18;\n    d = min(d,d2);\n    d = mix(d,abs(d)-0.01,outline);\n    p.x = abs(p.x)-0.06;\n    d2 = length(p-vec2(0.0,0.16))-0.02;\n    d = min(d,d2);\n    return d;\n}\n\nfloat snow(vec2 p){\n    vec2 prevP = p;\n    float d = snowman(p,1.);\n    p*=Rot(radians(20.));\n    p.y+=iTime*0.1;\n    p = mod(p,0.14)-0.07;\n    float d2 = length(p)-0.02;\n    d2 = max(-snowman(prevP,0.),d2);\n    d = min(d,d2);\n    \n    d = max((abs(prevP.x)-0.45),d);\n    d = max((abs(prevP.y)-0.45),d);    \n    \n    return d;\n}\n\nfloat thunder(vec2 p){\n    vec2 prevP = p;\n    p.x-=0.01;\n    p.y-=0.15;\n    p.y*=0.5;\n    float d = Tri(p,vec2(0.09));\n    d = max(p.x,d);\n    \n    p = prevP;\n    p.x+=0.01;\n    p.y*=-1.;\n    p.y-=0.15;\n    p.y*=0.5;\n    float d2 = Tri(p,vec2(0.09));\n    d2 = max(-p.x,d2);\n    d = min(d,d2);\n    return abs(d)-0.005;    \n}\n\nfloat thunders(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(20.));\n    p.y+=iTime*0.3;\n    p.x = mod(p.x,0.26)-0.13;\n    p.y = mod(p.y,0.42)-0.21;\n    float d = thunder(p);\n    \n    d = max((abs(prevP.x)-0.45),d);\n    d = max((abs(prevP.y)-0.9),d);       \n    return d;\n}\n\nfloat snowflake(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-30.*iTime));\n    p = DF(p,2.);\n    \n    p-=0.08;\n    \n    p*=0.8;\n    p*=Rot(radians(45.));\n    p.x*=2.;\n    p.y= abs(p.y)-0.05;\n    \n    float d = abs(Tri(p,vec2(0.3)))-0.01;\n    return d;\n}\n\nfloat snowflakes(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(20.));\n    p.y+=iTime*0.3;\n    p.x = mod(p.x,0.4)-0.2;\n    p.y = mod(p.y,0.42)-0.21;\n    float d = snowflake(p);\n    \n    d = max((abs(prevP.x)-0.45),d);\n    d = max((abs(prevP.y)-0.9),d);  \n    \n    return d;\n}\n\nfloat moon(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(-30.));\n    float d = length(p)-0.26;\n    p.y*=0.8;\n    float mask = length(p-vec2(0.12,0.0))-0.18;\n    d = max(-mask,d);\n    return abs(d)-0.01;\n}\n\nfloat moons(vec2 p){\n    vec2 prevP = p;\n    \n    p.x+=iTime*0.3;\n    p.x = mod(p.x,0.7)-0.35;\n    float d = moon(p);\n    \n    d = max((abs(prevP.x)-0.9),d);\n    d = max((abs(prevP.y)-0.45),d);      \n    \n    return d;\n}\n\nfloat arrow(vec2 p){\n    vec2 prevP = p;\n    p*=Rot(radians(90.));\n    p.x*=1.7;\n    p.y-=0.2;\n    float d = Tri(p,vec2(0.4));\n    p.y+=0.25;\n    float d2 = Tri(p,vec2(0.4));\n    d = max(-d2,d);\n    return abs(d)-0.02;\n}\n\nfloat arrows(vec2 p){\n    vec2 prevP = p;\n        \n    p.x-=iTime*0.3;\n    p.x = mod(p.x,0.6)-0.3;\n    float d = arrow(p);\n    \n    d = max((abs(prevP.x)-0.9),d);\n    d = max((abs(prevP.y)-0.45),d);       \n    \n    return d;\n}\n\nfloat temparature(vec2 p){\n    vec2 prevP = p;\n    float d = B(p-vec2(0,0.1),vec2(0.04,0.15));\n    float d2 = length(p-vec2(0,-0.14))-0.12;\n    d = abs(min(d,d2))-0.005;\n    \n    d2 = B(p-vec2(0,0.02),vec2(0.003,0.1));\n    d = min(d,d2);\n    d2 = length(p-vec2(0,-0.14))-0.06;\n    d = min(d,d2);\n    \n    p.x-=0.06;\n    p.y-=iTime*0.05;\n    p.y = mod(p.y,0.04)-0.02;\n    d2 = B(p,vec2(0.02,0.005));\n    p = prevP;\n    p.y-=0.12;\n    d2 = max(abs(p.y)-0.08,d2);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat temparatures(vec2 p){\n    vec2 prevP = p;\n    \n    p.x+=iTime*0.3;\n    p.x = mod(p.x,0.4)-0.2;    \n    \n    float d = temparature(p);\n    \n    d = max((abs(prevP.x)-0.9),d);\n    d = max((abs(prevP.y)-0.45),d);           \n    \n    return d;\n}\n\nvec2 pattern1(vec3 p){\n    vec3 prevP = p;\n    p.y = abs(p.y)-0.5;\n    float d = sdBoxFrame(p, vec3(0.95,0.45,0.5),WIRE_SIZE);\n    \n    vec2 vd = vec2(d,WIRE_COLOR);\n    p = prevP;    \n    \n    float d2 = moons(p.xy-vec2(0.0,0.5));\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd2 = vec2(d2,OBJECT_COLOR);    \n    \n    p.xy-=vec2(0.0,-0.5);\n    p.yz*=Rot(radians(60.*iTime));\n    d2 = arrows(p.xy);\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd3 = vec2(d2,OBJECT_COLOR);\n    \n    return combine(combine(vd,vd2),vd3);\n}\n\nvec2 pattern2(vec3 p){\n    vec3 prevP = p;\n    p.x = abs(p.x)-0.5;\n    float d = sdBoxFrame(p, vec3(0.45,0.95,0.5),WIRE_SIZE);\n    vec2 vd = vec2(d,WIRE_COLOR);\n    p = prevP;\n    \n    float d2 = thunders(p.xy-vec2(0.5,0.0));\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd2 = vec2(d2,OBJECT_COLOR);\n    \n    d2 = snowflakes(p.xy-vec2(-0.5,0.0));\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd3 = vec2(d2,OBJECT_COLOR);\n    \n    return combine(combine(vd,vd2),vd3);\n}\n\nvec2 pattern3(vec3 p){\n    vec3 prevP = p;\n    float d = sdBoxFrame(p-vec3(0,0.5,0), vec3(0.95,0.45,0.5),WIRE_SIZE);\n    p.x = abs(p.x)-0.5;\n    p*= vec3(sign(prevP.x),1,1);\n    float d2 = sdBoxFrame(p-vec3(0,-0.5,0), vec3(0.45,0.45,0.5),WIRE_SIZE);\n    d = min(d,d2);\n    vec2 vd = vec2(d,WIRE_COLOR);\n    \n    d2 = rain(p.xy-vec2(0,-0.5));\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd2 = vec2(d2,OBJECT_COLOR);\n    \n    p = prevP;\n    d2 = temparatures(p.xy-vec2(0,0.5));\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd3 = vec2(d2,OBJECT_COLOR);    \n    \n    return combine(combine(vd,vd2),vd3);\n}\n\nvec2 pattern4(vec3 p, float n){\n    vec3 prevP = p;\n    float d = sdBoxFrame(p-vec3(0,-0.5,0), vec3(0.95,0.45,0.5),WIRE_SIZE);\n    p.x = abs(p.x)-0.5;\n    p*= vec3(sign(prevP.x),1,1);\n    float d2 = sdBoxFrame(p-vec3(0,0.5,0), vec3(0.45,0.45,0.5),WIRE_SIZE);\n    d = min(d,d2);\n    \n    d2 = snow(p.xy-vec2(0,0.5));\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd3 = vec2(d2,OBJECT_COLOR);\n    \n    \n    p = prevP;\n    vec2 vd = vec2(d,WIRE_COLOR);\n    \n    d2 = digitNumbers(p.xy-vec2(0,-0.5),n);\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd2 = vec2(d2,OBJECT_COLOR);\n    \n    return combine(combine(vd,vd2),vd3);\n}\n\nvec2 pattern5(vec3 p, float n){\n    vec3 prevP = p;\n    p.x = abs(p.x)-0.5;\n    p.y = abs(p.y)-0.5;\n    p*= vec3(sign(prevP.x),sign(prevP.y),1);\n    float d = sdBoxFrame(p, vec3(0.45,0.45,0.5),WIRE_SIZE);\n    vec2 vd = vec2(d,WIRE_COLOR);\n    \n    float d2 = sun(p.xy);\n    if(n>=0.8 && n<0.85){\n        d2 = cloud(p.xy,0.0,-1.);\n    } else if(n>=0.85 && n<0.9){\n        d2 = sunAndCloud(p.xy);\n    } else if(n>=0.9 && n<0.95){\n        d2 = wind(p.xy);\n    }\n    d2 = max(abs(p.z)-0.02,d2);\n    vec2 vd2 = vec2(d2,OBJECT_COLOR);\n    \n    return combine(vd,vd2);\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.y-=0.5*iTime;\n    vec2 id = floor(p.xy*0.5);\n    p.z-=3.;\n    p.xy = mod(p.xy,2.0)-1.0;\n    float n = random(id); \n    \n    vec2 res = vec2(10,0.);\n    if(n<0.2){\n        res = pattern1(p);\n    } else if(n>=0.2 && n < 0.4){\n        res = pattern2(p);\n    } else if(n>=0.4 && n < 0.6){\n        res = pattern3(p);\n    } else if(n>=0.6 && n < 0.8){\n        res = pattern4(p,n);\n    } else {\n        res = pattern5(p,n);\n    }\n\n    return res;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd,  int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n        \n        if(i<50){\n            dO.x += dS.x*0.38;\n        } else {\n            dO.x += dS.x;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff;\n    diffCol += col*vec3(1.0,1.0,1.0)*skyDiff;\n    diffCol += col*vec3(0.8)*bounceDiff;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == 0){\n        col = diffuseMaterial(n,rd,p,vec3(0.3));\n    } else {\n        col = diffuseMaterial(n,rd,p,vec3(1.0));\n    }\n    \n    return col;\n}\n\nvec3 ACESFilmic(vec3 x, float a, float b, float c, float d, float e){\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nvec3 cameraAnim(vec3 p){\n\n    float rotX = 0.;\n    float rotY = -10.;\n\n    float frame = mod(iTime,20.0);\n    float time = frame;\n\n    if(frame>=5. && frame<10.){\n        time = getTime(time-5.,0.6);\n\n        rotY = -10.+cubicInOut(time)*-10.;\n        rotX = cubicInOut(time)*-30.;\n    } else if(frame>=10. && frame<15.){\n        time = getTime(time-10.,0.6);\n        \n        rotY = -20.;\n        rotX = -30.+cubicInOut(time)*60.;\n    } else if(frame>=15.){\n        time = getTime(time-15.,0.6);\n\n        rotY = -20.+cubicInOut(time)*10.;\n        rotX = 30.+cubicInOut(time)*-30.;\n    }\n\n    p.xz*=Rot(radians(rotX));\n    p.yz*=Rot(radians(rotY));\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    \n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.5);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro = cameraAnim(ro);\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.);\n    vec2 d = RayMarch(ro, rd, MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    col = ACESFilmic(col,3.,0.03,2.43,0.59,0.14);\n\n    /* // debug icons\n    col = vec3(0.);\n    d.x = temparatures(uv);\n    col = mix(col,vec3(1.),S(d.x,0.0));\n    */\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[830, 888, 931, 931, 1030], [1032, 1032, 1068, 1068, 1110], [1112, 1112, 1135, 1135, 1208], [1211, 1211, 1233, 1233, 1558], [1560, 1560, 1579, 1579, 1729], [1731, 1731, 1750, 1750, 2061], [2063, 2063, 2082, 2082, 2370], [2372, 2372, 2391, 2391, 2686], [2688, 2688, 2707, 2707, 2995], [2997, 2997, 3016, 3016, 3304], [3306, 3306, 3325, 3325, 3595], [3597, 3597, 3616, 3616, 3799], [3802, 3802, 3821, 3821, 4007], [4009, 4009, 4028, 4028, 4298], [4300, 4300, 4321, 4321, 4456], [4458, 4458, 4500, 4500, 4560], [4562, 4562, 4595, 4595, 5041], [5043, 5043, 5079, 5079, 5554], [5556, 5614, 5659, 5659, 5946], [5948, 5948, 5966, 5966, 6193], [6195, 6195, 6238, 6238, 6697], [6699, 6699, 6725, 6725, 6942], [6944, 6944, 6963, 6963, 7159], [7161, 7161, 7199, 7199, 7856], [7858, 7858, 7877, 7877, 8261], [8263, 8263, 8300, 8300, 8567], [8569, 8569, 8588, 8588, 8898], [8900, 8900, 8922, 8922, 9224], [9226, 9226, 9249, 9249, 9500], [9502, 9502, 9526, 9526, 9758], [9760, 9760, 9785, 9785, 10036], [10038, 10038, 10057, 10057, 10244], [10246, 10246, 10266, 10266, 10466], [10468, 10468, 10488, 10488, 10688], [10690, 10690, 10711, 10711, 10916], [10918, 10918, 10944, 10944, 11418], [11420, 11420, 11447, 11447, 11667], [11669, 11669, 11691, 11691, 12181], [12183, 12183, 12205, 12205, 12643], [12645, 12645, 12667, 12667, 13239], [13241, 13241, 13272, 13272, 13852], [13854, 13854, 13885, 13885, 14417], [14419, 14419, 14441, 14441, 14914], [14916, 14916, 14963, 14963, 15314], [15316, 15316, 15340, 15340, 15541], [15543, 15543, 15585, 15585, 15780], [15782, 15782, 15839, 15839, 16326], [16328, 16328, 16387, 16387, 16545], [16547, 16547, 16616, 16616, 16656], [16658, 16658, 16685, 16685, 16769], [16771, 16771, 16810, 16810, 16855], [16857, 16857, 16881, 16881, 17521], [17523, 17523, 17580, 17580, 18406]], "test": "untested"}
{"id": "ddSfzm", "name": "Year of Truchets #050", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\ndont puke, it's truchets...in a warp", "tags": ["warp", "truchet"], "likes": 17, "viewed": 205, "published": 3, "date": "1691321255", "time_retrieved": "2024-07-30T17:40:41.705013", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #050\n    08/06/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    50.\n\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//@iq hue palettes \nvec3 hue(float t){ return .35 + .4*cos(PI2*t*(vec3(1.,.95,.65)+vec3(.05,.5,.95))); }\n\nfloat scale = 4.;\nvoid mainImage( out vec4 fragColor, in vec2 F )\n{\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 vv = uv;\n    uv*=rot(T*.1+(M.x/R.x)*PI);\n\n    float y = .3*sin(T*.5), x = .3*cos(T*.5);\n    if(M.z>0.) {x=0.;y=0.;}\n    \n    uv *= rot(y+(M.y/R.y)*2.);\n    uv = vec2(log(length(uv)), atan(uv.y, uv.x))*.637;//.31825;//1.274;//.637;//.31825;//\n  \n    uv.x+=.35*sin(uv.y*PI+T);\n    uv.x+=T*.5;\n    \n    vec3 clb = hue(uv.x*.2);\n    vec3 cla = vec3(.8);\n    vec3 clx = mix(vec3(.1),vec3(.4),clamp(vv.y+.5,0.,1.));\n    vec3 C = clx;\n\n    float px = fwidth(uv.x)*4.;\n    \n    vec2 id=floor(uv*scale);\n    float ck=mod(id.x+id.y,2.)*2.-1.;\n\n    //mod for long slices\n    vec2 cd=vec2(mod(id.x,1.),mod(id.y,3.))*2.-1.;\n\n    uv=fract(uv*scale)-.5;\n    \n    float hs = hash21(id);\n    if(hs>.5) uv.x=-uv.x;\n    \n    float rd = fract(hs*37.39);\n    \n    vec2 p = length(uv-.5) < length(uv+.5) ? uv-.5 : uv+.5;\n    \n    float d = length(p)-.5;\n    \n    if(rd>.85) d = min(length(uv.x),length(uv.y));\n    //skip section logic\n    if(cd.x>.5 ) d = length(uv.y);\n    if(cd.y>.5 ) d = length(uv.x);\n\n    if(cd.y>.5 && cd.x>.5) {\n        d = 1.;\n    }\n    \n    C = mix(C,C*.45,smoothstep(.05+px,-px,abs(d)-.2));\n    C = mix(C,cla,smoothstep(px,-px,abs(d)-.14));\n    C = mix(C,clb,smoothstep(px,-px,abs(abs(d)-.14)-.075));\n\n    hs=hash21(vv);\n    if(hs<.5) C=mix(clamp(C+(hs*.1),vec3(0),vec3(1)),C,smoothstep(px,-px,abs(d)-.2));\n    // Gamma & Output\n    C = pow(C,vec3(.4545));\n    fragColor = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddSfzm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[375, 375, 399, 399, 457], [458, 458, 476, 476, 520], [522, 542, 560, 560, 626], [646, 646, 695, 695, 2139]], "test": "untested"}
{"id": "mlsczN", "name": "fractal-shader", "author": "notmysql", "description": "fractal", "tags": ["fractal"], "likes": 6, "viewed": 217, "published": 3, "date": "1691296921", "time_retrieved": "2024-07-30T17:40:42.474955", "image_code": "// Squares a given complex number\nvec2 cSquare( in vec2 z ) \n{\n    return vec2(\n            z.x * z.x - z.y * z.y,\n            2.0 * z.x * z.y\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 c = fragCoord/iResolution.x;\n    \n    // Scale [lower is more zoomed in]\n    float scale = 5.0;\n    \n    c *= scale;\n    \n    // Move set into view\n    c += vec2(-3.0,-1.5);\n    \n    // Maximum number of iterations\n    int maxIterations = 256;\n\n\t// Starting point\n\tvec2 Z = vec2(0,0);\n    \n    for(int i = 0; i < maxIterations; i++)\n    {\n        // Z(n+1) = Z(n)^2 + C\n        vec2 oldZ = Z;\n        Z = cSquare(cSquare(oldZ)) + (c/2.0) + (oldZ * sin(iTime/5.0)*2.0);\n        \n        if(dot(Z, Z) > sin(iTime) * 4.0 + 20.0) {\n            // get smooth iters\n            float sn = float(i) - log2(log2(dot(Z,Z))) + 4.0;\n            \n            // multipliers for ( R   G   B ) values\n            vec3 weights = vec3(10.0 + sin(iTime) * 5.0,10.0 + cos(iTime) * 5.0,2.0);\n            \n            fragColor = vec4(vec3(float(sn)/float(maxIterations)) * weights, 1.0);\n            break;\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n    \n    // Output to screen\n    //fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 62, 62, 155], [157, 157, 214, 264, 1319]], "test": "untested"}
{"id": "dtsyWX", "name": "Ridge extraction", "author": "Gegell", "description": "Extracts all ridges from a scalar field (height map) by setting gradient orthogonal to ridge to 0, and the 2nd derivative to be negative.\n\nCan do valley extraction via ridge extraction of the negative scalar field. (see flag in Common tab)", "tags": ["extraction", "scivis", "ridge", "featureextraction"], "likes": 7, "viewed": 185, "published": 3, "date": "1691287730", "time_retrieved": "2024-07-30T17:40:43.269829", "image_code": "#define SOURCE_TEXTURE iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float scale = 2.2;\n    float grid_size = 4.;\n    float grad_zero_eps = 0.01;\n    float eigen_val_neg_eps = 0.01;\n\n    // Compute needed values for ridge extraction\n    vec2 pos = fragCoord / scale;\n    mat2 hessian = hessian(pos, grid_size);\n    vec2 grad = gradient(pos, grid_size);\n    vec2 eigen_val = eigenvalues(hessian);\n    vec2 eigen_vec_2 = eigenvector(hessian, eigen_val.y);\n    \n    // We know that on a ridge the following have to hold:\n    // 1. The gradient in direction orthogonal to the ridge is 0 (for this direction take smaller eigenvector)\n    float dir_grad = dot(eigen_vec_2, grad);\n    float dir_grad_zero_mask = smoothstep(grad_zero_eps, 0.0, abs(dir_grad));\n    // 2. The eigenvalue of the corresponding eigenvector is smaller than 0. (2nd derivative < 0)\n    float eval2_neg_mask = smoothstep(0.0, -eigen_val_neg_eps, eigen_val.y);\n    float ridge_mask = dir_grad_zero_mask * eval2_neg_mask;\n    \n    \n    // Output to screen\n    switch(int(clamp(iMouse.x / iResolution.x, 0., 1.) * 5.)) {\n    // Actual output\n    case 0: \n        fragColor = vec4(mix(vec3(abs(loadTex(pos))), vec3(1., 0., 0.), ridge_mask), 1.);\n        break;\n    // Debug views\n    case 1: // Show gradient\n        fragColor = (vec4(grad, 0, 0)) * 20.;\n        break;\n    case 2: // Show hessian matrix entries\n        fragColor = abs(vec4(hessian[0][0], hessian[1][1], hessian[0][1], 0) * 50.);\n        break;\n    case 3: // Eigenvalues of hessian\n        fragColor = abs(vec4(-eigen_val, 0, 0)) * 50.;\n        break;\n    case 4: // Separate masks\n        fragColor = vec4(dir_grad_zero_mask, eval2_neg_mask, 0, 0);\n        break;\n    }\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Uncomment the following to extract valleys (continuous low points) instead of ridges. \n//#define VALLEY_EXTRACTION\n\n\n\n#define normalizeSafe(v) (v * min(1./length(v), 1e20))\n\nfloat loadTex( sampler2D source, vec2 p ) {\n    vec2 ts = vec2(textureSize(source, 0));\n    float f = texture(source, (p+.5)/ts).r;\n#ifdef VALLEY_EXTRACTION\n    return -f;\n#else\n    return f;\n#endif\n}\n\nuniform sampler2D SOURCE_TEXTURE;\nfloat loadTex( vec2 p ) {\n    return loadTex(SOURCE_TEXTURE, p);\n}\n\nvec2 gradient( vec2 p, float h ) {\n    return vec2(\n        loadTex(p + vec2(h, 0)) - loadTex(p + vec2(-h, 0)),\n        loadTex(p + vec2(0, h)) - loadTex(p + vec2(0, -h))\n    ) / (2. * h);\n}\n\nmat2 hessian( vec2 p, float h ) {\n    mat2x2 hessian;\n    hessian[0][0] = loadTex(p + vec2(-h,  0)) - 2. * loadTex(p) + loadTex(p + vec2(h, 0));\n    hessian[1][1] = loadTex(p + vec2( 0, -h)) - 2. * loadTex(p) + loadTex(p + vec2(0, h));\n    hessian[0][1] = 0.25*(loadTex(p + vec2(-h, -h)) - loadTex(p + vec2(h, -h)) - loadTex(p + vec2(-h, h)) + loadTex(p + vec2(h, h)));\n    hessian[1][0] = hessian[0][1];\n    return hessian / (h * h);\n}\n\nvec2 eigenvalues( mat2 M ) {\n    // Assume all eigenvalues are real. Solve the following:\n    //                    | a-λ b   |\n    // det |M - λI| = det | c   d-λ | = λ^2 - (a + d)λ + (ad - bc) = 0\n    float b = -(M[0][0] + M[1][1]);\n    float c = determinant(M);\n    \n    float d = sqrt(b*b - 4.*c);\n    vec2 ev = (-b + vec2(d, -d)) / 2.;\n    return ev;\n}\n\nvec2 eigenvector( mat2 M, float ev ) {\n    // For a given eigenvalue ev of matrix M, we know that we only have 1 linear independent equation.\n    // Simply choose a value for x (e.g. 1) and normalize.\n    // (M - λI) v = 0  <->  (a-λ)x + by = 0  <->  x = -b/(a-λ) y\n    return normalizeSafe(vec2(-M[0][1], M[0][0] - ev));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 141, 1822]], "test": "untested"}
{"id": "mtlcWf", "name": "Simple smoke cutout", "author": "Oman395", "description": "Very simple implementation of how I think that valve is doing the CS2 smoke cutouts. Just changes the perceived depth through the smoke based on the cubemap where a ray intersects the sphere in both directions.", "tags": ["volumetric", "smoke"], "likes": 3, "viewed": 263, "published": 3, "date": "1691282820", "time_retrieved": "2024-07-30T17:40:44.031792", "image_code": "const vec3 CAM = vec3(0,0,-3);\nconst float PI = 3.14159265;\nconst float FOCUS = 3.0;\nconst vec2 EPSILON = vec2(0.000001, 0);\nconst vec4 SMOKE_COL = vec4(0.3);\nconst float MAX_DIST = 0.7;\n\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\nvec3 camPos(float iTimse, vec2 iMouse) {\n    return rotate(CAM, iMouse * vec2(PI, -PI));\n}\n\nvec2 camDir(float iTime, vec2 iMouse) {\n    return iMouse * vec2(PI, -PI);\n}\n\n// https://gist.github.com/wwwtyro/beecc31d65d1004f5a9d\nvec2 raySphere(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n\tfloat disc = b * b - 4.0 * a* c;\n    if (disc < 0.0) {\n        return vec2(-1.0, -1.0);\n    }else{\n\t\treturn vec2(-b - sqrt(disc), -b + sqrt(disc)) / (2.0 * a);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvN = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uvN.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS));\n    rayDir = rotate(rayDir, dir);\n    vec2 sphereData = raySphere(pos, rayDir, vec3(0), 0.5);\n    float mult = 1.0;\n    if(sphereData.x > 0.0) {\n        vec3 dirToCenterI = normalize(\n            pos + rayDir * sphereData.x - vec3(0)\n        );\n        vec3 dirToCenterO = normalize(\n            pos + rayDir * sphereData.y - vec3(0)\n        );\n        float depthThrough = sphereData.y - sphereData.x; // Original depth through smoke\n        vec4 depthAdjIn = texture(iChannel0, dirToCenterI); // Smoke cutout sample where the ray enters the smoke\n        vec4 depthAdjOut = texture(iChannel0, dirToCenterO); // Smoke cutout sample where the ray exits the smoke\n        depthThrough -= pow(0.5 * length(\n                depthAdjIn * // We multiply the adjustments to make sure that if only one of them is clear, we have very little influence\n                depthAdjOut // I have no idea why, but we need to keep these as vec4s, and take the length of their products, rather than just taking the product of their lengths\n            ), 4.0); // We raise this to 4 because it helps make a sharper curve between cutout and not cut out\n        depthThrough = max(depthThrough, 0.0); // Doesn't make sense to have negative depth values\n        mult = 1.0 - abs(depthThrough); // The smoke should be less opaque when the distance travelled through it is less\n        mult /= MAX_DIST; // Scale this so that we can have only the edges be opaque\n        mult = clamp(mult, 0.0, 1.0); // Doesn't make sense to have negative or >1 opacity values\n        mult = pow(mult, 3.0); // Make the smoke mostly opaque, with a fade-off towards the edge\n    }\n    vec4 col = texture(iChannel2, rayDir);\n    fragColor = col * mult + SMOKE_COL * (1.0 - mult);\n    return;\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 224, 224, 561], [563, 563, 603, 603, 653], [655, 655, 694, 694, 731], [733, 789, 842, 842, 1142], [1144, 1144, 1201, 1201, 3361]], "test": "untested"}
{"id": "DtscDX", "name": "Animated Colored Bubble Pack", "author": "leon", "description": "Pack it up, pack it in", "tags": ["bubble", "packing"], "likes": 43, "viewed": 364, "published": 3, "date": "1691269374", "time_retrieved": "2024-07-30T17:40:44.806720", "image_code": "// Animated Colored Bubble Pack\n// by Leon Denise\n// 05/08/2023\n\n// variation of Colored Bubble Pack\n// https://www.shadertoy.com/view/mtfcDf\n\n// inspired by stb with his amazing shape packing:\n// https://www.shadertoy.com/view/MdGGWt\n\n// this is a very naive understanding and implementation of distance packing\n// with a weird fancy light rendering so it feels a bit special\n\n// Buffer A: color pass\n// Buffer B: distance packing\n\n// update 06/08/2023\n// replace step to smoothstep to reduce aliasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    float radius = map.y;\n    vec2 pos = map.zw;\n    \n    // shape position\n    vec2 p = 2.*(uv-pos)*vec2(R.x/R.y,1);\n    float dist = length(p);\n    \n    // circle shape from distance\n    float shape = smoothstep(.0,-.01,dist-radius);\n    \n    // seed per shape\n    vec2 seed = floor(pos*R.xy);\n    \n    // uv per shape\n    uv = (p/radius)*.5+.5;\n    \n    // normal and direction\n    float z = sqrt(1.-dist/radius);\n    vec3 normal = normalize(vec3(p/map.y, z));\n    vec3 ray = normal;\n    vec3 axis = erot(vec3(0,0,1), vec3(0,1,0), iTime*hash12(seed+196.));\n    ray = rndrot(ray, hash42(seed)*2.-1.);\n    ray = erot(ray, axis, iTime*hash12(seed)*.5);\n    \n    float angle = dot(ray, vec3(0,1,0));\n    float material = hash12(seed+172.) * 10.;\n    vec3 color = vec3(1);\n\n    // strips\n    if (material < 1.)\n    {\n        color = vec3(1) * ss(abs(fract(ray.z*2.+iTime)-.5)-.25, .01/radius);\n    }\n    // normal axis\n    else if (material < 2.)\n    {\n        color = smoothstep(.0,.01/radius,ray);\n    }\n    // gradient\n    else if (material < 3.)\n    {\n        color = .5+.5*cos(vec3(1,2,3)*5.+hash12(seed+196.)*6.+ray.y*2.+iTime);\n    }\n    // gray\n    else if (material < 4.)\n    {\n        color = vec3(angle*.5+.5);\n    }\n    // dots\n    else if (material < 5.)\n    {\n        vec3 pr = ray*5.+iTime;\n        float cell = hash13(floor(pr));\n        float black = step(cell,.5);\n        float thin = .02/radius;\n        float circle = ss(length(fract(pr)-.5)-.5+thin, thin);\n        color *= black*circle*radius*3.;\n    }\n    // normal\n    else if (material < 6.)\n    {\n        color = ray*.5+.5;\n    }\n    // planet\n    else if (material < 7.)\n    {\n        float x = noise(vec3(ray)*2.+hash42(seed).xyz, 0., 0.5, 2.);\n        color = mix(vec3(0,0,1), vec3(0,1,0), ss(x, .05/radius));\n        color *= dot(normal, vec3(0,0,1));\n    }\n    // cross\n    else if (material < 8.)\n    {\n        float size = .1;\n        float thin = -.01/radius;\n        color *= ss(abs(ray.y)-size, thin)*ss(abs(ray.z)-size, thin)*ss(abs(ray.x)-size, thin);\n    }\n    // code bar\n    else if (material < 9.)\n    {\n        float lon = atan(ray.z, ray.x);\n        float lat = sin(angle+iTime);\n        lat = (acos(lat)/3.14)*.5+.5;\n        vec2 pl = vec2(lon*.5, lat)*10.;\n        float x = hash12(floor(pl));\n        float ex = 1.-(2.*abs(fract(pl.x)-.5));\n        float ey = 1.-(2.*abs(fract(pl.y)-.5));\n        color *= step(.8,x)*smoothstep(.0,.01/radius,ey)*smoothstep(.0,.1/radius,ex);\n    }\n    // noise\n    else\n    {\n        float x = noise(vec3(ray)+hash42(seed).xyz, iTime*.5, 4.*radius, 2.);\n        color *= smoothstep(.2,0.,abs(x));\n        color *= dot(normal, vec3(0,0,1))*radius*4.;\n    }\n    \n    // lighting\n    angle = dot(normal, normalize(vec3(0,-2,-1)));\n    float ratio = (acos(angle)/3.14)*.5+.5;\n    color += pow(ratio, 10.)*.5;\n    color *= ratio;\n    \n    fragColor = vec4(shape*color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;\n    \n    // random\n    float t = float(iFrame)+iDate.x+iDate.y+iDate.z+iDate.w;\n    vec2 q = hash21(t);\n    \n    // position\n    p -= (q-.5)*2.*vec2(R.x/R.y,1);\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    vec4 d = texture(iChannel0, q);\n    float radius = d.x*.9;\n    \n    // distance test\n    float dist = length(p)-radius;\n    \n    // if farer, choose previous result\n    if (map.x < dist)\n    {\n        dist = map.x;\n        radius = map.y;\n        q = map.zw;\n    }\n    \n    // init and reset\n    if (iFrame < 1 || mod(float(iFrame), 60.*40.) < 1.\n    \n    // resolution changed\n    || texture(iChannel0, vec2(0)).xy != iResolution.xy)\n    {\n        // border distance\n        float edge = min(min(abs(uv.y), abs(1.-uv.y)), min(abs(uv.x), abs(1.-uv.x)));\n        float maxRadius = .5;\n        \n        // make it special sometimes\n        //dist = hash11(t) > .9 ? maxRadius : edge;\n        dist = maxRadius;\n        \n        // init/reset values\n        radius = maxRadius;\n        q = vec2(-1);\n    }\n    \n    // serve\n    fragColor = vec4(dist,radius,q);\n    \n    // store resolution so we can reset if it change the next frame\n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n        fragColor = vec4(iResolution.xy, 0, 0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(x,t) smoothstep(t,.0,x)\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\n// Gyroid pattern\n// Explained by Martijn Steinrucken at:\n// https://www.youtube.com/watch?v=b0AayhCO7s8\nfloat gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }\n\n// FBM type of noise with gyroid pattern\nfloat noise (vec3 p, float t, float w, float aa)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 4.; ++i, a/=aa)\n    {\n        p.z += t+result*w; // distortion\n        result += (gyroid(p/a))*a; // noise pattern\n    }\n    return result;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Blackle\n// https://suricrasia.online/blog/shader-functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd)\n{\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*acos(-1.));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtscDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 561, 580, 3565]], "test": "untested"}
{"id": "DtscWX", "name": "Wave Library (desmos)", "author": "SnoopethDuckDuck", "description": "Suggestions/improvements are welcome!", "tags": ["wave", "triangle", "sin", "circle", "cos", "square", "bounce", "graph", "function", "periodic", "spring", "saw", "easing", "sawtooth", "elastic", "desmos"], "likes": 17, "viewed": 231, "published": 3, "date": "1691259214", "time_retrieved": "2024-07-30T17:40:45.572672", "image_code": "#define D(v) d = min(d, length(u - vec2(.6*v, h))); h -= 0.08;\n#define F(c1,c2,c3) O += vec4(c1,c2,c3,0) * smoothstep(-2./R.y,2./R.y,.028-d); d = 1e5;\n                    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         u = (U+U-R)/R.y;\n         \n    float t = iTime,\n          h = 0.9,\n          d = 1e5;\n    \n    O *= 0.;\n    \n    // Cyan\n    D(cos(t)) \n    D(cosSkewL(t))\n    D(cosSkewR(t))\n    F(0,1,1)\n    \n    // Yellow\n    D(tri(t)) \n    D(triSoft(t, 5.))\n    D(triCos(t));   \n    F(1,1,0)\n    \n    // Pink\n    D(saw(2.*t)) \n    D(sawSoftU(2.*t, 4.))\n    D(sawSoftO(2.*t, 0.6))\n    F(1,0,1)\n\n    // Green\n    D(squSoft1(t, 9.)) \n    D(squSoft2(t, 9.))\n    D(squSoft3(t, 9.))\n    F(0,1,0)\n    \n    // Red\n    D(cir(2.*t/pi+1.)) \n    F(1,.5,.5)\n    \n    // Blue\n    D(mulWav(t, 4., 0.5)) \n    D(mulWav(t, 4., -0.75))\n    D(mulWav2(t, 3., 0.3, 3.))\n    F(.5,.5,1)\n    \n    // Light pink\n    D(wobBi(t, 12., 14.)) \n    D(wobUni(t/pi-.5, 7., 20., 15., 20.))\n    D(wobSoft(2.*t/pi-1., 8., 22., 4.))\n    F(1,.5,1)\n    \n    // White\n    D(wei(.5*t, 1., 1.))\n    D(wei2(.5*t, 1., 1., 0.5))\n    D(wei3(.5*t, 1., 1., 0.5)) // disappears at 0 :(\n    F(1,1,1)\n}", "image_inputs": [], "common_code": "// Todo: improve mulwav2, add bounce wave, delete wei3?\n\n#define pi 3.14159\n#define tanh2(a) ((exp2(a)-1.)/(exp2(a)+1.))\n#define atanh2(x) log2((1.+(x))/(1.-(x)))\n\n// Skew cos sin \n// https://www.desmos.com/calculator/1co5kkgpzk\n#define cosSkew(x,a) sqrt(4.-a*a)*cos(x)/(2.+a*sin(x))\n#define cosSkewL(x) sqrt(3.)*cos(x)/(2.+sin(x))\n#define cosSkewR(x) sqrt(3.)*cos(x)/(2.-sin(x))\n#define sinSkewL(x) sqrt(3.)*sin(x)/(2.-cos(x))\n#define sinSkewR(x) sqrt(3.)*sin(x)/(2.+cos(x))\n\n// Triangle\n// https://www.desmos.com/calculator/gbzybnz3ap\n#define tri(x) (2.*abs(1.-mod(x/pi,2.))-1.)\n#define triCos(x) tan(pi/4.*cos(x))\nfloat triSoft(float x, float a) {\n    float b = 1. - exp2(-max(1e-5, a));\n    return asin(b * cos(x)) / asin(b);\n}\n\n// Saw\n// https://www.desmos.com/calculator/sq7rw2sfev\n#define saw(x) (1.-mod(x/pi,2.))\nfloat sawSoftU(float x, float a) {\n    float m = 1. - mod(x / pi, 2.);\n    return m * (1. - pow(m, 2. * floor(a)));\n}\n#define sawSoftO(x,a) atan(a*sin(x)/(1.-a*cos(x)))/atan(a/sqrt(1.-a*a))\n#define sawSquSoftO(x,a,b) tanh2(a*b*sin(x)/(1.-a*cos(x)))/tanh2(a*b/sqrt(1.-a*a))\n\n// Square\n// https://www.desmos.com/calculator/cgvbcbg99d\n#define squ(x,p) sign(mod(x,p+p)-p)\n#define squSoft1(x,a) tanh2((a)*cos(x))/tanh2(a)\n#define squSoft2(x,a) (1.+abs(a))*cos(x)/(1.+abs(a*cos(x)))\n#define squSoft3(x,a) sign(cos(x))*(1.-exp2(-abs(a*cos(x))))/(1.-exp2(-abs(a)))\n\n// Pulse (multi wave is soft pulse)\n// https://www.desmos.com/calculator/eoviatvrdo\n#define pul(x,a,p) sign(mod(-x,p)+a-p)\n\n// Circle\n// https://www.desmos.com/calculator/1xmbt1wzjn\nfloat cir(float x) {\n    float m = mod(x, 2.) - 1.;\n    return sign(2. - mod(x, 4.)) * sqrt(1. - m * m);\n}\n\n// Multi wave\n// https://www.desmos.com/calculator/agixzs0m99\n#define mulWav(x,a,o) tanh2(a*(atanh2(cos(x))-atanh2(o)))\n\n// https://www.desmos.com/calculator/xiqfros6no\nfloat mulWav2(float x, float a, float o, float n) {\n    float ix = cos(x) / pow(1. - pow(abs(cos(x)), n), 1./n);\n    float io = o / pow(1. - pow(abs(o), n), 1./n);\n    float v = a * (ix - io);\n    return v / pow(1. + pow(abs(v), n), 1./n);\n}\n\n// Spring\n// https://www.desmos.com/calculator/erxxo0vibc\n#define wobBi(x,a,b) sign(cos(x))*(1.-exp2(-(a)*abs(cos(x)))*cos((b)*abs(cos(x))))\n\n// https://www.desmos.com/calculator/gbkax818fx\nfloat wobUni(float x, float a1, float b1, float a2, float b2) {\n    x = mod(x, 2.);\n    float f1 = 1. - exp(-a1 * x) * cos(b1 * x); \n    float f2 = exp(-a2 * (x-1.)) * cos(b2 * (x-1.));\n    f2 = mix(1., f2, step(1., x));\n    return 1. - 2. * f1 * f2;\n}\n\n// https://www.shadertoy.com/view/ctfcW4\nfloat wobSoft(float x, float a, float b, float n) {\n    float s = sign(mod(x, 4.) - 2.);    \n    x = mod(x, 2.); \n    float v = min(1., x);\n    float f = 1. - exp(-a * x) * cos(b * x);\n    float g = pow(1. - pow(1.-x, n), 1./n);   \n    float l = mix(mix(f, g, v), \n                  1. - exp(-7. * sqrt(x)), \n                  1. - pow(v, .1));     \n    return l * s;    \n}\n\n// Weird\n// https://www.desmos.com/calculator/wlf8nghsp8\n#define wei(x,a,b) cos(pi*tanh(a+b*tan(x)))\nfloat wei2(float x, float a, float b, float c) {\n    float p = c * pi;\n    float s = cos(p);\n    return 2. * (cos(p*tanh(a+b*tan(x)))-s) / (1.-s) - 1.;\n}\nfloat wei3(float x, float a, float b, float c) {\n    float p = c * pi;\n    float s = cos(p);\n    return 2. * (cos(p*tanh2(a+b*tan(x)))-s) / (1.-s) - 1.;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtscWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dssfRM", "name": "Circles Color Experiment", "author": "martymarty", "description": "First idea after learning circles from The Book of Shaders. Used different color schemes, one a weird color effect based on x,y position and time. Also RGB and CMY.", "tags": ["circles", "colors", "experiment", "learning", "mesmerizing"], "likes": 1, "viewed": 177, "published": 3, "date": "1691256417", "time_retrieved": "2024-07-30T17:40:46.334635", "image_code": "float circleStep(float thickness, float inner, float outer, float value) {\n    return smoothstep(inner, inner+thickness, value) - smoothstep(outer-thickness,outer,value);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    clamp(fragCoord, 0.0,iResolution.y);\n    vec2 st = fragCoord/iResolution.y;\n    float time = mod(iTime,45.0)+0.05;\n    float pct = 0.0;\n    float pct2 = 0.0;\n    //Circle using distance\n    pct = distance(st,vec2(0.2,0.2));\n    pct2 = distance(st,vec2(0.8,0.5));\n    float select = floor(pct*time);\n    float select2 = floor(pct*time*1.2);\n    pct = fract(pct*time);\n    pct2 = fract(pct2*time*1.2);\n    vec3 color = vec3(1.0);\n    //Weird Color effect\n    //color = vec3(1.0-mod(select,3.0),1.0-mod(st.x*select+1.0*iTime,3.0),1.0-mod(select*st.y+2.0*iTime,3.0));\n    //RGB Color\n    //color = vec3(1.0-mod(select,3.0),1.0-mod(select+1.0,3.0),1.0-mod(select+2.0,3.0));\n    //CMY Color\n    color = vec3(mod(select,3.0),mod(select+1.0,3.0),mod(select+2.0,3.0));\n    vec3 color2 = vec3(1.0-mod(select2,3.0),1.0-mod(select2+1.0,3.0),1.0-mod(select2+2.0,3.0));\n    //pct = smoothstep(0.30,0.32,pct)-smoothstep(0.38,0.40,pct);\n    pct = circleStep(0.02, 0.30,0.40,pct);\n    pct2 = circleStep(0.07,0.25,0.40,pct2);\n    //Circle using length\n    //vec2 toCenter = vec2(0.5)-st;\n    //pct = length(toCenter);\n    \n    //Circle using square root\n    //pct = sqrt((st.x-0.5)*(st.x-0.5)+(st.y-0.5)*(st.y-0.5));\n    vec3 col = pct*color+pct2*color2;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dssfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 74, 74, 172], [173, 173, 230, 280, 1578]], "test": "untested"}
{"id": "mtfcDf", "name": "Colored Bubble Pack", "author": "leon", "description": "Pack it up", "tags": ["bubble", "packing"], "likes": 32, "viewed": 366, "published": 3, "date": "1691256401", "time_retrieved": "2024-07-30T17:40:47.096597", "image_code": "// Colored Bubble Pack\n// by Leon Denise\n// 05/08/2023\n\n// inspired by stb with his amazing shape packing:\n// https://www.shadertoy.com/view/MdGGWt\n\n// this is a very naive understanding and implementation of distance packing\n// with a weird fancy light rendering so it feels a bit special\n\n// Buffer A: color pass\n// Buffer B: distance packing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    float radius = map.y;\n    vec2 pos = map.zw;\n    \n    // shape position\n    vec2 p = 2.*(uv-pos)*vec2(R.x/R.y,1);\n    float dist = length(p);\n    \n    // circle shape from distance\n    float shape = smoothstep(.0,-.01,dist-radius);\n    \n    // seed per shape\n    vec2 seed = floor(pos*R.xy);\n    \n    // uv per shape\n    uv = (p/radius)*.5+.5;\n    \n    // color palette\n    // by Inigo Quilez at\n    // https://iquilezles.org/articles/palettes/\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*5.+hash12(seed+196.)*6.+uv.x*1.5);\n    tint *= step(hash12(seed),.8);\n    \n    // normal randomized\n    vec3 ray = normalize(vec3(p*2., 1.-dist/radius));\n    ray = rndrot(ray, hash42(seed)*2.-1.);\n    \n    // the cubemap version (you'll have to load the texture)\n    //fragColor = vec4(shape*texture(iChannel2, ray).r*tint,1);\n    \n    float shade = dot(ray, vec3(0,1,0))*.5+.5;\n    \n    // the tint light version\n    //fragColor = vec4(tint*shape*shade,1);\n    \n    // the weird version\n    fragColor = vec4(shape*(mix(tint * pow(1.-shade, 10.), vec3(1), shade)),1);\n    \n    // the debug viewer\n    // fragColor = vec4(p/map.y, shape, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;\n    \n    // random\n    float t = float(iFrame)+iDate.x+iDate.y+iDate.z+iDate.w;\n    vec2 q = hash21(t);\n    \n    // position\n    p -= (q-.5)*2.*vec2(R.x/R.y,1);\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    vec4 d = texture(iChannel0, q);\n    float radius = d.x;\n    \n    // distance test\n    float dist = length(p)-radius;\n    \n    // if farer, choose previous result\n    if (map.x < dist)\n    {\n        dist = map.x;\n        radius = map.y;\n        q = map.zw;\n    }\n    \n    // init and reset\n    if (iFrame < 1 || mod(float(iFrame), 60.*40.) < 1.\n    \n    // resolution changed\n    || texture(iChannel0, vec2(0)).xy != iResolution.xy)\n    {\n        // border distance\n        float edge = min(min(abs(uv.y), abs(1.-uv.y)), min(abs(uv.x), abs(1.-uv.x)));\n        float maxRadius = .5;\n        \n        // make it special sometimes\n        dist = hash11(t) > .9 ? maxRadius : edge;\n        \n        // init/reset values\n        radius = maxRadius;\n        q = vec2(-1);\n    }\n    \n    // serve\n    fragColor = vec4(dist,radius,q);\n    \n    // store resolution so we can reset if it change the next frame\n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n        fragColor = vec4(iResolution.xy, 0, 0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// Blackle\n// https://suricrasia.online/blog/shader-functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd)\n{\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*acos(-1.));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfcDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 403, 422, 1638]], "test": "untested"}
{"id": "mtfyDX", "name": "Candy clouds", "author": "motus_art", "description": "A soft, slow moving cotton candy like cloud effect with pastel colours I used as a background on my portfolio website.", "tags": ["perlinnoise", "clouds", "smooth"], "likes": 1, "viewed": 139, "published": 3, "date": "1691247589", "time_retrieved": "2024-07-30T17:40:47.869531", "image_code": "//\n// Candy clouds\n// By: Motus Art\n// Website: motus.art\n//\n// A soft, slow moving cotton candy like cloud effect\n// with pastel colours I used as a background\n// on my portfolio website.\n//\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n//\tClassic Perlin 3D Noise by Stefan Gustavson\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n// Candy clouds\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 vUv = fragCoord/iResolution.xy;\n\n  float speed = iTime / 8.0;\n  float strength = smoothstep(1.0, 0.0, sin(cnoise(vec3(vUv.x * 10.0 + speed / 1.5, vUv.y * 1.5 + speed, speed)) * 3.0));\n  strength = clamp(strength, 0.0, 1.0);\n\n  // Colour it\n  vec3 bgColor = vec3(1.0);\n  vec3 uvColor = vec3(vUv*cos(iTime/2.0), sin(iTime/2.0) * 0.2 + 0.8);\n  uvColor = mix(uvColor, vec3(1.0), 0.86);\n  vec3 mixedColor = mix(bgColor, uvColor, strength);\n  fragColor = vec4(mixedColor, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 214, 214, 251], [252, 252, 279, 279, 327], [328, 328, 347, 347, 383], [385, 432, 453, 453, 2724], [2727, 2743, 2800, 2800, 3281]], "test": "untested"}
{"id": "mlsyDj", "name": "Balls Simulated (updated)", "author": "beans_please", "description": "This is my first physics simulation, and I just followed my gut, so feel free to comment on how this can be improved\n\nUpdate: Implemented suggestions by @fenix (no more jittering + general improvements)", "tags": ["simulation", "sphere", "balls", "ball", "physics"], "likes": 12, "viewed": 188, "published": 3, "date": "1691237601", "time_retrieved": "2024-07-30T17:40:48.823979", "image_code": "/* -----------------------------------------------\n  Shadertoy Unit: Image\n  Description: Rendering\n  iChannel0: Cubemap\n  iChannel1: Buffer A\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nfloat fake_hdr(float x)\n{\n    if (x < 0.6) return x;\n    const float a = 1.5, b = 2.0;\n    return a * pow(x, b) + 0.6 - a * pow(0.6, b);\n}\n\nvec3 get_env(vec3 dir)\n{\n    vec3 c = pow(texture(iChannel0, dir.xzy).xyz, vec3(2.2));\n    c *= vec3(0.32, 0.8, 1.0) * 2.5;\n    //c = vec3(fake_hdr(c.r), fake_hdr(c.g), fake_hdr(c.b));\n    c *= 1.1;\n    return c;\n}\n\nfloat get_visibility(ray_t r)\n{\n    // Raycast to the balls\n    for (int i = 0; i < num_balls; i++)\n    {\n        vec4 data = texelFetch(iChannel1, index2icoord(i * ppe + 1), 0);\n        vec3 ball_pos = vec3(data.x, 1.0, data.y);\n        hit_t h2;\n        ray_sphere(ball_pos, ball_radius, r, h2);\n        if (h2.hit)\n        {\n            return 0.0;\n        }\n    }\n    return 1.0;\n}\n\nvec2 screen_to_uv(vec2 coord)\n{\n    return (2.0 * coord - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nray_t gen_cam_ray(vec2 uv)\n{\n    // Camera params\n    const vec3 cam_pos = vec3(0.0, -4.3, 1.5);\n    const float cam_fov = 47.0;\n    \n    // Camera details\n    const float cam_zoom = 90.0 / cam_fov;\n    const vec3 cam_forward = normalize(vec3(0.0, 0.0, 1.85) - cam_pos);\n    const vec3 cam_right = normalize(cross(cam_forward, vec3(0, 0, 1)));\n    const vec3 cam_up = cross(cam_right, cam_forward);\n    \n    // Ray\n    ray_t r;\n    r.orig = cam_pos;\n    r.dir = normalize(cam_forward + cam_right * (uv.x / cam_zoom) + cam_up * (uv.y / cam_zoom));\n    return r;\n}\n\nvec3 view_transform(vec3 col)\n{\n\t// OETF (Gamma)\n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvec3 render(vec2 frag_coord)\n{\n    // UV\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Generate camera ray\n    ray_t r = gen_cam_ray(uv);\n    \n    // Hit info\n    int ball_id = -1;\n    hit_t closest;\n    closest.hit = false;\n    closest.t = 1000.;\n    \n    // Raycast to ground\n    hit_t h;\n    ray_aabb(vec3(-7.0, -7.0, -0.1), vec3(7.0, 7.0, 0.0), r, h);\n    if (h.hit && h.t < closest.t)\n    {\n        ball_id = -1;\n        closest = h;\n    }\n    \n    // Raycast to the balls\n    for (int i = 0; i < num_balls; i++)\n    {\n        vec4 data = texelFetch(iChannel1, index2icoord(i * ppe + 1), 0);\n        vec3 ball_pos = vec3(data.x, 1.0, data.y);\n        hit_t h2;\n        ray_sphere(ball_pos, ball_radius, r, h2);\n        if (h2.hit && h2.t < closest.t)\n        {\n            ball_id = i;\n            closest = h2;\n        }\n    }\n    \n    // Shade\n    vec3 col = vec3(0);\n    if (closest.hit)\n    {\n        float t = -TAU * iTime * 0.1;\n        vec3 light_dir = normalize(vec3(cos(t), sin(t), 2.5));\n        if (ball_id < 0)\n        {\n            // Ground shading\n            const vec3 mat_diff = vec3(.14, .4, .7);\n            vec3 diffuse = 0.8 * mat_diff * max(0., dot(closest.normal, light_dir));\n            vec3 hv = normalize(light_dir - r.dir);\n            vec3 spec = vec3(1.0) * pow(dot(hv, closest.normal), 15.0);\n            col = diffuse + spec;\n            \n            // Shadows\n            ray_t rshadow;\n            rshadow.orig = closest.pos + r.dir * 0.002;\n            rshadow.dir = light_dir;\n            col *= get_visibility(rshadow);\n            \n            // Ambient\n            col += mat_diff * 0.1;\n        }\n        else\n        {\n            // Ball shading\n            \n            const vec3 mat_diff = vec3(1.0, 0.5, 0.06);\n            vec3 diffuse = mat_diff * max(0., dot(closest.normal, light_dir));\n            vec3 ambient = 0.065 * mat_diff + vec3(0., .002, .01);\n            \n            vec3 envref = get_env(reflect(r.dir, closest.normal));\n            float fresnel = pow(1.0 - dot(-r.dir, closest.normal), 5.0);\n            vec3 spec = envref * lerp(0.01, 0.8, fresnel);\n            \n            col = diffuse + ambient + spec;\n        }\n    }\n    else\n    {\n        col = get_env(r.dir);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Render with super sampling\n    vec3 col = vec3(0.0);\n    col += render(frag_coord + vec2(-0.25, -0.25));\n    col += render(frag_coord + vec2(-0.25, +0.25));\n    col += render(frag_coord + vec2(+0.25, +0.25));\n    col += render(frag_coord + vec2(+0.25, -0.25));\n    col /= 4.;\n    \n    // Output\n    col *= 1.2;\n    col = view_transform(col);\n    frag_col = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* -----------------------------------------------\n  Shadertoy Unit: Common\n----------------------------------------------- */\n\n\n\n// -----------------------------------------------\n// What to define\n// -----------------------------------------------\n\n/* Math Utils */\n#define MATH_UTILS 1\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\n// -----------------------------------------------\n// Math Utils\n// -----------------------------------------------\n\n#if MATH_UTILS\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n#define DEG_TO_RAD 0.01745329251994329576923690768\n#define RAD_TO_DEG 57.2957795130823208767981548141\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_MAP_RANGE(T) \\\nT map_range(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_MAP_RANGE_CLAMP(T) \\\nT map_range_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_MAP_RANGE(float)\nFUNC_MAP_RANGE(vec2)\nFUNC_MAP_RANGE(vec3)\nFUNC_MAP_RANGE(vec4)\n\nFUNC_MAP_RANGE_CLAMP(float)\nFUNC_MAP_RANGE_CLAMP(vec2)\nFUNC_MAP_RANGE_CLAMP(vec3)\nFUNC_MAP_RANGE_CLAMP(vec4)\n\n#endif\n\n// -----------------------------------------------\n// End\n// -----------------------------------------------\n\n\n\nstruct ray_t\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct hit_t\n{\n    bool hit;\n    float t;\n    vec3 pos;\n    vec3 normal;\n};\n\n// https://www.reddit.com/r/opengl/comments/8ntzz5/comment/dzyqwgr\nvoid ray_aabb(const vec3 box_min, const vec3 box_max, in ray_t r, out hit_t h) {\n    vec3 inv_dir = 1.0 / r.dir;\n    vec3 tbot = inv_dir * (box_min - r.orig);\n    vec3 ttop = inv_dir * (box_max - r.orig);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    float t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    float t1 = min(t.x, t.y);\n    if (t1 > max(t0, 0.0))\n    {\n        h.hit = true;\n        h.t = t0;\n        h.pos = r.orig + r.dir * t0;\n        h.normal = vec3(0.0, 0.0, 1.0); // what's the proper way? please comment\n    }\n}\n\nvoid ray_sphere(const vec3 center, const float radius, in ray_t r, out hit_t h)\n{\n    vec3 ro = r.orig - center;\n    \n    // Quadratic equation\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(ro, r.dir);\n    float c = dot(ro, ro) - radius*radius;\n    float discriminant = (b * b) - (4.0 * a * c);\n    \n    if (discriminant < 0.0)\n    {\n        // No hits\n        h.hit = false;\n        return;\n    }\n    \n    float sqrt_d = sqrt(discriminant);\n    float t = (-b - sqrt_d) / (2.0 * a);\n    \n    if (t < 0.0)\n    {\n        h.hit = false;\n        return;\n    }\n    \n    h.hit = true;\n    h.t = t;\n    h.pos = r.orig + (t * r.dir);\n    \n    // Normal\n    h.normal = (h.pos - center) / radius;\n}\n\n// A 20x10 grid of pixels in buffer A will be used to store\n// and manipulate simulation data.\nconst ivec2 data_res = ivec2(20, 10);\n\n// Pixels per element. Every N pixels hold information about\n// one ball.\nconst int ppe = 2;\n\n// Ball parameters\nconst int num_balls = 100;\nconst float ball_radius = 0.2;\n\n// Convert pixel indices in the data buffer to a 1D index\nint icoord2index(ivec2 icoord)\n{\n    if (icoord.x >= data_res.x || icoord.y >= data_res.y)\n        return -1;\n    return icoord.x + icoord.y * data_res.x;\n}\n\n// Convert a 1D index to pixel indices in the data buffer\nivec2 index2icoord(int index)\n{\n    return ivec2(index % data_res.x, index / data_res.x);\n}\n", "buffer_a_code": "/* -----------------------------------------------\n  Shadertoy Unit: Buffer A\n  Description: Simulation\n  iChannel0: Buffer A (self-feeding)\n  iChannel1: None\n  iChannel2: None\n  iChannel3: None\n----------------------------------------------- */\n\nvoid mainImage(out vec4 o, in vec2 frag_coord)\n{\n    // Integer coordinates\n    ivec2 icoord = ivec2(floor(frag_coord));\n    \n    // Are we outside the data buffer?\n    if (icoord.x >= data_res.x || icoord.y >= data_res.y)\n    {\n        o = vec4(0);\n        return;\n    }\n    \n    // Convert pixel indices to 1D index\n    int idx = icoord2index(icoord);\n    \n    // Ball index\n    int ball_id = int(floor(float(idx) / float(ppe)));\n    \n    // Ball data index\n    // 0 = Velocity,\n    // 1 = Position\n    int data_id = idx % ppe;\n    \n    // Ball data\n    vec4 vel = texelFetch(iChannel0, index2icoord(idx + 0 - data_id), 0);\n    vec4 pos = texelFetch(iChannel0, index2icoord(idx + 1 - data_id), 0);\n    \n    // First frames / Initialization\n    const float valid_w = 2.0;\n    bool init = (iFrame < 5 || iTime <= 0. || texelFetch(iChannel0, icoord, 0).w != valid_w);\n    \n    // Delta time\n    float dt = 1.0 * min(iTimeDelta, 0.016);\n    \n    // Step\n    if (!init)\n    {\n        // Update values\n        const vec2 gravity = vec2(0.0, -2.);\n        vel.xy += gravity * dt;\n        pos.xy += vel.xy * dt;\n        \n        if (pos.y < ball_radius)\n        {\n            // Collision with the ground\n            vel.y *= -.3;\n            pos.y = ball_radius;\n        }\n        else\n        {\n            // (2 * radius) ^ 2\n            const float d2 = 4. * ball_radius * ball_radius;\n            \n            // Collision with the other balls\n            for (int i = 0; i < num_balls; i++)\n            {\n                // Skip self\n                if (i == ball_id) continue;\n                \n                // Get other ball's position\n                vec2 vel2 = texelFetch(iChannel0, index2icoord(i * ppe + 0), 0).xy;\n                vec2 pos2 = texelFetch(iChannel0, index2icoord(i * ppe + 1), 0).xy;\n                \n                // Check their distance\n                vec2 temp = pos.xy - pos2;\n                if (pos.y > pos2.y && dot(temp, temp) < d2)\n                {\n                    vec2 rel_vel = vel2 - vel.xy;\n                    vel.xy += normalize(temp) * max(0., dot(rel_vel, temp));\n                    pos.xy = pos2 + normalize(pos.xy - pos2) * ball_radius * 2.;\n                }\n            }\n        }\n    }\n    \n    // Velocity\n    if (data_id == 0)\n    {\n        // First frame\n        if (init)\n        {\n            o = vec4(0.0, 0.0, 0.0, valid_w);\n            return;\n        }\n        o = vel;\n    }\n    \n    // Position\n    if (data_id == 1)\n    {\n        // First frame\n        if (init)\n        {\n            int ix = ball_id % 10;\n            int iy = ball_id / 10;\n            o = vec4(\n                float(ix - 5) * 2.0 * ball_radius * 1.2 + sin(float(iy) * 500.0) * .4,\n                0.005 + ball_radius + float(iy) * 2.0 * ball_radius * 1.2,\n                0.0, valid_w\n            );\n            return;\n        }\n        o = pos;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlsyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 256, 256, 369], [371, 371, 395, 395, 585], [587, 587, 618, 646, 972], [974, 974, 1005, 1005, 1086], [1088, 1088, 1116, 1137, 1650], [1652, 1652, 1683, 1700, 1740], [1742, 1742, 1772, 1782, 4012], [4014, 4014, 4069, 4103, 4451]], "test": "untested"}
{"id": "dllcDj", "name": "Cloudy Blue Sky", "author": "leon", "description": "Guess who is in vacation in the country side.\nAnother layers of noise that look like something.", "tags": ["2d", "cloud", "sky"], "likes": 38, "viewed": 979, "published": 3, "date": "1691224020", "time_retrieved": "2024-07-30T17:40:49.595915", "image_code": "\n// Cloudy Blue Sky\n// by Leon Denise\n// 05/08/2023\n\n// Guess who is in vacation in the country side.\n// Another layers of noise that look like something.\n// Trying to push noise patterns farer to create complex shapes with simple code.\n\n// Could be very golfed and textureless,\n// but the blue noise scrolling is really adding to the picture,\n// and would be hard to golf.\n\n\n// Gyroid pattern\n// Explained by Martijn Steinrucken at:\n// https://www.youtube.com/watch?v=b0AayhCO7s8\nfloat gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }\n\n// FBM type of noise with gyroid pattern\nfloat noise (vec3 p, float t, float w, float aa)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 4.; ++i, a/=aa)\n    {\n        p.z += t+result*w; // distortion\n        result += abs(gyroid(p/a))*a; // noise pattern\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = 2.*(fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // blue noise scroll\n    // by Inigo Quilez from:\n    // https://www.shadertoy.com/view/tlySzR\n    ivec2 pp = ivec2(fragCoord);\n    pp = (pp+(iFrame*196)*ivec2(113,127)) & 1023;\n    vec3 blu = texelFetch(iChannel0,pp,0).xyz;\n    \n    // shape from noise\n    vec3 q = vec3(p, 0.);\n    float t = iTime*.05-.2/(uv.y); // animation and perspective\n    q.y += noise(q*10., -t*4., 0., 1.9)*.1; // small details\n    color += noise(q, t, .3, 1.7)*.5-.5; // overall shape\n    color += blu.x*0.4; // extra shape reveal with blue noise\n    color *= smoothstep(.05,.4,uv.y); // fade out horizon\n    \n    // color\n    vec3 sky = mix(vec3(1), vec3(.4,.8,1), smoothstep(-.4, .4, uv.y));\n    color = mix(sky, vec3(1), smoothstep(.0,.2,color.r));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 481, 504, 504, 537], [539, 580, 630, 630, 833], [835, 835, 892, 892, 1822]], "test": "untested"}
{"id": "ctsyDj", "name": "Alien nuerons", "author": "jackjackdev", "description": "Credits to Art of Code's gyroid tutorial on YT, tutorial is here: https://www.youtube.com/watch?v=-adHIyjIYgk&list=PLGmrMu-IwbgsVjE7SAtFaWyhZXyBjJNnO&index=7", "tags": ["raymarching", "alien", "gyroid"], "likes": 10, "viewed": 210, "published": 3, "date": "1691192149", "time_retrieved": "2024-07-30T17:40:50.364859", "image_code": "// Alien nuerons - Raymarching gyroid\n// Credits to Art of Code's gyroid tutorial on YT, tutorial is here: https://www.youtube.com/watch?v=-adHIyjIYgk&list=PLGmrMu-IwbgsVjE7SAtFaWyhZXyBjJNnO&index=7\n// \"Gyroid is a minimal surface: a surface that minimizes its area for a given boundary\"\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n        return abs(dot(sin(p), cos(p.zxy)) - bias) / scale - thickness;\n}\n\n\nvec3 Transform(vec3 p) {\n    p.z -= iTime*.1;\n    p.y -=.3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    p = Transform(p);\n    \n    float box = sdBox(p, vec3(1));\n    \n    float g1 = sdGyroid(p, 5.23, .03, 1.4);\n    float g2 = sdGyroid(p, 10.76, .03, .3);\n    float g3 = sdGyroid(p, 20.76, .03, .3);\n    float g4 = sdGyroid(p, 35.76, .03, .3);\n    float g5 = sdGyroid(p, 60.76, .03, .3);\n    float g6 = sdGyroid(p, 101.72, .03, .3);\n    float g7 = sdGyroid(p, 185.56, .03, .3);\n\n\n    //float g = min(g1, g2); //union\n    //float g = max(g1, -g2); //subtraction\n    g1 -= g2*.3;\n    g1 -= g3*.2;\n    g1 += g4*.1;\n    g1 += g5*.1;\n        g1 += g6*.8;\n    g1 += g7*.5;\n\n    \n    float d = g1*.9; \n    //float d = max(box, g1 * .8);\n    \n    return d;\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.005, 0);\n    vec3 n = GetDist(p) - \n    vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 Background(vec3 rd) {\n    vec3 col = vec3(0);\n    float t = iTime;\n    float y = rd.y *.5+.5;\n    col += (1.-y)*vec3(0.4, 0.8, 1.)*1.5;\n    \n    float a = atan(rd.x, rd.z);\n    float beams = (sin(a*10.+t) * sin(a*7.-t) * sin(a*3.+t));\n    beams *= smoothstep(.8, .5, y);\n    col += beams;\n    col = max(col, 0.);\n    col += smoothstep(.5, .0, y);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    vec3 ro = vec3(0, 0, -.03);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 lookat = vec3(0, 0, 0);\n    vec3 rd = GetRayDir(uv, ro, lookat, .8);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        p = Transform(p);\n        \n        //vec3 r = reflect(rd, n);\n        //float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        //col = vec3(dif);\n        \n        float dif = n.y*.5+.5;\n        col += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        col *= smoothstep(-.1, .1, g2); //dimmer\n        \n        float crackWidth = -0.02 + smoothstep(0., -.5, n.y) * .04;\n        float cracks = smoothstep(crackWidth, -.03, g2);\n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p+t*.05, 4.76, .03, .0);\n        cracks *= g3*g4*20.+.2*smoothstep(.2, .0, n.y);\n        \n        \n        col += cracks*vec3(0.1,0.2,1.)*3.;\n    }\n    //col *= 0.;\n    //d = sdGyroid(vec3(uv.x, uv.y, iTime*.1), 20., .02, 0.);\n    //col += d*10.;\n    \n    col = mix(col, Background(rd), smoothstep(0., 7., d));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctsyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 454, 454, 516], [518, 518, 547, 547, 628], [630, 630, 696, 696, 786], [789, 789, 813, 813, 864], [866, 866, 889, 889, 1539], [1544, 1544, 1578, 1578, 1789], [1791, 1791, 1815, 1815, 1965], [1967, 1967, 2017, 2017, 2202], [2204, 2204, 2230, 2230, 2578], [2580, 2580, 2637, 2637, 3959]], "test": "untested"}
{"id": "ctXyzj", "name": "Lissajous visualizer", "author": "Ebanflo", "description": "Start of some tests on music visualization in shadertoy", "tags": ["2d", "music", "lissajous", "fourier", "notes"], "likes": 5, "viewed": 226, "published": 3, "date": "1691191244", "time_retrieved": "2024-07-30T17:40:51.129814", "image_code": "const float pi = 4.*atan(1.);\nconst int steps = 200;\n\nvec2 lissajous(float t, float a, float b, float d)\n{\n\treturn vec2(sin(a*t+d), sin(b*t));\n}\n\nfloat render_lissajous(vec2 uv, float a, float b, float d) {\n\n\tfloat m = 1.0;\n\tfloat period = 2.*pi;\n    vec2 lp = lissajous(iTime, a, b, d)*0.8;\n    for(int i = 1; i <= steps; i++) \n    {\n        float t = float(i)*period / float(steps);\n\t\tt += iTime;\n        vec2 p = lissajous(t, a, b, d)*0.8;\n\n        vec2 pa = uv - p;\n        vec2 ba = lp - p;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        vec2 q = pa - ba*h;\n        m = min( m, dot( q, q ) );\n\t\t\n        lp = p;\n    }\n    \n    return m;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0);\n    fragColor.a = 1.0;\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    float a = texture(iChannel0, uv).r;\n    float b = texture(iChannel0, uv).g;\n\n    int y_ix = int(uv.y > 0.5);\n    int x_ix = int(step(0.333, uv.x) + step(0.666, uv.x));\n\n    int octave = y_ix + 2*x_ix;\n\n    uv -= vec2(0.333, 0.5)*vec2(x_ix, y_ix);\n    uv *= vec2(3, 2);\n    uv *= 2.0;\n    uv -= 1.0;\n\n    float lissajous_dist = pow(\n        render_lissajous(uv, a, b,\n                         float(octave) + iTime), 0.4);\n    float brightness = 1.0 - 8.0*lissajous_dist;\n    vec3 col;\n    if(x_ix == 0) {\n        col = vec3(0.2, 0.2, 1.0);\n    } else if(x_ix == 1) {\n        col = vec3(0.6, 0.1, 0.7);\n    } else {\n        col = vec3(0.8, 0.1, 0.5);\n    }\n    fragColor.rgb = brightness*col;\n \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// low pass filter of the power in each frequency seems to stabilize note identification\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 5) {\n        fragColor = vec4(0, 0, 0, 1);\n    } else {\n        fragColor = 0.95*pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(2))\n                  + 0.05*pow(texture(iChannel1, fragCoord/iResolution.xy), vec4(2));\n    }\n}", "buffer_a_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// sampling of the texture thanks to Gibj\n// https://www.shadertoy.com/view/4dc3zH\n\nconst float A = 0.0370;\nconst float semitone  = pow(2.0, 1.0/12.0);\n\nfloat note_to_freq(int n){\n    return pow(semitone, float(n - 49))*440.;\n}\n\nfloat freq_to_text(float freq){\n    return freq*A/440.;\n}\n\nivec3 current_notes(float[12] texture_indices) {\n\n    float[12] texture_values;\n    for(int i = 0; i < 12; i++) {\n        texture_values[i] = texture(iChannel1, vec2(texture_indices[i], 0.25)).r;\n    }\n\n    ivec3 result = ivec3(0);\n    int count = 0;\n    \n    for(int i = 0; i < 12; i++) {\n        if(texture_values[i] > 0.02) {\n            if(texture_values[i] > texture_values[result[2]]) {\n                result[0] = result[1];\n                result[1] = result[2];\n                result[2] = i;\n            }\n            else if(texture_values[i] > texture_values[result[1]]) {\n                result[0] = result[1];\n                result[1] = i;\n            }\n            else if(texture_values[i] > texture_values[result[0]]) {\n                result[0] = i;\n            }\n        }\n    }\n\n    return result;    \n}\n\nint denominator_from_steps(int note1, int note2) {\n    int n = note2 - note1;\n    if(n < 0) {\n        return 1;\n    }\n    else if(n == 0) {\n        return 1;\n    }\n    else if(n == 1) {\n        return 8;\n    }\n    else if(n == 2) {\n        return 6;\n    }\n    else if(n == 3) {\n        return 7;\n    }\n    else if(n == 4) {\n        return 4;\n    }\n    else if(n == 5) {\n        return 3;\n    }\n    else if(n == 6) {\n        return 32;\n    }\n    else if(n == 7) {\n        return 2;\n    }\n    else if(n == 8) {\n        return 6;\n    }\n    else if(n == 9) {\n        return 8;\n    }\n    else if(n == 10) {\n        return 5;\n    }\n    else {\n        return 11;\n    }\n}\n\nivec2 get_ratios(ivec3 notes) {\n    return ivec2(denominator_from_steps(notes[0], notes[1]),\n                 denominator_from_steps(notes[1], notes[2]));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    int y_ix = int(uv.y > 0.5);\n    int x_ix = int(step(0.333, uv.x) + step(0.666, uv.x));\n\n    int octave = y_ix + 2*x_ix;\n    int start_note = 12*octave + 10;\n    float[12] texture_indices;\n    for(int i = 0; i < 12; i++) {\n        texture_indices[i] = freq_to_text(note_to_freq(start_note + i));\n    }\n    \n    ivec3 current_notes = current_notes(texture_indices);\n    ivec2 ratios = get_ratios(current_notes);\n    \n    fragColor.rg = 0.2*texture(iChannel0, uv).rg + 0.8*vec2(1 + current_notes.yz);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctXyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 106, 106, 144], [146, 146, 206, 206, 665], [667, 667, 723, 723, 1516]], "test": "untested"}
{"id": "dlfcD2", "name": "Colorful 2D Raymarching gyroid", "author": "jackjackdev", "description": "Inspired by Art of Code on YT, tutorial: https://www.youtube.com/watch?v=-adHIyjIYgk&list=PLGmrMu-IwbgsVjE7SAtFaWyhZXyBjJNnO&index=7", "tags": ["raymarching", "gyroid"], "likes": 1, "viewed": 130, "published": 3, "date": "1691184736", "time_retrieved": "2024-07-30T17:40:51.887787", "image_code": "// 2D Raymarching gyroid\n// Used Art of Code's gyroid tutorial on YT as a starting spot, tutorial is here: https://www.youtube.com/watch?v=-adHIyjIYgk&list=PLGmrMu-IwbgsVjE7SAtFaWyhZXyBjJNnO&index=7\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    return abs(dot(sin(p*2.5), cos(p.zxy*.56)) - bias) / scale - thickness;\n}\n\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    \n    float gyroid = sdGyroid(p, 8., .05, 1.5);\n    \n    float d = max(box, gyroid * .7);\n    \n    return d;\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0.5,0.,0), 2.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n    }\n    \nd = pow(abs(d), 0.5); // Apply contrast function\n    col *= 0.;\n    d = sdGyroid(vec3(uv.x, uv.y, cos(iTime)*.1), 10., .05, 1.0);\n    col+= abs(d) * 7.;\n    //col += d*8.;\n    col.rbg = vec3(col.r * sin(iTime) + .5, col.g * cos(iTime) + .5, col.b * sin(iTime)*.5 + .5);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 366, 366, 428], [430, 430, 459, 459, 540], [542, 542, 608, 608, 702], [705, 705, 728, 728, 877], [882, 882, 916, 916, 1127], [1129, 1129, 1153, 1153, 1307], [1309, 1309, 1359, 1359, 1544], [1546, 1546, 1603, 1603, 2420]], "test": "untested"}
{"id": "mlfyD2", "name": "Line Pair", "author": "QuantumSuper", "description": "An auto-VJ of a pair of snake/flame-like sine shapes with a centered plus.\n\n- Use with music in iChannel0 -", "tags": ["2d", "music"], "likes": 5, "viewed": 237, "published": 3, "date": "1691183066", "time_retrieved": "2024-07-30T17:40:52.670694", "image_code": "// Line Pair 0.2.230804 by QuantumSuper\n// auto-vj of a pair of snake/flame-like sine shapes with a centered plus\n// (colors, shapes, and animations are based on sound)\n// \n// - use with music in iChannel0 -\n\n#define aTime 12.7/6.*iTime\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nfloat sdCross( vec2 p, vec2 b, float r){ //source: https://iquilezles.org/articles/distfunctions2d/\n    p = abs(p); p = (p.y>p.x)? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max( q.y, q.x);\n    vec2  w = (k>0.)? q : -vec2( p.x-b.y, k);\n    return sign(k) * length(max(w,0.)) + r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    compressFft(); //initializes fft, ffts\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n\n    fragColor = vec4(\n        .01*fft.w / max( .0, sdCross( uv, vec2(.4,.1) * pow(fft.x,6.) * .4, .0)) + //cross\n        (.01+.09*fft.z) / max( .0, length( abs( sin(aTime + uv.y*4. + ffts.w) * sin(aTime*2. + fft.w) *.2 - abs(uv.x) + .5))) //side-sinus\n        * sin(vec3(.1,.3,.7)*aTime + uv.y + ffts.xyz), 1.); //color\n}", "image_inputs": [{"id": 34339, "src": "https://soundcloud.com/mikaheggemann/heggemann-tommy-devito-feat-gutschi-schnellste-brille-instrumental", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 308, 399, 1521], [1523, 1523, 1563, 1622, 1809], [1811, 1811, 1866, 1866, 2354]], "test": "untested"}
{"id": "dlXcDj", "name": "GLSL Fractals", "author": "notmysql", "description": "a fractal", "tags": ["fractals"], "likes": 1, "viewed": 185, "published": 3, "date": "1691173799", "time_retrieved": "2024-07-30T17:40:53.521419", "image_code": "// Base completed ShaderToy program for a Hack Club Jam\n// https://code-jams.hackclub.dev/jam/glsl-shaders\n// Remember to RECOMPILE and PRESS PLAY\n\n// Go to https://www.shadertoy.com/view/clfcRs to see a COMPLETED project\n\n\n// Squares a given complex number\nvec2 cSquare( in vec2 z ) \n{\n    return vec2(\n            z.x * z.x - z.y * z.y,\n            2.0 * z.x * z.y\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 c = fragCoord/iResolution.x;\n    \n    // Scale [lower is more zoomed in]\n    float scale = 4.0;\n    \n    c *= scale;\n    \n    // Move set into view\n    c += vec2(-2.7,-1.1);\n    \n    // Maximum number of iterations\n    int maxIterations = 256;\n\n\t// Starting point\n\tvec2 Z = vec2(0,0);\n    \n    for(int i = 0; i < maxIterations; i++)\n    {\n        vec2 oldZ = Z;\n        Z = cSquare(oldZ) + c;\n        \n        if(dot(Z, Z) > 20.0) {\n            // Normalize i for brightness\n            float brightness = (float(i) - log2(log2(dot(Z,Z))) + 4.0) / float(maxIterations);\n            \n            // multipliers for ( R   G   B ) values\n            vec3 weights = vec3(15.0, 5.0, 4.0);\n            \n            fragColor = vec4(vec3(brightness) * weights, 1.0);\n            break;\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 258, 286, 286, 379]], "test": "untested"}
{"id": "clfcRs", "name": "Orpheus Fractal!", "author": "notmysql", "description": "fractal", "tags": ["fractal"], "likes": 1, "viewed": 189, "published": 3, "date": "1691173761", "time_retrieved": "2024-07-30T17:40:54.282385", "image_code": "// Completed ShaderToy program for a Hack Club Jam\n// https://code-jams.hackclub.dev/jam/glsl-shaders\n// Remember to RECOMPILE and PRESS PLAY\n\n// Go to https://www.shadertoy.com/view/dlXcDj to see a BASE project\n// Want another example?? => https://www.shadertoy.com/view/mlsczN\n\n\n// Squares a given complex number\nvec2 cSquare( in vec2 z ) \n{\n    return vec2(\n            z.x * z.y - z.y * z.y,\n            2.0 * z.x * z.x\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 c = fragCoord/iResolution.x;\n    \n    // Scale [lower is more zoomed in]\n    float scale = 5.5;\n    \n    c *= scale;\n    \n    // Move set into view\n    c += vec2(-3.0,-1.5);\n    \n    // Maximum number of iterations\n    int maxIterations = 256;\n\n\t// Starting point\n\tvec2 Z = vec2(0,0);\n    \n    for(int i = 0; i < maxIterations; i++)\n    {\n        // Z(n+1) = Z(n)^2 + C\n        vec2 oldZ = Z;\n        Z = (cSquare(oldZ) + (c/cos(iTime/5.0)/10.0) + (oldZ * sin(iTime/2.0)/0.5)) + (sin(c)-cos(c) + tan(c));\n        \n        if(dot(Z, Z) > 100.0) {\n            // get smooth iters\n            float brightness = (float(i) - log2(log2(dot(Z,Z))) + 4.0) / float(maxIterations);\n            \n            // multipliers for ( R   G   B ) values\n            vec3 weights = vec3(10.0 + sin(iTime/5.0) * 5.0,10.0 + cos(iTime/5.0) * 5.0,2.0);\n            \n            fragColor = vec4(vec3(brightness * weights *2.0), 1.0);\n            break;\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 315, 343, 343, 436]], "test": "untested"}
{"id": "dtXyDj", "name": "atmospheric scattering - 1st try", "author": "MacSlow", "description": "It has been far too long since I did my last shader here on ShaderToy. This is a good opportunity to try something new this time around. So here is my first attempt at 'atmosphereic scattering'. The scene does not really 'sell' it yet. But kind of works.", "tags": ["3d", "raymarching", "scattering", "cineshader"], "likes": 22, "viewed": 1324, "published": 3, "date": "1691173362", "time_retrieved": "2024-07-30T17:40:55.043350", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// A first attempt of getting an effect of 'atmospheric scattering' working.\n//\n// Copyright 2023 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 64; \nconst float EPSILON = .0001;\nconst float STEP_BIAS = .95;\n\nfloat sdPlane (vec3 p, float d)\n{\n    return p.y - d;\n}\n\nfloat sdSphere (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat map (vec3 p)\n{\n    float ground = sdPlane (p, -.2);\n    float r = .01*sin(120.*p.y*p.x + 5.*iTime);\n    float ball1 = sdSphere (p - vec3 (2.*cos(iTime), .2, sin(iTime)), .1);\n    float ball2 = sdSphere (p - vec3 (.3, .4 + .2*cos(3.*iTime), .0), .2);\n    float ball3 = sdSphere (p - vec3 (-.2, .3, -.2), .2);\n    float ball4 = sdSphere (p - vec3 (-.4, .2, .4), .3 + r); \n    float balls = min (ball1, min (ball2, min (ball3, ball4)));\n\n    return min (ground, balls);\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (.001, .0);\n    float d = map (p);\n    vec3 n = vec3 (map (p + e.xyy) - d,\n                   map (p + e.yxy) - d,\n                   map (p + e.yyx) - d); \n\n    return normalize (n);\n}\n\nfloat shadow (vec3 ro, vec3 rd) \n{\n    float value = 1.; \n    const float steps = 10.;\n    const float s = 1./steps;\n    float t = .25;\n    float d = .0; \n\n    for (float i = .0; i < steps; ++i) {\n        d = map (ro + t*rd);\n        value = clamp (min (value, 8.*d/t), .0, 1.);\n        if (abs (d) < EPSILON*(1. + .125*d)) break;\n        t += d*STEP_BIAS;\n    }   \n\n    return value;\n}\n\nconst vec3 lpos1 = vec3 (-1.);\nconst vec3 lcol1 = vec3 (.3, .2, .2);\n\nfloat rnd (vec3 value)\n{\n    float v = dot (value, vec3 (12.324, 34.439, 78.1858));\n    return fract (sin (v) * 783.94 + 82.2453);\n}\n\nfloat raymarch (vec3 ro, vec3 rd, out float atmophere, out float attenuation)\n{\n    float d = .0;\n    float t = .0;\n\n    atmophere = .0;\n    attenuation = 1.;\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + d*rd;\n        float ldist = distance (p, lpos1 + .15*rnd(rd));\n        float illum = 1./(ldist*ldist);\n        vec3 ldir = normalize (p - lpos1);\n        vec3 n = normal (p);\n        float sha = shadow (p, normalize (p - lpos1));\n        t = map (p);\n        atmophere += illum*.25*attenuation*sha;\n        if (abs (t) < EPSILON*(1. + .125*t)) {\n            break;\n        }\n        attenuation *= .95;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 light (vec3 light_pos, vec3 light_col, vec3 surf_pos, vec3 surf_norm, vec3 rd)\n{\n    vec3 light_dir = normalize (surf_pos - light_pos);\n    float light_dist = distance (surf_pos, light_pos);\n    float diffuse = max (.0, dot (surf_norm, light_dir));\n    float sha = shadow (surf_pos - 0.01*surf_norm, light_dir);\n    vec3 h = normalize (light_dir - rd);\n    float spec = pow (max (dot (h, surf_norm), .0), 4.);\n\n    return sha*diffuse*light_col*spec;\n}\n\nvec3 shade (vec3 ro, vec3 rd, vec3 p, vec3 n)\n{\n    float attenuation = 1.0;\n    float atmosphere = 0.0;\n\n    vec3 lpos2 = vec3 (.0, -2., .0);\n    vec3 lcol2 = vec3 (.6);\n    vec3 lpos3 = vec3 (2., -1.5, .0);\n    vec3 lcol3 = vec3 (.1, .4, .8);\n    vec3 lamb = vec3 (.1);\n\n    return lamb +\n           light (lpos1, lcol1, p, n, rd) +\n           light (lpos2, lcol2, p, n, rd) +\n           light (lpos3, lcol3, p, n, rd);\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1.0, .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward*zoom);\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float camdist = 4.;\n    vec3 ro = vec3 (camdist*cos(iTime), .8 + .4*cos (2.*iTime), camdist*sin(iTime));\n    vec3 aim = vec3 (.0, .2, .0);\n    float zoom = 1.25;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    float atmophere = .0;\n    float attenuation = .0;\n    float d = raymarch (ro, rd, atmophere, attenuation);\n    float fog = 1./(1. + d*d*.1);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p);\n    vec3 color = fog*shade (ro, rd, p, n);\n    color += atmophere*(lcol1);\n\n    float alpha = 1.0;\n\n    // tone-mapping\n    color = color/(1. + color);\n\n    // 'film-grain'\n    color += .025*rnd(rd);\n\n    // tint\n    color *= vec3 (.975, .9, .825);\n\n    // gamma-correction\n    color = .25*color + .75*sqrt (color);\n\n    // color-correction\n    color = smoothstep (vec3(.0125), vec3(.9875), color);\n\n    fragColor = vec4 (color, alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXyDj.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1042, 1042, 1075, 1075, 1097], [1099, 1099, 1133, 1133, 1162], [1164, 1164, 1184, 1184, 1638], [1640, 1640, 1662, 1662, 1866], [1868, 1868, 1902, 1902, 2254], [2326, 2326, 2350, 2350, 2458], [2460, 2460, 2539, 2539, 3134], [3136, 3136, 3221, 3221, 3592], [3594, 3594, 3641, 3641, 4017], [4019, 4019, 4073, 4073, 4402], [4404, 4404, 4461, 4511, 5456]], "test": "untested"}
{"id": "dtXcWj", "name": "blueish bitorderinversion noise2", "author": "FabriceNeyret2", "description": "base version of flockaroo's https://shadertoy.com/view/mllcDB\nclick to see gradient dithering", "tags": ["bluenoise"], "likes": 13, "viewed": 297, "published": 3, "date": "1691170395", "time_retrieved": "2024-07-30T17:40:55.816283", "image_code": "// Fork of \"blueish bitorder inversion noise\" by flockaroo. https://shadertoy.com/view/mllcDB\n// just show the pure noise or gradient dithering.\n\n\n// created by florian berger (flockaroo) - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// bitorder inversion blue-noise\n//\n// some noise experiments i did some while ago with bitorder-inversion to retrieve some blue-ish noise\n//\n// comparing 3 noises\n// left to right: (none), whitenoise, bitinvnoise, bluenoise\n\nfloat flockaroo_bitinv_noise(ivec2 v) { \n    v &= 255; \n    \n   // for(int b = 15 ; b > 0 ; b -= 2 , v >>= 1 ) \n   //     v |= ( v & 1 ) << b;\n   \n    v = ( v& 0x0F ) << 4  |  ( v & 0xF0 ) >> 4 ;             //  butterfly parallel optimization\n    v = ( v& 0x33 ) << 2  |  ( v & 0xCC ) >> 2 ;\n    v = ( v& 0x55 ) << 1  |  ( v & 0xAA ) >> 1 ;\n\n    return float( (v.x*7+v.y*73) % 255 ) / 254.; \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float PixScale = float( 1 + int(iTime)%3 ); \n         u /= PixScale;\n    vec2 R = iResolution.xy/PixScale,\n         U = u/R;\n         \n    int i = int(4.*U.x);\n    \n    float r = i == 0 ? .5\n            : i == 1 ? textureLod(iChannel0,u/256.,0.).x     // white noise\n            : i == 2 ? flockaroo_bitinv_noise(ivec2(u))      // flockaroo procedural pseudobluenoise\n            :          textureLod(iChannel1,u/1024.,0.).x;   // ref bluenoise\n    \n    O = iMouse.z > 0. ? vec4( i > 0 ? step(1.,r+U.y) : U.y ) // gradient\n                      : vec4( r );                           // noise texture \n   \n    if ( int(u) % int(R/4.) == 0 ) O = vec4(.6,0,0,1);       // separator\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtXcWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[511, 511, 550, 550, 905], [907, 907, 945, 945, 1632]], "test": "untested"}
{"id": "ctfyD2", "name": "HG vs HG-D Scattering Function", "author": "codyjbennett", "description": "Side-by-side comparison of Henyey-Greenstein (top, a=0) and Henyey-Greenstein-Draine (bottom, a=1) phase functions from https://research.nvidia.com/labs/rtr/approximate-mie/publications/approximate-mie.pdf.\n\nDrag to tweak the scattering direction.", "tags": ["light", "scattering", "mie", "phase", "henyeygreenstein", "draine"], "likes": 10, "viewed": 219, "published": 3, "date": "1691166753", "time_retrieved": "2024-07-30T17:40:56.608167", "image_code": "const float PI = 3.14159265359;\n\n// https://research.nvidia.com/labs/rtr/approximate-mie/publications/approximate-mie.pdf\n// https://desmos.com/calculator/sueequpmkl\nfloat HenyeyGreensteinDraine(float g, float u, float a) {\n  float gg = g * g;\n  float uu = u * u;\n\n  const float I = 1.0 / (4.0 * PI);\n  float HG = (1.0 - gg) / pow(1.0 + gg - 2.0 * g * u, 1.5);\n  float D = (1.5 * a * uu + 1.5) / (a * gg + 0.5 * a + 1.5);\n\n  return I * HG * D;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord * 2.0 / iResolution.xy - 1.0;\n\n  float g = iMouse.x * 2.0 / iResolution.x - 1.0;\n  if (iMouse.xy == vec2(0)) g = 0.7;\n\n  bool isTop = fragCoord.y >= iResolution.y / 2.0;\n  if (isTop) uv.y = (uv.y - 0.5) * 2.0;\n  else uv.y = (uv.y + 0.5) * 2.0;\n\n  float u = uv.x / length(uv);\n  float a = isTop ? 0.0 : 1.0;\n  float p = HenyeyGreensteinDraine(g, u, a);\n\n  fragColor = vec4(vec3(pow(p, 0.4545)), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 166, 223, 223, 445], [447, 447, 502, 502, 924]], "test": "untested"}
{"id": "mllcDB", "name": "blueish bitorder inversion noise", "author": "flockaroo", "description": "...saw some nice blue-noise halftone examples recently (from FabriceNeyret2 and Xor).\nand wanted to share my own experiments using bitorder-inversion for generating some blue-ish noise (3rd column)\nleft to right: originial, whitenoise, mynoise, bluenoise\n", "tags": ["bluenoise"], "likes": 18, "viewed": 369, "published": 3, "date": "1691163342", "time_retrieved": "2024-07-30T17:40:57.375116", "image_code": "// created by florian berger (flockaroo) - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// bitorder inversion blue-noise\n//\n// some noise experiments i did some while ago with bitorder-inversion to retrieve some blue-ish noise\n//\n// comparing 3 noises\n// left to right: (none), whitenoise, bitinvnoise, bluenoise\n//\n\n\nfloat flockaroo_bitinv_noise(ivec2 v) { v&=255; for(int b=15;b>0;b-=2,v>>=1) v|=(v&1)<<b; return float((v.x*15+v.y*73)%255)/254.; }\n//                                                                                                           ^also 7 or 1 works nicely instead of 15 here\n//maybe there's even some better prime-factors to be found than 73 and 15 - well 15 isnt prime anway ;-)\n\n\n\n//-----------------------------------------------------------------------------------------\n// simplification of https://www.shadertoy.com/view/MdcXDs\n\nfloat truchetRand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\nfloat truchetArc(vec3 pos, float radius) { pos=fract(pos); float r=length(pos.xy); return length(vec2(r-0.5,pos.z-0.5))-radius; }\n\nfloat truchetCell(vec3 pos, float r)\n{\n    return min(min(\n        truchetArc(pos.xyz               ,r),\n        truchetArc(pos.zxy*vec3( 1,-1, 1),r)),\n        truchetArc(pos.yzx*vec3(-1,-1, 1),r));\n}\n\nfloat truchetDist(vec3 pos, float r)\n{\n    vec3 cellpos=fract(pos);\n    vec3 gridpos=floor(pos);\n    float rnd=truchetRand(gridpos);\n    vec3 fact=floor(mod(rnd*vec3(2.0,4.0,8.0),vec3(2.0)))*2.0-vec3(1.0);\n    return truchetCell(cellpos*fact,r);\n}\n\nfloat dist(vec3 pos)\n{\n    vec3 pos0=pos;\n    float sc=2.;\n    for(int i=0;i<10;i++) {\n        vec3 dir=normalize(texelFetch(iChannel0,ivec2(i,0),0).xyz-.5);\n        pos+=sin(dot(dir,pos0)/sc)*dir.zxy*vec3(1,-1,1)*sc*.15;\n        sc*=.9;\n    }\n    return truchetDist(pos*0.006,0.13+0.05*cos(0.02*(pos.x+pos.y+pos.z)))/0.006;\n}\n\nvec3 getGrad(vec3 pos, float delta)\n{\n    vec3 eps=vec3(delta,0,0);\n    float d=dist(pos);\n    return vec3(dist(pos+eps.xyy)-d, dist(pos+eps.yxy)-d, dist(pos+eps.yyx)-d)/delta;\n}\n\n\nvec4 march(vec3 pos0, vec3 dir, float maxDist)\n{\n    vec3 colbg = vec3(.9,1,1.1);\n\n    vec3 p = pos0;\n\n    float eps=0.0001;\n    for( int i=0 ; i<200 ; i++ )\n    {\n        float d=dist(p);\n        p+=dir*d*.5;\n        if(d<eps) break;\n        if(d>maxDist) break;\n    }\n\n    vec3 n=normalize(getGrad(p,0.01));\n\n    float ao = 1.0;\n    for(float sc=15.;sc>.01;sc*=.6) ao*=clamp(.7+.25*dist(p+n*sc)/sc,0.,1.);\n\n    vec4 col;\n    col.xyz=vec3(ao)*(n*.05+.95)*vec3(1.1,1,.9)*vec3(1,.9,.7);\n\n    float fog = 1.0-exp(-length(p-pos0)/maxDist);\n    col.xyz = mix(col.xyz,colbg,fog);\n\n    return col*col;\n}\n\n//-----------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PixScale=1.+float(int(iTime)%3);\n    fragCoord=(floor(fragCoord/PixScale)+.5)*PixScale;\n    vec2 myRes=iResolution.xy;\n    vec3 pos=vec3(iTime*50.,0,0);\n    vec2 scoord=(fragCoord.xy-myRes*.5)/myRes.x;\n    float phi = iTime*.333;\n    float th = iTime*.23423;\n    vec3 dir0 = vec3(sin(phi)*cos(th),cos(phi)*cos(th),sin(th));\n    vec3 left = normalize(vec3(dir0.yx*vec2(-1,1),0));\n    vec3 up=cross(left,dir0);\n    vec3 dir=normalize(dir0+left*scoord.x*2.+up*scoord.y*2.);\n    fragColor = march(pos,dir,1000.0);\n    \n    vec2 Res=iResolution.xy/PixScale;\n    \n    fragCoord/=PixScale;\n    // halftoning\n    #if 1\n    float lnum=3.;\n    float r=flockaroo_bitinv_noise(ivec2(fragCoord));\n    if (fragCoord.y<Res.y*.3) { fragColor=vec4(dot(fragColor.xyz,vec3(.333))); lnum=1.; }\n    if (fragCoord.x>Res.x*.75) r=textureLod(iChannel1,fragCoord/1024.,0.).x;\n    if (fragCoord.x<Res.x*.5) r=textureLod(iChannel0,fragCoord/256.,0.).x;\n    if (fragCoord.x>Res.x*.25) fragColor =floor(fragColor*lnum+r)/(lnum); else r=.5;\n    if (fragCoord.y<.1*Res.y) { fragColor=vec4(r); }\n    if (int(fragCoord.x)==int(Res.x*.25)) fragColor =vec4(.6,0,0,1);\n    if (int(fragCoord.x)==int(Res.x*.5)) fragColor =vec4(.6,0,0,1);\n    if (int(fragCoord.x)==int(Res.x*.75)) fragColor =vec4(.6,0,0,1);\n    #endif\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllcDB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[368, 368, 407, 407, 499], [914, 914, 941, 941, 1025], [1027, 1027, 1069, 1069, 1156], [1158, 1158, 1196, 1196, 1358], [1360, 1360, 1398, 1398, 1607], [1609, 1609, 1631, 1631, 1935], [1937, 1937, 1974, 1974, 2115], [2118, 2118, 2166, 2166, 2715], [2810, 2810, 2867, 2867, 4160]], "test": "untested"}
{"id": "clXyWj", "name": "inverse spline", "author": "FabriceNeyret2", "description": "solving the inverse of a spline:  in green, x = invspline( y samples ).\nCompulsory to produce the yellow dots, for instance.", "tags": ["spline", "inverse"], "likes": 8, "viewed": 199, "published": 3, "date": "1691158295", "time_retrieved": "2024-07-30T17:40:58.139073", "image_code": "// more complexe variant  h.spline + (1-h).x → here: https://www.shadertoy.com/view/DlByz1\n\n#define S(v)      smoothstep( 1.5, 0., abs(v)/fwidth(v) )\n#define dot(x,y)  smoothstep( 3./R.y, 0.,length(U-vec2(x,y)) - 5./R.y )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;\n \n    float y = U.y, x = U.x,  R3 = sqrt(3.),\n          a = 1. -2.*y, b = 2.*sqrt(y*(1.-y)), /* l = pow(a*a+b*b,1./6.),*/ A = atan(b,a)/3., // https://www.wolframalpha.com/input?i=solve%28y%3Dx*x*%283-2*x%29%2C+x%29\n                                               // hey,l = 1 !\n/*       X1 = (  (l+1./l)* cos(A)                        + 1. ) / 2.,\n         X2 = ( -(l+1./l)* cos(A) + R3* (l+1./l)*sin(A)  + 2. ) / 4.,   // ← the interesting one\n         X3 = ( -(l+1./l)* cos(A) - R3* (l+1./l)*sin(A)  + 2. ) / 4.;\n*/       X1 =     cos(A)               + .5,\n         X2 = ( - cos(A) + R3* sin(A)  + 1. ) / 2.,   // ← the interesting one\n         X3 = ( - cos(A) - R3* sin(A)  + 1. ) / 2.;\n\n    O = vec4( S( U.y - x*x*(3.-2.*x) ) * step( 1., mod(u.x/4.,2.) ) ) ; // dashed spline\n    if ( y*(1.-y) > 0. )          \n      O += vec4( S(U.x-X1 ) ,  S(U.x-X2 ), S(U.x-X3 ), 1 );             // R,G,B = 3 solutions\n      \n    // --- example of uses -------------------------------  \n/*\n#define invspline(y) ( a = 1. -2.*y, b = 2.*sqrt(y*(1.-y)), l = pow(a*a+b*b,1./6.), A = atan(b,a)/3., \\\n                       ( -(l+1./l)*cos(A) + 2.*R3*l*sin(A)  + 2. ) / 4.                               \\\n                     ) */\n#define invspline(y) ( a = 1. -2.*y, b = 2.*sqrt(y*(1.-y)), A = atan(b,a)/3., \\\n                       ( -cos(A) + R3*sin(A)  + 1. ) / 2.                     \\\n                     )\n\n    float t = iTime;\n\n    U.y += .2;                                                      // --- direct draw y=spline(x)\n    x = U.x;\n    x = round(x*20.-t)/20. +t/20.;                                  // steps\n    y =  x*x*(3.-2.*x);                                             // spline\n    if ( x*(1.-x) > 0. )\n      O.r += dot(x,y);                                              // dot every dx steps\n\n\n    U.y += .2;                                                      // --- inverse draw x=invspline(y)\n    y = U.y, y = round(y*20.-t)/20. +t/20.;                         // steps\n    x = invspline(y);\n    if ( y*(1.-y) > 0. )\n      O.g += dot(x,y);                                              // dot every dy steps\n\n\n    y = U.y -= .2;                                                  // --- same, using x as simple parameterization \n    x = invspline(y);\n    \n    x = round(x*20.-t)/20. +t/20.;                                  // redo the steps and spline()\n    y =  x*x*(3.-2.*x);                                             // spline\n    if ( x*(1.-x) > 0. )\n      O.rg += dot(-1.,y);                                           // free to remap to anything, e.g. vertical line\n    R.y*=3.; if ( U.x>-1. && U.x<x ) O.rg += dot(U.x,y)*.2;         // horizontal lines                     \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 263, 263, 3030]], "test": "untested"}
{"id": "clXyWB", "name": "you like kissing boys don't you?", "author": "dankcatlord", "description": "run-length encoding is magic", "tags": ["music", "synth", "tracker", "meme", "rle", "boykisser"], "likes": 16, "viewed": 578, "published": 3, "date": "1691122947", "time_retrieved": "2024-07-30T17:40:59.091527", "image_code": "// Everything that isn't credited to someone else is licensed under the GPLv3\n// (https://www.gnu.org/licenses/gpl-3.0.html)\n\nvec2 imgUV(vec2 uv) { return fract(uv) * vec2(320.0, 240.0) / iResolution.xy; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n\n    float aspect = iResolution.y / iResolution.x;\n\n    uv.x += (abs(mod(iTime * 0.5, 4.0) - 2.0) - 1.0) * 0.5625;\n    uv.y += (abs(mod(iTime / aspect, 4.0) - 2.0) - 1.0) * (aspect - 0.3333333);\n\n    vec3 dir = normalize(vec3(uv, 1.0));\n    vec3 norm = vec3(sin(iTime * TAU * 0.25), 0.0, cos(iTime * TAU * 0.25));\n\n    uv.x /= norm.z;\n    uv /= uv.x * norm.x + 2.0;\n    uv *= 6.0;\n    \n    uv.x *= 0.75;\n    \n    vec3 col;\n    if (uv.x < -1.0 || uv.x > 1.0 || uv.y < -1.0 || uv.y > 1.0) col = vec3(0.0);\n    else {\n        col = texture(iChannel0, imgUV(uv * 0.5 + 0.5)).rgb * sqrt(abs(dot(dir, norm)));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Everything that isn't credited to someone else is licensed under the GPLv3\n// (https://www.gnu.org/licenses/gpl-3.0.html)\n\n////////////////////////////////////////\n// Silly cat - mauzymice\n// https://www.furaffinity.net/view/47768433/\n\nuint image[] = uint[](\n\n\t2139062143u, 2139062143u, 2139062143u,  931102591u,  427960706u,  965410946u, 1887580804u,\n\t 428026242u,  898498689u, 1837446020u,  428026242u,  881078421u,  713191044u,  109385859u,\n\t 914631819u,  713256323u,  209787012u,  931408266u,  730033794u,  276895620u,  948184712u,\n\t 763522690u,  327227012u,  964960904u,  780299906u,  344069763u,  981672072u,  797077122u,\n\t 377623939u,  998448520u,  797141892u,  427955332u,  998448262u,  813919108u,  461509508u,\n\t1015224710u,  847408004u,  495063684u, 1015224453u,  864185220u,  495129219u, 1032000902u,\n\t 881027971u,  528683395u, 1032000645u,  881027971u,  528683396u, 1065554565u,  914516866u,\n\t 562237827u, 1065554308u,  931294082u,  578949252u, 1082330757u,  931294082u,  579014533u,\n\t1082330501u,  948136578u,  595791748u, 1099107205u,  981691010u,  629280643u, 1099106693u,\n\t 998402690u,  646057604u, 1115883397u, 1015179906u,  646122884u, 1115883141u, 1032022402u,\n\t 662965635u, 1132659844u, 1048799618u,  662965635u, 1132659333u, 1065511298u,  679677316u,\n\t1149370757u, 1082288514u,  696388741u, 1149370756u, 1099065730u,  713231237u, 1149370499u,\n\t1115842946u,  696519556u, 1770144903u,  159597698u, 1149707657u, 1149397378u,  646645635u,\n\t1770144902u,   42157442u, 1149511823u, 1166174594u,  713228686u, 1770144900u,   76236418u,\n\t1149381762u, 1199729026u, 2181070726u, 2235990633u, 1770127999u, 2139309698u, 2187952644u,\n\t  92243012u, 1115842946u, 2181463941u, 2269151849u, 1770129023u, 2139504514u, 2187952648u,\n\t 176129597u, 1015179650u, 2181857157u, 2302444137u, 2188087052u, 2805695081u, 2187952747u,\n\t2188092988u, 2420408937u, 2187952761u, 1770147711u, 2186248066u, 1333756521u, 2139253122u,\n\t2187952974u, 1770212991u, 2186182530u, 1316979306u, 2139253378u, 2188018254u, 1786924671u,\n\t2186182530u, 1316979306u, 2139253378u, 2188018254u, 1786924671u, 2186116995u, 1300202346u,\n\t2139253634u, 2188083789u, 1803766911u, 2202828674u, 1283424875u, 2139253890u, 2188149324u,\n\t1820543871u, 2202763138u, 1233093484u, 2139319683u, 2188280649u, 1870809471u, 2202566530u,\n\t1216316015u, 2139254659u, 2205188680u, 1887651455u, 2202435459u, 1182761585u, 2139320962u,\n\t2199755785u,   58688370u, 1937972387u,  481196162u, 1954772098u,   92540053u, 1954749315u,\n\t 782181763u,  629280405u,  360871299u,  244657074u, 1988240515u,  733091202u,  579014293u,\n\t 344159876u,  714541457u,  545460117u,  478377605u,  714542979u,  545459862u,  461600900u,\n\t 697765763u,  511905687u,  444824195u,  697766019u,  495128471u,  428047236u,  697766019u,\n\t 444797079u,  411270277u,  697831555u,  428019863u,  394493573u,  697831555u,  394400151u,\n\t 394493830u,  697831810u,  377622935u, 2197979013u, 2551284246u, 2198968105u,   58689043u,\n\t 293803395u,  295119256u, 2139427459u, 2199159558u, 2536085521u, 2199093778u,  327419775u,\n\t 697832066u,  327291543u,  293896076u,  697832067u,  310579863u, 1988625034u,  310579587u,\n\t 311896472u,    8850563u, 1988821637u,  327290501u,  328673688u,   92932994u,  243627661u,\n\t 697832322u,  193074071u, 1602359434u,  243536261u,  697832322u,  193074071u, 1602426754u,\n\t 327295369u,  328673688u, 1602430594u,  377553041u,  697832322u,  629281687u,    9527683u,\n\t 327355019u,  328673688u, 1652827266u,    9110146u,  327355018u,  345385368u, 1669538946u,\n\t   8522627u,  344066442u,  345385368u, 1686315906u,  159585923u,  714544258u,  562173078u,\n\t 360932741u,  360843651u,  345385622u, 1720000642u,  360850307u,  362032022u, 1753489538u,\n\t 360850051u,  362032022u, 1786978178u,  360850051u,  362032277u, 1803820674u,  360849795u,\n\t 361966997u, 1820597634u,  360849540u,  378678677u, 1854151810u,  377626500u,  412037011u,\n\t1887705986u,  360914564u,  395194515u, 1921260163u,  377691524u,  411906449u, 1954814339u,\n\t 394403204u,  428553103u, 1988368770u,  411179909u,  411196300u,  444954756u, 1535842435u,\n\t2055477122u,  428022404u, 2105833097u,  444799364u, 1502220678u,  394690180u, 1485648003u,\n\t2248179588u, 2368766487u,   58688344u, 1468877190u, 2231795587u,  448925823u, 2215083907u,\n\t 130289279u, 2139230146u, 3322643209u, 3288712570u,  109019665u, 2059995523u,  298124485u,\n\t2214887299u, 3346582024u, 2215822595u,  142803839u,  163709382u,   46688962u, 2139297220u,\n\t3288891907u, 3305554436u, 3254830441u, 2199372801u,  142738047u,   79824323u,   46361031u,\n\t 415433154u, 2197847940u, 3271934472u, 3261777922u, 2216347395u, 3272704895u, 3346319104u,\n\t2206106395u, 3329674001u, 2206040861u, 2186660113u, 2216674335u, 3339879291u, 3256910678u,\n\t2205909793u, 2203632914u, 2205778758u, 2252260116u, 2202501906u, 2371191673u, 2219345163u,\n\t2455077750u, 2236188165u, 2236908405u, 2219546114u, 2185658997u, 2399765769u, 2188673871u,\n\t2231796806u, 2203158798u, 2252768115u, 2188150784u, 2370274163u, 2188608110u, 2188347978u,\n\t2219606643u, 2188543600u,  411181951u, 2139255433u, 2417067041u, 2182513266u,  260376191u,\n\t 210007949u, 2248376203u, 2675611650u, 2432992895u, 2090926463u, 2140079494u, 2315554822u,\n\t 964658808u, 2139648647u, 2339210813u, 1753759871u, 2319744906u, 1233095264u, 2139773069u,\n\t2370866513u, 1234130559u, 2388426634u, 1602192968u, 2139244687u, 2139066211u, 2382397999u,\n\t2183954303u, 2139067655u, 2466808606u, 1551860286u, 1049561988u, 2203877251u, 1568637786u,\n\t2139380355u, 2237236315u, 1501846399u, 2203877252u, 1551860571u, 2139314819u, 2203747420u,\n\t1501846655u, 2220654468u, 1568637785u, 2139314564u, 2203551069u, 1468358271u, 2254339971u,\n\t1618969429u, 2139313286u, 2203289184u, 1417962111u, 2204270467u, 1618969428u, 2139248260u,\n\t2203485535u, 1468358015u, 2220654467u, 1535083098u, 2139315076u, 2203878489u, 1585666431u,\n\t2203549571u, 1451197279u, 2139316356u, 2220983380u, 1669550975u, 2203221891u, 1384088165u,\n\t2139317635u, 2282062417u, 1350533975u, 2139314322u, 2203619919u,   59461503u, 2139249026u,\n\t2203681630u, 1501781375u, 2203877251u, 1551860315u, 2139249539u, 2187101019u, 1552112511u,\n\t2186968963u, 1518306141u, 2139250306u, 2187232089u, 1585666431u, 2203615106u, 1467974495u,\n\t2139316099u, 2187428439u, 1635997311u, 2203484034u, 1451197025u, 2139251330u, 2187493974u,\n\t1652708991u, 2203418498u, 1417642850u, 2139316867u, 2187625044u, 1686262911u, 2203287426u,\n\t1384088420u, 2139317379u, 2204468050u, 1703104895u, 2139062147u, 2139062143u, 2139062143u,\n\t4280319871u\n);\n////////////////////////////////////////\n\nint getCol(uint idx) {\n    uint a = 0u;\n    int ret;\n    for (int i = 0; i < image.length(); i++) {\n        uint b = image[i];\n        for (int j = 0; j < 4; j++) {\n            uint c = b & 255u;\n            if ((b & 128u) == 128u) {\n                if ((b & 192u) == 192u) {\n                    if (b == 255u) return -1;\n                    else ret = 2;\n                } else ret = 1;\n                a += b & 63u;\n            } else {\n                ret = 0;\n                a += b & 127u;\n            }\n            a += 1u;\n            if (idx < a) return ret;\n            b >>= 8;\n        }\n    }\n    return -1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 initCol = texture(iChannel0, fragCoord / iResolution.xy);\n    if (iFrame == 0 || initCol == vec4(0.0)) {\n        vec3 col;\n        switch (getCol((239u - uint(fragCoord.y) % 240u) * 320u + (uint(fragCoord.x) % 320u))) {\n            case 0: col = vec3(1.0); break;\n            case 1: col = vec3(20.0 / 255.0); break;\n            case 2: col = vec3(1.0, vec2(23.0 / 255.0)); break;\n            case -1: col = vec3(1.0,0.0,1.0);\n        }\n        fragColor = vec4(col,1.0);\n    } else {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Everything that isn't credited to someone else is licensed under the GPLv3\n// (https://www.gnu.org/licenses/gpl-3.0.html)\n\n////////////////////////////////////////\n// eek! - surasshu\n// https://modarchive.org/index.php?request=view_by_moduleid&query=186901\n\nuint pattern1_1[16] = uint[](\n\n        /* 03020100 */\n/* 00 */ 0x54545352u,\n/* 04 */ 0x0000005Bu,\n/* 08 */ 0x0000005Eu,\n/* 0C */ 0x00000060u,\n/* 10 */ 0x005A005Bu,\n/* 14 */ 0x59595959u,\n/* 18 */ 0x00000000u,\n/* 1C */ 0x00565454u,\n/* 20 */ 0x58585858u,\n/* 24 */ 0x00000059u,\n/* 28 */ 0x5B5B5B5Bu,\n/* 2C */ 0x0000005Eu,\n/* 30 */ 0x58585858u,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x00000000u,\n/* 3C */ 0x00000000u\n);\n\nuint pattern1_2[16] = uint[](\n/* 00 */ 0x58585655u,\n/* 04 */ 0x0000005Bu,\n/* 08 */ 0x0000005Du,\n/* 0C */ 0x0000005Bu,\n/* 10 */ 0x005D0061u,\n/* 14 */ 0x5B5B5B5Bu,\n/* 18 */ 0x00000000u,\n/* 1C */ 0x005A5B5Bu,\n/* 20 */ 0x59595959u,\n/* 24 */ 0x00000054u,\n/* 28 */ 0x56565656u,\n/* 2C */ 0x00000054u,\n/* 30 */ 0x53535353u,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x00000000u,\n/* 3C */ 0x00000000u\n);\n\nuint pattern1_3[16] = uint[](\n/* 00 */ 0x5151504Fu,\n/* 04 */ 0x0000005Du,\n/* 08 */ 0x00000060u,\n/* 0C */ 0x00000062u,\n/* 10 */ 0x005C005Du,\n/* 14 */ 0x5B5B5B5Bu,\n/* 18 */ 0x00000000u,\n/* 1C */ 0x005B5959u,\n/* 20 */ 0x5C5C5C5Bu,\n/* 24 */ 0x00000059u,\n/* 28 */ 0x5050504Fu,\n/* 2C */ 0x0000004Du,\n/* 30 */ 0x48484848u,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x00000000u,\n/* 3C */ 0x00000000u\n);\n\nuint pattern2_0[16] = uint[](\n/* 00 */ 0x48484848u,\n/* 04 */ 0x00000000u,\n/* 08 */ 0x00004343u,\n/* 0C */ 0x00430000u,\n/* 10 */ 0x48484848u,\n/* 14 */ 0x00000000u,\n/* 18 */ 0x00004343u,\n/* 1C */ 0x00430000u,\n/* 20 */ 0x48484848u,\n/* 24 */ 0x00000000u,\n/* 28 */ 0x00004343u,\n/* 2C */ 0x00430000u,\n/* 30 */ 0x3C3C3C3Cu,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x00000000u,\n/* 3C */ 0x00000000u\n);\n\nuint pattern2_1[16] = uint[](\n/* 00 */ 0x48484848u,\n/* 04 */ 0x00000000u,\n/* 08 */ 0x00004343u,\n/* 0C */ 0x00430000u,\n/* 10 */ 0x48484848u,\n/* 14 */ 0x00000000u,\n/* 18 */ 0x00004343u,\n/* 1C */ 0x00430000u,\n/* 20 */ 0x48484848u,\n/* 24 */ 0x00000000u,\n/* 28 */ 0x00004343u,\n/* 2C */ 0x00430000u,\n/* 30 */ 0x48484848u,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x47474747u,\n/* 3C */ 0x00000000u\n);\n\nuint pattern2_2[16] = uint[](\n/* 00 */ 0x45454545u,\n/* 04 */ 0x00000000u,\n/* 08 */ 0x00004040u,\n/* 0C */ 0x00400000u,\n/* 10 */ 0x45454545u,\n/* 14 */ 0x00000000u,\n/* 18 */ 0x00004040u,\n/* 1C */ 0x00400000u,\n/* 20 */ 0x4A4A4A4Au,\n/* 24 */ 0x00000000u,\n/* 28 */ 0x00004545u,\n/* 2C */ 0x00450000u,\n/* 30 */ 0x43434343u,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x42424242u,\n/* 3C */ 0x00000000u\n);\n\nuint pattern2_3[16] = uint[](\n/* 00 */ 0x41414141u,\n/* 04 */ 0x00000000u,\n/* 08 */ 0x00003C3Cu,\n/* 0C */ 0x003C0000u,\n/* 10 */ 0x41414141u,\n/* 14 */ 0x00000000u,\n/* 18 */ 0x00003C3Cu,\n/* 1C */ 0x003C0000u,\n/* 20 */ 0x44444444u,\n/* 24 */ 0x00000000u,\n/* 28 */ 0x00003F3Fu,\n/* 2C */ 0x003F0000u,\n/* 30 */ 0x3C3C3C3Cu,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x00000000u,\n/* 3C */ 0x00000000u\n);\n\nuint pattern3_1[16] = uint[](\n        /* 03020100 */\n/* 00 */ 0x45484541u,\n/* 04 */ 0x4D484D48u,\n/* 08 */ 0x54515951u,\n/* 0C */ 0x5D595451u,\n/* 10 */ 0x484B4844u,\n/* 14 */ 0x504B504Bu,\n/* 18 */ 0x57545054u,\n/* 1C */ 0x605C5754u,\n/* 20 */ 0x4A4D4A45u,\n/* 24 */ 0x514D514Du,\n/* 28 */ 0x59565156u,\n/* 2C */ 0x625D5956u,\n/* 30 */ 0x4A4F4A47u,\n/* 34 */ 0x534F534Fu,\n/* 38 */ 0x5B565356u,\n/* 3C */ 0x625F5B56u\n);\n\nuint pattern4_1[16] = uint[](\n        /* 03020100 */\n/* 00 */ 0x64646464u,\n/* 04 */ 0x64646464u,\n/* 08 */ 0x63636060u,\n/* 0C */ 0x67676464u,\n/* 10 */ 0x6A6A6A69u,\n/* 14 */ 0x6A696C6Cu,\n/* 18 */ 0x6C6C6A6Au,\n/* 1C */ 0x65656667u,\n/* 20 */ 0x60606364u,\n/* 24 */ 0x5B5B5E5Eu,\n/* 28 */ 0x57575959u,\n/* 2C */ 0x60605454u,\n/* 30 */ 0x60606060u,\n/* 34 */ 0x60606460u,\n/* 38 */ 0x5A5B5E5Eu,\n/* 3C */ 0x58585959u\n);\n\nuint pattern4_2[16] = uint[](\n        /* 03020100 */\n/* 00 */ 0x58585655u,\n/* 04 */ 0x5D5D5B5Bu,\n/* 08 */ 0x62626160u,\n/* 0C */ 0x67676464u,\n/* 10 */ 0x69696969u,\n/* 14 */ 0x6D6D6E6Eu,\n/* 18 */ 0x67676969u,\n/* 1C */ 0x62626464u,\n/* 20 */ 0x65656564u,\n/* 24 */ 0x69696767u,\n/* 28 */ 0x6E6E6C6Cu,\n/* 2C */ 0x67676C6Cu,\n/* 30 */ 0x69696969u,\n/* 34 */ 0x69696B69u,\n/* 38 */ 0x65656767u,\n/* 3C */ 0x60606464u\n);\n\nuint pattern4_3[16] = uint[](\n/* 00 */ 0x65656465u,\n/* 04 */ 0x65656767u,\n/* 08 */ 0x63636464u,\n/* 0C */ 0x61616262u,\n/* 10 */ 0x6C696060u,\n/* 14 */ 0x70706E6Eu,\n/* 18 */ 0x6C6C6E6Eu,\n/* 1C */ 0x67676969u,\n/* 20 */ 0x65656465u,\n/* 24 */ 0x62626464u,\n/* 28 */ 0x69696060u,\n/* 2C */ 0x62626767u,\n/* 30 */ 0x60606060u,\n/* 34 */ 0x00000000u,\n/* 38 */ 0x00000000u,\n/* 3C */ 0x00000000u\n);\n////////////////////////////////////////\n\nuint getNote(int pos, uint pattern[16]) { return ((pattern[(pos >> 2) & 15] >> ((pos & 3) << 3)) & 255u); }\n\nfloat triangle(int note, int samp) {\n    int intSampleRate = int(iSampleRate);\n    float freq = pow(2.0, float(int(note) - 69) / 12.0) * 440.0;\n    float a = (iSampleRate / freq) * 256.0;\n    return float(abs((samp * 256) % int(a) - int(a) / 2) * 2) / a - 0.5;\n}\n\nfloat sawtooth(int note, int samp) {\n    int intSampleRate = int(iSampleRate);\n    float freq = pow(2.0, float(int(note) - 69) / 12.0) * 440.0;\n    float a = (iSampleRate / freq) * 256.0;\n    return float((samp * 256) % int(a)) / a - 0.5;\n}\n\nfloat synth(int pos, int samp) {\n    float ret = 0.0;\n    uint note1 = 0u, note2 = 0u;\n    \n    pos %= 704;\n\n    if (pos < 64) {\n            note2 = getNote(pos, pattern2_0);\n    } else if (pos < 448) {\n        if (pos % 192 < 0x40) {\n            note1 = getNote(pos, pattern1_3);\n            note2 = getNote(pos, pattern2_3);\n        } else if (pos % 192 < 0x80) {\n            note1 = getNote(pos, pattern1_1);\n            note2 = getNote(pos, pattern2_1);\n        } else if (pos % 192 < 0xC0) {\n            note1 = getNote(pos, pattern1_2);\n            note2 = getNote(pos, pattern2_2);\n        }\n    } else if (pos < 512) {\n        note1 = getNote(pos, pattern3_1);\n        if ((pos & 63) < 16) {\n            ret += triangle(65 - 24, samp) * .6666667;\n            ret += triangle(69 - 24, samp) * .6666667;\n            ret += triangle(72 - 24, samp) * .6666667;\n        } else if ((pos & 63) < 32) {\n            ret += triangle(68 - 24, samp) * .6666667;\n            ret += triangle(72 - 24, samp) * .6666667;\n            ret += triangle(75 - 24, samp) * .6666667;\n        } else if ((pos & 63) < 48) {\n            ret += triangle(71 - 24, samp) * .6666667;\n            ret += triangle(74 - 24, samp) * .6666667;\n            ret += triangle(77 - 24, samp) * .6666667;\n        } else if ((pos & 63) < 52) {\n            ret += triangle(67 - 24, samp) * .6666667;\n            ret += triangle(77 - 24, samp) * .6666667;\n            ret += triangle(79 - 24, samp) * .6666667;\n        } \n    } else {\n        if (pos < 576) {\n            note1 = getNote(pos, pattern4_1);\n            note2 = getNote(pos, pattern2_1);\n        } else if (pos < 640) {\n            note1 = getNote(pos, pattern4_2);\n            note2 = getNote(pos, pattern2_2);\n        } else {\n            note1 = getNote(pos, pattern4_3);\n            note2 = getNote(pos, pattern2_3);\n        }\n    }\n    \n    if (note1 != 0u) if (pos < 256)\n        ret += triangle(int(note1) - 12, samp);\n    else ret += sawtooth(int(note1) - 24, samp) * 0.25;\n    if (note2 != 0u) ret += triangle(int(note2) - 24, samp);\n    \n    return ret;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float tempo = iSampleRate / 14.6666667;\n    int intSampleRate = int(iSampleRate) * 10;\n    int pos = samp / int(tempo);\n    float a = float(samp % int(tempo)) / (tempo);\n    \n    float prev = synth(pos - 1, samp) * max(1.0 - a * 64.0, 0.0);\n    float cur = synth(pos, samp) * min(a * 64.0, 1.0);\n    \n    return vec2( prev + cur );\n}", "sound_inputs": [], "common_code": "// Everything that isn't credited to someone else is licensed under the GPLv3\n// (https://www.gnu.org/licenses/gpl-3.0.html)\n\nprecision highp int;\nprecision highp float;\n\n#define TAU 6.2831853", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXyWB.jpg", "access": "api", "license": "gpl-3.0", "functions": [[126, 126, 147, 147, 205], [207, 207, 264, 264, 974]], "test": "untested"}
{"id": "mtfcDS", "name": "Glob", "author": "soimn", "description": "An attempt at making something similar to the github globe\nFor textures check instructions in \"Buffer A\".", "tags": ["globe"], "likes": 3, "viewed": 154, "published": 3, "date": "1691099664", "time_retrieved": "2024-07-30T17:40:59.865458", "image_code": "void\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect_ratio = 9.0/16.0;\n    float PI      = 3.1415926535;\n    float TAU     = 6.2831853071;\n    float RES_TAU = 0.1591549430;\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 ray = normalize(vec3(-0.5 + uv.x, (-0.5 + uv.y)*aspect_ratio, -0.5));\n    \n    vec3 globe_center = vec3(0.0, 0.0, -2.2);\n    float globe_r     = 1.0;\n    \n    vec3 p             = globe_center;\n    float b            = dot(ray, p);\n    float discriminant = b*b - dot(p, p) + globe_r*globe_r;\n    float t            = b - sqrt(discriminant);\n    \n    vec3 light_dir = normalize(vec3(-0.5, 0.5, 0.5));\n    \n    vec3 color;\n    if (discriminant >= 0.0)\n    {\n        vec3 hit          = t*ray;\n        vec3 globe_to_hit = hit - globe_center;\n        vec3 normal       = normalize(globe_to_hit);\n        \n        float cos_tilt = cos(-0.4189/2.3);\n        float sin_tilt = sin(-0.4189/2.3);\n        vec3 glob_vector = vec3(normal.x*cos_tilt - normal.y*sin_tilt, normal.x*sin_tilt + normal.y*cos_tilt, normal.z);\n        \n        float it = mod(iTime, TAU);\n        float cos_it = cos(it);\n        float sin_it = sin(it);\n        vec3 afr_vector = normalize(vec3(cos_it,   0.0, -sin_it));\n        vec3 nfr_vector = normalize(vec3(sin_it,   0.0,  cos_it));\n        vec3 mn_vector  = normalize(vec3(glob_vector.x, 0.0,  glob_vector.z));\n        \n        float half_map_x = acos(dot(mn_vector, afr_vector))*RES_TAU;\n        float map_x = (dot(mn_vector, nfr_vector) >= 0.0 ? 1.0 - half_map_x : half_map_x);\n        float map_y = acos(-glob_vector.y)/PI;\n        \n        int imap_x = int(clamp(iResolution.x*map_x, 0.0, iResolution.x));\n        int imap_y = int(clamp(iResolution.y*map_y, 0.0, iResolution.y));\n        \n        vec3 map_color = texelFetch(iChannel0, ivec2(imap_x, imap_y), 0).rgb;\n        \n        float light = max(dot(normal, light_dir), 0.0);\n        color = light*mix(vec3(0.43, 0.09, 0.31), vec3(0.25, 0.27, 0.72), pow(light, 0.2));\n        \n        float al = clamp(map_color.r, 0.0, 1.0);\n        al *= al;\n        color = (1.0-al)*color + al*vec3(0.7, 0.8, 1.0);\n    }\n    else\n    {\n        float l = 0.1;\n        float ring = max(0.0, discriminant + l)/l;\n        vec3 fake_normal = normalize(b*ray - globe_center);\n        \n        float fake_light = max(dot(fake_normal, light_dir), 0.0);\n        \n        vec3 ring_color = ring*mix(vec3(0.02, 0.05, 0.13), vec3(0.34, 0.47, 0.98), fake_light);\n        \n        color = vec3(0.02, 0.05, 0.13) + ring_color;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* For custom globe texture\n// ----------------------------------------------------------------------------------------\n//\t\"Load Custom Textures\" by Antoine Clappier - March 2015\n//\n//\tLicensed under a Creative Commons Attribution-ShareAlike 4.0 International License\n//\thttp://creativecommons.org/licenses/by-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n\n// Image credits:\n//  Nasa, http://visibleearth.nasa.gov/\n\n\nA simple method to load custom image textures in Shadertoy!\n-----------------------------------------------------------\n\nThe idea is to call directly the SetTexture function found in Shadertoy js code.\n\nHere is how to loads the three textures needed for this shader:\n - Open the javascript console of your browser:\n\t\t\t\t   Mac      /     Windows\n\tChrome:  cmd + opt + J  /  ctrl + shift J\n\tFirefox: cmd + opt + K  /  ctrl + shift K\n    IE:          na         /  F12   \n\n- Then copy the following lines in the console to load custom 2048x2048 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/88u2uo8dxdmgzxo/height2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    float t = 1.0;\n    fragColor = vec4(sin(t*fragCoord.x)*cos(t*fragCoord.y) * (color.r*color.g >= 0.01 ? 1.0 : 0.0));\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 2567]], "test": "untested"}
{"id": "DlXyDS", "name": "Homero basico", "author": "jorge2017a2", "description": "Homero basico", "tags": ["2d", "bezier", "homer", "homerobasico"], "likes": 20, "viewed": 220, "published": 3, "date": "1691080688", "time_retrieved": "2024-07-30T17:41:00.637393", "image_code": "///por jorge2017a2\n///Homero basico\n//3-ago-2023-\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\n\nvec3 lineasBz(vec2 uv, vec3 col)\n{\nvec2 pc1p1=vec2(3.650,3.770);\nvec2 pc1p2=vec2(4.360,4.290);\nvec2 pc1p3=vec2(4.490,3.480);\nvec2 pc2p1=vec2(3.980,3.750);\nvec2 pc2p2=vec2(4.650,4.280);\nvec2 pc2p3=vec2(4.680,3.320);\nvec2 pc3p1=vec2(2.630-0.05,1.730);\nvec2 pc3p2=vec2(2.800-0.05,1.720);\nvec2 pc3p3=vec2(2.710-0.05,1.570);\nvec2 pc4p1=vec2(4.540,1.410);\nvec2 pc4p2=vec2(4.560,1.730);\nvec2 pc4p3=vec2(4.690,1.620);\nvec2 pc5p1=vec2(2.890,1.870);\nvec2 pc5p2=vec2(3.010,2.050);\nvec2 pc5p3=vec2(3.220,2.020);\nvec2 pc6p1=vec2(2.990,1.620);\nvec2 pc6p2=vec2(2.820,1.760);\nvec2 pc6p3=vec2(2.890,1.880);\nvec2 pc7p1=vec2(3.230,2.010);\nvec2 pc7p2=vec2(3.340,2.050);\nvec2 pc7p3=vec2(3.460,2.080);\nvec2 pc8p1=vec2(4.490,1.690-0.05);\nvec2 pc8p2=vec2(4.520,1.860-0.05);\nvec2 pc8p3=vec2(4.720,1.770-0.05);\nvec2 pc9p1=vec2(4.440,1.340);\nvec2 pc9p2=vec2(4.500,1.250);\nvec2 pc9p3=vec2(4.610,1.280);\nvec3 colNegro=vec3(0.0);\nfloat d1= sdBezier(uv,pc1p1,pc1p2,pc1p3);\nfloat d2= sdBezier(uv,pc2p1,pc2p2,pc2p3);\nfloat d3= sdBezier(uv,pc3p1,pc3p2,pc3p3);\nfloat d4= sdBezier(uv,pc4p1,pc4p2,pc4p3);\nfloat d5= sdBezier(uv,pc5p1,pc5p2,pc5p3);\nfloat d6= sdBezier(uv,pc6p1,pc6p2,pc6p3);\nfloat d7= sdBezier(uv,pc7p1,pc7p2,pc7p3);\nfloat d8= sdBezier(uv,pc8p1,pc8p2,pc8p3);\nfloat d9= sdBezier(uv,pc9p1,pc9p2,pc9p3);\ncol=DrawFigBorde(colNegro,col,d1); //pelo1\ncol=DrawFigBorde(colNegro,col,d2); //pelo2\ncol=DrawFigBorde(colNegro,col,d3); //oreja\ncol=DrawFigBorde(colNegro,col,d4);\ncol=DrawFigBorde(colNegro,col,d5);\ncol=DrawFigBorde(colNegro,col,d6);\ncol=DrawFigBorde(colNegro,col,d7);\ncol=DrawFigBorde(colNegro,col,d8);\ncol=DrawFigBorde(colNegro,col,d9);\n    return col;\n}\n\n\nvec3 Ojos(vec2 p, vec3 col)\n{ float t=iTime;\nfloat px=abs(0.5*sin(t));\nfloat py=abs(0.15*sin(t*cos(t*0.25)))-0.1;\n\nfloat r15=0.46;\nvec2 p15=vec2(3.89,2.28);\nfloat d15= sdCircle(p-p15,r15);\n\nfloat r16=0.44;\nvec2 p16=vec2(3.07,2.29);\nfloat d16= sdCircle(p-p16,r16);\n\nfloat r17=0.1;\nvec2 p17=vec2(2.72+px,2.46+py);\nfloat d17= sdCircle(p-p17,r17);\n\nfloat r18=0.1;\nvec2 p18=vec2(3.52+px,2.38+py);\nfloat d18= sdCircle(p-p18,r18);\n    col= DrawFigBorde(vec3(1.0),col,d16);\n    col= DrawFigBorde(vec3(1.0),col,d15);\n    col= DrawFigBorde(vec3(0.0),col,d17);\n    col= DrawFigBorde(vec3(0.0),col,d18);\n    return col;\n}\n\nvec3 pelos02(vec2 p, vec3 col)\n{\nvec2 A,B;\np.y=4.15-p.y;\nA= vec2(4.36,2.47);\nB= vec2(4.6,1.84);\nfloat d1=sdSegment(p,A,B);\nA= vec2(4.61,1.87);\nB= vec2(4.64,2.37);\nfloat d2=sdSegment(p,A,B);\n\nA= vec2(4.62,2.36);\nB= vec2(4.86,1.9);\nfloat d3=sdSegment(p,A,B);\nA= vec2(4.84,1.91);\nB= vec2(4.77,2.31);\nfloat d4=sdSegment(p,A,B);\n    col= DrawFigBorde(vec3(0.0),col,d1);\n    col= DrawFigBorde(vec3(0.0),col,d2);\n    col= DrawFigBorde(vec3(0.0),col,d3);\n    col= DrawFigBorde(vec3(0.0),col,d4);\n    return col;\n}\n\nvec3 Homero(vec2 p, vec3 col)\n{float r1=1.0;\nvec2 p1=vec2(3.81,2.83);\nfloat d1= sdCircle(p-p1,r1);\n\nfloat r2=1.0;\nvec2 p2=vec2(3.87,2.84);\nfloat d2= sdCircle(p-p2,r2);\n\nfloat r3=0.9;\nvec2 p3=vec2(3.65,1.35);\nfloat d3= sdCircle(p-p3,r3);\n\n    d1=min(d1,d2);\n    d1=min(d1,d3);\n    vec3 colc=vec3(0.94,0.72,0.01);\n\nvec2 pos=vec2(3.21,2.07);\nvec2 med=vec2(0.425,1.025);\nfloat d4= sdBox(p-pos, med );\n\nfloat ang = 5.0 * PI / 180.0;\nvec2 pr = Rotate(p- pos, med/2.0, ang);\nd4 = sdBox(pr, med);\n    d1=min(d1,d4);\n\npos=vec2(4.24,1.96);\nmed=vec2(0.425,1.025);\nang = 10.0 * PI / 180.0;\npr = Rotate(p- pos, med/2.0, ang);\nfloat d5 = sdBox(pr, med);\n    d1=min(d1,d5);\n    //da,d2,d3,d4,d5 =cabeza\n    \npos=vec2(3.87,0.62);\nmed=vec2(0.67,0.65);\nfloat d6= sdBox(p-pos, med );\n    d1=min(d1,d6); //cuello\n\nfloat r7=0.6;\nvec2 p7=vec2(3.62,0.91);\nfloat d7= sdCircle(p-p7,r7);\n    d1=min(d1,d7);// barba\n    vec3 colb=vec3(0.85,0.76,0.67);\n\nfloat r8=0.46;\nvec2 p8=vec2(3.08,1.12);\nfloat d8= sdCircle(p-p8,r8);\n    d7=min(d7,d8); //barba\n\npos=vec2(3.4,1.1);\nmed=vec2(0.79,0.48);\nfloat d9=sdEllipse(p-pos,med);\nd7=min(d7,d9);    \n\npos=vec2(3.08,0.65);\nmed=vec2(0.16,0.13);\nfloat d10=sdEllipse(p-pos,med); //barba\n\n    d7=min(d7,d10);\n\npos=vec2(2.84,0.81);\nmed=vec2(0.31,0.13);\n ang = -5.0 * PI / 180.0;\n pr = Rotate(p-pos, med/2.0, ang);\nfloat d11  = sdEllipse(pr, med);\n    d7=min(d7,d11);\n\npos=vec2(2.76,0.87);\nmed=vec2(0.24,0.14);\nang = -5.0 * PI / 180.0;\n pr = Rotate(p-pos, med/2.0, ang);\nfloat d12  = sdEllipse(pr, med);\n    d7=min(d7,d12);\n\n//oreja\npos=vec2(4.4,1.58);\nmed=vec2(0.25,0.19);\nang = -60. * PI / 180.0;\n pr = Rotate(p-pos, med/2.0, ang);\nfloat d13  = sdEllipse(pr, med);\n    d1=min(d1,d13);\n\n\npos=vec2(2.77,1.5);\nmed=vec2(0.25,0.19);\nang = 60.0 * PI / 180.0;\npr = Rotate(p-pos, med/2.0, ang);\nfloat d14  = sdEllipse(pr, med);\n\nfloat py=abs(0.05*sin(iTime));\nfloat r19=0.08;\nvec2 p19=vec2(3.09,0.65+py);\nfloat d19= sdCircle(p-p19,r19);\n\npos=vec2(2.81,2.7);\nmed=vec2(0.17,0.18);\nfloat d20=sdEllipse(p-pos,med);\n    d1=min(d1,d20);\n\n//nariz\npos=vec2(3.29,1.8);\nmed=vec2(0.4,0.2);\nfloat d1a=sdEllipse(p-pos,med);\n\n pos=vec2(3.5,1.82);\n med=vec2(0.158,0.2);\n ang = -20.0 * PI / 180.0;\n pr = Rotate(p-pos, med, ang);\nfloat d2a  = sdEllipse(pr, med);\n\n pos=vec2(3.14,1.82);\n med=vec2(0.25,0.18);\nfloat d3a=sdEllipse(p-pos,med);\n    d1a=min(d1a,d2a);\n    d1a=min(d1a,d3a);\n    \n    col= DrawFigBorde(colc, col, d14);\n    col= DrawFigBorde(colc, col, d1);\n    col= DrawFigBorde(colb, col, d7);//barba\n    col= DrawFigBorde(vec3(0.0),col,d19); //boca\n    col=Ojos(p,col);\n    col=lineasBz(p,col);\n    col= DrawFigSolo(colc, col, d1a);\n    col= pelos02(p,col);\n    return col;\n}\n\nvec3 escena(vec2 p, vec3 col)\n{ col= Homero(p,col);  return col; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uv2=uv*5.0;\n    uv-=vec2(-1.0,-0.5);\n    uv*=4.0;\n    vec3 col=vec3(0.,0.58,0.99);\n    col=escena(uv,col);\n    col=escena(vec2(-uv.x+4.0,uv.y)+vec2(sin(iTime),0.0),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n\n\n//Quadratic Bezier - exact   (https://www.shadertoy.com/view/MlKcDD)\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlXyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 235, 282, 282, 309], [310, 310, 353, 353, 380], [381, 381, 429, 429, 457], [460, 476, 524, 524, 602], [604, 604, 639, 639, 662], [664, 664, 701, 701, 773], [775, 775, 827, 827, 934], [936, 936, 998, 998, 1124], [1126, 1126, 1188, 1188, 1253], [1257, 1257, 1291, 1291, 2891], [2894, 2894, 2923, 2923, 3503], [3505, 3505, 3537, 3537, 4010], [4012, 4012, 4043, 4043, 6681], [6683, 6683, 6714, 6714, 6749], [6751, 6751, 6808, 6808, 7114]], "test": "untested"}
{"id": "DtXcWS", "name": "Hypno Eye Music Visualizer", "author": "iSandRocks", "description": "super basic pattern with some volume responsive elements", "tags": ["reactive", "music", "visualizer"], "likes": 6, "viewed": 232, "published": 3, "date": "1691077714", "time_retrieved": "2024-07-30T17:41:01.407335", "image_code": "const float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 formula(vec2 p) {\n\t\tp.xy = abs(p.xy+1.)-abs(p.xy-1.)-p.xy;\n\t\tp.y-=.25;\n\t\tp.xy*=rot(radians(35.));\n\t\tp=p*2./clamp(dot(p.xy,p.xy),.2,1.);\n\treturn p;\n}\n\nfloat getfrequency(float x) {\n    return texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n    float index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n    return mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 palette(float t) {\n    float angle = atan(iResolution.x, iResolution.y);\n    float frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\n    vec3 a1 = vec3(0.21, 0.16, 0.35);\n    vec3 b2 = vec3(0.07, 0.07, 0.07);\n    vec3 c3 = vec3(1, 1, 1);\n    vec3 d4 = vec3(1, 1, 1);\n    vec3 a = a1 * (frequency + 0.1);\n    vec3 b = b2 * (frequency + 0.1);\n    vec3 c = c3 * .05;\n    vec3 d = d4 ;\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float angle = atan(iResolution.x, iResolution.y);\n    float frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n    \n    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n\n    for(float i = 0.0; i < 4.0; i ++) {\n    \n        uv = formula(uv * ( 0.13));\n     \n\n        float d = length(uv) * exp(- length(uv0));\n\n        vec3 col = palette(length(uv0) + i * .4 + iTime*2.0 );\n\n        d = sin(d * 8. + ((0.5*frequency)+iTime)) / 15.;\n        d = abs(d);\n       \n\n        d = pow((0.02 +( .01*frequency)) / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtXcWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 159, 159, 206], [208, 208, 230, 230, 361], [363, 363, 392, 392, 488], [490, 490, 526, 526, 743], [745, 745, 780, 780, 844], [846, 846, 869, 869, 1299], [1300, 1300, 1357, 1357, 2045]], "test": "untested"}
{"id": "mlXyRf", "name": "automatic mapping between shapes", "author": "FabriceNeyret2", "description": "inspired from Sig'23:  iteratively find a mapping between 2 arbitrary shapes\nHere: from disk to square (cf Common )\nChange buffA#14:dt for better precision\nshow square UV map + some corresponding dots (→ disc)\nSwitch comments in Image:8,9 for averaging", "tags": ["mapping", "iadb"], "likes": 17, "viewed": 234, "published": 3, "date": "1691077009", "time_retrieved": "2024-07-30T17:41:02.186252", "image_code": "// inspired from Sig'23 \"Iterative 𝛼-(de)Blending\" https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n// Fork of https://shadertoy.com/view/mdX3Wl\n\n#define blend(d)  O = mix( O, vec4(1), smoothstep( 2./R.y, 0., abs(d) ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n // O = T(u);                        // O.xy = UV coords\n    O = texture(iChannel0, u/R, 2.); // averaged version\n                                 \n    vec2  P = 2.*O.xy - 1., d, C;    // --- draw UV map --------------------------------\n    float l = length(P), a = atan(P.y,P.x);             // polar coords    \n    O = \n //     iMouse.z > 0. ? // texture(iChannel1, O.xy)     // map texture\n //                        sin(32.* vec4(l,a/2.,0,0) )  // polar grid\n //                   :   \n                           sin(128.*O);                 // show UV grid\n                        // vec4(l,fract(a/6.28),0,0) ;  // UV in polar coords\n                        // sin(32.* vec4(l,a/2.,0,0) ); // polar grid\n                      \n    l = 1e9;                         // --- plot N² UV dots ----------------------------\n    int N = 15;\n    for( int i = 0; i < N*N; i++ )                      // plot some UV coords.\n        d = ( .5 + vec2(i%N,i/N) )/float(N),\n        P = T( d * R ).xy * R - u,                      // offset to current pixel\n        a = dot(P,P),            \n        a < l ? l = a, C = d : C;                       // keep min dist² and corresponding Id\n    O = mix( O, vec4(C,1,1), smoothstep( 5.5, 4., sqrt(l) ) ); // draw dots\n                \n    d = c - u/R;                     // --- draw source & target shapes --------               \n    blend( length( d )  - r );\n    d = abs(r - u/R);\n    blend( max(d.x,d.y) - r );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// inspired from Sig'23 \"Iterative 𝛼-(de)Blending\" https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html\n// Shapes can have any topological genus and dimension. Can be superimposed.\n// Weighting on shapes can be consider (tune the sampler accordingly).\n\n// shape parameters c,r in Common :   disc( (c,c), r ) , square [0,2r]²\n\n#define hash2(p) fract(sin(mod((p)*mat2(127.1,311.7, 269.5,183.3),6.283)) *3758.5453123)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if (iFrame==0) O = vec4(2.*r *u/R,0,0);              // init: P maps the square\n    else {\n        O = T(u);                                        // previous state\n        float dt = 1./600., t = float(iFrame)*dt;\n        if ( t > 1. ) return;                            // end of iterations\n        \n         vec2 P = O.xy,                                  // P: previous pivot\n              H,\n              A,                                         // point in the source shape ( square )\n              B;                                         // point in the target shape ( disc )\n        bool ok = false;\n                                                         // ------- deblending phase --------        \n        for( float i=0.; i++ < 6e2 && ok == false ; ) {  // rejection sampling\n            H = hash2( P +t -i/1.3 +u/R );               // random vec2\n            if ( t < .5 )                                // --- if first half of iterations:\n                B = c + r * sqrt(H.x) * cos( 6.283*H.y + vec2(0,1.57)), // B sampled in disc\n                A = ( P - t*B ) / (1.-t),                // A such that (1-t)A + tB = P\n                H = abs(A-r), \n                ok = max(H.x,H.y) < r;                   // reject up to A in square\n\n            else                                         // --- if second half if iterations: \n                A = 2.*r*H,                              // A sampled in square\n                B = ( P - (1.-t)*A ) / t,                // B such that (1-t)A + tB = P   \n                ok = length(B-c) < r;                    // reject up to B is disc\n       }\n                                                         // ------- blending phase --------\n       if (ok) O.xy = mix(A,B,t+dt);                     // new pivot between A and B\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// float c = .5, r = .5;           // unit disc( (.5,.5), .5 ) to unit square [0,1]²\n   float c = .75, r = .25;         // disc( (c,c), r ) to square [0,2r]²\n\n\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 289, 346, 1741]], "test": "untested"}
{"id": "dtlyzs", "name": "cheap bluenoise: Lanczos filte", "author": "FabriceNeyret2", "description": "( easy extend to nD )\nleft to right :  cheap blue noise with 3x3 FD  ,  with 11x11 Lanczos filtering  (=49 coefs)  ,  ref blue noise\ncenter line: thresholding.\nbottom half: zoom\n→ Not much gain using the big filter. And still not so good for thresholding.", "tags": ["hash", "bluenoise", "lanczos"], "likes": 13, "viewed": 321, "published": 3, "date": "1691074632", "time_retrieved": "2024-07-30T17:41:02.962177", "image_code": "// https://en.wikipedia.org/wiki/Lanczos_resampling\n\nconst float a = 3., n = a-.5, N = 2., PI = 3.1415927;\n\n//#define L(i)    ( i==0. ? 1. : a* sin(PI*i)*sin(PI*i/a) / ( PI*PI*i*i ) )\n  #define L(i) float[]( 1., .60793, 0., -.13509, 0., .024317 )[abs(int(i+i))] // for a=3,N=2\n\n#define T(i,j)  ( 2.* texture( iChannel0, ( u +N*vec2(i,j) ) / 256. ) - 1. )\n\n#define blue() (  \\\n          (  H(-1,-1) +     H(0,-1)  + H(1,-1)  \\\n           + H(-1, 0) - 8.* H(0, 0)  + H(1, 0)  \\\n           + H(-1, 1) +     H(0, 1)  + H(1, 1)  \\\n          ) *.5/9. *2.1 +.5 )\n#define H(i,j) texture( iChannel0, ( u + vec2(i,j) ) /256. )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R;\n    bool b = iMouse.z<=0.;\n    if ( b && int(u) % int(R/3.) == 0 ) { O = vec4(1,0,0,1); return; } // red separator\n    int  i = int( 3.*( b ? u : iMouse.xy ) / R );  // select noise via zone or mouse\n    \n    if ( b && U.y < .5 ) u = floor(u/2.)+.5;       // bottom: zoom\n    \n    if ( i==0 )                                    // left: cheap blue with 9 points FD\n        O = blue();\n    \n    else if (i==1) {                               // middle: blue with 11x11  Lanczos filtering\n        O *= 0.;                              \n        for( float y=-n; y<=n; y+= 1./N )\n            for( float x=-n; x<=n; x+= 1./N )\n                O +=   L(x)*L(y) * T(x,y);\n\n        O = .5 + .65*( T(0,0) - O/(N*N) );         // keep only high freqs\n                                                   // testing some histogram corrections\n     // O = .5 + .7*tanh((O*2.-1.)/(1.76*.8));     // would be valid for gaussian distrib\n     // O = (O-.5)*.6+.5;                          // fit to [0,1] interval → histo = /‾\\\n        // O = 2.*O-1.; O = .5+.5*(O + sin(1.57*O))/2.;\n        // O = (O + O*O*(3.-2.*O))/2.;\n        // float s = .242, x = abs(O.x-.5), k = 3.14/(.5-s); O = vec4(.5+.5*sign(O.x-.5)*.517*( x<s ? s*x : s*s+ .5*x+.5/k*sin(k*(x-s))));\n    }\n    else                                           // right: ref blue noise\n         O = texelFetch(iChannel1, ivec2(u)%1024,0);\n\n    if ( b && abs( U.y-.5) < .25 ) O = step(.8,O); // centerline: thresholding\n    O = O.xxxx;                                    // grey\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtlyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[619, 619, 657, 657, 2230]], "test": "untested"}
{"id": "dtsczl", "name": "z-order fail", "author": "pema99", "description": "fail", "tags": ["morton"], "likes": 0, "viewed": 155, "published": 3, "date": "1691069591", "time_retrieved": "2024-07-30T17:41:03.728130", "image_code": "// Switch between methods of converting float -> uint\n#define USE_NEW_MAPPING 0\n\nuint Part1By1(uint x)\n{\n    x &= 0x0000ffffu;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210\n    x = (x ^ (x <<  8)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n    x = (x ^ (x <<  4)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n    x = (x ^ (x <<  2)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n    x = (x ^ (x <<  1)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n    return x;\n}\n\n\nuint MortonCodeEncode2D(uint x, uint y)\n{\n    return (Part1By1(y) << 1) + Part1By1(x);\n}\n\nuvec3 Float3ToUint3(vec3 v)\n{\n    // Reinterpret value as uint\n    uvec3 value_as_uint = uvec3(floatBitsToUint(v.x), floatBitsToUint(v.y), floatBitsToUint(v.z));\n\n    // Invert sign bit of positives and whole of  to anegativesllow comparison as unsigned ints\n    value_as_uint.x ^= (1u + ~(value_as_uint.x >> 31u) | 0x80000000u);\n    value_as_uint.y ^= (1u + ~(value_as_uint.y >> 31u) | 0x80000000u);\n    value_as_uint.z ^= (1u + ~(value_as_uint.z >> 31u) | 0x80000000u);\n\n    return value_as_uint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x /= iResolution.y/iResolution.x;\n    \n    // Grid resolution to display\n    const uint res = 1u << 5u;\n    const uint res2 = res * res;\n    const float fres = float(res);\n    \n    // Scaled uv\n    vec3 vuv = vec3(uv * fres, 0.0);\n    \n    // Map floats to unsigned integers\n    #if USE_NEW_MAPPING\n    uvec3 uuv = Float3ToUint3(vuv); \n    #else\n    uvec3 uuv = uvec3(vuv);\n    #endif\n\n\n    // Find index on curve of pixel\n    uint curveIndex = MortonCodeEncode2D(uuv.x, uuv.y) % res2;\n    vec3 col = vec3(float(curveIndex) / float(res2));\n    \n    // Color one pixel so we can see the Z-order nature of the curve\n    if (curveIndex == uint(iTime*3.) % res2)\n        col = vec3(1.0, 0.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtsczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 104, 104, 550], [553, 553, 594, 594, 641], [643, 643, 672, 705, 1143], [1145, 1145, 1202, 1202, 2003]], "test": "untested"}
{"id": "mllcRl", "name": "cheap bluenoise 2", "author": "FabriceNeyret2", "description": "( easy extend to nD )\nleft to right:  with noise ,   pseudo-blue with LOD0 - LOD1   ,  with 9 points FD  ,       ref blue noise.\ncenter line: thresholding.\nbottom half: zoom.\n→ Not so good for thresholding.", "tags": ["hash", "bluenoise"], "likes": 19, "viewed": 287, "published": 3, "date": "1691069448", "time_retrieved": "2024-07-30T17:41:04.497074", "image_code": "// various variants             https://www.shadertoy.com/view/tllcR2\n// LOD0-LOD1 on 9 points + FFT  https://www.shadertoy.com/view/7dyfzW\n   \n#define H(p)  fract(sin(mod(dot(p, vec2(12.9898, 78.233)),6.283)) * 43758.5453)\n\n#define blue(p) (  \\\n          (  H(p+vec2(-1,-1)) + H(p+vec2(0,-1)) + H(p+vec2(1,-1))  \\\n           + H(p+vec2(-1, 0)) - 8.* H( p )      + H(p+vec2(1, 0))  \\\n           + H(p+vec2(-1, 1)) + H(p+vec2(0, 1)) + H(p+vec2(1, 1))  \\\n          ) *.5/9. *2.1 +.5 )\n   \n#define T(l) texelFetch(iChannel0, (ivec2(u)%256) >> l, l )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u -= .5;\n    if ( int(u) % int(iResolution/4.) == 0 ) { O = vec4(1,0,0,1); return; } // red separator\n    vec2 U = u/iResolution.xy;\n    int i = int(4.*U.x); \n    if (U.y<.5) u = floor(u/2.);          // bottom: zoom\n    \n    O =  i==0 ? vec4(H(u))                // left to right: white, cheapblue1, 2, ref blue\n       : i==1 ?.5 + (T(0) -  T(1))\n       : i==2 ? vec4(blue(u))\n       :        texelFetch(iChannel1, ivec2(u)%1024,0);\n    \n    if (abs(U.y-.5)<.25) O = step(.9,O);  // center line: thresholding\n    \n    O = O.rrrr;                           // grey\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllcRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 586, 586, 1157]], "test": "untested"}
{"id": "cllyRs", "name": "Tunnel shader", "author": "jackjackdev", "description": "Credits to @CoderSpaceChannel on YT, tutorial: https://www.youtube.com/shorts/VF2R4tRdKMI", "tags": ["tunnel"], "likes": 3, "viewed": 183, "published": 3, "date": "1691054358", "time_retrieved": "2024-07-30T17:41:05.269010", "image_code": "// Tunnel shader\n// Credits to @CoderSpaceChannel on YT, tutorial: https://www.youtube.com/shorts/VF2R4tRdKMI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) /iResolution.y;\n    \n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    \n    vec2 st = vec2(a / 3.1415, 0.1 / r) + 0.11 * iTime;\n    \n    vec3 col = texture(iChannel0, st).rgb;\n    col *= 3.5 * r;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cllyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 168, 462]], "test": "untested"}
{"id": "dlXyzs", "name": "logeps for heighmapped terrain", "author": "ollj", "description": "imprecise distance fields tend to overstepping\nlogeps() can sometimes perform better on bad distance fields, but it is an issue of scaling and of how convex/concave the object is.\nlogeps fails if the camera is inside the surface.", "tags": ["raymarching", "terrain", "sdf"], "likes": 4, "viewed": 214, "published": 3, "date": "1691043563", "time_retrieved": "2024-07-30T17:41:06.057900", "image_code": "//maxRays increased to 100\n//, increasing maxRays to something like 2000 WITHIN LOGEPS\n//, while understepping more, is pretty normal for logeps\n//, that shines at LOD-downscaling at larger distqances.\n//and that shines at converging faster within distorted sets.\n#define MAX_RAYS 100\n#define MAX_DIST 5.0\n\n//logeps demoes that are low-gpu-cost\n//https://www.shadertoy.com/view/tdXXzl\n//https://www.shadertoy.com/view/dlXyzs#\n//https://www.shadertoy.com/view/4tXyDH\n\n//beware if camera is inside object, it may march as if the object is hollow.\n//beware, if camera is inside object, it may skip over all convex gaps (much worse overstepping)\n//, to toggle between various LOD-scales (distance field zoom levels)\n//, to make it toggleAble (sometimes a simpler end condition is better)\nbool logEps(float s,float c//s=distanceToSurface c=DistanceToCamera\n){  //if(s<0.0001)return true;return false;//basic raymarching with epsilon=0.01\n \n if(s<0.)return true;\n //avoids exp(<0) and log(<0) undefined issues\n //avoids oscillating-distances from negative to positive, while close to 0. (bad-performance risk avoided)\n //logeps negative distances returned as distance==0, instead of as hollowed shell distance; d=abs(d)\n  \n //if(1./exp(s)<.01)return s<.001;\n   //better for short distance REFLECTIONS, that need extra precision+CONTINUITY, that logeps likely lacks (for spheres)\n   //this reflection-fix fails for a nearby tensor-distorted-object\n   //the main issue here is that SHORT is a RELATIBE term, rleative to the model-SCALE\n\n //return log(c*c/s/1e5)>0. //FAST long-distance logeps for spinor /tdXXzl\n    //goes VERY bloated beyond d>2000, just set zFar<2000\n  \n    //other logebs work better (for less distorted fields)\n    //, but they tend to be slower by multiplying/dividing more\n    //, allowing for near-infinite-zfar within 10000 steps\n    //, because log() is fun like that:\n  \n  //the more common logeps looks something like below (work well for nearby heavily distorted sets)\n \n  return log(c*c/s/s/1000000.)>0.5  \n     //equires +1 division, and thats not needed for strong distortions\n     //performs better for longer distances.\n     //2 constants are more arbitiary than it seems.\n\n  //return log(c*c*c/s/s/100000000000.)>0.\n    //this is what lobeps tend to look like before it grows inefficient by diminishing-returns\n    //at the cost of quite a LOT of divisions and being cubic-by-distance \n    //, and dividing by a large number, this may fail in 16bit.\n    //but it keeps gettign more exponential within the log() \n    //and larger numbers tend to be bad for nearby precision\n    //this is ideal for a set like in the game OuterWilds, while it may even be useful for an earh-moon-syste-to-scale.\n    \n  //in summary, the later log()-eps variants  are better for VERY large zFar (almost-to-scale planetary systems fit in this)\n  //and much less distorted fields.\n  //and the upper ones are better for more distorted fields, but lower zFar max distances.\n  //the lower-distance-ones generally need less divisions (and mults) to work, so they tend to perform better \n  //(also for having a lower zFar bound, like its 90s gaming with a close fog)\n ;}\n//some very-long-distance-logeps variants dared to also log(NumberOfSteps), but this had very few use cases (solar systems too scale)\n//, and other issues of precision long before overstepping.\n\nfloat N(float uv) {\n    return fract(sin(uv + 5.0) * 39352.212);\n}\nfloat noise(float uv) {\n    float s = uv;\n    float frac = fract(s);\n    float id = floor(s);\n    \n    float l = N(id);\n    float r = N(id + 1.0);\n    float m = mix(l, r, frac);\n    \n    return m;\n}\nfloat fbnoise(float uv) {\n    float n = noise(uv * 4.0);\n    n += noise(uv * 8.0) * 0.5;\n    n += noise(uv * 16.0) * 0.25;\n    n += noise(uv * 32.0) * 0.125;\n    \n    n /= 1.875;\n    \n    return n;\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b) {\n    vec2 pa = uv - a;\n    vec2 ba = b - a;\n    float p = dot(pa, ba) / dot(ba, ba);\n    return length(uv - ba * min(max(p, 0.0), 1.0));\n}\nfloat map(vec2 uv) {\n    return uv.y - 0.8 + fbnoise(uv.x * 0.5 + iTime * 0.05) * 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouseP = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    float d = map(uv);\n    //ground is greener to differ from parent\n    vec3 col = mix(mix(vec3(0.6, 0.6, 0.0), vec3(0.5, 0.6, 0.9), step(0.0, d)), vec3(0.8), sin(d * 50.0 + iTime * 4.0 * sign(-d)) * 0.3 + 0.3);\n    col -= smoothstep(0.01, 0.0, abs(d));\n    \n    vec2 origin = vec2(0.0);\n    vec2 dir = normalize(mouseP - origin);\n    \n    float t = 0.0;\n    for (int i = 0; i < MAX_RAYS && t < MAX_DIST; i++) {\n        vec2 p = origin + dir * t;\n        float dist = map(p);\n        col = mix(col, vec3(1.0, 0.0, 0.0), step(abs(length(uv - p) - dist) - 0.005, 0.0));\n        //if (dist < 0.0001) break;//original\n        if (logEps(dist,t))break;\n        t += dist * mix(0.2,1.,(cos(iTime*10.)*.5+.5));//oscillating understepping over time\n        // by multiplying dist by some fraction here, you-\n        // can decrease the potential of overshoothing\n    }\n    col = mix(col, vec3(0.0), step(line(uv, origin, origin + dir * t) - 0.01, 0.0));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 784, 854, 932, 3170], [3366, 3366, 3385, 3385, 3432], [3433, 3433, 3456, 3456, 3631], [3632, 3632, 3657, 3657, 3831], [3833, 3833, 3870, 3870, 4008], [4009, 4009, 4029, 4029, 4097], [4099, 4099, 4156, 4156, 5275]], "test": "untested"}
{"id": "csXBWB", "name": "Inebriated Bouncing Cross DVD", "author": "martymarty", "description": "I started with a box and made it move around the screen. I wanted it to move randomly and watch when it hits the corner like the Office episode. I added the speed up slow down, rotations and blur. It reminds me of a sea creature now.", "tags": ["tutorial", "learning", "rotation", "practice"], "likes": 2, "viewed": 176, "published": 3, "date": "1691032369", "time_retrieved": "2024-07-30T17:41:06.819863", "image_code": "#define PI 3.14159265359\n\nfloat box1(in vec2 _st, in vec2 _size, float blur){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,_size+vec2(blur), _st) \n              - smoothstep(vec2(1.0)-_size - vec2(blur), vec2(1.0)- _size, _st);\n    //uv *= smoothstep(_size, _size + vec2(0.001), vec2(1.0)- _st);\n    clamp(uv,0.0,1.0);\n    return uv.x*uv.y;\n}\n\nfloat box2(in vec2 _st, in vec2 _size, float blur){\n    _size = vec2(0.5) - _size*0.5;\n    //vec2 uv = smoothstep(_size,_size+vec2(0.001), _st) \n    //          - smoothstep(vec2(1.0)-_size - vec2(0.001), vec2(1.0) - _size, _st);\n    vec2 uv = smoothstep(_size, _size + vec2(2.0), _st);\n    uv *= smoothstep(_size, _size + vec2(2.0), vec2(1.0)- _st);\n    return uv.x*uv.y;\n}\n\nfloat drawcross(in vec2 _st, float _size, float blur){\n    return box1(_st, vec2(_size,_size/4.0), blur) + box1(_st, vec2(_size/4.0, _size), blur);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle), sin(_angle), cos(_angle));\n}\n\nmat2 scale2d(vec2 _scale){\n    return mat2(_scale.x,0.0,0.0,_scale.y);\n}\nfloat triangle(float top, float period, float x){\n    return top*abs(2.0*fract(x/period-0.5)-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    fragCoord.x = fragCoord.x -  0.5*(iResolution.x-iResolution.y);\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0.0);\n    vec2 translate = vec2(-0.375+triangle(0.75,1.0/sqrt(2.0),(iTime+4.0*sin(iTime*0.25))*0.1+0.1),-0.375+triangle(0.75,1.0/sqrt(3.0),(iTime+3.0*sin(iTime*0.33))*0.1+0.15));\n    //vec2 translate = vec2(-0.375*cos(2.0*PI*sqrt(2.0)*((iTime+4.0*sin(iTime*0.25))*0.1+0.1)),-0.375*cos(2.0*PI*sqrt(3.0)*((iTime+3.0*sin(iTime*0.33))*0.1+0.15)));\n    float newTime = iTime-0.02;\n    float newTimeCos = newTime -0.03;\n    vec2 translate2 = vec2(-0.375+triangle(0.75,1.0/sqrt(2.0),(newTime+4.0*sin(newTime*0.25))*0.1+0.1),-0.375+triangle(0.75,1.0/sqrt(3.0),(newTime+3.0*sin(newTime*0.33))*0.1+0.15));\n    vec2 translate2cos = vec2(-0.375*cos(2.0*PI*sqrt(2.0)*((newTimeCos+4.0*sin(newTimeCos*0.25))*0.1+0.1)),-0.375*cos(2.0*PI*sqrt(3.0)*((newTimeCos+3.0*sin(newTimeCos*0.33))*0.1+0.15)));\n    translate2 = (3.5*translate2+translate2cos)/4.5;\n    translate.x *= 2.07;\n    translate2.x *= 2.07;\n    vec2 echouv = vec2(uv.x,uv.y);\n    echouv -=translate2;\n    uv -= translate;\n    col = vec3(0.0,1.1*uv.y,1.1*uv.x);\n    uv -= vec2(0.5);\n    echouv -= vec2(0.5);\n    uv *= rotate2d(2.0*PI*sin(iTime*0.2));\n    echouv *= rotate2d(2.0*PI*sin((newTimeCos-0.4)*0.20));\n    uv += vec2(0.5);\n    echouv += vec2(0.5);\n    vec2 echo1 = uv*0.66667+echouv*0.33333;\n    vec2 echo2 = uv*0.33333+echouv*0.66667;\n    //col += 0.2*(5.0*vec3(cross(uv,0.25,0.001))+1.0*vec3(cross(echouv,0.25,0.1)));\n    float cross1 = drawcross(uv,0.25,0.003);\n    float cross2 = drawcross(echo1,0.26,0.025);\n    float cross3 = drawcross(echo2,0.26,0.025);\n    float cross4 = drawcross(echouv,0.27,0.025);\n\n    col += 0.9*vec3(cross1);\n    col += 0.25*vec3(cross2);\n    col += 0.15*vec3(cross3);\n    col += 0.1*vec3(cross4);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csXBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 77, 77, 363], [365, 365, 416, 416, 739], [741, 741, 795, 795, 890], [892, 892, 920, 920, 991], [993, 993, 1019, 1019, 1065], [1066, 1066, 1115, 1115, 1166], [1168, 1168, 1225, 1275, 3146]], "test": "untested"}
{"id": "DllcDM", "name": "TOXI_SPIRAL_01", "author": "Toxijuice", "description": "I was trying to draw a straight line but then it went really not straight.", "tags": ["spiral", "neon"], "likes": 3, "viewed": 148, "published": 3, "date": "1691023674", "time_retrieved": "2024-07-30T17:41:07.582823", "image_code": "const float PI = 3.1415926535;\n\nvec3 uvspiral(vec2 uv, float angleRadians, float zoom){\n    float centerDist = length(uv);\n\n    float angle = (centerDist * zoom * PI) + angleRadians;\n    float sinA = sin(angle);\n    float cosA = cos(angle);\n\n    mat2 rotMat = mat2(cosA, -sinA, sinA, cosA);\n\n    return vec3((uv * rotMat).xy, centerDist);\n}\n\nvec2 spiral(vec2 uv, float angleRadians, float zoom){\n    vec3 ruv = uvspiral(uv, angleRadians, zoom);\n    \n    float arc = ((atan(ruv.x, ruv.y)/(PI*2.0))+0.5);\n    arc = min(arc, (1.0-arc)) * 2.0;\n\n    return vec2(arc, ruv.z);\n}\n\nfloat smoothedge(float x, float width, float edge){\n    return smoothstep(width + edge, width, x);\n}\n\nfloat brightedge(float x, float width){\n    return 1.0 / x * width;\n}\n\nfloat sin01(float x){\n    return (sin(x) + 1.0) * 0.5;\n}\n\nfloat cos01(float x){\n    return (cos(x) + 1.0) * 0.5;\n}\n\nfloat snap(float x, float amount){\n    x *= amount;\n    x = floor(x);\n    return x / amount;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.y;\n  uv.x -= 9./16. * 0.666666; // Not really sure if this is the right math\n  \n  vec2 ouv = uv;\n  uv = (uv - 0.5) * 2.0;\n\n  vec3 col = vec3(0.0);\n\n  float centerDist = length(uv);\n\n  float speed = -0.75;\n  float zoom = 3.0 / ((1.0-sin01(iTime * 0.5 + centerDist)+0.25));\n  float angle = (fract(iTime*speed) * PI * 2.0);\n\n  vec2 sp = spiral(uv, angle, zoom);\n\n  float width = 0.2 + 0.1 * sin01(iTime * 1.33 + sp.y * 5.);\n\n  vec3 ratioA = vec3(0.6588, 0.7451, 0.4);\n  vec3 ratioB = vec3(0.4549, 0.6784, 0.7922);\n  vec3 ratio = mix(ratioA, ratioB, sin01(iTime + sp.y));\n  vec3 bgratio = mix(ratioA, ratioB, sin01(iTime + sp.y + 0.5));\n\n  col.r = brightedge(sp.x, width*ratio.r);\n  col.g = brightedge(sp.x, width*ratio.g);\n  col.b = brightedge(sp.x, width*ratio.b);\n\n  col = mix(col, col * col, 1.25);\n  col = clamp(col, 0.0, 1.0);\n  col += bgratio * 0.25;\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 87, 87, 340], [342, 342, 395, 395, 571], [573, 573, 624, 624, 673], [675, 675, 714, 714, 744], [746, 746, 767, 767, 802], [804, 804, 825, 825, 860], [862, 862, 896, 896, 956], [958, 958, 1013, 1013, 1938]], "test": "untested"}
{"id": "Dtfyzl", "name": "Custom Kuwahara Filter", "author": "copperbotte", "description": "This is a naiive Kuwahara filter using a gaussian blur.  Interestingly, it acts like a convolutional neural network doing a min pool!\nIt sure does look like Skyward Sword's depth of field.\n\nMade as shader help for Kyecedar", "tags": ["blur", "kuwahara"], "likes": 6, "viewed": 234, "published": 3, "date": "1691020451", "time_retrieved": "2024-07-30T17:41:08.419586", "image_code": "\nvec4 sector_data(vec2 uv, vec2 sector_scale)\n{\n    // Compute the mean of a sector\n    vec2 duv = vec2(1)/iResolution.xy;\n    \n    vec3 mean = vec3(0);\n    \n    const int samples = 3;\n    for(int i=0; i<samples; ++i)\n    {\n        float dx = duv.x * float(i+1);\n        for(int j=0; j<samples; j++)\n        {\n            float dy = duv.y * float(j+1);\n            vec2 duv = vec2(dx, dy) * sector_scale;\n            mean += texture(iChannel0, uv + duv).xyz;\n        }\n    }\n    mean /= float(samples*samples);\n    \n    // Compute the variance of a sector\n    float var = 0.0;\n    for(int i=0; i<samples; ++i)\n    {\n        float dx = duv.x * float(i+1);\n        for(int j=0; j<samples; j++)\n        {\n            float dy = duv.y * float(j+1);\n            vec2 duv = vec2(dx, dy) * sector_scale;\n            vec3 dcol = texture(iChannel0, uv + duv).xyz - mean;\n            var += dot(dcol, dcol);\n        }\n    }\n    //var /= float(samples*samples);\n    return vec4(mean, var);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 duv = vec2(9)/iResolution.xy;\n    \n    /*vec4 sec0 = texture(iChannel1, uv + duv*vec2( 1, 1));//sector_data(uv, vec2( 1, 1));\n    vec4 sec1 = texture(iChannel1, uv + duv*vec2(-1, 1));//sector_data(uv, vec2(-1, 1));\n    vec4 sec2 = texture(iChannel1, uv + duv*vec2(-1,-1));//sector_data(uv, vec2(-1,-1));\n    vec4 sec3 = texture(iChannel1, uv + duv*vec2( 1,-1));//sector_data(uv, vec2( 1,-1));\n    \n    vec4 sec = sec0;\n    if(sec1.w < sec.w) sec = sec1;\n    if(sec2.w < sec.w) sec = sec2;\n    if(sec3.w < sec.w) sec = sec3;\n    // sec.xyz is now the minimum std of the 4 sectors\n    \n    vec3 col = sec.xyz;\n    */\n    \n    vec4 minsec = vec4(0,0,0,1e30);\n    minsec = texture(iChannel1, uv);\n    \n    const int sectors = 6;\n    for(int i=0; i<sectors; i++)\n    {\n        const float pi = 3.141592;\n        float angle = pi/4.0 + float(i)*2.0*pi/float(sectors) + iTime;\n        vec4 sec = texture(iChannel1, uv + duv*vec2(cos(angle), sin(angle)));\n        if(sec.w < minsec.w) minsec = sec;\n    }\n    \n    vec3 col = minsec.xyz;\n    //col = texture(iChannel1, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat kernel(vec2 uv, vec2 duv)\n{\n    const float sigma = 0.01;//9.0;\n    duv /= sigma;\n    return exp(-dot(duv, duv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Gaussian blur\n    vec2 duv0 = vec2(1)/iResolution.xy;\n    const int samples = 21;\n    float weight = 0.0;\n    for(int i=0; i<samples; ++i)\n    {\n        float dx = float(i - samples/2);\n        for(int j=0; j<samples; j++)\n        {\n            float dy = float(j - samples/2);\n            vec2 duv = vec2(dx, dy) * duv0;\n            weight += kernel(uv, duv);\n        }\n    }\n    \n    vec3 mean = vec3(0);\n    for(int i=0; i<samples; ++i)\n    {\n        float dx = float(i - samples/2);\n        for(int j=0; j<samples; j++)\n        {\n            float dy = float(j - samples/2);\n            vec2 duv = vec2(dx, dy) * duv0;\n            mean += texture(iChannel0, uv + duv).xyz * kernel(uv, duv) / weight;\n        }\n    }\n    \n    // Compute the variance of a sector\n    float var = 0.0;\n    for(int i=0; i<samples; ++i)\n    {\n        float dx = float(i - samples/2);\n        for(int j=0; j<samples; j++)\n        {\n            float dy = float(j - samples/2);\n            vec2 duv = vec2(dx, dy) * duv0;\n            vec3 dcol = texture(iChannel0, uv + duv).xyz - mean;\n            var += dot(dcol, dcol) * kernel(uv, duv) / weight;\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(mean,var);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dtfyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 47, 83, 980], [982, 982, 1039, 1089, 2265]], "test": "untested"}
{"id": "clsczX", "name": "eindacor_im_too_hexy", "author": "Eindacor_DS", "description": "it's a better hex grid, you dolt!", "tags": ["hexagons"], "likes": 0, "viewed": 14, "published": 3, "date": "1691007927", "time_retrieved": "2024-07-30T17:41:09.194514", "image_code": "#define TWOPI 6.28318530718f\n#define AA 0.001f\n#define SIXTY_DEGREES 1.0471975512f\n\nfloat hash(vec2 p)\n{\n    float val = sin(dot(p, vec2(12.9898f, 78.233f))) * 43758.5453f;\n    return val - floor(val);\n}\n\nfloat circleSmoothStepFill(vec2 center, float radius, vec2 p, float antiAlias) {\n\treturn 1.f - smoothstep(radius - antiAlias, radius + antiAlias, distance(center, p));\n}\n\nvec2 rotateAroundAxis(vec2 point, vec2 axis, float angle) \n{\n    point -= axis;\n    float x = point.x * cos(angle) - point.y * sin(angle);\n    float y = point.y * cos(angle) + point.x * sin(angle);\n    return vec2(x, y) + axis;\n}\n\nfloat lineSegmentSmoothStep(vec2 start, vec2 end, vec2 p, float lineThickness, float antiAlias, bool roundEnds) {\n    float halfThickness = lineThickness / 2.f;\n    if (dot(p-end, start - end) < 0.f || dot(p - start, end - start) < 0.f) {\n        return !roundEnds ? 0.f : max(\n\t\t\tcircleSmoothStepFill(start, halfThickness, p, antiAlias),\n\t\t\tcircleSmoothStepFill(end, halfThickness, p, antiAlias)\n        );  \n    }\n    \n    vec2 lineVec = normalize(end - start);\n    vec2 pVec = normalize(p - start);\n\n    float angle = acos(dot(lineVec, pVec) / length(lineVec) * length(pVec));\n    float distFromLine = sin(angle) * distance(start, p);\n    \n    return 1.f - smoothstep(lineThickness / 2.f - antiAlias, halfThickness + antiAlias, distFromLine);\n}\n\nstruct AspectRatioData {\n    mat2x2 scaleMatrix;\n    mat2x2 inverseScaleMatrix;\n    float aspectRatio;\n};\n\nAspectRatioData getAspectRatioData(vec2 uvSize) {\n    float aspectRatio = uvSize.x / uvSize.y;\n    AspectRatioData aspectRatioData;\n    aspectRatioData.aspectRatio = aspectRatio;\n    aspectRatioData.scaleMatrix = mat2x2(\n        aspectRatio, 0.f,\n        0.f, 1.f\n    );\n    \n    aspectRatioData.inverseScaleMatrix = mat2x2(\n        1.f / aspectRatio, 0.f,\n        0.f, 1.f\n    );\n\n    return aspectRatioData;\n}\n\nvec3 getLocalHexCenter(vec2 uv, float hexRadius) {\n    float shortRadius = hexRadius * sin(SIXTY_DEGREES);\n    vec2 hexCenter = vec2(uv.x - mod(uv.x, 2. * shortRadius) + shortRadius,\n                            uv.y - mod(uv.y, 3. * hexRadius) + 1.5 * hexRadius);\n         \n    return vec3(hexCenter.x, hexCenter.y, distance(hexCenter, uv));\n}\n\nvec2 getHexCenter(vec2 uv, float hexRadius)\n{\n    float shortRadius = hexRadius * sin(SIXTY_DEGREES);\n    vec3 hexCenter1 = getLocalHexCenter(uv, hexRadius);\n         \n    vec2 altOffset = vec2(shortRadius, 1.5 * hexRadius);\n                            \n    vec3 hexCenter2 = getLocalHexCenter(uv + altOffset, hexRadius);\n                            \n    if (hexCenter1.z < hexCenter2.z) {\n        return hexCenter1.xy;\n    } else {\n        return hexCenter2.xy - altOffset;\n    }\n}\n\nstruct HexData {\n    // value (0 -> 1) representing the uv's value in radial space, origin is (1, 0)\n    float radialVal; \n    \n    // value (0 -> 1) representing approximity to center compared to hex radius\n    float distFromCenter;  \n    \n    // center vertex of the hexagon\n    vec2 center;           \n    \n    // locations of each vertex of the hex\n    vec2[6] vertices;  \n    \n    // locations of hex midpoints\n    vec2[6] midpoints; \n    \n    // value (0 -> 1) representing approximity to center compared to hexagon's edge\n    float edgeCoefficient;  \n    \n    // value (0 -> 1) representinglinear interpolation of radians between local triangle vertices\n    float radialLerp;      \n};\n\n\nmat2x2 createRotationMatrix(float rotation) {\n    return mat2x2(\n        cos(rotation), -sin(rotation),\n        sin(rotation), cos(rotation)\n    );\n}\n\nvec2[6] getHexMidpoints(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = hexCenter + vec2(hexRadius * sin(SIXTY_DEGREES), 0.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = rotateAroundAxis(firstVertex, hexCenter, rotationIncrement * float(i));\n    }\n    \n    return hexVertices;\n}\n\nvec2[6] getHexVertices(vec2 hexCenter, float hexRadius) {\n    vec2[6] hexVertices;\n    \n    float rotationIncrement = TWOPI / 6.;\n    \n    vec2 firstVertex = rotateAroundAxis(hexCenter + vec2(hexRadius, 0.), hexCenter, TWOPI / 12.);\n    \n    for (int i=0; i<6; ++i) {\n        hexVertices[i] = rotateAroundAxis(firstVertex, hexCenter, rotationIncrement * float(i));\n    }\n    \n    return hexVertices;\n}\n\nfloat getOffsetAngle(vec2 first, vec2 second) {\n    vec2 offsetVec = second - first;\n    float angle = atan(offsetVec.y / offsetVec.x);\n    \n    \n    if (first.x < second.x) {\n        angle = TWOPI / 2.f + angle;\n    } else if (first.y > second.y) {\n        angle = TWOPI + angle;\n    }\n    \n    return angle;\n}\n\nfloat getRadialVal(vec2 hexCenter, vec2 p) {\n    float offsetAngle = getOffsetAngle(hexCenter, p);\n    offsetAngle = mod(TWOPI - offsetAngle + 3.f * TWOPI / 6.f, TWOPI);\n    return offsetAngle / TWOPI;\n}\n\nHexData getHexData(\n    vec2 uv, \n    float hexRadius) \n{\n    float aspectHexRadius = hexRadius;\n    vec2 hexCenter = getHexCenter(uv, hexRadius);\n    \n    HexData hexData;\n    hexData.radialVal = getRadialVal(hexCenter, uv);\n    hexData.center = hexCenter;\n    hexData.distFromCenter = distance(uv, hexCenter) / hexRadius;\n    hexData.vertices = getHexVertices(hexCenter, hexRadius);\n    hexData.midpoints = getHexMidpoints(hexCenter, hexRadius);\n    hexData.radialLerp = mod(hexData.radialVal, 1./6.) / (1./6.);\n     \n    return hexData;\n}\n\nfloat getLineValFromVertices(vec2 uv, vec2[6] vertices, float lineThickness) {\n    float lineVal = 0.;\n    for (int i=0; i<6; i++) {\n        vec2 first = vertices[i];\n\n        vec2 second;\n        if (i == 0) {\n            second = vertices[5];\n        } else {\n            second = vertices[i-1];\n        }\n        lineVal = max(lineVal, lineSegmentSmoothStep(first, second, uv, lineThickness, AA, true));\n    }\n    \n    return lineVal;\n}\n\nfloat getHoldTransitionValue(float lower, float upper, float holdTime, float transitionTime, float time) {\n    float period = 2. * holdTime + 2. * transitionTime;\n    float halfPeriod = period / 2.;\n    float relativeTime = fract(time / halfPeriod);\n    float halfHoldTime = holdTime / 2.;\n    \n    float val = smoothstep(halfHoldTime, halfHoldTime + transitionTime, relativeTime * halfPeriod);\n    \n    if (int(time / halfPeriod) % 2 == 0) {\n        val = 1. - val;\n    }\n\n    return mix(lower, upper, val);\n}\n\nfloat getHoldTransitionValue(float holdTime, float transitionTime, float time) {\n    return getHoldTransitionValue(0., 1., holdTime, transitionTime, time);\n}\n\nfloat getPointVal(vec2 uv, vec2 point, float radius, float antialias) {\n    float dist = distance(uv, point);\n    return smoothstep(radius + antialias, radius - antialias, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    AspectRatioData aspectRatioData = getAspectRatioData(iResolution.xy);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * aspectRatioData.scaleMatrix;\n    uv += vec2(iTime * .02, getHoldTransitionValue(0., 1., 2., 4., iTime * .2));\n\n    float hexRadius = .2;\n    vec2 hexCenter = getHexCenter(uv, hexRadius);\n    \n    HexData hexData = getHexData(uv, hexRadius);\n    \n    hexData.radialVal = mod(hexData.radialVal + iTime * .1 + hash(hexData.center), 1.);\n    //uv = rotateAroundAxis(uv, hexData.center, sin(iTime));\n    \n    float val = getHoldTransitionValue(2., 4., iTime);\n    \n    vec3 hexColor = vec3(mix(0.25, 1., abs(.5 - hexData.radialLerp) / .5),\n        mix(0.5, 1., abs(.5 - hexData.radialVal) / .5),\n        mix(0.25, .8, hexData.distFromCenter));\n   \n    float distVal = 1. - hexData.distFromCenter;\n    \n    float lineThickness = hexRadius * .02;\n    float lineVal = getLineValFromVertices(uv, hexData.vertices, lineThickness);\n    vec3 lineColor = vec3(1.);\n    \n    vec3 outColor = mix(hexColor, lineColor, lineVal);\n    \n    float timeVal = getHoldTransitionValue(1., 4., iTime * .2);\n    fragColor = vec4(outColor * mix(.25, 1., 1. - pow(distVal, timeVal + hexData.radialLerp)), 1.0);\n    \n    fragColor = mix(fragColor, vec4(lineColor, 1.), lineVal);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clsczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 104, 104, 203], [205, 205, 285, 285, 374], [376, 376, 436, 436, 605], [607, 607, 720, 720, 1354], [1463, 1463, 1512, 1512, 1874], [1876, 1876, 1926, 1926, 2219], [2221, 2221, 2266, 2266, 2703], [3399, 3399, 3444, 3444, 3548], [4336, 4336, 4383, 4383, 4647], [4649, 4649, 4693, 4693, 4852], [4854, 4854, 4911, 4911, 5395], [5838, 5838, 5944, 5944, 6348], [6350, 6350, 6430, 6430, 6507], [6509, 6509, 6580, 6580, 6689], [6691, 6691, 6748, 6748, 8028]], "test": "untested"}
{"id": "DtsyRf", "name": "suecia", "author": "CraquePedro", "description": "suecia", "tags": ["suecia"], "likes": 0, "viewed": 101, "published": 3, "date": "1691007210", "time_retrieved": "2024-07-30T17:41:09.965453", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (uv.y <= 0.5 + 0.05 && uv.y >= 0.5 - 0.05)\n    {\n        fragColor = vec4(1, 1, 0, 1);\n    }\n    else if (uv.x <= 0.3 + 0.05 && uv.x >= 0.3 - 0.05)\n    {\n        fragColor = vec4(1, 1, 0, 1);\n    }\n    else\n    {\n        fragColor = vec4(0,0.5,0.85,1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 416]], "test": "untested"}
{"id": "DllczX", "name": "inglaterra", "author": "CraquePedro", "description": "s", "tags": ["s"], "likes": 0, "viewed": 87, "published": 3, "date": "1691004733", "time_retrieved": "2024-07-30T17:41:10.827149", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (uv.y <= 0.5 + 0.05 && uv.y >= 0.5 - 0.05)\n    {\n        fragColor = vec4(0.8, 0., 0, 1);\n    }\n    else if (uv.x <= 0.5 + 0.05 && uv.x >= 0.5 - 0.05)\n    {\n        fragColor = vec4(0.8, 0, 0, 1);\n    }\n    else\n    {\n        fragColor = vec4(1,1,1,1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DllczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 416]], "test": "untested"}
{"id": "ctlczH", "name": "Courant Noise Voxels", "author": "fenix", "description": "The wave equation applied to a spherical source, with varying Courant number, rendered via voxel traversal. Voxel shadows are precomputed.\n\n*WASD/QE: control camera*\n*mouse: move light*\n*Left/right: voxel resolution*\n*space: reset*\n*alt: b/w*", "tags": ["3d", "noise", "wave", "light", "voxel", "volumetric", "shadows", "transparent", "translucent", "equation"], "likes": 28, "viewed": 267, "published": 3, "date": "1690996661", "time_retrieved": "2024-07-30T17:41:11.782594", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another shader using the wave equation, but in 3D. It's the 3D analogue of my\n//  previous shader\n//\n//      Courant Noise                      https://shadertoy.com/view/cslBWX\n//\n//  Specifically, they are both updated according to Nils Burglund's \"wave equation\"\n//  with a Courant number (also wave speed) that is positionally dependant.\n//\n//  The rendering is conceptually identical but cleaned up from its fork parent\n//\n//      Smoke of Many Colors               https://shadertoy.com/view/ddGGzd\n//      \n//  Buffer A runs the simulation while Buffer B computes the light/shadow reaching\n//  each voxel. By default, the voxel buffer size is the maximum possible NxNxN that\n//  will fit in your buffer; press left arrow to reduce it (and right arrow to increase\n//  it back again). You might get a performance benefit from a scaled-down buffer size.\n//\n//  I've tried to tune the sim so that different resolutions and buffer sizes appear\n//  as similar as I could get, but of course very small buffers look quite a bit\n//  different from \"normal sized\" ones.\n//\n//  Move the light around with the mouse, and take control of the camera with WASD/QE.\n//  Space to reset and resume camera rotation. Hold alt to turn off the false color\n//  for a more traditional \"cloud\" effect.\n//\n//  In terms of the implmentation, the voxel traversal is fairly standard but you\n//  might find it interesting that I achieved minimal \"generic programming\" with it.\n//  The traversal is implemented as a function-like macro INTEGRATE_VOXELS, so that\n//  different voxel processors can be plugged in. I am thereby able to use the same\n//  voxel loop for voxel self shadows, ground shadows, and voxel rendering.\n//\n//  The floor is rendered using the technique from iq's\n//\n//       Filtered checker (triangle, 3D)   https://shadertoy.com/view/llffWs\n//\n// ---------------------------------------------------------------------------------------\n\nvoid renderVoxels(vec3 ro, vec3 rd, int maxIter, float maxDist, inout vec3 color);\nvec3 ACESFilm(vec3 x);\nfloat renderChecker( in vec2 fragCoord, float light, float t, vec3 pos, vec3 ro, vec3 rd, vec3 ww, vec3 uu, vec3 vv );\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    // init global variables\n    fxGetState();\n    computeVoxelSide();\n\n    // set up main camera ray\n    vec3 ta, ro, fwd, left, up;\n    fxCalcCamera(ta, ro, fwd, left, up);\n    vec3 rd = fxCalcRay(u, iResolution, fwd, left, up);\n    \n    // noise to reduce visible voxel boundaries\n    float dth = textureLod(iChannel2,(floor(iTime*1024.0)+u)/1024.0,0.0).x*1.0;\n    vec3 dth3 = vec3(dth, fract(dth + .666), fract(dth * .333)) * 2. - 1.;\n\n    // ground\n    float t = -ro.y / rd.y;\n    vec3 hit = ro + rd * t; // ground hit position\n    vec3 ld = g_State.lightPos - hit; // light direction\n    float light = 1e2 * ld.y / dot(ld, ld); // light intensity\n\n    // compute shadows\n    ld = normalize(ld);\n    float block = 1.;\n    vec2 ts = boxIntersection(hit - vec3(0, g_vs / 2., 0), ld, vec3(g_vs / 2.));\n\n    if (ts.x != -1. && g_State.resolution > 0. && rd.y < 0.)\n    {\n        block = integrateDensity(hit + dth3, ld, g_ivs * 4, ts.y);\n    }\n\n    // checkerboard pattern\n    float check = renderChecker(u, light, t, hit, ro, rd, fwd, left, up);\n\n    // compute color\n    O = vec4(block * check);\n    \n    // check for ray hitting voxel bounding box\n    vec2 t2 = boxIntersection(ro - vec3(0, g_vs / 2., 0), rd, vec3(g_vs / 2.));\n    \n    if (t2.x != -1. && g_State.resolution > 0.)\n    {\n        // if the ray hits the box, cast against the voxels\n        renderVoxels(ro + rd * t2.x + dth3, rd, g_ivs * 2, t2.y, O.rgb);\n    }\n    \n    O.xyz = pow(ACESFilm(O.xyz), vec3(1./2.2));\n    O.a = 1.;\n}\n\n// VOXELS\n\n// light scattering\nconst float LIGHT_BLOCK = .5;\nconst float LIGHT_BOUNCE = 1.;\n\n// collect color contributed to the pixel by a single voxel. this function is designed\n// to be used as a \"functor\" for INTEGRATE_VOXELS.\nvoid colorFromVoxel(vec3 pos, inout vec4 acc, sampler2D vox, int width)\n{\n    vec4 v = voxel(pos);\n    if (v.w > MIN_DENS)\n    {\n        acc.a *= exp(-max(0., v.w)); // accumulate alpha with Beer's Law\n\n        ivec3 addr = ivec3(pos + vec3(g_vs / 2., 0, g_vs / 2.));\n        ivec2 coords = coordFromAddr(addr, width);\n        float light = fxIsStatePixel(coords) ? 0. : texelFetch(iChannel1, ivec2(coords), 0).x * .2 + .008; // get bounced/trasmitted light from buffer\n        vec3 color = keyDown(KEY_ALT) ? vec3(1) : normalize(sin(smoothstep(-0.8, .8, v.w) * 6. + vec3(0, 11, 33))); // colorize\n        acc.rgb += acc.a * v.w * light * LIGHT_BOUNCE * color; // add light contribution from bounced light\n    }\n}\n\n// traverse voxels and accumulate color along camera ray\nvoid renderVoxels(vec3 ro, vec3 rd, int maxIter, float maxDist, inout vec3 color)\n{\n    INTEGRATE_VOXELS(ro, rd, maxIter, maxDist, iChannel0, int(iResolution.x), colorFromVoxel);\n    \n\tcolor = color * a.a + a.rgb;\n}\n\n// COLOR GRADING\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\n// CHECKERED FLOOR\n\n// from iq's  Filtered checker (triangle, 3D)  https://shadertoy.com/view/llffWs\n// --- analytically triangle-filtered checkerboard ---\n\nvec3 pri(vec3 x)\n{\n    // see https://www.shadertoy.com/view/MtffWs\n    vec3 h = fract(x/2.)-.5;\n    return x*.5 + h*(1.-2.*abs(h));\n}\n\nfloat checkersTextureGradTri(vec3 p, vec3 ddx, vec3 ddy)\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + .001;      // filter kernel\n    vec3 i = (pri(p+w)-2.*pri(p)+pri(p-w))/(w*w); // analytical integral (triangle filter)\n    return .5 - .5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvec3 texCoords(vec3 p)\n{\n\treturn 5. * p / g_vs + vec3(0, .5, 0);\n}\n\nfloat renderChecker(vec2 u, float light, float t, vec3 pos, vec3 ro, vec3 rd, vec3 ww, vec3 uu, vec3 vv)\n{\n\tvec3 ddx_rd = fxCalcRay(u + vec2(1,0), iResolution, ww, uu, vv);\n\tvec3 ddy_rd = fxCalcRay(u + vec2(0,1), iResolution, ww, uu, vv);\n\n    // trace\n\tfloat col = rd.y * .1 + .02;\n\tif( t > 0. && ro.y > 0. )\n\t{\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ro - ddx_rd*(ro-pos).y/ddx_rd.y;\n\t\tvec3 ddy_pos = ro - ddy_rd*(ro-pos).y/ddy_rd.y;\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3     uvw = texCoords(    pos);\n\t\tvec3 ddx_uvw = texCoords(ddx_pos) - uvw;\n\t\tvec3 ddy_uvw = texCoords(ddy_pos) - uvw;\n        \n\t\t// shading\t\t\n\t\tcol = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n\n        // fog\t\t\n        col = mix( col, .9, 1.-exp( -.000001*t*t ) ) * light;\n\t}\n\t\n\treturn col * .8 + .1;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float LIGHT_INTENS = 1.5; // light intensity\nconst float MIN_DENS = .08; // miminum density\nconst float DENSITY_LIGHT_BLOCK = .1; // how much light is blocked by some amount of density\n\n// UTILITY\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat length2(vec3 v) { return dot(v, v); }\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_ALT 18\n#define KEY_SPACE 32\n\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n\n    return vec2( tN, tF );\n}\n\n// STATE MANAGEMENT\n\nstruct fxState\n{\n    vec3 lightPos;\n    float camAngle;\n    float camPitch;\n    float camOrbit;\n    float resolution;\n    float bufferScale;\n    float attractPause;\n    float camPitchVel;\n    float waveDelay;\n} g_State;\n\nvoid fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(0, 1), 0);\n    vec4 data2 = texelFetch(sampler, ivec2(0, 2), 0);\n    \n    g_State.camAngle = data0.x;\n    g_State.camPitch = data0.y;\n    g_State.camOrbit = data0.z;\n    g_State.resolution = data0.w;\n    g_State.bufferScale = data1.x;\n    g_State.camPitchVel = data1.y;\n    g_State.attractPause = data1.z;\n    g_State.lightPos = data2.xyz;\n    g_State.waveDelay = data2.w;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1)\n\nvec4 fxPutState(ivec2 ifc)\n{\n    if (ifc == ivec2(0, 2))\n        return vec4(g_State.lightPos, g_State.waveDelay);\n    else if (ifc == ivec2(0, 1))\n        return vec4(g_State.bufferScale, g_State.camPitchVel, g_State.attractPause, 0);\n    \n    return vec4(g_State.camAngle, g_State.camPitch, g_State.camOrbit, g_State.resolution);\n}\n\nbool fxIsStatePixel(ivec2 ifc)\n{\n    return ifc == ivec2(0) || ifc == ivec2(0, 1) || ifc == ivec2(0, 2);\n}\n\nconst int NUM_STATE_PIXELS = 3; // used to move voxels over so they do not overlap with state pixels\n\n// VOXELS\n\n// the length of the side of the voxel cube\nfloat g_vs = 0.;\nint g_ivs = 0;\n\n// compute the largest voxel side length that will fit in our buffer\n// must be called in each buffer before g_vs and g_ivs are valid\n#define computeVoxelSide() computeVoxelSideImpl(iResolution.xy)\nvoid computeVoxelSideImpl(vec2 res)\n{\n    float pixels = res.x * res.y * g_State.bufferScale;\n    g_vs = trunc(pow(pixels, 1./3.));\n    g_ivs = int(g_vs);\n}\n\n// compute the voxel address from the buffer coordinates where its data is stored\n#define posFromCoord(X) posFromCoordImpl(X, int(iResolution.x))\nvec3 posFromCoordImpl(ivec2 p, int width)\n{\n    int id = p.y * width + p.x - NUM_STATE_PIXELS;\n    int y = id / (g_ivs * g_ivs);\n    int xz = id - y * (g_ivs * g_ivs);\n    int x = xz / g_ivs;\n    int z = xz - x * g_ivs;\n    return vec3(x, y, z) - vec3(g_vs / 2., 0, g_vs / 2.);\n}\n\n// compute the buffer coordinates for a particular voxel\nivec2 coordFromAddr(ivec3 p, int width)\n{\n    int id = p.z + g_ivs * p.x + g_ivs * g_ivs * p.y + NUM_STATE_PIXELS;\n    int y = id / width;\n    int x = id - y * width;\n    return ivec2(x, y);\n}\n\n// get voxel data at a particular position\n#define voxel(X) voxelImpl(X, iChannel0, int(iResolution.x))\nvec4 voxelImpl(vec3 pos, sampler2D vox, int width)\n{\n    ivec3 addr = ivec3(pos + vec3(g_vs / 2., 0, g_vs / 2.));\n    if (addr.x < 0 || addr.y < 0 || addr.z < 0) return vec4(0);\n    if (addr.x >= g_ivs || addr.y >= g_ivs || addr.z >= g_ivs) return vec4(0);\n    ivec2 coords = coordFromAddr(addr, width);\n    return texelFetch(vox, ivec2(coords), 0);\n}\n\n// integrate voxels along ray, apply \"functor\" f\n#define INTEGRATE_VOXELS(ro, rd, mi, mt, vox, w, f) \\\nvec4 a = vec4(0,0,0,1);                             \\\nvec3 p = floor(ro),                                 \\\n     s = sign(rd),                                  \\\n     q = s / rd,                                    \\\n     d = (p - ro + .5 + s * .5) / rd, m;            \\\nfloat t = 0.;                                       \\\nfor (int x = 0; x < mi && t < mt; ++x)              \\\n{                                                   \\\n    f(p, a, vox, w);                                \\\n    m = step(d, d.yzx);                             \\\n    m *= (1. - m.zxy);                              \\\n    d += m * q;                                     \\\n    p += m * s;                                     \\\n    t = dot(d - q, m);                              \\\n}\n\n// get density from one voxel. this function is designed to be used as a \"functor\" for INTEGRATE_VOXELS.\nvoid densityFromVoxel(vec3 pos, inout vec4 acc, sampler2D vox, int width)\n{\n    acc.w *= exp(-max(0., voxelImpl(pos, vox, width).w * DENSITY_LIGHT_BLOCK));\n}\n\n// accumulate density along ray, for shadows (both per-voxel and on the ground)\n#define integrateDensity(X, Y, Z, W) integrateDensityImpl(X, Y, Z, W, iChannel0, int(iResolution.x))\nfloat integrateDensityImpl(vec3 eye, vec3 ray, int maxIter, float maxDist, sampler2D vox, int width)\n{\n    INTEGRATE_VOXELS(eye, ray, maxIter, maxDist, vox, width, densityFromVoxel);\n    \n    return max(0., a.w);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 ta, out vec3 ro, out vec3 fwd, out vec3 left, out vec3 up)\n{\n    ro = vec3(0, 0, g_State.camOrbit * g_vs);\n    ro.yz *= rotate(g_State.camPitch);\n    ro.xz *= rotate(g_State.camAngle);\n    ro.y += g_vs / 8.;\n    ta = vec3(0, g_vs / 2., 0);\n\n    fwd  = normalize(ta - ro);\n    left = -normalize(cross(fwd, vec3(0,1,0)));\n    up   = normalize(cross(left, fwd));\n}\n\nvec3 fxCalcRay(vec2 u, vec3 R, vec3 fwd, vec3 left, vec3 up)\n{\n\tvec2 screen = (u - .5 * R.xy) / R.y;\n\treturn normalize(fwd - screen.x * left - screen.y * up);\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Performs wave equation simulation; x is displacement, y is previous displacement\n// ---------------------------------------------------------------------------------------\n\nconst float SPAWN_DENSITY = 100.; // how strong the waves are when created\nconst float DAMPING = .99; // allows waves to fade as they spread\n\nfloat noise(vec3 p)\n{\n    p *= .005; // scale\n    p += iTime * .002; // motion\n\n    return .45 * textureLod(iChannel2, p, 0.).x\n         + .22 * textureLod(iChannel2, 2.3 * p, 0.).x\n         + .2  * textureLod(iChannel2, 4.4 * p, 0.).x\n         + .05 * textureLod(iChannel2, 6.3 * p, 0.).x;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxGetState();\n\n    O = vec4(0);\n    \n    if (iFrame == 0 || g_State.resolution < 0.)\n        return;\n\n    computeVoxelSide();\n\n    vec3 pos = posFromCoord(ivec2(u));\n    if (pos.y >= g_vs) return;\n    \n    float C = noise(pos); // Courant number, modulated by position\n    C *= .1 * C;\n    \n    O = voxel(pos).xxyz; // shift x into y to store prev; copy old prev into z for use\n    \n    const vec2 o = vec2(1, 0); // offset\n    O.x = -O.z + 2.*O.x + C*(voxel(pos + o.xyy) + voxel(pos - o.xyy) +\n                             voxel(pos + o.yxy) + voxel(pos - o.yxy) +\n                             voxel(pos + o.yyx) + voxel(pos - o.yyx) - 6. * O).x; // apply wave equation\n\n    // spawn spherical waves at center\n    float d = distance(pos, vec3(0, g_vs * .5, 0));\n    if (d < 3. && g_State.waveDelay <= 0.)\n        O.y += SPAWN_DENSITY * pow(g_State.bufferScale * iResolution.y / 2e3, 1.2) * sin(d) / (1. + d);\n\n    O.x *= DAMPING;\n    O.w = pow(abs(O.x), 1.3); // convenience for render\n}\n", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n// Computes the light reaching each voxel (shadow buffer) and maintains persistent state\n// ---------------------------------------------------------------------------------------\n\nconst float ATTRACT_PAUSE_TIME = 10.; // camera rotation restarts after this many seconds\n\nvoid updateCamera();\nvoid updateLightPos();\nbool updateState(ivec2 ifc);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxGetState();\n    \n    ivec2 ifc = ivec2(u);\n    if (updateState(ifc))\n    {\n        O = fxPutState(ifc);\n        return;\n    }\n\n    computeVoxelSide();\n\n    vec3 pos = posFromCoord(ifc);\n    if (pos.y >= g_vs) return;\n    \n    if (voxel(pos).w < MIN_DENS)\n    {\n        O.x = 1.; // skip voxels with no density...we'll never query them\n        return;\n    }\n    \n    // compute light reaching this voxel\n    vec3 delta = pos - g_State.lightPos;\n    vec3 lightDir = -normalize(delta);\n    float block = integrateDensity(pos + .5 + lightDir, lightDir, g_ivs * 2, g_vs);\n    O.x = block * LIGHT_INTENS * length2(g_State.lightPos) / length2(delta);\n}\n\n// STATE MANAGEMENT\n\nvoid updateCamera()\n{\n    if (keyDown(KEY_W)) { g_State.camPitch -= .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_S)) { g_State.camPitch += .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    g_State.camPitch = clamp(g_State.camPitch, -1.5, 1.5);\n    if (keyDown(KEY_A)) { g_State.camAngle -= .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_D)) { g_State.camAngle += .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_Q)) { g_State.camOrbit += .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    if (keyDown(KEY_E)) { g_State.camOrbit -= .1; g_State.attractPause = ATTRACT_PAUSE_TIME; }\n    g_State.camOrbit = max(.1, g_State.camOrbit);\n    \n    if (g_State.attractPause > 0.)\n    {\n        g_State.attractPause -= iTimeDelta;\n        g_State.camPitchVel = 0.;\n    }\n    else\n    {\n        g_State.attractPause = 0.;\n        \n        g_State.camAngle += .005;\n        g_State.camPitch += g_State.camPitchVel * 2e-5;\n        g_State.camPitchVel -= sin(g_State.camPitch * 2.) * 1.2 + .7;\n    }\n}\n\nvoid updateLightPos()\n{\n    vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    if (iMouse.z > 0.)\n        g_State.lightPos = floor(vec3(m.x * 300., m.y * 150. + 250., 200)) + .5; // keep light away from voxel sides to avoid traversal errors\n}\n\nbool updateState(ivec2 ifc)\n{\n    if (iFrame == 0)\n    {\n        g_State.camAngle = 3.;\n        g_State.camPitch = 0.;\n        g_State.camOrbit = 1.2;\n    }\n    \n    if (iFrame == 0 || keyClick(KEY_SPACE) || iResolution.x * iResolution.y != abs(g_State.resolution))\n    {\n        g_State.lightPos = vec3(-100, 300, 200);\n        g_State.resolution = -iResolution.x * iResolution.y;\n        g_State.bufferScale = 1.;\n        g_State.attractPause = 0.;\n        g_State.waveDelay = 0.;\n    }\n    else\n    {\n        g_State.resolution = abs(g_State.resolution);\n\n        updateCamera();\n        updateLightPos();\n\n        if (keyDown(KEY_LEFT)) { g_State.bufferScale *= .9; g_State.resolution = -abs(g_State.resolution); }\n        if (keyDown(KEY_RIGHT)) { g_State.bufferScale /= .9; g_State.resolution = -abs(g_State.resolution); }\n        \n        g_State.bufferScale = min(1., g_State.bufferScale);\n        \n        if (g_State.waveDelay < 0.)\n            g_State.waveDelay = 100.;\n        else\n            g_State.waveDelay--;\n    }\n\n    return fxIsStatePixel(ifc);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctlczH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2371, 2371, 2409, 2438, 3908], [4003, 4141, 4214, 4214, 4854], [4856, 4913, 4996, 4996, 5128], [5148, 5232, 5255, 5255, 5445], [5604, 5604, 5622, 5671, 5738], [5740, 5740, 5798, 5798, 6022], [6024, 6024, 6048, 6048, 6090], [6092, 6092, 6198, 6198, 6888]], "test": "untested"}
{"id": "mtfczX", "name": "Japan Flag Naka", "author": "nakanzaki", "description": "Japan Flag", "tags": ["japan"], "likes": 0, "viewed": 113, "published": 3, "date": "1690991264", "time_retrieved": "2024-07-30T17:41:12.594424", "image_code": "bool circle(vec2 pos, vec2 center, float radius) {\n    return distance(pos, center) < radius;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 center = vec2(iResolution.x / 2.0, iResolution.y / 2.0);\n\n    // Output to screen\n    if(circle(center, fragCoord, iResolution.y / 4.0)) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 95], [101, 101, 158, 208, 439]], "test": "untested"}
{"id": "mtfyzX", "name": "peruuuuuuuuuuuuuu", "author": "CraquePedro", "description": "A", "tags": ["a"], "likes": 0, "viewed": 94, "published": 3, "date": "1690990980", "time_retrieved": "2024-07-30T17:41:13.397277", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n   \n       if(uv.x>0.66)\n    {\n    \n    fragColor = vec4(1,0,0,1);\n    \n    } else{\n    \n    \n     fragColor = vec4(1,1,1,1);\n    }\n    if(uv.x<0.33)\n   {\n     fragColor = vec4(1,0,0,1);\n     }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtfyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 295]], "test": "untested"}
{"id": "mlXyzX", "name": "Lituânia", "author": "Rogrifo", "description": "Bandeira da Lituania", "tags": ["lituania"], "likes": 0, "viewed": 98, "published": 3, "date": "1690990955", "time_retrieved": "2024-07-30T17:41:14.220077", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(uv.y > 0.66) fragColor = vec4(0.9, 1.0, 0.0, 0.0);\n    \n    else if(uv.y < 0.33) fragColor = vec4(0.8, 0.0, 0.0, 1.0);\n    \n    else fragColor = vec4(0.0, 0.7, 0.3, 0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 333]], "test": "untested"}
{"id": "dlfcRX", "name": "Estônia DANÇANTE", "author": "Rogrifo", "description": "Bandeira da Estônia", "tags": ["estonia"], "likes": 0, "viewed": 79, "published": 3, "date": "1690990704", "time_retrieved": "2024-07-30T17:41:14.980046", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = sin(radians(100.0) * 4.0 *(iTime + uv.x))*0.25;\n    uv = uv + vec2(0.0, time * 0.05);\n\n    if(uv.y > 0.66) fragColor = vec4(0.1, 0.4, 1.0, 1.0);\n    \n    else if(uv.y < 0.33) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    else fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlfcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 441]], "test": "untested"}
{"id": "Dlfyzf", "name": "Letônia", "author": "Rogrifo", "description": "Bandeira da Letônia", "tags": ["letonia"], "likes": 0, "viewed": 80, "published": 3, "date": "1690990442", "time_retrieved": "2024-07-30T17:41:15.772925", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(uv.y < 0.4) fragColor = vec4(0.6, 0.0, 0., 0.0);\n    \n    else if(uv.y > 0.6) fragColor = vec4(0.6, 0.0, 0., 0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dlfyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 277]], "test": "untested"}
{"id": "ctfyzf", "name": "Italia", "author": "bjks", "description": "Shader de uma bandeira", "tags": ["flag", "trying", "class"], "likes": 0, "viewed": 87, "published": 3, "date": "1690990021", "time_retrieved": "2024-07-30T17:41:16.520925", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    if(uv.x<0.33) \n    {\n        fragColor = vec4(0,1,0,1);\n    }\n    else if(uv.x>0.66)\n    {\n       fragColor=vec4(1,0,0,1); \n    }\n    else\n    {\n       fragColor=vec4(1,1,1,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 361]], "test": "untested"}
{"id": "clXyzf", "name": "Julia sets montage", "author": "nicone1", "description": "Different Julia sets from Wikipedia put in a montage", "tags": ["juliamandelbrot"], "likes": 2, "viewed": 103, "published": 3, "date": "1690989186", "time_retrieved": "2024-07-30T17:41:17.268925", "image_code": "#define MAX_ITERATIONS 100.0\n#define MAX_BOUND 4.0\n#define PATTERN_AMOUNT 9.0 // Patterns 0.0 to PATTERN_AMOUNT included in transitions\n#define TRANSITION_DURATION 3.0\n#define COLOUR_INTENSITY 0.2 // Between 0.0 to 1.0\n\n// https://en.wikipedia.org/wiki/Julia_set\nconst vec2 patterns[] =\nvec2[]\n(\n    vec2(-0.4, 0.6),\n    vec2(0.285, 0.0),\n    vec2(0.285, 0.1),\n    vec2(0.45, 0.1428),\n    vec2(-0.70176, -0.3842),\n    vec2(-0.835,-0.2321),\n    vec2(-0.8, 0.156),\n    vec2(-0.7269, 0.1889),\n    vec2(0.0, 0.8)\n);\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(2.0, 1.0, 0.0);\n    vec3 d = vec3(0.5, 0.20, 0.25);\n\n    return a + b * cos(6.28318*(c * t +d ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    int pos = int(mod(iTime / TRANSITION_DURATION, PATTERN_AMOUNT));\n    float mixValue = mod(iTime, TRANSITION_DURATION) / TRANSITION_DURATION;\n    vec2 c = patterns[pos] * (1.0 - mixValue) + patterns[(pos + 1) % int(PATTERN_AMOUNT)] * mixValue;\n    vec2 z = uv;\n    \n    float it;\n    for (it = 0.0; it < MAX_ITERATIONS; ++it)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (dot(z, z) > MAX_BOUND)\n            break;\n    }\n    \n    float ratio = it / MAX_ITERATIONS;\n    vec3 col = vec3(ratio) * (1.0 - COLOUR_INTENSITY) + palette(ratio) * COLOUR_INTENSITY;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 513, 536, 536, 722], [724, 724, 779, 779, 1481]], "test": "untested"}
{"id": "clfyRX", "name": "Nixi Digital", "author": "Smoothie", "description": "fork of : https://www.shadertoy.com/view/csl3DS\n\nHorizontal Digital Format\nRemove noise artifacts ?", "tags": ["clock", "digital", "vertical", "seconds", "nixitubes"], "likes": 12, "viewed": 2147, "published": 3, "date": "1690979938", "time_retrieved": "2024-07-30T17:41:18.017923", "image_code": "#define TWELVE_HOUR_CLOCK   0\n#define GLOWPULSE    1\n#define SECONDS      1\n#define SHOW_GRID      0\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 cubic(vec2 p) {\n  return p * p * (3.0 - 2.0 * p);\n}\n\nvec2 quintic(vec2 p) {\n  return p * p * p * (10.0 + p * (-15.0 + p * 6.0));\n}\n\nfloat whiteNoise2x1(vec2 p) {\n  float random = dot(p, vec2(12., 78.));\n  random = sin(random);\n  random = random * 43758.5453;\n  random = fract(random);\n  return random;\n}\n\n//noise func from here https://github.com/SuboptimalEng/shader-tutorials/blob/main/04-worley-voronoi-noise/shader.frag \nfloat noise(vec2 uv) {\n  vec2 gridUv = fract(uv);\n  vec2 gridId = floor(uv);\n\n  gridUv = quintic(gridUv);\n\n  float botLeft = whiteNoise2x1(gridId);\n  float botRight = whiteNoise2x1(gridId + vec2(1.0, 0.0));\n  float b = mix(botLeft, botRight, gridUv.x);\n\n  float topLeft = whiteNoise2x1(gridId + vec2(0.0, 1.0));\n  float topRight = whiteNoise2x1(gridId + vec2(1.0, 1.0));\n  float t = mix(topLeft, topRight, gridUv.x);\n\n  float noise = mix(b, t, gridUv.y);\n\n  return noise;\n}\n\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Distance to a number This handles 2 digit integers, leading 0's will be drawn\nfloat dfNumberInt(vec2 origin, int inum, vec2 uv)\n{\n    float num = float(inum);\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 1.0;i >= 0.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\t\t\n        dist = min(dist, dfDigit(pos, d, uv));\n        offs++;\n\t}\n\treturn dist;\t\n}\n\nfloat dfColon(vec2 origin, vec2 uv) {\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.9)*1.1, 0.04,uv));\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.4)*1.1, 0.04,uv));\n    return dist;\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y - aspect/2.0) *1.1;\n\t\n    \n    int hour = int(iDate.w/3600.);\n#if TWELVE_HOUR_CLOCK\n    if( hour > 12 ) hour -= 12;\n    if( hour == 0 ) hour = 12;\n#endif\n    int minute = int(mod(iDate.w/60.,60.));\n    \n    \n\tfloat nsize = numberLength(999999.);\n\tvec2 pos = vec2((-digitSize.x*1.1),digitSize.y/1.4);\n\n    vec2 basepos = pos;\n    pos.y = basepos.y;\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumberInt(pos, hour, uv));\n    \n    \n    pos.y -= 0.32;\n    float dist2 = 1e6;\n\tdist = min(dist, dfNumberInt(pos, minute, uv));\n\n \n#ifdef SECONDS\n    int seconds = int(mod(iDate.w,60.));\n    \n    //pos.y += 0.27;\n\t//dist = min(dist, dfColon( pos, uv ));\n    pos.y -= 0.32;\n\tdist = min(dist, dfNumberInt(pos, seconds, uv));\n#endif\n    \n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.4;\n\t\n\tshade = 0.006 / (dist);\n\t\n\tcolor += vec3(0.2,0.8,0.2) * shade;\n#if GLOWPULSE\n\tcolor += vec3(0,1,0.2) * shade * noise((uv + vec2(iTime*0.3)) * 2.5 + .5);// * 10.*(noise(uv.yx));\n#endif\n\n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 339, 361, 361, 481], [483, 483, 503, 503, 539], [541, 541, 563, 563, 618], [620, 620, 649, 649, 791], [793, 913, 935, 935, 1386], [1389, 1419, 1464, 1464, 1642], [1644, 1680, 1732, 1732, 1818], [1820, 1842, 1917, 1917, 2239], [2241, 2276, 2322, 2322, 4590], [4592, 4615, 4664, 4664, 5053], [5055, 5135, 5186, 5186, 5481], [5483, 5483, 5520, 5520, 5723], [5725, 5756, 5785, 5785, 5844], [5846, 5846, 5904, 5904, 7179]], "test": "untested"}
{"id": "mtlczj", "name": "just_sound_round_bar", "author": "beetom", "description": "implementation of very high performance of music visualizer event on fullscreen mode, no for loop on any set of bar count!", "tags": ["soundbar"], "likes": 3, "viewed": 180, "published": 3, "date": "1690970124", "time_retrieved": "2024-07-30T17:41:18.777891", "image_code": "const lowp float PI = 3.1415926535;\nlowp float hash(lowp vec3 p)  \n{\n    p  = fract( p*0.3183099+.1 );\n    p *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nlowp float noise( in lowp vec3 x )\n{\n    lowp vec3 i = floor(x);\n    lowp vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n            mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nlowp float sdArc(lowp vec2 p, lowp vec2 o, lowp float iner, lowp float outer, lowp float rays)\n{\n    lowp vec2 c = p - o;\n    lowp float n = length(c);\n    \n    p = p + vec2(.01, 0);\n    lowp float rad = mod(abs(acos((p.x * o.x + p.y * o.y) / (length(p) * length(o)))), PI);\n    rad = (o.y - p.y) < 0. ? rad : 2. * PI - rad;\n    lowp float crad = 2.0 * PI / rays;\n    \n    int i = int(rad / crad);\n    lowp float cd = noise(vec3(sin(iTime * 0.17 * float(i) * 0.3), cos(iTime * 0.07 * float(i)), cos(iTime * 0.09 * float(i) * 0.3)));\n    lowp float len = (outer-iner) * cd;\n    outer = iner + len;\n    \n    \n    lowp float t = float(i) * crad;\n    lowp float d0 = n - iner;\n    lowp float d1 = outer - n;\n    lowp float d2 = crad / 2.0 - abs(t - rad);\n    lowp float d = min(d0, d1);\n    d = min(d, d2);\n    \n    return smoothstep(0.0, 0.01, d);\n}\n\n\nvoid mainImage( out lowp vec4 fragColor, in lowp vec2 fragCoord )\n{\n    lowp vec2 uv = fragCoord/iResolution.xy;\n    uv = (vec2(.5) - uv) / vec2(.5);\n    uv.x *= (iResolution.x  / iResolution.y);\n    lowp float d = 0.f;\n    lowp vec3 col = vec3(.0f);\n    if(d > 0.f)\n        col += vec3(d);\n    lowp vec3 colorIndicator = vec3(1., .4, .7);\n    lowp vec3 colorBg = vec3(.3, .3, .3);\n        \n    d = sdArc(vec2(.0, .0), uv, 0.475, 1.0, 120.0);\n    if(d > 0.f)\n        col += (colorIndicator * d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtlczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dllyzj", "name": "Nixi Tubes HH:MM:SS", "author": "Smoothie", "description": "fork of : https://www.shadertoy.com/view/csl3DS\n\nAdded seconds fn on the same line.", "tags": ["clock", "seconds", "nixitubes"], "likes": 8, "viewed": 414, "published": 3, "date": "1690968421", "time_retrieved": "2024-07-30T17:41:19.537859", "image_code": "#define TWELVE_HOUR_CLOCK   0\n#define GLOWPULSE    1\n#define SECONDS      1\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nconst float scale = 1.0 / 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\n\n// hash function copy from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    \n    float a = hash12(i);\n    float b = hash12(i + vec2(1, 0));\n    float c = hash12(i + vec2(0, 1));\n    float d = hash12(i + vec2(1, 1));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n//Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n//Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n//Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep / 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n//Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n//Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n//Distance to a number This handles 2 digit integers, leading 0's will be drawn\nfloat dfNumberInt(vec2 origin, int inum, vec2 uv)\n{\n    float num = float(inum);\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 1.0;i >= 0.0;i--)\n\t{\t\n\t\tfloat d = mod(num / pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\t\t\n        dist = min(dist, dfDigit(pos, d, uv));\n        offs++;\n\t}\n\treturn dist;\t\n}\n\nfloat dfColon(vec2 origin, vec2 uv) {\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.9)*1.1, 0.04,uv));\n    dist = min(dist, dfCircle(vec2(offs+0.9,0.4)*1.1, 0.04,uv));\n    return dist;\n}\n\n//Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) / log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.y - aspect/2.0) *0.86;\n\t\n    \n    int hour = int(iDate.w/3600.);\n#if TWELVE_HOUR_CLOCK\n    if( hour > 12 ) hour -= 12;\n    if( hour == 0 ) hour = 12;\n#endif\n    int minute = int(mod(iDate.w/60.,60.));\n    //minute = 55;\n    \n    \n\tfloat nsize = numberLength(999999.);\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)/2.0;\n\n    vec2 basepos = pos;\n    pos.x = basepos.x;\n\tfloat dist = 1e6;\n    pos.x += 0.02;\n\tdist = min(dist, dfNumberInt(pos, hour, uv));\n    \n    pos.x += 0.27;\n\tdist = min(dist, dfColon( pos, uv ));\n    \n    pos.x += 0.27;\n    float dist2 = 1e6;\n\tdist = min(dist, dfNumberInt(pos, minute, uv));\n\n \n#ifdef SECONDS\n    int seconds = int(mod(iDate.w,60.));\n    \n    pos.x += 0.27;\n\tdist = min(dist, dfColon( pos, uv ));\n    pos.x += 0.27;\n\tdist = min(dist, dfNumberInt(pos, seconds, uv));\n#endif\n    \n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 / (dist);\n\t\n\tcolor += vec3(1,0.2,0) * shade;\n#if GLOWPULSE\n\tcolor += vec3(1,0.2,0) * shade * noise((uv + vec2(iTime*.5)) * 2.5 + .5);// * 10.*(noise(uv.yx));\n#endif\n\n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 / iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 314, 336, 336, 456], [459, 459, 482, 482, 771], [773, 803, 848, 848, 1026], [1028, 1064, 1116, 1116, 1202], [1204, 1226, 1301, 1301, 1623], [1625, 1660, 1706, 1706, 3974], [3976, 3999, 4048, 4048, 4437], [4439, 4519, 4570, 4570, 4865], [4867, 4867, 4904, 4904, 5107], [5109, 5140, 5169, 5169, 5228], [5230, 5230, 5288, 5288, 6646]], "test": "untested"}
{"id": "mlfcz2", "name": "Sea ice", "author": "jarble", "description": "A sea of fractured ice floes.", "tags": ["fbm", "ice"], "likes": 15, "viewed": 243, "published": 3, "date": "1690947303", "time_retrieved": "2024-07-30T17:41:20.397560", "image_code": "//based on\n//https://www.shadertoy.com/view/3dXcW2\n\n#define SC (250.0)\n\nvec2 triwave(vec2 uv){\n    return\n        //abs(fract(uv)-.5)\n        max(abs(fract(uv)-.5),abs(fract(uv.yx-.01)-.5))\n    ;\n}\n\n#define OCTAVES 8\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.,\n    value1=value,\n    amplitude = 2.;\n    uv /= 32./4.;\n    vec2 t1 = vec2(0.);\n    mat2 r = rotate2D(12.);\n    vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        t1= triwave(uv-triwave(uv1*r/2.15))-t1.yx;\n        value1=sqrt(value1*value1+value*value);\n        value =\n            ((t1.x-t1.y) * amplitude-value)\n            //abs(abs(t1.x+t1.y) * amplitude-value)\n        ;\n        uv1 = uv;\n        amplitude /= 2.15;\n        uv = (uv.yx*2.15 + t1)*r;\n    }\n    \n    return value1;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n    \n    //vec2 prev = vec2(0.);\n    //float t_prev = 0.;\n    \n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n        float f1 = f(pos,OCTAVES);\n\t\tfloat h = pos.y - f1;\n        //if(prev.y < h && prev.y < prev.x)\n        //return t_prev;\n        //prev = vec2(prev.y,h);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n        //t_prev = t;\n        \n\t}\n\n\treturn t;\n}\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * (iTime+12.)/4.;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    ro.y += fbm(ro.xz,OCTAVES)-1.8;\n\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n        \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iTime/8.-iMouse.x/iResolution.x*3.14*2.0);\n    }\n\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlfcz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 94, 94, 197], [218, 218, 242, 242, 294], [296, 296, 331, 380, 905], [907, 907, 929, 929, 959], [961, 961, 991, 991, 1041], [1043, 1043, 1063, 1063, 1110], [1112, 1112, 1145, 1145, 1339], [1341, 1341, 1408, 1408, 1845], [1846, 1846, 1898, 1898, 2443], [2445, 2445, 2496, 2496, 2697], [2699, 2699, 2725, 2725, 2801], [2869, 2869, 2926, 2926, 4899]], "test": "untested"}
{"id": "clfyz2", "name": "MrFuzz - Test3", "author": "MrFuzz32", "description": "test", "tags": ["test"], "likes": 1, "viewed": 129, "published": 3, "date": "1690931635", "time_retrieved": "2024-07-30T17:41:21.157528", "image_code": "#define PI 3.14159265359\n\nvec3 palette(float t){\n    vec3 a = vec3(0.968, 1.118, 1.278);\n    vec3 b = vec3(0.268, 0.318, 0.448);\n    vec3 c = vec3(-0.342, -0.162, 0.158);\n    vec3 d = vec3(-0.582, -0.452, -0.452);\n\n    return a + b*cos(2.0*PI*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \n    //Conform pixel coordinates to -1 to 1, and adjust for aspect ratio\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 finalColour = vec3(0.0);\n    float pixel_angle = mod(atan(uv.x,uv.y),2.0*PI);\n    float pixel_distance =  length(uv)* 2.0;\n    float line_angle = mod(iTime,2.0*PI);\n\n    vec3 col = palette((abs(uv.y)-0.5)*(sin(iTime/4.0)*4.0));\n    col *= 0.05/mod(abs(line_angle-pixel_angle),2.0*PI);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfyz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 254], [257, 257, 314, 393, 787]], "test": "untested"}
{"id": "clfyR2", "name": "Terror Van Damme [222 Chars]", "author": "SnoopethDuckDuck", "description": "1961 commercial is also pretty scary", "tags": ["parallax", "raytrace", "plane", "surface"], "likes": 20, "viewed": 222, "published": 3, "date": "1690928451", "time_retrieved": "2024-07-30T17:41:21.982323", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec3 p = iResolution,\n         v = vec3((u+u-p.xy)/p.y/3., 1);\n            \n    v.zy *= mat2(cos(vec4(0, -11, 11, 0) - .4));\n    \n    for (float d, i; i++ < 1e2; d += 1. - .4 * O.r + .5 * p.y) \n        p = vec3(5,0,1) + .25 *v * d,\n        O = texture(iChannel0, .1*p.xz);\n               \n    O *= 3. * O * O;\n}\n\n// Original [252]\n/*\n#define T texture(iChannel0, .1*p.xz)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         v = normalize(vec3(u + u - R.xy, 3. * R.y)),\n         p;\n            \n    v.zy *= mat2(cos(vec4(0, -11, 11, 0) - .4));\n    \n    for (float d, i; i++ < 1e2; ) \n        p = vec3(5,0,1) + v * d + .2 * p.y * v * d,\n        d += 1. - .3 * T.r + .5 * p.y;\n       \n    O = O - O + 3. * T * T * T;\n}\n//*/", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 354]], "test": "untested"}
{"id": "DlfyR2", "name": "Broken Puddles [262 Chars]", "author": "SnoopethDuckDuck", "description": "jank", "tags": ["reflection", "water", "parallax", "raytrace", "plane", "surface"], "likes": 27, "viewed": 311, "published": 3, "date": "1690928177", "time_retrieved": "2024-07-30T17:41:22.732318", "image_code": "// -6  thanks to iq      😎\n// -14 thanks to Fabrice 😎\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 p = iResolution,\n         v = vec3((u+u-p.xy)/p.y/6., 1);        \n    v.zy *= mat2(cos(vec4(0, -11, 11, 0) - .37));\n    \n    for (float d, i; i++ < 1e2; d += 1. - .3*O.r + .5*p.y) \n        p = vec3(.1,0,.5) * iTime + v*d + .3*p.y * v*d // 100% jank\n          + cos(p.x + p.z + iTime) / 1e2, // cos for waves\n        O = texture(iChannel0, .07*p.xz);\n       \n    O *= 5. * O*O;\n}\n\n\n// Original\n/*\n#define T texture(iChannel0, .07*p.xz)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 R = iResolution,\n         v = normalize(vec3(u + u - R.xy, 6. * R.y)),\n         p;\n            \n    v.zy *= mat2(cos(vec4(0, -11, 11, 0) - .37));\n    \n    for (float d, i; i++ < 1e2; ) \n        p = vec3(.1, 0, .5) * iTime + v * d + .3 * p.y * v * d // 100% jank\n          + cos(p.x + p.z + iTime) / 1e2, // cos for waves\n        d += 1. - .3 * T.r + .5 * p.y;\n       \n    O = O - O + 5. * T * T * T;\n}\n//*/", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlfyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 98, 98, 486]], "test": "untested"}
{"id": "DtsczS", "name": "Gravity's Fractal Spectrum", "author": "vipiao", "description": "Gravity simulation. Press 'r' to reset and 't' to switch views. Four colored gravity points attract particles with initial position of the pixel. Change common file for different behaviour. Check http://y2u.be/3jJ51bj1jTM which this was inspired by.", "tags": ["simulation", "fractals", "physics", "particle", "gravity"], "likes": 1, "viewed": 162, "published": 3, "date": "1690909581", "time_retrieved": "2024-07-30T17:41:23.485305", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Convert to pixel coordinates\n    vec2 pixel = fragCoord;\n    vec3 color = vec3(0.0); // Initialize as black\n\n    // Check if 't' or 'T' key is pressed\n    bool keyT = texelFetch(iChannel1, ivec2(KEY_T, 0), 0).x > 0.5;\n\n    // Fetch the particle data from Buffer A\n    vec4 bufferAColor = texelFetch(iChannel0, ivec2(pixel), 0);\n    vec2 position = bufferAColor.rg;\n\n    if(keyT) {\n        for(int i = 0; i < 4; i++) {\n            vec2 gpPos = gravityPoints[i].position;\n            vec3 gpColor = gravityPoints[i].color;\n\n            float distance = length(pixel - gpPos);\n            if(distance < RADIUS) {\n                color = gpColor;\n                break;\n            }\n        }\n\n        for(int i = 0; i < numRenderIndices; i++) {\n            ivec2 renderIndex = renderIndices[i];\n            vec4 bufferAColor = texelFetch(iChannel0, renderIndex, 0);\n            vec2 position = bufferAColor.rg;\n\n            if(distance(position, pixel) < 1.0) {\n                color = vec3(1.0); // Render as white\n                break;\n            }\n        }\n    } else {\n        vec3 totalColor = vec3(0.0);\n        float totalWeight = 0.0;\n        for(int i = 0; i < 4; i++) {\n            vec2 gpPos = gravityPoints[i].position;\n            vec3 gpColor = gravityPoints[i].color;\n            float distance = length(position - gpPos);\n            float weight = 1.0 / (distance + 1.0);\n            totalColor += weight * gpColor;\n            totalWeight += weight;\n        }\n        color = totalColor / totalWeight; // Calculate weighted average\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Get integer position from fragCoord\n    ivec2 pixel = ivec2(fragCoord);\n\n    vec4 previousColor;\n\n    // Check if 'r' or 'R' key is pressed\n    bool keyR = texelFetch(iChannel1, ivec2(KEY_R, 0), 0).x > 0.5;\n\n    if (keyR || iFrame == 0) {\n        previousColor = vec4(fragCoord.x, fragCoord.y, initVel.x, initVel.y);\n    } else {\n        // Read the previous frame's color\n        previousColor = texelFetch(iChannel0, pixel, 0);\n    }\n\n    // Get the position and velocity from the color\n    vec2 position = previousColor.rg;\n    vec2 velocity = previousColor.ba;\n\n    // Calculate total acceleration\n    vec2 totalAcceleration = vec2(0.0);\n    for(int i = 0; i < 4; i++) {\n        vec2 direction = gravityPoints[i].position - position;\n        float distance = length(direction);\n        if(distance >= RADIUS) {\n            vec2 normalizedDirection = direction / distance;\n            vec2 acceleration = G * normalizedDirection / (distance * distance);\n            totalAcceleration += acceleration;\n        } else {\n            velocity = vec2(0.0);  // Velocity set to 0 if within RADIUS\n            totalAcceleration = vec2(0,0);\n            break;\n        }\n    }\n\n    // Calculate the time variable 't'\n    float t = 1.0 / (length(totalAcceleration)*1000. + 0.01);\n    if(t < 1.0) {\n        t = 1.0;\n    }\n\n    // Half-acceleration application\n    velocity += 0.5 * totalAcceleration * t;\n\n    // Position update\n    position += velocity * t;\n\n    // Second half-acceleration application\n    velocity += 0.5 * totalAcceleration * t;\n    \n    // Friction\n    velocity = velocity * pow(1. - friction, t);\n\n    fragColor = vec4(position, velocity);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n/*\nThis ShaderToy project demonstrates a particle simulation\nunder the influence of gravitational forces from four point\nsources. Each point has its own gravitational field and is\nrepresented by a distinct color. When you start the\nsimulation, each particle begins with an initial velocity\nwhich can be modified through the 'common file'. The initial\nposition of each particle is the pixel position. Over time\nas the particle moves, the origial pixel is showing the\ncolor of the nearest gravity point.\nSee:\nhttps://www.youtube.com/watch?v=3jJ51bj1jTM&ab_channel=prossello\nFor a better understanding of how this works. This\nsimulation was mostly inspired by this video.\n\n\nTo interact with the simulation:\n\n    Press the 'R' key to reset the simulation. When reset,\n    each particle will be set back to its original position\n    with the initial velocity.\n    \n    Press and hold the 'T' key to toggle between different\n    visualization modes. One mode renders the gravity points\n    and specific particles as colored discs, while the other\n    mode colors the particles based on a weighted average of\n    the colors of the nearest gravity points.\n\nCustomizing the simulation:\n\nIn the 'common file', several constants and structures allow\nyou to customize the simulation to your needs.\n\n    'G': The gravitational constant. Higher values will\n        result in stronger gravitational forces.\n    'friction': Determines how much the particles slow down\n        over time. A value of 0.0 means no friction, while a\n        value of 1.0 means maximum friction.\n    'initVel': The initial velocity of the particles when\n        the simulation is reset. You can experiment with\n        different values to see how they affect the\n        particles' motion.\n    'GravityPoint': A structure that defines the position\n        and color of a gravity point. The simulation\n        currently includes four gravity points, but you can\n        add or remove gravity points as needed.\n\nThe code for this project was largely written with the help\nof ChatGPT.\n\nThe simulation is optimized by making the particle move in\na faster pace when they are far from a gravitational\npoint. This is why their motion may seem somewhat uneven.\n\n*/\n\n\nconst float G = 1.0;  // Gravitational constant, change as needed\nconst float friction = 0.0; // 0.0 is no friction, 1. is total friction\nconst vec2 initVel = vec2(0.05, 0.02); // Initial velocity of the particles\n\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\nconst float RADIUS = 5.0;\n\nstruct GravityPoint {\n    vec2 position;\n    vec3 color;\n};\n\nGravityPoint gravityPoints[4] = GravityPoint[](\n    GravityPoint(vec2(220.0, 120.0), RED),\n    GravityPoint(vec2(380.0, 120.0), GREEN),\n    GravityPoint(vec2(220.0, 280.0), BLUE),\n    GravityPoint(vec2(380.0, 280.0), YELLOW)\n);\n\nconst int off = 0;\nconst int numRenderIndices = 6;\nivec2 renderIndices[numRenderIndices] = ivec2[](\n    ivec2(571, 175+0),\n    ivec2(571, 175+1),\n    ivec2(571, 175+2),\n    ivec2(571, 175+3),\n    ivec2(571, 175+4),\n    ivec2(571, 175+5)\n);\n\n// Input.\nconst int KEY_R  = 82;\nconst int KEY_T  = 84; // Added definition for 'T' key\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtsczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 93, 1658]], "test": "untested"}
{"id": "mllczn", "name": "Extruded Subdivided Triangles", "author": "Shane", "description": "Combining raymarching and cell-by-cell traversal techniques to produce extruded subdivided equilateral triangles in realtime.", "tags": ["raymarching", "grid", "triangle", "traversal", "extrude", "subdivide"], "likes": 90, "viewed": 1422, "published": 3, "date": "1690896668", "time_retrieved": "2024-07-30T17:41:24.413822", "image_code": "/*\n\n    Extruded Subdivided Triangles\n    -----------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n\n/*\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 1.5, coc = .7;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n*/\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x,6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the one's you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bokeh(sampler2D iCh, vec2 uv){\n\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 2.4, coc = .7;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .25);\n    //float ra = (smoothstep(.2, 1., length(uv - .5)));\n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 1.6;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.5); \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        ////////\n        /*\n        // Polygons, if desired. Comment out the line above and comment in\n        // the \"rot2\" formula above, if using it.\n        const float N = 6.;\n        float ra = rnd2.y;\n        float a = (floor(ra*N) + .5)*6.2831859/N;\n        vec2 offs  = mix(rot2(a)*vec2(0, 1), rot2(a + 6.2831859/N)*vec2(0, 1), fract(ra*N));\n        offs *= 6.*sqrt(rnd2.x);\n        */\n        ////////\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.5);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        vec4 bokeh = pow(col, vec4(4));\n\t\ttot += bokeh*col*col;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field.\n    vec4 colOrig = texture(iCh, uv);\n    // Not entirely correct, but no one will notice here. :)\n\treturn mix(colOrig, colOrig*.25 + tot/div*4., ra);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    vec4 col = bokeh(iChannel0, uv);\n\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Extruded Subdivided Triangles\n    -----------------------------\n    \n    Combining raymarching and cell-by-cell prism boundary techniques\n    provides the opportunity to create some grid structures that would\n    normally be considered prohibitively expensive. This is a subdivided\n    triangle prism grid, and it'd be near impossible to raymarch one \n    in realtime using the usual neighboring cell techniques.\n    \n    To be fair, it's kind of expensive doing it this way too, so \n    apologies to those with slower systems. Having said that, a decent\n    machine could run this pretty easily -- Mine can push this out in\n    fullscreen without too much trouble.\n    \n    Anyway, I posted this just to get one of these on the board and to\n    show that raymarching with cell boundary restrictions can work on\n    non rectangular polygon grids as well. The work is a little rushed,\n    but I'll look into improving the sudivision routine later.\n\n\n\n    Similar examples:\n    \n    // This is a cell-by-cell traversal of subdivided equilateral \n    // triangles. Like all of Abje's stuff, it's understated,\n    // underrated and cleverly written. On the surface, his subdivision \n    // routine seems to be faster than the one I hacked together, so I \n    // might take a look at it later.\n    recursive triangles - abje\n    https://www.shadertoy.com/view/3scyR2\n\n    // A 2D Truchet subdivided triangle grid example.\n\tMultiscale Triangle Truchet - Shane\n    https://www.shadertoy.com/view/dllyD7\n\n*/\n\n\n// Maximum ray distance.\n#define FAR 20.\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831853))*43758.5453); \n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear \n    // space (squaring is a rough approximation) prior to working with them... or \n    // something like that. :) Once the final color value is gamma corrected, you \n    // should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n/*\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n*/\n\n// Height map value, which is just the pixel's greyscale value.\n//float hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\nfloat hm(vec2 p){\n\n    float rnd = hash21(p + .22);\n    rnd = smoothstep(.84, .94, sin(6.2831*rnd + iTime/2.));\n    float sn = dot(sin(p - cos(p.yx*1.25)*3.14159), vec2(.25)) + .5;\n    //float sn = dot(getTex(iChannel0, p/4.), vec3(.299, .587, .114)); \n    return mix(sn, rnd, .2) + .05;\n}\n\n\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n   \n    p.y = p.y + r/k; \n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n   \n    /*   \n    const float k = sqrt(3.0);\n    p.y = abs(p.y) - r; // This one has been reversed.\n    p.x = p.x + r/k;\n    if( p.y + k*p.x>0.) p = vec2(-k*p.y - p.x, p.y - k*p.x)/2.0;\n    p.y -= clamp( p.y, -2.0, 0.0 );\n    return -length(p)*sign(p.x);\n    */  \n}\n\n\n\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /* \n    // Slight rounding. A little nicer, but slower.\n    const float sf = .01;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n     \n}\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n\n// Number of possible subdivisions. Larger numbers will work,\n// but will slow your machine down. This example is designed to\n// work with numbers 0 to 2. For 3 and 4, etc, you'll need to change\n// the triangle scale variable below.\n#define DIV_NUM 2\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = .8;\n\n// Rectangle scale.\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n\nfloat gTri;\n\n// Triangle routine, with additinal subdivision. It returns the \n// local tringle coordinates, the vertice IDs and vertices.\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n   \n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n  \n    // Centering at the zero point.\n    vec2 ctr = (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n    vec2 tID = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n    \n    \n    /////////////////////////////\n    #if DIV_NUM > 0\n    \n    // The random triangle subdivsion addition. I put this together pretty\n    // quickly, so there'd probably be better ways to do it. By the way, if\n    // you know of ways to improve the following, feel free to let me know.\n    for(int j = 0; j<DIV_NUM; j++){\n    \n        // Randomly subdivide.\n        if(hash21(tID + float(j + 6)/32.)<.35){\n\n            // Subdividing an equilateral triangle into four smaller \n            // equilateral ones. Use the \"GRID\" define and refer to the \n            // resultant imagery, if you're not sure.\n\n            mat3x2 mid, midID; // Midpoints.\n            vec3 dl; // Divding lines.\n\n            for(int i = 0; i<3; i++){\n                int ip1 = (i + 1)%3;\n                mid[i] = mix(v[i], v[ip1], .5); // Mid points.\n                midID[i] = mix(vID[i], vID[ip1], .5); // Mid point IDs.\n                // Divinding lines -- separating  the midpoints.            \n                dl[i] = distLineS(p, mid[i], mix(v[ip1], v[(i + 2)%3], .5));  \n            }\n\n            // Choosing which of the four new triangles you're in. The top\n            // triangle is above the first midpoint dividing line, the\n            // bottom right is to the right of the next diving line and the\n            // bottom left is to the left of the third one. If you're not in\n            // any of those triangles, then you much be in the middle one...\n            // By the way, if you know of better, faster, logic to subdivide\n            // a triangle into four smaller ones, feel free to let me know. :)\n            //\n            if(dl[0]<0.){ // Top.   \n                v[0] = mid[0]; vID[0] = midID[0];\n                v[2] = mid[1]; vID[2] = midID[1];        \n            }\n            else if(dl[1]<0.){ // Bottom right.   \n                v[1] = mid[1]; vID[1] = midID[1];\n                v[0] = mid[2]; vID[1] = midID[2];        \n            }\n            else if(dl[2]<0.){ // Bottom left.   \n                v[2] = mid[2]; vID[2] = midID[2];\n                v[1] = mid[0]; vID[1] = midID[0];        \n            }  \n            else { // Center.\n               v[0] = mid[0]; vID[0] = midID[0];\n               v[1] = mid[1]; vID[1] = midID[1];\n               v[2] = mid[2]; vID[2] = midID[2];  \n               gTri = -gTri;\n            }\n\n            // Triangle center coordinate.\n            ctr = (v[0] + v[1] + v[2])/3.;\n            // Centering the coordinate system -- vec2(0) is the triangle center.\n            p -= ctr;\n            v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n\n             // Centered ID, taking the inflation factor of three into account.\n            ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n            tID += ctrID;   \n            // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n            vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n        }\n    }\n    \n    #endif\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, tID);\n}\n\nvec2 gTriID;\nmat3x2 gVert, gVertID;\nvec2 gP;\n\n// The subdivided triangle routine.\nfloat tr(vec2 p){\n    \n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    mat3x2 v, vID;\n    vec4 p4 = getTriVerts(p, vID, v);\n    vec2 triID = p4.zw;\n    gTriID = p4.zw;\n    \n    // Setting some globals.\n    gVert = v;\n    gVertID = vID;\n    gP = p4.xy;\n    \n    \n    // Grid triangles. Some are upside down.\n    float ew = .01;\n    vec2 q = p4.xy*vec2(1, gTri); // Equivalent to the line above.\n    \n    float rad = length(v[0]); // 2D object radius.\n    float d2D = getTri(q, (rad - ew - rad*.15*2.)*.8660254) - rad*.15; // Triangle.\n    //float d2D = length(q) - (rad*.5 - .001); // Cylinders.\n    \n    // Randomly bore out some of the triangle centers.\n    if(hash21(gTriID + .093)<.5) d2D = max(d2D, -(d2D + .3*sqrt(length(v[0]))));\n\n    // Return the 2D field.\n    return d2D;\n\n\n}\n\n\n\n// Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   //return max(dot(p - ro, n), 0.)/max(dot(rd, n), 1e-8);\n   float dn = dot(rd, n);\n   return dn>0.? dot(p - ro, n)/dn : 1e8;   \n   //return dn>0.? max(dot(p - ro, n), 0.)/dn : 1e8;   \n\n} \n\nvec3 gRd; // Global ray variable.\nfloat gCD; // Global cell boundary distance.\n\n \n// The scene's distance function: There'd be faster ways to do this, but it's\n// more readable this way. Plus, this  is a pretty simple scene, so it's \n// efficient enough.\nfloat m(vec3 p){\n    \n    \n    // 2D triangle distance -- for the extrusion cross section.\n    float d2D = tr(p.xy);\n    \n    // Back plane.\n    float fl = -p.z;\n\n    \n    // Extrude the 2D Truchet object along the Z-plane. Note that this is a cheap\n    // hack. However, in this case, it doesn't make much of a visual difference.\n    vec2 gTriV = unskewXY(gTriID*rect/3., sk);\n    float h = hm(gTriV);\n    // Proper extrusion formula for comparisson.\n    float obj = opExtrusion(d2D, p.z + h/2., h/2.);\n    \n   \n    // Adding the 2D field to angle the tops a bit.\n    obj -= max(-(d2D + .02), .0)*.1;\n    //obj -= clamp(-(d2D + .02), .0, .08)*.15;\n    //obj += smoothstep(0., .5, sin(d2D*80.))*.002;\n    //obj += smoothstep(0., .5, sin((p.z - h)*60.))*.002;\n    \n    \n    ///////////\n    // Ray to triangle prism wall distances.\n    vec3 rC;\n    rC.x = rayLine(gP.xy, gRd.xy, gVert[0], \n                   normalize(gVert[1] - gVert[0]).yx*vec2(1, -1));\n    rC.y = rayLine(gP.xy, gRd.xy, gVert[1], \n                   normalize(gVert[2] - gVert[1]).yx*vec2(1, -1));\n    rC.z = rayLine(gP.xy, gRd.xy, gVert[2], \n                   normalize(gVert[0] - gVert[2]).yx*vec2(1, -1));\n    /* \n    // Same thing, but using absolute coordinates.\n    rC.x = rayLine(oP.xy, gRd.xy, gTriV + gVert[0], \n                   normalize(gVert[1] - gVert[0]).yx*vec2(1, -1));\n    rC.y = rayLine(oP.xy, gRd.xy, gTriV + gVert[1], \n                   normalize(gVert[2] - gVert[1]).yx*vec2(1, -1));\n    rC.z = rayLine(oP.xy, gRd.xy, gTriV + gVert[2], \n                   normalize(gVert[0] - gVert[2]).yx*vec2(1, -1));\n    */\n\n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... or something like that.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    \n    \n    ///////////\n    \n   \n    // Object ID.\n    objID = fl<obj? 0 : 1 ;\n    \n    // Minimum distance for the scene.\n    return min(fl, obj);\n    \n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash21(r.xy*57. + fract(iTime + r.z))*.5;\n    \n    gRd = rd; // Set the global ray  direction varible.\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on \n        // accuracy, as \"t\" increases. It's a cheap trick that works in most \n        // situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        // Restrict the maximum ray distance to the prism wall boundaries.\n        t += min(d, gCD); \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, \n// or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale \n    // texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks \n    // to EvilRyu for reminding me why we perform this step. It's been a while, but I \n    // vaguely recall that it's some kind of orthogonal space fix using the Gram-Schmidt \n    // process. However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer, but not always affordable for slower machines.\n    const int iter = 32; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<iter; i++){\n\n        float d = m(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // IQ's subtle refinement.\n        t += clamp(min(d, gCD), .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.2/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n  \n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Aspect correct coordinates. Only one line necessary.\n    u = (u - iResolution.xy*.5)/iResolution.y;    \n    \n    // Unit direction vector, camera origin and light position.\n    vec3 r = normalize(vec3(u, 1)), o = vec3(iTime/4., iTime/8., -3.25),\n         l = o + vec3(1, 2.5, 1);\n    \n    // Rotating the camera about the XY plane.\n    r.yz = rot2(.35)*r.yz;\n    r.xz = rot2(-cos(iTime*3.14159/32.)/16.)*r.xz;\n    r.xy = rot2(sin(iTime*3.14159/32.)/16. + .28)*r.xy; \n    \n    // Rough fish-eye lens.\n    r = normalize(vec3(r.xy, sqrt(max(r.z*r.z - dot(r.xy, r.xy)*.15, 0.))));\n  \n    \n    // Raymarch to the scene.\n    float t = trace(o, r);\n \n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int gObjID = objID;\n    \n    \n    // Initialize the scene color to zero.\n    c = vec4(0);\n    \n    \n    if(t<FAR){\n    \n        // Very basic lighting.\n        // Hit point and normal.\n        vec3 p = o + r*t, n = nr(p); \n        \n        // Texture base bump mapping.\n        // Slightly better, but I thought we could save the cycles.\n        // If using it, uncomment the \"texBump\" function.\n        //n = texBump(iChannel1, p, n, .003);///(1. + t/FAR)\n        \n         // Basic point lighting.   \n        vec3 ld = l - p;\n        float lDist = length(ld);\n        ld /= lDist; // Light direction vector.\n        float at = 1.5/(1. + lDist*.05); // Attenuation.\n\n        // Very, very cheap shadows -- Not used here.\n        //float sh = min(min(m(p + ld*.08), m(p + ld*.16)), \n        //           min(m(p + ld*.24), m(p + ld*.32)))/.08*1.5;\n        //sh = clamp(sh, 0., 1.);\n        float sh = softShadow(p, l, n, 8.); // Shadows.\n        float ao = calcAO(p, n); // Ambient occlusion.\n\n\n        // UV texture coordinate holder.\n        vec2 uv = p.xy;\n\n\n        // Returns the local coordinates (centered on zero), cellID, the \n        // triangle vertex ID and relative coordinates.\n        mat3x2 v, vID;\n\n\n        // Triangle face distace -- Used to render borders, etc.\n        float d = tr(p.xy);\n\n        /*\n        // Subtle pattern lines for a bit of texture.\n        #ifdef LINES\n        float lSc = 30.;\n        vec2 rUV = rot2(-3.14159/3.)*uv;\n        float pat = (abs(fract(rUV.x*lSc - .5) - .5) - .125)/lSc;\n        #else\n        float pat = 1e5;\n        #endif     \n        */\n\n        // Object color.\n        vec4 oCol;\n\n\n        // Use whatever logic to color the individual scene components. I made it\n        // all up as I went along, but things like edges, textured line patterns,\n        // etc, seem to look OK.\n        //\n        if(gObjID == 1){\n        \n            // Extruded subdivided triangle height.            \n            vec2 gTriV = unskewXY(gTriID*rect/3., sk);\n            float h = hm(gTriV); \n\n         \n            // Metallic texturing.\n            vec4 tx = tex3D(iChannel1, p/2., n).xyzx;\n             \n            // Two colors, used for decorating the prisms.\n            vec4 col1 = tx*(tx*2. + .1)/2.;\n            vec4 col2 = tx/2.;\n\n \n            float bw = .05; // Side band width.\n            float ew = .02; // Dark edge line width.\n            float sf = .007;//3./iResolution.y;\n            oCol = col2*vec4(1, .6, .38, 0)/2.;\n            oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., sf, max(d, (p.z + h - bw))));\n         \n            \n \n            // Darken alternate checkers on the face only.\n            //if(gTri>0.) col1 *= vec4(1, .6, .4, 0);\n            \n            // Giving the triangle faces some subtle random gold hints.\n            vec4 fCol = mix(vec4(1), vec4(1, .7, .4, 0), hash21(gTriV + .08)*.5 + .1);\n            col1 *= fCol;\n            col2 *= fCol*.5 + .5;\n             \n            // Screen gradient... Not for this example. :)\n            //col1 *= mix(vec4(1, .7, .4, 0), vec4(1, .7, .4, 0).zyxw, -u.y + .5);\n            \n            // Fake pearlescence.\n            vec4 pearl = mix(vec4(1, .6, .2, 0), vec4(1, .6, .3, 0).zyxw,\n                                clamp(-n.y*8. + .5, 0., 1.))*2. + .1;\n            col1 *= pearl;\n            col2 *= pearl; \n            \n            // Green falloff.\n            col1 += col1*vec4(.6, 1, .2, 0)/2.*(1. - smoothstep(0., sf*16., (d + .2)));\n            // Line pattern. Uncomment the line pattern block above.\n            //col1 = mix(col1*1.25, col1*.7, 1. - smoothstep(0., sf, pat));\n            \n            // Applying the top face color and edging.\n            oCol = mix(oCol, col2*vec4(1, .77, .5, 0), \n                       1. - smoothstep(0., sf, max(d, (p.z + h - bw + ew))));\n            oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., sf, max(d, (p.z + h ))));\n            \n            \n            // Apply the colored face to the Truchet, but leave enough room\n            // for an edge.\n            oCol = mix(oCol, col2*vec4(1, .8, .6, 0), 1. - smoothstep(0., sf, d + ew));\n            oCol = mix(oCol, oCol*.05, 1. - smoothstep(0., sf, d + ew + .02));\n            oCol = mix(oCol, col1, 1. - smoothstep(0., sf, d + ew*2. + .02));\n\n\n        }\n        else {\n            \n            // The floor. Mostly hidden.\n            oCol = vec4(.02); \n        }\n\n\n\n       \n\n        // Diffuse and specular.\n        float df = pow(max(dot(n, ld), 0.), 2. + 8.*oCol.x)*2.; // Diffuse.\n        float sp = pow(max(dot(reflect(r, n), ld), 0.), 16.); // Specular.\n\n\n        // Specular reflection.\n        vec3 hv = normalize(ld - r); // Half vector.\n        vec3 ref = reflect(r, n); // Surface reflection.\n        vec4 refTx = texture(iChannel2, -ref.yzx); refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, n), 0.), 5.); // Specular reflection.\n        float rf = mix(.5, 1., 1. - smoothstep(0., .01, d + .02));\n        rf *= (gObjID == 0)? .1 : 1.;\n        oCol += oCol*spRef*refTx.zyxw*rf*24.;\n        \n\n\n        // Apply the lighting and shading. \n        c = oCol*(df*sh + sp*sh*8. + .3)*at*ao;\n    \n    \n    }\n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    //c = mix(c, vec4(0), smoothstep(.25, .9, t/FAR));\n  \n   \n \n    // Rough gamma correction.\n    c = vec4(max(c.xyz, 0.), t);  \n\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mllczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1851, 2027, 2050, 2050, 2100], [2102, 2530, 2565, 2752, 5652], [5654, 5654, 5708, 5736, 6144]], "test": "untested"}
{"id": "dllyD7", "name": "Multiscale Triangle Truchet", "author": "Shane", "description": "Rendering a multiscale triangle Truchet pattern on a subdivided triangle grid.", "tags": ["grid", "triangle", "simplex", "truchet", "polar", "multiscale", "weave"], "likes": 60, "viewed": 562, "published": 3, "date": "1690896230", "time_retrieved": "2024-07-30T17:41:25.431102", "image_code": "/*\n\n    Multiscale Triangle Truchet\n    ---------------------------\n    \n    I put this together ages ago, but took a while to pretty it up\n    enough to deem it worth releasing. Anyway, if you've ever seen \n    one of these patterns on stock image sites, or wherever, and \n    wondered how they were made, I hope this helps.\n    \n    Construction is reasonably straight forward: Produce a triangle \n    grid, subdivide it, create separate concentric circle arcs around \n    each triangle cell vertex, then render each of them in random \n    order -- A quick way to do that is to randomly rotate the local \n    triangle cell coordinates then render the arcs in their original\n    order.\n    \n    If you investigate these patterns on the net, you'll see that \n    they're all flat in appearance, which look pretty cool as well, \n    however, to differentiate this example from others, I rendered \n    it in a faux 3D style.\n    \n    \n    Other examples:\n    \n    // A simpler to understand square version, for anyone interested.\n    Subdivided Grid Truchet Pattern - Shane\n    https://www.shadertoy.com/view/NdKfRD\n    \n    // An extruded simplex weave. Eventually, I'll convert this\n    // example to the 3D environment.\n    Simplex Weave - Shane\n    https://www.shadertoy.com/view/WdlSWl\n    \n    // There aren't a great deal of subdivided triangle grid examples\n    // on here, but here's a simple one.\n    tritree 2 - FabriceNeyret2 \n    https://www.shadertoy.com/view/MlsBzH\n\n\n*/\n\n// The subdivided triangle grid. Oddly enough, viewing the grid can help\n// facilate a better understanding of how a grid pattern is formed. :)\n//#define GRID \n\n// Number of possible subdivisions. Larger numbers will work,\n// but will slow your machine down. This example is designed to\n// work with numbers 0 to 2. For 3 and 4, etc, you'll need to change\n// the triangle scale variable below.\n#define DIV_NUM 2\n// Triangle scale.\n#define triSc 1./3.\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n   \n    p.y = p.y + r/k; \n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n   \n    /*   \n    const float k = sqrt(3.0);\n    p.y = abs(p.y) - r; // This one has been reversed.\n    p.x = p.x + r/k;\n    if( p.y + k*p.x>0.) p = vec2(-k*p.y - p.x, p.y - k*p.x)/2.0;\n    p.y -= clamp( p.y, -2.0, 0.0 );\n    return -length(p)*sign(p.x);\n    */  \n}\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = triSc;\n\n// Rectangle scale.\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale;\n\n// Triangle ID.\nfloat gTri;\n\n// Number of random triangle subdivisions.\nfloat subSc = 0.;\n\n// Triangle routine, with additinal subdivision. It returns the \n// local tringle coordinates, the vertice IDs and vertices.\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n   \n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n  \n    // Centering at the zero point.\n    vec2 ctr = (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n    vec2 tID = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n    \n    // A number to represent the number of subdivisions a triangle\n    // has undergone.\n    subSc = 0.;\n    \n    /////////////////////////////\n    #if DIV_NUM > 0\n    \n    // The random triangle subdivsion addition. I put this together pretty\n    // quickly, so there'd probably be better ways to do it. By the way, if\n    // you know of ways to improve the following, feel free to let me know.\n    for(int j = 0; j<DIV_NUM; j++){\n    \n        // Randomly subdivide.\n        if(hash21(tID + float(j + 1)/128.)<.4){\n            \n            // Increase the subdivision number.\n            subSc++;\n\n            // Subdividing an equilateral triangle into four smaller \n            // equilateral ones. Use the \"GRID\" define and refer to the \n            // resultant imagery, if you're not sure.\n\n            mat3x2 mid, midID; // Midpoints.\n            vec3 dl; // Divding lines.\n\n            for(int i = 0; i<3; i++){\n                int ip1 = (i + 1)%3;\n                mid[i] = mix(v[i], v[ip1], .5); // Mid points.\n                midID[i] = mix(vID[i], vID[ip1], .5); // Mid point IDs.\n                // Divinding lines -- separating  the midpoints.            \n                dl[i] = distLineS(p, mid[i], mix(v[ip1], v[(i + 2)%3], .5));  \n            }\n\n            // Choosing which of the four new triangles you're in. The top\n            // triangle is above the first midpoint dividing line, the\n            // bottom right is to the right of the next diving line and the\n            // bottom left is to the left of the third one. If you're not in\n            // any of those triangles, then you much be in the middle one...\n            // By the way, if you know of better, faster, logic to subdivide\n            // a triangle into four smaller ones, feel free to let me know. :)\n            //\n            if(dl[0]<0.){ // Top.   \n                v[0] = mid[0]; vID[0] = midID[0];\n                v[2] = mid[1]; vID[2] = midID[1];        \n            }\n            else if(dl[1]<0.){ // Bottom right.   \n                v[1] = mid[1]; vID[1] = midID[1];\n                v[0] = mid[2]; vID[1] = midID[2];        \n            }\n            else if(dl[2]<0.){ // Bottom left.   \n                v[2] = mid[2]; vID[2] = midID[2];\n                v[1] = mid[0]; vID[1] = midID[0];        \n            }  \n            else { // Center.\n               v[0] = mid[0]; vID[0] = midID[0];\n               v[1] = mid[1]; vID[1] = midID[1];\n               v[2] = mid[2]; vID[2] = midID[2];  \n               gTri = -gTri;\n            }\n\n            // Triangle center coordinate.\n            ctr = (v[0] + v[1] + v[2])/3.;\n            // Centering the coordinate system -- vec2(0) is the triangle center.\n            p -= ctr;\n            v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n\n             // Centered ID, taking the inflation factor of three into account.\n            ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/3.;\n            tID += ctrID;   \n            // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n            vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n        }\n    }\n    \n    #endif\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, tID);\n}\n\n//////////\n// Rendering a colored distance field onto a background. I'd argue that\n// this one simple function is the key to rendering most vector styled\n// 2D Photoshop effects onto a canvas. I've explained it in more detail\n// before. Here are the key components:\n//\n// bg: background color, fg: foreground color, sf: smoothing factor,\n// d: 2D distance field value, tr: transparency (0 - 1).\nvec3 blend(vec3 bg, vec3 fg, float sf, float d, float tr){\n\n     return mix(bg, fg, (1. - smoothstep(0., sf, d))*tr);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Global scaling and translation.\n    float gSc = 1.;\n    // Smoothing factor, based on global scaling.\n    float sf = gSc/iResolution.y;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north easterly (top right) direction. \n    vec2 p = rot2(-3.14159/12.)*uv*gSc - vec2(-.57735, -1)*iTime/32.;\n    \n \n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    mat3x2 v, vID;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec4 p4 = getTriVerts(p, vID, v);\n    p = p4.xy;\n    vec2 triID = p4.zw;\n    float tri = gTri;\n    \n    float sL = length(v[0] - v[1]);\n    \n    // Grid triangles. Some are upside down.\n    //vec2 q = tri<0.? p*vec2(1, -1) : p;\n    vec2 q = p*vec2(1, tri); // Equivalent to the line above.\n    float tr = getTri(q, length(v[0])*.8660254);\n\n   \n    // Nearest vertex ID.\n    float vert = 1e5;\n    vec3 arc, ang; // Three vertex arcs and corresponding angles.\n   \n    \n    // Random value based on the overall triangle ID.\n    float rnd = hash21(triID + .1);\n    \n    // Random rotation, in incrents of 120 degrees to maintain symmetry.\n    p = rot2(floor(rnd*72.)*6.2831853/3.)*p;\n    \n    \n\n    // Nearest vertex, vertex-arc and angle (subtended from each vertex) calculations.\n    for(int i = 0; i<3; i++){\n    \n        // Current vertex. By the way, you could change this to a hexagon or\n        // dodecahedron metric, and multiply the side length variable, \"sL\" by\n        // \"sqrt(3)/2\" to produce a straight line pattern.\n        float vDist = length(p - v[i]);\n        \n        // Nearest overall vertex.\n        vert = min(vert, vDist); \n        \n \n        // One of three arcs that loop around each vertex. This is still\n        // circle distance at this point, but the rest of the calculations \n        // are performed outside the loop (see below).\n        arc[i] = (vDist - sL*2./3.);\n       \n        // Angle of each pixel on each arc. As above, further calculations\n        // are performed outside the loop for speed.\n        vec2 vp = p - v[i];\n        ang[i] = atan(vp.y, vp.x);\n    }\n    \n\n    \n    // The concentric line number; It needs to be a factor of three. I've opted\n    // for a tightly bound pattern. Using something like \"6.\" will work, but due\n    // to the shading setup, changing the global triangle \"scale\" variable to \n    // something higher will look better.\n    const float lNum = 1.*3.; \n    // Side length factor that halves each time the triangle subdivides.\n    // Using: \"pow(2, a) = exp2(a)\" and \"exp2(a)/exp2(b) = exp2(a - b)\".\n    float sL0 = sL*exp2(subSc - float(DIV_NUM)); \n    float lW = sL0/lNum;// Concentric line width.\n    vec3 ln = abs(mod(arc + lW/2., lW) - lW/2.) - lW/4.; // Repeat lines.\n \n \n     \n    // Restricing the concentric line field to the vertex arc size.\n    ln = max(arc - lW/4., ln);\n    //ln -= lW/4.*.15; // Change the colored line width, if so desired.\n  \n        \n\n\n     // RENDERING.\n    \n    // Background, set to black.\n    vec3 col = vec3(0);\n    \n    // Resolution factor for shadow width -- It's a hack to make sure shadows\n    // have the same area influence at different resolutions. If you think it's\n    // confusing, you'll get no arguments from me. :)\n    float resF = iResolution.y/450.;\n    \n    // Using the angle (subtented to the arc vertex) to create some faux shading.\n    vec3 sh = -cos(ang*6.)*.5 + .5;\n    \n    // Rendering the three sets of double arcs.\n    for(int i = 0; i<3; i++){\n\n\n        // Concentric line color.\n        vec3 lnCol = mix(vec3(1, .6, .2), vec3(1, .1, .2), 1./(1. + sh[i]));\n        lnCol *= sh[i]*.35 + .65;\n \n        // White concentric line color, which some added shading.\n        vec3 lnCol2 = vec3(1)*((sh[i]*sh[i])*.4 + .6);\n        \n        // Just a hack to lighten the spokes around the vertices.\n        // It's not really necessary and not entirely accurate. \n        lnCol2 = blend(lnCol2, lnCol2 + .15, sf*2., vert - lW, 1. - sh[i]);      \n   \n   \n        // Rendering.\n        // Very subtle drop shadows, tapered by the shadow factor, which \n        // was a last minute hack to avoid triangle boundary issues. \n        col = blend(col, lnCol2/32.,  sf*6.*resF, arc[i] - lW/4., sqrt(sh[i]));\n        \n        // Two colored lines and dark edges.\n        col = blend(col, lnCol2, sf, arc[i] - lW/4. + .005, 1.); // Colored line.\n        //col = blend(col, vec3(0), sf*2.*resF, ln[i], sh); // Line shadows.\n        col = blend(col, vec3(0), sf, ln[i], 1.); // Edges.\n        col = blend(col, lnCol, sf, ln[i] + .005, 1.); // White lines.   \n   \n\n    } \n    \n    \n    #ifdef GRID\n    // Grid boundaries.\n    col = blend(col, vec3(0), sf, abs(tr) - .004, 1.);\n    col = blend(col, vec3(1, .6, .2)*1.5, sf, abs(tr) - .0005, 1.);\n    #endif\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./8.));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dllyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1939, 1972, 1994, 1994, 2052], [2055, 2083, 2104, 2104, 2167], [2170, 2224, 2264, 2264, 2328], [2331, 2424, 2460, 2460, 2938], [3162, 3225, 3253, 3253, 3283], [3285, 3350, 3380, 3380, 3419], [3793, 3918, 3980, 4023, 9240], [9242, 9637, 9695, 9695, 9756], [9758, 9758, 9812, 9856, 15116]], "test": "untested"}
{"id": "dlXyzB", "name": "Cellular Sculpture 2", "author": "dr2", "description": "3D cellular automaton - updated for larger (8x) grid", "tags": ["life", "cell", "automaton"], "likes": 23, "viewed": 260, "published": 3, "date": "1690883134", "time_retrieved": "2024-07-30T17:41:26.374580", "image_code": "// \"Cellular Sculpture 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n 3D cellular automaton related to the game of Life. Cell alive if 13 or 15+\n live neighbors (out of 27, including itself), otherwise dead.\n Use mouse to halt process and rotate/zoom; click in ring to restart\n (else automatic).\n Grid cells are packed 8 per texel; grid size limited by texture (window) size.\n Cell-marching from \"Mandelcity\".\n Step counter and live cell count (/1000) shown.\n (Note 1: only single compute buffer used here; could use more for speedup.)\n (Note 2: changes to rules and initial state are currently exercises for\n the reader. :)\n*/\n\n#define AA   1   // optional antialiasing\n\n#define BIG  1   // (same in all shaders)\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec3 HsvToRgb (vec3 c);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (int idVar);\nfloat Fbm2 (vec2 p);\n\nvec3 gCel, ltDir, gsv;\nfloat dstFar, tCur, gSizeH;\nint nFrame;\nconst float pi = 3.1415927;\n\nbool Occ (vec3 g)\n{\n#if BIG\n  return (((int (Loadv4 (int (dot (floor (g / 2.), gsv))).x) >>\n     int (dot (mod (g, 2.), vec3 (1., 2., 4.)))) & 1) != 0);\n#else\n  return (int (Loadv4 (int (dot (g, gsv))).x) != 0);\n#endif\n}\n\nvec4 CellRay (vec3 ro, vec3 rd)\n{\n  vec3 ig, fcHit, gb, s, cp, rdi;\n  float g1, g2;\n  int stepLim;\n  bool occ;\n  rdi = 1. / rd;\n  gCel = floor (ro);\n  gb = (max (sign (rd), vec3 (0.)) - ro) * rdi;\n  occ = false;\n  stepLim = int (1.9 * gSizeH);\n  for (int i = VAR_ZERO; i < stepLim; i ++) {\n    s = gb + gCel * rdi;\n    cp = step (s, s.yzx);\n    fcHit = cp * (1. - cp.zxy);\n    gCel += sign (rd) * fcHit;\n    ig = gCel + 0.5 * gSizeH;\n    g1 = Minv3 (ig);\n    g2 = Maxv3 (ig);\n    if (g1 < -1. || g2 > gSizeH) break;\n    if (g1 >= 0. && g2 < gSizeH) {\n      occ = Occ (ig);\n      if (occ) break;\n    }\n  }\n  return (occ) ? vec4 (dot (s - abs (rdi), fcHit), fcHit) : vec4 (dstFar, 0., 0., 0.);\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dn, df;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nvec2 BlkHitQ (vec3 ro, vec3 rd, vec3 p, float bSize)\n{\n  vec3 v, tm, u, fcBlk;\n  v = (ro - p) / rd;\n  tm = - bSize / abs (rd) - v;\n  fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = (v + Maxv3 (tm)) * rd;\n  return vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col, skCol;\n  vec2 u;\n  float el, f;\n  skCol = vec3 (0.1, 0.15, 0.6);\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 32.;\n  col = mix (skCol, vec3 (0.9, 0.9, 0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, skCol, smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return 0.9 * col;\n}\n\n#define COL 1\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 dc4;\n  vec3 col, vn, cm;\n  float dBlk, sh, nDotL, b;\n  rd += 1e-5;\n  dBlk = BlkHit (ro, rd, vec3 (0.5 * gSizeH + 1.));\n#if COL\n  col = BgCol (rd);\n#else\n  col = vec3 (0.);\n#endif\n  if (dBlk < dstFar) {\n    ro += dBlk * rd;\n    dc4 = CellRay (ro, rd);\n    if (dc4.x < dstFar) {\n      cm = gCel + 0.5;\n      ro += dc4.x * rd;\n      vn = - dc4.yzw * sign (rd);\n      b = Maxv2 (abs (BlkHitQ (ro, rd, cm, 0.5)));\n#if COL\n      col = HsvToRgb (vec3 (1. - 0.8 * fract (length (cm) / (0.5 * gSizeH)), 0.8, 1.));\n      //col = vec3 (1.); // b/w\n      col *= mix (1., 0.7, step (0.4, b));\n      sh = 0.5 + 0.5 * smoothstep (0.1, 0.6, CellRay (ro + 0.01 * vn, ltDir).x / gSizeH);\n      nDotL = max (dot (ltDir, vn), 0.);\n      col = col * (0.3 + 0.2 * max (dot (- ltDir, vn), 0.) + 0.7 * sh * nDotL * nDotL) +\n         0.2 * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n#else\n      col = mix (col, vec3 (1.), step (0.4, b));\n      col *= 0.3 + 0.7 * max (- dot (vn, rd), 0.);\n#endif\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, wgBxC;\n  vec2 canvas, uv;\n  float asp, dVu, sr, el, az, zmFac, gSize, nStep;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  nFrame = iFrame;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n  nStep = Loadv4 (0).z;\n  mPtr.xy = Loadv4 (1).zw;\n  mPtr.z = Loadv4 (2).z;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) > wgBxC.z) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.01 * tCur;\n  }\n  zmFac = 4.5 - 9. * (cos (el) - 1.);\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  az -= 0.3 * pi;\n  el -= 0.1 * pi;\n  vuMat = StdVuMat (el, az);\n  gSize = Loadv4 (0).w;\n#if BIG\n  gSizeH = 2. * gSize;\n#else\n  gSizeH = gSize;\n#endif\n  gsv = vec3 (1., gSize, gSize * gSize);\n  dVu = 3. * gSizeH;\n  ro = vuMat * vec3 (0., 0., - dVu);\n  dstFar = dVu + 2. * gSizeH + 3.;\n  ltDir = vuMat * normalize (vec3 (0.6, 1.1, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = mix (vec3 (1., 1., 0.7), col, smoothstep (2., 2.2,\n     abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y));\n  col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.45),\n     vec2 (0.06 * asp, 0.03), 4., floor (Loadv4 (1).y / 1000. + 0.5)));\n  if (true) col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.4),\n     vec2 (0.06 * asp, 0.03), 4., 10. * floor ((max (nStep, 0.) + 9.) / 10.)));\n  if (false) col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.35),\n     vec2 (0.06 * asp, 0.03), 4., gSizeH));\n  if (false) col = mix (col, vec3 (0.2), ShowInt (0.5 * uv - vec2 (0.47 * asp, - 0.3),\n     vec2 (0.06 * asp, 0.03), 4., txSize.x));\n  fragColor = vec4 (col, 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val + 0.01) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) + 0.5) / txSize);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Cellular Sculpture 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define BIG  1   // (same in all shaders)\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 gsv;\nfloat todCur, gSize, nStep;\nint nFrame;\n\nbool InOcc (vec3 g)\n{\n  return (fract (Hashfv3 (vec3 (1.11, 1.13, 1.17) * g + fract (todCur))) > 0.499);\n}\n\nfloat CInit (vec3 gCel)\n{\n  vec3 g;\n  int iv;\n  iv = 0;\n#if BIG\n  for (int k = 0; k < 8; k ++) {\n    g = gCel - 0.5 * gSize;\n    if (sqrt (length (g * g)) < 0.5 * gSize && InOcc (gCel)) iv += 1 << k;\n  }\n#else\n  g = gCel - 0.5 * gSize;\n  if (sqrt (length (g * g)) < 0.5 * gSize && InOcc (gCel)) iv = 1;\n#endif\n  return float (iv);\n}\n\nbool Rule (int ns)\n{\n  return (ns == 13 || ns >= 15);\n}\n\nbool Occ (vec3 g)\n{\n#if BIG\n  return (((int (Loadv4 (int (dot (floor (g / 2.), gsv))).x) >>\n     int (dot (mod (g, 2.), vec3 (1., 2., 4.)))) & 1) != 0);\n#else\n  return (int (Loadv4 (int (dot (g, gsv))).x) != 0);\n#endif\n}\n\nfloat CUpdate (vec3 gCel)\n{\n  int iv, ns;\n  iv = 0;\n#if BIG\n  vec3 ig;\n  for (int k = 0; k < 8; k ++) {\n    ig = 2. * gCel + mod (vec3 (k, k / 2, k / 4), 2.);\n    ns = 0;\n    for (int iz = -1; iz <= 1; iz ++) {\n      for (int iy = -1; iy <= 1; iy ++) {\n        for (int ix = -1; ix <= 1; ix ++) {\n           if (Occ (ig + vec3 (ix, iy, iz))) ++ ns;\n        }\n      }\n    }\n    if (Rule (ns)) iv += 1 << k;\n  }\n#else\n  ns = 0;\n  for (int iz = -1; iz <= 1; iz ++) {\n    for (int iy = -1; iy <= 1; iy ++) {\n      for (int ix = -1; ix <= 1; ix ++) {\n        if (Occ (gCel + vec3 (ix, iy, iz))) ++ ns;;\n      }\n    }\n  }\n  if (Rule (ns)) iv = 1;\n#endif\n  return float (iv);\n}\n\nfloat CCopy (vec3 gCel)\n{\n  return Loadv4 (int (dot (gCel, gsv))).x;\n}\n\nvoid CCount (vec3 gCel, inout float sv)\n{\n  int state, iv, nv;\n  state = int (mod (nStep, 10.));\n  nv = int (sv);\n  if (state == 1) {\n    if (gCel.x == 0.) {\n      nv = 0;\n      for (int ix = 0; ix < int (gSize); ix ++) {\n        iv = int (Loadv4 (int (dot (gCel + vec3 (ix, 0., 0.), gsv))).x);\n#if BIG\n        for (int k = 0; k < 8; k ++) {\n          if ((iv & (1 << k)) != 0) ++ nv;\n        }\n#else\n        nv += iv;\n#endif\n      }\n    }\n  } else if (state == 2) {\n    if (gCel.xy == vec2 (0.)) {\n      nv = 0;\n      for (int iy = 0; iy < int (gSize); iy ++) {\n        nv += int (Loadv4 (int (dot (gCel + vec3 (0., iy, 0.), gsv))).y);\n      }\n    }\n  } else if (state == 3) {\n    if (gCel == vec3 (1., 0., 0.)) {\n      nv = 0;\n      for (int iz = 0; iz < int (gSize); iz ++) {\n        nv += int (Loadv4 (int (dot (vec3 (0., 0., iz), gsv))).y);\n      }\n    }\n  }\n  sv = float (nv);\n}\n\n#define MAX_GRID  120  // (limit set by numerical precision)\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 gCel, wgBxC;\n  vec2 canvas, iFrag;\n  float v, sv, ip, nsi, frSkip, asp;\n  int pxId;\n  bool init, doStep;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  nFrame = iFrame;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  iFrag = floor (fragCoord);\n  ip = floor (iFrag.x + txSize.x * iFrag.y);\n  pxId = int (ip);\n  init = (nFrame <= 2);\n  gSize = min (floor (floor (pow (txSize.x * txSize.y, 1./3.)) / 2.) * 2., float (MAX_GRID));\n  if (! init  && gSize != Loadv4 (0).w) init = true;\n  if (ip >= gSize * gSize * gSize) discard;\n  frSkip = 2.;   // set = 1 for max speed, else slow down [(txSize.x <= 128.) ? 5. : 2.;]\n  doStep = (mPtr.z <= 0. && mod (float (nFrame), frSkip) == 0.);\n  asp = canvas.x / canvas.y;\n  wgBxC = vec3 (0.48 * asp, 0.46, 0.022);\n  gsv = vec3 (1., gSize, gSize * gSize);\n  gCel = mod (floor (vec3 (ip) / gsv), vec3 (gSize));\n  nStep = Loadv4 (0).z;\n  if (! init && (nStep > 30. * gSize || nStep > 40. && Loadv4 (1).y == 0.)) init = true;\n  mPtrP.z = Loadv4 (2).z;\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBxC.xy) < wgBxC.z) {\n      if (mPtrP.z <= 0.) init = true;\n    }\n  }\n  v = 0.;\n  if (init) nStep = -20.;\n  else if (doStep) ++ nStep;\n  if (Minv3 (gCel) > 0. && Maxv3 (gCel) < gSize - 1.) {\n    if (init) v = CInit (gCel);\n    else if (doStep && nStep > 0.) v = CUpdate (gCel);\n    else v = CCopy (gCel);\n  }\n  stDat = vec4 (v, Loadv4 (pxId).y, 0., 0.);\n  if      (pxId == 0) stDat.zw = vec2 (nStep, gSize);\n  else if (pxId == 1) stDat.zw = mPtr.xy;\n  else if (pxId == 2) stDat.z = mPtr.z;\n  if (doStep) CCount (gCel, stDat.y);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txSize.x), floor (fi / txSize.x)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dlXyzB.jpg", "access": "api", "license": "cc-by-nc-sa-2.0", "functions": [[1436, 1436, 1469, 1469, 2129], [2131, 2131, 2176, 2176, 2361], [2363, 2363, 2417, 2417, 2643], [2645, 2645, 2667, 2667, 3055], [3072, 3072, 3107, 3107, 4138], [4140, 4140, 4196, 4196, 6340], [6342, 6342, 6366, 6366, 6483], [6485, 6485, 6507, 6507, 6534], [6536, 6536, 6558, 6558, 6596], [6598, 6598, 6620, 6620, 6658], [6660, 6660, 6690, 6690, 6803], [6805, 6805, 6841, 6841, 7047], [7049, 7049, 7072, 7072, 7174], [7247, 7247, 7279, 7279, 7821], [7823, 7823, 7883, 7883, 8432], [8434, 8434, 8459, 8459, 8588], [8622, 8622, 8646, 8646, 8758], [8760, 8760, 8785, 8785, 8969], [8971, 8971, 8992, 8992, 9147]], "test": "untested"}
{"id": "clfyWr", "name": "Sekhmet", "author": "virne", "description": "Simple 2D skeletal animation with some distance field lines and noise to render a stick figure.\n\n", "tags": ["lines", "skeleton", "stickfigure", "skeletal"], "likes": 6, "viewed": 131, "published": 3, "date": "1690876438", "time_retrieved": "2024-07-30T17:41:27.138537", "image_code": "#define getuv (2.0*fragCoord-iResolution.xy)/iResolution.y\n#define _main void mainImage(out vec4 fragColor, in vec2 fragCoord )\n\n#define time iTime\n\n\n// Stolen code ------\n\nfloat udSegment( vec2 pos, vec2 a, vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = pos-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvec2 hash( vec2 pos ) // replace this by something better\n{\n\tpos = vec2( dot(pos,vec2(127.1,311.7)), dot(pos,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(pos)*43758.5453123);\n}\n\nfloat noise( vec2 pos )\n{\n    const float K1 = 0.366025; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( pos + (pos.x+pos.y)*K1 );\n    vec2  a = pos - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x);\n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// Stolen code ------\n\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\n\n\n_main\n{\n\tvec2 pos = getuv;\n\n\n  \n    \n    float posx = pos.x;\n\n    vec2 uv = pos;\n    \n    float bgWave = 0.4;\n    float disMul = 1.0;\n    float globalFade = 1.;\n    float it = time*4.;\n    float headTilt = it*0.5; // 4\n    float headTiltMul = 0.1;\n    vec2 offset = vec2(-0.2, (sin(pow(abs(sin(time*3.)), 3.0)))*0.05 + 0.05);\n    float scale = 1.0;\n\n    vec2 ds = vec2(sin(pos.y*1.6+pos.x*.3 + time*0.2), cos(pos.x*2.7+pos.y*1.3 + time*0.3));\n\n    \n    ds = ds*noise(pos*pos+ds);\n    \n    vec3 col;\n    \n  \n    const int verlen = 23;\n  \n    vec2 verts[verlen] = vec2[verlen](\n            \n            // Root / Neck\n            vec2(0, 0.5),  // 0\n            // Head top\n            vec2(0.1, 0.8), // 1\n            // Hair\n            vec2(-0.3, 0.3), vec2(-0.4, 0.5), vec2(-0.4, 0.4), // 2,3,4\n            // eye\n            vec2(0.1, 0.7), vec2(0.15, 0.68), // 5,6\n            // body bottom\n            vec2(0, -0.1), // 7\n            // left leg\n            vec2(0, -0.5), vec2(0, -0.9), // 8,9\n            // right leg\n            vec2(0, -0.5), vec2(0, -0.9), // 10,11\n            // left arm\n            vec2(-0.3, 0), vec2(-0.2, -0.3), // 12, 13\n            // right arm\n            vec2(0.3, 0), vec2(0.7, 0), // 14, 15\n            // staff\n            vec2(0.7, -0.7), vec2(0.7, 0.5), // 16, 17\n            // face\n            vec2(0.05, 0.75), vec2(0.2, 0.66), vec2(0.18, 0.6), vec2(0.1, 0.6),\n            // right hand\n            vec2(0.75, 0)\n            \n     \n    );\n        \n        \n    vec2 tverts[verlen];\n \n    const int linelen = (3+1+1+2+2+2+2+1+4+1)*2;\n \n    int lines[linelen] = int[linelen]( \n            // hair\n            1, 2, 1, 3, 1, 4,\n            // eye\n            5, 6,\n            // body bottom\n            0, 7, \n            // left leg\n            7, 8, 8, 9,\n            // right leg\n            7, 10, 10, 11,\n            // left arm\n            0, 12, 12, 13,\n            // right arm\n            0, 14, 14, 15,\n            // staff\n            17, 16,\n            // face\n            18, 19, 19, 20, 20, 21, 21, 0,\n            // right arm\n            15, 22\n            );\n            \n           \n            \n    float widths[linelen] = float[linelen]    \n    (\n            // hair\n            0.0, 0.5, 0.0, 0.5, 0.0, 0.5,\n            // eye\n            0.1, 0.,\n            // body bottom\n            0.3, -0.5, \n            // left leg\n            0.2, 0.5, -0.4, 0.2,\n            // right leg\n            0.2, 0.5, -0.4, 0.2,\n            // left arm\n            0.1, 0.15, 0.15, 0.1,\n            // right arm\n            0.1, 0.15, 0.15, 0.1,\n            // staff\n            -0.1, 0.1,\n            // face\n            0.05, 0.0, 0.0, -0.25, -0.05, 0.0, 0.0, 0.05,\n            // right arm\n            -0.1, 0.3\n    \n    );\n            \n    const int skellen = (1+3+2+1+2+2+2+2+2+4+1)*2;\n\n\n    int skel[skellen] = int[skellen](\n        // head\n        0, 1,\n        // hair\n        1,2,1,3,1,4,\n        // eye\n        1,5,5,6,\n        // body bottom\n        0, 7,\n        // left leg\n        7, 8, 8, 9,\n        // right leg\n        7, 10, 10, 11,\n        // left arm\n        0, 12, 12, 13,\n        // right arm\n        0, 14, 14, 15,\n        // staff\n        15, 16, 15, 17,\n        // face\n        1, 18, 1, 19, 1, 20, 1, 21,\n        // right arm\n        15, 22\n        );\n\n\n    // root 0\n    // head 1 -> 0\n\n\n    mat2 mats[skellen];\n\n    for (int i = 0; i < verts.length(); i++)\n        tverts[i] = verts[i];\n\n    for (int i = 0; i < skellen; i++)\n        mats[i] = mat2(1, 0, 0, 1);\n        \n    mats[0] = r2d(ds.x*0.1);\n   \n    mats[0][0] += sin(time)*0.2;\n    \n    // legs\n    mats[8] = r2d(cos(it)*0.3);\n    mats[9] = r2d((-cos(it)+1.)*-0.2);\n    \n    mats[10] = r2d(-cos(it)*0.3);\n    mats[11] = r2d((-sin(it)+1.)*-0.2);\n    \n    // more noise\n    it += ds.x;\n    \n    // head\n    mats[1] = r2d(-sin(headTilt)*headTiltMul);\n\n\n    // arms\n    mats[12] = r2d(sin(it)*0.25);\n    \n    mats[13] = r2d(sin(it)*0.25);\n   \n    mats[14] = r2d(cos(it)*0.25);\n    mats[15] = r2d(sin(it)*0.2);\n   \n    // some noise\n    mats[2] = r2d(ds.x);\n    mats[3] = r2d(ds.x);\n    mats[4] = r2d(ds.x);\n    \n\n    for (int i = 0; i < skellen; i+=2)\n    {\n        int mi=skel[i],mi2=skel[i+1];\n\n        mats[mi2] *= mats[mi];\n       \n        vec2 dir = verts[mi2] - verts[mi];\n\n        dir = mats[mi2] * dir;\n\n        tverts[mi2] = tverts[mi] + dir;\n\n    }\n\n    for (int i = 0; i < verlen; i++)\n        tverts[i] = tverts[i]*scale + offset;\n\n\n    float d = 0.;\n    float c = 0.;\n    float thh = 0.;\n\n    for (int i = 0; i < linelen; i += 2)\n    {\n        vec2 p0 = tverts[lines[i]];\n        vec2 p1 = tverts[lines[i+1]];\n\n\n        float dist = length(p0 - pos);\n\n        vec2 dir = p1 - p0;\n        float len = length(dir);\n\n        float nlen = length(pos - p0);\n\n        vec2 ndir = normalize(dir);\n        \n        float normalizedDist = nlen / len;\n        \n        float distToCenter = length(pos - (p0+p1)*0.5) / len;\n\n        float w0 = widths[i];\n        float w1 = widths[i+1];\n\n        float tdist = length(pos + ds - p0);\n            \n        float width = mix(w0, w1, tdist)*0.2;\n\n\n\n        for (float th = -0.8; th <= 0.8; th += 0.2)\n        {\n\n            \n\n            \n            vec2 dis = vec2(-ndir.y, ndir.x)*th*width; // *(1.0-dist);\n            \n            dis += dis.x+cos(abs(pos.x*3.)*0.21 + time + th*3.0 + ds.y)*0.1*(1.0 - distToCenter*distToCenter);\n            \n           \n            dis *= 20.*width;\n\n\n\n            float dd = udSegment(pos + ds*len*0.04 + dis, p0, p1);\n            float dd2 = dd;\n            \n            \n            dd = 0.0 - dd;\n            dd = smoothstep(-0.01, 0.03, dd); \n            dd = dd*(1.0 - dist)*2.0*th;\n            dd = abs(dd);\n            \n\n            d = d + dd * max(1.0-distToCenter*distToCenter*4., 0.); // (d2 + ddd*0.02)*min(d + dd*0.1, 0.5);\n\n            c += smoothstep(-0.25, 0.45, -dd2 + ds.x*0.1)*0.15 + th*4.0*d;\n\n             thh += sin(th*24.0+ds.x)*d;\n        }\n        \n        thh = clamp(thh, -0.7, 0.7);\n\n\n\n    }\n   \n\n    col = mix(vec3(1.0, 0.3, 0.1)*(1.0 + cos(1.2+ds.y+thh)*0.7), vec3(0.8, 0.9, 0.2),min(d*c, 1.0))*(d + c*0.1); // + sin(c*0.4+d*0.3+time)*0.3); //*(d + noise(pos*1.0+d)*c*0.2);\n    col = mix(col, vec3(0.3, 0.2, 0.9)*d, thh); //min(noise(pos+c)*2.9, 1.0) );\n   \n    col += pow(c, 0.8 + sin(it+ds.y)*0.2)*0.2;\n\n\n    \n    float staffBall = smoothstep(0.6, 1.1, 1.-length(pos - tverts[17]));\n    staffBall *= staffBall;\n    \n    float wall = noise((pos*vec2(0.25, 24.0) + vec2(time, 0)));\n    wall = smoothstep(-0.5, 2.4, wall+noise(pos + vec2(time*0.5, 0)))*3.0;\n    wall *= wall;\n    \n    vec3 bg = mix(vec3(0.7, 0.2, 0.1), vec3(0.4, 0.4, 0.55), \n        \n        wall + staffBall + \n        noise(vec2(0.1 + time, 0.4+uv.y + c)*0.2)\n        );\n   \n   bg = mix(bg, bg*bg*c, 0.5 + 1.0-c);\n   \n   col.rgb += staffBall*vec3(0.95, 0.9, 0.2);;\n    \n    col.rgb = mix(bg, col.rgb, min(0.5 + c, 1.0))*globalFade;\n    \n\n    fragColor = vec4(col,1.0);\n}             ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clfyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 218, 218, 343], [345, 345, 404, 404, 527], [529, 529, 554, 554, 1040], [1066, 1066, 1085, 1085, 1170]], "test": "untested"}
{"id": "mlXyRS", "name": "Galactic donut", "author": "jackjackdev", "description": "this donut is tripping yo", "tags": ["donut"], "likes": 2, "viewed": 111, "published": 3, "date": "1690871522", "time_retrieved": "2024-07-30T17:41:27.887534", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 3, -3);\n    vec3 lookat = vec3(0);\n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat - ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i - ro);\n        \n    float dS, dO;\n    vec3 p;\n    \n    for(int i = 0; i < 100; i++) {\n        p = ro + rd * dO;\n        //distance funct (torus)\n        dS = length(vec2(length(p.xz) - 1., p.y)) - .5;\n        if(dS < .001) break;\n        dO += dS;\n    }\n    \n    vec3 col = vec3(0);\n    \n    if(dS < .001) {\n        float x = atan(p.x, p.z);\n        float y = atan(length(p.xz) - 1., p.y);\n        col += sin(y*(iTime*10.));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlXyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 872]], "test": "untested"}
{"id": "clXcRB", "name": "8 bit masked rounded box combine", "author": "Danielhu", "description": "sdf", "tags": ["sdf"], "likes": 1, "viewed": 141, "published": 3, "date": "1690865940", "time_retrieved": "2024-07-30T17:41:28.642516", "image_code": "float box(vec3 position, vec3 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(max(position.x, position.y), position.z), 0.0) - cornerRadius;\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nfloat sdf(vec3 position) { \n    float halfEdge = 0.25;\n    float cornerRadius = 0.06;\n    float separation = halfEdge - cornerRadius; // separation equal to the edge length minus the corner radius\n    float distance = 1e0; // Large initial distance\n    int mask = 1 | 2 | 4 | 16 ; // Change this to specify which cubes to draw\n    int cubeIndex = 0;\n    for(int x=-1; x<=1; x+=2) {\n        for(int y=-1; y<=1; y+=2) {\n            for(int z=-1; z<=1; z+=2) {\n                if ((mask & (1 << cubeIndex)) != 0) { // Only draw the cube if it matches the mask\n                    vec3 center = vec3(x, y, z) * separation; // Use the new separation\n                    vec3 p = position - center;\n                    distance = min(distance, box(p, vec3(halfEdge, halfEdge, halfEdge), cornerRadius));\n                }\n                cubeIndex++;\n            }\n        }\n    }\n    return distance;\n}\n\n\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128 * 2;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.5 * (iTime - 10.0);\n\tvec3 rayOrigin = vec3(1.0 * cos(angle), 0.4, 1.0 * sin(angle));\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clXcRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 228], [230, 230, 269, 269, 451], [453, 453, 507, 507, 848], [850, 850, 876, 876, 1746], [1750, 1750, 1778, 1778, 2123], [2125, 2125, 2175, 2175, 2561], [2563, 2563, 2618, 2618, 4125]], "test": "untested"}
{"id": "DtfcRS", "name": "KIFS FRACTAL", "author": "jackjackdev", "description": "Credits to Art of Code on YT, this is the tutorial video: https://www.youtube.com/watch?v=il_Qg9AqQkE", "tags": ["fractal", "kifs"], "likes": 3, "viewed": 156, "published": 3, "date": "1690859039", "time_retrieved": "2024-07-30T17:41:29.399492", "image_code": "// KALEIDOSCOPE KIFS FRACTAL\n// Credits to Art of Code on YT, this is the tutorial video: https://www.youtube.com/watch?v=il_Qg9AqQkE\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    //vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0);\n    \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.)*3.1415)*.5;\n    \n    vec2 n = N((5./6.)*3.1415);\n    float d = dot(uv - vec2(.5, 0), n);\n    uv -= n * max(0., d)*2.;\n    \n    //col += smoothstep(.01, .0, abs(d));\n\n    n = N((2./3.) * 3.1415);\n    float scale = 1.;\n    uv.x += .5;\n    for(int i = 0; i < 5; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv -= n * min(0., dot(uv, n))*2.;\n    }\n    \n    d = length(uv - vec2(clamp(uv.x, -1., 1.), 0));\n    //col += smoothstep(1./iResolution.y, .0, d/scale);\n    uv /= scale;\n    col += texture(iChannel0, uv).bgr;\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DtfcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 156, 156, 199], [201, 201, 258, 258, 1082]], "test": "untested"}
{"id": "mdBcWc", "name": "Year of Truchets #049", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes! \n\nmore a test / playing with textures / green screen / and motion - finally getting time to play again!", "tags": ["raymarching", "animation", "truchet", "tiles"], "likes": 16, "viewed": 236, "published": 3, "date": "1690853957", "time_retrieved": "2024-07-30T17:41:30.220297", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #049\n    07/31/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n\n*/\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n\n#define HI          1.57079632679\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    55.\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n\n//@iq sdfs & extrude\nfloat box(vec3 p, vec3 b){vec3 q=abs(p)-b;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat box(vec2 p, vec2 a){vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\nfloat cap(vec3 p, float h, float r){p.y-=clamp(p.y,0.,h);return length(p)-r;}\nfloat opx(in float sdf, in float pz, in float h){vec2 w=vec2(sdf,abs(pz)-h);return min(max(w.x,w.y),0.)+length(max(w,0.));}\n\nvec3 hit,hp;\nvec2 sid,gid;\nfloat scale = .5,time = 0.,speed = 0.,gir,sir;\nconst float tc = .15;\nconst float amt = 2.;\n\nmat2 r90;\n\nvec2 map (vec3 pos) {\n    vec2 res=vec2(1e5,0.);\n    pos.xz-=T*.2;\n    \n    vec2 id= floor(pos.xz*scale), q = fract(pos.xz*scale)-.5; \n    float ck = mod(id.x+id.y,2.)*2.-1.;\n\n    float rnd = hash21(id);\n    if(rnd>.5) q.y=-q.y;\n\n    float dir = (ck>.5^^rnd<.5)? 1.:-1.;\n    gir = dir; \n    \n    float hs=fract(rnd*32.83);\n    vec3 qp= vec3(q.x,pos.y*scale,q.y);\n    vec2 p = length(q.xy-.5) < length(q.xy+.5) ? q.xy-.5 : q.yx+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-tc;\n    d= opx(d,qp.y-.1,.1);\n    \n    // arcs/angles for path & movements\n    vec2 ar = q-sign(q.x+q.y)*.5;\n    float an = atan(ar.x, ar.y);\n    float da = length(ar);\n\n    // truchet uv coords\n    float mv = amt*ck*an/HI+speed;\n    vec2 q2 = vec2(fract(mv),(da-(.5-tc))/(2.*tc)*2.)-.5;\n\n    // id for objects on truchet\n    vec2 tid = mod(vec2(floor(mv),0),amt);\n    vec3 mq = vec3(q2.x*1.75,pos.y/scale,q2.y-.5);\n    if(d<res.x) {\n        res = vec2(d/scale,1.);\n        hp = mq;\n        gid = tid;\n    }\n\n    float f = pos.y;\n    if(f<res.x) {\n        res = vec2(f,2.);\n        hp = pos;\n    }\n    \n    return res;\n}\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<180;i++){\n        vec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<100?ray.x*.25:ray.x*.75;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 F){\n    speed = T*.3;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,4);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy==vec2(0) || M.z <0. ? .0 : (M.y/R.y * .5-.25)*PI;\n    float y = M.xy==vec2(0) || M.z <0. ? .0 : (M.x/R.x * 1.-.5)*PI;\n\n    float sw = .3*sin(T*.06);\n    mat2 rx = rot(-.88-x), ry = rot(.78+sw-y);\n    \n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    \n    vec2 ray = marcher(ro,rd);\n    float d=ray.x, m=ray.y;\n    hit = hp;\n    sid = gid;\n    sir = gir;\n    \n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST)\n    {\n             p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(-6.,12.,12.);\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),.09,.99);\n        \n        float shdw = 1.;\n        for( float t=.01; t < 20.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 12.*h/t);\n            t += h*.25;\n            if( shdw<MIN_DIST ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 h = vec3(.5);\n\n        if(m==1.) {\n            float px=4./R.x;\n            vec3 f = hit*vec3(1.7,1.85,1.);\n            vec2 d = vec2(length(f.xy-vec2(0,.735))-.65,length(f.xz)-.65);\n            vec3 t = fract(f)-.5;\n            if(sir>0.) t.x=-t.x;\n            \n            vec3 clr = texture(iChannel0,hit.xy-vec2(.5,.75)).rgb;\n            \n            int face;\n            vec3 aN = abs(n);\n            ivec3 idF = ivec3(n.x<-.25? 0 : 5, n.y<-.25? 1 : 4, n.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n            vec2 hpp = hit.xz*vec2(1,sir);\n            if(face==3||face==5||face==0) {\n                hpp = hit.xy;\n            }\n           \n            vec3 clx = texture(iChannel1,hpp).rgb;\n            vec3 clb = sid.x < 1.? texture(iChannel2,(hpp*.8)-vec2(.5)).rgb:texture(iChannel3,(hpp*.8)-vec2(.5)).rgb;\n            h = mix(clx*.5,clx,(t.x*t.y*t.z>.0)?0.:1.);\n            h = mix(h,clr,smoothstep(px,-px,d.x));\n            h = mix(h,vec3(.1),smoothstep(px,-px,abs(d.x)-.025));\n            \n            h = mix(h,clb,smoothstep(px,-px,d.y));\n            h = mix(h,vec3(.1),smoothstep(px,-px,abs(d.y)-.025));\n            \n        }\n        \n        if(m==2.) {\n            vec3 clr = texture(iChannel3,hit.xz*vec2(.5,-.5)).rgb;\n            vec3 clx = texture(iChannel1,hit.xz).rgb;\n            vec2 f = fract(hit.xz*(scale*.5))-.5;\n            h=clx;\n            if(f.x*f.y>0.) h=clr;\n        }\n        \n        if(m==4.) h = hsv2rgb(vec3((sid.x*.025),1.,.5));\n        \n        C = (diff*h);\n    } \n    C = mix(C,vec3(.01),1.-exp(-.00175*d*d*d*d));\n    C = pow(max(C,0.),vec3(.4545));\n    fragColor = vec4(C,1);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    @byt3_m3chanic\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI         3.14159265359\n#define PI2        6.28318530718\nconst float scale = 10.;\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a) {return fract(sin(dot(a,vec2(27.609,57.583)))*43758.5453);}\nfloat box(vec2 p, vec2 a) {vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    mat2 r45 = rot(.7853981634);\n    vec3 C = vec3(.1);\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n\n    // upscale\n    float scale = 2.545;\n\n    // warp and turn\n    uv *= rot(-T*.075);\n    uv = vec2(log(length(uv)), atan(uv.y, uv.x))*scale;\n    uv.x -= T*.25;\n   \n    float px = fwidth(uv.x); \n    \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float hs = hash21(id.xy);\n    float ck =mod(id.x+id.y,2.)*2.-1.;\n\n    if(hs>.5)  q.xy *= rot(1.5707);\n    \n    hs = fract(hs*575.913);\n    \n    float pf = .353, wd = .085+.065*sin(uv.x*.26);\n    wd += .085+.065*sin(uv.x*.13);\n    \n    vec2 q2 = q;\n    q*=r45;\n    \n    vec2 p2 = vec2(length(q.x+pf),length(q.x-pf));\n    float pq = p2.x<p2.y? q.x+pf : q.x-pf;\n    vec2 p = q;\n\n    float d = length(pq);\n    d=abs(d)-wd;\n\n    if(hs>.85) d = min(length(q2.x),length(q2.y))-(wd*1.4);\n    float d2 = abs(max(abs(q2.x),abs(q2.y))-.5)-.01;\n\n    C = mix(C,vec3(.25),smoothstep(px,-px,d2));\n    \n    vec3 clr = hsv2rgb(vec3((uv.x*.015),1.,.5));\n\n    C = mix(C,C*.45,smoothstep(.075+px,-px,d-.015));\n    C = mix(C,clr,smoothstep(px,-px,d));\n    \n    //https://www.shadertoy.com/view/XsfGzn\n    vec3 fg = texture(iChannel0, F.xy/R.xy).rgb;\n    vec3 bg = C;\n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    C = mix(fg, bg, k);\n    \n    \n    O = vec4(C,1.);\n}\n", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    @byt3_m3chanic\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI         3.14159265359\n#define PI2        6.28318530718\nfloat scale = 6.;\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat hash21(vec2 a) {return fract(sin(dot(a,vec2(27.609,57.583)))*43758.5453);}\nfloat box(vec2 p, vec2 a) {vec2 q=abs(p)-a;return length(max(q,0.))+min(max(q.x,q.y),0.);}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(.005);\n    if(R.x>1400.) scale*=2.;\n    uv *=rot(.1*sin(T*.05));\n    uv *= scale;   \n    uv.x+=T;\n    float px = fwidth(uv.x); \n\n    vec4 uv1 = vec4(floor(uv),fract(uv)-.5);\n    vec4 uv2 = vec4(floor(uv-.5),fract(uv-.5)-.5);\n    vec2 id = uv1.xy, q = uv1.zw;\n    vec2 id2 = uv2.xy,q2 = uv2.zw;\n    \n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    float ck2 = mod(id2.x+id2.y,2.)*2.-1.;\n    float hs = hash21(id);\n    \n    float sfm = .5;\n    float wd = .065+.055*sin(uv.x*sfm);\n    wd += .065+.055*cos(uv.y*sfm);\n    \n    if(ck>.5) q *= rot(1.5707);\n    hs = fract(hs*575.913);\n    \n    vec2 sp = vec2(length(q-.5),length(q+.5));\n    vec2 p = sp.x<sp.y? q-.5 : q+.5;\n\n    float d = abs(length(p)-.5)-wd;\n    float g = length(abs(q)-.5)-(.425-wd);\n    float c = min(length(q.x)-wd,length(q.y)-wd);\n\n    if (hs>.85) d = c;\n    hs = fract(hs*415.372);\n\n    float b = length(q2)-.2;\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.01;\n    if(ck2>.5) d2=max(d2,-b);\n    \n    C = mix(C,vec3(.05),smoothstep(px,-px,d2));\n    \n    if(ck2>.5) C = mix(C,vec3(0,.2,.5),smoothstep(px,-px,abs(b)-.05));\n    C = mix(C,vec3(.45,0,0),smoothstep(px,-px,d));\n\n    //https://www.shadertoy.com/view/XsfGzn\n    vec3 fg = texture(iChannel0, F.xy/R.xy).rgb;\n    vec3 bg = C;\n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    C = mix(fg, bg, k);\n\n    O = vec4(C,1.);\n}\n", "buffer_b_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdBcWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[435, 435, 453, 453, 497], [498, 498, 519, 519, 574], [576, 597, 623, 623, 695], [696, 696, 722, 722, 785], [786, 786, 822, 822, 863], [864, 864, 913, 913, 987], [2224, 2293, 2323, 2323, 2543], [2545, 2545, 2577, 2577, 2806], [2808, 2825, 2852, 2852, 2968], [2970, 2970, 3015, 3015, 5797]], "test": "untested"}
